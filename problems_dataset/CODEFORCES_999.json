{
    "name": "999_F. Cards and Joy",
    "source": "CODEFORCES",
    "description": "There are n players sitting at the card table. Each player has a favorite number. The favorite number of the j-th player is f_j.\n\nThere are k \u22c5 n cards on the table. Each card contains a single integer: the i-th card contains number c_i. Also, you are given a sequence h_1, h_2, ..., h_k. Its meaning will be explained below.\n\nThe players have to distribute all the cards in such a way that each of them will hold exactly k cards. After all the cards are distributed, each player counts the number of cards he has that contains his favorite number. The joy level of a player equals h_t if the player holds t cards containing his favorite number. If a player gets no cards with his favorite number (i.e., t=0), his joy level is 0.\n\nPrint the maximum possible total joy levels of the players after the cards are distributed. Note that the sequence h_1, ..., h_k is the same for all the players.\n\nInput\n\nThe first line of input contains two integers n and k (1 \u2264 n \u2264 500, 1 \u2264 k \u2264 10) \u2014 the number of players and the number of cards each player will get.\n\nThe second line contains k \u22c5 n integers c_1, c_2, ..., c_{k \u22c5 n} (1 \u2264 c_i \u2264 10^5) \u2014 the numbers written on the cards.\n\nThe third line contains n integers f_1, f_2, ..., f_n (1 \u2264 f_j \u2264 10^5) \u2014 the favorite numbers of the players.\n\nThe fourth line contains k integers h_1, h_2, ..., h_k (1 \u2264 h_t \u2264 10^5), where h_t is the joy level of a player if he gets exactly t cards with his favorite number written on them. It is guaranteed that the condition h_{t - 1} < h_t holds for each t \u2208 [2..k].\n\nOutput\n\nPrint one integer \u2014 the maximum possible total joy levels of the players among all possible card distributions.\n\nExamples\n\nInput\n\n4 3\n1 3 2 8 5 5 8 2 2 8 5 2\n1 2 2 5\n2 6 7\n\n\nOutput\n\n21\n\n\nInput\n\n3 3\n9 9 9 9 9 9 9 9 9\n1 2 3\n1 2 3\n\n\nOutput\n\n0\n\nNote\n\nIn the first example, one possible optimal card distribution is the following:\n\n  * Player 1 gets cards with numbers [1, 3, 8]; \n  * Player 2 gets cards with numbers [2, 2, 8]; \n  * Player 3 gets cards with numbers [2, 2, 8]; \n  * Player 4 gets cards with numbers [5, 5, 5]. \n\n\n\nThus, the answer is 2 + 6 + 6 + 7 = 21.\n\nIn the second example, no player can get a card with his favorite number. Thus, the answer is 0.",
    "difficulty": "F",
    "tags": [
        "dp"
    ],
    "rating": 2000,
    "public_test": [
        {
            "input": "4 3\n1 3 2 8 5 5 8 2 2 8 5 2\n1 2 2 5\n2 6 7\n",
            "output": "21\n"
        },
        {
            "input": "3 3\n9 9 9 9 9 9 9 9 9\n1 2 3\n1 2 3\n",
            "output": "0\n"
        }
    ],
    "generated_test": [
        {
            "input": "1 1\n1\n1\n101000\n",
            "output": "101000\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 1299 1696 507 631 1971 775 1052 1665 1035 203 1564 1329 1592 1295 983 177 734 1442 172 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 425 746 309 387 1761 1002 625 496 1638 1855 1115 47 1813 1258 289 891 518 1247 1782 788 1449 1174 183 899 1728 366 1270 1641 327 1839 1093 223 82 1214 1866 1432 1715 25 1240 1234 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "1 1\n1\n4\n1\n",
            "output": "0\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 4 103 10 86 70 4 98 102 35 149 47 136 87 4 127 142 105 78 10 123 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 60 135 5 30 127 61 74 102 131 11 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 126 130 4 148 86 3\n94393\n",
            "output": "1321502\n"
        },
        {
            "input": "4 3\n2 3 2 8 5 5 8 2 2 8 5 2\n1 2 2 5\n2 6 7\n",
            "output": "20\n"
        },
        {
            "input": "4 3\n2 1 2 8 5 5 8 2 2 8 5 2\n1 2 2 5\n2 6 7\n",
            "output": "22\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 4 103 10 86 70 4 98 102 37 149 47 136 87 4 127 142 105 78 10 123 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 60 135 5 30 127 61 74 38 131 11 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 126 130 4 148 86 3\n94393\n",
            "output": "1227109\n"
        },
        {
            "input": "4 3\n2 1 2 8 1 5 8 2 2 3 5 2\n1 2 2 5\n2 6 7\n",
            "output": "25\n"
        },
        {
            "input": "4 3\n4 1 2 8 1 5 8 2 2 3 5 2\n1 2 2 5\n2 6 7\n",
            "output": "24\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 4 103 10 86 70 4 167 102 37 149 47 136 87 4 127 26 105 78 10 123 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 60 135 5 30 127 61 74 38 131 11 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 73 130 4 148 86 3\n94393\n",
            "output": "1415895\n"
        },
        {
            "input": "4 3\n8 1 4 8 0 5 4 2 2 3 5 2\n1 2 2 5\n2 6 7\n",
            "output": "16\n"
        },
        {
            "input": "4 3\n11 1 4 8 0 5 7 2 2 6 5 0\n1 2 2 5\n2 6 7\n",
            "output": "14\n"
        },
        {
            "input": "4 3\n11 0 4 8 0 5 7 2 2 6 5 0\n1 2 2 5\n2 6 7\n",
            "output": "12\n"
        },
        {
            "input": "50 1\n995 1815 1146 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 689 775 1191 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 2885 1506 597 746 309 517 1761 1002 309 496 1638 1855 1115 47 3359 707 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 2529 2172 327 2874 1093 223 82 1214 1866 2082 1715 25 1240 2270 324\n52314\n",
            "output": "52314\n"
        },
        {
            "input": "50 1\n995 1815 1146 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 689 775 1191 2173 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 2885 1506 597 746 309 517 1761 1002 462 496 1638 1855 1115 47 3359 707 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 2529 2172 327 2874 1093 223 82 1214 1866 2082 1715 25 1240 2270 324\n102655\n",
            "output": "102655\n"
        },
        {
            "input": "3 3\n9 9 9 9 9 9 9 9 8\n1 2 3\n1 2 3\n",
            "output": "0\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 1971 775 1052 1665 1035 203 1564 1329 1592 1295 983 177 734 1442 172 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 425 746 309 387 1761 1002 625 496 1638 1855 1115 47 1813 1258 289 891 518 1247 1782 788 1449 1174 183 899 1728 366 1270 1641 327 1839 1093 223 82 1214 1866 1432 1715 25 1240 1234 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "1 1\n1\n7\n1\n",
            "output": "0\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 4 103 10 86 70 4 98 102 37 149 47 136 87 4 127 142 105 78 10 123 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 60 135 5 30 127 61 74 102 131 11 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 126 130 4 148 86 3\n94393\n",
            "output": "1321502\n"
        },
        {
            "input": "3 3\n9 9 9 9 9 9 11 9 8\n1 2 3\n1 2 3\n",
            "output": "0\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 1971 775 1052 1665 1035 203 1564 1329 1592 1295 983 177 734 1442 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 425 746 309 387 1761 1002 625 496 1638 1855 1115 47 1813 1258 289 891 518 1247 1782 788 1449 1174 183 899 1728 366 1270 1641 327 1839 1093 223 82 1214 1866 1432 1715 25 1240 1234 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "1 1\n1\n7\n2\n",
            "output": "0\n"
        },
        {
            "input": "4 3\n2 1 2 8 5 5 8 2 2 3 5 2\n1 2 2 5\n2 6 7\n",
            "output": "22\n"
        },
        {
            "input": "3 3\n9 9 9 9 6 9 11 9 8\n1 2 3\n1 2 3\n",
            "output": "0\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 1971 775 1052 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 425 746 309 387 1761 1002 625 496 1638 1855 1115 47 1813 1258 289 891 518 1247 1782 788 1449 1174 183 899 1728 366 1270 1641 327 1839 1093 223 82 1214 1866 1432 1715 25 1240 1234 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "1 1\n1\n7\n3\n",
            "output": "0\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 4 103 10 86 70 4 98 102 37 149 47 136 87 4 127 26 105 78 10 123 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 60 135 5 30 127 61 74 38 131 11 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 126 130 4 148 86 3\n94393\n",
            "output": "1321502\n"
        },
        {
            "input": "3 3\n9 9 9 9 6 9 11 9 8\n1 2 3\n1 2 2\n",
            "output": "0\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 1971 775 1052 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 425 746 309 387 1761 1002 625 496 1638 1855 1115 47 1813 1258 289 891 518 1247 1782 788 1449 1174 183 899 1728 366 1270 1641 327 1839 1093 223 82 1214 1866 1432 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 4 103 10 86 70 4 167 102 37 149 47 136 87 4 127 26 105 78 10 123 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 60 135 5 30 127 61 74 38 131 11 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 126 130 4 148 86 3\n94393\n",
            "output": "1321502\n"
        },
        {
            "input": "3 3\n9 9 9 9 6 9 11 9 8\n1 2 3\n1 2 4\n",
            "output": "0\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 1971 775 1052 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 425 746 309 387 1761 1002 625 496 1638 1855 1115 47 1813 1258 289 891 518 1247 1782 788 1449 1174 183 899 1728 366 1270 2172 327 1839 1093 223 82 1214 1866 1432 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "4 3\n8 1 2 8 1 5 8 2 2 3 5 2\n1 2 2 5\n2 6 7\n",
            "output": "24\n"
        },
        {
            "input": "3 3\n9 9 9 9 4 9 11 9 8\n1 2 3\n1 2 4\n",
            "output": "0\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 1971 775 1052 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 597 746 309 387 1761 1002 625 496 1638 1855 1115 47 1813 1258 289 891 518 1247 1782 788 1449 1174 183 899 1728 366 1270 2172 327 1839 1093 223 82 1214 1866 1432 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 4 139 10 86 70 4 167 102 37 149 47 136 87 4 127 26 105 78 10 123 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 60 135 5 30 127 61 74 38 131 11 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 73 130 4 148 86 3\n94393\n",
            "output": "1415895\n"
        },
        {
            "input": "4 3\n8 1 2 8 0 5 8 2 2 3 5 2\n1 2 2 5\n2 6 7\n",
            "output": "20\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 1971 775 1052 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 597 746 309 387 1761 1002 625 496 1638 1855 1115 47 1813 1258 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 1270 2172 327 1839 1093 223 82 1214 1866 1432 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 4 139 10 155 70 4 167 102 37 149 47 136 87 4 127 26 105 78 10 123 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 60 135 5 30 127 61 74 38 131 11 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 73 130 4 148 86 3\n94393\n",
            "output": "1321502\n"
        },
        {
            "input": "4 3\n8 1 2 8 0 5 4 2 2 3 5 2\n1 2 2 5\n2 6 7\n",
            "output": "20\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 1971 775 1191 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 597 746 309 387 1761 1002 625 496 1638 1855 1115 47 1813 1258 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 1270 2172 327 1839 1093 223 82 1214 1866 1432 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 4 139 10 155 70 4 167 102 37 149 47 136 87 4 127 26 105 78 10 123 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 60 135 5 30 127 61 74 45 131 11 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 73 130 4 148 86 3\n94393\n",
            "output": "1321502\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 1971 775 1191 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 597 746 309 387 1761 1002 625 496 1638 1855 1115 47 1813 1258 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 1270 2172 327 2874 1093 223 82 1214 1866 1432 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 4 139 10 155 70 4 167 102 37 149 47 136 87 4 127 26 105 78 10 192 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 60 135 5 30 127 61 74 45 131 11 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 73 130 4 148 86 3\n94393\n",
            "output": "1321502\n"
        },
        {
            "input": "4 3\n8 1 4 8 0 5 7 2 2 3 5 2\n1 2 2 5\n2 6 7\n",
            "output": "16\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 689 775 1191 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 597 746 309 387 1761 1002 625 496 1638 1855 1115 47 1813 1258 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 1270 2172 327 2874 1093 223 82 1214 1866 1432 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 5 139 10 155 70 4 167 102 37 149 47 136 87 4 127 26 105 78 10 192 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 60 135 5 30 127 61 74 45 131 11 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 73 130 4 148 86 3\n94393\n",
            "output": "1321502\n"
        },
        {
            "input": "4 3\n11 1 4 8 0 5 7 2 2 3 5 2\n1 2 2 5\n2 6 7\n",
            "output": "16\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 689 775 1191 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 597 746 309 387 1761 1002 625 496 1638 1855 1115 47 1813 707 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 1270 2172 327 2874 1093 223 82 1214 1866 1432 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 5 139 10 155 70 4 167 102 37 149 47 136 87 4 127 26 105 78 10 192 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 7 135 5 30 127 61 74 45 131 11 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 73 130 4 148 86 3\n94393\n",
            "output": "1321502\n"
        },
        {
            "input": "4 3\n11 1 4 8 0 5 7 2 2 6 5 2\n1 2 2 5\n2 6 7\n",
            "output": "16\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 689 775 1191 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 597 746 309 517 1761 1002 625 496 1638 1855 1115 47 1813 707 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 1270 2172 327 2874 1093 223 82 1214 1866 1432 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 143 148 10 140 131 29 82 134 56 73 121 57 98 101 134 5 139 10 155 70 4 167 102 37 149 47 136 87 4 127 26 105 78 10 192 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 7 135 5 30 127 61 74 45 131 12 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 73 130 4 148 86 3\n94393\n",
            "output": "1321502\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 689 775 1191 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 597 746 309 517 1761 1002 309 496 1638 1855 1115 47 1813 707 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 1270 2172 327 2874 1093 223 82 1214 1866 1432 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 178 148 10 140 131 29 82 134 56 73 121 57 98 101 134 5 139 10 155 70 4 167 102 37 149 47 136 87 4 127 26 105 78 10 192 75 67 149 81 78 34 79 62 12 43 146\n31 132 59 75 4 135 138 33 33 7 135 5 30 127 61 74 45 131 12 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 73 130 4 148 86 3\n94393\n",
            "output": "1321502\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 689 775 1191 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 597 746 309 517 1761 1002 309 496 1638 1855 1115 47 1813 707 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 2529 2172 327 2874 1093 223 82 1214 1866 1432 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 178 148 10 140 131 29 82 134 56 73 121 57 98 101 134 5 139 10 155 70 4 167 102 37 149 47 136 87 4 127 26 105 78 10 192 75 67 149 81 78 34 79 62 12 72 146\n31 132 59 75 4 135 138 33 33 7 135 5 30 127 61 74 45 131 12 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 73 130 4 148 86 3\n94393\n",
            "output": "1321502\n"
        },
        {
            "input": "4 3\n11 0 4 8 0 5 7 2 2 6 5 0\n1 2 2 5\n2 6 11\n",
            "output": "12\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 689 775 1191 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 597 746 309 517 1761 1002 309 496 1638 1855 1115 47 3359 707 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 2529 2172 327 2874 1093 223 82 1214 1866 1432 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 178 148 10 140 131 29 82 134 56 73 121 57 98 101 134 5 139 10 155 70 4 167 102 37 149 47 136 87 4 127 26 105 78 10 192 75 67 149 81 78 34 79 62 12 72 146\n31 132 59 75 4 135 138 33 33 7 135 5 30 127 61 74 45 131 12 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 64 130 4 148 86 3\n94393\n",
            "output": "1227109\n"
        },
        {
            "input": "4 3\n11 0 4 8 0 5 7 2 2 6 5 0\n2 2 2 5\n2 6 11\n",
            "output": "12\n"
        },
        {
            "input": "50 1\n995 1815 941 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 689 775 1191 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 597 746 309 517 1761 1002 309 496 1638 1855 1115 47 3359 707 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 2529 2172 327 2874 1093 223 82 1214 1866 2082 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 178 148 10 140 131 29 82 134 56 73 121 57 98 101 134 5 139 10 155 70 4 167 102 36 149 47 136 87 4 127 26 105 78 10 192 75 67 149 81 78 34 79 62 12 72 146\n31 132 59 75 4 135 138 33 33 7 135 5 30 127 61 74 45 131 12 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 64 130 4 148 86 3\n94393\n",
            "output": "1227109\n"
        },
        {
            "input": "50 1\n995 1815 1146 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 689 775 1191 1665 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 1524 1506 597 746 309 517 1761 1002 309 496 1638 1855 1115 47 3359 707 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 2529 2172 327 2874 1093 223 82 1214 1866 2082 1715 25 1240 2270 324\n52314\n",
            "output": "104628\n"
        },
        {
            "input": "50 1\n52 96 99 37 178 148 10 140 131 29 82 134 56 73 121 57 98 101 134 5 139 10 155 70 4 167 102 36 149 47 136 87 4 127 26 105 78 10 192 75 67 149 81 78 34 79 62 12 72 146\n31 132 59 75 4 135 138 33 33 7 135 5 30 127 64 74 45 131 12 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 64 130 4 148 86 3\n94393\n",
            "output": "1227109\n"
        },
        {
            "input": "50 1\n52 96 99 37 178 148 10 140 131 29 82 134 56 73 121 57 98 101 134 5 139 10 155 70 4 167 102 36 149 47 136 87 4 127 26 105 78 10 192 75 67 149 81 78 34 79 62 12 72 146\n31 132 59 75 4 135 138 33 33 7 135 10 30 127 64 74 45 131 12 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 64 130 4 148 86 3\n94393\n",
            "output": "1227109\n"
        },
        {
            "input": "50 1\n995 1815 1146 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 689 775 1191 2173 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 2885 1506 597 746 309 517 1761 1002 309 496 1638 1855 1115 47 3359 707 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 2529 2172 327 2874 1093 223 82 1214 1866 2082 1715 25 1240 2270 324\n52314\n",
            "output": "52314\n"
        },
        {
            "input": "50 1\n52 96 99 37 178 148 10 140 131 29 1 134 56 73 121 57 98 101 134 5 139 10 155 70 4 167 102 36 149 47 136 87 4 127 26 105 78 10 192 75 67 149 81 78 34 79 62 12 72 146\n31 132 59 75 4 135 138 33 33 7 135 10 30 127 64 74 45 131 12 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 55 64 130 4 148 86 3\n94393\n",
            "output": "1227109\n"
        },
        {
            "input": "50 1\n995 1815 1146 1716 725 1098 747 627 1728 1007 34 1001 679 1742 22 1495 465 1696 507 631 689 775 1191 2173 1035 203 1564 1329 1592 1295 983 177 734 450 73 943 33 486 1078 946 947 592 1524 563 396 1541 1670 326 543 79\n176 214 1601 1758 1468 972 628 2885 1506 597 746 309 517 1761 1002 462 496 1638 1855 1115 47 3359 707 289 891 518 1247 1782 788 1449 1174 84 899 1728 366 2529 2172 327 2874 1093 223 82 1214 1866 2082 1715 25 1240 2270 324\n52314\n",
            "output": "52314\n"
        },
        {
            "input": "50 1\n52 96 99 37 178 148 10 140 131 29 1 134 56 73 121 57 98 101 134 5 139 10 155 70 4 167 102 36 149 47 136 87 4 127 26 105 78 10 192 75 67 149 81 78 34 79 62 12 72 146\n31 132 59 75 4 135 138 33 33 7 135 10 30 127 64 74 45 131 12 16 74 4 101 74 70 45 29 12 137 59 24 52 25 122 64 147 92 77 23 6 19 76 26 33 64 130 4 148 86 3\n94393\n",
            "output": "1227109\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint joy[15];\nint dp[505][5005];\nint solve(int play, int cards) {\n  for (int i = 0; i <= play; i++)\n    for (int j = 0; j <= cards; j++) dp[i][j] = 0;\n  for (int i = 1; i <= play; i++)\n    for (int j = 1; j <= cards; j++)\n      for (int l = 1; l <= min(k, j); l++)\n        dp[i][j] = max(dp[i][j], dp[i - 1][j - l] + joy[l]);\n  return dp[play][cards];\n}\nint main() {\n  int x;\n  cin >> n >> k;\n  unordered_map<int, int> c, f;\n  for (int i = 0; i < n * k; i++) {\n    cin >> x;\n    c[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> x;\n    f[x]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> joy[i];\n  joy[0] = 0;\n  int ans = 0;\n  for (auto it = f.begin(); it != f.end(); it++) {\n    ans += solve(it->second, min(k * (it->second), c[it->first]));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def solve():\n    n, k = map(int, input().split())\n    c = list(map(int, input().split()))\n    f = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    cnt = {}\n    for i in c:\n        cnt[i] = cnt.get(i, 0) + 1\n    likecolor = {}\n    for i in range(n):\n        likecolor.setdefault(f[i], []).append(i)\n        cnt[f[i]] = cnt.get(f[i], 0)\n    ans = 0\n    for key, v in likecolor.items():\n        n1 = len(v)\n        if cnt[key] >= n1 * k:\n            ans += n1 * h[k - 1]\n            continue\n        dp = [[-float(\"INF\")] * (cnt[key]+1) for _ in range(n1 + 1)]\n        dp[0][0] = 0\n        for i in range(n1):\n            j = i + 1\n            for e in range(cnt[key] + 1):\n                dp[j][e] = max(dp[j][e], dp[i][e])\n                for w in range(e + 1, min(cnt[key] + 1, e + k + 1)):\n                    dp[j][w] = max(dp[i][e] + h[w - e - 1], dp[j][w])\n        ans += dp[n1][cnt[key]]\n    print(ans)\n\n\nsolve()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int gcd(long long int a, long long int b) {\n  if (b != 0)\n    return gcd(b, a % b);\n  else\n    return a;\n}\nlong long int power(long long int a, long long int b) {\n  if (b == 0) return 1;\n  if (b == 1) return a;\n  if (b % 2 == 0) {\n    long long int t = power(a, b / 2);\n    return t * t;\n  } else {\n    long long int t = power(a, b / 2);\n    return a * t * t;\n  }\n}\nlong long int powin(long long int a, long long int b) {\n  if (b == 0)\n    return 1;\n  else if (b == 1)\n    return a;\n  else if (b % 2 == 0) {\n    long long int t = powin(a, b / 2);\n    return (t * t) % 1000000007;\n  } else {\n    long long int t = powin(a, b / 2);\n    return (((t * t) % 1000000007) * a) % 1000000007;\n  }\n}\nlong long int n, k;\nlong long int dp[509][10 * 509];\nlong long int h[20];\nvoid solve() {\n  for (long long int i = 1; i < n + 1; i++) {\n    for (long long int j = 1; j < k * n + 1; j++) {\n      for (long long int p = 1; p < k + 1; p++) {\n        if (j >= p) dp[i][j] = max(dp[i][j], dp[i - 1][j - p] + h[p]);\n      }\n    }\n  }\n}\nlong long int fr[100000 + 10];\nlong long int f[100000 + 10];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k;\n  memset(dp, 0, sizeof dp);\n  memset(fr, 0, sizeof fr);\n  memset(f, 0, sizeof f);\n  for (long long int i = 0; i < n * k; i++) {\n    long long int t;\n    cin >> t;\n    fr[t]++;\n  }\n  for (long long int i = 0; i < n; i++) {\n    int p;\n    cin >> p;\n    f[p]++;\n  }\n  h[0] = 0;\n  for (long long int i = 1; i < k + 1; i++) {\n    cin >> h[i];\n    dp[1][i] = h[i];\n  }\n  solve();\n  long long int ans = 0;\n  for (long long int i = 1; i < 100000 + 1; i++) {\n    ans += dp[f[i]][fr[i]];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ara[100003], tra[100003], val[15];\nint dp[2][5003];\nint main() {\n  int n, k, sz = 0, a, b, c, d, lt, ans = 0, fr, sc, x, y, z, i, j;\n  vector<int> v;\n  scanf(\"%d %d\", &n, &k);\n  lt = n * k;\n  for (i = 1; i <= lt; i++) {\n    scanf(\"%d\", &a);\n    ara[a]++;\n  }\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &a);\n    tra[a]++;\n    if (tra[a] == 1) {\n      v.push_back(a);\n      sz++;\n    }\n  }\n  for (i = 1; i <= k; i++) {\n    scanf(\"%d\", &a);\n    val[i] = a;\n  }\n  int idx, cap;\n  for (i = 0; i < sz; i++) {\n    a = v[i];\n    b = tra[a];\n    c = min(b * k, ara[a]);\n    if (c != 0) {\n      for (idx = b; idx >= 1; idx--) {\n        fr = idx % 2;\n        sc = (idx + 1) % 2;\n        for (cap = 0; cap <= c; cap++) {\n          if (idx == b) {\n            int p = 0;\n            for (int lp = 0; lp <= k; lp++) {\n              if (cap - lp < 0) break;\n              p = max(p, val[lp]);\n            }\n            dp[fr][cap] = p;\n          } else {\n            int p = 0;\n            for (int lp = 0; lp <= k; lp++) {\n              if (cap - lp < 0)\n                break;\n              else {\n                p = max(p, val[lp] + dp[sc][cap - lp]);\n              }\n            }\n            dp[fr][cap] = p;\n          }\n        }\n      }\n      ans = ans + dp[1][c];\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint cnt[121212], fcnt[121212], R[121212];\nint D[501][5001];\nint max(int a, int b) {\n  if (a < b) return b;\n  return a;\n}\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  int i, j;\n  for (i = 0; i < n * k; i++) {\n    int c;\n    scanf(\"%d\", &c);\n    cnt[c]++;\n  }\n  for (i = 0; i < n; i++) {\n    int f;\n    scanf(\"%d\", &f);\n    fcnt[f]++;\n  }\n  for (i = 1; i <= k; i++) scanf(\"%d\", &R[i]);\n  for (i = 1; i <= n; i++) {\n    for (j = 0; j <= i * k; j++) {\n      for (int p = 0; p <= k && j - p >= 0; p++) {\n        D[i][j] = max(D[i][j], D[i - 1][j - p] + R[p]);\n      }\n    }\n  }\n  long long ans = 0;\n  for (i = 1; i <= 100000; i++)\n    if (cnt[i] && fcnt[i]) {\n      int x = cnt[i], y = fcnt[i];\n      if (x > y * k) x = y * k;\n      ans += D[y][x];\n    }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nlong double PI = 4 * atan(1);\nint n, k, h[100001], first[100001], c[100001], t;\nset<int> second;\nlong long ans, dp[501][5001];\nlong long calc(int u, int v) {\n  if (!u) return 0;\n  long long res = dp[u][v];\n  if (res != -1) return res;\n  res = 0;\n  for (int i = 0; i < min(v, k) + 1; i++) {\n    res = max(res, (long long)calc(u - 1, v - i) + h[i]);\n  }\n  return dp[u][v] = res;\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) cin >> t, c[t]++;\n  for (int i = 0; i < n; i++) cin >> t, first[t]++, second.insert(t);\n  for (int i = 1; i < k + 1; i++) cin >> h[i];\n  memset(dp, -1, sizeof(dp));\n  for (int a : second) {\n    ans += calc(first[a], c[a]);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nconst int N = 100003;\nconst long long mod = 1e9 + 7;\nint freq[N], f[503], h[13], dp[5003];\nunordered_map<int, int> cnt;\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, k;\n  cin >> n >> k;\n  int i, j, l, c, x, y;\n  for (i = 1; i <= k * n; ++i) cin >> c, freq[c]++;\n  for (i = 1; i <= n; ++i) cin >> f[i], cnt[f[i]]++;\n  for (i = 1; i <= k; ++i) cin >> h[i];\n  int ans = 0;\n  for (auto it : cnt) {\n    tie(i, j) = it;\n    int lt = min(freq[i], j * k);\n    fill(dp, dp + lt + 1, 0);\n    for (l = 1; l <= j; ++l)\n      for (x = lt; x >= 0; --x)\n        for (y = 0; y <= min(k, lt - x); ++y)\n          dp[x + y] = max(dp[x + y], dp[x] + h[y]);\n    ans += dp[lt];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e3 + 10;\nint h[510];\nint dp[N][510][15];\nint Cal(int totalCards, int totalPlayers, int atMostCards) {\n  for (int i = 0; i <= totalCards; ++i) {\n    for (int j = 0; j <= totalPlayers; ++j) {\n      for (int k = 0; k <= atMostCards; ++k) {\n        dp[i][j][k] = -1e9;\n      }\n    }\n  }\n  for (int i = 0; i <= totalCards; ++i) dp[i][0][i] = 0;\n  int ans = -1e9;\n  for (int num = 0; num <= totalCards; ++num) {\n    for (int i = 0; i < totalPlayers; ++i) {\n      for (int j = 0; j <= atMostCards; ++j) {\n        for (int k = 0; k <= atMostCards && num + k <= totalCards; ++k) {\n          dp[num + k][i + 1][k] =\n              max(dp[num + k][i + 1][k], dp[num][i][j] + h[k]);\n          ans = max(ans, dp[num + k][i + 1][k]);\n        }\n      }\n    }\n  }\n  return ans;\n}\nmap<int, int> mp, fav;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < n * k; ++i) {\n    int x;\n    cin >> x;\n    ++mp[x];\n  }\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    fav[x]++;\n  }\n  for (int i = 1; i <= k; ++i) cin >> h[i];\n  int ans = 0;\n  for (auto i : fav) {\n    ans += Cal(mp[i.first], i.second, k);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\n\tprivate static final String NO = \"NO\";\n\tprivate static final String YES = \"YES\";\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tprivate static long MOD = 1000000009;\n\n\tvoid solve() {\n\t\tint N = ni();\n\t\tint K = ni();\n\n\t\tint cnt1[] = new int[100001];\n\t\tfor (int i = 0; i < N * K; i++)\n\t\t\tcnt1[ni()]++;\n\n\t\tint cnt2[] = new int[100001];\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcnt2[ni()]++;\n\n\t\tint[] h = na(K);\n//\t\ttr(cnt2, h);\n\n\t\tlong[][] dp = new long[N + 1][N * K + 1];\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j <= N * K; j++)\n\t\t\t\tfor (int k = 1; j + k <= N * K && k <= K; k++)\n\t\t\t\t\tdp[i][j + k] = Math.max(dp[i][j + k], dp[i - 1][j] + h[k - 1]);\n//\t\t\ttr(dp[i]);\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 1; i < cnt2.length; i++) {\n\t\t\tif (cnt2[i] > 0) {\n\t\t\t\tans += dp[cnt2[i]][cnt1[i]];\n//\t\t\t\ttr(i, cnt2[i], cnt1[i], dp[cnt2[i]][cnt1[i]], ans);\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tlong power(long a, long b) {\n\t\tlong x = 1, y = a;\n\t\twhile (b > 0) {\n\t\t\tif (b % 2 != 0) {\n\t\t\t\tx = (x * y) % MOD;\n\t\t\t}\n\t\t\ty = (y * y) % MOD;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn x % MOD;\n\t}\n\n\tprivate long gcd(long a, long b) {\n\t\twhile (a != 0) {\n\t\t\tlong tmp = b % a;\n\t\t\tb = a;\n\t\t\ta = tmp;\n\t\t}\n\t\treturn b;\n\t}\n\n\tvoid run() throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!INPUT.isEmpty())\n\t\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n) {\n\t\t\tif (!(isSpaceChar(b)))\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate Integer[] na2(int n) {\n\t\tInteger[] a = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int[][] na(int n, int m) {\n\t\tint[][] a = new int[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = na(m);\n\t\treturn a;\n\t}\n\n\tprivate Integer[][] na2(int n, int m) {\n\t\tInteger[][] a = new Integer[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = na2(m);\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long[] nl(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint dx8[] = {0, 0, 1, 1, 1, -1, -1, -1};\nint dy8[] = {1, -1, -1, 0, 1, -1, 0, 1};\nlong long frq[100005], f[100005], h[100005], dp[510][5100], p;\nlong long dpcall(long long n, long long m) {\n  if (m == 0 || n == 0) return 0;\n  if (dp[n][m] != -1) return dp[n][m];\n  dp[n][m] = 0;\n  for (int i = 0; i < (m + 1); i++) {\n    if (i > p) break;\n    dp[n][m] = max(dp[n][m], h[i] + dpcall(n - 1, m - i));\n  }\n  return dp[n][m];\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, k, a;\n  cin >> n >> k;\n  p = k;\n  for (int i = 0; i < (n * k); i++) {\n    cin >> a;\n    frq[a]++;\n  }\n  for (int i = 0; i < (n); i++) {\n    cin >> a;\n    f[a]++;\n  }\n  for (int i = 0; i < (k); i++) {\n    cin >> h[i + 1];\n  }\n  long long ans = 0;\n  for (int i = 0; i < (100001); i++) {\n    if (f[i]) {\n      memset((dp), -1, sizeof(dp));\n      ans += dpcall(f[i], frq[i]);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint n, k, c[N], f[N], h[N];\nint dp[505][5505];\nint main() {\n  cin >> n >> k;\n  int num;\n  for (int i = 1; i <= n * k; ++i) {\n    cin >> num;\n    ++c[num];\n  }\n  for (int i = 1; i <= n; ++i) {\n    cin >> num;\n    ++f[num];\n  }\n  for (int i = 1; i <= k; ++i) {\n    cin >> h[i];\n  }\n  for (int x = 0; x < n; ++x) {\n    for (int y = 0; y <= n * k; ++y) {\n      for (int i = 0; i <= k; ++i) {\n        dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]);\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= 100000; ++i) {\n    ans += dp[f[i]][c[i]];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, ans;\nint c[100010], f[100010], h[20], k;\nint dp[510][5010];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cin >> n >> k;\n  for (int i = 0; i < k * n; ++i) {\n    int x;\n    cin >> x;\n    ++c[x];\n  }\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    f[x]++;\n  }\n  for (int i = 0; i < k; ++i) {\n    cin >> h[i + 1];\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0; j < k * n; ++j) {\n      for (int e = 0; e <= k; ++e) {\n        dp[i][j + e] = max(dp[i][j + e], dp[i - 1][j] + h[e]);\n      }\n    }\n  }\n  for (int i = 0; i < 100010; ++i) {\n    ans += dp[f[i]][c[i]];\n  }\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        int[] a;\n        int[] f;\n        int[] h;\n        int n;\n        int k;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt();\n            k = in.nextInt();\n            a = new int[n * k];\n            f = new int[n];\n            h = new int[k];\n            Map<Integer, Info> infoMap = new HashMap<>();\n            for (int i = 0; i < n * k; ++i) {\n                a[i] = in.nextInt();\n            }\n            for (int i = 0; i < n; ++i) {\n                f[i] = in.nextInt();\n                if (!infoMap.containsKey(f[i])) {\n                    infoMap.put(f[i], new Info(0, 0));\n                }\n                infoMap.get(f[i]).players++;\n            }\n            for (int i = 0; i < k; ++i) {\n                h[i] = in.nextInt();\n            }\n            for (int i = 0; i < k * n; ++i) {\n                if (infoMap.containsKey(a[i])) {\n                    infoMap.get(a[i]).cnt++;\n                }\n            }\n            int res = 0;\n            for (Map.Entry<Integer, Info> entry : infoMap.entrySet()) {\n                Info cur = entry.getValue();\n                int[][] mem = new int[cur.players + 1][cur.cnt + 1];\n                for (int i = 0; i < mem.length; ++i) {\n                    Arrays.fill(mem[i], -1);\n                }\n                res += solve(0, cur.cnt, cur.players, mem);\n            }\n            out.println(res);\n        }\n\n        private int solve(int idx, int rem, int n, int[][] mem) {\n            if (rem <= 0) return 0;\n            if (idx >= n) return 0;\n            if (mem[idx][rem] != -1) return mem[idx][rem];\n            int res = solve(idx + 1, rem, n, mem);\n            for (int i = 0; i < Math.min(rem, k); ++i) {\n                res = Math.max(res, h[i] + solve(idx + 1, rem - i - 1, n, mem));\n            }\n            mem[idx][rem] = res;\n            return res;\n        }\n\n        class Info {\n            int players;\n            int cnt;\n\n            public Info(int players, int cnt) {\n                this.players = players;\n                this.cnt = cnt;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing ulint = unsigned long long;\nconst int N = 500 + 1;\nconst int K = 10 + 1;\nint h[K];\nint dp[N * K];\nint n, k;\nint solve(int p, int c) {\n  if (p == 0 || c == 0) {\n    return 0;\n  }\n  fill(begin(dp), end(dp), 0);\n  while (p--) {\n    for (int i = 0; i <= c; i++) {\n      for (int j = 0; j <= k; j++) {\n        if (i >= j) {\n          dp[i - j] = max(dp[i - j], dp[i] + h[j]);\n        }\n      }\n    }\n  }\n  return *max_element(begin(dp), end(dp));\n}\nint main(void) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cin >> n >> k;\n  map<int, int> fav, cnt;\n  for (int i = 0; i < n * k; i++) {\n    int c;\n    cin >> c;\n    cnt[c]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int f;\n    cin >> f;\n    fav[f]++;\n  }\n  for (int i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  int ans = 0;\n  for (auto e : fav) {\n    ans += solve(e.second, cnt[e.first]);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class CardsJoy {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer tokenizer;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\tint ans = 0;\n\t\tHashMap<Integer,Integer> arr = new HashMap<Integer, Integer>();\n\t\tint[] fav = new int[n];\n\t\tint[] amt = new int[k];\n\t\tfor(int i = 0; i < n * k; i++) {\n\t\t\tint t = nextInt();\n\t\t\tif(!arr.containsKey(t))\n\t\t\t\tarr.put(t, 0);\n\t\t\tarr.replace(t, arr.get(t) + 1);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfav[i] = nextInt();\n\t\tfor(int i = 0; i < k; i++)\n\t\t\tamt[i] = nextInt();\n\t\tArrays.sort(fav);\n\t\t{\n\t\t\tint l = 0;\n\t\t\twhile(l < n) {\n\t\t\t\tint r = l + 1;\n\t\t\t\twhile(r < n && fav[r] == fav[l]) r++;\n\t\t\t\tif(arr.containsKey(fav[l]))\n\t\t\t\t\tans += solve(amt, r - l, arr.get(fav[l]), k);\n\t\t\t\tl = r;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tstatic int solve(int[] amt, int num, int tot, int k) {\n\t\tif(tot >= num * k) return amt[k - 1] * num;\n\t\tint[][][] dp = new int[num + 1][tot + 1][k + 1];\n\t\tfor(int[][] a: dp)\n\t\t\tfor(int[] e: a)\n\t\t\t\tArrays.fill(e, -1);\n\t\tdp[0][0][0] = 0;\n\t\tfor(int i = 0; i < num; i++) {\n\t\t\tfor(int j = 0; j <= tot; j++) {\n\t\t\t\tfor(int l = 0; l <= k; l++) {\n\t\t\t\t\tif(dp[i][j][l] < 0) continue;\n\t\t\t\t\tdp[i + 1][j][0] = Math.max(dp[i + 1][j][0], dp[i][j][l]);\n\t\t\t\t\tif(l != k && j != tot) dp[i][j + 1][l + 1] = Math.max(dp[i][j + 1][l + 1], dp[i][j][l] + amt[l] - (l != 0 ? amt[l - 1]:0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i = 0; i < num; i++)\n\t\t\tfor(int l = 0; l <= k; l++)\n\t\t\t\tmax = Math.max(max, dp[i][tot][l]);\n//\t\tSystem.out.println(max);\n\t\treturn max;\n\t}\n\n\tpublic static String next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tthrow new IOException();\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, k;\n  cin >> n >> k;\n  vector<int> v;\n  v.resize(k * n);\n  for (int i = 0; i < n * k; i++) {\n    cin >> v[i];\n  }\n  sort(v.begin(), v.end());\n  vector<int> vn;\n  vn.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> vn[i];\n  }\n  sort(vn.begin(), vn.end());\n  vector<int> vk;\n  vk.resize(k + 1);\n  for (int i = 1; i <= k; i++) {\n    cin >> vk[i];\n  }\n  vk[0] = 0;\n  int a[100001], b[100001];\n  for (int i = 0; i < 100001; i++) {\n    a[i] = 0;\n    b[i] = 0;\n  }\n  for (int i = 0; i < n * k; i++) {\n    a[v[i]]++;\n  }\n  for (int i = 0; i < n; i++) {\n    b[vn[i]]++;\n  }\n  int dp[n + 1][n * k + 1];\n  for (int i = 1; i <= n * k; i++) {\n    if (i > k) {\n      dp[1][i] = vk[k];\n    } else {\n      dp[1][i] = vk[i];\n    }\n  }\n  for (int i = 2; i <= n; i++) {\n    for (int j = 1; j <= n * k; j++) {\n      int u = 0;\n      for (int h = 0; h <= k; h++) {\n        if (j - h > 0 && u < dp[i - 1][j - h] + vk[h]) {\n          u = dp[i - 1][j - h] + vk[h];\n        }\n      }\n      dp[i][j] = u;\n    }\n  }\n  long long c = 0;\n  for (int i = 1; i < 100001; i++) {\n    if (b[i] > 0 && a[i] > 0) {\n      if (a[i] >= b[i] * k) {\n        c += vk[k] * b[i];\n      } else {\n        c += dp[b[i]][a[i]];\n      }\n    }\n  }\n  cout << c << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kessido\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FCardsAndJoy solver = new FCardsAndJoy();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FCardsAndJoy {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.NextInt();\n            int k = in.NextInt();\n            int[] c = in.NextIntArray(n * k);\n            int[] f = in.NextIntArray(n);\n            int[] h = new int[k+1];\n            for(int i = 0; i<k; i++) h[i+1]=in.NextInt();\n            Arrays.sort(c);\n            Arrays.sort(f);\n            int i = 0, j = 0;\n            long res = 0;\n            long[][] dp = new long[n + 1][n * k + 1];\n            for (int l = 0; l < n; l++) {\n                for (int m = 0; m <= n * k; m++) {\n                    dp[l + 1][m] = Math.max(dp[l + 1][m], dp[l][m]);\n                    for (int o = 1; o <= k; o++) {\n                        if (o + m <= n * k) {\n                            dp[l + 1][m + o] = Math.max(dp[l + 1][m + o], dp[l][m] + h[o]);\n                        }\n                    }\n                }\n            }\n            while (i < n && j < n * k) {\n                if (f[i] < c[j]) {\n                    i++;\n                } else if (f[i] > c[j]) {\n                    j++;\n                } else {\n                    int countI = 0;\n                    int countJ = 0;\n                    while (i < n && f[i - countI] == f[i]) {\n                        countI++;\n                        i++;\n                    }\n                    while (j < k * n && c[j - countJ] == c[j]) {\n                        countJ++;\n                        j++;\n                    }\n                    res += dp[countI][countJ];\n                }\n            }\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] NextIntArray(int n) {\n            return NextIntArray(n, 0);\n        }\n\n        public int[] NextIntArray(int n, int offset) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = NextInt() + offset;\n            }\n            return a;\n        }\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nint c[maxn], f[maxn], h[maxn], dp[515][maxn];\nint main() {\n  int n, k, z, tmp;\n  scanf(\"%d%d\", &n, &k);\n  z = n * k;\n  for (int i = 1; i <= z; i++) scanf(\"%d\", &tmp), c[tmp]++;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &tmp), f[tmp]++;\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &h[i]);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= z; j++) {\n      for (int l = 0; l <= k; l++) {\n        dp[i][j + l] = max(dp[i][j + l], dp[i - 1][j] + h[l]);\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < maxn; i++)\n    if (f[i]) res += dp[f[i]][c[i]];\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "// package CF;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class B{\n\t\n\tstatic int [] f, c, h, memo[];\n\tstatic int k;\n\tstatic int dp(int p, int c){\n\t\tif(p == 0 || c == 0)\n\t\t\treturn 0;\n\t\tif(memo[p][c] != -1)\n\t\t\treturn memo[p][c];\n\t\tint ans = dp(p-1, c);\n\t\tfor (int i = 1, sz = Math.min(c, k); i <= sz; i++) {\n\t\t\tans = Math.max(ans, h[i-1] + dp(p-1, c-i));\n\t\t}\n\t\treturn memo[p][c] = ans;\n\t}\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt(); k = sc.nextInt();\n\t\tc = new int[(int)1e6];\n\t\tfor (int i = 0; i < n*k; i++) {\n\t\t\tc[sc.nextInt()]++;\n\t\t}\n\t\tf = new int[(int)1e6];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[sc.nextInt()]++;\n\t\t}\n\t\th = new int[k];\n\t\tfor (int i = 0; i < h.length; i++) {\n\t\t\th[i] = sc.nextInt();\n\t\t}\n\t\tmemo = new int[600][6000];\n\t\tfor(int [] i: memo)\n\t\t\tArrays.fill(i, -1);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < f.length; i++) {\n\t\t\tans += dp(f[i], c[i]);\n\t\t}\n\t\tout.println(ans);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s)\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader fileReader)\n\t\t{\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\n\t\tpublic String next() throws IOException\n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException\n\t\t{\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException\n\t\t{\n\t\t\treturn br.ready();\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*; \t\nimport java.util.*;\n\npublic class C\n{\t\n\t\tstatic long [][]memo;\n\t\tstatic int []h;\n\t\tstatic int K;\n\t\tpublic static long dp(int n,int k)\n\t\t{\n\t\t\tif(k==0 || n==0)\n\t\t\t\treturn 0;\n\t\t\tif(memo[n][k]!=-1)\n\t\t\t\treturn memo[n][k];\n\t\t\tlong ans=0;\n\t\t\tfor(int i=0;i<=Math.min(n, K);i++)\n\t\t\t\tans=Math.max(ans, h[i]+dp(n-i,k-1));\n\t\t\t//System.out.println(n+\" \"+k+\" \"+ans);\n\t\t\treturn memo[n][k]=ans;\n\t\t}\n\t\t\n\t\tpublic static void main(String[] args) throws IOException \n\t\t{\n\t\t\t\tScanner sc=new Scanner(System.in);\n\t\t\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\t\t\tint n=sc.nextInt();K=sc.nextInt();\n\t\t\t\tint []cnt=new int [100000];\n\t\t\t\tfor(int i=0;i<n*K;i++)\n\t\t\t\t\tcnt[sc.nextInt()-1]++;\n\t\t\t\t\n\t\t\t\tint []fav=new int [100000];\n\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t\tfav[sc.nextInt()-1]++;\n\t\t\t\t\n\t\t\t\th=new int [K+1];\n\t\t\t\tfor(int i=1;i<=K;i++)\n\t\t\t\t\th[i]=sc.nextInt();\n\t\t\t\tmemo=new long [n*K+1][n+1];\n\t\t\t\tfor(long []a:memo)\n\t\t\t\t\tArrays.fill(a, -1);\n\t\t\t\t\n\t\t\t\tlong ans=0;\n\t\t\t\tfor(int i=0;i<fav.length;i++)\n\t\t\t\t{\n\t\t\t\t\tans+=dp(cnt[i], fav[i]);\n\t\t\t\t}\n\t\t\t\tpw.println(ans);\n\t\t\t\t\n\t\t\t\tpw.close();\n\t\t\n\t\t\t\n\t\t\n\t\t\n\t\t}\n\t\t\n\t\tstatic class Scanner\n\t\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic Scanner(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t}\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n\t\t\n\t\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[5001][501];\nint main() {\n  for (int j = 0; j <= 500; j++) {\n    dp[0][j] = 0;\n  }\n  int n, k;\n  cin >> n >> k;\n  int card_count[100005] = {0};\n  for (int i = 0; i < n * k; i++) {\n    int z;\n    cin >> z;\n    card_count[z]++;\n  }\n  int favorite_count[100005] = {0};\n  for (int i = 1; i <= n; i++) {\n    int z;\n    cin >> z;\n    favorite_count[z]++;\n  }\n  int h[k + 1];\n  for (int i = 1; i <= k; i++) {\n    int x;\n    cin >> x;\n    h[i] = x;\n  }\n  h[0] = 0;\n  for (int i = 1; i <= k; i++) {\n    dp[i][1] = h[i];\n  }\n  for (int i = k + 1; i <= n * k; i++) {\n    dp[i][1] = h[k];\n  }\n  for (int i = 1; i <= 500; i++) {\n    dp[1][i] = h[1];\n  }\n  for (int i = 2; i <= n * k; i++) {\n    for (int j = 2; j <= n; j++) {\n      for (int l = 0; l <= min(k, i); l++) {\n        dp[i][j] = max(dp[i - l][j - 1] + h[l], dp[i][j]);\n      }\n    }\n  }\n  int happiness = 0;\n  for (int i = 1; i <= 100000; i++) {\n    happiness += dp[card_count[i]][favorite_count[i]];\n  }\n  cout << happiness;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\npublic class Main\n{  \n    static MyScanner scan;\n    static PrintWriter pw;\n    public static void main(String[] args) {\n        new Thread(null,null,\"_\",1<<25)\n        {\n           public void run()\n           {\n               try\n               {\n                   solve();\n               }\n               catch(Exception e)\n               {  \n                   e.printStackTrace();\n                   System.exit(1);\n               }\n           }\n        }.start();\n    }\n    static void solve() throws IOException\n    {\n        scan = new MyScanner();\n        pw = new PrintWriter(System.out,true);\n        StringBuilder sb = new StringBuilder();\n        int n = ni();\n        int k = ni();\n        int freq[] = new int[100001];\n        int N = n*k;\n        for(int i=0;i<N;++i)\n            ++freq[ni()];\n        Map<Integer,Integer> map = new HashMap();\n        for(int i=0;i<n;++i)\n            add(map,ni());\n        int bc[] = new int[k+1];\n        for(int i=1;i<=k;++i)\n            bc[i] = ni();\n        long ans = 0;\n        for(int e:map.keySet())\n        {\n            int np = map.get(e);\n            if(freq[e]>=np*k)\n                ans+=bc[k]*np;\n            else if(freq[e]>0)\n            {\n                int dp[][] = new int[freq[e]+1][np+1];\n                for(int i=1;i<=np;i++)\n                {\n                    for(int j=1;j<=freq[e];++j)\n                    {\n                        dp[j][i] = dp[j][i-1];\n                        for(int give=1;give<=min(k,j);++give)\n                            dp[j][i] = max(dp[j][i],dp[j-give][i-1]+bc[give]);\n                    }\n                }\n                ans+=dp[freq[e]][np];\n            }\n        }\n        pl(ans);\n        pw.flush();\n        pw.close();\n    }\n    static void add(Map<Integer,Integer> map,int key)\n    {\n        Integer val = map.get(key);\n        if(val==null)\n            map.put(key,1);\n        else map.put(key,val+1);\n    }\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static String ne() throws IOException\n    {\n        return scan.next();\n    }\n    static String nel() throws IOException\n    {\n        return scan.nextLine();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static class MyScanner\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        MyScanner()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String nextLine()throws IOException\n        {\n            return br.readLine();\n        }\n        String next() throws IOException\n        {\n            if(st==null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        int nextInt() throws IOException\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong() throws IOException\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble() throws IOException\n        {\n            return Double.parseDouble(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nunordered_map<int, int> cf, ff;\nint h[N];\nint dp[505][5005];\nint pers;\nint k;\nint rec(int pos, int rem) {\n  if (pos == pers) {\n    return 0;\n  }\n  if (dp[pos][rem] != -1) return dp[pos][rem];\n  int ans = 0;\n  for (int i = 1; i <= k; i++) {\n    if (rem - i >= 0) {\n      ans = max(ans, rec(pos + 1, rem - i) + h[i]);\n    }\n  }\n  dp[pos][rem] = ans;\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    int c;\n    cin >> c;\n    cf[c]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int num;\n    cin >> num;\n    ff[num]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  int ans = 0;\n  for (auto i : cf) {\n    if (ff.find(i.first) != ff.end()) {\n      for (int ii = 0; ii <= ff[i.first]; ii++)\n        for (int jj = 0; jj <= i.second; jj++) dp[ii][jj] = -1;\n      pers = ff[i.first];\n      ans += rec(0, i.second);\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100010;\nint c[5005], f[505], h[15];\nint C[MAXN], F[MAXN];\nint dp[5005][505];\nint main() {\n  int n, k, i, j, p;\n  scanf(\"%d%d\", &n, &k);\n  for (i = 0; i < n * k; ++i) scanf(\"%d\", &c[i]), C[c[i]]++;\n  for (i = 0; i < n; ++i) scanf(\"%d\", &f[i]), F[f[i]]++;\n  for (i = 1; i <= k; ++i) scanf(\"%d\", &h[i]);\n  for (i = 1; i <= n * k; ++i) dp[i][1] = h[min(i, k)];\n  for (i = 1; i <= n * k; ++i) {\n    for (j = 2; j <= n; ++j) {\n      for (p = 1; p <= min(i, k); ++p) {\n        dp[i][j] = max(dp[i][j], dp[i - p][j - 1] + h[p]);\n      }\n    }\n  }\n  long long ans = 0;\n  for (i = 0; i < MAXN; ++i) {\n    if (F[i]) ans += dp[C[i]][F[i]];\n  }\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 500, K = 10, VAL = 1e5;\nlong long dp[N + 10][N * K + 10];\nint h[K + 10], f[N + 10];\nint card[VAL + 10], cnt[VAL + 10];\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n * k; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    card[x]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &f[i]);\n    cnt[f[i]]++;\n  }\n  sort(f + 1, f + n + 1);\n  n = unique(f + 1, f + n + 1) - f - 1;\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &h[i]);\n  long long ans = 0;\n  for (int col = 1; col <= n; col++) {\n    int nn = cnt[f[col]], mm = card[f[col]];\n    memset(dp, 0, sizeof(dp));\n    for (int i = 1; i <= nn; i++)\n      for (int j = 1; j <= mm; j++)\n        for (int l = 0; l <= min(j, k); l++)\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - l] + h[l]);\n    ans += dp[nn][mm];\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> mp;\nconst int maxn = 2e5 + 10;\nconst int inf = 0x3f3f3f3f;\nconst long long maxx = 2e18;\nint n, k, c[5010], f[510], h[20], num[510], dp[510][5010], ans;\nvector<pair<int, int> > v;\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n * k; i++) cin >> c[i];\n  sort(c + 1, c + 1 + n * k);\n  for (int i = 1; i <= n; i++) cin >> f[i];\n  sort(f + 1, f + 1 + n);\n  v.push_back(pair<int, int>(f[1], 1));\n  int pre = 1;\n  for (int i = 2; i <= n; i++) {\n    if (f[i] == f[pre])\n      v[v.size() - 1].second++;\n    else {\n      v.push_back(pair<int, int>(f[i], 1));\n      pre = i;\n    }\n  }\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  h[0] = 0;\n  memset(num, 0, sizeof(num));\n  for (int i = 1, j = 0; i <= n * k && j < v.size();) {\n    if (v[j].first > c[i])\n      i++;\n    else if (v[j].first == c[i]) {\n      num[j + 1]++;\n      i++;\n    } else\n      j++;\n  }\n  ans = 0;\n  for (int i = 1; i <= v.size(); i++) {\n    if (num[i] == 0)\n      continue;\n    else if (num[i] >= v[i - 1].second * k)\n      ans += h[k] * v[i - 1].second;\n    else {\n      for (int j = 1; j <= v[i - 1].second; j++) {\n        for (int g = 1; g <= min(num[i], j * k); g++) {\n          for (int l = 0; l <= min(k, g); l++) {\n            dp[j][g] = max(dp[j - 1][g - l] + h[l], dp[j][g]);\n          }\n        }\n      }\n      ans += dp[v[i - 1].second][num[i]];\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nconstexpr int MAXN = 505;\nconstexpr int MAXK = 11;\nconstexpr int MAXV = 100005;\nint n, k;\nint card_freq[MAXV];\nint man_freq[MAXV];\nint joy[MAXK];\nll dp[MAXN][MAXN * MAXK];\nll solve(int men, int cards) {\n  if (men == 0 or cards == 0) return 0;\n  if (dp[men][cards] != -1) return dp[men][cards];\n  ll ans = 0LL;\n  for (int h = 1; h <= min(cards, k); ++h) {\n    ans = max(ans, joy[h] + solve(men - 1, cards - h));\n  }\n  return dp[men][cards] = ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  scanf(\" %d %d\", &n, &k);\n  int x;\n  for (int i = 0; i < n * k; ++i) {\n    scanf(\" %d\", &x);\n    ++card_freq[x];\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\" %d\", &x);\n    ++man_freq[x];\n  }\n  for (int i = 1; i <= k; ++i) {\n    scanf(\" %d\", &joy[i]);\n  }\n  memset(dp, -1, sizeof(dp));\n  ll ans = 0LL;\n  for (int i = 0; i < MAXV; ++i) {\n    if (man_freq[i]) {\n      ans += solve(man_freq[i], card_freq[i]);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class cardsAndJoy {\n\tstatic long [][] memo;\n\tstatic int n,k,curN;\n\tpublic static long dp(int left, int idx) {\n\t\tif(left==0)\n\t\t\treturn 0;\n\t\tif(idx==curN)\n\t\t\treturn 0;\n\t\tlong cur = 0;\n\t\tif(memo[left][idx]!=-1)\n\t\t\treturn memo[left][idx];\n\t\tfor(int i = 0;i<=Math.min(k, left);i++) {\n\t\t\tcur = Math.max(cur, hk[i]+dp(left-i,idx+1));\n\t\t}\n\t\treturn memo[left][idx] = cur;\n\t}\npublic static void main(String[] args) throws IOException{\n\tScanner sc = new Scanner(System.in);\n\t n = sc.nextInt(); k = sc.nextInt();\n\telm = new int[n*k];\n\tfor (int i = 0; i < elm.length; i++) {\n\t\telm[i] = sc.nextInt();\n\t}\n\tfav =new int[n];\n\tHashSet<Integer> hs =new HashSet<Integer>();\n\tfor (int i = 0; i < fav.length; i++) {\n\t\tfav[i] = sc.nextInt();\n\t\ths.add(fav[i]);\n\t}\n\t hk = new int[k+1];\n\tfor (int i = 0; i < hk.length-1; i++) {\n\t\thk[i+1] = sc.nextInt();\n\t}\n\tint count = 0;\n\tTreeMap<Integer, Integer> map =new TreeMap<Integer,Integer>();\n\tfor (int i :hs) {\n\t\tmap.put(i, count++);\n\t}\n\tint [] countFavC = new int[hs.size()];\n\tint [] countFavH = new int[hs.size()];\n//\tSystem.out.println(\"hello\");\n\tfor (int i = 0; i < elm.length; i++) {\n\t\tif(map.containsKey(elm[i])) {\n\t\t\tint idx = map.get(elm[i]);\n\t\t\tcountFavC[idx]++;\n\t\t}\n\t}\n//\tSystem.out.println(\"hello\");\n\tfor(int i = 0;i<fav.length;i++) {\n\t\tif(map.containsKey(fav[i])) {\n\t\t\tint idx = map.get(fav[i]);\n\t\t\tcountFavH[idx]++;\n\t\t}\n\t}\n//\tSystem.out.println(\"hadfadf\");\n\tlong counter = 0;\n\tfor(int i = 0;i<countFavC.length;i++) {\n\t\tint humans = countFavH[i];\n\t\tint elms = countFavC[i];\n\t\tcurN = humans;\n//\t\tSystem.out.println(humans+\" \"+elms);\n\t\tmemo = new long[elms+1][humans];\n\t\tfor (int j = 0; j < memo.length; j++) {\n\t\t\tArrays.fill(memo[j],-1);\n\t\t}\n\t\tcounter+=dp(elms,0);\n\t}\n\tSystem.out.println(counter);\n}\nstatic int [] hk, fav, elm;\nstatic class Scanner \n{\n\tStringTokenizer st;\n\tBufferedReader br;\n\n\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\tpublic String next() throws IOException \n\t{\n\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\n\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\tpublic String nextLine() throws IOException {return br.readLine();}\n\t\n\tpublic double nextDouble() throws IOException\n\t{\n\t\tString x = next();\n\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\tdouble res = 0, f = 1;\n\t\tboolean dec = false, neg = false;\n\t\tint start = 0;\n\t\tif(x.charAt(0) == '-')\n\t\t{\n\t\t\tneg = true;\n\t\t\tstart++;\n\t\t}\n\t\tfor(int i = start; i < x.length(); i++)\n\t\t\tif(x.charAt(i) == '.')\n\t\t\t{\n\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\tdec = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\tif(dec)\n\t\t\t\t\tf *= 10;\n\t\t\t}\n\t\tres += Long.parseLong(sb.toString()) / f;\n\t\treturn res * (neg?-1:1);\n\t}\n\t\n\tpublic boolean ready() throws IOException {return br.ready();}\n\n\n}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int mod = 1000000007;\nlong long int freqC[100001];\nlong long int freqF[100001];\nlong long int h[11];\nlong long int DP[5000][501];\nint main() {\n  long long int i, j, k, l, m, n, p, q, x, y, z, a, b, c, d, e, f, r;\n  scanf(\"%lld\", &n);\n  scanf(\"%lld\", &k);\n  for (i = 0; i < k * n; i++) {\n    scanf(\"%lld\", &c);\n    freqC[c]++;\n  }\n  for (i = 0; i < n; i++) {\n    scanf(\"%lld\", &f);\n    freqF[f]++;\n  }\n  for (i = 1; i <= k; i++) {\n    scanf(\"%lld\", &h[i]);\n  }\n  for (j = 1; j <= n; j++) {\n    for (i = 1; i < k * n; i++) {\n      if (i >= j * k) {\n        DP[i][j] = h[k] * j;\n      } else {\n        for (p = 0; p <= min(k, i); p++) {\n          DP[i][j] = max(DP[i][j], h[p] + DP[i - p][j - 1]);\n        }\n      }\n    }\n  }\n  a = 0;\n  for (i = 0; i <= 100000; i++) {\n    if (freqC[i] >= freqF[i] * k) {\n      a += h[k] * freqF[i];\n    } else {\n      a += DP[freqC[i]][freqF[i]];\n    }\n  }\n  printf(\"%lld\\n\", a);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint c[100010], f[100010], h[100010], dp[550][10010];\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n * k; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    c[x]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    f[x]++;\n  }\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &h[i]);\n  for (int i = 1; i <= n; i++)\n    for (int j = 0; j <= n * k; j++)\n      for (int l = 0; l <= k; l++)\n        dp[i][j + l] = max(dp[i][j + l], dp[i - 1][j] + h[l]);\n  int ans = 0;\n  for (int i = 1; i <= 100000; i++)\n    if (f[i] != 0) ans += dp[f[i]][c[i]];\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FCardsAndJoy solver = new FCardsAndJoy();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FCardsAndJoy {\n        int n;\n        int k;\n        int[] count;\n        int[] fav;\n        int[] joy;\n        int[][] memo;\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            n = sc.nextInt();\n            k = sc.nextInt();\n            count = new int[(int) 1e5 + 1];\n            fav = new int[n];\n            joy = new int[k + 1];\n            for (int i = 0; i < n * k; i++)\n                count[sc.nextInt()]++;\n            for (int i = 0; i < n; i++)\n                fav[i] = sc.nextInt();\n            Arrays.sort(fav);\n            for (int i = 1; i <= k; i++)\n                joy[i] = sc.nextInt();\n            memo = new int[n][k * n + 1];\n            for (int[] x : memo)\n                Arrays.fill(x, -1);\n            pw.println(dp(0, count[fav[0]]));\n        }\n\n        private int dp(int idx, int rem) {\n            if (rem < 0)\n                return (int) -1e9;\n            if (idx == n - 1) {\n                return joy[Math.min(k, rem)];\n            }\n            if (memo[idx][rem] != -1)\n                return memo[idx][rem];\n            int max = Integer.MIN_VALUE;\n            for (int i = 0; i <= Math.min(k, rem); i++) {\n                max = Math.max(joy[i] + dp(idx + 1, fav[idx] == fav[idx + 1] ? rem - i : count[fav[idx + 1]]), max);\n            }\n            return memo[idx][rem] = max;\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-9;\nconst long long MOD = 1e9 + 7;\nconst int OO = 1e9;\nconst long long N = 1e5 + 5;\nint f[N];\nint joy[11];\nint fav[505];\nint k, n;\nint mem[505][5005];\nint dp(int idx, int rem) {\n  if (!idx) return 0;\n  int mn = min(k, rem);\n  int &ret = mem[idx][rem];\n  if (ret != -1) return ret;\n  ret = 0;\n  for (int i = 0; i <= mn; ++i)\n    if (i)\n      ret = max(ret, dp(idx - 1, rem - i) + joy[i - 1]);\n    else\n      ret = max(ret, dp(idx - 1, rem - i));\n  return ret;\n}\nint freq[N];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int c;\n  cin >> n >> k;\n  for (int i = 0; i < n * k; ++i) {\n    cin >> c;\n    f[c]++;\n  }\n  for (int i = 0; i < n; ++i) {\n    cin >> fav[i];\n    freq[fav[i]]++;\n  }\n  for (int i = 0; i < k; ++i) cin >> joy[i];\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    if (freq[fav[i]]) {\n      memset(mem, -1, sizeof mem);\n      ans += dp(freq[fav[i]], f[fav[i]]);\n      freq[fav[i]] = 0;\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class CF_490 {\n\n\tstatic int[] h;\n\tstatic int[][] memo;\n\tstatic int k;\n\n\tpublic static int dp(int p, int c) {\n\t\tif (p == 0 || c == 0)\n\t\t\treturn 0;\n\t\tif (memo[p][c] != -1)\n\t\t\treturn memo[p][c];\n\t\tint max = dp(p - 1, c);\n\t\tfor (int i = 0; i < k && i + 1 <= c; i++) {\n\t\t\tmax = Math.max(max, h[i] + dp(p - 1, c - i - 1));\n\t\t}\n\t\treturn memo[p][c] = max;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\tint[] cards = new int[(int) 1e5 + 1];\n\t\tfor (int i = 0; i < n * k; i++) {\n\t\t\tcards[sc.nextInt()]++;\n\t\t}\n\t\tint[] players = new int[(int) 1e5 + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tplayers[sc.nextInt()]++;\n\t\t}\n\t\th = sc.nextIntArray(k);\n\t\tint tot = 0;\n\t\tmemo = new int[n + 1][n * k + 1];\n\t\tfor (int[] a : memo)\n\t\t\tArrays.fill(a, -1);\n\t\tfor (int i = 0; i < (int) 1e5 + 1; i++) {\n\t\t\tif (players[i] != 0 && cards[i] != 0) {\n\t\t\t\ttot += dp(players[i], cards[i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(tot);\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(String f) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int[] nextIntArray1(int n) throws IOException {\n\t\t\tint[] a = new int[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int[] shuffle(int[] a, int n) {\n\t\t\tint[] b = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tb[i] = a[i];\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint j = i + r.nextInt(n - i);\n\t\t\t\tint t = b[i];\n\t\t\t\tb[i] = b[j];\n\t\t\t\tb[j] = t;\n\t\t\t}\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic int[] nextIntArraySorted(int n) throws IOException {\n\t\t\tint[] a = nextIntArray(n);\n\t\t\ta = shuffle(a, n);\n\t\t\tArrays.sort(a);\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray1(int n) throws IOException {\n\t\t\tlong[] a = new long[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArraySorted(int n) throws IOException {\n\t\t\tlong[] a = nextLongArray(n);\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint j = i + r.nextInt(n - i);\n\t\t\t\tlong t = a[i];\n\t\t\t\ta[i] = a[j];\n\t\t\t\ta[j] = t;\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\treturn a;\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<long long int> > memo(501, vector<long long int>(5001, -1));\nvector<long long int> h;\nlong long int n, k;\nlong long int dp(long long int num_players, long long int num_cards) {\n  if (num_cards < 0) {\n    return -INT_MAX;\n  }\n  if (num_players == 0) {\n    return 0;\n  }\n  if (num_cards == 0) {\n    return 0;\n  }\n  if (memo[num_players][num_cards] != -1) {\n    return memo[num_players][num_cards];\n  }\n  long long int maxa = -INT_MAX;\n  for (long long int i = 0; i <= k; i++) {\n    maxa = max(maxa, dp(num_players - 1, num_cards - i) + h[i]);\n  }\n  memo[num_players][num_cards] = maxa;\n  return maxa;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k;\n  vector<long long int> numcards(100001, 0);\n  vector<long long int> favour_num(100001, 0);\n  for (long long int i = 0; i < k * n; i++) {\n    long long int temp;\n    cin >> temp;\n    numcards[temp]++;\n  }\n  for (long long int i = 0; i < n; i++) {\n    long long int temp;\n    cin >> temp;\n    favour_num[temp]++;\n  }\n  h.resize(k + 1, 0);\n  for (long long int i = 0; i < k; i++) {\n    cin >> h[i + 1];\n  }\n  long long int ans = 0;\n  for (long long int i = 0; i < 100001; i++) {\n    if (favour_num[i] > 0 && numcards[i] > 0) {\n      ans += dp(favour_num[i], numcards[i]);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, u, m, cnt[100010], p[100010], c[100010], ans;\nint dp[505][5005];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.setf(ios::fixed);\n  cout.precision(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n * m; i++) {\n    cin >> u;\n    cnt[u]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> u;\n    p[u]++;\n  }\n  for (int i = 1; i <= m; i++) cin >> c[i];\n  for (int i = 1; i <= 100000; i++) {\n    if (p[i] == 0) continue;\n    for (int j = 1; j <= p[i]; j++) {\n      for (int k = 1; k <= cnt[i]; k++) {\n        for (int l = k - 1; l >= max(0, k - m); l--) {\n          dp[j][k] = max(dp[j][k], dp[j - 1][l] + c[k - l]);\n        }\n      }\n    }\n    ans += dp[p[i]][cnt[i]];\n    for (int j = 1; j <= p[i]; j++)\n      for (int k = 1; k <= cnt[i]; k++) dp[j][k] = 0;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma 03\nusing namespace std;\nlong long n, k;\nlong long cnt1[200005];\nlong long cnt2[200005];\nlong long c[5005];\nlong long f[505];\nlong long h[15];\nlong long dp[5005][505];\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < 200005; i++) {\n    cnt1[i] = 0;\n    cnt2[i] = 0;\n  }\n  for (long long i = 0; i < k * n; i++) {\n    cin >> c[i];\n    cnt1[c[i]]++;\n  }\n  for (long long i = 0; i < n; i++) {\n    cin >> f[i];\n    cnt2[f[i]]++;\n  }\n  h[0] = 0;\n  for (long long i = 1; i <= k; i++) cin >> h[i];\n  for (long long i = 0; i < 505; i++) dp[0][i] = 0;\n  for (long long i = 1; i < 5005; i++) {\n    for (long long j = 1; j < 505; j++) {\n      long long r = min(k, i);\n      for (long long a = 0; a <= r; a++)\n        dp[i][j] = max(dp[i - a][j - 1] + h[a], dp[i][j]);\n    }\n  }\n  long long ans = 0;\n  for (long long i = 0; i < 200005; i++) ans += dp[cnt1[i]][cnt2[i]];\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.*;\n\npublic class F {\n\n\tstatic int N, K;\n\tstatic int NK;\n\tstatic int cards[];\n\tstatic int cardFreq[];\n\tstatic int fav[];\n\tstatic int favFreq[];\n\tstatic int hap[];\n\tstatic HashMap<Integer, Integer> comp = new HashMap<Integer, Integer>();\n\t\n\tstatic int dp[][];\n\t\n\tstatic ArrayList<Integer> favOf[];\n\tpublic static void main(String[] args) {\n\t\tJS in = new JS();\n\t\tN = in.nextInt();\n\t\tK = in.nextInt();\n\t\tNK = N*K;\n\t\tcards = new int[NK];\n\t\tfor(int i = 0; i < NK; i++) cards[i] = in.nextInt();\n\t\tArrays.sort(cards);\n\t\t\n\t\tint curC = 0;\n\t\tfor(int i = 0; i < NK; i++) {\n\t\t\tif(!comp.containsKey(cards[i])) {\n\t\t\t\tcomp.put(cards[i], curC);\n\t\t\t\tcurC++;\n\t\t\t}\n\t\t\tcards[i] = comp.get(cards[i]);\n\t\t}\n\t\t\n\t\tfav = new int[N];\n\t\thap = new int[K];\n\t\t\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfav[i] = comp.getOrDefault(in.nextInt(), -1);\n\t\t}\n\t\tfor(int i = 0; i < K; i++) hap[i] = in.nextInt();\n\t\t\n\t\tdp = new int[N+1][NK+1];\n\t\tfor(int a[] : dp) Arrays.fill(a, -1);\n\t\t\n\t\tfavFreq = new int[curC];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tif(fav[i] != -1) favFreq[fav[i]]++;\n\t\t}\n\t\t\n\t\tcardFreq = new int[curC];\n\t\tfor(int i = 0; i < NK; i++) cardFreq[cards[i]]++;\n\t\t\n\t\tint res = 0;\n\t\tfor(int i = 0; i < curC; i++) {\n\t\t\t//System.out.println(\"Card: \"+i+\"  \"+favFreq[i]+\" \"+cardFreq[i]);\n\t\t\tres += go(favFreq[i], cardFreq[i]);\n\t\t}\n\n\t\tSystem.out.println(res);\n\t\t\n\t}\n\t\n\tstatic int go(int pLeft, int cLeft) {\n\t\tif(pLeft == 0 || cLeft == 0) return 0;\n\t\tif(dp[pLeft][cLeft] != -1) return dp[pLeft][cLeft];\n\t\t\n\t\tint res = 0;\n\t\tfor(int i = 1; i <= Math.min(cLeft, K); i++) {\n\t\t\tres = Math.max(res, hap[i-1]+go(pLeft-1, cLeft-i));\n\t\t}\n\t\tres = Math.max(res, go(pLeft-1, cLeft));\n\t\treturn dp[pLeft][cLeft]=res;\n\t}\n\t\n\t\n\tstatic class JS{\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\t\t\n\t\tpublic JS() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\t\t\n\t\tpublic JS(String s) throws FileNotFoundException {\n\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t}\n\t\t\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c!='.' ? cur:cur+nextLong()/num;\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\t\t\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\nIf you want to aim high, aim high\nDon't let that studying and grades consume you\nJust live life young\n******************************\nWhat do you think? What do you think?\n1st on Billboard, what do you think of it\nNext is a Grammy, what do you think of it\nHowever you think, I\u2019m sorry, but shit, I have no fcking interest\n*******************************\nI'm standing on top of my Monopoly board\nThat means I'm on top of my game and it don't stop\ntil my hip don't hop anymore\nhttps://www.a2oj.com/Ladder16.html\n*******************************\n300iq as writer = Sad!\n*/\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n   public class x999F\n   {\n      public static void main(String hi[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int K = Integer.parseInt(st.nextToken());\n         int[] cards = readArr(N*K, infile, st);\n         int[] favor = readArr(N, infile, st);\n         int[] joy = new int[K+1];\n         st = new StringTokenizer(infile.readLine());\n         for(int i=1; i <= K; i++)\n            joy[i] = Integer.parseInt(st.nextToken());\n         int[] freq = new int[100001];\n         for(int x: cards)\n            freq[x]++;\n         int[] players = new int[100001];\n         for(int x: favor)\n            players[x]++;\n         long res = 0L;\n         for(int tag=1; tag <= 100000; tag++)\n         {\n            int A = players[tag];\n            int B = freq[tag];\n            //dp[a][b] = answer with A players and B favorite number occurences\n            long[][] dp = new long[A+1][B+1];\n            for(int a=1; a <= A; a++)\n               for(int b=0; b <= B; b++)\n                  for(int k=0; k <= K; k++)\n                     if(b >= k)\n                        dp[a][b] = Math.max(dp[a][b], dp[a-1][b-k]+joy[k]);\n            res += dp[A][B];\n         }\n         System.out.println(res);\n      }\n      public static int[] readArr(int N, BufferedReader infile, StringTokenizer st) throws Exception\n      {\n         int[] arr = new int[N];\n         st = new StringTokenizer(infile.readLine());\n         for(int i=0; i < N; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n         return arr;\n      }\n   }"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\nimport java.util.*; \nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collections;\nimport java.util.Scanner;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n\npublic class momo {\n\tstatic int x, y;\n\tstatic int [][][]dp;\n\tstatic int []q;\n\tstatic int []p;\n\tstatic int []pq;\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tx = scan.nextInt();\n\t\ty = scan.nextInt();\n\t\tdp = new int [x][x * y][y + 5];\n\t\tp = new int [x * y];\n\t\tq = new int [x];\n\t\tpq = new int [y + 1];\n\t\tfor(int i = 0;i < x * y;i++) {\n\t\t\tp[i] = scan.nextInt();\n\t\t}\n\t\tfor(int i = 0;i < x;i++) {\n\t\t\tq[i] = scan.nextInt();\n\t\t}\n\t\tpq[0] = 0;\n\t\tfor(int i = 1;i <= y;i++) {\n\t\t    pq[i] = scan.nextInt();\n\t\t}\n\t\t Arrays.sort(p);\n\t\t Arrays.sort(q);\n\t\t for(int i = 0;i < x;i++) {\n\t\t\t for(int j = 0;j < x * y;j++) {\n\t\t\t\t Arrays.fill(dp[i][j], -1);\n\t\t\t }\n\t\t }\n\t\t System.out.print(rec(0, 0, 0));\n\t}\n\tpublic static int rec(int s, int ss, int n) {\n\t\tif(s == x || ss == x * y) {\n\t\t\treturn pq[n];\n\t\t}\n\t\tif(dp[s][ss][n] != -1) {\n\t\t\treturn dp[s][ss][n];\n\t\t}\n\t\tdp[s][ss][n] = 0;\n\t\tif(n < y && p[ss] == q[s]) {\n\t\t\tdp[s][ss][n] = Math.max(rec(s, ss + 1, n + 1), dp[s][ss][n]);\n\t\t}\n\t\tdp[s][ss][n] = Math.max(rec(s + 1, ss, 0) + pq[n], dp[s][ss][n]);\n\t\tdp[s][ss][n] = Math.max(rec(s, ss + 1, n), dp[s][ss][n]);\n\t\treturn dp[s][ss][n];\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 510;\nconst int maxm = 101010;\nconst int maxk = 15;\nconst long long inf = 0x3f3f3f3f3f3f3f3f;\nint n, k;\nlong long h[maxk];\nlong long dp[maxn][maxn * maxk];\nlong long solve(int res, int val) {\n  if (res == 0 or val == 0) return 0ll;\n  if (dp[res][val] >= 0) return dp[res][val];\n  dp[res][val] = 0;\n  for (int i = 1; i <= min(val, k); i++)\n    dp[res][val] = max(dp[res][val], solve(res - 1, val - i) + h[i]);\n  return dp[res][val];\n}\nint cnt[maxm], g[maxm];\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    int x;\n    cin >> x;\n    cnt[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    g[x]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  long long ans = 0;\n  for (int i = 1; i <= 100000; i++) {\n    if (cnt[i] and g[i]) {\n      for (int j = 0; j <= g[i]; j++)\n        for (int k = 0; k <= cnt[i]; k++) dp[j][k] = -1;\n      long long x = solve(g[i], cnt[i]);\n      ans += x;\n    }\n  }\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint c[510 * 15];\nint f[510];\nint h[15];\nint ccnt[100100];\nint fcnt[100100];\nbool fmark[100100];\nint dp[510][510 * 15];\nint main(void) {\n  int n, k;\n  cin >> n >> k;\n  int i, j;\n  for (i = 0; i < n * k; i++) {\n    cin >> c[i];\n    ccnt[c[i]]++;\n  }\n  for (i = 0; i < n; i++) {\n    cin >> f[i];\n    fcnt[f[i]]++;\n  }\n  for (i = 1; i <= k; i++) cin >> h[i];\n  for (i = 1; i <= n; i++) {\n    for (j = 1; j <= n * k; j++) {\n      for (int x = 0; x <= k; x++) {\n        dp[i][j] = max(dp[i][j], (j >= x) ? (dp[i - 1][j - x] + h[x]) : 0);\n      }\n    }\n  }\n  long long ans = 0;\n  for (i = 0; i < n; i++) {\n    if (fmark[f[i]]) continue;\n    fmark[f[i]] = 1;\n    int x = fcnt[f[i]];\n    int y = ccnt[f[i]];\n    ans += dp[x][y];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k;\nlong long a[510];\nlong long dp[510][59999];\nlong long nn = 0;\nlong long allcard = 0;\nlong long h[510];\nlong long rec(int i, int card) {\n  if (i <= 0 || card <= 0) return 0;\n  long long &ret = dp[i][card];\n  if (ret != -1) {\n    return ret;\n  }\n  ret = 0;\n  for (int j = 0; j <= k; j++) {\n    if (card >= j) {\n      ret = max(ret, rec(i - 1, card - j) + h[j]);\n    }\n  }\n  return ret;\n}\nint main() {\n  cin >> n >> k;\n  map<long long, long long> nk;\n  long long i;\n  for (i = 0; i < n * k; i++) {\n    long long x;\n    cin >> x;\n    nk[x]++;\n  }\n  map<long long, long long> person;\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n    person[a[i]]++;\n  }\n  for (i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  map<long long, long long> visit;\n  long long sum = 0;\n  memset(dp, -1, sizeof dp);\n  for (i = 0; i < n; i++) {\n    if (!visit[a[i]]) {\n      nn = person[a[i]];\n      allcard = nk[a[i]];\n      sum += rec(nn, allcard);\n      visit[a[i]] = 1;\n    }\n  }\n  cout << sum;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int dp[5010];\nlong long int cnt[(long long int)1e5 + 2], fav[(long long int)1e5 + 2];\nlong long int k;\nvector<long long int> h;\nlong long int calc(long long int x) {\n  if (fav[x] == 0) return 0;\n  long long int allot = min(fav[x] * k, cnt[x]);\n  for (long long int i = 0; i <= allot; i++) dp[i] = 0;\n  for (long long int i = 0; i < fav[x]; i++) {\n    for (long long int j = allot; j >= 1; j--) {\n      for (long long int m = 1; m <= min(k, j); m++)\n        dp[j] = (dp[j] > dp[j - m] + h[m] ? dp[j] : dp[j - m] + h[m]);\n    }\n  }\n  fav[x] = 0;\n  return dp[allot];\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  ;\n  long long int n;\n  cin >> n >> k;\n  h.assign(k + 1, 0);\n  long long int c;\n  for (long long int i = 0; i < n * k; i++) cin >> c, cnt[c]++;\n  vector<long long int> first(n);\n  for (auto &it : first) cin >> it, fav[it]++;\n  for (long long int i = 1; i < k + 1; i++) cin >> h[i];\n  long long int ans = 0;\n  for (long long int i = 0; i <= 1e5 + 1; i++) {\n    ans += calc(i);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\", \"unroll-loops\")\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch > '9' || ch < '0') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint hav[100005];\nmap<int, int> nd;\nlong long wei[15];\nlong long d[505][5005];\nint n, k, all;\nvoid init() {}\nint main() {\n  cin >> n >> k;\n  all = k * n;\n  for (int i = (1); i <= (int)(all); i++) hav[read()]++;\n  for (int i = (1); i <= (int)(n); i++) nd[read()]++;\n  for (int i = (1); i <= (int)(k); i++) wei[i] = read();\n  for (int i = (1); i <= (int)(n); i++) {\n    for (int j = (0); j <= (int)(all); j++) {\n      for (int x = (0); x <= (int)(min(k, j)); x++) {\n        d[i][j] = max(d[i][j], d[i - 1][j - x] + wei[x]);\n      }\n    }\n  }\n  long long ans = 0;\n  for (auto &p : nd) {\n    int cnt = hav[p.first];\n    ans += d[p.second][cnt];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author xuanquang1999\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt(), k = in.nextInt();\n            int c[] = new int[n * k];\n            int f[] = new int[n];\n            int h[] = new int[k + 1];\n            for (int i = 0; i < n * k; ++i)\n                c[i] = in.nextInt();\n            for (int i = 0; i < n; ++i)\n                f[i] = in.nextInt();\n            for (int i = 1; i <= k; ++i)\n                h[i] = in.nextInt();\n\n            int maxX = 100005;\n            int cntCard[] = new int[maxX];\n            int cntPlayer[] = new int[maxX];\n            for (int i = 0; i < n * k; ++i)\n                ++cntCard[c[i]];\n            for (int i = 0; i < n; ++i)\n                ++cntPlayer[f[i]];\n\n            int ans = 0;\n            for (int x = 0; x < maxX; ++x) {\n                int dp[][] = new int[cntCard[x] + 1][cntPlayer[x] + 1];\n                for (int i = 1; i <= cntCard[x]; ++i) {\n                    for (int j = 1; j <= cntPlayer[x]; ++j) {\n                        for (int p = 0; p <= Math.min(i, k); ++p) {\n                            dp[i][j] = Math.max(dp[i][j], dp[i - p][j - 1] + h[p]);\n                        }\n                    }\n                }\n                ans += dp[cntCard[x]][cntPlayer[x]];\n            }\n\n            out.println(ans);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mem[505][6000];\nlong long n, k, t, ans;\nlong long freq_cards[100005], freq_players[100005], h[11];\nlong long solve(long long remaining_players, long long remaining_cards) {\n  if (!remaining_players || !remaining_cards) return 0;\n  long long &ret = mem[remaining_players][remaining_cards];\n  if (~ret) return ret;\n  ret = 0;\n  for (long long i = 0; i < min(k + 1, remaining_cards + 1); i++)\n    ret = max(ret, h[i] + solve(remaining_players - 1, remaining_cards - i));\n  return ret;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k;\n  for (long long i = 0; i < n * k; i++) {\n    cin >> t;\n    freq_cards[t]++;\n  }\n  for (long long i = 0; i < n; i++) {\n    cin >> t;\n    freq_players[t]++;\n  }\n  for (long long i = 0; i < k; i++) cin >> h[i + 1];\n  memset(mem, -1, sizeof(mem));\n  for (long long i = 1; i < 100001; i++)\n    ans += solve(freq_players[i], freq_cards[i]);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint p, curm, ct[100010], f[100010], A[5010], dp[5010][5010];\nint fun(int a, int k) {\n  if (k < 0) return -1e9;\n  if (a == curm) return 0;\n  if (dp[a][k] != -1) return dp[a][k];\n  int maxi = 0;\n  for (int i = a; i <= curm && i <= (a + p); i++) {\n    maxi = max(maxi, A[i - a] + fun(i, k - 1));\n  }\n  return dp[a][k] = maxi;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, k;\n  cin >> n >> k;\n  p = k;\n  for (int i = 0; i < n * k; i++) {\n    int x;\n    cin >> x;\n    ct[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    f[x]++;\n  }\n  A[0] = 0;\n  for (int i = 1; i <= k; i++) {\n    cin >> A[i];\n  }\n  long long ans = 0;\n  for (int i = 1; i < 100010; i++) {\n    if (ct[i]) {\n      for (int j = 0; j <= ct[i]; j++) {\n        for (int k = 0; k <= 500; k++) dp[j][k] = -1;\n      }\n      curm = ct[i];\n      ans += fun(0, f[i]);\n    }\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 3,
            "solution": "from __future__ import print_function\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\n# CONFIG\nsys.setrecursionlimit(10**9)\n\n# LOG\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return map(int, input().split())\n\n\ndef nio(offset):\n    return map(lambda x: int(x) + offset, input().split())\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef countMap(arr):\n    m = {}\n    for x in arr:\n        m[x] = m.get(x,0) + 1\n    return m\n\ndef sortId(arr):\n    return sorted(range(arr), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = [0]\nh.extend(nia())\n\ncc = countMap(c)\ncf = countMap(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n    # log(dp[ni])\n\n# log(n,k)\n# log(\"c\", cc)\n# log(\"f\", cf)\n# log(\"h\", h)\n# log(dp)\n\nres = 0\n\n\nfor fk,fv in cf.items():\n    # log(fk, fv, cc.get(fk,0))\n    res += dp[fv][cc.get(fk,0)]\n\nprint(res)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class Main {\n\tstatic ArrayList<Integer> adj[];\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tpublic static long mod;\n\n\tstatic int [][]notmemo;\n\tstatic int k;\n\tstatic int a[];\n\tstatic int b[];\n\tstatic int m;\n\tstatic char c[];\n\n\n\tstatic int trace[];\n\tstatic int h[];\n\tstatic int x;\n\tstatic int ans1;\n\tstatic int ans2;\n    static char t[];\n\tstatic char l[];\n\tstatic char r[];\n    static int w;\n    static int s;\n\tstatic int fn[];\n    public static void main(String args[]) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn=sc.nextInt();\n\t\t k=sc.nextInt();\n\t\t a=new int[(int) (1e5+5)];\n\t\t\n\t\t for (int i = 0; i <k*n; i++) {\n\t\t\ta[sc.nextInt()]++;\n\t\t}\n\t\t fn=new int[n];\n\tHashMap<Integer,Integer> map=new HashMap<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x=sc.nextInt();\n\t\t\tmap.put(x,map.getOrDefault(x,0)+1);\n\t\t}\n\t\th=new int[k+1];\n\t\t\n\t\tfor (int i = 0; i < h.length-1; i++) {\n\t\t\th[i+1]=sc.nextInt();\n\t\t}\n\t\tint ans=0;\n\t\tnotmemo=new int[n+1][(n*k)+3];\n\t\tfor(int x[]:notmemo) {\n\t\t\tArrays.fill(x, -1);\n\t\t}\n\t\tfor(int x:map.keySet()) {\n\t\t\n\t\t\tans+=dp(map.get(x),a[x]);\n\t\t//System.out.println(x+\" \"+map.get(x)+\" \"+a[x]);\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tout.flush();\n    }\n    static int dp(int i,int rem) {\n\tif(rem==0||i==0) {\n\t\treturn 0;\n\t}\n\tif(notmemo[i][rem]!=-1) {\n\t\treturn notmemo[i][rem];\n\t}\t\n\t\n\tint ans=0;\n\tfor (int j = 1; j <=Math.min(rem,k); j++) {\n\t\tans=Math.max(ans, dp(i-1,rem-j)+h[j]);\n\t}\n\t\n\treturn notmemo[i][rem]=ans;\n    }\n    static String y;\n    \tstatic int nomnom[];\n\tstatic long fac[];\n\t\n\tstatic class book implements Comparable<book> {\n\t\tint idx;\n\t\tlong score;\n\n\t\tpublic book(int i, long s) {\n\t\t\tidx = i;\n\t\t\tscore = s;\n\t\t}\n\n\t\tpublic int compareTo(book o) {\n\t\t\treturn (int) (o.score - score);\n\t\t}\n\t}\n\n\tstatic class library implements Comparable<library> {\n\t\tint numofbooks;\n\t\tint signup;\n\t\tint shiprate;\n\t\tint idx;\n\n\t\tpublic library(int a, int b, int c, int idx) {\n\t\t\tnumofbooks = a;\n\t\t\tsignup = b;\n\t\t\tshiprate = c;\n\t\t\tthis.idx = idx;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(library o) {\n\t\tif(signup==o.signup) {\n\t\t\t  return o.numofbooks-numofbooks;\n\t\t}\n\t\treturn signup - o.signup;\n\t\t\n\t\t}\n\t}\n\n\n\n\n\n\tstatic boolean isOn(int S, int j) {\n\t\treturn (S & 1 << j) != 0;\n\t}\n\n\n\tstatic boolean f = true;\n\n\tstatic class SegmentTree { // 1-based DS, OOP\n\n\t\tint N; // the number of elements in the array as a power of 2 (i.e. after padding)\n\t\tint[] array, sTree, lazy;\n\n\t\tSegmentTree(int[] in) {\n\t\t\tarray = in;\n\t\t\tN = in.length - 1;\n\t\t\tsTree = new int[N << 1]; // no. of nodes = 2*N - 1, we add one to cross out index zero\n\t\t\tlazy = new int[N << 1];\n\t\t\t//build(1, 1, N);\n\t\t}\n\n\t\tvoid build(int node, int b, int e) // O(n)\n\t\t{\n\t\t\tif (b == e)\n\t\t\t\tsTree[node] = array[b];\n\t\t\telse {\n\t\t\t\tint mid = b + e >> 1;\n\t\t\t\tbuild(node << 1, b, mid);\n\t\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\t\tsTree[node] = sTree[node << 1] + sTree[node << 1 | 1];\n\t\t\t}\n\t\t}\n\n\t\tvoid update_point(int index, int val) // O(log n)\n\t\t{\n\t\t\tindex += N - 1;\t\t\t\t\n\t\t\tsTree[index] = val;\t\t\t\n\t\t\twhile(index>1)\t\t\t\t\n\t\t\t{\n\t\t\t\tindex >>= 1;\n\t\t\t\tsTree[index] = Math.max(sTree[index<<1] ,sTree[index<<1|1]);\t\t\n\t\t\t}\n\t\t}\n\n\t\tvoid update_range(int i, int j, int val) // O(log n)\n\t\t{\n\t\t\tupdate_range(1, 1, N, i, j, val);\n\t\t}\n\n\t\tvoid update_range(int node, int b, int e, int i, int j, int val) {\n\t\t\tif (i > e || j < b)\n\t\t\t\treturn;\n\t\t\tif (b >= i && e <= j) {\n\t\t\t\tsTree[node] += (e - b + 1) * val;\n\t\t\t\tlazy[node] += val;\n\t\t\t} else {\n\t\t\t\tint mid = b + e >> 1;\n\t\t\t\tpropagate(node, b, mid, e);\n\t\t\t\tupdate_range(node << 1, b, mid, i, j, val);\n\t\t\t\tupdate_range(node << 1 | 1, mid + 1, e, i, j, val);\n\t\t\t\tsTree[node] = sTree[node << 1] + sTree[node << 1 | 1];\n\t\t\t}\n\n\t\t}\n\n\t\tvoid propagate(int node, int b, int mid, int e) {\n\t\t\tlazy[node << 1] += lazy[node];\n\t\t\tlazy[node << 1 | 1] += lazy[node];\n\t\t\tsTree[node << 1] += (mid - b + 1) * lazy[node];\n\t\t\tsTree[node << 1 | 1] += (e - mid) * lazy[node];\n\t\t\tlazy[node] = 0;\n\t\t}\n\n\t\tint query(int i, int j) {\n\t\t\treturn query(1, 1, N, i, j);\n\t\t}\n\n\t\tint query(int node, int b, int e, int i, int j) // O(log n)\n\t\t{\n\t\t\tif (i > e || j < b)\n\t\t\t\treturn 0;\n\t\t\tif (b >= i && e <= j)\n\t\t\t\treturn sTree[node];\n\t\t\tint mid = b + e >> 1;\n\t\t\t// propagate(node, b, mid, e);\n\t\t\tint q1 = query(node << 1, b, mid, i, j);\n\t\t\tint q2 = query(node << 1 | 1, mid + 1, e, i, j);\n\t\t\treturn Math.max(q1,q2);\n\n\t\t}\n\t}\n\n\tstatic int memo[];\n\n\n\tstatic class UnionFind {\n\t\tint[] p, rank, setSize;\n\t\tint numSets;\n\t\tint max[];\n\n\t\tpublic UnionFind(int N) {\n\t\t\tp = new int[numSets = N];\n\t\t\trank = new int[N];\n\t\t\tsetSize = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tp[i] = i;\n\t\t\t\tsetSize[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tpublic int findSet(int i) {\n\t\t\treturn p[i] == i ? i : (p[i] = findSet(p[i]));\n\t\t}\n\n\t\tpublic boolean isSameSet(int i, int j) {\n\t\t\treturn findSet(i) == findSet(j);\n\t\t}\n\n\t\tpublic void unionSet(int i, int j) {\n\t\t\tif (isSameSet(i, j))\n\t\t\t\treturn;\n\t\t\tnumSets--;\n\t\t\tint x = findSet(i), y = findSet(j);\n\t\t\tif (rank[x] > rank[y]) {\n\t\t\t\tp[y] = x;\n\t\t\t\tsetSize[x] += setSize[y];\n\n\n\t\t\t} else {\n\t\t\t\tp[x] = y;\n\t\t\t\tsetSize[y] += setSize[x];\n\t\t\t\tif (rank[x] == rank[y])\n\t\t\t\t\trank[y]++;\n\n\n\t\t\t}\n\t\t}\n\n\t\t\n\n\t\tpublic int numDisjointSets() {\n\t\t\treturn numSets;\n\t\t}\n\n\t\tpublic int sizeOfSet(int i) {\n\t\t\treturn setSize[findSet(i)];\n\t\t}\n\t}\n\n\t/**\n\t * private static void trace(int i, int time) { if(i==n) return;\n\t * \n\t * \n\t * long ans=dp(i,time);\n\t * if(time+a[i].t<a[i].burn&&(ans==dp(i+1,time+a[i].t)+a[i].cost)) {\n\t * \n\t * trace(i+1, time+a[i].t);\n\t * \n\t * l1.add(a[i].idx); return; } trace(i+1,time);\n\t * \n\t * }\n\t **/\n\n\tstatic class incpair implements Comparable<incpair> {\n\t\tint a;\n\t\tlong b;\n\t\tint idx;\n\n\t\tincpair(int a, long dirg, int i) {\n\t\t\tthis.a = a;\n\t\t\tb = dirg;\n\t\t\tidx = i;\n\t\t}\n\n\t\tpublic int compareTo(incpair e) {\n\t\t\treturn (int) (b - e.b);\n\t\t}\n\t}\n\n\tstatic class decpair implements Comparable<decpair> {\n\t\tint a;\n\t\tlong b;\n\t\tint idx;\n\n\t\tdecpair(int a, long dirg, int i) {\n\t\t\tthis.a = a;\n\t\t\tb = dirg;\n\t\t\tidx = i;\n\t\t}\n\n\t\tpublic int compareTo(decpair e) {\n\t\t\treturn (int) (e.b - b);\n\t\t}\n\t}\n\n\tstatic long allpowers[];\n\n\tstatic class Quad implements Comparable<Quad> {\n\t\tint u;\n\t\tint v;\n\t\tchar state;\n\t\tint turns;\n\n\t\tpublic Quad(int i, int j, char c, int k) {\n\t\t\tu = i;\n\t\t\tv = j;\n\t\t\tstate = c;\n\t\t\tturns = k;\n\t\t}\n\n\t\tpublic int compareTo(Quad e) {\n\t\t\treturn (int) (turns - e.turns);\n\t\t}\n\n\t}\n\n\tstatic long dirg[][];\n\tstatic Edge[] driver;\n\n\tstatic int n;\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint node;\n\t\tlong cost;\n\n\t\tEdge(int a, long dirg) {\n\t\t\tnode = a;\n\t\t\tcost = dirg;\n\t\t}\n\n\t\tpublic int compareTo(Edge e) {\n\t\t\treturn (int) (cost - e.cost);\n\t\t}\n\t}\n\n\tstatic long manhatandistance(long x, long x2, long y, long y2) {\n\t\treturn Math.abs(x - x2) + Math.abs(y - y2);\n\t}\n\n\tstatic long fib[];\n\n\tstatic long fib(int n) {\n\t\tif (n == 1 || n == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (fib[n] != -1) {\n\t\t\treturn fib[n];\n\t\t} else\n\t\t\treturn fib[n] = ((fib(n - 2) % mod + fib(n - 1) % mod) % mod);\n\t}\n\n\tstatic class Point  implements Comparable<Point>{\n\t\tint x, y;\n\n\t\tPoint(int a, int b) {\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\tif(x!=o.x) {\n\t\t\treturn x-o.x;\n\t\t}\n\t\treturn y-o.y;\n\t\t}\n\t\t\n\n\n\t}\n\n\tstatic long[][] comb;\n\n\tstatic class Triple implements Comparable<Triple> {\n\n\t\tint l;\n\t\tint r;\n\t\tlong cost;\n\t\tint idx;\n\n\t\tpublic Triple(int a, int b, long l1, int l2) {\n\t\t\tl = a;\n\t\t\tr = b;\n\t\t\tcost = l1;\n\t\t\tidx = l2;\n\t\t}\n\n\t\tpublic int compareTo(Triple x) {\n\t\t\tif (l != x.l || idx == x.idx)\n\t\t\t\treturn l - x.l;\n\t\t\treturn -idx;\n\t\t}\n\n\t}\n\n\tstatic TreeSet<Long> primeFactors(long N) // O(sqrt(N) / ln sqrt(N))\n\t{\n\t\tTreeSet<Long> factors = new TreeSet<Long>(); // take abs(N) in case of -ve integers\n\t\tint idx = 0, p = primes.get(idx);\n\n\t\twhile (p * p <= N) {\n\t\t\twhile (N % p == 0) {\n\t\t\t\tfactors.add((long) p);\n\t\t\t\tN /= p;\n\t\t\t}\n\t\t\tif (primes.size() > idx + 1)\n\t\t\t\tp = primes.get(++idx);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (N != 1) // last prime factor may be > sqrt(N)\n\t\t\tfactors.add(N); // for integers whose largest prime factor has a power of 1\n\t\treturn factors;\n\t}\n\n\tstatic boolean visited[];\n\n\t/**\n\t * static int bfs(int s) { Queue<Integer> q = new LinkedList<Integer>();\n\t * q.add(s); int count=0; int maxcost=0; int dist[]=new int[n]; dist[s]=0;\n\t * while(!q.isEmpty()) {\n\t * \n\t * int u = q.remove(); if(dist[u]==k) { break; } for(Pair v: adj[u]) {\n\t * maxcost=Math.max(maxcost, v.cost);\n\t * \n\t * \n\t * \n\t * if(!visited[v.v]) {\n\t * \n\t * visited[v.v]=true; q.add(v.v); dist[v.v]=dist[u]+1; maxcost=Math.max(maxcost,\n\t * v.cost); } }\n\t * \n\t * } return maxcost; }\n\t **/\n\tpublic static boolean FindAllElements(int n, int k) {\n\t\tint sum = k;\n\t\tint[] A = new int[k];\n\t\tArrays.fill(A, 0, k, 1);\n\n\t\tfor (int i = k - 1; i >= 0; --i) {\n\n\t\t\twhile (sum + A[i] <= n) {\n\n\t\t\t\tsum += A[i];\n\t\t\t\tA[i] *= 2;\n\t\t\t}\n\t\t}\n\t\tif (sum == n) {\n\t\t\treturn true;\n\t\t} else\n\t\t\treturn false;\n\t}\n\n\tstatic boolean vis2[][];\n\n\tstatic boolean f2 = false;\n\n\tstatic long[][] matMul(long[][] a2, long[][] b, int p, int q, int r) // C(p x r) = A(p x q) x (q x r) -- O(p x q x\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// r)\n\t{\n\t\tlong[][] C = new long[p][r];\n\t\tfor (int i = 0; i < p; ++i) {\n\t\t\tfor (int j = 0; j < r; ++j) {\n\t\t\t\tfor (int k = 0; k < q; ++k) {\n\t\t\t\t\tC[i][j] = (C[i][j] + (a2[i][k] % mod * b[k][j] % mod)) % mod;\n\t\t\t\t\tC[i][j] %= mod;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\treturn C;\n\t}\n\n\tstatic int memo1[];\n\n\tstatic boolean vis[];\n\tstatic TreeSet<Integer> set = new TreeSet<Integer>();\n\n\tstatic long modPow(long ways, long count, long mod) // O(log e)\n\t{\n\t\tways %= mod;\n\t\tlong res = 1;\n\t\twhile (count > 0) {\n\t\t\tif ((count & 1) == 1)\n\t\t\t\tres = (res * ways) % mod;\n\t\t\tways = (ways * ways) % mod;\n\t\t\tcount >>= 1;\n\t\t}\n\t\treturn res % mod;\n\t}\n\n\tstatic long gcd(long ans, long b) {\n\t\tif (b == 0) {\n\t\t\treturn ans;\n\t\t}\n\t\treturn gcd(b, ans % b);\n\t}\n\n\tstatic int[] isComposite;\n\tstatic int[] valid;\n\n\tstatic ArrayList<Integer> primes;\n\tstatic ArrayList<Integer> l1;\n\n\t\n\tstatic TreeSet<Integer> primus = new TreeSet<Integer>();\n\t\n\tstatic void sieveLinear(int N)\n\t{\n\t\tint[] lp = new int[N + 1];\t\t\t\t\t\t\t\t//lp[i] = least prime divisor of i\n\t\tfor(int i = 2; i <= N; ++i)\n\t\t{\n\t\t\tif(lp[i] == 0)\n\t\t\t{\n\t\t\t\tprimus.add(i);\n\t\t\t\tlp[i] = i;\n\t\t\t}\n\t\t\tint curLP = lp[i];\n\t\t\tfor(int p: primus)\n\t\t\t\tif(p > curLP || p * i > N)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tlp[p * i] = i;\n\t\t}\n\t}\n\t\n\n\tpublic static int[] schuffle(int[] p) {\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tint x = (int) (Math.random() * p.length);\n\t\t\tint temp = p[x];\n\t\t\tp[x] = p[i];\n\t\t\tp[i] = temp;\n\t\t}\n\t\treturn p;\n\t}\n\n\tstatic int V;\n\tstatic long INF = (long) 1E16;\n\n\tstatic class Edge2 {\n\t\tint node;\n\t\tlong cost;\n\t\tlong next;\n\n\t\tEdge2(int a, int c, Long long1) {\n\t\t\tnode = a;\n\t\t\tcost = long1;\n\t\t\tnext = c;\n\t\t}\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\n\t\tpublic int[] nxtArr(int n) throws IOException {\n\t\t\tint[] ans = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tans[i] = nextInt();\n\t\t\treturn ans;\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class ProblemF {\n\n    public static InputStream inputStream = System.in;\n\n    public static OutputStream outputStream = System.out;\n\n    public static void main(String[] args) {\n        MyScanner scanner = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n        Map<Integer, Integer> cards = new HashMap<>();\n        for (int i = 0; i < n * k; i++) {\n            int x = scanner.nextInt();\n            if (!cards.containsKey(x)) {\n                cards.put(x, 0);\n            }\n            cards.put(x, cards.get(x) + 1);\n        }\n        Map<Integer, Integer> favorites = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int x = scanner.nextInt();\n            if (!favorites.containsKey(x)) {\n                favorites.put(x, 0);\n            }\n            favorites.put(x, favorites.get(x) + 1);\n        }\n\n        List<Integer> h = new ArrayList<>();\n        h.add(0);\n        for (int i = 0; i < k; i++) {\n            h.add(scanner.nextInt());\n        }\n\n        int ans = 0;\n        for (Map.Entry<Integer, Integer> entry : cards.entrySet()) {\n            int c = entry.getValue();\n            if (favorites.containsKey(entry.getKey())) {\n                int m = favorites.get(entry.getKey());\n                int[][] dp = new int[m + 1][c + 1];\n                dp[0][1] = h.get(1);\n                for (int i = 0; i < m; i++) {\n                    for (int j = 0; j <= c; j++) {\n                        for (int p = 0; p <= Math.min(j, k); p++) {\n                            dp[i][j] = Math.max(dp[i][j], (i == 0 ? 0 : dp[i - 1][j - p]) + h.get(p));\n                        }\n                    }\n                }\n                ans += dp[m - 1][c];\n            }\n        }\n\n        out.println(ans);\n\n\n\n\n\n        out.flush();\n    }\n\n    private static class MyScanner {\n        private BufferedReader bufferedReader;\n        private StringTokenizer stringTokenizer;\n\n        private MyScanner(InputStream inputStream) {\n            bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        private String next() {\n            while (stringTokenizer == null || !stringTokenizer.hasMoreElements()) {\n                try {\n                    stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return stringTokenizer.nextToken();\n        }\n\n        private int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        private long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        private double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        private String nextLine() {\n            String str = \"\";\n            try {\n                str = bufferedReader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    private static class Pair<F, S> {\n\n        private F first;\n\n        private S second;\n\n        public Pair() {}\n\n        public Pair(F first, S second) {\n            this.first = first;\n            this.second = second;\n        }\n    }\n\n    private static class Triple<F, S, T> {\n\n        private F first;\n\n        private S second;\n\n        private T third;\n\n        public Triple() {}\n\n        public Triple(F first, S second, T third) {\n            this.first = first;\n            this.second = second;\n            this.third = third;\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int N = 100003;\n            int n = in.nextInt();\n            int k = in.nextInt();\n\n            int l = n * k;\n            int[] cards = new int[N];\n            Arrays.fill(cards, 0);\n            for (int i = 1; i <= l; i++) {\n                cards[in.nextInt()]++;\n            }\n\n            int[] favorite = new int[N];\n            for (int i = 1; i <= n; i++) {\n                favorite[in.nextInt()]++;\n            }\n\n            int[] joy = new int[k + 1];\n            joy[0] = 0;\n            for (int i = 1; i <= k; i++) {\n                joy[i] = in.nextInt();\n            }\n\n            long[][] dp = new long[l + 1][n + 1];\n            dp[0][0] = 0;\n\n            for (int colors = 1; colors <= l; colors++) {\n                for (int people = 1; people <= n; people++) {\n                    for (int gp = 0; gp <= k; gp++) {\n                        if (colors >= gp) {\n                            dp[colors][people] = Math.max(dp[colors][people], dp[colors - gp][people - 1] + joy[gp]);\n                        }\n                    }\n                }\n            }\n\n//        for(long[] x: dp) {\n//            out.println(Arrays.toString(x));\n//        }\n            long ans = 0L;\n            for (int i = 0; i < N; i++) {\n                ans += dp[cards[i]][favorite[i]];\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader bufferedReader;\n        private StringTokenizer stringTokenizer;\n\n        public FastScanner(InputStream inputStream) {\n            bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            while (stringTokenizer == null || !stringTokenizer.hasMoreElements()) {\n                try {\n                    stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return stringTokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class dsu {\n\n\tstatic int k, n;\n\tstatic int memo[][];\n\tstatic int val[];\n\n\tpublic static int dp(int idx, int rem) {\n\t\tif (idx == 0)\n\t\t\treturn 0;\n\t\tif (memo[idx][rem] != -1)\n\t\t\treturn memo[idx][rem];\n\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < k + 1; i++) {\n\t\t\tint x = Math.min(i, rem);\n\t//\t\tSystem.out.println(max+\" \"+i+\" \"+x+\" \"+val[x]);\n\t\t\tmax = Math.max(max, dp(idx - 1, rem - x) + val[x]);\n\t\t}\n\t\treturn memo[idx][rem] = max;\n\n\t}\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tk = Integer.parseInt(st.nextToken());\n\t\tHashMap<Integer, Integer> hm = new HashMap<>();\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor (int i = 0; i < n * k; i++) {\n\t\t\tint x = Integer.parseInt(st.nextToken());\n\t\t\thm.put(x, hm.getOrDefault(x, 0) + 1);\n\t\t}\n\t\tArrayList<Integer> a = new ArrayList<>();\n\t\tHashMap<Integer, Integer> h = new HashMap<>();\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = Integer.parseInt(st.nextToken());\n\t\t\tif (!h.containsKey(x)) {\n\t\t\t\ta.add(x);\n\t\t\t}\n\t\t\th.put(x, h.getOrDefault(x, 0) + 1);\n\t\t}\n\t\tmemo = new int[502][5005];\n\t\tfor (int i = 0; i < memo.length; i++) {\n\t\t\tArrays.fill(memo[i], -1);\n\t\t}\n\t\tval = new int[k + 1];\n\t\tst=new StringTokenizer(br.readLine());\n\t\tfor (int i = 1; i < val.length; i++) {\n\t\t\tval[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tint x = dp(500, 5000);\n\t\tint sum=0;\n\t\tfor(int w:a) {\n\t\t\tint rem=0;\n\t\t\tif(hm.containsKey(w)) {\n\t\t\t\trem=hm.get(w);\n\t\t\t}\n\t\t\tsum+=dp(h.get(w),rem);\n\t\t}\n\t\tpw.print(sum);\n\t\tpw.flush();\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\n\n\tstatic class pair implements Comparable<pair> {\n\t\tint x;\n\t\tint y;\n\n\t\tpair(int r, int t) {\n\t\t\tx = r;\n\t\t\ty = t;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn o.x - x;\n\t\t}\n\n\t}\n\n\tstatic long power(long x, long y, int p) {\n\n\t\t// Initialize result\n\t\tlong res = 1;\n\n\t\t// Update x if it is more than or\n\t\t// equal to p\n\t\tx = x % p;\n\n\t\twhile (y > 0) {\n\n\t\t\t// If y is odd, multiply x\n\t\t\t// with result\n\t\t\tif (y % 2 == 1)\n\t\t\t\tres = (res * x) % p;\n\n\t\t\t// y must be even now\n\t\t\ty = y >> 1; // y = y/2\n\t\t\tx = (x * x) % p;\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t// Returns n^(-1) mod p\n\tstatic long modInverse(long n, int p) {\n\t\treturn power(n, p - 2, p);\n\t}\n\n\t// Returns nCr % p using Fermat's\n\t// little theorem.\n\tstatic long nCrModPFermat(int n, int r, int p) {\n\n\t\t// Base case\n\t\tif (r == 0)\n\t\t\treturn 1;\n\n\t\t// Fill factorial array so that we\n\t\t// can find all factorial of r, n\n\t\t// and n-r\n\t\tlong[] fac = new long[n + 1];\n\t\tfac[0] = 1;\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfac[i] = (fac[i - 1] * i) % p;\n\n\t\treturn (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n\nimport static java.lang.Math.*;\n\npublic class Cards implements Runnable {\n\n  long mod = 1000000000 + 7;\n  /*\n   * less than return 1 => large number first;\n   */\n\n  public void run() {\n    InputReader in = new InputReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n\n    int n = in.nextInt();\n    int k = in.nextInt();\n    int total = n * k;\n\n    int[] freq = new int[(int) (1e5 + 1)];\n    int[] favs = new int[(int) (1e5 + 1)];\n    int[] h = new int[k + 1];\n\n    for (int i = 0; i < total; i++) {\n      freq[in.nextInt()]++;\n    }\n\n    for (int i = 0; i < n; i++) {\n      favs[in.nextInt()]++;\n    }\n\n    for (int i = 1; i <= k; i++) {\n      h[i] = in.nextInt();\n    }\n\n    int[][] dp = new int[total + 1][n + 1];\n\n    for (int i = 1; i <= total; i++) {\n      for (int j = 1; j <= n; j++) {\n        int min = Math.min(i, k);\n        int max = 0;\n\n        for(int l=1;l<=min;l++){\n          max = Math.max(max, h[l] + dp[i-l][j-1]);\n        }\n\n        dp[i][j] = max;\n\n        //System.out.println(\"i: \"+i+\" j: \"+j+\" ans: \"+max);\n      }\n    }\n\n    int max = 0;\n\n    for(int i=0;i<(int)(1e5+1);i++){\n      if(favs[i] <=0) continue;\n      max += dp[freq[i]][favs[i]];\n    }\n\n    System.out.println(max);\n    out.close();\n  }\n\n  long log2(long a) {\n    return (long) (Math.log(a) / Math.log(2));\n  }\n\n  public long modAdd(long a, long b) {\n    return (a % mod + b % mod) % mod;\n  }\n\n  public long modSub(long a, long b) {\n    return ((a % mod - b % mod) % mod);\n  }\n\n  public long modMul(long a, long b) {\n    return ((a % mod) * (b % mod)) % mod;\n  }\n\n  public long modDiv(long a, long b) {\n    return ((a % mod) * (binaryExp(b, mod - 2))) % mod;\n  }\n\n  public long modPow(long a) {\n    return a % (mod - 1);\n  }\n\n  public long binaryExp(long a, long pow) {\n    a = a % mod;\n    if (pow == 0) {\n      return 1;\n    } else if (pow == 1) {\n      return a;\n    } else {\n      long half = pow / 2;\n      long temp = binaryExp(a, half);\n      if (pow % 2 == 0) {\n        return (temp * temp) % mod;\n      } else {\n        return ((a % mod) * ((temp * temp) % mod)) % mod;\n      }\n    }\n  }\n\n  public static void main(String args[]) throws Exception {\n    new Thread(null, new Cards(), \"Main\", 1 << 27).start();\n  }\n\n  static class InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n    private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (numChars == -1)\n        throw new InputMismatchException();\n\n      if (curChar >= numChars) {\n        curChar = 0;\n        try {\n          numChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n\n        if (numChars <= 0)\n          return -1;\n      }\n      return buf[curChar++];\n    }\n\n    public String nextLine() {\n      String str = \"\";\n      try {\n        str = br.readLine();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      return str;\n    }\n\n    public int nextInt() {\n      int c = read();\n\n      while (isSpaceChar(c))\n        c = read();\n\n      int sgn = 1;\n\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n\n      int res = 0;\n      do {\n        if (c < '0' || c > '9')\n          throw new InputMismatchException();\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n\n      return res * sgn;\n    }\n\n    public long nextLong() {\n      int c = read();\n      while (isSpaceChar(c))\n        c = read();\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      long res = 0;\n\n      do {\n        if (c < '0' || c > '9')\n          throw new InputMismatchException();\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public double nextDouble() {\n      int c = read();\n      while (isSpaceChar(c))\n        c = read();\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      double res = 0;\n      while (!isSpaceChar(c) && c != '.') {\n        if (c == 'e' || c == 'E')\n          return res * Math.pow(10, nextInt());\n        if (c < '0' || c > '9')\n          throw new InputMismatchException();\n        res *= 10;\n        res += c - '0';\n        c = read();\n      }\n      if (c == '.') {\n        c = read();\n        double m = 1;\n        while (!isSpaceChar(c)) {\n          if (c == 'e' || c == 'E')\n            return res * Math.pow(10, nextInt());\n          if (c < '0' || c > '9')\n            throw new InputMismatchException();\n          m /= 10;\n          res += (c - '0') * m;\n          c = read();\n        }\n      }\n      return res * sgn;\n    }\n\n    public String readString() {\n      int c = read();\n      while (isSpaceChar(c))\n        c = read();\n      StringBuilder res = new StringBuilder();\n      do {\n        res.appendCodePoint(c);\n        c = read();\n      } while (!isSpaceChar(c));\n\n      return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n      if (filter != null)\n        return filter.isSpaceChar(c);\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public String next() {\n      return readString();\n    }\n\n    public interface SpaceCharFilter {\n      public boolean isSpaceChar(int ch);\n    }\n  }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = (long long)1e18 + 7;\nconst int inf = (int)1e9 + 7;\nconst double eps = 1e-7;\nconst double pi = 3.14159265359;\nint n, k, c, f, h[11], ans;\nint cnt_cards[100001], cnt_favorites[100001];\nint dp[501][5001];\nbool use_pos[501][5001];\nint d(int people, int cards) {\n  if (people == 0 || cards == 0) return 0;\n  if (!use_pos[people][cards]) {\n    use_pos[people][cards] = true;\n    int res = 0;\n    for (int i = 0; i < min(cards, k) + 1; ++i)\n      res = max(res, h[i] + d(people - 1, cards - i));\n    dp[people][cards] = res;\n  }\n  return dp[people][cards];\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n * k; ++i) {\n    scanf(\"%d\", &c);\n    ++cnt_cards[c];\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &f);\n    ++cnt_favorites[f];\n  }\n  for (int i = 0; i < k; ++i) scanf(\"%d\", &h[i + 1]);\n  for (int i = 1; i <= 100000; ++i)\n    ans += d(cnt_favorites[i], min(cnt_cards[i], cnt_favorites[i] * k));\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5;\nint dp[5001], c[N + 1], p[N + 1], h[501];\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n * m; i++) {\n    int tmp;\n    cin >> tmp;\n    c[tmp] += 1;\n  }\n  for (int i = 0; i < n; i++) {\n    int tmp;\n    cin >> tmp;\n    p[tmp] += 1;\n  }\n  for (int i = 1; i <= m; i++) cin >> h[i];\n  int ans = 0;\n  for (int i = 0; i <= N; i++) {\n    memset(dp, 0, c[i] + 1 << 2);\n    for (int j = 1; j <= p[i]; j++)\n      for (int k = c[i]; k; k--)\n        for (int l = 1; k - l >= 0 && l <= m; l++)\n          dp[k] = max(dp[k], dp[k - l] + h[l]);\n    ans += dp[c[i]];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint c[100005], f[587], h[11], dp[505][5005], cc[100005];\nint main() {\n  std::ios::sync_with_stdio(0);\n  std::cin.tie(0);\n  ;\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    int t;\n    cin >> t;\n    c[t]++;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> f[i];\n    cc[f[i]]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n * k; j++) {\n      for (int l = 0; l <= min(j, k); l++)\n        dp[i][j] = max(dp[i][j], dp[i - 1][j - l] + h[l]);\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < 100005; i++) ans += dp[cc[i]][c[i]];\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005, A = 5005;\nint n, k, f[N], d[N], D[A], F[A], a[20];\nint solve(int x, int y) {\n  for (int i = 1; i <= n * k; i++) D[i] = F[i] = 0;\n  for (int i = 1; i <= x; i++) {\n    for (int j = 1; j <= y; j++)\n      for (int z = 1; z <= min(j, k); z++) D[j] = max(D[j], F[j - z] + a[z]);\n    for (int j = 1; j <= y; j++) F[j] = D[j], D[j] = 0;\n  }\n  return F[y];\n}\nint main(int argc, char const *argv[]) {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i <= n * k; i++) {\n    int x;\n    cin >> x;\n    f[x]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    d[x]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> a[i];\n  int ans = 0;\n  for (int i = 1; i <= 100000; i++)\n    if (d[i]) ans += solve(d[i], f[i]);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long MOD2 = 998244353;\nconst long long N = 2e5 + 5;\nconst long double pi = 3.14159265359;\nlong long n, k, x, cnt[N], p[N], dp[2][N], f[N], h[15], ans;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (long long i = 0; i < n * k; i++) cin >> x, cnt[x]++;\n  for (long long i = 1; i <= n; i++) cin >> f[i], p[f[i]]++;\n  for (long long i = 1; i <= k; i++) cin >> h[i];\n  for (long long i = 1; i <= N; i++) {\n    for (long long j = 1; j <= cnt[i]; j++) dp[0][j] = dp[1][j] = 0;\n    for (long long g = 1; g <= p[i]; g++) {\n      for (long long j = 1; j <= cnt[i]; j++) {\n        dp[g & 1][j] = 0;\n        for (long long z = 1; z <= k; z++) {\n          if (j >= z)\n            dp[g % 2][j] = max(dp[g % 2][j], dp[(g + 1) % 2][j - z] + h[z]);\n        }\n      }\n    }\n    ans += dp[p[i] % 2][cnt[i]];\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint cnt[100010], cnt2[100010], h[20], sh[210], dp[510][5010];\nlong long ans;\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    int x;\n    cin >> x;\n    cnt[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    cnt2[x]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n * k; j++) {\n      for (int t = 1; t <= min(j, k); t++)\n        dp[i][j] = max(dp[i][j], dp[i - 1][j - t] + h[t]);\n    }\n  for (int i = 1; i <= 100000; i++) ans += dp[cnt2[i]][cnt[i]];\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(\n    (unsigned int)chrono::steady_clock::now().time_since_epoch().count());\nvector<int> gain;\nvector<vector<int>> dp;\nint n, k;\nint solve(int want, int have) {\n  if (have == 0 || want == 0) return 0;\n  if (dp[want][have] != -1) {\n    return dp[want][have];\n  }\n  int ans = 0;\n  int limit = min(k, have);\n  for (int i = 1; i <= limit; i++) {\n    ans = max(ans, gain[i - 1] + solve(want - 1, have - i));\n  }\n  return dp[want][have] = ans;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  int all = n * k;\n  map<int, int> nums;\n  for (int i = 0; i < all; i++) {\n    int a;\n    cin >> a;\n    nums[a]++;\n  }\n  map<int, int> fev;\n  for (int i = 0; i < n; i++) {\n    int a;\n    cin >> a;\n    fev[a]++;\n  }\n  gain.resize(k);\n  dp.resize(n + 1, vector<int>(all + 1, -1));\n  for (int i = 0; i < k; i++) cin >> gain[i];\n  int ans = 0;\n  for (auto it : fev) {\n    int have = nums[it.first];\n    int want = it.second;\n    ans += solve(want, have);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ninline int scan() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\ninline void Out(int a) {\n  if (a < 0) {\n    putchar('-');\n    a = -a;\n  }\n  if (a >= 10) Out(a / 10);\n  putchar(a % 10 + '0');\n}\nusing namespace std;\nconst int maxn = 100005;\nlong long f[maxn];\nlong long h[maxn];\nlong long sum[maxn];\nlong long c[maxn];\nlong long dp[5005][505];\nlong long ji = 0;\nmap<long long, long long> M;\nstruct A {\n  long long num1;\n  long long num2;\n};\nA node[maxn];\nint n, k;\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> k;\n  for (long long i = 1; i <= n * k; i++) {\n    cin >> c[i];\n    sum[c[i]]++;\n  }\n  for (long long i = 1; i <= n; i++) {\n    cin >> f[i];\n    if (M[f[i]] == 0) {\n      M[f[i]] = ++ji;\n      node[M[f[i]]].num1++;\n      node[M[f[i]]].num2 = sum[f[i]];\n    } else {\n      node[M[f[i]]].num1++;\n    }\n  }\n  for (long long i = 1; i <= k; i++) cin >> h[i];\n  for (int i = 1; i <= n * k; i++) {\n    dp[i][1] = h[min(i, k)];\n    for (int j = 2; j <= n; j++)\n      for (int u = 1; i - u >= 0 && u <= k; u++)\n        dp[i][j] = max(dp[i][j], dp[i - u][j - 1] + h[u]);\n  }\n  long long ans = 0;\n  for (long long i = 1; i <= ji; i++) {\n    ans += dp[node[i].num2][node[i].num1];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 999999999;\nconst int maxn = 1e5 + 5;\nconst int minm = -0x7;\nconst long long mod = 10000007;\nconst double ABS = 1e-6;\nlong long dp[505][6005], h[505];\nint n, K;\nvoid init(void) {\n  for (int i = 1; i <= n; i++) {\n    for (int res = 0; res <= n * K; res++) {\n      for (int j = 0; j <= K; j++) {\n        dp[i][res + j] = max(dp[i][res + j], dp[i - 1][res] + h[j]);\n      }\n    }\n  }\n}\nint cnt1[maxn], cnt2[maxn];\nint main() {\n  int x;\n  cin >> n >> K;\n  for (int i = 0; i < n * K; i++) {\n    scanf(\"%d\", &x);\n    cnt1[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &x);\n    cnt2[x]++;\n  }\n  for (int i = 1; i <= K; i++) cin >> h[i];\n  init();\n  long long ans = 0;\n  for (int i = 1; i < maxn; i++) {\n    if (cnt2[i] != 0) ans += dp[cnt2[i]][cnt1[i]];\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[505][5005];\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  map<int, int> mp;\n  for (int i = 0, x; i < n * k; ++i) {\n    cin >> x;\n    ++mp[x];\n  }\n  map<int, int> f;\n  for (int i = 0, x; i < n; ++i) {\n    cin >> x;\n    ++f[x];\n  }\n  vector<int> h(k + 1);\n  for (int i = 1; i <= k; ++i) cin >> h[i];\n  long long ans = 0;\n  for (auto i : f) {\n    int v = i.first, c = i.second;\n    int x = mp[v];\n    memset(dp, 0, sizeof dp);\n    for (int z = c; z > 0; --z)\n      for (int j = x; j >= 0; --j)\n        for (int l = 0; l <= min(k, j); ++l)\n          dp[z - 1][j - l] = max(dp[z - 1][j - l], dp[z][j] + h[l]);\n    long long w = 0;\n    for (int i = 0; i <= x; ++i) w = max(w, dp[0][i]);\n    ans += w;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint fc[100005], fp[100005], h[15];\nint dp[505][5042], ans, n, k;\nint main() {\n  cin >> n >> k;\n  for (int i = k * n, x; i--; ++fc[x]) cin >> x;\n  for (int i = n, x; i--; ++fp[x]) cin >> x;\n  for (int i = 1; i <= k; cin >> h[i++])\n    ;\n  for (int x = 0, y, i; x < n; ++x)\n    for (y = 0; y <= k * n; ++y)\n      for (i = 0; i <= k; ++i)\n        dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]);\n  for (int i = 100005; i--; ans += dp[fp[i]][fc[i]])\n    ;\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5;\nconst long long INF = 1e18;\nint k;\nint cf[N];\nint pf[N];\nint H[N];\nlong long dp[5005][505];\nlong long fun(int p, int rem) {\n  if (p == 0) return 0;\n  long long &memo = dp[rem][p];\n  if (memo != -1) return memo;\n  long long ans = 0;\n  for (int i = 0; i <= min(rem, k); i++) {\n    ans = max(ans, H[i] + fun(p - 1, rem - i));\n  }\n  return memo = ans;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n >> k;\n  for (int i = 1; i <= n * k; i++) {\n    int c;\n    cin >> c;\n    cf[c]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    int f;\n    cin >> f;\n    pf[f]++;\n  }\n  for (int i = 1; i <= k; i++) {\n    cin >> H[i];\n  }\n  memset(dp, -1, sizeof dp);\n  long long ans = 0;\n  for (int i = 1; i < N; i++) {\n    if (pf[i]) {\n      ans += fun(pf[i], cf[i]);\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int power(long long int x, long long int n) {\n  long long int res = 1;\n  while (n > 0) {\n    if (n % 2 == 1) {\n      res = res * x;\n    }\n    x = x * x;\n    n = n / 2;\n  }\n  return res;\n}\nlong long int powm(long long int a, long long int b) {\n  long long int res = 1;\n  a %= 1000000007;\n  assert(b >= 0);\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a % 1000000007;\n    a = a * a % 1000000007;\n  }\n  return res;\n}\nlong long int h[12];\nlong long int solve(long long int n, long long int k, long long int cnt) {\n  int i, j;\n  if (cnt == 0) return 0;\n  long long int dp[n + 1][cnt + 1];\n  memset(dp, 0, sizeof(dp));\n  for (i = 1; i <= n; i++) {\n    for (j = 1; j <= cnt; j++) {\n      for (int k1 = 0; k1 <= k; k1++) {\n        if (j - k1 >= 0) dp[i][j] = max(dp[i - 1][j - k1] + h[k1], dp[i][j]);\n      }\n    }\n  }\n  if (dp[n][cnt] < 0) dp[n][cnt] = 0;\n  return dp[n][cnt];\n}\nint main() {\n  int n, k, i, j;\n  cin >> n >> k;\n  int f[100005] = {0};\n  for (i = 0; i < n * k; i++) {\n    int x;\n    cin >> x;\n    f[x]++;\n  }\n  int fav[100005] = {0};\n  for (i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    fav[x]++;\n  }\n  long long int ans = 0;\n  for (i = 0; i < k; i++) cin >> h[i + 1];\n  for (i = 1; i <= 100000; i++) {\n    if (fav[i] != 0) {\n      ans += solve(fav[i], k, f[i]);\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long INF = 1000000000;\nconst long long N = 200000;\nconst long long modi = 1000000007;\nconst long long modi2 = 1000000006;\nusing namespace std;\nint main() {\n  long long n, k;\n  cin >> n >> k;\n  long long val = n * k;\n  long long c[val + 1];\n  long long f[n + 1];\n  long long h[k + 1];\n  for (long long i = 0; i < val; i++) {\n    cin >> c[i];\n  }\n  for (long long i = 0; i < n; i++) {\n    cin >> f[i];\n  }\n  h[0] = 0;\n  for (long long j(1); j < k + 1; j++) {\n    cin >> h[j];\n  }\n  long long dp[n + 1][val + 1];\n  for (long long i = 0; i < n + 1; i++) {\n    for (long long j = 0; j < val + 1; j++) {\n      dp[i][j] = 0;\n    }\n  }\n  for (long long j = 0; j < val + 1; j++) {\n    dp[0][j] = 0;\n  }\n  for (long long i(1); i < n + 1; i++) {\n    for (long long j = 0; j < val + 1; j++) {\n      for (long long r = 0; r < k + 1; r++) {\n        if (j >= r) {\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - r] + h[r]);\n        }\n      }\n    }\n  }\n  long long sum = 0;\n  map<long long, long long> fc;\n  map<long long, long long> ff;\n  for (long long i = 0; i < val; i++) {\n    fc[c[i]]++;\n  }\n  for (long long i = 0; i < n; i++) {\n    ff[f[i]]++;\n  }\n  for (auto i : ff) {\n    sum += dp[i.second][fc[i.first]];\n  }\n  cout << sum << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, c[5001], f[501], h[11], dp[501][5001], cnt[100001],\n    cntf[100001], ans = 0;\nvector<long long> a;\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long long i = 0; i < n * k; i++) cin >> c[i];\n  sort(c, c + n * k);\n  for (long long i = 0; i < n; i++) cin >> f[i];\n  sort(f, f + n);\n  h[0] = 0;\n  for (long long i = 1; i < k + 1; i++) cin >> h[i];\n  for (long long i = 0; i < n * k; i++) {\n    if (!i || c[i] != c[i - 1]) a.push_back(c[i]);\n    cnt[c[i]]++;\n  }\n  for (long long i = 0; i < n; i++) cntf[f[i]]++;\n  for (long long i = 0; i < a.size(); i++) {\n    long long p = cnt[a[i]], q = cntf[a[i]];\n    dp[0][0] = 0;\n    for (long long ti = 1; ti < q + 1; ti++)\n      for (long long j = 0; j < p + 1; j++) {\n        dp[ti][j] = 0;\n        for (long long tk = 0; tk < min(j, k) + 1; tk++)\n          dp[ti][j] = max(dp[ti][j], dp[ti - 1][j - tk] + h[tk]);\n      }\n    ans += dp[q][p];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 100;\nint n, k, x, cnt[N], f[N], h[12], dp[512][512 * 12], ans, ma = -1e9;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i <= n * k; ++i) {\n    cin >> x;\n    ++cnt[x];\n  }\n  for (int i = 1; i <= n; ++i) {\n    cin >> x;\n    ++f[x];\n    ma = max(ma, x);\n  }\n  for (int i = 1; i <= k; ++i) {\n    cin >> h[i];\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0; j <= n * k; ++j) {\n      for (int tmp = 0; tmp <= k; ++tmp) {\n        dp[i][j + tmp] = max(dp[i][j + tmp], dp[i - 1][j] + h[tmp]);\n      }\n    }\n  }\n  for (int i = 0; i <= ma; ++i)\n    if (f[i] != 0) ans += dp[f[i]][cnt[i]];\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"03\")\nusing namespace std;\nint n, k, c[510 * 11], f[510], h[23], nr[100100], fav[100100];\nset<int> hh;\nlong long dp[510 * 11][510], ans;\nvoid solve(int card) {\n  int sz = min(nr[card], fav[card] * k);\n  for (int i = 1; i <= sz; i++)\n    for (int j = 1; j <= fav[card]; j++) dp[i][j] = 1;\n  for (int i = 1; i <= sz; i++)\n    for (int j = 1; j <= fav[card]; j++)\n      for (int p = 1; p <= k; p++) {\n        if (i >= p) dp[i][j] = max(dp[i - p][j - 1] + h[p], dp[i][j]);\n      }\n  ans += (fav[card] > 1 ? dp[sz][fav[card]] : h[sz]);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cin >> n >> k;\n  for (int i = 1; i <= n * k; i++) cin >> c[i], nr[c[i]]++;\n  for (int i = 1; i <= n; i++) cin >> f[i], hh.insert(f[i]), fav[f[i]]++;\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  for (auto xd : hh) solve(xd);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n \n/* spar5h */\n \npublic class cf6 implements Runnable{    \n\t\n\tfinal static long mod = (long)1e9 + 7; \n\t\n\tpublic void run() {\n\t    \n\t\tInputReader s = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\t\n\t\tint n = s.nextInt(), k = s.nextInt();\n\t\t\n\t\tint[] c = new int[(int)1e5 + 1];\n\t\t\n\t\tfor(int i = 1; i <= n * k; i++)\n\t\t\tc[s.nextInt()]++;\n\t\t\n\t\tint[] f = new int[(int)1e5 + 1];\n\t\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tf[s.nextInt()]++;\n\t\t\n\t\tint[] h = new int[k + 1];\n\t\t\n\t\tfor(int i = 1; i <= k; i++)\n\t\t\th[i] = s.nextInt();\n\t\t\n\t\t//dp[players][cards]\n\t\tint[][] dp = new int[n + 1][n * k + 1];\n\t\t\n\t\tfor(int j = 1; j <= k; j++)\n\t\t\tdp[1][j] = h[j];\n\t\t\n\t\tfor(int i = 2; i <= n; i++) \n\t\t\tfor(int j = 1; j <= n * k; j++) \n\t\t\t\tfor(int l = 1; l <= k; l++)\n\t\t\t\t\tif(j - l >= 1 && dp[i - 1][j - l] != 0)\n\t\t\t\t\t\tdp[i][j] = Math.max(dp[i - 1][j - l] + h[l], dp[i][j]); \n\t\t\n\t\tlong res = 0;\n\t\t\n\t\tfor(int i = 1; i <= (int)1e5; i++) {\n\t\t\t\n\t\t\tif(c[i] == 0 || f[i] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tc[i] = Math.min(c[i], k * f[i]);\n\t\t\t\n\t\t\tlong max = 0;\n\t\t\t\n\t\t\tfor(int j = 1; j <= f[i]; j++)\n\t\t\t\tmax = Math.max(dp[j][c[i]], max);\n\t\t\t\n\t\t\tres += max;\n\t\t}\n\t\t\n\t\tw.println(res);\n\t\t\n\t\tw.close();\n\t}\n\t\n\tstatic class InputReader {\n\t\t\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\t\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\t\t\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars==-1) \n\t\t\t\tthrow new InputMismatchException();\n\t\t\t\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t \n\t\tpublic String nextLine()\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n\t\t}\n\t\tpublic int nextInt()\n\t\t{\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile(isSpaceChar(c)) \n\t\t\t\tc = read();\n\t\t\t\n\t\t\tint sgn = 1;\n\t\t\t\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic long nextLong() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\t\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t{\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') \n\t\t\t{\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic String readString() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\n\t\t\treturn res.toString();\n\t\t}\n\t \n\t\tpublic boolean isSpaceChar(int c) \n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t \n\t\tpublic String next() \n\t\t{\n\t\t\treturn readString();\n\t\t}\n\t\t\n\t\tpublic interface SpaceCharFilter \n\t\t{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n    \n\tpublic static void main(String args[]) throws Exception\n\t{\n\t\tnew Thread(null, new cf6(),\"cf6\",1<<26).start();\n\t}\n}   "
        },
        {
            "language": 4,
            "solution": "// package CodeForces;\n\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\n\npublic class Round490F {\n\n\tpublic static void solve() {\n\t\tint n = s.nextInt();\n\t\tint k = s.nextInt();\n\t\tint[] colors = s.nextIntArray(n * k);\n\t\tint[] favs = s.nextIntArray(n);\n\t\tlong[] h = s.nextLongArray(k);\n\t\tHashMap<Integer, Integer> places = new HashMap<Integer, Integer>();\n\t\tHashMap<Integer, Integer> things = new HashMap<Integer, Integer>();\n\t\tfor(int i = 0; i < n * k; i++) {\n\t\t\tthings.put(colors[i], things.getOrDefault(colors[i], 0) + 1);\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tplaces.put(favs[i], places.getOrDefault(favs[i], 0) + 1);\n\t\t}\n\t\tlong ans = 0;\n\t\tfor(Integer x : places.keySet()) {\n\t\t\tint place = places.get(x);\n\t\t\tif(things.containsKey(x)) {\n\t\t\t\tint thing = things.get(x);\n\t\t\t\tans = ans + solveSmall(h, thing, place, k);\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tpublic static long solveSmall(long[] h, int things, int places, int k) {\n\t\tif(places * k <= things) {\n\t\t\treturn places * h[k - 1];\n\t\t}\n\t\tlong[][] dp = new long[places][things + 1];\n\t\tlong ans = 0;\n\t\tfor(int i = 0; i < places; i++) {\n\t\t\tfor(int j = 0; j <= things; j++) {\n\t\t\t\tfor(int itake = 0; itake <= k; itake++) {\n\t\t\t\t\tif(j - itake < 0) break;\t\n\t\t\t\t\tdp[i][j] = Long.max((itake == 0 ? 0 : h[itake - 1]) + (i - 1 >= 0 ? dp[i - 1][j - itake] : 0), dp[i][j]);\n\t\t\t\t}\n\t\t\t\tans = Long.max(dp[i][j], ans);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, null, \"Thread\", 1 << 27) {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\t\t\t\t\ts = new FastReader(System.in);\n\t\t\t\t\tsolve();\n\t\t\t\t\tout.close();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}.start();\n\t}\n\n\tpublic static PrintWriter out;\n\tpublic static FastReader s;\n\n\tpublic static class FastReader {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[4096];\n\t\tprivate int curChar, snumChars;\n\n\t\tpublic FastReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (snumChars == -1) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException E) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (snumChars <= 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint number = 0;\n\t\t\tdo {\n\t\t\t\tnumber *= 10;\n\t\t\t\tnumber += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn number * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong number = 0;\n\t\t\tdo {\n\t\t\t\tnumber *= 10L;\n\t\t\t\tnumber += (long) (c - '0');\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn number * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndofLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic boolean isEndofLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t}\n\n\t\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kessido\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FCardsAndJoy solver = new FCardsAndJoy();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FCardsAndJoy {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.NextInt();\n            int k = in.NextInt();\n            int[] c = in.NextIntArray(n * k);\n            int[] f = in.NextIntArray(n);\n            int[] h = new int[k+1];\n            for(int i = 0; i<k; i++) h[i+1]=in.NextInt();\n            Arrays.sort(c);\n            Arrays.sort(f);\n            int i = 0, j = 0;\n            long res = 0;\n            long[][] dp = new long[n + 1][n * k + 1];\n            for (int l = 1; l <= n; l++) {\n                for (int m = 0; m <= (l-1)*k; m++) {\n                    for (int o = 0; o <= k; o++) {\n                        if (o + m <= n * k) {\n                            dp[l][m + o] = Math.max(dp[l][m + o], dp[l-1][m] + h[o]);\n                        }\n                    }\n                }\n            }\n            while (i < n && j < n * k) {\n                if (f[i] < c[j]) {\n                    i++;\n                } else if (f[i] > c[j]) {\n                    j++;\n                } else {\n                    int countI = 0;\n                    int countJ = 0;\n                    while (i < n && f[i - countI] == f[i]) {\n                        countI++;\n                        i++;\n                    }\n                    while (j < k * n && c[j - countJ] == c[j]) {\n                        countJ++;\n                        j++;\n                    }\n                    res += dp[countI][Math.min(countJ, countI*k)];\n                }\n            }\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] NextIntArray(int n) {\n            return NextIntArray(n, 0);\n        }\n\n        public int[] NextIntArray(int n, int offset) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = NextInt() + offset;\n            }\n            return a;\n        }\n\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "from __future__ import print_function\nfrom collections import Counter\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\nsys.setrecursionlimit(10**9)\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\ndef ni():\n    return map(int, input().split())\ndef nio(offset):\n    return map(lambda x: int(x) + offset, input().split())\ndef nia():\n    return list(map(int, input().split()))\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\ndef sortId(arr):\n    return sorted(range(arr), key=lambda k: arr[k])\nn, k = ni()\nc = nia()\nf = nia()\nh = nia()\nh.insert(0,0)\ncc = Counter(c)\ncf = Counter(f)\nn1 = n+1\nk1 = k+1\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\nres = 0\nfor fk,fv in cf.items():\n    res += dp[fv][cc[fk]]\nprint(res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 6010;\nint n, k;\nint card[maxn], fav[510], joy[15];\nint dp[520][maxn];\nint f[100010], c[100010];\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  int tot = n * k;\n  for (int i = 0; i < tot; i++) {\n    scanf(\"%d\", &card[i]);\n    c[card[i]]++;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &fav[i]);\n    f[fav[i]]++;\n  }\n  for (int i = 1; i < k + 1; i++) scanf(\"%d\", &joy[i]);\n  for (int x = 0; x < n; x++)\n    for (int y = 0; y < tot; y++)\n      for (int i = 0; i < k + 1; i++) {\n        dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + joy[i]);\n      }\n  int ans = 0;\n  for (int i = 0; i < 100010; i++) {\n    if (f[i] != 0) ans += dp[f[i]][c[i]];\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nlong double PI = 4 * atan(1);\nint n, k, h[100001], first[100001], c[100001], t;\nset<int> second;\nlong long ans, dp[501][5001];\nlong long calc(int u, int v) {\n  if (!u) return 0;\n  long long& res = dp[u][v];\n  if (~res) return res;\n  res = 0;\n  for (int i = 0; i < min(v, k) + 1; i++) {\n    res = max(res, (long long)calc(u - 1, v - i) + h[i]);\n  }\n  return dp[u][v] = res;\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) cin >> t, c[t]++;\n  for (int i = 0; i < n; i++) cin >> t, first[t]++, second.insert(t);\n  for (int i = 1; i < k + 1; i++) cin >> h[i];\n  memset(dp, -1, sizeof(dp));\n  for (int a : second) {\n    ans += calc(first[a], c[a]);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 1e5 + 123, inf = 1e18, mod = 1e9 + 7, N = 360360;\nint n, k, x, cntc[maxn], cntp[maxn], ans, a[15], dp[5000][5000];\nint get(int k, int m, int n) {\n  if (n * k <= m) return a[k] * n;\n  for (int i = 0; i <= n; i++)\n    for (int j = 0; j <= m; j++) dp[i][j] = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j <= m; j++)\n      for (int q = 0; j + q <= m && q <= k; q++)\n        dp[i + 1][j + q] = max(dp[i + 1][j + q], dp[i][j] + a[q]);\n  }\n  return dp[n][m];\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    cin >> x;\n    cntc[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> x;\n    cntp[x]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> a[i];\n  for (int i = 0; i < maxn; i++) {\n    if (cntp[i] && cntc[i]) {\n      ans += get(k, cntc[i], cntp[i]);\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n/**\n * Copyright \u00a9 2018 Chris. All rights reserved.\n *\n * @author Chris\n * 2018/6/25 20:48\n * @see\n */\npublic class Main {\n\n    private static void solve(Scanner sc) {\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int m = n * k;\n        Map<Integer, Integer> card = new HashMap<>();\n        Map<Integer, Integer> f = new HashMap<>();\n        int h[] = new int[k];\n\n        for (int i = 0; i < m; i++) {\n            int c = sc.nextInt();\n            card.put(c, card.getOrDefault(c, 0) + 1);\n        }\n        for (int i = 0; i < n; i++) {\n            int val = sc.nextInt();\n            f.put(val, f.getOrDefault(val, 0) + 1);\n        }\n        for (int i = 0; i < k; i++) {\n            h[i] = sc.nextInt();\n        }\n\n        int sum = 0;\n        for (int key : f.keySet()) {\n            sum += cnt(f.get(key), card.getOrDefault(key, 0), h);\n        }\n        System.out.println(sum);\n    }\n\n    private static int cnt(int n, int k, int h[]) {\n        int contains = Math.min(n * h.length, k);\n        int dp[] = new int[contains + 1];\n\n        for (int m = n; m >= 1; m--) {\n            for (int j = contains; j >= 0; j--) {\n                for (int i = 1; i <= h.length; i++) {\n                    if (j >= i) {\n                        dp[j] = Math.max(dp[j], dp[j - i] + h[i - 1]);\n                    }\n                }\n            }\n        }\n\n        return dp[contains];\n    }\n\n    public static void main(String args[]) throws FileNotFoundException {\n        //System.setIn(new FileInputStream(\"src/in.txt\"));\n        //System.setOut(new PrintStream(\"src/out.txt\"));\n\n        Scanner sc = new Scanner(System.in);\n\n        solve(sc);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[5005][505];\nint h[12];\nint n, k;\nint getDp(int card, int people) {\n  if (dp[card][people]) return dp[card][people];\n  if (people == 1) return dp[card][people] = h[card];\n  for (int i = 0; i <= k; ++i) {\n    if (card == i) break;\n    dp[card][people] =\n        max(getDp(card - i, people - 1) + h[i], dp[card][people]);\n    ;\n  }\n  return dp[card][people];\n}\nint main() {\n  cin >> n >> k;\n  map<int, int> card;\n  map<int, int> f;\n  int x;\n  for (int i = 0; i < n * k; ++i) {\n    scanf(\"%d\", &x);\n    card[x]++;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &x);\n    f[x]++;\n  }\n  for (int i = 1; i <= k; i++) {\n    scanf(\"%d\", &h[i]);\n  }\n  int ans = 0;\n  for (auto fav : f) {\n    if (fav.second == 1) {\n      int cardNum = min(card[fav.first], k);\n      ans += h[cardNum];\n    } else {\n      int cardNum = min(card[fav.first], k * fav.second);\n      ;\n      ans += getDp(cardNum, fav.second);\n    };\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[6003][503];\nint N, K;\nint fav[100001], favcnt[100001];\nint joy[100001];\nint card[100001];\nint cnt[100001];\nint main() {\n  cin >> N >> K;\n  for (int i = 0; i < N * K; i++) {\n    cin >> card[i];\n    cnt[card[i]]++;\n  }\n  for (int i = 0; i < N; i++) {\n    cin >> fav[i];\n    favcnt[fav[i]]++;\n  }\n  for (int i = 1; i <= K; i++) cin >> joy[i];\n  for (int k = 0; k <= N; k++)\n    for (int j = 0; j <= N * K; j++)\n      for (int i = 1; i <= K; i++)\n        dp[i + j][k + 1] = max(dp[i + j][k + 1], dp[j][k] + joy[i]);\n  long long ans = 0;\n  for (int i = 1; i <= 100000; i++) ans += dp[cnt[i]][favcnt[i]];\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from __future__ import print_function\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\n# CONFIG\nsys.setrecursionlimit(10**9)\n\n# LOG\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return map(int, input().split())\n\n\ndef nio(offset):\n    return map(lambda x: int(x) + offset, input().split())\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef countMap(arr):\n    m = {}\n    for x in arr:\n        m[x] = m.get(x,0) + 1\n    return m\n\ndef sortId(arr):\n    return sorted(range(arr), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = nia()\nh.insert(0,0)\n\ncc = countMap(c)\ncf = countMap(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n    # log(dp[ni])\n\n# log(n,k)\n# log(\"c\", cc)\n# log(\"f\", cf)\n# log(\"h\", h)\n# log(dp)\n\nres = 0\n\n\nfor fk,fv in cf.items():\n    # log(fk, fv, cc.get(fk,0))\n    res += dp[fv][cc.get(fk,0)]\n\nprint(res)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e6 + 2;\nconst long long N1 = 1e2 + 2;\nconst long long mod = 1e9 + 7;\nconst int MASK = 1 << 17 + 1;\nconst int who = 6 * N * log2(N);\nlong long power(long long a, long long b, long long c) {\n  long long ret = 1;\n  while (b) {\n    if (b % 2 == 1) {\n      ret = (ret * a) % c;\n    }\n    b /= 2;\n    a = (a * a) % c;\n  }\n  return ret;\n}\nmap<int, int> ma, ma1;\nint n, k, m;\nint lev[13];\nint dp[501][5001];\nint calc(int count, int tot_avail) {\n  if (count <= 1) {\n    if (!count) return 0;\n    return lev[min(tot_avail, k)];\n  }\n  if (dp[count][tot_avail] != -1) {\n    return dp[count][tot_avail];\n  }\n  int solve = 0;\n  for (int i = 1; i <= min(k, tot_avail); i++) {\n    solve = max(solve, lev[i] + calc(count - 1, tot_avail - i));\n  }\n  return dp[count][tot_avail] = solve;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k;\n  m = n * k;\n  memset(dp, -1, sizeof(dp));\n  for (int i = 0; i < m; i++) {\n    int tm;\n    cin >> tm;\n    ma[tm]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int tm;\n    cin >> tm;\n    ma1[tm]++;\n  }\n  lev[0] = 0;\n  for (int i = 1; i <= k; i++) {\n    cin >> lev[i];\n  }\n  long long ans = 0;\n  for (auto it : ma1) {\n    int var = it.second;\n    int temp = it.first;\n    if (var <= 1) {\n      ans += lev[min(ma[temp], k)];\n      continue;\n    }\n    ans += calc(var, ma[temp]);\n  }\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint card[5001];\nint card_cnt[100001];\nint fav[501];\nint fav_cnt[100001];\nint joy[11];\nint dp[501][5001];\nint n, k;\nint f(int x, int y) {\n  if (x <= 0 || y <= 0) return 0;\n  int &ret = dp[x][y];\n  if (ret) return ret;\n  for (int i = 1; i <= min(k, y); i++) {\n    ret = max(ret, f(x - 1, y - i) + joy[i]);\n  }\n  return ret;\n}\nbool v[100001];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int i, j;\n  cin >> n >> k;\n  for (i = 0; i < n * k; i++) {\n    cin >> card[i];\n    card_cnt[card[i]]++;\n  }\n  for (i = 0; i < n; i++) {\n    cin >> fav[i];\n    fav_cnt[fav[i]]++;\n  }\n  for (i = 1; i <= k; i++) cin >> joy[i];\n  int ans = 0;\n  for (i = 0; i < n; i++) {\n    if (v[fav[i]] || fav_cnt[fav[i]] == 0) continue;\n    v[fav[i]] = true;\n    ans += f(fav_cnt[fav[i]], card_cnt[fav[i]]);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k;\n  cin >> n >> k;\n  const int C = 100001 + 10;\n  vector<int> cs(C);\n  for (int i = 0; i < n * k; ++i) {\n    int x;\n    cin >> x;\n    ++cs[x];\n  }\n  vector<int> fs(C);\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    ++fs[x];\n  }\n  vector<int> h(k + 1);\n  for (int i = 1; i <= k; ++i) cin >> h[i];\n  vector<vector<int>> dp(n + 1, vector<int>(k * (n + 1) + 1));\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j <= n * k; ++j) {\n      for (int cur = 0; cur <= k; ++cur) {\n        dp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < C; ++i) {\n    if (fs[i] != 0) ans += dp[fs[i]][cs[i]];\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\nc = list(map(int, input().split()))\nf = list(map(int, input().split()))\nh = [0] + list(map(int, input().split()))\ncnt1 = defaultdict(lambda : 0)\nfor i in c:\n    cnt1[i] += 1\ncnt2 = defaultdict(lambda : 0)\nfor i in f:\n    cnt2[i] += 1\nans = 0\nfor i in cnt2:\n    c1, c2 = cnt1[i], cnt2[i]\n    dp0 = [0]\n    l = 1\n    for _ in range(c2):\n        dp = [0] * (l + k)\n        for i in range(l):\n            dp0i = dp0[i]\n            for j in range(k + 1):\n                dp[i + j] = max(dp[i + j], dp0i + h[j])\n        l += k\n        dp0 = dp\n    ans += dp[min(c1, k * c2)]\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint color[N], like[N], h[N], f[507][5007];\nint n, k, x;\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n * k; i++) {\n    cin >> x;\n    color[x]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> x;\n    like[x]++;\n  }\n  for (int i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= i * k; j++) {\n      for (int cur = 0; cur <= k; cur++) {\n        if (j >= cur) f[i][j] = max(f[i][j], f[i - 1][j - cur] + h[cur]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= 100000; i++) {\n    if (!like[i]) continue;\n    int num = min(color[i], like[i] * k);\n    ans += f[like[i]][num];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint a[100005];\nint f[100005];\nint h[100005];\nint play[100005];\nint card[100005];\nlong long dp[505][5005];\nlong long rec(int i, int j) {\n  if (i == 0 || j == 0) return 0;\n  if (dp[i][j] != -1) return dp[i][j];\n  long long s = 0;\n  for (int q = 0; q <= k; q++)\n    if (q <= j) s = max(s, rec(i - 1, j - q) + h[q]);\n  return dp[i][j] = s;\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < n * k; i++) scanf(\"%d\", a + i);\n  for (int i = 0; i < n; i++) scanf(\"%d\", f + i);\n  for (int i = 1; i <= k; i++) scanf(\"%d\", h + i);\n  for (int i = 0; i < n; i++) play[f[i]]++;\n  for (int i = 0; i < n * k; i++) card[a[i]]++;\n  long long ans = 0;\n  for (int i = 0; i < 100005; i++)\n    if (play[i] && card[i]) {\n      memset(dp, -1, sizeof dp);\n      ans += rec(play[i], card[i]);\n    }\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class CardsAndJoy {\n\t\n\tstatic int[] joyLevels;\n\tstatic int k;\n\t\n\tpublic static long solve(int people, int cards) {\n\t\tif (people == 0 || cards == 0) return 0;\n\t\tcards = Math.min(cards, people * k);\n\t\tlong[][] lookup = new long[people + 1][cards + 1];\n\t\tfor (int j = 0; j <= cards; j++) {\n\t\t\tlookup[1][j] = joyLevels[Math.min(j, k)];\n\t\t}\n\t\tfor (int i = 2; i <= people; i++) {\n\t\t\tfor (int j = 0; j <= cards; j++) {\n\t\t\t\tfor (int m = 0; m <= j && m <= k; m++) {\n\t\t\t\t\tlong candidate = joyLevels[m] + lookup[i - 1][j - m];\n\t\t\t\t\tlookup[i][j] = Math.max(lookup[i][j], candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lookup[people][cards];\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\t\n\t\tint n = s.nextInt();\n\t\tk = s.nextInt();\n\t\t\n\t\tint[] favoriteCount = new int[500001];\n\t\tint[] cardCount = new int[500001];\n\t\tjoyLevels  = new int[k + 1];\n\t\t\n\t\t\n\t\tfor (int i = 0; i < n * k; i++) {\n\t\t\tcardCount[s.nextInt()]++;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfavoriteCount[s.nextInt()]++;\n\t\t}\n\t\t\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tjoyLevels[i + 1] = s.nextInt();\n\t\t}\n\t\t\n\t\tlong maxJoy = 0;\n\t\tfor (int i = 1; i <= 500000; i++) {\n\t\t\tmaxJoy += solve(favoriteCount[i], cardCount[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(maxJoy);\n\t\t\n\t\ts.close();\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint c[100100], f[100100], h[11], dp[550][5050];\nint n, k;\nint solve(int x) {\n  for (int i = 1; i <= f[x]; i++) {\n    for (int j = 1; j <= c[x]; j++) {\n      dp[i][j] = 0;\n      for (int l = 1; l <= j && l <= k; l++)\n        if (dp[i][j] < dp[i - 1][j - l] + h[l])\n          dp[i][j] = dp[i - 1][j - l] + h[l];\n    }\n  }\n  return dp[f[x]][c[x]];\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  int x;\n  for (int i = 1; i <= n * k; i++) {\n    scanf(\"%d\", &x);\n    c[x]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &x);\n    f[x]++;\n  }\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &h[i]);\n  int res = 0;\n  for (int i = 1; i <= 100000; i++)\n    if (f[i]) res += solve(i);\n  printf(\"%d\", res);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\n// Solution\n\npublic class Main \n{    \n  public static void main (String[] argv) \n  {\n\t  new Main();\n  } \n     \n     \n  \n  boolean test = false;  \n  \n  \n  \n  public Main() {\n\t  FastReader in = new FastReader(new BufferedReader(new InputStreamReader(System.in)));\n\t  //FastReader in = new FastReader(new BufferedReader(new FileReader(\"Main.in\")));\n      int n = in.nextInt();\n      int k = in.nextInt();\n      Map<Integer, Integer> cnt = new HashMap<>();\n      Map<Integer, Integer> map = new HashMap<>();\n      int[] joy = new int[k+1];\n      \n      int N =0;\n      \n      for(int i = 0; i < n *k; i++) {\n          int key = in.nextInt();\n          int c = 1;\n          if (cnt.containsKey(key)) c += cnt.get(key);\n          cnt.put(key, c);\n          \n          N = max(N, c);\n      }\n      \n      int M = 0;\n      for (int i = 0; i < n; i++) {\n          int key = in.nextInt();\n          int c = 1;\n          if (map.containsKey(key)) c += map.get(key);\n          map.put(key, c);\n          \n          M = max(M, c);\n      }\n      \n      \n      for (int i = 1; i <= k; i++) {\n          joy[i] = in.nextInt();\n      }\n      \n      int[][] dp = new int[N+1][M+1];\n      for (int i = 1; i <= N; i++) {\n          for (int j = 1; j <= M; j++) {\n              dp[i][j] = dp[i][j-1];\n              for (int t = 1; t <= k && t <= i; t++) {\n                  dp[i][j] = max(dp[i][j], dp[i-t][j-1] + joy[t]);                  \n              }              \n          }          \n      }\n      \n      int tot = 0;\n      for (int key : cnt.keySet()) {\n          if (map.containsKey(key)) {\n              int i = cnt.get(key);\n              int j = map.get(key);\n              tot += dp[i][j];\n          }          \n      }\n      \n      System.out.println(tot);\n  }\n  \n  \n  \n  private boolean ok(char a, char b, char c, char d) {\n      return ((a == '0' || b == '0') && c == '0' && d == '0') || \n              ((c == '0' || d == '0') && a == '0' && b == '0');\n  }\n  \n  private int nBit1(int v) {\n      int v0 = v;\n      int c = 0;\n      while (v != 0) {\n          ++c;\n          v = v & (v - 1);\n      }\n      return c;\n  }\n  \n  private int common(int v) {\n      int c = 0;\n      while (v != 1) {\n          v = (v >>> 1);\n          ++c;\n      }\n      \n      return c;\n  }\n  \n  private void reverse(char[] a, int i, int j) {\n      while (i < j) {\n          swap(a, i++, j--);\n      }\n  }\n  \n  private void swap(char[] a, int i, int j) {\n      char t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n  }\n  \n  \n  private long gcd(long x, long y) {\n      if (y == 0) return x;\n      return gcd(y, x % y);\n  }\n  private int max(int a, int b) {\n      return a >  b ? a : b;\n  }\n  \n  private int min(int a, int b) {\n      return a >  b ? b : a;\n  }\n  \n  \n  static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader(BufferedReader in)\n        {            \n            br = in;\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    String line = br.readLine();\n                    if (line == null || line.length() == 0) return \"\";\n                    st = new StringTokenizer(line);\n                }\n                catch (IOException  e)\n                {\n                    return \"\";\n                    //e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                return \"\";\n                //e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> ccnt, pcnt;\nint n, k, dp[501][501 * 11], h[11], ans;\nint main() {\n  cin >> n >> k;\n  for (int i = 0, c; i < k * n; ++i) {\n    cin >> c;\n    ccnt[c]++;\n  }\n  for (int i = 0, p; i < n; ++i) {\n    cin >> p;\n    pcnt[p]++;\n  }\n  for (int i = 1; i <= k; ++i) cin >> h[i];\n  for (int p = 1; p <= n; ++p)\n    for (int c = 1; c <= k * n; ++c)\n      for (int i = 0; i <= min(k, c); ++i)\n        dp[p][c] = max(dp[p][c], dp[p - 1][c - i] + h[i]);\n  for (auto p : pcnt) ans += dp[p.second][ccnt[p.first]];\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long t = 1, n, k, c, f, h[15], frq_c[100010], frq_f[100010], dp[505][5005],\n          ans;\nlong long rec(int person, long long card) {\n  if (person == 0) return (card ? -1e9 : 0);\n  long long &ret = dp[person][card];\n  if (ret + 1) return ret;\n  ret = 0;\n  for (int i = 0; i <= min(card, k); i++)\n    ret = max(ret, rec(person - 1, card - i) + h[i]);\n  return ret;\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) cin >> c, frq_c[c]++;\n  for (int i = 0; i < n; i++) cin >> f, frq_f[f]++;\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  for (int i = 0; i < 100010; i++)\n    if (frq_c[i] && frq_f[i])\n      memset(dp, -1, sizeof dp),\n          ans += rec(frq_f[i], min(frq_c[i], frq_f[i] * k));\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.util.stream.Stream;\nimport java.util.Map.Entry;\n\npublic class Main implements Runnable {\n    static final int MOD = (int) 1e9 + 7;\n    static final int MI = (int) 1e9;\n    static final long ML = (long) 1e18;\n    static final Reader in = new Reader();\n    static final PrintWriter out = new PrintWriter(System.out);\n    StringBuilder answer = new StringBuilder();\n\n    public static void main(String[] args) {\n        new Thread(null, new Main(), \"persefone\", 1 << 32).start();\n    }\n\n    @Override\n    public void run() {\n        solve();\n        printf();\n        flush();\n    }\n\n    void solve() {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        Map<Integer, Pair> map = new HashMap<>();\n        for (int i = 0; i < n * k; i++) {\n            map.computeIfAbsent(in.nextInt(), v -> new Pair()).addCard();\n        }\n        for (int i = 0; i < n; i++) {\n            map.computeIfPresent(in.nextInt(), (integer, pair) -> new Pair(++pair.people, pair.cards));\n        }\n\n        int[] h = new int[k + 1];\n        for (int i = 1; i <= k; i++) {\n            h[i] = in.nextInt();\n        }\n        int ans = 0;\n        for (Entry<Integer, Pair> e : map.entrySet()) {\n            Pair pair = e.getValue();\n            int people = pair.people;\n            if (people == 0) continue;\n            int cards = Math.min(people * k, pair.cards);\n            int[][] dp = new int[cards + 1][people + 1];\n            for (int i = 1; i <= cards; i++) {\n                for (int j = 1; j <= people; j++) {\n                    for (int t = 0; t <= Math.min(i, k); t++) {\n                        dp[i][j] = Math.max(dp[i][j], dp[i - t][j - 1] + h[t]);\n                    }\n                }\n            }\n            ans += dp[cards][people];\n        }\n        printf(ans);\n    }\n\n    static class Pair {\n        private int people, cards;\n\n        public Pair() {}\n\n        public Pair(int people, int cards) {\n            this.people = people;\n            this.cards = cards;\n        }\n\n        public void addPeople() {\n            people++;\n        }\n        public void addCard() {\n            cards++;\n        }\n\n        @Override\n        public String toString() {\n            return \"Pair{\" +\n                    \"people=\" + people +\n                    \", cards=\" + cards +\n                    '}';\n        }\n    }\n\n    void printf() {\n        out.print(answer);\n    }\n\n    void close() {\n        out.close();\n    }\n\n    void flush() {\n        out.flush();\n    }\n\n    void printf(Stream<?> str) {\n        str.forEach(o -> add(o, \" \"));\n        add(\"\\n\");\n    }\n\n\n    void printf(Object... obj) {\n        printf(false, obj);\n    }\n\n    void printfWithDescription(Object... obj) {\n        printf(true, obj);\n    }\n\n\n    private void printf(boolean b, Object... obj) {\n\n        if (obj.length > 1) {\n            for (int i = 0; i < obj.length; i++) {\n                if (b) add(obj[i].getClass().getSimpleName(), \" - \");\n                if (obj[i] instanceof Collection<?>) {\n                    printf((Collection<?>) obj[i]);\n                } else if (obj[i] instanceof int[][]) {\n                    printf((int[][]) obj[i]);\n                } else if (obj[i] instanceof long[][]) {\n                    printf((long[][]) obj[i]);\n                } else if (obj[i] instanceof double[][]) {\n                    printf((double[][]) obj[i]);\n                } else printf(obj[i]);\n            }\n            return;\n        }\n\n        if (b) add(obj[0].getClass().getSimpleName(), \" - \");\n        printf(obj[0]);\n    }\n\n    void printf(Object o) {\n        if (o instanceof int[])\n            printf(Arrays.stream((int[]) o).boxed());\n        else if (o instanceof char[])\n            printf(new String((char[]) o));\n        else if (o instanceof long[])\n            printf(Arrays.stream((long[]) o).boxed());\n        else if (o instanceof double[])\n            printf(Arrays.stream((double[]) o).boxed());\n        else if (o instanceof boolean[]) {\n            for (boolean b : (boolean[]) o) add(b, \" \");\n            add(\"\\n\");\n        } else\n            add(o, \"\\n\");\n    }\n\n    void printf(int[]... obj) {\n        for (int i = 0; i < obj.length; i++) printf(obj[i]);\n    }\n\n    void printf(long[]... obj) {\n        for (int i = 0; i < obj.length; i++) printf(obj[i]);\n    }\n\n    void printf(double[]... obj) {\n        for (int i = 0; i < obj.length; i++) printf(obj[i]);\n    }\n\n    void printf(boolean[]... obj) {\n        for (int i = 0; i < obj.length; i++) printf(obj[i]);\n    }\n\n    void printf(Collection<?> col) {\n        printf(col.stream());\n    }\n\n    <T, K> void add(T t, K k) {\n        if (t instanceof Collection<?>) {\n            ((Collection<?>) t).forEach(i -> add(i, \" \"));\n        } else if (t instanceof Object[]) {\n            Arrays.stream((Object[]) t).forEach(i -> add(i, \" \"));\n        } else\n            add(t);\n        add(k);\n    }\n\n\n    <T> void add(T t) {\n        answer.append(t);\n    }\n\n    static class Reader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        Reader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        Reader(String fileName) throws FileNotFoundException {\n            br = new BufferedReader(new FileReader(fileName));\n        }\n\n        boolean isReady() throws IOException {\n            return br.ready();\n        }\n\n        String next() {\n            try {\n                while (st == null || !st.hasMoreTokens()) {\n                    st = new StringTokenizer(br.readLine());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextInt();\n            return arr;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        String nextLine() {\n            String s = \"\";\n            try {\n                s = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return s;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint cnt[100005], h[15], memo[5005][505];\nint DP(int rem, int group) {\n  if (group == 0 || rem == 0) {\n    return 0;\n  } else if (memo[rem][group] != -1) {\n    return memo[rem][group];\n  } else {\n    int ret = 0;\n    for (int i = 1; i <= min(k, rem); i++) {\n      ret = max(ret, DP(rem - i, group - 1) + h[i]);\n    }\n    return memo[rem][group] = ret;\n  }\n}\nint main() {\n  int ans = 0;\n  map<int, int> mp;\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0, in; i < n * k; i++) {\n    scanf(\"%d\", &in);\n    cnt[in]++;\n  }\n  for (int i = 0, in; i < n; i++) {\n    scanf(\"%d\", &in);\n    mp[in]++;\n  }\n  for (int i = 1; i <= k; i++) {\n    scanf(\"%d\", h + i);\n  }\n  for (auto it = mp.begin(); it != mp.end(); it++) {\n    memset(memo, -1, sizeof(memo));\n    ans += DP(min(cnt[it->first], it->second * k), it->second);\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T, size_t N>\nostream& operator<<(ostream& os, const array<T, N>& v);\ntemplate <class T1, class T2>\nostream& operator<<(ostream& os, const pair<T1, T2>& p) {\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  bool f = 1;\n  os << \"[\";\n  for (auto& i : v) {\n    if (!f) os << \", \";\n    os << i;\n    f = 0;\n  }\n  return os << \"]\";\n}\ntemplate <class T, size_t N>\nostream& operator<<(ostream& os, const array<T, N>& v) {\n  bool f = 1;\n  os << \"[\";\n  for (auto& i : v) {\n    if (!f) os << \", \";\n    os << i;\n    f = 0;\n  }\n  return os << \"]\";\n}\ntemplate <class T1, class T2>\nostream& operator<<(ostream& os, const set<T1, T2>& v) {\n  bool f = 1;\n  os << \"[\";\n  for (auto& i : v) {\n    if (!f) os << \", \";\n    os << i;\n    f = 0;\n  }\n  return os << \"]\";\n}\ntemplate <class T1, class T2>\nostream& operator<<(ostream& os, const multiset<T1, T2>& v) {\n  bool f = 1;\n  os << \"[\";\n  for (auto& i : v) {\n    if (!f) os << \", \";\n    os << i;\n    f = 0;\n  }\n  return os << \"]\";\n}\ntemplate <class T1, class T2, class T3>\nostream& operator<<(ostream& os, const map<T1, T2, T3>& v) {\n  bool f = 1;\n  os << \"[\";\n  for (auto& ii : v) {\n    if (!f) os << \", \";\n    os << \"(\" << ii.first << \" -> \" << ii.second << \") \";\n    f = 0;\n  }\n  return os << \"]\";\n}\ntemplate <class T1, class T2>\nostream& operator<<(ostream& os, const multimap<T1, T2>& v) {\n  bool f = 1;\n  os << \"[\";\n  for (auto& ii : v) {\n    if (!f) os << \", \";\n    os << \"(\" << ii.first << \" -> \" << ii.second << \") \";\n    f = 0;\n  }\n  return os << \"]\";\n}\ntemplate <class T1, class T2>\nostream& operator<<(ostream& os, priority_queue<T1, T2> v) {\n  bool f = 1;\n  os << \"[\";\n  while (!v.empty()) {\n    auto x = v.top();\n    v.pop();\n    if (!f) os << \", \";\n    f = 0;\n    os << x;\n  }\n  return os << \"]\";\n}\ntemplate <class T1, class T2>\nvoid printarray(const T1& a, T2 sz, T2 beg = 0) {\n  for (T2 i = beg; i < sz; i++) cout << a[i] << \" \";\n  cout << endl;\n}\nint N, K;\nlong long c[100500], f[100500], h[100500];\nlong long dp[5050][5050];\nlong long getdp(long long a, long long b) {\n  if (b == 0) return 0;\n  if (a == 0) return 0;\n  long long& res = dp[a][b];\n  if (res != -1) return res;\n  res = 0;\n  for (int i = 0; i <= min(a, 1LL * K); i++) {\n    res = max(res, h[i] + getdp(a - i, b - 1));\n  }\n  return res;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> N >> K;\n  memset(dp, -1, sizeof dp);\n  for (int i = 1; i <= N * K; i++) {\n    int x;\n    cin >> x;\n    c[x]++;\n  }\n  for (int i = 1; i <= N; i++) {\n    int x;\n    cin >> x;\n    f[x]++;\n  }\n  for (int i = 1; i <= K; i++) cin >> h[i];\n  long long ans = 0;\n  for (int i = 1; i <= 100000; i++) {\n    ans += getdp(c[i], f[i]);\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, v, cnt, mx;\nunordered_map<int, int> frq, play, cost;\nint mem[600][6000];\nint dp(int i, int sum) {\n  if (i == cnt) {\n    return 0;\n  }\n  int& ret = mem[i][sum];\n  if (~ret) return ret;\n  ret = 0;\n  for (int j = 1; j <= k; j++) {\n    if (sum - j >= 0) {\n      ret = max(ret, cost[j] + dp(i + 1, sum - j));\n    }\n  }\n  return ret;\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    cin >> v;\n    frq[v]++;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> v;\n    play[v]++;\n  }\n  for (int i = 1; i <= k; i++) {\n    cin >> cost[i];\n  }\n  int sum = 0;\n  for (auto i : play) {\n    memset(mem, -1, sizeof mem);\n    cnt = i.second, mx = frq[i.first];\n    sum += dp(0, mx);\n  }\n  cout << sum;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 505;\nconst int MAXK = 12;\nconst int MAXV = 1e5 + 5;\nint N, K;\nint card[MAXV];\nint fav[MAXV];\nint joy[MAXK];\nint dp[MAXV];\nint solve(int player, int freq) {\n  memset(dp, 0xaf, sizeof dp);\n  dp[0] = 0;\n  for (int a = 0; a < player; a++) {\n    for (int b = freq; b >= 0; b--) {\n      for (int c = 0; c <= K && c <= b; c++) {\n        dp[b] = max(dp[b], dp[b - c] + joy[c]);\n      }\n    }\n  }\n  return *max_element(dp, dp + MAXV);\n}\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n  cin >> N >> K;\n  for (int a = 1; a <= N * K; a++) {\n    int x;\n    cin >> x;\n    card[x]++;\n  }\n  for (int a = 1; a <= N; a++) {\n    int x;\n    cin >> x;\n    fav[x]++;\n  }\n  for (int a = 1; a <= K; a++) {\n    cin >> joy[a];\n  }\n  int ans = 0;\n  for (int a = 0; a < MAXV; a++) {\n    if (card[a] != 0 && fav[a] != 0) {\n      ans += solve(fav[a], card[a]);\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int maxm = 5e2 + 10;\nint dp[maxm * 10][maxm], h[20], card[maxm * 10], f[maxm], num[100010],\n    peo[100010];\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n * k; i++) {\n    scanf(\"%d\", &card[i]);\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &f[i]);\n    peo[f[i]]++;\n  }\n  for (int i = 1; i <= k; i++) {\n    scanf(\"%d\", &h[i]);\n  }\n  for (int i = 1; i <= n * k; i++) {\n    for (int j = 1; j <= n; j++) {\n      for (int z = 0; z <= k && z <= i; z++) {\n        dp[i][j] = max(h[z] + dp[i - z][j - 1], dp[i][j]);\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n * k; i++) {\n    num[card[i]]++;\n    ans -= dp[num[card[i]] - 1][peo[card[i]]];\n    ans += dp[num[card[i]]][peo[card[i]]];\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# ---------------------------iye ha aam zindegi---------------------------------------------\nimport math\nimport random\nimport heapq,bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\nthreading.stack_size(10**8)\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\n# ------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nsys.setrecursionlimit(300000)\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n        \"\"\"\n        Side effect!!! Changes node. Node should have exactly one child\n        \"\"\"\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\n\n# -----------------------------------------------binary seacrh tree---------------------------------------\nclass SegmentTree1:\n    def __init__(self, data, default=2**51, func=lambda a, b: a & b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a,b:max(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------------------iye ha chutiya zindegi-------------------------------------\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\n\n# --------------------------------------iye ha combinations ka zindegi---------------------------------\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n // 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\n\n# --------------------------------------iye ha power ka zindegi---------------------------------\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\n\n# --------------------------------------------------product----------------------------------------\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\n\n# --------------------------------------------------binary----------------------------------------\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) / 2)\n\n        # Check if middle element is\n        # less than or equal to key\n        if (arr[mid] < key):\n            count = mid + 1\n            left = mid + 1\n\n        # If key is smaller, ignore right half\n        else:\n            right = mid - 1\n\n    return count\n\n\n# --------------------------------------------------binary----------------------------------------\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    # Stores the index of the left most element\n    # from the array which is greater than k\n    leftGreater = n\n\n    # Finds number of elements greater than k\n    while (l <= r):\n        m = int(l + (r - l) / 2)\n        if (arr[m] >= k):\n            leftGreater = m\n            r = m - 1\n\n        # If mid element is less than\n        # or equal to k update l\n        else:\n            l = m + 1\n\n    # Return the count of elements\n    # greater than k\n    return (n - leftGreater)\n\n\n# --------------------------------------------------binary------------------------------------\nfor ik in range(1):\n    n,k=map(int,input().split())\n    cards=list(map(int,input().split()))\n    l=list(map(int,input().split()))\n    h=list(map(int,input().split()))\n    h=[0]+h\n    count=defaultdict(int)\n    rt=defaultdict(int)\n    def find(x,y):\n        dp=[[0 for i in range(y+1)]for i in range(x+1)]\n        for i in range(1,x+1):\n            for j in range(y+1):\n                for t in range(min(j+1,k+1)):\n                    dp[i][j]=max(dp[i][j],dp[i-1][j-t]+h[t])\n        return dp[x][y]\n    for i in range(n*k):\n        count[cards[i]]+=1\n    for i in range(n):\n        rt[l[i]]+=1\n    ans=0\n    for i in rt:\n        if count[i]==0:\n            continue\n        ans+=find(rt[i],count[i])\n    print(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long p = 1000000007;\nconst int N = 501;\nconst int K = 11;\nint n, k;\nint cards[N * K];\nint m[2 * 100000 + 1];\nint amount[N * K];\nint fav[N * K];\nint dp[N][N * K];\nint h[K + 1];\nint DP(int card) {\n  for (int i = 0; i < amount[card]; i++) dp[0][i] = 0;\n  for (int a = 1; a < fav[card] + 1; a++) {\n    for (int b = 0; b < amount[card] + 1; b++) {\n      int mx = 0;\n      for (int j = 0; j < min(b, k) + 1; j++) {\n        mx = max(dp[a - 1][b - j] + h[j], mx);\n      }\n      dp[a][b] = mx;\n    }\n  }\n  return dp[fav[card]][amount[card]];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    cin >> cards[i];\n  }\n  sort(cards, cards + k * n);\n  int it = 1;\n  int i = 1;\n  while (i < k * n) {\n    if (cards[i] != cards[i - 1]) {\n      m[cards[i - 1]] = it;\n      it++;\n    }\n    i++;\n  }\n  m[cards[n * k - 1]] = it;\n  for (int i = 0; i < n * k; i++) amount[m[cards[i]]]++;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    fav[m[x]]++;\n  }\n  for (int i = 0; i < k; i++) cin >> h[i + 1];\n  int result = 0;\n  for (int i = 1; i < it + 1; i++) {\n    result += DP(i);\n  }\n  cout << result << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntemplate <typename T, typename TT>\ninline ostream &operator<<(ostream &os, const pair<T, TT> &t) {\n  return os << t.first << \" \" << t.second;\n}\ntemplate <typename T>\ninline ostream &operator<<(ostream &os, const vector<T> &t) {\n  for (auto i : t) os << i << \" \";\n  return os;\n}\ntemplate <typename T>\ninline istream &operator>>(istream &is, vector<T> &v) {\n  for (T &t : v) is >> t;\n  return is;\n}\ntemplate <typename T1, typename T2>\ninline istream &operator>>(istream &is, pair<T1, T2> &t) {\n  is >> t.first >> t.second;\n  return is;\n}\nconst long long mod = 1e9 + 7;\nvoid solve() {\n  int n, k, ans = 0;\n  cin >> n >> k;\n  vector<int> v(n * k);\n  cin >> v;\n  vector<int> fav(n);\n  cin >> fav;\n  vector<int> h(k);\n  cin >> h;\n  vector<int> cnt(1e5 + 5), done(1e5 + 5);\n  for (int i = 0; i < n * k; i++) cnt[v[i]]++;\n  for (int i = 0; i < n; i++) {\n    if (!done[fav[i]]) {\n      done[fav[i]] = 1;\n      vector<vector<int> > dp(n + 1, vector<int>(cnt[fav[i]] + 1, -1e9));\n      dp[0][0] = 0;\n      for (int j = 1; j <= n; j++) {\n        for (int used = 0; used <= cnt[fav[i]]; used++) {\n          dp[j][used] = dp[j - 1][used];\n          for (int l = 1; l <= k and used - l >= 0; l++)\n            dp[j][used] =\n                max(dp[j][used],\n                    dp[j - 1][used - l] + h[l - 1] * (fav[j - 1] == fav[i]));\n        }\n      };\n      ans += dp[n][cnt[fav[i]]];\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  ;\n  long long T = 1;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[1000][10 * 1000], c[1000], f[1000], h[1000];\nint dd[10000006], d[1000006];\nlong long ans = 0;\nint n, k;\nint main() {\n  memset(dd, 0, sizeof(dd));\n  memset(d, 0, sizeof(d));\n  ios_base::sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 1; i <= n * k; i++) {\n    int x;\n    cin >> x;\n    dd[x]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    d[x]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  memset(dp, 0, sizeof(dp));\n  for (int i = 1; i <= n; i++)\n    for (int j = 0; j <= n * k; j++)\n      for (int t = 0; t <= min(k, j); t++)\n        dp[i][j] = max(dp[i][j], dp[i - 1][j - t] + h[t]);\n  for (int i = 1; i <= 1e5 + 10; i++) ans += dp[d[i]][dd[i]];\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class Dp_div3_F {\n\tstatic int n, m;\n\tstatic int[] ar1 = new int[200005];\n\tstatic int[] ar2 = new int[200005];\n\tstatic int[] ar3 = new int[200005];\n\tstatic long[][] dp = new long[501][501*10+2];\n\n\tpublic static void main(String[] args) {\n\t\tfor (int i = 0; i < 200002; i++)\n\t\t\tar1[i] = 0;\n\t\tfor (int i = 0; i < 200002; i++)\n\t\t\tar2[i] = 0;\n\t\tfor (int i = 0; i < 200002; i++)\n\t\t\tar3[i] = 0;\n\t\tfor (int i = 0; i < 501; i++) {\n\t\t\tfor (int j = 0; j < 501*10; j++)\n\t\t\t\tdp[i][j] = -1;\n\t\t}\n\t\tScanner tt = new Scanner(System.in);\n\t\tn = tt.nextInt();\n\t\tm = tt.nextInt();\n\t\tfor (int i = 0; i < n * m; i++) {\n\t\t\tint a = tt.nextInt();\n\t\t\tar1[a]++;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = tt.nextInt();\n\t\t\tar2[a]++;\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tar3[i] = tt.nextInt();\n\t\t}\n\t\tLong tot = 0L;\n\t\tfor (int i = 1; i <= 100000; i++) {\n\t\t\tint pp = ar2[i];\n\t\t\tint cc = ar1[i];\n\t\t\ttot += solve(pp, cc);\n\t\t}\n\t\tSystem.out.println(tot);\n\n\t}\n\n\tprivate static Long solve(int pp, int cc) {\n\t\t// TODO Auto-generated method stub\n\t\tif (cc < 0)\n\t\t\treturn Long.MIN_VALUE;\n\t\tif (pp == 0)\n\t\t\treturn 0L;\n\t\tif (dp[pp][cc] != -1)\n\t\t\treturn (long) dp[pp][cc];\n\t\tLong ret = 0L;\n\t\tfor (int i = 0; i <= m; i++) {\n\t\t\tint val = 0;\n\t\t\tif (i == 0)\n\t\t\t\tval = 0;\n\t\t\telse\n\t\t\t\tval = ar3[i - 1];\n\t\t\tret = Math.max(ret, val + solve(pp - 1, cc - i));\n\t\t}\n\t\tdp[pp][cc] = ret;\n\t\treturn ret;\n\t\t// return null;\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\nusing namespace std;\nconst int N = (int)1e5 + 34;\nconst int M = 12;\nconst int INF = (int)1e9 + 41;\nconst long long MD = (long long)1e9 + 7;\nbool D = false;\ninline void mxe(int &a, int b) {\n  if (b > a) a = b;\n}\nint dp[5001][501];\nint solve(int n, int k, const vector<int> &h) {\n  if (n == 0 || k == 0) return 0;\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= k; j++) {\n      dp[i][j] = -INF;\n    }\n  }\n  dp[0][0] = 0;\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j < k; j++) {\n      int curDp = dp[i][j];\n      if (curDp == -INF) continue;\n      for (int x = 0; x < (int)h.size() && i + x <= n; x++) {\n        mxe(dp[i + x][j + 1], curDp + h[x]);\n      }\n    }\n  }\n  int ans = -INF;\n  for (int i = 0; i <= n; i++) {\n    mxe(ans, dp[i][k]);\n  }\n  return ans;\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> num(N, 0);\n  for (int i = 0; i < n * k; i++) {\n    int x;\n    cin >> x;\n    num[x]++;\n  }\n  vector<int> chel(N, 0);\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    chel[x]++;\n  }\n  vector<int> h(k + 1, 0);\n  for (int i = 0; i < k; i++) {\n    cin >> h[i + 1];\n  }\n  int ans = 0;\n  for (int i = 0; i < N; i++) {\n    ans += solve(num[i], chel[i], h);\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int tst = 1;\n  while (tst--) solve();\n}\n"
        },
        {
            "language": 1,
            "solution": "def func():\n    N = 520\n    K = 12\n    C = 100 * 1000 + 11\n    n, k = [int(x) for x in list(raw_input().split(' '))]\n    c = [0 for _ in range(C)]\n    f = [0 for _ in range(C)]\n\n    dp = [[0 for _ in range(K*(N))] for _ in range(N)]\n\n    a = [int(x) for x in list(raw_input().split(' '))]\n    for x in a:\n        c[x] += 1\n\n    b = [int(x) for x in list(raw_input().split(' '))]\n    for x in b:\n        f[x] += 1\n\n    h = [0]+[int(x) for x in list(raw_input().split(' '))]\n\n    for i in range(n):\n        for j in range(n*k + 1):\n            for cur in range(k+1):\n                dp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur])\n\n    ans = 0\n    for i in range(C):\n        if f[i] != 0:\n            ans += dp[f[i]][c[i]]\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    print(func())\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7, siz = 1e6 + 5;\nlong long t, n, m, k, a[siz], h[siz], fav[siz], have[siz], dp[505][5005];\nlong long go(long long rest, long long lft) {\n  if (rest == 0 or lft == 0) return 0;\n  if (dp[rest][lft] != -1) return dp[rest][lft];\n  long long ret = 0;\n  for (long long i = 0; i <= min(lft, k); i++) {\n    ret = max(ret, h[i] + go(rest - 1, lft - i));\n  }\n  return dp[rest][lft] = ret;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (long long i = 1; i <= n * k; i++) {\n    long long x;\n    cin >> x;\n    have[x]++;\n  }\n  for (long long i = 1; i <= n; i++) {\n    long long x;\n    cin >> x;\n    fav[x]++;\n  }\n  for (long long i = 1; i <= k; i++) cin >> h[i];\n  long long ans = 0;\n  memset(dp, -1, sizeof dp);\n  for (long long i = 1; i <= 1e5; i++) {\n    if (fav[i] == 0) continue;\n    ans += go(fav[i], have[i]);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid func(void) {\n  freopen(\"input.c\", \"r\", stdin);\n  freopen(\"output.c\", \"w\", stdout);\n}\nlong long n, k;\nconst int N = 1e5 + 100;\nlong long cardCount[N];\nlong long fav[N];\nlong long kCount[N];\nlong long dp[502][5002];\nlong long akhon;\nlong long given;\nvector<long long> v, favNum, kk;\nlong long calc(int i, long long ache) {\n  if (i == 0) return 0;\n  if (dp[i][ache] != -1) return dp[i][ache];\n  long long dau = min(k, ache);\n  long long x = 0;\n  for (int j = 1; j <= dau; j++) {\n    x = max(x, kCount[j] + calc(i - 1, ache - j));\n  }\n  return dp[i][ache] = x;\n}\nint main() {\n  long long q, i, j = 0, temp, t, ans = 0, sum = 0, x, y, z, cnt = 0, m, fg = 0,\n                  mx = 0, mx1 = 0, mn = 8000000000000000000,\n                  mn1 = 8000000000000000000;\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    cin >> x;\n    v.push_back(x);\n    cardCount[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> x;\n    favNum.push_back(x);\n    fav[x]++;\n  }\n  for (int i = 0; i < k; i++) {\n    cin >> x;\n    kk.push_back(x);\n    kCount[i + 1] = x;\n  }\n  memset((dp), -1, sizeof(dp));\n  for (int i = 0; i < N; i++) {\n    if (fav[i]) {\n      given = fav[i];\n      ans += calc(given, cardCount[i]);\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nconst long long int MOD = 1e9 + 7, INF = 1e18;\nlong long int dx[8] = {0, -1, 1, 0, 1, -1, 1, -1},\n              dy[8] = {1, 0, 0, -1, -1, -1, 1, 1};\nstruct edge {\n  long long int cost;\n  long long int u, v;\n};\nlong long int N, K, A;\nmap<long long int, long long int> cnt;\nmap<long long int, long long int> p_cnt;\nlong long int score[10];\nint main() {\n  cin >> N >> K;\n  for (long long int i = (0), i_end_ = (N * K); i < i_end_; i++) {\n    cin >> A;\n    A--;\n    cnt[A]++;\n  }\n  for (long long int i = (0), i_end_ = (N); i < i_end_; i++) {\n    cin >> A;\n    A--;\n    p_cnt[A]++;\n  }\n  for (long long int i = (0), i_end_ = (K); i < i_end_; i++) {\n    cin >> score[i];\n  }\n  long long int ans = 0;\n  for (auto itr : p_cnt) {\n    vector<vector<long long int>> dp(itr.second + 1,\n                                     vector<long long int>(cnt[itr.first] + 1));\n    for (long long int i = (0), i_end_ = (itr.second); i < i_end_; i++) {\n      for (long long int j = (0), j_end_ = (cnt[itr.first] + 1); j < j_end_;\n           j++) {\n        for (long long int k = (0), k_end_ = (K + 1); k < k_end_; k++) {\n          if (k == 0)\n            chmax(dp[i + 1][j], dp[i][j]);\n          else if (j + k <= cnt[itr.first])\n            chmax(dp[i + 1][j + k], dp[i][j] + score[k - 1]);\n        }\n      }\n    }\n    ans += dp[itr.second][cnt[itr.first]];\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\nvoid debugi(vector<int>& vec) {\n  int n = (int)vec.size();\n  for (int i = 0; i < n; i++) {\n    cout << vec[i] << \" \";\n  }\n  cout << endl;\n}\nvoid debugl(vector<ll>& vec) {\n  int n = (int)vec.size();\n  for (int i = 0; i < n; i++) {\n    cout << vec[i] << \" \";\n  }\n  cout << endl;\n}\nvoid debugmap(map<int, int>& mp) {\n  for (auto x : mp) {\n    cout << x.first << \" \" << x.second << \" , \";\n  }\n  cout << endl;\n}\nvoid debugset(set<int>& st) {\n  for (auto x : st) {\n    cout << x << \" \";\n  }\n  cout << endl;\n}\nvoid debugparri(vector<pair<int, int>>& arr) {\n  for (int i = 0; i < (int)arr.size(); i++) {\n    cout << \"[\" << arr[i].first << \" : \" << arr[i].second << \"]\"\n         << \" \";\n  }\n  cout << endl;\n}\nvoid debugpi(pair<int, int>& pi) {\n  cout << pi.first << \" \" << pi.second << endl;\n}\nvoid debugq(queue<int> q) {\n  while (!q.empty()) {\n    cout << q.front() << \" \";\n    q.pop();\n  }\n  cout << endl;\n}\nbool check(int n, int i, int j) {\n  if ((0 <= i & i < n) && (0 <= j & j < n)) {\n    return true;\n  }\n  return false;\n}\nll MOD = 1e9 + 7;\nll powab(ll a, ll b, ll mod) {\n  if (b == 0) {\n    return 1;\n  }\n  ll z = powab(a, b / 2, mod);\n  ll res = (z * z * 1LL) % mod;\n  if (b & 1) {\n    res = (res * 1LL * a) % mod;\n  }\n  return res;\n}\nvoid upd(int k, int x, vector<int>& tree, int n) {\n  if (k == 0) {\n    return;\n  }\n  while (k <= n) {\n    tree[k] += x;\n    k += (k & -k);\n  }\n}\nint sum(int k, vector<int>& tree, int n) {\n  int s = 0;\n  while (k >= 1) {\n    s += tree[k];\n    k -= (k & -k);\n  }\n  return s;\n}\nll gcd(ll a, ll b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\nint lim = 100005;\nll mod = 1e9 + 7;\nvector<int> h(lim);\nint dia = 0;\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  map<int, int> mp;\n  for (int i = 0; i < n * k; i++) {\n    int x;\n    cin >> x;\n    mp[x] += 1;\n  }\n  map<int, int> pl;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    pl[x] += 1;\n  }\n  vector<int> h(k);\n  for (int i = 0; i < k; i++) {\n    cin >> h[i];\n  }\n  vector<vector<int>> dp(n * k + 5, vector<int>(n + 2, 0));\n  int lim = n * k;\n  for (int people = 1; people <= n; people++) {\n    for (int i = 0; i < lim + 2; i++) {\n      int maxx = 0;\n      for (int j = 0; j < k; j++) {\n        if (i - j - 1 >= 0) {\n          int cur = h[j] + dp[i - (j + 1)][people - 1];\n          maxx = max(cur, maxx);\n        }\n      }\n      dp[i][people] = maxx;\n    }\n  }\n  ll ans = 0;\n  for (auto x : pl) {\n    int players = x.second;\n    int cards = mp[x.first];\n    int nax = min(cards, players * k);\n    ans += dp[nax][players];\n  }\n  cout << ans << endl;\n}\nint main(int argc, const char* argv[]) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  t = 1;\n  for (int tt = 0; tt < t; tt++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nfrom collections import defaultdict\n\n\ndef main():\n    n, k = map(int, input().split())\n    cards = list(map(int, input().split()))\n    fav = list(map(int, input().split()))\n\n    h = [0] + list(map(int, input().split()))\n\n    cards_cnt = defaultdict(int)\n    for val in cards:\n        cards_cnt[val] += 1\n\n    players_fav_cnt = defaultdict(int)\n    for val in fav:\n        players_fav_cnt[val] += 1\n\n    # dp[a][b] - a players, b favourite cards (in total)\n    dp = [[0 for _ in range(k*n+k+1)] for _ in range(n+1)]\n    for p in range(n):\n        for c in range(k*n+1):\n            for hand in range(k+1):\n                dp[p+1][c+hand] = max(dp[p+1][c+hand], dp[p][c] + h[hand])\n\n    res = 0\n    for f in players_fav_cnt:\n        res += dp[players_fav_cnt[f]][cards_cnt[f]]\n\n    print(res)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 3,
            "solution": "n,k= map(int,input().split(' '))\nl= list(map(int,input().split(' ')))\nf =list(map(int,input().split(' ')))\nh=list(map(int,input().split(' ')))\nd1=dict({(a,0) for a in f})\nd2=dict({(a,0) for a in f})\nfor a in l:\n\tif(a in d1):d1[a]+=1\nfor a in f:\n\td2[a]+=1\n#print(d1,d2)\ndp = [[0 for i in range(520*12)] for j in range(520)]\n#print(len(dp), len(dp[0]))\nfor x in range(n+1):\n\tfor y in range(n*k+1):\n\t\tfor i in range(k+1):\n\t\t\t\tdp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) )\nss=0\nfor i in d1:\n\t#print(dp[d1[i]][d2[i]])\n\tss+=dp[d2[i]][d1[i]]\nprint(ss)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint solve() {\n  int n, k;\n  cin >> n >> k;\n  int cnt[100001] = {0}, f[100001] = {0};\n  for (int j = 0; j < n * k; j++) {\n    int c;\n    cin >> c;\n    f[c]++;\n  }\n  for (int j = 0; j < n; j++) {\n    int c;\n    cin >> c;\n    cnt[c]++;\n  }\n  vector<int> h(k + 1);\n  h[0] = 0;\n  for (int j = 1; j <= k; j++) {\n    cin >> h[j];\n  }\n  int ans = 0;\n  for (int d = 1; d <= 1e5; d++) {\n    if ((!cnt[d]) || (!f[d])) continue;\n    vector<vector<int>> dp(cnt[d] + 1, vector<int>(f[d] + 1, 0));\n    for (int j = 0; j <= min(k, f[d]); j++) {\n      dp[1][j] = h[j];\n    }\n    for (int i = 2; i <= cnt[d]; i++) {\n      for (int j = 0; j <= min(k * i, f[d]); j++) {\n        int mx = -1;\n        for (int t = 0; t <= min(j, k); t++) {\n          mx = max(mx, dp[i - 1][j - t] + h[t]);\n        }\n        dp[i][j] = mx;\n      }\n    }\n    int mx = -1;\n    for (int j = 0; j <= min(cnt[d] * k, f[d]); j++) {\n      mx = max(mx, dp[cnt[d]][j]);\n    }\n    ans += mx;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t;\n  t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tprivate static final int TYPES = 100001;\n\n\tpublic static void solve(FastIO io) {\n\t\tint N = io.nextInt();\n\t\tint K = io.nextInt();\n\t\tint[] C = io.nextIntArray(N * K);\n\t\tint[] F = io.nextIntArray(N);\n\t\tint[] H = io.nextIntArray(K, 1);\n\n\t\tint[] freqC = new int[TYPES + 1];\n\t\tfor (int v : C) {\n\t\t\t++freqC[v];\n\t\t}\n\n\t\tint[] freqF = new int[TYPES + 1];\n\t\tfor (int v : F) {\n\t\t\t++freqF[v];\n\t\t}\n\n\t\tlong best = 0;\n\t\tfor (int i = 1; i <= TYPES; ++i) {\n\t\t\tif (freqC[i] > 0 && freqF[i] > 0) {\n\t\t\t\tbest += get(freqF[i], Math.min(freqC[i], freqF[i] * K), H);\n\t\t\t}\n\t\t}\n\t\tio.println(best);\n\t}\n\n\tprivate static long get(int P, int X, int[] H) {\n\t\tlong[][] dp = new long[P + 1][X + 1];\n\t\tdp[0][X] = 0;\n\t\tfor (int i = 1; i <= P; ++i) {\n\t\t\tfor (int j = 0; j <= X; ++j) {\n\t\t\t\tfor (int k = 0; k < H.length && j + k <= X; ++k) {\n\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], H[k] + dp[i - 1][j + k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[P][0];\n\t}\n\n\tpublic static class FastIO {\n\t\tprivate InputStream reader;\n\t\tprivate PrintWriter writer;\n\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastIO(InputStream r, OutputStream w) {\n\t\t\treader = r;\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(w)));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = reader.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\treturn nextIntArray(n, 0);\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n, int off) {\n\t\t\tint[] arr = new int[n + off];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i + off] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\treturn nextLongArray(n, 0);\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n, int off) {\n\t\t\tlong[] arr = new long[n + off];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i + off] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic void print(Object... objects) {\n\t\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\twriter.print(' ');\n\t\t\t\t}\n\t\t\t\twriter.print(objects[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void println(Object... objects) {\n\t\t\tprint(objects);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void printArray(int[] arr) {\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\twriter.print(' ');\n\t\t\t\t}\n\t\t\t\twriter.print(arr[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void printArray(long[] arr) {\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\twriter.print(' ');\n\t\t\t\t}\n\t\t\t\twriter.print(arr[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void printlnArray(int[] arr) {\n\t\t\tprintArray(arr);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void printlnArray(long[] arr) {\n\t\t\tprintArray(arr);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void printf(String format, Object... args) {\n\t\t\tprint(String.format(format, args));\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\twriter.flush();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFastIO io = new FastIO(System.in, System.out);\n\t\tsolve(io);\n\t\tio.flush();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ans, n, k, h[11], cnt[100005], f[100005], dp[505][5015];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> k;\n  for (long long i = 0, x; i < n * k; i++) cin >> x, cnt[x]++;\n  for (long long i = 0, x; i < n; i++) cin >> x, f[x]++;\n  for (long long i = 1; i <= k; i++) cin >> h[i];\n  for (long long i = 0; i < n; i++)\n    for (long long j = 0; j <= n * k; j++)\n      for (long long cur = 0; cur <= k; cur++)\n        dp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n  for (long long i = 0; i < 100005; i++)\n    if (f[i]) ans += dp[f[i]][cnt[i]];\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint d[505][5005];\nint h[15];\nint cnt[100005];\nmap<int, int> nd;\nvoid init() {}\nint main() {\n  cin >> n >> k;\n  for (int i = (0); i < (int)(n * k); i++) {\n    int t;\n    scanf(\"%d\", &t);\n    cnt[t]++;\n  }\n  for (int i = (1); i <= (int)(n); i++) {\n    int t;\n    scanf(\"%d\", &t);\n    nd[t]++;\n  }\n  for (int i = (1); i <= (int)(k); i++) scanf(\"%d\", h + i);\n  for (int i = (1); i <= (int)(n); i++) {\n    for (int j = (0); j <= (int)(n * k); j++) {\n      for (int t = (0); t <= (int)(k); t++) {\n        if (j >= t) d[i][j] = max(d[i][j], d[i - 1][j - t] + h[t]);\n      }\n    }\n  }\n  long long ans = 0;\n  for (auto &t : nd) {\n    ans += d[t.second][min(t.second * k, cnt[t.first])];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 555;\nint n, k;\nint h[20];\nmap<int, pair<int, int>> m;\nlong long ans = 0;\nint dp[N][10 * N];\nint dpsolve(int people, int cards) {\n  if (people == 0 || cards == 0) return 0;\n  cards = min(people * k, cards);\n  if (dp[people][cards] != 0) return dp[people][cards];\n  int &ref = dp[people][cards];\n  for (int i = 0; i <= min(cards, k); i++) {\n    ref = max(ref, h[i] + dpsolve(people - 1, cards - i));\n  }\n  return ref;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n * k; i++) {\n    int c;\n    scanf(\"%d\", &c);\n    m[c].second++;\n  }\n  for (int i = 0; i < n; i++) {\n    int f;\n    scanf(\"%d\", &f);\n    m[f].first++;\n  }\n  for (int i = 1; i <= k; i++) {\n    scanf(\"%d\", &h[i]);\n  }\n  for (auto &p : m) {\n    ans += dpsolve(p.second.first, p.second.second);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, K, NK;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> N >> K;\n  NK = N * K;\n  vector<int> C(NK), F(N), H(K);\n  vector<pair<int, int>> num(1e5 + 1, {0, 0});\n  for (auto& c : C) {\n    cin >> c;\n    num[c].second++;\n  }\n  for (auto& f : F) {\n    cin >> f;\n    num[f].first++;\n  }\n  for (auto& h : H) cin >> h;\n  int ans = 0;\n  for (int i = 0; i < 1e5 + 1; i++) {\n    if (num[i].first == 0 || num[i].second == 0) continue;\n    vector<vector<int>> dp(num[i].first + 1, vector<int>(num[i].second + 1, 0));\n    for (int p = 0; p <= num[i].first; p++)\n      for (int c = 0; c <= num[i].second; c++)\n        if (p > 0 && c > 0) {\n          for (int tc = 0; tc <= min(c, K); tc++) {\n            dp[p][c] =\n                max(dp[p][c], (tc == 0 ? 0 : H[tc - 1]) + dp[p - 1][c - tc]);\n          }\n        }\n    ans += dp[num[i].first][num[i].second];\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXK = 10;\nconst int MAXN = 500;\nconst int MAXC = 100000;\nint n, k, h[MAXK + 2], ans;\nint cnt[MAXC + 2], p[MAXC + 2];\nint dp[MAXN + 2][MAXN * MAXK + 2];\nvector<int> like;\ninline void read(int &x) {\n  x = 0;\n  char c = getchar();\n  bool f = 0;\n  if (c == '-') f = 1;\n  while (c < '0' || c > '9') c = getchar();\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n}\nint main() {\n  read(n);\n  read(k);\n  for (int i = 1; i <= n * k; i++) {\n    int c;\n    read(c);\n    cnt[c]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    int f;\n    read(f);\n    if (!p[f]) like.push_back(f);\n    p[f]++;\n  }\n  for (int i = 1; i <= k; i++) read(h[i]);\n  for (int l = 0; l < like.size(); l++) {\n    int u = like[l];\n    int o = min(p[u] * k, cnt[u]);\n    for (int i = 1; i <= p[u]; i++)\n      for (int j = 0; j <= min(i * k, o); j++)\n        for (int r = 0; r <= min(j, k); r++)\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - r] + h[r]);\n    ans += dp[p[u]][o];\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing ll = int64_t;\nconst int MAX = 1e5;\nint32_t main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n  int n, k;\n  std::cin >> n >> k;\n  std::vector<int> number_count(MAX + 1), favorite_count(MAX + 1), h(k + 1);\n  int lim = k * n;\n  for (int i = 0; i < lim; i++) {\n    int x;\n    std::cin >> x;\n    number_count[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int x;\n    std::cin >> x;\n    favorite_count[x]++;\n  }\n  for (int i = 1; i <= k; i++) std::cin >> h[i];\n  std::vector<std::vector<int>> dp(501, std::vector<int>(5001 + 1000));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j <= n * (k); j++) {\n      for (int cnt = 0; cnt <= k; cnt++) {\n        dp[i + 1][j + cnt] = std::max(dp[i + 1][j + cnt], dp[i][j] + h[cnt]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= MAX; i++) {\n    if (favorite_count[i] > 0) ans += dp[favorite_count[i]][number_count[i]];\n  }\n  std::cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        new Solver().run(1);\n    }\n}\n\nclass Solver {\n\n    private BufferedReader reader = null;\n    private StringTokenizer st = null;\n\n    private static final int MAXCARDVALUE = (int)1e5;\n\n    private int n, k;\n    private int[] amountOfCards, amountOfPlayers, h;\n    private int[][] dp;\n    private Set<Integer> cards;\n\n    private int ans = 0;\n\n    public void run(int inputType) throws Exception {\n        if (inputType == 0)\n            reader = new BufferedReader(new FileReader(\"input.txt\"));\n        else\n            reader = new BufferedReader(new InputStreamReader(System.in));\n\n        st = new StringTokenizer(reader.readLine());\n        n = Integer.parseInt(st.nextToken());\n        k = Integer.parseInt(st.nextToken());\n\n        amountOfPlayers = new int[MAXCARDVALUE + 1];\n        amountOfCards = new int[MAXCARDVALUE + 1];\n        h = new int[k + 1];\n        cards = new HashSet<>(n);\n\n        dp = new int[n + 1][k*n + 1];\n\n        st = new StringTokenizer(reader.readLine());\n        for(; st.hasMoreTokens();) {\n            int v = Integer.parseInt(st.nextToken());\n            amountOfCards[v]++;\n        }\n\n        st = new StringTokenizer(reader.readLine());\n        for(int i = 0; i < n; ++i) {\n            int v = Integer.parseInt(st.nextToken());\n            amountOfPlayers[v]++;\n            cards.add(v);\n        }\n\n        st = new StringTokenizer(reader.readLine());\n        for (int i = 1; i <= k; ++i) {\n            h[i] = Integer.parseInt(st.nextToken());\n        }\n\n        reader.close();\n\n        for (Integer card : cards) {\n            if (amountOfPlayers[card] == 0)\n                continue;\n\n            if (amountOfPlayers[card] == 1) {\n                ans += h[Math.min(k, amountOfCards[card])];\n                continue;\n            }\n\n            for (int i = 0; i <= k*n; ++i)\n                dp[0][i] = 0;\n\n            for (int i = 0; i <= n; ++i) {\n                dp[i][0] = 0;\n            }\n\n            for (int i = 1; i <= amountOfPlayers[card]; ++i) {\n                for (int j = 1; j <= amountOfCards[card]; ++j) {\n\n                    dp[i][j] = 0;\n                    int border = Math.min(k, j);\n                    for (int t = 1; t <= border; ++t) {\n                        dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - t] + h[t]);\n                    }\n                }\n            }\n\n            ans += dp[amountOfPlayers[card]][amountOfCards[card]];\n        }\n\n        System.out.println(ans);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint fq[112345], pf[112345], h[15];\nint dp[12][505][5002];\nint main() {\n  int n, k, i, f, g, first = 0, K, ans = 0, x, j;\n  scanf(\"%d %d\", &n, &K);\n  for (j = K * n; j--;) {\n    scanf(\"%d\", &x);\n    fq[x]++;\n    first = max(first, fq[x]);\n  }\n  vector<int> q;\n  for (i = 1; i <= n; ++i) {\n    scanf(\"%d\", &x);\n    if (!pf[x]) q.push_back(x);\n    pf[x]++;\n  }\n  for (i = 1; i <= K; ++i) {\n    scanf(\"%d\", h + i);\n  }\n  for (k = 1; k <= K; ++k) {\n    for (i = 1; i <= n; ++i) {\n      for (f = 0; f <= first; ++f) {\n        g = k < f ? k : f;\n        for (j = 0; j <= g; ++j) {\n          dp[k][i][f] = max(dp[k][i][f], h[j] + dp[k][i - 1][f - j]);\n        }\n      }\n    }\n  }\n  for (int p : q) {\n    ans += dp[K][pf[p]][fq[p]];\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k;\n  scanf(\"%d %d\", &n, &k);\n  map<int, int> cards;\n  for (int i = 0; i < n * k; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    ++cards[x];\n  }\n  map<int, int> faves;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    ++faves[x];\n  }\n  vector<int> rewards(k + 1);\n  for (int i = 0; i < k; ++i) {\n    scanf(\"%d\", &rewards[i + 1]);\n  }\n  int ans = 0;\n  for (auto n_c : faves) {\n    int pc = n_c.second, cc = cards[n_c.first];\n    vector<vector<int>> opt(pc + 1, vector<int>(cc + 1, 0));\n    for (int i = 1; i <= pc; ++i) {\n      for (int cards = 0; cards <= cc; ++cards) {\n        for (int cpc = 0; cpc <= min(k, cards); ++cpc) {\n          opt[i][cards] =\n              max(opt[i][cards], rewards[cpc] + opt[i - 1][cards - cpc]);\n        }\n      }\n    }\n    ans += opt[pc][cc];\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nlong long int dp[503][5030];\nlong long int cnt[100100];\nlong long int fav[100100];\nint t[550];\nint used[100100];\nlong long int h[15];\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  for (int i = 0; i < n * m; i++) {\n    int x;\n    cin >> x;\n    cnt[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> t[i];\n    fav[t[i]]++;\n  }\n  for (int i = 0; i < m; i++) {\n    cin >> h[i];\n  }\n  long long int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (used[t[i]]) continue;\n    used[t[i]] = 1;\n    cnt[t[i]] = min(cnt[t[i]], fav[t[i]] * (long long int)m);\n    for (int j = 0; j <= fav[t[i]]; j++) {\n      for (int k = 0; k <= cnt[t[i]]; k++) {\n        dp[j][k] = -1e15;\n      }\n    }\n    dp[0][0] = 0;\n    for (int j = 0; j < fav[t[i]]; j++) {\n      for (int k = 0; k <= cnt[t[i]]; k++) {\n        if (dp[j][k] < 0) continue;\n        for (int l = 0; l <= min((int)m, (int)cnt[t[i]] - k); l++) {\n          dp[j + 1][k + l] =\n              max(dp[j + 1][k + l],\n                  dp[j][k] + (l == 0 ? 0 : (long long int)h[l - 1]));\n        }\n      }\n    }\n    long long int ma = 0;\n    for (int j = 0; j <= cnt[t[i]]; j++) {\n      ma = max(ma, dp[fav[t[i]]][j]);\n    }\n    ans += ma;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long sum = 0, nega = 1;\n  char ch = getchar();\n  while (ch > '9' || ch < '0') {\n    if (ch == '-') nega = -1;\n    ch = getchar();\n  }\n  while (ch <= '9' && ch >= '0') sum = sum * 10 + ch - '0', ch = getchar();\n  return sum * nega;\n}\nlong long n, k, m, a[5009], b[5009], c[5009], cnt[100009], ans, dp[5009];\nsigned main() {\n  n = read(), k = read();\n  m = n * k;\n  for (long long i = 1; i <= m; i++) a[i] = read(), cnt[a[i]]++;\n  for (long long i = 1; i <= n; i++) b[i] = read();\n  for (long long i = 1; i <= k; i++) c[i] = read();\n  sort(b + 1, b + n + 1);\n  long long l = 1, r = 1;\n  while (l <= n) {\n    while (b[r + 1] == b[l]) r++;\n    long long qwq = cnt[b[l]], len = (r - l + 1);\n    for (long long i = 0; i <= n * k; i++) dp[i] = 0;\n    for (long long i = 1; i <= len; i++) {\n      for (long long j = qwq; j >= 0; j--)\n        for (long long p = min(j, k); p >= 1; p--)\n          dp[j] = max(dp[j], dp[j - p] + c[p]);\n    }\n    long long res = 0;\n    for (long long i = 1; i <= qwq; i++) res = max(res, dp[i]);\n    ans += res;\n    l = r + 1;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 500;\nconst long long K = 10;\nconst long long VMAX = 100000;\nlong long n, k;\nlong long v[N * K + 5];\nlong long f[N + 5], s[K + 5];\nlong long ap[VMAX + 5], caut[VMAX + 5];\nlong long dp[N + 5][N * K + 5];\nlong long ans = 0;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k;\n  for (long long i = 1; i <= n * k; i++) {\n    cin >> v[i];\n    ap[v[i]]++;\n  }\n  for (long long i = 1; i <= n; i++) {\n    cin >> f[i];\n    caut[f[i]]++;\n  }\n  for (long long i = 1; i <= k; i++) cin >> s[i];\n  for (long long x = 1; x <= VMAX; x++) {\n    if (ap[x] == 0 || caut[x] == 0) continue;\n    long long cnt = min(ap[x], caut[x] * k);\n    dp[0][0] = 0;\n    long long bst = 0;\n    for (long long cate = 1; cate <= caut[x]; cate++) {\n      for (long long lst = 1; lst <= k; lst++)\n        for (long long sum = lst; sum <= min(cnt, cate * k); sum++) {\n          dp[cate][sum] = max(dp[cate][sum], dp[cate - 1][sum - lst] + s[lst]);\n        }\n      bst = max(bst, dp[cate][cnt]);\n    }\n    ans += bst;\n    for (long long i = 1; i <= caut[x]; i++)\n      for (long long j = 0; j <= min(cnt, i * k); j++) dp[i][j] = 0;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"4 3\\n\" +\n            \"1 3 2 8 5 5 8 2 2 8 5 2\\n\" +\n            \"1 2 2 5\\n\" +\n            \"2 6 7\\n\";\n    final int maxn = (int)1e5 + 1;\n    int n,k;\n    int c1[] = new int[maxn],c2[] = new int[maxn];\n    int h[] = new int[maxn];\nfinal int M = 5001;\n    long dp[][] = new long[M][M];\n    void go(){\n        n = ni();\n        k = ni();\n        for (int i=0;i<n*k;i++){\n            int temp = ni();\n            c1[temp]++;\n        }\n        for (int i=0;i<n;i++){\n            int temp = ni();\n            c2[temp]++;\n        }\n        for (int i=1;i<=k;i++){\n            h[i] = ni();\n        }\n        for (int i=1;i<M;i++){\n            for (int j=1;j<M;j++){\n                dp[i][j] = dp[i-1][j];\n                for (int x = 0;x<=k;x++){\n                    if(x>j)continue;\n                    dp[i][j] = Math.max(dp[i][j],dp[i-1][j-x]+h[x]);\n                }\n            }\n        }\n        long ans =0;\n        for (int i=0;i<maxn;i++){\n            ans+=dp[c2[i]][c1[i]];\n        }\n        out.println(ans);\n    }\n\n    void solve(){\n        go();\n    }\n\n    void run() throws Exception\n    {\n        is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        tr(System.currentTimeMillis()-s+\"ms\");\n    }\n\n    public static void main(String[] args) throws Exception { new Main().run(); }\n\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n\n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n\n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        for(;(b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'););\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        for(;;){\n            if(Character.isDigit(b)){\n                num = num * 10 + (b - '0');\n            } else\n                return minus ? -num : num;\n            b = readByte();\n        }\n    }\n\n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        for(;(b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'););\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        for(;;){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    //private boolean oj = true;\n\n    private boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T>\nusing VV = vector<V<T>>;\ntemplate <typename T>\nistream& operator>>(istream& cin, V<T>& arr) {\n  for (T& val : arr) {\n    cin >> val;\n  }\n  return cin;\n}\ntemplate <typename T>\nostream& operator<<(ostream& cout, V<T>& arr) {\n  for (T& val : arr) {\n    cout << val << ' ';\n  }\n  return cout;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  vector<long long> c(n * k);\n  cin >> c;\n  vector<long long> f(n);\n  cin >> f;\n  vector<long long> h(k);\n  cin >> h;\n  sort(c.begin(), c.end());\n  sort(f.begin(), f.end());\n  vector<vector<long long>> ma(5001, vector<long long>(501));\n  for (long long i = 1; i < 5001; i++) {\n    for (long long j = 1; j < 501LL; j++) {\n      if (j * k <= i) {\n        ma[i][j] = h[k - 1] * j;\n      } else {\n        ma[i][j] = ma[i][j - 1];\n        for (long long q = 1; q <= k && i - q >= 0; q++) {\n          ma[i][j] = max(ma[i][j], h[q - 1] + ma[i - q][j - 1]);\n        }\n      }\n    }\n  }\n  long long i = 0;\n  long long j = 0;\n  long long ans = 0;\n  while (i < n) {\n    long long cntPeople = 0;\n    while (i + cntPeople < n && f[i + cntPeople] == f[i]) {\n      cntPeople++;\n    }\n    while (j < n * k && c[j] < f[i]) {\n      j++;\n    }\n    if (j < n * k && c[j] == f[i]) {\n      long long cntCards = 0;\n      while (j + cntCards < n * k && c[j + cntCards] == c[j]) {\n        cntCards++;\n      }\n      ans += ma[cntCards][cntPeople];\n    }\n    i += cntPeople;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"-O2\")\nconst int LIM = 1e5 + 5, MOD = 1e9 + 7;\nlong long INF = 1e17;\nint t, n, m, k, x, y;\nint a[LIM], h[12];\nmap<int, int> mpp;\nlong long solve(int sum, int var) {\n  sum = min(sum, k * var);\n  long long dp[sum + 1][var + 1];\n  for (int j = 0; j < sum + 1; j++) {\n    if (j > k)\n      dp[j][1] = -INF;\n    else\n      dp[j][1] = h[j];\n  }\n  for (int i = 2; i < var + 1; i++) {\n    for (int j = 0; j < sum + 1; j++) {\n      long long curr = -INF;\n      for (int l = 0; l < j + 1; l++) {\n        if (l > k) break;\n        curr = max(curr, h[l] + dp[j - l][i - 1]);\n      }\n      dp[j][i] = curr;\n    }\n  }\n  return dp[sum][var];\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) cin >> x, a[x]++;\n  for (int i = 0; i < n; i++) cin >> x, mpp[x]++;\n  for (int i = 0; i < k; i++) cin >> h[i + 1];\n  long long ans = 0;\n  for (auto &it : mpp) {\n    ans += solve(a[it.first], it.second);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 101010;\nint n, k, c[N], f[N], h[N];\nconst int K = 514;\nint dp[10 * K];\nint cal(int x) {\n  if (f[x] == 0) return 0;\n  int atmst = min(f[x] * k, c[x]);\n  for (int i = 0; i <= atmst; i++) dp[i] = 0;\n  while (f[x]--) {\n    for (int i = atmst; i >= 0; i--)\n      for (int j = 1; j <= k and i - j >= 0; j++)\n        dp[i] = max(dp[i], dp[i - j] + h[j]);\n  }\n  return dp[atmst];\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n * k; i++) {\n    int ci;\n    scanf(\"%d\", &ci);\n    c[ci]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int fi;\n    scanf(\"%d\", &fi);\n    f[fi]++;\n  }\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &h[i]);\n  int ans = 0;\n  for (int i = 0; i < N; i++) ans += cal(i);\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 510, M = 1000 * 100 + 10;\nint n, K, h[N], cnt[2][M], dp[N][N * 10];\nvoid read() {\n  int c, f;\n  cin >> n >> K;\n  for (int i = 1; i <= n * K; i++) cin >> c, cnt[0][c]++;\n  for (int i = 1; i <= n; i++) cin >> f, cnt[1][f]++;\n  for (int i = 1; i <= K; i++) cin >> h[i];\n}\nint joy(int n, int m) {\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      dp[i][j] = -1 * (1 << 20);\n      for (int k = 0; k <= min(K, j); k++)\n        dp[i][j] = max(dp[i][j], h[k] + dp[i - 1][j - k]);\n    }\n  return dp[n][m];\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  read();\n  int ans = 0;\n  for (int i = 1; i < M; i++) ans += joy(cnt[1][i], cnt[0][i]);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXK = 105;\nconst int MAXN = 505;\nconst int MAXM = 1e5 + 5;\nint n, k;\nlong long h[MAXN];\nlong long memo[MAXN][MAXN * MAXK];\nint cardCnt[MAXM], demandCnt[MAXM];\nlong long calcState(int cards, int players) {\n  if (cards == 0 || players == 0) return 0;\n  if (memo[players][cards] != -1) return memo[players][cards];\n  long long answer = 0;\n  for (int i = 0; i <= min(k, cards); i++) {\n    answer = max(answer, h[i] + calcState(cards - i, players - 1));\n  }\n  memo[players][cards] = answer;\n  return answer;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long answer = 0;\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    int x;\n    cin >> x;\n    cardCnt[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    demandCnt[x]++;\n  }\n  for (int i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  memset(memo, -1, sizeof(memo));\n  for (int i = 1; i < MAXM; i++) {\n    answer += calcState(cardCnt[i], demandCnt[i]);\n  }\n  cout << answer << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> a, b;\nint n, k, c[10 * 510], f[510], h[510], g[510][10 * 510];\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n * k; i++) {\n    scanf(\"%d\", &c[i]);\n    b[c[i]]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &f[i]);\n    a[f[i]]++;\n  }\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &h[i]);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n * k; j++)\n      for (int t = 0; t <= k; t++)\n        if (j >= t) g[i][j] = max(g[i][j], g[i - 1][j - t] + h[t]);\n  int ans = 0;\n  for (auto e : a)\n    if (b.count(e.first)) {\n      int m = b[e.first], n = e.second;\n      ans += g[n][m];\n    }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXK = 15;\nconst int MAXN = 505;\nconst int MAXC = 100005;\nint n, k, h[MAXK], ans;\nint cnt[MAXC], p[MAXC];\nint dp[MAXN][MAXN * MAXK];\nvector<int> like;\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n * k; i++) {\n    int c;\n    scanf(\"%d\", &c);\n    cnt[c]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    int f;\n    scanf(\"%d\", &f);\n    if (!p[f]) like.push_back(f);\n    p[f]++;\n  }\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &h[i]);\n  for (int l = 0; l < like.size(); l++) {\n    int u = like[l];\n    int o = min(p[u] * k, cnt[u]);\n    for (int i = 1; i <= p[u]; i++)\n      for (int j = 0; j <= min(i * k, o); j++)\n        for (int r = 0; r <= min(j, k); r++)\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - r] + h[r]);\n    ans += dp[p[u]][o];\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[505][5050];\nint main() {\n  int n, k;\n  cin >> n >> k;\n  int c[5000];\n  int f[5000];\n  int h[5000];\n  vector<int> vec;\n  for (int i = 0; i < n * k; i++) {\n    cin >> c[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> f[i];\n    vec.push_back(f[i]);\n  }\n  for (int i = 0; i < k; i++) cin >> h[i + 1];\n  memset(dp, 0, sizeof(dp));\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n * k; j++) {\n      for (int l = 1; l <= k; l++) {\n        if (j >= l) dp[i][j] = max(dp[i - 1][j - l] + h[l], dp[i][j]);\n      }\n    }\n  }\n  long final = 0;\n  int freq[100005];\n  int freq1[100005];\n  memset(freq1, 0, sizeof(freq1));\n  memset(freq, 0, sizeof(freq));\n  for (int j = 0; j < n * k; j++) {\n    freq[c[j]]++;\n  }\n  for (int i = 0; i < n; i++) {\n    freq1[f[i]]++;\n  }\n  sort(vec.begin(), vec.end());\n  vector<int>::iterator itr;\n  itr = unique(vec.begin(), vec.end());\n  vec.resize(distance(vec.begin(), itr));\n  for (int i = 0; i < vec.size(); i++) {\n    final += dp[freq1[vec[i]]][freq[vec[i]]];\n  }\n  cout << final << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "/**\n * @author sakt_coder\n * created on 2020-10-21 12:36\n */\nimport java.io.*;\nimport java.util.*;\npublic class Main\n{\n\tprivate void solve()throws Exception\n\t{\n\t\tint n=nextInt();\n\t\tint K=nextInt();\n\t\t//freq[i] is the number of cards i\n\t\tint freq[]=new int[(int)(1e5)+1];\n\t\tfor(int i=1;i<=K*n;i++)\n\t\t\tfreq[nextInt()]++;\n\n\t\tHashMap<Integer,Integer> map=new HashMap<>();\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint f=nextInt();\n\t\t\tmap.put(f,map.getOrDefault(f,0)+1);\n\t\t}\n\n\t\tint free=0;\n\t\tfor(int i=1;i<=(int)(1e5);i++)\n\t\t\tif(map.containsKey(i)==false)\n\t\t\t\tfree+=freq[i];\n\n\t\tint h[]=new int[K+1];\n\t\tfor(int i=1;i<=K;i++)\n\t\t\th[i]=nextInt();\n\n\t\t//dp2[i][j] is the max sum by distributing j cards among i players\n\t\tint dp2[][]=new int[501][5001];\n\t\tfor(int i=0;i<=500;i++)\n\t\t\tfor(int j=0;j<=5000;j++)\n\t\t\t{\n\t\t\t\tif(i==0)\n\t\t\t\t\tdp2[i][j]=0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp2[i][j]=Integer.MIN_VALUE;\n\t\t\t\t\tfor(int k=0;k<=K && k<=j;k++)\n\t\t\t\t\t\tdp2[i][j]=Math.max(dp2[i][j],h[k]+dp2[i-1][j-k]);\n\t\t\t\t}\n\t\t\t}\n\n\t\tint zero=5000;\n\t\t//dp[i][j] is the max sum of joy from the first i players such that there are j free cards remaining\n\t\tint dp[][]=new int[2][zero+zero+1];\n\n\t\tArrays.fill(dp[0],Integer.MIN_VALUE);\n\n\t\tdp[0][zero+free]=0;\n\n\t\tint p=1;\n\t\tfor(Map.Entry<Integer,Integer> e:map.entrySet())\n\t\t{\n\t\t\tint fav=e.getKey();\n\t\t\tint cnt=e.getValue();\n\t\t\tfor(int j=-zero;j<=zero;j++)\n\t\t\t{\n\t\t\t\tdp[p][zero+j]=Integer.MIN_VALUE;\n\t\t\t\tfor(int k=0;k<=freq[fav];k++)\n\t\t\t\t{\n\t\t\t\t\tint rem=freq[fav]-k;\n\t\t\t\t\tif(j-rem+(K-k)>=-zero && j-rem+(cnt*K-k)<=zero)\n\t\t\t\t\t\tdp[p][zero+j]=Math.max(dp[p][zero+j],dp2[cnt][k]+dp[1-p][zero+j-rem+(cnt*K-k)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp=1-p;\n\t\t}\n\t\tp=1-p;\n\t\tout.println(dp[p][zero]);\n\t}\n\n\t \n\t///////////////////////////////////////////////////////////\n\n\tpublic void run()throws Exception\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t\tst=null;\n\t\tout=new PrintWriter(System.out);\n\n\t\ttry{\n\t\t\tsolve();\n\n\t\t}catch(Exception e){e.printStackTrace();}\n\t\tfinally{\n\t\t\tbr.close();\n\t\t\tout.close();\n\t\t}\n\t\t\n\t}\n\tpublic static void main(String args[])throws Exception{\n\t\tnew Main().run();\n\t}\n\tBufferedReader br;\n\tStringTokenizer st;\n\tPrintWriter out;\n\tString nextToken()throws Exception{\n\t\twhile(st==null || !st.hasMoreTokens())\n\t\tst=new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\tString nextLine()throws Exception{\n\t\treturn br.readLine();\n\t}\n\tint nextInt()throws Exception{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tlong nextLong()throws Exception{\n\t\treturn Long.parseLong(nextToken());\n\t}\n\tdouble nextDouble()throws Exception{\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[501][5001];\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> c(1e5 + 1, 0);\n  for (int i = 0; i < n * k; i++) {\n    int x;\n    cin >> x;\n    c[x]++;\n  }\n  long long ans = 0;\n  vector<int> a(1e5 + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    a[x]++;\n  }\n  vector<int> h(k + 1, 0);\n  for (int i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  for (int x = 1; x <= 1e5; x++) {\n    long long mx = 0;\n    if (!a[x] || !c[x]) continue;\n    int S = min(a[x] * k, c[x]);\n    int N = a[x];\n    for (int i = 0; i <= S; i++) {\n      for (int j = 0; j <= N; j++) {\n        dp[j][i] = 0;\n      }\n    }\n    for (int i = 0; i <= min(S, k); i++) {\n      dp[1][i] = h[i];\n      mx = max(mx, dp[1][i]);\n    }\n    for (int i = 2; i <= N; i++) {\n      for (int s = 0; s <= S; s++) {\n        for (int kol = 0; kol <= min(k, S); kol++) {\n          if (s - kol >= 0) {\n            dp[i][s] = max(dp[i][s], dp[i - 1][s - kol] + h[kol]);\n            mx = max(mx, dp[i][s]);\n          }\n        }\n      }\n    }\n    ans += mx;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst int N = 1e5 + 4;\nint fa[N], pri[N];\nvector<int> v[N];\nint main() {\n  int n, k;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  for (int i = 0; i < n * k; i++) {\n    int temp;\n    scanf(\"%d\", &temp);\n    fa[temp]++;\n  }\n  for (int i = 1; i < n + 1; i++) {\n    int temp;\n    scanf(\"%d\", &temp);\n    v[temp].push_back(i);\n  }\n  for (int i = 1; i < N; i++) {\n    if (i <= k)\n      scanf(\"%d\", &pri[i]);\n    else\n      pri[i] = pri[k];\n  }\n  int total = 0;\n  for (int i = 1; i < N; i++)\n    if (v[i].size() and fa[i]) {\n      int sz = v[i].size();\n      int dp[fa[i] + 1][sz + 1];\n      memset(dp, 0, sizeof(dp));\n      for (int j = 0; j < sz; j++) {\n        for (int l = 0; l < fa[i] + 1; l++) {\n          for (int x = 0; x < k + 1; x++)\n            if (l + x <= fa[i])\n              dp[l + x][j + 1] = max(dp[l + x][j + 1], pri[x] + dp[l][j]);\n        }\n      }\n      int here = 0;\n      for (int j = 0; j < fa[i] + 1; j++) here = max(here, dp[j][sz]);\n      total += here;\n    }\n  printf(\"%d\", total);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e5 + 10;\nint b[N], f[N], c[N], K;\nlong long table[501][500 * 10 + 1];\nint x;\nlong long g(int pos, int k) {\n  if (!pos) return 0;\n  if (!k) return 0;\n  if (table[pos][k]) return table[pos][k];\n  long long o = g(pos - 1, k);\n  int i;\n  for (i = 1; i < min(k, K) + 1; i++) {\n    o = max(o, g(pos - 1, k - i) + c[i - 1]);\n  }\n  return table[pos][k] = o;\n}\nint main() {\n  int n, i, a;\n  cin >> n >> K;\n  for (i = 0; i < n * K; i++) {\n    scanf(\"%d\", &a);\n    a--;\n    b[a]++;\n  }\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a);\n    a--;\n    f[a]++;\n  }\n  for (i = 0; i < K; i++) {\n    scanf(\"%d\", &c[i]);\n  }\n  long long o = 0;\n  for (i = 0; i < 100001; i++) {\n    if (f[i]) {\n      o += g(f[i], b[i]);\n    }\n  }\n  cout << o;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\n\tFastReader in = new FastReader();\n\tPrintWriter out = new PrintWriter(System.out);\n\tvoid run(){\n\t\twork();\n\t\tout.flush();\n\t}\n\tlong mod=998244353L;\n\tlong inf=Long.MAX_VALUE;\n\tlong gcd(long a,long b) {\n\t\treturn a==0?b:gcd(b%a,a);\n\t}\n\tint maxn=100000;\n\tvoid work() {\n\t\tint n=ni(),k=ni();\n\t\tint[] count=new int[maxn+1];\n\t\tfor(int i=0;i<n*k;i++) {\n\t\t\tcount[ni()]++;\n\t\t}\n\t\tint[] count2=new int[maxn+1];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tcount2[ni()]++;\n\t\t}\n\t\tint[] A=new int[k+1];\n\t\tfor(int i=1;i<=k;i++) {\n\t\t\tA[i]=ni();\n\t\t}\n\t\tlong ret=0;\n\t\tfor(int p=1;p<=maxn;p++) {\n\t\t\tint sum=count[p];\n\t\t\tint c=count2[p];\n\t\t\tlong[][] dp=new long[c+1][sum+1];\n\t\t\tfor(long[] d:dp) {\n\t\t\t\tArrays.fill(d,-1);\n\t\t\t}\n\t\t\tdp[0][0]=0;\n\t\t\tfor(int i=0;i<c;i++) {\n\t\t\t\tfor(int j=0;j<=sum;j++) {\n\t\t\t\t\tif(dp[i][j]==-1)continue;\n\t\t\t\t\tfor(int l=0;l<=k;l++) {\n\t\t\t\t\t\tint s=l+j;\n\t\t\t\t\t\tif(s<=sum) {\n\t\t\t\t\t\t\tdp[i+1][s]=Math.max(dp[i][j]+A[l], dp[i+1][s]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret+=dp[c][Math.min(sum, c*k)];\n\t\t}\n\t\tout.println(ret);\n\t}\n\n\t//input\n\t@SuppressWarnings(\"unused\")\n\tprivate ArrayList<Integer>[] ng(int n, int m) {\n\t\tArrayList<Integer>[] graph=(ArrayList<Integer>[])new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i]=new ArrayList<>();\n\t\t}\n\t\tfor(int i=1;i<=m;i++) {\n\t\t\tint s=in.nextInt()-1,e=in.nextInt()-1;\n\t\t\tgraph[s].add(e);\n\t\t\tgraph[e].add(s);\n\t\t}\n\t\treturn graph;\n\t}\n\n\tprivate ArrayList<long[]>[] ngw(int n, int m) {\n\t\tArrayList<long[]>[] graph=(ArrayList<long[]>[])new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i]=new ArrayList<>();\n\t\t}\n\t\tfor(int i=1;i<=m;i++) {\n\t\t\tlong s=in.nextLong()-1,e=in.nextLong()-1,w=in.nextLong();\n\t\t\tgraph[(int)s].add(new long[] {e,w,i});\n\t\t\tgraph[(int)e].add(new long[] {s,w});\n\t\t}\n\t\treturn graph;\n\t}\n\n\tprivate int ni() {\n\t\treturn in.nextInt();\n\t}\n\n\tprivate long nl() {\n\t\treturn in.nextLong();\n\t}\n\t\n\tprivate String ns() {\n\t\treturn in.next();\n\t}\n\n\tprivate long[] na(int n) {\n\t\tlong[] A=new long[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tA[i]=in.nextLong();\n\t\t}\n\t\treturn A;\n\t}\n\tprivate int[] nia(int n) {\n\t\tint[] A=new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tA[i]=in.nextInt();\n\t\t}\n\t\treturn A;\n\t}\n}\t\n\nclass FastReader\n{\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic FastReader()\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\n\tpublic String next() \n\t{\n\t\twhile(st==null || !st.hasMoreElements())//\u56de\u8f66\uff0c\u7a7a\u884c\u60c5\u51b5\n\t\t{\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() \n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong()\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst int N = 1e5 + 4;\nint fa[N], pri[N];\nvector<int> v[N];\nint main() {\n  int n, k;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  for (int i = 0; i < n * k; i++) {\n    int temp;\n    scanf(\"%d\", &temp);\n    fa[temp]++;\n  }\n  for (int i = 1; i < n + 1; i++) {\n    int temp;\n    scanf(\"%d\", &temp);\n    v[temp].push_back(i);\n  }\n  for (int i = 1; i < N; i++) {\n    if (i <= k)\n      scanf(\"%d\", &pri[i]);\n    else\n      pri[i] = pri[k];\n  }\n  int total = 0;\n  for (int i = 1; i < N; i++)\n    if (v[i].size() and fa[i]) {\n      int sz = v[i].size();\n      int dp[fa[i] + 1][sz + 1];\n      memset(dp, 0, sizeof(dp));\n      for (int j = 1; j < sz + 1; j++) {\n        for (int l = 0; l < fa[i] + 1; l++) {\n          for (int x = 0; x < k + 1; x++)\n            if (l - x >= 0) dp[l][j] = max(dp[l][j], dp[l - x][j - 1] + pri[x]);\n        }\n      }\n      int here = 0;\n      for (int j = 0; j < fa[i] + 1; j++) here = max(here, dp[j][sz]);\n      total += here;\n    }\n  printf(\"%d\", total);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[501][5001] = {};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n, k;\n  cin >> n >> k;\n  vector<int> cnt(100001, 0);\n  for (int i = 0; i < k * n; i++) {\n    int x;\n    cin >> x;\n    cnt[x]++;\n  }\n  vector<int> fav(n), fcnt(100001, 0);\n  for (int i = 0; i < n; i++) cin >> fav[i], fcnt[fav[i]]++;\n  vector<int> h(k + 1, 0);\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  long long ans = 0;\n  for (int i = 1; i <= 100000; i++) {\n    if (fcnt[i] == 0 || cnt[i] == 0) continue;\n    int upper = min(fcnt[i] * k, cnt[i]);\n    for (int person = 1; person <= fcnt[i]; person++) {\n      for (int j = 0; j <= person * k; j++) dp[person][j] = 0;\n      for (int j = 0; j <= person * k; j++) {\n        for (int tmp = 0; tmp <= k && j + tmp <= upper; tmp++) {\n          dp[person][j + tmp] =\n              max(dp[person][j + tmp], dp[person - 1][j] + h[tmp]);\n        }\n      }\n    }\n    long long ma = 0;\n    for (int j = 0; j <= upper; j++) ma = max(ma, dp[fcnt[i]][j]);\n    ans += ma;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid write(int x) {\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n}\nint read() {\n  int d = 0, w = 1;\n  char c = getchar();\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') w = -1;\n  for (; c >= '0' && c <= '9'; c = getchar()) d = (d << 1) + (d << 3) + c - 48;\n  return d * w;\n}\nvoid wln(int x) {\n  write(x);\n  putchar('\\n');\n}\nvoid wrs(int x) {\n  write(x);\n  putchar(' ');\n}\nint n, k, like[510], mst[20], a[510 * 20], dp[510 * 20], last[510 * 20];\nsigned main() {\n  n = read();\n  k = read();\n  for (int i = 1; i <= n * k; a[i++] = read())\n    ;\n  sort(a + 1, a + n * k + 1);\n  for (int i = 1; i <= n; like[i++] = read())\n    ;\n  sort(like + 1, like + n + 1);\n  for (int i = 1; i <= k; mst[i++] = read())\n    ;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n * k; j++) {\n      dp[j] = max(dp[j], dp[j - 1]);\n      for (int kk = 0; kk <= min(k, j); kk++) {\n        int cnt = 0;\n        for (int l = j - kk + 1; l <= j; l++) cnt += (like[i] == a[l]);\n        dp[j] = max(dp[j], last[j - kk] + mst[cnt]);\n      }\n    }\n    for (int j = 1; j <= n * k; j++) last[j] = dp[j];\n    memset(dp, 0, sizeof dp);\n  }\n  write(last[n * k]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, x, a[100010], c[100010], t, y, mem[505][5005], ans;\nmap<int, int> b;\nint dp(int i = 1, int v = t) {\n  if (v < 0) return -1e9;\n  if (v == 0 || i == y + 1) return 0;\n  int& ret = mem[i][v];\n  if (~ret) return ret;\n  ret = -1e9;\n  for (int j = 0; j <= k; j++) {\n    ret = max(ret, dp(i + 1, v - j) + c[j]);\n  }\n  return ret;\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n * k; i++) {\n    cin >> x;\n    a[x]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> x;\n    b[x]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> c[i];\n  for (auto p : b) {\n    t = a[p.first];\n    y = p.second;\n    memset(mem, -1, sizeof mem);\n    ans += dp();\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 505, MAXK = 15;\nint n, k;\nint h[MAXK];\nint dp[2][MAXN * MAXK];\nunordered_map<int, int> c, f;\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1, x; i <= n * k; i++) {\n    scanf(\"%d\", &x);\n    c[x]++;\n  }\n  for (int i = 1, x; i <= n; i++) {\n    scanf(\"%d\", &x);\n    f[x]++;\n  }\n  for (int i = 1; i <= k; i++) scanf(\"%d\", h + i);\n  long long ans = 0;\n  for (auto& p : f) {\n    if (c.find(p.first) == c.end()) continue;\n    memset(dp[0], 0, sizeof dp[0]);\n    for (int i = 1; i <= p.second; i++)\n      for (int j = 0; j <= c[p.first]; j++) {\n        dp[i & 1][j] = 0;\n        for (int t = 0; t <= k && t <= j; t++)\n          dp[i & 1][j] = max(dp[i & 1][j], dp[(i - 1) & 1][j - t] + h[t]);\n      }\n    ans += dp[p.second & 1][c[p.first]];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[10000], sum, L[10000], apr[100100], tot[10000], dp[502][5002], v[510];\nint main() {\n  int n, m, i, j, k;\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n * m; i++) scanf(\"%d\", &a[i]);\n  for (i = 1; i <= n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    if (!apr[x]) {\n      sum++;\n      apr[x] = sum;\n    }\n    v[apr[x]]++;\n  }\n  for (i = 1; i <= m; i++) scanf(\"%d\", &L[i]);\n  for (i = 1; i <= n * m; i++)\n    if (apr[a[i]]) tot[apr[a[i]]]++;\n  int ans = 0;\n  for (int _ = 1; _ <= sum; _++) {\n    memset(dp, -0x3f, sizeof(dp));\n    dp[0][0] = 0;\n    int t = v[_];\n    for (i = 1; i <= t; i++)\n      for (j = 0; j <= min(tot[_], i * m); j++)\n        for (k = 0; k <= min(j, m); k++)\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - k] + L[k]);\n    ans += dp[t][min(tot[_], t * m)];\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint64_t mod = 1e9 + 7;\nint64_t mod1 = 1e9 + 5;\nint64_t power(int64_t a, int64_t b) {\n  if (b == 0)\n    return 1;\n  else if (b % 2 == 0)\n    return power(((((a) % mod) * ((a) % mod)) % mod), b / 2) % mod;\n  else\n    return (((a) % mod) *\n            (power(((((a) % mod) * ((a) % mod)) % mod), b / 2) % mod)) %\n           mod;\n}\ninline int64_t inverse(int64_t a, int64_t md) {\n  a %= md;\n  if (a < 0) a += md;\n  int64_t b = md, u = 0, v = 1;\n  while (a) {\n    int64_t t = b / a;\n    b -= t * a;\n    swap(a, b);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\nconst int64_t ce = 1e9 + 7;\nint64_t fast_mod(int64_t input) { return input < ce ? input : input % ce; }\nint64_t fre[100001];\nint64_t co[11];\nint64_t n, k;\nint64_t f[100001];\nint64_t maxi;\nint64_t dp[501][5001];\nint64_t solve(int64_t i, int64_t rem) {\n  if (rem == 0) return 0;\n  if (i == maxi) return 0;\n  int64_t &res = dp[i][rem];\n  if (res != -1) return res;\n  res = 0;\n  for (int64_t j = 1; j <= min(rem, k); j++) {\n    res = max(res, co[j] + solve(i + 1, rem - j));\n  }\n  return res;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> k;\n  memset(fre, 0, sizeof(fre));\n  for (int64_t i = 0; i < n * k; i++) {\n    int64_t x;\n    cin >> x;\n    fre[x]++;\n  }\n  memset(f, 0, sizeof(f));\n  for (int64_t i = 1; i <= n; i++) {\n    int64_t s;\n    cin >> s;\n    f[s]++;\n  }\n  co[0] = 0;\n  for (int64_t i = 1; i <= k; i++) {\n    cin >> co[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  int64_t ans = 0;\n  for (int64_t i = 1; i <= 100000; i++) {\n    maxi = f[i];\n    for (int64_t j = 0; j <= maxi; j++)\n      for (int64_t k = 0; k <= fre[i]; k++) dp[j][k] = -1;\n    ans += solve(0, fre[i]);\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\n# ------------------------------\n# f = open('./input.txt')\n# sys.stdin = f\n\ndef main():\n    n, k = RL()\n    cds = RLL()\n    fn = RLL()\n    sc = [0]+RLL()\n\n    rec = set(fn)\n    uses = 0\n    dic = defaultdict(int)\n    for i in cds:\n        if i in rec:\n            dic[i]+=1\n            uses+=1\n\n    dp = [[0]*(uses+1) for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        for j in range(1, uses+1):\n            for l in range(k+1):\n                if l>j: break\n                val = sc[l]\n                dp[i][j] = max(dp[i][j], dp[i-1][j-l]+val)\n    res = 0\n\n    for i, v in Counter(fn).items():\n        res+=dp[v][dic[i]]\n    # for i in dp: print(i)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int MAXN = 1e5 + 10;\nconst int MAXM = 2e6 + 10;\nconst long long mod = 1e9 + 7;\nlong long dp[510][5010];\nint f[510], h[15];\nint num[MAXN], player[MAXN];\nbool vis[MAXN];\nint main() {\n  memset((dp), (0), sizeof(dp));\n  memset((num), (0), sizeof(num));\n  memset((player), (0), sizeof(player));\n  memset((vis), (false), sizeof(vis));\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  int m = n * k;\n  for (int i = 0; i < m; i++) {\n    int c;\n    scanf(\"%d\", &c);\n    num[c]++;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &f[i]);\n    player[f[i]]++;\n  }\n  h[0] = 0;\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &h[i]);\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (vis[f[i]]) continue;\n    vis[f[i]] = true;\n    memset((dp), (0), sizeof(dp));\n    long long maxx = 0;\n    for (int j = 0; j <= min(k, num[f[i]]); j++) {\n      dp[1][j] = (long long)h[j];\n      maxx = max(maxx, (long long)h[j]);\n    }\n    for (int j = 2; j <= player[f[i]]; j++) {\n      for (int l = 0; l <= min(j * k, num[f[i]]); l++) {\n        for (int g = 0; g <= min(k, l); g++) {\n          dp[j][l] = max(dp[j][l], dp[j - 1][l - g] + (long long)h[g]);\n          maxx = max(maxx, dp[j][l]);\n        }\n      }\n    }\n    ans += maxx;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint c[100012], f[100012], h[12];\nlong long dp[512][50012], ans;\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n * k; i++) {\n    int x;\n    cin >> x;\n    c[x]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    f[x]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  for (int i = 0; i <= n; i++)\n    for (int j = 0; j <= n * k; j++)\n      for (int lol = 0; lol <= k; lol++)\n        dp[i + 1][j + lol] = max(dp[i + 1][j + lol], dp[i][j] + h[lol]);\n  for (int i = 1; i <= 100001; i++) {\n    if (f[i]) ans += dp[f[i]][c[i]];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class F490 {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt(); int k = sc.nextInt();\n        int [] cards = new int[k * n];\n        for (int i = 0; i < k * n; i++) cards[i] = sc.nextInt();\n        Map<Integer, Integer> f = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt();\n            f.put(x, f.getOrDefault(x, 0) + 1);\n        }\n        Map<Integer, Integer> amt = new HashMap<>();\n        for (int i = 0; i < k * n; i++) {\n            if (f.containsKey(cards[i])) {\n                amt.put(cards[i], amt.getOrDefault(cards[i], 0) + 1);\n            }\n        }\n        long res = 0;\n        int [] h = new int[k + 1];\n        for (int i = 1; i <= k; i++) h[i] = sc.nextInt();\n        // dp[i][j] is the maximal joy I can get by distributing i cards to j people\n        int [][] dp = new int[n * k + 1][n + 1];\n        for (int i = 1; i <= n * k; i++) {\n            for (int j = 1; j <= n; j++) {\n                for (int give = 0; give <= k; give++) {\n                    if (give <= i) {\n                        dp[i][j] = Math.max(dp[i][j], dp[i - give][j - 1] + h[give]);\n                    }\n                }\n            }\n        }\n        for (Integer i: f.keySet()) {\n            int people = f.get(i);\n            int c = amt.getOrDefault(i, 0);\n            res += dp[c][people];\n        }\n        out.println(res);\n        out.close();\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, k;\n  cin >> n >> k;\n  int a[n * k];\n  vector<int> kol(100001, 0);\n  for (int i = 0; i < n * k; i++) {\n    cin >> a[i];\n    kol[a[i]]++;\n  }\n  int f[n];\n  vector<int> ko(100001, 0);\n  set<int> st;\n  for (int i = 0; i < n; i++) {\n    cin >> f[i];\n    st.insert(f[i]);\n    ko[f[i]]++;\n  }\n  int h[k];\n  for (int i = 0; i < k; i++) cin >> h[i];\n  int ans = 0;\n  for (auto r : st) {\n    vector<vector<int> > dp(ko[r] + 1, vector<int>(kol[r] + 1));\n    for (int i = 1; i <= ko[r]; i++) {\n      for (int j = 1; j <= kol[r]; j++) {\n        for (int l = 0; l < min(k, j); l++) {\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - l - 1] + h[l]);\n        }\n      }\n    }\n    ans += dp[ko[r]][kol[r]];\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst int N = 1e5 + 4;\nint fa[N], pri[N];\nvector<int> v[N];\nint main() {\n  int n, k;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  for (int i = 0; i < n * k; i++) {\n    int temp;\n    scanf(\"%d\", &temp);\n    fa[temp]++;\n  }\n  for (int i = 1; i < n + 1; i++) {\n    int temp;\n    scanf(\"%d\", &temp);\n    v[temp].push_back(i);\n  }\n  for (int i = 1; i < N; i++) {\n    if (i <= k)\n      scanf(\"%d\", &pri[i]);\n    else\n      pri[i] = pri[k];\n  }\n  int total = 0;\n  for (int i = 1; i < N; i++)\n    if (v[i].size() and fa[i]) {\n      int sz = v[i].size();\n      int dp[fa[i] + 1][sz + 1];\n      memset(dp, 0, sizeof(dp));\n      for (int j = 0; j < sz; j++) {\n        for (int l = 0; l < fa[i] + 1; l++) {\n          for (int x = 0; x < k + 1; x++)\n            if (l + x <= fa[i])\n              dp[l + x][j + 1] = max(dp[l + x][j + 1], pri[x] + dp[l][j]);\n        }\n      }\n      int here = 0;\n      for (int j = 0; j < fa[i] + 1; j++) here = max(here, dp[j][sz]);\n      total += here;\n    }\n  printf(\"%d\", total);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXC = 1e5 + 5;\nconst int MAXK = 11;\nconst int MAXN = 505;\nint card[MAXC]{};\nint dp[MAXN][MAXK * MAXN]{};\nint fave[MAXC]{};\nint h[MAXK]{};\nint c, f, K, N;\nint main() {\n  scanf(\" %d%d\", &N, &K);\n  int KN = K * N;\n  for (int i = 0; i < KN; ++i) {\n    scanf(\"%d\", &c);\n    ++card[c];\n  }\n  for (int i = 0; i < N; ++i) {\n    scanf(\"%d\", &f);\n    ++fave[f];\n  }\n  for (int i = 1; i <= K; ++i) scanf(\"%d\", &h[i]);\n  for (int i = 0; i < N; ++i)\n    for (int j = 0; j < KN; ++j)\n      for (int k = 1; (k <= K) && (j + k <= KN); ++k)\n        dp[i + 1][j + k] = std::max(dp[i][j] + h[k], dp[i + 1][j + k]);\n  int ret = 0;\n  for (int i = 1; i < MAXC; ++i) ret += dp[fave[i]][card[i]];\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxk = 20;\nconst int maxn = 500 + 10;\nconst int maxnum = 1e6 + 10;\nint dp[maxn][maxn * maxk];\nint n, K;\nint a[maxn * maxk], val[maxk];\ninline void DP(int ned, int cnt) {\n  memset(dp, -1, sizeof dp);\n  dp[0][0] = 0;\n  for (int i = 1; i <= ned; ++i) {\n    for (int j = 0; j <= i * K; ++j) {\n      for (int k = 0; k <= j && k <= K; ++k)\n        dp[i][j] = max(dp[i][j], dp[i - 1][j - k] + val[k]);\n    }\n  }\n}\nint c[maxnum], ned[maxnum];\nint main() {\n  cin >> n >> K;\n  for (int i = 1; i <= n * K; ++i) {\n    cin >> a[i];\n    ++c[a[i]];\n  }\n  for (int i = 1, t; i <= n; ++i) {\n    cin >> t;\n    ++ned[t];\n  }\n  for (int i = 1; i <= K; ++i) {\n    cin >> val[i];\n  }\n  DP(n, n * K);\n  int ans = 0;\n  for (int i = 1; i < maxnum; ++i)\n    if (ned[i]) ans += dp[ned[i]][min(c[i], ned[i] * K)];\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void setmin(int &x, int y) {\n  if (y < x) x = y;\n}\ninline void setmax(int &x, int y) {\n  if (y > x) x = y;\n}\ninline void setmin(long long &x, long long y) {\n  if (y < x) x = y;\n}\ninline void setmax(long long &x, long long y) {\n  if (y > x) x = y;\n}\nconst int N = 500;\nconst int inf = (int)1e9 + 1;\nconst long long big = (long long)1e18 + 1;\nconst int P = 239;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\nint dp[N + 1][N * 10 + 1];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.precision(20);\n  cout << fixed;\n  int n, k;\n  cin >> n >> k;\n  map<int, int> a, f;\n  int h[k];\n  for (int i = 0; i < n * k; i++) {\n    int x;\n    cin >> x;\n    a[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    f[x]++;\n  }\n  for (int i = 0; i < k; i++) cin >> h[i];\n  dp[0][0] = 0;\n  for (int i = 1; i < n + 1; i++) {\n    for (int j = 0; j < n * k + 1; j++)\n      for (int cnt = 0; cnt < k + 1; cnt++)\n        if (cnt <= j)\n          setmax(dp[i][j], dp[i - 1][j - cnt] + (cnt > 0 ? h[cnt - 1] : 0));\n  }\n  int ans = 0;\n  for (int x = 1; x < 100000 + 1; x++) ans += dp[f[x]][a[x]];\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, cnt[100015], a[500], p[15], f[515][100015], res;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 0, x; i < n * k; i++) cin >> x, cnt[x]++;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  sort(a, a + n);\n  for (int i = 1; i <= k; i++) cin >> p[i];\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n * k; j++)\n      for (int x = 0; x <= min(j, k); x++)\n        f[i][j] = max(f[i][j], f[i - 1][j - x] + p[x]);\n  for (int i = 0, j; i < n; i = j) {\n    for (j = i + 1; j < n && a[i] == a[j]; j++)\n      ;\n    res += f[j - i][cnt[a[i]]];\n  }\n  cout << res;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    \n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] freq = new int[100001];\n        for(int i = 0; i < n * k; ++i) \n            freq[sc.nextInt()]++;\n\n        ArrayList<Integer> adj[] = new ArrayList[100001];\n        for(int i = 0; i <= 100000; ++i)\n            adj[i] = new ArrayList<>();\n        for(int i = 0; i < n; ++i)\n            adj[sc.nextInt()].add(i);\n\n        int[] h = new int[k + 1];\n        for(int i = 1; i <= k; ++i)\n            h[i] = sc.nextInt();\n\n        int ans = 0;\n\n        for(int i = 1; i <= 100000; ++i) {\n            if(adj[i].size() == 0)\n                continue;\n\n            int a[] = new int[adj[i].size() + 1];\n            int m = 1;\n            for(int j : adj[i]) {\n                a[m++] = j;\n            }\n\n            int cnt = freq[i];\n\n            int dp[][] = new int[m][cnt + 1];\n\n            for(int j = 0; j < cnt; ++j)\n                dp[0][j] = -1;\n            dp[0][cnt] = 0;\n\n            for(int j = 1; j < m; ++j) {\n                for(int p = 0; p <= cnt; ++p)\n                    dp[j][p] = -1;\n                for(int p = 0; p <= cnt; ++p) {\n                    for(int l = 0; l <= min(p, k); ++l) {\n                        if(dp[j - 1][p] == -1)\n                            dp[j][p - l] = max(dp[j][p - l], -1);\n                        else\n                            dp[j][p - l] = max(dp[j][p - l], dp[j - 1][p] + h[l]);\n                    }\n                }\n            }\n\n            int cans = 0;\n            for(int j = 0; j <= cnt; ++j) {\n                cans = max(cans, dp[m - 1][j]);\n            }\n\n            ans += cans;\n        }\n\n        w.print(ans);\n\n        w.close();      \n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, c[5005], f[505], h[15];\nint cnt[100005], num[100005], dp[5005][505];\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n * k; i++) scanf(\"%d\", &c[i]), cnt[c[i]]++;\n  for (int i = 0; i < n; i++) scanf(\"%d\", &f[i]), num[f[i]]++;\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &h[i]);\n  for (int i = 1; i <= n * k; i++) {\n    dp[i][1] = h[min(i, k)];\n    for (int j = 2; j <= n; j++) {\n      for (int u = 1; u <= min(i, k); u++) {\n        dp[i][j] = max(dp[i][j], dp[i - u][j - 1] + h[u]);\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i <= 1e5; i++)\n    if (num[i]) ans += dp[cnt[i]][num[i]];\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n/*\n * @author romit17\n */\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\n\npublic class E999{\n    \n    long[][] dp;\n    int n,k;\n    int[] h;\n    void solve() throws IOException {\n        PrintWriter out = new PrintWriter(System.out);\n        StringBuilder sb = new StringBuilder(\"\");        \n        n = ni();\n        k = ni();\n        dp = new long[n+1][(n+1)*(k+1)];\n        int[] c = na(n*k);\n        int[] f = na(n);\n        h = na(k);\n        HashMap<Integer,Integer> fav = new HashMap<>();\n        for(int ff:f)\n        {\n            if(fav.containsKey(ff))\n                fav.put(ff, fav.get(ff)+1);\n            else\n                fav.put(ff, 1);\n        }\n        HashMap<Integer,Integer> card = new HashMap<>();\n        for(int cc:c)\n        {\n            if(card.containsKey(cc))\n                card.put(cc, card.get(cc)+1);\n            else\n                card.put(cc,1);\n        }\n        long ans = 0;\n        for(int crdvl : fav.keySet())\n        {\n            ans += happy(fav.get(crdvl), card.getOrDefault(crdvl,0));\n        }\n        System.out.println(ans);\n    }\n    \n    long happy(int ppl, int crd)\n    {\n        if(ppl<=0 || crd<=0)\n            return 0;\n        if(ppl==1)\n        {\n            return h[Math.min(crd-1, k-1)];\n        }\n        if(crd==1)\n        {\n            return h[0];\n        }\n        if(ppl*k<=crd)\n        {\n            return ppl*h[k-1];\n        }\n        if(dp[ppl][crd]!=0)\n            return dp[ppl][crd];\n        long max = 0;\n        for(int i=0;i<=k&&i<=crd;i++)\n        {\n            max = Math.max(max, happy(1,i) + happy(ppl-1,crd-i));                        \n        }\n        dp[ppl][crd] = max;\n        return max;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        new E999().solve();\n    }    \n    \n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;    \n    InputStream is = System.in;\n    //InputStream is = new ByteArrayInputStream(\"input\".getBytes());\n\n    private int readByte() {\n        if (lenbuf == -1) {\n            throw new InputMismatchException();\n        }\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) {\n                return -1;\n            }\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n    \n    private int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b));\n        return b;\n    }\n    \n    private double nd() {\n        return Double.parseDouble(ns());\n    }\n    \n    private char nc() {\n        return (char) skip();\n    }\n    \n    private String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) {\n            map[i] = ns(m);\n        }\n        return map;\n    }\n    \n    private int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = ni();\n        }\n        return a;\n    }\n    \n    private int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        \n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        \n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int gcd(long long int a, long long int b) {\n  if (b != 0)\n    return gcd(b, a % b);\n  else\n    return a;\n}\nlong long int power(long long int a, long long int b) {\n  if (b == 0) return 1;\n  if (b == 1) return a;\n  if (b % 2 == 0) {\n    long long int t = power(a, b / 2);\n    return t * t;\n  } else {\n    long long int t = power(a, b / 2);\n    return a * t * t;\n  }\n}\nlong long int powin(long long int a, long long int b) {\n  if (b == 0)\n    return 1;\n  else if (b == 1)\n    return a;\n  else if (b % 2 == 0) {\n    long long int t = powin(a, b / 2);\n    return (t * t) % 1000000007;\n  } else {\n    long long int t = powin(a, b / 2);\n    return (((t * t) % 1000000007) * a) % 1000000007;\n  }\n}\nlong long int n, k;\nlong long int dp[509][10 * 509];\nlong long int h[20];\nvoid solve() {\n  for (long long int i = 1; i < n + 1; i++) {\n    for (long long int j = 1; j < k * n + 1; j++) {\n      for (long long int p = 1; p < k + 1; p++) {\n        if (j >= p) dp[i][j] = max(dp[i][j], dp[i - 1][j - p] + h[p]);\n      }\n    }\n  }\n}\nlong long int fr[100000 + 10];\nlong long int f[100000 + 10];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k;\n  memset(dp, 0, sizeof dp);\n  memset(fr, 0, sizeof fr);\n  memset(f, 0, sizeof f);\n  for (long long int i = 0; i < n * k; i++) {\n    long long int t;\n    cin >> t;\n    fr[t]++;\n  }\n  for (long long int i = 0; i < n; i++) {\n    int p;\n    cin >> p;\n    f[p]++;\n  }\n  h[0] = 0;\n  for (long long int i = 1; i < k + 1; i++) {\n    cin >> h[i];\n    dp[1][i] = h[i];\n  }\n  solve();\n  long long int ans = 0;\n  for (long long int i = 1; i < 100000 + 1; i++) {\n    if (f[i] > 0) {\n      long long int temp = 0;\n      for (long long int j = 1; j < f[i] + 1; j++) {\n        temp = max(dp[j][fr[i]], temp);\n      }\n      ans += temp;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\n# ------------------------------\n# f = open('./input.txt')\n# sys.stdin = f\n\ndef main():\n    n, k = RL()\n    cds = RLL()\n    fn = RLL()\n    sc = [0]+RLL()\n\n    rec = set(fn)\n    uses = 0\n    dic = defaultdict(int)\n    for i in cds:\n        if i in rec:\n            dic[i]+=1\n            uses+=1\n\n    dp = [[0]*(n*k+1) for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        for j in range(1, n*k+1):\n            for l in range(k+1):\n                if l>j: break\n                val = sc[l]\n                dp[i][j] = max(dp[i][j], dp[i-1][j-l]+val)\n    res = 0\n\n    for i, v in Counter(fn).items():\n        res+=dp[v][dic[i]]\n    # for i in dp: print(i)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nconst long long inf = 1e18 * 4;\nconst long double pai = acos(-1);\nlong long N, n, k;\nlong long a[100009], f[100009], h[100009], cards[100009], num[100009];\nlong long dp[509][5009];\nvector<pair<long long, long long> > v;\nlong long bt(long long id, long long crnt) {\n  if (id == N || crnt == 0) return 0;\n  long long &ret = dp[id][crnt];\n  if (ret != -1) return ret;\n  ret = 0;\n  v.push_back({id, crnt});\n  for (long long i = 0; i <= k; i++) {\n    if (i > crnt) break;\n    ret = max(ret, bt(id + 1, crnt - i) + h[i]);\n  }\n  return ret;\n}\nint main() {\n  memset(dp, -1, sizeof(dp));\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) cin >> a[i], cards[a[i]]++;\n  for (int i = 0; i < n; i++) cin >> f[i], num[f[i]]++;\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  long long ans = 0;\n  for (long long i = 0; i <= 100000; i++) {\n    N = num[i];\n    ans += bt(0, cards[i]);\n    for (auto u : v) dp[u.first][u.second] = -1;\n    v.clear();\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*; \nimport java.text.DecimalFormat;\n\npublic class Main{\n    final long mod = (int)1e9+7, IINF = (long)1e19;\n    final int MAX = (int)1e6+1, MX = (int)1e7+1, INF = (int)1e9, root = 3;\n    DecimalFormat df = new DecimalFormat(\"0.0000000000000\");\n    double eps = 1e-9;\n    FastReader in;\n    PrintWriter out;\n    static boolean multipleTC = false, memory = false;\n\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, \"1\", 1 << 26).start();\n        else new Main().run();\n    }\n\n    void run() throws Exception{\n        in = new FastReader();\n        out = new PrintWriter(System.out);\n        for(int i = 1, t = (multipleTC)?ni():1; i<=t; i++)solve(i);\n        out.flush();    \n        out.close();\n    }\n    \n    void solve(int TC)throws Exception{\n        int n = ni(), k = ni();\n        int[] f1 = new int[MAX], f2 = new int[MAX];\n        for(int i = 0; i< n*k; i++)f1[ni()]++;\n        for(int i = 0; i< n; i++)f2[ni()]++;\n        long[] h = new long[k+1];\n        for(int i = 1; i<=k; i++)h[i] = nl();\n        long[][] dp = new long[n+1][k*n+1];\n        for(int i = 1; i<= n; i++){\n            for(int j = 1; j<= n*k; j++){\n                for(int l = 0; l<= Math.min(j, k); l++)dp[i][j] = Math.max(dp[i][j], dp[i-1][j-l]+h[l]);\n            }\n        }\n        long ans = 0;\n        for(int i= 0; i< MAX; i++)ans+=dp[f2[i]][f1[i]];\n        pn(ans);\n        \n    }\n    \n    int[] reverse(int[] a){\n        int[] o = new int[a.length];\n        for(int i = 0; i< a.length; i++)o[i] = a[a.length-i-1];\n        return o;   \n    }\n\n    int[] sort(int[] a){\n        if(a.length==1)return a;\n        int mid = a.length/2;\n        int[] b = sort(Arrays.copyOfRange(a,0,mid)), c = sort(Arrays.copyOfRange(a,mid,a.length));\n        for(int i = 0, j = 0, k = 0; i< a.length; i++){\n            if(j<b.length && k<c.length){\n                if(b[j]<c[k])a[i] = b[j++];\n                else a[i] = c[k++];\n            }else if(j<b.length)a[i] = b[j++];\n            else a[i] = c[k++];\n        }\n        return a;\n    }\n\n    long[] sort(long[] a){\n        if(a.length==1)return a;\n        int mid = a.length/2;\n        long[] b = sort(Arrays.copyOfRange(a,0,mid)), c = sort(Arrays.copyOfRange(a,mid,a.length));\n        for(int i = 0, j = 0, k = 0; i< a.length; i++){\n            if(j<b.length && k<c.length){\n                if(b[j]<c[k])a[i] = b[j++];\n                else a[i] = c[k++];\n            }else if(j<b.length)a[i] = b[j++];\n            else a[i] = c[k++];\n        }\n        return a;\n    }\n\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bitcount(long n){return (n==0)?0:(1+bitcount(n&(n-1)));}\n    void p(Object o){out.print(o);}\n    void pn(Object o){out.println(o);}\n    void pni(Object o){out.println(o);out.flush();}\n    String n(){return in.next();}\n    String nln(){return in.nextLine();}\n    int ni(){return Integer.parseInt(in.next());}\n    long nl(){return Long.parseLong(in.next());}\n    double nd(){return Double.parseDouble(in.next());}\n\n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next(){\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine(){\n            String str = \"\";\n            try{\n                str = br.readLine();\n            }catch (IOException e){\n                e.printStackTrace();\n            }   \n            return str;\n        }\n    }\n}      "
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class AA{\n\tpublic static void main(String[] args)throws Throwable {\n\t\tMyScanner sc=new MyScanner();\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\t\n\t\t\n\t\tint n=sc.nextInt();\n\t\tk=sc.nextInt();\n\t\tmem=new Integer[n+1][n*k+1];\n\t\tint mx=(int)1e5+1;\n\t\tint [] cntCard=new int [mx];\n\t\tint [] cntPlayer=new int [mx];\n\t\tfor(int i=0;i<n*k;i++)\n\t\t\tcntCard[sc.nextInt()]++;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcntPlayer[sc.nextInt()]++;\n\t\th=new int [k];\n\t\tfor(int i=0;i<k;i++)\n\t\t\th[i]=sc.nextInt();\n\t\tint ans=0;\n\t\tfor(int i=1;i<mx;i++)\n\t\t\tans+=dp(cntPlayer[i], cntCard[i]);\n\t\tpw.println(ans);\n\t\tpw.flush();\n\t\tpw.close();\n    }\n\tstatic int k;\n\tstatic int [] h;\n\tstatic Integer [][] mem;\n\t\n\tstatic int dp(int i,int r) {\n\t\tif(i==0)\n\t\t\treturn 0;\n\t\tif(mem[i][r]!=null)\n\t\t\treturn mem[i][r];\n\t\tint ans=dp(i-1, r);\n\t\tfor(int c=1;c<=Math.min(r, k);c++)\n\t\t\tans=Math.max(ans, h[c-1]+dp(i-1, r-c));\n\t\treturn mem[i][r]=ans;\n\t}\n\t\n\tstatic class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {while (st == null || !st.hasMoreElements()) {\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (IOException e) {e.printStackTrace();}}\n\t\treturn st.nextToken();}\n\t\tint nextInt() {return Integer.parseInt(next());}\n\t\tlong nextLong() {return Long.parseLong(next());}\n\t\tdouble nextDouble() {return Double.parseDouble(next());}\n\t\tString nextLine(){String str = \"\";\n\t\ttry {str = br.readLine();}\n\t\tcatch (IOException e) {e.printStackTrace();}\n\t\treturn str;}\n\t}\n} "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint h[100010], f[100010], c[100010], dp[2][5010];\nunordered_map<int, int> mp, mpp;\nint main() {\n  cin.tie(0);\n  int ans = 0;\n  ios::sync_with_stdio(0);\n  mp.clear();\n  mpp.clear();\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= k; j++) {\n      cin >> c[i];\n      if (!mp[c[i]]) mp[c[i]] = 0;\n      mp[c[i]]++;\n    }\n  for (int i = 1; i <= n; i++) {\n    cin >> f[i];\n    if (!mpp[f[i]]) mpp[f[i]] = 0;\n    mpp[f[i]]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  for (auto it : mpp) {\n    int cur = 1, pre = 0;\n    int i = it.first, res = 0;\n    int t = it.second, m = mp[i];\n    memset(dp, 0, sizeof(dp));\n    for (int j = 1; j <= t; j++) {\n      for (int l = 0; l <= m && l <= j * k; l++) {\n        for (int p = 0; p <= k && p <= l; p++)\n          if (l - p <= (j - 1) * k)\n            dp[cur][l] = max(dp[cur][l], dp[pre][l - p] + h[p]);\n        res = max(res, dp[cur][l]);\n      }\n      swap(cur, pre);\n    }\n    ans += res;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n@SuppressWarnings(\"unchecked\")\npublic class F995\n{\n   static long time = System.currentTimeMillis();\n   public static void main(String[] args) throws Exception \n   {\n      FastReader infile = new FastReader();\n      //infile = new FastReader(\"text.in\");\n      int n = infile.nextInt();\n      int k = infile.nextInt();\n      int[] count = new int[100001];\n      for(int x = 0; x < n*k; x++)\n         count[infile.nextInt()]++;\n      int[] fav = new int[n];\n      int[] joy = new int[k+1];\n      for(int x = 0; x < n; x++)\n         fav[x] = infile.nextInt();\n      for(int x = 1; x <= k; x++)\n         joy[x] = infile.nextInt();\n      Arrays.sort(fav);\n      long ans = 0;\n      int index = 0;\n      for(int x = 1; x <= 100000; x++)\n      {\n         int p = 0;\n         int y;\n         for(y = index; y < n; y++)\n         {\n            if(fav[y]!=x)\n            {\n               break;\n            }\n         }\n         p = y-index;\n         index = y;\n         if(p==0)\n            continue;\n         int total = count[x];\n         int[][][] dp = new int[total+1][p+1][k+1];\n         int[][] max = new int[total+1][p+1];\n         int maxi = 0;\n         for(int a = 1; a <= total; a++)\n         {\n            for(int b = 1; b <= p; b++)\n            {\n               for(int c = 1; c <= k; c++)\n               {\n                  if(a<c)\n                     break;\n                  dp[a][b][c] = max[a-c][b-1] + joy[c];\n                  max[a][b] = Math.max(max[a][b], dp[a][b][c]);\n                  maxi = Math.max(max[a][b], maxi);\n               }\n            }\n         }\n         ans+=maxi;\n      }\n      StringBuilder sb = new StringBuilder();\n      sb.append(ans);\n      System.out.println(sb);\n      //System.out.println(\"Time: \"+(System.currentTimeMillis()-time));\n   }\n}\nclass FastReader\n{\n   BufferedReader br;\n   StringTokenizer st;\n\n   public FastReader(String file) throws FileNotFoundException\n   {\n      br = new BufferedReader(new FileReader(file));\n   }\n   \n   public FastReader() throws FileNotFoundException\n   {\n      br = new BufferedReader(new InputStreamReader(System.in));\n   }\n \n   String next()\n   {\n      while (st == null || !st.hasMoreElements())\n      {\n         try\n         {\n            st = new StringTokenizer(br.readLine());\n         }\n         catch (IOException  e)\n         {\n            e.printStackTrace();\n         }\n      }\n      return st.nextToken();\n   }\n \n   int nextInt()\n   {\n      return Integer.parseInt(next());\n   }\n \n   long nextLong()\n   {\n      return Long.parseLong(next());\n   }\n \n   double nextDouble()\n   {\n      return Double.parseDouble(next());\n   }\n \n   String nextLine()\n   {\n      String str = \"\";\n      try\n      {\n         str = br.readLine();\n      }\n      catch (IOException e)\n      {\n         e.printStackTrace();\n      }\n      return str;\n   }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 510, K = 20, I = 100010;\nint n = 0, k = 0, c[K * N] = {0}, f[N] = {0}, h[K] = {0};\nint cs[I] = {0}, dp[N][N * K] = {0};\nint via(int a, int b) {\n  if (dp[a][b] != -1) return dp[a][b];\n  if (a == 1) return dp[a][b] = h[min(b, k)];\n  dp[a][b] = via(a - 1, b);\n  for (int i = 1; i <= min(b, k); ++i)\n    dp[a][b] = max(dp[a][b], via(a - 1, b - i) + h[i]);\n  return dp[a][b];\n}\nint main() {\n  memset(dp, -1, sizeof dp);\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < n * k; ++i) scanf(\"%d\", c + i), cs[c[i]]++;\n  for (int i = 0; i < n; ++i) scanf(\"%d\", f + i);\n  sort(f, f + n);\n  for (int i = 1; i <= k; ++i) scanf(\"%d\", h + i);\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    int nps = 1, lps = cs[f[i]];\n    while (f[i + 1] == f[i] && i < n) ++i, ++nps;\n    ans += via(nps, lps);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, c[5005], fa[505], h[15], f[505][5005];\nint solve(int in, int st) {\n  if (in == n + 1) return 0;\n  if (st == n * k + 1) return 0;\n  if (f[in][st] != -1) return f[in][st];\n  int cur = 0, cnt = 0;\n  cur = max(cur, solve(in + 1, st));\n  for (int i = st; i <= n * k; i++) {\n    if (c[i] > fa[in]) break;\n    if (c[i] == fa[in]) {\n      cnt++;\n      cur = max(cur, solve(in + 1, i + 1) + h[cnt]);\n      if (cnt == k) break;\n    }\n  }\n  return f[in][st] = cur;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i <= n * k; i++) cin >> c[i];\n  for (int i = 1; i <= n; i++) cin >> fa[i];\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  sort(c + 1, c + n * k + 1);\n  sort(fa + 1, fa + n + 1);\n  memset(f, -1, sizeof f);\n  cout << solve(1, 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long SZ = 1e5 + 1;\nvector<long long> cnt(SZ);\nvector<long long> fav(SZ);\nvector<long long> h;\nlong long n, k;\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long long i = 0; i < n * k; i++) {\n    long long x;\n    cin >> x;\n    cnt[x]++;\n  }\n  for (long long i = 0; i < n; i++) {\n    long long x;\n    cin >> x;\n    fav[x]++;\n  }\n  h.resize(k + 1);\n  for (long long i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  long long score = 0;\n  for (long long i = 0; i < SZ; i++) {\n    long long dp[fav[i] + 1][cnt[i] + 1];\n    for (long long a = 0; a <= fav[i]; a++) {\n      for (long long b = 0; b <= cnt[i]; b++) {\n        if (a == 0 || b == 0) {\n          dp[a][b] = 0;\n        } else {\n          dp[a][b] = 0;\n          for (long long j = 1; j <= k && b - j >= 0; j++) {\n            dp[a][b] = max(dp[a][b], dp[a - 1][b - j] + h[j]);\n          }\n        }\n      }\n    }\n    score += dp[fav[i]][cnt[i]];\n  }\n  cout << score << '\\n';\n  fflush(stdout);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> fav(1e5 + 5, 0), cnt(1e5 + 5, 0), incr(k + 3, 0);\n  for (int i = 1; i <= k * n; i++) {\n    int x;\n    cin >> x;\n    cnt[x]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    fav[x]++;\n  }\n  incr[0] = 0;\n  for (int i = 1; i <= k; i++) {\n    cin >> incr[i];\n  }\n  int ans = 0;\n  for (int i = 1; i <= 100000; i++) {\n    int dp[fav[i] + 3][cnt[i] + 3];\n    for (int p = 0; p <= fav[i]; p++) {\n      for (int q = 0; q <= cnt[i]; q++) {\n        dp[p][q] = 0;\n      }\n    }\n    for (int p = 1; p <= fav[i]; p++) {\n      for (int q = 0; q <= cnt[i]; q++) {\n        for (int r = 0; r <= k; r++) {\n          if (q - r < 0) {\n            continue;\n          }\n          dp[p][q] = max(dp[p][q], dp[p - 1][q - r] + incr[r]);\n        }\n      }\n    }\n    ans += dp[fav[i]][cnt[i]];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nimport io\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\n#sys.setrecursionlimit(300000)\n#threading.stack_size(10**8)\n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------------------------------------------------------------\n#mod = 9223372036854775807  \nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a+b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n \n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n \n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n \n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n \n \nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n \n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n#---------------------------------Lazy Segment Tree--------------------------------------\n# https://github.com/atcoder/ac-library/blob/master/atcoder/lazysegtree.hpp\nclass LazySegTree:\n    def __init__(self, _op, _e, _mapping, _composition, _id, v):\n        def set(p, x):\n            assert 0 <= p < _n\n            p += _size\n            for i in range(_log, 0, -1):\n                _push(p >> i)\n            _d[p] = x\n            for i in range(1, _log + 1):\n                _update(p >> i)\n \n        def get(p):\n            assert 0 <= p < _n\n            p += _size\n            for i in range(_log, 0, -1):\n                _push(p >> i)\n            return _d[p]\n \n        def prod(l, r):\n            assert 0 <= l <= r <= _n\n \n            if l == r:\n                return _e\n \n            l += _size\n            r += _size\n \n            for i in range(_log, 0, -1):\n                if ((l >> i) << i) != l:\n                    _push(l >> i)\n                if ((r >> i) << i) != r:\n                    _push(r >> i)\n \n            sml = _e\n            smr = _e\n            while l < r:\n                if l & 1:\n                    sml = _op(sml, _d[l])\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    smr = _op(_d[r], smr)\n                l >>= 1\n                r >>= 1\n \n            return _op(sml, smr)\n \n        def apply(l, r, f):\n            assert 0 <= l <= r <= _n\n            if l == r:\n                return\n \n            l += _size\n            r += _size\n \n            for i in range(_log, 0, -1):\n                if ((l >> i) << i) != l:\n                    _push(l >> i)\n                if ((r >> i) << i) != r:\n                    _push((r - 1) >> i)\n \n            l2 = l\n            r2 = r\n            while l < r:\n                if l & 1:\n                    _all_apply(l, f)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    _all_apply(r, f)\n                l >>= 1\n                r >>= 1\n            l = l2\n            r = r2\n \n            for i in range(1, _log + 1):\n                if ((l >> i) << i) != l:\n                    _update(l >> i)\n                if ((r >> i) << i) != r:\n                    _update((r - 1) >> i)\n \n        def _update(k):\n            _d[k] = _op(_d[2 * k], _d[2 * k + 1])\n \n        def _all_apply(k, f):\n            _d[k] = _mapping(f, _d[k])\n            if k < _size:\n                _lz[k] = _composition(f, _lz[k])\n \n        def _push(k):\n            _all_apply(2 * k, _lz[k])\n            _all_apply(2 * k + 1, _lz[k])\n            _lz[k] = _id\n \n        _n = len(v)\n        _log = _n.bit_length()\n        _size = 1 << _log\n        _d = [_e] * (2 * _size)\n        _lz = [_id] * _size\n        for i in range(_n):\n            _d[_size + i] = v[i]\n        for i in range(_size - 1, 0, -1):\n            _update(i)\n \n        self.set = set\n        self.get = get\n        self.prod = prod\n        self.apply = apply\n \n \nMIL = 1 << 20\n \n \ndef makeNode(total, count):\n    # Pack a pair into a float\n    return (total * MIL) + count\n \n \ndef getTotal(node):\n    return math.floor(node / MIL)\n \n \ndef getCount(node):\n    return node - getTotal(node) * MIL\n \n \nnodeIdentity = makeNode(0.0, 0.0)\n \n \ndef nodeOp(node1, node2):\n    return node1 + node2\n    # Equivalent to the following:\n    return makeNode(\n        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)\n    )\n \n \nidentityMapping = -1\n \n \ndef mapping(tag, node):\n    if tag == identityMapping:\n        return node\n    # If assigned, new total is the number assigned times count\n    count = getCount(node)\n    return makeNode(tag * count, count)\n \n \ndef composition(mapping1, mapping2):\n    # If assigned multiple times, take first non-identity assignment\n    return mapping1 if mapping1 != identityMapping else mapping2\n#-------------------------------------------------------------------------\nprime = [True for i in range(10)] \npp=[0]*10\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c=0\n    while (p * p <= n): \n          \n        if (prime[p] == True):\n            c+=1\n            for i in range(p, n+1, p): \n                pp[i]+=1\n                prime[i] = False\n        p += 1\n#---------------------------------Binary Search------------------------------------------\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=arr[n-1]\n    while (left <= right):\n        mid = (right + left)//2\n        if (arr[mid] >= key):\n            res=arr[mid]\n            right = mid-1\n        else:\n            left = mid + 1\n    return res\n\ndef binarySearch1(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=arr[0]\n    while (left <= right):\n        mid = (right + left)//2\n        if (arr[mid] > key):\n            right = mid-1\n        else:\n            res=arr[mid]\n            left = mid + 1\n    return res\n#---------------------------------running code------------------------------------------\nn,k= map(int,input().split(' '))\nl= list(map(int,input().split(' ')))\nf =list(map(int,input().split(' ')))\nh=list(map(int,input().split(' ')))\nd1=dict({(a,0) for a in f})\nd2=dict({(a,0) for a in f})\nfor a in l:\n\tif(a in d1):d1[a]+=1\nfor a in f:\n\td2[a]+=1\n#print(d1,d2)\ndp = [[0 for i in range(520*12)] for j in range(520)]\n#print(len(dp), len(dp[0]))\nfor x in range(n+1):\n\tfor y in range(n*k+1):\n\t\tfor i in range(k+1):\n\t\t\t\tdp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) )\nss=0\nfor i in d1:\n\t#print(dp[d1[i]][d2[i]])\n\tss+=dp[d2[i]][d1[i]]\nprint(ss)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 503, MAXK = 13, MAXC = 1e5 + 3;\nint joy[MAXK], players[MAXC], cards[MAXC], dp[MAXN][MAXC];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < k * n; ++i) {\n    int curr;\n    cin >> curr;\n    ++cards[curr];\n  }\n  for (int i = 0; i < n; ++i) {\n    int fav;\n    cin >> fav;\n    ++players[fav];\n  }\n  for (int i = 1; i <= k; ++i) {\n    cin >> joy[i];\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int i2 = 0; i2 <= n * k; ++i2) {\n      for (int cnt = 0; cnt <= k and i2 + cnt <= n * k; ++cnt) {\n        dp[i + 1][i2 + cnt] = max(dp[i + 1][i2 + cnt], dp[i][i2] + joy[cnt]);\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < MAXC; ++i) {\n    res += dp[players[i]][cards[i]];\n  }\n  cout << res << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> cards;\nint num[200005];\nint used[200005];\nint peo[200001];\nint h[5001];\nint nump[200005];\nint dp[500][5001];\nint main() {\n  int n, k;\n  cin >> n >> k;\n  int type_c = 0;\n  int type_p = 0;\n  for (int i = 1; i <= n * k; i++) {\n    int a1;\n    cin >> a1;\n    cards[a1]++;\n    if (!used[a1]) {\n      used[a1] = 1;\n      type_c++;\n      num[type_c] = a1;\n    }\n  }\n  memset(used, 0, sizeof(used));\n  for (int i = 1; i <= n; i++) {\n    int a1;\n    cin >> a1;\n    peo[a1]++;\n    if (!used[a1]) {\n      used[a1] = 1;\n      type_p++;\n      nump[type_p] = a1;\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  long long ans = 0;\n  for (int i = 1; i <= type_p; i++) {\n    memset(dp, 0, sizeof(dp));\n    for (int j = 1; j <= peo[nump[i]]; j++) {\n      for (int l = 0; l <= cards[nump[i]]; l++) {\n        if (!cards[nump[i]]) continue;\n        for (int x = 0; x <= k; x++) {\n          if (l - x < 0) continue;\n          dp[j][l] = max(dp[j][l], dp[j - 1][l - x] + h[x]);\n        }\n      }\n    }\n    ans += dp[peo[nump[i]]][cards[nump[i]]];\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nostream& operator<<(ostream& o, pair<A, B> a) {\n  return o << a.first << ' ' << a.second;\n}\ntemplate <typename A, typename B>\nistream& operator>>(istream& o, pair<A, B>& a) {\n  return o >> a.first >> a.second;\n}\nconst int mod = 998244353, abc = 864197532, N = 200005, K = 111;\nint dp[5001][501];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> cnt1(100001, 0), cnt2(100001, 0), h(k + 1, 0);\n  for (int i = 0, x; i < n * k; ++i) cin >> x, cnt1[x]++;\n  for (int i = 0, x; i < n; ++i) cin >> x, cnt2[x]++;\n  for (int i = 0; i < k; ++i) cin >> h[i + 1];\n  for (int i = 0; i <= n * k; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      dp[i][j] = -1 << 30;\n    }\n  }\n  dp[0][0] = 0;\n  for (int j = 0; j < n; ++j) {\n    for (int i = 0; i < n * k; ++i) {\n      for (int cnt = 0; cnt <= k; ++cnt)\n        if (i + cnt <= n * k) {\n          dp[i + cnt][j + 1] = max(dp[i + cnt][j + 1], dp[i][j] + h[cnt]);\n        }\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= 100000; ++i)\n    if (cnt2[i] > 0) {\n      cnt1[i] = min(cnt1[i], cnt2[i] * k);\n      ans += dp[cnt1[i]][cnt2[i]];\n    }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint memo[5001][501];\nint k;\nint h[11];\nlong long distribute(int cards, int players) {\n  if (cards <= 0 or players <= 0) return 0;\n  if (cards >= k * players) return players * h[k];\n  if (memo[cards][players] != -1) {\n    return memo[cards][players];\n  }\n  int min_cards = max(0, cards - k * (players - 1));\n  long long best = 0;\n  for (int c = min_cards; c <= min(k, cards); ++c) {\n    best = max(best, h[c] + distribute(cards - c, players - 1));\n  }\n  return memo[cards][players] = best;\n}\nvoid solve() {\n  memset(memo, -1, sizeof memo);\n  int n;\n  cin >> n >> k;\n  vector<int> c, f;\n  c.reserve(n * k);\n  copy_n(istream_iterator<int>(cin), n * k, back_inserter(c));\n  f.reserve(n);\n  copy_n(istream_iterator<int>(cin), n, back_inserter(f));\n  h[0] = 0;\n  for (int i = 1; i <= k; ++i) cin >> h[i];\n  sort(begin(c), end(c));\n  sort(begin(f), end(f));\n  long long joy = 0;\n  auto itf = begin(f);\n  auto itc = begin(c);\n  while (itf != end(f)) {\n    int x = *itf;\n    auto foo = equal_range(itf, end(f), x);\n    auto bar = equal_range(itc, end(c), x);\n    joy += distribute(bar.second - bar.first, foo.second - foo.first);\n    itf = foo.second;\n    itc = bar.second;\n  }\n  cout << joy << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint sum[100010], num[100010], dp[5010][510], val[20];\nint main() {\n  int n, m, x;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n * m; i++) {\n    scanf(\"%d\", &x);\n    num[x]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &x);\n    sum[x]++;\n  }\n  for (int i = 1; i <= m; i++) scanf(\"%d\", &val[i]);\n  for (int i = 0; i <= n * m; i++) {\n    for (int j = 1; j <= n; j++) {\n      for (int k = 0; k <= min(m, i); k++) {\n        dp[i][j] = max(dp[i][j], dp[i - k][j - 1] + val[k]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= 100000; i++) {\n    ans += dp[num[i]][sum[i]];\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble const EPS = 1.0E-9;\nint const MOD = (int)1e9 + 7;\ninline void read(char* s) { scanf(\"%s\", s); }\ninline void read(int& x) { scanf(\"%d\", &(x)); }\ninline void read(long long& x) { scanf(\"%lld\", &x); }\ninline void read(double& x) { scanf(\"%lf\", &x); }\ninline void writeln(int x) { printf(\"%d\\n\", x); }\ninline void writeln(long long x) { printf(\"%lld\\n\", x); }\ninline void writeln(double x) { printf(\"%.12f\\n\", x); }\ntemplate <typename... T>\nvoid read(T&... args) {\n  using swallow = int[];\n  swallow w = {0, (read(args), 0)...};\n}\ninline long long gcd(long long x, long long y) {\n  return y == 0 ? x : gcd(y, x % y);\n}\ninline long long lcm(long long x, long long y) {\n  return x == 0 && y == 0 ? 0 : x / gcd(x, y) * y;\n}\ninline long long powmod(long long x, long long n, long long m = MOD) {\n  long long r = 1;\n  while (n) {\n    if (n & 1) r = (r * x) % m;\n    x = (x * x) % m;\n    n /= 2;\n  }\n  return r;\n}\nstatic int leap(int y) { return y % 4 == 0 && y % 100 != 0 || y % 400 == 0; }\nstatic int const month[2][12] = {\n    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},\n    {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}};\nstatic const int N = 1 << 18;\nstatic const int M = 1 << 20;\nint freq[N];\nint n, k;\nint f[N];\nint h[12];\nint hw[5012][512];\nstatic int solve() {\n  read(n, k);\n  for (int i = 1; i <= n * k; ++i) {\n    int a;\n    read(a);\n    freq[a]++;\n  }\n  for (int i = 1; i <= n; ++i) {\n    int x;\n    read(x);\n    f[x]++;\n  }\n  for (int i = 1; i <= k; ++i) {\n    read(h[i]);\n  }\n  for (int i = 0; i < 5012; ++i) {\n    for (int j = 0; j < 512; ++j) {\n      if (i == 0 || j == 0) {\n        hw[i][j] = 0;\n      } else {\n        hw[i][j] = 0;\n        for (int l = 0; l <= k && l <= i; ++l) {\n          hw[i][j] = std::max(hw[i][j], hw[i - l][j - 1] + h[l]);\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = (0), vzq_b = (N); i < vzq_b; ++i) {\n    int fa = f[i];\n    ans += hw[freq[i]][fa];\n  }\n  writeln(ans);\n  return 0;\n}\nint main(int argc, char* argv[]) {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint cnt[100005], h[15], memo[5005][505];\nint DP(int rem, int group) {\n  if (group == 0 || rem == 0) {\n    return 0;\n  } else if (memo[rem][group] != -1) {\n    return memo[rem][group];\n  } else {\n    int ret = 0;\n    for (int i = 1; i <= min(k, rem); i++) {\n      ret = max(ret, DP(rem - i, group - 1) + h[i]);\n    }\n    return memo[rem][group] = ret;\n  }\n}\nint main() {\n  int ans = 0;\n  map<int, int> mp;\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0, in; i < n * k; i++) {\n    scanf(\"%d\", &in);\n    cnt[in]++;\n  }\n  for (int i = 0, in; i < n; i++) {\n    scanf(\"%d\", &in);\n    mp[in]++;\n  }\n  for (int i = 1; i <= k; i++) {\n    scanf(\"%d\", h + i);\n  }\n  memset(memo, -1, sizeof(memo));\n  for (auto it = mp.begin(); it != mp.end(); it++) {\n    ans += DP(min(cnt[it->first], it->second * k), it->second);\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std;\nlong long dp[501][5001];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long card[5001], f[501], h[11], n, k, i, j, p, q, r, demand[100001],\n      supply[100001], ans = 0;\n  for (i = 0; i < 100001; i++) demand[i] = supply[i] = 0;\n  map<long long, long long> make_pair;\n  cin >> n >> k;\n  for (i = 0; i < n * k; i++) {\n    cin >> card[i];\n    supply[card[i]]++;\n  }\n  for (i = 0; i < n; i++) {\n    cin >> f[i];\n    demand[f[i]]++;\n  }\n  h[0] = 0;\n  for (i = 1; i < k + 1; i++) cin >> h[i];\n  for (j = 0; j < 501; j++) dp[0][j] = 0;\n  for (p = 1; p < 501; p++) {\n    for (q = 1; q < 5001; q++) {\n      dp[p][q] = dp[p - 1][q];\n      for (r = 1; r < q + 1; r++) {\n        if (r > k) break;\n        dp[p][q] = max(dp[p][q], dp[p - 1][q - r] + h[r]);\n      }\n    }\n  }\n  for (i = 1; i < 100001; i++) {\n    ans += dp[demand[i]][supply[i]];\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar _;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long fpow(long long b, long long exp, long long mod) {\n  if (exp == 0) return 1;\n  long long t = fpow(b, exp / 2, mod);\n  if (exp & 1) return t * t % mod * b % mod;\n  return t * t % mod;\n}\nint num_people, num_each, cnt[100005], happ[100005], fav[100005], dp[505][5005];\nlong long res;\nint solve(int rem_people, int rem_cards) {\n  if (rem_people == 0 || rem_cards == 0) return 0;\n  if (dp[rem_people][rem_cards] != -1) return dp[rem_people][rem_cards];\n  int ans = 0;\n  for (int i = 1; i <= num_each; i++)\n    if (rem_cards >= i)\n      ans = max(ans, happ[i] + solve(rem_people - 1, rem_cards - i));\n  return dp[rem_people][rem_cards] = ans;\n}\nint main() {\n  scanf(\"%d %d\", &num_people, &num_each);\n  for (int i = 1; i <= num_people * num_each; i++) {\n    int card;\n    scanf(\" %d\", &card);\n    cnt[card]++;\n  }\n  for (int i = 1; i <= num_people; i++) {\n    int f;\n    scanf(\" %d\", &f);\n    fav[f]++;\n  }\n  for (int i = 1; i <= num_each; i++) scanf(\" %d\", &happ[i]);\n  for (int i = 1; i <= 1e5; i++) {\n    if (fav[i]) {\n      memset(dp, -1, sizeof dp);\n      res += solve(fav[i], cnt[i]);\n    }\n  }\n  printf(\"%lld\\n\", res);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class _999_F_CardsAndJoy {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tint N = readInt(), K = readInt(); long dp[][] = new long[N+1][N*K+1];\n\t\tint mod[] = new int[100001]; for(int i = 1; i<=N*K; i++) mod[readInt()]++;\n\t\tint fav[] = new int[100001]; for(int i = 1; i<=N; i++) fav[readInt()]++;\n\t\tint val[] = new int[K+1]; for(int i =1; i<=K; i++) val[i] =readInt();\n\t\tfor(int i = 1; i<=N; i++) for(int j = 1; j<=N*K; j++) for(int k = 1; k<=K && k<=j; k++) \n\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i-1][j-k] + val[k]);\n\t\tlong tot = 0; for(int i =1; i<=100000; i++) tot += dp[fav[i]][mod[i]]; println(tot);\n\t\texit();\n\t}\n\n\tfinal private static int BUFFER_SIZE = 1 << 16;\n\tprivate static DataInputStream din = new DataInputStream(System.in);\n\tprivate static byte[] buffer = new byte[BUFFER_SIZE];\n\tprivate static int bufferPointer = 0, bytesRead = 0;\n\tstatic PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n\tpublic static String readLine() throws IOException {\n\t\tbyte[] buf = new byte[64]; // line length\n\t\tint cnt = 0, c;\n\t\twhile ((c = Read()) != -1) {\n\t\t\tif (c == '\\n')\n\t\t\t\tbreak;\n\t\t\tbuf[cnt++] = (byte) c;\n\t\t}\n\t\treturn new String(buf, 0, cnt);\n\t}\n\n\tpublic static String read() throws IOException {\n\t\tbyte[] ret = new byte[1024];\n\t\tint idx = 0;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ') {\n\t\t\tc = Read();\n\t\t}\n\t\tdo {\n\t\t\tret[idx++] = c;\n\t\t\tc = Read();\n\t\t} while (c != -1 && c != ' ' && c != '\\n' && c != '\\r');\n\t\treturn new String(ret, 0, idx);\n\t}\n\n\tpublic static int readInt() throws IOException {\n\t\tint ret = 0;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ')\n\t\t\tc = Read();\n\t\tboolean neg = (c == '-');\n\t\tif (neg)\n\t\t\tc = Read();\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while ((c = Read()) >= '0' && c <= '9');\n\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\n\tpublic static long readLong() throws IOException {\n\t\tlong ret = 0;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ')\n\t\t\tc = Read();\n\t\tboolean neg = (c == '-');\n\t\tif (neg)\n\t\t\tc = Read();\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while ((c = Read()) >= '0' && c <= '9');\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\n\tpublic static double readDouble() throws IOException {\n\t\tdouble ret = 0, div = 1;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ')\n\t\t\tc = Read();\n\t\tboolean neg = (c == '-');\n\t\tif (neg)\n\t\t\tc = Read();\n\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while ((c = Read()) >= '0' && c <= '9');\n\n\t\tif (c == '.') {\n\t\t\twhile ((c = Read()) >= '0' && c <= '9') {\n\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t}\n\t\t}\n\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\n\tprivate static void fillBuffer() throws IOException {\n\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\tif (bytesRead == -1)\n\t\t\tbuffer[0] = -1;\n\t}\n\n\tprivate static byte Read() throws IOException {\n\t\tif (bufferPointer == bytesRead)\n\t\t\tfillBuffer();\n\t\treturn buffer[bufferPointer++];\n\t}\n\n\tstatic void print(Object o) {\n\t\tpr.print(o);\n\t}\n\n\tstatic void println(Object o) {\n\t\tpr.println(o);\n\t}\n\n\tstatic void flush() {\n\t\tpr.flush();\n\t}\n\n\tstatic void println() {\n\t\tpr.println();\n\t}\n\n\tstatic void exit() throws IOException {\n\t\tdin.close();\n\t\tpr.close();\n\t\tSystem.exit(0);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k;\n  cin >> n >> k;\n  int limit = n * k;\n  unordered_map<int, int> count;\n  for (int i = 0; i < limit; i++) {\n    int c;\n    cin >> c;\n    count[c]++;\n  }\n  unordered_map<int, int> fav;\n  for (int i = 0; i < n; i++) {\n    int f;\n    cin >> f;\n    fav[f]++;\n  }\n  vector<int> joy = {0};\n  for (int i = 0; i < k; i++) {\n    int j;\n    cin >> j;\n    joy.push_back(j);\n  }\n  vector<vector<int>> dp(n + 1, vector<int>(limit + 1, 0));\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= limit; j++) {\n      int mx = 0;\n      int lim = min(k, j);\n      for (int m = 0; m <= lim; m++) {\n        mx = max(dp[i - 1][j - m] + joy[m], mx);\n      }\n      dp[i][j] = mx;\n    }\n  }\n  int ans = 0;\n  for (auto &pa : fav) {\n    int card = count[pa.first];\n    ans += dp[pa.second][card];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD1 = 1e9 + 7;\nconst int MOD2 = 998244353;\nconst long long INF = 2 * 1e18;\nconst long double PI = 3.14159265358979323846;\nlong long dp[505][5050] = {0}, h[15] = {0};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ;\n  long long n, k, mxc = 0, mxf = 0, ans = 0, c, f;\n  map<long long, long long> mc, mf;\n  cin >> n >> k;\n  for (int i = 0; i < k * n; i++) {\n    cin >> c;\n    mc[c]++;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> f;\n    mf[f]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < k * n + 1; j++) {\n      for (int a = 0; a < k + 1; a++)\n        dp[i][j + a] = max(dp[i][j + a], dp[i - 1][j] + h[a]);\n    }\n  }\n  for (int i = 1; i <= 100005; i++)\n    if (mf[i] != 0) ans += dp[mf[i]][mc[i]];\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nlong long mod = 1000000007;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long lcm(long long a, long long b) { return a * (b / gcd(a, b)); }\nbool is_vowel(char c) {\n  if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') return 1;\n  return 0;\n}\ndouble getDistance(double x1, double y1, double x2, double y2) {\n  return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\nlong long extended_euclidean(long long a, long long b, long long &x,\n                             long long &y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long g = extended_euclidean(b, a % b, y, x);\n  y -= (a / b) * x;\n  return g;\n}\nlong long power(long long base, long long p) {\n  if (p == 1) return base;\n  if (!p) return 1ll;\n  long long ret = power(base, p / 2);\n  ret *= ret;\n  ret %= mod;\n  if (p & 1) ret *= base;\n  return ret % mod;\n}\npair<long long, long long> vec(pair<long long, long long> a,\n                               pair<long long, long long> b) {\n  pair<long long, long long> ret =\n      pair<long long, long long>(a.first - b.first, a.second - b.second);\n  return ret;\n}\nlong long getArea(pair<long long, long long> a, pair<long long, long long> b,\n                  pair<long long, long long> c) {\n  pair<long long, long long> x = vec(a, b);\n  pair<long long, long long> y = vec(c, b);\n  return abs(x.first * y.second - x.second * y.first);\n}\nint h[505], cnt[100005], n, k, kam[100005];\nlong long dp[505][5005];\nlong long solve(int p, int fadl) {\n  if (fadl == 0 || p == 0) return 0;\n  if (dp[p][fadl] != -1) return dp[p][fadl];\n  long long ret = 0;\n  for (int i = (0); i <= (min(fadl, k)); ++i)\n    ret = max(ret, solve(p - 1, fadl - i) + h[i]);\n  return dp[p][fadl] = ret;\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = (0); i <= (n * k - 1); ++i) {\n    int c;\n    scanf(\"%d\", &c);\n    cnt[c]++;\n  }\n  for (int i = (0); i <= (n - 1); ++i) {\n    int a;\n    scanf(\"%d\", &a);\n    kam[a]++;\n  }\n  for (int i = (1); i <= (k); ++i) scanf(\"%d\", &h[i]);\n  long long sum = 0;\n  memset(dp, -1, sizeof(dp));\n  for (int i = (0); i <= (100000); ++i) {\n    sum += solve(kam[i], cnt[i]);\n  }\n  cout << sum;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint n, k, a[maxn], f[5005], w[15];\nint cnt[maxn], num[maxn], dp[5005][521];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  memset(cnt, 0, sizeof cnt);\n  memset(num, 0, sizeof num);\n  cin >> n >> k;\n  for (int i = 1; i <= n * k; i++) cin >> a[i], cnt[a[i]]++;\n  for (int i = 1; i <= n; i++) cin >> f[i], num[f[i]]++;\n  for (int i = 1; i <= k; i++) cin >> w[i];\n  for (int i = 1; i <= n * k; i++) {\n    dp[i][1] = w[min(i, k)];\n    for (int j = 2; j <= n; j++) {\n      for (int u = 1; u <= min(i, k); u++)\n        dp[i][j] = max(dp[i][j], dp[i - u][j - 1] + w[u]);\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i < maxn; i++)\n    if (num[i]) ans += dp[cnt[i]][num[i]];\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint arr[5005];\nint Favo[505];\nint cost[11];\nint dp[5005][505][11];\nint solve(int idx, int f, int rem) {\n  if (idx == n * k || f == n) return cost[rem];\n  int &ret = dp[idx][f][rem];\n  if (~ret) return ret;\n  if (rem < k && arr[idx] == Favo[f])\n    ret = max(ret, solve(idx + 1, f, rem + 1));\n  ret = max(ret, solve(idx, f + 1, 0) + cost[rem]);\n  ret = max(ret, solve(idx + 1, f, rem));\n  return ret;\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (size_t i = 0; i < n * k; i++) {\n    scanf(\"%d\", &arr[i]);\n  }\n  sort(arr, arr + (n * k));\n  for (size_t i = 0; i < n; i++) {\n    scanf(\"%d\", &Favo[i]);\n  }\n  sort(Favo, Favo + n);\n  for (size_t i = 1; i <= k; i++) {\n    scanf(\"%d\", &cost[i]);\n  }\n  memset(dp, -1, sizeof dp);\n  printf(\"%d\", solve(0, 0, 0));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\nint dp[N][K * N];\nint main() {\n  cin >> n >> k;\n  h = vector<int>(k + 1);\n  for (int i = 0; i < n * k; ++i) {\n    int x;\n    cin >> x;\n    ++c[x];\n  }\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    ++f[x];\n  }\n  for (int i = 1; i <= k; ++i) cin >> h[i];\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j <= n * k; ++j) {\n      for (int cur = 0; cur <= k; ++cur) {\n        dp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < C; ++i) {\n    if (f[i] != 0) ans += dp[f[i]][c[i]];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\n\npublic class Main {\n    static PrintWriter out;\n    static Reader in;\n    public static void main(String[] args) throws IOException {\n        input_output();\n        //out = new PrintWriter(System.out);\n        //in = new Reader(new FileInputStream(\"card.in\"));\n        Main solver = new Main();\n        solver.solve();\n        out.close(); \n        out.flush(); \n    }\n\n    static int INF = (int)1e9+2;\n    static int maxn = (int)1e5+5;\n    static int mod = (int)1e9+7;\n    static int n, m, q, t, k;\n    static double pi = 3.141592653589;\n\n    void solve() throws IOException{\n        n = in.nextInt();\n        k = in.nextInt();\n\n        int[] cnt = new int[maxn];\n        for (int i = 0; i < n*k; i++) cnt[in.nextInt()]++;\n        int[] fav = new int[maxn];\n        for (int i = 0; i < n; i++) fav[in.nextInt()]++;\n        int[] h = new int[k+1];\n        for (int i = 1; i <= k; i++) h[i] = in.nextInt();\n\n        long[][] dp = new long[n+1][k*n+1];\n        for (int i = 0; i <= k; i++) dp[1][i] = h[i];\n\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < n*k+1; j++) {\n                for (int add = 0; add <= k && j+add < n*k+1; add++) {\n                    dp[i+1][j+add] = Math.max(dp[i+1][j+add], dp[i][j]+h[add]);\n                }\n            }\n        }\n\n\n        long ans = 0;\n        for (int i = 1; i < maxn; i++) {\n            ans += dp[fav[i]][Math.min(cnt[i], fav[i]*k)];\n        }\n\n        out.println(ans);\n    }\n\n    //<>\n\n    static class Reader {\n \n        private InputStream mIs;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n    \n        public Reader() {\n            this(System.in);\n        }\n    \n        public Reader(InputStream is) {\n            mIs = is;\n        }\n    \n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n    \n        }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = mIs.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n    \n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n    \n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n    \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n    \n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n    \n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    \n        public boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n \n    }\n    static void input_output() throws IOException {\n        File f = new File(\"in.txt\");\n        if(f.exists() && !f.isDirectory()) { \n            in = new Reader(new FileInputStream(\"in.txt\"));\n        } else in = new Reader();\n        f = new File(\"out.txt\");\n        if(f.exists() && !f.isDirectory()) {\n            out = new PrintWriter(new File(\"out.txt\"));\n        } else out = new PrintWriter(System.out);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from __future__ import print_function\nfrom collections import Counter\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\n# CONFIG\nsys.setrecursionlimit(10**9)\n\n# LOG\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return map(int, input().split())\n\n\ndef nio(offset):\n    return map(lambda x: int(x) + offset, input().split())\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef sortId(arr):\n    return sorted(range(arr), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = nia()\nh.insert(0,0)\n\ncc = Counter(c)\ncf = Counter(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n    # log(dp[ni])\n\n# log(n,k)\n# log(\"c\", cc)\n# log(\"f\", cf)\n# log(\"h\", h)\n# log(dp)\n\nres = 0\n\n\nfor fk,fv in cf.items():\n    # log(fk, fv, cc.get(fk,0))\n    res += dp[fv][cc[fk]]\n\nprint(res)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double ld;\ntemplate <typename T>\ninline void setmin(T &x, T y) {\n  if (y < x) x = y;\n}\ntemplate <typename T>\ninline void setmax(T &x, T y) {\n  if (y > x) x = y;\n}\ntemplate <typename T>\ninline T gcd(T a, T b) {\n  while (b) swap(a %= b, b);\n  return a;\n}\nconst long long MOD = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nconst long long LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst ld PI = acos(-1);\nconst int N = 5007;\nint c[N], f[N], h[N];\nconst int M = 1e5 + 7;\nint cnt1[M], cnt2[M];\nint dp[N][N];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    cin >> c[i];\n    cnt1[c[i]]++;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> f[i];\n    cnt2[f[i]]++;\n  }\n  for (int i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  for (int i = 1; i < n + 1; i++) {\n    for (int j = 0; j < k + 1; j++) {\n      for (int l = j; l < n * k + 1; l++) {\n        setmax(dp[i][l], dp[i - 1][l - j] + h[j]);\n      }\n    }\n  }\n  for (int i = 1; i < n + 1; i++) {\n    for (int j = 1; j < n * k + 1; j++) {\n      setmax(dp[i][j], dp[i][j - 1]);\n    }\n  }\n  long long res = 0;\n  for (int i = 0; i < M; i++) {\n    if (cnt2[i] > 0) {\n      int temp = cnt1[i], temp2 = cnt2[i];\n      if (temp >= n * k)\n        res += h[k] * temp2;\n      else\n        res += dp[temp2][temp];\n    }\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\n\nn, k = [int(x) for x in input().split()]\nc = [int(x) for x in input().split()]\nf = [int(x) for x in input().split()]\nh = [0] + [int(x) for x in input().split()]\n\ncnt_all = Counter(c)\ncnt_fav = Counter(f)\n\nans = 0\nfor fi in cnt_fav:\n    if fi not in cnt_all:\n        continue\n    m = cnt_fav[fi]\n    t = min(cnt_all[fi], m * k)\n    dp = [[0] * (t + 1) for _ in range(m + 1)]\n    for x in range(1, m + 1):\n        for s in range(0, t + 1):\n            for ki in range(0, k + 1):\n                if ki + s > t:\n                    break\n                dp[x][ki + s] = max(dp[x][ki + s], dp[x - 1][s] + h[ki])\n    ans += dp[m][t]\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "//package c490;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Fproblem\n{\n\tpublic static void main(String[] wxargs)\n\t{\n\t\tFastReader reader = new FastReader();\n\t\tPrintWriter writer = new PrintWriter(System.out);\n\n\t\tint n = reader.nextInt();\n\t\tint k = reader.nextInt();\n\t\tint[] cards = new int[100001];\n\t\tint[] players = new int[100001];\n\t\tint[] happy = new int[k+1];\n\t\t\n\t\tfor (int i=0; i<k*n; i++)\n\t\t\tcards[reader.nextInt()]++;\n\t\tfor (int i=0; i<n; i++)\n\t\t\tplayers[reader.nextInt()]++;\n\t\tfor (int i=1; i<=k; i++)\n\t\t\thappy[i] = reader.nextInt();\n\t\t\n\t\tlong ans = 0;\n\t\t\n\t\tfor (int i=1; i<100001; i++)\n\t\t{\n\t\t\tif (cards[i]>0 && players[i]>0)\n\t\t\t{\n\t\t\t\tint a = cards[i];\n\t\t\t\tint b = players[i];\n\t\t\t\tlong[][] dp = new long[a+1][b+1];\n\t\t\t\tfor (int j=1; j<=a; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int t=1; t<=b; t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int y=0; y<=k; y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (j-y >= 0)\n\t\t\t\t\t\t\t\tdp[j][t] = Math.max (dp[j][t], dp[j-y][t-1] + happy[y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans += dp[a][b];\n\t\t\t}\n\t\t}\n\n\t\twriter.println(ans);\n\t\twriter.close();\n\t}\n\n\tstatic class FastReader\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader()\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next()\n\t\t{\n\t\t\twhile (st == null || !st.hasMoreElements())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine()\n\t\t{\n\t\t\tString str = \"\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstr = br.readLine();\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint cnt[5050 * 100], player[5050 * 100], n, k, h[5050];\nlong long dp[5050][5050];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> k;\n  for (int i = (1); i <= (n * k); ++i) {\n    int x;\n    cin >> x;\n    cnt[x]++;\n  }\n  for (int i = (1); i <= (n); ++i) {\n    int x;\n    cin >> x;\n    player[x]++;\n  }\n  for (int i = (1); i <= (k); ++i) cin >> h[i];\n  for (int i = (1); i <= (n); ++i) {\n    for (int j = (1); j <= (n * k); ++j) {\n      for (int z = (1); z <= (k); ++z)\n        if (z <= j) {\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - z] + h[z]);\n        }\n    }\n  }\n  long long ans = 0;\n  for (int i = (1); i <= (1e5); ++i) {\n    ans += dp[player[i]][cnt[i]];\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class S, class T>\npair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) {\n  return pair<S, T>(s.first + t.first, s.second + t.second);\n}\ntemplate <class S, class T>\npair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) {\n  return pair<S, T>(s.first - t.first, s.second - t.second);\n}\ntemplate <class S, class T>\nostream &operator<<(ostream &os, pair<S, T> p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nconst long long inf = 1000000001;\nconst long long INF = 2e18;\nconst long long MOD = 1000000007;\nconst double pi = 3.14159265358979323846;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nint dx2[8] = {1, 1, 0, -1, -1, -1, 0, 1}, dy2[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<long long> _c(k * n);\n  vector<int> c_num(100010), p_num(100010);\n  for (long long i = 0; i < (long long)(k * n); i++) {\n    cin >> _c[i];\n    _c[i]--;\n    c_num[_c[i]]++;\n  }\n  vector<long long> f(n);\n  for (long long i = 0; i < (long long)(n); i++) {\n    cin >> f[i];\n    f[i]--;\n    p_num[f[i]]++;\n  }\n  vector<long long> h(k + 1);\n  for (long long i = 1; i <= (long long)(k); i++) {\n    cin >> h[i];\n  }\n  vector<vector<long long> > dp(n + 1, vector<long long>(n * k + 1, -INF));\n  dp[0][0] = 0;\n  for (long long i = 0; i < (long long)(n); i++) {\n    for (long long j = 0; j < (long long)(n * k + 1); j++) {\n      for (long long l = 0; l < (long long)(k + 1); l++) {\n        if (j + l > n * k) {\n          break;\n        }\n        chmax(dp[i + 1][j + l], dp[i][j] + h[l]);\n      }\n    }\n  }\n  int nokori = 0;\n  long long ans = 0;\n  for (long long i = 0; i < (long long)(100000); i++) {\n    long long c = c_num[i], p = p_num[i];\n    if (c == 0) {\n      continue;\n    }\n    if (c >= p * k) {\n      ans += h[k] * p;\n      nokori += c - p * k;\n      continue;\n    }\n    ans += dp[p][c];\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long ThaoNguyen = 1e5 + 5, mod = 1e9 + 7;\nlong long dp[5005][15], n, k, h[12], getmax[505][5005];\nlong long cnt[ThaoNguyen], cntfav[ThaoNguyen];\nsigned main() {\n  cin >> n >> k;\n  for (long long i = 1; i <= n * k; i++) {\n    long long temp;\n    cin >> temp;\n    cnt[temp]++;\n  }\n  for (long long i = 1; i <= n; i++) {\n    long long temp;\n    cin >> temp;\n    cntfav[temp]++;\n  }\n  for (long long i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= i * k; j++) {\n      for (long long cnt = 0; cnt <= min(k, j); cnt++) {\n        dp[j][cnt] = getmax[i - 1][j - cnt] + h[cnt];\n        getmax[i][j] = max(getmax[i][j], dp[j][cnt]);\n      }\n    }\n  }\n  long long ans = 0;\n  for (long long i = 1; i < ThaoNguyen; i++) {\n    if (cntfav[i] > 0) {\n      ans += getmax[cntfav[i]][min(cnt[i], cntfav[i] * k)];\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid guan() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n}\nconst int maxn = 100010;\nconst long long mod = 1e9 + 7;\nconst double pi = acos(-1.0);\nconst long long maxx = 1LL << 61;\nconst double eps = 1e-7;\nint n, k;\ninline int read() { return cin >> n >> k ? 1 : 0; }\nint dp[510][12][5100];\nint h[555], f[555];\nmap<int, int> cnt;\nmap<int, int> p;\nvoid init() {\n  int tk = k;\n  memset(dp, 0, sizeof(dp));\n  for (int i = 0; i <= 10; i++) dp[0][i][0] = 0;\n  for (int i = 1; i <= 505; i++) {\n    for (int k = 1; k <= 5010; ++k) {\n      for (int j = 1; j <= tk; j++) {\n        int maxx = 0;\n        if (j > k) break;\n        for (int q = 1; q <= j; q++) {\n          maxx = max(dp[i - 1][q][k - j], maxx);\n        }\n        dp[i][j][k] = h[j] + maxx;\n      }\n    }\n  }\n}\nvoid solve() {\n  for (int i = 1; i <= k * n; i++) {\n    int t;\n    cin >> t;\n    cnt[t]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> f[i];\n    p[f[i]]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  init();\n  int ans = 0;\n  for (map<int, int>::iterator it = p.begin(); it != p.end(); ++it) {\n    int nump = it->second, sum = cnt[it->first];\n    sum = min(sum, nump * k);\n    int maxx = 0;\n    for (int i = 1; i <= k; i++) {\n      maxx = max(maxx, dp[nump][i][sum]);\n    }\n    ans += maxx;\n  }\n  cout << ans << endl;\n}\nint main() {\n  guan();\n  int t = 1;\n  while (t--) {\n    while (read()) solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid optimise() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n}\nlong long int mod = (long long int)1e9 + 7;\nvoid normalize(long long int &a) { a = (a + mod) % mod; }\nlong long int modmul(long long int a, long long int b) {\n  a = a % mod;\n  b = b % mod;\n  normalize(a);\n  normalize(b);\n  return (a * b) % mod;\n}\nlong long int modadd(long long int a, long long int b) {\n  a = a % mod;\n  b = b % mod;\n  normalize(a);\n  normalize(b);\n  return (a + b) % mod;\n}\nlong long int modsub(long long int a, long long int b) {\n  a = a % mod;\n  b = b % mod;\n  normalize(a);\n  normalize(b);\n  return (a - b + mod) % mod;\n}\nlong long int me(long long int x, long long int n) {\n  x %= mod;\n  if (n == 0) return 1;\n  long long int u = me(x, n / 2) % mod;\n  u = (u * u) % mod;\n  if (n % 2) u = (u * x) % mod;\n  return u;\n}\nlong long int me1(long long int x, long long int n) {\n  if (n == 0) return 1;\n  long long int u = me1(x, n / 2);\n  u = u * u;\n  if (n % 2) u = u * x;\n  return u;\n}\ninline long long int modInv(long long int a) { return me(a, mod - 2); }\ninline long long int modDiv(long long int a, long long int b) {\n  return modmul(a, modInv(b));\n}\nfloat power(float x, long long int y) {\n  float temp;\n  if (y == 0) return 1;\n  temp = power(x, y / 2);\n  if (y % 2 == 0)\n    return temp * temp;\n  else {\n    if (y > 0)\n      return x * temp * temp;\n    else\n      return (temp * temp) / x;\n  }\n}\nlong long int __gcd(long long int a, long long int b) {\n  if (b == 0)\n    return a;\n  else\n    return __gcd(b, a % b);\n}\npair<long long int, long long int> operator+(\n    pair<long long int, long long int> a,\n    pair<long long int, long long int> b) {\n  return {a.first + b.first, a.second + b.second};\n}\npair<long long int, long long int> operator-(\n    pair<long long int, long long int> a,\n    pair<long long int, long long int> b) {\n  return {a.first - b.first, a.second - b.second};\n}\npair<long long int, long long int> operator*(\n    pair<long long int, long long int> a,\n    pair<long long int, long long int> b) {\n  return {a.first * b.first, a.second * b.second};\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const set<T> &v) {\n  for (auto it : v) os << it << \" \";\n  return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for (long long int i = 0; i < v.size(); ++i) os << v[i] << \" \";\n  return os;\n}\ntemplate <typename T>\nvoid Unique(vector<T> &v) {\n  sort(v.begin(), v.end()),\n      v.resize(distance(v.begin(), unique(v.begin(), v.end())));\n}\nlong long int dp[5001][501];\nlong long int k;\nlong long int h[11];\nlong long int fun(long long int fav, long long int cnt) {\n  if (fav <= 0 || cnt <= 0) return 0;\n  if (dp[fav][cnt] != -1) return dp[fav][cnt];\n  if (cnt == 1 and fav >= 0) {\n    fav = min(fav, k);\n    return dp[fav][cnt] = h[fav];\n  }\n  dp[fav][cnt] = INT_MIN;\n  for (long long int i = 1; i <= min(k, fav); i++) {\n    dp[fav][cnt] = max(dp[fav][cnt], h[i] + fun(fav - i, cnt - 1));\n  }\n  return dp[fav][cnt];\n}\nvoid solve() {\n  long long int n;\n  cin >> n >> k;\n  long long int fav[(long long int)1e5 + 1];\n  long long int cnt[(long long int)1e5 + 1];\n  memset(dp, -1, sizeof(dp));\n  memset(fav, 0, sizeof(fav));\n  memset(cnt, 0, sizeof(cnt));\n  for (long long int i = 0; i < n * k; i++) {\n    long long int x;\n    cin >> x;\n    fav[x]++;\n  }\n  for (long long int i = 0; i < n; i++) {\n    long long int x;\n    cin >> x;\n    cnt[x]++;\n  }\n  long long int ans = 0;\n  for (long long int i = 1; i <= k; i++) cin >> h[i];\n  for (long long int i = 1; i <= 1e5; i++) {\n    if (!cnt[i] || !fav[i]) continue;\n    ans += fun(fav[i], cnt[i]);\n  }\n  cout << ans;\n}\nsigned main() {\n  optimise();\n  long long int t;\n  t = 1;\n  cout << fixed << setprecision(20);\n  while (t--) {\n    solve();\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int maxnum = 1e5 + 10;\nconst int maxn = 500 + 10;\nconst int maxk = 10 + 2;\nint n, k;\nint a[maxn];\nint cntc[maxnum], cntp[maxnum];\nint h[maxk];\nint f[maxn][maxn * maxk];\nvoid print(int a[], int n, int st = 0) {\n  for (int i = 0; i < n; i++) {\n    if (i != 0) printf(\" \");\n    printf(\"%d\", a[i + st]);\n  }\n  printf(\"\\n\");\n}\nvoid init() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n * k; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    cntc[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    cntp[x]++;\n  }\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &h[i]);\n}\nvoid doit() {\n  int ans = 0;\n  for (int i = 1; i <= 1e5; i++) {\n    if (cntp[i] == 0 || cntc[i] == 0) continue;\n    for (int j = 0; j <= cntp[i]; j++)\n      for (int p = 0; p <= cntc[i]; p++) f[j][p] = 0;\n    for (int j = 1; j <= cntp[i]; j++) {\n      for (int p = 1; p <= min(j * k, cntc[i]); p++) {\n        for (int q = 0; q <= min(p, k); q++) {\n          f[j][p] = max(f[j][p], f[j - 1][p - q] + h[q]);\n        }\n      }\n    }\n    ans += f[cntp[i]][min(cntc[i], cntp[i] * k)];\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  init();\n  doit();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint fq[112345], pf[112345], h[15];\nint dp[505][5002];\nint main() {\n  int n, k, i, f, g, first = 0, ans = 0, x, j;\n  scanf(\"%d %d\", &n, &k);\n  for (j = k * n; j--;) {\n    scanf(\"%d\", &x);\n    fq[x]++;\n    first = max(first, fq[x]);\n  }\n  vector<int> q;\n  for (i = 1; i <= n; ++i) {\n    scanf(\"%d\", &x);\n    if (!pf[x]) q.push_back(x);\n    pf[x]++;\n  }\n  for (i = 1; i <= k; ++i) {\n    scanf(\"%d\", h + i);\n  }\n  for (i = 1; i <= n; ++i) {\n    for (f = 0; f <= first; ++f) {\n      g = k < f ? k : f;\n      for (j = 0; j <= g; ++j) {\n        dp[i][f] = max(dp[i][f], h[j] + dp[i - 1][f - j]);\n      }\n    }\n  }\n  for (int p : q) {\n    ans += dp[pf[p]][fq[p]];\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"4 3\\n\" +\n            \"1 3 2 8 5 5 8 2 2 8 5 2\\n\" +\n            \"1 2 2 5\\n\" +\n            \"2 6 7\\n\";\n    final int maxn = (int)1e5 + 10;\n    int n,k;\n    int c1[] = new int[maxn],c2[] = new int[maxn];\n    int h[] = new int[maxn];\nfinal int M = 5010;\n    long dp[][] = new long[M][M];\n    void go(){\n        n = ni();\n        k = ni();\n        for (int i=0;i<n*k;i++){\n            int temp = ni();\n            c1[temp]++;\n        }\n        for (int i=0;i<n;i++){\n            int temp = ni();\n            c2[temp]++;\n        }\n        for (int i=1;i<=k;i++){\n            h[i] = ni();\n        }\n        for (int i=1;i<M;i++){\n            for (int j=1;j<M;j++){\n                dp[i][j] = dp[i-1][j];\n                for (int x = 0;x<=k;x++){\n                    if(x>j)continue;\n                    dp[i][j] = Math.max(dp[i][j],dp[i-1][j-x]+h[x]);\n                }\n            }\n        }\n        long ans =0;\n        for (int i=0;i<maxn;i++){\n            ans+=dp[c2[i]][c1[i]];\n        }\n        out.println(ans);\n    }\n\n    void solve(){\n        go();\n    }\n\n    void run() throws Exception\n    {\n        is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        tr(System.currentTimeMillis()-s+\"ms\");\n    }\n\n    public static void main(String[] args) throws Exception { new Main().run(); }\n\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n\n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n\n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        for(;(b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'););\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        for(;;){\n            if(Character.isDigit(b)){\n                num = num * 10 + (b - '0');\n            } else\n                return minus ? -num : num;\n            b = readByte();\n        }\n    }\n\n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        for(;(b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'););\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        for(;;){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    //private boolean oj = true;\n\n    private boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint num[100010], cnt[100010];\nlong long dp[666][6666];\nint h[6666];\ninline int read() {\n  register int ret = 0;\n  register char ch = getchar();\n  while (ch > '9' || ch < '0') ch = getchar();\n  while (ch <= '9' && ch >= '0') ret = ret * 10 + ch - 48, ch = getchar();\n  return ret;\n}\nint main() {\n  int i, j, k, x, y, z, n, m;\n  long long ans = 0;\n  n = read(), m = read();\n  for (i = 1; i <= n * m; i++) num[read()]++;\n  for (i = 1; i <= n; i++) cnt[read()]++;\n  for (i = 1; i <= m; i++) h[i] = read();\n  for (j = 1; j <= n * m; j++) {\n    dp[1][j] = h[min(m, j)];\n    for (i = 2; i <= n; i++)\n      for (k = 0; k <= m && k <= j; k++)\n        dp[i][j] = max(dp[i][j], dp[i - 1][j - k] + h[k]);\n  }\n  for (i = 1; i <= 100000; i++) ans += dp[cnt[i]][num[i]];\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Task {\n\n    public static void main(String[] args) throws IOException {\n\n        new Task().go();\n    }\n\n    PrintWriter out;\n    Reader in;\n    BufferedReader br;\n\n    Task() throws IOException {\n\n        try {\n\n            //br = new BufferedReader( new FileReader(\"input.txt\") );\n            in = new Reader(\"input.txt\");\n            out = new PrintWriter( new BufferedWriter(new FileWriter(\"output.txt\")) );\n        }\n        catch (Exception e) {\n\n            //br = new BufferedReader( new InputStreamReader( System.in ) );\n            in = new Reader();\n            out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );\n        }\n    }\n\n    void go() throws IOException {\n\n        int t = 1;\n        while (t > 0) {\n            solve();\n            //out.println();\n            t--;\n        }\n\n        out.flush();\n        out.close();\n    }\n\n    int inf = 2000000000;\n    int mod = 1000000007;\n    double eps = 0.000000001;\n\n    int n;\n    int m;\n    ArrayList<Integer>[] g;\n    void solve() throws IOException {\n\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int[] cards = new int[100010];\n        for (int i = 0; i < n * k; i++) {\n            int x = in.nextInt();\n            cards[x]++;\n        }\n\n        int[] gamers = new int[100010];\n        for (int i = 0; i < n; i++) {\n            int x = in.nextInt();\n            gamers[x]++;\n        }\n\n        long[] c = new long[k + 1];\n        for (int i = 0; i < k; i++) {\n            c[i + 1] = in.nextInt();\n        }\n\n        long ans = 0;\n        for (int num = 0; num < 100010; num++) {\n            if (cards[num] > 0 && gamers[num] > 0) {\n                if (cards[num] > k * gamers[num])\n                    cards[num] = k * gamers[num];\n\n                long[][] dp = new long[gamers[num] + 1][cards[num] + 1];\n                for (int i = 1; i <= gamers[num]; i++)\n                    for (int j = 0; j <= cards[num]; j++) {\n                        for (int l = 0; l <= k; l++) {\n                            if (j + l <= cards[num])\n                                dp[i][j + l] = Math.max(dp[i][j + l], dp[i - 1][j] + c[l]);\n                        }\n                    }\n                ans += dp[gamers[num]][cards[num]];\n            }\n        }\n\n        out.println(ans);\n    }\n\n    class Pair implements Comparable<Pair> {\n        int a;\n        int b;\n\n        Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        public int compareTo(Pair p) {\n            if (a != p.a)\n                return Integer.compare(a, p.a);\n            else\n                return Integer.compare(b, p.b);\n        }\n    }\n\n    class Item {\n\n        int a;\n        int b;\n        int c;\n\n        Item(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n    }\n\n    class Reader {\n\n        BufferedReader  br;\n        StringTokenizer tok;\n\n        Reader(String file) throws IOException {\n            br = new BufferedReader( new FileReader(file) );\n        }\n\n        Reader() throws IOException {\n            br = new BufferedReader( new InputStreamReader(System.in) );\n        }\n\n        String next() throws IOException {\n\n            while (tok == null || !tok.hasMoreElements())\n                tok = new StringTokenizer(br.readLine());\n            return tok.nextToken();\n        }\n\n        int nextInt() throws NumberFormatException, IOException {\n            return Integer.valueOf(next());\n        }\n\n        long nextLong() throws NumberFormatException, IOException {\n            return Long.valueOf(next());\n        }\n\n        double nextDouble() throws NumberFormatException, IOException {\n            return Double.valueOf(next());\n        }\n\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        ArrayList<Integer>[] nextGraph(int n, int m) throws IOException {\n            ArrayList<Integer>[] g = new ArrayList[n];\n            for (int i = 0; i < n; i++)\n                g[i] = new ArrayList<>();\n            for (int i = 0; i < m; i++) {\n                int x = nextInt() - 1;\n                int y = nextInt() - 1;\n                g[x].add(y);\n                g[y].add(x);\n            }\n\n            return g;\n        }\n\n    }\n\n}"
        },
        {
            "language": 3,
            "solution": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO,IOBase\n\ndef main():\n    n,k = map(int,input().split())\n    card = list(map(int,input().split()))\n    fav = list(map(int,input().split()))\n    joy = [0]+list(map(int,input().split()))\n    dp = [[0]*(n*k+1) for _ in range(n+1)]\n    for i in range(len(joy)):\n        dp[1][i] = joy[i]\n    for i in range(len(joy),n*k+1):\n        dp[1][i] = joy[-1]\n    for i in range(2,n+1):\n        for j in range(1,n*k+1):\n            for kk in range(min(k+1,j+1)):\n                dp[i][j] = max(dp[i][j],dp[i-1][j-kk]+dp[1][kk])\n    tot = [0]*(10**5+1)\n    for i in card:\n        tot[i] += 1\n    tot1 = [0]*(10**5+1)\n    for i in fav:\n        tot1[i] += 1\n    ans = 0\n    for i in range(10**5+1):\n        ans += dp[tot1[i]][tot[i]]\n    print(ans)\n\n#Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[5005], h[15], favorite[505];\nint vis[100005], ans;\nmap<int, int> m1, m2;\nint dp[505][5005];\nint main() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= n * k; i++) {\n    cin >> a[i];\n    m1[a[i]]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> favorite[i];\n    m2[favorite[i]]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= i * k; j++) {\n      for (int c = 0; c <= min(j, k); c++)\n        dp[i][j] = max(dp[i][j], dp[i - 1][j - c] + h[c]);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (vis[favorite[i]]) continue;\n    ans += dp[m2[favorite[i]]][min(m2[favorite[i]] * k, m1[favorite[i]])];\n    vis[favorite[i]] = 1;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint fav[100005];\nint cnt[100005];\nlong long cost[20];\nint n, k;\nlong long dp[501][5001];\nlong long call(int idx, int remain) {\n  if (remain == 0) return 0;\n  if (idx <= 0) return 0;\n  long long &ret = dp[idx][remain];\n  if (ret != -1) return ret;\n  ret = 0;\n  for (int i = 1; i <= k && remain - i >= 0; i++) {\n    ret = max(ret, cost[i] + call(idx - 1, remain - i));\n  }\n  return ret;\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < n * k; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    cnt[a]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    fav[a]++;\n  }\n  for (int i = 1; i <= k; i++) scanf(\"%lld\", &cost[i]);\n  long long ans = 0;\n  memset(dp, -1, sizeof(dp));\n  for (int i = 0; i < 100005; i++) {\n    if (cnt[i] && fav[i]) {\n      ans += call(fav[i], min(cnt[i], fav[i] * k));\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author programajor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        long[][] dp;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n//        int n = 500;\n//        int k = 10;\n            dp = new long[n + 1][n * k + 1];\n            for (long[] line : dp) {\n                Arrays.fill(line, -1);\n            }\n            Map<Integer, Integer> cards = new HashMap<>();\n            Map<Integer, Integer> players = new HashMap<>();\n            for (int i = 0; i < n * k; i++) {\n                int x = in.nextInt();\n//            int x = 100000;\n                cards.put(x, cards.getOrDefault(x, 0) + 1);\n            }\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt();\n//            int x = 100000;\n                players.put(x, players.getOrDefault(x, 0) + 1);\n            }\n            int[] h = in.nextIntArray(k);\n//        int[] h = new int[10];\n            long ans = 0;\n            for (Map.Entry<Integer, Integer> entry : players.entrySet()) {\n                ans += solve(entry.getValue(), cards.getOrDefault(entry.getKey(), 0), k, h);\n            }\n            out.println(ans);\n        }\n\n        private long solve(int players, int cards, int k, int[] h) {\n            if (cards < 0) return Integer.MIN_VALUE;\n            if (players == 0) return 0;\n            if (dp[players][cards] != -1) return dp[players][cards];\n            long ans = 0;\n            for (int i = 0; i < k; i++) {\n                ans = Math.max(ans, h[i] + solve(players - 1, cards - i - 1, k, h));\n            }\n            return dp[players][cards] = ans;\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] nextIntArray(int s) {\n            int[] in = new int[s];\n            for (int i = 0; i < s; i++) {\n                in[i] = nextInt();\n            }\n            return in;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nconst int maxm = 500 + 10;\nconst long long mod = 998244353;\nconst int inf = 0x3ffffff;\nconst double eps = 1e-5;\nint n, m;\nint h[11];\nint cntc[maxn], cntf[maxn];\nint dp[5010][510];\nmap<int, int> mp;\nint check(int x, int y) {\n  for (int i = 0; i <= x; i++)\n    for (int j = 0; j <= y; j++) dp[i][j] = 0;\n  for (int i = 1; i <= x; i++) {\n    for (int j = 1; j <= y; j++) {\n      for (int k = 1; k <= min(m, i); k++) {\n        dp[i][j] = max(dp[i][j], dp[i - k][j - 1] + h[k]);\n      }\n    }\n  }\n  return dp[x][y];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < n * m; i++) {\n    int a;\n    cin >> a;\n    cntc[a]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    int a;\n    cin >> a;\n    cntf[a]++;\n  }\n  for (int i = 1; i <= m; i++) cin >> h[i];\n  int ans = 0;\n  for (int i = 1; i <= 1e5; i++)\n    if (cntc[i] != 0 && cntf[i] != 0) {\n      ans += check(cntc[i], cntf[i]);\n    }\n  cout << ans;\n  return ~~(0 - 0);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint datos[5015];\nint joy[15];\nint dp[505][5015] = {0};\nmap<int, int> cant;\nmap<int, int> fav;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    cin >> datos[i];\n    cant[datos[i]]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int aux;\n    cin >> aux;\n    fav[aux]++;\n  }\n  joy[0] = 0;\n  for (int i = 1; i <= k; i++) {\n    cin >> joy[i];\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j <= n * k; j++) {\n      for (int x = 0; x <= k; x++) {\n        dp[i + 1][j + x] = max(dp[i + 1][j + x], dp[i][j] + joy[x]);\n      }\n    }\n  }\n  int ans = 0;\n  for (auto it = cant.begin(); it != cant.end(); it++) {\n    if (fav.count(it->first)) ans += dp[fav[it->first]][it->second];\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int sum = 0, ff = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') ff = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) sum = sum * 10 + (ch ^ 48), ch = getchar();\n  return sum * ff;\n}\nconst int N = 5005;\nint n, m, c[N], f[N], h[N], g[N], dp[505][N], hh[N * 20], ans;\nint cwy[N * 20], wyy[N * 20];\nint main() {\n  n = read();\n  m = read();\n  int M = n * m;\n  for (int i = 1; i <= M; i++) wyy[c[i] = read()]++;\n  for (int i = 1; i <= n; i++) cwy[f[i] = read()]++;\n  for (int i = 1; i <= m; i++) h[i] = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= M; j++)\n      for (int k = 1; k <= min(m, j); k++)\n        dp[i][j] = max(dp[i][j], dp[i - 1][j - k] + h[k]);\n  for (int i = 1; i <= (int)1e5; i++) ans += dp[cwy[i]][wyy[i]];\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import collections\nimport sys\n\nn,k=map(int,raw_input().split())\ncards=collections.Counter(map(int,raw_input().split()))\nfavs=collections.Counter(map(int,raw_input().split()))\nhapp=[0]+map(int,raw_input().split())\n\n\nmxp=favs.most_common(1)[0][1]\nmxc=min(cards.most_common(1)[0][1],mxp*k)\ndp=[[0 for i in range(mxc)] for j in range(mxp)]\ndp[0][0]=happ[0]\nfor p in range(mxp):\n    for c in range(mxc):\n        if p==0:\n            dp[p][c]=happ[-1] if c>=len(happ)-1 else happ[c+1]\n            continue\n        for k in range(len(happ)):\n            if c-k<0: break\n            dp[p][c]=max(dp[p][c], dp[p-1][c-k]+happ[k])\n\nprint sum(dp[favs[c]-1][min(cards[c]-1,mxc-1)] if cards[c] else 0 for c in favs)\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*; \nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\tstatic final long MOD = 998244353;\n\n    public static void main(String[] args) throws IOException {\n        FastScanner sc=new FastScanner();\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        int[] players = new int[100000];\n        int[] cards = new int[100000];\n        for (int i = 0; i < N*K; i++) {\n        \tint card = sc.nextInt()-1;\n        \tcards[card] += 1;\n        }\n        for (int i = 0; i < N; i++) {\n        \tint player = sc.nextInt()-1;\n        \tplayers[player] += 1;\n        }\n        int[] joy = new int[K+1];\n        for (int i = 1; i <= K; i++) {\n        \tjoy[i] = sc.nextInt();\n        }\n        \n        int[][] dp = new int[N+1][N*K+1];\n        for (int i = 1; i <= N; i++) {\n        \tfor (int j = 1; j <= N*K; j++) {\n        \t\tint base = dp[i-1][j]; //Current player takes nothing\n        \t\tfor (int take = 1; take <= Math.min(j,K); take++) {\n        \t\t\tbase = Math.max(base,dp[i-1][j-take]+joy[take]);\n        \t\t}\n        \t\tdp[i][j] = base;\n        \t}\n        }\n        \n        long answer = 0;\n        for (int i = 0; i < 100000; i++) {\n        \tanswer += dp[players[i]][cards[i]];\n        }\n        System.out.println(answer);\n    }\n    \n    static class FastScanner { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastScanner() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n}\n\nclass Node {\n\tpublic int n;\n\tpublic HashSet<Node> children;\n\t\n\tpublic Node(int n) {\n\t\tthis.n = n;\n\t\tchildren = new HashSet<Node>();\n\t}\n\t\n\tpublic void addChild(Node node) {\n\t\tchildren.add(node);\n\t}\n\t\n\tpublic void removeChild(Node node) {\n\t\tchildren.remove(node);\n\t}\n}\n\nclass BinaryIndexedTree {\n\t  public long[] arr;\n\n\t  public BinaryIndexedTree (int N) {\n\t    arr = new long[N+1];\n\t    arr[0] = 0;\n\t  }\n\n\t  //add k to the i-th element.\n\t  public void add(long k, int i) {\n\t    int node = i+1;\n\t    while (node < arr.length) {\n\t      arr[node] += k;\n\t      node += node & (-node);\n\t    }\n\t  }\n\n\t  //sum up the elements from input[s_i] to input[e_i], from [s_i,e_i).\n\t  public long sum(int s_i, int e_i) {\n\t    return sum(e_i) - sum(s_i);\n\t  }\n\n\t  public long sum(int i) {\n\t    long total = 0;\n\t    int node = i;\n\t    while (node > 0) {\n\t      total += arr[node];\n\t      node -= node & (-node);\n\t    }\n\t    return total;\n\t  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 505, K = 11, M = 1e5 + 5;\nint n, k, x, fav[M], g[K], dp[N][N * K], counter[M], out;\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) cin >> x, counter[x]++;\n  for (int i = 0; i < n; i++) cin >> x, fav[x]++;\n  for (int i = 0; i < k; i++) cin >> g[i];\n  for (int i = 1; i < N * K; i++) dp[n][i] = -1e9;\n  for (int i = n - 1; i >= 0; i--)\n    for (int j = 1; j <= n * k; j++)\n      for (int w = 1; w <= k; w++)\n        if (j >= w) dp[i][j] = max(dp[i][j], dp[i + 1][j - w] + g[w - 1]);\n  for (int i = 0; i < M; i++)\n    if (fav[i] > 0) out += dp[n - fav[i]][min(fav[i] * k, counter[i])];\n  cout << out;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint n, k, c[maxn], f[maxn], h[maxn];\nint dp[maxn][505], num[maxn], cnt[maxn];\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) cin >> c[i], num[c[i]]++;\n  for (int i = 0; i < n; i++) cin >> f[i], cnt[f[i]]++;\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  for (int i = 0; i <= n * k; i++) {\n    dp[i][1] = h[min(i, k)];\n    for (int j = 2; j <= n; j++) {\n      for (int u = 1; u <= k && i - u >= 0; u++)\n        dp[i][j] = max(dp[i][j], dp[i - u][j - 1] + h[u]);\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i <= 1e5; i++) {\n    if (num[i] == 0) continue;\n    ans += dp[num[i]][cnt[i]];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n,k = map(int,raw_input().split())\nnums = list(map(int,raw_input().split()))\ncnt = [0 for x in range(100001)]\ncnt2 = [0 for x in range(100001)]\nfavs = list(map(int,raw_input().split()))\nvals = [0]+list(map(int,raw_input().split()))\nfor i in nums:\n  cnt[i] += 1\nfor i in favs:\n  cnt2[i] += 1\nans = 0\nfor i in set(nums):\n  if cnt2[i]:\n    N = min(cnt2[i]*k,cnt[i])+1\n    dp = [[0 for x in range(N)] for x in range(cnt2[i]+1)]\n    for m in range(1,cnt2[i]+1):\n      for j in range(N-1,-1,-1):\n        for l in range(1,k+1):\n          if l+j>=N:\n            break\n          if vals[l]+dp[m-1][j] > dp[m][j+l]:\n            dp[m][j+l] = vals[l]+dp[m-1][j]\n    ans += max(dp[cnt2[i]])\nprint ans"
        },
        {
            "language": 3,
            "solution": "from __future__ import print_function\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\nsys.setrecursionlimit(10**9)\n\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\ndef ni():\n    return map(int, input().split())\n\n\ndef nio(offset):\n    return map(lambda x: int(x) + offset, input().split())\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef countMap(arr):\n    m = {}\n    for x in arr:\n        m[x] = m.get(x,0) + 1\n    return m\n\ndef sortId(arr):\n    return sorted(range(arr), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = nia()\nh.insert(0,0)\n\ncc = countMap(c)\ncf = countMap(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n\n\nres = 0\n\n\nfor fk,fv in cf.items():\n    res += dp[fv][cc.get(fk,0)]\n\nprint(res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5005;\nconst int M = 1e5 + 3;\nint c[N];\nint f[505];\nint h[12];\nint sz;\nint cnt[M];\nvector<int> x[M];\nint k;\nint dp[505][N];\nint backtrack(int idx, int rem) {\n  if (idx == sz - 1) {\n    return h[min(k, rem)];\n  }\n  if (dp[idx][rem] != -1) return dp[idx][rem];\n  int i, mx = 0;\n  for (i = 1; i <= k; i++) {\n    if (rem >= i) mx = max(mx, h[i] + backtrack(idx + 1, rem - i));\n  }\n  return dp[idx][rem] = mx;\n}\nint main() {\n  int n, i;\n  cin >> n >> k;\n  for (i = 0; i < n * k; i++) {\n    cin >> c[i];\n    cnt[c[i]]++;\n  }\n  for (i = 0; i < n; i++) {\n    cin >> f[i];\n    x[f[i]].push_back(i);\n  }\n  for (i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  int ans = 0;\n  for (i = 1; i < M; i++) {\n    if (x[i].empty() || !cnt[i]) continue;\n    sz = x[i].size();\n    memset(dp, -1, sizeof dp);\n    ans += backtrack(0, cnt[i]);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long t = 1, n, k, c, f, h[15], frq_c[100010], frq_f[100010], dp[505][5005],\n          ans;\nlong long rec(int person, long long card) {\n  if (person == 0) return 0;\n  long long &ret = dp[person][card];\n  if (ret + 1) return ret;\n  ret = 0;\n  for (int i = 0; i <= min(card, k); i++)\n    ret = max(ret, rec(person - 1, card - i) + h[i]);\n  return ret;\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) cin >> c, frq_c[c]++;\n  for (int i = 0; i < n; i++) cin >> f, frq_f[f]++;\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  for (int i = 0; i < 100010; i++)\n    if (frq_c[i] && frq_f[i])\n      memset(dp, -1, sizeof dp),\n          ans += rec(frq_f[i], min(frq_c[i], frq_f[i] * k));\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int a[5010], fv[510], joy[20], dp[5010][510], c[100010], fvc[100010];\nset<long long int> s;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n, k, x;\n  cin >> n >> k;\n  long long int nk = n * k;\n  memset(c, 0, sizeof c);\n  memset(fvc, 0, sizeof fvc);\n  for (int i = 0; i < nk; i++) {\n    cin >> x;\n    c[x]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> fv[i];\n    s.insert(fv[i]);\n    fvc[fv[i]]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> joy[i];\n  memset(dp, 0, sizeof dp);\n  for (int i = 0; i <= nk; i++) {\n    for (int j = 0; j <= n; j++) {\n      if (i == 0 || j == 0) {\n        dp[i][j] = 0;\n        continue;\n      }\n      long long int mn;\n      if (i < k)\n        mn = i;\n      else\n        mn = k;\n      for (int l = 0; l <= mn; l++) {\n        dp[i][j] = max(dp[i][j], dp[i - l][j - 1] + joy[l]);\n      }\n    }\n  }\n  long long int ans = 0;\n  for (auto it : s) {\n    ans += dp[c[it]][fvc[it]];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 50;\nint n, k, num, ans = 0;\nint c[maxn];\nint f[maxn];\nint h[15];\nint dp[maxn][505];\nint main() {\n  cin >> n >> k;\n  memset(dp, 0, sizeof(dp));\n  memset(c, 0, sizeof(c));\n  memset(f, 0, sizeof(f));\n  for (int i = 1; i <= n * k; i++) {\n    cin >> num;\n    c[num]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> num;\n    f[num]++;\n  }\n  for (int i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  for (int i = 1; i <= n * k; i++) {\n    dp[i][1] = h[min(k, i)];\n    for (int j = 2; j <= n; j++) {\n      for (int z = 1; i - z >= 0 && z <= k; z++) {\n        dp[i][j] = max(dp[i][j], dp[i - z][j - 1] + h[z]);\n      }\n    }\n  }\n  for (int i = 1; i < maxn; i++) {\n    if (f[i] != 0 && c[i] != 0) {\n      ans += dp[c[i]][f[i]];\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 9;\nint dp[maxn][509];\nint cnt[maxn], fav[maxn], h[maxn];\nint c[509], f[509];\nint main() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    cin >> c[i];\n    cnt[c[i]]++;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> f[i];\n    fav[f[i]]++;\n  }\n  for (int i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  for (int i = 1; i <= n * k; i++) {\n    dp[i][1] = h[min(i, k)];\n    for (int j = 2; j <= n; j++) {\n      for (int z = 1; z <= min(i, k); z++) {\n        dp[i][j] = max(dp[i][j], dp[i - z][j - 1] + h[z]);\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i <= maxn; i++) {\n    if (fav[i]) {\n      ans += dp[cnt[i]][fav[i]];\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint cnt[100100], need[100100], gt[100];\nint dp[505][5005];\nint solve(int idx, int rem) {\n  if (rem == 0 || idx == 0) return 0;\n  int& ret = dp[idx][rem];\n  if (~ret) return ret;\n  ret = 0;\n  for (int i = 1; i <= min(rem, k); ++i) {\n    ret = max(ret, solve(idx - 1, rem - i) + gt[i]);\n  }\n  return ret;\n}\nint main() {\n  cin >> n >> k;\n  int m = n * k;\n  for (int i = 0; i < m; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    cnt[x]++;\n  }\n  for (int i = 0; i < n; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    need[x]++;\n  }\n  for (int i = 1; i <= k; ++i) scanf(\"%d\", &gt[i]);\n  int N = 1e5;\n  int ans = 0;\n  memset(dp, -1, sizeof dp);\n  for (int i = 1; i <= N; ++i) {\n    int x = cnt[i];\n    int y = need[i];\n    if (y == 0 || x == 0) continue;\n    ans += solve(y, x);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kessido\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FCardsAndJoy solver = new FCardsAndJoy();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FCardsAndJoy {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.NextInt();\n            int k = in.NextInt();\n            int[] c = in.NextIntArray(n * k);\n            int[] f = in.NextIntArray(n);\n            int[] h = in.NextIntArray(k);\n            Arrays.sort(c);\n            Arrays.sort(f);\n            int i = 0, j = 0;\n            long res = 0;\n            long[][] dp = new long[n + 1][n * k + 1];\n            for (int l = 0; l < n; l++) {\n                for (int m = 0; m <= n * k; m++) {\n                    dp[l + 1][m] = Math.max(dp[l + 1][m], dp[l][m]);\n                    for (int o = 1; o <= k; o++) {\n                        if (o + m <= n * k) {\n                            dp[l + 1][m + o] = Math.max(dp[l + 1][m + o], dp[l][m] + h[o - 1]);\n                        }\n                    }\n                }\n            }\n            while (i < n && j < n * k) {\n                if (f[i] < c[j]) {\n                    i++;\n                } else if (f[i] > c[j]) {\n                    j++;\n                } else {\n                    int countI = 0;\n                    int countJ = 0;\n                    while (i < n && f[i - countI] == f[i]) {\n                        countI++;\n                        i++;\n                    }\n                    while (j < k * n && c[j - countJ] == c[j]) {\n                        countJ++;\n                        j++;\n                    }\n                    res += dp[countI][countJ];\n                }\n            }\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] NextIntArray(int n) {\n            return NextIntArray(n, 0);\n        }\n\n        public int[] NextIntArray(int n, int offset) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = NextInt() + offset;\n            }\n            return a;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.*;\npublic class codeforces {\n\n    public static long rec(int people,int v,long n,long[][] dp)\n    {\n\n        //System.out.println(people+\" \"+v+\" \"+dp[people][v]);\n        if(people==n || v==0) {\n            dp[people][v]=0;\n            return 0;\n        }\n\n        long max=0;\n\n        if(dp[people][v]!=-1)\n            return dp[people][v];\n\n        for(int i=1;i<=Math.min(k,v);i++)\n        {\n            long res=rec(people+1 ,v-i , n ,dp )+val[i-1];\n            max=Math.max(res,max);\n        }\n        dp[people][v]=max;\n\n        return max;\n\n    }\n\n    static int n,k;\n    static long[] want,val;\n    public static void main(String[] args) throws IOException {\n\n        Scanner sc = new Scanner(System.in);\n        n=sc.nextInt();\n        k=sc.nextInt();\n        want=new long[n];\n        val=new long[k];\n\n        HashMap<Long,Long> map=new HashMap<>();\n        HashMap<Long,Long> map2=new HashMap<>();\n\n        long input;\n        for(int i=0;i<n*k;i++) {\n            input = sc.nextLong();\n            if(map.containsKey(input))\n            map.put(input,map.get(input)+1);\n            else\n            map.put(input,1l);\n        }\n\n        for(int i=0;i<n;i++) {\n            want[i] = sc.nextLong();\n            if(map2.containsKey(want[i]))\n              map2.put(want[i],map2.get(want[i])+1);\n            else\n                map2.put(want[i],1l);\n        }\n\n        for(int i=0;i<k;i++) {\n            val[i] = sc.nextLong();\n        }\n\n\n        long ans=0;\n        long dp[][]=new long[501][5001];\n\n        for(Map.Entry<Long,Long> entry:map2.entrySet())\n        {\n            long key=entry.getKey();\n            long value=entry.getValue();\n\n            long feq=0;\n            if(map.containsKey(key))\n                feq=map.get(key);\n            if(feq==0) continue;\n\n            for(int i=0;i<=500;i++)\n                Arrays.fill(dp[i],-1);\n\n            long temp=rec(0,(int)feq,value,dp);\n          //  System.out.println(\"temp:\"+temp+\" \"+feq+\" \"+value);\n            ans+=temp;\n        }\n\n        System.out.println(ans);\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[501][5001];\nint main() {\n  std::ios::sync_with_stdio(false);\n  int T;\n  T = 1;\n  while (T--) {\n    int n, k, i, j, l;\n    cin >> n >> k;\n    int ar[k * n + 100], ar2[n + 100], ar3[k + 100];\n    for (i = 0; i < n * k; ++i) cin >> ar[i];\n    for (i = 0; i < n; ++i) cin >> ar2[i];\n    for (i = 0; i < k; ++i) cin >> ar3[i];\n    for (i = 1; i <= n; ++i) {\n      for (j = 1; j <= i * k; ++j) {\n        if (i == 1)\n          dp[i][j] = ar3[j - 1];\n        else if (j == 1)\n          dp[i][j] = ar3[0];\n        else {\n          dp[i][j] = max(dp[i][j], dp[i - 1][j]);\n          for (l = j - 1; l >= 0 && j - l <= k; --l) {\n            if (l > (i - 1) * k) continue;\n            dp[i][j] = max(dp[i][j], ar3[j - l - 1] + dp[i - 1][l]);\n          }\n        }\n      }\n    }\n    sort(ar2, ar2 + n);\n    long long ans = 0;\n    int ct = 0, pre = -1, ct2 = 0;\n    for (i = 0; i < n;) {\n      pre = ar2[i];\n      ct = 0;\n      while (i < n && ar2[i] == pre) {\n        ++ct, ++i;\n      }\n      ct2 = 0;\n      for (j = 0; j < n * k; ++j) {\n        if (ar[j] == pre) ++ct2;\n      }\n      ct2 = min(ct2, k * ct);\n      if (ct2 == 0)\n        ;\n      else\n        ans = ans + dp[ct][ct2];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import javax.print.attribute.standard.PrinterMessageFromOperator;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        new Main().run();}\n\n//    int[] h,ne,to,wt;\n//    int ct = 0;\n//    int n;\n//    void graph(int n,int m){\n//        h = new int[n];\n//        Arrays.fill(h,-1);\n////        sccno = new int[n];\n////        dfn = new int[n];\n////        low = new int[n];\n////        iscut = new boolean[n];\n//        ne = new int[2*m];\n//        to = new int[2*m];\n//        wt = new int[2*m];\n//        ct = 0;\n//    }\n//    void add(int u,int v,int w){\n//        to[ct] = v;\n//        ne[ct] = h[u];\n//        wt[ct] = w;\n//        h[u] = ct++;\n//    }\n//\n//    int color[],dfn[],low[],stack[] = new int[1000000],cnt[];\n//    int sccno[];\n//    boolean iscut[];\n//    int time = 0,top = 0;\n//    int scc_cnt = 0;\n//\n//    // \u6709\u5411\u56fe\u7684\u5f3a\u8fde\u901a\u5206\u91cf\n//    void tarjan(int u) {\n//        low[u] = dfn[u]= ++time;\n//        stack[top++] = u;\n//        for(int i=h[u];i!=-1;i=ne[i]) {\n//            int v = to[i];\n//            if(dfn[v]==0) {\n//                tarjan(v);\n//                low[u]=Math.min(low[u],low[v]);\n//            } else if(sccno[v]==0) {\n//                // dfn>0 but sccno==0, means it's in current stack\n//                low[u]=Math.min(low[u],low[v]);\n//            }\n//        }\n//\n//        if(dfn[u]==low[u]) {\n//            sccno[u] = ++scc_cnt;\n//            while(stack[top-1]!=u) {\n//                sccno[stack[top-1]] = scc_cnt;\n//                --top;\n//            }\n//            --top;\n//        }\n//    }\n//\n//    //\u7f29\u70b9, topology sort\n//    int[] h1,to1,ne1;\n//    int ct1 = 0;\n//    void point(){\n//        for(int i=0;i<n;i++) {\n//            if(dfn[i]==0) tarjan(i);//\u6709\u53ef\u80fd\u56fe\u4e0d\u8fde\u901a\uff0c\u6240\u4ee5\u8981\u5faa\u73af\u5224\u65ad\u3002\n//        }\n//        // \u5165\u5ea6\n//        int du[] = new int[scc_cnt+1];\n//        h1 = new int[scc_cnt+1];\n//        Arrays.fill(h1, -1);\n//        to1 = new int[scc_cnt*scc_cnt];\n//        ne1 = new int[scc_cnt*scc_cnt];\n//        // scc_cnt \u4e2a\u70b9\n//\n//        for(int i=1;i<=n;i++) {\n//            for(int j=h[i]; j!=-1; j=ne[j]) {\n//                int y = to[j];\n//                if(sccno[i] != sccno[y]) {\n//                    // add(sccno[i],sccno[y]);  // \u5efa\u65b0\u56fe\n//                    to1[ct1] = sccno[y];\n//                    ne1[ct1] = h[sccno[i]];\n//                    h[sccno[i]] = ct1++;\n//                    du[sccno[y]]++; //\u5b58\u5165\u5ea6\n//                }\n//            }\n//        }\n//\n//        int q[] = new int[100000];\n//        int end = 0;\n//        int st = 0;\n//        for(int i=1;i<=scc_cnt;++i){\n//            if(du[i]==0){\n//                q[end++] = i;\n//            }\n//        }\n//\n//        int dp[] = new int[scc_cnt+1];\n//        while(st<end){\n//            int cur = q[st++];\n//            for(int i=h1[cur];i!=-1;i=ne1[i]){\n//                int y = to[i];\n//                // dp[y] += dp[cur];\n//                if(--du[y]==0){\n//                    q[end++] = y;\n//                }\n//            }\n//        }\n//    }\n//\n//\n//\n//\n//    int fa[];\n//    int faw[];\n//\n//    int dep = -1;\n//    int pt = 0;\n//    void go(int rt,int f,int dd){\n//\n//        int p = 0;\n//        stk[p] = rt;\n//        lk[p] = 0;\n//        fk[p] = f;p++;\n//        while(p>0) {\n//            int cur = stk[p - 1];\n//            int fp = fk[p - 1];\n//            int ll = lk[p - 1];\n//            p--;\n//\n//\n//            if (ll > dep) {\n//                dep = ll;\n//                pt = cur;\n//            }\n//            for (int i = h[cur]; i != -1; i = ne[i]) {\n//                int v = to[i];\n//                if (fp == v) continue;\n//\n//                stk[p] = v;\n//                lk[p] = ll + wt[i];\n//                fk[p] = cur;\n//                p++;\n//            }\n//        }\n//    }\n//    int pt1 = -1;\n//    void go1(int rt,int f,int dd){\n//\n//        int p = 0;\n//        stk[p] = rt;\n//        lk[p] = 0;\n//        fk[p] = f;p++;\n//        while(p>0) {\n//            int cur = stk[p - 1];\n//            int fp = fk[p - 1];\n//            int ll = lk[p - 1];\n//            p--;\n//\n//\n//            if (ll > dep) {\n//                dep = ll;\n//                pt1 = cur;\n//            }\n//\n//            fa[cur] = fp;\n//            for (int i = h[cur]; i != -1; i = ne[i]) {\n//                int v = to[i];\n//                if (v == fp) continue;\n//                faw[v] = wt[i];\n//                stk[p] = v;\n//                lk[p] = ll + wt[i];\n//                fk[p] = cur;\n//                p++;\n//            }\n//        }\n//    }\n//\n//    int r = 0;\n//    int stk[] = new int[301];\n//    int fk[] = new int[301];\n//    int lk[] = new int[301];\n//    void ddfs(int rt,int t1,int t2,int t3,int l){\n//\n//\n//        int p = 0;\n//        stk[p] = rt;\n//        lk[p] = 0;\n//        fk[p] = t3;p++;\n//        while(p>0){\n//            int cur = stk[p-1];\n//            int fp = fk[p-1];\n//            int ll = lk[p-1];\n//            p--;\n//            r = Math.max(r,ll);\n//            for(int i=h[cur];i!=-1;i=ne[i]){\n//                int v = to[i];\n//                if(v==t1||v==t2||v==fp) continue;\n//                stk[p] = v;\n//                lk[p] = ll+wt[i];\n//                fk[p] = cur;p++;\n//            }\n//        }\n//\n//\n//\n//    }\n\n\n    static long mul(long a, long b, long p)\n    {\n        long res=0,base=a;\n        while(b>0)\n        {\n            if((b&1L)>0)\n                res=(res+base)%p;\n            base=(base+base)%p;\n            b>>=1;\n        }\n        return res;\n    }\n\n    static long mod_pow(long k,long n,long p){\n        long res = 1L;\n        long temp = k;\n        while(n!=0L){\n            if((n&1L)==1L){\n                res = (res*temp)%p;\n            }\n            temp = (temp*temp)%p;\n            n = n>>1L;\n        }\n        return res%p;\n    }\n\n    static int[] getNext(char[] cs){\n        int len = cs.length;\n        int next[] = new int[len+1];\n        next[0] = -1;\n        int j = -1;\n        int i = 0;\n        while(i<len){\n            if(j==-1||cs[i]==cs[j]){\n                next[++i] = ++j;\n            }else{\n                j = next[j];\n            }\n        }\n        return next;\n    }\n\n\n    void solve() {\n\n        int n  =ni();\n        int k  =ni();\n        int tot = n*k;\n        int offer[] = new int[100001];\n        for(int i=0;i<tot;++i){\n            offer[ni()]++;\n        }\n        int needs[] = new int[100001];\n        for(int i=0;i<n;++i){\n            needs[ni()]++;\n        }\n\n        int h[] = na(k);\n\n        long dp[][] =new long[tot+1][n+1];\n\n        for(int p=1;p<=n;++p){\n            for(int s=1;s<=tot;++s){\n                int ma = Math.min(k,s);\n                for(int f=0;f<=ma;++f){\n                    dp[s][p] = Math.max(dp[s][p], dp[s-f][p-1]+(f>0?h[f-1]:0));\n                }\n            }\n        }\n\n        long r = 0;\n        for(int i=1;i<=100000;++i){\n            if(needs[i]>0&&offer[i]>0){\n                int ma =  Math.min(offer[i],needs[i]*k);\n                r += dp[ma][needs[i]];\n\n            }\n        }\n        print(r);\n\n\n\n\n\n\n\n\n\n\n\n\n\n        //N , M , K , a , b , c , d . \u5176\u4e2dN , M\u662f\u77e9\u9635\u7684\u884c\u5217\u6570\uff1bK \u662f\u4e0a\u9501\u7684\u623f\u95f4\u6570\u76ee\uff0c(a, b)\u662f\u8d77\u59cb\u4f4d\u7f6e\uff0c(c, d)\u662f\u51fa\u53e3\u4f4d\u7f6e\n\n\n//        int n = ni();\n//        int m = ni();\n//        int k = ni();\n//        int a = ni();\n//        int b = ni();\n//        int c = ni();\n//        int d = ni();\n//\n//\n//        char cc[][] = nm(n,m);\n//        char keys[][] = new char[n][m];\n//\n//        char ky = 'a';\n//        for(int i=0;i<k;++i){\n//            int x = ni();\n//            int y = ni();\n//            keys[x][y] = ky;\n//            ky++;\n//        }\n//        int f1[] = {a,b,0};\n//\n//        int dd[][] = {{0,1},{0,-1},{1,0},{-1,0}};\n//\n//        Queue<int[]> q =  new LinkedList<>();\n//        q.offer(f1);\n//        int ts = 1;\n//\n//        boolean vis[][][] = new boolean[n][m][33];\n//\n//        while(q.size()>0){\n//            int sz = q.size();\n//            while(sz-->0) {\n//                int cur[] = q.poll();\n//                vis[cur[0]][cur[1]][cur[2]] = true;\n//\n//                int x = cur[0];\n//                int y = cur[1];\n//\n//                for (int u[] : dd) {\n//                       int lx = x +  u[0];\n//                       int ly = y +  u[1];\n//                       if (lx >= 0 && ly >= 0 && lx < n && ly < m && (cc[lx][ly] != '#')&&!vis[lx][ly][cur[2]]){\n//                            char ck =cc[lx][ly];\n//                            if(ck=='.'){\n//                                if(lx==c&&ly==d){\n//                                    println(ts); return;\n//                                }\n//                                if(keys[lx][ly]>='a'&&keys[lx][ly]<='z') {\n//                                    int cao = cur[2] | (1 << (keys[lx][ly] - 'a'));\n//                                    q.offer(new int[]{lx, ly, cao});\n//                                    vis[lx][ly][cao] = true;\n//                                }else {\n//\n//                                    q.offer(new int[]{lx, ly, cur[2]});\n//                                }\n//\n//                            }else if(ck>='A'&&ck<='Z'){\n//                                int g = 1<<(ck-'A');\n//                                if((g&cur[2])>0){\n//                                    if(lx==c&&ly==d){\n//                                        println(ts); return;\n//                                    }\n//                                    if(keys[lx][ly]>='a'&&keys[lx][ly]<='z') {\n//\n//                                        int cao = cur[2] | (1 << (keys[lx][ly] - 'a'));\n//                                        q.offer(new int[]{lx, ly, cao});\n//                                        vis[lx][ly][cao] = true;;\n//                                    }else {\n//\n//                                        q.offer(new int[]{lx, ly, cur[2]});\n//                                    }\n//                                }\n//                            }\n//                       }\n//                }\n//\n//                }\n//            ts++;\n//        }\n//        println(-1);\n\n\n\n\n//        int n = ni();\n//\n//        HashSet<String> st = new HashSet<>();\n//        HashMap<String,Integer> mp = new HashMap<>();\n//\n//\n//        for(int i=0;i<n;++i){\n//            String s  = ns();\n//            int id= 1;\n//            if(mp.containsKey(s)){\n//                int u = mp.get(s);\n//                id = u;\n//\n//            }\n//\n//            if(st.contains(s)) {\n//\n//                while (true) {\n//                    String ts = s + id;\n//                    if (!st.contains(ts)) {\n//                        s = ts;\n//                        break;\n//                    }\n//                    id++;\n//                }\n//                mp.put(s,id+1);\n//            }else{\n//                mp.put(s,1);\n//            }\n//            println(s);\n//            st.add(s);\n//\n//        }\n\n//        int t = ni();\n//\n//        for(int i=0;i<t;++i){\n//            int n = ni();\n//            long w[] = nal(n);\n//\n//            Map<Long,Long> mp = new HashMap<>();\n//            PriorityQueue<long[]> q =new PriorityQueue<>((xx,xy)->{return Long.compare(xx[0],xy[0]);});\n//\n//            for(int j=0;j<n;++j){\n//                q.offer(new long[]{w[j],0});\n//                mp.put(w[j],mp.getOrDefault(w[j],0L)+1L);\n//            }\n//\n//            while(q.size()>=2){\n//                long f[] = q.poll();\n//                long y1 = f[1];\n//                if(y1==0){\n//                    y1 = mp.get(f[0]);\n//                    if(y1==1){\n//                        mp.remove(f[0]);\n//                    }else{\n//                        mp.put(f[0],y1-1);\n//                    }\n//                }\n//                long g[] = q.poll();\n//                long y2 = g[1];\n//                if(y2==0){\n//                    y2 = mp.get(g[0]);\n//                    if(y2==1){\n//                        mp.remove(g[0]);\n//                    }else{\n//                        mp.put(g[0],y2-1);\n//                    }\n//                }\n//                q.offer(new long[]{f[0]+g[0],2L*y1*y2});\n//\n//            }\n//            long r[] = q.poll();\n//            println(r[1]);\n//\n//\n//\n//\n//        }\n        //  int o= 9*8*7*6;\n        //  println(o);\n\n\n//       int t = ni();\n//       for(int i=0;i<t;++i){\n//           long a = nl();\n//           int k  = ni();\n//           if(k==1){\n//               println(a);\n//               continue;\n//           }\n//\n//           int f = (int)(a%10L);\n//           int s = 1;\n//           int j = 0;\n//           for(;j<30;j+=2){\n//               int u = f-j;\n//               if(u<0){\n//                   u = 10+u;\n//               }\n//               s = u*s;\n//               s = s%10;\n//               if(s==k){\n//                   break;\n//               }\n//           }\n//\n//           if(s==k) {\n//               println(a - j - 2);\n//           }else{\n//               println(-1);\n//           }\n//\n//\n//\n//\n//       }\n\n//     int m = ni();\n//     h = new int[n];\n//     to = new int[2*(n-1)];\n//     ne = new int[2*(n-1)];\n//     wt = new int[2*(n-1)];\n//\n//     for(int i=0;i<n-1;++i){\n//         int u = ni()-1;\n//         int v = ni()-1;\n//\n//     }\n        //  long a[] = nal(n);\n\n\n//        int n = ni();\n//        int k = ni();\n//        t1 = new long[200002];\n//\n//        int p[][] = new int[n][3];\n//\n//        for(int i=0;i<n;++i){\n//            p[i][0]  = ni();\n//            p[i][1]  = ni();\n//            p[i][2]  = i+1;\n//        }\n//        Arrays.sort(p, new Comparator<int[]>() {\n//            @Override\n//            public int compare(int[] x, int[] y) {\n//                if(x[1]!=y[1]){\n//                    return Integer.compare(x[1],y[1]);\n//                }\n//                return Integer.compare(y[0], x[0]);\n//            }\n//        });\n//\n//        for(int i=0;i<n;++i){\n//            int ck = p[i][0];\n//\n//        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    }\n\n\n\n\n\n\n\n\n\n//    int []h,to,ne,wt;\n\n    long t1[];\n    //    long t2[];\n    void update(long[] t,int i,long v){\n        for(;i<t.length;i+=(i&-i)){\n            t[i] += v;\n        }\n    }\n    long get(long[] t,int i){\n        long s = 0;\n        for(;i>0;i-=(i&-i)){\n            s += t[i];\n        }\n        return s;\n    }\n\n    int equal_bigger(long t[],long v){\n        int s=0,p=0;\n        for(int i=Integer.numberOfTrailingZeros(Integer.highestOneBit(t.length));i>=0;--i) {\n            if(p+(1<<i)< t.length && s + t[p+(1<<i)] < v){\n                v -= t[p+(1<<i)];\n                p |= 1<<i;\n            }\n        }\n        return p+1;\n    }\n\n\n\n\n\n\n\n\n\n    static class S{\n        int l = 0;\n        int r = 0 ;\n        long le = 0;\n        long ri = 0;\n        long tot = 0;\n        long all = 0;\n\n        public S(int l,int r) {\n            this.l = l;\n            this.r = r;\n        }\n    }\n\n    static S a[];\n    static int[] o;\n\n    static void init(int[] f){\n        o = f;\n        int len = o.length;\n        a = new S[len*4];\n        build(1,0,len-1);\n    }\n\n    static void build(int num,int l,int r){\n        S cur = new S(l,r);\n        if(l==r){\n            a[num] = cur;\n            return;\n        }else{\n            int m = (l+r)>>1;\n            int le = num<<1;\n            int ri = le|1;\n            build(le, l,m);\n            build(ri, m+1,r);\n            a[num] = cur;\n            pushup(num, le, ri);\n        }\n    }\n\n\n\n    //    static int query(int num,int l,int r){\n//\n//        if(a[num].l>=l&&a[num].r<=r){\n//            return a[num].tot;\n//        }else{\n//            int m = (a[num].l+a[num].r)>>1;\n//            int le = num<<1;\n//            int ri = le|1;\n//            pushdown(num, le, ri);\n//            int ma = 1;\n//            int mi = 100000001;\n//            if(l<=m) {\n//                int r1 = query(le, l, r);\n//                ma = ma*r1;\n//\n//            }\n//            if(r>m){\n//                int r2 = query(ri, l, r);\n//                ma = ma*r2;\n//            }\n//            return ma;\n//        }\n//    }\n    static long dd = 10007;\n    static void update(int num,int l,long v){\n        if(a[num].l==a[num].r){\n            a[num].le = v%dd;\n            a[num].ri = v%dd;\n            a[num].all = v%dd;\n            a[num].tot = v%dd;\n        }else{\n            int m = (a[num].l+a[num].r)>>1;\n            int le = num<<1;\n            int ri = le|1;\n            pushdown(num, le, ri);\n            if(l<=m){\n                update(le,l,v);\n            }\n            if(l>m){\n                update(ri,l,v);\n            }\n            pushup(num,le,ri);\n        }\n    }\n\n    static void pushup(int num,int le,int ri){\n        a[num].all = (a[le].all*a[ri].all)%dd;\n        a[num].le = (a[le].le + a[le].all*a[ri].le)%dd;\n        a[num].ri = (a[ri].ri + a[ri].all*a[le].ri)%dd;\n        a[num].tot = (a[le].tot + a[ri].tot + a[le].ri*a[ri].le)%dd;\n\n\n        //a[num].res[1] = Math.min(a[le].res[1],a[ri].res[1]);\n    }\n    static void pushdown(int num,int le,int ri){\n\n    }\n\n\n    int gcd(int a,int b){ return b==0?a: gcd(b,a%b);}\n    InputStream is;PrintWriter out;\n    void run() throws Exception {is = System.in;out = new PrintWriter(System.out);solve();out.flush();}\n    private byte[] inbuf = new byte[2];\n    public int lenbuf = 0, ptrbuf = 0;\n    private int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {lenbuf = is.read(inbuf);} catch (IOException e) {throw new InputMismatchException();}\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];}\n    private boolean isSpaceChar(int c) {return !(c >= 33 && c <= 126);}\n    private int skip() {int b;while((b = readByte()) != -1 && isSpaceChar(b));return b;}\n    private double nd() {return Double.parseDouble(ns());}\n    private char nc() {return (char) skip();}\n    private char ncc() {int b;while((b = readByte()) != -1 && !(b >= 32 && b <= 126));return (char)b;}\n    private String ns() {int b = skip();StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);b = readByte(); }\n        return sb.toString();}\n    private char[] ns(int n) {char[] buf = new char[n];int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) { buf[p++] = (char) b;b = readByte(); }\n        return n == p ? buf : Arrays.copyOf(buf, p);}\n    private String nline() {int b = skip();StringBuilder sb = new StringBuilder();\n        while (!isSpaceChar(b) || b == ' ') { sb.appendCodePoint(b);b = readByte(); }\n        return sb.toString();}\n    private char[][] nm(int n, int m) {char[][] a = new char[n][];for (int i = 0; i < n; i++) a[i] = ns(m);return a;}\n    private int[] na(int n) {int[] a = new int[n];for (int i = 0; i < n; i++) a[i] = ni();return a;}\n    private long[] nal(int n) { long[] a = new long[n];for (int i = 0; i < n; i++) a[i] = nl();return a;}\n    private int ni() { int num = 0, b; boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')){};\n        if (b == '-') { minus = true; b = readByte(); }\n        while (true) {\n            if (b >= '0' && b <= '9') num = (num << 3) + (num << 1) + (b - '0');\n            else return minus ? -num : num;\n            b = readByte();}}\n    private long nl() { long num = 0; int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')){};\n        if (b == '-') { minus = true; b = readByte(); }\n        while (true) {\n            if (b >= '0' && b <= '9')  num = num * 10 + (b - '0');\n            else return minus ? -num : num;\n            b = readByte();}}\n    void print(Object obj){out.print(obj);}\n    void println(Object obj){out.println(obj);}\n    void println(){out.println();}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing int128 = __int128_t;\ntemplate <typename T>\nvoid print_vector(vector<T>& vec, string sep = \" \", string end = \"\\n\") {\n  int n = vec.size();\n  for (int i = 0; i < n; ++i) {\n    cout << vec[i];\n    if (i < n - 1)\n      cout << sep;\n    else\n      cout << end;\n  }\n}\nconstexpr int M = 100000;\nconstexpr long long INF = 1LL << 60;\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> x(M, 0), y(M, 0), h(k + 1, 0);\n  for (int i = 0; i < n * k; ++i) {\n    int t;\n    cin >> t;\n    ++x[t - 1];\n  }\n  for (int i = 0; i < n; ++i) {\n    int f;\n    cin >> f;\n    ++y[f - 1];\n  }\n  for (int i = 0; i < k; ++i) {\n    cin >> h[i + 1];\n  }\n  vector<vector<long long>> dp(n + 1, vector<long long>(n * k + 1, -INF));\n  dp[0][0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0; j <= n * k; ++j) {\n      for (int t = 0; t <= min(j, k); ++t) {\n        dp[i][j] = max(dp[i][j], dp[i - 1][j - t] + h[t]);\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i < M; ++i) {\n    ans += dp[y[i]][min(k * y[i], x[i])];\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from __future__ import print_function\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\n# CONFIG\nsys.setrecursionlimit(10**9)\n\n# LOG\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return map(int, input().split())\n\n\ndef nio(offset):\n    return map(lambda x: int(x) + offset, input().split())\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef countMap(arr):\n    m = {}\n    for x in arr:\n        m[x] = m.get(x,0) + 1\n    return m\n\ndef sortId(arr):\n    return sorted(range(arr), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = [0] + (nia())\n\ncc = countMap(c)\ncf = countMap(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n    # log(dp[ni])\n\n# log(n,k)\n# log(\"c\", cc)\n# log(\"f\", cf)\n# log(\"h\", h)\n# log(dp)\n\nres = 0\n\n\nfor fk,fv in cf.items():\n    # log(fk, fv, cc.get(fk,0))\n    res += dp[fv][cc.get(fk,0)]\n\nprint(res)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, cnt[100010], tot[100010];\nlong long dp[5005][505];\nlong long ans;\nlong long h[100010];\nint c[100010], f[100010];\nint main(void) {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n * k; ++i) {\n    scanf(\"%d\", &c[i]);\n    ++cnt[c[i]];\n  }\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &f[i]);\n    ++tot[f[i]];\n  }\n  for (int i = 1; i <= k; ++i) {\n    scanf(\"%I64d\", &h[i]);\n  }\n  for (int i = 1; i <= n * k; ++i) {\n    dp[i][1] = h[min(i, k)];\n    for (int j = 2; j <= n; ++j) {\n      for (int o = 1; o <= min(i, k); ++o) {\n        dp[i][j] = max(dp[i][j], dp[i - o][j - 1] + h[o]);\n      }\n    }\n  }\n  for (int i = 0; i <= 100000; ++i) {\n    ans += dp[cnt[i]][tot[i]];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[100010], cnt[100010], b[100010], p[100010], h[100];\nlong long mem[501][5001], nn, k;\nvector<pair<int, int> > v;\nlong long dp(int x, int nm) {\n  if (x == nn) return 0;\n  if (mem[x][nm] != -1) return mem[x][nm];\n  long long ans = 0;\n  for (int i = 0; i <= min(k, (long long)nm); ++i) {\n    ans = max(ans, h[i] + dp(x + 1, nm - i));\n  }\n  mem[x][nm] = ans;\n  v.push_back(make_pair(x, nm));\n  return ans;\n}\nint main() {\n  int n;\n  while (cin >> n >> k) {\n    set<int> s;\n    for (int i = 0; i < n * k; ++i) {\n      cin >> a[i];\n      ++cnt[a[i]];\n      s.insert(a[i]);\n    }\n    for (int i = 0; i < n; ++i) {\n      cin >> b[i];\n      ++p[b[i]];\n    }\n    for (int i = 1; i <= k; ++i) {\n      cin >> h[i];\n    }\n    h[0] = 0;\n    long long ans = 0;\n    memset(mem, -1, sizeof mem);\n    for (auto it : s) {\n      nn = p[it];\n      ans += dp(0, cnt[it]);\n      for (int i = 0; i < v.size(); ++i) {\n        mem[v[i].first][v[i].second] = -1;\n      }\n      v.clear();\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int len, dp[501][5001], k, ara[11], cur;\nint ad2[100001], n, ad3[100001];\nlong long int mod = 1e9 + 7;\nlong long int bigmod(long long int a, long long int b) {\n  long long int res = 1;\n  while (b) {\n    if (b % 2) res = (res * a) % mod;\n    a = (a * a) % mod, b /= 2;\n  }\n  return res;\n}\nint gcd(int a, int b) {\n  if (!b) return a;\n  return gcd(b, a % b);\n}\nlong long int ab(long long int a, long long int b) {\n  if (a < b)\n    return b - a;\n  else\n    return a - b;\n}\nlong long int res(int i, int rem) {\n  if (rem == 0 || i == ad3[cur]) return 0;\n  if (dp[i][rem] != -1) return dp[i][rem];\n  long long int ans = 0;\n  for (int st = 1; st <= k && rem - st >= 0; st++) {\n    ans = max(ans, res(i + 1, rem - st) + ara[st]);\n  }\n  return dp[i][rem] = ans;\n}\nint main() {\n  int t = 1, u = 1, p;\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    cin >> p;\n    ad2[p]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> p, ad3[p]++;\n  }\n  for (int i = 1; i <= k; i++) cin >> ara[i];\n  long long int ans = 0;\n  for (int i = 1; i <= 100000; i++) {\n    for (int j = 0; j <= ad3[i]; j++) {\n      for (int k = 0; k <= ad2[i]; k++) dp[j][k] = -1;\n    }\n    cur = i;\n    ans += res(0, ad2[i]);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ans[5005][1000];\nlong long h[20];\nlong long cnt[100005];\nlong long f[100005];\nsigned main() {\n  long long n, k;\n  cin >> n >> k;\n  for (long long i = 0; i < n * k; i++) {\n    long long tmp;\n    cin >> tmp;\n    cnt[tmp]++;\n  }\n  for (long long i = 0; i < n; i++) {\n    long long tmp;\n    cin >> tmp;\n    f[tmp]++;\n  }\n  for (long long i = 0; i < k; i++) {\n    long long tmp;\n    cin >> tmp;\n    h[i] = tmp;\n  }\n  for (long long iii = 0; iii < k; iii++) {\n    for (long long ii = 1; ii <= n; ii++) {\n      for (long long i = iii + 1; i <= n * k; i++) {\n        ans[i][ii] = max(ans[i][ii], ans[i - iii - 1][ii - 1] + h[iii]);\n      }\n    }\n  }\n  long long re = 0;\n  for (long long i = 0; i < 100005; i++) {\n    re += ans[cnt[i]][f[i]];\n  }\n  cout << re;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nconst int N = 1e5 + 5, M = 5e2 + 5;\nint n, k;\nint cnt[N];\nint first[M], h[15];\nvector<int> idx[N];\nint sz, dp[M][M * 10];\nint vis[M][M * 10], vid;\nint solve(int i, int rem) {\n  if (i == sz) return 0;\n  if (vis[i][rem] == vid) return dp[i][rem];\n  vis[i][rem] = vid;\n  int &ret = dp[i][rem];\n  ret = 0;\n  for (int kam = 1; kam <= min(k, rem); ++kam)\n    ret = max(ret, solve(i + 1, rem - kam) + h[kam]);\n  return ret;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n * k; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    ++cnt[x];\n  }\n  for (int i = 0; i < n; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    idx[x].emplace_back(i);\n  }\n  for (int i = 1; i <= k; ++i) scanf(\"%d\", h + i);\n  int ans = 0;\n  for (int i = 0; i < N; ++i) {\n    sz = idx[i].size();\n    if (sz == 0) continue;\n    int kam = min(cnt[i], sz * k);\n    ++vid;\n    int here = solve(0, kam);\n    ans += here;\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 500 + 1, K = 10 + 1, MAX = 1e5 + 3;\n;\nint n, k, ns[N * K];\nint f[N], h[K], v[MAX], cnt[MAX];\nint dp[N][N * K], vis[N][N * K];\nint sz, lvl = 1;\nint solve(int cur, int tot) {\n  if (cur == sz) return 0;\n  int &ret = dp[cur][tot];\n  if (vis[cur][tot] == lvl) return ret;\n  vis[cur][tot] = lvl;\n  ret = solve(cur + 1, tot);\n  for (int i = 0; i < min(tot, k); i++) {\n    ret = max(ret, h[i] + solve(cur + 1, tot - i - 1));\n  }\n  return ret;\n}\nint no;\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n * k; i++) {\n    scanf(\"%d\", &no);\n    cnt[no]++;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &no);\n    v[no]++;\n  }\n  for (int i = 0; i < k; i++) scanf(\"%d\", &h[i]);\n  int tot = 0;\n  for (int i = 1; i < MAX; i++) {\n    if (!v[i]) continue;\n    sz = v[i];\n    tot += solve(0, cnt[i]);\n    lvl++;\n  }\n  printf(\"%d\\n\", tot);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\n\npublic class div2 {\n\tpublic static int[][] dp;\n\tpublic static int k;\n\tpublic static int dp(int c, int r) {\n\t\tif (dp[r][c]!=0) {\n\t\t\treturn dp[r][c];\n\t\t}\n\t\telse {\n\t\t\tif (r<=0 || c<=0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i=1; i<=k; i++) {\n\t\t\t\t\tif (c>=i && r>=1)\n\t\t\t\t\t\tdp[r][c]=Math.max(dp[r][c],dp[1][i]+dp(c-i,r-1));\n\t\t\t\t}\n\t\t\t\treturn dp[r][c];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t    k=sc.nextInt();\n\t\tint h=n*k;\n\t\t\n\t\tHashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\n\t\tint[] v=new int[k+1];\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tint a=sc.nextInt();\n\t\t\tif (map.containsKey(a)) {\n\t\t\t\tint cp=map.get(a);\n\t\t\t\tmap.put(a, cp+1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap.put(a,1);\n\t\t\t}\n\t\t}\n\t\tHashMap<Integer,Integer> mp=new HashMap<Integer,Integer>();\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint a=sc.nextInt();\n\t\t\tif (mp.containsKey(a)) {\n\t\t\t\tint cp=mp.get(a);\n\t\t\t\tmp.put(a, cp+1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp.put(a,1);\n\t\t\t}\n\t\t}\n\t\tv[0]=0;\n\t\tfor (int i=1; i<=k; i++) {\n\t\t\tv[i]=sc.nextInt();\t\n\t\t\t\n\t\t}\n\t\tlong sum=0;\n\t\tfor (int p : mp.keySet()) {\n\t\t\tif (map.containsKey(p)) {\n\t\t\t\tif (mp.get(p)==1) {\n\t\t\t\t\tint y=Math.min(k, map.get(p));\n\t\t\t\t\t//System.out.println(y+\"  \"+v[y]);\n\t\t\t\t\tsum+=v[y];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint r=mp.get(p);\n\t\t\t\t\tint card=map.get(p);\n\t\t\t\t\tif (k==1) {\n\t\t\t\t\t\tsum+=Math.min(r, card)*v[1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp=new int[501][5001];\n\t\t\t\t\t\tfor (int i=1; i<=k; i++) {\n\t\t\t\t\t\t\tdp[1][i]=v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp(card,r);\n\t\t\t\t\t\t//System.out.println(dp[r][card]);\n\t\t\t\t\t\tsum+=dp[r][card];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum+=0;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\n\t}\n\n}\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll INF = static_cast<ll>(1e9) + 7;\nconst int MAXN = static_cast<int>(4e5) + 17;\nint n, k;\nint a[MAXN], cnt1[MAXN], cnt2[MAXN], f[MAXN], h[MAXN];\nbool read() {\n  if (!(cin >> n >> k)) return false;\n  for (ll i = 0; i < (ll)(n * k); ++i) cin >> a[i];\n  for (ll i = 0; i < (ll)(n); ++i) cin >> f[i];\n  for (ll i = 0; i < (ll)(k); ++i) cin >> h[i + 1];\n  return true;\n}\nvoid solve() {\n  for (ll i = 0; i < (ll)(n * k); ++i) ++cnt1[a[i]];\n  for (ll i = 0; i < (ll)(n); ++i) ++cnt2[f[i]];\n  ll ans = 0;\n  for (int x = 1; x <= 100000; ++x)\n    if (cnt2[x] != 0) {\n      vector<vector<int> > dp(cnt2[x] + 1, vector<int>(cnt1[x] + 1, 0));\n      for (int i = 0; i < cnt2[x]; ++i)\n        for (int j = 0; j <= cnt1[x]; ++j)\n          for (int dj = 0; dj <= k && j + dj <= cnt1[x]; ++dj)\n            dp[i + 1][j + dj] = max(dp[i + 1][j + dj], dp[i][j] + h[dj]);\n      ans += dp[cnt2[x]][cnt1[x]];\n    }\n  cout << ans << '\\n';\n}\nint main() {\n  cin.tie(nullptr);\n  std::ios_base::sync_with_stdio(false);\n  std::mt19937 rand('S' + 'E' + 'R' + 'E' + 'Z' + 'H' + 'K' + 'A');\n  while (read()) solve();\n  return 0;\n};\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.InputMismatchException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tstatic class TaskAdapter implements Runnable {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tlong startTime = System.currentTimeMillis();\n\t\t\tInputStream inputStream = System.in;\n\t\t\tOutputStream outputStream = System.out;\n\t\t\tFastReader in = new FastReader(inputStream);\n\t\t\tOutput out = new Output(outputStream);\n\t\t\tFCardsAndJoy solver = new FCardsAndJoy();\n\t\t\tsolver.solve(1, in, out);\n\t\t\tout.close();\n\t\t\tSystem.err.println(System.currentTimeMillis()-startTime+\"ms\");\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tThread thread = new Thread(null, new TaskAdapter(), \"\", 1<<28);\n\t\tthread.start();\n\t\tthread.join();\n\t}\n\n\tstatic class FCardsAndJoy {\n\t\tpublic FCardsAndJoy() {\n\t\t}\n\n\t\tpublic void solve(int kase, InputReader in, Output pw) {\n\t\t\tint n = in.nextInt(), k = in.nextInt(), mn = (int) 1e5;\n\t\t\tint[] cardCnt = new int[mn], favCnt = new int[mn], arr = new int[k+1];\n\t\t\tfor(int i = 0; i<n*k; i++) {\n\t\t\t\tcardCnt[in.nextInt()-1]++;\n\t\t\t}\n\t\t\tfor(int i = 0; i<n; i++) {\n\t\t\t\tfavCnt[in.nextInt()-1]++;\n\t\t\t}\n\t\t\tfor(int i = 0; i<k; i++) {\n\t\t\t\tarr[i+1] = in.nextInt();\n\t\t\t}\n\t\t\tlong[][] dp = new long[n*k+1][n+1];\n\t\t\tfor(int i = 1; i<=n*k; i++) {\n\t\t\t\tfor(int j = 1; j<=n; j++) {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\tfor(int a = 1; a<=k; a++) {\n\t\t\t\t\t\tif(i-a>=0) {\n\t\t\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], arr[a]+dp[i-a][j-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor(int i = 0; i<mn; i++) {\n\t\t\t\tans += dp[cardCnt[i]][favCnt[i]];\n\t\t\t}\n\t\t\tpw.println(ans);\n\t\t}\n\n\t}\n\n\tstatic class FastReader implements InputReader {\n\t\tfinal private int BUFFER_SIZE = 1<<16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer;\n\t\tprivate int bytesRead;\n\n\t\tpublic FastReader(InputStream is) {\n\t\t\tdin = new DataInputStream(is);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint ret = 0;\n\t\t\tbyte c = skipToDigit();\n\t\t\tboolean neg = (c=='-');\n\t\t\tif(neg) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = ret*10+c-'0';\n\t\t\t} while((c = read())>='0'&&c<='9');\n\t\t\tif(neg) {\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate boolean isDigit(byte b) {\n\t\t\treturn b>='0'&&b<='9';\n\t\t}\n\n\t\tprivate byte skipToDigit() {\n\t\t\tbyte ret;\n\t\t\twhile(!isDigit(ret = read())&&ret!='-') ;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() {\n\t\t\ttry {\n\t\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif(bytesRead==-1) {\n\t\t\t\tbuffer[0] = -1;\n\t\t\t}\n\t\t}\n\n\t\tprivate byte read() {\n\t\t\tif(bytesRead==-1) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}else if(bufferPointer==bytesRead) {\n\t\t\t\tfillBuffer();\n\t\t\t}\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t}\n\n\tstatic class Output implements Closeable, Flushable {\n\t\tpublic StringBuilder sb;\n\t\tpublic OutputStream os;\n\t\tpublic int BUFFER_SIZE;\n\t\tpublic String lineSeparator;\n\n\t\tpublic Output(OutputStream os) {\n\t\t\tthis(os, 1<<16);\n\t\t}\n\n\t\tpublic Output(OutputStream os, int bs) {\n\t\t\tBUFFER_SIZE = bs;\n\t\t\tsb = new StringBuilder(BUFFER_SIZE);\n\t\t\tthis.os = new BufferedOutputStream(os, 1<<17);\n\t\t\tlineSeparator = System.lineSeparator();\n\t\t}\n\n\t\tpublic void println(long l) {\n\t\t\tprintln(String.valueOf(l));\n\t\t}\n\n\t\tpublic void println(String s) {\n\t\t\tsb.append(s);\n\t\t\tprintln();\n\t\t\tif(sb.length()>BUFFER_SIZE >> 1) {\n\t\t\t\tflushToBuffer();\n\t\t\t}\n\t\t}\n\n\t\tpublic void println() {\n\t\t\tsb.append(lineSeparator);\n\t\t}\n\n\t\tprivate void flushToBuffer() {\n\t\t\ttry {\n\t\t\t\tos.write(sb.toString().getBytes());\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tsb = new StringBuilder(BUFFER_SIZE);\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\ttry {\n\t\t\t\tflushToBuffer();\n\t\t\t\tos.flush();\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic void close() {\n\t\t\tflush();\n\t\t\ttry {\n\t\t\t\tos.close();\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic interface InputReader {\n\t\tint nextInt();\n\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k;\nlong long c[100006], freq[100006], people[100006], h[100006];\nlong long catche[5005][505];\nlong long dp(long long left, long long pep) {\n  if (left == 0 || pep == 0) return 0;\n  long long &ans = catche[left][pep];\n  if (ans != -1) return ans;\n  ans = 0;\n  for (long long j = 1; j <= min(left, k); j++) {\n    ans = max(ans, h[j] + dp(left - j, pep - 1));\n  }\n  return ans;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> k;\n  long long ans = 0;\n  long long i, j;\n  for (i = 1; i <= (n * k); i++) {\n    long long x;\n    cin >> x;\n    freq[x]++;\n  }\n  for (i = 1; i <= n; i++) {\n    long long x;\n    cin >> x;\n    people[x]++;\n  }\n  for (i = 1; i <= k; i++) {\n    cin >> h[i];\n  }\n  for (i = 1; i <= 100005; i++) {\n    if (!people[i]) {\n      continue;\n    }\n    for (j = 0; j <= freq[i]; j++) {\n      for (long long kk = 0; kk <= people[i]; kk++) {\n        catche[j][kk] = -1;\n      }\n    }\n    ans += dp(freq[i], people[i]);\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.security.KeyStore.Entry;\nimport java.text.Bidi;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class grafff {\n\tstatic long[][] memo;\n\tstatic int n, mod = (int) (1e9 + 7), Arr[];\n\tstatic ArrayList<Integer>[] adjlist;\n\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint a;\n\t\tint b;\n\t\tint c;\n\n\t\tpublic Pair(int a, int b, int c) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\t@Override\n\n\t\tpublic int compareTo(Pair p) {\n\t\t\treturn p.a - a;\n\t\t}\n\n\t}\n\n\tstatic String S, t;\n\n\t// public static long dp(int i, int j) {\n\t// if (i == S.length() && j == t.length())\n\t// return 1;\n\t// if (i >= S.length() || j > t.length())\n\t// return 0;\n\t// if (memo[i][j] != -1)\n\t// return memo[i][j];\n\t// long take = 0, leave;\n\t// if (S.charAt(i) == t.charAt(j))\n\t// take = 1 + dp(i + 1, j + 1);\n\t// leave = dp(i + 1, j);\n\t//\n\t// return memo[i][j] = take + leave;\n\t// }\n\tstatic int k, kkk[];\n\n\tpublic static long dp(int rem, int num) {\n\t\tif (rem == 0 || num == 0)\n\t\t\treturn 0;\n\t\tif (memo[rem][num] != -1)\n\t\t\treturn memo[rem][num];\n\t\tlong max = 0;\n\t\tint y=Math.min(k, num);\n\t\tfor (int i = 0; i <= y; i++)\n\t\t\tmax = Math.max(max, kkk[i] + dp(rem - 1, num - i));\n\t\treturn memo[rem][num] = max;\n\t}\n\n\tstatic long pow(long a, int n) {\n\t\tlong res = 1;\n\t\twhile (n != 0) {\n\t\t\tif ((n & 1) == 1)\n\t\t\t\tres *= a;\n\t\t\ta *= a;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static int divideandconqur(int left, int right) throws IOException {\n\t\tif (left == right)\n\t\t\treturn left;\n\t\tint mid = (left + right) / 2;\n\t\tint l = divideandconqur(left, mid);\n\t\tint r = divideandconqur(mid + 1, right);\n\t\tSystem.out.println(\"? \" + l + \" \" + r);\n\t\tboolean ans = sc.next().charAt(0) == '>';\n\t\tif (ans) {\n\t\t\tadjlist[l].add(r);\n\t\t\treturn l;\n\t\t} else {\n\t\t\tadjlist[r].add(l);\n\t\t\treturn r;\n\t\t}\n\n\t}\n\n\tstatic Scanner sc;\n\tstatic PrintWriter pw;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tsc = new Scanner(System.in);\n\t\tpw = new PrintWriter(System.out);\n\t\t// Scanner sc = new Scanner(\"folding.in\");\n\t\t// PrintWriter pw=new PrintWriter(\"folding.out\");\n\t\tint n = sc.nextInt();\n\t\tint[] players = new int[n];\n\t\tTreeMap<Integer, Integer> tm = new TreeMap<Integer, Integer>();\n\t\tk = sc.nextInt();\n\t\tkkk = new int[k + 1];\n\n\t\tint Arr[] = new int[100005];\n\t\tfor (int i = 0; i < k * n; i++)\n\t\t\tArr[sc.nextInt()]++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tplayers[i] = sc.nextInt();\n\t\t\ttm.put(players[i], tm.getOrDefault(players[i], 0) + 1);\n\t\t}\n\t\tfor (int i = 1; i < k + 1; i++)\n\t\t\tkkk[i] = sc.nextInt();\n\t\tlong ans = 0;\n\t\t memo = new long[n + 1][n * k + 5];\n\t\tfor (long[] x : memo)\n\t\t\tArrays.fill(x, -1);\n\t\tfor (int e : tm.keySet()) {\n\t\t\tans += dp(tm.get(e), Arr[e]);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing ll = int64_t;\nconst int MAX = 1e5;\nint32_t main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n  int n, k;\n  std::cin >> n >> k;\n  std::vector<int> number_count(MAX + 1), favorite_count(MAX + 1), h(k + 1);\n  int lim = n * k;\n  for (int i = 0; i < lim; i++) {\n    int x;\n    std::cin >> x;\n    number_count[x]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int x;\n    std::cin >> x;\n    favorite_count[x]++;\n  }\n  for (int i = 1; i <= k; i++) std::cin >> h[i];\n  std::vector<std::vector<int>> dp(501, std::vector<int>(5001 + 1000));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j <= lim - k; j++) {\n      for (int cnt = 0; cnt <= k; cnt++) {\n        dp[i + 1][j + cnt] = std::max(dp[i + 1][j + cnt], dp[i][j] + h[cnt]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= MAX; i++) {\n    if (favorite_count[i] > 0) ans += dp[favorite_count[i]][number_count[i]];\n  }\n  std::cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)500 + 11;\nconst int M = (int)5000 + 11;\nconst int mod = (int)1e9 + 7;\nconst int inf = 0x3f3f3f3f;\nmap<int, int> cnt, ge;\nmap<int, int>::iterator it;\nint h[N];\nlong long dp[M][N];\nlong long solve(long long k, long long x, long long y) {\n  for (int i = 0; i <= y; i++) {\n    for (int j = 0; j <= x; j++) {\n      dp[i][j] = 0;\n    }\n  }\n  for (int i = 1; i <= y; i++) {\n    for (int j = 1; j <= x; j++) {\n      for (int u = 1; u <= i && u <= k; u++) {\n        dp[i][j] = max(dp[i][j], dp[i - u][j - 1] + h[u]);\n      }\n    }\n  }\n  return dp[y][x];\n}\nvoid init(long long n, long long k) {\n  for (int i = 1; i <= n * k; i++) {\n    for (int j = 1; j <= n; j++) {\n      for (int u = 1; u <= i && u <= k; u++) {\n        dp[i][j] = max(dp[i][j], dp[i - u][j - 1] + h[u]);\n      }\n    }\n  }\n}\nint main() {\n  long long n, k;\n  scanf(\"%lld%lld\", &n, &k);\n  for (int i = 0; i < n * k; i++) {\n    int val;\n    scanf(\"%d\", &val);\n    cnt[val]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int f;\n    scanf(\"%d\", &f);\n    ge[f]++;\n  }\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &h[i]);\n  init(n, k);\n  long long ans = 0;\n  for (it = ge.begin(); it != ge.end(); it++) {\n    ans += dp[cnt[it->first]][it->second];\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ben[11];\nint n, k;\nint mem[505][505 * 11];\nint arr[505 * 505];\nint freqFav[100005];\nint freqCards[100005];\nint solve(int num, int rem) {\n  if (rem == 0 || num == 0) return 0;\n  int &ret = mem[num][rem];\n  if (~ret) return ret;\n  for (int i = 0; i < min(k, rem); i++) {\n    ret = max(ret, ben[i] + solve(num - 1, rem - i - 1));\n  }\n  return ret;\n}\nint main() {\n  memset(mem, -1, sizeof(mem));\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < k * n; i++) {\n    scanf(\"%d\", arr + i);\n    freqCards[arr[i]]++;\n  }\n  for (int i = 0; i < n; i++) {\n    int fav;\n    scanf(\"%d\", &fav);\n    freqFav[fav]++;\n  }\n  for (int i = 0; i < k; i++) {\n    scanf(\"%d\", ben + i);\n  }\n  int res = 0;\n  for (int i = 0; i < 100005; i++) {\n    res += solve(freqFav[i], freqCards[i]);\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  register int x = 0;\n  register bool f = 0;\n  register char ch = getchar();\n  while (!isdigit(ch)) {\n    f ^= !(ch ^ '-');\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = ((x + (x << 2)) << 1) + (ch ^ '0');\n    ch = getchar();\n  }\n  return f ? -x : x;\n}\ninline void print(int x) {\n  register int sc[30] = {0}, tot = 0;\n  do {\n    sc[++tot] = x % 10;\n    x /= 10;\n  } while (x);\n  while (tot) putchar('0' + sc[tot--]);\n}\nint n, maxn, k, ans;\nint peo[510 * 510], tot[510 * 510], h[510];\nint dp[5010][5010];\nint main() {\n  n = read();\n  k = read();\n  for (register int i = 1; i <= n * k; i++) {\n    int tmp = read();\n    tot[tmp]++;\n    maxn = max(maxn, tmp);\n  }\n  for (register int i = 1; i <= n; i++) {\n    int tmp = read();\n    peo[tmp]++;\n  }\n  for (register int i = 1; i <= k; i++) h[i] = read();\n  for (register int i = 1; i <= n; i++)\n    for (register int j = 1; j <= n * k; j++)\n      for (register int l = 1; l <= min(j, k); l++)\n        dp[i][j] = max(dp[i][j], dp[i - 1][j - l] + h[l]);\n  for (register int i = 1; i <= maxn; i++)\n    if (peo[i]) ans += dp[peo[i]][tot[i]];\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*Author: Satyajeet Singh, Delhi Technological University*/\n    import java.io.*;\n    import java.util.*;\n    import java.text.*; \n    import java.lang.*;\n    import java.math.*;\n\npublic class Main{\n/*********************************************Constants******************************************/\n    static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));        \n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static long mod=(long)1e9+7;\n    static long mod1=998244353;\n    static boolean sieve[];\n    static ArrayList<Integer> primes;\n    static ArrayList<Long> factorial;\n    static HashSet<Pair> graph[];\n/****************************************Solutions Begins***************************************/\n    static int n,k,cards[],fcards[],fav[],ffav[],cost[];\n    static int dp[][];\n    static int dfs(int t,int p){\n        //debug(t,p);\n        if(t<0){\n            return Integer.MIN_VALUE/5;\n        }\n        if(t==0||p==0){\n            return 0;\n        }\n        if(dp[t][p]!=-1){\n            return dp[t][p];\n        }\n        int ans=0;\n        for(int i=0;i<=k;i++){\n            ans=Math.max(ans,cost[i]+dfs(t-i,p-1));\n        }\n        dp[t][p]=ans;\n        return dp[t][p];\n    }\n    public static void main (String[] args) throws Exception {\n        String st[]=br.readLine().split(\" \");\n        n=Integer.parseInt(st[0]);\n        k=Integer.parseInt(st[1]);\n        cards=new int[k*n];\n        fcards=new int[100001];\n        st=br.readLine().split(\" \");\n        for(int i=0;i<k*n;i++){\n            cards[i]=Integer.parseInt(st[i]);\n            fcards[cards[i]]++;\n        }\n        st=br.readLine().split(\" \");\n        fav=new int[n];\n        ffav=new int[100001];\n        for(int i=0;i<n;i++){\n            fav[i]=Integer.parseInt(st[i]);\n            ffav[fav[i]]++;\n        }\n\n        st=br.readLine().split(\" \");\n        cost=new int[k+1];\n        for(int i=0;i<k;i++){\n            cost[i+1]=Integer.parseInt(st[i]);\n        }\n        int ans=0;\n            dp=new int[5001][501];\n            for(int arr[]:dp){\n                Arrays.fill(arr,-1);\n            }\n            boolean taken[]=new boolean[100001];\n\n        for(int i=0;i<n;i++){\n            if(!taken[fav[i]]){\n                //debug(fav[i],ffav[fav[i]],fcards[fav[i]]);\n                ans+=dfs(fcards[fav[i]],ffav[fav[i]]);\n                //debug(ans);\n                taken[fav[i]]=true;\n            }\n        }\n        out.println(ans);\n/****************************************Solutions Ends**************************************************/\n        out.flush();\n        out.close();\n    }\n\n/****************************************Template Begins************************************************/\n/***************************************Precision Printing**********************************************/\n    static void printPrecision(double d){\n        DecimalFormat ft = new DecimalFormat(\"0.00000000000000000\"); \n        out.println(ft.format(d));\n    }\n/******************************************Graph*********************************************************/\n    static void Makegraph(int n){\n        graph=new HashSet[n];\n        for(int i=0;i<n;i++){\n            graph[i]=new HashSet<>();\n        }\n    }\n    static void addEdge(int a,int b,int c){\n        graph[a].add(new Pair(b,c));\n    }    \n/*********************************************PAIR********************************************************/\n    static class PairComp implements Comparator<Pair>{\n        public int compare(Pair p1,Pair p2){\n            if(p1.u!=p2.u){\n                return p1.u-p2.u;\n            }\n            else{\n                return p2.v-p1.v;\n            }\n        }\n    }\n    static class Pair implements Comparable<Pair> {\n        int u;\n        int v;\n        int index=-1;\n        public Pair(int u, int v) {\n            this.u = u;\n            this.v = v;\n        }\n \n        public int hashCode() {\n            int hu = (int) (u ^ (u >>> 32));\n            int hv = (int) (v ^ (v >>> 32));\n            return 31 * hu + hv;\n        }\n \n        public boolean equals(Object o) {\n            Pair other = (Pair) o;\n            return u == other.u && v == other.v;\n        }\n \n        public int compareTo(Pair other) {\n            if(index!=other.index)\n                return Long.compare(index, other.index);\n            return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);\n        }\n \n        public String toString() {\n            return \"[u=\" + u + \", v=\" + v + \"]\";\n        }\n    }\n/******************************************Long Pair*************************************************/\n    static class PairCompL implements Comparator<Pairl>{\n        public int compare(Pairl p1,Pairl p2){\n            long aa=p2.u-p1.u;\n            if(aa<0){\n                return -1;\n            }\n            else if(aa>0){\n                return 1;\n            }\n            else{\n                return 0;\n            }\n        }\n    }\n    static class Pairl implements Comparable<Pair> {\n            long u;\n            long v;\n            int index=-1;\n            public Pairl(long u, long v) {\n                this.u = u;\n                this.v = v;\n            }\n    \n            public int hashCode() {\n                int hu = (int) (u ^ (u >>> 32));\n                int hv = (int) (v ^ (v >>> 32));\n                return 31 * hu + hv;\n            }\n    \n            public boolean equals(Object o) {\n                Pair other = (Pair) o;\n                return u == other.u && v == other.v;\n            }\n    \n            public int compareTo(Pair other) {\n                if(index!=other.index)\n                    return Long.compare(index, other.index);\n                return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);\n            }\n    \n            public String toString() {\n                return \"[u=\" + u + \", v=\" + v + \"]\";\n            }\n        }\n/*****************************************DEBUG***********************************************************/\n    public static void debug(Object... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n/************************************MODULAR EXPONENTIATION***********************************************/\n    static long modulo(long a,long b,long c) {\n        long x=1;\n        long y=a;\n        while(b > 0){\n            if(b%2 == 1){\n                x=(x*y)%c;\n            }\n            y = (y*y)%c; // squaring the base\n            b /= 2;\n        }\n        return  x%c;\n    }\n/********************************************GCD**********************************************************/\n    static long gcd(long x, long y)\n    {\n        if(x==0)\n            return y;\n        if(y==0)\n            return x;\n        long r=0, a, b;\n        a = (x > y) ? x : y; // a is greater number\n        b = (x < y) ? x : y; // b is smaller number\n        r = b;\n        while(a % b != 0)\n        {\n            r = a % b;\n            a = b;\n            b = r;\n        }\n        return r;\n    }\n/******************************************SIEVE**********************************************************/\n    static void sieveMake(int n){\n        sieve=new boolean[n];\n        Arrays.fill(sieve,true);\n        sieve[0]=false;\n        sieve[1]=false;\n        for(int i=2;i*i<n;i++){\n            if(sieve[i]){\n                for(int j=i*i;j<n;j+=i){\n                    sieve[j]=false;\n                }\n            }\n        }\n        primes=new ArrayList<Integer>();\n        for(int i=0;i<n;i++){\n            if(sieve[i]){\n                primes.add(i);\n            }\n        }        \n    }\n/********************************************End***********************************************************/\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXA = 1e5 + 10, MAXN = 505, MAXK = 15;\nint nl[MAXA], nv[MAXA], n, k, tmp, h[MAXK], dp[MAXN][MAXN * MAXK];\nlong long ans;\nint calc(int num) {\n  int av = min(nv[num], nl[num] * k);\n  int pop = nl[num];\n  if (pop == 0) return 0;\n  for (int i = 0; i <= min(k, av); i++) dp[0][i] = h[i];\n  for (int i = 1; i < pop; i++)\n    for (int used = 0; used <= av; used++) {\n      dp[i][used] = dp[i - 1][used];\n      for (int j = 1; j <= k; j++)\n        if (used >= j)\n          dp[i][used] = max(dp[i - 1][used - j] + h[j], dp[i][used]);\n    }\n  return dp[pop - 1][av];\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) cin >> tmp, nv[tmp]++;\n  for (int i = 0; i < n; i++) cin >> tmp, nl[tmp]++;\n  for (int i = 1; i <= k; i++) cin >> h[i];\n  for (int i = 1; i < MAXA; i++) ans += calc(i);\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 500;\nint c[100000], h[10], fc[100000], k;\nlong long mem[501][5001];\nlong long solve(int pos, int rem) {\n  if (pos == 0) return 0;\n  if (mem[pos][rem] != -1) return mem[pos][rem];\n  long long ans = 0;\n  for (int i = 1; i <= rem && i <= k; i++) {\n    long long cur = h[i - 1] + solve(pos - 1, rem - i);\n    if (cur > ans) ans = cur;\n  }\n  return mem[pos][rem] = ans;\n}\nint main() {\n  int n;\n  cin >> n >> k;\n  for (int i = 0; i < n * k; i++) {\n    int cc;\n    cin >> cc;\n    c[cc - 1]++;\n  }\n  set<int> favourites;\n  for (int i = 0; i < n; i++) {\n    int ff;\n    cin >> ff;\n    ff--;\n    fc[ff]++;\n    favourites.insert(ff);\n  }\n  for (int i = 0; i < k; i++) {\n    cin >> h[i];\n  }\n  long long ans = 0;\n  memset(mem, -1, sizeof(mem));\n  for (auto& ff : favourites) {\n    long long cur = solve(fc[ff], c[ff]);\n    ans += cur;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint c[505 * 10], f[505], h[505];\nint has[100005];\nvector<int> val[100005];\nint dp[505][505 * 10];\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n * k; ++i) {\n    scanf(\"%d\", &c[i]);\n    has[c[i]]++;\n  }\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &f[i]), val[f[i]].push_back(i);\n  for (int i = 1; i <= k; ++i) scanf(\"%d\", &h[i]);\n  int ans = 0;\n  for (int i = 1; i <= 100000; ++i)\n    if (val[i].size()) {\n      int tot = has[i], r = val[i].size(), mx = min(tot, r * k);\n      for (int j = 1; j <= r; ++j) {\n        for (int x = 1; x <= mx; ++x) {\n          for (int y = 1; y <= x && y <= k; ++y) {\n            dp[j][x] = max(dp[j][x], dp[j - 1][x - y] + h[y]);\n          }\n        }\n      }\n      ans += dp[r][mx];\n      for (int j = 1; j <= r; ++j)\n        for (int x = 1; x <= mx; ++x) dp[j][x] = 0;\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nofstream fout(\"test.out\");\nifstream fin(\"test.in\");\nconst long long MX = 2e6 + 100, INF = 1e18, INF2 = -1e18, D = 1e9 + 7;\nlong long n, m, arr[MX], arr1[MX], fa[20], cnt, flg, ans, del = 10433,\n                                                          dp[501][5001];\nstring s;\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (long long i = 0; i < n * m; i++) {\n    long long a;\n    cin >> a;\n    arr[a]++;\n  }\n  for (long long i = 0; i < n; i++) {\n    long long a;\n    cin >> a;\n    arr1[a]++;\n  }\n  for (long long i = 0; i < m; i++) {\n    cin >> fa[i];\n  }\n  for (long long i = 1; i <= m * n; i++) {\n    dp[1][i] = max(fa[i - 1], dp[1][i - 1]);\n  }\n  for (long long i = 2; i <= n; i++) {\n    for (long long j = 1; j <= m * n; j++) {\n      long long big = dp[i - 1][j];\n      for (long long k = 1; k <= min(j, m); k++) {\n        big = max(big, fa[k - 1] + dp[i - 1][j - k]);\n      }\n      dp[i][j] = big;\n    }\n  }\n  for (long long i = 0; i < 1000001; i++) {\n    if (arr[i] > 0 && arr1[i] > 0) {\n      ans += dp[arr1[i]][arr[i]];\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf999f {\n\n    public static void main(String[] args) throws IOException {\n        int n = rni(), k = ni(), c[] = riam1(n * k), f[] = riam1(n), h[] = ria(k), nc[] = new int[100000], nf[] = new int[100000], dp[][] = new int[n + 1][k * n + 1];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k * n; ++j) {\n                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n                for (int x = 1, end = min(k, k * n - j); x <= end; ++x) {\n                    dp[i + 1][j + x] = max(dp[i + 1][j + x], dp[i][j] + h[x - 1]);\n                }\n            }\n        }\n        for (int i = 0; i < n * k; ++i) {\n            ++nc[c[i]];\n        }\n        for (int i = 0; i < n; ++i) {\n            ++nf[f[i]];\n        }\n        long ans = 0;\n        for (int i = 0; i < 100000; ++i) {\n            ans += dp[nf[i]][nc[i]];\n        }\n        prln(ans);\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(\"yes\");}\n    static void pry() {prln(\"Yes\");}\n    static void prY() {prln(\"YES\");}\n    static void prno() {prln(\"no\");}\n    static void prn() {prln(\"No\");}\n    static void prN() {prln(\"NO\");}\n    static boolean pryesno(boolean b) {prln(b ? \"yes\" : \"no\"); return b;};\n    static boolean pryn(boolean b) {prln(b ? \"Yes\" : \"No\"); return b;}\n    static boolean prYN(boolean b) {prln(b ? \"YES\" : \"NO\"); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(\"hlfd\"); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline char gc() {\n  static char now[1 << 16], *S, *T;\n  if (T == S) {\n    T = (S = now) + fread(now, 1, 1 << 16, stdin);\n    if (T == S) return EOF;\n  }\n  return *S++;\n}\ninline int read() {\n  int x = 0, f = 1;\n  char ch = gc();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = gc();\n  }\n  while (isdigit(ch)) x = x * 10 + ch - '0', ch = gc();\n  return x * f;\n}\nconst int N = 1e5 + 10;\nint n, k, c[N], f[N], dp[510][5010], ans, h[11];\nint main() {\n  n = read();\n  k = read();\n  for (int i = 1; i <= n * k; ++i) ++c[read()];\n  for (int i = 1; i <= n; ++i) ++f[read()];\n  for (int i = 1; i <= k; ++i) h[i] = read();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= n * k; ++j)\n      for (int z = 1; z <= min(j, k); ++z)\n        dp[i][j] = max(dp[i][j], dp[i - 1][j - z] + h[z]);\n  for (int i = 1; i <= 1e5; ++i)\n    if (f[i]) ans += dp[f[i]][c[i]];\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from __future__ import print_function\nfrom collections import Counter\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\n# CONFIG\nsys.setrecursionlimit(10**9)\n\n# LOG\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return map(int, input().split())\n\n\ndef nio(offset):\n    return map(lambda x: int(x) + offset, input().split())\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef sortId(arr):\n    return sorted(range(arr), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = nia()\nh.insert(0,0)\n\ncc = Counter(c)\ncf = Counter(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n    # log(dp[ni])\n\n# log(n,k)\n# log(\"c\", cc)\n# log(\"f\", cf)\n# log(\"h\", h)\n# log(dp)\n\nres = 0\n\n\nfor fk,fv in cf.items():\n    # log(fk, fv, cc.get(fk,0))\n    res += dp[fv][cc.get(fk,0)]\n\nprint(res)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"4 3\\n\" +\n            \"1 3 2 8 5 5 8 2 2 8 5 2\\n\" +\n            \"1 2 2 5\\n\" +\n            \"2 6 7\\n\";\n    final int maxn = (int)1e5 + 10;\n    int n,k;\n    int c1[] = new int[maxn],c2[] = new int[maxn];\n    int h[] = new int[maxn];\nfinal int M = 5010;\n    long dp[][] = new long[M][M];\n    void go(){\n        n = ni();\n        k = ni();\n        for (int i=0;i<n*k;i++){\n            int temp = ni();\n            c1[temp]++;\n        }\n        for (int i=0;i<n;i++){\n            int temp = ni();\n            c2[temp]++;\n        }\n        for (int i=1;i<=k;i++){\n            h[i] = ni();\n        }\n        for (int i=1;i<=505;i++){\n            for (int j=1;j<M;j++){\n                dp[i][j] = dp[i-1][j];\n                for (int x = 0;x<=k;x++){\n                    if(x>j)continue;\n                    dp[i][j] = Math.max(dp[i][j],dp[i-1][j-x]+h[x]);\n                }\n            }\n        }\n        long ans =0;\n        for (int i=0;i<maxn;i++){\n            ans+=dp[c2[i]][c1[i]];\n        }\n        out.println(ans);\n    }\n\n    void solve(){\n        go();\n    }\n\n    void run() throws Exception\n    {\n        is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        tr(System.currentTimeMillis()-s+\"ms\");\n    }\n\n    public static void main(String[] args) throws Exception { new Main().run(); }\n\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n\n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n\n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        for(;(b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'););\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        for(;;){\n            if(Character.isDigit(b)){\n                num = num * 10 + (b - '0');\n            } else\n                return minus ? -num : num;\n            b = readByte();\n        }\n    }\n\n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        for(;(b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'););\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        for(;;){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    //private boolean oj = true;\n\n    private boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.lang.*;\nimport java.math.BigInteger;\nimport java.util.regex.*;\npublic class Myclass {\n\t\t/*public static ArrayList a[]=new ArrayList[100001];\n\t\tpublic static boolean visited[]=new boolean [100001];\n\t\tpublic static int dp[]=new int[100001];\n\t\tstatic TreeSet<Integer>sub=new TreeSet<>();\n\t\tpublic static void bfs()\n\t\t{\n\t\t\tQueue<pair> q=new LinkedList<>();\n\t\t\tq.add(new pair(1,1));\n\t\t\tdp[1]=0;\n\t\t\twhile(!q.isEmpty())\n\t\t\t{\n\t\t\t\tpair p=q.poll();\n\t\t\t\tint y=p.x;\n\t\t\t\tvisited[y]=true;\n\t\t\t\tfor(int i=0;i<a[y].size();i++)\n\t\t\t\t{\n\t\t\t\t\tpair id=(pair) a[y].get(i);\n\t\t\t\t\tif(!visited[id.x])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(id.y==2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsub.add(dp[y]);\n\t\t\t\t\t\t\tdp[id.x]=id.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[id.x]=dp[y];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tstatic int n,m;\n\t\tpublic static boolean cheak(int i,int j)\n\t\t{\n\t\t\treturn(i>=0&&i<n &&j>=0&&j<m);\n\t\t}\n\t\t\n\t\tpublic static void main(String[] args)\n\t\t{\n\t\t    InputReader in = new InputReader(System.in);\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\tint n=in.nextInt();\n\t\t\tint k=in.nextInt();\n\t\t\tint a[]=new int[n*k];\n\t\t\tint freq[]=new int[100001];\n\t\t\tint people[]=new int[100001];\n\t\t\tfor(int i=0;i<n*k;i++)\n\t\t\t{\n\t\t\t\t a[i]=in.nextInt();\n\t\t\t\tfreq[a[i]]++;\n\t\t\t}\n\t\t\tint f[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tf[i]=in.nextInt();\n\t\t\t\tpeople[f[i]]++;\n\t\t\t}\n\t\t\tint h[]=new int[k];\n\t\t\tfor(int i=0;i<k;i++)\n\t\t\t{\n\t\t\t\th[i]=in.nextInt();\n\t\t\t}\n\t\t\tlong dp[][]=new long[n+1][n*k+1];\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=1;j<=n*k;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(int gv=1;gv<=k;gv++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j>=gv)\n\t\t\t\t\t\tdp[i][j]=Math.max(dp[i][j], dp[i-1][j-gv]+h[gv-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<100001;i++)\n\t\t\t{\n\t\t\t\tif(people[i]*k<=freq[i])\n\t\t\t\t\tsum+=h[k-1]*people[i];\n\t\t\t\telse\n\t\t\t\t\tsum+=dp[people[i]][freq[i]];\n\t\t\t}\n\t\t\tpw.println(sum);\n\t\t\tpw.flush();\n\t\t\tpw.close();\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\n\n\t\tstatic class InputReader \n\t\t{\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) \n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\t\tpublic int snext() \n\t\t{\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) \n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} \n\t\t\t\tcatch (IOException e) \n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() \n\t    {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) \n\t\t\t{\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-')\n\t\t    {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong()\n\t    {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) \n\t\t\t{\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) \n\t\t{\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t{\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tstatic class tri implements Comparable<tri> {\n\t\t\tint p, c, l;\n\n\t\t\ttri(int p, int c, int l) {\n\t\t\t\tthis.p = p;\n\t\t\t\tthis.c = c;\n\t\t\t\tthis.l = l;\n\t\t\t}\n\n\t\t\tpublic int compareTo(tri o) {\n\t\t\t\treturn Integer.compare(l, o.l);\n\t\t\t}\n\t\t}\n\n\t\tpublic String readString()\n\t    {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) \n\t\t\t{\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() \n\t\t{\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) \n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) \n\t\t{\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter\n\t    {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n\t\tpublic static long mod = 1000000007;\n\t\tpublic static int d;\n\t\tpublic static int p;\n\t\tpublic static int q;\n\t\t\n\t\tpublic static int[] suffle(int[] a,Random gen)\n\t\t{\n\t\t\tint n = a.length;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint ind = gen.nextInt(n-i)+i;\n\t\t\t\tint temp = a[ind];\n\t\t\t\ta[ind] = a[i];\n\t\t\t\ta[i] = temp;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tpublic static void swap(int a, int b){\n\t\t\tint temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t}\n\t\t\n\t\tpublic static HashSet<Integer> primeFactorization(int n)\n\t\t{\n\t\t\tHashSet<Integer> a =new HashSet<Integer>();\n\t\t\tfor(int i=2;i*i<=n;i++)\n\t\t\t{\n\t\t\t\twhile(n%i==0)\n\t\t\t\t{\n\t\t\t\t\ta.add(i);\n\t\t\t\t\tn/=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(n!=1)\n\t\t\t\ta.add(n);\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tpublic static void sieve(boolean[] isPrime,int n)\n\t\t{\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t\tisPrime[i] = true;\n\t\t\t\n\t\t\tisPrime[0] = false;\n\t\t\tisPrime[1] = false;\n\t\t\t\n\t\t\tfor(int i=2;i*i<n;i++)\n\t\t\t{\n\t\t\t\tif(isPrime[i] == true)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=(2*i);j<n;j+=i)\n\t\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static int GCD(int a,int b)\n\t\t{\n\t\t\tif(b==0)\n\t\t\t\treturn a;\n\t\t\telse\n\t\t\t\treturn GCD(b,a%b);\n\t\t}\n\t\t\n\t\tpublic static long GCD(long a,long b)\n\t\t{\n\t\t\tif(b==0)\n\t\t\t\treturn a;\n\t\t\telse\n\t\t\t\treturn GCD(b,a%b);\n\t\t}\n\t\t\n\t\tpublic static void extendedEuclid(int A,int B)\n\t\t{\n\t\t\tif(B==0)\n\t\t\t{\n\t\t\t\td = A;\n\t\t\t\tp = 1 ;\n\t\t\t\tq = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\textendedEuclid(B, A%B);\n\t\t\t\tint temp = p;\n\t\t\t\tp = q;\n\t\t\t\tq = temp - (A/B)*q;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static long LCM(long a,long b)\n\t\t{\n\t\t\treturn (a*b)/GCD(a,b);\n\t\t}\n\t\t\n\t\tpublic static int LCM(int a,int b)\n\t\t{\n\t\t\treturn (a*b)/GCD(a,b);\n\t\t}\n\t\t\n\t\tpublic static int binaryExponentiation(int x,int n)\n\t\t{\n\t\t    int result=1;\n\t\t    while(n>0)\n\t\t    {\n\t\t        if(n % 2 ==1)\n\t\t            result=result * x;\n\t\t        x=x*x;\n\t\t        n=n/2;\n\t\t    }\n\t\t    return result;\n\t\t}\n\t\t\n\t\tpublic static long binaryExponentiation(long x,long n)\n\t\t{\n\t\t    long result=1;\n\t\t    while(n>0)\n\t\t    {\n\t\t        if(n % 2 ==1)\n\t\t            result=result * x;\n\t\t        x=x*x;\n\t\t        n=n/2;\n\t\t    }\n\t\t    return result;\n\t\t}\n\t\t\n\t\tpublic static int modularExponentiation(int x,int n,int M)\n\t\t{\n\t\t    int result=1;\n\t\t    while(n>0)\n\t\t    {\n\t\t        if(n % 2 ==1)\n\t\t            result=(result * x)%M;\n\t\t        x=(x*x)%M;\n\t\t        n=n/2;\n\t\t    }\n\t\t    return result;\n\t\t}\n\t\t\n\t\tpublic static long modularExponentiation(long x,long n,long M)\n\t\t{\n\t\t    long result=1;\n\t\t    while(n>0)\n\t\t    {\n\t\t        if(n % 2 ==1)\n\t\t            result=(result * x)%M;\n\t\t        x=(x*x)%M;\n\t\t        n=n/2;\n\t\t    }\n\t\t    return result;\n\t\t}\n\t\t\n\t\tpublic static long modInverse(int A,int M)\n\t\t{\n\t\t    return modularExponentiation(A,M-2,M);\n\t\t}\n\t\t\n\t\tpublic static long modInverse(long A,long M)\n\t\t{\n\t\t    return modularExponentiation(A,M-2,M);\n\t\t}\n\t\t\n\t\tpublic static boolean isPrime(int n)\n\t\t{\n\t\t    \n\t\t    if (n <= 1)  return false;\n\t\t    if (n <= 3)  return true;\n\t\t    \n\t\t    if (n%2 == 0 || n%3 == 0) \n\t\t    \treturn false;\n\t\t \n\t\t    for (int i=5; i*i<=n; i=i+6)\n\t\t    {\n\t\t        if (n%i == 0 || n%(i+2) == 0)\n\t\t           return false;\n\t\t    }\n\t\t    \n\t\t    return true;\n\t\t}\n\t\t\n\t\t public static long[] shuffle(long[] a, Random gen){ \n\t\t        for(int i = 0, n = a.length;i < n;i++){ \n\t\t            int ind = gen.nextInt(n-i)+i; \n\t\t            long d = a[i]; \n\t\t            a[i] = a[ind]; \n\t\t            a[ind] = d; \n\t\t        } \n\t\t        return a; \n\t\t    }\n\t\tstatic class pair implements Comparable<pair>\n\t\t{\n\t\t\tInteger x;\n\t\t\tInteger y;\n\t\t\tpair(int a,int m)\n\t\t\t{\n\t\t\t\tthis.x=a;\n\t\t\t\tthis.y=m;\n\t\t\t}\n\t\t\t\n\n\t\t\t\n\n\n\t\tpublic int compareTo(pair o) {\n\t\t\t\tint result = x.compareTo(o.x);\n\t\t\t\tif(result==0)\n\t\t\t\t\tresult = y.compareTo(o.y);\n\t\t\t\t\n\t\t\treturn result;\n\t\t\t}  \n\t\t\t\n\t\t\tpublic String toString()\n\t\t\t{\n\t\t\t\treturn x+\" \"+y;\n\t\t\t}\n\t\t\t\n\t\t\tpublic boolean equals(Object o)\n\t\t\t{\n\t\t\t\tif (o instanceof pair)\n\t\t\t    {\n\t\t\t\t\tpair p = (pair)o;\n\t\t\t\t\treturn p.x == x && p.y == y ;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpublic int hashCode()\n\t\t\t{\n\t\t\t\treturn new Long(x).hashCode()*31 + new Long(y).hashCode();\n\t\t\t}\n\t\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint c[5005], h[11], f[505];\nint cnt[100005];\nint fcnt[100005];\nint cache[5005][505];\nint solve(int idx1, int idx2) {\n  if (idx1 == 0 || idx2 == 0) return 0;\n  int &ret = cache[idx1][idx2];\n  if (ret != -1) return ret;\n  ret = 0;\n  for (int i = 0; i <= k && i <= idx1; i++)\n    ret = max(ret, solve(idx1 - i, idx2 - 1) + h[i]);\n  return ret;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n * k; i++) {\n    scanf(\"%d\", &c[i]);\n    cnt[c[i]]++;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &f[i]);\n    fcnt[f[i]]++;\n  }\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &h[i]);\n  int ans = 0;\n  for (int i = 0; i < 100005; i++) {\n    if (fcnt[i]) {\n      memset(cache, -1, sizeof(cache));\n      ans += solve(cnt[i], fcnt[i]);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n    static final long INF = (long) 1e15;\n    static final int max = (int) (1e5 + 1);\n    static final int UNCALC = -1;\n    static int[] h;\n    static int k;\n    static int n;\n    static int memo[][];\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        k = sc.nextInt();\n        int[] cnt = new int[max];\n        for (int i = 0; i < n * k; i++)\n            cnt[sc.nextInt()]++;\n        int[] fav = new int[max];\n        for (int i = 0; i < n; i++)\n            fav[sc.nextInt()]++;\n        h = sc.nextIntArray(k);\n        int ans = 0;\n        for (int i = 0; i < max; i++)\n            ans += get(fav[i], cnt[i]);\n        out.println(ans);\n        out.flush();\n        out.close();\n    }\n\n    static int get(int nn, int tot) {\n        if (nn == 0 || tot == 0) return 0;\n        memo = new int[nn][tot+1];\n        n = nn;\n        for (int[] a : memo)\n            Arrays.fill(a, UNCALC);\n        return dp(0, tot);\n    }\n\n    static int dp(int i, int rem) {\n        if (i == n) return 0;\n        if (memo[i][rem] != UNCALC) return memo[i][rem];\n        int max = 0;\n        for (int take = 0; take <= Math.min(k, rem); take++)\n            max = Math.max((take == 0 ? 0 : h[take - 1]) + dp(i + 1, rem - take), max);\n        return memo[i][rem] = max;\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n        public Scanner(String file) throws Exception {\n            br = new BufferedReader(new FileReader(file));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public Long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n        public void waitForInput() throws InterruptedException {\n            Thread.sleep(3000);\n        }\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextDouble();\n            return ans;\n        }\n\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Solution{\n\t\n\t\n\tstatic final int N = (int)1e5+10;\n\t\n\t\n\t\n\t\n\t\n    public static void main(String[] args) throws IOException {\n    \t\n\t\t\n    \tFastScanner fs = new FastScanner();\n    \tPrintWriter out = new PrintWriter(System.out);\n    \t\t\n    \tint tt = 1;\n    \twhile(tt-->0) {\n    \t\t\n    \t\tint n = fs.nextInt(), k = fs.nextInt();\n    \t\tint[] c = new int[N];\n    \t\t\n    \t\tfor(int i=0;i<n*k;i++) {\n    \t\t\tint x = fs.nextInt();\n    \t\t\tc[x]++;\n    \t\t}\n    \t\t\n    \t\tint[] f = new int[N];\n    \t\t\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\tint x = fs.nextInt();\n    \t\t\tf[x]++;\n    \t\t}\n    \t\t\n    \t\tint[] h = new int[k+1];\n    \t\th[0] = 0;\n    \t\t\n    \t\tfor(int i=1;i<=k;i++) {\n    \t\t\th[i] = fs.nextInt();\n    \t\t}\n    \t\t\n    \t\tlong[][] dp = new long[n+1][k*n+1];\n    \t\tdp[0][0] = 0;\n    \t\t\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\tfor(int j=0;j<=i*k;j++) {\n    \t\t\t\tfor(int cur=0;cur<=k;cur++) {\n    \t\t\t\t\tdp[i+1][j+cur] = Math.max(dp[i+1][j+cur], dp[i][j] + h[cur]);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\t\n    \t\tlong ans = 0;\n    \t\t\n    \t\tfor(int i=0;i<N;i++) {\n    \t\t\tans += dp[f[i]][Math.min(k*f[i], c[i])];\n    \t\t}\n    \t\t\n    \t\tout.println(ans);\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t}\n    \t\n    \tout.close();\n    \t\t\n    }\n    \n    \n    \n    \n    \n    static final Random random=new Random();\n    \n    static <T> void shuffle(T[] arr) {\n    \tint n = arr.length;\n    \tfor(int i=0;i<n;i++\t) {\n    \t\tint k = random.nextInt(n);\n    \t\tT temp = arr[k]; arr[k] = arr[i]; arr[i] = temp;\n    \t}\n    }\n    \n    \t\n    static void ruffleSort(int[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); int temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n    \n    static void ruffleSort(long[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); long temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n   \n  \n    \n    static void reverse(int[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tint temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    static void reverse(long[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tlong temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    \n    static <T> void reverse(T[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++) {\n    \t\tT temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \t\n    \t\n    static class FastScanner{\n    \tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    \tStringTokenizer st = new StringTokenizer(\"\");\n     \n    \tpublic String next(){\n    \t\twhile(!st.hasMoreElements()){\n    \t\t\ttry{\n    \t\t\t\tst = new StringTokenizer(br.readLine());\n    \t\t\t} catch(IOException e){\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\t}\n    \t\treturn st.nextToken();\n    \t}\n    \t\t\n    \tpublic String nextLine() throws IOException {\n    \t\treturn br.readLine();\n    \t}\n    \t\t\n    \tpublic int nextInt(){\n    \t\treturn Integer.parseInt(next());\n    \t}\n     \n    \tpublic int[] readArray(int n){\n    \t\tint[] a = new int[n];\n    \t\tfor(int i=0;i<n;i++)\n    \t\t\ta[i] = nextInt();\n    \t\treturn a;\n    \t}\n    \t\t\n    \tpublic long nextLong() {\n    \t\treturn Long.parseLong(next());\n    \t}\n    \t\t\n    \tpublic char nextChar() {\n    \t\treturn next().toCharArray()[0];\n    \t}\n    }\n   \t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100100;\nconst int maxk = 510;\nint n, k;\nint temp;\nint c[maxn], f[maxn], dp[maxk][maxk * 10];\nint res, h[11];\nint main() {\n  int cnt = 0;\n  while (~scanf(\"%d%d\", &n, &k)) {\n    if (cnt++) {\n      memset(c, 0, sizeof c);\n      memset(f, 0, sizeof f);\n      memset(dp, 0, sizeof dp);\n    }\n    int tot = n * k;\n    for (int i = 0; i < tot; i++) {\n      scanf(\"%d\", &temp);\n      c[temp]++;\n    }\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d\", &temp);\n      f[temp]++;\n    }\n    for (int i = 1; i <= k; i++) {\n      scanf(\"%d\", &h[i]);\n    }\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= tot; j++) {\n        for (int t = 1; t <= min(j, k); t++) {\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - t] + h[t]);\n        }\n      }\n    }\n    res = 0;\n    for (int i = 1; i <= 1e5; i++) {\n      if (f[i]) {\n        res += dp[f[i]][c[i]];\n      }\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\ntemplate <typename T>\nT gcd(T m, T n) {\n  while (n) {\n    T t = m % n;\n    m = n;\n    n = t;\n  };\n  return m;\n}\ntemplate <typename T>\nT exgcd(T a, T b, T& sa, T& ta) {\n  T q, r, sb = 0, tb = 1, sc, tc;\n  sa = 1, ta = 0;\n  if (b) do\n      q = a / b, r = a - q * b, a = b, b = r, sc = sa - q * sb, sa = sb,\n      sb = sc, tc = ta - q * tb, ta = tb, tb = tc;\n    while (b);\n  return a;\n}\ntemplate <typename T>\nT mul_inv(T a, T b) {\n  T t1 = a, t2 = b, t3;\n  T v1 = 1, v2 = 0, v3;\n  T x;\n  while (t2 != 1)\n    x = t1 / t2, t3 = t1 - x * t2, v3 = v1 - x * v2, t1 = t2, t2 = t3, v1 = v2,\n    v2 = v3;\n  return (v2 + b) % b;\n}\ntemplate <typename T>\nT powmod(T a, T b, T MOD) {\n  if (b < 0) return 0;\n  T rv = 1;\n  while (b) (b % 2) && (rv = (rv * a) % MOD), a = a * a % MOD, b /= 2;\n  return rv;\n}\ntemplate <long long n>\nstruct BitSize {\n  enum { Size = BitSize<n / 2>::Size + 1 };\n};\ntemplate <>\nstruct BitSize<0> {\n  enum { Size = 1 };\n};\ntemplate <>\nstruct BitSize<1> {\n  enum { Size = 1 };\n};\nconst int maxn = 500;\nconst int maxk = 10;\nconst int maxci = 10e5 + 7;\nint n, k;\nint c[maxci];\nint f[maxn + 1];\nint h[maxk + 1];\nlong long dp[maxn + 1][maxn * maxk + 7];\nint main(int argc, char* argv[]) {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  (cin >> n >> k);\n  {\n    memset(c, 0, sizeof(c));\n    int mx = 0;\n    for (int i = 1, ie = k * n; i <= ie; i++) {\n      int x;\n      cin >> x;\n      mx = max(mx, ++c[x]);\n    }\n    map<int, int> FN;\n    FN.clear();\n    for (int i = 1; i <= n; i++) {\n      cin >> f[i];\n      FN[f[i]]++;\n    }\n    h[0] = 0;\n    for (int i = 1; i <= k; i++) cin >> h[i];\n    memset(dp, 0, sizeof(dp));\n    for (int p = 1; p <= n; p++) {\n      for (int x = 1; x <= mx; x++) {\n        for (int j = 1; j <= k; j++) {\n          if (x >= j) {\n            dp[p][x] = max(dp[p][x], dp[p - 1][x - j] + h[j]);\n          }\n        }\n      }\n    }\n    long long r = 0;\n    for (auto it : FN) {\n      long long pc = it.second;\n      long long nc = c[it.first];\n      r += dp[pc][nc];\n    }\n    cout << r << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long power(long long x, long long y, long long m);\nlong long modInverse(long long n, long long m);\nlong long nCr(long long n, long long r, long long m);\nlong long ceiling(long long x, long long y);\nbool sortbyth(const tuple<long long, int, int>& a,\n              const tuple<long long, int, int>& b) {\n  if (get<0>(a) != get<0>(b))\n    return get<0>(a) > get<0>(b);\n  else\n    return get<1>(a) < get<1>(b);\n}\nint dx[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint dy[] = {-1, 0, 1, 1, 1, 0, -1, -1};\nvoid aksayushx() {\n  long long n, k;\n  cin >> n >> k;\n  vector<long long> cards(n * k);\n  for (long long i = 0; i < n * k; i++) cin >> cards[i];\n  vector<long long> f(n), h(k);\n  for (long long i = 0; i < n; i++) cin >> f[i];\n  for (long long i = 0; i < k; i++) cin >> h[i];\n  vector<vector<long long>> dp(n + 1, vector<long long>(k * n + 1, -1));\n  for (long long i = 0; i <= k * n; i++) dp[0][i] = 0;\n  for (long long i = 0; i <= n; i++) dp[i][0] = 0;\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= k * n; j++) {\n      for (long long give = 0; give <= k; give++) {\n        if (give > j) break;\n        long long happiness = give == 0 ? 0 : h[give - 1];\n        happiness += dp[i - 1][j - give];\n        dp[i][j] = max(dp[i][j], happiness);\n      }\n    }\n  }\n  map<long long, long long> cf, pf;\n  for (long long i = 0; i < n; i++) pf[f[i]]++;\n  for (long long i = 0; i < n * k; i++) cf[cards[i]]++;\n  long long ans = 0;\n  for (auto& e : cf) {\n    long long cardsav = e.second;\n    long long people = pf[e.first];\n    ans += dp[people][cardsav];\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t = 1;\n  while (t--) aksayushx();\n  return 0;\n}\nlong long power(long long x, long long y, long long m) {\n  long long res = 1;\n  x = x % m;\n  if (x == 0) return 0;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % m;\n    y = y >> 1;\n    x = (x * x) % m;\n  }\n  return res;\n}\nlong long modInverse(long long n, long long m) { return power(n, m - 2, m); }\nlong long ceiling(long long x, long long y) { return (x + y - 1) / y; }\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class F {\n\n    static int[] h;\n    static int k;\n\n    static int[][][] memo;\n\n    static int dp(int p, int m, int l) {\n        if(m == 0 || p == 0)\n            return p != 0 ? h[k - l] : 0;\n        if(memo[l][p][m] != -1)\n            return memo[l][p][m];\n        return memo[l][p][m] = Math.max(h[k - l] + dp(p - 1, m, k), l == 0 ? 0 : dp(p, m - 1, l - 1));\n    }\n    public static void main(String[] args) throws IOException {\n\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        k = sc.nextInt();\n        h = new int[n + 1];\n        HashMap<Integer, Integer> c = new HashMap<>();\n        for(int i = n * k - 1; i >= 0; --i) {\n            int x = sc.nextInt();\n            c.put(x, c.getOrDefault(x, 0) + 1);\n        }\n\n        HashMap<Integer, Integer> f = new HashMap<>();\n        for(int i = n - 1; i >= 0; --i) {\n            int x = sc.nextInt();\n            f.put(x, f.getOrDefault(x, 0) + 1);\n        }\n        for(int i = 1; i <= k; ++i)\n            h[i] = sc.nextInt();\n        memo = new int[k + 1][n + 1][n * k + 1];\n        for(int[][] x: memo)\n            for(int[] y: x)\n                Arrays.fill(y, -1);\n        int ans = 0;\n        for(Map.Entry<Integer, Integer> e: f.entrySet())\n            ans += dp(e.getValue(), c.getOrDefault(e.getKey(), 0), k);\n        out.println(ans);\n        out.close();\n    }\n\n    static class Scanner\n    {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n        public String next() throws IOException\n        {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {return Integer.parseInt(next());}\n\n        public long nextLong() throws IOException {return Long.parseLong(next());}\n\n        public double nextDouble() throws IOException { return Double.parseDouble(next()); }\n\n        public String nextLine() throws IOException {return br.readLine();}\n\n        public boolean ready() throws IOException { return br.ready(); }\n\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class CardsAndJoy {\n\tstatic int cards;\n\tstatic int[] H;\n\tstatic int INF=(int) 1e9;\n\tstatic int[][] memo;\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\tint ppl=sc.nextInt();\n\t\tcards=sc.nextInt();\n\t\tmemo=new int[501][5001];\n\t\t \n\t\tfor(int i=0;i<501;i++)\n\t\t\t Arrays.fill(memo[i],-1);\n\t\t \n\t\tint[] Cards=new int[(int) 1e5 +1]; //\n\t\tfor(int i=0;i<ppl*cards;i++)\n\t\t\tCards[sc.nextInt()]++;\n\t\t\n\t\tint[] fav=new int[ppl];\n\t\tint[] favf=new int[(int) 1e5 +1]; //\n\t\t\n\t\tfor(int i=0;i<ppl;i++) {\n\t\t\tfavf[fav[i]=sc.nextInt()]++;\n\t\t}\n\t\tArrays.sort(fav);\n\t\t\n\t\tH=new int[cards];\n\t\t\n\t\tfor(int i=0;i<cards;i++)\n\t\t\tH[i]=sc.nextInt();\n\n\t\tint total=0;\n\t\tboolean inc=false;\n\t\t\n\t\tfor(int i=0;i<ppl;i++) {\n\t\t\tinc=false;\n\t\t\tint f=fav[i];\n\t\t\tif(Cards[fav[i]]==0)\n\t\t\t\tcontinue;\n\t\t\telse {\n\t\t\t\tint p=favf[fav[i]];\n\t\t\t\tint c=Cards[fav[i]];\n\t\t\t\t\n\t\t\t\ttotal+=dp(p,c);\n//\t\t\t\tSystem.out.println(p+\" \"+c);\n//\t\t\t\tSystem.out.println(dp(p,c));\n\t\t\t\t\n\t\t\t\twhile(i <ppl && fav[i]==f) {\n\t\t\t\t\ti++;\n\t\t\t\t\tinc=true;\n\t\t\t\t}\n\t\t\t\tif(inc)\n\t\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t    System.out.println(total);\n\t}\n\t\n\tpublic static int dp(int p, int c) {\n\t\tif(p==0) \n\t\t\treturn 0;\n\t\t\n\t\tif(c<0)\n\t\t\treturn -INF;\n\t\t\n\t\tif(memo[p][c]!=-1)\n\t\t\treturn memo[p][c];\n\t\t\n\t\tint max=0;\n\t\t\n\t\tfor(int i=0;i<c && i<cards;i++) \n\t\t\tmax=Math.max(max, dp(p-1,c-i-1)+H[i]);\n\t\t\n\t\treturn memo[p][c]=max;\n\t}\n\n\tstatic class Scanner \n\t{\n\t    StringTokenizer st;\n\t    BufferedReader br;\n\n\t    public Scanner(InputStream s){    br = new BufferedReader(new InputStreamReader(s));}\n\n\t    public String next() throws IOException \n\t    {\n\t        while (st == null || !st.hasMoreTokens()) \n\t            st = new StringTokenizer(br.readLine());\n\t        return st.nextToken();\n\t    }\n\n\t    public int nextInt() throws IOException {return Integer.parseInt(next());}\n\t    \n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 501, K = 11;\nlong long n, k;\nlong long c[N * K];\nlong long f[N];\nlong long h[K];\nmap<long long, long long> num;\nmap<long long, long long> rs;\nlong long ans = 0;\nlong long dp[N * K][N];\nlong long read() {\n  long long x = 0;\n  char c = getchar();\n  while (isdigit(c)) {\n    x = ((x << 1) + (x << 3) + (c ^ 48));\n    c = getchar();\n  }\n  return x;\n}\nlong long tmp = 0;\nint main() {\n  n = read();\n  k = read();\n  for (long long i = 1; i <= n * k; i++) c[i] = read(), num[c[i]]++;\n  for (long long i = 1; i <= n; i++) f[i] = read(), rs[f[i]]++;\n  for (long long i = 1; i <= k; i++) h[i] = read();\n  sort(f + 1, f + n + 1);\n  tmp = f[1] - 1;\n  for (long long i = 1; i <= n * k; i++) {\n    long long minn = min(i, k);\n    dp[i][1] = h[minn];\n    for (long long j = 2; j <= n; j++) {\n      for (long long t = 1; t <= minn; t++) {\n        dp[i][j] = max(dp[i][j], dp[i - t][j - 1] + h[t]);\n      }\n    }\n  }\n  for (long long i = 1; i <= n;) {\n    tmp = f[i];\n    i += rs[tmp];\n    ans += dp[num[tmp]][rs[tmp]];\n  }\n  cout << ans << endl;\n}\n"
        }
    ]
}