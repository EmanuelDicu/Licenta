{
    "name": "1561_D2. Up the Strip",
    "source": "CODEFORCES",
    "description": "Note that the memory limit in this problem is lower than in others.\n\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\n\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\n\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \n\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \n\n\n\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\n\nInput\n\nThe only line contains two integers n and m (2 \u2264 n \u2264 4 \u22c5 10^6; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\n\nOutput\n\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\n\nExamples\n\nInput\n\n\n3 998244353\n\n\nOutput\n\n\n5\n\n\nInput\n\n\n5 998244353\n\n\nOutput\n\n\n25\n\n\nInput\n\n\n42 998244353\n\n\nOutput\n\n\n793019428\n\n\nInput\n\n\n787788 100000007\n\n\nOutput\n\n\n94810539\n\nNote\n\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\n\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\n\nTherefore, there are five ways in total.",
    "difficulty": "D",
    "tags": [
        "brute force",
        "dp",
        "math",
        "number theory"
    ],
    "rating": 1900,
    "public_test": [
        {
            "input": "3 998244353\n",
            "output": "5"
        },
        {
            "input": "42 998244353\n",
            "output": "793019428"
        },
        {
            "input": "787788 100000007\n",
            "output": "94810539"
        },
        {
            "input": "5 998244353\n",
            "output": "25"
        }
    ],
    "generated_test": [
        {
            "input": "182550 754401678\n",
            "output": "331750090\n"
        },
        {
            "input": "93 318786553\n",
            "output": "3834838\n"
        },
        {
            "input": "363 791893607\n",
            "output": "297147181\n"
        },
        {
            "input": "3912472 307193683\n",
            "output": "149191773\n"
        },
        {
            "input": "104450 998244353\n",
            "output": "806661494\n"
        },
        {
            "input": "6 879902963\n",
            "output": "55\n"
        },
        {
            "input": "30249 936347479\n",
            "output": "142140502\n"
        },
        {
            "input": "2924225 466256901\n",
            "output": "96875854\n"
        },
        {
            "input": "69843 463252301\n",
            "output": "422573163\n"
        },
        {
            "input": "2383 248535541\n",
            "output": "32560999\n"
        },
        {
            "input": "2525447 612881327\n",
            "output": "368194805\n"
        },
        {
            "input": "4 1022845464\n",
            "output": "12\n"
        },
        {
            "input": "4000000 183642095\n",
            "output": "22912955\n"
        },
        {
            "input": "3 1745482103\n",
            "output": "5\n"
        },
        {
            "input": "42 182096533\n",
            "output": "150614713\n"
        },
        {
            "input": "787788 40344335\n",
            "output": "13963078\n"
        },
        {
            "input": "5 1823748024\n",
            "output": "25\n"
        },
        {
            "input": "182550 259156327\n",
            "output": "23231734\n"
        },
        {
            "input": "93 447734838\n",
            "output": "32270285\n"
        },
        {
            "input": "104450 147098549\n",
            "output": "79900151\n"
        },
        {
            "input": "8 879902963\n",
            "output": "231\n"
        },
        {
            "input": "2924225 629135317\n",
            "output": "498731287\n"
        },
        {
            "input": "69843 799260826\n",
            "output": "715019339\n"
        },
        {
            "input": "1106 248535541\n",
            "output": "238535103\n"
        },
        {
            "input": "3175292 612881327\n",
            "output": "609803727\n"
        },
        {
            "input": "2 1745482103\n",
            "output": "2\n"
        },
        {
            "input": "31 182096533\n",
            "output": "23516106\n"
        },
        {
            "input": "787788 44544120\n",
            "output": "10298823\n"
        },
        {
            "input": "182550 356939314\n",
            "output": "33287744\n"
        },
        {
            "input": "77 447734838\n",
            "output": "278525249\n"
        },
        {
            "input": "104450 29817370\n",
            "output": "19290250\n"
        },
        {
            "input": "9 879902963\n",
            "output": "466\n"
        },
        {
            "input": "2924225 78749238\n",
            "output": "64277353\n"
        },
        {
            "input": "101599 799260826\n",
            "output": "467453677\n"
        },
        {
            "input": "653 248535541\n",
            "output": "66084596\n"
        },
        {
            "input": "2984980 612881327\n",
            "output": "547104902\n"
        },
        {
            "input": "31 213877682\n",
            "output": "101678831\n"
        },
        {
            "input": "787788 43068696\n",
            "output": "21525519\n"
        },
        {
            "input": "182550 673535321\n",
            "output": "562002790\n"
        },
        {
            "input": "77 439653971\n",
            "output": "14989602\n"
        },
        {
            "input": "104450 44764019\n",
            "output": "11645004\n"
        },
        {
            "input": "186221 799260826\n",
            "output": "277058979\n"
        },
        {
            "input": "346 248535541\n",
            "output": "75903713\n"
        },
        {
            "input": "1185887 612881327\n",
            "output": "20242229\n"
        },
        {
            "input": "31 193044863\n",
            "output": "96129339\n"
        },
        {
            "input": "787788 75141983\n",
            "output": "38444895\n"
        },
        {
            "input": "227600 673535321\n",
            "output": "417031934\n"
        },
        {
            "input": "89 439653971\n",
            "output": "432690230\n"
        },
        {
            "input": "118564 44764019\n",
            "output": "10860768\n"
        },
        {
            "input": "186221 190113066\n",
            "output": "167300161\n"
        },
        {
            "input": "630 248535541\n",
            "output": "69612322\n"
        },
        {
            "input": "1185887 820168200\n",
            "output": "599059054\n"
        },
        {
            "input": "31 250865928\n",
            "output": "19650545\n"
        },
        {
            "input": "716714 75141983\n",
            "output": "71308850\n"
        },
        {
            "input": "15 1116240308\n",
            "output": "30793\n"
        },
        {
            "input": "227600 997062914\n",
            "output": "159596758\n"
        },
        {
            "input": "165 439653971\n",
            "output": "110178601\n"
        },
        {
            "input": "212169 44764019\n",
            "output": "38923596\n"
        },
        {
            "input": "186221 248736626\n",
            "output": "109267203\n"
        },
        {
            "input": "1116 248535541\n",
            "output": "198441612\n"
        },
        {
            "input": "10 250865928\n",
            "output": "947\n"
        },
        {
            "input": "716714 9396539\n",
            "output": "3092228\n"
        },
        {
            "input": "227600 604116569\n",
            "output": "548651355\n"
        },
        {
            "input": "150 439653971\n",
            "output": "87582893\n"
        },
        {
            "input": "212169 81610688\n",
            "output": "1183222\n"
        },
        {
            "input": "186221 473301202\n",
            "output": "194640529\n"
        },
        {
            "input": "1146 248535541\n",
            "output": "70112473\n"
        },
        {
            "input": "14 250865928\n",
            "output": "15388\n"
        },
        {
            "input": "367960 9396539\n",
            "output": "1830007\n"
        },
        {
            "input": "227600 14038108\n",
            "output": "948654\n"
        },
        {
            "input": "150 807177737\n",
            "output": "108423380\n"
        },
        {
            "input": "4152 81610688\n",
            "output": "30074061\n"
        },
        {
            "input": "11 50907741\n",
            "output": "1895\n"
        },
        {
            "input": "186221 514794851\n",
            "output": "508420149\n"
        },
        {
            "input": "1146 233873517\n",
            "output": "161815303\n"
        },
        {
            "input": "367960 6657520\n",
            "output": "6110527\n"
        },
        {
            "input": "227600 27497781\n",
            "output": "21736379\n"
        },
        {
            "input": "24 807177737\n",
            "output": "15830909\n"
        },
        {
            "input": "4152 46369125\n",
            "output": "1140634\n"
        },
        {
            "input": "186221 19810836\n",
            "output": "7472617\n"
        },
        {
            "input": "1146 6967396\n",
            "output": "912187\n"
        },
        {
            "input": "163040 6657520\n",
            "output": "2064610\n"
        },
        {
            "input": "156823 27497781\n",
            "output": "11285900\n"
        },
        {
            "input": "17 807177737\n",
            "output": "123431\n"
        },
        {
            "input": "6948 46369125\n",
            "output": "997242\n"
        },
        {
            "input": "301385 19810836\n",
            "output": "2528500\n"
        },
        {
            "input": "166 6967396\n",
            "output": "6512293\n"
        },
        {
            "input": "163040 1542905\n",
            "output": "631025\n"
        },
        {
            "input": "156823 29246228\n",
            "output": "25289685\n"
        },
        {
            "input": "12331 46369125\n",
            "output": "43386667\n"
        },
        {
            "input": "75058 19810836\n",
            "output": "5744960\n"
        },
        {
            "input": "166 10580968\n",
            "output": "552545\n"
        },
        {
            "input": "163040 396627\n",
            "output": "105423\n"
        },
        {
            "input": "156823 21780074\n",
            "output": "4352617\n"
        },
        {
            "input": "12331 61732484\n",
            "output": "577901\n"
        },
        {
            "input": "75058 15541748\n",
            "output": "2940888\n"
        },
        {
            "input": "261 10580968\n",
            "output": "3886965\n"
        },
        {
            "input": "94537 396627\n",
            "output": "250428\n"
        },
        {
            "input": "156823 22900124\n",
            "output": "11065121\n"
        },
        {
            "input": "20 17989931\n",
            "output": "989033\n"
        },
        {
            "input": "12331 79765391\n",
            "output": "32043942\n"
        },
        {
            "input": "42983 15541748\n",
            "output": "4504511\n"
        },
        {
            "input": "492 10580968\n",
            "output": "6622061\n"
        },
        {
            "input": "67942 396627\n",
            "output": "236326\n"
        },
        {
            "input": "156823 14860189\n",
            "output": "9185498\n"
        },
        {
            "input": "12331 117233745\n",
            "output": "93892702\n"
        },
        {
            "input": "42983 27829485\n",
            "output": "607808\n"
        },
        {
            "input": "492 3044541\n",
            "output": "1906814\n"
        },
        {
            "input": "67942 51199\n",
            "output": "4292\n"
        },
        {
            "input": "156823 8048341\n",
            "output": "394738\n"
        },
        {
            "input": "12331 83542833\n",
            "output": "63662263\n"
        },
        {
            "input": "41179 27829485\n",
            "output": "8091168\n"
        },
        {
            "input": "492 3323205\n",
            "output": "1736111\n"
        },
        {
            "input": "28599 51199\n",
            "output": "8838\n"
        },
        {
            "input": "206095 8048341\n",
            "output": "2597465\n"
        },
        {
            "input": "14052 83542833\n",
            "output": "2635117\n"
        },
        {
            "input": "67183 27829485\n",
            "output": "5252153\n"
        },
        {
            "input": "552 3323205\n",
            "output": "2824909\n"
        },
        {
            "input": "55258 51199\n",
            "output": "26614\n"
        },
        {
            "input": "10532 8048341\n",
            "output": "3299690\n"
        },
        {
            "input": "22769 83542833\n",
            "output": "10392111\n"
        },
        {
            "input": "67183 46989357\n",
            "output": "42900344\n"
        },
        {
            "input": "552 5092609\n",
            "output": "4054109\n"
        },
        {
            "input": "4941 51199\n",
            "output": "5524\n"
        },
        {
            "input": "19040 8048341\n",
            "output": "6583869\n"
        },
        {
            "input": "9248 83542833\n",
            "output": "4464453\n"
        },
        {
            "input": "67183 72452193\n",
            "output": "64858487\n"
        },
        {
            "input": "552 4024366\n",
            "output": "2604770\n"
        },
        {
            "input": "4941 51946\n",
            "output": "43303\n"
        },
        {
            "input": "17324 8048341\n",
            "output": "7197178\n"
        },
        {
            "input": "9248 139933488\n",
            "output": "111318681\n"
        },
        {
            "input": "67183 56504624\n",
            "output": "26373095\n"
        },
        {
            "input": "155 4024366\n",
            "output": "1783863\n"
        },
        {
            "input": "8271 51946\n",
            "output": "26105\n"
        },
        {
            "input": "17324 11981040\n",
            "output": "11164031\n"
        },
        {
            "input": "14261 139933488\n",
            "output": "39714764\n"
        },
        {
            "input": "128981 56504624\n",
            "output": "50954145\n"
        },
        {
            "input": "137 4024366\n",
            "output": "2031761\n"
        },
        {
            "input": "8271 37507\n",
            "output": "34813\n"
        },
        {
            "input": "23818 11981040\n",
            "output": "4537585\n"
        },
        {
            "input": "14261 157203681\n",
            "output": "105895505\n"
        },
        {
            "input": "128981 66633041\n",
            "output": "47281007\n"
        },
        {
            "input": "137 5368668\n",
            "output": "757071\n"
        },
        {
            "input": "5048 37507\n",
            "output": "27881\n"
        },
        {
            "input": "8782 11981040\n",
            "output": "8818471\n"
        },
        {
            "input": "2890 157203681\n",
            "output": "60777039\n"
        },
        {
            "input": "128981 70105743\n",
            "output": "28701894\n"
        },
        {
            "input": "152 5368668\n",
            "output": "5299211\n"
        },
        {
            "input": "5048 58721\n",
            "output": "41109\n"
        },
        {
            "input": "8782 19984674\n",
            "output": "13096249\n"
        },
        {
            "input": "2890 10972381\n",
            "output": "887484\n"
        },
        {
            "input": "128981 74610689\n",
            "output": "58240278\n"
        },
        {
            "input": "235 5368668\n",
            "output": "773188\n"
        },
        {
            "input": "5048 59691\n",
            "output": "9865\n"
        },
        {
            "input": "16473 19984674\n",
            "output": "3594421\n"
        },
        {
            "input": "2890 18871262\n",
            "output": "14193830\n"
        },
        {
            "input": "128981 73102034\n",
            "output": "65159059\n"
        },
        {
            "input": "235 4246068\n",
            "output": "67900\n"
        },
        {
            "input": "2093 59691\n",
            "output": "14622\n"
        },
        {
            "input": "11181 19984674\n",
            "output": "1897773\n"
        },
        {
            "input": "2842 18871262\n",
            "output": "9321592\n"
        },
        {
            "input": "128981 130346717\n",
            "output": "57100141\n"
        },
        {
            "input": "235 4532354\n",
            "output": "3151220\n"
        },
        {
            "input": "2093 15811\n",
            "output": "10040\n"
        },
        {
            "input": "11181 29399257\n",
            "output": "29105933\n"
        },
        {
            "input": "4878 18871262\n",
            "output": "17438843\n"
        },
        {
            "input": "245228 130346717\n",
            "output": "106184866\n"
        },
        {
            "input": "235 3157816\n",
            "output": "1967764\n"
        },
        {
            "input": "1106 15811\n",
            "output": "14198\n"
        },
        {
            "input": "20099 29399257\n",
            "output": "26022645\n"
        },
        {
            "input": "2404 18871262\n",
            "output": "13415858\n"
        },
        {
            "input": "195991 130346717\n",
            "output": "15298476\n"
        },
        {
            "input": "32 3157816\n",
            "output": "1709061\n"
        },
        {
            "input": "1106 1040\n",
            "output": "889\n"
        },
        {
            "input": "20099 41021268\n",
            "output": "26504895\n"
        },
        {
            "input": "1503 18871262\n",
            "output": "4814093\n"
        },
        {
            "input": "382631 130346717\n",
            "output": "46984815\n"
        },
        {
            "input": "32 940571\n",
            "output": "266550\n"
        },
        {
            "input": "801 1040\n",
            "output": "484\n"
        },
        {
            "input": "20663 41021268\n",
            "output": "19802861\n"
        },
        {
            "input": "1503 12982854\n",
            "output": "9342457\n"
        },
        {
            "input": "301059 130346717\n",
            "output": "118653078\n"
        },
        {
            "input": "54 940571\n",
            "output": "163916\n"
        },
        {
            "input": "215 1040\n",
            "output": "850\n"
        },
        {
            "input": "20663 51068843\n",
            "output": "25565449\n"
        },
        {
            "input": "1503 1021015\n",
            "output": "998577\n"
        },
        {
            "input": "446269 130346717\n",
            "output": "18572168\n"
        },
        {
            "input": "30 940571\n",
            "output": "294017\n"
        },
        {
            "input": "215 494\n",
            "output": "434\n"
        },
        {
            "input": "20663 4463170\n",
            "output": "324183\n"
        },
        {
            "input": "319 1021015\n",
            "output": "651991\n"
        },
        {
            "input": "446269 19193041\n",
            "output": "13282548\n"
        },
        {
            "input": "37 940571\n",
            "output": "825548\n"
        },
        {
            "input": "215 744\n",
            "output": "306\n"
        },
        {
            "input": "20663 5274903\n",
            "output": "4301723\n"
        },
        {
            "input": "633 1021015\n",
            "output": "464829\n"
        },
        {
            "input": "446269 7585633\n",
            "output": "2270773\n"
        },
        {
            "input": "22 744\n",
            "output": "610\n"
        },
        {
            "input": "28289 5274903\n",
            "output": "890933\n"
        },
        {
            "input": "633 1975331\n",
            "output": "1954828\n"
        }
    ],
    "solution": [
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\nc = [0]*n + [1] + [0]*n\nfor i in range(n-1, 0, -1):\n    c[i] = 2*c[i+1] % m\n    for j in range(2, n//i + 1):\n        c[i] = (c[i] + c[i*j] - c[(i+1)*j]) % m\n\nprint((c[1] - c[2]) % m)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 2e9, mod = 998244353;\nconst long long N = 4e6 + 100, M = 3e5 + 100, T = 101000, maxn = 1e6 + 100;\nlong long n, m, dp[N], qz[N];\nsigned main() {\n  scanf(\"%lld%lld\", &n, &m);\n  dp[1] = 1;\n  long long crt = 0;\n  for (long long i = 1; i <= n; i++) {\n    qz[i] += qz[i - 1];\n    qz[i] %= m;\n    dp[i] += (crt + qz[i]) % m;\n    for (long long j = 2; j * i <= n; j++) {\n      qz[i * j] += dp[i];\n      qz[i * j] %= m;\n      qz[min(i * j + j, n + 1ll)] += (m - dp[i]) % m;\n      qz[min(i * j + j, n + 1ll)] %= m;\n    }\n    crt = (crt + dp[i]) % m;\n  }\n  printf(\"%lld\\n\", dp[n]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class A, class B>\nostream& operator<<(ostream& out, const pair<A, B>& a) {\n  return out << \"(\" << a.first << \", \" << a.second << \")\";\n}\ntemplate <class A>\nostream& operator<<(ostream& out, const vector<A>& a) {\n  out << \"[\";\n  for (auto it = a.begin(); it != a.end(); ++it) {\n    if (it != a.begin()) out << \", \";\n    out << *it;\n  }\n  return out << \"]\";\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int i, j, x, t, y, k, n, m, z;\n  cin >> n >> m;\n  vector<int> dp(n + 1), sum(n + 1), diff(n + 1);\n  sum[0] = diff[0] = 0;\n  diff[1] = 1;\n  diff[2] = -1;\n  for (i = 1; i <= n; i++) {\n    diff[i] = (diff[i] + diff[i - 1]) % m;\n    dp[i] = (sum[i - 1] + diff[i]) % m;\n    for (j = 2; i * j <= n; j++) {\n      diff[i * j] = (diff[i * j] + dp[i]) % m;\n      if ((i + 1) * j <= n)\n        diff[(i + 1) * j] = (diff[(i + 1) * j] - dp[i] + m) % m;\n    }\n    sum[i] = (sum[i - 1] + dp[i]) % m;\n  }\n  cout << dp[n] << \"\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class D1 {\n\tpublic static void main (String[] args) throws IOException {\n\t\tKattio io = new Kattio();\n\t\tint n = io.nextInt();\n\t\tlong m = io.nextLong();\n\n\t\tlong[] dp = new long[n+1];\n\t\tdp[1] = 1;\n\n\t\tfor (int i=2; i<n+1; i++) {\n\t\t\tdp[i] = (dp[i] + 2*dp[i-1] + 1)%m;\n\n\t\t\tif (i==2) {\n\t\t\t\tdp[i]--;\n\t\t\t}\n\n\t\t\tfor (int j = 2; j<=n; j++) {\n\t\t\t\tif (i*j > n) break;\n\t\t\t\tdp[i*j] = (dp[i*j] + dp[i] - dp[i-1])%m;\n\t\t\t}\n\t\t\tif (dp[i] < 0) {\n\t\t\t\tdp[i] += m;\n\t\t\t} \n\t\t}\n\t\tSystem.out.println(dp[n]);\n\t}\n\t/*\n\t1\n2\n5\n12\n25\n55\n111\n231\n466\n947\n1895\n3832\n7665\n15388\n\t*/\n\n\tstatic HashSet<Integer> factor(int n) {\n\t\tHashSet<Integer> ret = new HashSet<Integer>();\n\t\tfor (int i=2; i*i <= n; i++) {\n\t\t\tif (n%i == 0) {\n\t\t\t\tif (n/i == i) ret.add(i);\n\t\t\t\telse {\n\t\t\t\t\tret.add(i);\n\t\t\t\t\tret.add(n/i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (n>1) ret.add(n);\n\t\treturn ret;\n\t}\n\n\tstatic class Kattio extends PrintWriter {\n\t\tprivate BufferedReader r;\n\t\tprivate StringTokenizer st;\n\n\t\t// standard input\n\t\tpublic Kattio() { this(System.in, System.out); }\n\t\tpublic Kattio(InputStream i, OutputStream o) {\n\t\t\tsuper(o);\n\t\t\tr = new BufferedReader(new InputStreamReader(i));\n\t\t}\n\t\t// USACO-style file input\n\t\tpublic Kattio(String problemName) throws IOException {\n\t\t\tsuper(new FileWriter(problemName + \".out\"));\n\t\t\tr = new BufferedReader(new FileReader(problemName + \".in\"));\n\t\t}\n\n\t\t// returns null if no more input\n\t\tpublic String next() {\n\t\t\ttry {\n\t\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\t\tst = new StringTokenizer(r.readLine());\n\t\t\t\treturn st.nextToken();\n\t\t\t} catch (Exception e) { }\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic int nextInt() { return Integer.parseInt(next()); }\n\t\tpublic double nextDouble() { return Double.parseDouble(next()); }\n\t\tpublic long nextLong() { return Long.parseLong(next()); }\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[4000001];\nint pre[4000001];\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  memset(dp, 0, sizeof(dp));\n  memset(pre, 0, sizeof(pre));\n  dp[n] = 1;\n  pre[n] = dp[n];\n  for (int i = n - 1; i >= 1; i--) {\n    dp[i] = pre[i + 1];\n    for (int j = 2; i * j <= n; j++) {\n      int mx = min(i * j + j - 1, n);\n      dp[i] = ((long long)dp[i] + (long long)pre[i * j] -\n               (mx + 1 <= n ? (long long)pre[mx + 1] : 0ll)) %\n              m;\n    }\n    pre[i] = ((long long)pre[i + 1] + (long long)dp[i]) % m;\n  }\n  cout << dp[1] << \"\\n\";\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int T = 1;\n  for (int i = 1; i <= T; i++) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long power(long long x, long long y) {\n  long long res = 1;\n  x = x % 1000000007;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % 1000000007;\n    y = y >> 1;\n    x = (x * x) % 1000000007;\n  }\n  return res % 1000000007;\n}\nlong long inv(long long n) { return power(n, 1000000007 - 2) % 1000000007; }\nlong long n, m, pre, dp1[6000005], dp2[6000005];\nvoid solve() {\n  cin >> n >> m;\n  dp1[1] = 1;\n  long long i, j;\n  pre = 1;\n  for (i = 2; i <= n; i++) {\n    dp2[i]++;\n    long long nxt = 2 * i;\n    if (nxt <= n) dp2[nxt]--;\n  }\n  for (i = 2; i <= n; i++) {\n    dp2[i] += dp2[i - 1];\n    dp2[i] %= m;\n    dp2[i] = (dp2[i] + m) % m;\n    dp1[i] += pre;\n    dp1[i] %= m;\n    dp1[i] += dp2[i];\n    dp1[i] %= m;\n    dp1[i] += m;\n    dp1[i] %= m;\n    for (j = 2; i * j <= n; j++) {\n      dp2[i * j] += dp1[i];\n      long long nxt = (i + 1) * j;\n      if (nxt <= n) dp2[nxt] -= dp1[i];\n    }\n    pre += dp1[i];\n    pre %= m;\n  }\n  cout << dp1[n] << '\\n';\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long t = 1;\n  long long tc = 0;\n  while (t--) {\n    tc++;\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 4e6 + 5;\nint n, m;\nint dp[MAX_N + 1];\nint p, prime[283146 + 5];\nbool is_prime[MAX_N + 1];\nvoid init() {\n  p = 0;\n  fill(is_prime, is_prime + n + 1, true);\n  is_prime[0] = is_prime[1] = false;\n  for (int i = 2; i <= n; i++) {\n    if (is_prime[i]) {\n      prime[p++] = i;\n      for (long long j = (long long)i * i; j <= n; j += i) {\n        is_prime[j] = false;\n      }\n    }\n  }\n}\nvoid dfs(int t, int s, vector<pair<int, int> >& a, vector<int>& f) {\n  if (t >= a.size()) {\n    f.push_back(s);\n    return;\n  }\n  for (int i = 0; i <= a[t].second; i++) {\n    dfs(t + 1, s, a, f);\n    s *= a[t].first;\n  }\n}\nvoid get(int x, vector<int>& f) {\n  vector<pair<int, int> > a;\n  for (int i = 0; i < p && (long long)prime[i] * prime[i] <= x; i++) {\n    if (x % prime[i] == 0) {\n      int ans = 0;\n      while (x % prime[i] == 0) {\n        x /= prime[i];\n        ans++;\n      }\n      a.push_back(pair<int, int>(prime[i], ans));\n    }\n  }\n  if (x != 1) {\n    a.push_back(pair<int, int>(x, 1));\n  }\n  dfs(0, 1, a, f);\n}\nvoid solve() {\n  init();\n  dp[1] = 1;\n  dp[2] = 2;\n  int s = 3, t = 1;\n  for (int i = 3; i <= n; i++) {\n    vector<int> f;\n    get(i, f);\n    for (int ii = 1; ii + 1 < f.size(); ii++) {\n      int x = f[ii];\n      int j = i / x;\n      t = ((t - dp[j - 1] + m) % m + dp[j]) % m;\n    }\n    t = (t + 1) % m;\n    dp[i] = (s + t) % m;\n    s = (s + dp[i]) % m;\n  }\n  cout << dp[n] << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4000006;\nusing ll = long long;\nll f[N];\nint main() {\n  ll n, m;\n  while (cin >> n >> m) {\n    for (int i = 1; i <= n; i++) f[i] = 0;\n    f[1] = 1;\n    ll sum = 0;\n    ll sum2 = 0;\n    for (int i = 2; i <= n; i++) {\n      (f[i] += sum) %= m;\n      (f[i] += sum2) %= m;\n      (f[i] += f[i - 1]) %= m;\n      (sum += f[i - 1]) %= m;\n      (f[i] += 1) %= m;\n      sum2 = (f[i] - sum);\n      while (sum2 < 0) sum2 += m;\n      sum2 %= m;\n      if (f[i] < 0) {\n        printf(\"%d %lld %lld\\n\", i, f[i - 1], sum2);\n        cout << sum2 << endl;\n        break;\n      }\n      for (int j = 2; j * i <= n; j++) {\n        (f[j * i] += ((f[i] - f[i - 1] + m) % m)) %= m;\n      }\n    }\n    cout << f[n] << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom array import array\n\ninput = sys.stdin.readline\n\n\ndef ri(): return [int(i) for i in input().split()]\n\n\ndef rs(): return input().split()[0]\n\n\ndef main():\n    t = 1\n\n    for _ in range(t):\n        n, m = ri()\n        sum = [0] * (n + 2)  # ans[x] + ... + ans[n]\n        sum[n] = 1\n        sum[n + 1] = 0\n\n        last = -1\n        for x in range(n - 1, 0, -1):\n            extra = sum[x + 1]  # jump by subtraction\n\n            # jump by division\n            for d in range(2, n // x + 1):\n                from_ = x * d\n                to_ = min(x * d + d - 1, n)\n                extra = (extra + sum[from_] - sum[to_ + 1]) % m\n\n            last = extra\n            sum[x] = (sum[x + 1] + last) % m\n        # print(ans)\n        print(last % m)\n\n\nmain()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = (1ll << 62) - 1;\nlong long mod = 1e9 + 7;\nconst long long N = 1e5 + 100;\nconst long double pi = 3.14159265358979323846;\nconst long double eps = 1e-7;\nlong long dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nlong long dy[] = {0, 1, 0, -1, -1, 1, 1, -1};\nchar dir[] = {'U', 'R', 'D', 'L'};\nlong long bPow(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) {\n      res = (res * a) % mod;\n    }\n    b >>= 1;\n    a = (a * a) % mod;\n  }\n  return res % mod;\n}\nlong long gcd(long long a, long long b) {\n  if (a < b) swap(a, b);\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nvector<long long> fact(N, 0ll);\nvoid factorial() {\n  fact[0] = 1, fact[1] = 1;\n  for (long long i = 2; i < N; i++) {\n    fact[i] = (fact[i - 1] * i) % mod;\n  }\n}\nlong long ncr(long long n, long long r) {\n  if (r > n) return 0;\n  long long ans = fact[n] % mod;\n  ans *= bPow(fact[r], mod - 2) % mod;\n  ans %= mod;\n  ans *= bPow(fact[n - r], mod - 2) % mod;\n  ans %= mod;\n  return ans;\n}\nvector<long long> primes(N, -1);\nvoid sieve() {\n  iota(primes.begin(), primes.end(), 0);\n  for (long long i = 2; i < N; ++i) {\n    if (primes[i] == i) {\n      for (long long j = i * 2; j < N; j += i) {\n        primes[j] = i;\n      }\n    }\n  }\n}\nlong long add(long long a, long long b) {\n  a %= mod, b %= mod;\n  return ((a + b) % mod + mod) % mod;\n}\nlong long mul(long long a, long long b) {\n  a %= mod, b %= mod;\n  return ((a * b) % mod + mod) % mod;\n}\nlong long sub(long long a, long long b) {\n  a %= mod, b %= mod;\n  return ((a - b + 2 * mod) % mod + mod) % mod;\n}\nvoid solve() {\n  long long n;\n  cin >> n >> mod;\n  vector<long long> dp(n + 1, 0), pref(n + 2, 0);\n  long long prev = 0;\n  for (long long i = 1; i <= n; ++i) {\n    pref[i] = add(pref[i], pref[i - 1]);\n    dp[i] = add(dp[i], pref[i] + prev);\n    if (i == 1) {\n      dp[i] = add(dp[i], 1);\n    }\n    long long j = 2;\n    while (i * j <= n) {\n      long long x = i * j, y = min(n + 1, (i + 1) * j);\n      pref[x] = add(pref[x], dp[i]);\n      pref[y] = sub(pref[y], dp[i]);\n      j++;\n    }\n    prev = add(prev, dp[i]);\n  }\n  cout << dp[n] << \"\\n\";\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  long long tc = 1, test = 1;\n  while (tc--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nimport os\nfrom io import BytesIO\n\n# pypy2\nif sys.version_info[0] < 3:\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n\nf = sys.stdin\n\nline = lambda: f.readline().strip('\\r\\n').split()\n\nn, m = map(int, line())\ndp = [0] * (n + 1)\ndp[1] = 1\ndp[2] = 2\nfor i in range(2, n+1):\n    if i != 2:\n        dp[i] = (dp[i] + dp[i-1])%m\n        dp[i] = (dp[i] + 1 + dp[i-1]) % m\n    j = 2 * i\n    while j <= n:\n        dp[j] = (dp[j] - dp[i-1] + dp[i]) % m\n        j += i\nprint(dp[-1]%m)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T>\nusing vt = vector<T>;\ntemplate <class T>\nusing vvt = vt<vt<T>>;\ntemplate <class T, class U>\nusing pr = pair<T, U>;\ntemplate <class T, class U>\nusing vpr = vt<pr<T, U>>;\nmt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\nstruct custom_hash {\n  static uint64_t split_mix_64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t r =\n        std::chrono::steady_clock::now().time_since_epoch().count();\n    return split_mix_64(x + r);\n  }\n};\ntemplate <class T>\nbool mxx(T& a, const T& b) {\n  return a < b ? a = b, true : false;\n}\ntemplate <class T>\nbool mnn(T& a, const T& b) {\n  return a > b ? a = b, true : false;\n}\ntemplate <class T>\nT f_div(const T& a, const T& b) {\n  return a / b - ((a ^ b) < 0 && a % b);\n}\ntemplate <class T>\nT c_div(const T& a, const T& b) {\n  return a / b + ((a ^ b) > 0 && a % b);\n}\ntemplate <class T>\nostream& operator<<(ostream& out, const vt<T>& v) {\n  for (auto& c : v) out << c << ' ';\n  return out << '\\n';\n}\nostream& operator<<(ostream& out, const vvt<char>& v) {\n  for (auto& r : v) {\n    for (auto& c : r) out << c;\n    out << '\\n';\n  }\n  return out << \"\";\n}\ntemplate <class T>\nostream& operator<<(ostream& out, const vvt<T>& v) {\n  for (auto& r : v) out << r;\n  return out << \"\";\n}\ntemplate <class T, class U>\nostream& operator<<(ostream& out, const pr<T, U>& p) {\n  return out << p.first << ' ' << p.second;\n}\ntemplate <class T, class U>\nostream& operator<<(ostream& out, const vpr<T, U>& v) {\n  for (auto& p : v) out << p;\n  return out << \"\";\n}\ntemplate <class T>\nistream& operator>>(istream& in, vt<T>& v) {\n  for (int i = 0; i < (int)(v).size() - 1; ++i) in >> v[i];\n  return in >> v.back();\n}\ntemplate <class T, class U>\nistream& operator>>(istream& in, pr<T, U>& p) {\n  return in >> p.first >> p.second;\n}\ntemplate <class T, class U>\nistream& operator>>(istream& in, vpr<T, U>& v) {\n  for (int i = 0; i < (int)(v).size() - 1; ++i) in >> v[i];\n  return in >> v.back();\n}\nconst int MOD0 = 1e9 + 7, MOD1 = 998244353;\nconst int MAX0 = 2e5 + 5, MAX1 = 1e7 + 5;\nconst ll MAX2 = (ll)1e18 + 5;\nconst int DI[] = {-1, +1, 0, 0, -1, +1, -1, +1};\nconst int DJ[] = {0, 0, +1, -1, +1, -1, -1, +1};\nvoid dbg(const string& s = \"../test\", bool usaco = false) {\n  freopen((s + \".in\" + (usaco ? \"\" : \".txt\")).c_str(), \"r\", stdin);\n  freopen((s + \".out\" + (usaco ? \"\" : \".txt\")).c_str(), \"w\", stdout);\n}\nvoid solve(int test) {\n  ll n, m;\n  cin >> n >> m;\n  vt<ll> dp(n + 1, 0);\n  dp[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    (dp[i] += (2 * dp[i - 1] + (i > 2))) %= m;\n    for (int j = 2 * i; j <= n; j += i) (dp[j] += dp[i] - dp[i - 1] + m) %= m;\n  }\n  cout << dp[n] << '\\n';\n}\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int cases = 1;\n  for (int test = 1; test <= cases; ++test) solve(test);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e6 + 100;\nint n, m;\nint dp[maxn];\nint dif[maxn];\nvoid solve() {\n  cin >> n >> m;\n  dif[1] = 1;\n  dif[2] = -1;\n  int now = 0;\n  for (int i = 1; i <= n; i++) {\n    now = (now + dif[i]) % m;\n    dp[i] = now;\n    ;\n    if (i + 1 <= n) dif[i + 1] = (dif[i + 1] + now) % m;\n    for (int j = 2 * i; j <= n; j += i) {\n      int l = j;\n      int r = j + j / i;\n      ;\n      if (l <= n) dif[l] = (dif[l] + dp[i]) % m;\n      if (r <= n) dif[r] = (dif[r] - dp[i] + m) % m;\n    }\n  }\n  cout << dp[n] << '\\n';\n}\nint main() { solve(); }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string &s) { return '\"' + s + '\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long lcm(long long x, long long y) { return x / gcd(x, y) * y; }\nlong long INF = 1e18 + 13;\nlong double eps = 1e-12;\nlong double PI = 3.14159265;\nconst long long MAXN = 4 * 1e6 + 13;\nconst long long MAXH = 100;\nconst long long MAXM = 1e5 + 13;\nlong long MOD;\nlong long dp[MAXN];\nlong long pref[2 * MAXN + 2];\nvoid solve() {\n  long long n;\n  cin >> n >> MOD;\n  dp[n] = 1;\n  pref[n] = 1;\n  long long summ = 1;\n  for (long long i = n - 1; i >= 1; i--) {\n    dp[i] += summ;\n    dp[i] = dp[i] % MOD;\n    for (long long j = 2; j * i <= n; j++) {\n      dp[i] += (pref[i * j] - pref[i * j + j]);\n      dp[i] = dp[i] % MOD;\n    }\n    summ += dp[i];\n    summ = summ % MOD;\n    pref[i] = pref[i + 1] + dp[i];\n    pref[i] = pref[i] % MOD;\n  }\n  cout << dp[1];\n}\nint32_t main() {\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"-Ofast\", \"-funroll-all-loops\")\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst long long INF = 0x3f3f3f3f;\nconst double PI = acos(-1);\nconst long long N = 4e6 + 10;\nlong long f[N], s[N];\nvoid problem_solver() {\n  long long x, mod;\n  cin >> x >> mod;\n  f[1] = 1;\n  f[2] = 2;\n  long long pre = 0;\n  for (long long i = 1; i <= x; i++) {\n    s[i] = (s[i] + s[i - 1]) % mod;\n    if (i > 2) {\n      f[i] = (pre + s[i]) % mod;\n    }\n    for (long long j = 2; j * i <= x; j++) {\n      long long l = j * i;\n      long long r = j * (i + 1);\n      if (r < N) s[r] = (s[r] - f[i] + mod) % mod;\n      s[l] = (s[l] + f[i]) % mod;\n    }\n    pre = (pre + f[i]) % mod;\n  }\n  cout << f[x] << endl;\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long T = 1;\n  while (T--) problem_solver();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class CF1561D2 extends PrintWriter {\n\tCF1561D2() { super(System.out, true); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1561D2 o = new CF1561D2(); o.main(); o.flush();\n\t}\n\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint md = sc.nextInt();\n\t\tint[] dp = new int[n + 1]; dp[1] = 1;\n\t\tint[] dd = new int[n + 1];\n\t\tfor (int d = 0, p = 0, x = 1; x <= n; x++) {\n\t\t\td = (d + dd[x]) % md;\n\t\t\tint s = x == 1 ? 1 : (d + p) % md;\n\t\t\tdp[x] = s;\n\t\t\tfor (int z = 2; x * z <= n; z++) {\n\t\t\t\tint x1 = x * z, x0 = (x + 1) * z;\n\t\t\t\tdd[x1] = (dd[x1] + s) % md;\n\t\t\t\tif (x0 <= n)\n\t\t\t\t\tdd[x0] = (dd[x0] - s) % md;\n\t\t\t}\n\t\t\tp = (p + s) % md;\n\t\t}\n\t\tint ans = dp[n];\n\t\tif (ans < 0)\n\t\t\tans += md;\n\t\tprintln(ans);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class _1561_D {\n    static long MOD;\n    public static void main(String[] args) throws IOException {\n        Reader in = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = in.nextInt();\n        MOD = in.nextInt();\n        long[] p = new long[n + 1];\n        p[n] = 1;\n        for(int i = n - 1; i >= 1; i--) {\n            long cur = 0;\n            int cap = n / i;\n            for(int j = 2; j <= cap; j++) {\n                int start = j * i;\n                int end = Math.min(n, start + j - 1);\n                cur = modadd(cur, sum(p, start, end));\n            }\n            cur = modadd(cur, sum(p, i + 1, n));\n            p[i] = modadd(p[i + 1], cur);\n        }\n        out.println(sum(p, 1, 1));\n        in.close();\n        out.close();\n    }\n    static long sum(long[] p, int l, int r) {\n        if(r == p.length - 1) {\n            return p[l];\n        }\n        return modadd(p[l], -p[r + 1]);\n    }\n    static long modadd(long a, long b) {\n        return (a + b + MOD) % MOD;\n    }\n    static long modmult(long a, long b) {\n        return a * b % MOD;\n    }\n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt != 0) {\n                        break;\n                    } else {\n                        continue;\n                    }\n                }\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) {\n                buffer[0] = -1;\n            }\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) {\n                fillBuffer();\n            }\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) {\n                return;\n            }\n            din.close();\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid test() {\n  while (1) {\n    getchar();\n    for (int x = 2; x <= 30; x++) {\n      for (int i = 2; i <= x; i++) printf(\"%3d\", x / i);\n      printf(\"\\n\");\n    }\n  }\n}\nconst int N = 4e6 + 5;\nint n, m, pre;\nint f[N], g[N];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  f[1] = 1;\n  pre = 1;\n  for (int i = 2; i <= n; i++) {\n    g[i] += 1;\n    g[min(n + 1, i + i)] -= 1;\n  }\n  for (int i = 2; i <= n; i++) {\n    g[i] = (g[i] + g[i - 1]) % m;\n    f[i] = (pre + g[i]) % m;\n    int line = 1;\n    while (1) {\n      if (1ll * (i - 1) * (line + 1) + line + 1 > n) break;\n      g[i * (line + 1)] = (g[i * (line + 1)] + f[i]) % m;\n      if (1ll * (i + 1) * (line + 1) <= n)\n        g[(i + 1) * (line + 1)] =\n            (1ll * g[(i + 1) * (line + 1)] - f[i] + m) % m;\n      line++;\n    }\n    pre = (pre + f[i]) % m;\n  }\n  printf(\"%d\\n\", f[n]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 4e6 + 10;\nlong long mod, n;\nlong long f[maxn], g[maxn];\nint main() {\n  scanf(\"%lld\", &n), scanf(\"%lld\", &mod);\n  f[1] = 1;\n  long long sum = 0;\n  for (long long i = 2; i <= n; ++i) {\n    g[i] += g[i - 1] + 1;\n    sum += f[i - 1];\n    f[i] = sum + g[i];\n    f[i] %= mod;\n    for (long long j = 2; j * i <= n; ++j) {\n      g[i * j] += f[i] - f[i - 1];\n      g[i * j] = (g[i * j] + mod) % mod;\n    }\n  }\n  printf(\"%lld\\n\", f[n] % mod);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main\n{\n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n    //static final long mod=(long)1e9+7;\n    /*static final long mod=998244353L;\n    public static long pow(long a,long p)\n    {\n        long res=1;\n        while(p>0)\n        {\n            if(p%2==1)\n            {\n                p--;\n                res*=a;\n                res%=mod;\n            }\n            else\n            {\n                a*=a;\n                a%=mod;\n                p/=2;\n            }\n        }\n        return res;\n    }*/\n    /*static class Pair\n    {\n        int u,v;\n        Pair(int u,int v)\n        {\n            this.u=u;\n            this.v=v;\n        }\n    }*/\n    /*static class Pair implements Comparable<Pair>\n    {\n        int v,l;\n        Pair(int v,int l)\n        {\n            this.v=v;\n            this.l=l;\n        }\n        public int compareTo(Pair p)\n        {\n            return l-p.l; \n        }\n    }*/\n    /*static long gcd(long a,long b)\n    {\n        if(b%a==0)\n        return a;\n        return gcd(b%a,a);\n    }\n    public static void dfs(int u,ArrayList<Integer> edge[],boolean vis[])\n    {\n        vis[u]=true;\n        for(int v:edge[u])\n        {\n            if(!vis[v])\n            dfs(v,edge,vis);\n        }\n    }\n    static class DSU\n    {\n        int par[],rank[],n;\n        DSU(int n)\n        {\n            this.n=n;\n            par=new int[n+1];\n            rank=new int[n+1];\n            for(int i=1;i<=n;i++)\n            par[i]=i;\n        }\n        public void union(int u,int v)\n        {\n            u=find(u);\n            v=find(v);\n            if(u==v)\n            return;\n            if(rank[u]>rank[v])\n            par[v]=u;\n            else if(rank[u]<rank[v])\n            par[u]=v;\n            else\n            {\n                rank[v]++;\n                par[u]=v;\n            }\n        }\n        public int find(int u)\n        {\n            if(u==par[u])\n            return u;\n            return par[u]=find(par[u]);\n        }\n    }\n    static class Edge \n    {\n        int v,ind;\n        long w;\n        Edge(int v,int w,int ind)\n        {\n            this.ind=ind;\n            this.v=v;\n            this.w=1L*w;\n        }\n    }\n    static class Pair implements Comparable<Pair>\n    {\n        int u,v;\n        Pair(int u,int v)\n        {\n            this.u=u;\n            this.v=v;\n        }\n        public int compareTo(Pair p)\n        {\n            if(this.u!=p.u)\n            return this.u-p.u;\n            return p.v-this.v;\n        }\n    }*/\n    public static void main(String args[])throws Exception\n    {\n        FastReader fs=new FastReader();\n        PrintWriter pw=new PrintWriter(System.out);\n        int n=fs.nextInt();\n        long m=fs.nextLong();\n        long a[]=new long[n+1];\n        long suff[]=new long[n+2];\n        suff[n]=1;\n        a[n]=1;\n        for(int i=n-1;i>0;i--)\n        {\n            long ans=suff[i+1];\n            for(int j=2;j*i<=n;j++)\n            {\n                int l=j*i,r=Math.min((i+1)*j,n+1);\n                ans+=(suff[l]-suff[r]+m)%m;\n                ans%=m;\n            }\n            a[i]=ans;\n            suff[i]+=a[i];\n            suff[i]%=m;\n            suff[i]+=suff[i+1];\n            suff[i]%=m;\n        }\n        pw.println(a[1]);\n        pw.flush();\n        pw.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long md(long long m, long long v) { return ((v % m) + m) % m; }\nvoid solve() {\n  long long n, mod;\n  cin >> n >> mod;\n  vector<long long> psum(n + 2);\n  psum[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    long long tmp = psum[i + 1];\n    for (long long j = 2; j * i <= n; j++) {\n      long long l = i * j, r = min((i + 1) * j - 1, n);\n      tmp = md(mod, tmp + psum[l] - psum[r + 1]);\n    }\n    psum[i] = md(mod, tmp + psum[i + 1]);\n  }\n  cout << md(mod, psum[1] - psum[2]);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble log(double x, double base) { return log(x) / log(base); }\nstring operator*(const string& a, int b) {\n  string res = \"\";\n  for (int i = 1; i <= b; i++) res += a;\n  return res;\n}\nconst long double eps = 1e-7;\nconst long long N = 5e6;\nlong long n, mod;\nlong long dp[N], prefx[N];\nlong long sieve[N];\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> mod;\n  dp[1] = 1;\n  prefx[1] = 1;\n  for (long long i = 1, j = 2; j <= n; j++) {\n    sieve[i * j] += dp[1];\n    if ((i + 1) * j <= n) sieve[(i + 1) * j] -= dp[1];\n  }\n  for (long long i = 2; i <= n; i++) {\n    sieve[i] = (sieve[i] + sieve[i - 1] % mod) % mod;\n    dp[i] = (prefx[i - 1] + sieve[i]) % mod;\n    prefx[i] = (prefx[i - 1] + dp[i]) % mod;\n    for (long long j = 2; i * j <= n; j++) {\n      sieve[i * j] = (sieve[i * j] + dp[i] % mod + mod * mod) % mod;\n      if ((i + 1 * j) <= n) sieve[(i + 1) * j] -= dp[i];\n    }\n  }\n  cout << (dp[n] + mod * mod) % mod << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx2\")\nusing namespace std;\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<long long> dp(n + 1);\n  dp[n] = 1;\n  long long sum = 0;\n  vector<long long> s(n + 2);\n  for (int i = n; i >= 1; i--) {\n    for (long long div = 2; div * i <= n; div++) {\n      long long mn = i * div;\n      long long mx = min(1LL * n, (i + 1) * div - 1);\n      dp[i] = (dp[i] + s[mn] - s[mx + 1] + m) % m;\n    }\n    dp[i] = (dp[i] + sum + m) % m;\n    sum = (sum + dp[i] + m) % m;\n    s[i] = (dp[i] + s[i + 1] + m) % m;\n  }\n  cout << dp[1] << '\\n';\n}\nsigned main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin.exceptions(cin.failbit);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e6 + 5;\nint dp[maxn];\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n, mod;\n  cin >> n >> mod;\n  dp[1] = 1;\n  int now = 0;\n  for (int i = 2; i <= n; ++i) {\n    now = dp[i] = (1LL * dp[i] + now + dp[i - 1] + 1) % mod;\n    for (int j = 2 * i; j <= n; j += i) {\n      dp[j] = (1LL * dp[j] + dp[i] - dp[i - 1]) % mod;\n    }\n  }\n  cout << (dp[n] % mod + mod) % mod;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, dp[4444444];\nint main() {\n  cin >> n >> m;\n  dp[2] = 2;\n  dp[1] = 1;\n  for (long long i = 3; i <= n; i++) {\n    dp[i] = (dp[i] + 2 * dp[i - 1] + 1) % m;\n    if (i % 2 == 0) dp[i] = (dp[i] + 1) % m;\n    for (long long j = i + i; j <= n; j += i) {\n      dp[j] = (dp[j] + dp[i] - dp[i - 1] + m) % m;\n    }\n  }\n  cout << dp[n];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[4000001];\nint s[8000001];\nint main() {\n  int n, m, i, j;\n  cin >> n >> m;\n  dp[n] = 1;\n  s[n] = 1;\n  for (i = n - 1; i >= 1; i--) {\n    dp[i] = s[i + 1];\n    for (j = 2; i * j <= n; j++)\n      dp[i] = (1ll * dp[i] + s[i * j] - s[(i + 1) * j] + m) % m;\n    s[i] = (s[i + 1] + dp[i]) % m;\n  }\n  cout << dp[1];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <const int32_t MOD>\nstruct modint {\n  int32_t value;\n  modint() = default;\n  modint(int32_t value_) : value(value_) {}\n  inline modint<MOD> operator+(modint<MOD> other) const {\n    int32_t c = this->value + other.value;\n    return modint<MOD>(c >= MOD ? c - MOD : c);\n  }\n  inline modint<MOD> operator-(modint<MOD> other) const {\n    int32_t c = this->value - other.value;\n    return modint<MOD>(c < 0 ? c + MOD : c);\n  }\n  inline modint<MOD> operator*(modint<MOD> other) const {\n    int32_t c = (int64_t)this->value * other.value % MOD;\n    return modint<MOD>(c < 0 ? c + MOD : c);\n  }\n  inline modint<MOD> &operator+=(modint<MOD> other) {\n    this->value += other.value;\n    if (this->value >= MOD) this->value -= MOD;\n    return *this;\n  }\n  inline modint<MOD> &operator-=(modint<MOD> other) {\n    this->value -= other.value;\n    if (this->value < 0) this->value += MOD;\n    return *this;\n  }\n  inline modint<MOD> &operator*=(modint<MOD> other) {\n    this->value = (int64_t)this->value * other.value % MOD;\n    if (this->value < 0) this->value += MOD;\n    return *this;\n  }\n  inline modint<MOD> operator-() const {\n    return modint<MOD>(this->value ? MOD - this->value : 0);\n  }\n  modint<MOD> pow(uint64_t k) const {\n    modint<MOD> x = *this, y = 1;\n    for (; k; k >>= 1) {\n      if (k & 1) y *= x;\n      x *= x;\n    }\n    return y;\n  }\n  modint<MOD> inv() const { return pow(MOD - 2); }\n  inline modint<MOD> operator/(modint<MOD> other) const {\n    return *this * other.inv();\n  }\n  inline modint<MOD> operator/=(modint<MOD> other) {\n    return *this *= other.inv();\n  }\n  inline bool operator==(modint<MOD> other) const {\n    return value == other.value;\n  }\n  inline bool operator!=(modint<MOD> other) const {\n    return value != other.value;\n  }\n  inline bool operator<(modint<MOD> other) const { return value < other.value; }\n  inline bool operator>(modint<MOD> other) const { return value > other.value; }\n};\ntemplate <int32_t MOD>\nmodint<MOD> operator*(int64_t value, modint<MOD> n) {\n  return modint<MOD>(value) * n;\n}\ntemplate <int32_t MOD>\nmodint<MOD> operator*(int32_t value, modint<MOD> n) {\n  return modint<MOD>(value % MOD) * n;\n}\ntemplate <int32_t MOD>\nistream &operator>>(istream &in, modint<MOD> &n) {\n  return in >> n.value;\n}\ntemplate <int32_t MOD>\nostream &operator<<(ostream &out, modint<MOD> n) {\n  return out << n.value;\n}\nusing namespace std;\nconst int maxn = 1e7 + 100;\nlong long n, m, f[maxn];\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  f[1] = 1;\n  for (long long i = 1; i <= n; i++) {\n    f[i] = (f[i] + f[i - 1]) % m;\n    f[i + 1] = (f[i + 1] + f[i]) % m;\n    for (long long j = 2; i * j <= n; j++) {\n      f[i * j] = (f[i * j] + f[i]) % m;\n      f[i * j + j] = (f[i * j + j] - f[i]) % m;\n    }\n    f[1] = 0;\n  }\n  cout << (f[n] + m) % m << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Sol{\n \n/*   \n->check n=1, int overflow , array bounds , all possibilites(dont stuck on 1 approach)\n->Problem = Observation(constraints(m<=n/3 or k<=min(100,n)) \n           + Thinking + Technique (seg_tree,binary lift,rmq,bipart,dp,connected comp etc)\n->solve or leave it (- tutorial improves you in minimal way -)\n*/\n \npublic static void main (String []args) {\n//precomp();\n \nint times=1;while(times-->0){solve();}out.close();}\n\n//dp[n]= (dp[1]+dp[2] .. dp[n-1] )+dp[n/2]+dp[n/3]+dp[n/4]+.. dp[n/n];\n//dp[n]= ( p[n-1] ) + ( q[n-1]+dp[n/r]-dp[(n-1)/r] n%r==0) O(nsqrt(n))\n\nstatic int sieve[];\n\nstatic void solve(){\n  int n=ni();mod=ni();\n  long dp[]=new long[n+5];\n  dp[1]=1;dp[2]=2;for(int i=4;i<=n;i+=2){dp[i]++;}\n  for(int i=3;i<=n;i++){\n     dp[i]+=dp[i-1];dp[i]+=dp[i-1];dp[i]+=1;dp[i]%=mod;\n     for(int j=2*i;j<=n;j+=i){\n         dp[j]+=dp[i]-dp[i-1]+mod;dp[j]%=mod;\n     }\n  }\n  out.println(dp[n]);\n}\n\n//-----------------Utility--------------------------------------------\n\nstatic long gcd(long a,long b){if(b==0)return a; return gcd(b,a%b);}\n \nstatic int Max=Integer.MAX_VALUE; static long mod=1000000007;\n \n//static int v(char c){return (int)(c-'a');}\n \npublic static long power(long x, long y )\n    {\n        //0^0 = 1\n        long res = 1L;\n        x = x%mod;\n        while(y > 0)\n        {\n            if((y&1)==1)\n                res = (res*x)%mod;\n            y >>= 1;\n            x = (x*x)%mod;\n        }\n        return res;\n    }\n \nstatic class Pair implements Comparable<Pair>{\n        int id;int value;Pair next;\n        public Pair(int id,int value) {\n         \n          this.id=id;this.value=value;next=null;\n        }\n        @Override\n        public int compareTo(Pair p){return Long.compare(value,p.value);}\n    }\n\n \n//----------------------I/O---------------------------------------------\n \nstatic InputStream inputStream = System.in;\nstatic OutputStream outputStream = System.out;\nstatic FastReader in=new FastReader(inputStream);\nstatic PrintWriter out=new PrintWriter(outputStream);\n \nstatic class FastReader \n{ \n  BufferedReader br; \n  StringTokenizer st; \n \n        FastReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n \n  public String next() \n  { \n      while (st == null || !st.hasMoreElements()) \n      { \n          try\n          { \n              st = new StringTokenizer(br.readLine()); \n          } \n          catch (IOException  e) \n          { \n              e.printStackTrace(); \n          } \n      } \n      return st.nextToken(); \n  } \n \n  public int nextInt() \n  { \n      return Integer.parseInt(next()); \n  } \n \n  public long nextLong() \n  { \n      return Long.parseLong(next()); \n  } \n \n public  double nextDouble() \n  { \n      return Double.parseDouble(next()); \n  } \n \n \n  String nextLine() \n  { \n      String str = \"\"; \n      try\n      { \n          str = br.readLine(); \n      } \n      catch (IOException e) \n      { \n          e.printStackTrace(); \n      } \n      return str; \n  } \n}\n//Only for Integer Input\n/*static int ni() {\n        try {\n            boolean in = false;\n            int res = 0;\n            for (;;) {\n                int b = System.in.read() - '0';\n                if (b >= 0) {\n                    in = true;\n                    res = 10 * res + b;\n                }\n                else if (in)\n                    return res;\n            }\n        } catch (IOException e) {\n            throw new Error(e);\n        }\n    }*/\nstatic int ni(){return in.nextInt();}\nstatic long nl(){return in.nextLong();}\nstatic double nd(){return in.nextDouble();}\nstatic String ns(){return in.nextLine();}\n}"
        },
        {
            "language": 1,
            "solution": "import sys\nimport os\nfrom io import BytesIO\n\n# pypy2\nif sys.version_info[0] < 3:\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n\nf = sys.stdin\n\nline = lambda: f.readline().strip('\\r\\n').split()\n\ndef write(w):\n    sys.stdout.write(w)\n    sys.stdout.write(\"\\n\")\n\ndef solve():\n    \n    dp = [1] * (N+1)\n    dp[2] = 0\n    \n    for i in range(2,N+1):\n        dp[i] = (dp[i] + (2 * dp[i-1]) % M) % M\n        \n        d = dp[i] - dp[i-1]\n        for j in range(2,N//i+1):\n            dp[i*j] = (dp[i*j] + d) % M\n    \n    return str(dp[N])\n\nT = 1\nfor test in range(1,T+1):\n    N,M = map(int, line())\n    \n    write(solve())\n    \nf.close()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[4000005], g[4000005], f[4000005];\nsigned main() {\n  long long n, mod;\n  scanf(\"%lld %lld\", &n, &mod);\n  dp[1] = 1;\n  g[1] = 1;\n  for (long long i = 2; i <= n; i++) {\n    f[i] += f[i - 1] + 1;\n    dp[i] = (dp[i] + g[i - 1] + f[i]) % mod;\n    for (long long j = 2 * i; j <= n; j += i)\n      f[j] = (f[j] + dp[i] - dp[i - 1]) % mod;\n    g[i] = g[i - 1] + dp[i];\n  }\n  printf(\"%lld\", (dp[n] + mod) % mod);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[4000010], b[4000010], c[4000010], mod;\nint main() {\n  int x;\n  scanf(\"%d%d\", &x, &mod);\n  a[1] = 1;\n  b[1] = 1, c[1] = 0;\n  for (int i = 2; i <= x; i++) {\n    a[i] = (a[i] + b[i - 1]);\n    if (a[i] >= mod) a[i] -= mod;\n    for (int j = 1; i * j <= x; j++) {\n      if (j >= i) {\n        break;\n      } else {\n        c[i * j] += a[j];\n        if (c[i * j] >= mod) c[i * j] -= mod;\n        if (i * (j + 1) <= x) {\n          c[i * (j + 1)] -= a[j];\n          if (c[i * (j + 1)] < 0) c[i * (j + 1)] += mod;\n        }\n      }\n    }\n    c[i] += c[i - 1];\n    if (c[i] < 0) c[i] += mod;\n    if (c[i] >= mod) c[i] -= mod;\n    a[i] = (a[i] + c[i]);\n    if (a[i] >= mod) a[i] -= mod;\n    b[i] = (b[i - 1] + a[i]);\n    if (b[i] >= mod) b[i] -= mod;\n    for (int j = 1; j <= i && i * j <= x; j++) {\n      c[j * i] += a[i];\n      if (c[j * i] >= mod) c[j * i] -= mod;\n      if ((i + 1) * j <= x) {\n        c[(i + 1) * j] -= a[i];\n        if (c[(i + 1) * j] < 0) c[(i + 1) * j] += mod;\n      }\n    }\n  }\n  printf(\"%d\\n\", a[x]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e6 + 7;\nlong long n, mod;\nlong long f[N], sum[N], tim[N];\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> mod;\n  f[1] = 1;\n  sum[1] = 1;\n  for (register int i = 2; i <= n; ++i) {\n    tim[i] += (tim[i - 1] + 1) % mod;\n    f[i] = (f[i] + sum[i - 1] + tim[i]) % mod;\n    for (register int j = i + i; j <= n; j += i) {\n      tim[j] = (tim[j] + f[i]) % mod;\n      tim[j] = (tim[j] - f[i - 1] + mod) % mod;\n    }\n    sum[i] = (sum[i - 1] + f[i]) % mod;\n  }\n  cout << f[n] % mod;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 4e6 + 10;\nint N, P, arr[MAXN], diff[MAXN];\ninline void add(int& a, int b) { a = a + b >= P ? a + b - P : a + b; }\ninline void sub(int& a, int b) { a = a - b < 0 ? a - b + P : a - b; }\nint main() {\n  scanf(\"%d %d\", &N, &P);\n  arr[1] = 1;\n  int sum = 1;\n  for (int j = 2; j <= N; ++j) {\n    add(diff[j], 1);\n    sub(diff[min(j + j, MAXN)], 1);\n  }\n  for (int i = (2), iend = (N + 1); i < iend; ++i) {\n    add(diff[i], diff[i - 1]);\n    add(arr[i], sum);\n    int tmp = arr[i];\n    add(tmp, diff[i]);\n    for (int j = 2; i * j <= N; ++j) {\n      add(diff[i * j], tmp);\n      sub(diff[min(MAXN, j * i + j)], tmp);\n    }\n    add(sum, tmp);\n  }\n  int ans = arr[N];\n  add(ans, diff[N]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int a = 0;\n  int f = 0;\n  char p = getchar();\n  while (!isdigit(p)) {\n    f |= p == '-';\n    p = getchar();\n  }\n  while (isdigit(p)) {\n    a = (a << 3) + (a << 1) + (p ^ 48);\n    p = getchar();\n  }\n  return f ? -a : a;\n}\nconst int INF = 998244353;\nint T, n, m;\nint f[10000050];\nint sum[10000050];\nint main() {\n  n = read();\n  m = read();\n  f[n] = sum[n] = 1;\n  for (int i = n - 1; i >= 1; --i) {\n    f[i] = sum[i + 1];\n    for (int j = 2; i * j <= n; j++) {\n      int l = i * j;\n      int r = min(n, (i + 1) * j - 1);\n      int tmp = (sum[l] + m - sum[r + 1]) % m;\n      f[i] = (f[i] + tmp) % m;\n    }\n    sum[i] = (sum[i + 1] + f[i]) % m;\n  }\n  printf(\"%d\", f[1]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod;\nlong long add(long long x, long long y) {\n  return x + y - (x + y >= mod ? mod : 0);\n}\nvoid addTo(long long &x, long long y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  if (x < 0) x += mod;\n}\nlong long mul(long long x, long long y) { return (x * y) % mod; }\nsigned main() {\n  long long n;\n  cin >> n >> mod;\n  vector<long long> dp(n + 1), df(n + 1);\n  long long all = 0, sum = 0, prv = 1;\n  for (long long i{1}; i <= n; ++i) {\n    addTo(sum, df[i]);\n    dp[i] = add(prv, sum);\n    addTo(all, dp[i]);\n    prv = all;\n    for (long long j{2}; i * j <= n; ++j) {\n      addTo(df[i * j], dp[i]);\n      if ((i + 1) * j <= n) addTo(df[(i + 1) * j], -dp[i]);\n    };\n  }\n  cout << dp[n] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e6 + 10;\nvoid add(int &a, long long b);\nint n, mod, dp[N], sum[N];\nint main() {\n  scanf(\"%d%d\", &n, &mod);\n  sum[n] = dp[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    sum[i] = dp[i] = sum[i + 1];\n    for (int j = i + i, t = 2; j <= n; j += i, t++)\n      add(dp[i], sum[j] - sum[j + t < n + 1 ? j + t : n + 1]);\n    add(sum[i], dp[i]);\n  }\n  cout << dp[1] << endl;\n  return 0;\n}\nvoid add(int &a, long long b) {\n  a = ((a + b) % mod + mod) % mod;\n  return;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 4e6 + 5;\nlong long f[N];\nlong long sum[N];\nlong long num;\nlong long n, MOD;\nlong long re() {\n  char c = getchar();\n  long long all = 0, pd = 1;\n  for (; c > '9' || c < '0'; c = getchar())\n    if (c == '-') pd = -1;\n  while (c >= '0' && c <= '9') all = all * 10 + c - '0', c = getchar();\n  return all * pd;\n}\nlong long work(long long x) {\n  if (f[x]) return f[x];\n  if (x == n) return f[x] = 1;\n  for (long long i = 2; i <= n && i * x <= n; i++) {\n    int t = x * i + i;\n    if (x * i + i > n) t = n + 1;\n    f[x] = (f[x] + sum[i * x] - sum[t] + MOD) % MOD;\n  }\n  f[x] = (f[x] + sum[x + 1]) % MOD;\n  return f[x];\n}\nint main() {\n  n = re(), MOD = re();\n  for (long long i = n; i >= 1; i--) {\n    work(i);\n    sum[i] = (f[i] + sum[i + 1]) % MOD;\n  }\n  cout << (f[1] % MOD + MOD) % MOD;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\n\npublic class Main {\n    public static MyScanner sc = new MyScanner(System.in);\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static void main(String[] args) {\n        int n = sc.nextint();\n        int mod = sc.nextint();\n        int[] dp1 = new int[n + 9];\n        int[] dp2 = new int[n + 9];\n        dp2[1] = 1;\n        for(int i = 1; i <= n; i++){\n            dp1[i] += dp1[i - 1];\n            dp1[i] %= mod;\n            dp2[i] = dp1[i];\n            if(i == 1){\n                dp2[i] = 1;\n            }\n            dp1[i + 1] += dp2[i];\n            dp1[i + 1] %= mod;\n            for(int j = 2; i * j <= n; j++){\n                dp1[i * j] += dp2[i];\n                dp1[i * j] %= mod;\n                if((i + 1) * j <= n) {\n                    dp1[(i + 1) * j] += mod - dp2[i];\n                    dp1[(i + 1) * j] %= mod;\n                }\n            }\n        }\n        out.print(dp2[n]);\n        out.close();\n    }\n}\nclass MyScanner {\n    private BufferedReader br;\n    private StringTokenizer tokenizer;\n\n    public MyScanner(InputStream is) {\n        br = new BufferedReader(new InputStreamReader(is));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextint() {\n        return Integer.parseInt(next());\n    }\n    public long nextlong() {\n        return Long.parseLong(next());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long pow2(long long i) { return 1LL << i; }\nlong long topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\nlong long topbit(long long t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\nlong long lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }\nlong long lowbit(long long a) { return a == 0 ? 64 : __builtin_ctzll(a); }\nlong long allbit(long long n) { return (1LL << n) - 1; }\nlong long popcount(signed t) { return __builtin_popcount(t); }\nlong long popcount(long long t) { return __builtin_popcountll(t); }\nbool ispow2(long long i) { return i && (i & -i) == i; }\ntemplate <class T>\nT POW(T x, long long n) {\n  T res = 1;\n  for (; n; n >>= 1, x *= x)\n    if (n & 1) res *= x;\n  return res;\n}\ninline long long max(long long x, long long y) { return (x < y) ? y : x; }\ninline long long min(long long x, long long y) { return (x < y) ? x : y; }\ninline long long read() {\n  register long long a = 0, po = 1;\n  char ch = getchar();\n  while (!isdigit(ch) && ch != '-') ch = getchar();\n  if (ch == '-') po = -1, ch = getchar();\n  while (isdigit(ch)) a = (a << 1) + (a << 3) + ch - 48, ch = getchar();\n  return a * po;\n}\nvoid write(long long x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n  return;\n}\nlong long gcd(long long x, long long y) {\n  while (x % y) {\n    long long temp = x % y;\n    x = y, y = temp;\n  }\n  return y;\n}\nlong long mgml(long long a, long long b, long long mod) {\n  long long temp = 1;\n  while (b) {\n    if (b % 2) {\n      temp = temp * a % mod;\n    }\n    a = a * a % mod;\n    b /= 2;\n  }\n  return temp;\n}\nlong long exgcd(long long a, long long b, long long &x, long long &y) {\n  long long ret, tmp;\n  if (!b) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  ret = exgcd(b, a % b, x, y);\n  tmp = x;\n  x = y;\n  y = tmp - a / b * y;\n  return ret;\n}\nlong long lcm(long long x, long long y) { return (x * y) / gcd(x, y); }\nlong long fac[100009], inv[100009], MXNC = 100005;\nlong long mod = 1000000007;\nvoid init() {\n  inv[0] = inv[1] = fac[0] = 1;\n  for (long long i = 2; i <= MXNC; i++)\n    inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n  for (long long i = 2; i <= MXNC; i++)\n    inv[i] = 1ll * inv[i - 1] * inv[i] % mod;\n  for (long long i = 1; i < MXNC; i++) fac[i] = fac[i - 1] * i % mod;\n}\nlong long C(long long n, long long m) {\n  return 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\nlong long fenkuai(long long n) {\n  long long ans = 0;\n  for (long long l = 1, r; l <= n; l = r + 1) {\n    r = n / (n / l);\n    ans += (r - l + 1) * (n / l);\n  }\n  return ans;\n}\nlong long fl[1200010];\nvector<long long> prime;\nvoid gep() {\n  memset(fl, false, sizeof(fl));\n  fl[1] = true;\n  for (long long i = 2; i <= 1200000; i++) {\n    long long t = 1200000 / i;\n    for (long long j = 2; j <= t; j++) fl[i * j] = true;\n  }\n  for (long long i = 2; i <= 1200000; i++)\n    if (!fl[i]) prime.push_back(i);\n}\nlong long dp[4000010], sum[4000010], cr = 0;\nsigned main() {\n  long long n = read(), m = read();\n  dp[n] = 1;\n  sum[n] = 1;\n  for (long long i = n; i >= 1; i--) {\n    long long cnt = 2;\n    while (cnt * i <= n) {\n      long long nowt = cnt * i, tt = min(n, cnt * i + cnt - 1);\n      dp[i] = (dp[i] + (sum[nowt] - sum[tt + 1] + m)) % m;\n      cnt++;\n    }\n    dp[i] = (dp[i] + sum[i + 1]) % m;\n    sum[i] = (sum[i + 1] + dp[i]) % m;\n  }\n  cout << dp[1] << \"\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "//package codeforces.cfr740div2;\n\nimport java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class D2 {\n    private static class Reader implements Closeable {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public Reader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public void readLine() {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public String next() {\n            if (st == null || !st.hasMoreTokens()) {\n                readLine();\n            }\n            return st.nextToken();\n        }\n\n        public <T> T next(Function<String, T> parser) {\n            return parser.apply(next());\n        }\n\n        public int nextInt() {\n            return next(Integer::valueOf);\n        }\n\n        public long nextLong() {\n            return next(Long::valueOf);\n        }\n\n        public double nexDouble() {\n            return next(Double::valueOf);\n        }\n\n        @Override\n        public void close() throws IOException {\n            br.close();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        try (Reader in = new Reader(System.in);\n             PrintStream out = new PrintStream(new BufferedOutputStream(System.out))) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] sum = new int[n + 2];\n            sum[n] = 1;\n            for (int x = n - 1; x >= 1; x--) {\n                int fx = sum[x + 1];\n                for (int y = 2; y * x <= n; y++) {\n                    int fy = (m + sum[y * x] - sum[Math.min(n + 1, y * (x + 1))]) % m;\n                    fx = (fx + fy) % m;\n                }\n                sum[x] = (sum[x + 1] + fx) % m;\n            }\n            out.println((m + sum[1] - sum[2]) % m);\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint Read() {\n  int val = 0, opt = 1;\n  char ch;\n  while (!isdigit(ch = getchar()))\n    if (ch == '-') opt = -1;\n  while (isdigit(ch)) (val *= 10) += ch - '0', ch = getchar();\n  return val * opt;\n}\nlong long n, m, f[4000100], sq[4000100];\nvoid work() {\n  n = Read(), m = Read();\n  f[n] = sq[n] = 1;\n  for (int i = n - 1; i; i--) {\n    f[i] = sq[i + 1];\n    for (int j = 2; j * 1ll * i <= n; j++)\n      if (j * 1ll * (i + 1) <= n)\n        f[i] += sq[i * j] - sq[j * (i + 1)];\n      else\n        f[i] += sq[i * j];\n    f[i] %= m;\n    sq[i] = (sq[i + 1] + f[i]) % m;\n  }\n  printf(\"%lld\\n\", f[1]);\n}\nint main(void) {\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4000010;\nconst long long mod = 998244353;\nconst double pi = 3.1415926535897932;\nint n;\nlong long m;\nlong long dp[N], sum[N];\nint main() {\n  cin >> n >> m;\n  dp[n] = 1, sum[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    dp[i] = sum[i + 1];\n    for (int j = 2; i * j <= n; j++) {\n      int r = min(n, i * j + j - 1);\n      dp[i] = dp[i] + sum[i * j] - sum[r + 1];\n      dp[i] += m;\n      dp[i] %= m;\n    }\n    sum[i] = dp[i] + sum[i + 1];\n    sum[i] %= m;\n  }\n  cout << dp[1] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e6 + 10;\nint n, p;\nint inc(int a, int b) {\n  a += b;\n  return a >= p ? a - p : a;\n}\nint dec(int a, int b) {\n  a -= b;\n  return a < 0 ? a + p : a;\n}\nint mul(int a, int b) { return 1ll * a * b % p; }\nint f[maxn], c[maxn];\nvoid add(int l, int r, int x) {\n  if (r > n) r = n + 1;\n  c[l] = inc(c[l], x);\n  c[r + 1] = dec(c[r + 1], x);\n}\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  f[1] = 1;\n  int cur = 0;\n  for (int i = 1; i <= n; ++i) {\n    cur = inc(cur, c[i]);\n    f[i] = inc(f[i], cur);\n    f[i] = inc(f[i], f[i - 1]);\n    for (int j = 2; 1ll * j * i <= n; ++j) {\n      add(i * j, i * j + j - 1, f[i]);\n    }\n    f[i] = inc(f[i], f[i - 1]);\n  }\n  printf(\"%d\\n\", dec(f[n], f[n - 1]));\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "// package com.company;\n\n\n\nimport com.sun.source.tree.Tree;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n     static TreeMap<Integer,Integer> mp = new TreeMap<>();\n     static int fac[] = new int[200000];\n    public static int totalSum(int n) {\n\n        // Stores total sum\n        int result = 0;\n        int i = 1;\n\n        // Finding numbers and\n        //its occurence\n        while(true) {\n\n            // Sum of product of each\n            // number and its occurence\n           // result += rangeSum(n / i, n / (i + 1)) *\n         //           (i % mod) % mod;\n            mp.put(i,n/i - n/(i+1));\n\n            //result %= mod;\n\n            if (i == n)\n                break;\n\n            i = n / (n / (i + 1));\n        }\n        return result;\n    }\n\n\n\n    public static void main(String[] args) throws Exception {\n        long start=System.currentTimeMillis();\n        FastScanner fs=new FastScanner();\n        int T=1; // T=fs.nextInt();\n        while(T--!=0) {\n            int n=fs.nextInt(),m=fs.nextInt();\n            int dp[] = new int[n+1];\n            int pdp [] = new int[n+2];\n            dp[n] = 1;\n            pdp[n]=1;\n            int sum_till_now=1;\n            for(int i=n-1;i>=1;i--){\n                dp[i] = (dp[i] + sum_till_now)%m;\n                // do stuff for j = 1\n                for(int j=2;i*j<=n;j++){\n                    int extra_add = pdp[i*j] - pdp[Math.min(n+1,i*j + j)];\n                    if(extra_add < 0) extra_add =(int) ((long)extra_add+(long)m)%m;\n//                    if(i*j + 1 <=n ) extra_add = pdp[i*j] - pdp[i*j + Math.min(i,j)];    //dp[i*j +1];\n                    dp[i] =(int) ((long)dp[i]  + (long)extra_add) % m;\n                }\n              //  dp[i]  = (dp[i] + pdp[i+1] - pdp[Math.min(2*i,n)]);\n               // System.out.println(i + \" \"+ sum_till_now);\n                sum_till_now =(int) ((long)sum_till_now + (long)dp[i])%m;\n                pdp[i] = sum_till_now;\n\n            }\n           // for(int i=1;i<=n;i++) System.out.print(dp[i]+ \" \");\n           // System.out.println();\n            System.out.println((dp[1])%m);\n\n//            int mx = 1000000009;\n//            short count[] = new short[mx];\n//            for(int i=0;i<mx;i++){\n//                count[i]=2;\n//            }\n//\n//            for(int i=2;i<mx;i++){\n//              //  if(count[i]==2) {\n//                    for (int j = 2; i * j < mx; j++){\n//                       count[i*j]++;\n//                    }\n//               // }\n//            }\n//           // for(int i=0;i<100;i++) System.out.println(Integer.toString(i)+\" \"+Integer.toString(count[i]));\n//            int freq[] = new int[100000];\n//            for(int i=0;i<100000;i++) freq[i]=0;\n//            for(var v : count) freq[v]++;\n//\n//            for(int i=0;i<100000;i++) System.out.println(Integer.toString(i)+\",\");\n//            mp.clear();\n//            int n=fs.nextInt(),m=fs.nextInt();\n//            totalSum(n);\n//            long ans=0;\n//            long mod = 1000000007;\n//            for(var v : mp.keySet()){\n//                ans += v * mp.get(v) * binexp(v,)\n//            }\n\n        }\n//         long end=(System.currentTimeMillis()-start);\n//         System.err.println(\"Time taken is \"+end+\" ms\");\n    }\n\n    void factorial(int k,int md)\n    {\n\n        fac[0] = 1;\n        for (int i = 1; i <= k + 1; i++) {\n            fac[i] = (i * fac[i - 1])%md;\n        }\n    }\n\n// Function to return the binomial coefficient\n    static long bin(int a, int b,int md)\n    {\n\n        // nCr = (n! * (n - r)!) / r!\n        long num = fac[a];\n        long den = (fac[a-b] * fac[b]) %md;\n\n       // long  ans =\n       //     ((fac[a]) / (fac[a - b] * fac[b]));\n        long ans = num * binexp(den,md-2,md);\n        return ans;\n    }\n\n// Function to return the sum of kth powers of\n// n natural numbers\n    static long sumofn(int n, int k,int md)\n    {\n        int p = 0;\n        long  num1, temp, arr[] = new long[2000];\n        for (int j = 1; j <= k; j++) {\n\n            // When j is unity\n            if (j == 1) {\n                num1 = ((n * (n + 1)) / 2)%md;\n\n                // Calculating sum(n^1) of unity powers\n                // of n; storing sum(n^1) for sum(n^2)\n                arr[p++] = num1;\n\n                // If k = 1 then temp is the result\n                temp = num1;\n            }\n            else {\n                temp = (binexp(n + 1, j + 1,md) - 1 - n);//(pow(n + 1, j + 1) - 1 - n);\n                if(temp<0){\n                    temp=temp+md;\n                    temp%=md;\n                }\n                // For finding sum(n^k) removing 1 and\n                // n * kCk from (n + 1)^k\n                for (int s = 1; s < j; s++) {\n\n                    // Removing all kC2 * sum(n^(k - 2))\n                    // + ... + kCk - 1 * (sum(n^(k - (k - 1))\n                    temp = temp -\n                            (arr[j - s - 1] * bin(j + 1, s + 1,md));\n                    if(temp<0){\n                        temp=temp+md;\n                        temp%=md;\n                    }\n                }\n                temp = temp / (j + 1);\n\n                // Storing the result for next sum of\n                // next powers of k\n                arr[p++] = temp;\n            }\n        }\n        temp = arr[p - 1];\n        return temp;\n    }\n\n\n    public static long binexp(long a, long b,long md){\n        if(b==0) return 1;\n        if(b==1) return a%md;\n        long xx=binexp(a,b/2,md);\n        if(b%2==0){\n            return (xx%md * xx%md)%md;\n        }\n        else {\n            return (xx%md * xx%md * a)%md;\n        }\n    }\n\n\n    public static int gcd(int a,int b) {\n        if (b == 0) return a;\n        if (a == 0) return b;\n        if (a > b) return gcd(b, a);\n        return gcd(a, b % a);\n\n    }\n\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    static void sort(int[] a) {\n        ArrayList<Integer> l=new ArrayList<>();\n        for (int i:a) l.add(i);\n        Collections.sort(l);\n        for (int i=0; i<a.length; i++) a[i]=l.get(i);\n    }\n\n\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        double nextDouble() { return Double.parseDouble(next()); }\n\n        int[] readArray(int n) {\n            int[] a=new int[n];\n            for (int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n    static class pair<t1 extends Comparable<t1>, t2 extends Comparable<t2> > implements Comparable<pair<t1,t2>>{\n        public t1 ff;\n        public t2 ss;\n        pair(){}\n        pair(t1 first,t2 second){\n            this.ff=first;\n            this.ss=second;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if(obj==null) return false;\n            else if(obj.getClass()!=this.getClass()) return false;\n            pair<?,?> pp = (pair<?,?>) obj;\n            return pp.ff.equals(this.ff) && pp.ss.equals(this.ss);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(ff,ss);\n            //return 31 * ff.hashCode() + ss.hashCode();\n        }\n\n        @Override\n        public int compareTo(pair<t1,t2> pp) {\n            pair<?,?> p = (pair<?,?>) pp;\n            var res = this.ff.compareTo(pp.ff);\n            if(res==0) res=this.ss.compareTo(pp.ss);\n\n            return res;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "\ndef naiveSolve():\n    \n    \n    \n    return\n\n\n\ndef solve():\n    \n    \n    \n    return\n\n\n\ndef main():\n    \n    n,MOD=readIntArr()\n    \n    def addAcrossRange(l,r,val):\n        diffArr[l]+=val\n        diffArr[l]%=MOD\n        diffArr[r+1]-=val\n        diffArr[r+1]=(diffArr[r+1]+MOD)%MOD\n    def getVal(i):\n        return diffArr[i]-diffArr[i-1]\n    \n    diffArr=[0]*(n+5)\n    arr=[0]*(n+5)\n    diffArr[1]=1\n    diffArr[2]=-1\n    arr[1]=1\n    currVal=0\n    prefixSum=0\n    \n    \n    # nlogn solution\n    \n    for i in range(1,n+1):\n        currVal+=diffArr[i]\n        currVal%=MOD\n        \n        arr[i]=currVal\n        prefixSum+=arr[i]\n        prefixSum%=MOD\n        addAcrossRange(i+1,i+1,prefixSum) # for the subtraction (y) cases\n\n        \n        # arr[i] contributes to arr[i*z] to arr[i*z+z-1] for all z>=1. avoid adding for i==i.\n        z=1 # for the floor divide (z) cases\n        while True:\n            left=i*z\n            if z==1:\n                left+=1\n            right=i*z+z-1\n            right=min(right,n)\n            if left>n:\n                break\n            addAcrossRange(left,right,arr[i])\n\n            z+=1\n        \n    \n    ans=arr[n]\n    print(ans)\n    \n    \n    return\n\n\n\nimport sys\n# input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\ninput=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(x):\n    print('{}'.format(x))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n \ninf=float('inf')\n# MOD=10**9+7\nMOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, m;\n  cin >> n >> m;\n  vector<long long> dp(n + 1, 0), diff(n + 1, 0);\n  dp[1] = 1;\n  long long sum = 0;\n  for (long long i = 1; i <= n; i++) {\n    diff[i] = (diff[i] + diff[i - 1]) % m;\n    dp[i] = (dp[i] + sum) % m;\n    dp[i] = (dp[i] + diff[i]) % m;\n    for (long long j = i * 2; j <= n; j += i) {\n      diff[j] = (diff[j] + dp[i]) % m;\n      diff[j] = (diff[j] - dp[i - 1]) % m;\n      if (diff[j] < 0) diff[j] += m;\n    }\n    sum = (sum + dp[i]) % m;\n  }\n  cout << dp[n] % m;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, mod = map(int, input().split())\ndp = [0]*(n+1)\ndp[-1] = 1\nfor i in range(n-1, 0, -1):\n    dp[i] = (dp[i+1] + dp[i+1]) % mod\n    for j in range(2, n//i+1):\n        dp[i] = (dp[i] + dp[i*j] - (dp[i*j+j] if i*j+j <= n else 0)) % mod\nprint((dp[1]-dp[2]) % mod)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e6 + 10;\nlong long f[N];\nlong long c[N], n, mod;\nint main() {\n  cin >> n >> mod;\n  f[n] = 1;\n  for (int i = n; i >= 1; i--) {\n    f[i] = f[i] + c[i + 1] - c[n + 1];\n    for (int j = i + 1, l, r; j <= n; j = r + 1) {\n      l = j, r = (j / i + 1) * i - 1;\n      r = min(1ll * r, n);\n      f[i] = (f[i] + 1ll * j / i * (c[l] - c[r + 1]) % mod);\n    }\n    for (int j = i + 1, l, r; j <= n; j = r + 1) {\n      l = j, r = (j / (i + 1) + 1) * (i + 1) - 1;\n      r = min(1ll * r, n);\n      f[i] = (f[i] - 1ll * j / (i + 1) * (c[l] - c[r + 1]) % mod);\n    }\n    f[i] %= mod;\n    c[i] = (c[i + 1] + f[i]);\n  }\n  cout << (f[1] + mod) % mod << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "N, MOD = map(int, input().split())\nDP = [0] * N\nDP[0] = 1\nCum = [0] * (N + 1)\nCum[1] = 1\nfor i1 in range(1, N):\n    i2 = N - i1\n    Value = Cum[i1]\n    for j in range(2, N + 1):\n        if i2 * j > N: break\n        Value += Cum[N - i2 * j + 1] - Cum[max(0, N - i2 * j - j + 1)]\n        Value %= MOD\n    Cum[i1 + 1] += Cum[i1] + Value\n    Cum[i1 + 1] %= MOD\n    DP[i1] = Value\nprint(DP[-1])"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int nn = 4e6 + 5;\nint n, m, f[nn], sum, suff[nn];\nint add(int a, int b) { return a + b >= m ? a + b - m : a + b; }\nint sub(int a, int b) { return a < b ? a - b + m : a - b; }\nint mul(int a, int b) { return 1ll * a * b % m; }\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  f[n] = 1;\n  for (int i = n; i >= 1; i--) {\n    f[i] = add(f[i], sum);\n    for (int j = 2; i * j <= n; j++) {\n      int l = i * j, r = (i + 1) * j - 1;\n      if (r > n) r = n;\n      f[i] = add(f[i], sub(suff[l], suff[r + 1]));\n    }\n    sum = add(sum, f[i]);\n    suff[i] = add(suff[i + 1], f[i]);\n  }\n  printf(\"%d\", f[1]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f[4000006], mus[4000006];\nint n, m;\nint main() {\n  cin >> n >> m;\n  f[n] = mus[n] = 1;\n  for (int i = n - 1; i >= 1; --i) {\n    f[i] = mus[i + 1];\n    for (int k = 2; i * k <= n; ++k)\n      f[i] =\n          (f[i] + ((mus[i * k] - mus[min(i * k + k - 1, n) + 1]) % m + m) % m) %\n          m;\n    mus[i] = (mus[i + 1] + f[i]) % m;\n  }\n  cout << f[1];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 4000010;\nlong long f[MAXN], sum[MAXN], MOD;\nint main() {\n  int n;\n  scanf(\"%d %lld\", &n, &MOD);\n  f[n] = 1;\n  sum[n] = 1;\n  for (int i = n - 1; i; --i) {\n    f[i] = (f[i] + sum[i + 1]) % MOD;\n    for (int j = 2; j * i <= n; ++j) {\n      int l = j * i, r = min(n, i * j + j - 1);\n      f[i] += sum[l] - sum[r + 1];\n      f[i] = (f[i] % MOD + MOD) % MOD;\n    }\n    sum[i] = (sum[i + 1] + f[i]) % MOD;\n  }\n  printf(\"%lld\\n\", f[1]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconst int MAX = 4e6 + 5;\nconst long long MOD = 1000000007;\nconst long long MOD2 = 2010405347;\nconst long long INF = 2e18;\nconst int dr[] = {1, 0, -1, 0, 1, 1, -1, -1, 0};\nconst int dc[] = {0, 1, 0, -1, 1, -1, 1, -1, 0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 315;\ninline long long pw(long long x, long long y, long long md = MOD) {\n  long long ret = 1;\n  x %= md;\n  while (y) {\n    if (y & 1) ret = ret * x % md;\n    x = x * x % md, y >>= 1;\n  }\n  return ret;\n}\ninline void add(int &a, int b, int md = MOD) {\n  a = a + b >= md ? a + b - md : a + b;\n}\nlong long n, md, sm, nw, z;\nint x[MAX], y[MAX], cnt, tmp, bg[MAX], k;\nvector<pair<int, int> > v;\nbitset<MAX> p;\nvoid gen(int nw, int o) {\n  if (nw == v.size()) {\n    if (o != 1) z += x[y[o] + 1] - x[y[o]], ++y[o];\n    return;\n  }\n  gen(nw + 1, o);\n  for (int i = (1); i <= (v[nw].second); ++i) {\n    o *= v[nw].first;\n    gen(nw + 1, o);\n  }\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  for (int i = (2); i < (MAX); ++i)\n    if (!p[i]) {\n      for (int j = i; j < MAX; j += i) {\n        p[j] = 1;\n        bg[j] = i;\n      }\n    }\n  cin >> n >> md;\n  x[1] = sm = 1;\n  for (int i = (2); i <= (n); ++i) {\n    tmp = i;\n    v.clear();\n    while (tmp != 1) {\n      cnt = 0, k = bg[tmp];\n      while (tmp % k == 0) tmp /= k, ++cnt;\n      v.push_back({k, cnt});\n    }\n    gen(0, 1);\n    z %= md;\n    x[i] = (sm + z) % md;\n    sm = (sm + x[i]) % md;\n  }\n  cout << (x[n] % md + md) % md << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 2e9;\nFILE* stream;\nmt19937 rng(1337);\nlong long n, m;\nvoid solve() {\n  vector<long long> dp(n + 1, 0);\n  dp[1] = 1;\n  dp[2] = 2;\n  for (long long j = 2; j * 2 <= n; j++) {\n    dp[j * 2] += dp[2] - dp[2 - 1];\n    dp[j * 2] %= m;\n  }\n  for (long long i = 3; i <= n; i++) {\n    dp[i] += dp[i - 1] * 2 + 1;\n    dp[i] %= m;\n    for (long long j = 2; j * i <= n; j++) {\n      dp[j * i] += dp[i] - dp[i - 1];\n      dp[j * i] %= m;\n    }\n  }\n  cout << (dp[n] + m) % m << endl;\n  return;\n}\nvoid solve1() {\n  vector<long long> dp(n + 1);\n  dp[n] = 1;\n  long long all = 0;\n  for (long long i = n; i >= 1; i--) {\n    dp[i] += all;\n    dp[i] %= m;\n    all += dp[i];\n    all %= m;\n    long long j = 1;\n    while (j * j < i) {\n      dp[j] += (i / j - i / (j + 1)) * dp[i];\n      dp[j] %= m;\n      if (j != 1 && i / j != j) dp[i / j] += dp[i];\n      dp[i / j] %= m;\n      j++;\n    }\n    if (j != 1 && j * j == i) {\n      dp[j] += dp[i];\n      dp[j] %= m;\n    }\n  }\n  cout << dp[1] << endl;\n  return;\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\ntemplate <typename T>\nvoid readArray(vector<T> &A) {\n  for (T &i : A) cin >> i;\n}\ntemplate <typename T>\nvoid printArray(vector<T> A) {\n  for (T i : A) cout << i << \" \";\n}\nlong long fastPow(long long a, long long b, long long m = mod) {\n  a %= m;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a % m;\n    a = a * a % m;\n    b >>= 1;\n  }\n  return res;\n}\nbool isPrime(long long n, int iter = 5) {\n  if (n < 4) return n == 2 || n == 3;\n  for (int i = 0; i < iter; i++) {\n    int a = 2 + rand() % (n - 3);\n    if (fastPow(a, n - 1, n) != 1) return false;\n  }\n  return true;\n}\nlong long inv(long long n, long long m) { return fastPow(n, m - 2); }\nint n, m;\nvector<int> d, g, second;\nvoid solve() {\n  cin >> n >> m;\n  d = g = second = vector<int>(n + 2, 0);\n  d[n] = g[n] = 1;\n  for (int i = n - 1; i > 0; i--) {\n    d[i] = g[i + 1];\n    for (int j = 2; j * i <= n; j++) {\n      second[i] = (g[i * j] - g[min(i * j + j, n + 1)] + m) % m;\n      d[i] = (d[i] + second[i]) % m;\n    }\n    g[i] = (d[i] + g[i + 1]) % m;\n  }\n  cout << d[1];\n}\nvoid trials() {\n  int t;\n  for (cin >> t; t--; cout << endl) {\n    solve();\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  solve();\n}\n"
        },
        {
            "language": 3,
            "solution": "# template begins\n#####################################\nfrom io import BytesIO, IOBase\nimport sys\nimport math\nimport os\nimport heapq\nfrom collections import defaultdict, deque\nfrom math import ceil\nfrom bisect import bisect_left, bisect_left\nfrom time import perf_counter\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\ndef mint(): return map(int, input().split())\ndef mfloat(): return map(float, input().split())\ndef intin(): return int(input())\n\n\n#####################################\n# template ends\n# Use the recursion snippet if heavy recursion is needed (depth>1000)\n# If constraints are tight, use 1d arrays instead of 2d, like g[i*m+j] instead of g[i][j]\ndef solve():\n    n, mod = map(int, input().split())\n    dp = [0]*(n+1)\n    dp[-1] = 1\n    # brute force\n    # for i in range(n, 1, -1):\n    #     for j in range(1, i):\n    #         dp[j] = (dp[j] + dp[i]) % mod\n    #     for j in range(2, i+1):\n    #         dp[i//j] = (dp[i] + dp[i//j]) % mod\n    # print(dp[1])\n    \"\"\"\n    2^(n-2) ways by addition alone? yes\n    \"\"\"\n    # for i in range(n-1, 0, -1):\n    #     by_addition = pow(2, n-i-1, mod)\n    # print(\"power =\", pow(2, n-2, mod))\n    current = 1\n    suffix_sum = [0]*(n+1)\n    suffix_sum[-1] = 1\n    for i in range(n-1, 0, -1):\n        dp[i] = suffix_sum[i+1]\n        # for j in range(2*i, n+1, i):\n        #     dp[i] = (dp[i] + suffix_sum[j] -\n        #              (suffix_sum[j+j] if j+j < n else 0))  # % mod\n        #     break\n        for j in range(2, n+1):\n            if i*j > n:\n                break\n            dp[i] += suffix_sum[i*j] - (suffix_sum[i*j+j] if i*j+j <= n else 0)\n            dp[i] %= mod\n        suffix_sum[i] = (suffix_sum[i+1] + dp[i]) % mod\n    # print(dp)\n    # print(suffix_sum)\n    print(dp[1] % mod)\n\n\ndef main():\n    t = 1\n    # t = int(input())\n    for _ in range(t):\n        solve()\n\n\nif __name__ == \"__main__\":\n    start_time = perf_counter()\n    main()\n    print(perf_counter()-start_time, file=sys.stderr)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e6 + 5;\nlong long int n, m, dp[N], suf[N];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> m;\n  dp[n] = 1;\n  suf[n] = 1;\n  for (long long int i = n - 1; i >= 1; i--) {\n    dp[i] += suf[i + 1];\n    dp[i] %= 1000000007;\n    for (long long int j = 2; j * i <= n; j++) {\n      long long int r = j * i, l = min(j * (i + 1), n + 1);\n      dp[i] += (suf[r] - suf[l]);\n      dp[i] %= m;\n    }\n    suf[i] += dp[i] + suf[i + 1];\n    suf[i] %= m;\n  }\n  cout << dp[1] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\nlong long bin_pow(long long a, long long n) {\n  if (n == 0) return 1;\n  if (n & 1) return a * bin_pow(a, n - 1);\n  long long b = bin_pow(a, n / 2);\n  return b * b;\n}\nvector<long long> ans, suf;\nlong long mod;\nint n;\nvoid solve() {\n  cin >> n >> mod;\n  ans.resize(n);\n  suf.resize(n + 1);\n  suf[n] = 0;\n  ans[n - 1] = 1;\n  for (int i = n; i >= 1; i--) {\n    ans[i - 1] += suf[i];\n    int d = 1;\n    for (int j = i + i; j <= n; j += i) {\n      ans[i - 1] += (suf[j - 1] + mod - suf[min(n, j + d)]) % mod;\n      ans[i - 1] %= mod;\n      d++;\n    }\n    suf[i - 1] = (ans[i - 1] + suf[i]) % mod;\n  }\n  cout << ans[0];\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization(\"unroll-loops, no-stack-protector\")\n#pragma GCC target(\"avx,avx2,fma\")\nusing namespace std;\nmt19937_64 rnd;\nconst long long maxn = 4e6 + 10;\nconst long long mod = 998244353;\nconst long long base = 1e15;\nconst long double eps = 1e-7;\nlong long p[maxn];\nlong long dp[maxn];\nlong long len = 0;\nlong long t[20];\nlong long sl[20];\nvector<long long> vt;\nlong long nw = 1;\nvoid dosth(long long id) {\n  if (id == len + 1) {\n    vt.push_back(nw);\n    return;\n  }\n  long long pre = 1;\n  for (int i = 0; i <= sl[id]; i++) {\n    nw = nw * pre;\n    dosth(id + 1);\n    nw = nw / pre;\n    pre = pre * t[id];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  if (fopen(\"t.inp\", \"r\")) {\n    freopen(\"test.inp\", \"r\", stdin);\n    freopen(\"test.out\", \"w\", stdout);\n  }\n  for (int i = 2; i < maxn; i++) {\n    if (p[i]) continue;\n    for (int j = i; j < maxn; j += i) {\n      p[j] = i;\n    }\n  }\n  long long n, m;\n  cin >> n >> m;\n  long long nw = 0;\n  dp[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    nw = (nw + dp[i - 1]) % m;\n    vt.clear();\n    len = 0;\n    long long h = i;\n    while (h != 1) {\n      len++;\n      t[len] = p[h];\n      sl[len] = 0;\n      while (h % t[len] == 0) h /= t[len], sl[len]++;\n    }\n    dosth(1);\n    for (auto to : vt) {\n      if (to == 1 || to == i) continue;\n      nw = (nw - dp[(i - 1) / to] + dp[i / to] + m) % m;\n    }\n    nw = (nw + 1) % m;\n    dp[i] = nw;\n  }\n  cout << dp[n] << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e6 + 10;\nlong long n, m;\nlong long dp[N];\nlong long s[N];\nlong long sum(int l, int r) { return (s[l] - s[r + 1] + m) % m; }\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  dp[n] = 1;\n  s[n] = 1;\n  for (int i = n - 1; i; i--) {\n    dp[i] = s[i + 1];\n    for (int j = 2; j <= n / i; j++) {\n      int l = i * j, r = min(n, (long long)j * (i + 1) - 1);\n      dp[i] = dp[i] + sum(l, r);\n      dp[i] %= m;\n    }\n    s[i] = s[i + 1] + dp[i];\n    s[i] %= m;\n  }\n  printf(\"%lld\", (dp[1] + m) % m);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long i, j, p, q, n, m, k, dp[4000006], sum, g, dpp[4000006];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> m;\n  dp[1] = 1;\n  sum = 1;\n  for (i = 2; i <= n; i++) dpp[i] += 1;\n  dp[2] = 2;\n  dpp[2] = 1;\n  for (i = 4; i <= n; i += 2) dpp[i]++;\n  sum = 3;\n  for (i = 3; i <= n; i++) {\n    while (dpp[i] < 0) dpp[i] += m;\n    dp[i] = sum;\n    dp[i] %= m;\n    dpp[i] += dpp[i - 1];\n    dpp[i] %= m;\n    dp[i] = dpp[i] + dp[i];\n    dp[i] %= m;\n    for (j = i * 2; j <= n; j += i) {\n      dpp[j] += dp[i] - dp[i - 1];\n      dpp[j] %= m;\n    }\n    sum += dp[i];\n    sum %= m;\n  }\n  cout << dp[n] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 9223372036854775807LL;\nconst long long SMALL_INF = 2147483647;\nconst long long NSIZE = 2 * 1e+5 + 1000;\nconst long long MOD = 998244353;\nconst long double EPS = 1e-12;\nconst long long MAX = 1e+6 + 1000;\nconst long double PI = atan(1) * 4;\nint divup(int a, int b) { return a / b + a % b > 0; }\nint main() {\n  ios_base::sync_with_stdio(false);\n  long long n, mod;\n  cin >> n >> mod;\n  vector<long long> dp(n + 2);\n  vector<long long> suf(n + 2);\n  suf[n] = 1;\n  for (long long i = n - 1; i >= 1; i--) {\n    dp[i] = suf[i + 1];\n    for (long long j = 2; j * i <= n; j++) {\n      dp[i] += (mod + (suf[i * j] - suf[min(n, i * j + j - 1) + 1])) % mod;\n    }\n    suf[i] = (suf[i + 1] + dp[i]) % mod;\n    dp[i] %= mod;\n  }\n  cout << dp[1];\n}\n"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\nc = [0]*n + [1, 0]\nfor i in range(n-1, 0, -1):\n    c[i] = 2*c[i+1] % m\n    for j in range(2, n//i + 1):\n        c[i] = (c[i] + c[i*j] - c[min(n+1, (i+1)*j)]) % m\n\nprint((c[1] - c[2]) % m)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nint MOD;\nint dp[4000005];\nint criba[4000005 + 1];\nvoid crearCriba() {\n  int w[] = {4, 2, 4, 2, 4, 6, 2, 6};\n  for (int p = 25; p <= 4000005; p += 10) criba[p] = 5;\n  for (int p = 9; p <= 4000005; p += 6) criba[p] = 3;\n  for (int p = 4; p <= 4000005; p += 2) criba[p] = 2;\n  for (int p = 7, cur = 0; p * p <= 4000005; p += w[cur++ & 7])\n    if (!criba[p])\n      for (int j = p * p; j <= 4000005; j += (p << 1))\n        if (!criba[j]) criba[j] = p;\n}\nvector<int> primos;\nvoid buscarPrimos() {\n  crearCriba();\n  for (int i = (2); i < (4000005 + 1); i++)\n    if (!criba[i]) primos.push_back(i);\n}\nvoid fact(long long n, map<long long, long long> &f) {\n  while (criba[n]) {\n    f[criba[n]]++;\n    n /= criba[n];\n  }\n  if (n > 1) f[n]++;\n}\nvoid divisores(map<long long, long long> &f, vector<int> &divs,\n               map<long long, long long>::iterator it, long long n = 1) {\n  if (it == f.begin()) divs.clear();\n  if (it == f.end()) {\n    divs.push_back(n);\n    return;\n  }\n  long long p = it->first, k = it->second;\n  ++it;\n  for (int _ = (0); _ < (k + 1); _++) divisores(f, divs, it, n), n *= p;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n;\n  cin >> n;\n  cin >> MOD;\n  long long acum = 0;\n  dp[1] = 1;\n  const int mod = MOD;\n  buscarPrimos();\n  for (int i = (2); i < (n + 1); i++) {\n    map<long long, long long> factores;\n    vector<int> divs;\n    fact(i, factores);\n    divisores(factores, divs, factores.begin());\n    divs.pop_back();\n    for (auto it = divs.begin(); it != divs.end(); it++) {\n      if (*it == 1)\n        acum = (acum + dp[*it]) % mod;\n      else\n        acum = (acum + mod - dp[*it - 1] + dp[*it]) % mod;\n    }\n    acum += dp[i - 1];\n    acum %= mod;\n    dp[i] += acum;\n    dp[i] %= mod;\n  }\n  cout << dp[n] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*Everything is Hard \n * Before Easy \n * Jai Mata Dii \n */ \n \nimport java.util.*;\nimport java.io.*; \n  \npublic class Main {\n\tstatic class FastReader{ BufferedReader br;StringTokenizer st;public FastReader(){br = new BufferedReader(new InputStreamReader(System.in));}String next(){while (st == null || !st.hasMoreElements()){try{st = new StringTokenizer(br.readLine());}catch (IOException  e){e.printStackTrace();}}return st.nextToken();}int nextInt(){ return Integer.parseInt(next());}long nextLong(){return Long.parseLong(next());}double nextDouble(){return Double.parseDouble(next());}String nextLine(){String str = \"\"; try{str = br.readLine(); } catch (IOException e) {e.printStackTrace();} return str; }} \n\tstatic long mod = (long)(1e9+7); \n\t// static long mod = 998244353; \n//\t static Scanner sc = new Scanner(System.in); \n\tstatic FastReader sc = new FastReader(); \n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tpublic static void main (String[] args) { \n\t\tint ttt = 1;\n//\t\tttt = sc.nextInt();\n\t\tz :for(int tc=1;tc<=ttt;tc++){\n\t\t\tint n = sc.nextInt();\n\t\t\tlong m = sc.nextLong();\n\t\t\tlong dp[] = new long[n+1];\n\t\t\tdp[n] = 1;\n\t\t\tlong sum = 0;\n\t\t\tlong pre[] = new long[n+2];\n\t\t\tfor(int i=n;i>=1;i--) {\n\t\t\t\tdp[i] = (dp[i] + sum)%m;\n\t\t\t\tfor(long j=2;j*i<=n;j++) {\n\t\t\t\t\tlong fir = j*i;\n\t\t\t\t\tlong sec = Math.min(n, (j)*(i+1)-1);\n\t\t\t\t\tdp[i] = (dp[i] + pre[(int) fir] - pre[(int) (sec+1)] + m)%m;\n\t\t\t\t}\n\t\t\t\tsum = (sum + dp[i] + m)%m;\n\t\t\t\tpre[i] = (dp[i] + pre[i+1] + m)%m;\n\t\t\t}\n\t\t\tout.write(dp[1]+\"\\n\");\n\t\t}\n\t\tout.close();\n\t}\n\tstatic long pow(long a, long b){long ret = 1;while(b>0){if(b%2 == 0){a = (a*a)%mod;b /= 2;}else{ret = (ret*a)%mod;b--;}}return ret%mod;}\n\tstatic long gcd(long a,long b){if(b==0) return  a; return gcd(b,a%b); } \n\tprivate static void sort(double[] a) {List<Double> k = new ArrayList<>();for(double val : a) k.add(val);Collections.sort(k);for(int i=0;i<a.length;i++) a[i] = k.get(i);} \n\tprivate static void ini(List<Integer>[] tre2){for(int i=0;i<tre2.length;i++){tre2[i] = new ArrayList<>();}} \n\tprivate static void init(List<int[]>[] tre2){for(int i=0;i<tre2.length;i++){tre2[i] = new ArrayList<>();}} \n\tprivate static void sort(long[] a) {List<Long> k = new ArrayList<>();for(long val : a) k.add(val);Collections.sort(k);for(int i=0;i<a.length;i++) a[i] = k.get(i);} \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimize(\"O2\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconst long long int N = 4e6 + 20, mod = 1e9 + 7, inf = 1e9;\nvector<int> tajz[N];\nint dp[N];\nint main() {\n  ios ::sync_with_stdio(0);\n  cin.tie(0);\n  int T = 1;\n  while (T--) {\n    int n, m;\n    cin >> n >> m;\n    dp[1] = 1;\n    dp[2] = 2;\n    for (int i = 2; 2 * i <= n; i++) dp[2 * i]++;\n    for (int i = 3; i < n + 1; i++) {\n      dp[i] += (2 * dp[i - 1] + 1) % m;\n      dp[i] %= m;\n      for (int j = 2; j * i <= n; j++) {\n        dp[j * i] = (dp[j * i] + (-dp[i - 1] + dp[i] + m) % m) % m;\n      }\n    }\n    cout << dp[n];\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e6 + 10;\nint n, mod, dp[maxn], s[maxn];\ninline int add(int x, int y) {\n  x += y;\n  return x >= mod ? x - mod : x;\n}\ninline int sub(int x, int y) {\n  x -= y;\n  return x < 0 ? x + mod : x;\n}\ninline int mul(int x, int y) { return (long long)x * y % mod; }\nvoid solve2() {\n  cin >> n >> mod;\n  dp[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    dp[i] = add(dp[i], add(dp[i - 1], dp[i - 1]));\n    if (i != 2) dp[i] = add(dp[i], 1);\n    for (int j = i + i; j <= n; j += i)\n      dp[j] = add(dp[j], sub(dp[i], dp[i - 1]));\n  }\n  cout << dp[n] << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  solve2();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static long startTime = System.currentTimeMillis();\n\n    // for global initializations and methods starts here\n\n    // global initialisations and methods end here\n\n    static void run() {\n        boolean tc = false;\n        AdityaFastIO r = new AdityaFastIO();\n        //FastReader r = new FastReader();\n\n        try (OutputStream out = new BufferedOutputStream(System.out)) {\n\n            //long startTime = System.currentTimeMillis();\n\n            int testcases = tc ? r.ni() : 1;\n            int tcCounter = 1;\n            // Hold Here Sparky------------------->>>\n            // Solution Starts Here\n\n            start:\n            while (testcases-- > 0) {\n\n                int n = r.ni();\n                int mod = r.ni();\n\n                int[] dp = new int[n + 2];\n                int[] temp = new int[n + 2];\n                dp[n] = temp[n] = 1;\n                for (int i = n - 1; i > 0; i--) {\n                    dp[i] = temp[i + 1];\n                    for (int j = 2; i * j <= n; j++) {\n                        int ind = Math.min(n + 1, (i + 1) * j);\n                        dp[i] = ((dp[i] + temp[i * j]) % mod - temp[ind] + mod) % mod;\n                    }\n                    temp[i] = (temp[i + 1] + dp[i]) % mod;\n                }\n\n                out.write((dp[1] + \" \").getBytes());\n            }\n            // Solution Ends Here\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class AdityaFastIO {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n        public BufferedReader br;\n        public StringTokenizer st;\n\n        public AdityaFastIO() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public AdityaFastIO(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String word() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String line() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[100000001]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int ni() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nl() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nd() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        run();\n    }\n\n    static long mod = 998244353;\n\n    static long modInv(long base, long e) {\n        long result = 1;\n        base %= mod;\n        while (e > 0) {\n            if ((e & 1) > 0) result = result * base % mod;\n            base = base * base % mod;\n            e >>= 1;\n        }\n        return result;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String word() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String line() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int ni() {\n            return Integer.parseInt(word());\n        }\n\n        long nl() {\n            return Long.parseLong(word());\n        }\n\n        double nd() {\n            return Double.parseDouble(word());\n        }\n    }\n\n    static int MOD = (int) (1e9 + 7);\n\n    static long powerLL(long x, long n) {\n        long result = 1;\n        while (n > 0) {\n            if (n % 2 == 1) result = result * x % MOD;\n            n = n / 2;\n            x = x * x % MOD;\n        }\n        return result;\n    }\n\n    static long powerStrings(int i1, int i2) {\n        String sa = String.valueOf(i1);\n        String sb = String.valueOf(i2);\n        long a = 0, b = 0;\n        for (int i = 0; i < sa.length(); i++) a = (a * 10 + (sa.charAt(i) - '0')) % MOD;\n        for (int i = 0; i < sb.length(); i++) b = (b * 10 + (sb.charAt(i) - '0')) % (MOD - 1);\n        return powerLL(a, b);\n    }\n\n    static long gcd(long a, long b) {\n        if (a == 0) return b;\n        else return gcd(b % a, a);\n    }\n\n    static long lcm(long a, long b) {\n        return (a * b) / gcd(a, b);\n    }\n\n    static long lower_bound(List<Long> list, long k) {\n        int s = 0;\n        int e = list.size();\n        while (s != e) {\n            int mid = (s + e) >> 1;\n            if (list.get(mid) < k) s = mid + 1;\n            else e = mid;\n        }\n        if (s == list.size()) return -1;\n        return s;\n    }\n\n    static int upper_bound(List<Long> list, long k) {\n        int s = 0;\n        int e = list.size();\n        while (s != e) {\n            int mid = (s + e) >> 1;\n            if (list.get(mid) <= k) s = mid + 1;\n            else e = mid;\n        }\n        if (s == list.size()) return -1;\n        return s;\n    }\n\n    static void addEdge(ArrayList<ArrayList<Integer>> graph, int edge1, int edge2) {\n        graph.get(edge1).add(edge2);\n        graph.get(edge2).add(edge1);\n    }\n\n    public static class Pair implements Comparable<Pair> {\n        int first;\n        int second;\n\n        public Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(Pair o) {\n            // TODO Auto-generated method stub\n            if (this.first != o.first)\n                return (int) (this.first - o.first);\n            else return (int) (this.second - o.second);\n        }\n    }\n\n    public static class PairC<X, Y> implements Comparable<PairC> {\n        X first;\n        Y second;\n\n        public PairC(X first, Y second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(PairC o) {\n            // TODO Auto-generated method stub\n            return o.compareTo((PairC) first);\n        }\n    }\n\n    static boolean isCollectionsSorted(List<Long> list) {\n        if (list.size() == 0 || list.size() == 1) return true;\n        for (int i = 1; i < list.size(); i++) if (list.get(i) <= list.get(i - 1)) return false;\n        return true;\n    }\n\n    static boolean isCollectionsSortedReverseOrder(List<Long> list) {\n        if (list.size() == 0 || list.size() == 1) return true;\n        for (int i = 1; i < list.size(); i++) if (list.get(i) >= list.get(i - 1)) return false;\n        return true;\n    }\n\n}"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    sol = [0] * (n + 2)\n    def add(start, end, val):\n        sol[start] = (sol[start] + val) % m\n        sol[end] = (sol[end] - val) % m\n\n    add(1, 2, 1)\n\n    out = 0\n    for i in range(1, n):\n        out = (out + sol[i]) % m\n        add(i + 1, n + 1, out)\n        for j in range(2, (n // i) + 1):\n            add(i * j, min(n + 1, (i + 1) * j), out)\n\n    print((out + sol[n]) % m)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\nc = [0]*n + [1, 0]\nfor i in range(n-1, 0, -1):\n    c[i] = 2*c[i+1] % m\n    for j in range(2, n//i + 1):\n        c[i] = (c[i] + c[i*j] - c[min(n+1, i*j + j)]) % m\n\nprint((c[1] - c[2]) % m)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1000000000;\nlong long mod = 1000000007LL;\nlong long mod2 = 998244353LL;\nint n;\nlong long m;\nlong long dp[4000005];\nint main() {\n  cin >> n >> m;\n  memset(dp, 0LL, sizeof(dp));\n  dp[n] = 1LL;\n  for (int i = n - 1; i >= 1; --i) {\n    dp[i] = (dp[i] + dp[i + 1]) % m;\n    for (int j = 2; j <= n / i; ++j) {\n      long long j2 = min((long long)n, (long long)j * (long long)(i + 1) - 1);\n      long long det = dp[j * i];\n      if (j2 < n) det = (det - dp[j * (i + 1)] + m) % m;\n      dp[i] = (dp[i] + det) % m;\n    }\n    dp[i] = (dp[i] + dp[i + 1]) % m;\n  }\n  long long ans = (dp[1] - dp[2] + m) % m;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<i64> f(n + 1), suf(n + 5);\n  f[n] = suf[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    f[i] = (f[i] + suf[i + 1]) % m;\n    for (int j = 2; i * j <= n; j++) {\n      f[i] = (f[i] + suf[i * j] - suf[min(n + 1, i * j + j)] + m) % m;\n    }\n    suf[i] = (suf[i + 1] + f[i]) % m;\n  }\n  cout << f[1] << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint32_t main() {\n  long long int n, mod;\n  cin >> n >> mod;\n  vector<long long int> dp(4000010);\n  dp[1] = 1;\n  for (long long int i = 2; i <= n; i++) {\n    dp[i] = (dp[i] + 2LL * dp[i - 1] + 1LL) % mod;\n    if (i == 2) dp[i]--;\n    for (long long int j = 2 * i; j < 4000010; j += i) {\n      dp[j] = (dp[j] + dp[i] + mod - dp[i - 1]) % mod;\n    }\n  }\n  cout << dp[n];\n  cerr << \"Time : \" << 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC\n       << \"ms\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\n#pragma comment(linker, \"/STACK:16777216\")\nusing namespace std;\nconst int INF = 1000000000 + 1e8;\nconst long long LINF = 2000000000000000000;\nconst int N = 4e6 + 1010;\nlong long dp[N];\nlong long pref[N];\nlong long n, mod;\nlong long get(int l, int r) {\n  return (pref[l] - (r >= n ? 0 : pref[r + 1]) + 2 * mod) % mod;\n}\nvoid solve() {\n  cin >> n >> mod;\n  dp[n] = 1, pref[n] = 1;\n  int l, r;\n  for (int i = n - 1; i >= 1; i--) {\n    dp[i] = pref[i + 1] % mod;\n    for (int x = 2; i * x <= n; x++) {\n      l = i * x;\n      r = i * x + x - 1;\n      dp[i] = (dp[i] + get(l, r)) % mod;\n    }\n    pref[i] = (pref[i + 1] + dp[i]) % mod;\n  }\n  cout << dp[1];\n}\nint main() {\n  srand(time(0));\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int tst = 1;\n  while (tst--) solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\n\tprivate static final String NO = \"No\";\n\tprivate static final String YES = \"Yes\";\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tprivate static final long MOD = 1000000007;\n\n\tvoid solve() {\n\t\tint T = 1;// ni();\n\n\t\tfor (int i = 0; i < T; i++)\n\t\t\tsolve(i);\n\t}\n\n\tvoid solve(int nth) {\n\t\tint n = ni(), m = ni();\n\t\tint dp[] = new int[n + 1];\n\t\tint suff[] = new int[n + 2];\n\t\tdp[n] = 1;\n\t\tsuff[n] = 1;\n\t\tsuff[n + 1] = 0;\n\n\t\tfor (int i = n - 1; i >= 1; i--) {\n\t\t\tdp[i] = suff[i + 1];\n\t\t\tfor (int b = 2; b <= n / i; b++) {\n//\t\t\t\ttr(\">\", i, b, b * i, n + 1, b * i + b);\n\t\t\t\tdp[i] += suff[b * i] - suff[Math.min(n + 1, b * i + b)];\n\t\t\t\tif (dp[i] < 0)\n\t\t\t\t\tdp[i] += m;\n\t\t\t\tif (dp[i] > m)\n\t\t\t\t\tdp[i] -= m;\n\t\t\t}\n\n\t\t\tsuff[i] = suff[i + 1] + dp[i];\n\t\t\tif (suff[i] > m)\n\t\t\t\tsuff[i] -= m;\n//\t\t\ttr(i, dp, suff);\n\t\t}\n\t\tout.println(dp[1]);\n\t}\n\n\t// a^b\n\tlong power(long a, long b) {\n\t\tlong x = 1, y = a;\n\t\twhile (b > 0) {\n\t\t\tif (b % 2 != 0) {\n\t\t\t\tx = (x * y) % MOD;\n\t\t\t}\n\t\t\ty = (y * y) % MOD;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn x % MOD;\n\t}\n\n\tprivate long gcd(long a, long b) {\n\t\twhile (a != 0) {\n\t\t\tlong tmp = b % a;\n\t\t\tb = a;\n\t\t\ta = tmp;\n\t\t}\n\t\treturn b;\n\t}\n\n\tvoid run() throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!INPUT.isEmpty())\n\t\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate char[] nc(int n) {\n\t\tchar[] ret = new char[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tret[i] = nc();\n\t\treturn ret;\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n) {\n\t\t\tif (!(isSpaceChar(b)))\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate Integer[] na2(int n) {\n\t\tInteger[] a = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int[][] na(int n, int m) {\n\t\tint[][] a = new int[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = na(m);\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate Long[] nl2(int n) {\n\t\tLong[] a = new Long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate long[] nl(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate long[][] nl(int n, int m) {\n\t\tlong[][] a = new long[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl(m);\n\t\treturn a;\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic class SuffixArray {\n\n\t\t// ALPHABET_SZ is the default alphabet size, this may need to be much\n\t\t// larger if you're using the LCS method with multiple sentinels\n\t\tint ALPHABET_SZ = 256, N;\n\t\tint[] T, lcp, sa, sa2, rank, tmp, c;\n\n\t\tpublic SuffixArray(String str) {\n\t\t\tthis(toIntArray(str));\n\t\t}\n\n\t\tprivate static int[] toIntArray(String s) {\n\t\t\tint[] text = new int[s.length()];\n\t\t\tfor (int i = 0; i < s.length(); i++)\n\t\t\t\ttext[i] = s.charAt(i);\n\t\t\treturn text;\n\t\t}\n\n\t\t// Designated constructor\n\t\tpublic SuffixArray(int[] text) {\n\t\t\tT = text;\n\t\t\tN = text.length;\n\t\t\tsa = new int[N];\n\t\t\tsa2 = new int[N];\n\t\t\trank = new int[N];\n\t\t\tc = new int[Math.max(ALPHABET_SZ, N)];\n\t\t\tconstruct();\n\t\t\tkasai();\n\t\t}\n\n\t\tprivate void construct() {\n\t\t\tint i, p, r;\n\t\t\tfor (i = 0; i < N; ++i)\n\t\t\t\tc[rank[i] = T[i]]++;\n\t\t\tfor (i = 1; i < ALPHABET_SZ; ++i)\n\t\t\t\tc[i] += c[i - 1];\n\t\t\tfor (i = N - 1; i >= 0; --i)\n\t\t\t\tsa[--c[T[i]]] = i;\n\t\t\tfor (p = 1; p < N; p <<= 1) {\n\t\t\t\tfor (r = 0, i = N - p; i < N; ++i)\n\t\t\t\t\tsa2[r++] = i;\n\t\t\t\tfor (i = 0; i < N; ++i)\n\t\t\t\t\tif (sa[i] >= p)\n\t\t\t\t\t\tsa2[r++] = sa[i] - p;\n\t\t\t\tArrays.fill(c, 0, ALPHABET_SZ, 0);\n\t\t\t\tfor (i = 0; i < N; ++i)\n\t\t\t\t\tc[rank[i]]++;\n\t\t\t\tfor (i = 1; i < ALPHABET_SZ; ++i)\n\t\t\t\t\tc[i] += c[i - 1];\n\t\t\t\tfor (i = N - 1; i >= 0; --i)\n\t\t\t\t\tsa[--c[rank[sa2[i]]]] = sa2[i];\n\t\t\t\tfor (sa2[sa[0]] = r = 0, i = 1; i < N; ++i) {\n\t\t\t\t\tif (!(rank[sa[i - 1]] == rank[sa[i]] && sa[i - 1] + p < N && sa[i] + p < N\n\t\t\t\t\t\t\t&& rank[sa[i - 1] + p] == rank[sa[i] + p]))\n\t\t\t\t\t\tr++;\n\t\t\t\t\tsa2[sa[i]] = r;\n\t\t\t\t}\n\t\t\t\ttmp = rank;\n\t\t\t\trank = sa2;\n\t\t\t\tsa2 = tmp;\n\t\t\t\tif (r == N - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tALPHABET_SZ = r + 1;\n\t\t\t}\n\t\t}\n\n\t\t// Use Kasai algorithm to build LCP array\n\t\tprivate void kasai() {\n\t\t\tlcp = new int[N - 1];\n\t\t\tint[] inv = new int[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tinv[sa[i]] = i;\n\t\t\tfor (int i = 0, len = 0; i < N; i++) {\n\t\t\t\tif (inv[i] > 0) {\n\t\t\t\t\tint k = sa[inv[i] - 1];\n\t\t\t\t\twhile ((i + len < N) && (k + len < N) && T[i + len] == T[k + len])\n\t\t\t\t\t\tlen++;\n\t\t\t\t\tlcp[inv[i] - 1] = len;\n\t\t\t\t\tif (len > 0)\n\t\t\t\t\t\tlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = long unsigned long;\nusing ld = double long;\nint n, m;\nint a[4000005], z[4000005];\nint ad(int x, int y) {\n  x += y;\n  if (x >= m) x -= m;\n  return x;\n}\nint sub(int x, int y) {\n  x -= y;\n  if (x < 0) x += m;\n  return x;\n}\nvoid walk_up(int x) {\n  for (int q = 1; q * x <= n; q++) {\n    z[q * x] = ad(z[q * x], a[x]);\n    if (q * x + q <= n) {\n      z[q * x + q] = sub(z[q * x + q], a[x]);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(!cin.tie(0));\n  cin >> n >> m;\n  a[1] = 1;\n  int s = 1;\n  walk_up(1);\n  for (int x = 2; x <= n; x++) {\n    a[x] = s;\n    z[x] = ad(z[x], z[x - 1]);\n    a[x] = ad(a[x], z[x]);\n    s = ad(s, a[x]);\n    walk_up(x);\n  }\n  cout << a[n] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nlong long dp[4000005], c[4000005], sum = 0, x = 0;\nint main() {\n  cin >> n >> m;\n  c[1] = 1;\n  for (int i = 1; i <= n; i++) {\n    dp[i] = sum;\n    x += c[i];\n    x %= m;\n    dp[i] += x;\n    dp[i] %= m;\n    sum += dp[i];\n    sum %= m;\n    if (i == 1) x = 0;\n    for (int j = 2; i * j <= n; j++) {\n      c[i * j] += dp[i];\n      c[min(i * j + j, n + 1)] -= dp[i];\n      c[i * j] %= m;\n      c[min(i * j + j, n + 1)] = (c[min(i * j + j, n + 1)] % m + m) % m;\n    }\n  }\n  cout << dp[n];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace chrono;\nlong long int pref[50 * 100001] = {};\nlong long int N;\nlong long int MOD;\nlong long int sum(long long int l, long long int r) {\n  r = min(N, r);\n  return (pref[l] - pref[r + 1] + MOD) % MOD;\n}\nvoid solve() {\n  long long int n;\n  cin >> n;\n  N = n;\n  cin >> MOD;\n  pref[n] = 1;\n  for (long long int i = n - 1; i >= 1; i--) {\n    long long int curr = sum(i + 1, n);\n    long long int cnt = 2;\n    while (true) {\n      if (cnt * i > n) break;\n      curr += sum(cnt * i, cnt * i + cnt - 1);\n      curr %= MOD;\n      cnt++;\n    }\n    pref[i] = (pref[i + 1] + curr) % MOD;\n  }\n  cout << sum(1, 1) << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  auto start1 = high_resolution_clock::now();\n  solve();\n  auto stop1 = high_resolution_clock::now();\n  auto duration = duration_cast<microseconds>(stop1 - start1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 5000005;\nlong long n, m;\nlong long f[maxn];\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  f[1] = 1;\n  for (long long x = 2; x <= n; x++) {\n    f[x] = (f[x] + 2 * f[x - 1]) % m;\n    if (x > 2) f[x] = (f[x] + 1) % m;\n    long long cur = (f[x] - f[x - 1] + m) % m;\n    for (long long y = 2 * x; y <= n; y += x) f[y] = (f[y] + cur) % m;\n  }\n  printf(\"%lld\\n\", f[n]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, mod;\nint dp[4000005];\nint psum[4000005];\nvoid f(int cur, int v) {\n  for (int div = 2; div * cur <= n; div++) {\n    int l = div * cur;\n    int r = div * cur + div - 1;\n    r = min(r, n + 1);\n    psum[l] += v;\n    psum[l] %= mod;\n    psum[r + 1] -= v;\n    while (psum[r + 1] < 0) psum[r + 1] += mod;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> mod;\n  dp[1] = 1;\n  f(1, 1);\n  for (int i = 2; i <= n; i++) {\n    psum[i] += psum[i - 1];\n    psum[i] %= mod;\n    while (psum[i] < 0) psum[i] += mod;\n    dp[i] = dp[i - 1] + psum[i];\n    dp[i] %= mod;\n    f(i, dp[i]);\n    dp[i] += dp[i - 1];\n    dp[i] %= mod;\n  }\n  int ans = dp[n] - dp[n - 1];\n  if (ans < 0) ans += mod;\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Ada{\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n        int m=sc.nextInt();\n        int dp[]=new int[n+1];\n        int pre[]=new int[n+1];\n        int prevSum=dp[1]=1;\n        for (int p=2, j=2;j<=n; p++,j=p){\n            int r=j+p;\n            pre[j]=(pre[j]+dp[1])%m;\n            if(r<=n)pre[r]=((pre[r]-dp[1])%m+m)%m;\n        }\n        for (int i=2;i<=n;i++){\n            pre[i]=(pre[i-1]+pre[i])%m;\n            dp[i]=(prevSum+pre[i])%m;\n            for (int p=2, j=2*i;j<=n; p++,j=p*i){\n                int r=j+p;\n                pre[j]=(pre[j]+dp[i])%m;\n                if(r<=n)pre[r]=((pre[r]-dp[i])%m+m)%m;\n            }\n            prevSum=(prevSum+dp[i])%m;\n        }\n        System.out.println(dp[n]);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 10 + 4e6;\nlong long dp[N];\nint n, mod;\nvoid solve() {\n  cin >> n >> mod;\n  dp[1] = 1, dp[2] = 2;\n  for (int i = 2; i <= n; i++) {\n    if (i > 2) dp[i] = (dp[i] + dp[i - 1] * 2 + 1) % mod;\n    long long d = dp[i] - dp[i - 1];\n    for (int j = 2; j <= n / i; j++) dp[i * j] += d;\n  }\n  cout << (dp[n] % mod + mod) % mod << endl;\n}\nsigned main() {\n  ios::sync_with_stdio();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 4e6 + 5;\nint n, MOD, F[MAXN], Sum[MAXN];\nint min(int x, int y) { return x < y ? x : y; }\nint main() {\n  scanf(\"%d%d\", &n, &MOD);\n  F[n] = 1;\n  Sum[n] = 1;\n  for (int i = n - 1; i; i--) {\n    F[i] = Sum[i + 1];\n    for (int j = 2; i * j <= n; j++) {\n      F[i] =\n          ((F[i] + Sum[i * j] - Sum[min((i + 1) * j - 1, n) + 1]) % MOD + MOD) %\n          MOD;\n    }\n    Sum[i] = (Sum[i + 1] + F[i]) % MOD;\n  }\n  printf(\"%d\\n\", F[1]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int N = 200043;\nlong long int MOD = 1000000007;\nlong long int add(long long int x, long long int y) {\n  x = ((x % MOD) + (y % MOD)) % MOD;\n  while (x >= MOD) x -= MOD;\n  while (x < 0) x += MOD;\n  return x;\n}\nlong long int mul(long long int x, long long int y) {\n  return ((x % MOD) * (y % MOD)) % MOD;\n}\nlong long int binpow(long long int x, long long int y) {\n  long long int z = 1;\n  while (y) {\n    if (y & 1) z = mul(z, x);\n    x = mul(x, x);\n    y >>= 1;\n  }\n  return z;\n}\nlong long int inv(long long int x) { return binpow(x, MOD - 2); }\nlong long int divide(long long int x, long long int y) {\n  return mul(x, inv(y));\n}\nlong long int ar[4000005];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t, i, j;\n  t = 1;\n  while (t--) {\n    long long int n;\n    cin >> n >> MOD;\n    if (n == 1)\n      cout << 1 << endl;\n    else if (n == 2)\n      cout << 2 % MOD << endl;\n    if (n <= 2) continue;\n    ar[n] = 1;\n    ar[n - 1] = 1;\n    ar[n - 1] = add(ar[n - 1], ar[n]);\n    long long int cur = 2;\n    for (i = n - 2; i >= 1; i--) {\n      ar[i] = add(ar[i], cur);\n      for (j = 2 * i; j <= n; j += i) {\n        long long int k = j / i;\n        ar[i] = add(ar[i], add(ar[j], -ar[min(j + k, n + 1)]));\n      }\n      cur = add(cur, ar[i]);\n      ar[i] = add(ar[i], ar[i + 1]);\n    }\n    cout << add(ar[1], -ar[2]) << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 1) + (x << 3) + (c ^ 48);\n    c = getchar();\n  }\n  return x * f;\n}\nconst int N = 4e6 + 10;\nint f[N], h[N], sum[N];\nint main() {\n  int n = read(), mod = read();\n  h[1] = 1, h[2] = mod - 1;\n  int s = 0;\n  for (int i = 1; i <= n; i++) {\n    s = (s + h[i]) % mod, f[i] = (s + sum[i - 1]) % mod;\n    for (int j = 2; j * i <= n; j++) {\n      h[i * j] += f[i], h[i * j] %= mod;\n      if ((i + 1) * j <= n)\n        h[(i + 1) * j] -= f[i], h[(i + 1) * j] = (h[(i + 1) * j] + mod) % mod;\n    }\n    sum[i] = (sum[i - 1] + f[i]) % mod;\n  }\n  printf(\"%d\", f[n]);\n}\n"
        },
        {
            "language": 3,
            "solution": "\nimport sys\ninput = sys.stdin.readline\n \nn,m=map(int,input().split())\n \nDP=[0]*(n+5)\nCUM=[1]*(n+5)\nCUM[1]=0\nDP[1]=1\n \nS=1\n \nfor i in range(2,n+1):\n    CUM[i]=(CUM[i-1]+CUM[i])%m\n    DP[i]=(S+CUM[i])%m\n    S+=DP[i]\n    S%=m\n \n    for j in range(i+i,n+1,i):\n        CUM[j]=(CUM[j]+DP[i]-DP[i-1])%m\n \nprint(DP[n])"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class UpStripHard {\n    //--------------------------INPUT READER--------------------------------//\n    static class fs {\n        public BufferedReader br;\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        public fs() { this(System.in); }\n        public fs(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n        String next() {\n            while (!st.hasMoreTokens()) {\n                try { st = new StringTokenizer(br.readLine()); }\n                catch (IOException e) { e.printStackTrace(); }\n            }\n            return st.nextToken();\n        }\n\n        int ni() { return Integer.parseInt(next()); }\n        long nl() { return Long.parseLong(next()); }\n        double nd() { return Double.parseDouble(next()); }\n        String ns() { return next(); }\n\n        int[] na(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = ni();\n            return a;\n        }\n    }\n    //-----------------------------------------------------------------------//\n\n    //---------------------------PRINTER-------------------------------------//\n    static class Printer {\n        static PrintWriter w;\n        public Printer() {this(System.out);}\n        public Printer(OutputStream os) {\n            w = new PrintWriter(os);\n        }\n        public void p(int i) {w.println(i);};\n        public void p(long l) {w.println(l);};\n        public void p(double d) {w.println(d);};\n        public void p(String s) { w.println(s);};\n        public void pr(int i) {w.println(i);};\n        public void pr(long l) {w.print(l);};\n        public void pr(double d) {w.print(d);};\n        public void pr(String s) { w.print(s);};\n        public void pl() {w.println();};\n        public void close() {w.close();};\n    }\n    //------------------------------------------------------------------------//\n\n    //--------------------------VARIABLES------------------------------------//\n    static fs sc = new fs();\n    static OutputStream outputStream = System.out;\n    static Printer w = new Printer(outputStream);\n    //-----------------------------------------------------------------------//\n\n    //--------------------------ADMIN_MODE-----------------------------------//\n    private static void ADMIN_MODE() throws IOException {\n        if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n            w = new Printer(new FileOutputStream(\"output.txt\"));\n            sc = new fs(new FileInputStream(\"input.txt\"));\n        }\n    }\n    //-----------------------------------------------------------------------//\n\n    //----------------------------START--------------------------------------//\n    public static void main(String[] args)\n            throws IOException {\n\n        ADMIN_MODE();\n\n//        int t = sc.ni();\n//        while(t-->0)\n            solve();\n\n\n        w.close();\n    }\n\n    static long mod;\n\n    static void solve() throws IOException {\n        int n = sc.ni();\n        mod = sc.nl();\n        long[] dp = new long[n+1];\n        long[] su = new long[n+2];\n        dp[n] = 1;\n        su[n] = 1;\n\n        for(int i = n-1; i>=1; i--) {\n            long ways = su[i+1];\n            ways %= mod;\n            for(int mul = 2; true; mul++) {\n                int lower = mul*i;\n                int high = (i+1)*mul-1;\n                if(lower > n) break;\n                high = Math.min(high, n);\n                ways += su[lower]-su[high+1];\n                ways %= mod;\n            }\n            dp[i] = ways;\n            su[i] = ways + su[i+1];\n            su[i] %= mod;\n        }\n\n        w.p(dp[1]);\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint D[4000002];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int N, MOD;\n  cin >> N >> MOD;\n  D[N] = 1;\n  for (int i = N - 1; i > 0; i--) {\n    D[i] = D[i + 1];\n    for (int j = 2; i * j <= N; j++) {\n      D[i] = D[i] + D[j * i] - D[min(j * (i + 1), N + 1)];\n      if (D[i] >= MOD) D[i] -= MOD;\n      if (D[i] < 0) D[i] += MOD;\n    }\n    D[i] += D[i + 1];\n    if (D[i] >= MOD) D[i] -= MOD;\n  }\n  cout << (D[1] + MOD - D[2]) % MOD << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC target(\"avx,avx2,fma\")\nusing namespace std;\nconst long long MAXN = 1000005;\nconst long long SQRTN = 1003;\nconst long long LOGN = 22;\nconst double PI = acos(-1);\nconst long long INF = 1e18;\nconst long long MOD = 1e9 + 7;\nconst long long FMOD = 998244353;\nconst double eps = 1e-9;\nvoid __print(long long x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  long long f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nmt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT gcd(T a, T b) {\n  if (b == 0) return a;\n  a %= b;\n  return gcd(b, a);\n}\ntemplate <typename T>\nT lcm(T a, T b) {\n  return (a * (b / gcd(a, b)));\n}\nlong long add(long long a, long long b, long long c = MOD) {\n  long long res = a + b;\n  return (res >= c ? res % c : res);\n}\nlong long sub(long long a, long long b, long long c = MOD) {\n  long long res;\n  if (abs(a - b) < c)\n    res = a - b;\n  else\n    res = (a - b) % c;\n  return (res < 0 ? res + c : res);\n}\nlong long mul(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return (res >= c ? res % c : res);\n}\nlong long muln(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return ((res % c) + c) % c;\n}\nlong long mulmod(long long a, long long b, long long m = MOD) {\n  long long q = (long long)(((long double)a * (long double)b) / (long double)m);\n  long long r = a * b - q * m;\n  if (r > m) r %= m;\n  if (r < 0) r += m;\n  return r;\n}\ntemplate <typename T>\nT binpow(T e, T n) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = x * p;\n    p = p * p;\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT binpow2(T e, T n, T m = MOD) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = mul(x, p, m);\n    p = mul(p, p, m);\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT extended_euclid(T a, T b, T &x, T &y) {\n  T xx = 0, yy = 1;\n  y = 0;\n  x = 1;\n  while (b) {\n    T q = a / b, t = b;\n    b = a % b;\n    a = t;\n    t = xx;\n    xx = x - q * xx;\n    x = t;\n    t = yy;\n    yy = y - q * yy;\n    y = t;\n  }\n  return a;\n}\ntemplate <typename T>\nT mod_inverse(T a, T n = MOD) {\n  T x, y, z = 0;\n  T d = extended_euclid(a, n, x, y);\n  return (d > 1 ? -1 : sub(x, z, n));\n}\nconst long long FACSZ = 1e4;\nlong long fact[FACSZ], ifact[FACSZ];\nvoid precom(long long c = MOD) {\n  fact[0] = 1;\n  for (long long i = 1; i < FACSZ; i++) fact[i] = mul(fact[i - 1], i, c);\n  ifact[FACSZ - 1] = mod_inverse(fact[FACSZ - 1], c);\n  for (long long i = FACSZ - 1 - 1; i >= 0; i--) {\n    ifact[i] = mul(i + 1, ifact[i + 1], c);\n  }\n}\nvector<long long> primes;\nvoid prime_precom() {\n  primes.push_back(2);\n  for (long long x = 3; primes.size() <= MAXN; x += 2) {\n    bool isPrime = true;\n    for (auto p : primes) {\n      if (x % p == 0) {\n        isPrime = false;\n        break;\n      }\n      if (p * p > x) {\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(x);\n    }\n  }\n}\nlong long ncr(long long n, long long k) {\n  if (n < k) return 0;\n  if (k == 0) return 1;\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res *= (n - i);\n    res /= (i + 1);\n  }\n  return res;\n}\nlong long ncr_modp(long long n, long long k, long long c = MOD) {\n  if (n < k) return 0;\n  if (k == 0) return 1;\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res = mul(res, n - i, c);\n    res = mul(res, binpow2(i + 1, c - 2, c), c);\n  }\n  return res;\n}\nvector<long long> factors;\nvoid factorize(long long a) {\n  factors.clear();\n  for (long long i = 1; i * i <= a; i++) {\n    if (a % i == 0) {\n      factors.push_back(i);\n      factors.push_back(a / i);\n    }\n  }\n  sort(factors.begin(), factors.end());\n}\nlong long ncr_precom(long long n, long long r, long long c = MOD) {\n  return mul(mul(ifact[r], ifact[n - r], c), fact[n], c);\n}\nlong long ceil(long long a, long long b) { return (a + b - 1) / b; }\nbool is_prime(long long n) {\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\nbool diophantine_checker(long long a, long long b, long long n) {\n  for (long long i = 0; i * a <= n; i++) {\n    if ((n - (i * a)) % b == 0) {\n      return true;\n    }\n  }\n  return false;\n}\nlong long count_divisors(long long n) {\n  long long c;\n  long long ans = 1;\n  for (long long i = 2; i * i <= n; i++) {\n    c = 0;\n    while (n % i == 0) {\n      c++;\n      n /= i;\n    }\n    ans *= (c + 1);\n  }\n  if (n > 2) {\n    return ans * 2;\n  }\n  return ans;\n}\nstring to_binary(long long n) {\n  string r;\n  while (n != 0) {\n    r = (n % 2 == 0 ? \"0\" : \"1\") + r;\n    n /= 2;\n  }\n  return r;\n}\nbool ispower2(long long x) { return x && (!(x & (x - 1))); }\nunsigned long long mulmodBitwise(unsigned long long a, unsigned long long b,\n                                 unsigned long long p) {\n  a %= p;\n  b %= p;\n  if (a <= 0xFFFFFFF && b <= 0xFFFFFFF) {\n    return (a * b) % p;\n  }\n  if (b > a) {\n    swap(a, b);\n  }\n  unsigned long long result = 0;\n  while (a > 0 && b > 0) {\n    if (b & 1) {\n      result += a;\n      result %= p;\n    }\n    a <<= 1;\n    a %= p;\n    b >>= 1;\n  }\n  return result;\n}\nunsigned long long mulmod2(unsigned long long a, unsigned long long b,\n                           unsigned long long p) {\n  a %= p;\n  b %= p;\n  if (a <= 0xFFFFFFF && b <= 0xFFFFFFF) {\n    return (a * b) % p;\n  }\n  unsigned long long zeros = 0;\n  unsigned long long m = p;\n  while ((m & 0x8000000000000000ULL) == 0) {\n    zeros++;\n    m <<= 1;\n  }\n  unsigned long long mask = (1 << zeros) - 1;\n  unsigned long long result = 0;\n  while (a > 0 && b > 0) {\n    result += (b & mask) * a;\n    result %= p;\n    b >>= zeros;\n    a <<= zeros;\n    a %= p;\n  }\n  return result;\n}\nunsigned long long powmod(unsigned long long base, unsigned long long exponent,\n                          unsigned long long p) {\n  unsigned long long result = 1;\n  while (exponent > 0) {\n    if (exponent & 1) {\n      result = mulmod2(result, base, p);\n    }\n    base = mulmod2(base, base, p);\n    exponent >>= 1;\n  }\n  return result;\n}\nvector<long long> spf;\nvoid sieve() {\n  spf.resize(MAXN);\n  spf[1] = 1;\n  for (long long i = 2; i < MAXN; i++) {\n    spf[i] = i;\n  }\n  for (long long i = 4; i < MAXN; i += 2) {\n    spf[i] = 2;\n  }\n  for (long long i = 3; i * i <= MAXN; i++) {\n    if (spf[i] == i) {\n      for (long long j = i * i; j < MAXN; j += i) {\n        if (spf[j] == j) {\n          spf[j] = i;\n        }\n      }\n    }\n  }\n}\nvoid pfactor(long long x, vector<long long> &ret) {\n  while (x != 1) {\n    ret.push_back(spf[x]);\n    x = x / spf[x];\n  }\n}\nvoid solvethetestcase() {\n  long long n, m;\n  cin >> n >> m;\n  vector<long long> dp(n + 1, 0ll);\n  vector<long long> upd(n + 1, 0ll);\n  vector<long long> sm(n + 1, 0ll);\n  vector<long long> psum(n + 1, 0ll);\n  for (long long i = 1; i <= n; i++) {\n    sm[i] = sm[i - 1] + upd[i];\n    if (i == 1) {\n      dp[i] = 1ll;\n    } else {\n      dp[i] = add(psum[i - 1], sm[i], m);\n    }\n    psum[i] = add(psum[i - 1], dp[i], m);\n    for (long long j = 2; j * i <= n; j++) {\n      long long l = j * i;\n      long long r = j * (i + 1);\n      upd[l] = add(upd[l], dp[i], m);\n      if (r <= n) {\n        upd[r] = sub(upd[r], dp[i], m);\n      }\n    }\n  }\n  cout << dp[n] << \"\\n\";\n}\nsigned main() {\n  cout << fixed << setprecision(12);\n  ;\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  for (long long testcase = 1; testcase < t + 1; testcase++) {\n    solvethetestcase();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC target(\"avx,avx2,fma\")\nusing namespace std;\n#pragma GCC optimize(3)\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\nconst long long MAXN = 1000005;\nconst long long SQRTN = 1003;\nconst long long LOGN = 22;\nconst double PI = acos(-1);\nconst long long INF = 1e18;\nconst long long MOD = 1e9 + 7;\nconst long long FMOD = 998244353;\nconst double eps = 1e-9;\nvoid __print(long long x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  long long f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nmt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT gcd(T a, T b) {\n  if (b == 0) return a;\n  a %= b;\n  return gcd(b, a);\n}\ntemplate <typename T>\nT lcm(T a, T b) {\n  return (a * (b / gcd(a, b)));\n}\nlong long add(long long a, long long b, long long c = MOD) {\n  long long res = a + b;\n  return (res >= c ? res % c : res);\n}\nlong long sub(long long a, long long b, long long c = MOD) {\n  long long res;\n  if (abs(a - b) < c)\n    res = a - b;\n  else\n    res = (a - b) % c;\n  return (res < 0 ? res + c : res);\n}\nlong long mul(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return (res >= c ? res % c : res);\n}\nlong long muln(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return ((res % c) + c) % c;\n}\nlong long mulmod(long long a, long long b, long long m = MOD) {\n  long long q = (long long)(((long double)a * (long double)b) / (long double)m);\n  long long r = a * b - q * m;\n  if (r > m) r %= m;\n  if (r < 0) r += m;\n  return r;\n}\ntemplate <typename T>\nT binpow(T e, T n) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = x * p;\n    p = p * p;\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT binpow2(T e, T n, T m = MOD) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = mul(x, p, m);\n    p = mul(p, p, m);\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT extended_euclid(T a, T b, T &x, T &y) {\n  T xx = 0, yy = 1;\n  y = 0;\n  x = 1;\n  while (b) {\n    T q = a / b, t = b;\n    b = a % b;\n    a = t;\n    t = xx;\n    xx = x - q * xx;\n    x = t;\n    t = yy;\n    yy = y - q * yy;\n    y = t;\n  }\n  return a;\n}\ntemplate <typename T>\nT mod_inverse(T a, T n = MOD) {\n  T x, y, z = 0;\n  T d = extended_euclid(a, n, x, y);\n  return (d > 1 ? -1 : sub(x, z, n));\n}\nconst long long FACSZ = 1e4;\nlong long fact[FACSZ], ifact[FACSZ];\nvoid precom(long long c = MOD) {\n  fact[0] = 1;\n  for (long long i = 1; i < FACSZ; i++) fact[i] = mul(fact[i - 1], i, c);\n  ifact[FACSZ - 1] = mod_inverse(fact[FACSZ - 1], c);\n  for (long long i = FACSZ - 1 - 1; i >= 0; i--) {\n    ifact[i] = mul(i + 1, ifact[i + 1], c);\n  }\n}\nvector<long long> primes;\nvoid prime_precom() {\n  primes.push_back(2);\n  for (long long x = 3; primes.size() <= MAXN; x += 2) {\n    bool isPrime = true;\n    for (auto p : primes) {\n      if (x % p == 0) {\n        isPrime = false;\n        break;\n      }\n      if (p * p > x) {\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(x);\n    }\n  }\n}\nlong long ncr(long long n, long long k) {\n  if (n < k) return 0;\n  if (k == 0) return 1;\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res *= (n - i);\n    res /= (i + 1);\n  }\n  return res;\n}\nlong long ncr_modp(long long n, long long k, long long c = MOD) {\n  if (n < k) return 0;\n  if (k == 0) return 1;\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res = mul(res, n - i, c);\n    res = mul(res, binpow2(i + 1, c - 2, c), c);\n  }\n  return res;\n}\nvector<long long> factors;\nvoid factorize(long long a) {\n  factors.clear();\n  for (long long i = 1; i * i <= a; i++) {\n    if (a % i == 0) {\n      factors.push_back(i);\n      factors.push_back(a / i);\n    }\n  }\n  sort(factors.begin(), factors.end());\n}\nlong long ncr_precom(long long n, long long r, long long c = MOD) {\n  return mul(mul(ifact[r], ifact[n - r], c), fact[n], c);\n}\nlong long ceil(long long a, long long b) { return (a + b - 1) / b; }\nbool is_prime(long long n) {\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\nbool diophantine_checker(long long a, long long b, long long n) {\n  for (long long i = 0; i * a <= n; i++) {\n    if ((n - (i * a)) % b == 0) {\n      return true;\n    }\n  }\n  return false;\n}\nlong long count_divisors(long long n) {\n  long long c;\n  long long ans = 1;\n  for (long long i = 2; i * i <= n; i++) {\n    c = 0;\n    while (n % i == 0) {\n      c++;\n      n /= i;\n    }\n    ans *= (c + 1);\n  }\n  if (n > 2) {\n    return ans * 2;\n  }\n  return ans;\n}\nstring to_binary(long long n) {\n  string r;\n  while (n != 0) {\n    r = (n % 2 == 0 ? \"0\" : \"1\") + r;\n    n /= 2;\n  }\n  return r;\n}\nbool ispower2(long long x) { return x && (!(x & (x - 1))); }\nunsigned long long mulmodBitwise(unsigned long long a, unsigned long long b,\n                                 unsigned long long p) {\n  a %= p;\n  b %= p;\n  if (a <= 0xFFFFFFF && b <= 0xFFFFFFF) {\n    return (a * b) % p;\n  }\n  if (b > a) {\n    swap(a, b);\n  }\n  unsigned long long result = 0;\n  while (a > 0 && b > 0) {\n    if (b & 1) {\n      result += a;\n      result %= p;\n    }\n    a <<= 1;\n    a %= p;\n    b >>= 1;\n  }\n  return result;\n}\nunsigned long long mulmod2(unsigned long long a, unsigned long long b,\n                           unsigned long long p) {\n  a %= p;\n  b %= p;\n  if (a <= 0xFFFFFFF && b <= 0xFFFFFFF) {\n    return (a * b) % p;\n  }\n  unsigned long long zeros = 0;\n  unsigned long long m = p;\n  while ((m & 0x8000000000000000ULL) == 0) {\n    zeros++;\n    m <<= 1;\n  }\n  unsigned long long mask = (1 << zeros) - 1;\n  unsigned long long result = 0;\n  while (a > 0 && b > 0) {\n    result += (b & mask) * a;\n    result %= p;\n    b >>= zeros;\n    a <<= zeros;\n    a %= p;\n  }\n  return result;\n}\nunsigned long long powmod(unsigned long long base, unsigned long long exponent,\n                          unsigned long long p) {\n  unsigned long long result = 1;\n  while (exponent > 0) {\n    if (exponent & 1) {\n      result = mulmod2(result, base, p);\n    }\n    base = mulmod2(base, base, p);\n    exponent >>= 1;\n  }\n  return result;\n}\nvector<long long> spf;\nvoid sieve() {\n  spf.resize(MAXN);\n  spf[1] = 1;\n  for (long long i = 2; i < MAXN; i++) {\n    spf[i] = i;\n  }\n  for (long long i = 4; i < MAXN; i += 2) {\n    spf[i] = 2;\n  }\n  for (long long i = 3; i * i <= MAXN; i++) {\n    if (spf[i] == i) {\n      for (long long j = i * i; j < MAXN; j += i) {\n        if (spf[j] == j) {\n          spf[j] = i;\n        }\n      }\n    }\n  }\n}\nvoid pfactor(long long x, vector<long long> &ret) {\n  while (x != 1) {\n    ret.push_back(spf[x]);\n    x = x / spf[x];\n  }\n}\nvoid solvethetestcase() {\n  long long n, m;\n  cin >> n >> m;\n  vector<long long> dp(n + 1, 0ll);\n  vector<long long> upd(n + 1, 0ll);\n  vector<long long> sm(n + 1, 0ll);\n  vector<long long> psum(n + 1, 0ll);\n  for (long long i = 1; i <= n; i++) {\n    sm[i] = sm[i - 1] + upd[i];\n    if (i == 1) {\n      dp[i] = 1ll;\n    } else {\n      dp[i] = add(psum[i - 1], sm[i], m);\n    }\n    psum[i] = add(psum[i - 1], dp[i], m);\n    for (long long j = 2; j * i <= n; j++) {\n      long long l = j * i;\n      long long r = j * (i + 1);\n      upd[l] = add(upd[l], dp[i], m);\n      if (r <= n) {\n        upd[r] = sub(upd[r], dp[i], m);\n      }\n    }\n  }\n  cout << dp[n] << \"\\n\";\n}\nsigned main() {\n  cout << fixed << setprecision(12);\n  ;\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  for (long long testcase = 1; testcase < t + 1; testcase++) {\n    solvethetestcase();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid Read(T &x) {\n  x = 0;\n  int _f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) _f = (ch == '-' ? -1 : _f), ch = getchar();\n  while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n  x = x * _f;\n}\ntemplate <typename T, typename... Args>\nvoid Read(T &x, Args &...others) {\n  Read(x);\n  Read(others...);\n}\nconst int N = 4e6 + 5;\nint n, Mod;\nlong long f[N], ps[N];\nint main() {\n  Read(n, Mod);\n  f[n] = ps[n] = 1;\n  for (int i = (n - 1); i >= (1); --i) {\n    for (int j = 2; i * j <= n; ++j) {\n      f[i] = (f[i] - ps[min(n, j * (i + 1) - 1) + 1] + ps[j * i]) % Mod;\n    }\n    f[i] = (f[i] + ps[i + 1]) % Mod;\n    ps[i] = (ps[i + 1] + f[i]) % Mod;\n  }\n  printf(\"%lld\\n\", (long long)f[1]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nll mod = 1e9 + 7;\nvoid solve() {\n  int n;\n  cin >> n >> mod;\n  vector<ll> a(n + 1);\n  a[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    if (i == 2) {\n      a[i] = 2;\n    } else {\n      a[i] = (a[i] + 2 * a[i - 1] + a[1]) % mod;\n    }\n    for (int j = 2 * i; j <= n; j += i) {\n      a[j] = (a[j] - a[i - 1] + a[i]) % mod;\n    }\n  }\n  if (a[n] < 0) {\n    a[n] += mod;\n  }\n  cout << a[n] << endl;\n  return;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  auto start = clock();\n  int t = 1;\n  for (int i = 0; i < t; i++) {\n    solve();\n  }\n  double used = (double)(clock() - start);\n  used = (used * 1000) / CLOCKS_PER_SEC;\n  cerr << fixed << setprecision(2) << used << \" ms\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\nconst int maxn = 8e6 + 5;\nLL n, mod, dp[maxn], sum[maxn];\nint main() {\n  cin >> n >> mod;\n  sum[n] = 1, dp[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    dp[i] = (dp[i] + sum[i + 1]) % mod;\n    for (int j = 2; i * j <= n; j++) {\n      dp[i] = (dp[i] + sum[i * j] - sum[(i + 1) * j]) % mod + mod;\n      dp[i] %= mod;\n    }\n    sum[i] = (dp[i] + sum[i + 1]) % mod;\n  }\n  cout << (dp[1] + mod) % mod << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from __future__ import division, print_function\nimport math\nimport sys\nimport os\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = \"x\" in file.mode or \"r\" not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b\"\\n\") + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\tself.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n\t\tself.read = lambda: self.buffer.read().decode(\"ascii\")\n\t\tself.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n\t\"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n\tsep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop(\"end\", \"\\n\"))\n\tif kwargs.pop(\"flush\", False):\n\t\tfile.flush()\n\n\nif sys.version_info[0] < 3:\n\tsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n\tsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input().strip()\n    return(list(s[:len(s)]))\ndef invr():\n    return(map(int,input().split()))\ndef Divisors(n) :\n    i = 1\n    fac=[]\n    while i <= int(math.sqrt(n)):\n         \n        if (n % i == 0) :\n            if (n // i == i) :\n                fac.append(i)\n            else :\n                fac.append(i)\n                fac.append(n//i)\n        i = i + 1\n    return fac\nn,maxn=invr()\ndp=[1 for i in range(n+1)]\ndp[0]=0\ndp[2]=0\nfor i in range(2,n+1):\n    dp[i]+=(2*dp[i-1])%maxn\n    for j in range(2*i,n+1,i):\n        dp[j]+=(dp[i]-dp[i-1])%maxn\n        dp[j]=dp[j]%maxn\n    dp[i]=dp[i]%maxn\nprint(dp[n])"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e6 + 10;\nlong long n, m;\nlong long dp[maxn];\nlong long pr[maxn];\nlong long dd[maxn];\nvoid solve() {\n  cin >> n >> m;\n  dp[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    dp[i] = (dp[i] + dp[i + 1]) % m;\n    for (int j = 2; i * j <= n; j++) {\n      long long o = min(n, 1LL * j * (i + 1) - 1);\n      long long d = dp[i * j];\n      if (o < n) d = (d - dp[j * (i + 1)] + m) % m;\n      dp[i] = (dp[i] + d) % m;\n    }\n    dp[i] = (dp[i] + dp[i + 1]) % m;\n  }\n  cout << (dp[1] - dp[2] + m) % m << endl;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e6 + 7, M = 100 + 7, K = 4;\nconst int MOD = 1e9 + 7;\nconst int oo = 1e9 + 7;\nint n, m, k, t;\nint _dp[N], p[N];\nint add(int a, int b) {\n  a += b;\n  if (a >= m) a -= m;\n  return a;\n}\nsigned main() {\n  scanf(\"%d%d\", &n, &m);\n  p[n] = _dp[n] = 1;\n  for (int i = n - 1; i > 0; i--) {\n    _dp[i] = p[i + 1];\n    for (int j = 2; j * i <= n; j++)\n      _dp[i] = add(_dp[i], add(p[i * j], m - p[min(n + 1, (i + 1) * j)]));\n    p[i] = add(p[i + 1], _dp[i]);\n  }\n  printf(\"%d\", _dp[1]);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class D {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n\n        solve(s.nextInt(), s.nextInt());\n    }\n\n\n    public static void solve(int n, long mod) {\n        long p[] = new long[n];\n        long divAdd[] = new long[n];\n        p[0] = 1;\n        long sum = 1;\n        long div = 0;\n\n        for (int i = 1; i < n; i++) {\n            div = (div + divAdd[i] + 1) % mod;\n\n            p[i] = (div + sum) % mod;\n\n            for (int j = i; j < n; j += i + 1) divAdd[j] = ((divAdd[j] + p[i] - p[i - 1]) % mod + mod) % mod;\n\n            sum = (sum + p[i]) % mod;\n        }\n\n        System.out.println(p[n - 1]);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long s = 0, w = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (ch <= '9' && ch >= '0') s = s * 10 + ch - '0', ch = getchar();\n  return s * w;\n}\nlong long n, mod, dp[4000005], sum[8000005];\nsigned main() {\n  n = read(), mod = read();\n  sum[n] = dp[n] = 1;\n  for (long long i = n - 1; i >= 1; i--) {\n    dp[i] = sum[i + 1];\n    for (long long j = n / i; j >= 2; j--)\n      dp[i] = (dp[i] + sum[i * j] - sum[i * j + j]) % mod;\n    sum[i] = (dp[i] + sum[i + 1]) % mod;\n  }\n  printf(\"%d\", (dp[1] + mod) % mod);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int P = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nconst int N = 4e6 + 10;\nconst double eps = 1e-8;\nint n, p;\nlong long f[N], g[N];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> p;\n  f[1] = 1;\n  for (int i = 2; i <= n; ++i) g[i] = 1;\n  for (int i = 2, s = 1; i <= n; ++i) {\n    g[i] = (g[i] + g[i - 1]) % p;\n    f[i] = (g[i] + s) % p;\n    s = (s + f[i]) % p;\n    for (int j = i * 2; j <= n; j += i) g[j] = (g[j] + f[i] - f[i - 1] + p) % p;\n  }\n  cout << f[n] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Ada{\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n        int m=sc.nextInt();\n        int dp[]=new int[n+1];\n        int pre[]=new int[n+1];\n        int prevSum=dp[1]=1;\n        for (int i=1;i<=n;i++){\n            if(i!=1) {\n                pre[i] = (pre[i - 1] + pre[i]) % m;\n                dp[i] = (prevSum + pre[i]) % m;\n                prevSum=(prevSum+dp[i])%m;\n            }\n            for (int p=2, j=2*i;j<=n; p++,j=p*i){\n                int r=j+p;\n                pre[j]=(pre[j]+dp[i])%m;\n                if(r<=n)pre[r]=((pre[r]-dp[i])%m+m)%m;\n            }\n        }\n        System.out.println(dp[n]);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e6 + 10;\nconst int inf = 0x3f3f3f3f;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst int mod = 998244353;\nconst int UP = 31500;\nconst double PI = acos(-1.0);\nconst double eps = -1e8;\nint f[N], sum[N];\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  ;\n  int n, mod;\n  cin >> n >> mod;\n  f[n] = 1;\n  sum[n + 1] = 0;\n  sum[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    f[i] = sum[i + 1];\n    for (int j = 2; (long long)i * j <= n; j++)\n      f[i] = (f[i] + (sum[i * j] - sum[min((i + 1) * j, n + 1)])) % mod;\n    f[i] = (f[i] + mod) % mod;\n    sum[i] = (sum[i + 1] + f[i]) % mod;\n  }\n  cout << f[1] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f;\nconst long long N = 4e6 + 10;\nlong long f[N];\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, P;\n  cin >> n >> P;\n  f[1] = 1;\n  for (long long i = 2; i <= n; i++) {\n    f[i] = (f[i] + 2 * f[i - 1] % P + (i != 2 ? f[1] : 0)) % P;\n    for (long long j = 2; j * i <= n; j++) {\n      f[j * i] = (f[j * i] + f[i] - f[i - 1] + P) % P;\n    }\n  }\n  cout << f[n] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\nc = [0] * (n-1) + [1, 0]\nfor i in range(n-1, 0, -1):\n    c[i-1] = 2*c[i] % m\n    for j in range(2, n//i + 1):\n        c[i-1] += c[i*j-1] - c[min(n, i*j-1 + j)]\n        c[i-1] %= m\n\nprint((c[0] - c[1]) % m)"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\ninput = stdin.readline\n\ndef add(x , y):return ((x%mod) + (y%mod))%mod\ndef sub(x , y):return (x - y + mod)%mod\n\n\ndef answer():\n\n    dp = [0]*(n + 1)\n    prefix = [0]*(n + 2)\n\n    dp[n] = 1\n\n    for i in range(n , 0 , -1):\n\n        dp[i] = add(dp[i] , prefix[i + 1])\n\n        j = 2\n        while(i*j <= n):\n\n            dp[i] = add(dp[i] , prefix[i*j])\n            if((j*i + j) <= n):dp[i] = sub(dp[i] , prefix[j*i + j])\n            j += 1\n\n            \n        prefix[i] = add(prefix[i + 1] , dp[i])\n\n    return dp[1]\n\n    \n    \n\nfor T in range(1):\n\n    n , mod = map(int,input().split())\n\n    print(answer())\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &x) {\n  T f = 1;\n  x = 0;\n  char ch = getchar();\n  while (0 == isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (0 != isdigit(ch)) x = (x << 1) + (x << 3) + ch - '0', ch = getchar();\n  x *= f;\n}\ntemplate <typename T>\ninline void write(T x) {\n  if (x < 0) {\n    x = ~(x - 1);\n    putchar('-');\n  }\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n}\nconst int inf = 0x3f3f3f3f;\nconst int N = 4e6 + 100;\nlong long dp[N], sum[N];\nint main() {\n  int n, mod;\n  read(n), read(mod);\n  dp[n] = 1;\n  for (int i = n; i >= 1; i--) {\n    dp[i] = (dp[i] + sum[i + 1]) % mod;\n    for (int p = 2;; p++) {\n      dp[i] = (dp[i] + sum[i * p] - sum[min(i * p + p, n + 1)] + mod) % mod;\n      if (1LL * p * i > n) {\n        break;\n      }\n    }\n    sum[i] = (sum[i + 1] + dp[i]) % mod;\n  }\n  cout << dp[1] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, mod;\nconst int nax = 4e6 + 5;\nint dp[nax];\nint pref[nax];\nvoid solve() {\n  cin >> n >> mod;\n  dp[n] = 1;\n  pref[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    dp[i] = pref[i + 1];\n    for (int mul = 2; mul * i <= n; mul++) {\n      int LO = i * mul;\n      int HI = min(n, LO + mul - 1);\n      long long int sum = pref[HI + 1] - pref[LO];\n      sum %= mod;\n      dp[i] -= sum;\n      dp[i] %= mod;\n    }\n    pref[i] = pref[i + 1] + dp[i];\n    pref[i] %= mod;\n  }\n  cout << dp[1];\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int tt = 1;\n  while (tt--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        solve(in, out);\n        out.close();\n    }\n\n    static String reverse(String s) {\n        return (new StringBuilder(s)).reverse().toString();\n    }\n\n    static void sieveOfEratosthenes(int n, int factors[], ArrayList<Integer> ar) \n    { \n        factors[1]=1;\n        int p;\n        for(p = 2; p*p <=n; p++) \n        { \n            if(factors[p] == 0) \n            { \n                ar.add(p);\n                factors[p]=p;\n                for(int i = p*p; i <= n; i += p) \n                    if(factors[i]==0)\n                        factors[i] = p; \n            } \n        } \n        for(;p<=n;p++){\n            if(factors[p] == 0) \n            { \n                factors[p] = p;\n                ar.add(p);\n            } \n        }\n    }\n\n    static void sort(int ar[]) {\n        int n = ar.length;\n        ArrayList<Integer> a = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            a.add(ar[i]);\n        Collections.sort(a);\n        for (int i = 0; i < n; i++)\n            ar[i] = a.get(i);\n    }\n\n    static void sort1(long ar[]) {\n        int n = ar.length;\n        ArrayList<Long> a = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            a.add(ar[i]);\n        Collections.sort(a);\n        for (int i = 0; i < n; i++)\n            ar[i] = a.get(i);\n    }\n\n    static void sort2(char ar[]) {\n        int n = ar.length;\n        ArrayList<Character> a = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            a.add(ar[i]);\n        Collections.sort(a);\n        for (int i = 0; i < n; i++)\n            ar[i] = a.get(i);\n    }\n\n    static long ncr(long n, long r, long mod) {\n        if (r == 0)\n            return 1;\n        long val = ncr(n - 1, r - 1, mod);\n        val = (n * val) % mod;\n        val = (val * modInverse(r, mod)) % mod;\n        return val;\n    }\n\n    static long sum[];\n    static long lz[];\n    \n    static void build(long a[], int v, int tl, int tr) {\n        if (tl == tr) {\n            sum[v] = a[tl];\n            \n        } else {\n            int tm = (tl + tr) / 2;\n            build(a, v*2, tl, tm);\n            build(a, v*2+1, tm+1, tr);\n            sum[v] = sum[v*2] + sum[v*2+1];\n        }\n    }\n\n    static void push(int v, int tl, int tr){\n        if(tl==tr){\n            lz[v] = 0;\n            return;\n        }\n        sum[2*v] += lz[v];\n        sum[2*v] %= m;\n        sum[2*v+1] += lz[v];\n        sum[2*v+1] %= m;\n        lz[2*v] += lz[v];\n        lz[2*v] %= m;\n        lz[2*v+1] += lz[v];\n        lz[2*v+1] %= m;\n        lz[v] = 0;\n    }\n\n    static void update(int v, int tl, int tr, int l, int r, long val) {\n        push(v,tl,tr);\n        if(tl>r||tr<l)\n            return;\n        if(tl>=l&&tr<=r){\n            sum[v] += val;\n            sum[v] %= m;\n            lz[v] += val;\n            lz[v] %= m;\n            return;\n        }\n        int tm = ((tl + tr) >> 1);\n        update(v*2, tl, tm, l, r, val);\n        update(v*2+1, tm+1, tr, l, r, val);\n        sum[v] = sum[2*v]+sum[2*v+1];\n        sum[v] %= m;\n    }\n\n    static long get(int v, int tl, int tr, int l, int r) {\n        push(v,tl,tr);\n        if (tl >= l && tr <= r) {\n            return sum[v];\n        }\n        int tm = ((tl + tr) >> 1);\n        if(l>tm){\n            return get(2*v+1, tm+1, tr, l, r);\n        }\n        if(r<tm+1){\n            return get(2*v, tl, tm, l, r);\n        }\n        return (get(2*v, tl, tm, l, r) + get(2*v+1, tm+1, tr, l, r)) % m;\n    }\n\n    // static int y = 0;\n\n    static int parent[];\n    static int rank[];\n\n    static long m = 0;\n\n    static int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return find_set(parent[v]);\n    }\n    \n    static void make_set(int v) {\n        parent[v] = v;\n        rank[v] = 0;\n    }\n    \n    static void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a != b) {\n            if (rank[a] < rank[b]){\n                int tmp = a;\n                a = b;\n                b = tmp;\n            }\n            parent[b] = a;\n            if (rank[a] == rank[b])\n                rank[a]++;\n        }\n    }\n\n    static int parent1[];\n    static int rank1[];\n\n    static int find_set1(int v) {\n        if (v == parent1[v])\n            return v;\n        return find_set1(parent1[v]);\n    }\n    \n    static void make_set1(int v) {\n        parent1[v] = v;\n        rank1[v] = 0;\n    }\n    \n    static void union_sets1(int a, int b) {\n        a = find_set1(a);\n        b = find_set1(b);\n        if (a != b) {\n            if (rank1[a] < rank1[b]){\n                int tmp = a;\n                a = b;\n                b = tmp;\n            }\n            parent1[b] = a;\n            if (rank1[a] == rank1[b])\n                rank1[a]++;\n        }\n    }\n\n    public static void solve(InputReader sc, PrintWriter pw){\n        int i, j = 0;\n        int t = 1; \n        long mod = 1000000007;\n        // int t = sc.nextInt();\n        u: while (t-- > 0) {\n            int n = sc.nextInt();\n            m = sc.nextInt();\n            // sum = new long[4*n];\n            // lz = new long[4*n];\n            // update(1, 1, n, 1, 1, 1);\n            // for(i=1;i<=n;i++){\n            //     long y = 0;\n            //     if(i>1)\n            //         y = get(1, 1, n, 1, i-1);\n            //     // pw.println(y);\n            //     update(1, 1, n, i, i, y);\n            //     // pw.println(i+\" \"+get(1, 1, n, i, i));\n            //     y = get(1, 1, n, i, i);\n            //     for(j=2;j*i<=n;j++){\n            //         int l = j*i;\n            //         int r = j*(i+1)-1;\n            //         r = Math.min(r,n);\n            //         // pw.println(j+\" \"+l+\"  \"+r);\n            //         update(1, 1, n, l, r, y);\n            //     }\n            // }\n            long diff[] = new long[n+2];\n            long dp[] = new long[n+1];\n            dp[1] = 1;\n            long sum = 0;\n            long currdiff = 0;\n            for(i=1;i<=n;i++){\n                currdiff += diff[i];\n                dp[i] += currdiff + sum;\n                dp[i] %= m;\n                sum += dp[i];\n                sum %= m;\n                // pw.println(y);\n                // update(1, 1, n, i, i, y);\n                // pw.println(i+\" \"+get(1, 1, n, i, i));\n                // y = get(1, 1, n, i, i);\n                for(j=2;j*i<=n;j++){\n                    int l = j*i;\n                    int r = j*(i+1)-1;\n                    r = Math.min(r,n);\n                    // pw.println(j+\" \"+l+\"  \"+r);\n                    diff[l] += dp[i];\n                    diff[r+1] -= dp[i];\n                    diff[l] %= m;\n                    if(diff[r+1]<0)\n                        diff[r+1] = (diff[r+1]+m);\n                }\n            }\n            pw.println(dp[n]);\n        }\n    }\n\n\n    static void KMPSearch(char pat[], char txt[], int pres[])\n    {\n        int M = pat.length;\n        int N = txt.length;\n        int lps[] = new int[M];\n        int j = 0; \n        computeLPSArray(pat, M, lps);\n        int i = 0;\n        while (i < N) {\n            if (pat[j] == txt[i]) {\n                j++;\n                i++;\n            }\n            if (j == M) {\n                pres[i-1] = 1;\n                j = lps[j - 1];\n            }\n            else if (i < N && pat[j] != txt[i]) {\n                if (j != 0)\n                    j = lps[j - 1];\n                else\n                    i = i + 1;\n            }\n        }\n    }\n  \n    static void computeLPSArray(char pat[], int M, int lps[])\n    {\n        int len = 0;\n        int i = 1;\n        lps[0] = 0; \n        while (i < M) {\n            if (pat[i] == pat[len]) {\n                len++;\n                lps[i] = len;\n                i++;\n            }\n            else \n            {\n                if (len != 0) {\n                    len = lps[len - 1];\n                }\n                else\n                {\n                    lps[i] = len;\n                    i++;\n                }\n            }\n        }\n    }\n\n    static long[][] matrixMult(long a[][], long b[][], long mod){\n        int n = a.length;\n        int m = a[0].length;\n        int p = b[0].length;\n        long c[][] = new long[n][p];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                for(int k=0;k<p;k++){\n                    c[i][k] += a[i][j]*b[j][k];\n                    c[i][k] %= mod;\n                }\n            }\n        }\n        return c;\n    }\n\n    static long[][] exp(long mat[][], long b, long mod){\n        if(b==0){\n            int n = mat.length;\n            long res[][] = new long[n][n];\n            for(int i=0;i<n;i++){\n                res[i][i] = 1;\n            }\n            return res;\n        }\n        long half[][] = exp(mat, b/2, mod);\n        long res[][] = matrixMult(half, half, mod);\n        if(b%2==1){\n            res = matrixMult(res, mat, mod);\n        }\n        return res;\n    }\n\n    static void countPrimeFactors(int num, int a[], HashMap<Integer,Integer> pos){\n        for(int i=2;i*i<num;i++){\n            if(num%i==0){\n                int y = pos.get(i);\n                while(num%i==0){\n                    a[y]++;\n                    num/=i;\n                }\n            }\n        }\n        if(num>1){\n            int y = pos.get(num);\n            a[y]++;\n        }\n    }\n\n    static void assignAnc(ArrayList<Integer> ar[], int depth[], int sz[], int par[][] ,int curr, int parent, int d){\n        depth[curr] = d;\n        sz[curr] = 1;\n        par[curr][0] = parent;\n        for(int v:ar[curr]){\n            if(parent==v)\n                continue;\n            assignAnc(ar, depth, sz, par, v, curr, d+1);\n            sz[curr] += sz[v];\n        }\n    }\n\n    static int findLCA(int a, int b, int par[][], int depth[]){\n        if(depth[a]>depth[b]){\n            a = a^b;\n            b = a^b;\n            a = a^b;\n        }\n        int diff = depth[b] - depth[a];\n        for(int i=19;i>=0;i--){\n            if((diff&(1<<i))>0){\n                b = par[b][i];\n            }\n        }\n        if(a==b)\n            return a;\n        for(int i=19;i>=0;i--){\n            if(par[b][i]!=par[a][i]){\n                b = par[b][i];\n                a = par[a][i];\n            }\n        }\n        return par[a][0];\n    }\n\n    static void formArrayForBinaryLifting(int n, int par[][]){\n        for(int j=1;j<20;j++){\n            for(int i=0;i<n;i++){\n                if(par[i][j-1]==-1)\n                    continue;\n                par[i][j] = par[par[i][j-1]][j-1];\n            }\n        }\n    }\n\n    static long lcm(int a, int b){\n        return a*b/gcd(a,b);\n    }\n\n    static class Pair1 {\n        long a;\n        long b;\n        \n        Pair1(long a, long b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int a;\n        int b;\n        // int c;\n        \n        Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n            // this.c = c;\n        }\n \n        public int compareTo(Pair p) {\n            // if(c!=p.c)\n            return a-p.a;\n            // return b-p.b;\n        }\n    }\n\n    static class Pair2 implements Comparable<Pair2> {\n        int a;\n        int b;\n        int c;\n        \n        Pair2(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n \n        public int compareTo(Pair2 p) {\n            return a-p.a;\n        }\n    }\n\n    static boolean isPrime(int n) { \n        if (n <= 1) \n            return false; \n        if (n <= 3) \n            return true; \n        if (n % 2 == 0 ||  n % 3 == 0) \n            return false; \n        for (int i = 5; i * i <= n; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n                return false; \n        return true; \n    } \n\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    static long fast_pow(long base, long n, long M) {\n        if (n == 0)\n            return 1;\n        if (n == 1)\n            return base % M;\n        long halfn = fast_pow(base, n / 2, M);\n        if (n % 2 == 0)\n            return (halfn * halfn) % M;\n        else\n            return (((halfn * halfn) % M) * base) % M;\n    }\n\n    static long modInverse(long n, long M) {\n        return fast_pow(n, M - 2, M);\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 9992768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n, m = map(int, input().split())\n    dp = [0] * (n + 1)\n    pre=[0]*(n+2)\n    su = 0\n    for i in range(1,n+1):\n        pre[i]= (pre[i]+pre[i-1])%m\n        dp[i] = (su+pre[i]+(i==1))%m\n        su = (su+dp[i]) % m\n        for j in range(2,n//i+1):\n            pre[i*j]=(pre[i*j]+dp[i])%m\n            z=min(i*j+j,n+1)\n            pre[z]=(pre[z]-dp[i])%m\n    print(dp[-1])\n\n\n# FASTIO REGION\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long t, n, m;\nlong long dp[5000000];\nlong long ans[5000000];\nlong long sum;\nint main() {\n  t = 1;\n  while (t--) {\n    int n;\n    cin >> n >> m;\n    dp[1] = 1;\n    sum = 0;\n    for (int i = 1; i <= n; i++) {\n      ans[i] += ans[i - 1];\n      ans[i] %= m;\n      dp[i] += (sum + ans[i]) % m;\n      for (long long j = 2; j * i <= n; j++) {\n        ans[i * j] += dp[i];\n        ans[i * j] %= m;\n        ans[min(i * j + j, n + 1ll)] += (m - dp[i]) % m;\n        ans[min(i * j + j, n + 1ll)] %= m;\n      }\n      sum = (sum + dp[i]) % m;\n    }\n    cout << dp[n] << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e6 + 10;\nlong long f[N];\nlong long s[N];\nint main() {\n  int n, m;\n  cin >> n >> m;\n  f[n] = 1, s[n] = 1;\n  for (int i = n - 1; i; i--) {\n    f[i] = s[i + 1];\n    for (int j = 2; i * j <= n; j++) {\n      int l = i * j;\n      int r = min(n, j * (i + 1) - 1);\n      f[i] = (f[i] + s[l] - s[r + 1] + m) % m;\n    }\n    s[i] = (s[i + 1] + f[i]) % m;\n  }\n  cout << f[1] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing cd = complex<double>;\nconst double PI = acos(-1);\nconst int N = 4e6 + 10;\nint d[N], ans[N], sum[N];\nint MOD;\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n}\nvoid sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += MOD;\n}\nvoid solve() {\n  int n;\n  cin >> n >> MOD;\n  ans[1] = 1;\n  for (int i = 2; i <= n; i++) d[i] = 1;\n  sum[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    add(d[i], d[i - 1]);\n    add(ans[i], (d[i] + sum[i - 1]) % MOD);\n    for (int j = i + i; j <= n; j += i) {\n      sub(d[j], ans[i - 1]);\n      add(d[j], ans[i]);\n    }\n    sum[i] = (sum[i - 1] + ans[i]) % MOD;\n  }\n  cout << ans[n] << \"\\n\";\n}\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n  int tc = 1;\n  int t;\n  t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long i, j, p, q, n, m, k, dp[4000006], sum, g, dpp[4000006];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> m;\n  dp[1] = 1;\n  sum = 1;\n  for (i = 2; i <= n; i++) dpp[i] += 1;\n  dp[2] = 2;\n  dpp[2] = 1;\n  for (i = 4; i <= n; i += 2) dpp[i]++;\n  sum = 3;\n  for (i = 3; i <= n; i++) {\n    dp[i] = sum;\n    dp[i] %= m;\n    dpp[i] += dpp[i - 1];\n    dpp[i] %= m;\n    dp[i] = dpp[i] + dp[i];\n    dp[i] %= m;\n    for (j = i * 2; j <= n; j += i) {\n      dpp[j] += dp[i] - dp[i - 1];\n      if (dpp[j] < 0) dpp[j] += m;\n      dpp[j] %= m;\n    }\n    sum += dp[i];\n    sum %= m;\n  }\n  cout << dp[n] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long psa[4000101];\nlong long ans[4000101];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  long long m;\n  cin >> m;\n  ans[n] = 1;\n  psa[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    ans[i] += (psa[i + 1] % m);\n    for (int j = 2; j <= n; j++) {\n      if (j * i > n) break;\n      ans[i] += (psa[j * i] - psa[min(n + 1, j * i + j)]) % m;\n    }\n    psa[i] = (psa[i + 1] + ans[i]) % m;\n  }\n  cout << ans[1] % m << \"\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class D1 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner s = new Scanner(System.in);\n\t\t\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\t\n\t\tlong[] dp = new long[n+10];\n\t\tlong[] ddp = new long[n+10];\n\t\tlong sum = 0;\n\t\t\n\t\tdp[1] = 1;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\t\t\n\t\t\tddp[i] = (ddp[i-1] + ddp[i]) % m;\n\t\t\tdp[i] = (dp[i] + ddp[i] + sum) % m;\t\t\t\n\t\t\tsum = (sum + dp[i]) % m;\n\t\t\t//System.out.println(dp[i] + \" \" + ddp[i] + \" \" + (sum-dp[i]));\n\t\t\t\n\t\t\tfor(int j = 2; j*i <= n; j++) {\n\t\t\t\t\n\t\t\t\tddp[j*i] = (ddp[j*i] + dp[i]) % m;\n\t\t\t\t\n\t\t\t\t//System.out.println(ddp[i*j] + \" \" + i*j);\n\t\t\t\t\n\t\t\t\tif(j*i+j <= n) {\n\t\t\t\t\tddp[j*i+j] = (ddp[j*i+j] - dp[i]) % m;\n\t\t\t\t\tif(ddp[j*i+j] < 0)\n\t\t\t\t\t\tddp[j*i+j] += m;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\t\n\t\t/*for(int i = 1; i <= n; i++)\n\t\t\tSystem.out.print(dp[i] + \" \");\n\t\tSystem.out.println();\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tSystem.out.print(ddp[i] + \" \");*/\n\t\t\n\t\tSystem.out.println(dp[n]);\n\t\t\t\t\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Practice {\n//\tpublic static long mod = (long) Math.pow(10, 9) + 7;\n//\tpublic static long mod2 = 998244353;\n//\tpublic static int tt = 1;\n//\tpublic static ArrayList<Integer> prime;\n//\tpublic static long[] fac = new long[200005];\n//\tpublic static long[] invfac = new long[200005];\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// int t = Integer.parseInt(br.readLine());\n\t\t// while (t-- > 0) {\n\t\tString[] s1 = br.readLine().split(\" \");\n\t\tint n = Integer.valueOf(s1[0]);\n\t\tlong m = Integer.valueOf(s1[1]);\n\t\tlong[] arr = new long[n + 1];\n\t\tarr[n] = 1;\n\t\tlong sum = 0;\n\t\tfor (int i = n - 1; i >= 1; i--) {\n\t\t\tint cu = 2;\n\t\t\tfor (int j = 2 * i; j <= n; j += i) {\n\t\t\t\tif (j + cu > n) {\n\t\t\t\t\tarr[i] = (arr[j] + arr[i]) % m;\n\t\t\t\t} else {\n\t\t\t\t\tarr[i] = (m - arr[j + cu] + arr[j] + arr[i]) % m;\n\t\t\t\t}\n\t\t\t\tcu++;\n\t\t\t\t// System.out.println(\"**************\");\n\t\t\t}\n\t\t\t// System.out.println(i + \" \" + arr[i]);\n\n\t\t\tarr[i] = (arr[i + 1] + arr[i + 1] + arr[i]) % m;\n\n\t\t\t// System.out.println(arr[i]);\n\t\t}\n\t\tpw.println((arr[1] + m - arr[2]) % m);\n\t\t// }\n\t\tpw.close();\n\t}\n\n//\n//\tprivate static long power(long a, long p) {\n//\t\t// TODO Auto-generated method stub\n//\t\tlong res = 1;\n//\t\twhile (p > 0) {\n//\t\t\tif (p % 2 == 1) {\n//\t\t\t\tres = (res * a) % mod;\n//\t\t\t}\n//\t\t\tp = p / 2;\n//\t\t\ta = (a * a) % mod;\n//\t\t}\n//\t\treturn res;\n//\t}\n\n\t// private static int kmp(String str) {\n//\t\t// TODO Auto-generated method stub\n//\t\t// System.out.println(str);\n//\t\tint[] pi = new int[str.length()];\n//\t\tpi[0] = 0;\n//\t\tfor (int i = 1; i < str.length(); i++) {\n//\t\t\tint j = pi[i - 1];\n//\t\t\twhile (j > 0 && str.charAt(i) != str.charAt(j)) {\n//\t\t\t\tj = pi[j - 1];\n//\t\t\t}\n//\t\t\tif (str.charAt(j) == str.charAt(i)) {\n//\t\t\t\tj++;\n//\t\t\t}\n//\t\t\tpi[i] = j;\n//\t\t\tSystem.out.print(pi[i]);\n//\t\t}\n//\t\tSystem.out.println();\n//\t\treturn pi[str.length() - 1];\n//\t}\n\n}\n\n//\tprivate static void getFac(long n, PrintWriter pw) {\n//\t\t// TODO Auto-generated method stub\n//\t\tint a = 0;\n//\t\twhile (n % 2 == 0) {\n//\t\t\ta++;\n//\t\t\tn = n / 2;\n//\t\t}\n//\t\tif (n == 1) {\n//\t\t\ta--;\n//\t\t}\n//\t\tfor (int i = 3; i <= Math.sqrt(n); i += 2) {\n//\t\t\twhile (n % i == 0) {\n//\t\t\t\tn = n / i;\n//\t\t\t\ta++;\n//\t\t\t}\n//\t\t}\n//\t\tif (n > 1) {\n//\t\t\ta++;\n//\t\t}\n//\t\tif (a % 2 == 0) {\n//\t\t\tpw.println(\"Bob\");\n//\t\t} else {\n//\t\t\tpw.println(\"Alice\");\n//\t\t}\n//\t\t//System.out.println(a);\n//\t\treturn;\n//\t}\n\n//\tprivate static long power(long a, long p) {\n//\t\t// TODO Auto-generated method stub\n//\t\tlong res = 1;\n//\t\twhile (p > 0) {\n//\t\t\tif (p % 2 == 1) {\n//\t\t\t\tres = (res * a) % mod;\n//\t\t\t}\n//\t\t\tp = p / 2;\n//\t\t\ta = (a * a) % mod;\n//\t\t}\n//\t\treturn res;\n//\t}\n//\n//\tprivate static void fac() {\n//\t\tfac[0] = 1;\n//\t\t// TODO Auto-generated method stub\n//\t\tfor (int i = 1; i < fac.length; i++) {\n//\t\t\tif (i == 1) {\n//\t\t\t\tfac[i] = 1;\n//\t\t\t} else {\n//\t\t\t\tfac[i] = i * fac[i - 1];\n//\t\t\t}\n//\t\t\tif (fac[i] > mod) {\n//\t\t\t\tfac[i] = fac[i] % mod;\n//\t\t\t}\n//\t\t}\n//\t}\n//\n//\tprivate static int getLower(Long long1, Long[] st) {\n//\t\t// TODO Auto-generated method stub\n//\t\tint left = 0, right = st.length - 1;\n//\t\tint ans = -1;\n//\t\twhile (left <= right) {\n//\t\t\tint mid = (left + right) / 2;\n//\t\t\tif (st[mid] <= long1) {\n//\t\t\t\tans = mid;\n//\t\t\t\tleft = mid + 1;\n//\t\t\t} else {\n//\t\t\t\tright = mid - 1;\n//\t\t\t}\n//\t\t}\n//\t\treturn ans;\n//\t}\n\n//private static long getGCD(long l, long m) {\n//\n//\tlong t1 = Math.min(l, m);\n//\tlong t2 = Math.max(l, m);\n//\tif (t1 == 0) {\n//\t\treturn t2;\n//\t}\n//\twhile (true) {\n//\t\tlong temp = t2 % t1;\n//\t\tif (temp == 0) {\n//\t\t\treturn t1;\n//\t\t}\n//\t\tt2 = t1;\n//\t\tt1 = temp;\n//\t}\n//}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e6 + 5;\nlong long f[maxn] = {};\nint main() {\n  int q = 1;\n  while (q--) {\n    long long n, m;\n    cin >> n >> m;\n    f[1] = 1;\n    f[2] = 2;\n    for (int i = 2; i <= n; i++) {\n      if (i == 2)\n        f[i] = 2;\n      else\n        f[i] = (f[i] + 2 * f[i - 1] + 1) % m;\n      long long x = f[i] - f[i - 1];\n      for (int j = i * 2; j <= n; j += i) f[j] = (f[j] + x) % m;\n    }\n    cout << (f[n] % m + m) % m << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid REV(T *a, int n) {\n  reverse(a + 1, a + 1 + n);\n}\ntemplate <class T>\nvoid SRT(T *a, int n) {\n  sort(a + 1, a + 1 + n);\n}\ntemplate <class T>\nint UNI(T *a, int n) {\n  sort(a + 1, a + 1 + n);\n  return unique(a + 1, a + 1 + n) - (a + 1);\n}\ntemplate <class T>\nint POS(T *a, int n, T v) {\n  return lower_bound(a + 1, a + 1 + n, v) - a;\n}\ntemplate <class T>\nint fisrtGe(T *a, int n, T v) {\n  return lower_bound(a + 1, a + 1 + n, v) - a;\n}\ntemplate <class T>\nint lastLe(T *a, int n, T v) {\n  return upper_bound(a + 1, a + 1 + n, v) - a - 1;\n}\ntemplate <class T>\nvoid _RD(T &x) {\n  cin >> x;\n}\nvoid _RD(int &x) { scanf(\"%d\", &x); }\nvoid _RD(unsigned int &x) { scanf(\"%u\", &x); }\nvoid _RD(long long &x) { scanf(\"%lld\", &x); }\nvoid _RD(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid _RD(double &x) { scanf(\"%lf\", &x); }\nvoid _RD(char &x) { scanf(\" %c\", &x); }\nvoid _RD(char *x) { scanf(\"%s\", x + 1); }\ntemplate <class T, class U>\nvoid _RD(pair<T, U> &x) {\n  _RD(x.first);\n  _RD(x.second);\n}\nvoid RD() {}\ntemplate <class T, class... U>\nvoid RD(T &head, U &...tail) {\n  _RD(head);\n  RD(tail...);\n}\ntemplate <class T>\nvoid RDN(T *a, int n) {\n  for (int i = 1; i <= n; ++i) _RD(a[i]);\n}\ntemplate <class T>\nvoid _WT(const T &x) {\n  cout << x;\n}\nvoid _WT(const int &x) { printf(\"%d\", x); }\nvoid _WT(const unsigned int &x) { printf(\"%u\", x); }\nvoid _WT(const long long &x) { printf(\"%lld\", x); }\nvoid _WT(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid _WT(const double &x) { printf(\"%.12f\", x); }\nvoid _WT(const char &x) { putchar(x); }\nvoid _WT(const char *x) { printf(\"%s\", x + 1); }\ntemplate <class T, class U>\nvoid _WT(const pair<T, U> &x) {\n  _WT(x.first);\n  putchar(' ');\n  _WT(x.second);\n}\nvoid WT() {}\ntemplate <class T, class... U>\nvoid WT(const T &head, const U &...tail) {\n  _WT(head);\n  putchar(sizeof...(tail) ? ' ' : '\\n');\n  WT(tail...);\n}\ntemplate <class T>\nvoid WTN(T *a, int n) {\n  for (int i = 1; i <= n; ++i) {\n    _WT(a[i]);\n    putchar(\" \\n\"[i == n]);\n  }\n}\ntemplate <class T>\nvoid WTV(const vector<T> &x, bool ln = false) {\n  WT(x.size());\n  for (auto i = x.begin(); i != x.end(); ++i) {\n    _WT(*i);\n    putchar(ln ? '\\n' : ' ');\n  }\n  if (!ln) putchar('\\n');\n}\ntemplate <typename T>\nvoid cmin(T &x, T y) {\n  if (y < x) x = y;\n}\ntemplate <typename T>\nvoid cmax(T &x, T y) {\n  if (y > x) x = y;\n}\nunsigned int rnd_seed = chrono::duration_cast<chrono::nanoseconds>(\n                            chrono::steady_clock::now().time_since_epoch())\n                            .count();\nmt19937 rnd(rnd_seed);\nconst int INF = 0x3F3F3F3F;\nconst long long LINF = 0x3F3F3F3F3F3F3F3FLL;\nint MOD = 998244353;\nstruct ModularIntegers {\n  int num;\n  ModularIntegers() { num = 0; }\n  template <typename T>\n  ModularIntegers(const T &x) {\n    long long tmp = x;\n    if (tmp >= MOD) {\n      if (tmp < (MOD << 1))\n        tmp -= MOD;\n      else\n        tmp %= MOD;\n    } else if (tmp < 0) {\n      if (tmp >= -MOD)\n        tmp += MOD;\n      else if (tmp %= MOD)\n        tmp += MOD;\n    }\n    num = tmp;\n  }\n  friend ModularIntegers operator+(const ModularIntegers &x,\n                                   const ModularIntegers &y) {\n    return x.num + y.num;\n  }\n  friend ModularIntegers operator-(const ModularIntegers &x,\n                                   const ModularIntegers &y) {\n    return x.num - y.num;\n  }\n  friend ModularIntegers operator*(const ModularIntegers &x,\n                                   const ModularIntegers &y) {\n    return x.num * y.num;\n  }\n  friend ModularIntegers operator/(const ModularIntegers &x,\n                                   const ModularIntegers &y) {\n    return x * y.inv();\n  }\n  friend bool operator==(const ModularIntegers &x, const ModularIntegers &y) {\n    return x.num == y.num;\n  }\n  friend bool operator!=(const ModularIntegers &x, const ModularIntegers &y) {\n    return x.num != y.num;\n  }\n  ModularIntegers operator+() { return +this->num; }\n  ModularIntegers operator-() { return -this->num; }\n  ModularIntegers &operator+=(const ModularIntegers &x) {\n    if ((this->num += x.num) >= MOD) this->num -= MOD;\n    return *this;\n  }\n  ModularIntegers &operator-=(const ModularIntegers &x) {\n    if ((this->num -= x.num) < 0) this->num += MOD;\n    return *this;\n  }\n  ModularIntegers &operator*=(const ModularIntegers &x) {\n    this->num = 1LL * this->num * x.num % MOD;\n    return *this;\n  }\n  ModularIntegers &operator/=(const ModularIntegers &x) {\n    this->num = ((*this) * x.inv()).num;\n    return *this;\n  }\n  ModularIntegers pow(long long x) const {\n    ModularIntegers res(1), cur(this->num);\n    for (; x; cur *= cur, x >>= 1)\n      if (x & 1) res *= cur;\n    return res;\n  }\n  ModularIntegers inv() const { return pow(MOD - 2); }\n  operator int() { return num; }\n  operator unsigned int() { return num; }\n  operator long long() { return num; }\n  operator unsigned long long() { return num; }\n};\nvoid _RD(ModularIntegers &x) { scanf(\"%d\", &x.num); }\nvoid _WT(const ModularIntegers &x) { printf(\"%d\", x.num); }\nint n;\nModularIntegers tag[4000005];\nvoid purin_solve() {\n  RD(n, MOD);\n  ModularIntegers pfi = 0;\n  ModularIntegers ptag = 0;\n  ModularIntegers ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    ptag += tag[i];\n    ModularIntegers fi = ptag + pfi;\n    if (i == 1) fi = 1;\n    for (int z = 2;; ++z) {\n      int L = z * i;\n      if (L > n) break;\n      int R = min(n + 1, z * (i + 1));\n      tag[L] += fi;\n      tag[R] -= fi;\n    }\n    pfi += fi;\n    ans = fi;\n  }\n  WT(ans);\n}\nint main() {\n  cout << fixed << setprecision(12);\n  cerr << fixed << setprecision(12);\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t = 1;\n  while (t--) purin_solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e6 + 10;\nlong long f[maxn];\nint mod = 998244353;\nlong long g[maxn];\nint main() {\n  f[1] = 1, f[2] = 2;\n  int n;\n  cin >> n >> mod;\n  for (int i = 2; i <= n; i++) {\n    if (i != 2) f[i] = (f[i - 1] * 2 % mod + 1 + g[i]) % mod;\n    for (int j = 2; i * j <= n; j++) {\n      g[i * j] = (g[i * j] + f[i] - f[i - 1] + mod) % mod;\n    }\n  }\n  cout << f[n] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long T;\nlong long n, mod;\nlong long C[4000005];\nlong long dp[4000005];\nlong long sum = 0;\nsigned main() {\n  cin >> n >> mod;\n  dp[n] = 1;\n  C[n] = 1;\n  for (long long i = n - 1; i >= 1; i--) {\n    dp[i] = C[i + 1];\n    for (long long j = 2; j * i <= n; j++) {\n      long long dn = i * j, up = min(n, (i + 1) * j - 1);\n      dp[i] = (dp[i] + (C[dn] - C[up + 1] + mod) % mod) % mod;\n    }\n    C[i] = (C[i + 1] + dp[i]) % mod;\n  }\n  cout << dp[1] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"unroll-loops\")\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::make_pair;\nusing std::pair;\nconst int N = 4e6 + 10;\nint n, p;\nint f[N], pre[N];\nint c[N];\nvoid calc(int u) {\n  for (int i = 2; i * u <= n; ++i) {\n    c[i * u] = (c[i * u] + f[u] >= p ? c[i * u] + f[u] - p : c[i * u] + f[u]);\n    c[std::min(i * (u + 1) - 1, n) + 1] =\n        (c[std::min(i * (u + 1) - 1, n) + 1] + p - f[u] >= p\n             ? c[std::min(i * (u + 1) - 1, n) + 1] + p - f[u] - p\n             : c[std::min(i * (u + 1) - 1, n) + 1] + p - f[u]);\n  }\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  cout.tie(0);\n  cin >> n >> p;\n  f[1] = 1;\n  pre[1] = 1;\n  for (int i = (2); i <= (n); ++i) {\n    calc(i - 1);\n    c[i] = (c[i] + c[i - 1] >= p ? c[i] + c[i - 1] - p : c[i] + c[i - 1]);\n    f[i] = (c[i] + pre[i - 1]) % p;\n    pre[i] = pre[i - 1];\n    pre[i] = (pre[i] + f[i] >= p ? pre[i] + f[i] - p : pre[i] + f[i]);\n  }\n  cout << (f[n] + p) % p << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring int_to_string(long long n) {\n  string s = \"\";\n  while (n) {\n    long long now = n % 10;\n    s += now + '0';\n    n /= 10;\n  }\n  reverse(s.begin(), s.end());\n  return s;\n}\nlong long string_to_int(string s) {\n  long long n = 0;\n  for (int i = 0; i < (int)(s.size()); i++) {\n    n *= 10;\n    n += s[i] - '0';\n  }\n  return n;\n}\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int month[2][12] = {{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},\n                          {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}};\nint n, mod;\nlong long dp[4000020];\nlong long sum[8000020];\nvoid solve() {\n  cin >> n >> mod;\n  dp[n] = 1;\n  sum[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    dp[i] += sum[i + 1];\n    dp[i] %= mod;\n    for (int j = 2; j <= n / i; j++) {\n      dp[i] += (sum[i * j] + mod - sum[(i + 1) * j]) % mod;\n      dp[i] %= mod;\n    }\n    sum[i] = sum[i + 1] + dp[i];\n    sum[i] %= mod;\n  }\n  cout << dp[1] << endl;\n}\nsigned main() {\n  std::ios::sync_with_stdio(false);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint main() {\n  int h, i, j, k;\n  int t, n, m;\n  scanf(\"%d %d\", &n, &m);\n  int d[n + 1];\n  int sum[n + 1];\n  int div[n + 1];\n  int diff[n + 1];\n  d[1] = 1;\n  sum[1] = 0;\n  div[1] = 0;\n  for (i = 1; i <= n; i++) {\n    diff[i] = 1;\n  }\n  for (i = 2; i <= n; i++) {\n    div[i] = div[i - 1];\n    div[i] = (div[i - 1] + diff[i]) % m;\n    sum[i] = (sum[i - 1] + d[i - 1]) % m;\n    d[i] = (div[i] + sum[i]) % m;\n    for (j = i * 2; j <= n; j += i) {\n      diff[j] = ((long long)m + diff[j] + d[i] - d[i - 1]) % m;\n    }\n  }\n  printf(\"%d\\n\", d[n]);\n}\n"
        },
        {
            "language": 4,
            "solution": "//Utilities\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n\tstatic int n;\n\tstatic int M;\n\tstatic long[] dp, sum;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tn = in.iscan(); M = in.iscan(); dp = new long[n+1]; sum = new long[n+1];\n\t\tdp[n] = 1; sum[n] = 1;\n\t\tint y = 1;\n\t\tfor (int i = n-1; i >= 1; i--) {\n\t\t\tdp[i] = sum[i+1];\n\t\t\twhile (i * (y+1) <= n) {\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tint l, r;\n\t\t\tfor (int x = 2; x <= y; x++) {\n\t\t\t\tl = i * x;\n\t\t\t\tr = Math.min(n, i * x + x - 1);\n\t\t\t\tdp[i] = (dp[i] + sumRange(l, r)) % M;\n\t\t\t}\n\t\t\tsum[i] = (sum[i+1] + dp[i]) % M;\n\t\t}\n\t\tout.println(dp[1]);\n\t\tout.close();\n\t}\n\t\n\tstatic long sumRange(int l, int r) {\n\t\tif (r != n) {\n\t\t\treturn ((sum[l] - sum[r+1]) % M + M) % M;\n\t\t}\n\t\treturn sum[l];\n\t}\n\t\n\tstatic INPUT in = new INPUT(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tprivate static class INPUT {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar, numChars;\n\n\t\tpublic INPUT (InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic INPUT (String file) throws IOException {\n\t\t\tthis.stream = new FileInputStream (file);\n\t\t}\n\n\t\tpublic int cscan () throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read (buf);\n\t\t\t}\n\t\t\t\n\t\t\tif (numChars == -1)\n\t\t\t\treturn numChars;\n\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int iscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo {\n\t\t\t\tres = (res << 1) + (res << 3);\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String sscan () throws IOException {\n\t\t\tint c = cscan ();\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tStringBuilder res = new StringBuilder ();\n\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint (c);\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res.toString ();\n\t\t}\n\n\t\tpublic double dscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tdouble res = 0;\n\n\t\t\twhile (!space (c) && c != '.') {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * UTILITIES.fast_pow (10, iscan ());\n\t\t\t\t\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tif (c == '.') {\n\t\t\t\tc = cscan ();\n\t\t\t\tdouble m = 1;\n\n\t\t\t\twhile (!space (c)) {\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * UTILITIES.fast_pow (10, iscan ());\n\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = cscan ();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long lscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tlong res = 0;\n\n\t\t\tdo {\n\t\t\t\tres = (res << 1) + (res << 3);\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean space (int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n\tpublic static class UTILITIES {\n\n\t\tstatic final double EPS = 10e-6;\n\t\t\n\t\tpublic static void sort(int[] a, boolean increasing) {\n\t\t\tArrayList<Integer> arr = new ArrayList<Integer>();\n\t\t\tint n = a.length;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr.add(a[i]);\n\t\t\t}\n\t\t\tCollections.sort(arr);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (increasing) {\n\t\t\t\t\ta[i] = arr.get(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[i] = arr.get(n-1-i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static void sort(long[] a, boolean increasing) {\n\t\t\tArrayList<Long> arr = new ArrayList<Long>();\n\t\t\tint n = a.length;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr.add(a[i]);\n\t\t\t}\n\t\t\tCollections.sort(arr);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (increasing) {\n\t\t\t\t\ta[i] = arr.get(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[i] = arr.get(n-1-i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static void sort(double[] a, boolean increasing) {\n\t\t\tArrayList<Double> arr = new ArrayList<Double>();\n\t\t\tint n = a.length;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr.add(a[i]);\n\t\t\t}\n\t\t\tCollections.sort(arr);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (increasing) {\n\t\t\t\t\ta[i] = arr.get(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[i] = arr.get(n-1-i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic static int lower_bound (int[] arr, int x) {\n\t\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\n\t\t\t\tif (arr[mid] >= x)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse\n\t\t\t\t\tlow = mid + 1;\n\t\t\t}\n\n\t\t\treturn low;\n\t\t}\n\n\t\tpublic static int upper_bound (int[] arr, int x) {\n\t\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\n\t\t\t\tif (arr[mid] > x)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse\n\t\t\t\t\tlow = mid + 1;\n\t\t\t}\n\n\t\t\treturn low;\n\t\t}\n\t\t\n\t\tpublic static void updateMap(HashMap<Integer, Integer> map, int key, int v) {\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, v);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap.put(key, map.get(key) + v);\n\t\t\t}\n\t\t\tif (map.get(key) == 0) {\n\t\t\t\tmap.remove(key);\n\t\t\t}\n\t\t}\n\n\t\tpublic static long gcd (long a, long b) {\n\t\t\treturn b == 0 ? a : gcd (b, a % b);\n\t\t}\n\n\t\tpublic static long lcm (long a, long b) {\n\t\t\treturn a * b / gcd (a, b);\n\t\t}\n\n\t\tpublic static long fast_pow_mod (long b, long x, int mod) {\n\t\t\tif (x == 0) return 1;\n\t\t\tif (x == 1) return b;\n\t\t\tif (x % 2 == 0) return fast_pow_mod (b * b % mod, x / 2, mod) % mod;\n\n\t\t\treturn b * fast_pow_mod (b * b % mod, x / 2, mod) % mod;\n\t\t}\n\n\t\tpublic static int fast_pow (int b, int x) {\n\t\t\tif (x == 0) return 1;\n\t\t\tif (x == 1) return b;\n\t\t\tif (x % 2 == 0) return fast_pow (b * b, x / 2);\n\n\t\t\treturn b * fast_pow (b * b, x / 2);\n\t\t}\n\n\t\tpublic static long choose (long n, long k) {\n\t\t\tk = Math.min (k, n - k);\n\t\t\tlong val = 1;\n\n\t\t\tfor (int i = 0; i < k; ++i)\n\t\t\t\tval = val * (n - i) / (i + 1);\n\n\t\t\treturn val;\n\t\t}\n\n\t\tpublic static long permute (int n, int k) {\n\t\t\tif (n < k) return 0;\n\t\t\tlong val = 1;\n\n\t\t\tfor (int i = 0; i < k; ++i)\n\t\t\t\tval = (val * (n - i));\n\n\t\t\treturn val;\n\t\t}\n\t\t\n\t\t// start of permutation and lower/upper bound template\n\t\tpublic static void nextPermutation(int[] nums) {\n\t\t    //find first decreasing digit\n\t\t    int mark = -1;\n\t\t    for (int i = nums.length - 1; i > 0; i--) {\n\t\t        if (nums[i] > nums[i - 1]) {\n\t\t            mark = i - 1;\n\t\t            break;\n\t\t        }\n\t\t    }\n\t\t \n\t\t    if (mark == -1) {\n\t\t        reverse(nums, 0, nums.length - 1);\n\t\t        return;\n\t\t    }\n\t\t \n\t\t    int idx = nums.length-1;\n\t\t    for (int i = nums.length-1; i >= mark+1; i--) {\n\t\t        if (nums[i] > nums[mark]) {\n\t\t            idx = i;\n\t\t            break;\n\t\t        }\n\t\t    }\n\t\t \n\t\t    swap(nums, mark, idx);\n\t\t \n\t\t    reverse(nums, mark + 1, nums.length - 1);\n\t\t}\n\t\t \n\t\tpublic static void swap(int[] nums, int i, int j) {\n\t\t    int t = nums[i];\n\t\t    nums[i] = nums[j];\n\t\t    nums[j] = t;\n\t\t}\n\t\t \n\t\tpublic static void reverse(int[] nums, int i, int j) {\n\t\t    while (i < j) {\n\t\t        swap(nums, i, j);\n\t\t        i++;\n\t\t        j--;\n\t\t    }\n\t\t}\n\t\t\n\t\tstatic int lower_bound (int[] arr, int hi, int cmp) {\n\t\t\tint low = 0, high = hi, mid = -1;\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\t\t\t\tif (arr[mid] >= cmp) high = mid;\n\t\t\t\telse low = mid + 1;\n\t\t\t}\n\t\t\treturn low;\n\t\t}\n\t \n\t\tstatic int upper_bound (int[] arr, int hi, int cmp) {\n\t\t\tint low = 0, high = hi, mid = -1;\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\t\t\t\tif (arr[mid] > cmp) high = mid;\n\t\t\t\telse low = mid + 1;\n\t\t\t}\n\t\t\treturn low;\n\t\t}\n\t\t// end of permutation and lower/upper bound template\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 1000005;\nconst long long SQRTN = 1003;\nconst long long LOGN = 22;\nconst double PI = acos(-1);\nconst long long INF = 1e18;\nconst long long MOD = 1e9 + 7;\nconst long long FMOD = 998244353;\nconst double eps = 1e-9;\nvoid __print(long long x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  long long f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nmt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT gcd(T a, T b) {\n  if (b == 0) return a;\n  a %= b;\n  return gcd(b, a);\n}\ntemplate <typename T>\nT lcm(T a, T b) {\n  return (a * (b / gcd(a, b)));\n}\nlong long add(long long a, long long b, long long c = MOD) {\n  long long res = a + b;\n  return (res >= c ? res % c : res);\n}\nlong long sub(long long a, long long b, long long c = MOD) {\n  long long res;\n  if (abs(a - b) < c)\n    res = a - b;\n  else\n    res = (a - b) % c;\n  return (res < 0 ? res + c : res);\n}\nlong long mul(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return (res >= c ? res % c : res);\n}\nlong long muln(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return ((res % c) + c) % c;\n}\nlong long mulmod(long long a, long long b, long long m = MOD) {\n  long long q = (long long)(((long double)a * (long double)b) / (long double)m);\n  long long r = a * b - q * m;\n  if (r > m) r %= m;\n  if (r < 0) r += m;\n  return r;\n}\ntemplate <typename T>\nT binpow(T e, T n) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = x * p;\n    p = p * p;\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT binpow2(T e, T n, T m = MOD) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = mul(x, p, m);\n    p = mul(p, p, m);\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT extended_euclid(T a, T b, T &x, T &y) {\n  T xx = 0, yy = 1;\n  y = 0;\n  x = 1;\n  while (b) {\n    T q = a / b, t = b;\n    b = a % b;\n    a = t;\n    t = xx;\n    xx = x - q * xx;\n    x = t;\n    t = yy;\n    yy = y - q * yy;\n    y = t;\n  }\n  return a;\n}\ntemplate <typename T>\nT mod_inverse(T a, T n = MOD) {\n  T x, y, z = 0;\n  T d = extended_euclid(a, n, x, y);\n  return (d > 1 ? -1 : sub(x, z, n));\n}\nconst long long FACSZ = 1e4;\nlong long fact[FACSZ], ifact[FACSZ];\nvoid precom(long long c = MOD) {\n  fact[0] = 1;\n  for (long long i = 1; i < FACSZ; i++) fact[i] = mul(fact[i - 1], i, c);\n  ifact[FACSZ - 1] = mod_inverse(fact[FACSZ - 1], c);\n  for (long long i = FACSZ - 1 - 1; i >= 0; i--) {\n    ifact[i] = mul(i + 1, ifact[i + 1], c);\n  }\n}\nvector<long long> primes;\nvoid prime_precom() {\n  primes.push_back(2);\n  for (long long x = 3; primes.size() <= MAXN; x += 2) {\n    bool isPrime = true;\n    for (auto p : primes) {\n      if (x % p == 0) {\n        isPrime = false;\n        break;\n      }\n      if (p * p > x) {\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(x);\n    }\n  }\n}\nlong long ncr(long long n, long long k) {\n  if (n < k) return 0;\n  if (k == 0) return 1;\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res *= (n - i);\n    res /= (i + 1);\n  }\n  return res;\n}\nlong long ncr_modp(long long n, long long k, long long c = MOD) {\n  if (n < k) return 0;\n  if (k == 0) return 1;\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res = mul(res, n - i, c);\n    res = mul(res, binpow2(i + 1, c - 2, c), c);\n  }\n  return res;\n}\nvector<long long> factors;\nvoid factorize(long long a) {\n  factors.clear();\n  for (long long i = 1; i * i <= a; i++) {\n    if (a % i == 0) {\n      factors.push_back(i);\n      factors.push_back(a / i);\n    }\n  }\n  sort(factors.begin(), factors.end());\n}\nlong long ncr_precom(long long n, long long r, long long c = MOD) {\n  return mul(mul(ifact[r], ifact[n - r], c), fact[n], c);\n}\nlong long ceil(long long a, long long b) { return (a + b - 1) / b; }\nbool is_prime(long long n) {\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\nbool diophantine_checker(long long a, long long b, long long n) {\n  for (long long i = 0; i * a <= n; i++) {\n    if ((n - (i * a)) % b == 0) {\n      return true;\n    }\n  }\n  return false;\n}\nlong long count_divisors(long long n) {\n  long long c;\n  long long ans = 1;\n  for (long long i = 2; i * i <= n; i++) {\n    c = 0;\n    while (n % i == 0) {\n      c++;\n      n /= i;\n    }\n    ans *= (c + 1);\n  }\n  if (n > 2) {\n    return ans * 2;\n  }\n  return ans;\n}\nstring to_binary(long long n) {\n  string r;\n  while (n != 0) {\n    r = (n % 2 == 0 ? \"0\" : \"1\") + r;\n    n /= 2;\n  }\n  return r;\n}\nbool ispower2(long long x) { return x && (!(x & (x - 1))); }\nunsigned long long mulmodBitwise(unsigned long long a, unsigned long long b,\n                                 unsigned long long p) {\n  a %= p;\n  b %= p;\n  if (a <= 0xFFFFFFF && b <= 0xFFFFFFF) {\n    return (a * b) % p;\n  }\n  if (b > a) {\n    swap(a, b);\n  }\n  unsigned long long result = 0;\n  while (a > 0 && b > 0) {\n    if (b & 1) {\n      result += a;\n      result %= p;\n    }\n    a <<= 1;\n    a %= p;\n    b >>= 1;\n  }\n  return result;\n}\nunsigned long long mulmod2(unsigned long long a, unsigned long long b,\n                           unsigned long long p) {\n  a %= p;\n  b %= p;\n  if (a <= 0xFFFFFFF && b <= 0xFFFFFFF) {\n    return (a * b) % p;\n  }\n  unsigned long long zeros = 0;\n  unsigned long long m = p;\n  while ((m & 0x8000000000000000ULL) == 0) {\n    zeros++;\n    m <<= 1;\n  }\n  unsigned long long mask = (1 << zeros) - 1;\n  unsigned long long result = 0;\n  while (a > 0 && b > 0) {\n    result += (b & mask) * a;\n    result %= p;\n    b >>= zeros;\n    a <<= zeros;\n    a %= p;\n  }\n  return result;\n}\nunsigned long long powmod(unsigned long long base, unsigned long long exponent,\n                          unsigned long long p) {\n  unsigned long long result = 1;\n  while (exponent > 0) {\n    if (exponent & 1) {\n      result = mulmod2(result, base, p);\n    }\n    base = mulmod2(base, base, p);\n    exponent >>= 1;\n  }\n  return result;\n}\nvector<long long> spf;\nvoid sieve() {\n  spf.resize(MAXN);\n  spf[1] = 1;\n  for (long long i = 2; i < MAXN; i++) {\n    spf[i] = i;\n  }\n  for (long long i = 4; i < MAXN; i += 2) {\n    spf[i] = 2;\n  }\n  for (long long i = 3; i * i <= MAXN; i++) {\n    if (spf[i] == i) {\n      for (long long j = i * i; j < MAXN; j += i) {\n        if (spf[j] == j) {\n          spf[j] = i;\n        }\n      }\n    }\n  }\n}\nvoid pfactor(long long x, vector<long long> &ret) {\n  while (x != 1) {\n    ret.push_back(spf[x]);\n    x = x / spf[x];\n  }\n}\nvoid solvethetestcase() {\n  long long n, m;\n  cin >> n >> m;\n  vector<long long> dp(n + 1, 0ll);\n  vector<long long> psum(n + 1, 0ll);\n  vector<long long> upd(n + 1, 0ll);\n  vector<long long> psm(n + 1, 0ll);\n  for (long long i = 1; i <= n; i++) {\n    psm[i] = psm[i - 1] + upd[i];\n    psm[i] %= m;\n    if (i == 1) {\n      dp[i] = 1;\n    } else {\n      dp[i] = psm[i] + psum[i - 1];\n      dp[i] %= m;\n    }\n    psum[i] = psum[i - 1] + dp[i];\n    psum[i] %= m;\n    for (long long j = 2; j * i <= n; j++) {\n      upd[j * i] += dp[i];\n      upd[j * i] %= m;\n      if (j * (i + 1) <= n) {\n        upd[j * (i + 1)] -= dp[i];\n        upd[j * (i + 1)] += m;\n        upd[j * (i + 1)] %= m;\n      }\n    }\n  }\n  cout << dp[n] << \"\\n\";\n}\nsigned main() {\n  cout << fixed << setprecision(12);\n  ;\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  for (long long testcase = 1; testcase < t + 1; testcase++) {\n    solvethetestcase();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar buf[1 << 23], *p1 = buf, *p2 = buf, obuf[1 << 23], *O = obuf;\ninline int rd() {\n  int x = 0, f = 1;\n  char ch =\n      (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2)\n           ? EOF\n           : *p1++);\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch =\n        (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2)\n             ? EOF\n             : *p1++);\n  }\n  while (isdigit(ch))\n    x = x * 10 + (ch ^ 48),\n    ch =\n        (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2)\n             ? EOF\n             : *p1++);\n  return x * f;\n}\nconst int maxn = 4e6 + 6;\nlong long Mod;\nlong long a[maxn];\nint n;\nstruct st {\n  long long v[maxn];\n  int lowbit(int x) { return x & -x; }\n  long long query(int n) {\n    long long ans = 0;\n    while (n > 0) {\n      ans = (ans + v[n] + Mod) % Mod;\n      n -= lowbit(n);\n    }\n    return ans;\n  }\n  void add(int x, long long val) {\n    while (x <= n) {\n      v[x] = (v[x] + val + Mod) % Mod;\n      x += lowbit(x);\n    }\n  }\n  void add_seg(int l, int r, int val) {\n    add(l, val);\n    add(r + 1, -val);\n  }\n} x;\nlong long s[maxn];\nint main() {\n  n = rd();\n  Mod = rd();\n  a[1] = 1;\n  x.add_seg(1, 1, 1);\n  long long sum = 0;\n  for (int i = 1; i < n; ++i) {\n    sum = (s[i] + sum + Mod) % Mod;\n    a[i] = (x.query(i) + sum + Mod) % Mod;\n    x.add_seg(i + 1, n, a[i]);\n    for (int z = 2; i * z <= n; ++z) {\n      int l = max(i + 1, i * z), r = min(n, i * z + z - 1);\n      s[l] = (s[l] + a[i]) % Mod;\n      s[r + 1] = (s[r + 1] - a[i] + Mod) % Mod;\n    }\n  }\n  sum = (sum + s[n] + Mod) % Mod;\n  printf(\"%lld\\n\", (x.query(n) + sum + Mod) % Mod);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nbool getbit(long first, long second) { return (first >> second) & 1; }\nusing namespace std;\nconst long N = 4e6 + 5;\nlong n, M, dp[N], sum[N], l, r;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> M;\n  dp[n] = 1;\n  sum[n] = 1;\n  for (long i = n - 1; i >= 1; i--) {\n    dp[i] = sum[i + 1];\n    for (long j = 2; j <= n / i; j++) {\n      l = min(j * (i + 1) - 1, n);\n      dp[i] = ((dp[i] + sum[j * i]) % M - sum[l + 1] + M) % M;\n    }\n    sum[i] = (sum[i + 1] + dp[i]) % M;\n  }\n  cout << dp[1] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint f[4000005], sum[4000005];\nvoid solve() {\n  cin >> n >> m;\n  f[n] = 1;\n  sum[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    f[i] = (f[i] + sum[i + 1]) % m;\n    for (int j = 2; j <= n / i; j++) {\n      int l = i * j, r = min(n, (i + 1) * j - 1);\n      int u = (sum[l] - sum[r + 1] + m) % m;\n      f[i] = (f[i] + u) % m;\n    }\n    sum[i] = (sum[i + 1] + f[i]) % m;\n  }\n  cout << f[1];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) x = x * 10 + (ch - '0'), ch = getchar();\n  return x * f;\n}\nint dp[4000010];\nint main() {\n  int n = read(), m = read();\n  dp[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    dp[i] += dp[i + 1];\n    for (int j = 2 * i; j <= n; j += i)\n      dp[i] = (dp[i] + ((dp[j] - dp[min(j + j / i, n + 1)]) % m + m) % m) % m;\n    dp[i] = (dp[i] + dp[i + 1]) % m;\n  }\n  printf(\"%d\\n\", ((dp[1] - dp[2]) % m + m) % m);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int maxn = 4000005;\nint n, m;\nll dp[maxn];\nint main() {\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  cin >> n >> m;\n  dp[1] = 1;\n  dp[2] = 2;\n  for (ll x = 3; x <= n; x++) {\n    dp[x] = (dp[x] + dp[x - 1] + dp[1] + dp[x - 1]) % m;\n    for (int c = 2 * (x - 1); c <= n; c += x - 1) {\n      dp[c] += dp[x - 1] - dp[x - 2] + m;\n      dp[c] %= m;\n    }\n  }\n  cout << dp[n] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,m=map(int,input().split())\ndp=[0 for i in range(n+3)]\ndp2=[0 for i in range(n+3)]\ndp[n] =1\ndp2[n] =1\nfor i in range(n-1,0,-1):\n    dp[i] =dp2[i+1] %m\n    mul =2\n    while i*mul <=n:\n        dp[i] =(dp[i] % m+ dp2[i*mul] %m-dp2[min((i+1)*mul,n+1)] %m) %m\n        mul +=1\n    dp2[i] =(dp[i]%m +dp2[i+1]%m) %m\nprint(dp[1] % m)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int INF = 1LL << 60;\nconst long long int Mod = 1000000007;\nconst long long int sMod = 998244353;\nusing ll = long long int;\nusing ci = const int;\nusing vi = vector<int>;\nusing Vi = vector<long long int>;\nusing P = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing matrix = vector<vector<ll>>;\ntemplate <class T>\nbool chmax(T &former, const T &b) {\n  if (former < b) {\n    former = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>\nbool chmin(T &former, const T &b) {\n  if (b < former) {\n    former = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>\nT sqar(T x) {\n  return x * x;\n}\ntemplate <class T>\ninline void princ(T x) {\n  cout << x << \" \";\n};\ntemplate <class T>\ninline void print(T x) {\n  cout << x << \"\\n\";\n};\ntemplate <class T>\ninline void Yes(T condition) {\n  if (condition)\n    cout << \"Yes\" << endl;\n  else\n    cout << \"No\" << endl;\n}\ntemplate <class T>\ninline void YES(T condition) {\n  if (condition)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n}\nVi dp(4000050, 0);\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  int sum = 0;\n  dp[1] = 1;\n  for (ll j = ll(3); j < ll(n + 1); ++j) {\n    dp[j] = 1;\n  }\n  for (ll i = ll(2); i < ll(n + 1); ++i) {\n    dp[i] += dp[i - 1];\n    dp[i] %= m;\n    dp[i] += dp[i - 1];\n    dp[i] %= m;\n    for (ll j = i + i; j <= n; j += i) {\n      dp[j] += dp[i] - dp[i - 1];\n      while (dp[j] < 0) dp[j] += m;\n      dp[j] %= m;\n    }\n  }\n  print(dp[n]);\n  return;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  std::cout << std::fixed << std::setprecision(30);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.time.LocalTime;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.regex.*;\n\n\n\npublic class D {\n\n\n\tpublic static void main(String [] args) {\n\t\t\n\t\tFastScanner scan = new FastScanner();\n    \tint T = 1;\n    //\tT = scan.nextInt();\n    \t\tfor(int tt=0; tt<T; tt++) {\n    \t\t\tint n = scan.nextInt();\n    \t\t\tmod = scan.nextInt();\n    \t\t\tint [] dp = new int[n+2];\n    \t\t\tint [] sum = new int[n+2];\n    \t\t\tdp[n] = 1;\n    \t\t\tsum[n] = 1;\n    \t\t\tfor(int fillIn = n-1; fillIn > 0; fillIn--) {\n    \t\t\t\tint ans = sum[fillIn+1];\n    \t\t\t\t\n    \t\t\t\tfor(int mul = 2; true; mul++) {\n    \t\t\t\t\tint lower = mul * fillIn;\n    \t\t\t\t\tint higher = mul * fillIn + mul - 1;\n    \t\t\t\t\tif(lower > n) break;\n    \t\t\t\t\thigher = Math.min(higher, n);\n    \t\t\t\t\tans = add(ans, sub(sum[lower], sum[higher+1]));\n    \t\t\t\t}\n    \t\t\t\tdp[fillIn] = ans;\n    \t\t\t\tsum[fillIn] = add(sum[fillIn+1], dp[fillIn]);\n    \t\t\t}\n    \t\t\tSystem.out.println(dp[1]);\n    \t\t}\t\n\t}\n\t\n\t/*\n\t \n\t 12 998244353\n\t \n\t 158032 121694641\n\t */\n\t\n\tstatic int mod;\n\t\n\tstatic int add(int a, int b) {\n\t\ta+=b;\n\t\tif (a>=mod) return a-mod;\n\t\treturn a;\n\t}\n\t\n\tstatic int sub(int a, int b) {\n\t\ta-=b;\n\t\tif (a<0) a+=mod;\n\t\telse if (a>=mod) a-=mod;\n\t\treturn a;\n\t}\n\n\t\n\tpublic static void sort(int [] a) {\n    \tArrayList<Integer> b = new ArrayList<>();\n    \tfor(int i: a) b.add(i);\n    \tCollections.sort(b);\n    \tfor(int i=0; i<a.length; i++) a[i]= b.get(i);\n    }\n  \n    \n    static class FastScanner{\n    \t\n    \tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    \tStringTokenizer st = new StringTokenizer(\"\");\n    \tString next() {\n    \t\twhile(!st.hasMoreTokens())\n    \t\t\ttry {\n    \t\t\t\tst = new StringTokenizer(br.readLine());\n    \t\t\t} catch (IOException e){\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\treturn st.nextToken();\n    \t}\n    \t\n    \tint nextInt() {\n    \t\treturn Integer.parseInt(next());\n    \t}\n    \t\n    \tint [] readArray(int n) {\n    \t\tint [] a = new int[n];\n    \t\tfor(int i=0; i<n ; i++) a[i] = nextInt();\n    \t\treturn a;\n    \t}\n    \t\n    \tlong nextLong() {\n    \t\treturn Long.parseLong(next());\n    \t}\n    \t\n    \t\n    }\n   \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nnamespace IO {\nconst int SIZE = (1 << 20) + 1;\nchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;\nchar _st[55];\nint _qr = 0;\ninline char gc() {\n  return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),\n          (iS == iT ? EOF : *iS++) : *iS++);\n}\ninline void qread() {}\ntemplate <class T1, class... T2>\ninline void qread(T1 &IEE, T2 &...ls) {\n  register T1 __ = 0, ___ = 1;\n  register char ch;\n  while (!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n  do {\n    __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n  } while (isdigit(ch = gc()));\n  __ *= ___;\n  IEE = __;\n  qread(ls...);\n  return;\n}\ntemplate <class T>\ninline void QreadArr(T Begin, T End) {\n  while (Begin != End) {\n    qread(*Begin);\n    ++Begin;\n  }\n}\ninline void flush() {\n  fwrite(obuf, 1, oS - obuf, stdout);\n  oS = obuf;\n  return;\n}\ninline void putc_(char _x) {\n  *oS++ = _x;\n  if (oS == oT) flush();\n}\ninline void qwrite() {}\ntemplate <class T1, class... T2>\ninline void qwrite(T1 IEE, T2... ls) {\n  if (!IEE) putc_('0');\n  if (IEE < 0) putc_('-'), IEE = -IEE;\n  while (IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;\n  while (_qr) putc_(_st[_qr--]);\n  qwrite(ls...);\n  return;\n}\ntemplate <class T>\ninline void WriteArr(T Begin, T End) {\n  const char Kg = ' ', Edl = '\\n';\n  while (Begin != End) {\n    qwrite(*Begin);\n    ++Begin;\n    putc_(Kg);\n  }\n  putc_(Edl);\n}\nstruct Flusher_ {\n  ~Flusher_() { flush(); }\n} io_flusher;\n}  // namespace IO\nusing namespace IO;\nusing namespace std;\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());\nlong long My_Rand(long long Mod) { return (unsigned long long)(rnd()) % Mod; }\ntemplate <class T1, class T2>\nT1 Min(const T1 x, const T2 y) {\n  return x > y ? y : x;\n}\ntemplate <class T1, class T2>\nT1 Max(const T1 x, const T2 y) {\n  return x > y ? x : y;\n}\ntemplate <class T1, class T2>\nvoid To_max(T1 &x, const T2 y) {\n  x < y ? x = y : x = x;\n}\ntemplate <class T1, class T2>\nvoid To_min(T1 &x, const T2 y) {\n  x > y ? x = y : x = x;\n}\ninline long long qmul(long long x, long long y, long long p) {\n  long long l = x * (y >> 25) % p * (1 << 25) % p;\n  long long r = x * (y & ((1 << 25) - 1)) % p;\n  return (l + r) % p;\n}\ninline long long qpow(long long n, long long base, long long mod = 1e18) {\n  long long ret = 1;\n  while (n) {\n    if (n & 1) ret = ret * base % mod;\n    base = base * base % mod;\n    n >>= 1;\n  }\n  return ret % mod;\n}\ninline long long gcd(long long x, long long y) {\n  return !y ? x : gcd(y, x % y);\n}\ninline long long lcm(long long x, long long y) { return x / gcd(x, y) * y; }\nvoid InitHash(unsigned long long &base, int &prime, unsigned long long &mod) {\n  base = 131, prime = 233317, mod = 212370440130137957ll;\n}\nconst int N = 4e6 + 5;\nint n, p;\nint f[N], q[N];\nint main() {\n  qread(n, p);\n  for (int i = (1); i <= (n); ++i) {\n    (f[i] += f[i - 1]) %= p;\n    q[i] = f[i];\n    if (i == 1) q[i] = 1;\n    (f[i + 1] += q[i]) %= p;\n    for (int j = (2); j <= (n / i); ++j) {\n      (f[i * j] += q[i]) %= p;\n      if (i * j + j <= n) (f[i * j + j] += p - q[i]) %= p;\n    }\n  }\n  cout << (q[n] + p) % p << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9;\nconst int N = 10000007;\nconst int mod = 1e9 + 7;\nconst double eps = 1e-6;\nconst double pi = acos(-1.0);\ninline int read() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\nstruct Node {\n  int mn, key;\n  bool operator<(const Node& b) const {\n    if (mn == b.mn) return key < b.key;\n    return mn < b.mn;\n  }\n};\nint T, n, m;\nint dp[2][N];\nint ksm(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = res * a % mod;\n    a = a * a % mod;\n    b <<= 1;\n  }\n  return res;\n}\nvoid solve() {\n  n = read(), m = read();\n  dp[0][1] = 1;\n  long long pre = 0;\n  for (int i = (1); i <= (n); ++i) {\n    dp[1][i] = (0ll + dp[1][i] + dp[1][i - 1]) % m;\n    if (i > 1) dp[0][i] = dp[1][i];\n    dp[0][i] = (0ll + dp[0][i] + pre) % m;\n    int l = 1, r = 2 * i;\n    while (r <= n) {\n      dp[1][r] = (0ll + dp[1][r] + dp[0][i]) % m;\n      dp[1][r + l + 1] = (0ll + dp[1][r + l + 1] + m - dp[0][i]) % m;\n      ++l;\n      r += i;\n    }\n    pre = (0ll + dp[0][i] + pre) % m;\n  }\n  printf(\"%d\\n\", dp[0][n]);\n}\nsigned main() { solve(); }\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\n\npublic class Main\n{\n    static MyScanner scan;\n    static PrintWriter pw;\n    static long MOD = 1_000_000_007;\n    static long INF = 2_000_000_000_000_000_000L;\n    static long inf = 2_000_000_000;\n    public static void main(String[] args) {\n        new Thread(null, null, \"_\", 1 << 27) {\n            public void run() {\n                try {\n                    solve();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n\n\n    static void solve() throws java.lang.Exception {\n        //initIo(true, \"\");\n        initIo(false, \"\");\n        StringBuilder sb = new StringBuilder();\n\n        int n = ni(), mod = ni();\n        long ways[] = new long[n+1];\n        long sum = 0;\n        ways[1] = 1;\n        long pref[] = new long[n+1];\n        for(int i=1;i<=n;i++) {\n            pref[i] = (pref[i] + pref[i-1])%mod;\n            ways[i] += pref[i];\n            ways[i] += sum;\n            ways[i] %= mod;\n            for(int j=2;i*j<=n;j++) {\n                int l = i*j;\n                int r = (i+1)*j-1;\n                if(l<=r) {\n                    pref[l] = (pref[l] + ways[i]) % mod;\n                    if(r+1<=n) {\n                        pref[r + 1] = (pref[r + 1] - ways[i] + mod) % mod;\n                    }\n                }\n            }\n\n            sum = (sum + ways[i])%mod;\n        }\n\n        // pa(\"ways\", ways);\n        pl(ways[n]);\n\n        pw.flush();\n        pw.close();\n    }\n\n\n    static void assert_in_range(String varName, int n, int l, int r) {\n        if (n >=l && n<=r) return;\n        System.out.println(varName + \" is not in range. Actual: \"+n+\" l : \"+l+\" r: \"+r);\n        System.exit(1);\n    }\n    static void assert_in_range(String varName, long n, long l, long r) {\n        if (n>=l && n<=r) return;\n        System.out.println(varName + \" is not in range. Actual: \"+n+\" l : \"+l+\" r: \"+r);\n        System.exit(1);\n    }\n\n    static void initIo(boolean isFileIO, String suffix) throws IOException {\n        scan = new MyScanner(isFileIO, suffix);\n        if(isFileIO) {\n            pw = new PrintWriter(\"/Users/dsds/Desktop/output\"+suffix+\".txt\");\n        }\n        else {\n            pw = new PrintWriter(System.out, true);\n        }\n    }\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static String ne() throws IOException\n    {\n        return scan.next();\n    }\n    static String nel() throws IOException\n    {\n        return scan.nextLine();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Object arr[])\n    {\n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n\n    static void pa(String arrayName, TreeSet<Integer> set)\n    {\n        pl(arrayName+\" : \");\n        for(Object o : set)\n            p(o);\n        pl();\n    }\n\n    static void pa(String arrayName, boolean arr[])\n    {\n        pl(arrayName+\" : \");\n        for(boolean o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String listName, List list)\n    {\n        pl(listName+\" : \");\n        for(Object o : list)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(Object o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, int[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(int o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, long[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(long o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, char[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(char o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, double[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(double o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, boolean[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(boolean o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static class MyScanner\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        MyScanner(boolean readingFromFile, String suffix) throws IOException\n        {\n            if(readingFromFile) {\n                br = new BufferedReader(new FileReader(\"/Users/ddfds/Desktop/input\"+suffix+\".txt\"));\n            }\n            else {\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n        }\n        String nextLine()throws IOException\n        {\n            return br.readLine();\n        }\n        String next() throws IOException\n        {\n            if(st==null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        int nextInt() throws IOException\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong() throws IOException\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble() throws IOException\n        {\n            return Double.parseDouble(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nlong mod;\nlong dp[4000001];\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  long n;\n  cin >> n >> mod;\n  long curr = 0;\n  long prevsum = 1;\n  for (long i = 1; i <= n; ++i) {\n    curr = (curr + dp[i]) % mod;\n    dp[i] = (curr + prevsum) % mod;\n    for (long j = 2;; j++) {\n      long s = i * j;\n      long e = s + j;\n      if (s > n) break;\n      dp[s] = (dp[s] + dp[i]) % mod;\n      if (e <= n) dp[e] = (dp[e] - dp[i] + mod) % mod;\n    }\n    prevsum = (prevsum + dp[i]) % mod;\n    if (i == 1) prevsum--;\n  }\n  cout << dp[n];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nll dp[4000001];\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  dp[1] = 1;\n  for (int i = 2, v; i <= n; i++) {\n    if (i == 2) {\n      dp[i] = 2;\n    } else {\n      dp[i] += 1 + dp[i - 1] * 2;\n      dp[i] %= m;\n    }\n    v = (dp[i] - dp[i - 1] + m) % m;\n    for (int j = i << 1; j <= n; j += i) {\n      dp[j] += v;\n      dp[j] %= m;\n    }\n  }\n  cout << dp[n];\n}\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  char c = getchar();\n  int x = 0, y = 1;\n  while (c < '0' || c > '9') {\n    if (c == '-') y = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 3) + (x << 1) + c - '0';\n    c = getchar();\n  }\n  return x * y;\n}\nvoid write(int x) {\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n}\ninline long long readll() {\n  char c = getchar();\n  long long x = 0;\n  int y = 1;\n  while (c < '0' || c > '9') {\n    if (c == '-') y = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 3) + (x << 1) + c - '0';\n    c = getchar();\n  }\n  return x * y;\n}\nvoid writell(long long x) {\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  if (x > 9) writell(x / 10);\n  putchar(x % 10 + '0');\n}\nint n;\nlong long mod, suf[4000005];\nsigned main() {\n  int i, j;\n  long long dp, s = 0;\n  cin >> n >> mod;\n  suf[n] = s = 1;\n  for (i = n - 1; i; i--) {\n    dp = s;\n    for (j = 2; i * j <= n; j++)\n      dp = (dp + suf[i * j] - suf[min(n + 1, i * j + j)]) % mod;\n    s = (s + dp) % mod;\n    suf[i] = (suf[i + 1] + dp) % mod;\n  }\n  cout << dp;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 4e6 + 10;\nlong long mod = 1e9 + 7;\nconst long long inf = 0x3f3f3f3f;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nlong long n, m;\nlong long dp[N];\nvoid solve() {\n  cin >> n >> mod;\n  dp[1] = 1, dp[2] = 2;\n  for (long long i = (2); i <= (n); ++i) {\n    if (i > 2) dp[i] = (dp[i] + dp[i - 1] * 2 + 1) % mod;\n    long long d = dp[i] - dp[i - 1];\n    for (long long j = 2; j <= n / i; j++) {\n      dp[i * j] += d;\n    }\n  }\n  cout << (dp[n] % mod + mod) % mod << endl;\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool isprime(int k) {\n  for (int i = 2; i <= sqrt(k); i++)\n    if (k % i == 0) return false;\n  return true;\n}\nint bm(int a, int b, int mod) {\n  if (b == 0) return 1;\n  int t = bm(a, b / 2, mod);\n  t = t * t % mod;\n  return (b % 2 == 1 ? t * a % mod : t);\n}\nint inv(int a, int mod) { return bm(a, mod - 2, mod); }\nvector<int> upd[4000005];\nvoid solve() {\n  long long n, mod;\n  cin >> n >> mod;\n  int dp[n + 5];\n  dp[0] = 0;\n  dp[1] = 1;\n  int sum = 1;\n  int add[n + 5];\n  for (int i = 2; i <= n; i++) dp[i] = 0;\n  for (int i = 2; i <= n; i++) add[i] = 1;\n  for (int i = 2; i <= n; i++) {\n    sum += add[i];\n    sum %= mod;\n    dp[i] += sum;\n    dp[i] %= mod;\n    sum = (sum + dp[i]) % mod;\n    for (int j = 2; j * i <= n; j++) {\n      add[j * i] += (dp[i] - dp[i - 1]);\n      if (add[j * i] < 0) add[j * i] += mod;\n      add[j * i] %= mod;\n    }\n  }\n  dp[n] %= mod;\n  if (dp[n] < 0) dp[n] += mod;\n  cout << dp[n] % mod << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ndouble eps = 1e-12;\ntemplate <class T>\nvoid swp(T& a, T& b) {\n  T temp = a;\n  a = b;\n  b = temp;\n}\nlong long ceil_div(long long a, long long b) {\n  return a % b == 0 ? a / b : a / b + 1;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long modex(long long x, unsigned int y, long long p) {\n  long long res = 1;\n  x = x % p;\n  if (x == 0) return 0;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nint binarySearch(int arr[], int l, int r, int x) {\n  if (r >= l) {\n    int mid = l + (r - l) / 2;\n    if (arr[mid] == x) return mid;\n    if (arr[mid] > x) return binarySearch(arr, l, mid - 1, x);\n    return binarySearch(arr, mid + 1, r, x);\n  }\n  return -1;\n}\nconst long long MOD = 998244353;\nconst long long mod = 1e9 + 7;\nvoid solve() {}\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  vector<long long> v(n + 2);\n  v[n] = 1ll;\n  for (long long i = n - 1; i > 0ll; --i) {\n    v[i] = v[i + 1];\n    for (long long j = 2ll; j < n + 1ll; j++) {\n      if (j * i > n) break;\n      v[i] = (v[i] + (v[j * i] - v[min(n, j * (i + 1ll) - 1ll) + 1ll])) % m;\n    }\n    v[i] = (v[i] + v[i + 1ll]) % m;\n  }\n  if (v[1] >= v[2]) {\n    cout << v[1] - v[2];\n  } else {\n    cout << (m + v[1] - v[2]) % m;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std::chrono;\nlong long MOD = 1000000007;\nstruct mi {\n  long long v;\n  explicit operator long long() const { return v; }\n  mi() { v = 0; }\n  mi(long long _v) {\n    v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n    if (v < 0) v += MOD;\n  }\n  friend bool operator==(const mi &a, const mi &b) { return a.v == b.v; }\n  friend bool operator!=(const mi &a, const mi &b) { return !(a == b); }\n  friend bool operator<(const mi &a, const mi &b) { return a.v < b.v; }\n  mi &operator+=(const mi &m) {\n    if ((v += m.v) >= MOD) v -= MOD;\n    return *this;\n  }\n  mi &operator-=(const mi &m) {\n    if ((v -= m.v) < 0) v += MOD;\n    return *this;\n  }\n  mi &operator*=(const mi &m) {\n    v = v * m.v % MOD;\n    return *this;\n  }\n  mi &operator/=(const mi &m) { return (*this) *= inv(m); }\n  friend mi pow(mi a, long long p) {\n    mi ans = 1;\n    assert(p >= 0);\n    for (; p; p /= 2, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  friend mi inv(const mi &a) {\n    assert(a.v != 0);\n    return pow(a, MOD - 2);\n  }\n  mi operator-() const { return mi(-v); }\n  mi &operator++() { return *this += 1; }\n  mi &operator--() { return *this -= 1; }\n  mi operator++(int) {\n    mi temp;\n    temp.v = v++;\n    return temp;\n  }\n  mi operator--(int) {\n    mi temp;\n    temp.v = v--;\n    return temp;\n  }\n  friend mi operator+(mi a, const mi &b) { return a += b; }\n  friend mi operator-(mi a, const mi &b) { return a -= b; }\n  friend mi operator*(mi a, const mi &b) { return a *= b; }\n  friend mi operator/(mi a, const mi &b) { return a /= b; }\n  friend ostream &operator<<(ostream &os, const mi &m) {\n    os << m.v;\n    return os;\n  }\n  friend istream &operator>>(istream &is, mi &m) {\n    long long x;\n    is >> x;\n    m.v = x;\n    return is;\n  }\n};\nvoid solve() {\n  long long n;\n  cin >> n;\n  long long m;\n  cin >> m;\n  MOD = m;\n  vector<mi> dp(n + 1, 0);\n  vector<mi> suffix(n + 2, 0);\n  dp[n] = 1;\n  suffix[n] = 1;\n  mi sum = 0;\n  for (long long i = (n)-1; i >= 1; i--) {\n    sum = sum + dp[i + 1];\n    dp[i] = sum;\n    for (long long j = 2; j < (n + 1); j++) {\n      if (i * j > n)\n        break;\n      else {\n        mi sf = suffix[i * j] - suffix[min(i * j + j, n + 1)];\n        dp[i] = dp[i] + sf;\n      }\n    }\n    suffix[i] = suffix[i + 1] + dp[i];\n  }\n  cout << dp[1] << endl;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nsigned main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n  long long int n, m;\n  cin >> n >> m;\n  long long int a[n + 1];\n  long long int p[n + 1];\n  p[n] = 1;\n  a[n] = 1;\n  for (long long int i = n - 1; i >= 1; i--) {\n    a[i] = p[i + 1];\n    long long int k = 2;\n    long long int j = i * k;\n    while (j <= n) {\n      a[i] = (a[i] + p[j] - ((j + k <= n) ? p[j + k] : 0)) % m;\n      k++;\n      j = i * k;\n    }\n    p[i] = p[i + 1] + a[i];\n    p[i] %= m;\n  }\n  cout << a[1];\n  cout << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D1UpTheStripSimplifiedVersion solver = new D1UpTheStripSimplifiedVersion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D1UpTheStripSimplifiedVersion {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int mod = in.nextInt();\n            int[] dp = new int[n + 1];\n            dp[n] = 1;\n            int[] sum = new int[n + 1];\n            sum[n] = 1;\n            for (int i = n - 1; i >= 1; i--) {\n                dp[i] = sum[i + 1];\n                for (int j = 2; j * i <= n; j++) {\n                    if (j * i + j > n) {\n                        dp[i] = add(dp[i], sum[i * j], mod);\n//                    dp[i] = (dp[i] + sum[i * j]) % mod;\n                    } else {\n                        dp[i] = add(dp[i], dec(sum[i * j], sum[j * i + j], mod), mod);\n//                    dp[i] = (dp[i] + (sum[i * j] - sum[j * i + j] + mod) % mod) % mod;\n                    }\n                }\n                sum[i] = add(dp[i], sum[i + 1], mod);\n//            sum[i] = (sum[i + 1] + dp[i]) % mod;\n            }\n            out.println(dp[1]);\n        }\n\n        int add(int x, int y, int mod) {\n            int t = x + y;\n            if (t >= mod) {\n                t -= mod;\n            }\n            return t;\n        }\n\n        int dec(int x, int y, int mod) {\n            int t = x - y;\n            if (t < 0) {\n                t += mod;\n            }\n            return t;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f;\nconst long long dis[][2] = {{0, 1}, {1, 0},  {0, -1}, {-1, 0},\n                            {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\nconst long long N = 4e6 + 10;\nlong long dp[N], sum[N];\nvoid solve() {\n  long long n, p;\n  cin >> n >> p;\n  dp[n] = sum[n] = 1;\n  for (long long i = n - 1; i >= 1; i--) {\n    dp[i] = sum[i + 1];\n    for (long long j = 2; i * j <= n; j++) {\n      long long l = i * j, r = min((i + 1) * j, n + 1);\n      dp[i] = (dp[i] + sum[l] - sum[r] + p) % p;\n    }\n    sum[i] = (sum[i + 1] + dp[i]) % p;\n  }\n  cout << dp[1] << endl;\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long T = 1;\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\")\n#pragma GCC optimize(\"trapv\")\n#pragma GCC target( \\\n    \"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx2,tune=native\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-funroll-all-loops,-fpeel-loops,-funswitch-loops\")\nusing namespace std;\nlong long power(long long x, long long y, long long m) {\n  if (y < 0) return 0;\n  long long temp;\n  if (y == 0) return 1;\n  temp = (power(x, y / 2, m)) % m;\n  if (y % 2 == 0)\n    return ((temp % m) * temp) % m;\n  else\n    return ((x * temp % m) * temp % m) % m;\n}\nlong long inv(long long x, long long m = 1000000007) {\n  return (power(x, m - 2, m)) % m;\n}\nint32_t n, m, DP[4000001], L[4000001], R[4000001];\nint32_t main() {\n  cin.tie(0), iostream::sync_with_stdio(0);\n  cin >> n >> m;\n  DP[1] = 1;\n  long long TOT = 0, TOT2 = 0;\n  for (long long i = 1; i <= n; i++) {\n    TOT2 = (TOT2 + L[i]) % m;\n    DP[i] = (DP[i] + TOT + TOT2) % m;\n    TOT2 = (TOT2 - R[i] + m) % m;\n    for (long long j = i * 2; j <= n; j += i) {\n      L[j] = (L[j] + DP[i]) % m;\n      if (j + j / i - 1 <= 4000000)\n        R[j + j / i - 1] = (R[j + j / i - 1] + DP[i]) % m;\n    }\n    TOT = ((TOT + DP[i]) >= m ? TOT + DP[i] - m : TOT + DP[i]);\n  }\n  cout << DP[n];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 1000005;\nconst long long SQRTN = 1003;\nconst long long LOGN = 22;\nconst double PI = acos(-1);\nconst long long INF = 1e18;\nconst long long MOD = 1e9 + 7;\nconst long long FMOD = 998244353;\nconst double eps = 1e-9;\nvoid __print(long long x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  long long f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nmt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT gcd(T a, T b) {\n  if (b == 0) return a;\n  a %= b;\n  return gcd(b, a);\n}\ntemplate <typename T>\nT lcm(T a, T b) {\n  return (a * (b / gcd(a, b)));\n}\nlong long add(long long a, long long b, long long c = MOD) {\n  long long res = a + b;\n  return (res >= c ? res % c : res);\n}\nlong long sub(long long a, long long b, long long c = MOD) {\n  long long res;\n  if (abs(a - b) < c)\n    res = a - b;\n  else\n    res = (a - b) % c;\n  return (res < 0 ? res + c : res);\n}\nlong long mul(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return (res >= c ? res % c : res);\n}\nlong long muln(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return ((res % c) + c) % c;\n}\nlong long mulmod(long long a, long long b, long long m = MOD) {\n  long long q = (long long)(((long double)a * (long double)b) / (long double)m);\n  long long r = a * b - q * m;\n  if (r > m) r %= m;\n  if (r < 0) r += m;\n  return r;\n}\ntemplate <typename T>\nT binpow(T e, T n) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = x * p;\n    p = p * p;\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT binpow2(T e, T n, T m = MOD) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = mul(x, p, m);\n    p = mul(p, p, m);\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT extended_euclid(T a, T b, T &x, T &y) {\n  T xx = 0, yy = 1;\n  y = 0;\n  x = 1;\n  while (b) {\n    T q = a / b, t = b;\n    b = a % b;\n    a = t;\n    t = xx;\n    xx = x - q * xx;\n    x = t;\n    t = yy;\n    yy = y - q * yy;\n    y = t;\n  }\n  return a;\n}\ntemplate <typename T>\nT mod_inverse(T a, T n = MOD) {\n  T x, y, z = 0;\n  T d = extended_euclid(a, n, x, y);\n  return (d > 1 ? -1 : sub(x, z, n));\n}\nconst long long FACSZ = 1e4;\nlong long fact[FACSZ], ifact[FACSZ];\nvoid precom(long long c = MOD) {\n  fact[0] = 1;\n  for (long long i = 1; i < FACSZ; i++) fact[i] = mul(fact[i - 1], i, c);\n  ifact[FACSZ - 1] = mod_inverse(fact[FACSZ - 1], c);\n  for (long long i = FACSZ - 1 - 1; i >= 0; i--) {\n    ifact[i] = mul(i + 1, ifact[i + 1], c);\n  }\n}\nvector<long long> primes;\nvoid prime_precom() {\n  primes.push_back(2);\n  for (long long x = 3; primes.size() <= MAXN; x += 2) {\n    bool isPrime = true;\n    for (auto p : primes) {\n      if (x % p == 0) {\n        isPrime = false;\n        break;\n      }\n      if (p * p > x) {\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(x);\n    }\n  }\n}\nlong long ncr(long long n, long long k) {\n  if (n < k) return 0;\n  if (k == 0) return 1;\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res *= (n - i);\n    res /= (i + 1);\n  }\n  return res;\n}\nlong long ncr_modp(long long n, long long k, long long c = MOD) {\n  if (n < k) return 0;\n  if (k == 0) return 1;\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res = mul(res, n - i, c);\n    res = mul(res, binpow2(i + 1, c - 2, c), c);\n  }\n  return res;\n}\nvector<long long> factors;\nvoid factorize(long long a) {\n  factors.clear();\n  for (long long i = 1; i * i <= a; i++) {\n    if (a % i == 0) {\n      factors.push_back(i);\n      factors.push_back(a / i);\n    }\n  }\n  sort(factors.begin(), factors.end());\n}\nlong long ncr_precom(long long n, long long r, long long c = MOD) {\n  return mul(mul(ifact[r], ifact[n - r], c), fact[n], c);\n}\nlong long ceil(long long a, long long b) { return (a + b - 1) / b; }\nbool is_prime(long long n) {\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\nbool diophantine_checker(long long a, long long b, long long n) {\n  for (long long i = 0; i * a <= n; i++) {\n    if ((n - (i * a)) % b == 0) {\n      return true;\n    }\n  }\n  return false;\n}\nlong long count_divisors(long long n) {\n  long long c;\n  long long ans = 1;\n  for (long long i = 2; i * i <= n; i++) {\n    c = 0;\n    while (n % i == 0) {\n      c++;\n      n /= i;\n    }\n    ans *= (c + 1);\n  }\n  if (n > 2) {\n    return ans * 2;\n  }\n  return ans;\n}\nstring to_binary(long long n) {\n  string r;\n  while (n != 0) {\n    r = (n % 2 == 0 ? \"0\" : \"1\") + r;\n    n /= 2;\n  }\n  return r;\n}\nbool ispower2(long long x) { return x && (!(x & (x - 1))); }\nunsigned long long mulmodBitwise(unsigned long long a, unsigned long long b,\n                                 unsigned long long p) {\n  a %= p;\n  b %= p;\n  if (a <= 0xFFFFFFF && b <= 0xFFFFFFF) {\n    return (a * b) % p;\n  }\n  if (b > a) {\n    swap(a, b);\n  }\n  unsigned long long result = 0;\n  while (a > 0 && b > 0) {\n    if (b & 1) {\n      result += a;\n      result %= p;\n    }\n    a <<= 1;\n    a %= p;\n    b >>= 1;\n  }\n  return result;\n}\nunsigned long long mulmod2(unsigned long long a, unsigned long long b,\n                           unsigned long long p) {\n  a %= p;\n  b %= p;\n  if (a <= 0xFFFFFFF && b <= 0xFFFFFFF) {\n    return (a * b) % p;\n  }\n  unsigned long long zeros = 0;\n  unsigned long long m = p;\n  while ((m & 0x8000000000000000ULL) == 0) {\n    zeros++;\n    m <<= 1;\n  }\n  unsigned long long mask = (1 << zeros) - 1;\n  unsigned long long result = 0;\n  while (a > 0 && b > 0) {\n    result += (b & mask) * a;\n    result %= p;\n    b >>= zeros;\n    a <<= zeros;\n    a %= p;\n  }\n  return result;\n}\nunsigned long long powmod(unsigned long long base, unsigned long long exponent,\n                          unsigned long long p) {\n  unsigned long long result = 1;\n  while (exponent > 0) {\n    if (exponent & 1) {\n      result = mulmod2(result, base, p);\n    }\n    base = mulmod2(base, base, p);\n    exponent >>= 1;\n  }\n  return result;\n}\nvector<long long> spf;\nvoid sieve() {\n  spf.resize(MAXN);\n  spf[1] = 1;\n  for (long long i = 2; i < MAXN; i++) {\n    spf[i] = i;\n  }\n  for (long long i = 4; i < MAXN; i += 2) {\n    spf[i] = 2;\n  }\n  for (long long i = 3; i * i <= MAXN; i++) {\n    if (spf[i] == i) {\n      for (long long j = i * i; j < MAXN; j += i) {\n        if (spf[j] == j) {\n          spf[j] = i;\n        }\n      }\n    }\n  }\n}\nvoid pfactor(long long x, vector<long long> &ret) {\n  while (x != 1) {\n    ret.push_back(spf[x]);\n    x = x / spf[x];\n  }\n}\nvoid solvethetestcase() {\n  long long n, m;\n  cin >> n >> m;\n  vector<long long> dp(n + 1, 0ll);\n  vector<long long> upd(n + 1, 0ll);\n  vector<long long> sm(n + 1, 0ll);\n  vector<long long> psum(n + 1, 0ll);\n  for (long long i = 1; i <= n; i++) {\n    sm[i] = sm[i - 1] + upd[i];\n    if (i == 1) {\n      dp[i] = 1ll;\n    } else {\n      dp[i] = add(psum[i - 1], sm[i], m);\n    }\n    psum[i] = add(psum[i - 1], dp[i], m);\n    for (long long j = 2; j * i <= n; j++) {\n      long long l = j * i;\n      long long r = j * (i + 1);\n      upd[l] = add(upd[l], dp[i], m);\n      if (r <= n) {\n        upd[r] = sub(upd[r], dp[i], m);\n      }\n    }\n  }\n  cout << dp[n] << \"\\n\";\n}\nsigned main() {\n  cout << fixed << setprecision(12);\n  ;\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  for (long long testcase = 1; testcase < t + 1; testcase++) {\n    solvethetestcase();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int N = 4e6 + 10;\nint f[N];\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, P;\n  cin >> n >> P;\n  f[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    f[i] = (f[i] + 2 * f[i - 1] % P + (i != 2 ? f[1] : 0)) % P;\n    for (int j = 2; j * i <= n; j++) {\n      f[j * i] = ((f[j * i] + f[i]) % P - f[i - 1] + P) % P;\n    }\n  }\n  cout << f[n] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m;\nlong long dp[4000050];\nlong long sum[4000050];\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  dp[n] = 1;\n  sum[n + 1] = 0;\n  for (long long i = n; i >= 1; --i) {\n    dp[i] += sum[i + 1];\n    dp[i] %= m;\n    for (long long j = 2; j * i <= n; ++j) {\n      long long l = j * i;\n      long long r = min(j * i + j, n + 1);\n      dp[i] += (sum[l] - sum[r]);\n      dp[i] %= m;\n    }\n    sum[i] = sum[i + 1] + dp[i];\n    sum[i] %= m;\n  }\n  printf(\"%lld\\n\", dp[1]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int rd() {\n  int x = 0;\n  char ch, t = 0;\n  while (!isdigit(ch = getchar())) t |= ch == '-';\n  while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n  return x = t ? -x : x;\n}\nlong long maxll(long long x, long long y) { return x > y ? x : y; }\nlong long minll(long long x, long long y) { return x < y ? x : y; }\nlong long absll(long long x) { return x > 0ll ? x : -x; }\nlong long gcd(long long x, long long y) { return (y == 0) ? x : gcd(y, x % y); }\nint n, mod;\nint sum, pre[8000005];\nint main() {\n  n = rd(), mod = rd();\n  pre[2] = 1;\n  for (int j = 2; j <= n; j++) {\n    pre[j] = (pre[j] + 1) % mod;\n    pre[j + j] = (pre[j + j] + mod - 1) % mod;\n  }\n  for (int i = 2, opt; i <= n; i++) {\n    sum = (sum + pre[i]) % mod, opt = n / i;\n    pre[i + 1] = (pre[i + 1] + sum) % mod;\n    if (opt >= 2)\n      for (int j = 2; j <= opt; j++) {\n        pre[i * j] = (pre[i * j] + sum) % mod;\n        pre[i * j + j] = (pre[i * j + j] + mod - sum) % mod;\n      }\n  }\n  printf(\"%d\\n\", sum);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 5e6 + 10;\nlong long dp[maxn];\nlong long sum[maxn];\nint main() {\n  long long n, mod;\n  scanf(\"%lld%lld\", &n, &mod);\n  dp[n] = 1;\n  sum[n] = 1;\n  for (long long i = n - 1; i >= 1; i--) {\n    dp[i] += sum[i + 1];\n    dp[i] %= mod;\n    for (long long j = 2; j * i <= n; j++) {\n      int r = min(n, i * j + j - 1);\n      int l = i * j;\n      dp[i] = dp[i] + ((sum[l] - sum[r + 1]) % mod + mod) % mod;\n    }\n    sum[i] = (sum[i + 1] + dp[i]) % mod;\n  }\n  printf(\"%lld\\n\", dp[1] % mod);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 5e6 + 7;\nlong long n;\nlong long mod;\nlong long dak[N];\nlong long dp[N];\nlong long s[N];\nsigned main() {\n  cin >> n >> mod;\n  dp[1] = 1;\n  for (long long i = 2; i <= n; i++) {\n    dak[1 * i]++;\n    dak[1 * i] %= mod;\n    if (2 * i > n) continue;\n    dak[2 * i]--;\n    dak[2 * i] = (dak[2 * i] + mod) % mod;\n  }\n  s[1] = 1;\n  for (long long i = 2; i <= n; i++) {\n    dak[i] += dak[i - 1];\n    dak[i] %= mod;\n    dp[i] = s[i - 1] + dak[i];\n    dp[i] %= mod;\n    for (long long j = 2; j <= n / i; j++) {\n      dak[i * j] += dp[i];\n      dak[i * j] %= mod;\n      if ((i + 1) * j > n) continue;\n      dak[(i + 1) * j] -= dp[i];\n      dak[(i + 1) * j] = (dak[(i + 1) * j] + mod) % mod;\n    }\n    s[i] = s[i - 1] + dp[i];\n    s[i] %= mod;\n  }\n  cout << dp[n];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class c>\nstruct rge {\n  c b, e;\n};\ntemplate <class c>\nrge<c> range(c i, c j) {\n  return rge<c>{i, j};\n}\ntemplate <class c>\nauto dud(c* x) -> decltype(cerr << *x, 0);\ntemplate <class c>\nchar dud(...);\nstruct debug {\n  template <class c>\n  debug& operator<<(const c&) {\n    return *this;\n  }\n};\nvector<char*> tokenizer(const char* args) {\n  char* token = new char[111];\n  strcpy(token, args);\n  token = strtok(token, \", \");\n  vector<char*> v({token});\n  while (token = strtok(NULL, \", \")) v.push_back(token);\n  return reverse(v.begin(), v.end()), v;\n}\nvoid debugg(vector<char*> args) { cerr << \"\\b \"; }\ntemplate <typename Head, typename... Tail>\nvoid debugg(vector<char*> args, Head H, Tail... T) {\n  debug() << \" [\" << args.back() << \": \" << H << \"] \";\n  args.pop_back();\n  debugg(args, T...);\n}\nconst double PI = acos(-1);\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int test = 1;\ntpo:\n  while (test--) {\n    long long n, mod;\n    cin >> n >> mod;\n    vector<long long> dp(n + 1, 0);\n    vector<long long> prefix(n + 1, 0);\n    long long prevSum = 0;\n    for (int i = 1; i <= n; i++) {\n      if (i == 1) {\n        prevSum = 1;\n        dp[i] = 1;\n        prefix[i] = 1;\n        continue;\n      }\n      prefix[i] += prefix[i - 1];\n      dp[i] = (prefix[i] + prevSum) % mod;\n      dp[i] += (i / 2);\n      if (i % 2 == 1) dp[i] += 1;\n      dp[i]--;\n      dp[i] %= mod;\n      for (int a = 2 * i, p = 2; a <= n; a += i, p += 1) {\n        prefix[a] += dp[i];\n        prefix[a] %= mod;\n        int subIndex = a + p;\n        if (subIndex <= n) {\n          prefix[subIndex] -= dp[i];\n          if (prefix[subIndex] < 0) {\n            prefix[subIndex] = ((prefix[subIndex] % mod) + mod) % mod;\n          }\n        }\n      }\n      prevSum += dp[i];\n      prevSum %= mod;\n    }\n    cout << dp[n] << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 4e6 + 5;\nlong long n, m, dp[MAXN], f1[MAXN], f2[MAXN], s;\nsigned main() {\n  cin >> n >> m;\n  f2[1] = 1;\n  f2[2] = m - 1;\n  for (long long i = 1; i <= n; ++i) {\n    (s += f2[i]) %= m;\n    dp[i] = (f1[i - 1] + s) % m;\n    for (long long j = 2; i * j <= n; ++j) {\n      (f2[i * j] += dp[i]) %= m;\n      if (i * j + j <= n) {\n        (f2[i * j + j] -= dp[i]) %= m;\n      }\n    }\n    f1[i] = (f1[i - 1] + dp[i]) % m;\n  }\n  dp[n] %= m;\n  dp[n] = (dp[n] + m) % m;\n  cout << dp[n] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# ------------------------template--------------------------#\nimport os\nimport sys\nimport math\nimport collections\nimport functools\nimport itertools\n\n# from fractions import *\nimport heapq\nimport bisect\nfrom io import BytesIO, IOBase\n\n\ndef vsInput():\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA = \"abcde\"\nMOD = 10 ** 9 + 7\nEPS = 1e-6\n\n\ndef Ceil(a, b):\n    return a // b + int(a % b > 0)\n\n\ndef INT():\n    return int(input())\n\n\ndef STR():\n    return input()\n\n\ndef INTS():\n    return tuple(map(int, input().split()))\n\n\ndef ARRINT():\n    return [int(i) for i in input().split()]\n\n\ndef ARRSTR():\n    return [i for i in input().split()]\n\n\n# -------------------------code---------------------------#\n\n\nn, MOD = INTS()\n\ndp = [0] * (n + 2)\ndp[n] = 1\n\nfor i in range(n - 1, 0, -1):\n    tmp = dp[i + 1]\n    j = 2\n    while i * j < n + 2:\n        tmp += dp[i * j] - dp[min(n + 1, (i + 1) * j)]\n        tmp %= MOD\n        j += 1\n    dp[i] = tmp + dp[i + 1]\n    dp[i] %= MOD\n\nprint((dp[1] - dp[2]) % MOD)\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom io import BytesIO, IOBase\nimport os\n\n################################ <fast I/O> ###########################################\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, **kwargs):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\n#############################################<I/O Region >##############################################\n\n\ndef inp():\n    return sys.stdin.readline().strip()\n\n\ndef map_inp(v_type):\n    return map(v_type, inp().split())\n\n\ndef list_inp(v_type):\n    return list(map_inp(v_type))\n\n\n######################################## Solution ####################################\n\nn, m = map_inp(int)\ndp = [0 for col in range(n + 1)]\nadd_q = [0 for item in range(n + 2)]\ndp[n] = 1\nadd_q[n] = 1\nfor i in range(n - 1, 0, -1):\n    dp[i] += add_q[i + 1] % m\n    z = 2\n    for temp in range(i * z, n + 1, i):\n        left = i * z\n        right = min(i * z + z - 1, n)\n        dp[i] += add_q[left] - add_q[right + 1]\n        dp[i] %= m\n        z += 1\n    add_q[i] += dp[i] + add_q[i + 1]\n    add_q[i] %= m\nprint(dp[1])\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n/*\n\n*/\n \n public class D{\n\tstatic FastReader sc=null;\n\tstatic long mod;\n\t\n\tpublic static void main(String[] args) {\n\t\tsc=new FastReader();\n\t\tint n=sc.nextInt();\n\t\tmod=sc.nextLong();\n\t\tlong dp[]=new long[n+2],suf[]=new long[n+2];\n\t\t\n\t\tdp[n]=1;\n\t\tsuf[n]=1;\n\t\tfor(int i=n-1;i>0;i--) {\n\t\t\tfor(int j=2;j*i<=n;j++) {\n\t\t\t\tdp[i]+=suf[j*i];\n\t\t\t\tif(dp[i]>=mod)dp[i]-=mod;\n\t\t\t\tif(j*(i+1)<=n) {\n\t\t\t\t\tdp[i]-=suf[(j*(i+1))];\n\t\t\t\t\tif(dp[i]<0)dp[i]+=mod;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tdp[i]+=suf[i+1];\n\t\t\tif(dp[i]>=mod)dp[i]-=mod;\n\t\t\tsuf[i]=suf[i+1]+dp[i];\n\t\t\tif(suf[i]>=mod)suf[i]-=mod;\n\t\t}\n\t\tSystem.out.println(dp[1]);\n\t\t\n\t}\n\t\n\tstatic int[] ruffleSort(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al);\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\t\n\tstatic void print(int a[]) {\n\t\tfor(int e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic class FastReader{\n\t\t\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString next() {\n\t\t\twhile(!st.hasMoreTokens()) \n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t   catch(IOException e){\n\t\t\t\t   e.printStackTrace();\n\t\t\t   }\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++)a[i]=sc.nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = 0x3f3f3f3f;\nlong long sum[4000010], f[4000010];\nsigned main() {\n  long long n, m;\n  sum[1] = 1;\n  f[1] = 1;\n  cin >> n >> m;\n  f[n] = sum[n] = 1;\n  for (long long i = n - 1; i >= 1; i--) {\n    f[i] = sum[i + 1];\n    for (long long j = 2; i * j <= n; j++) {\n      long long l = i * j, r = min(n, (i + 1) * j - 1);\n      if (l <= r) f[i] = ((f[i] + sum[l]) % m - sum[r + 1]) % m;\n    }\n    sum[i] = (sum[i + 1] + f[i]) % m;\n  }\n  cout << (f[1] + m) % m << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nvoid solve() {\n  cin >> n >> m;\n  vector<long long> f(n + 1, 0);\n  f[1] = 1;\n  long long cursum = 0;\n  for (int i = 2; i <= n; i++) {\n    cursum += f[i - 1] + f[1];\n    cursum %= m;\n    f[i] += cursum;\n    f[i] %= m;\n    cursum = f[i];\n    for (int j = 2 * i; j <= n; j += i) {\n      f[j] += (f[i] - f[i - 1]);\n      f[j] %= m;\n    }\n  }\n  cout << (f[n] + m) % m << endl;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout << fixed << setprecision(10);\n  int t = 1;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6, mod = 1e9 + 7;\nlong long n, m, ans[4 * N + 1];\nvoid input() {\n  cin >> n >> m;\n  ans[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    ans[i] = (ans[i] + 2LL * ans[i - 1] + 1) % m;\n    if (i == 2) ans[i]--;\n    for (int j = 2 * i; j <= n; j += i)\n      ans[j] = (ans[j] + ans[i] - ans[i - 1] + m) % m;\n  }\n  cout << ans[n] << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  input();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  long long n, m;\n  cin >> n >> m;\n  vector<long long> dp(n + 1, 0);\n  dp[1] = 1;\n  dp[2] = 2;\n  for (int j = 4; j <= n; j += 2) dp[j] = (dp[j] + 1) % m;\n  for (int i = 3; i <= n; i++) {\n    dp[i] = (dp[i] + 2 * dp[i - 1] + 1) % m;\n    for (int j = 2 * i; j <= n; j += i) {\n      long long inc = dp[i] - dp[i - 1];\n      while (inc < 0) inc += m;\n      dp[j] = (dp[j] + inc) % m;\n    }\n  }\n  cout << dp[n] << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e6 + 100;\nint mod;\nlong long dp[N], sum[N];\nvoid solve() {\n  int n;\n  cin >> n >> mod;\n  dp[n] = 1;\n  sum[n] = 1;\n  sum[n + 1] = 0;\n  for (int i = n - 1; i >= 1; i--) {\n    dp[i] = sum[i + 1];\n    for (int j = i + i; j <= n; j += i) {\n      dp[i] = (dp[i] + sum[j] - sum[min(j + j / i - 1, n) + 1] + mod) % mod;\n    }\n    sum[i] = (dp[i] + sum[i + 1]) % mod;\n  }\n  cout << dp[1] % mod << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int t;\n  t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint dp[4000400];\nint sum[4000400];\nint f(int l, int r) {\n  if (r > n) {\n    r = n;\n  }\n  int x = sum[l] - sum[r + 1];\n  if (x < 0) {\n    x += m;\n  }\n  return x;\n}\nint main() {\n  cin >> n >> m;\n  dp[n] = 1;\n  sum[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    for (int z = 2; i * z <= n; z++) {\n      dp[i] += f(i * z, (i + 1) * z - 1);\n      if (dp[i] >= m) {\n        dp[i] -= m;\n      }\n    }\n    dp[i] += sum[i + 1];\n    if (dp[i] >= m) {\n      dp[i] -= m;\n    }\n    sum[i] = sum[i + 1] + dp[i];\n    if (sum[i] >= m) {\n      sum[i] -= m;\n    }\n  }\n  cout << dp[1];\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\nc = [0] * (n-1) + [1, 0]\nfor i in range(n-1, 0, -1):\n    c[i-1] = 2*c[i] % m\n    for j in range(2, n//i + 1):\n        c[i-1] = (c[i-1] + c[i*j-1] - c[min(n, i*j-1 + j)]) % m\n\nprint((c[0] - c[1]) % m)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, mo;\nlong long f[4000004], sum[4000004];\nint main() {\n  scanf(\"%d%d\", &n, &mo);\n  f[n] = sum[n] = 1;\n  for (int i = n - 1; i; i--) {\n    f[i] += sum[i + 1];\n    for (int j = 2; i * j <= n; j++)\n      f[i] += ((sum[i * j] - sum[min(i * j + j, n + 1)]) % mo + mo) % mo,\n          f[i] %= mo;\n    sum[i] = (sum[i + 1] + f[i]) % mo;\n  }\n  printf(\"%lld\\n\", (f[1] % mo + mo) % mo);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, mod = map(int, input().split())\ndp = [0]*(n+1)\ndp[-1] = 1\nsuffix_sum = [0]*(n+1)\nsuffix_sum[-1] = 1\nfor i in range(n-1, 0, -1):\n    dp[i] = suffix_sum[i+1]\n    for j in range(2, n//i+1):\n        dp[i] = (dp[i] + suffix_sum[i*j] -\n                 (suffix_sum[i*j+j] if i*j+j <= n else 0)) % mod\n    suffix_sum[i] = (suffix_sum[i+1] + dp[i]) % mod\nprint(dp[1] % mod)\n"
        },
        {
            "language": 3,
            "solution": "\nimport sys\ninput=sys.stdin.readline #\u6587\u5b57\u5217\u5165\u529b\u306f\u3059\u308b\u306a\uff01\uff01\n\nn,m=map(int,input().split())\nmod=m\ndp=[0]*(n+3)\ndp[n]=1\nsdp=[0]*(n+3)\nsdp[n]=1\n\nfor x in range(n-1,0,-1):\n    dp[x]+=sdp[x+1]\n    dp[x]%=mod\n    z=2\n    while x*z<=n:\n        l=x*z\n        r=(x+1)*z-1\n        if r>n:r=n\n        dp[x]+=sdp[l]-sdp[r+1]\n        dp[x]%=mod\n        z+=1\n    sdp[x]=sdp[x+1]+dp[x]\n    sdp[x]%=mod\n\nprint(dp[1]%mod)\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing cd = complex<double>;\nconst double PI = acos(-1);\nconst int N = 4e6 + 10;\nint d[N], ans[N], sum[N];\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  ans[1] = 1;\n  for (int i = 2; i <= n; i++) d[i] = 1;\n  sum[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    d[i] += d[i - 1];\n    d[i] %= m;\n    ans[i] = (d[i] + sum[i - 1]) % m;\n    for (int j = i + i; j <= n; j += i) {\n      d[j] -= ans[i - 1];\n      d[j] %= m;\n      d[j] += ans[i];\n      d[j] %= m;\n      if (d[j] < 0) d[j] += m;\n    }\n    sum[i] = (sum[i - 1] + ans[i]) % m;\n  }\n  cout << ans[n] << \"\\n\";\n}\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n  int tc = 1;\n  int t;\n  t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ans[4000005];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n, m;\n  cin >> n >> m;\n  long long sum = 1, sum1 = 0;\n  ans[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    sum1 = (sum1 + ans[i] + 1) % m;\n    ans[i] = (sum + sum1) % m;\n    sum = (sum + ans[i]) % m;\n    for (int j = 2 * i; j <= n; j += i)\n      ans[j] = (ans[j] + ans[i] - ans[i - 1]) % m;\n  }\n  cout << (ans[n] + m) % m << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst long long INF = INT_MAX;\nconst long double pi = 4 * atan((long double)1);\ntemplate <class T>\ninline T gcd(T a, T b) {\n  if (b)\n    return gcd(b, a % b);\n  else\n    return a;\n}\ntemplate <class T>\ninline T lcm(T a, T b) {\n  return a / gcd(a, b) * b;\n}\nlong long f[4000006];\nsigned main() {\n  ios::sync_with_stdio();\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long n, m;\n  scanf(\"%lld%lld\", &n, &m);\n  f[1] = 1;\n  for (long long i = 2; i <= n; ++i) {\n    f[i] += ((2 * f[i - 1] + 1) % m);\n    f[i] = f[i] % m;\n    if (i == 2) f[i]--;\n    for (long long j = 2 * i; j <= n; j += i) {\n      f[j] += (f[i] - f[i - 1]);\n      f[j] = (f[j] + m) % m;\n    }\n  }\n  cout << f[n];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nbool MEMST;\nconst long long N = 5e6 + 5;\nlong long n, P, f[N], g[N], sum[N];\nbool MEMED;\nsigned main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n  cin >> n >> P;\n  f[1] = 1;\n  for (long long i = 1; i <= n; ++i) {\n    g[i] = (g[i] + g[i - 1]) % P;\n    f[i] = (f[i] + g[i] + sum[i - 1]) % P;\n    for (long long j = 2; i * j <= n; ++j) {\n      g[i * j] = (g[i * j] + f[i]) % P;\n      if (1ll * i * j + j <= n) g[i * j + j] = (g[i * j + j] - f[i] + P) % P;\n    }\n    sum[i] = (sum[i - 1] + f[i]) % P;\n  }\n  cout << f[n] << '\\n';\n  cout.flush();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint f[4000001];\nint n, m;\nint main() {\n  cin >> n >> m;\n  f[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    f[i] = (i == 2) ? 2 : (f[i] + ((f[i - 1] * 2) % m) + 1) % m;\n    for (int j = 2; j * i <= n; j++) {\n      int dif = f[i] - f[i - 1];\n      if (dif < 0) dif = m + dif;\n      f[i * j] = (f[i * j] + dif) % m;\n    }\n  }\n  cout << f[n];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000 * 1000 * 1000;\nconst long long LINF = 1LL * INF * INF;\nconst int MAX = 100010;\nconst long double PI = acos(-1.);\nconst double EPS = 1e-6;\nconst long long MOD = INF + 7;\nlong long v[8000500];\nlong long da[8000500];\nint m;\nvoid add(long long& a, long long b) {\n  a += b;\n  while (a >= m) a -= m;\n}\nlong long sub(long long& a, long long b) {\n  long long q = a - b;\n  if (q < 0) q += m;\n  return q;\n}\nlong long mult(long long a, long long b) { return (a * b) % m; }\nvoid solve() {\n  int n;\n  cin >> n >> m;\n  v[1] = 1;\n  long long a = 0;\n  long long pf = 0;\n  for (int i = 1; i < n + 1; ++i) {\n    add(pf, da[i]);\n    add(v[i], pf);\n    add(v[i], a);\n    add(a, v[i]);\n    for (int j = 2; j * i <= n; j++) {\n      add(da[j * i], v[i]);\n      da[j * (i + 1)] = sub(da[j * (i + 1)], v[i]);\n    }\n  }\n  cout << v[n] << endl;\n  cerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e6 + 10;\nlong long f[N];\nlong long c[N], n, mod;\nint main() {\n  cin >> n >> mod;\n  f[n] = 1;\n  for (int i = n; i >= 1; i--) {\n    f[i] = f[i] + c[i + 1] - c[n + 1];\n    for (int j = i + 1, l, r; j <= n; j = r + 1) {\n      l = j, r = (j / i + 1) * i - 1;\n      r = min(1ll * r, n);\n      f[i] = (f[i] + 1ll * j / i * (c[l] - c[r + 1]));\n      if (f[i] > 1e18) f[i] %= mod;\n    }\n    for (int j = i + 1, l, r; j <= n; j = r + 1) {\n      l = j, r = (j / (i + 1) + 1) * (i + 1) - 1;\n      r = min(1ll * r, n);\n      f[i] = (f[i] - 1ll * j / (i + 1) * (c[l] - c[r + 1]));\n      if (f[i] > 1e18) f[i] %= mod;\n    }\n    if (f[i] > 1e18) f[i] %= mod;\n    c[i] = (c[i + 1] + f[i]) % mod;\n  }\n  cout << (f[1] + mod) % mod << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization(\"unroll-loops\")\nconst long long M = 998244353;\nconst long long INF = LLONG_MAX;\nconst long long MOD = 1e9 + 7;\nconst float pi = 3.1415926535897932384626433832795028841971693993751058209749;\nusing namespace std;\nlong long Prime(long long x) {\n  bool flag = 1;\n  for (long long i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      flag = 0;\n      break;\n    }\n  }\n  return flag;\n}\nlong long gcd(long long r, long long b) {\n  long long x = 1;\n  while (b != 0) {\n    x = b;\n    b = r % b;\n    r = x;\n  }\n  return x;\n}\nlong long po(long long x, long long y) {\n  long long res = 1;\n  while (y) {\n    if (y % 2) res = (res * x) % MOD;\n    y /= 2;\n    x = (x * x) % MOD;\n  }\n  return res;\n}\nvoid io() {}\nvoid solve() {\n  long long n, mod;\n  cin >> n >> mod;\n  vector<long long> dp(n + 1, 0);\n  vector<long long> pre(n + 1, 0);\n  long long pre_sum = 0;\n  for (long long i = 1; i <= n; i++) {\n    if (i == 1) {\n      dp[i] = 1;\n      pre_sum = 1;\n      pre[i] = 1;\n      continue;\n    }\n    pre[i] += pre[i - 1];\n    dp[i] = (pre[i] + pre_sum) % mod;\n    dp[i] += (i / 2);\n    if (i % 2 == 1) dp[i] += 1;\n    dp[i]--;\n    dp[i] %= mod;\n    for (long long a = 2 * i, p = 2; a <= n; a += i, p += 1) {\n      pre[a] += dp[i];\n      pre[a] %= mod;\n      long long subIdx = a + p;\n      if (subIdx <= n) {\n        pre[subIdx] -= dp[i];\n        if (pre[subIdx] < 0) {\n          pre[subIdx] = ((pre[subIdx] % mod) + mod) % mod;\n        }\n      }\n    }\n    pre_sum += dp[i];\n    pre_sum %= mod;\n  }\n  cout << dp[n] << endl;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, mod;\nconst int nax = 4e6 + 5;\nlong long int dp[nax];\nlong long int pref[nax];\nvoid solve() {\n  cin >> n >> mod;\n  dp[n] = 1;\n  pref[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    dp[i] = pref[i + 1];\n    for (int mul = 2; mul * i <= n; mul++) {\n      int LO = i * mul;\n      int HI = min(n, LO + mul - 1);\n      long long int sum = pref[LO] - pref[HI + 1];\n      dp[i] += sum;\n      dp[i] %= mod;\n    }\n    pref[i] = pref[i + 1] + dp[i];\n    pref[i] %= mod;\n  }\n  cout << dp[1];\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int tt = 1;\n  while (tt--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 4e6 + 10;\nlong long sol[MAXN];\nlong long sum[MAXN];\nlong long sub_mod(long long a, long long b, long long m) {\n  if (a >= b)\n    return a - b;\n  else\n    return m - b + a;\n}\nlong long add_mod(long long a, long long b, long long m) {\n  if (0 == b) return a;\n  b = m - b;\n  if (a >= b)\n    return a - b;\n  else\n    return m - b + a;\n}\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  sol[n] = 1;\n  sum[n] = 1;\n  for (long long i = n - 1; i >= 1; i--) {\n    sol[i] = sum[i + 1];\n    for (long long j = 2;; j++) {\n      if (i * j > n) break;\n      if (i * j + j <= n) {\n        sol[i] = sub_mod(add_mod(sol[i], sum[i * j], m), sum[i * j + j], m);\n      } else {\n        sol[i] = sub_mod(add_mod(sol[i], sum[i * j], m), 0, m);\n      }\n    }\n    sum[i] = add_mod(sol[i], sum[i + 1], m);\n  }\n  cout << sol[1] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nn,m=map(int,input().split())\ndp=[0]*(n+1)\ndp[1]=1\ndp[2]=2\nfor i in range(2, n+1):\n    if i>2:\n        dp[i]=((dp[i]+dp[i-1])%m+dp[i-1]+1)%m\n    for j in range(i+i, n+1, i):\n        dp[j]=(dp[j]+dp[i]-dp[i-1])%m\nprint(dp[n])"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> conn[1000005];\nbool vi[1000005];\nvoid init(int k) {\n  for (int i = 0; i <= k; i++) {\n    vi[i] = false;\n    conn[i].clear();\n  }\n}\nbool isprime(int k) {\n  for (int i = 2; i <= sqrt(k); i++)\n    if (k % i == 0) return false;\n  return true;\n}\nint bm(int a, int b, int mod) {\n  if (b == 0) return 1;\n  int t = bm(a, b / 2, mod);\n  t = t * t % mod;\n  return (b % 2 == 1 ? t * a % mod : t);\n}\nint inv(int a, int mod) { return bm(a, mod - 2, mod); }\nvoid solve() {\n  long long n, mod;\n  cin >> n >> mod;\n  int dp[n + 5];\n  dp[0] = 0;\n  dp[1] = 1;\n  int sum = 1;\n  int idk[n + 5];\n  int add[n + 5];\n  for (int i = 2; i <= n; i++) dp[i] = 0;\n  for (int i = 0; i <= n; i++) idk[i] = 0;\n  for (int i = 2; i <= n; i++) add[i] = 1;\n  for (int i = 2; i <= n; i++) {\n    sum += add[i];\n    sum %= mod;\n    dp[i] += sum;\n    dp[i] %= mod;\n    sum = (sum + dp[i]) % mod;\n    for (int j = 2; j * i <= n; j++) {\n      add[j * i] = (add[j * i] + (dp[i] - dp[i - 1] + mod)) % mod;\n    }\n  }\n  dp[n] %= mod;\n  if (dp[n] < 0) dp[n] += mod;\n  cout << dp[n] % mod << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nimport os\nfrom io import BytesIO\n\n# pypy2\nif sys.version_info[0] < 3:\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n\nf = sys.stdin\n\nline = lambda: f.readline().strip('\\r\\n').split()\n\nn, m = map(int, line())\ndp = [0] * (n + 1)\ndp[1] = 1\ndp[2] = 2\nfor i in range(2, n+1):\n    if i != 2:\n        dp[i] = (dp[i] + dp[i-1])%m\n        dp[i] = (dp[i] + 1 + dp[i-1]) % m\n    for j in range(2*i, n+1, i):\n        dp[j] = (dp[j] - dp[i-1] + dp[i]) % m\nprint(dp[n]%m)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace chrono;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"O2\")\nlong long MOD = 1e9 + 7;\nlong long power(long long a, long long b, long long m = MOD) {\n  long long ans = 1;\n  a = a % m;\n  while (b > 0) {\n    if (b & 1) ans = (1ll * a * ans) % m;\n    b >>= 1;\n    a = (1ll * a * a) % m;\n  }\n  return ans;\n}\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long lcm(long long x, long long y) { return (x * y) / gcd(x, y); }\nbool isprime(long long n) {\n  if (n < 2) return 0;\n  long long i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) return 0;\n    i++;\n  }\n  return 1;\n}\nbool isPowerOfTwo(long long x) { return x && (!(x & (x - 1))); }\ndouble distform(long long x, long long y, long long z, long long w) {\n  return sqrt(1. * pow(x - z, 2) + 1. * pow(y - w, 2));\n}\nlong long dx[] = {-1, 1, 0, 0, -1, 1, 1, -1};\nlong long dy[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst long long MAXN = 4e6 + 10;\nconst long long inf = 1e18;\ntemplate <typename T, typename T1>\nT amax(T &a, T1 b) {\n  if (b > a) a = b;\n  return a;\n}\ntemplate <typename T, typename T1>\nT amin(T &a, T1 b) {\n  if (b < a) a = b;\n  return a;\n}\nlong long intlog(double base, double x) {\n  return (long long)(log(x) / log(base));\n}\nbool isvalid(long long x, long long y, long long n, long long m) {\n  return x >= 0 and x < n and y >= 0 and y < m;\n}\ntemplate <typename T>\nvoid read(T &x) {\n  for (long long i = 0; i < ((long long)(x).size()); ++i) cin >> x[i];\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nlong long query(long long start, long long end) {\n  cout << \"? \" << start << \" \" << end << '\\n';\n  long long q;\n  cin >> q;\n  return q;\n}\nvoid print(long long n) { cout << \"! \" << n << '\\n'; }\nstruct Local {\n  char paramA;\n  Local(char paramA) { this->paramA = paramA; }\n  bool operator()(long long i, long long j, ...) { return false; }\n};\nlong long diff_array[MAXN];\nvoid solve() {\n  long long n, m;\n  cin >> n >> m;\n  MOD = m;\n  vector<long long> dp(n + 1);\n  dp[1] = 1;\n  long long sum = 0;\n  long long diff_sum = 0;\n  for (long long i = 1; i <= n; ++i) {\n    diff_sum += diff_array[i];\n    if (i != 1) dp[i] = diff_sum;\n    dp[i] = (dp[i] + sum) % MOD;\n    sum = (sum + dp[i]) % MOD;\n    for (long long j = 2; i * j <= n; ++j) {\n      diff_array[j * i] += dp[i];\n      diff_array[j * i] %= MOD;\n      diff_array[min(n, (j * (i + 1)) - 1) + 1] -= dp[i];\n      diff_array[min(n, (j * (i + 1)) - 1) + 1] %= MOD;\n    }\n    diff_sum %= MOD;\n  }\n  cout << (dp[n] + MOD) % MOD << '\\n';\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(NULL);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint main() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, mod;\n  cin >> n >> mod;\n  vector<int> dp(n + 1), suf(n + 1);\n  dp[n] = 1;\n  for (int i = n - 1; i > 0; i--) {\n    suf[i] = dp[i + 1] + suf[i + 1];\n    if (suf[i] >= mod) suf[i] -= mod;\n    dp[i] = suf[i];\n    for (int j = 2; i * j <= n; j++) {\n      int l = i * j, r = min(n + 1, l + j);\n      int u = suf[l - 1] - suf[r - 1];\n      if (u < 0) u += mod;\n      dp[i] += u;\n      if (dp[i] >= mod) dp[i] -= mod;\n    }\n  }\n  cout << dp[1] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e6 + 10;\nlong long f[N];\nlong long c[N], n, mod;\nlong long min(long long a, long long b) {\n  if (a < b)\n    return a;\n  else\n    return b;\n}\nint main() {\n  cin >> n >> mod;\n  f[n] = 1;\n  for (int i = n; i >= 1; i--) {\n    f[i] = f[i] + c[i + 1] - c[n + 1];\n    for (int j = i + 1, l, r; j <= n; j = r + 1) {\n      l = j, r = (j / i + 1) * i - 1;\n      r = min(1ll * r, n);\n      f[i] = (f[i] + 1ll * j / i * (c[l] - c[r + 1]));\n      if (f[i] > 1e18) f[i] %= mod;\n    }\n    for (int j = i + 1, l, r; j <= n; j = r + 1) {\n      l = j, r = (j / (i + 1) + 1) * (i + 1) - 1;\n      r = min(1ll * r, n);\n      f[i] = (f[i] - 1ll * j / (i + 1) * (c[l] - c[r + 1]));\n      if (f[i] > 1e18) f[i] %= mod;\n    }\n    if (f[i] > 1e18) f[i] %= mod;\n    c[i] = (c[i + 1] + f[i]) % mod;\n  }\n  cout << (f[1] + mod) % mod << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n/*\n\n*/\n \n public class D{\n\tstatic FastReader sc=null;\n\tstatic long mod;\n\t\n\tpublic static void main(String[] args) {\n\t\tsc=new FastReader();\n\t\tint n=sc.nextInt();\n\t\tmod=sc.nextLong();\n\t\tlong dp[]=new long[n+2],suf[]=new long[n+2];\n\t\t\n\t\tdp[n]=1;\n\t\tsuf[n]=1;\n\t\tfor(int i=n-1;i>0;i--) {\n\t\t\tif(dp[i]>=mod)dp[i]-=mod;\n\t\t\t\n\t\t\tfor(int j=2;j*i<=n;j++) {\n\t\t\t\tdp[i]+=suf[j*i];\n\t\t\t\tif(dp[i]>=mod)dp[i]-=mod;\n\t\t\t\tif(j*(i+1)<=n) {\n\t\t\t\t\tdp[i]-=suf[(j*(i+1))];\n\t\t\t\t\tif(dp[i]<0)dp[i]+=mod;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tdp[i]+=suf[i+1];\n\t\t\tif(dp[i]>=mod)dp[i]-=mod;\n\t\t\tsuf[i]=suf[i+1]+dp[i];\n\t\t\tif(suf[i]>=mod)suf[i]-=mod;\n\t\t}\n\t\tSystem.out.println(dp[1]);\n\t\t\n\t}\n\t\n\tstatic int[] ruffleSort(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al);\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\t\n\tstatic void print(int a[]) {\n\t\tfor(int e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic class FastReader{\n\t\t\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString next() {\n\t\t\twhile(!st.hasMoreTokens()) \n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t   catch(IOException e){\n\t\t\t\t   e.printStackTrace();\n\t\t\t   }\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++)a[i]=sc.nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble log(double x, double base) { return log(x) / log(base); }\nstring operator*(const string& a, int b) {\n  string res = \"\";\n  for (int i = 1; i <= b; i++) res += a;\n  return res;\n}\nconst long double eps = 1e-7;\nconst long long N = 5e6;\nlong long n, mod;\nlong long dp[N], prefx[N];\nlong long sieve[N];\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> mod;\n  dp[1] = 1;\n  prefx[1] = 1;\n  for (long long i = 1, j = 2; j <= n; j++) {\n    sieve[i * j] += dp[1];\n    if ((i + 1) * j <= n) sieve[(i + 1) * j] -= dp[1];\n  }\n  for (long long i = 2; i <= n; i++) {\n    sieve[i] = (sieve[i] + sieve[i - 1] % mod) % mod;\n    dp[i] = (prefx[i - 1] + sieve[i]) % mod;\n    prefx[i] = (prefx[i - 1] + dp[i]) % mod;\n    for (long long j = 2; i * j <= n; j++) {\n      sieve[i * j] = (sieve[i * j] + dp[i] % mod + mod * mod) % mod;\n      if ((i + 1) * j <= n) sieve[(i + 1) * j] -= dp[i];\n    }\n  }\n  cout << (dp[n] + mod * mod) % mod << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\n#pragma comment(linker, \"/STACK:16777216\")\nusing namespace std;\nconst int INF = 1000000000 + 1e8;\nconst long long LINF = 2000000000000000000;\nconst int N = 1e5 + 10;\nint add(int a, int b, int mod) { return a + b > mod ? a + b - mod : a + b; }\nvoid solve() {\n  int n, mod;\n  cin >> n >> mod;\n  vector<int> dp(n + 1, 0);\n  dp[n] = 1;\n  vector<int> suff(n + 1);\n  suff[n] = 1;\n  for (int i = n - 1; i >= 1; i--) {\n    for (int j = 2; j <= n / i; j++) {\n      int l = i * j;\n      int r = i * j + j - 1;\n      int val = add(suff[l], mod - (r + 1 > n ? 0 : suff[r + 1]), mod);\n      dp[i] = add(dp[i], val, mod);\n    }\n    dp[i] = add(dp[i], suff[i + 1], mod);\n    suff[i] = add(dp[i], suff[i + 1], mod);\n  }\n  cout << dp[1] << '\\n';\n}\nsigned main() {\n  srand(time(0));\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int tst = 1;\n  while (tst--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 4000009;\nlong long MOD;\nlong long dp[N];\nsigned main(void) {\n  ios::sync_with_stdio(false);\n  long long n;\n  cin >> n >> MOD;\n  dp[1] = 1;\n  dp[2] = 2;\n  for (long long j = 4; j < N; j += 2) dp[j] += dp[2] - dp[1];\n  for (long long i = 3; i <= n; i++) {\n    dp[i] += 2 * dp[i - 1] + dp[1];\n    dp[i] %= MOD;\n    for (long long j = 2 * i; j < N; j += i) dp[j] += dp[i] - dp[i - 1];\n  }\n  cout << (dp[n] % MOD + MOD) % MOD << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,m = map(int,input().split())\nsumL = [0]*(n+2)\nL = 1\nsumL[-2] = 1\nfor i in range(n-1,0,-1):\n    L = sumL[i+1]\n    j = 2\n    while i*j<=n:\n        L+=(sumL[i*j]-sumL[min(n,(i+1)*j-1)+1])\n        L%=m\n        j+=1\n    L %= m\n    sumL[i] = (sumL[i+1]+L)\n    sumL[i]%=m\nprint(L)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4000000 + 100;\nlong long f[maxn];\nvector<int> p, c;\nvector<int> primes;\nbool flag[maxn];\nvoid init(int N) {\n  for (int i = 2; i <= N; i++) {\n    if (!flag[i]) {\n      primes.push_back(i);\n    }\n    for (int j : primes) {\n      if (i * j > N) break;\n      flag[i * j] = true;\n      if (i % j == 0) break;\n    }\n  }\n}\nvoid div(int x) {\n  p.clear(), c.clear();\n  for (int j = 0; j < primes.size() && primes[j] * primes[j] <= x; j++) {\n    if (x % primes[j] == 0) {\n      p.push_back(primes[j]);\n      c.push_back(0);\n      while (x % primes[j] == 0) x /= primes[j], c.back()++;\n    }\n  }\n  if (x > 1) p.push_back(x), c.push_back(1);\n}\nint n, m;\nlong long val;\nvoid dfs(int d, int cur, int x) {\n  if (d == p.size()) {\n    if (cur == 1) return;\n    if (cur != x) val = (val + m - f[(x - 1) / cur]) % m;\n    val = (val + f[x / cur]) % m;\n    return;\n  }\n  for (int i = 0; i <= c[d]; i++) {\n    dfs(d + 1, cur, x);\n    cur *= p[d];\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  init(n);\n  long long sum = 1;\n  f[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    f[i] = sum;\n    div(i);\n    dfs(0, 1, i);\n    f[i] = (f[i] + val) % m;\n    sum = (sum + f[i]) % m;\n  }\n  printf(\"%lld\\n\", f[n]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, MOD, f[(long long)4e6 + 5], sum[(long long)4e6 + 5],\n    d[(long long)4e6 + 5];\nsigned main() {\n  cin >> n >> MOD;\n  long long Sum = 0;\n  for (long long i = 1; i <= n; i++) {\n    if (i == 1)\n      f[1] = 1;\n    else\n      f[i] = (Sum + d[i] + sum[i - 1]) % MOD;\n    sum[i] = (sum[i - 1] + f[i]) % MOD;\n    for (long long j = 1; j * i <= n; j++) {\n      d[j * i] = (d[j * i] + f[i]) % MOD;\n      if (j * i + j <= n) d[j * i + j] = (d[j * i + j] - f[i] + MOD) % MOD;\n    }\n    Sum = (Sum + d[i]) % MOD;\n  }\n  cout << f[n] % MOD;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint Ruusupuu;\nFILE* rsp_5u;\nusing namespace std;\nconst int N = 4e6 + 10;\ninline int read() {\n  int w = 0;\n  bool fg = 0;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') fg |= (ch == '-'), ch = getchar();\n  while (ch >= '0' && ch <= '9')\n    w = (w << 1) + (w << 3) + (ch ^ 48), ch = getchar();\n  return fg ? -w : w;\n}\nint n, p, a[N], b[N], c[N], sum[N];\ninline int A(int a, int b) { return (a + b >= p) ? (a + b - p) : (a + b); }\ninline int E(int a, int b) { return (a - b < 0) ? (a - b + p) : (a - b); }\ninline int T(int a, int b) { return (1ll * a * b) - ((1ll * a * b) / p) * p; }\ninline int qpow(int x, int b) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = T(ans, x);\n    x = T(x, x), b >>= 1;\n  }\n  return ans;\n}\nvoid sc() { n = read(), p = read(); }\nvoid work() {\n  a[n] = 1;\n  for (register int i = n; i >= 1; i--) {\n    b[i] = A(b[i], b[i + 1]);\n    a[i] = A(a[i], b[i]);\n    for (register int j = 2; j * i <= n; j++) {\n      int l = j * i, r = min(n, (i + 1) * j - 1);\n      a[i] = A(a[i], E(sum[l], sum[r + 1]));\n    }\n    b[i - 1] = A(b[i - 1], a[i]);\n    sum[i] = A(sum[i + 1], a[i]);\n  }\n  printf(\"%d\\n\", a[1]);\n}\nsigned main() {\n  sc();\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\"\"\"RANK1ZEN; 3966 PEAK; NA; FLEX SUPPORT: Zen, Bap; Battlenet ID -> Knuckles#11791\"\"\"\n# region ---------------------------------------------------------------------------|\n# MNNNNNNNNNNNNNNNNMNho///++//+oooooossssssssssssysssooyyyyyso+//++//shNNNNNNNNNNNNNM\n# MNNNNNNNNNNNNNNMNy////////++++oooooooooossssssssoosssssysyyysoossss+/oshNNNNNNNNNNM\n# MNNNNNNNNNNNNMNs///////+oooooo++++oooooooooooso+ossssssssssssssssssss++soymMNNNNNNM\n# MNNNNNNNNNNNMd/:-//+//shNNmhsoo+++++++++ooooo++oooooooooossssssssssssso+ooosmNNNNNM\n# MNNNNNNNNNNMh::://+/+ymMMMMmhsoso+++++++++o+/+ooooooooooooooooooooossso++o+++hMNNNM\n# MNNNNNNNNNMy//-:/+/osmMMMMNhssyshNdssoooo++:++++++++++oooooooooooooooooo++-++/sMMNM\n# MNNNNNNNNMd:/:///+/ohNMMMNhsohyyNMNNNdhhs+:++++++++++++++++++++ooooooooo/+.o+:/+NNM\n# MNNNNNNNMm/:/-///++ooshmmhs+sysdMMMMNdMMd/+++++ooo++++++++++++++++++++++::-++/:/sNM\n# MNNNNNNMN/://-+++++++++oo+//yosNMNMNmNMNo/o/oshNmhyoo+++++++++++++++++++/-/+++:/:sM\n# MNNNNNMNo://-/+++++:/+++++//++osyhmdhMNs/o/+shMMMMmsooooyo++/+++++++++++://+++://oM\n# MNNNNNMs:///:/++++//++-/+/:++++++ooooyo++o-oyNNMMmysooymmso/+shysyyysooo+/++o+/-s+M\n# MNNNNMd:///+:/++++-++:`++:/++++//++++++:+-/oyhsmys+oohmyo++:sNMdmMMNNysy+-ohNs+-myM\n# MNNNMN::///+-:+++:.+/``++/++++++++++++:+/`+++oo/:/++oyo+oy+odNddMMMMmyyh:-sdMh/odyN\n# MNNNNo:///++-:+o/`::```++/+++++++++++//+-.o++:-:/++/+/+ymo/+ossyyhdhssy+.:ohhd/sy+M\n# MMNMh-///+++--oo:`/````++-+++++++++++-o/`/+:.:/+++//+hmNo/++++++ooooooo-`/+o++/++-M\n# MMMN/:///+++-.o/````-s:+/:++++++++++/++`.:.-/++++/+sdmmo/+++++++++++++: -+++++////M\n# MMMh:///++++-`+:```/dN+/::++++++++++++:``.+ooo++ohNMNm++oooooooo+++++o+ :++++/-//oM\n# MMd:/-/+++++-`/.``:hmm//./+++++++++o/o..:osoooymmdddmoooooooooooooo+oms.+++++////+M\n# MMo// -+++++:`.`` dNddo-.:+++++++++++--/soo:.--::ymh+ssssssssssooo+sNN/++++++++/-dM\n# Md/// `/+++o/```` dMddN.-:++++++++++/`/o/+:``-:-`/ooyssssssssssssoodmMo++++++++//NM\n# M/:// `-+oooo.``` oMNMM+--/+++++++++/:yd-``.`-+o+hoyyoosyyyyyyys:+o+o++o//+++++/hMM\n# m++:/```:oooo/````.dmNNm/-/+++++++//+dhy::ohs:/hysyosyyyyyyyyys:----:-/o/ooo++/-mMM\n# s:++//```/oooo-  ``yNmdm:-/++++++////MMNmdhoys+ssssyyyyyysoysss:-.odd/o+/+oo++-+MMM\n# s`:++/````:oooo. ```:hNNh-/++++++//:hNNNMMNMdsossyyyyyyss+osdM/o/:yNyoo///ooo/.MMNM\n# d `-++/-```:+oo+-`````-+ds/++++++//-mMMMNNhs+syyysysyys+osdMMNyoshdh/+/o:ooo+.+MMNM\n# M/` `-/+/-``.:ooo-```````s:++++++++/mNdhsoossssyyhyo/-+hmMMMMNNNNNNo//+.:oo++ oMMNM\n# MMo``:..-//-.`-+oo:.`````/+++++++++:ooossyhyyyo+:-:ohNMmMMMMMNmNNNh:/:` :oo/: mMMNM\n# MMMh.oMh+``.-:-.-/o+-````mh/+++++++:++++/:--:+syhmMMMMMNMMMMMMMMMo-.//``+oo:`-MMNNM\n# MMMMh-omNd+````..`./+/.`hMMs+++++++/dmmmmNMMNNMMMMMMMMMMMMMMMMms:`` :/..+oo: yMNNNM\n# MNNNMN/``..``````````.-.+dNy-oooooo/o+s++sNMMNmNMMmmNMMMMMMMmo-   ``-/.-oo+- yMNNNM\n# MNNNNMMNdy-``````..``````-+o/+ooooo/++///:`:yMMMMMMMMMMMMds/`/++/````o--o++- MMNNNM\n# MMNNMMMMMN:`........-:+oyssoo+ssssss:ooo+/+:`:mMMMMMNho/.````+ooohd+//:+ooo-/MMMMMM\n# MMMMMMMMMMs.-...-.-osyyyyysdMhshhhhhossssssdh-.ss+/-.``----.sdhy+mMMMsosssy:sMMMMMM\n# endregion ------------------------------------------------------------------------|\n# region ---------------------------------------------------------------------------|\nfrom sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom math import ceil, floor, log, gcd, sqrt\nfrom collections import Counter, deque\nfrom heapq import heappush, heappop, heapify\ndef re(): return stdin.readline().rstrip()\ndef ints(): return map(int, stdin.readline().split())\ndef test(tc): \n    for _ in range(tc): solve()\nmod = 1000000007\nnl = \"\\n\"\n# endregion\n# region ---------------------------------------------------------------------------|\nclass Dsu:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [1] * n\n\n    def find(self, x):\n        while x != self.parent[x]:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return 0\n        if self.rank[py] > self.rank[px]:\n            px, py = py, px\n        self.parent[py] = px\n        self.rank[px] += self.rank[py]\n        return 1\n\n    def get_size(self, x):\n        return self.rank[self.find(x)]\n\nclass SegTree:\n    def __init__(self, n, array):\n        self.n = n\n        self.tree = [0] * (2 * n)\n        for i in range(n, 2 * n):\n            self.tree[i] = array[i - n]\n        for i in range(n - 1, -1, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n    \n    def update(self, i, val):\n        self.tree[i] = val\n        while i:\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n            i //= 2\n\n    def query(self):\n        pass\n\n    def top(self):\n        return self.tree[0]\n\n\n\n# endregion ------------------------------------------------------------------------|\n\ndef solve():\n    n, m = ints()\n    dp = [0] * (n + 1); dp[n] = 1\n    suf = [0] * (n + 2); suf[n] = 1\n    for i in range(n - 1, 0, -1):\n        dp[i] = suf[i + 1] % m\n        for mul in range(2, n + 1):\n            lo = i * mul\n            hi = (i + 1) * mul - 1\n            if lo > n: break\n\n            dp[i] = (dp[i] + suf[lo] - suf[min(n, hi) + 1]) % m\n\n        suf[i] = (suf[i + 1] + dp[i]) % m\n    \n    print(dp[1] % m)\n    return\n\ntest(1)\n"
        },
        {
            "language": 3,
            "solution": "from __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound \ndef so():  return int(input())\ndef st():  return input()\ndef mj():  return map(int,input().strip().split(\" \"))\ndef msj(): return map(str,input().strip().split(\" \"))\ndef le():  return list(map(int,input().split()))\ndef lebe():return list(map(int, input()))\n\ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\ndef joro(L):\n    return(''.join(map(str, L)))\n\n\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\n\n\ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\ndef npr(n, r):\n    return factorial(n) // factorial(n - r) if n >= r else 0\n \n \ndef ncr(n, r):\n    return factorial(n) // (factorial(r) * factorial(n - r)) if n >= r else 0\n \n \ndef lower_bound(li, num):\n    answer = -1\n    start = 0\n    end = len(li) - 1\n \n    while (start <= end):\n        middle = (end + start) // 2\n        if li[middle] >= num:\n            answer = middle\n            end = middle - 1\n        else:\n            start = middle + 1\n    return answer  # min index where x is not less than num\n \n \ndef upper_bound(li, num):\n    answer = -1\n    start = 0\n    end = len(li) - 1\n \n    while (start <= end):\n        middle = (end + start) // 2\n \n        if li[middle] <= num:\n            answer = middle\n            start = middle + 1\n \n        else:\n            end = middle - 1\n    return answer  # max index where x is not greater than num\n \n \ndef abs(x):\n    return x if x >= 0 else -x\n \n \ndef binary_search(li, val, lb, ub):\n    # print(lb, ub, li)\n    ans = -1\n    while (lb <= ub):\n        mid = (lb + ub) // 2\n        # print('mid is',mid, li[mid])\n        if li[mid] > val:\n            ub = mid - 1\n        elif val > li[mid]:\n            lb = mid + 1\n        else:\n            ans = mid  # return index\n            break\n    return ans\n \n \ndef kadane(x):  # maximum sum contiguous subarray\n    sum_so_far = 0\n    current_sum = 0\n    for i in x:\n        current_sum += i\n        if current_sum < 0:\n            current_sum = 0\n        else:\n            sum_so_far = max(sum_so_far, current_sum)\n    return sum_so_far\n \n \ndef pref(li):\n    pref_sum = [0]\n    for i in li:\n        pref_sum.append(pref_sum[-1] + i)\n    return pref_sum\n \n \ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    li = []\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n \n    for p in range(2, len(prime)):\n        if prime[p]:\n            li.append(p)\n    return li\n \n \ndef primefactors(n):\n    factors = []\n    while (n % 2 == 0):\n        factors.append(2)\n        n //= 2\n    for i in range(3, int(sqrt(n)) + 1, 2):  # only odd factors left\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 2:  # incase of prime\n        factors.append(n)\n    return factors\n         \n    \ndef read():\n    sys.stdin  = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \ndef tr(n):\n    return n*(n+1)//2\n\ndef fb(k,L):\n    if(k==L[k]):\n        return k\n    if(L[k]==fb(L[k],L)):\n        return L[k]\ndef usa(a,b,Y,Z):\n    a=fb(a,Y)\n    b=fb(b,Y)\n    if(a!=b):\n        if(Z[a]<Z[b]):\n            a,b=b,a\n        Y[b]=a\n        Z[a]+=Z[b]\n\n\n    \ndef iu():\n    import sys\n    input =sys.stdin.buffer.readline\n    import math as my\n    p,q=mj()\n    if(p==1):\n        print(1)\n        return\n    L=[]\n    P=[]\n    for i in range(p+1):\n        L.append(1)\n        P.append(0)\n    P[1]=1\n    P[2]=2\n    j=4\n    while(j<1+p):\n        L[j]=L[2]+L[j]\n        j=2+j\n    i=3\n    while(i<1+p):\n        L[i]=P[i-1]+L[i]\n        L[i]%=q\n        j=i*2\n        while(j<1+p):\n            L[j]=L[i]+L[j]\n            L[j]%=q\n            j+=i\n        P[i]=(P[i-1]+L[i])%q\n        i+=1\n    print(P[p])\n        \n    \n        \n    \n    \n    \n    \n        \n            \n    \n            \n            \n            \n        \n    \n        \n    \n    \n        \n        \n        \ndef main():\n    for i in range(1):\n        iu()\n    \n    \n            \n                    \n                \n                    \n                    \n                    \n                    \n                    \n                    \n        \n                \n        \n        \n       \n    \n           \n          \n          \n                \n            \n        \n                \n    \n        \n        \n        \n       \n            \n                \n        \n\n\n\n\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long MOD;\nlong long cha[4000005];\nlong long ans[4000005];\nint main() {\n  scanf(\"%d%lld\", &n, &MOD);\n  cha[1] = 1;\n  cha[2] = -1;\n  ans[1] = 1;\n  for (int i = 1; i <= n; i++) {\n    if (i != 1) {\n      ans[i] = ((cha[i] + ans[i - 1]) % MOD + MOD) % MOD;\n    }\n    for (int j = i * 2, k = 1; j <= n; j = j + i, k++) {\n      cha[j] = (cha[j] + ans[i]) % MOD;\n      cha[min(j + k, n) + 1] =\n          ((cha[min(j + k, n) + 1] - ans[i]) % MOD + MOD) % MOD;\n    }\n    cha[i + 1] = (cha[i + 1] + ans[i]) % MOD;\n  }\n  printf(\"%lld\\n\", ans[n]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[4000010], b[4000010], c[4000010], mod;\nint main() {\n  int x;\n  scanf(\"%d%d\", &x, &mod);\n  a[1] = 1;\n  b[1] = 1, c[1] = 0;\n  for (int i = 2; i <= x; i++) {\n    a[i] = (a[i] + b[i - 1]) % mod;\n    for (int j = 1; i * j <= x; j++) {\n      if (j >= i) {\n        break;\n      } else {\n        c[i * j] += a[j];\n        if (c[i * j] >= mod) c[i * j] -= mod;\n        if (i * (j + 1) <= x) {\n          c[i * (j + 1)] -= a[j];\n          if (c[i * (j + 1)] < 0) c[i * (j + 1)] += mod;\n        }\n      }\n    }\n    c[i] += c[i - 1];\n    if (c[i] < 0) c[i] += mod;\n    if (c[i] >= mod) c[i] -= mod;\n    a[i] = (a[i] + c[i]) % mod;\n    b[i] = (b[i - 1] + a[i]) % mod;\n    for (int j = 1; j <= i && i * j <= x; j++) {\n      c[j * i] += a[i];\n      if (c[j * i] >= mod) c[j * i] -= mod;\n      if ((i + 1) * j <= x) {\n        c[(i + 1) * j] -= a[i];\n        if (c[(i + 1) * j] < 0) c[(i + 1) * j] += mod;\n      }\n    }\n  }\n  printf(\"%d\\n\", a[x]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 1000005;\nconst long long SQRTN = 1003;\nconst long long LOGN = 22;\nconst double PI = acos(-1);\nconst long long INF = 1e18;\nconst long long MOD = 1e9 + 7;\nconst long long FMOD = 998244353;\nconst double eps = 1e-9;\nvoid __print(long long x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  long long f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nmt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT gcd(T a, T b) {\n  if (b == 0) return a;\n  a %= b;\n  return gcd(b, a);\n}\ntemplate <typename T>\nT lcm(T a, T b) {\n  return (a * (b / gcd(a, b)));\n}\nlong long add(long long a, long long b, long long c = MOD) {\n  long long res = a + b;\n  return (res >= c ? res % c : res);\n}\nlong long sub(long long a, long long b, long long c = MOD) {\n  long long res;\n  if (abs(a - b) < c)\n    res = a - b;\n  else\n    res = (a - b) % c;\n  return (res < 0 ? res + c : res);\n}\nlong long mul(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return (res >= c ? res % c : res);\n}\nlong long muln(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return ((res % c) + c) % c;\n}\nlong long mulmod(long long a, long long b, long long m = MOD) {\n  long long q = (long long)(((long double)a * (long double)b) / (long double)m);\n  long long r = a * b - q * m;\n  if (r > m) r %= m;\n  if (r < 0) r += m;\n  return r;\n}\ntemplate <typename T>\nT binpow(T e, T n) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = x * p;\n    p = p * p;\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT binpow2(T e, T n, T m = MOD) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = mul(x, p, m);\n    p = mul(p, p, m);\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT extended_euclid(T a, T b, T &x, T &y) {\n  T xx = 0, yy = 1;\n  y = 0;\n  x = 1;\n  while (b) {\n    T q = a / b, t = b;\n    b = a % b;\n    a = t;\n    t = xx;\n    xx = x - q * xx;\n    x = t;\n    t = yy;\n    yy = y - q * yy;\n    y = t;\n  }\n  return a;\n}\ntemplate <typename T>\nT mod_inverse(T a, T n = MOD) {\n  T x, y, z = 0;\n  T d = extended_euclid(a, n, x, y);\n  return (d > 1 ? -1 : sub(x, z, n));\n}\nconst long long FACSZ = 1e4;\nlong long fact[FACSZ], ifact[FACSZ];\nvoid precom(long long c = MOD) {\n  fact[0] = 1;\n  for (long long i = 1; i < FACSZ; i++) fact[i] = mul(fact[i - 1], i, c);\n  ifact[FACSZ - 1] = mod_inverse(fact[FACSZ - 1], c);\n  for (long long i = FACSZ - 1 - 1; i >= 0; i--) {\n    ifact[i] = mul(i + 1, ifact[i + 1], c);\n  }\n}\nvector<long long> primes;\nvoid prime_precom() {\n  primes.push_back(2);\n  for (long long x = 3; primes.size() <= MAXN; x += 2) {\n    bool isPrime = true;\n    for (auto p : primes) {\n      if (x % p == 0) {\n        isPrime = false;\n        break;\n      }\n      if (p * p > x) {\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(x);\n    }\n  }\n}\nlong long ncr(long long n, long long k) {\n  if (n < k) return 0;\n  if (k == 0) return 1;\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res *= (n - i);\n    res /= (i + 1);\n  }\n  return res;\n}\nlong long ncr_modp(long long n, long long k, long long c = MOD) {\n  if (n < k) return 0;\n  if (k == 0) return 1;\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res = mul(res, n - i, c);\n    res = mul(res, binpow2(i + 1, c - 2, c), c);\n  }\n  return res;\n}\nvector<long long> factors;\nvoid factorize(long long a) {\n  factors.clear();\n  for (long long i = 1; i * i <= a; i++) {\n    if (a % i == 0) {\n      factors.push_back(i);\n      factors.push_back(a / i);\n    }\n  }\n  sort(factors.begin(), factors.end());\n}\nlong long ncr_precom(long long n, long long r, long long c = MOD) {\n  return mul(mul(ifact[r], ifact[n - r], c), fact[n], c);\n}\nlong long ceil(long long a, long long b) { return (a + b - 1) / b; }\nbool is_prime(long long n) {\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\nbool diophantine_checker(long long a, long long b, long long n) {\n  for (long long i = 0; i * a <= n; i++) {\n    if ((n - (i * a)) % b == 0) {\n      return true;\n    }\n  }\n  return false;\n}\nlong long count_divisors(long long n) {\n  long long c;\n  long long ans = 1;\n  for (long long i = 2; i * i <= n; i++) {\n    c = 0;\n    while (n % i == 0) {\n      c++;\n      n /= i;\n    }\n    ans *= (c + 1);\n  }\n  if (n > 2) {\n    return ans * 2;\n  }\n  return ans;\n}\nstring to_binary(long long n) {\n  string r;\n  while (n != 0) {\n    r = (n % 2 == 0 ? \"0\" : \"1\") + r;\n    n /= 2;\n  }\n  return r;\n}\nbool ispower2(long long x) { return x && (!(x & (x - 1))); }\nunsigned long long mulmodBitwise(unsigned long long a, unsigned long long b,\n                                 unsigned long long p) {\n  a %= p;\n  b %= p;\n  if (a <= 0xFFFFFFF && b <= 0xFFFFFFF) {\n    return (a * b) % p;\n  }\n  if (b > a) {\n    swap(a, b);\n  }\n  unsigned long long result = 0;\n  while (a > 0 && b > 0) {\n    if (b & 1) {\n      result += a;\n      result %= p;\n    }\n    a <<= 1;\n    a %= p;\n    b >>= 1;\n  }\n  return result;\n}\nunsigned long long mulmod2(unsigned long long a, unsigned long long b,\n                           unsigned long long p) {\n  a %= p;\n  b %= p;\n  if (a <= 0xFFFFFFF && b <= 0xFFFFFFF) {\n    return (a * b) % p;\n  }\n  unsigned long long zeros = 0;\n  unsigned long long m = p;\n  while ((m & 0x8000000000000000ULL) == 0) {\n    zeros++;\n    m <<= 1;\n  }\n  unsigned long long mask = (1 << zeros) - 1;\n  unsigned long long result = 0;\n  while (a > 0 && b > 0) {\n    result += (b & mask) * a;\n    result %= p;\n    b >>= zeros;\n    a <<= zeros;\n    a %= p;\n  }\n  return result;\n}\nunsigned long long powmod(unsigned long long base, unsigned long long exponent,\n                          unsigned long long p) {\n  unsigned long long result = 1;\n  while (exponent > 0) {\n    if (exponent & 1) {\n      result = mulmod2(result, base, p);\n    }\n    base = mulmod2(base, base, p);\n    exponent >>= 1;\n  }\n  return result;\n}\nvector<long long> spf;\nvoid sieve() {\n  spf.resize(MAXN);\n  spf[1] = 1;\n  for (long long i = 2; i < MAXN; i++) {\n    spf[i] = i;\n  }\n  for (long long i = 4; i < MAXN; i += 2) {\n    spf[i] = 2;\n  }\n  for (long long i = 3; i * i <= MAXN; i++) {\n    if (spf[i] == i) {\n      for (long long j = i * i; j < MAXN; j += i) {\n        if (spf[j] == j) {\n          spf[j] = i;\n        }\n      }\n    }\n  }\n}\nvoid pfactor(long long x, vector<long long> &ret) {\n  while (x != 1) {\n    ret.push_back(spf[x]);\n    x = x / spf[x];\n  }\n}\nvoid solvethetestcase() {\n  long long n, mod;\n  cin >> n >> mod;\n  vector<long long> dp(n + 1, 0ll);\n  vector<long long> psum(n + 1, 0ll);\n  vector<long long> dx(n + 1, 0ll);\n  for (long long i = 1; i <= n; i++) {\n    dx[i] += dx[i - 1];\n    dx[i] %= mod;\n    if (i == 1) {\n      dp[i] = 1;\n    } else {\n      dp[i] = psum[i - 1] + dx[i];\n      dp[i] %= mod;\n    }\n    psum[i] = psum[i - 1] + dp[i];\n    psum[i] %= mod;\n    for (long long j = 1; j * i <= n; j++) {\n      dx[j * i] += dp[i];\n      long long r = (i + 1) * j;\n      if (r <= n) {\n        dx[r] -= dp[i];\n        dx[r] += mod;\n        dx[r] %= mod;\n      }\n    }\n  }\n  cout << dp[n] << \"\\n\";\n}\nsigned main() {\n  cout << fixed << setprecision(12);\n  ;\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  for (long long testcase = 1; testcase < t + 1; testcase++) {\n    solvethetestcase();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count() +\n            reinterpret_cast<unsigned long>(new long long) +\n            *(new unsigned long));\nvoid eraseDups(vector<long long>& a) {\n  a.erase(unique(a.begin(), a.end()), a.end());\n}\nlong long strToInt(string& a) {\n  stringstream x(a);\n  long long b;\n  x >> b;\n  return b;\n}\nlong long bitCnt(long long a) {\n  bitset<64> b(a);\n  return b.count();\n}\nlong long bitCnt(string a) {\n  bitset<64> b(a);\n  return b.count();\n}\nvector<long long> readVI(long long n) {\n  vector<long long> a(n);\n  for (long long i = 0; i < n; i++) cin >> a[i];\n  return a;\n}\nvector<vector<long long> > readVVI(long long n, long long m) {\n  vector<vector<long long> > a(n, vector<long long>(m));\n  for (long long i = 0; i < n; i++) a[i] = readVI(m);\n  return a;\n}\nvector<long long> readVLL(long long n) {\n  vector<long long> a(n);\n  for (long long i = 0; i < n; i++) cin >> a[i];\n  return a;\n}\nvector<vector<long long> > readVVLL(long long n, long long m) {\n  vector<vector<long long> > a(n, vector<long long>(m));\n  for (long long i = 0; i < n; i++) a[i] = readVLL(m);\n  return a;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nvoid print(vector<long long>& a) {\n  for (auto el : a) {\n    cout << el << ' ';\n  }\n  cout << '\\n';\n}\nvoid print(vector<pair<long long, long long> >& a) {\n  for (auto el : a) {\n    cout << el.first << ',' << el.second << ' ';\n  }\n  cout << '\\n';\n}\nvoid print(vector<long long>& a, long long n) {\n  long long cnt = 0;\n  for (auto el : a) {\n    if (cnt++ == n) break;\n    cout << el << ' ';\n  }\n  cout << '\\n';\n}\nvoid print(vector<vector<long long> >& a) {\n  for (auto el : a) {\n    print(el);\n  }\n}\nconst long long INF = 2e9;\nconst long long INFF = INT64_MAX;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst long long dx[] = {-1, 0, 1, 0};\nconst long long dy[] = {0, 1, 0, -1};\nlong long n, MOD;\nconst long long N = 4e6 + 5;\nvector<long long> dp(N, 0);\ninline long long mul(long long a, long long b) {\n  return (long long)a * (long long)b % MOD;\n}\ninline long long add(long long a, long long b) {\n  return (((long long)a + long long(b)) % MOD + MOD) % MOD;\n}\nvoid go() {\n  cin >> n >> MOD;\n  dp[1] = 1;\n  for (long long i = 2; i <= n; i++) {\n    dp[i] = add(dp[i], (i == 2 ? 2 : dp[i - 1] * 2 + 1));\n    for (long long k = 2; i * k <= n; k++)\n      dp[i * k] = add(dp[i * k], dp[i] - dp[i - 1]);\n  }\n  cout << dp[n] << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long T = 1;\n  while (T--) go();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n#######################################\n# #######\n  #     #\n  #######\n  #   #\n  #    # \n  #      #   Rahul Kaushik.2.0 #\n\n            \n    \nfor i in range(1):\n    n,m=map(int,input().split())\n    dp=[0]*(n+1)\n    s=[0]*(n+2)\n    dp[n]=1\n    \n    s[n]=1\n    for i in range(n-1,0,-1):\n        dp[i]=s[i+1]\n        j=2\n        while i*j<=n:\n            if (i+1)*j-1<=n:\n                dp[i]+=(s[j*i]-s[(i+1)*(j)])%m\n                \n            else:\n                dp[i]+=s[j*i]\n            dp[i]%=m\n            j+=1\n        s[i]+=(s[i+1]+dp[i])%m\n    \n    print(dp[1]%m)\n    \n    \n    \n                \n            \n        "
        }
    ]
}