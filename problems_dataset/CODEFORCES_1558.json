{
    "name": "1558_E. Down Below",
    "source": "CODEFORCES",
    "description": "In a certain video game, the player controls a hero characterized by a single integer value: power.\n\nOn the current level, the hero got into a system of n caves numbered from 1 to n, and m tunnels between them. Each tunnel connects two distinct caves. Any two caves are connected with at most one tunnel. Any cave can be reached from any other cave by moving via tunnels.\n\nThe hero starts the level in cave 1, and every other cave contains a monster.\n\nThe hero can move between caves via tunnels. If the hero leaves a cave and enters a tunnel, he must finish his movement and arrive at the opposite end of the tunnel.\n\nThe hero can use each tunnel to move in both directions. However, the hero can not use the same tunnel twice in a row. Formally, if the hero has just moved from cave i to cave j via a tunnel, he can not head back to cave i immediately after, but he can head to any other cave connected to cave j with a tunnel.\n\nIt is known that at least two tunnels come out of every cave, thus, the hero will never find himself in a dead end even considering the above requirement.\n\nTo pass the level, the hero must beat the monsters in all the caves. When the hero enters a cave for the first time, he will have to fight the monster in it. The hero can beat the monster in cave i if and only if the hero's power is strictly greater than a_i. In case of beating the monster, the hero's power increases by b_i. If the hero can't beat the monster he's fighting, the game ends and the player loses.\n\nAfter the hero beats the monster in cave i, all subsequent visits to cave i won't have any consequences: the cave won't have any monsters, and the hero's power won't change either.\n\nFind the smallest possible power the hero must start the level with to be able to beat all the monsters and pass the level.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and m (3 \u2264 n \u2264 1000; n \u2264 m \u2264 min((n(n-1))/(2), 2000)) \u2014 the number of caves and tunnels.\n\nThe second line contains n-1 integers a_2, a_3, \u2026, a_n (1 \u2264 a_i \u2264 10^9) \u2014 values the hero's power are compared to while fighting monsters in caves 2, 3, \u2026, n.\n\nThe third line contains n-1 integers b_2, b_3, \u2026, b_n (1 \u2264 b_i \u2264 10^9) \u2014 increases applied to the hero's power for beating monsters in caves 2, 3, \u2026, n.\n\nEach of the next m lines contains two integers u_i and v_i (1 \u2264 u_i, v_i \u2264 n; u_i \u2260 v_i) \u2014 the numbers of caves connected with a tunnel.\n\nNo two caves are connected with more than one tunnel. Any cave can be reached from any other cave by moving via tunnels. At least two tunnels come out of every cave.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 1000, and the sum of m over all test cases does not exceed 2000.\n\nOutput\n\nFor each test case print a single integer \u2014 the smallest possible power the hero must start the level with to be able to beat all the monsters and pass the level.\n\nExample\n\nInput\n\n\n3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n4 5\n\n\nOutput\n\n\n15\n15\n19\n\nNote\n\nIn the first test case, the hero can pass the level with initial power 15 as follows: \n\n  * move from cave 1 to cave 2: since 15 > 11, the hero beats the monster, and his power increases to 15 + 8 = 23; \n  * move from cave 2 to cave 3: since 23 > 22, the hero beats the monster, and his power increases to 23 + 7 = 30; \n  * move from cave 3 to cave 4: since 30 > 13, the hero beats the monster, and his power increases to 30 + 5 = 35. \n\n\n\nIn the second test case, the situation is similar except that the power increases for beating monsters in caves 2 and 4 are exchanged. The hero can follow a different route, 1 \u2192 4 \u2192 3 \u2192 2, and pass the level with initial power 15.\n\nIn the third test case, the hero can pass the level with initial power 19 as follows: \n\n  * move from cave 1 to cave 2: since 19 > 10, the hero beats the monster, and his power increases to 19 + 7 = 26; \n  * move from cave 2 to cave 4: since 26 > 20, the hero beats the monster, and his power increases to 26 + 10 = 36; \n  * move from cave 4 to cave 5: since 36 > 30, the hero beats the monster, and his power increases to 36 + 5 = 41; \n  * move from cave 5 to cave 2: there is no monster in this cave anymore, nothing happens; \n  * move from cave 2 to cave 3: since 41 > 40, the hero beats the monster, and his power increases to 41 + 2 = 43. ",
    "difficulty": "E",
    "tags": [
        "binary search",
        "dfs and similar",
        "graphs",
        "greedy",
        "meet-in-the-middle",
        "shortest paths"
    ],
    "rating": 3000,
    "public_test": [
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n4 5\n",
            "output": "15\n15\n19\n"
        }
    ],
    "generated_test": [
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n15\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n5 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12271\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n1 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "18\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n10 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12266\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 3\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n4 5\n",
            "output": "15\n18\n19\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "18\n15\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n10 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12270\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 0 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20956\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n4 0 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "18\n5\n24\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 6 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n6 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21010\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n10 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "18\n15\n21\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 10\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 3 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n14\n24\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 44\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n15\n26\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n1 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n10 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "18\n12\n21\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 12 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12269\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n10 9 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12327\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 7\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "16\n15\n24\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n12\n21\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 0 10 10 10 10 10 14\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20952\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 15 12345 10 10\n5 11 10 10 10 10 10 10 5\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12275\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 0 10 10 10 10 10 14\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 8\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20962\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 15 12345 10 10\n5 11 10 13 10 10 10 10 5\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12272\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n11 10 10 10 18 10 12345 10 10\n8 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 2\n5 6\n6 7\n7 2\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12268\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n10 10 10 10 10 10 10 13 10\n1 2\n2 3\n3 4\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12263\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 898 10 10\n10 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n879\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 2\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 1 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n3 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12280\n"
        },
        {
            "input": "2\n3 3\n1 1\n2 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 6 10\n1 2\n2 3\n3 4\n3 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12274\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 10\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 44\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "14\n15\n26\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n4 -1 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n4 5\n",
            "output": "18\n5\n21\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n0 10 10 10 18 15 12345 10 10\n5 11 10 2 10 10 10 10 10\n1 2\n2 3\n2 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12278\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 5 10 10 10 10 12345 10 4\n10 10 10 9 17 8 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n10 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12262\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n14 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n1 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "12\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 4 10 10 10 10 12345 10 10\n13 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12323\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n1 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n12 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n10 2 10 7\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "18\n13\n21\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n5 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n1 5\n",
            "output": "15\n8\n21\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n14 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n1 48 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "12\n12\n27\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 19702 10 10\n10 10 10 10 10 10 10 13 10\n1 2\n2 3\n3 4\n4 5\n2 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n19620\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 20 10 10 10 898 10 10\n10 6 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n883\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 19702 10 10\n10 10 10 10 10 8 10 13 10\n1 2\n2 3\n3 4\n4 5\n2 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n19622\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 5 10 10 10 10 11443 10 4\n10 10 10 9 4 5 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n10 1\n5 9\n9 10\n10 5\n",
            "output": "2\n11376\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 29069 10 10\n10 10 10 10 10 8 10 13 10\n1 2\n2 3\n3 4\n4 5\n2 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n28989\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 5 10 10 10 10 11443 10 4\n10 10 12 9 4 5 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n10 1\n5 9\n9 10\n10 5\n",
            "output": "2\n11374\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 6063 10 10\n10 10 15 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n6044\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 0 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 61 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "18\n12\n40\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 14 10 17 10 12345 10 10\n5 10 10 8 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12273\n"
        },
        {
            "input": "2\n3 3\n1 1\n2 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n10 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12265\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n8 9 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12329\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 7\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 39 30\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "16\n15\n28\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n4 -1 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 42\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "18\n5\n31\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 15 12345 10 10\n5 11 10 10 10 10 10 2 5\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12283\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 15 12345 10 10\n5 11 10 13 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12267\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 2 25\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n1 22 20 30\n7 2 10 10\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n14\n14\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 3 10 10 16 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21013\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 10 10 10 10 3 10 10\n1 2\n2 3\n3 8\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n1 9\n9 10\n10 5\n",
            "output": "2\n20946\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 0 10\n16 10 10 10 10 10 11 10 1\n1 2\n2 3\n3 8\n4 5\n5 6\n6 7\n7 8\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21000\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 10\n1 2\n2 3\n3 4\n4 1\n4 4\n11 0 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n1 3\n1 4\n2 5\n3 4\n2 3\n",
            "output": "14\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 1 8\n6 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 4\n",
            "output": "2\n12330\n"
        },
        {
            "input": "3\n4 4\n9 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n18 12 13\n5 7 2\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 37 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n14\n26\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 32 10 15 21025 10 10\n10 10 0 10 1 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20965\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n1 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n12 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n10 2 15 7\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "18\n13\n16\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 5 10 10 10 10 12345 10 4\n10 10 10 9 4 8 10 10 10\n1 2\n2 3\n3 8\n1 5\n4 6\n6 7\n7 4\n4 8\n10 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12297\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n14 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n1 48 20 43\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "12\n12\n32\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 5 10 10 10 10 12345 10 4\n10 10 10 6 4 5 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n10 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12281\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n14 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 11\n1 2\n2 3\n3 4\n4 1\n5 7\n1 48 20 30\n7 2 10 4\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "12\n12\n28\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 29069 10 10\n11 10 10 10 10 8 10 13 10\n1 2\n2 3\n3 4\n4 5\n2 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n28988\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 12 10 10 10 10 24303 10 10\n10 10 10 10 6 10 3 10 10\n1 2\n2 3\n3 8\n4 10\n5 6\n6 7\n7 4\n7 8\n8 1\n5 9\n9 10\n8 5\n",
            "output": "2\n24284\n"
        },
        {
            "input": "3\n4 4\n11 22 25\n4 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n2 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "19\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n10 10 10 0 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 3\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12276\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 20 10 10 10 7843 10 10\n5 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n7769\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n18 22 13\n5 7 10\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n4 3 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n14\n27\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 2 25\n5 8 8\n1 2\n2 3\n3 4\n4 1\n5 7\n1 40 20 30\n7 3 10 10\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n13\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 16 10\n10 10 0 11 10 10 10 10 14\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n2 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20951\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 32 10 15 21025 10 10\n10 10 0 10 1 10 10 14 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20961\n"
        },
        {
            "input": "3\n4 4\n3 22 13\n5 7 10\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n11 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "14\n15\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 11 10 10 10 10 12345 10 10\n16 10 10 10 10 10 10 10 6\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12320\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 20 10 10 10 7843 10 10\n5 13 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n7766\n"
        },
        {
            "input": "3\n4 4\n11 22 22\n2 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 6 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 35 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "21\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n11 10 3 10 18 10 12345 10 10\n8 10 10 10 7 10 10 10 10\n1 2\n2 3\n3 4\n4 2\n5 6\n1 7\n7 2\n6 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12308\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 32 10 15 21025 10 10\n10 10 0 10 1 10 10 14 1\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20970\n"
        },
        {
            "input": "3\n4 4\n11 22 25\n6 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n2 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 4 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "17\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 8 10 3821 10 10\n10 10 18 10 10 10 1 13 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n3802\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 4 10 12345 10 10\n5 20 10 10 10 10 10 10 10\n1 2\n2 3\n3 6\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12261\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 8\n10 5 10 9 18 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 1\n4 8\n8 1\n5 9\n9 10\n10 4\n",
            "output": "2\n12264\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n10 10 10 16 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12260\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 8\n7 3 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n15\n19\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 72 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n12\n51\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n1 4\n3 4\n2 5\n",
            "output": "15\n12\n19\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 21 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n1 5\n",
            "output": "15\n15\n14\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n3 -1 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "18\n4\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12271\n"
        },
        {
            "input": "3\n4 4\n11 22 25\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "18\n15\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n11 10 10 10 18 10 12345 10 10\n5 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12271\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n10 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 0 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 3 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n15\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 14 10 10 10 12345 10 10\n5 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12271\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n10 10 15 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 0 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "18\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n10 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 14 10 17 10 12345 10 10\n5 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12271\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12270\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n10 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 4\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 14 10 17 10 12345 10 10\n5 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 3\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12271\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 15 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12270\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 11 10 10 10 12345 10 10\n10 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 4\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n6 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n1 5\n",
            "output": "15\n15\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n10 10 10 10 10 10 1 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n3 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12270\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 2\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 11\n10 10 15 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 4\n10 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n5 10 10 10 10 10 21025 10 10\n10 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 20 10 10 21025 10 10\n10 10 0 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20956\n"
        },
        {
            "input": "2\n3 3\n1 1\n2 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12270\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 6 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 0 10 10 10 12345 10 10\n10 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 4\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n0 10 10 10 18 15 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12270\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 11 10 10 10 12345 10 10\n10 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n3 1\n5 9\n9 10\n10 4\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 6 10 10 10 10 10 14 10\n1 2\n2 3\n3 8\n6 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21010\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 10 30\n10 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "18\n15\n21\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n10 10 9 10 10 10 1 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 10\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 3 10 9\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n14\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 2\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n3 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12270\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 4\n10 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 5\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 20 10 10 21025 10 19\n10 10 0 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20956\n"
        },
        {
            "input": "2\n3 3\n1 1\n2 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n3 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12270\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 2 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "2\n3 3\n2 1\n1 2\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n3 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12270\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n12 10 10 20 10 10 21025 10 19\n10 10 0 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20956\n"
        },
        {
            "input": "2\n3 3\n1 1\n2 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n3 3\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12270\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 2 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n1 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n12 10 10 20 10 10 21025 10 19\n10 10 0 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 5\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20956\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 2 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n2 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 7\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n11 10 10 10 18 10 12345 10 10\n5 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 2\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12271\n"
        },
        {
            "input": "3\n4 4\n11 22 6\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 0 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "18\n12\n24\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 10 10 10 10 4 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n1 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12270\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n4 -1 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "18\n5\n24\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 10 10 10 10 11 10 10\n1 2\n2 3\n3 8\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 18 10 10 10 10 12345 10 11\n10 10 15 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 5 10 10 10 10 12345 10 4\n10 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 20 10 10 21025 10 10\n14 10 0 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20952\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 6 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n8 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n0 10 10 10 18 15 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n2 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12270\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 11 10 10 10 12345 10 10\n10 10 10 9 10 10 7 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n3 1\n5 9\n9 10\n10 4\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 18 10 10 12345 10 4\n10 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 5\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 20 10 10 21025 10 19\n10 10 0 10 10 10 8 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20956\n"
        },
        {
            "input": "2\n3 3\n2 1\n1 2\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12270\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 2 25\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n1 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n14\n24\n"
        },
        {
            "input": "3\n4 4\n11 22 11\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 44\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n15\n26\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n11 10 10 10 18 10 12345 10 10\n5 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 2\n5 6\n6 7\n7 2\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12271\n"
        },
        {
            "input": "3\n4 4\n6 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n4 -1 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 5\n",
            "output": "18\n5\n24\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 10 10 10 10 11 10 10\n1 2\n2 3\n3 8\n4 5\n5 6\n6 7\n7 8\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 5 10 10 10 10 12345 10 4\n10 10 10 9 10 8 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n0 10 10 10 18 12 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n2 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12270\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 2 25\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n1 40 20 30\n7 2 10 10\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n14\n24\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 0 10\n10 10 10 10 10 10 11 10 10\n1 2\n2 3\n3 8\n4 5\n5 6\n6 7\n7 8\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 5 10 10 10 10 12345 10 4\n10 10 10 9 10 8 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n10 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12269\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n0 10 10 10 18 12 12345 10 4\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n2 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12270\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 2 25\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n1 40 20 30\n7 3 10 10\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n14\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n11 10 10 10 18 10 12345 10 10\n8 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 2\n5 6\n6 7\n7 2\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12268\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 0 10\n10 10 10 10 1 10 11 10 10\n1 2\n2 3\n3 8\n4 5\n5 6\n6 7\n7 8\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 15 10 10 12345 10 10\n10 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12266\n"
        },
        {
            "input": "2\n3 3\n2 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 10\n5 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12271\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n1 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 22 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n20 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "18\n15\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 4 10 10 10 10 12345 10 10\n10 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n11 10 10 10 18 10 12345 10 6\n5 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12271\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 18 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 12 21025 10 10\n10 10 0 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 14 10 10 5 12345 10 10\n5 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12271\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n2 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n5 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 0 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n1 4\n2 5\n3 4\n2 3\n",
            "output": "18\n12\n24\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 10 10 10 16 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 8\n10 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 4\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 19\n10 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21006\n"
        },
        {
            "input": "2\n3 3\n1 1\n1 1\n1 2\n2 3\n3 1\n10 12\n10 10 14 10 17 10 12345 10 10\n8 10 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 3\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12268\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n19 10 11 10 10 10 12345 10 10\n10 10 10 9 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 4\n",
            "output": "2\n12326\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n18 12 13\n5 7 2\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "15\n14\n24\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 12345 10 11\n10 10 15 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12326\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 32 10 10 21025 10 10\n10 10 0 10 10 10 10 10 10\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20956\n"
        },
        {
            "input": "2\n3 3\n1 1\n2 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n2 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12270\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 6 21\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "2\n3 3\n0 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 10 10\n10 6 10 0 10 10 10 14 10\n1 2\n2 3\n3 8\n6 5\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n21010\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 2 13\n9 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 2\n1 5\n2 3\n2 4\n1 5\n3 4\n2 5\n",
            "output": "15\n12\n24\n"
        },
        {
            "input": "2\n3 3\n2 1\n1 2\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 10 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n4 5\n2 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 5\n",
            "output": "2\n12270\n"
        },
        {
            "input": "2\n3 3\n1 1\n2 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 18 9 12345 10 10\n5 11 10 10 10 10 10 10 10\n1 2\n2 3\n3 4\n3 3\n5 6\n6 7\n7 4\n4 8\n8 1\n5 9\n9 10\n10 3\n",
            "output": "2\n12270\n"
        },
        {
            "input": "3\n4 4\n11 22 13\n1 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n10 2 10 7\n1 2\n1 5\n2 3\n2 4\n2 5\n3 4\n2 5\n",
            "output": "18\n12\n21\n"
        },
        {
            "input": "3\n4 4\n11 22 12\n8 7 5\n1 2\n2 3\n3 4\n4 1\n4 4\n11 12 13\n5 7 8\n1 2\n2 3\n3 4\n4 1\n5 7\n10 40 20 30\n7 2 10 5\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n1 5\n",
            "output": "15\n12\n21\n"
        },
        {
            "input": "2\n3 3\n1 1\n0 1\n1 2\n2 3\n3 1\n10 12\n10 10 10 10 10 10 21025 16 10\n10 10 0 10 10 10 10 10 14\n1 2\n2 3\n3 8\n4 5\n4 6\n6 7\n7 4\n4 8\n6 1\n5 9\n9 10\n10 5\n",
            "output": "2\n20952\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid chmin(T &x, const T &y) {\n  if (x > y) x = y;\n}\ntemplate <typename T>\nvoid chmax(T &x, const T &y) {\n  if (x < y) x = y;\n}\nchar readc() {\n  char c;\n  while (isspace((c = getchar())))\n    ;\n  return c;\n}\nint read() {\n  char c;\n  while ((c = getchar()) < '-')\n    ;\n  if (c == '-') {\n    int x = (c = getchar()) - '0';\n    while ((c = getchar()) >= '0') x = x * 10 + c - '0';\n    return -x;\n  }\n  int x = c - '0';\n  while ((c = getchar()) >= '0') x = x * 10 + c - '0';\n  return x;\n}\nconst int N = 1000 + 5, INF = 1e9 + 10;\nint n, mx[N], fr[N], a[N], b[N], a0[N], b0[N], q[N];\nvector<int> lk[N];\nbool one(int p) {\n  int t = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (a[i] == INF) {\n      for (auto j : lk[i]) {\n        if (p > a[j]) {\n          if (mx[j]) {\n            a[j] = INF;\n            return 1;\n          }\n          fr[j] = 0;\n          mx[j] = min(INF, b[j] + p);\n          q[++t] = j;\n        }\n      }\n    }\n  }\n  for (int h = 1; h <= t; ++h) {\n    int x = q[h];\n    for (auto y : lk[x])\n      if (y != fr[x]) {\n        int d = mx[x];\n        if (d > a[y]) {\n          if (mx[y]) {\n            for (int i = y; i; i = fr[i]) a[i] = INF;\n            for (int i = x; i; i = fr[i]) a[i] = INF;\n            return 1;\n          }\n          mx[y] = min(INF, d + b[y]);\n          fr[y] = x;\n          q[++t] = y;\n        } else if (a[y] == INF && fr[x]) {\n          for (int i = x; i; i = fr[i]) a[i] = INF;\n          return 1;\n        }\n      }\n  }\n  return 0;\n}\nbool check(int p0) {\n  for (int i = 2; i <= n; ++i) a[i] = a0[i];\n  for (int i = 2; i <= n; ++i) b[i] = b0[i];\n  a[1] = INF;\n  b[1] = 0;\n  while (1) {\n    bool ok = 1;\n    int p = p0;\n    for (int i = 2; i <= n; ++i) {\n      ok &= a[i] == INF;\n      if (a[i] == INF) p = min(INF, p + b[i]);\n    }\n    if (ok) break;\n    for (int i = 1; i <= n; ++i) {\n      mx[i] = fr[i] = 0;\n    }\n    if (!one(p)) return 0;\n  }\n  return 1;\n}\nint main() {\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int m;\n    cin >> n >> m;\n    for (int i = 2; i <= n; ++i) scanf(\"%d\", a0 + i);\n    for (int i = 2; i <= n; ++i) scanf(\"%d\", b0 + i);\n    for (int i = 1; i <= n; ++i) lk[i].clear();\n    while (m--) {\n      int u, v;\n      scanf(\"%d%d\", &u, &v);\n      lk[u].push_back(v);\n      lk[v].push_back(u);\n    }\n    int l = 0, r = 1e9 + 5;\n    while (l + 1 != r) {\n      int mid = (l + r) / 2;\n      if (check(mid))\n        r = mid;\n      else\n        l = mid;\n    }\n    cout << r << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nusing ll = long long;\ntemplate <class t, class u>\nbool chmax(t& first, u second) {\n  if (first < second) {\n    first = second;\n    return true;\n  } else\n    return false;\n}\ntemplate <class t, class u>\nbool chmin(t& first, u second) {\n  if (second < first) {\n    first = second;\n    return true;\n  } else\n    return false;\n}\ntemplate <class t>\nusing vc = vector<t>;\ntemplate <class t>\nusing vvc = vc<vc<t>>;\nusing pi = pair<ll, ll>;\nusing vi = vc<ll>;\ntemplate <class t, class u>\nostream& operator<<(ostream& os, const pair<t, u>& p) {\n  return os << \"{\" << p.first << \",\" << p.second << \"}\";\n}\ntemplate <class t>\nostream& operator<<(ostream& os, const vc<t>& v) {\n  os << \"{\";\n  for (auto e : v) os << e << \",\";\n  return os << \"}\";\n}\nusing uint = unsigned;\nusing ull = unsigned long long;\ntemplate <class t, size_t n>\nostream& operator<<(ostream& os, const array<t, n>& first) {\n  return os << vc<t>(first.begin(), first.end());\n}\ntemplate <ll i, class T>\nvoid print_tuple(ostream&, const T&) {}\ntemplate <ll i, class T, class H, class... Args>\nvoid print_tuple(ostream& os, const T& t) {\n  if (i) os << \",\";\n  os << get<i>(t);\n  print_tuple<i + 1, T, Args...>(os, t);\n}\ntemplate <class... Args>\nostream& operator<<(ostream& os, const tuple<Args...>& t) {\n  os << \"{\";\n  print_tuple<0, tuple<Args...>, Args...>(os, t);\n  return os << \"}\";\n}\ntemplate <class t>\nvoid print(t x, ll suc = 1) {\n  cout << x;\n  if (suc == 1) cout << \"\\n\";\n  if (suc == 2) cout << \" \";\n}\nll read() {\n  ll i;\n  cin >> i;\n  return i;\n}\nvi readvi(ll n, ll off = 0) {\n  vi v(n);\n  for (ll i = ll(0); i < ll(n); i++) v[i] = read() + off;\n  return v;\n}\npi readpi(ll off = 0) {\n  ll first, second;\n  cin >> first >> second;\n  return pi(first + off, second + off);\n}\ntemplate <class t, class u>\nvoid print(const pair<t, u>& p, ll suc = 1) {\n  print(p.first, 2);\n  print(p.second, suc);\n}\ntemplate <class T>\nvoid print(const vector<T>& v, ll suc = 1) {\n  for (ll i = ll(0); i < ll(v.size()); i++)\n    print(v[i], i == ll(v.size()) - 1 ? suc : 2);\n}\ntemplate <class T>\nvoid print_offset(const vector<T>& v, ll off, ll suc = 1) {\n  for (ll i = ll(0); i < ll(v.size()); i++)\n    print(v[i] + off, i == ll(v.size()) - 1 ? suc : 2);\n}\ntemplate <class T, size_t N>\nvoid print(const array<T, N>& v, ll suc = 1) {\n  for (ll i = ll(0); i < ll(N); i++) print(v[i], i == ll(N) - 1 ? suc : 2);\n}\nstring readString() {\n  string s;\n  cin >> s;\n  return s;\n}\ntemplate <class T>\nT sq(const T& t) {\n  return t * t;\n}\nvoid yes(bool ex = true) {\n  cout << \"Yes\"\n       << \"\\n\";\n  if (ex) exit(0);\n}\nvoid no(bool ex = true) {\n  cout << \"No\"\n       << \"\\n\";\n  if (ex) exit(0);\n}\nvoid possible(bool ex = true) {\n  cout << \"Possible\"\n       << \"\\n\";\n  if (ex) exit(0);\n}\nvoid impossible(bool ex = true) {\n  cout << \"Impossible\"\n       << \"\\n\";\n  if (ex) exit(0);\n}\nconstexpr ll ten(ll n) { return n == 0 ? 1 : ten(n - 1) * 10; }\nconst ll infLL = LLONG_MAX / 3;\nconst ll inf = infLL;\nll topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\nll topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\nll botbit(signed first) { return first == 0 ? 32 : __builtin_ctz(first); }\nll botbit(ll first) { return first == 0 ? 64 : __builtin_ctzll(first); }\nll popcount(signed t) { return __builtin_popcount(t); }\nll popcount(ll t) { return __builtin_popcountll(t); }\nbool ispow2(ll i) { return i && (i & -i) == i; }\nll mask(ll i) { return (ll(1) << i) - 1; }\nbool inc(ll first, ll second, ll c) { return first <= second && second <= c; }\ntemplate <class t>\nvoid mkuni(vc<t>& v) {\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n}\nll rand_int(ll l, ll r) {\n  static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n  return uniform_int_distribution<ll>(l, r)(gen);\n}\ntemplate <class t>\nvoid myshuffle(vc<t>& first) {\n  for (ll i = ll(0); i < ll(ll(first.size())); i++)\n    swap(first[i], first[rand_int(0, i)]);\n}\ntemplate <class t>\nll lwb(const vc<t>& v, const t& first) {\n  return lower_bound(v.begin(), v.end(), first) - v.begin();\n}\nvvc<ll> readGraph(ll n, ll m) {\n  vvc<ll> g(n);\n  for (ll i = ll(0); i < ll(m); i++) {\n    ll first, second;\n    cin >> first >> second;\n    first--;\n    second--;\n    g[first].push_back(second);\n    g[second].push_back(first);\n  }\n  return g;\n}\nvvc<ll> readTree(ll n) { return readGraph(n, n - 1); }\nconst ll nmax = 1005;\nll par[nmax];\nll first[nmax], second[nmax];\nvi g[nmax];\nll cur, num;\nbool used[nmax], preu[nmax];\nvoid goup(ll v) {\n  while (!used[v]) {\n    used[v] = true;\n    cur += second[v];\n    v = par[v];\n    num++;\n  }\n}\nvoid dfs(ll v, ll p, ll sum) {\n  assert(par[v] < 0);\n  par[v] = p;\n  for (auto to : g[v])\n    if (to != p && sum >= first[to]) {\n      if (par[to] == -1) {\n        dfs(to, v, sum + second[to]);\n      } else {\n        goup(v);\n      }\n    }\n}\nvoid slv() {\n  ll n, m;\n  cin >> n >> m;\n  for (ll i = ll(1); i < ll(n); i++) cin >> first[i];\n  for (ll i = ll(1); i < ll(n); i++) cin >> second[i];\n  for (ll i = ll(0); i < ll(n); i++) g[i].clear();\n  for (ll i = ll(0); i < ll(m); i++) {\n    ll x, y;\n    cin >> x >> y;\n    x--;\n    y--;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  ll lw = -1, up = ten(9) + 1;\n  while (up - lw > 1) {\n    const ll mid = (lw + up) / 2;\n    cur = mid;\n    num = 1;\n    for (ll i = ll(0); i < ll(n); i++) used[i] = false;\n    used[0] = 1;\n    while (num < n) {\n      for (ll i = ll(0); i < ll(n); i++) preu[i] = used[i];\n      for (ll i = ll(0); i < ll(n); i++) par[i] = preu[i] ? -2 : -1;\n      ll tmp = num;\n      for (ll i = ll(0); i < ll(n); i++)\n        if (preu[i]) {\n          dfs(i, -2, cur);\n        }\n      if (num == tmp) break;\n    }\n    if (num == n)\n      up = mid;\n    else\n      lw = mid;\n  }\n  print(up + 1);\n}\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout << fixed << setprecision(20);\n  ll t;\n  cin >> t;\n  for (ll _ = ll(0); _ < ll(t); _++) slv();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nbool chkmax(T &x, T y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <typename T>\nbool chkmin(T &x, T y) {\n  return x > y ? x = y, true : false;\n}\nusing namespace std;\nlong long ksm(long long a, long long b) {\n  if (!b) return 1;\n  long long ns = ksm(a, b >> 1);\n  ns = ns * ns % 998244353;\n  if (b & 1) ns = ns * a % 998244353;\n  return ns;\n}\nint n, m, a[4005], b[4005], u[4005], v[4005], dis[4005], lst[4005];\nlong long power;\nint cur;\nbool vis[4005];\nvector<pair<int, int> > e[4005];\nvector<int> E[4005];\nlong long refresh() {\n  for (int i = 1; i <= n; i++) {\n    E[i].clear();\n    for (auto x : e[i]) E[i].push_back(x.second);\n  }\n  long long del = 1 << 30;\n  queue<int> q;\n  for (auto x : E[1])\n    if (dis[x] <= power)\n      q.push(x);\n    else\n      del = min(del, dis[x] - power);\n  E[1].clear();\n  while (!q.empty()) {\n    int id = q.front();\n    q.pop();\n    if (!vis[v[id]]) {\n      vis[v[id]] = 1;\n      power += b[v[id]];\n      del = -1;\n      return del;\n    }\n    bool rid = false;\n    for (auto x : E[v[id]]) {\n      if (x == (id ^ 1)) {\n        rid = true;\n        continue;\n      }\n      if (dis[x] <= power)\n        q.push(x);\n      else\n        del = min(del, dis[x] - power);\n    }\n    E[v[id]].clear();\n    if (rid) E[v[id]].push_back(id ^ 1);\n  }\n  return del;\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) e[i].clear(), vis[i] = 0;\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &a[i]), a[i] += 1;\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &b[i]);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &u[2 * i], &v[2 * i]);\n    u[2 * i + 1] = v[2 * i];\n    v[2 * i + 1] = u[2 * i];\n    e[u[2 * i]].push_back(make_pair(v[2 * i], 2 * i));\n    e[u[2 * i + 1]].push_back(make_pair(v[2 * i + 1], 2 * i + 1));\n  }\n  for (int i = 0; i < 2 * m; i++) dis[i] = a[v[i]];\n  for (int r = 0; r < m; r++) {\n    memcpy(lst, dis, sizeof lst);\n    for (int i = 1; i <= n; i++) {\n      pair<int, int> m1(1 << 30, -1), m2(1 << 30, -1);\n      for (auto x : e[i]) {\n        if (lst[x.second] < m2.first) m2 = {lst[x.second], x.second};\n        if (m2 < m1) swap(m2, m1);\n      }\n      for (auto x : e[i]) {\n        int id = x.second ^ 1;\n        if (m1.second == x.second)\n          dis[id] = max(a[v[id]], m2.first - b[i]);\n        else\n          dis[id] = max(a[v[id]], m1.first - b[i]);\n      }\n    }\n  }\n  cur = 0;\n  power = 0;\n  while (true) {\n    int del = refresh();\n    if (del == (1 << 30)) break;\n    if (del > 0) {\n      cur += del;\n      power += del;\n    }\n  }\n  printf(\"%d\\n\", cur);\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  for (int i = 0; i < T; i++) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntemplate <class T>\ninline void amin(T &x, const T &y) {\n  if (y < x) x = y;\n}\ntemplate <class T>\ninline void amax(T &x, const T &y) {\n  if (x < y) x = y;\n}\nint N, M;\nint A[1011];\nint B[1011];\nint X[2011];\nint Y[2011];\nvector<int> G[1011];\nbool is_root[1011];\nvector<int> que;\nint parent[1011];\nint parent_edge[1011];\nbool vis[1011];\nlong long S[1011];\nint anti(int v, int j) {\n  int x = X[j];\n  int y = Y[j];\n  if (is_root[x]) x = 0;\n  if (is_root[y]) y = 0;\n  return v ^ x ^ y;\n}\nbool ok(long long mid) {\n  memset(is_root, 0, sizeof is_root);\n  is_root[0] = true;\n  int rest = N;\n  while (1) {\n    memset(S, 0, sizeof S);\n    S[0] = mid;\n    for (int i = 0, i_len = (N); i < i_len; ++i) G[i].clear();\n    for (int j = 0, j_len = (M); j < j_len; ++j) {\n      int x = X[j];\n      int y = Y[j];\n      if (is_root[x]) x = 0;\n      if (is_root[y]) y = 0;\n      if (x == 0 && y == 0) continue;\n      G[x].push_back(j);\n      G[y].push_back(j);\n    }\n    que.clear();\n    que.push_back(0);\n    memset(vis, 0, sizeof vis);\n    memset(parent_edge, -1, sizeof parent_edge);\n    vis[0] = true;\n    int find_x = -1, find_y = -1;\n    for (int i_ = 0; i_ < (int)que.size(); i_++) {\n      int v = que[i_];\n      for (__typeof((G[v]).begin()) e = (G[v]).begin(), e_end = (G[v]).end();\n           e != e_end; ++e) {\n        int w = anti(v, *e);\n        if (vis[w] && *e == parent_edge[v]) continue;\n        if (vis[w]) {\n          find_x = v;\n          find_y = w;\n          goto OUT;\n        } else if (A[w] < S[v]) {\n          vis[w] = true;\n          parent[w] = v;\n          parent_edge[w] = *e;\n          S[w] = S[v] + B[w];\n          que.push_back(w);\n        }\n      }\n    }\n  OUT:\n    if (find_x == -1) return false;\n    while (!is_root[find_x]) {\n      mid += B[find_x];\n      is_root[find_x] = true;\n      rest--;\n      find_x = parent[find_x];\n    }\n    while (!is_root[find_y]) {\n      mid += B[find_y];\n      is_root[find_y] = true;\n      rest--;\n      find_y = parent[find_y];\n    }\n    if (rest == 1) return true;\n  }\n}\nvoid MAIN() {\n  scanf(\"%d%d\", &N, &M);\n  for (int i = 0, i_len = (N - 1); i < i_len; ++i) scanf(\"%d\", A + i + 1);\n  for (int i = 0, i_len = (N - 1); i < i_len; ++i) scanf(\"%d\", B + i + 1);\n  for (int j = 0, j_len = (M); j < j_len; ++j) {\n    scanf(\"%d%d\", X + j, Y + j);\n    X[j]--;\n    Y[j]--;\n  }\n  long long lo = -1, hi = 1000000001;\n  while (hi - lo > 1) {\n    long long mid = (hi + lo) / 2;\n    (ok(mid) ? hi : lo) = mid;\n  }\n  printf(\"%lld\\n\", hi);\n}\nint main() {\n  int TC = 1;\n  scanf(\"%d\", &TC);\n  for (int tc = 0, tc_len = (TC); tc < tc_len; ++tc) MAIN();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nbool chkmax(T &x, T y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <typename T>\nbool chkmin(T &x, T y) {\n  return x > y ? x = y, true : false;\n}\nusing namespace std;\nlong long ksm(long long a, long long b) {\n  if (!b) return 1;\n  long long ns = ksm(a, b >> 1);\n  ns = ns * ns % 998244353;\n  if (b & 1) ns = ns * a % 998244353;\n  return ns;\n}\nint n, m, a[4005], b[4005], u[4005], v[4005], dis[4005], lst[4005];\nlong long power;\nint cur;\nbool vis[4005];\nvector<pair<int, int> > e[4005];\nvector<int> E[4005];\nlong long refresh() {\n  for (int i = 1; i <= n; i++) {\n    E[i].clear();\n    for (auto x : e[i]) E[i].push_back(x.second);\n  }\n  long long del = 1 << 30;\n  queue<int> q;\n  for (auto x : E[1])\n    if (dis[x] <= power)\n      q.push(x);\n    else\n      del = min(del, dis[x] - power);\n  E[1].clear();\n  while (!q.empty()) {\n    int id = q.front();\n    q.pop();\n    if (!vis[v[id]]) {\n      vis[v[id]] = 1;\n      power += b[v[id]];\n      del = -1;\n      return del;\n    }\n    bool rid = false;\n    for (auto x : E[v[id]]) {\n      if (x == (id ^ 1)) {\n        rid = true;\n        continue;\n      }\n      if (dis[x] <= power)\n        q.push(x);\n      else\n        del = min(del, dis[x] - power);\n    }\n    E[v[id]].clear();\n    if (rid) E[v[id]].push_back(id ^ 1);\n  }\n  return del;\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) e[i].clear(), vis[i] = 0;\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &a[i]), a[i] += 1;\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &b[i]);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &u[2 * i], &v[2 * i]);\n    u[2 * i + 1] = v[2 * i];\n    v[2 * i + 1] = u[2 * i];\n    e[u[2 * i]].push_back(make_pair(v[2 * i], 2 * i));\n    e[u[2 * i + 1]].push_back(make_pair(v[2 * i + 1], 2 * i + 1));\n  }\n  for (int i = 0; i < 2 * m; i++) dis[i] = a[v[i]];\n  for (int r = 0; r < 2 * m; r++) {\n    memcpy(lst, dis, sizeof lst);\n    for (int i = 1; i <= n; i++) {\n      pair<int, int> m1(1 << 30, -1), m2(1 << 30, -1);\n      for (auto x : e[i]) {\n        if (dis[x.second] < m2.first) m2 = {dis[x.second], x.second};\n        if (m2 < m1) swap(m2, m1);\n      }\n      for (auto x : e[i]) {\n        int id = x.second ^ 1;\n        if (m1.second == x.second)\n          dis[id] = max(lst[id], m2.first - b[i]);\n        else\n          dis[id] = max(lst[id], m1.first - b[i]);\n      }\n    }\n  }\n  cur = 0;\n  power = 0;\n  while (true) {\n    int del = refresh();\n    if (del == (1 << 30)) break;\n    if (del > 0) {\n      cur += del;\n      power += del;\n    }\n  }\n  printf(\"%d\\n\", cur);\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  for (int i = 0; i < T; i++) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1005;\nint n, m, suc;\nvector<int> e[N];\nint a[N], b[N], fr[N];\nlong long ATK;\nint vis[N];\nvoid dfs(int x, int fa, long long ATK) {\n  if (suc) return;\n  for (auto i : e[x])\n    if (i != fa && a[i] < ATK) {\n      if (vis[i] && vis[x]) continue;\n      if (vis[i]) {\n        suc = 1;\n        for (int j = x; j; j = fr[j]) vis[j] = 1;\n      } else if (fr[i]) {\n        suc = 1;\n        for (int j = i; j; j = fr[j]) vis[j] = 1;\n        for (int j = x; j; j = fr[j]) vis[j] = 1;\n      } else {\n        fr[i] = x;\n        dfs(i, x, ATK + b[i]);\n      }\n      if (suc) return;\n    }\n}\nbool check(int v) {\n  int rem = n - 1;\n  memset(vis, 0, sizeof(vis));\n  vis[1] = 1;\n  for (;;) {\n    bool flg = 0;\n    suc = 0;\n    long long ATK = v;\n    memset(fr, 0, sizeof(fr));\n    for (int i = 1; i <= n; i++)\n      if (vis[i])\n        ATK += b[i];\n      else\n        flg = 1;\n    if (!flg) return 1;\n    for (int i = 1; i <= n && !suc; i++)\n      if (vis[i]) dfs(i, 0, ATK);\n    if (!suc) return 0;\n  }\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) e[i].resize(0);\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &b[i]);\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    e[x].push_back(y);\n    e[y].push_back(x);\n  }\n  int l = 1, r = 1e9 + 5, ans = -1;\n  while (l <= r) {\n    int mid = (l + r) / 2;\n    if (check(mid))\n      ans = mid, r = mid - 1;\n    else\n      l = mid + 1;\n  }\n  cout << ans << endl;\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v[1005];\nint a[1005], b[1005];\nlong long d[1005];\nint from[1005];\nint f[1005];\nint vis[1005];\nint Find(int first) {\n  if (f[first] == first) return first;\n  return f[first] = Find(f[first]);\n}\nvoid solve() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) v[i].clear();\n  for (int i = 2; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for (int i = 2; i <= n; i++) {\n    scanf(\"%d\", &b[i]);\n  }\n  vector<pair<int, int> > edge;\n  for (int i = 0; i < m; i++) {\n    int first, second;\n    scanf(\"%d %d\", &first, &second);\n    edge.push_back(make_pair(first, second));\n    v[first].push_back(second);\n    v[second].push_back(first);\n  }\n  int Max = 1e9 + 1, Min = 0;\n  while (Max > Min + 1) {\n    int mid = (Max + Min) / 2;\n    for (int i = 1; i <= n; i++) f[i] = i, d[i] = -1;\n    while (true) {\n      long long now = mid;\n      for (int i = 1; i <= n; i++) {\n        d[i] = -1, vis[i] = 0;\n        if (f[i] == 1) now += b[i];\n      }\n      queue<int> q;\n      q.push(1);\n      d[1] = now;\n      vis[1] = 1;\n      int ok = 0;\n      vector<int> tmp;\n      while (!q.empty()) {\n        int first = q.front();\n        q.pop();\n        for (auto it : v[first]) {\n          if (!vis[it]) {\n            if (f[it] == 1) {\n              q.push(it);\n              vis[it] = 1;\n              d[it] = d[1];\n            } else {\n              if (d[first] > a[it]) {\n                q.push(it);\n                vis[it] = 1;\n                d[it] = d[first] + b[it];\n                from[it] = first;\n              }\n            }\n          } else {\n            if (f[it] == 1) {\n              if (from[first] != it && f[first] != 1) {\n                ok = 1;\n                int a = first, b = it;\n                while (f[a] != 1) tmp.push_back(a), a = from[a];\n                while (f[b] != 1) tmp.push_back(b), b = from[b];\n                break;\n              }\n            } else if (from[first] != it) {\n              ok = 1;\n              int a = first, b = it;\n              while (f[a] != 1) tmp.push_back(a), a = from[a];\n              while (f[b] != 1) tmp.push_back(b), b = from[b];\n              break;\n            }\n          }\n        }\n        if (ok) break;\n      }\n      if (ok) {\n        for (auto it : tmp) {\n          f[it] = 1;\n        }\n      } else {\n        break;\n      }\n    }\n    int ok = 1;\n    for (int i = 1; i <= n; i++) {\n      if (f[i] != 1) ok = 0;\n    }\n    if (ok)\n      Max = mid;\n    else\n      Min = mid;\n  }\n  printf(\"%d\\n\", Max);\n}\nint main() {\n  int t = 1;\n  scanf(\"%d\", &t);\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INFi = 2e9 + 5;\nconst int md = 998244353;\nconst long long INF = 2e18;\nconst int maxN = 3e6 + 1;\ndouble getTime() { return clock() / (double)CLOCKS_PER_SEC; }\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < (n - 1); ++i) cin >> a[i + 1];\n  for (int i = 0; i < (n - 1); ++i) cin >> b[i + 1];\n  long long s = 0;\n  int ans = 0;\n  vector<vector<pair<int, int>>> g(n);\n  vector<int> U(m), V(m);\n  for (int i = 0; i < (m); ++i) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    U[i] = u;\n    V[i] = v;\n    g[u].emplace_back(v, i);\n    g[v].emplace_back(u, i);\n  }\n  vector<bool> us(n);\n  bool ok = true;\n  us[0] = true;\n  while (ok) {\n    ok = false;\n    vector<long long> dp(n, INF);\n    vector<int> p(n, -1);\n    vector<bool> was(n, false);\n    set<array<int, 3>> q;\n    for (int i = 0; i < (n); ++i) {\n      for (auto &[u, j] : g[i]) {\n        if (us[u] && u) {\n          if (U[j] == u) {\n            U[j] = 0;\n          } else {\n            V[j] = 0;\n          }\n          u = 0;\n        }\n      }\n    }\n    for (int i = 0; i < (n); ++i) {\n      if (!us[i]) continue;\n      for (auto &[u, j] : g[i]) {\n        if (!u) continue;\n        q.insert({(int)max(0ll, 1ll * a[u] + 1 - s), u, j});\n      }\n    }\n    was[0] = true;\n    int f1 = -1, f2 = -1;\n    while (!q.empty()) {\n      auto [need, v, j] = *q.begin();\n      q.erase(q.begin());\n      ans = max(ans, need);\n      if (was[v]) {\n        f1 = v;\n        f2 = U[j] ^ V[j] ^ v;\n        ok = true;\n        break;\n      }\n      was[v] = true;\n      int from = U[j] ^ V[j] ^ v;\n      p[v] = from;\n      if (us[from]) {\n        dp[v] = s + b[v];\n      } else {\n        dp[v] = dp[from] + b[v];\n      }\n      for (auto &[u, e] : g[v]) {\n        if (e == j) continue;\n        q.insert({(int)max(0ll, 1ll * a[u] + 1 - dp[v]), u, e});\n      }\n    }\n    if (!ok) break;\n    while (!us[f1]) {\n      us[f1] = true;\n      s += b[f1];\n      f1 = p[f1];\n    }\n    while (!us[f2]) {\n      us[f2] = true;\n      s += b[f2];\n      f2 = p[f2];\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int tests = 1;\n  cin >> tests;\n  for (int _ = 0; _ < (tests); ++_) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1005;\nint n, m, a[N], b[N], aa[N], bb[N], dep[N], fa[N];\nvector<int> g[N];\nbool vis[N];\nlong long dfs(int u, long long cur) {\n  vis[u] = true;\n  for (auto v : g[u]) {\n    if (v == fa[u]) continue;\n    if (a[u] && !a[v]) {\n      long long res = 0;\n      while (a[u]) {\n        res += b[u];\n        a[u] = b[u] = 0;\n        u = fa[u];\n      }\n      return res;\n    } else if (a[u] && vis[v]) {\n      long long res = 0;\n      int x = u, y = v;\n      while (x != y) {\n        if (dep[x] < dep[y]) swap(x, y);\n        res += b[x];\n        a[x] = b[x] = 0;\n        x = fa[x];\n      }\n      return res;\n    } else if (!vis[v]) {\n      fa[v] = u, dep[v] = dep[u] + 1;\n      if (cur <= a[v]) continue;\n      long long res = dfs(v, cur + b[v]);\n      if (~res) return res;\n    }\n  }\n  return -1;\n}\ninline bool check(long long cur) {\n  while (count(a + 1, a + n + 1, 0) < n) {\n    memset(vis + 1, false, n);\n    memset(fa + 1, 0, n * 4);\n    long long tmp = dfs(1, cur);\n    if (tmp == -1) {\n      memcpy(a + 1, aa + 1, n * 4);\n      memcpy(b + 1, bb + 1, n * 4);\n      return false;\n    }\n    cur += tmp;\n  }\n  memcpy(a + 1, aa + 1, n * 4);\n  memcpy(b + 1, bb + 1, n * 4);\n  return true;\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) g[i].clear();\n  for (int i = 2; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 2; i <= n; ++i) scanf(\"%d\", &b[i]);\n  memcpy(aa + 1, a + 1, n * 4);\n  memcpy(bb + 1, b + 1, n * 4);\n  for (int i = 1; i <= m; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    g[u].emplace_back(v);\n    g[v].emplace_back(u);\n  }\n  int l = 0, r = 0x3f3f3f3f, ans = -1;\n  while (l <= r) {\n    int mid = (l + r) >> 1;\n    if (check(mid))\n      ans = mid, r = mid - 1;\n    else\n      l = mid + 1;\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4007, inf = 1e9 + 5;\nint n, m, a[N], b[N], lst[N];\nvector<int> adj[N];\nlong long dis[N];\nbool rns[N];\nbool SPFA(long long &w) {\n  queue<int> q;\n  for (int i = (1); i <= (n); ++i)\n    if (rns[i])\n      q.push(i), dis[i] = w, lst[i] = -1;\n    else\n      dis[i] = -1, lst[i] = -1;\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int v : adj[u])\n      if (a[v] < dis[u] && !(rns[u] && rns[v]) && lst[u] != v) {\n        if (dis[v] == -1)\n          dis[v] = dis[u] + b[v], lst[v] = u, q.push(v);\n        else {\n          for (int x = u; !rns[x]; x = lst[x]) w += b[x], rns[x] = true;\n          for (int x = v; !rns[x]; x = lst[x]) w += b[x], rns[x] = true;\n          return true;\n        }\n      }\n  }\n  return false;\n}\nbool check(long long x) {\n  for (int i = (1); i <= (n); ++i) rns[i] = i == 1;\n  while (SPFA(x))\n    ;\n  for (int i = (1); i <= (n); ++i)\n    if (!rns[i]) return false;\n  return true;\n}\nvoid Main() {\n  cin >> n >> m;\n  for (int i = (2); i <= (n); ++i) cin >> a[i];\n  for (int i = (2); i <= (n); ++i) cin >> b[i];\n  for (int i = (1); i <= (m); ++i) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v), adj[v].push_back(u);\n  }\n  int l = 0, r = 1e9 + 3, ns = -1;\n  while (l <= r) {\n    int mid = (l + r) >> 1;\n    if (check(mid))\n      ns = mid, r = mid - 1;\n    else\n      l = mid + 1;\n  }\n  cout << ns << \"\\n\";\n  for (int i = (1); i <= (n); ++i) adj[i].clear();\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int T;\n  cin >> T;\n  while (T--) Main();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1005;\nconst int inf = 0x3f3f3f3f;\nint read() {\n  int x = 0, f = 1;\n  char c;\n  while ((c = getchar()) < '0' || c > '9') {\n    if (c == '-') f = -1;\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 3) + (x << 1) + (c ^ 48);\n    c = getchar();\n  }\n  return x * f;\n}\nint T, n, m, ans, a[M], b[M], vis[M], cur[M], pre[M];\nvector<int> g[M];\nint path(int x) {\n  if (vis[x]) return 0;\n  vis[x] = 1;\n  return min(inf, path(pre[x]) + b[x]);\n}\nint dfs(int u, int x) {\n  x = min(inf, x + b[u]);\n  cur[u] = 1;\n  for (auto v : g[u]) {\n    if (v == pre[u] || x <= a[v]) continue;\n    if (cur[v]) return path(u) + path(v);\n    pre[v] = u;\n    int f = dfs(v, x);\n    if (f != -1) return f;\n  }\n  return -1;\n}\nint check(int x) {\n  int f = 0;\n  memset(vis, 0, sizeof vis);\n  vis[1] = 1;\n  while (f != -1) {\n    f = -1;\n    memcpy(cur, vis, sizeof cur);\n    for (int u = 1; u <= n && f == -1; u++)\n      if (vis[u])\n        for (auto v : g[u])\n          if (!vis[v] && x > a[v]) {\n            pre[v] = u;\n            f = dfs(v, x);\n            if (f != -1) break;\n          }\n    if (f == -1) {\n      for (int i = 1; i <= n; i++)\n        if (!vis[i]) return 0;\n      return 1;\n    }\n    x = min(inf, x + f);\n  }\n  return 0;\n}\nvoid dich(int l, int r) {\n  if (l > r) return;\n  int mid = (l + r) >> 1;\n  if (check(mid)) {\n    ans = mid;\n    dich(l, mid - 1);\n  } else\n    dich(mid + 1, r);\n}\nvoid work() {\n  n = read();\n  m = read();\n  for (int i = 1; i <= n; i++) g[i].clear();\n  for (int i = 2; i <= n; i++) a[i] = read();\n  for (int i = 2; i <= n; i++) b[i] = read();\n  for (int i = 1; i <= m; i++) {\n    int u = read(), v = read();\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dich(0, inf);\n  printf(\"%d\\n\", ans);\n}\nsigned main() {\n  T = read();\n  while (T--) work();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1000;\nint test, n, m, a[MAX + 1], b[MAX + 1], u, v, par[MAX + 1], lef, rig, mid, cnt,\n    res;\nlong long curB;\nbool fr[MAX + 1], frInProcess[MAX + 1], found;\nvector<int> adj[MAX + 1];\nvoid visit(const int& u, const long long& bInProcess) {\n  frInProcess[u] = true;\n  for (const int& v : adj[u]) {\n    if (v != par[u] && bInProcess >= a[v])\n      if (frInProcess[v]) {\n        for (int point = u; point != -1; point = par[point])\n          if (!fr[point]) {\n            fr[point] = true;\n            curB += b[point];\n            ++cnt;\n          }\n        for (int point = v; point != -1; point = par[point])\n          if (!fr[point]) {\n            fr[point] = true;\n            curB += b[point];\n            ++cnt;\n          }\n        found = true;\n        return;\n      } else {\n        par[v] = u;\n        visit(v, bInProcess + b[v]);\n      }\n    if (found) return;\n  }\n}\nint main() {\n  scanf(\"%d\", &test);\n  while (test--) {\n    scanf(\"%d %d\", &n, &m);\n    lef = 1e9 + 10;\n    rig = 0LL;\n    for (int i = 2; i <= n; ++i) {\n      scanf(\"%d\", a + i);\n      ++a[i];\n      lef = min(lef, a[i]);\n      rig = max(rig, a[i]);\n    }\n    for (int i = 2; i <= n; ++i) scanf(\"%d\", b + i);\n    for (int i = 1; i <= n; ++i) adj[i].clear();\n    while (m--) {\n      scanf(\"%d %d\", &u, &v);\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n    while (lef <= rig) {\n      mid = (lef + rig) >> 1;\n      curB = mid;\n      memset(fr + 1, false, n);\n      fr[1] = true;\n      cnt = 1;\n      while (cnt < n) {\n        memcpy(frInProcess + 1, fr + 1, n);\n        memset(par + 1, -1, n * sizeof(int));\n        found = false;\n        for (int start = 1; start <= n; ++start)\n          if (!found && fr[start])\n            for (const int& u : adj[start])\n              if (!found && !fr[u] && curB >= a[u]) {\n                par[u] = start;\n                visit(u, curB + b[u]);\n              }\n        if (!found) break;\n      }\n      if (cnt == n)\n        rig = (res = mid) - 1;\n      else\n        lef = mid + 1;\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int readint() {\n  int a = 0;\n  char c = getchar(), f = 1;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') f = -f;\n  for (; '0' <= c && c <= '9'; c = getchar())\n    a = (a << 3) + (a << 1) + (c ^ 48);\n  return a * f;\n}\nconst int MaxN = 1005;\nconst int MaxM = 2005;\nstruct Edge {\n  int to, nxt;\n  Edge() { to = nxt = 0; }\n  Edge(int T, int N) { to = T, nxt = N; }\n};\nEdge e[MaxM << 1];\nint head[MaxN], cntEdge;\nvoid addEdge(int a, int b) {\n  e[cntEdge] = Edge(b, head[a]);\n  head[a] = cntEdge++;\n}\nconst int infty = (1 << 30) - 1;\nint a[MaxN], b[MaxN];\nbool vis[MaxN], cur[MaxN];\nint pre[MaxN];\nint getPath(int x) {\n  if (vis[x]) return 0;\n  vis[x] = true;\n  return min(infty, getPath(pre[x]) + b[x]);\n}\nint dfs(int now, int x) {\n  cur[x] = true;\n  now = min(now + b[x], infty);\n  for (int i = head[x]; ~i; i = e[i].nxt) {\n    if (e[i].to == pre[x]) continue;\n    if (now <= a[e[i].to]) continue;\n    if (cur[e[i].to]) return getPath(x) + getPath(e[i].to);\n    pre[e[i].to] = x;\n    int f = dfs(now, e[i].to);\n    if (~f) return f;\n  }\n  return -1;\n}\nint n;\nbool check(int now) {\n  memset(vis + 1, 0, n);\n  memset(pre + 1, 0, n << 2);\n  for (vis[1] = 1; true;) {\n    memcpy(cur + 1, vis + 1, n);\n    bool ok = 1;\n    int f = -1;\n    for (int i = (1); i <= (n); ++i) ok = ok && vis[i];\n    if (ok) return true;\n    for (int i = 1; i <= n; ++i) {\n      if (!vis[i]) continue;\n      for (int j = head[i]; ~j; j = e[j].nxt)\n        if (!vis[e[j].to])\n          if (now > a[e[j].to]) {\n            pre[e[j].to] = i;\n            f = dfs(now, e[j].to);\n            if (~f) {\n              now += f;\n              break;\n            }\n          }\n      if (~f) break;\n    }\n    if (f == -1) return false;\n    now = min(now, infty);\n  }\n  return false;\n}\nint main() {\n  for (int T = readint(); T; --T) {\n    n = readint();\n    int m = readint();\n    cntEdge = 0;\n    memset(head + 1, -1, n << 2);\n    for (int i = (2); i <= (n); ++i) a[i] = readint();\n    for (int i = (2); i <= (n); ++i) b[i] = readint();\n    for (int i = 1, x, y; i <= m; ++i) {\n      x = readint(), y = readint();\n      addEdge(x, y), addEdge(y, x);\n    }\n    int L = 0, R = 1e9 + 1, mid = R >> 1;\n    for (; L != R; mid = (L + R) >> 1)\n      if (check(mid))\n        R = mid;\n      else\n        L = mid + 1;\n    printf(\"%d\\n\", L);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  char ch = getchar();\n  int w = 1, c = 0;\n  for (; !isdigit(ch); ch = getchar())\n    if (ch == '-') w = -1;\n  for (; isdigit(ch); ch = getchar()) c = (c << 1) + (c << 3) + (ch ^ 48);\n  return w * c;\n}\nconst int M = 1e5 + 10;\nint n, m, a[M], b[M];\nvector<int> v[M];\nlong long dis[M];\nint q[M], l, r, pre[M];\nbool vs[M], in[M];\nbool chk(int mid) {\n  for (int i = (1); i <= (n); ++i) in[i] = 0;\n  in[1] = 1;\n  long long now = mid;\n  while (1) {\n    l = 1;\n    r = 0;\n    for (int i = (1); i <= (n); ++i) dis[i] = pre[i] = 0, vs[i] = in[i];\n    for (int i = (1); i <= (n); ++i)\n      if (in[i]) q[++r] = i, dis[i] = now;\n    if (r == n) return 1;\n    int X = 0, Y = 0;\n    while (l <= r) {\n      int x = q[l++];\n      for (int y : v[x]) {\n        if (in[x] && in[y]) continue;\n        if (dis[x] <= a[y] || pre[x] == y) continue;\n        if (vs[y]) {\n          X = x;\n          Y = y;\n          break;\n        }\n        dis[y] = dis[x] + b[y];\n        pre[y] = x;\n        vs[y] = 1;\n        q[++r] = y;\n      }\n      if (X) break;\n    }\n    if (!X) return 0;\n    for (int x = X; x; x = pre[x])\n      if (!in[x]) in[x] = 1, now += b[x];\n    for (int x = Y; x; x = pre[x])\n      if (!in[x]) in[x] = 1, now += b[x];\n  }\n}\nvoid work() {\n  n = read();\n  m = read();\n  for (int i = (1); i <= (n); ++i) v[i].clear();\n  for (int i = (2); i <= (n); ++i) a[i] = read();\n  for (int i = (2); i <= (n); ++i) b[i] = read();\n  for (int i = (1); i <= (m); ++i) {\n    int x = read(), y = read();\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  int l = 0, r = (1 << 30), ret = r;\n  while (l <= r) {\n    int mid = (l + r >> 1);\n    if (chk(mid))\n      ret = mid, r = mid - 1;\n    else\n      l = mid + 1;\n  }\n  cout << ret << \"\\n\";\n}\nint main() {\n  int T = read();\n  while (T--) work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, a[2005], b[2005], inset[2005], from[2005], vis[2005];\nlong long dt;\nvector<long long> e[2005], vec;\nvoid fuck(long long x) {\n  while (!inset[x]) {\n    dt += b[x];\n    vec.push_back(x);\n    inset[x] = 1;\n    x = from[x];\n  }\n}\nbool dfs(long long u, long long pw) {\n  vis[u] = 1;\n  for (auto v : e[u]) {\n    if (pw <= a[v]) continue;\n    if (inset[u] && inset[v]) continue;\n    if (v == from[u]) continue;\n    if (vis[v]) {\n      fuck(v);\n      fuck(u);\n      return 1;\n    } else {\n      from[v] = u;\n      if (dfs(v, pw + b[v])) return 1;\n    }\n  }\n  return 0;\n}\nbool check(long long p) {\n  vec.clear();\n  for (long long i = (1); i <= (n); i++) inset[i] = 0;\n  vec.push_back(1);\n  inset[1] = 1;\n  for (long long i = (1); i <= (n); i++) {\n    for (long long j = (1); j <= (n); j++) from[j] = j, vis[j] = inset[j];\n    dt = 0;\n    for (auto x : vec) {\n      if (dfs(x, p)) {\n        break;\n      }\n    }\n    p += dt;\n  }\n  return ((long long)vec.size()) == n;\n}\nvoid solve() {\n  scanf(\"%lld%lld\", &n, &m);\n  for (long long i = (2); i <= (n); i++) scanf(\"%lld\", &a[i]);\n  for (long long i = (2); i <= (n); i++) scanf(\"%lld\", &b[i]);\n  for (long long i = (1); i <= (n); i++) e[i].clear();\n  for (long long i = (1); i <= (m); i++) {\n    long long u, v;\n    scanf(\"%lld%lld\", &u, &v);\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  long long l = 1, r = 1e9 + 1, ans = 0;\n  while (l <= r) {\n    long long mid = (l + r) >> 1;\n    if (check(mid))\n      ans = mid, r = mid - 1;\n    else\n      l = mid + 1;\n  }\n  printf(\"%lld\\n\", ans);\n}\nsigned main() {\n  long long T;\n  scanf(\"%lld\", &T);\n  while (T-- > 0) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void read(T& a) {\n  char c = getchar();\n  int f = 1;\n  a = 0;\n  for (; c > '9' || c < '0'; c = getchar())\n    if (c == '-') f = -1;\n  for (; c <= '9' && c >= '0'; c = getchar()) a = a * 10 + c - 48;\n  a *= f;\n}\nconst int o = 4010, inf = 1e9 + 1;\nint T, n, m, h[o], cnt, fr[o], a[o], b[o], st[o], pw;\nbool vis[o];\nstruct Edge {\n  int v, p;\n} e[o];\ninline void ad(int U, int V) {\n  e[++cnt].v = V;\n  e[cnt].p = h[U];\n  h[U] = cnt;\n}\ninline void ins(int u) {\n  for (; !vis[u]; u = fr[u])\n    pw += b[u], pw = (pw > inf ? inf : pw), vis[st[++cnt] = u] = 1;\n}\nbool dfs(int nw, int fa, long long val) {\n  for (int i = h[nw]; i; i = e[i].p)\n    if (e[i].v - fa && val > a[e[i].v])\n      if (vis[e[i].v])\n        if (vis[nw])\n          ;\n        else {\n          ins(nw);\n          return true;\n        }\n      else if (fr[e[i].v]) {\n        ins(e[i].v);\n        ins(nw);\n        return true;\n      } else if (dfs(e[i].v, fr[e[i].v] = nw, val + b[e[i].v]))\n        return true;\n  return false;\n}\nint main() {\n  for (read(T); T--;) {\n    read(n);\n    read(m);\n    cnt = 0;\n    for (int i = 1; i <= n; ++i) h[i] = 0;\n    for (int i = 2; i <= n; ++i) read(a[i]);\n    for (int i = 2; i <= n; ++i) read(b[i]);\n    for (int i, j; m--;) read(i), read(j), ad(i, j), ad(j, i);\n    for (int l = 0, r = inf, md; l < r;) {\n      for (int i = 2; i <= n; ++i) vis[i] = 0;\n      st[1] = vis[1] = cnt = 1;\n      pw = md = l + r >> 1;\n      for (bool flg; cnt < n;) {\n        for (int i = 1; i <= n; ++i) fr[i] = 0;\n        for (int i = flg = 1; i <= cnt; ++i)\n          if (dfs(st[i], 0, pw)) {\n            flg = 0;\n            break;\n          }\n        if (flg && cnt < n) {\n          l = md + 1;\n          break;\n        }\n      }\n      if (l <= md) r = md;\n      if (l == r) printf(\"%d\\n\", l);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, a[1005], b[1005];\nlong long ans, NowD;\nvector<int> vec[1005];\nbool Reach[1005], vis[1005];\nlong long dis[1005];\nint From[1005];\nbool check(long long x) {\n  queue<int> Q;\n  for (int i = 1; i <= n; i++) {\n    if (Reach[i]) {\n      dis[i] = x;\n      vis[i] = true;\n      Q.push(i);\n      From[i] = 0;\n    } else {\n      dis[i] = 0;\n      From[i] = 0;\n      vis[i] = false;\n    }\n  }\n  while (!Q.empty()) {\n    int Now = Q.front();\n    Q.pop();\n    if (!Reach[Now]) {\n      for (auto &p : vec[Now]) {\n        if (p == From[Now]) continue;\n        if (vis[p]) return true;\n        if (a[p] >= dis[Now]) continue;\n        vis[p] = true;\n        dis[p] = dis[Now] + b[p];\n        Q.push(p);\n        From[p] = Now;\n      }\n    } else {\n      for (auto &p : vec[Now]) {\n        if (vis[p] || a[p] >= dis[Now]) continue;\n        vis[p] = true;\n        dis[p] = dis[Now] + b[p];\n        Q.push(p);\n        From[p] = Now;\n      }\n    }\n  }\n  return false;\n}\nvoid GetR(int x) {\n  while (From[x] != 0) {\n    if (!Reach[x]) {\n      Reach[x] = true;\n      NowD += b[x];\n    }\n    x = From[x];\n  }\n}\nvoid bfs(long long x) {\n  queue<int> Q;\n  for (int i = 1; i <= n; i++) {\n    if (Reach[i]) {\n      dis[i] = x;\n      vis[i] = true;\n      From[i] = 0;\n      Q.push(i);\n    } else {\n      dis[i] = 0;\n      From[i] = 0;\n      vis[i] = false;\n    }\n  }\n  while (!Q.empty()) {\n    int Now = Q.front();\n    Q.pop();\n    if (!Reach[Now]) {\n      for (auto &p : vec[Now]) {\n        if (p == From[Now]) continue;\n        if (vis[p]) {\n          GetR(Now);\n          if (!Reach[p]) GetR(p);\n          return;\n        }\n        if (a[p] >= dis[Now]) continue;\n        vis[p] = true;\n        dis[p] = dis[Now] + b[p];\n        Q.push(p);\n        From[p] = Now;\n      }\n    } else {\n      for (auto &p : vec[Now]) {\n        if (vis[p] || a[p] >= dis[Now]) continue;\n        vis[p] = true;\n        dis[p] = dis[Now] + b[p];\n        From[p] = Now;\n        Q.push(p);\n      }\n    }\n  }\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) vec[i].clear(), Reach[i] = false;\n    NowD = 0;\n    ans = 0;\n    for (int i = 2; i <= n; i++) {\n      scanf(\"%d\", &a[i]);\n    }\n    for (int i = 2; i <= n; i++) {\n      scanf(\"%d\", &b[i]);\n    }\n    for (int i = 1; i <= m; i++) {\n      int u, v;\n      scanf(\"%d%d\", &u, &v);\n      vec[u].push_back(v);\n      vec[v].push_back(u);\n    }\n    Reach[1] = true;\n    while (1) {\n      bool flag = false;\n      for (int i = 1; i <= n; i++) {\n        if (!Reach[i]) flag = true;\n      }\n      if (!flag) break;\n      long long L = 1, R = 1e9 + 1;\n      while (L < R) {\n        long long Mid = (L + R) / 2;\n        if (check(Mid))\n          R = Mid;\n        else\n          L = Mid + 1;\n      }\n      ans = max(ans, L - NowD);\n      bfs(L);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1010;\nusing namespace std;\nint n, m;\nint a[N], b[N];\nint used[N];\nvector<int> v[N];\nint par[N];\nint X, Y;\nvoid dfs(int x, int p, long long k) {\n  k += b[x];\n  used[x] = 1;\n  par[x] = p;\n  for (int y : v[x]) {\n    if (y == p || k <= a[y]) {\n      continue;\n    } else if (used[y]) {\n      X = x;\n      Y = y;\n    } else {\n      dfs(y, x, k);\n    }\n    if (X != -1) {\n      break;\n    }\n  }\n}\nbool can(long long k) {\n  int cnt = 1;\n  for (int i = 1; i <= n; i++) {\n    used[i] = 0;\n  }\n  used[1] = 2;\n  while (cnt < n) {\n    for (int i = 1; i <= n; i++) {\n      if (used[i] == 1) {\n        used[i] = 0;\n      }\n      par[i] = -1;\n    }\n    X = Y = -1;\n    for (int i = 1; i <= n; i++) {\n      if (used[i] == 2) {\n        for (int j : v[i]) {\n          if (used[j] == 2 || k <= a[j]) {\n            continue;\n          }\n          if (used[j] == 1) {\n            X = i;\n            Y = j;\n          } else {\n            dfs(j, i, k);\n          }\n          if (X != -1) {\n            break;\n          }\n        }\n      }\n      if (X != -1) {\n        break;\n      }\n    }\n    if (X == -1) {\n      return false;\n    }\n    for (int x : {X, Y}) {\n      while (used[x] != 2) {\n        used[x] = 2;\n        k += b[x];\n        x = par[x];\n        cnt += 1;\n      }\n    }\n  }\n  return cnt == n;\n}\nvoid solve() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    v[i].clear();\n  }\n  for (int i = 2; i <= n; i++) {\n    cin >> a[i];\n  }\n  for (int i = 2; i <= n; i++) {\n    cin >> b[i];\n  }\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    cin >> x >> y;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  int l = 0, r = 1e9 + 1;\n  while (l < r) {\n    int m = (l + r) / 2;\n    if (can(m)) {\n      r = m;\n    } else {\n      l = m + 1;\n    }\n  }\n  cout << l << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:36777216\")\nusing namespace std;\ntemplate <class T>\ninline T &RD(T &);\ntemplate <class T>\ninline void OT(const T &);\ninline long long RD() {\n  long long x;\n  return RD(x);\n}\ninline double &RF(double &);\ninline double RF() {\n  double x;\n  return RF(x);\n}\ninline char *RS(char *s);\ninline char &RC(char &c);\ninline char RC();\ninline char &RC(char &c) {\n  scanf(\" %c\", &c);\n  return c;\n}\ninline char RC() {\n  char c;\n  return RC(c);\n}\ntemplate <class T>\ninline T &RDD(T &);\ninline long long RDD() {\n  long long x;\n  return RDD(x);\n}\ntemplate <class T0, class T1>\ninline T0 &RD(T0 &x0, T1 &x1) {\n  RD(x0), RD(x1);\n  return x0;\n}\ntemplate <class T0, class T1, class T2>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2) {\n  RD(x0), RD(x1), RD(x2);\n  return x0;\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3) {\n  RD(x0), RD(x1), RD(x2), RD(x3);\n  return x0;\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4) {\n  RD(x0), RD(x1), RD(x2), RD(x3), RD(x4);\n  return x0;\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5) {\n  RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5);\n  return x0;\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6) {\n  RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6);\n  return x0;\n}\ntemplate <class T0, class T1>\ninline void OT(const T0 &x0, const T1 &x1) {\n  OT(x0), OT(x1);\n}\ntemplate <class T0, class T1, class T2>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2) {\n  OT(x0), OT(x1), OT(x2);\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3) {\n  OT(x0), OT(x1), OT(x2), OT(x3);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3,\n               const T4 &x4) {\n  OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3,\n               const T4 &x4, const T5 &x5) {\n  OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3,\n               const T4 &x4, const T5 &x5, const T6 &x6) {\n  OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);\n}\ninline char &RC(char &a, char &b) {\n  RC(a), RC(b);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c) {\n  RC(a), RC(b), RC(c);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c, char &d) {\n  RC(a), RC(b), RC(c), RC(d);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c, char &d, char &e) {\n  RC(a), RC(b), RC(c), RC(d), RC(e);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c, char &d, char &e, char &f) {\n  RC(a), RC(b), RC(c), RC(d), RC(e), RC(f);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g) {\n  RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g);\n  return a;\n}\ninline double &RF(double &a, double &b) {\n  RF(a), RF(b);\n  return a;\n}\ninline double &RF(double &a, double &b, double &c) {\n  RF(a), RF(b), RF(c);\n  return a;\n}\ninline double &RF(double &a, double &b, double &c, double &d) {\n  RF(a), RF(b), RF(c), RF(d);\n  return a;\n}\ninline double &RF(double &a, double &b, double &c, double &d, double &e) {\n  RF(a), RF(b), RF(c), RF(d), RF(e);\n  return a;\n}\ninline double &RF(double &a, double &b, double &c, double &d, double &e,\n                  double &f) {\n  RF(a), RF(b), RF(c), RF(d), RF(e), RF(f);\n  return a;\n}\ninline double &RF(double &a, double &b, double &c, double &d, double &e,\n                  double &f, double &g) {\n  RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g);\n  return a;\n}\ninline void RS(char *s1, char *s2) { RS(s1), RS(s2); }\ninline void RS(char *s1, char *s2, char *s3) { RS(s1), RS(s2), RS(s3); }\ntemplate <class T0, class T1>\ninline T0 &RDD(T0 &a, T1 &b) {\n  RDD(a), RDD(b);\n  return a;\n}\ntemplate <class T0, class T1, class T2>\ninline T1 &RDD(T0 &a, T1 &b, T2 &c) {\n  RDD(a), RDD(b), RDD(c);\n  return a;\n}\ntemplate <class T>\ninline void RST(T &A) {\n  memset(A, 0, sizeof(A));\n}\ntemplate <class T>\ninline void FLC(T &A, int x) {\n  memset(A, x, sizeof(A));\n}\ntemplate <class T>\ninline void CLR(T &A) {\n  A.clear();\n}\ntemplate <class T0, class T1>\ninline void RST(T0 &A0, T1 &A1) {\n  RST(A0), RST(A1);\n}\ntemplate <class T0, class T1, class T2>\ninline void RST(T0 &A0, T1 &A1, T2 &A2) {\n  RST(A0), RST(A1), RST(A2);\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3) {\n  RST(A0), RST(A1), RST(A2), RST(A3);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4) {\n  RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5) {\n  RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6) {\n  RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);\n}\ntemplate <class T0, class T1>\ninline void FLC(T0 &A0, T1 &A1, int x) {\n  FLC(A0, x), FLC(A1, x);\n}\ntemplate <class T0, class T1, class T2>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x);\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x),\n      FLC(A6, x);\n}\ntemplate <class T>\ninline void CLR(priority_queue<T> &Q) {\n  while (!Q.empty()) Q.pop();\n}\ntemplate <class T>\ninline void CLR(stack<T> &S) {\n  while (!S.empty()) S.pop();\n}\ntemplate <class T>\ninline void CLR(queue<T> &Q) {\n  while (!Q.empty()) Q.pop();\n}\ntemplate <class T0, class T1>\ninline void CLR(T0 &A0, T1 &A1) {\n  CLR(A0), CLR(A1);\n}\ntemplate <class T0, class T1, class T2>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2) {\n  CLR(A0), CLR(A1), CLR(A2);\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3) {\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4) {\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5) {\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6) {\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);\n}\ntemplate <class T>\ninline void CLR(T &A, int n) {\n  for (int i = 0; i < n; ++i) CLR(A[i]);\n}\ntemplate <class T>\ninline bool EPT(T &a) {\n  return a.empty();\n}\ntemplate <class T>\ninline T &SRT(T &A) {\n  sort(A.begin(), A.end());\n  return A;\n}\ntemplate <class T, class C>\ninline T &SRT(T &A, C cmp) {\n  sort(A.begin(), A.end(), cmp);\n  return A;\n}\ntemplate <class T>\ninline T &RVS(T &A) {\n  reverse(A.begin(), A.end());\n  return A;\n}\ntemplate <class T>\ninline T &UNQQ(T &A) {\n  A.resize(unique(A.begin(), A.end()) - A.begin());\n  return A;\n}\ntemplate <class T>\ninline T &UNQ(T &A) {\n  SRT(A);\n  return UNQQ(A);\n}\ntemplate <class T, class C>\ninline T &UNQ(T &A, C cmp) {\n  SRT(A, cmp);\n  return UNQQ(A);\n}\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst long long INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-9;\nconst double OO = 1e20;\nconst double PI = acos(-1.0);\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\ntemplate <class T>\ninline bool checkMin(T &a, const T b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline bool checkMax(T &a, const T b) {\n  return a < b ? a = b, 1 : 0;\n}\ntemplate <class T, class C>\ninline bool checkUpd(T &a, const T b, C c) {\n  return c(b, a) ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline T min(T a, T b, T c) {\n  return min(min(a, b), c);\n}\ntemplate <class T>\ninline T max(T a, T b, T c) {\n  return max(max(a, b), c);\n}\ntemplate <class T>\ninline T min(T a, T b, T c, T d) {\n  return min(min(a, b), min(c, d));\n}\ntemplate <class T>\ninline T max(T a, T b, T c, T d) {\n  return max(max(a, b), max(c, d));\n}\ntemplate <class T>\ninline T min(T a, T b, T c, T d, T e) {\n  return min(min(min(a, b), min(c, d)), e);\n}\ntemplate <class T>\ninline T max(T a, T b, T c, T d, T e) {\n  return max(max(max(a, b), max(c, d)), e);\n}\ntemplate <class T>\ninline T sqr(T a) {\n  return a * a;\n}\ntemplate <class T>\ninline T cub(T a) {\n  return a * a * a;\n}\ntemplate <class T>\ninline T ceil(T x, T y) {\n  return (x - 1) / y + 1;\n}\ntemplate <class T>\nT abs(T x) {\n  return x > 0 ? x : -x;\n}\ninline int sgn(double x) { return x < -EPS ? -1 : x > EPS; }\ninline int sgn(double x, double y) { return sgn(x - y); }\ninline double cos(double a, double b, double c) {\n  return (sqr(a) + sqr(b) - sqr(c)) / (2 * a * b);\n}\ninline double cot(double x) { return 1. / tan(x); };\ninline double sec(double x) { return 1. / cos(x); };\ninline double csc(double x) { return 1. / sin(x); };\nnamespace BO {\ninline bool _1(int x, int i) { return bool(x & 1 << i); }\ninline bool _1(long long x, int i) { return bool(x & 1LL << i); }\ninline long long _1(int i) { return 1LL << i; }\ninline long long _U(int i) { return _1(i) - 1; };\ninline int reverse_bits(int x) {\n  x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n  x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n  x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n  x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n  x = ((x >> 16) & 0x0000ffff) | ((x << 16) & 0xffff0000);\n  return x;\n}\ninline long long reverse_bits(long long x) {\n  x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n  x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n  x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n  x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n  x = ((x >> 16) & 0x0000ffff0000ffffLL) | ((x << 16) & 0xffff0000ffff0000LL);\n  x = ((x >> 32) & 0x00000000ffffffffLL) | ((x << 32) & 0xffffffff00000000LL);\n  return x;\n}\ntemplate <class T>\ninline bool odd(T x) {\n  return x & 1;\n}\ntemplate <class T>\ninline bool even(T x) {\n  return !odd(x);\n}\ntemplate <class T>\ninline T low_bit(T x) {\n  return x & -x;\n}\ntemplate <class T>\ninline T high_bit(T x) {\n  T p = low_bit(x);\n  while (p != x) x -= p, p = low_bit(x);\n  return p;\n}\ntemplate <class T>\ninline T cover_bit(T x) {\n  T p = 1;\n  while (p < x) p <<= 1;\n  return p;\n}\ntemplate <class T>\ninline int cover_idx(T x) {\n  int p = 0;\n  while (_1(p) < x) ++p;\n  return p;\n}\ninline int clz(int x) { return __builtin_clz(x); }\ninline int clz(long long x) { return __builtin_clzll(x); }\ninline int ctz(int x) { return __builtin_ctz(x); }\ninline int ctz(long long x) { return __builtin_ctzll(x); }\ninline int lg2(int x) { return !x ? -1 : 31 - clz(x); }\ninline int lg2(long long x) { return !x ? -1 : 63 - clz(x); }\ninline int low_idx(int x) { return !x ? -1 : ctz(x); }\ninline int low_idx(long long x) { return !x ? -1 : ctz(x); }\ninline int high_idx(int x) { return lg2(x); }\ninline int high_idx(long long x) { return lg2(x); }\ninline int parity(int x) { return __builtin_parity(x); }\ninline int parity(long long x) { return __builtin_parityll(x); }\ninline int count_bits(int x) { return __builtin_popcount(x); }\ninline int count_bits(long long x) { return __builtin_popcountll(x); }\n}  // namespace BO\nusing namespace BO;\nnamespace NT {\ninline long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\ninline long long lcm(long long a, long long b) { return a * b / gcd(a, b); }\ninline void INC(int &a, int b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n}\ninline int sum(int a, int b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n  return a;\n}\ninline void DEC(int &a, int b) {\n  a -= b;\n  if (a < 0) a += MOD;\n}\ninline int dff(int a, int b) {\n  a -= b;\n  if (a < 0) a += MOD;\n  return a;\n}\ninline void MUL(int &a, int b) { a = (long long)a * b % MOD; }\ninline int pdt(int x, int y) {\n  int ret;\n  __asm__ __volatile__(\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\"\n                       : \"=d\"(ret)\n                       : \"a\"(x), \"b\"(y), \"c\"(MOD));\n  return ret;\n}\ninline int gcd(int m, int n, int &x, int &y) {\n  x = 1, y = 0;\n  int xx = 0, yy = 1, q;\n  while (1) {\n    q = m / n, m %= n;\n    if (!m) {\n      x = xx, y = yy;\n      return n;\n    }\n    DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n    q = n / m, n %= m;\n    if (!n) return m;\n    DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n  }\n}\ninline int sum(int a, int b, int c) { return sum(a, sum(b, c)); }\ninline int sum(int a, int b, int c, int d) { return sum(sum(a, b), sum(c, d)); }\ninline int pdt(int a, int b, int c) { return pdt(a, pdt(b, c)); }\ninline int pdt(int a, int b, int c, int d) { return pdt(pdt(a, b), pdt(c, d)); }\ninline int pow(int a, long long b) {\n  int c(1);\n  while (b) {\n    if (b & 1) MUL(c, a);\n    MUL(a, a), b >>= 1;\n  }\n  return c;\n}\ntemplate <class T>\ninline T pow(T a, long long b) {\n  T c(1);\n  while (b) {\n    if (b & 1) c *= a;\n    a *= a, b >>= 1;\n  }\n  return c;\n}\ntemplate <class T>\ninline T pow(T a, int b) {\n  return pow(a, (long long)b);\n}\ninline int _I(int b) {\n  int a = MOD, x1 = 0, x2 = 1, q;\n  while (1) {\n    q = a / b, a %= b;\n    if (!a) return x2;\n    DEC(x1, pdt(q, x2));\n    q = b / a, b %= a;\n    if (!b) return x1;\n    DEC(x2, pdt(q, x1));\n  }\n}\ninline void DIV(int &a, int b) { MUL(a, _I(b)); }\ninline int qtt(int a, int b) { return pdt(a, _I(b)); }\nstruct Int {\n  int val;\n  operator int() const { return val; }\n  Int(int _val = 0) : val(_val) {\n    val %= MOD;\n    if (val < 0) val += MOD;\n  }\n  Int(long long _val) : val(_val) {\n    _val %= MOD;\n    if (_val < 0) _val += MOD;\n    val = _val;\n  }\n  Int &operator+=(const int &rhs) {\n    INC(val, rhs);\n    return *this;\n  }\n  Int operator+(const int &rhs) const { return sum(val, rhs); }\n  Int &operator-=(const int &rhs) {\n    DEC(val, rhs);\n    return *this;\n  }\n  Int operator-(const int &rhs) const { return dff(val, rhs); }\n  Int &operator*=(const int &rhs) {\n    MUL(val, rhs);\n    return *this;\n  }\n  Int operator*(const int &rhs) const { return pdt(val, rhs); }\n  Int &operator/=(const int &rhs) {\n    DIV(val, rhs);\n    return *this;\n  }\n  Int operator/(const int &rhs) const { return qtt(val, rhs); }\n  Int operator-() const { return MOD - *this; }\n};\n}  // namespace NT\nusing namespace NT;\ntemplate <class T>\ninline T &RD(T &x) {\n  char c;\n  while (!isdigit((c = getchar())))\n    ;\n  x = c - '0';\n  while (isdigit((c = getchar()))) x = x * 10 + c - '0';\n  return x;\n}\ntemplate <class T>\ninline T &RDD(T &x) {\n  char c;\n  while ((c = getchar()), c != '-' && !isdigit(c))\n    ;\n  if (c == '-') {\n    x = '0' - (c = getchar());\n    while (isdigit((c = getchar()))) x = x * 10 + '0' - c;\n  } else {\n    x = c - '0';\n    while (isdigit((c = getchar()))) x = x * 10 + c - '0';\n  }\n  return x;\n}\ninline double &RF(double &x) {\n  char c;\n  while ((c = getchar()), c != '-' && c != '.' && !isdigit(c))\n    ;\n  if (c == '-')\n    if ((c = getchar()) == '.') {\n      x = 0;\n      double l = 1;\n      while (isdigit((c = getchar()))) l /= 10, x = x * 10 + '0' - c;\n      x *= l;\n    } else {\n      x = '0' - c;\n      while (isdigit((c = getchar()))) x = x * 10 + '0' - c;\n      if (c == '.') {\n        double l = 1;\n        while (isdigit((c = getchar()))) l /= 10, x = x * 10 + '0' - c;\n        x *= l;\n      }\n    }\n  else if (c == '.') {\n    x = 0;\n    double l = 1;\n    while (isdigit((c = getchar()))) l /= 10, x = x * 10 + c - '0';\n    x *= l;\n  } else {\n    x = c - '0';\n    while (isdigit((c = getchar()))) x = x * 10 + c - '0';\n    if (c == '.') {\n      double l = 1;\n      while (isdigit((c = getchar()))) l /= 10, x = x * 10 + c - '0';\n      x *= l;\n    }\n  }\n  return x;\n}\ninline char *RS(char *s) {\n  scanf(\"%s\", s);\n  return s;\n}\nlong long last_ans;\nint Case;\ntemplate <class T>\ninline void OT(const T &x) {\n  cout << x << endl;\n}\nconst int N = int(1e3) + 9;\nvector<int> adj[N];\nint n, m;\nint a[N], b[N];\nint fa[N];\nlong long p[N], p0;\nint Q[N], cz, op;\nvoid add_path(int u) {\n  while (~fa[u]) {\n    Q[op++] = u;\n    p0 += b[u];\n    int v = fa[u];\n    fa[u] = -1;\n    u = v;\n  }\n}\nbool find_circle() {\n  for (int i = 0; i < n; ++i) fa[i] = -1, p[i] = 0;\n  for (int i = 0; i < op; ++i) p[Q[i]] = p0;\n  cz = 0;\n  int op = ::op;\n  while (cz < op) {\n    int u = Q[cz++];\n    for (auto v : adj[u])\n      if (v != fa[u] && p[u] > a[v]) {\n        if (~fa[v] || p[v] == p0 && p[u] != p0) {\n          add_path(u);\n          add_path(v);\n          return 1;\n        }\n        if (p[v] == p0) continue;\n        p[v] = p[u] + b[v];\n        fa[v] = u;\n        Q[op++] = v;\n      }\n  }\n  return 0;\n}\nbool ok(int _p0) {\n  op = 0;\n  Q[op++] = 0;\n  p0 = _p0;\n  while (find_circle())\n    ;\n  return op == n;\n}\nint main() {\n  for (int ____T = RD(); ____T--;) {\n    RD(n, m);\n    for (int i = 1; i < n; ++i) RD(a[i]);\n    for (int i = 1; i < n; ++i) RD(b[i]);\n    for (int i = 0; i < n; ++i) adj[i].clear();\n    for (int ____n = m; ____n-- > 0;) {\n      int x, y;\n      RD(x, y);\n      --x;\n      --y;\n      adj[x].push_back(y);\n      adj[y].push_back(x);\n    }\n    int l = 2, r = int(1e9) + 1;\n    while (l < r) {\n      int m = (l + r) / 2;\n      if (ok(m))\n        r = m;\n      else\n        l = m + 1;\n    }\n    cout << l << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint a[1010], b[1010];\nvector<int> from[1010];\nint vis[1010];\nvector<int> path[1010];\nvector<int> cur, ans;\nint dfs(int x, int last, long long mid) {\n  if (mid <= a[x]) return 0;\n  if (path[x].size()) {\n    ans = cur;\n    for (int i = path[x].size() - 1; i >= 0; i--) {\n      ans.push_back(path[x][i]);\n    }\n    return 1;\n  }\n  mid += b[x];\n  cur.push_back(x);\n  path[x] = cur;\n  vis[x] = 1;\n  for (auto v : from[x])\n    if (v != last) {\n      if (vis[v]) {\n        ans = cur;\n        cur.pop_back();\n        vis[x] = 0;\n        return 1;\n      }\n      if (dfs(v, x, mid)) {\n        cur.pop_back();\n        vis[x] = 0;\n        return 1;\n      }\n    }\n  vis[x] = 0;\n  cur.pop_back();\n  return 0;\n}\nint Check(long long mid) {\n  for (int i = 1; i <= n; i++) {\n    vis[i] = 0;\n  }\n  vis[1] = 1;\n  int tot = 1;\n  while (tot < n) {\n    ans.clear();\n    for (int i = 1; i <= n; i++) {\n      path[i].clear();\n    }\n    for (int x = 1; x <= n; x++) {\n      if (!vis[x]) continue;\n      cur.push_back(x);\n      for (auto v : from[x]) {\n        if (!vis[v]) {\n          if (dfs(v, x, mid)) {\n            cur.pop_back();\n            goto END;\n          }\n        }\n      }\n      cur.pop_back();\n    }\n    return 0;\n  END:;\n    for (auto x : ans) {\n      if (!vis[x]) mid += b[x], tot++;\n      vis[x] = 1;\n    }\n  }\n  return 1;\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n      from[i].clear();\n    }\n    for (int i = 2; i <= n; i++) {\n      scanf(\"%d\", &a[i]);\n    }\n    for (int i = 2; i <= n; i++) {\n      scanf(\"%d\", &b[i]);\n    }\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      from[x].push_back(y);\n      from[y].push_back(x);\n    }\n    int l = 0, r = 1000000001;\n    while (l < r) {\n      int mid = l + r >> 1;\n      if (Check(mid))\n        r = mid;\n      else\n        l = mid + 1;\n    }\n    printf(\"%d\\n\", l);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T1, typename T2>\nvoid ckmin(T1 &a, T2 b) {\n  if (a > b) a = b;\n}\ntemplate <typename T1, typename T2>\nvoid ckmax(T1 &a, T2 b) {\n  if (a < b) a = b;\n}\nint read() {\n  int x = 0, f = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate <typename T>\nvoid print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <typename T>\nvoid print(T x, char let) {\n  print(x), putchar(let);\n}\nconst int N = 1005;\nvector<int> adj[N];\nint a[N], b[N], n, m;\nbool ok[N], vis[N];\nlong long cur;\nint chk() {\n  int cnt = 0;\n  for (int i = 1; i <= n; i++)\n    if (ok[i]) cnt++;\n  return cnt;\n}\nbool dfs(int u, int lst) {\n  if (vis[u] || ok[u]) return 1;\n  if (cur <= a[u]) return 0;\n  cur += b[u];\n  vis[u] = 1;\n  for (auto v : adj[u])\n    if (v != lst && dfs(v, u)) {\n      ok[u] = 1, vis[u] = 0;\n      return 1;\n    }\n  cur -= b[u];\n  vis[u] = 0;\n  return 0;\n}\nbool check(int mid) {\n  for (int i = 1; i <= n; i++) ok[i] = 0, vis[i] = 0;\n  ok[1] = 1;\n  cur = mid;\n  while (chk() != n) {\n    for (int i = 1; i <= n; i++) {\n      if (ok[i]) {\n        for (auto j : adj[i]) {\n          if (!ok[j] && dfs(j, i)) goto end;\n        }\n      }\n    }\n    return 0;\n  end:;\n  }\n  return 1;\n}\nvoid solve() {\n  n = read(), m = read();\n  for (int i = 2; i <= n; i++) a[i] = read();\n  for (int i = 2; i <= n; i++) b[i] = read();\n  for (int i = 1; i <= n; i++) adj[i].clear();\n  for (int i = 1; i <= m; i++) {\n    int u = read(), v = read();\n    adj[u].push_back(v), adj[v].push_back(u);\n  }\n  int l = 1, r = 1e9 + 5;\n  while (l < r) {\n    int mid = l + r >> 1;\n    if (check(mid))\n      r = mid;\n    else\n      l = mid + 1;\n  }\n  print(l, '\\n');\n}\nint main() {\n  int T = read();\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Inf = 0x3f3f3f3f;\nint N, M;\nint a[1005], b[1005];\nvector<int> nei[1005];\nbool lgl[1005];\nbool in[1005];\nlong long nhp;\nbool dfs(int now, int lst, long long hp) {\n  if (hp < a[now]) return 0;\n  lgl[now] = 1;\n  for (int i = 0; i < (((int)(nei[now]).size())); ++i) {\n    int to = nei[now][i];\n    if (to == lst) continue;\n    if (lgl[to] || in[to]) return nhp = hp + b[now], in[now] = 1, 1;\n    if (dfs(to, now, hp + b[now])) {\n      in[now] = 1;\n      return 1;\n    }\n  }\n  return 0;\n}\nbool check(long long hp) {\n  memset(in, 0, sizeof(in));\n  in[1] = 1;\n  while (1) {\n    memset(lgl, 0, sizeof(lgl));\n    bool fnd = 0;\n    for (int i = 1; i <= (N); ++i)\n      if (in[i]) {\n        for (int j = 0; j < (((int)(nei[i]).size())); ++j) {\n          int to = nei[i][j];\n          if (in[to]) continue;\n          if (dfs(to, i, hp)) {\n            fnd = 1;\n            hp = nhp;\n            goto Brk;\n          }\n        }\n      }\n  Brk:\n    if (!fnd) break;\n  }\n  for (int i = 1; i <= (N); ++i)\n    if (!in[i]) return 0;\n  return 1;\n}\nvoid solve() {\n  scanf(\"%d%d\", &N, &M);\n  for (int i = 1; i <= (N); ++i) nei[i].clear();\n  for (int i = 1; i <= (N - 1); ++i) scanf(\"%d\", a + i + 1), ++a[i + 1];\n  for (int i = 1; i <= (N - 1); ++i) scanf(\"%d\", b + i + 1);\n  for (int i = 0; i < (M); ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    nei[u].push_back(v);\n    nei[v].push_back(u);\n  }\n  int L = -1, R = 1e9 + 1;\n  while (R - L > 1) {\n    int m = (L + R) >> 1;\n    if (check(m))\n      R = m;\n    else\n      L = m;\n  }\n  printf(\"%d\\n\", R);\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nbool chkmax(T &x, T y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <typename T>\nbool chkmin(T &x, T y) {\n  return x > y ? x = y, true : false;\n}\nint readint() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint n, m, tot, cnt;\nlong long now;\nint v[4005], nxt[4005], h[2005], a[2005], b[2005], fr[2005];\nbool vis[2005];\nvoid addedge(int x, int y) {\n  v[++tot] = y;\n  nxt[tot] = h[x];\n  h[x] = tot;\n  v[++tot] = x;\n  nxt[tot] = h[y];\n  h[y] = tot;\n}\nvoid add(int u) {\n  while (!vis[u]) vis[u] = 1, now += b[u], cnt++, u = fr[u];\n}\nbool dfs(int u, int fa, long long val) {\n  for (int p = h[u]; p; p = nxt[p]) {\n    if (v[p] == fa) continue;\n    if (val <= a[v[p]]) continue;\n    if (!vis[u] && vis[v[p]]) {\n      add(u);\n      return true;\n    }\n    if (vis[v[p]]) continue;\n    if (fr[v[p]]) {\n      add(v[p]), add(u);\n      return true;\n    }\n    fr[v[p]] = u;\n    if (dfs(v[p], u, val + b[v[p]])) return true;\n  }\n  return false;\n}\nint main() {\n  int T = readint();\n  while (T--) {\n    n = readint();\n    m = readint();\n    for (int i = 2; i <= n; i++) a[i] = readint();\n    for (int i = 2; i <= n; i++) b[i] = readint();\n    for (int i = 1; i <= n; i++) h[i] = 0;\n    tot = 0;\n    for (int i = 1; i <= m; i++) addedge(readint(), readint());\n    long long l = 1, r = 1000000000 + 1, res = 0;\n    while (l <= r) {\n      long long mid = (l + r) / 2;\n      for (int i = 1; i <= n; i++) vis[i] = 0;\n      vis[1] = 1;\n      cnt = 1, now = mid;\n      bool can = 1;\n      while (cnt < n) {\n        for (int i = 1; i <= n; i++) fr[i] = 0;\n        bool fl = 0;\n        for (int i = 1; i <= n; i++) {\n          if (vis[i]) {\n            if (dfs(i, -1, now)) {\n              fl = 1;\n              break;\n            }\n          }\n        }\n        if (!fl && cnt < n) {\n          can = 0;\n          break;\n        }\n      }\n      if (can)\n        res = mid, r = mid - 1;\n      else\n        l = mid + 1;\n    }\n    printf(\"%lld\\n\", res);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1005;\nint T, n, m, a[N], b[N], fa[N], cnt;\nvector<int> e[N];\nlong long sum;\nbool vis[N];\nvoid add_(int u) {\n  for (; !vis[u]; u = fa[u]) vis[u] = 1, cnt++, sum += b[u];\n}\nbool dfs_(int u, long long sum) {\n  for (int v : e[u])\n    if (v != fa[u] && a[v] < sum) {\n      if (!vis[u] && vis[v]) {\n        add_(u);\n        return 1;\n      }\n      if (vis[v]) continue;\n      if (fa[v]) {\n        add_(v), add_(u);\n        return 1;\n      }\n      fa[v] = u;\n      if (dfs_(v, sum + b[v])) return 1;\n    }\n  return 0;\n}\nbool solve_() {\n  for (int i = 1; i <= n; i++) vis[i] = fa[i] = 0;\n  vis[1] = 1, cnt = 1;\n  while (cnt < n) {\n    int c = cnt;\n    for (int i = 1; i <= n; i++) fa[i] = 0;\n    for (int i = 1; i <= n; i++)\n      if (vis[i]) {\n        fa[i] = 0;\n        if (dfs_(i, sum)) break;\n      }\n    if (c == cnt) return 0;\n  }\n  return 1;\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 2; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 2; i <= n; i++) scanf(\"%d\", &b[i]);\n    for (int i = 1; i <= n; i++) e[i].clear();\n    for (int u, v, i = 1; i <= m; i++) {\n      scanf(\"%d%d\", &u, &v);\n      e[u].push_back(v);\n      e[v].push_back(u);\n    }\n    int l = 1, r = 1e9 + 1;\n    while (l < r) {\n      int mid = (l + r) >> 1;\n      sum = mid;\n      if (solve_())\n        r = mid;\n      else\n        l = mid + 1;\n    }\n    printf(\"%d\\n\", l);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \" \";\n  return os;\n}\nconst int mxN = 1e3 + 1, oo = 1e9;\nvector<int> adj[mxN];\nbitset<mxN> need;\nint n, a[mxN], b[mxN];\nint par[mxN];\nlong long gp;\nbool dfs(int at, long long p, bool good = false) {\n  for (int to : adj[at])\n    if (to != par[at]) {\n      if (a[to] >= p) break;\n      if (par[to] == -1) {\n        par[to] = at;\n        int extra = need[to] ? b[to] : 0;\n        if (dfs(to, p + extra, good or need[to])) {\n          if (need[to]) gp += b[to], need[to] = false;\n          return true;\n        }\n      } else {\n        if (good or need[to]) {\n          while (need[to]) {\n            gp += b[to];\n            need[to] = false;\n            to = par[at];\n          }\n          return true;\n        }\n      }\n    }\n  return false;\n}\nbool good(long long p) {\n  gp = p;\n  need.reset();\n  for (int i = 1; i < n; ++i) need[i] = true;\n  while (need.any()) {\n    fill(par, par + n, -1);\n    par[0] = 0;\n    if (!dfs(0, gp)) {\n      break;\n    }\n  }\n  return need.none();\n}\nvoid solve() {\n  int m;\n  cin >> n >> m;\n  for (int i = 1; i < n; ++i) cin >> a[i];\n  for (int i = 1; i < n; ++i) cin >> b[i];\n  for (int i = 0; i < n; ++i) {\n    adj[i].clear();\n  }\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v, --u, --v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  for (int i = 0; i < n; ++i)\n    sort(begin(adj[i]), end(adj[i]), [&](int c, int d) { return a[c] < a[d]; });\n  int lo = 1, hi = 1e9 + 3;\n  while (lo < hi) {\n    int mid = (lo + hi) / 2;\n    if (good(mid))\n      hi = mid;\n    else\n      lo = mid + 1;\n  }\n  cout << lo << '\\n';\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Edge {\n  int to, nxt;\n} e[5001];\nint head[1001], ecnt = 0;\ninline void addedge(int from, int to) {\n  e[ecnt].to = to;\n  e[ecnt].nxt = head[from];\n  head[from] = ecnt++;\n}\nint a[1001], b[1001];\nint vis[1001], pre[1001];\nbool pre0[1001];\nset<int> inv;\nvoid dfs(int u, int fa, long long now, bool p0) {\n  if (now < a[u]) return;\n  if (vis[u] == 0) now += b[u];\n  p0 |= (vis[u] == 0);\n  for (int i = head[u]; i != -1; i = e[i].nxt) {\n    int v = e[i].to;\n    if (v == fa || now <= a[v]) continue;\n    if (vis[v] == 2) {\n      if (p0) {\n        int uu = u;\n        while (vis[uu] != 2) {\n          if (vis[uu] == 0) inv.insert(uu);\n          uu = pre[uu];\n        }\n      }\n      continue;\n    } else if (vis[v] == 1) {\n      if (pre[v]) {\n        if (p0 || pre0[v]) {\n          int uu = u, vv = v;\n          while (vis[uu] != 2) {\n            if (vis[uu] == 0) inv.insert(uu);\n            uu = pre[uu];\n          }\n          while (vis[vv] != 2) {\n            if (vis[vv] == 0) inv.insert(vv);\n            vv = pre[vv];\n          }\n        }\n        continue;\n      }\n      pre[v] = u;\n      pre0[v] = pre0[u];\n      dfs(v, u, now, p0);\n      if (inv.size()) return;\n    } else {\n      if (pre[v]) {\n        int uu = u, vv = v;\n        while (vis[uu] != 2) {\n          if (vis[uu] == 0) inv.insert(uu);\n          uu = pre[uu];\n        }\n        while (vis[vv] != 2) {\n          if (vis[vv] == 0) inv.insert(vv);\n          vv = pre[vv];\n        }\n        return;\n      } else {\n        pre[v] = u;\n        pre0[v] = true;\n        dfs(v, u, now, p0);\n        if (inv.size()) return;\n      }\n    }\n  }\n}\ninline bool check(int n, long long power) {\n  set<int> now;\n  now.insert(1);\n  int tot = 1;\n  memset(vis, 0, sizeof(vis));\n  while (tot < n) {\n    memset(pre, 0, sizeof(pre));\n    memset(pre0, false, sizeof(pre0));\n    for (auto x : now) vis[x] = 2, pre[x] = x;\n    inv.clear();\n    for (auto x : now) {\n      dfs(x, x, power, false);\n      if (inv.size()) {\n        for (auto x : inv) power += b[x];\n        for (auto x : now) vis[x] = 1;\n        now = inv;\n        tot += inv.size();\n        break;\n      }\n    }\n    if (!inv.size()) return false;\n  }\n  return true;\n}\nint main() {\n  int testcase;\n  scanf(\"%d\", &testcase);\n  while (testcase--) {\n    memset(head, -1, sizeof(head));\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 2; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 2; i <= n; i++) scanf(\"%d\", &b[i]);\n    a[1] = b[1] = 0;\n    while (m--) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      addedge(u, v);\n      addedge(v, u);\n    }\n    int L = 1, R = 1000000001;\n    while (L < R) {\n      int mid = (L + R) >> 1;\n      if (check(n, mid))\n        R = mid;\n      else\n        L = mid + 1;\n    }\n    printf(\"%d\\n\", L);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint a[1024], b[1024];\nstd::vector<int> node[1024];\nint que[1024];\nint nq;\nint par[1024];\nint stat[1024];\nlong long int val[1024], gval;\nvoid set_stat(int u) {\n  while (stat[u] == 1) stat[u] = 2, u = par[u];\n}\nint solve(int k) {\n  b[0] = k;\n  memset(stat, 0, sizeof(stat));\n  stat[0] = 2, que[0] = 0, nq = 1;\n  bool f = true;\n  while (f) {\n    gval = 0;\n    for (int i = 0; i < nq; ++i) {\n      int u = que[i];\n      if (stat[u] == 1)\n        val[u] = val[par[u]] + b[u];\n      else\n        assert(stat[u] == 2), val[u] = 0, gval += b[u];\n    }\n    f = false;\n    for (int i = 0; i < nq; ++i) {\n      int u = que[i];\n      for (const int &v : node[u])\n        if (v != par[u]) {\n          if (stat[v] == 0 && gval + val[u] > a[v])\n            stat[v] = 1, par[v] = u, que[nq++] = v, val[v] = val[u] + b[v],\n            f = true;\n          else if ((stat[v] == 1 || stat[u] == 1) && par[v] != u &&\n                   gval + val[u] > a[v])\n            set_stat(u), set_stat(v), f = true;\n        }\n    }\n  }\n  return nq;\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  for (int tc = 1; tc <= T; ++tc) {\n    for (int i = 0; i < 1024; ++i) node[i].clear();\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i < n; ++i) scanf(\"%d\", &a[i]);\n    for (int i = 1; i < n; ++i) scanf(\"%d\", &b[i]);\n    for (int i = 0; i < m; ++i) {\n      int u, v;\n      scanf(\"%d%d\", &u, &v), --u, --v;\n      node[u].push_back(v);\n      node[v].push_back(u);\n    }\n    int ans = -1;\n    for (int i = 1 << 30; i; i >>= 1) {\n      int t = ans + i;\n      if (solve(t) != n) ans = t;\n    }\n    ++ans;\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[1010];\nint b[1010];\nbool mark[1010];\nint from[1010];\nint cnt = 0;\nvector<int> outgo[1010];\nbool extendFlag = false;\nint baseValue = 0;\nvoid update(int x) {\n  if (mark[x]) return;\n  baseValue += b[x];\n  if (baseValue > 1000000001) baseValue = 1000000001;\n  mark[x] = true;\n  cnt++;\n  update(from[x]);\n}\nvoid dfs(int now, int str) {\n  if (extendFlag) return;\n  if (str > 1000000001) str = 1000000001;\n  for (int i = 0; i < outgo[now].size(); i++) {\n    int to = outgo[now][i];\n    if (to == from[now]) continue;\n    if (mark[to] && mark[now]) continue;\n    if (from[to] == -1) {\n      if (mark[to]) {\n        update(now);\n        extendFlag = true;\n        return;\n      } else if (a[to] < str) {\n        from[to] = now;\n        dfs(to, str + b[to]);\n      }\n    } else {\n      if (mark[to]) {\n        extendFlag = true;\n        update(now);\n        return;\n      } else if (a[to] < str) {\n        update(to);\n        update(now);\n        extendFlag = true;\n        return;\n      }\n    }\n  }\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 2; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 2; i <= n; i++) scanf(\"%d\", &b[i]);\n    for (int i = 1; i <= n; i++) outgo[i].clear();\n    for (int i = 1; i <= m; i++) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      outgo[u].push_back(v);\n      outgo[v].push_back(u);\n    }\n    int l = 1, r = 1000000001;\n    int ans = 1000000001;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      baseValue = mid;\n      for (int i = 2; i <= n; i++) mark[i] = false;\n      mark[1] = true;\n      cnt = 1;\n      while (true) {\n        for (int i = 1; i <= n; i++) from[i] = -1;\n        extendFlag = false;\n        for (int i = 1; i <= n; i++)\n          if (mark[i]) {\n            from[i] = 0;\n            dfs(i, baseValue);\n            if (extendFlag) break;\n          }\n        if (!extendFlag) break;\n      }\n      if (cnt == n) {\n        ans = mid;\n        r = mid - 1;\n      } else\n        l = mid + 1;\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline T read() {\n  T s = 0, w = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') w = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    s = s * 10 + (c ^ 48);\n    c = getchar();\n  }\n  return s * w;\n}\ntemplate <class T>\ninline bool chkmax(T& x, const T& y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <class T>\ninline bool chkmin(T& x, const T& y) {\n  return x > y ? x = y, true : false;\n}\nconst long long maxn = 303030;\nconst long long maxm = 404040;\nvector<long long> G[maxn];\nlong long a[maxn], b[maxn];\nlong long l, r;\nlong long n, m;\nlong long vis[maxn], pre[maxn];\nlong long check(long long mid) {\n  long long power = mid;\n  for (long long i = 1; i <= n; i++) vis[i] = 0;\n  vector<long long> st;\n  st.push_back(1);\n  vis[1] = 1;\n  while (st.size() != n) {\n    queue<pair<long long, long long> > q;\n    for (long long v : st) q.push(make_pair(-v, power));\n    for (long long i = 1; i <= n; i++) pre[i] = 0;\n    long long s = 0, t = 0;\n    while (!q.empty()) {\n      pair<long long, long long> u = q.front();\n      q.pop();\n      long long flag = u.first > 0;\n      u.first = abs(u.first);\n      long long x = u.first;\n      for (long long v : G[u.first]) {\n        if (pre[x] == v || a[v] >= u.second) continue;\n        if (pre[v] || (vis[v] && flag)) {\n          s = x, t = v;\n          break;\n        }\n        if (vis[v]) continue;\n        pre[v] = x;\n        q.push(make_pair(v, u.second + b[v]));\n      }\n      if (s && t) break;\n    }\n    if (!s && !t) break;\n    do {\n      if (!vis[s]) {\n        st.push_back(s);\n        vis[s] = 1;\n        power += b[s];\n      }\n    } while (s = pre[s]);\n    do {\n      if (!vis[t]) {\n        st.push_back(t);\n        vis[t] = 1;\n        power += b[t];\n      }\n    } while (t = pre[t]);\n  }\n  if (st.size() == n)\n    return 1;\n  else\n    return 0;\n}\nsigned main() {\n  long long T = read<long long>();\n  while (T--) {\n    l = 1, r = 0;\n    n = read<long long>(), m = read<long long>();\n    for (long long i = 1; i <= n; i++) G[i].clear();\n    for (long long i = 2; i <= n; i++)\n      a[i] = read<long long>(), chkmax(r, a[i]);\n    for (long long i = 2; i <= n; i++) b[i] = read<long long>();\n    r = r + 1;\n    for (long long i = 1; i <= m; i++) {\n      long long x = read<long long>(), y = read<long long>();\n      G[x].push_back(y);\n      G[y].push_back(x);\n    }\n    long long ans = 0;\n    while (l <= r) {\n      long long mid = (l + r) / 2;\n      if (check(mid)) {\n        ans = mid;\n        r = mid - 1;\n      } else\n        l = mid + 1;\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M;\nint p[1010];\nlong long X[1010];\nint A[1010];\nlong long B[1010];\nint U[2020];\nint V[2020];\nint up[1010];\nbool chk[2020];\nbool vst[1010];\nbool chkv[1010];\nlong long mn[2020];\nvector<int> adj[1010];\npriority_queue<pair<long long, int>, vector<pair<long long, int> >,\n               greater<pair<long long, int> > >\n    pq;\nint par(int x) {\n  if (x == p[x]) return x;\n  return p[x] = par(p[x]);\n}\nvoid unite(int a, int b) {\n  a = par(a);\n  b = par(b);\n  p[a] = b;\n}\nvoid add(int e) {\n  int a = U[e], b = V[e];\n  assert(vst[a] || vst[b]);\n  if (vst[b]) swap(a, b);\n  if (vst[b]) {\n    int t = par(b);\n    while (t > 1) {\n      B[1] += B[t];\n      p[t] = 1;\n      t = up[t];\n      t = par(t);\n    }\n    t = par(a);\n    while (t > 1) {\n      B[1] += B[t];\n      p[t] = 1;\n      t = up[t];\n      t = par(t);\n    }\n  } else {\n    int t = par(a);\n    vst[b] = true;\n    up[b] = t;\n  }\n  chk[e] = true;\n}\nvoid dfs(int v) {\n  X[v] += B[v];\n  for (int i : adj[v]) {\n    X[i] += X[v];\n    dfs(i);\n  }\n}\nvoid add_edges() {\n  for (int i = 1; i <= N; i++) {\n    adj[i].clear();\n    X[i] = 0;\n  }\n  for (int i = 2; i <= N; i++) {\n    if (p[i] != i || !vst[i]) continue;\n    adj[par(up[i])].push_back(i);\n  }\n  dfs(1);\n  for (int i = 1; i <= M; i++) {\n    if (chk[i]) continue;\n    int a = U[i], b = V[i];\n    a = par(a);\n    b = par(b);\n    if (a == b) {\n      chk[i] = true;\n      continue;\n    }\n    if (vst[a]) {\n      if (mn[i] > A[V[i]] - X[a] + 1) {\n        mn[i] = A[V[i]] - X[a] + 1;\n        pq.emplace(mn[i], i);\n      }\n    }\n    if (vst[b]) {\n      if (mn[i] > A[U[i]] - X[b] + 1) {\n        mn[i] = A[U[i]] - X[b] + 1;\n        pq.emplace(mn[i], i);\n      }\n    }\n  }\n}\nint main() {\n  int tc;\n  scanf(\"%d\", &tc);\n  while (tc--) {\n    scanf(\"%d%d\", &N, &M);\n    int mxv = 0;\n    for (int i = 2; i <= N; i++) {\n      scanf(\"%d\", &A[i]);\n      if (A[mxv] < A[i]) mxv = i;\n    }\n    B[1] = 0;\n    for (int i = 2; i <= N; i++) scanf(\"%lld\", &B[i]);\n    for (int i = 1; i <= M; i++) scanf(\"%d%d\", &U[i], &V[i]);\n    while (pq.size()) pq.pop();\n    for (int i = 1; i <= N; i++) p[i] = i;\n    for (int i = 1; i <= N; i++) {\n      chkv[i] = vst[i] = false;\n      X[i] = up[i] = 0;\n    }\n    for (int i = 1; i <= M; i++) chk[i] = false;\n    vst[1] = true;\n    long long ans = 0;\n    for (int i = 1; i <= M; i++) mn[i] = 1LL << 60;\n    add_edges();\n    while (pq.size()) {\n      if (vst[mxv]) break;\n      pair<long long, int> t = pq.top();\n      pq.pop();\n      if (t.first > mn[t.second] || chk[t.second]) continue;\n      if (par(U[t.second]) == par(V[t.second])) {\n        chk[t.second] = true;\n        continue;\n      }\n      ans = max(ans, t.first);\n      add(t.second);\n      add_edges();\n    }\n    assert(vst[mxv]);\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e3;\nvector<int> G[N], rct;\nint n, m, a[N + 10], b[N + 10];\nbool used[N + 10];\nint pre[N + 10], l, r;\npair<int, long long> qu[N + 10];\nbool chk(int init) {\n  long long p = init;\n  for (int i = 1; i <= n; i++) used[i] = 0;\n  used[1] = 1, rct.clear(), rct.push_back(1);\n  while ((int)rct.size() != n) {\n    l = 1, r = 0;\n    int s = 0, t = 0;\n    for (auto i : rct) qu[++r] = make_pair(-i, p);\n    for (int i = 1; i <= n; i++) pre[i] = 0;\n    while (l <= r) {\n      int u = qu[l].first;\n      bool f = (u > 0);\n      u = abs(u);\n      long long np = qu[l++].second;\n      for (auto v : G[u]) {\n        if (pre[u] == v || a[v] >= np) continue;\n        if (pre[v] || (used[v] && f)) {\n          s = u, t = v;\n          break;\n        }\n        if (used[v]) continue;\n        pre[v] = u;\n        qu[++r] = make_pair(v, np + b[v]);\n      }\n      if (s && t) break;\n    }\n    if (s == 0 && t == 0) break;\n    do {\n      if (!used[s]) {\n        used[s] = 1;\n        rct.push_back(s);\n        p += b[s];\n      }\n    } while (s = pre[s]);\n    do {\n      if (!used[t]) {\n        used[t] = 1;\n        rct.push_back(t);\n        p += b[t];\n      }\n    } while (t = pre[t]);\n  }\n  if ((int)rct.size() != n) return 0;\n  return 1;\n}\nvoid solve() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &b[i]);\n  for (int i = 1; i <= n; i++) G[i].clear();\n  for (int i = 1, x, y; i <= m; i++) {\n    scanf(\"%d %d\", &x, &y);\n    G[x].push_back(y), G[y].push_back(x);\n  }\n  int L = 0, R = 1e9 + 1;\n  while (L <= R) {\n    int mid = (L + R) >> 1;\n    if (chk(mid))\n      R = mid - 1;\n    else\n      L = mid + 1;\n  }\n  printf(\"%d\\n\", R + 1);\n}\nint main() {\n  int TAT;\n  scanf(\"%d\", &TAT);\n  while (TAT--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long T, n, m, ans, sumb, a[2005], b[2005], tu[4005], tv[4005];\nlong long vis[2005], mer[2005], lis[8005], pre[2005], las[2005], lisc = 0;\nlong long ec, hed[2005], nxt[8005], to[8005];\nvoid add_edge(long long f, long long t) {\n  ++ec;\n  to[ec] = t;\n  nxt[ec] = hed[f];\n  hed[f] = ec;\n}\nstruct node {\n  long long x, v;\n} t;\nqueue<node> q;\nlong long bfs(long long x) {\n  for (long long i = 1; i <= n; i++) vis[i] = 0;\n  vis[1] = 1;\n  pre[1] = 1;\n  while (!q.empty()) q.pop();\n  t.x = 1;\n  t.v = x;\n  q.push(t);\n  while (!q.empty()) {\n    long long u, v, now;\n    node h = q.front();\n    q.pop();\n    u = h.x;\n    for (long long i = hed[u]; i; i = nxt[i]) {\n      v = to[i];\n      if (las[u] == (i ^ 1)) continue;\n      if (vis[v]) {\n        lisc = 0;\n        now = u;\n        while (1) {\n          if (now == 1) break;\n          lis[++lisc] = now;\n          now = pre[now];\n        }\n        now = v;\n        while (1) {\n          if (now == 1) break;\n          lis[++lisc] = now;\n          now = pre[now];\n        }\n        return 1;\n      }\n      if (a[v] < h.v) {\n        pre[v] = u;\n        las[v] = i;\n        vis[v] = 1;\n        t.x = v;\n        t.v = h.v + b[v];\n        q.push(t);\n      }\n    }\n  }\n  return 0;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> T;\n  while (T--) {\n    cin >> n >> m;\n    ans = 0;\n    sumb = 0;\n    a[1] = 0;\n    for (long long i = 2; i <= n; i++) cin >> a[i];\n    b[1] = 0;\n    for (long long i = 2; i <= n; i++) cin >> b[i];\n    for (long long i = 1; i <= n; i++) mer[i] = 0;\n    for (long long i = 1; i <= m; i++) cin >> tu[i] >> tv[i];\n    mer[1] = 1;\n    for (long long l, r, mid, tmp, cnt = n, i = 1; i <= n; i++) {\n      for (long long j = 1; j <= n; j++) hed[j] = 0;\n      ec = 1;\n      for (long long u, v, j = 1; j <= m; j++) {\n        u = tu[j];\n        v = tv[j];\n        if (mer[u]) u = 1;\n        if (mer[v]) v = 1;\n        if (u != v) {\n          add_edge(u, v);\n          add_edge(v, u);\n        }\n      }\n      l = ans;\n      tmp = r = 1000000001;\n      while (l <= r) {\n        mid = (l + r) >> 1;\n        if (bfs(mid + sumb)) {\n          tmp = mid;\n          r = mid - 1;\n        } else\n          l = mid + 1;\n      }\n      for (long long j = 1; j <= lisc; j++) {\n        if (!mer[lis[j]]) cnt--, sumb += b[lis[j]];\n        mer[lis[j]] = 1;\n      }\n      ans = tmp;\n      if (cnt == 1) break;\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1005;\nvoid work(int u);\nbool dfs(int u, long long now);\nint a[N], b[N];\nstd::vector<int> G[N];\nint fa[N];\nbool vis[N];\nlong long now;\nint cnt;\nint n, m;\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 2; i <= n; ++i) scanf(\"%d\", a + i);\n    for (int i = 2; i <= n; ++i) scanf(\"%d\", b + i);\n    for (int i = 1; i <= n; ++i) G[i].clear();\n    for (int i = 1; i <= m; ++i) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      G[u].push_back(v), G[v].push_back(u);\n    }\n    vis[1] = true;\n    int L = 0, R = 1e9 + 1;\n    int ans = 0;\n    while (L <= R) {\n      int mid = (L + R) >> 1;\n      for (int i = 2; i <= n; ++i) vis[i] = false;\n      now = mid;\n      cnt = 1;\n      while (cnt < n) {\n        for (int i = 1; i <= n; ++i) fa[i] = 0;\n        bool flag = false;\n        for (int i = 1; i <= n; ++i) {\n          if (vis[i] && dfs(i, now)) {\n            flag = true;\n            break;\n          }\n        }\n        if (!flag) break;\n      }\n      if (cnt == n) {\n        ans = mid;\n        R = mid - 1;\n      } else {\n        L = mid + 1;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\nvoid work(int u) {\n  while (!vis[u]) {\n    vis[u] = true;\n    now += b[u];\n    ++cnt;\n    u = fa[u];\n  }\n}\nbool dfs(int u, long long now) {\n  for (int v : G[u]) {\n    if (v == fa[u] || now <= a[v]) continue;\n    if (!vis[u] && vis[v]) {\n      work(u);\n      return true;\n    }\n    if (vis[v]) continue;\n    if (fa[v]) {\n      work(v), work(u);\n      return true;\n    }\n    fa[v] = u;\n    if (dfs(v, now + b[v])) return true;\n  }\n  return false;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::bitset;\nusing std::pair;\nusing std::priority_queue;\nusing std::vector;\nconst int N = 1005;\nint T, n, m, a[N], b[N], lim, id[N][2];\nlong long dis[N][2], tot, tota;\nunsigned long long st[N][2][20];\npriority_queue<pair<long long, int> > q;\nvector<int> e[N], eid[N];\ninline void set(unsigned long long *s, int first) {\n  s[first >> 6] |= 1ull << (first & 63);\n}\ninline int test(unsigned long long *s, int first) {\n  return (s[first >> 6] >> (first & 63)) & 1;\n}\nvoid dij(int s, long long k) {\n  for (int i = 1; i <= n; ++i) {\n    dis[i][0] = dis[i][1] = 0;\n    id[i][0] = id[i][1] = 0;\n    std::fill(st[i][0], st[i][0] + lim + 1, 0);\n    std::fill(st[i][1], st[i][1] + lim + 1, 0);\n  }\n  dis[s][0] = k;\n  set(st[s][0], s);\n  q.push(std::make_pair(k, s << 1));\n  while (!q.empty()) {\n    auto tmp = q.top();\n    q.pop();\n    int u = tmp.second >> 1, t = tmp.second & 1;\n    if (dis[u][t] != tmp.first) continue;\n    for (int i = 0; i < e[u].size(); ++i)\n      if (eid[u][i] != id[u][t]) {\n        int v = e[u][i], first = eid[u][i];\n        if (!test(st[u][t], v) && a[v] >= dis[u][t]) continue;\n        if (dis[v][0] < dis[u][t] + (test(st[u][t], v) ? 0 : b[v])) {\n          if (id[v][0] != first) {\n            id[v][1] = id[v][0];\n            dis[v][1] = dis[v][0];\n            memcpy(st[v][1], st[v][0], sizeof(unsigned long long) * (lim + 1));\n          }\n          id[v][0] = first;\n          dis[v][0] = dis[u][t] + (test(st[u][t], v) ? 0 : b[v]);\n          memcpy(st[v][0], st[u][t], sizeof(unsigned long long) * (lim + 1));\n          set(st[v][0], v);\n          q.push(std::make_pair(dis[v][0], v << 1));\n        } else if (id[v][0] != first &&\n                   dis[v][1] < dis[u][t] + (test(st[u][t], v) ? 0 : b[v])) {\n          id[v][1] = first;\n          dis[v][1] = dis[u][t] + (test(st[u][t], v) ? 0 : b[v]);\n          memcpy(st[v][1], st[u][t], sizeof(unsigned long long) * (lim + 1));\n          set(st[v][1], v);\n          q.push(std::make_pair(dis[v][1], v << 1 | 1));\n        }\n      }\n  }\n}\nbool chk(long long k) {\n  dij(1, k);\n  for (int i = 1; i <= n; ++i)\n    if (dis[i][0] == tot + k) return 1;\n  return 0;\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    for (int i = 1; i <= n; ++i) e[i].clear(), eid[i].clear();\n    scanf(\"%d%d\", &n, &m);\n    lim = (n + 63) >> 6;\n    tot = tota = 0;\n    for (int i = 2; i <= n; ++i) scanf(\"%d\", a + i), tota += a[i];\n    for (int i = 2; i <= n; ++i) scanf(\"%d\", b + i), tot += b[i];\n    for (int i = 1, first, second; i <= m; ++i) {\n      scanf(\"%d%d\", &first, &second);\n      e[first].push_back(second), e[second].push_back(first);\n      eid[first].push_back(i), eid[second].push_back(i);\n    }\n    long long l = 0, r = tota + 1;\n    while (l < r) {\n      long long mid = (l + r) >> 1;\n      if (chk(mid))\n        r = mid;\n      else\n        l = mid + 1;\n    }\n    printf(\"%lld\\n\", l);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint min(int a, int b) { return a < b ? a : b; }\nint max(int a, int b) { return a > b ? a : b; }\nint *ej[1000], eo[1000];\nvoid append(int i, int j) {\n  int o = eo[i]++;\n  if (o >= 2 && (o & o - 1) == 0)\n    ej[i] = (int *)realloc(ej[i], o * 2 * sizeof *ej[i]);\n  ej[i][o] = j;\n}\nint aa[1000], bb[1000];\nchar cloud[1000];\nint pp[1000];\nint dfs(int p, int i, int s) {\n  int o;\n  pp[i] = p;\n  for (o = eo[i]; o--;) {\n    int j = ej[i][o];\n    if (j != p && (!cloud[i] || !cloud[j]) && s > aa[j]) {\n      if (!cloud[j] && pp[j] == -1) {\n        if (dfs(i, j, min(s + bb[j], 0x3f3f3f3f))) return 1;\n      } else {\n        while (i != -1) cloud[i] = 1, i = pp[i];\n        while (j != -1) cloud[j] = 1, j = pp[j];\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\nint solve(int n, int s) {\n  memset(cloud, 0, n * sizeof *cloud), cloud[0] = 1;\n  while (1) {\n    int i, done, s_;\n    done = 1;\n    for (i = 0; i < n; i++)\n      if (cloud[i] == 0) {\n        done = 0;\n        break;\n      }\n    if (done) return 1;\n    s_ = s;\n    for (i = 0; i < n; i++)\n      if (cloud[i]) s_ = min(s_ + bb[i], 0x3f3f3f3f);\n    memset(pp, -1, n * sizeof *pp);\n    done = 1;\n    for (i = 0; i < n; i++)\n      if (cloud[i] && dfs(-1, i, s_)) {\n        done = 0;\n        break;\n      }\n    if (done) return 0;\n  }\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n, m, h, i, j, lower, upper;\n    scanf(\"%d%d\", &n, &m);\n    for (i = 1; i < n; i++) scanf(\"%d\", &aa[i]);\n    for (i = 1; i < n; i++) scanf(\"%d\", &bb[i]);\n    for (i = 0; i < n; i++) ej[i] = (int *)malloc(2 * sizeof *ej[i]), eo[i] = 0;\n    for (h = 0; h < m; h++) {\n      scanf(\"%d%d\", &i, &j), i--, j--;\n      append(i, j), append(j, i);\n    }\n    lower = -1, upper = 0x3f3f3f3f;\n    while (upper - lower > 1) {\n      int s = (lower + upper) / 2;\n      if (solve(n, s))\n        upper = s;\n      else\n        lower = s;\n    }\n    printf(\"%d\\n\", upper);\n    for (i = 0; i < n; i++) free(ej[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1e3 + 1;\nvector<int> g[MAXN];\nint n, m, a[MAXN], b[MAXN];\nbool vis[MAXN];\nlong long dis[MAXN];\nint pre[MAXN];\nbool check(int x) {\n  memset(vis, 0, sizeof(vis));\n  vis[1] = 1;\n  long long totb = 0;\n  while (true) {\n    for (int i = 1; i <= n; ++i) dis[i] = -1;\n    totb = 0;\n    bool ok = false;\n    for (int i = 1; i <= n; ++i)\n      if (vis[i]) totb += b[i];\n    for (int i = 1; i <= n; ++i) ok |= !vis[i];\n    if (!ok) break;\n    totb += x;\n    queue<int> q;\n    for (int i = 1; i <= n; ++i)\n      if (vis[i])\n        for (auto it : g[i]) {\n          if (!vis[it] && a[it] < totb && dis[it] == -1) {\n            q.push(it);\n            dis[it] = totb;\n            pre[it] = i;\n          }\n        }\n    ok = false;\n    while (!q.empty()) {\n      int now = q.front();\n      q.pop();\n      for (auto it : g[now])\n        if (it != pre[now]) {\n          if (vis[it]) {\n            ok = 1;\n            while (!vis[now]) {\n              vis[now] = 1;\n              now = pre[now];\n            }\n            break;\n          } else {\n            if (dis[now] + b[now] <= a[it]) {\n              continue;\n            }\n            if (dis[it] != -1) {\n              ok = 1;\n              while (!vis[now]) {\n                vis[now] = 1;\n                now = pre[now];\n              }\n              now = it;\n              while (!vis[now]) {\n                vis[now] = 1;\n                now = pre[now];\n              }\n              break;\n            } else {\n              pre[it] = now;\n              dis[it] = dis[now] + b[now];\n              q.push(it);\n            }\n          }\n        }\n      if (ok) break;\n    }\n    if (!ok) return false;\n  }\n  return true;\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 2; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 2; i <= n; ++i) scanf(\"%d\", &b[i]);\n  for (int i = 1; i <= n; ++i) g[i].clear();\n  for (int i = 1; i <= m; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  long long l = 0, r = 1e9 + 1;\n  while (l < r) {\n    int mid = (l + r) >> 1;\n    if (check(mid))\n      r = mid;\n    else\n      l = mid + 1;\n  }\n  printf(\"%d\\n\", l);\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int Maxn = 1000;\nconst int Inf = 0x3f3f3f3f;\nint n, m;\nint a[Maxn + 5], b[Maxn + 5];\nstd::vector<int> edge[Maxn + 5];\nint pre[Maxn + 5];\nlong long dis[Maxn + 5];\nbool vis[Maxn + 5];\nbool check(int x) {\n  for (int i = 1; i <= n; i++) {\n    vis[i] = 0;\n  }\n  vis[1] = 1;\n  long long now = x, tot = 1;\n  while (tot < n) {\n    std::queue<int> q;\n    for (int i = 1; i <= n; i++) {\n      pre[i] = 0;\n      dis[i] = 0;\n      if (vis[i]) {\n        q.push(i);\n        dis[i] = now;\n      }\n    }\n    int x = 0, y = 0;\n    while (!q.empty()) {\n      int u = q.front();\n      q.pop();\n      for (int i = 0; i < (int)edge[u].size(); i++) {\n        int v = edge[u][i];\n        if (!vis[v]) {\n          if (dis[u] <= a[v]) {\n            continue;\n          }\n          if (pre[v] == 0) {\n            pre[v] = u;\n            dis[v] = dis[u] + b[v];\n            q.push(v);\n          } else if (v != pre[u]) {\n            x = u, y = v;\n            goto OUT;\n          }\n        } else if (!vis[u] && v != pre[u]) {\n          x = u, y = v;\n          goto OUT;\n        }\n      }\n    }\n  OUT:;\n    if (x == 0) {\n      return 0;\n    }\n    for (int u = x; u; u = pre[u]) {\n      if (!vis[u]) {\n        vis[u] = 1;\n        now += b[u];\n        tot++;\n      }\n    }\n    for (int u = y; u; u = pre[u]) {\n      if (!vis[u]) {\n        vis[u] = 1;\n        now += b[u];\n        tot++;\n      }\n    }\n  }\n  return 1;\n}\nvoid solve() {\n  int left = Inf, right = 0;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 2; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    left = std::min(left, a[i]);\n    right = std::max(right, a[i]);\n  }\n  right++;\n  for (int i = 2; i <= n; i++) {\n    scanf(\"%d\", &b[i]);\n  }\n  for (int i = 1; i <= n; i++) {\n    edge[i].clear();\n  }\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    edge[u].push_back(v), edge[v].push_back(u);\n  }\n  while (left < right) {\n    int mid = (left + right) >> 1;\n    if (check(mid)) {\n      right = mid;\n    } else {\n      left = mid + 1;\n    }\n  }\n  printf(\"%d\\n\", left);\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1010;\nint T, n, m, a[maxn], b[maxn], vis[maxn], lst[maxn];\nlong long d[maxn];\nvector<int> G[maxn];\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n      G[i].clear();\n    }\n    for (int i = 2; i <= n; i++) {\n      scanf(\"%d\", &a[i]);\n    }\n    for (int i = 2; i <= n; i++) {\n      scanf(\"%d\", &b[i]);\n    }\n    while (m--) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      G[u].push_back(v), G[v].push_back(u);\n    }\n    auto bfs = [&](long long &x) {\n      queue<int> Q;\n      for (int i = 1; i <= n; i++) {\n        if (vis[i])\n          Q.push(i), d[i] = x;\n        else\n          d[i] = -1;\n      }\n      fill(lst + 1, lst + n + 1, 0);\n      while (!Q.empty()) {\n        int v = Q.front();\n        Q.pop();\n        for (int u : G[v])\n          if (a[u] < d[v] && !(vis[v] && vis[u]) && lst[v] ^ u) {\n            if (!~d[u]) {\n              Q.push(u), d[u] = d[v] + b[u], lst[u] = v;\n            } else {\n              for (int i = u; !vis[i]; i = lst[i]) x += b[i], vis[i] = 1;\n              for (int i = v; !vis[i]; i = lst[i]) x += b[i], vis[i] = 1;\n              return 1;\n            }\n          }\n      }\n      return 0;\n    };\n    auto chk = [&](long long x) {\n      fill(vis + 1, vis + n + 1, 0), vis[1] = 1;\n      while (bfs(x))\n        ;\n      return accumulate(vis + 1, vis + n + 1, 0) == n;\n    };\n    int l = 0, r = 1e9 + 1, ans;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      chk(mid) ? r = (ans = mid) - 1 : l = mid + 1;\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1005;\nint T, n, m, in[N], vis[N], a[N], b[N];\nvector<int> e[N];\nlong long cur;\nbool dfs(int k1, int k2) {\n  if (vis[k1] || in[k1]) return 1;\n  if (cur < a[k1]) return 0;\n  vis[k1] = 1;\n  cur += b[k1];\n  for (int x : e[k1])\n    if (x != k2 && dfs(x, k1)) {\n      vis[k1] = 0, in[k1] = 1;\n      return 1;\n    }\n  cur -= b[k1];\n  vis[k1] = 0;\n  return 0;\n}\nbool chk(int mid) {\n  for (int i = (1); i <= (n); ++i) in[i] = 0;\n  in[1] = 1, cur = mid;\n  while (1) {\n    for (int i = (1); i <= (n); ++i)\n      if (in[i]) {\n        for (auto x : e[i])\n          if (!in[x]) {\n            if (dfs(x, i)) {\n              goto qaq;\n            }\n          }\n      }\n    return 0;\n  qaq:;\n    if (count(in + 1, in + 1 + n, 1) == n) return 1;\n  }\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = (1); i <= (n); ++i) e[i].clear();\n    for (int i = (2); i <= (n); ++i) scanf(\"%d\", &a[i]);\n    for (int i = (2); i <= (n); ++i) scanf(\"%d\", &b[i]);\n    for (int i = (1); i <= (m); ++i) {\n      int k1, k2;\n      scanf(\"%d%d\", &k1, &k2);\n      e[k1].push_back(k2), e[k2].push_back(k1);\n    }\n    int l = 0, r = 1000000000, ans = 0;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if (chk(mid)) {\n        r = mid - 1;\n        ans = mid;\n      } else {\n        l = mid + 1;\n      }\n    }\n    printf(\"%d\\n\", ans + 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1009;\nint n, m, now;\nint in[M], p[M], a[M], b[M];\nlong long ma[M];\nvector<int> g[M];\nqueue<int> q;\nvoid add(long long& x) {\n  while (!q.empty()) q.pop();\n  for (int i = 1; i <= n; ++i) {\n    p[i] = ma[i] = 0;\n    if (in[i]) q.push(i);\n  }\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (auto v : g[u]) {\n      if (v != p[u] && x + ma[u] > a[v]) {\n        if (p[v] || (in[v] && !in[u])) {\n          while (u) {\n            if (!in[u]) now++, x += b[u];\n            in[u] = 1;\n            u = p[u];\n          }\n          while (v) {\n            if (!in[v]) now++, x += b[v];\n            in[v] = 1;\n            v = p[v];\n          }\n          return;\n        } else {\n          if (!p[v] && !in[v]) {\n            p[v] = u, ma[v] = ma[u] + b[v], q.push(v);\n          }\n        }\n      }\n    }\n  }\n}\nbool check(long long x) {\n  for (int i = 1; i <= n; ++i) in[i] = 0;\n  in[1] = now = 1;\n  while (1) {\n    int la = now;\n    add(x);\n    if (now == la) break;\n  }\n  return now == n;\n}\nvoid work() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) g[i].clear();\n  for (int i = 2; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 2; i <= n; ++i) scanf(\"%d\", &b[i]);\n  for (int i = 1, u, v; i <= m; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    g[u].emplace_back(v);\n    g[v].emplace_back(u);\n  }\n  int l = 0, r = 1e9;\n  while (l <= r) {\n    int mid = l + r >> 1;\n    if (check(mid))\n      r = mid - 1;\n    else\n      l = mid + 1;\n  }\n  printf(\"%d\\n\", l);\n}\nint main() {\n  int T;\n  for (scanf(\"%d\", &T); T; --T) work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4005, inf = 1e9;\nint n, m, a[N], b[N], lst[N];\nvector<int> g[N];\nlong long dis[N];\nbool rns[N];\nbool asdf(long long &w) {\n  queue<int> q;\n  for (int i = 1; i <= n; i++) {\n    if (rns[i])\n      q.push(i), dis[i] = w, lst[i] = -1;\n    else\n      dis[i] = -1, lst[i] = -1;\n  }\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (auto v : g[u])\n      if (a[v] < dis[u] && !(rns[u] && rns[v]) && lst[u] != v) {\n        if (dis[v] == -1)\n          dis[v] = dis[u] + b[v], lst[v] = u, q.push(v);\n        else {\n          for (int x = u; !rns[x]; x = lst[x]) w += b[x], rns[x] = true;\n          for (int x = v; !rns[x]; x = lst[x]) w += b[x], rns[x] = true;\n          return true;\n        }\n      }\n  }\n  return false;\n}\nbool check(long long x) {\n  for (int i = 1; i <= n; i++) rns[i] = i == 1;\n  while (asdf(x))\n    ;\n  for (int i = 1; i <= n; i++)\n    if (!rns[i]) return false;\n  return true;\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &b[i]);\n  for (int i = 1; i <= n; i++) g[i].clear();\n  for (int i = 1, u, v; i <= m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    g[u].push_back(v), g[v].push_back(u);\n  }\n  int l = 0, r = inf + 1;\n  while (l < r) {\n    int mid = (l + r) >> 1;\n    if (check(mid))\n      r = mid;\n    else\n      l = mid + 1;\n  }\n  printf(\"%d\\n\", l);\n}\nint main() {\n  int tt;\n  scanf(\"%d\", &tt);\n  while (tt--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\nstring to_string(const string &s) { return '\"' + s + '\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) res += static_cast<char>('0' + v[i]);\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) res += \", \";\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\nclass DSU {\n public:\n  DSU(int n, const vector<int> &a) : num_comp_(n), root_(n + 1, 0) {\n    ls_.resize(n + 1);\n    a_.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n      ls_[i].push_back(i);\n      a_[i] = a[i];\n    }\n  }\n  int num_comp() { return num_comp_; }\n  long long a(int u) { return a_[u]; }\n  vector<int> &ls(int u) { return ls_[u]; }\n  int GetRoot(int u) { return root_[u] ? root_[u] = GetRoot(root_[u]) : u; }\n  bool Unite(int u, int v) {\n    u = GetRoot(u);\n    v = GetRoot(v);\n    if (u == v) return 0;\n    a_[v] += a_[u];\n    if (ls_[v].size() < ls_[u].size()) {\n      swap(ls_[u], ls_[v]);\n    }\n    ls_[v].insert(ls_[v].end(), ls_[u].begin(), ls_[u].end());\n    ls_[u].clear();\n    root_[u] = v;\n    num_comp_--;\n    return 1;\n  }\n\n private:\n  int num_comp_;\n  vector<long long> a_;\n  vector<int> root_;\n  vector<vector<int>> ls_;\n};\nvoid Solve(int test) {\n  int n, m;\n  cin >> n >> m;\n  vector<int> a(n + 1, 0);\n  for (int i = 2; i <= n; i++) {\n    cin >> a[i];\n  }\n  vector<int> b(n + 1, 0);\n  for (int i = 2; i <= n; i++) {\n    cin >> b[i];\n  }\n  vector<vector<pair<int, int>>> adj(n + 1, vector<pair<int, int>>());\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back({v, i});\n    adj[v].push_back({u, i});\n  }\n  auto Check = [&](int init_value) -> bool {\n    b[1] = init_value;\n    DSU dsu(n, b);\n    while (dsu.num_comp() > 1) {\n      queue<int> q;\n      vector<int> d(n + 1, -1);\n      vector<int> last_edge(n + 1, -1);\n      vector<int> last_ver(n + 1, -1);\n      vector<long long> cur(n + 1, 0);\n      auto root = dsu.GetRoot(1);\n      cur[root] = dsu.a(root);\n      d[root] = 0;\n      q.push(root);\n      bool found_loop = false;\n      pair<int, int> loop;\n      while (!q.empty() && !found_loop) {\n        int u = q.front();\n        q.pop();\n        for (int node_u : dsu.ls(u)) {\n          for (auto [node_v, edge_id] : adj[node_u]) {\n            auto v = dsu.GetRoot(node_v);\n            if (u == v) continue;\n            if (last_edge[u] == edge_id) continue;\n            if (cur[u] <= a[node_v]) continue;\n            if (d[v] == -1) {\n              d[v] = d[u] + 1;\n              last_edge[v] = edge_id;\n              last_ver[v] = u;\n              cur[v] = cur[u] + dsu.a(v);\n              q.push(v);\n            } else {\n              found_loop = true;\n              loop = {u, v};\n              break;\n            }\n          }\n          if (found_loop) {\n            break;\n          }\n        }\n      }\n      if (!found_loop) {\n        break;\n      }\n      auto [u, v] = loop;\n      auto Go = [&](int u) {\n        while (u != -1) {\n          dsu.Unite(u, root);\n          u = last_ver[u];\n        }\n      };\n      Go(u);\n      Go(v);\n    }\n    return dsu.num_comp() == 1;\n  };\n  int low = 0, high = *max_element(a.begin(), a.end()) + 1;\n  while (high - low > 1) {\n    int mid = low + high >> 1;\n    if (Check(mid)) {\n      high = mid;\n    } else {\n      low = mid;\n    }\n  }\n  cout << high << '\\n';\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int tc;\n  cin >> tc;\n  for (int test = 1; test <= tc; ++test) Solve(test);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nvector<vector<int>> g;\nvector<long long> A, B, a, b;\nset<int> active;\nlong long gain = 0;\nbool dfs(int u, int pre, long long power) {\n  active.insert(u);\n  for (int v : g[u]) {\n    if (v == pre) continue;\n    if (power > a[v]) {\n      if (active.count(v) || dfs(v, u, power + b[v])) {\n        gain += b[v];\n        a[v] = b[v] = 0;\n        return true;\n      }\n    }\n  }\n  active.erase(u);\n  return false;\n}\nbool check(long long power) {\n  a = A;\n  b = B;\n  active.clear();\n  active.insert(0);\n  bool found = true;\n  while (found) {\n    found = false;\n    gain = 0;\n    set<int> old_active = active;\n    for (int u : old_active) {\n      for (int v : g[u]) {\n        if (!old_active.count(v)) {\n          if (power > a[v] && dfs(v, u, power + b[v])) {\n            power += gain + b[v];\n            a[v] = b[v] = 0;\n            found = true;\n          }\n        }\n        if (found) break;\n      }\n      if (found) break;\n    }\n  }\n  return ((int)(active).size()) == n;\n}\nvoid solve() {\n  cin >> n >> m;\n  g.clear();\n  g.resize(n);\n  A.assign(n, 0);\n  B.assign(n, 0);\n  for (int i = 1; i < n; ++i) cin >> A[i];\n  for (int i = 1; i < n; ++i) cin >> B[i];\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  long long lo = 0, hi = 1e9 + 1;\n  for (long long mid = (lo + hi) / 2; lo < hi; mid = (lo + hi) / 2) {\n    if (check(mid))\n      hi = mid;\n    else\n      lo = mid + 1;\n  }\n  cout << lo << \"\\n\";\n}\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  int t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2,fma,tune=native\")\ntemplate <typename T>\nvoid print(T&& x) {\n  cout << x << \"\\n\";\n}\ntemplate <typename T, typename... S>\nvoid print(T&& x, S&&... y) {\n  cout << x << ' ';\n  print(y...);\n}\nconst long long Mod = 1000000007, Mod2 = 998244353;\nconst long long MOD = Mod2;\nconst long long maxn = 1005;\nlong long n, m, a[maxn], b[maxn], c[maxn];\nvector<long long> adj[maxn];\nbool vis[maxn];\nvoid orzck() {\n  cin >> n >> m;\n  for (long long i = (0); i < ((long long)(n - 1)); i++) cin >> a[i + 1];\n  for (long long i = (0); i < ((long long)(n - 1)); i++) cin >> b[i + 1];\n  for (long long i = (0); i < ((long long)(n - 1)); i++) a[i + 1]++;\n  for (long long i = (0); i < ((long long)(n)); i++) adj[i].clear();\n  for (long long i = (0); i < ((long long)(m)); i++) {\n    long long u, v;\n    cin >> u >> v;\n    u--, v--;\n    adj[u].push_back(v), adj[v].push_back(u);\n  }\n  for (long long i = (0); i < ((long long)(n - 1)); i++) c[i + 1] = i + 1;\n  sort(c + 1, c + n, [](long long i, long long j) { return a[i] > a[j]; });\n  for (long long _ = (0); _ < ((long long)(n)); _++) {\n    for (long long i = (0); i < ((long long)(n - 1)); i++) {\n      long long u = c[i + 1];\n      long long cnt = 0;\n      for (auto v : adj[u])\n        if (a[v] <= a[u] + b[u]) cnt++;\n      if (cnt == 1) {\n        long long minn = 4000000000000000000;\n        for (auto v : adj[u])\n          if (a[v] > a[u] + b[u]) (minn = min(minn, a[v]));\n        a[u] = minn - b[u];\n      }\n      if (cnt == 0) {\n        long long minn = 4000000000000000000;\n        for (auto v : adj[u])\n          if (a[v] > a[u]) (minn = min(minn, a[v]));\n        a[u] = minn;\n      }\n    }\n  }\n  for (long long i = (0); i < ((long long)(n - 1)); i++) 826;\n  long long l = 0, r = 7777714490;\n  while (l < r) {\n    long long mid = l + r >> 1;\n    long long cur = mid;\n    memset(vis, 0, sizeof vis);\n    vis[0] = 1;\n    long long u = 0;\n    826;\n    for (long long _ = (0); _ < ((long long)(n)); _++) {\n      long long flag = 0;\n      for (auto v : adj[u])\n        if (vis[v]) flag++;\n      cur += b[u];\n      vis[u] = 1;\n      826;\n      if (flag >= 2) {\n        bool ok = 0;\n        for (long long i = (0); i < ((long long)(n)); i++)\n          if (cur >= a[i] && !vis[i]) {\n            bool flag2 = 0;\n            for (auto j : adj[i])\n              if (vis[j]) flag2 = 1;\n            if (flag2) {\n              u = i;\n              ok = 1;\n              break;\n            }\n          }\n        if (!ok) break;\n      } else {\n        bool ok = 0;\n        for (auto v : adj[u])\n          if (cur >= a[v] && !vis[v]) {\n            u = v;\n            ok = 1;\n            break;\n          }\n        if (!ok) break;\n      }\n    }\n    bool flag = 1;\n    for (long long i = (0); i < ((long long)(n)); i++)\n      if (!vis[i]) flag = 0;\n    if (flag)\n      r = mid;\n    else\n      l = mid + 1;\n  }\n  print(l);\n}\nsigned main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  cout << fixed << setprecision(15);\n  long long t;\n  cin >> t;\n  while (t--) orzck();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename U>\nusing pq = priority_queue<U>;\ntemplate <typename U>\nusing pqg = priority_queue<U, vector<U>, greater<U>>;\ntemplate <typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (auto& x : v) is >> x;\n  return is;\n}\ntemplate <typename T, typename U>\nbool umax(T& a, U b) {\n  return a < b ? a = b, 1 : 0;\n}\ntemplate <typename T, typename U>\nbool umin(T& a, U b) {\n  return a < b ? 0 : a = b, 1;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int INF = 1e9 + 5;\nconst long long LLINF = (long long)1e18 + 5;\nconst int MOD = 1e9 + 7;\nconst char nl = '\\n';\nint i4[4] = {1, 0, -1, 0};\nint j4[4] = {0, 1, 0, -1};\nint N, M;\nconst int mxN = 1005;\nint A[mxN], B[mxN];\nbool vis[mxN];\nvector<int> adj[mxN];\nlong long add = 0;\nbool go(int u, int p, long long power) {\n  if (power <= A[u]) return false;\n  vis[u] = 1;\n  for (int x : adj[u]) {\n    if (x == p) continue;\n    if (vis[x]) return true;\n    if (go(x, u, power + B[u])) {\n      add += B[x];\n      return true;\n    }\n  }\n  vis[u] = 0;\n  return false;\n}\nbool check(long long initial) {\n  for (int i = 1; i < N; i++) vis[i] = 0;\n  vis[0] = 1;\n  long long power = initial;\n  auto get = [&]() {\n    int ret = 0;\n    for (int i = 0; i < N; i++) ret += !vis[i];\n    return ret;\n  };\n  while (get()) {\n    add = 0;\n    bool ch = 0;\n    for (int i = 0; i < N && !ch; i++) {\n      if (!vis[i]) continue;\n      for (int x : adj[i]) {\n        if (!vis[x]) {\n          if (go(x, i, power)) {\n            ch = 1;\n            power += add + B[x];\n            break;\n          }\n        }\n      }\n    }\n    if (!ch) break;\n  }\n  return get() == 0;\n}\nvoid solve() {\n  cin >> N >> M;\n  for (int i = 0; i < N; i++) adj[i].clear();\n  for (int i = 1; i < N; i++) cin >> A[i];\n  for (int i = 1; i < N; i++) cin >> B[i];\n  for (int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b, --a, --b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  int lo = 1, hi = 1e9 + 5, best = -1;\n  while (lo <= hi) {\n    int m = (lo + hi) / 2;\n    if (check(m)) {\n      hi = m - 1;\n      best = m;\n    } else\n      lo = m + 1;\n  }\n  cout << best << nl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  clock_t myClock = clock();\n  int tt = 1;\n  cin >> tt;\n  for (int i = 1; i <= tt; i++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nlong long a[2222], b[2222];\nvector<int> G[2222];\nint fl[2222], pre[2222];\nlong long d[2222];\nbool bfs(long long &p) {\n  memset(d, -1, sizeof d);\n  queue<int> q;\n  for (int i = 1; i <= n; ++i)\n    if (fl[i]) q.push(i), d[i] = p, pre[i] = 0;\n  for (; q.size();) {\n    int x = q.front();\n    q.pop();\n    for (auto y : G[x]) {\n      if (y == pre[x]) continue;\n      if (d[x] > a[y] || fl[y]) {\n        if (d[y] == -1) {\n          d[y] = d[x] + b[y];\n          pre[y] = x;\n          q.push(y);\n        } else {\n          if (!fl[y] || fl[y] && !fl[x]) {\n            for (int t = x; !fl[t]; t = pre[t]) {\n              p += b[t];\n              fl[t] = 1;\n            }\n            for (int t = y; !fl[t]; t = pre[t]) {\n              p += b[t];\n              fl[t] = 1;\n            }\n            return 1;\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\nbool check(long long p) {\n  memset(fl, 0, sizeof fl);\n  fl[1] = 1;\n  while (*min_element(fl + 1, fl + n + 1) == 0) {\n    if (!bfs(p)) return 0;\n  }\n  return 1;\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    cin >> n >> m;\n    for (int i = 2; i <= n; ++i) cin >> a[i];\n    for (int i = 2; i <= n; ++i) cin >> b[i];\n    for (int i = 1; i <= n; ++i) G[i].clear();\n    for (int i = 1; i <= m; ++i) {\n      int x, y;\n      cin >> x >> y;\n      G[x].push_back(y);\n      G[y].push_back(x);\n    }\n    long long l = 1, r = 1e9 + 7, ans = -1;\n    while (l <= r) {\n      long long mid = l + r >> 1;\n      if (check(mid)) {\n        ans = mid;\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid _R(T &x) {\n  cin >> x;\n}\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate <class T, class... U>\nvoid R(T &head, U &...tail) {\n  _R(head);\n  R(tail...);\n}\ntemplate <class T>\nvoid _W(const T &x) {\n  cout << x;\n}\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate <class T, class U>\nvoid _W(const pair<T, U> &x) {\n  _W(x.first);\n  putchar(' ');\n  _W(x.second);\n}\ntemplate <class T>\nvoid _W(const vector<T> &x) {\n  for (auto i = x.begin(); i != x.end(); _W(*i++))\n    if (i != x.cbegin()) putchar(' ');\n}\nvoid W() {}\ntemplate <class T, class... U>\nvoid W(const T &head, const U &...tail) {\n  _W(head);\n  putchar(sizeof...(tail) ? ' ' : '\\n');\n  W(tail...);\n}\nint MOD = 1e9 + 7;\nvoid ADD(long long &x, long long v) {\n  x = (x + v) % MOD;\n  if (x < 0) x += MOD;\n}\nconst int SIZE = 1 << 12;\nint n, m;\nint a[SIZE], _b[SIZE];\nint b[SIZE];\nvector<int> e[SIZE];\nstruct Union_Find {\n  int d[1234567], num[1234567];\n  void init(int n) {\n    for (int i = 0; i < n; i++) {\n      d[i] = i;\n      num[i] = 1;\n    }\n  }\n  int find(int x) {\n    int y = x, z = x;\n    while (y != d[y]) {\n      y = d[y];\n    }\n    while (x != y) {\n      x = d[x];\n      d[z] = y;\n      z = x;\n    }\n    return y;\n  }\n  bool is_root(int x) { return d[x] == x; }\n  bool uu(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) {\n      return 0;\n    }\n    if (num[x] > num[y]) {\n      swap(x, y);\n    }\n    num[y] += num[x];\n    d[x] = y;\n    return 1;\n  }\n} U;\nint rn;\nint ma_v;\nbitset<2001> u;\nint from[SIZE];\nlong long add_v;\nlong long st;\nvoid clear(int y) {\n  int AA = y;\n  while (AA != 1) {\n    add_v += b[AA];\n    if (b[AA]) rn--;\n    b[AA] = 0;\n    AA = from[AA];\n  }\n}\nbool dfs(int x, int lt, long long now) {\n  u[x] = 1;\n  for (int y : e[x]) {\n    if (y == lt) {\n      continue;\n    }\n    if (u[y] && b[y] == 0) {\n      if (now > st) {\n        clear(y);\n        clear(x);\n        return 1;\n      }\n      continue;\n    }\n    if (now > a[y]) {\n      if (u[y]) {\n        clear(y);\n        clear(x);\n        return 1;\n      } else {\n        from[y] = x;\n        if (dfs(y, x, now + b[y])) return 1;\n      }\n    }\n  }\n  return 0;\n}\nbool valid(long long st_v) {\n  for (int i = (1); i <= (n); ++i) {\n    b[i] = _b[i];\n  }\n  U.init(n + 1);\n  rn = n;\n  add_v = 0;\n  while (rn == 1 || st_v <= ma_v) {\n    st = st_v;\n    u.reset();\n    if (!dfs(1, 1, st_v)) break;\n    st_v += add_v;\n    add_v = 0;\n  }\n  return rn == 1 || st_v > ma_v;\n}\nvoid solve() {\n  ma_v = *max_element(a + 1, a + n + 1) + 1;\n  int ll = MOD, rr = ma_v;\n  for (int x : e[1]) ll = min(ll, a[x]);\n  while (ll < rr) {\n    int mm = (ll + rr) / 2;\n    if (valid(mm))\n      rr = mm;\n    else\n      ll = mm + 1;\n  }\n  W(ll);\n}\nvoid input() {\n  R(n, m);\n  for (int i = (2); i <= (n); ++i) {\n    R(a[i]);\n  }\n  for (int i = (2); i <= (n); ++i) {\n    R(_b[i]);\n  }\n  for (int i = (1); i <= (n); ++i) {\n    vector<int> tmp;\n    e[i].swap(tmp);\n  }\n  for (int i = 0; i < (m); ++i) {\n    int x, y;\n    R(x, y);\n    e[x].emplace_back(y);\n    e[y].emplace_back(x);\n  }\n}\nint main() {\n  int ___T;\n  scanf(\"%d\", &___T);\n  for (int cs = 1; cs <= ___T; cs++) {\n    input();\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nbool chkmax(T &x, T y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <typename T>\nbool chkmin(T &x, T y) {\n  return x > y ? x = y, true : false;\n}\nusing namespace std;\nlong long ksm(long long a, long long b) {\n  if (!b) return 1;\n  long long ns = ksm(a, b >> 1);\n  ns = ns * ns % 998244353;\n  if (b & 1) ns = ns * a % 998244353;\n  return ns;\n}\nint n, m, a[4005], b[4005], u[4005], v[4005], dis[4005], lst[4005];\nlong long power;\nint cur;\nbool vis[4005];\nvector<pair<int, int> > e[4005];\nvector<int> E[4005];\nlong long refresh() {\n  for (int i = 1; i <= n; i++) {\n    E[i].clear();\n    for (auto x : e[i]) E[i].push_back(x.second);\n  }\n  long long del = 1 << 30;\n  queue<int> q;\n  for (auto x : E[1])\n    if (dis[x] <= power)\n      q.push(x);\n    else\n      del = min(del, dis[x] - power);\n  E[1].clear();\n  while (!q.empty()) {\n    int id = q.front();\n    q.pop();\n    if (!vis[v[id]]) {\n      vis[v[id]] = 1;\n      power += b[v[id]];\n      del = -1;\n      return del;\n    }\n    bool rid = false;\n    for (auto x : E[v[id]]) {\n      if (x == (id ^ 1)) {\n        rid = true;\n        continue;\n      }\n      if (dis[x] <= power)\n        q.push(x);\n      else\n        del = min(del, dis[x] - power);\n    }\n    E[v[id]].clear();\n    if (rid) E[v[id]].push_back(id ^ 1);\n  }\n  return del;\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) e[i].clear(), vis[i] = 0;\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &a[i]), a[i] += 1;\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &b[i]);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &u[2 * i], &v[2 * i]);\n    u[2 * i + 1] = v[2 * i];\n    v[2 * i + 1] = u[2 * i];\n    e[u[2 * i]].push_back(make_pair(v[2 * i], 2 * i));\n    e[u[2 * i + 1]].push_back(make_pair(v[2 * i + 1], 2 * i + 1));\n  }\n  for (int i = 0; i < 2 * m; i++) dis[i] = a[v[i]];\n  for (int r = 0; r < 2 * m; r++) {\n    memcpy(lst, dis, sizeof lst);\n    for (int i = 1; i <= n; i++) {\n      pair<int, int> m1(1 << 30, -1), m2(1 << 30, -1);\n      for (auto x : e[i]) {\n        if (lst[x.second] < m2.first) m2 = {lst[x.second], x.second};\n        if (m2 < m1) swap(m2, m1);\n      }\n      for (auto x : e[i]) {\n        int id = x.second ^ 1;\n        if (m1.second == x.second)\n          dis[id] = max(a[v[id]], m2.first - b[i]);\n        else\n          dis[id] = max(a[v[id]], m1.first - b[i]);\n      }\n    }\n  }\n  cur = 0;\n  power = 0;\n  while (true) {\n    int del = refresh();\n    if (del == (1 << 30)) break;\n    if (del > 0) {\n      cur += del;\n      power += del;\n    }\n  }\n  printf(\"%d\\n\", cur);\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  for (int i = 0; i < T; i++) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid read(T &x) {\n  x = 0;\n  int op = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') op = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = (x << 1) + (x << 3) + (c ^ 48);\n    c = getchar();\n  }\n  x *= op;\n}\ninline void swap(int &x, int &y) { x ^= y ^= x ^= y; }\ninline int min(int x, int y) { return x < y ? x : y; }\ninline int max(int x, int y) { return x > y ? x : y; }\nconst int MN = 1005;\nint n, m, a[MN], b[MN];\nvector<int> G[MN];\nvoid Adde(int x, int y) {\n  G[x].push_back(y);\n  G[y].push_back(x);\n}\nqueue<int> q;\nint ins[MN], pre[MN], vis[MN];\nlong long val[MN];\nbool Judge(int S) {\n  ins[1] = 1;\n  for (int i = (2); i <= (n); ++i) ins[i] = 0;\n  long long sum = S;\n  while (1) {\n    for (int i = 1; i <= n; ++i) vis[i] = ins[i], pre[i] = 0, val[i] = 0;\n    while (!q.empty()) q.pop();\n    for (int i = 1; i <= n; ++i)\n      if (ins[i]) q.push(i), val[i] = sum;\n    pair<int, int> pos = make_pair(0, 0);\n    while (!q.empty()) {\n      int x = q.front();\n      q.pop();\n      for (int y : G[x])\n        if (!ins[x] || !ins[y]) {\n          if (y == pre[x] || val[x] <= a[y]) continue;\n          if (vis[y]) {\n            pos = make_pair(x, y);\n            break;\n          }\n          vis[y] = 1;\n          val[y] = val[x] + b[y];\n          pre[y] = x;\n          q.push(y);\n        }\n      if (pos.first) break;\n    }\n    if (!pos.first) return 0;\n    for (int i = pos.first; !ins[i]; i = pre[i]) ins[i] = 1, sum += b[i];\n    for (int i = pos.second; !ins[i]; i = pre[i]) ins[i] = 1, sum += b[i];\n    bool ok = 1;\n    for (int i = 1; i <= n; ++i) ok &= ins[i];\n    if (ok) return 1;\n  }\n  return 0;\n}\nint main() {\n  int Tests;\n  read(Tests);\n  while (Tests--) {\n    read(n);\n    read(m);\n    for (int i = (1); i <= (n); ++i) G[i].clear();\n    for (int i = (2); i <= (n); ++i) read(a[i]);\n    for (int i = (2); i <= (n); ++i) read(b[i]);\n    for (int i = 1, u, v; i <= m; ++i) read(u), read(v), Adde(u, v);\n    int l = 1, r = 1e9 + 1, mid, ans = 0;\n    while (l <= r) {\n      mid = (l + r) >> 1;\n      if (Judge(mid))\n        ans = mid, r = mid - 1;\n      else\n        l = mid + 1;\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T, n, m, u, v;\nlong long a[1005], b[1005], tmp;\nvector<int> G[1005];\nint vis[1005], fa[1005], f[1005], t[1005];\nint type, str1, str2;\nvoid dfs(int x, int last, long long now) {\n  f[x] = now;\n  fa[x] = last;\n  t[x] = 1;\n  for (register int i = 0; i < G[x].size(); i++) {\n    int V = G[x][i];\n    if (V == last) continue;\n    if (vis[V]) {\n      type = 1, str1 = x;\n      return;\n    }\n    if (now <= a[V]) continue;\n    if (!t[V]) {\n      dfs(V, x, now + b[V]);\n    } else if (now + b[V] >= f[V]) {\n      type = 2, str1 = x, str2 = V;\n      return;\n    }\n    if (type) return;\n  }\n}\nint work() {\n  for (int i = 1; i <= n; i++) t[i] = 0;\n  type = str1 = str2 = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) continue;\n    for (int j = 0; j < G[i].size(); j++) {\n      int V = G[i][j];\n      if (vis[V] || tmp <= a[V]) continue;\n      dfs(V, i, tmp + b[V]);\n    }\n    if (type) break;\n  }\n  if (!type) return 0;\n  if (type == 1) {\n    for (int p = str1; !vis[p]; p = fa[p]) {\n      vis[p] = 1;\n      tmp += b[p];\n    }\n  }\n  if (type == 2) {\n    for (int p = str1; !vis[p]; p = fa[p]) {\n      vis[p] = 1;\n      tmp += b[p];\n    }\n    for (int p = str2; !vis[p]; p = fa[p]) {\n      vis[p] = 1;\n      tmp += b[p];\n    }\n  }\n  return 1;\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) G[i].clear();\n  for (int i = 2; i <= n; i++) scanf(\"%lld\", &a[i]);\n  for (int i = 2; i <= n; i++) scanf(\"%lld\", &b[i]);\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  int l = 1, r = 1000000001, mid;\n  while (l < r) {\n    mid = (l + r) >> 1;\n    for (int i = 1; i <= n; i++) vis[i] = 0;\n    vis[1] = 1;\n    tmp = mid;\n    while (work())\n      ;\n    int flag = 1;\n    for (int i = 1; i <= n; i++) flag &= vis[i];\n    if (flag)\n      r = mid;\n    else\n      l = mid + 1;\n  }\n  printf(\"%d\\n\", l);\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vvi = vector<vector<int>>;\nusing vi = vector<int>;\nusing vvll = vector<vector<long long>>;\nusing vll = vector<long long>;\nusing vd = vector<double>;\nusing vvd = vector<vector<double>>;\nusing pii = pair<int, int>;\nusing vpii = vector<pair<int, int>>;\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nbool dfs(int u, int last, vvi &adj, vi &strength, vi &buff, vi &par, ll cur_pow,\n         vi &vis, vi &done, bool nonvis) {\n  vis[u] = 1;\n  if (!done[u]) nonvis = true;\n  for (int v : adj[u]) {\n    if (v == last) continue;\n    if (vis[v] && nonvis) {\n      int cur = u;\n      while (cur != -1) {\n        done[cur] = 1;\n        cur = par[cur];\n      }\n      return true;\n    } else if (vis[v])\n      continue;\n    if (cur_pow <= (ll)strength[v]) continue;\n    par[v] = u;\n    bool res = dfs(v, u, adj, strength, buff, par,\n                   cur_pow + (!done[v]) * buff[v], vis, done, nonvis);\n    if (res) return true;\n  }\n  return false;\n}\nbool check(int n, int m, vvi &adj, vi &strength, vi &buff, ll pow) {\n  vi done(n);\n  done[0] = 1;\n  while (true) {\n    bool fin = true;\n    for (int i = 0; i < n; i++) {\n      if (done[i] == 0) {\n        fin = false;\n        break;\n      }\n    }\n    if (fin) return true;\n    vi vis(n), par(n, -1);\n    vis[0] = 1;\n    ll cur_pow = pow;\n    for (int i = 1; i < n; i++) {\n      if (done[i]) cur_pow += buff[i];\n    }\n    bool res = dfs(0, -1, adj, strength, buff, par, cur_pow, vis, done, false);\n    if (res == false) return false;\n  }\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vvi adj(n);\n  vi strength(n);\n  for (int i = 1; i < n; i++) cin >> strength[i];\n  vi buff(n);\n  for (int i = 1; i < n; i++) cin >> buff[i];\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--;\n    y--;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  int ans = (1 << 30) - 1;\n  for (int x = 1 << 29; x; x >>= 1) {\n    ll cand = ans - x;\n    if (check(n, m, adj, strength, buff, cand)) {\n      ans = cand;\n    }\n  }\n  cout << ans << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int tc;\n  cin >> tc;\n  while (tc--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T, n, m, K, pr[1010], a[1010], b[1010];\nbool in[1010], fl;\nvector<int> E[1010];\nvoid doit(int u) {\n  for (; u; u = pr[u]) in[u] = 1;\n}\nvoid dfs(int u, int fa, long long nw) {\n  for (int v : E[u])\n    if (v != fa && a[v] < nw && !(in[u] && in[v])) {\n      if (in[v]) {\n        fl = 1;\n        return doit(u);\n      }\n      if (pr[v]) {\n        fl = 1;\n        return doit(v), doit(u);\n      }\n      pr[v] = u, dfs(v, u, nw + b[v]);\n      if (fl) return;\n    }\n}\nbool chk(int x) {\n  for (int i = 1; i <= n; i++) in[i] = 0;\n  in[1] = 1;\n  while (1) {\n    fl = 1;\n    long long nw = x;\n    for (int i = 1; i <= n; i++) pr[i] = 0, nw += b[i] * in[i], fl &= in[i];\n    if (fl) return 1;\n    fl = 0;\n    for (int i = 1; i <= n && !fl; i++)\n      if (in[i]) dfs(i, 0, nw);\n    if (!fl) return 0;\n  }\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &b[i]);\n  for (int i = 1; i <= n; i++) E[i].resize(0);\n  for (int i = 1, u, v; i <= m; i++)\n    scanf(\"%d%d\", &u, &v), E[u].push_back(v), E[v].push_back(u);\n  int l = 1, r = 1e9 + 2, mid, ans = -1;\n  while (l <= r) {\n    mid = (l + r) >> 1;\n    if (chk(mid))\n      ans = mid, r = mid - 1;\n    else\n      l = mid + 1;\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:36777216\")\nusing namespace std;\ntemplate <class T>\ninline T &RD(T &);\ntemplate <class T>\ninline void OT(const T &);\ninline long long RD() {\n  long long x;\n  return RD(x);\n}\ninline double &RF(double &);\ninline double RF() {\n  double x;\n  return RF(x);\n}\ninline char *RS(char *s);\ninline char &RC(char &c);\ninline char RC();\ninline char &RC(char &c) {\n  scanf(\" %c\", &c);\n  return c;\n}\ninline char RC() {\n  char c;\n  return RC(c);\n}\ntemplate <class T>\ninline T &RDD(T &);\ninline long long RDD() {\n  long long x;\n  return RDD(x);\n}\ntemplate <class T0, class T1>\ninline T0 &RD(T0 &x0, T1 &x1) {\n  RD(x0), RD(x1);\n  return x0;\n}\ntemplate <class T0, class T1, class T2>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2) {\n  RD(x0), RD(x1), RD(x2);\n  return x0;\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3) {\n  RD(x0), RD(x1), RD(x2), RD(x3);\n  return x0;\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4) {\n  RD(x0), RD(x1), RD(x2), RD(x3), RD(x4);\n  return x0;\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5) {\n  RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5);\n  return x0;\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6) {\n  RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6);\n  return x0;\n}\ntemplate <class T0, class T1>\ninline void OT(const T0 &x0, const T1 &x1) {\n  OT(x0), OT(x1);\n}\ntemplate <class T0, class T1, class T2>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2) {\n  OT(x0), OT(x1), OT(x2);\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3) {\n  OT(x0), OT(x1), OT(x2), OT(x3);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3,\n               const T4 &x4) {\n  OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3,\n               const T4 &x4, const T5 &x5) {\n  OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3,\n               const T4 &x4, const T5 &x5, const T6 &x6) {\n  OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);\n}\ninline char &RC(char &a, char &b) {\n  RC(a), RC(b);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c) {\n  RC(a), RC(b), RC(c);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c, char &d) {\n  RC(a), RC(b), RC(c), RC(d);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c, char &d, char &e) {\n  RC(a), RC(b), RC(c), RC(d), RC(e);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c, char &d, char &e, char &f) {\n  RC(a), RC(b), RC(c), RC(d), RC(e), RC(f);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g) {\n  RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g);\n  return a;\n}\ninline double &RF(double &a, double &b) {\n  RF(a), RF(b);\n  return a;\n}\ninline double &RF(double &a, double &b, double &c) {\n  RF(a), RF(b), RF(c);\n  return a;\n}\ninline double &RF(double &a, double &b, double &c, double &d) {\n  RF(a), RF(b), RF(c), RF(d);\n  return a;\n}\ninline double &RF(double &a, double &b, double &c, double &d, double &e) {\n  RF(a), RF(b), RF(c), RF(d), RF(e);\n  return a;\n}\ninline double &RF(double &a, double &b, double &c, double &d, double &e,\n                  double &f) {\n  RF(a), RF(b), RF(c), RF(d), RF(e), RF(f);\n  return a;\n}\ninline double &RF(double &a, double &b, double &c, double &d, double &e,\n                  double &f, double &g) {\n  RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g);\n  return a;\n}\ninline void RS(char *s1, char *s2) { RS(s1), RS(s2); }\ninline void RS(char *s1, char *s2, char *s3) { RS(s1), RS(s2), RS(s3); }\ntemplate <class T0, class T1>\ninline T0 &RDD(T0 &a, T1 &b) {\n  RDD(a), RDD(b);\n  return a;\n}\ntemplate <class T0, class T1, class T2>\ninline T1 &RDD(T0 &a, T1 &b, T2 &c) {\n  RDD(a), RDD(b), RDD(c);\n  return a;\n}\ntemplate <class T>\ninline void RST(T &A) {\n  memset(A, 0, sizeof(A));\n}\ntemplate <class T>\ninline void FLC(T &A, int x) {\n  memset(A, x, sizeof(A));\n}\ntemplate <class T>\ninline void CLR(T &A) {\n  A.clear();\n}\ntemplate <class T0, class T1>\ninline void RST(T0 &A0, T1 &A1) {\n  RST(A0), RST(A1);\n}\ntemplate <class T0, class T1, class T2>\ninline void RST(T0 &A0, T1 &A1, T2 &A2) {\n  RST(A0), RST(A1), RST(A2);\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3) {\n  RST(A0), RST(A1), RST(A2), RST(A3);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4) {\n  RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5) {\n  RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6) {\n  RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);\n}\ntemplate <class T0, class T1>\ninline void FLC(T0 &A0, T1 &A1, int x) {\n  FLC(A0, x), FLC(A1, x);\n}\ntemplate <class T0, class T1, class T2>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x);\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x),\n      FLC(A6, x);\n}\ntemplate <class T>\ninline void CLR(priority_queue<T> &Q) {\n  while (!Q.empty()) Q.pop();\n}\ntemplate <class T>\ninline void CLR(stack<T> &S) {\n  while (!S.empty()) S.pop();\n}\ntemplate <class T>\ninline void CLR(queue<T> &Q) {\n  while (!Q.empty()) Q.pop();\n}\ntemplate <class T0, class T1>\ninline void CLR(T0 &A0, T1 &A1) {\n  CLR(A0), CLR(A1);\n}\ntemplate <class T0, class T1, class T2>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2) {\n  CLR(A0), CLR(A1), CLR(A2);\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3) {\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4) {\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5) {\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6) {\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);\n}\ntemplate <class T>\ninline void CLR(T &A, int n) {\n  for (int i = 0; i < n; ++i) CLR(A[i]);\n}\ntemplate <class T>\ninline bool EPT(T &a) {\n  return a.empty();\n}\ntemplate <class T>\ninline T &SRT(T &A) {\n  sort(A.begin(), A.end());\n  return A;\n}\ntemplate <class T, class C>\ninline T &SRT(T &A, C cmp) {\n  sort(A.begin(), A.end(), cmp);\n  return A;\n}\ntemplate <class T>\ninline T &RVS(T &A) {\n  reverse(A.begin(), A.end());\n  return A;\n}\ntemplate <class T>\ninline T &UNQQ(T &A) {\n  A.resize(unique(A.begin(), A.end()) - A.begin());\n  return A;\n}\ntemplate <class T>\ninline T &UNQ(T &A) {\n  SRT(A);\n  return UNQQ(A);\n}\ntemplate <class T, class C>\ninline T &UNQ(T &A, C cmp) {\n  SRT(A, cmp);\n  return UNQQ(A);\n}\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst long long INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-9;\nconst double OO = 1e20;\nconst double PI = acos(-1.0);\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\ntemplate <class T>\ninline bool checkMin(T &a, const T b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline bool checkMax(T &a, const T b) {\n  return a < b ? a = b, 1 : 0;\n}\ntemplate <class T, class C>\ninline bool checkUpd(T &a, const T b, C c) {\n  return c(b, a) ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline T min(T a, T b, T c) {\n  return min(min(a, b), c);\n}\ntemplate <class T>\ninline T max(T a, T b, T c) {\n  return max(max(a, b), c);\n}\ntemplate <class T>\ninline T min(T a, T b, T c, T d) {\n  return min(min(a, b), min(c, d));\n}\ntemplate <class T>\ninline T max(T a, T b, T c, T d) {\n  return max(max(a, b), max(c, d));\n}\ntemplate <class T>\ninline T min(T a, T b, T c, T d, T e) {\n  return min(min(min(a, b), min(c, d)), e);\n}\ntemplate <class T>\ninline T max(T a, T b, T c, T d, T e) {\n  return max(max(max(a, b), max(c, d)), e);\n}\ntemplate <class T>\ninline T sqr(T a) {\n  return a * a;\n}\ntemplate <class T>\ninline T cub(T a) {\n  return a * a * a;\n}\ntemplate <class T>\ninline T ceil(T x, T y) {\n  return (x - 1) / y + 1;\n}\ntemplate <class T>\nT abs(T x) {\n  return x > 0 ? x : -x;\n}\ninline int sgn(double x) { return x < -EPS ? -1 : x > EPS; }\ninline int sgn(double x, double y) { return sgn(x - y); }\ninline double cos(double a, double b, double c) {\n  return (sqr(a) + sqr(b) - sqr(c)) / (2 * a * b);\n}\ninline double cot(double x) { return 1. / tan(x); };\ninline double sec(double x) { return 1. / cos(x); };\ninline double csc(double x) { return 1. / sin(x); };\nnamespace BO {\ninline bool _1(int x, int i) { return bool(x & 1 << i); }\ninline bool _1(long long x, int i) { return bool(x & 1LL << i); }\ninline long long _1(int i) { return 1LL << i; }\ninline long long _U(int i) { return _1(i) - 1; };\ninline int reverse_bits(int x) {\n  x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n  x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n  x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n  x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n  x = ((x >> 16) & 0x0000ffff) | ((x << 16) & 0xffff0000);\n  return x;\n}\ninline long long reverse_bits(long long x) {\n  x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n  x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n  x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n  x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n  x = ((x >> 16) & 0x0000ffff0000ffffLL) | ((x << 16) & 0xffff0000ffff0000LL);\n  x = ((x >> 32) & 0x00000000ffffffffLL) | ((x << 32) & 0xffffffff00000000LL);\n  return x;\n}\ntemplate <class T>\ninline bool odd(T x) {\n  return x & 1;\n}\ntemplate <class T>\ninline bool even(T x) {\n  return !odd(x);\n}\ntemplate <class T>\ninline T low_bit(T x) {\n  return x & -x;\n}\ntemplate <class T>\ninline T high_bit(T x) {\n  T p = low_bit(x);\n  while (p != x) x -= p, p = low_bit(x);\n  return p;\n}\ntemplate <class T>\ninline T cover_bit(T x) {\n  T p = 1;\n  while (p < x) p <<= 1;\n  return p;\n}\ntemplate <class T>\ninline int cover_idx(T x) {\n  int p = 0;\n  while (_1(p) < x) ++p;\n  return p;\n}\ninline int clz(int x) { return __builtin_clz(x); }\ninline int clz(long long x) { return __builtin_clzll(x); }\ninline int ctz(int x) { return __builtin_ctz(x); }\ninline int ctz(long long x) { return __builtin_ctzll(x); }\ninline int lg2(int x) { return !x ? -1 : 31 - clz(x); }\ninline int lg2(long long x) { return !x ? -1 : 63 - clz(x); }\ninline int low_idx(int x) { return !x ? -1 : ctz(x); }\ninline int low_idx(long long x) { return !x ? -1 : ctz(x); }\ninline int high_idx(int x) { return lg2(x); }\ninline int high_idx(long long x) { return lg2(x); }\ninline int parity(int x) { return __builtin_parity(x); }\ninline int parity(long long x) { return __builtin_parityll(x); }\ninline int count_bits(int x) { return __builtin_popcount(x); }\ninline int count_bits(long long x) { return __builtin_popcountll(x); }\n}  // namespace BO\nusing namespace BO;\nnamespace NT {\ninline long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\ninline long long lcm(long long a, long long b) { return a * b / gcd(a, b); }\ninline void INC(int &a, int b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n}\ninline int sum(int a, int b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n  return a;\n}\ninline void DEC(int &a, int b) {\n  a -= b;\n  if (a < 0) a += MOD;\n}\ninline int dff(int a, int b) {\n  a -= b;\n  if (a < 0) a += MOD;\n  return a;\n}\ninline void MUL(int &a, int b) { a = (long long)a * b % MOD; }\ninline int pdt(int x, int y) {\n  int ret;\n  __asm__ __volatile__(\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\"\n                       : \"=d\"(ret)\n                       : \"a\"(x), \"b\"(y), \"c\"(MOD));\n  return ret;\n}\ninline int gcd(int m, int n, int &x, int &y) {\n  x = 1, y = 0;\n  int xx = 0, yy = 1, q;\n  while (1) {\n    q = m / n, m %= n;\n    if (!m) {\n      x = xx, y = yy;\n      return n;\n    }\n    DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n    q = n / m, n %= m;\n    if (!n) return m;\n    DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n  }\n}\ninline int sum(int a, int b, int c) { return sum(a, sum(b, c)); }\ninline int sum(int a, int b, int c, int d) { return sum(sum(a, b), sum(c, d)); }\ninline int pdt(int a, int b, int c) { return pdt(a, pdt(b, c)); }\ninline int pdt(int a, int b, int c, int d) { return pdt(pdt(a, b), pdt(c, d)); }\ninline int pow(int a, long long b) {\n  int c(1);\n  while (b) {\n    if (b & 1) MUL(c, a);\n    MUL(a, a), b >>= 1;\n  }\n  return c;\n}\ntemplate <class T>\ninline T pow(T a, long long b) {\n  T c(1);\n  while (b) {\n    if (b & 1) c *= a;\n    a *= a, b >>= 1;\n  }\n  return c;\n}\ntemplate <class T>\ninline T pow(T a, int b) {\n  return pow(a, (long long)b);\n}\ninline int _I(int b) {\n  int a = MOD, x1 = 0, x2 = 1, q;\n  while (1) {\n    q = a / b, a %= b;\n    if (!a) return x2;\n    DEC(x1, pdt(q, x2));\n    q = b / a, b %= a;\n    if (!b) return x1;\n    DEC(x2, pdt(q, x1));\n  }\n}\ninline void DIV(int &a, int b) { MUL(a, _I(b)); }\ninline int qtt(int a, int b) { return pdt(a, _I(b)); }\nstruct Int {\n  int val;\n  operator int() const { return val; }\n  Int(int _val = 0) : val(_val) {\n    val %= MOD;\n    if (val < 0) val += MOD;\n  }\n  Int(long long _val) : val(_val) {\n    _val %= MOD;\n    if (_val < 0) _val += MOD;\n    val = _val;\n  }\n  Int &operator+=(const int &rhs) {\n    INC(val, rhs);\n    return *this;\n  }\n  Int operator+(const int &rhs) const { return sum(val, rhs); }\n  Int &operator-=(const int &rhs) {\n    DEC(val, rhs);\n    return *this;\n  }\n  Int operator-(const int &rhs) const { return dff(val, rhs); }\n  Int &operator*=(const int &rhs) {\n    MUL(val, rhs);\n    return *this;\n  }\n  Int operator*(const int &rhs) const { return pdt(val, rhs); }\n  Int &operator/=(const int &rhs) {\n    DIV(val, rhs);\n    return *this;\n  }\n  Int operator/(const int &rhs) const { return qtt(val, rhs); }\n  Int operator-() const { return MOD - *this; }\n};\n}  // namespace NT\nusing namespace NT;\ntemplate <class T>\ninline T &RD(T &x) {\n  char c;\n  while (!isdigit((c = getchar())))\n    ;\n  x = c - '0';\n  while (isdigit((c = getchar()))) x = x * 10 + c - '0';\n  return x;\n}\ntemplate <class T>\ninline T &RDD(T &x) {\n  char c;\n  while ((c = getchar()), c != '-' && !isdigit(c))\n    ;\n  if (c == '-') {\n    x = '0' - (c = getchar());\n    while (isdigit((c = getchar()))) x = x * 10 + '0' - c;\n  } else {\n    x = c - '0';\n    while (isdigit((c = getchar()))) x = x * 10 + c - '0';\n  }\n  return x;\n}\ninline double &RF(double &x) {\n  char c;\n  while ((c = getchar()), c != '-' && c != '.' && !isdigit(c))\n    ;\n  if (c == '-')\n    if ((c = getchar()) == '.') {\n      x = 0;\n      double l = 1;\n      while (isdigit((c = getchar()))) l /= 10, x = x * 10 + '0' - c;\n      x *= l;\n    } else {\n      x = '0' - c;\n      while (isdigit((c = getchar()))) x = x * 10 + '0' - c;\n      if (c == '.') {\n        double l = 1;\n        while (isdigit((c = getchar()))) l /= 10, x = x * 10 + '0' - c;\n        x *= l;\n      }\n    }\n  else if (c == '.') {\n    x = 0;\n    double l = 1;\n    while (isdigit((c = getchar()))) l /= 10, x = x * 10 + c - '0';\n    x *= l;\n  } else {\n    x = c - '0';\n    while (isdigit((c = getchar()))) x = x * 10 + c - '0';\n    if (c == '.') {\n      double l = 1;\n      while (isdigit((c = getchar()))) l /= 10, x = x * 10 + c - '0';\n      x *= l;\n    }\n  }\n  return x;\n}\ninline char *RS(char *s) {\n  scanf(\"%s\", s);\n  return s;\n}\nlong long last_ans;\nint Case;\ntemplate <class T>\ninline void OT(const T &x) {\n  cout << x << endl;\n}\nconst int N = int(1e3) + 9;\nvector<int> adj[N];\nint n, m;\nint a[N], b[N];\nint fa[N];\nlong long p[N], p0;\nint Q[N], cz, op;\nvoid add_path(int u) {\n  while (~fa[u]) {\n    Q[op++] = u;\n    p0 += b[u];\n    int v = fa[u];\n    fa[u] = -1;\n    u = v;\n  }\n}\nbool find_circle() {\n  for (int i = 0; i < n; ++i) fa[i] = -1, p[i] = 0;\n  for (int i = 0; i < op; ++i) p[Q[i]] = p0;\n  cz = 0;\n  int op = ::op;\n  while (cz < op) {\n    int u = Q[cz++];\n    for (auto v : adj[u])\n      if (v != fa[u] && p[u] > a[v]) {\n        if (~fa[v] || p[v] == p0 && p[u] != p0) {\n          add_path(u);\n          add_path(v);\n          return 1;\n        }\n        if (p[v] == p0) continue;\n        p[v] = p[u] + b[v];\n        fa[v] = u;\n        Q[op++] = v;\n      }\n  }\n  return 0;\n}\nbool ok(int _p0) {\n  op = 0;\n  Q[op++] = 0;\n  p0 = _p0;\n  while (find_circle())\n    ;\n  return op == n;\n}\nint main() {\n  for (int ____T = RD(); ____T--;) {\n    RD(n, m);\n    for (int i = 1; i < n; ++i) RD(a[i]);\n    for (int i = 1; i < n; ++i) RD(b[i]);\n    for (int i = 0; i < n; ++i) adj[i].clear();\n    for (int ____n = m; ____n-- > 0;) {\n      int x, y;\n      RD(x, y);\n      --x;\n      --y;\n      adj[x].push_back(y);\n      adj[y].push_back(x);\n    }\n    int l = 2, r = int(1e9) + 1;\n    while (l < r) {\n      int m = (l + r) / 2;\n      if (ok(m))\n        r = m;\n      else\n        l = m + 1;\n    }\n    cout << l << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace jyy {\nconst int mod = 998244353, N = 200010;\nconst double eps = 1e-8;\ninline int read() {\n  static int x = 0, f = 1;\n  x = 0, f = 1;\n  static char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    (ch == '-') ? f *= -1 : f;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') x = x * 10 + int(ch - 48), ch = getchar();\n  return x * f;\n}\ninline void fw(int x) {\n  if (x < 0) putchar('-'), x = -x;\n  x >= 10 ? fw(x / 10), 1 : 0;\n  putchar(char(x % 10 + 48));\n}\nint qmo(int x) { return x + ((x >> 31) & mod); }\nint ksm(int x, int y) {\n  int tmp = 1;\n  for (; y; y >>= 1, x = 1ll * x * x % mod)\n    if (y & 1) tmp = 1ll * tmp * x % mod;\n  return tmp;\n}\nint inv(int x) { return ksm(x, mod - 2); }\nint tot, head[N], fa[N];\nstruct edge {\n  int to, next;\n} dat[N * 2];\nvoid add_edge(int x, int y) { dat[++tot] = (edge){y, head[x]}, head[x] = tot; }\nint find(int x) { return fa[x] ? fa[x] = find(fa[x]) : x; }\nint merge(int x, int y) {\n  return find(x) != find(y) ? fa[find(x)] = find(y), 0 : 1;\n}\nint low(int x) { return x & -x; }\nint ifac[N], fac[N];\nvoid init(int x) {\n  fac[0] = ifac[0] = 1;\n  for (int i = 1; i <= x; i++) fac[i] = 1ll * fac[i - 1] * i % mod;\n  ifac[x] = inv(fac[x]);\n  for (int i = x - 1; i >= 1; i--) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;\n}\nint C(int x, int y) {\n  return (x < y || y < 0 || x < 0)\n             ? 0\n             : 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n}  // namespace jyy\nusing namespace jyy;\nlong long dis[N];\nint in[N], v[N], n, last[N], a[N], b[N], m;\nqueue<int> q;\nbool check(long long now) {\n  for (int i = 1; i <= n; i++) in[i] = 0;\n  in[1] = 1;\n  while (1) {\n    while (q.size()) q.pop();\n    for (int i = 1; i <= n; i++) v[i] = in[i], dis[i] = 0, last[i] = 0;\n    for (int i = 1; i <= n; i++)\n      if (in[i]) q.push(i), dis[i] = now;\n    int t1 = 0, t2 = 0;\n    while (!q.empty()) {\n      int x = q.front();\n      q.pop();\n      for (int i = head[x]; i; i = dat[i].next) {\n        int t = dat[i].to;\n        if (last[x] == t || (in[x] && in[t])) continue;\n        if (v[t]) {\n          t1 = x, t2 = t;\n          break;\n        }\n        if ((long long)a[t] >= dis[x]) continue;\n        v[t] = 1, dis[t] = dis[x] + b[t], last[t] = x, q.push(t);\n      }\n      if (t1) break;\n    }\n    if (!t1) return 0;\n    for (; !in[t1]; t1 = last[t1]) now += b[t1], in[t1] = 1;\n    for (; !in[t2]; t2 = last[t2]) now += b[t2], in[t2] = 1;\n    int res = 1;\n    for (int i = 1; i <= n; i++) res &= in[i];\n    if (res) return 1;\n  }\n  return 0;\n}\nvoid solve() {\n  n = read(), m = read(), tot = 0;\n  for (int i = 1; i <= n; i++) head[i] = 0;\n  for (int i = 2; i <= n; i++) a[i] = read();\n  for (int i = 2; i <= n; i++) b[i] = read();\n  for (int i = 1, x, y; i <= m; i++)\n    x = read(), y = read(), add_edge(x, y), add_edge(y, x);\n  int l = 0, r = (int)1e9 + 1, ans = 0;\n  while (l <= r) {\n    int mid = (l + r) / 2;\n    if (check(mid))\n      ans = mid, r = mid - 1;\n    else\n      l = mid + 1;\n  }\n  fw(ans), puts(\"\");\n}\nint T;\nint main() {\n  cin >> T;\n  while (T--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nnamespace atcoder {\nstruct dsu {\n public:\n  dsu() : _n(0) {}\n  explicit dsu(int n) : _n(n), parent_or_size(n, -1) {}\n  int merge(int a, int b) {\n    assert(0 <= a && a < _n);\n    assert(0 <= b && b < _n);\n    int x = leader(a), y = leader(b);\n    if (x == y) return x;\n    if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n    parent_or_size[x] += parent_or_size[y];\n    parent_or_size[y] = x;\n    return x;\n  }\n  bool same(int a, int b) {\n    assert(0 <= a && a < _n);\n    assert(0 <= b && b < _n);\n    return leader(a) == leader(b);\n  }\n  int leader(int a) {\n    assert(0 <= a && a < _n);\n    if (parent_or_size[a] < 0) return a;\n    return parent_or_size[a] = leader(parent_or_size[a]);\n  }\n  int size(int a) {\n    assert(0 <= a && a < _n);\n    return -parent_or_size[leader(a)];\n  }\n  std::vector<std::vector<int>> groups() {\n    std::vector<int> leader_buf(_n), group_size(_n);\n    for (int i = 0; i < _n; i++) {\n      leader_buf[i] = leader(i);\n      group_size[leader_buf[i]]++;\n    }\n    std::vector<std::vector<int>> result(_n);\n    for (int i = 0; i < _n; i++) {\n      result[i].reserve(group_size[i]);\n    }\n    for (int i = 0; i < _n; i++) {\n      result[leader_buf[i]].push_back(i);\n    }\n    result.erase(\n        std::remove_if(result.begin(), result.end(),\n                       [&](const std::vector<int>& v) { return v.empty(); }),\n        result.end());\n    return result;\n  }\n\n private:\n  int _n;\n  std::vector<int> parent_or_size;\n};\n}  // namespace atcoder\nusing namespace atcoder;\nusing namespace std;\nvector<long long> a, b;\nvector<vector<pair<int, int>>> E;\nvector<int> pre;\npair<int, int> pp(-1, -1);\nlong long mid;\nvoid dfs(int cur, vector<vector<pair<int, int>>>& e, int pe, long long curA) {\n  for (int i = 0; i < (e[cur].size()); ++i) {\n    if (pp.first != -1) return;\n    int to = e[cur][i].first, ind = e[cur][i].second;\n    if (ind == pe) continue;\n    if (curA <= a[to]) continue;\n    if (to == 0 || pre[to] != -1) {\n      pp.first = to;\n      pp.second = cur;\n      return;\n    } else {\n      pre[to] = cur;\n      dfs(to, e, ind, curA + b[to]);\n    }\n  }\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  a.resize(n), b.resize(n);\n  a[0] = 0, b[0] = 0;\n  for (int i = 0; i < (n - 1); ++i) {\n    cin >> a[i + 1];\n  }\n  for (int i = 0; i < (n - 1); ++i) {\n    cin >> b[i + 1];\n  }\n  E.assign(n, vector<pair<int, int>>());\n  for (int i = 0; i < (m); ++i) {\n    int x, y;\n    cin >> x >> y;\n    x--;\n    y--;\n    E[x].emplace_back(y, i);\n    E[y].emplace_back(x, i);\n  }\n  long long ok = 1000000001, ng = 0;\n  while (ok - ng > 1LL) {\n    mid = (ok + ng) / 2;\n    dsu D(n);\n    long long cur = mid;\n    bool f = true;\n    auto e = E;\n    while (D.size(0) != n) {\n      pp = make_pair(-1, -1);\n      pre.assign(n, -1);\n      dfs(0, e, -1, cur);\n      if (pp.first == -1) {\n        f = false;\n        break;\n      }\n      {\n        int temp = pp.first;\n        while (temp != -1) {\n          if (!D.same(0, temp)) {\n            D.merge(0, temp);\n            cur += b[temp];\n          }\n          temp = pre[temp];\n        }\n      }\n      {\n        int temp = pp.second;\n        while (temp != -1) {\n          if (!D.same(0, temp)) {\n            D.merge(0, temp);\n            cur += b[temp];\n          }\n          temp = pre[temp];\n        }\n      }\n      vector<vector<pair<int, int>>> ee(n);\n      for (int i = 0; i < (n); ++i) {\n        int from = i;\n        if (D.same(i, 0)) from = 0;\n        for (int j = 0; j < (e[i].size()); ++j) {\n          int to = e[i][j].first, ind = e[i][j].second;\n          if (D.same(to, 0)) to = 0;\n          if (from == to) continue;\n          ee[from].emplace_back(to, ind);\n        }\n      }\n      swap(e, ee);\n    }\n    if (f) {\n      ok = mid;\n    } else {\n      ng = mid;\n    }\n  }\n  cout << ok << endl;\n}\nint main() {\n  int _t;\n  cin >> _t;\n  for (int _ = 0; _ < (_t); ++_) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD = 1000000007;\nvoid err(istream_iterator<string> it) {}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n  cerr << *it << \" = \" << a << endl;\n  err(++it, args...);\n}\nmap<int, int> candidates;\nvector<bool> visited;\nvector<set<long long>> adj;\nvector<long long> a;\nvector<long long> b;\nvoid merge(int x) {\n  candidates.erase(x);\n  for (auto z : adj[x]) {\n    if (!visited[z]) {\n      candidates[z] = x;\n    }\n  }\n}\nlong long dfs(int x, long long power, int prev) {\n  if (a[x] >= power) {\n    return 0;\n  }\n  visited[x] = true;\n  for (auto y : adj[x]) {\n    if (y == prev) {\n      continue;\n    }\n    if (visited[y]) {\n      merge(x);\n      return b[x];\n    }\n    long long inc = dfs(y, power + b[x], x);\n    if (inc > 0) {\n      merge(x);\n      return b[x] + inc;\n    }\n  }\n  visited[x] = false;\n  return 0;\n}\nbool poss(long long power) {\n  long long inc;\n  do {\n    inc = 0;\n    for (auto x : candidates) {\n      inc = dfs(x.first, power, x.second);\n      if (inc > 0) {\n        power += inc;\n        break;\n      }\n    }\n  } while (inc > 0);\n  return candidates.size() == 0;\n}\nvoid Solve() {\n  long long n, m, u, v;\n  cin >> n >> m;\n  adj = vector<set<long long>>(n + 1, set<long long>());\n  a = vector<long long>(n + 1);\n  b = vector<long long>(n + 1);\n  for (int i = 2; i <= n; i++) {\n    cin >> a[i];\n  }\n  for (int i = 2; i <= n; i++) {\n    cin >> b[i];\n  }\n  for (int i = 1; i <= m; i++) {\n    cin >> u >> v;\n    adj[u].insert(v);\n    adj[v].insert(u);\n  }\n  long long left = 1;\n  long long right = 1e9 + 1;\n  while (left < right) {\n    long long mid = (left + right) / 2;\n    candidates = map<int, int>();\n    for (auto ad : adj[1]) {\n      candidates[ad] = 1;\n    }\n    visited = vector<bool>(n + 1, false);\n    visited[1] = true;\n    if (poss(mid)) {\n      right = mid;\n    } else {\n      left = mid + 1;\n    }\n  }\n  cout << left << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  long long ntest;\n  cin >> ntest;\n  for (long long i = 0; i < ntest; i++) {\n    Solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename _Tp>\nvoid read(_Tp &x) {\n  char ch(getchar());\n  bool f(false);\n  while (!isdigit(ch)) f |= ch == 45, ch = getchar();\n  x = ch & 15, ch = getchar();\n  while (isdigit(ch)) x = x * 10 + (ch & 15), ch = getchar();\n  if (f) x = -x;\n}\ntemplate <typename _Tp, typename... Args>\nvoid read(_Tp &t, Args &...args) {\n  read(t);\n  read(args...);\n}\nconst int N = 1005;\nint a[N], b[N], n, Fa[N];\nstd::vector<int> e[N];\nbool used[N], vis[N];\nlong long c;\nbool dfs(int x, int fa, long long cur) {\n  vis[x] = true, Fa[x] = fa;\n  for (auto v : e[x])\n    if (v != fa) {\n      if (used[x] && used[v]) continue;\n      if (!used[x] && used[v]) {\n        for (int u = x; !used[u]; u = Fa[u]) used[u] = true, c += b[u];\n        return 1;\n      } else if (!used[x] && vis[v]) {\n        for (int u = x; !used[u]; u = Fa[u]) used[u] = true, c += b[u];\n        for (int u = v; !used[u]; u = Fa[u]) used[u] = true, c += b[u];\n        return 1;\n      } else if (!vis[v] && cur > a[v] && dfs(v, x, cur + b[v]))\n        return 1;\n    }\n  return 0;\n}\nbool check(int mid) {\n  memset(used, 0, n + 3), used[1] = 1, c = mid;\n  while (std::count(used + 1, used + n + 1, 0)) {\n    memset(vis, 0, n + 3);\n    bool flag = 0;\n    for (int i = 1; i <= n; ++i)\n      if (used[i] && dfs(i, 0, c)) {\n        flag = 1;\n        break;\n      }\n    if (!flag) return 0;\n  }\n  return 1;\n}\nvoid MAIN() {\n  int m;\n  read(n, m);\n  for (int i = 1; i <= n; ++i) e[i].clear();\n  for (int i = 2; i <= n; ++i) read(a[i]);\n  for (int i = 2; i <= n; ++i) read(b[i]);\n  for (int i = 1, x, y; i <= m; ++i)\n    read(x, y), e[x].push_back(y), e[y].push_back(x);\n  int l = 0, r = 1e9 + 1, mid = (l + r) >> 1;\n  while (l < r) mid = (l + r) >> 1, check(mid) ? r = mid : l = mid + 1;\n  printf(\"%d\\n\", l);\n}\nint main() {\n  int _;\n  read(_);\n  while (_--) MAIN();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::bitset;\nusing std::pair;\nusing std::priority_queue;\nusing std::vector;\nconst int N = 1005;\nint T, n, m, a[N], b[N], id[N][2];\nlong long dis[N][2], tot, tota;\nbitset<N> st[N][2];\npriority_queue<pair<long long, int> > q;\nvector<int> e[N], eid[N];\nvoid dij(int s, long long k) {\n  for (int i = 1; i <= n; ++i) {\n    dis[i][0] = dis[i][1] = 0;\n    id[i][0] = id[i][1] = 0;\n    st[i][0].reset(), st[i][1].reset();\n  }\n  dis[s][0] = k;\n  st[s][0].set(s);\n  q.push(std::make_pair(k, s << 1));\n  while (!q.empty()) {\n    auto tmp = q.top();\n    q.pop();\n    int u = tmp.second >> 1, t = tmp.second & 1;\n    if (dis[u][t] != tmp.first) continue;\n    for (int i = 0; i < e[u].size(); ++i)\n      if (eid[u][i] != id[u][t]) {\n        int v = e[u][i], first = eid[u][i];\n        if (!st[u][t].test(v) && a[v] >= dis[u][t]) continue;\n        if (dis[v][0] < dis[u][t] + (st[u][t][v] ? 0 : b[v])) {\n          if (id[v][0] != first) {\n            id[v][1] = id[v][0];\n            dis[v][1] = dis[v][0];\n            st[v][1] = st[v][0];\n          }\n          id[v][0] = first;\n          dis[v][0] = dis[u][t] + (st[u][t][v] ? 0 : b[v]);\n          st[v][0] = st[u][t];\n          st[v][0].set(v);\n          q.push(std::make_pair(dis[v][0], v << 1));\n        } else if (id[v][0] != first &&\n                   dis[v][1] < dis[u][t] + (st[u][t][v] ? 0 : b[v])) {\n          id[v][1] = first;\n          dis[v][1] = dis[u][t] + (st[u][t][v] ? 0 : b[v]);\n          st[v][1] = st[u][t];\n          st[v][1].set(v);\n          q.push(std::make_pair(dis[v][1], v << 1 | 1));\n        }\n      }\n  }\n}\nbool chk(long long k) {\n  dij(1, k);\n  for (int i = 1; i <= n; ++i)\n    if (dis[i][0] == tot + k) return 1;\n  return 0;\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    for (int i = 1; i <= n; ++i) e[i].clear(), eid[i].clear();\n    scanf(\"%d%d\", &n, &m);\n    tot = tota = 0;\n    for (int i = 2; i <= n; ++i) scanf(\"%d\", a + i), tota += a[i];\n    for (int i = 2; i <= n; ++i) scanf(\"%d\", b + i), tot += b[i];\n    for (int i = 1, first, second; i <= m; ++i) {\n      scanf(\"%d%d\", &first, &second);\n      e[first].push_back(second), e[second].push_back(first);\n      eid[first].push_back(i), eid[second].push_back(i);\n    }\n    long long l = 0, r = tota + 1;\n    while (l < r) {\n      long long mid = (l + r) >> 1;\n      if (chk(mid))\n        r = mid;\n      else\n        l = mid + 1;\n    }\n    printf(\"%lld\\n\", l);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nbool chkmax(T &x, T y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <typename T>\nbool chkmin(T &x, T y) {\n  return x > y ? x = y, true : false;\n}\nusing namespace std;\nlong long ksm(long long a, long long b) {\n  if (!b) return 1;\n  long long ns = ksm(a, b >> 1);\n  ns = ns * ns % 998244353;\n  if (b & 1) ns = ns * a % 998244353;\n  return ns;\n}\nint n, m, a[4005], b[4005], u[4005], v[4005], dis[4005], lst[4005];\nlong long power;\nint cur;\nbool vis[4005];\nvector<pair<int, int> > e[4005];\nvector<int> E[4005];\nlong long refresh() {\n  for (int i = 1; i <= n; i++) {\n    E[i].clear();\n    for (auto x : e[i]) E[i].push_back(x.second);\n  }\n  long long del = 1 << 30;\n  queue<int> q;\n  for (auto x : E[1])\n    if (dis[x] <= power)\n      q.push(x);\n    else\n      del = min(del, dis[x] - power);\n  E[1].clear();\n  while (!q.empty()) {\n    int id = q.front();\n    q.pop();\n    if (!vis[v[id]]) {\n      vis[v[id]] = 1;\n      power += b[v[id]];\n      del = -1;\n      return del;\n    }\n    bool rid = false;\n    for (auto x : E[v[id]]) {\n      if (x == (id ^ 1)) {\n        rid = true;\n        continue;\n      }\n      if (dis[x] <= power)\n        q.push(x);\n      else\n        del = min(del, dis[x] - power);\n    }\n    E[v[id]].clear();\n    if (rid) E[v[id]].push_back(id ^ 1);\n  }\n  return del;\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) e[i].clear(), vis[i] = 0;\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &a[i]), a[i] += 1;\n  for (int i = 2; i <= n; i++) scanf(\"%d\", &b[i]);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &u[2 * i], &v[2 * i]);\n    u[2 * i + 1] = v[2 * i];\n    v[2 * i + 1] = u[2 * i];\n    e[u[2 * i]].push_back(make_pair(v[2 * i], 2 * i));\n    e[u[2 * i + 1]].push_back(make_pair(v[2 * i + 1], 2 * i + 1));\n  }\n  for (int i = 0; i < 2 * m; i++) dis[i] = a[v[i]];\n  for (int r = 0; r < 2 * m; r++) {\n    memcpy(lst, dis, sizeof lst);\n    for (int i = 1; i <= n; i++) {\n      pair<int, int> m1(1 << 30, -1), m2(1 << 30, -1);\n      for (auto x : e[i]) {\n        if (lst[x.second] < m2.first) m2 = {lst[x.second], x.second};\n        if (m2 < m1) swap(m2, m1);\n      }\n      for (auto x : e[i]) {\n        int id = x.second ^ 1;\n        if (m1.second == x.second)\n          dis[id] = max(lst[id], m2.first - b[i]);\n        else\n          dis[id] = max(lst[id], m1.first - b[i]);\n      }\n    }\n  }\n  cur = 0;\n  power = 0;\n  while (true) {\n    int del = refresh();\n    if (del == (1 << 30)) break;\n    if (del > 0) {\n      cur += del;\n      power += del;\n    }\n  }\n  printf(\"%d\\n\", cur);\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  for (int i = 0; i < T; i++) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline char gc() {\n  static char buf[100000], *p1 = buf, *p2 = buf;\n  return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)\n             ? EOF\n             : *p1++;\n}\ninline long long read() {\n  char c = getchar();\n  long long su = 0, f = 1;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') f = -1;\n  for (; c >= '0' && c <= '9'; c = getchar()) su = su * 10 + c - '0';\n  return su * f;\n}\ninline void write(long long x) {\n  if (x < 0) {\n    putchar('-');\n    write(-x);\n    return;\n  }\n  if (x >= 10) write(x / 10);\n  putchar(x % 10 + '0');\n}\ninline void writesp(long long x) { write(x), putchar(' '); }\ninline void writeln(long long x) {\n  write(x);\n  putchar('\\n');\n}\nlong long f[100005], vis[100005], pre[100005], dis[100005], a[100005],\n    b[100005], L, R, ans;\nlong long n, m;\nqueue<long long> q;\nvector<long long> G[100005];\nlong long check(long long x) {\n  memset(f, 0, sizeof(f));\n  f[1] = 1;\n  while (1) {\n    long long sm = 0;\n    for (long long i = 1; i <= n; i++) vis[i] = f[i], pre[i] = 0, sm += f[i];\n    if (sm == n) return 1;\n    for (long long i = 1; i <= n; i++)\n      if (f[i]) q.push(i), dis[i] = x;\n    long long U = 0, V = 0;\n    while (!q.empty()) {\n      long long u = q.front();\n      q.pop();\n      for (auto v : G[u]) {\n        if (f[v] && f[u]) continue;\n        if (dis[u] <= a[v] || pre[u] == v) continue;\n        if (vis[v]) {\n          U = u;\n          V = v;\n          break;\n        }\n        dis[v] = dis[u] + b[v];\n        vis[v] = 1;\n        q.push(v);\n        pre[v] = u;\n      }\n      if (U) break;\n    }\n    while (!q.empty()) q.pop();\n    if (!U) return 0;\n    for (; !f[U]; U = pre[U]) f[U] = 1, x += b[U];\n    for (; !f[V]; V = pre[V]) f[V] = 1, x += b[V];\n  }\n}\nsigned main() {\n  long long T = read();\n  while (T--) {\n    n = read(), m = read();\n    for (long long i = 2; i <= n; i++) a[i] = read();\n    for (long long i = 2; i <= n; i++) b[i] = read();\n    for (long long i = 1; i <= m; i++) {\n      long long u = read(), v = read();\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n    L = 0, R = 1e14;\n    ans = 0;\n    while (L <= R) {\n      long long mid = L + (R - L) / 2;\n      if (check(mid))\n        ans = mid, R = mid - 1;\n      else\n        L = mid + 1;\n    }\n    writeln(ans);\n    for (long long i = 1; i <= n; i++) G[i].clear();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nvoid sc(int &x) { scanf(\"%d\", &x); }\nvoid sc(int &x, int &y) { scanf(\"%d%d\", &x, &y); }\nvoid sc(int &x, int &y, int &z) { scanf(\"%d%d%d\", &x, &y, &z); }\nvoid sc(long long &x) { scanf(\"%lld\", &x); }\nvoid sc(long long &x, long long &y) { scanf(\"%lld%lld\", &x, &y); }\nvoid sc(long long &x, long long &y, long long &z) {\n  scanf(\"%lld%lld%lld\", &x, &y, &z);\n}\nvoid sc(char *x) { scanf(\"%s\", x); }\nvoid sc(char *x, char *y) { scanf(\"%s%s\", x, y); }\nvoid sc(char *x, char *y, char *z) { scanf(\"%s%s%s\", x, y, z); }\nvoid out(int x) { printf(\"%d\\n\", x); }\nvoid out(long long x) { printf(\"%lld\\n\", x); }\nvoid out(int x, int y) { printf(\"%d %d\\n\", x, y); }\nvoid out(long long x, long long y) { printf(\"%lld %lld\\n\", x, y); }\nvoid out(int x, int y, int z) { printf(\"%d %d %d\\n\", x, y, z); }\nvoid out(long long x, long long y, long long z) {\n  printf(\"%lld %lld %lld\\n\", x, y, z);\n}\nvoid ast(long long x, long long l, long long r) { assert(x >= l && x <= r); }\nusing namespace std;\nconst int N = 2e3 + 5, mod = 998244353;\nint n, m, a[N], b[N];\nvector<int> e[N];\nbool vis[N], vv[N];\nint sp, pre[N];\nvector<int> vc;\nbool dfs(int u, int fa, int p) {\n  vv[u] = true;\n  for (int v : e[u])\n    if (!vis[v] && v != fa && p > a[v]) {\n      if (vv[v]) {\n        int x = u;\n        while (!vis[x]) {\n          vis[x] = true;\n          vc.push_back(x);\n          sp += b[x];\n          sp = min(sp, 1000000001);\n          x = pre[x];\n        }\n        x = v;\n        while (!vis[x]) {\n          vis[x] = true;\n          vc.push_back(x);\n          sp += b[x];\n          sp = min(sp, 1000000001);\n          x = pre[x];\n        }\n        return true;\n      }\n      pre[v] = u;\n      if (dfs(v, u, min(1000000001, p + b[v]))) return true;\n    } else if (vis[v] && v != fa && !vis[u]) {\n      int x = u;\n      while (!vis[x]) {\n        vis[x] = true;\n        vc.push_back(x);\n        sp += b[x];\n        sp = min(sp, 1000000001);\n        x = pre[x];\n      }\n      return true;\n    }\n  return false;\n}\nbool judge(int p) {\n  for (int i = 1; i <= n; i++) vis[i] = false;\n  vc.clear();\n  vis[1] = true;\n  vc.push_back(1);\n  bool flag = true;\n  while (flag) {\n    flag = false;\n    for (int i = 1; i <= n; i++) vv[i] = false;\n    for (int x : vc)\n      if (dfs(x, 0, p)) {\n        flag = true;\n        p += sp;\n        p = min(p, 1000000001);\n        sp = 0;\n        break;\n      }\n  }\n  for (int i = 1; i <= n; i++)\n    if (!vis[i]) return false;\n  return true;\n}\nvoid sol(int cas) {\n  sc(n, m);\n  for (int i = 2; i <= n; i++) sc(a[i]);\n  for (int i = 2; i <= n; i++) sc(b[i]);\n  for (int i = 1; i <= n; i++) e[i].clear();\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    sc(u, v);\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  int l = 1, r = 1e9;\n  r++;\n  while (l < r) {\n    int m = (l + r) >> 1;\n    if (judge(m))\n      r = m;\n    else\n      l = m + 1;\n  }\n  out(r);\n}\nint main() {\n  srand(time(0));\n  int t = 1, cas = 0;\n  scanf(\"%d\", &t);\n  while (t--) {\n    sol(++cas);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1005;\nint n, m, a[N], b[N];\nstd::vector<int> adj[N];\nbool used[N];\nstd::vector<int> store;\nint pre[N];\nstd::pair<int, long long> que[N];\nint l, r;\nbool check(int init) {\n  std::fill(used + 1, used + 1 + n, false);\n  used[1] = 1;\n  store.clear();\n  store.push_back(1);\n  long long power = init;\n  while ((int)store.size() != n) {\n    l = 1, r = 0;\n    for (int i = 0; i < (int)store.size(); i++)\n      que[++r] = std::make_pair(-store[i], power);\n    std::fill(pre + 1, pre + 1 + n, false);\n    int s = 0, t = 0;\n    while (l <= r) {\n      int x = que[l].first;\n      bool f = x > 0;\n      x = std::abs(x);\n      long long p = que[l++].second;\n      for (int e = 0; e < (int)adj[x].size(); e++) {\n        int y = adj[x][e];\n        if (pre[x] == y || a[y] >= p) continue;\n        if (pre[y] || (used[y] && f)) {\n          s = x, t = y;\n          break;\n        }\n        if (used[y]) continue;\n        pre[y] = x;\n        que[++r] = std::make_pair(y, p + b[y]);\n      }\n      if (s && t) break;\n    }\n    if (!s && !t) break;\n    do {\n      if (!used[s]) {\n        store.push_back(s);\n        used[s] = 1, power += b[s];\n      }\n    } while (s = pre[s]);\n    do {\n      if (!used[t]) {\n        store.push_back(t);\n        used[t] = 1, power += b[t];\n      }\n    } while (t = pre[t]);\n  }\n  if ((int)store.size() != n) return false;\n  return true;\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 2; i <= n; i++) scanf(\"%d\", a + i);\n  for (int i = 2; i <= n; i++) scanf(\"%d\", b + i);\n  for (int i = 1, u, v; i <= m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    adj[u].push_back(v), adj[v].push_back(u);\n  }\n  int lb = 0, ub = 1e9 + 1, best = -1;\n  while (lb <= ub) {\n    int mid = (lb + ub) >> 1;\n    if (check(mid))\n      ub = mid - 1, best = mid;\n    else\n      lb = mid + 1;\n  }\n  printf(\"%d\\n\", best);\n  for (int i = 1; i <= n; i++) adj[i].clear();\n}\nsigned main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\nstring to_string(const string &s) { return '\"' + s + '\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) res += static_cast<char>('0' + v[i]);\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) res += \", \";\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\nclass DSU {\n public:\n  DSU(long long n, const vector<long long> &a) : num_comp_(n), root_(n + 1, 0) {\n    ls_.resize(n + 1);\n    a_.resize(n + 1);\n    for (long long i = 1; i <= n; i++) {\n      ls_[i].push_back(i);\n      a_[i] = a[i];\n    }\n  }\n  long long num_comp() { return num_comp_; }\n  long long a(long long u) { return a_[u]; }\n  vector<long long> &ls(long long u) { return ls_[u]; }\n  long long GetRoot(long long u) {\n    return root_[u] ? root_[u] = GetRoot(root_[u]) : u;\n  }\n  bool Unite(long long u, long long v) {\n    u = GetRoot(u);\n    v = GetRoot(v);\n    if (u == v) return 0;\n    a_[v] += a_[u];\n    if (ls_[v].size() < ls_[u].size()) {\n      swap(ls_[u], ls_[v]);\n    }\n    ls_[v].insert(ls_[v].end(), ls_[u].begin(), ls_[u].end());\n    ls_[u].clear();\n    root_[u] = v;\n    num_comp_--;\n    return 1;\n  }\n\n private:\n  long long num_comp_;\n  vector<long long> a_;\n  vector<long long> root_;\n  vector<vector<long long>> ls_;\n};\nvoid Solve(long long test) {\n  long long n, m;\n  cin >> n >> m;\n  vector<long long> a(n + 1, 0);\n  for (long long i = 2; i <= n; i++) {\n    cin >> a[i];\n  }\n  vector<long long> b(n + 1, 0);\n  for (long long i = 2; i <= n; i++) {\n    cin >> b[i];\n  }\n  vector<vector<pair<long long, long long>>> adj(\n      n + 1, vector<pair<long long, long long>>());\n  for (long long i = 1; i <= m; i++) {\n    long long u, v;\n    cin >> u >> v;\n    adj[u].push_back({v, i});\n    adj[v].push_back({u, i});\n  }\n  auto Check = [&](long long init_value) -> bool {\n    b[1] = init_value;\n    DSU dsu(n, b);\n    while (dsu.num_comp() > 1) {\n      queue<long long> q;\n      vector<long long> d(n + 1, -1);\n      vector<long long> last_edge(n + 1, -1);\n      vector<long long> last_ver(n + 1, -1);\n      vector<long long> cur(n + 1, 0);\n      auto root = dsu.GetRoot(1);\n      cur[root] = dsu.a(root);\n      d[root] = 0;\n      q.push(root);\n      bool found_loop = false;\n      pair<long long, long long> loop;\n      while (!q.empty() && !found_loop) {\n        long long u = q.front();\n        q.pop();\n        for (long long node_u : dsu.ls(u)) {\n          for (auto [node_v, edge_id] : adj[node_u]) {\n            auto v = dsu.GetRoot(node_v);\n            if (u == v) continue;\n            if (last_edge[u] == edge_id) continue;\n            if (cur[u] <= a[node_v]) continue;\n            if (d[v] == -1) {\n              d[v] = d[u] + 1;\n              last_edge[v] = edge_id;\n              last_ver[v] = u;\n              cur[v] = cur[u] + dsu.a(v);\n              q.push(v);\n            } else {\n              found_loop = true;\n              loop = {u, v};\n              break;\n            }\n          }\n          if (found_loop) {\n            break;\n          }\n        }\n      }\n      if (!found_loop) {\n        break;\n      }\n      auto [u, v] = loop;\n      auto Go = [&](long long u) {\n        while (u != -1) {\n          dsu.Unite(u, root);\n          u = last_ver[u];\n        }\n      };\n      Go(u);\n      Go(v);\n    }\n    return dsu.num_comp() == 1;\n  };\n  long long low = 0, high = *max_element(a.begin(), a.end()) + 1;\n  while (high - low > 1) {\n    long long mid = low + high >> 1;\n    if (Check(mid)) {\n      high = mid;\n    } else {\n      low = mid;\n    }\n  }\n  cout << high << '\\n';\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  long long tc;\n  cin >> tc;\n  for (long long test = 1; test <= tc; ++test) Solve(test);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1100;\nvector<int> nxt[N];\ninline void link(int u, int v) { nxt[u].push_back(v); }\nint n, tag[N], vis[N], fa[N], a[N], b[N];\nvoid dfs(int x, int f, ll val) {\n  if (val <= a[x]) return;\n  vis[x] = 1, fa[x] = f;\n  for (int v : nxt[x])\n    if (v != f) {\n      if (!vis[v])\n        dfs(v, x, val + b[x]);\n      else\n        throw make_pair(x, v);\n    }\n}\nint find(ll &val) {\n  for (int i = 1; i <= n; i++) vis[i] = tag[i];\n  try {\n    for (int i = 1; i <= n; i++)\n      if (tag[i])\n        for (int v : nxt[i])\n          if (!tag[v]) dfs(v, i, val);\n  } catch (pair<int, int> pr) {\n    int v = pr.first, w = pr.second;\n    for (int x = w; !tag[x]; x = fa[x]) tag[x] = 1, val += b[x];\n    for (int x = v; !tag[x]; x = fa[x]) tag[x] = 1, val += b[x];\n    return 1;\n  }\n  return 0;\n}\nint test(int x) {\n  ll val = x;\n  for (int i = 1; i <= n; i++) tag[i] = 0;\n  tag[1] = 1;\n  while (find(val))\n    ;\n  for (int i = 1; i <= n; i++)\n    if (!tag[i]) return 0;\n  return 1;\n}\nvoid solve() {\n  int m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) nxt[i].clear();\n  for (int i = 2; i <= n; i++) scanf(\"%d\", a + i);\n  for (int i = 2; i <= n; i++) scanf(\"%d\", b + i);\n  for (int i = 1, u, v; i <= m; i++)\n    scanf(\"%d %d\", &u, &v), link(u, v), link(v, u);\n  int l = 0, r = 1000000000, ans = r + 1;\n  while (l <= r) {\n    int m = (l + r) >> 1;\n    if (test(m))\n      ans = m, r = m - 1;\n    else\n      l = m + 1;\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  int t;\n  for (scanf(\"%d\", &t); t; t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long tt;\n  cin >> tt;\n  while (tt--) {\n    long long n, m;\n    cin >> n >> m;\n    vector<long long> a(n), b(n);\n    for (long long i = 1; i < n; ++i) cin >> a[i];\n    for (long long i = 1; i < n; ++i) cin >> b[i];\n    vector<vector<long long>> edg(n);\n    for (long long i = 0; i < m; ++i) {\n      long long u, v;\n      cin >> u >> v;\n      --u, --v;\n      edg[u].push_back(v);\n      edg[v].push_back(u);\n    }\n    function<long long(long long)> solve = [&](long long cur) {\n      vector<long long> act(n, 0), acts;\n      act[0] = 1;\n      acts.push_back(0);\n      while (acts.size() != n) {\n        vector<long long> vis = act;\n        vector<long long> pre(n, -1);\n        function<void(long long)> dod = [&](long long u) {\n          if (act[u]) return;\n          cur += b[u];\n          act[u] = 1;\n          acts.push_back(u);\n          if (pre[u] != -1) dod(pre[u]);\n        };\n        long long gre = 1;\n        function<void(long long, long long, long long)> dfs =\n            [&](long long u, long long p, long long meja) {\n              vis[u] = 1;\n              pre[u] = p;\n              meja += b[u];\n              for (auto&& v : edg[u])\n                if (gre and v != p) {\n                  if (gre and vis[v])\n                    gre = 0, dod(u), dod(v);\n                  else if (gre and meja > a[v])\n                    dfs(v, u, meja);\n                }\n            };\n        for (auto&& u : acts)\n          if (gre)\n            for (auto&& v : edg[u])\n              if (gre and !act[v] and cur > a[v]) {\n                dfs(v, u, cur);\n                if (!gre) break;\n              }\n        if (gre) return (long long)0;\n      }\n      return (long long)1;\n    };\n    long long l = 0, r = 1000000001;\n    while (l < r) {\n      long long mid = (l + r) / 2;\n      if (solve(mid))\n        r = mid;\n      else\n        l = mid + 1;\n    }\n    cout << l << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll INF = (ll)1e9 + 7;\nconst int N = 1000;\nvector<pair<ll, int>> g[N];\nint zc[N];\nbool used[N];\nll as[N];\nll bs[N];\nll min_str[N];\nint pre[N];\nll res_a;\nll res_b;\npair<int, int> dfs(ll ini, int n) {\n  for (int i = 0; i < n; ++i) {\n    pre[i] = -1;\n    min_str[i] = INF;\n  }\n  min_str[0] = ini;\n  vector<int> que;\n  for (int t = 0; t < n; ++t) {\n    if (zc[t] == -1 || used[t] || as[t] >= ini) continue;\n    min_str[t] = ini;\n    if (zc[t] == -2) {\n      pre[t] = 0;\n      return {t, 0};\n    } else {\n      pre[t] = zc[t];\n      que.push_back(t);\n    }\n  }\n  for (int j = 0; j < que.size(); ++j) {\n    int i = que[j];\n    ll cur = min_str[i] + bs[i];\n    for (auto pr : g[i]) {\n      int t = pr.second;\n      if (as[t] >= cur) break;\n      if (t == pre[i]) continue;\n      if (pre[t] != -1 || used[t]) return {t, i};\n      pre[t] = i;\n      min_str[t] = cur;\n      que.push_back(t);\n    }\n  }\n  return {-1, -1};\n}\nvoid makeUsed(int i) {\n  res_b += bs[i];\n  used[i] = 1;\n  for (auto pr : g[i]) {\n    if (zc[pr.second] == -1)\n      zc[pr.second] = i;\n    else\n      zc[pr.second] = -2;\n  }\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  as[0] = 0;\n  bs[0] = 0;\n  for (int i = 0; i < n; ++i) zc[i] = -1;\n  for (int i = 1; i < n; ++i) cin >> as[i];\n  for (int i = 1; i < n; ++i) cin >> bs[i];\n  for (int i = 0; i < m; ++i) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    --y;\n    g[x].emplace_back(as[y], y);\n    g[y].emplace_back(as[x], x);\n  }\n  for (int i = 0; i < n; ++i) sort(g[i].begin(), g[i].end());\n  ll tot = 0;\n  for (int i = 0; i < n; ++i) tot += bs[i];\n  res_a = 0;\n  res_b = 0;\n  makeUsed(0);\n  while (res_b < tot) {\n    ll low = res_a + res_b;\n    ll high = max(low, INF);\n    while (low != high) {\n      ll ini = (low + high) >> 1;\n      pair<int, int> off = dfs(ini, n);\n      if (off.first == -1)\n        low = ini + 1;\n      else\n        high = ini;\n    }\n    res_a = low - res_b;\n    pair<int, int> off = dfs(low, n);\n    int x = off.first;\n    int y = off.second;\n    while (!used[x]) {\n      makeUsed(x);\n      x = pre[x];\n    }\n    while (!used[y]) {\n      makeUsed(y);\n      y = pre[y];\n    }\n  }\n  cout << res_a << '\\n';\n  for (int i = 0; i < n; ++i) {\n    g[i].clear();\n    g[i].shrink_to_fit();\n    used[i] = 0;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  for (int ti = 0; ti < t; ++ti) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint min(int a, int b) { return a < b ? a : b; }\nint max(int a, int b) { return a > b ? a : b; }\nunsigned int X;\nvoid srand_() {\n  struct timeval tv;\n  gettimeofday(&tv, NULL);\n  X = tv.tv_sec ^ tv.tv_usec | 1;\n}\nint rand_() { return (X *= 3) >> 1; }\nint *ej[1000], eo[1000];\nvoid append(int i, int j) {\n  int o = eo[i]++;\n  if (o >= 2 && (o & o - 1) == 0)\n    ej[i] = (int *)realloc(ej[i], o * 2 * sizeof *ej[i]);\n  ej[i][o] = j;\n}\nint aa[1000], bb[1000], ii[1000], n;\nint compare(int i, int j) { return aa[i] != aa[j] ? aa[i] - aa[j] : i - j; }\nvoid sort(int *ii, int l, int r) {\n  while (l < r) {\n    int i = l, j = l, k = r, i_ = ii[l + rand_() % (r - l)], tmp;\n    while (j < k) {\n      int c = compare(ii[j], i_);\n      if (c == 0)\n        j++;\n      else if (c < 0) {\n        tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;\n        i++, j++;\n      } else {\n        k--;\n        tmp = ii[j], ii[j] = ii[k], ii[k] = tmp;\n      }\n    }\n    sort(ii, l, i);\n    l = k;\n  }\n}\nchar visited[1000];\nint qu[1000], cnt;\nint i_;\nvoid dfs1(int i) {\n  int o;\n  if (visited[i] || compare(i, i_) > 0) return;\n  visited[i] = 1;\n  qu[cnt++] = i;\n  for (o = eo[i]; o--;) {\n    int j = ej[i][o];\n    dfs1(j);\n  }\n}\nchar add[1000];\nint cc[1000][1000];\nvoid dfs2(int p, int i, int c) {\n  int o;\n  for (o = eo[i]; o--;) {\n    int j = ej[i][o];\n    if (j != p) {\n      if (compare(j, i_) > 0)\n        cc[i_][j] = max(cc[i_][j], c);\n      else\n        dfs2(i, j, min(c + bb[j], 0x3f3f3f3f));\n    }\n  }\n}\nint dp[1000];\nint solve(int s) {\n  int g;\n  memset(dp, 0, n * sizeof *dp), dp[0] = s;\n  for (g = 0; g < n; g++) {\n    int i_ = ii[g], x = dp[i_], j;\n    if (x == 0) continue;\n    for (j = 0; j < n; j++)\n      if (compare(i_, j) < 0 && cc[i_][j] != -1) {\n        int c = add[i_] ? min(x + cc[i_][j], 0x3f3f3f3f)\n                        : min(s + cc[i_][j], 0x3f3f3f3f);\n        if (c >= aa[j]) dp[j] = max(dp[j], min(c + bb[j], 0x3f3f3f3f));\n      }\n  }\n  return dp[ii[n - 1]] > 0;\n}\nint main() {\n  int t;\n  srand_();\n  scanf(\"%d\", &t);\n  while (t--) {\n    static int qu_[1000], dd[1000], pp[1000];\n    int m, g, h, i, j, o, cnt_, lower, upper;\n    scanf(\"%d%d\", &n, &m);\n    aa[0] = 0;\n    for (i = 1; i < n; i++) scanf(\"%d\", &aa[i]), aa[i]++;\n    for (i = 1; i < n; i++) scanf(\"%d\", &bb[i]);\n    for (i = 0; i < n; i++) ej[i] = (int *)malloc(2 * sizeof *ej[i]), eo[i] = 0;\n    for (h = 0; h < m; h++) {\n      scanf(\"%d%d\", &i, &j), i--, j--;\n      append(i, j), append(j, i);\n    }\n    for (i = 0; i < n; i++) ii[i] = i;\n    sort(ii, 0, n);\n    for (g = 0; g < n; g++) {\n      i_ = ii[g];\n      memset(visited, 0, n * sizeof *visited), cnt = 0;\n      memset(cc[i_], -1, n * sizeof *cc[i_]);\n      dfs1(0);\n      if (visited[i_]) {\n        int tree, p;\n        memset(dd, 0, n * sizeof *dd);\n        memset(pp, -1, n * sizeof *pp);\n        for (h = 0; h < cnt; h++) {\n          i = qu[h];\n          for (o = eo[i]; o--;) {\n            j = ej[i][o];\n            if (visited[j]) dd[i]++;\n          }\n        }\n        cnt_ = 0;\n        for (h = 0; h < cnt; h++) {\n          i = qu[h];\n          if (dd[i] == 1) qu_[cnt_++] = i;\n        }\n        while (cnt_) {\n          i = qu_[--cnt_];\n          dd[i] = -1;\n          for (o = eo[i]; o--;) {\n            j = ej[i][o];\n            if (dd[j] > 0) {\n              pp[i] = j;\n              if (--dd[j] == 1) qu_[cnt_++] = j;\n            }\n          }\n        }\n        tree = 1;\n        for (h = 0; h < cnt; h++) {\n          i = qu[h];\n          if (dd[i] > 0) {\n            tree = 0;\n            break;\n          }\n        }\n        p = -1, i = 0;\n        while (i != -1 && dd[i] <= 0 && i != i_) p = i, i = pp[i];\n        add[i_] = 1;\n        if (dd[i_] <= 0 && i != i_)\n          dfs2(pp[i_], i_, 0);\n        else if (tree)\n          dfs2(p, i_, 0);\n        else {\n          int c;\n          add[i_] = 0;\n          c = 0;\n          for (i = 0; i != -1 && dd[i] <= 0; i = pp[i])\n            c = min(c + bb[i], 0x3f3f3f3f);\n          for (h = 0; h < cnt; h++) {\n            i = qu[h];\n            if (dd[i] > 0) c = min(c + bb[i], 0x3f3f3f3f);\n          }\n          for (p = -1, i = 0; i != -1 && dd[i] <= 0; p = i, i = pp[i])\n            for (o = eo[i]; o--;) {\n              j = ej[i][o];\n              if (compare(j, i_) > 0)\n                cc[i_][j] = max(cc[i_][j], c);\n              else if (j != pp[i] && j != p)\n                dfs2(i, j, min(c + bb[j], 0x3f3f3f3f));\n            }\n          for (h = 0; h < cnt; h++) {\n            i = qu[h];\n            if (dd[i] > 0)\n              for (o = eo[i]; o--;) {\n                j = ej[i][o];\n                if (compare(j, i_) > 0)\n                  cc[i_][j] = max(cc[i_][j], c);\n                else if (pp[j] == i && j != p)\n                  dfs2(i, j, min(c + bb[j], 0x3f3f3f3f));\n              }\n          }\n        }\n      }\n    }\n    lower = 0, upper = 0x3f3f3f3f;\n    while (upper - lower > 1) {\n      int s = (lower + upper) / 2;\n      if (solve(s))\n        upper = s;\n      else\n        lower = s;\n    }\n    printf(\"%d\\n\", upper);\n    for (i = 0; i < n; i++) free(ej[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int c = 2005;\nint w, n, m;\nlong long aa[c], bb[c];\nvector<int> sz[c];\nint cnt, fel[c];\nlong long pl[c];\nbool v[c], kesz[c];\nvoid add(int a, long long &val) {\n  kesz[a] = 1;\n  cnt++;\n  val += bb[a];\n}\nbool solve2(long long &val) {\n  queue<int> q;\n  for (int i = 1; i <= n; i++) {\n    v[i] = 0, pl[i] = 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (kesz[i]) {\n      q.push(i);\n      v[i] = 1;\n    }\n  }\n  while (q.size() > 0) {\n    int a = q.front();\n    q.pop();\n    for (auto x : sz[a]) {\n      if (x == fel[a] || kesz[a] && kesz[x]) {\n        continue;\n      }\n      if (val + pl[a] > aa[x]) {\n        if (!v[x]) {\n          v[x] = 1;\n          fel[x] = a, pl[x] = pl[a] + bb[x];\n          q.push(x);\n        } else {\n          int s1 = a, s2 = x;\n          while (!kesz[s1]) {\n            add(s1, val);\n            s1 = fel[s1];\n          }\n          while (!kesz[s2]) {\n            add(s2, val);\n            s2 = fel[s2];\n          }\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nbool solve(long long val) {\n  kesz[1] = 1, cnt = 1;\n  while (solve2(val)) {\n  }\n  for (int i = 1; i <= n; i++) {\n    kesz[i] = 0;\n  }\n  return (cnt == n);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> w;\n  for (int tc = 1; tc <= w; tc++) {\n    cin >> n >> m;\n    for (int i = 2; i <= n; i++) {\n      cin >> aa[i];\n    }\n    for (int i = 2; i <= n; i++) {\n      cin >> bb[i];\n    }\n    for (int i = 1; i <= m; i++) {\n      int a, b;\n      cin >> a >> b;\n      sz[a].push_back(b), sz[b].push_back(a);\n    }\n    int lo = 0, hi = 1e9 + 5, mid;\n    while (hi - lo > 1) {\n      mid = (hi + lo) / 2;\n      if (solve(mid)) {\n        hi = mid;\n      } else {\n        lo = mid;\n      }\n    }\n    cout << hi << \"\\n\";\n    for (int i = 1; i <= n; i++) {\n      sz[i].clear();\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') x = x * 10 + (c - '0'), c = getchar();\n  return f * x;\n}\nlong long min(long long a, long long b) { return a < b ? a : b; }\nlong long max(long long a, long long b) { return a > b ? a : b; }\ntemplate <typename T>\nbool umin(T& a, T t) {\n  if (a > t) return a = t, 1;\n  return 0;\n}\ntemplate <typename T>\nbool umax(T& a, T t) {\n  if (a < t) return a = t, 1;\n  return 0;\n}\nconst int MAXN = 200011;\nstd::vector<int> g[MAXN];\nbool used[MAXN];\nint a[MAXN], b[MAXN];\nint pre[MAXN], Q[MAXN], cur[MAXN], maxA;\nint Expand(int u, int v) {\n  int all = cur[u];\n  while (!used[u]) used[u] = 1, u = pre[u];\n  while (!used[v]) used[v] = 1, all = min(maxA, all + b[v]), v = pre[v];\n  return all;\n}\nint main() {\n  int task = read();\n  while (task--) {\n    int n = read(), m = read();\n    maxA = 0;\n    for (int i = 1; i <= n; ++i) g[i].clear();\n    for (int i = 2; i <= n; ++i) a[i] = read(), umax(maxA, a[i] + 1);\n    for (int i = 2; i <= n; ++i) b[i] = read();\n    while (m--) {\n      int u = read(), v = read();\n      g[u].push_back(v), g[v].push_back(u);\n    }\n    int l = 0, r = maxA;\n    while (l < r) {\n      int mid = (l + r) >> 1, all = mid, rest = n - 1;\n      for (int i = 2; i <= n; ++i) used[i] = 0;\n      used[1] = 1;\n      cur[1] = mid;\n      while (rest) {\n        int h = 0, t = 0, flag = 0;\n        for (int i = 1; i <= n; ++i)\n          if (used[i])\n            Q[t++] = i, pre[i] = -1, cur[i] = all;\n          else\n            pre[i] = 0;\n        while (h < t && !flag) {\n          int u = Q[h++];\n          for (auto v : g[u])\n            if (cur[u] > a[v] && v != pre[u]) {\n              if (!pre[v])\n                pre[v] = u, cur[v] = min(maxA, cur[u] + b[v]), Q[t++] = v;\n              else if (pre[u] != -1 && pre[v]) {\n                all = Expand(u, v);\n                flag = 1;\n                break;\n              }\n            }\n        }\n        if (!flag) break;\n        rest = 0;\n        for (int i = 1; i <= n; ++i)\n          if (!used[i]) ++rest;\n      }\n      if (rest)\n        l = mid + 1;\n      else\n        r = mid;\n    }\n    printf(\"%d\\n\", l);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e3 + 10;\nint T, n, m, a[N], b[N], l, r, ins[N], las[N];\nvector<int> to[N];\nstruct node {\n  int u;\n  long long k;\n  bool f;\n};\nnode q[N];\ninline bool check(long long now) {\n  vector<int> s;\n  for (int i = 1; i <= n; ++i) ins[i] = las[i] = 0;\n  s.push_back(1);\n  ins[1] = 1;\n  while (s.size() != n) {\n    memset(las + 1, 0, sizeof(int) * (n));\n    l = 1;\n    r = 0;\n    for (int i : s) q[++r] = (node){i, now, 0};\n    int x = -1, y = -1;\n    while (l <= r) {\n      node p = q[l++];\n      int u = p.u;\n      for (int v : to[u]) {\n        if (v == las[u]) continue;\n        if (p.k <= a[v]) continue;\n        if (las[v] || (ins[v] && p.f)) {\n          x = u;\n          y = v;\n          break;\n        }\n        if (ins[v]) continue;\n        las[v] = u;\n        q[++r] = (node){v, p.k + b[v], 1};\n      }\n      if (x != -1) break;\n    }\n    if (x == -1) return false;\n    while (x) {\n      if (ins[x]) {\n        x = las[x];\n        continue;\n      }\n      ins[x] = 1;\n      s.push_back(x);\n      now += b[x];\n      x = las[x];\n    }\n    while (y) {\n      if (ins[y]) {\n        y = las[y];\n        continue;\n      }\n      ins[y] = 1;\n      s.push_back(y);\n      now += b[y];\n      y = las[y];\n    }\n  }\n  return true;\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 2; i <= n; ++i) scanf(\"%d\", &a[i]);\n    for (int i = 2; i <= n; ++i) scanf(\"%d\", &b[i]);\n    for (int i = 1, u, v; i <= m; ++i) {\n      scanf(\"%d%d\", &u, &v);\n      to[u].push_back(v), to[v].push_back(u);\n    }\n    int l = 0, r = 1e9 + 1, ans = 1e9 + 1;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if (check(mid))\n        r = mid - 1, ans = mid;\n      else\n        l = mid + 1;\n    }\n    printf(\"%d\\n\", ans);\n    for (int i = 1; i <= n; ++i) to[i].clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstd::mt19937 rnd(\n    (int)std::chrono::steady_clock::now().time_since_epoch().count());\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nconst int MAXN = 1000;\nint n, m;\nint monster[MAXN];\nint gain[MAXN];\nvector<int> adj[MAXN];\nbool visited[MAXN];\nint prv[MAXN];\nlong long visitpower[MAXN];\nbool can(int startpower) {\n  for (int i = (0); i < (n); ++i) visited[i] = false;\n  visited[0] = true;\n  long long curpower = startpower;\n  while (true) {\n    for (int i = (0); i < (n); ++i) prv[i] = -2;\n    bool change = false;\n    queue<int> q;\n    for (int i = (0); i < (n); ++i)\n      if (visited[i]) prv[i] = -1, visitpower[i] = curpower, q.push(i);\n    while (!q.empty() && !change) {\n      int at = q.front();\n      q.pop();\n      for (int to : adj[at]) {\n        if (visited[at] && visited[to]) continue;\n        if (!visited[to] && visitpower[at] <= monster[to]) continue;\n        if (to == prv[at]) continue;\n        if (prv[to] == -2) {\n          assert(!visited[to]);\n          prv[to] = at, visitpower[to] = visitpower[at] + gain[to], q.push(to);\n        } else {\n          vector<int> path;\n          for (int x = at; x != -1; x = prv[x]) path.push_back(x);\n          reverse(path.begin(), path.end());\n          for (int x = to; x != -1; x = prv[x]) path.push_back(x);\n          if (visitpower[at] < visitpower[to])\n            reverse(path.begin(), path.end());\n          assert(((int)(path).size()) >= 3 && visited[path[0]] &&\n                 visited[path[((int)(path).size()) - 1]]);\n          bool any = false;\n          for (int i = (1); i < (((int)(path).size()) - 1); ++i) {\n            assert(curpower > monster[path[i]]);\n            if (!visited[path[i]]) {\n              curpower += gain[path[i]];\n              visited[path[i]] = true;\n              any = true;\n            }\n          }\n          assert(any);\n          change = true;\n          break;\n        }\n      }\n    }\n    if (!change) break;\n  }\n  for (int i = (0); i < (n); ++i)\n    if (!visited[i]) return false;\n  return true;\n}\nint solve() {\n  int mxmonster = 0;\n  for (int i = (1); i < (n); ++i) mxmonster = max(mxmonster, monster[i]);\n  int lo = 0, hi = mxmonster + 1;\n  while (lo + 1 < hi) {\n    int mi = lo + (hi - lo) / 2;\n    if (can(mi))\n      hi = mi;\n    else\n      lo = mi;\n  }\n  return hi;\n}\nvoid run() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = (1); i < (n); ++i) scanf(\"%d\", &monster[i]);\n  for (int i = (1); i < (n); ++i) scanf(\"%d\", &gain[i]);\n  for (int i = (0); i < (m); ++i) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    --a, --b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  printf(\"%d\\n\", solve());\n  for (int i = (0); i < (n); ++i) adj[i].clear();\n}\nint main() {\n  int ncase;\n  scanf(\"%d\", &ncase);\n  for (int i = (1); i <= (ncase); ++i) run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nnamespace {\nusing LL = long long;\nstruct Solver {\n  int n, m;\n  std::vector<int> a, b;\n  std::vector<std::vector<int>> graph;\n  LL cur = 0;\n  std::vector<char> cycle, instack;\n  bool dfs(int u, int prev) {\n    if (cycle[u] || instack[u]) return true;\n    if (cur <= a[u]) return false;\n    instack[u] = true;\n    cur += b[u];\n    for (int v : graph[u])\n      if (v != prev) {\n        if (dfs(v, u)) {\n          cycle[u] = true;\n          instack[u] = false;\n          return true;\n        }\n      }\n    cur -= b[u];\n    instack[u] = false;\n    return false;\n  }\n  bool ok(int start) {\n    cur = start;\n    std::fill(cycle.begin(), cycle.end(), false);\n    cycle[0] = true;\n    auto aug = [&]() -> bool {\n      for (int u = 0; u < n; ++u)\n        if (cycle[u]) {\n          for (int v : graph[u])\n            if (!cycle[v]) {\n              if (dfs(v, u)) return true;\n            }\n        }\n      return false;\n    };\n    while (aug())\n      ;\n    return std::count(cycle.begin(), cycle.end(), true) == n;\n  }\n  void solve(int ca, std::istream& reader) {\n    reader >> n >> m;\n    a.resize(n);\n    b.resize(n);\n    for (int i = 1; i < n; ++i) {\n      reader >> a[i];\n    }\n    for (int i = 1; i < n; ++i) {\n      reader >> b[i];\n    }\n    graph.resize(n);\n    for (int i = 0; i < m; ++i) {\n      int x, y;\n      reader >> x >> y;\n      --x;\n      --y;\n      graph[x].emplace_back(y);\n      graph[y].emplace_back(x);\n    }\n    cycle.resize(n);\n    instack.resize(n);\n    int l = 0, r = 1e9 + 1;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if (ok(mid))\n        r = mid - 1;\n      else\n        l = mid + 1;\n    }\n    printf(\"%d\\n\", r + 1);\n  }\n};\n}  // namespace\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  std::istream& reader = std::cin;\n  int cas = 1;\n  reader >> cas;\n  for (int ca = 1; ca <= cas; ++ca) {\n    Solver().solve(ca, reader);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\nusing namespace std;\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>\nbool ckmin(T& a, const T& b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char* x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string& x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V>& x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << \", \";\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T& x) {\n  int first = 0;\n  cerr << '{';\n  for (auto& i : x) cerr << (first++ ? \", \" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 2001;\nconst int CAP = 1e9 + 10;\nint N, M;\nvector<vector<int>> og;\nint A[MX], B[MX];\nbool proc[MX];\nvector<vector<int>> graph;\nint basePow;\nint pa[MX];\nint numZ[MX];\nbool dfs(int v, int p, int curPow) {\n  if (curPow <= A[v]) return false;\n  if (pa[v] != -1 || numZ[v] >= 2) {\n    int cur = v;\n    while (cur > 0) {\n      if (!proc[cur]) {\n        proc[cur] = true;\n        basePow += B[cur];\n        ckmin(basePow, CAP);\n        for (auto& a : graph[cur]) {\n          if (a != 0 && numZ[a] == 0) {\n            graph[0].push_back(a);\n            graph[a].push_back(0);\n          }\n          if (a != 0) numZ[a]++;\n        }\n      }\n      cur = pa[cur];\n    }\n    return true;\n  }\n  pa[v] = p;\n  curPow += B[v];\n  ckmin(curPow, CAP);\n  for (auto& a : graph[v]) {\n    if (a == p || (a > 0 && proc[a])) continue;\n    if (dfs(a, v, curPow)) {\n      if (!proc[v]) {\n        proc[v] = true;\n        basePow += B[v];\n        ckmin(basePow, CAP);\n        for (auto& b : graph[v]) {\n          if (b != 0 && numZ[b] == 0) {\n            graph[0].push_back(b);\n            graph[b].push_back(0);\n          }\n          if (b != 0) numZ[b]++;\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n}\nbool ok(int p) {\n  basePow = p;\n  for (int i = 0; i < (N); i++) proc[i] = false;\n  proc[0] = true;\n  graph = og;\n  for (int i = 0; i < (N); i++) numZ[i] = 0;\n  for (auto& a : graph[0]) numZ[a]++;\n  while (true) {\n    for (int i = 0; i < (N); i++) pa[i] = -1;\n    if (!dfs(0, 0, basePow)) {\n      return false;\n    }\n    bool done = true;\n    for (int i = 0; i < (N); i++)\n      if (!proc[i]) done = false;\n    if (done) return true;\n  }\n}\nvoid solve() {\n  cin >> N >> M;\n  og = vector<vector<int>>(N);\n  for (int i = 0; i < (N - 1); i++) {\n    cin >> A[i + 1];\n  }\n  for (int i = 0; i < (N - 1); i++) cin >> B[i + 1];\n  for (int i = 0; i < (M); i++) {\n    int X, Y;\n    cin >> X >> Y;\n    X--;\n    Y--;\n    og[X].push_back(Y);\n    og[Y].push_back(X);\n  }\n  int lo = 0, hi = CAP;\n  while (lo < hi) {\n    int mid = (lo + hi) / 2;\n    if (ok(mid)) {\n      hi = mid;\n    } else\n      lo = mid + 1;\n  }\n  cout << lo << nl;\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin.exceptions(cin.failbit);\n  int T = 1;\n  cin >> T;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e3 + 1e2 + 7;\nlong long T, n, m;\nvector<long long> g[N];\nlong long a[N], b[N];\nlong long ok[N], vis[N];\nlong long tag[N];\nbool dfs(long long x, long long f, long long en, long long nd) {\n  vis[x] = 1;\n  for (auto v : g[x]) {\n    if (v == f) continue;\n    if (vis[v]) {\n      if (nd) {\n        tag[x] = 1;\n        return 1;\n      }\n    } else if (en > a[v]) {\n      long long ret = dfs(v, x, en + b[v] * (!ok[v]), nd | (!ok[v]));\n      if (ret) {\n        tag[x] = 1;\n        return ret;\n      }\n    }\n  }\n  return 0;\n}\nbool chk(long long beg) {\n  fill(ok + 1, ok + n + 1, 0);\n  long long vs = 1;\n  long long now = beg;\n  while (vs != n) {\n    fill(vis + 1, vis + n + 1, 0);\n    fill(tag + 1, tag + n + 1, 0);\n    long long go = dfs(1, 0, now, 0);\n    if (!go) return 0;\n    for (long long i = 2; i <= n; i++)\n      if (tag[i] && !ok[i]) now += b[i], ok[i] = 1, vs++;\n  }\n  return 1;\n}\nsigned main() {\n  scanf(\"%lld\", &T);\n  while (T--) {\n    scanf(\"%lld%lld\", &n, &m);\n    for (long long i = 1; i <= n; i++) g[i].clear();\n    for (long long i = 2; i <= n; i++) scanf(\"%lld\", &a[i]);\n    for (long long i = 2; i <= n; i++) scanf(\"%lld\", &b[i]);\n    for (long long i = 1; i <= m; i++) {\n      long long u, v;\n      scanf(\"%lld%lld\", &u, &v);\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n    long long l = 0, r = *max_element(a + 1, a + n + 1) + 1;\n    while (r - l > 1) {\n      long long mid = (l + r) >> 1;\n      if (chk(mid))\n        r = mid;\n      else\n        l = mid;\n    }\n    printf(\"%lld\\n\", r);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing int64 = long long;\nvoid solve() {\n  int n, m;\n  std::cin >> n >> m;\n  int a[n], b[n];\n  a[0] = b[0] = 0;\n  for (int i = 1; i < n; ++i) std::cin >> a[i], ++a[i];\n  for (int i = 1; i < n; ++i) std::cin >> b[i];\n  std::vector<int> adj[n];\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    std::cin >> u >> v, --u, --v;\n    adj[u].push_back(v), adj[v].push_back(u);\n  }\n  int lo = 1, hi = 1E9 + 1;\n  while (lo < hi) {\n    int x = (lo + hi) / 2;\n    bool vis[n];\n    std::memset(vis, 0, sizeof(vis));\n    vis[0] = true;\n    int cntvis = 1;\n    int64 cur = x;\n    while (cntvis < n) {\n      bool f[n];\n      std::memcpy(f, vis, sizeof(f));\n      int parent[n];\n      std::memset(parent, -1, sizeof(parent));\n      bool nice = 0;\n      std::function<bool(int, int64)> dfs = [&](int u, int64 w) {\n        f[u] = true;\n        w += b[u];\n        for (auto v : adj[u]) {\n          if (v == parent[u] || w < a[v]) continue;\n          if (!f[v]) {\n            parent[v] = u;\n            if (dfs(v, w)) return true;\n          } else {\n            for (int i = u; i != -1; i = parent[i]) {\n              if (!vis[i]) vis[i] = true, ++cntvis, cur += b[i];\n            }\n            for (int i = v; i != -1; i = parent[i]) {\n              if (!vis[i]) vis[i] = true, ++cntvis, cur += b[i];\n            }\n            return true;\n          }\n        }\n        return false;\n      };\n      for (int u = 0; u < n; ++u) {\n        if (!vis[u]) {\n          continue;\n        }\n        for (auto v : adj[u]) {\n          if (vis[v]) continue;\n          if (cur >= a[v]) {\n            parent[v] = u;\n            if (dfs(v, cur) && (nice = true)) break;\n          }\n        }\n        if (nice) break;\n      }\n      if (!nice) break;\n    }\n    if (cntvis == n) {\n      hi = x;\n    } else {\n      lo = x + 1;\n    }\n  }\n  std::cout << lo << \"\\n\";\n}\nint main() {\n  std::ios::sync_with_stdio(0);\n  std::cin.tie(0), std::cout.tie(0);\n  int T;\n  std::cin >> T;\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"unroll-loops\")\nusing namespace std;\nclock_t timeStart, timeFinish;\nvoid timeBegin() { timeStart = clock(); }\nvoid timeEnd() { timeFinish = clock(); }\nvoid timeDuration() {\n  timeEnd();\n  double time_taken = double(timeFinish - timeStart) / double(CLOCKS_PER_SEC);\n  cout << \"Time taken by program is : \" << fixed << time_taken\n       << setprecision(5);\n  cout << \" sec \" << endl;\n}\nclass InputReader {\n public:\n  InputReader() {\n    input_file = stdin;\n    cursor = 0;\n    fread(buffer, SIZE, 1, input_file);\n  }\n  InputReader(const char *file_name) {\n    input_file = fopen(file_name, \"r\");\n    cursor = 0;\n    fread(buffer, SIZE, 1, input_file);\n  }\n  inline InputReader &operator>>(int &n) {\n    while ((buffer[cursor] < '0' || buffer[cursor] > '9') &&\n           buffer[cursor] != '-') {\n      advance();\n    }\n    int sign = 1;\n    if (buffer[cursor] == '-') {\n      sign = -1;\n      advance();\n    }\n    n = 0;\n    while ('0' <= buffer[cursor] && buffer[cursor] <= '9') {\n      n = n * 10 + buffer[cursor] - '0';\n      advance();\n    }\n    n *= sign;\n    return *this;\n  }\n\n private:\n  FILE *input_file;\n  static const int SIZE = 1 << 17;\n  int cursor;\n  char buffer[SIZE];\n  inline void advance() {\n    ++cursor;\n    if (cursor == SIZE) {\n      cursor = 0;\n      fread(buffer, SIZE, 1, input_file);\n    }\n  }\n};\nconst int MAXN = 1000;\nconst int INF = 1000000001;\nint a[1 + MAXN], b[1 + MAXN];\nvector<int> g[1 + MAXN];\nbool taken[1 + MAXN];\nint dad[1 + MAXN], total;\nlong long power;\nbool found;\nvoid take(int node) {\n  while (dad[node] != node) {\n    if (!taken[node]) {\n      taken[node] = true;\n      total++;\n      power += b[node];\n    }\n    node = dad[node];\n  }\n}\nvoid DFS(int node, long long current) {\n  for (auto neighbour : g[node]) {\n    if (dad[neighbour] != 0 && neighbour != dad[node] &&\n        (!taken[node] || !taken[neighbour])) {\n      found = true;\n      take(node);\n      take(neighbour);\n      return;\n    }\n    if (dad[neighbour] == 0 && current > a[neighbour]) {\n      dad[neighbour] = node;\n      DFS(neighbour, current + b[neighbour]);\n    }\n    if (found) {\n      return;\n    }\n  }\n}\nbool check(int n, int start) {\n  for (int i = 1; i <= n; i++) {\n    taken[i] = false;\n  }\n  taken[1] = true;\n  total = 1;\n  power = start;\n  while (total < n) {\n    for (int i = 1; i <= n; i++) {\n      if (taken[i]) {\n        dad[i] = i;\n      } else {\n        dad[i] = 0;\n      }\n    }\n    found = false;\n    for (int i = 1; i <= n && !found; i++) {\n      if (taken[i]) {\n        DFS(i, power);\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n  return true;\n}\nint main() {\n  timeBegin();\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  srand(time(0));\n  int tests;\n  cin >> tests;\n  for (int test = 1; test <= tests; test++) {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 2; i <= n; i++) {\n      cin >> a[i];\n    }\n    for (int i = 2; i <= n; i++) {\n      cin >> b[i];\n    }\n    for (int i = 1; i <= m; i++) {\n      int a, b;\n      cin >> a >> b;\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n    int left = 1, right = INF, answer = INF;\n    while (left <= right) {\n      int middle = (left + right) / 2;\n      if (check(n, middle)) {\n        answer = middle;\n        right = middle - 1;\n      } else {\n        left = middle + 1;\n      }\n    }\n    cout << answer << \"\\n\";\n    for (int i = 1; i <= n; i++) {\n      g[i].clear();\n    }\n  }\n  return 0;\n}\n"
        }
    ]
}