{
    "name": "580_B. Kefa and Company",
    "source": "CODEFORCES",
    "description": "Kefa wants to celebrate his first big salary by going to restaurant. However, he needs company. \n\nKefa has n friends, each friend will agree to go to the restaurant if Kefa asks. Each friend is characterized by the amount of money he has and the friendship factor in respect to Kefa. The parrot doesn't want any friend to feel poor compared to somebody else in the company (Kefa doesn't count). A friend feels poor if in the company there is someone who has at least d units of money more than he does. Also, Kefa wants the total friendship factor of the members of the company to be maximum. Help him invite an optimal company!\n\nInput\n\nThe first line of the input contains two space-separated integers, n and d (1 \u2264 n \u2264 105, <image>) \u2014 the number of Kefa's friends and the minimum difference between the amount of money in order to feel poor, respectively.\n\nNext n lines contain the descriptions of Kefa's friends, the (i + 1)-th line contains the description of the i-th friend of type mi, si (0 \u2264 mi, si \u2264 109) \u2014 the amount of money and the friendship factor, respectively. \n\nOutput\n\nPrint the maximum total friendship factir that can be reached.\n\nExamples\n\nInput\n\n4 5\n75 5\n0 100\n150 20\n75 1\n\n\nOutput\n\n100\n\n\nInput\n\n5 100\n0 7\n11 32\n99 10\n46 8\n87 54\n\n\nOutput\n\n111\n\nNote\n\nIn the first sample test the most profitable strategy is to form a company from only the second friend. At all other variants the total degree of friendship will be worse.\n\nIn the second sample test we can take all the friends.",
    "difficulty": "B",
    "tags": [
        "binary search",
        "sortings",
        "two pointers"
    ],
    "rating": 1500,
    "public_test": [
        {
            "input": "5 100\n0 7\n11 32\n99 10\n46 8\n87 54\n",
            "output": "111"
        },
        {
            "input": "4 5\n75 5\n0 100\n150 20\n75 1\n",
            "output": "100"
        }
    ],
    "generated_test": [
        {
            "input": "5 9\n0 98\n2 1000000000\n8 1000000000\n5 999999999\n3 1489916668\n",
            "output": "4489916765\n"
        },
        {
            "input": "4 1\n2 4\n2 2\n1 3\n3 3\n",
            "output": "6\n"
        },
        {
            "input": "3 1\n801 10100\n802 134509124\n801 1\n",
            "output": "134509124\n"
        },
        {
            "input": "3 3\n4 15\n0 17\n6 11\n",
            "output": "26\n"
        },
        {
            "input": "15 1234\n2738 365370390\n1160 970909702\n2594 902749351\n3126 324754476\n3151 177963947\n3424 396145897\n5578 737768323\n3423 687640543\n381 848813098\n1058 197211286\n936 650181776\n1025 776492538\n3598 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3677320675\n"
        },
        {
            "input": "5 1\n5 9\n2 10\n8 5\n18 13\n1 1\n",
            "output": "13\n"
        },
        {
            "input": "8 5\n3 227589091\n12 131068951\n8 291000839\n20 918918112\n11 6972428\n20 585402296\n12 220234661\n1 225083234\n",
            "output": "1504320408\n"
        },
        {
            "input": "5 10\n8 90\n1009 1000000\n14 121\n10 298\n0 109092\n",
            "output": "1000000\n"
        },
        {
            "input": "1 1000000000\n15 20\n",
            "output": "20\n"
        },
        {
            "input": "5 100\n0 7\n11 32\n99 10\n46 2\n87 54\n",
            "output": "105\n"
        },
        {
            "input": "4 5\n75 5\n0 100\n179 20\n75 1\n",
            "output": "100\n"
        },
        {
            "input": "5 10\n8 90\n1009 1001000\n14 121\n10 298\n0 109092\n",
            "output": "1001000\n"
        },
        {
            "input": "5 100\n0 7\n11 32\n168 10\n46 2\n87 54\n",
            "output": "95\n"
        },
        {
            "input": "4 5\n75 5\n0 110\n179 20\n75 1\n",
            "output": "110\n"
        },
        {
            "input": "8 5\n3 227589091\n12 131068951\n8 291000839\n20 25503219\n11 6972428\n20 585402296\n12 114701518\n1 225083234\n",
            "output": "610905515\n"
        },
        {
            "input": "5 100\n0 9\n11 32\n168 10\n46 2\n87 54\n",
            "output": "97\n"
        },
        {
            "input": "8 5\n3 227589091\n12 131068951\n8 291000839\n29 25503219\n11 8756474\n20 585402296\n12 114701518\n1 225083234\n",
            "output": "585402296\n"
        },
        {
            "input": "15 1234\n2738 365370390\n1091 680412079\n3762 902749351\n3126 324754476\n5847 177963947\n3424 396145897\n5578 737768323\n3755 687640543\n381 848813098\n1058 197211286\n936 829986595\n1025 776492538\n3598 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3499356728\n"
        },
        {
            "input": "5 9\n0 98\n2 1000000000\n8 1000000000\n5 999999999\n3 15331851\n",
            "output": "3015331948\n"
        },
        {
            "input": "4 1\n2 6\n2 2\n3 3\n3 3\n",
            "output": "8\n"
        },
        {
            "input": "3 1\n801 10101\n802 246867226\n801 1\n",
            "output": "246867226\n"
        },
        {
            "input": "3 3\n4 5\n0 17\n9 11\n",
            "output": "17\n"
        },
        {
            "input": "15 1234\n2738 322313356\n1160 970909702\n2594 902749351\n3126 324754476\n3151 177963947\n3424 396145897\n5578 737768323\n3423 687640543\n381 848813098\n1058 197211286\n936 650181776\n1025 982858164\n3598 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3682173966\n"
        },
        {
            "input": "5 1\n5 9\n2 3\n8 5\n18 12\n1 1\n",
            "output": "12\n"
        },
        {
            "input": "4 2\n10909234 9\n10909236 8\n10167263 10\n10909235 98\n",
            "output": "107\n"
        },
        {
            "input": "1 1000000000\n15 1\n",
            "output": "1\n"
        },
        {
            "input": "5 100\n0 7\n11 32\n99 10\n46 8\n87 13\n",
            "output": "70\n"
        },
        {
            "input": "5 9\n0 98\n2 1000000000\n8 0000000000\n5 999999999\n3 1489916668\n",
            "output": "3489916765\n"
        },
        {
            "input": "3 1\n801 10100\n802 70503936\n801 1\n",
            "output": "70503936\n"
        },
        {
            "input": "15 1234\n2738 365370390\n1160 970909702\n2594 145443401\n3126 324754476\n3151 177963947\n3424 396145897\n5578 737768323\n3423 687640543\n381 848813098\n1058 197211286\n936 650181776\n1025 776492538\n3598 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3475808340\n"
        },
        {
            "input": "5 1\n5 9\n2 10\n8 5\n18 25\n1 1\n",
            "output": "25\n"
        },
        {
            "input": "5 100\n0 7\n11 32\n168 10\n46 3\n87 54\n",
            "output": "96\n"
        },
        {
            "input": "15 1234\n2738 365370390\n1160 680412079\n2594 902749351\n3126 324754476\n3151 177963947\n3424 396145897\n5578 737768323\n3423 687640543\n381 848813098\n1058 197211286\n936 829986595\n1025 776492538\n808 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3535144131\n"
        },
        {
            "input": "8 5\n3 227589091\n12 131068951\n8 291000839\n20 25503219\n11 6972428\n20 457192047\n12 114701518\n1 225083234\n",
            "output": "543743736\n"
        },
        {
            "input": "15 1234\n2738 365370390\n1160 680412079\n2594 902749351\n3126 347138217\n3151 177963947\n3424 396145897\n5578 737768323\n3755 687640543\n381 848813098\n1058 197211286\n936 829986595\n1025 776492538\n3598 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3699704416\n"
        },
        {
            "input": "4 1\n2 4\n2 2\n1 6\n3 3\n",
            "output": "6\n"
        },
        {
            "input": "3 1\n801 10100\n1454 134509124\n801 1\n",
            "output": "134509124\n"
        },
        {
            "input": "3 3\n8 15\n0 17\n6 11\n",
            "output": "26\n"
        },
        {
            "input": "15 1234\n2738 365370390\n1160 970909702\n2594 902749351\n3126 324754476\n3151 177963947\n3424 396145897\n5578 737768323\n3423 687640543\n381 848813098\n1058 197211286\n936 829986595\n1025 776492538\n3598 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3677320675\n"
        },
        {
            "input": "5 1\n5 3\n2 10\n8 5\n18 13\n1 1\n",
            "output": "13\n"
        },
        {
            "input": "8 5\n3 227589091\n12 131068951\n8 291000839\n20 918918112\n11 6972428\n20 585402296\n12 114701518\n1 225083234\n",
            "output": "1504320408\n"
        },
        {
            "input": "1 1000000000\n19 20\n",
            "output": "20\n"
        },
        {
            "input": "2 1\n2 4\n2 2\n1 6\n3 3\n",
            "output": "6\n"
        },
        {
            "input": "3 2\n801 10100\n1454 134509124\n801 1\n",
            "output": "134509124\n"
        },
        {
            "input": "15 1234\n2738 365370390\n1160 680412079\n2594 902749351\n3126 324754476\n3151 177963947\n3424 396145897\n5578 737768323\n3423 687640543\n381 848813098\n1058 197211286\n936 829986595\n1025 776492538\n3598 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3677320675\n"
        },
        {
            "input": "4 5\n75 5\n0 110\n179 20\n100 1\n",
            "output": "110\n"
        },
        {
            "input": "2 1\n2 4\n2 2\n1 6\n3 2\n",
            "output": "6\n"
        },
        {
            "input": "15 1234\n2738 365370390\n1160 680412079\n2594 902749351\n3126 324754476\n3151 177963947\n3424 396145897\n5578 737768323\n3755 687640543\n381 848813098\n1058 197211286\n936 829986595\n1025 776492538\n3598 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3677320675\n"
        },
        {
            "input": "8 5\n3 227589091\n12 131068951\n8 291000839\n20 25503219\n11 8756474\n20 585402296\n12 114701518\n1 225083234\n",
            "output": "610905515\n"
        },
        {
            "input": "2 1\n2 4\n2 2\n1 6\n4 2\n",
            "output": "6\n"
        },
        {
            "input": "15 1234\n2738 365370390\n1160 680412079\n3762 902749351\n3126 324754476\n3151 177963947\n3424 396145897\n5578 737768323\n3755 687640543\n381 848813098\n1058 197211286\n936 829986595\n1025 776492538\n3598 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3677320675\n"
        },
        {
            "input": "15 1234\n2738 365370390\n1091 680412079\n3762 902749351\n3126 324754476\n3151 177963947\n3424 396145897\n5578 737768323\n3755 687640543\n381 848813098\n1058 197211286\n936 829986595\n1025 776492538\n3598 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3677320675\n"
        },
        {
            "input": "8 5\n3 227589091\n12 89525763\n8 291000839\n29 25503219\n11 8756474\n20 585402296\n12 114701518\n1 225083234\n",
            "output": "585402296\n"
        },
        {
            "input": "8 5\n3 227589091\n12 89525763\n8 291000839\n29 25503219\n11 8756474\n20 585402296\n12 172711181\n1 225083234\n",
            "output": "585402296\n"
        },
        {
            "input": "15 1234\n2738 365370390\n953 680412079\n3762 902749351\n3126 324754476\n5847 177963947\n3424 396145897\n5578 737768323\n3755 687640543\n381 848813098\n1058 197211286\n936 829986595\n1025 776492538\n3598 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3499356728\n"
        },
        {
            "input": "8 5\n3 227589091\n12 19086443\n8 291000839\n29 25503219\n11 8756474\n20 585402296\n12 172711181\n1 225083234\n",
            "output": "585402296\n"
        },
        {
            "input": "8 5\n3 227589091\n12 19086443\n8 291000839\n29 25503219\n9 8756474\n20 585402296\n12 172711181\n1 225083234\n",
            "output": "585402296\n"
        },
        {
            "input": "8 5\n3 227589091\n12 19086443\n8 291000839\n58 25503219\n9 8756474\n20 585402296\n12 172711181\n1 225083234\n",
            "output": "585402296\n"
        },
        {
            "input": "8 5\n3 227589091\n12 18498253\n8 291000839\n58 25503219\n9 8756474\n20 585402296\n12 172711181\n1 225083234\n",
            "output": "585402296\n"
        },
        {
            "input": "8 5\n3 227589091\n12 18498253\n8 291000839\n58 25503219\n9 9933363\n20 585402296\n12 172711181\n1 225083234\n",
            "output": "585402296\n"
        },
        {
            "input": "8 5\n3 227589091\n5 131068951\n8 492784630\n20 918918112\n11 6972428\n20 585402296\n12 220234661\n1 225083234\n",
            "output": "1504320408\n"
        },
        {
            "input": "5 10\n8 90\n1009 1000000\n9 121\n10 298\n-1 109092\n",
            "output": "1000000\n"
        },
        {
            "input": "4 5\n75 5\n0 100\n150 20\n75 2\n",
            "output": "100\n"
        },
        {
            "input": "4 1\n2 4\n2 2\n1 5\n3 3\n",
            "output": "6\n"
        },
        {
            "input": "3 3\n4 15\n0 25\n6 11\n",
            "output": "26\n"
        },
        {
            "input": "8 5\n3 227589091\n13 131068951\n8 291000839\n20 918918112\n11 6972428\n20 585402296\n12 220234661\n1 225083234\n",
            "output": "1504320408\n"
        },
        {
            "input": "5 12\n8 90\n1009 1000000\n14 121\n10 298\n0 109092\n",
            "output": "1000000\n"
        },
        {
            "input": "1 1000100000\n15 20\n",
            "output": "20\n"
        },
        {
            "input": "5 100\n0 7\n11 32\n99 10\n8 2\n87 54\n",
            "output": "105\n"
        },
        {
            "input": "4 5\n75 5\n0 000\n179 20\n75 1\n",
            "output": "20\n"
        },
        {
            "input": "4 1\n2 4\n4 2\n1 6\n3 3\n",
            "output": "6\n"
        },
        {
            "input": "3 1\n801 10100\n1454 134509124\n1510 1\n",
            "output": "134509124\n"
        },
        {
            "input": "3 3\n8 15\n1 17\n6 11\n",
            "output": "26\n"
        },
        {
            "input": "15 1234\n2738 365370390\n1160 68890665\n2594 902749351\n3126 324754476\n3151 177963947\n3424 396145897\n5578 737768323\n3423 687640543\n381 848813098\n1058 197211286\n936 829986595\n1025 776492538\n3598 142176544\n3595 680519527\n1191 32199940\n",
            "output": "3677320675\n"
        },
        {
            "input": "5 1\n5 3\n2 10\n9 5\n18 13\n1 1\n",
            "output": "13\n"
        },
        {
            "input": "8 5\n3 227589091\n1 131068951\n8 291000839\n20 918918112\n11 6972428\n20 585402296\n12 114701518\n1 225083234\n",
            "output": "1504320408\n"
        },
        {
            "input": "5 10\n8 90\n1009 1001000\n11 121\n10 298\n0 109092\n",
            "output": "1001000\n"
        },
        {
            "input": "1 1000000000\n19 8\n",
            "output": "8\n"
        },
        {
            "input": "4 7\n75 5\n0 110\n179 20\n75 1\n",
            "output": "110\n"
        },
        {
            "input": "3 3\n801 10100\n1454 134509124\n801 1\n",
            "output": "134509124\n"
        },
        {
            "input": "5 100\n0 9\n11 32\n151 10\n46 2\n87 54\n",
            "output": "97\n"
        },
        {
            "input": "4 5\n75 1\n0 110\n179 20\n100 1\n",
            "output": "110\n"
        }
    ],
    "solution": [
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\nfriends = {}\nfor _ in range(n):\n    a,b = map(int, raw_input().split())\n    if a not in friends:\n        friends[a] = 0\n    friends[a] += b\nfriends = sorted([(k,friends[k]) for k in friends], key = (lambda x: x[0]))\n\n# import pudb;pu.db\nmax_res = 0\nstart, end = 0,0\nwhile end != len(friends):\n    if friends[end][0] - friends[start][0] < d:\n        end += 1\n    else:\n        tmp_res = 0\n        for j in xrange(start, end):\n             tmp_res += friends[j][1]\n        if tmp_res > max_res:\n            max_res = tmp_res\n        while friends[end][0] - friends[start][0] >= d:\n            start += 1\ntmp_res = 0\nfor j in xrange(start, end):\n     tmp_res += friends[j][1]\nif tmp_res > max_res:\n    max_res = tmp_res        \nprint max_res\n"
        },
        {
            "language": 1,
            "solution": "n,d=map(int, raw_input().split())\nl=[]\nfor i in xrange(n):\n    a,b=map(int, raw_input().split())\n    l.append([a,b])\nl=sorted(l)\nz=i=j=c=0\nwhile i<n:\n    if l[i][0] - l[j][0] <d:\n        c+=l[i][1]\n        i+=1\n    else:\n        c-=l[j][1]\n        j+=1\n    if c>z:\n        z=c\nprint z"
        },
        {
            "language": 4,
            "solution": "/******************************************************************************\n\n                            Online Java Compiler.\n                Code, Compile, Run and Debug java program online.\nWrite your code in this editor and press \"Run\" button to execute it.\n\n*******************************************************************************/\nimport java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) {\n\t    Scanner scan=new Scanner(System.in);\n\t    int n=scan.nextInt();\n\t    int d=scan.nextInt();\n\t    Node[] arr=new Node[n];\n\t    for(int i=0;i<n;i++){\n\t        int money=scan.nextInt();\n\t        int friendshipFactor=scan.nextInt();\n\t        arr[i]=new Node(money,friendshipFactor);\n\t    }\n\t    Arrays.sort(arr, (a,b)-> b.money-a.money);\n\t   // Arrays.stream(arr).forEach(i->System.out.println(i.money+\" \"+i.friendshipFactor));\n\t    int low=0;\n\t    int high=0;\n\t    long ans=0;\n\t    long sum=0;\n\t    while(low<n){\n\t        while(high<n && Math.abs(arr[high].money-arr[low].money)<d){\n\t            sum=sum+arr[high].friendshipFactor;\n\t            high++;\n\t        }\n\t        ans=Math.max(ans,sum);\n\t        sum-=arr[low].friendshipFactor;\n\t        low++;\n\t    }\n\t    System.out.println(ans);\n\t    \n\t}\n\tstatic class Node{\n\t    int money;\n\t    int friendshipFactor;\n\t    public Node(int money, int friendshipFactor){\n\t        this.money=money;\n\t        this.friendshipFactor=friendshipFactor;\n\t    }\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\n\nv = []\nfor i in range(0, n):\n    a, b = map(int, input().split())\n    v.append((a, b))\n\nv = sorted(v)\n\n\nlo = 0\ntotalFriendship = v[0][1]\nbestFriendship = totalFriendship\n\nfor i in range(1, n):\n    while v[i][0] - v[lo][0] >= d:\n        totalFriendship -= v[lo][1]\n        lo += 1\n    totalFriendship += v[i][1]\n\n    bestFriendship = max(bestFriendship, totalFriendship)\n\nprint(bestFriendship)\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\t\n\tstatic class Pair<K, V> {\n\t\tK left;\n\t\tV right;\n\t\tpublic Pair(K left, V right) {\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t}\n\t\n//\tpublic static boolean bSearchCheck(int dif, int lo, int hi, long c, Pair<Long, Long>[] P) {\n//\t\twhile(hi>=lo) {\n//\t\t\tint m = lo + ((hi-lo)/2);\n//\t\t\tlong mid = P[m].left;\n//\t\t\tif(Math.abs(c-mid) > dif) return false;\n//\t\t\telse {\n//\t\t\t\thi = m-1;\n//\t\t\t}\n//\t\t}\n//\t\treturn true;\n//\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tFastReader f = new FastReader();\n\t\tint F = f.nextInt();\n\t\tint dif = f.nextInt();\n\t\tPair<Long, Long>[] P = (Pair<Long, Long>[]) new Pair[F];\n\t\tfor(int i=0; i<F; i++) {\n\t\t\tP[i] = new Pair((long) f.nextInt(), (long) f.nextInt());\n\t\t}\n\t\tArrays.sort(P, (Pair<Long, Long> a, Pair<Long, Long> b) -> Long.compare(a.left, b.left));\n\t\tlong max = Long.MIN_VALUE;\n\t\tlong sum = 0;\n\t\tint l = 0;\n\t\tint r = 0;\n\t\twhile(l < P.length && r < P.length) {\n\t\t\t//boolean check = bSearchCheck(dif, l, r, P[r].left, P);\n\t\t\t//System.out.println(check);\n\t\t\tif(P[r].left - P[l].left < dif) {\n\t\t\t\tsum += P[r].right;\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum -= P[l].right;\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif(sum > max) max = sum;\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\nconst int MAXN = 100000 + 1000;\nstruct node {\n  long long m, s;\n  bool operator<(const node& b) const { return m < b.m; }\n} num[MAXN];\nlong long sum[MAXN];\nlong long M[MAXN];\nint n, d;\nint main() {\n  while (scanf(\"%d%d\", &n, &d) != EOF) {\n    for (int i = 1; i <= n; i++) scanf(\"%I64d%I64d\", &num[i].m, &num[i].s);\n    sort(num + 1, num + n + 1);\n    sum[0] = 0;\n    M[0] = 0;\n    for (int i = 1; i <= n; i++) M[i] = num[i].m;\n    M[n + 1] = INF;\n    for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + num[i].s;\n    sum[n + 1] = sum[n];\n    long long ans = 0;\n    for (int i = 1; i <= n + 1; i++) {\n      int s = i - 1;\n      int e = ((long long)upper_bound(M + 1, M + n + 2,\n                                      (long long)M[i] + (long long)d - 1) -\n               (long long)(M + 1)) /\n              sizeof(long long);\n      long long temp = sum[e] - sum[s];\n      ans = max(ans, temp);\n    }\n    printf(\"%I64d\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "z,zz=input,lambda:list(map(int,z().split()))\nzzz=lambda:[int(i) for i in stdin.readline().split()]\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom string import *\nfrom re import *\nfrom collections import *\nfrom queue import *\nfrom sys import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom itertools import *\nfrom bisect import *\nfrom collections import Counter as cc\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom itertools import accumulate as ac\ndef lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))\ndef prime(x):\n    p=ceil(x**.5)+1\n    for i in range(2,p):\n        if (x%i==0 and x!=2) or x==0:return 0\n        \n    return 1\ndef dfs(u,visit,graph):\n    visit[u]=True\n    for i in graph[u]:\n        if not visit[i]:\n            dfs(i,visit,graph)\n\n###########################---Test-Case---#################################\n\"\"\"\n\n\n\n\"\"\"\n###########################---START-CODING---##############################\n\nn,m=zz()\nlst=[]\nfor _ in range(n):\n    lst.append(zz())\n\nlst=sorted(lst)\n\nans=0\nl=0\ns=0\n\nfor r in range(n):\n    while lst[r][0]-lst[l][0]>=m:\n        s-=lst[l][1]\n        l+=1\n    s+=lst[r][1]\n    ans=max(ans,s)\nprint(ans)\n\n\n\n\n\n\n\n\n    \n\n \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct man {\n  long long int m, s, I;\n};\nman a[131072];\nbool cmp(man a, man b) {\n  if (a.m < b.m) return true;\n  if (a.m > b.m) return false;\n  if (a.I > b.I) return true;\n  if (a.I < b.I) return false;\n}\nint main() {\n  queue<man> x;\n  long long int n, d, i, tbr = 0, maxbr = 0;\n  cin >> n >> d;\n  for (i = 0; i < n; i++) {\n    cin >> a[i].m >> a[i].s;\n    a[i].I = i;\n  }\n  sort(a, a + n, cmp);\n  for (i = 0; i < n; i++) {\n    x.push(a[i]);\n    struct man m = x.front(), m2 = x.back();\n    while (m2.m - m.m >= d) {\n      tbr -= m.s;\n      x.pop();\n      m = x.front();\n      m2 = x.back();\n    }\n    tbr += m2.s;\n    if (tbr > maxbr) maxbr = tbr;\n  }\n  cout << maxbr << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "friends = []\nn, d = map(int, input().split())\nfor i in range(n):\n    friends.append(tuple(map(int, input().split())))\n\nfriends.sort()\nsums = [friends[0][1]]\nfor i in range(1, n):\n    sums.append(sums[i - 1] + friends[i][1])\n\nl = r = 0\nanswer = 0\nwhile l <= n - 1 and r <= n - 1:\n    if friends[r][0] - friends[l][0] < d:\n        if sums[r] - sums[l] + friends[l][1] > answer:\n            answer = sums[r] - sums[l] + friends[l][1]\n        r += 1\n    elif l <= r - 1:\n        l += 1\n    else:\n        r += 1\n\nprint(answer)\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\nn, d = map(int, sys.stdin.readline().split())\nfriends = []\nfor i in range(n):\n    m, s = map(int, sys.stdin.readline().split())\n    friends.append((m, s))\n\nfriends.sort(key = lambda x:x[0])\nleft = 0\nright = 0\nans = 0\ncur = 0\nwhile left < n:\n    while right < n and friends[right][0] - friends[left][0] < d:\n        cur += friends[right][1]\n        right += 1\n    if cur > ans:\n        ans = cur\n\n    cur -= friends[left][1]\n    left += 1\n\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class KefaCompany {\n    static long [] preCalc;\n    static int d;\n    static Friend[] friends;\n    public static void main(String[] args) throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        d = Integer.parseInt(st.nextToken());\n        friends = new Friend[n];\n        preCalc = new long[n];\n        for(int i=0; i<n; i++){\n            st = new StringTokenizer(br.readLine());\n            int m = Integer.parseInt(st.nextToken());\n            int f = Integer.parseInt(st.nextToken());\n            friends[i] = new Friend(m,f);\n        }\n        Arrays.sort(friends);\n        preCalc[0] = friends[0].f;\n        for(int i=1; i<n; i++)\n            preCalc[i] = friends[i].f + preCalc[i-1];\n        \n        long max = 0;\n        for(int i=0; i<n; i++){\n            int j = getFarthest(i);\n            long maxF = preCalc[j-1];\n            if(i!=0)\n                maxF -= preCalc[i-1];\n            if(maxF>max)\n                max = maxF;\n            \n                \n        }\n        System.out.println(max);\n        \n\n    }\n    \n    \n    private static int getFarthest(int i) {\n        int lower = i;\n        int upper = friends.length-1;\n        int ans = 0;\n        while(lower<=upper){\n            int mid = (lower + upper)/2;\n            \n            if(friends[mid].m - friends[i].m >= d){\n                upper = mid - 1;\n            }\n            else\n                ans = lower = mid + 1;\n        }\n        return ans;\n    }\n\n\n    static class Friend implements Comparable<Friend>{\n        int m;\n        int f;\n        public Friend(int m, int f){\n            this.m = m;\n            this.f = f;\n        }\n        @Override\n        public int compareTo(Friend f) {\n            return this.m - f.m;\n        }\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\na=[]\nfor i in range(n):\n    a.append([])\nfor i in range(n):\n    a[i]=list(map(int,input().split()))\n    a[i].append(i)\na.sort()\ni=0\nmx=0\nx=a[i][0]\ns=a[i][1]\nj=1\nwhile j!=n:\n    if a[j][0]-x<d:\n        s+=a[j][1]\n        mx=max(s,mx)\n        j+=1\n    else:\n        mx=max(s,mx)\n        s-=a[i][1]\n        i+=1\n        x=a[i][0]\n    \n        \nprint(max(mx,s))"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n\n/**\n * Pick questions that you love and solve them with love, try to get AC in one\n * go with cleanest code Just one thing to keep in mind these questions should\n * be out of your reach, which make you step out of comfort zone Try to pick\n * them from different topics CP is a sport, enjoy it. Don't make it pressure\n * cooker or job ****Use pen and paper************* check few examples analyze\n * them, some not given in sample also analyze then code Use pen and paper.\n * Solve on paper then code. If there is some reasoning e.g. sequence/paths, try\n * printing first 100 elements or 100 answers using brute and observe.\n * *********Read question with extreme caution. Mistake is happening here which\n * costs time, WA and easy problem not getting solved.********* Sometimes we\n * make question complex due to misunderstanding. Prefix sum and suffix sum is\n * highly usable concept, look for it. Think of cleanest approach. If too many\n * if else are coming then its indication of WA. Solve 1-2 more questions than\n * you solved during contest.\n */\npublic class Codeforces {\n\n\tprivate static final String NEWLINE = \"\\n\";\n\tprivate static final String SPACE = \" \";\n\n\tpublic static void main(String args[]) throws IOException {\n//\t\tFastReader in = new FastReader(); use in case of millions of strings\n\t\tReader in = new Reader();\n//\t\tint t = in.nextInt();\n//\t\twhile (t-->0) {\n\t\t\tint n = in.nextInt();\n\t\t\tlong d = in.nextLong();\n\t\t\tPair prs[] = new Pair[n];\n\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\tprs[i] = new Pair(in.nextLong(), in.nextLong());\n\t\t\t}\n\t\t\t\n\t\t\tArrays.parallelSort(prs, new Pair.PairComparatorX());\n\t\t\tlong pref[] = new long[n];\n\t\t\tpref[0] = prs[0].y;\n\t\t\tfor (int i=1;i<n;i++) pref[i] = pref[i-1] + prs[i].y;\n\t\t\t\n\t\t\tlong max = 0;\n\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\tint s = i;\n\t\t\t\tint e = bs(prs, n, s, d);\n\t\t\t\tif (s == 0) {\n\t\t\t\t\tif (pref[e]>max) max = pref[e];\n\t\t\t\t} else if (pref[e]-pref[s-1]>max) max = pref[e]-pref[s-1];\n\t\t\t}\n\t\t\tSystem.out.println(max);\n//\t\t\twhile (l<n) {\n//\t\t\t\tint curr = l;\n//\t\t\t\tif (l+1<n && d>Math.abs(prs[l+1].x-prs[l].x)) {\n//\t\t\t\t\tlong fs = prs[l].y;\n//\t\t\t\t\tlong start = prs[l].x;\n//\t\t\t\t\twhile (l+1<n && d>Math.abs(prs[l+1].x-start)) {\n//\t\t\t\t\t\tl++;\n//\t\t\t\t\t\tfs = fs + prs[l].y;\n//\t\t\t\t\t}\n//\t\t\t\t\tif (fs>max) max = fs;\n//\t\t\t\t} else {\n//\t\t\t\t\tif (prs[l].y>max) max = prs[l].y;\n//\t\t\t\t}\n//\t\t\t\tl = curr+1;\n//\t\t\t}\n//\t\t\tSystem.out.println(max);\n//\t\t}\n\t\tin.close();\n\t}\n\t\n\tprivate static int bs(Pair[] prs, int n, int s, long d) {\n\t\tlong k = prs[s].x+d;\n\t\tif (s+1>=n) return s;\n\t\tif (prs[s+1].x >= k) return s;\n\t\t\n\t\tint l = s, r = n-1, ind = s;\n\t\twhile (l<=r) {\n\t\t\tint mid = l + (r-l)/2;\n\t\t\tif (prs[mid].x<k) {\n\t\t\t\tind = mid;\n\t\t\t\tl = mid+1;\n\t\t\t} else r = mid-1;\n\t\t}\n\t\treturn ind;\n\t}\n\n\tstatic class Pair {\n\t\tLong x;\n\t\tLong y;\n\n\t\tprivate Pair(Long x, Long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o == null || !(o instanceof Pair))\n\t\t\t\treturn false;\n\t\t\tPair cor = (Pair) o;\n\t\t\treturn x.equals(cor.x) && y.equals(cor.y);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tint result = 17;\n\t\t\treturn result;\n\t\t}\n\n\t\tstatic class PairComparatorX implements Comparator<Pair> {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\treturn o1.x.compareTo(o2.x);\n\t\t\t}\n\n\t\t}\n\n\t\tstatic class PairComparatorY implements Comparator<Pair> {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\treturn o1.y.compareTo(o2.y);\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\tstatic class Reader {\n\t\t/**\n\t\t * When reading millions of strings try using FastReader if getting tle\n\t\t */\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\t\tScanner in = new Scanner(System.in);\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tString next() {\n\t\t\treturn in.next();\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[64]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t\tif (in == null) \n\t\t\t\treturn;\n\t\t\tin.close();\n\t\t}\n\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n}"
        },
        {
            "language": 3,
            "solution": "I = lambda :map(int, input().split())\nn,d=I()\na=sorted([list(I()) for i in range(n)])\n    \nj = 0\n\n\nans =   t= a[0][1]\nfor i in range (1,n):\n    while(a[i][0]-a[j][0]>=d) :\n        t-=a[j][1]\n    \n        j+=1\n       \n         \n    t+=a[i][1]\n    ans = max(ans, t)\nprint(ans)\n          \n\n\n     \n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<long long, long long> a[100007];\nlong long p[100007];\nint main() {\n  long long n, d, L, R, res, s;\n  cin >> n >> d;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a + 1, a + 1 + n);\n  for (int i = 1; i <= n; i++) p[i] = p[i - 1] + a[i].second;\n  R = 1;\n  res = a[1].second;\n  for (int L = 1; L <= n; L++) {\n    while (R <= n && a[R].first - a[L].first < d) {\n      if (p[R] - p[L - 1] > res) res = p[R] - p[L - 1];\n      R++;\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long, long long> > k;\nint main() {\n  long long x, mii, sum = 0, sum2 = 0;\n  cin >> x >> mii;\n  for (long long i = 0; i < x; i++) {\n    long long n, m;\n    cin >> n >> m;\n    k.push_back(make_pair(n, m));\n  }\n  sort(k.begin(), k.end());\n  for (long long i = 0, t = 0; i < x && t < x && i <= t;) {\n    if (k[t].first - k[i].first < mii) {\n      sum = sum + k[t].second;\n      t++;\n    } else {\n      sum2 = max(sum2, sum);\n      sum -= k[i].second;\n      i++;\n    }\n  }\n  sum2 = max(sum2, sum);\n  cout << sum2;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > v;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long x, y, n, d, i, beg, p1 = 0;\n  cin >> n >> d;\n  for (i = 0; i < n; i++) {\n    cin >> x >> y;\n    v.push_back(make_pair(x, y));\n  }\n  sort(v.begin(), v.end());\n  long long minn = v[0].first, cur = v[0].second, ans = v[0].second;\n  for (i = 1; i < n; i++) {\n    if (v[i].first - minn >= d) {\n      cur += v[i].second;\n      while (p1 < i and v[i].first - v[p1].first >= d) {\n        cur -= v[p1].second;\n        p1++;\n      }\n      ans = max(ans, cur);\n      minn = v[p1].first;\n    } else {\n      cur += v[i].second;\n      ans = max(ans, cur);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n,d = map(int,raw_input().split())\nms = [map(int,raw_input().split()) for i in xrange(n)] + [[1e10,0]]\nms.sort(key = lambda x:x[0])\nscore = [s for m,s in ms] + [0]\nleft = 0\nfor m,s in ms[:-1]:\n\twhile ms[left][0] - m < d:\n\t\tleft += 1\n\tscore[left] -= s\nfor i in xrange(n-1):\n\tscore[i+1] += score[i]\nprint max(score)"
        },
        {
            "language": 3,
            "solution": "\"\"\"\nAuthor: Andrew Jakubowicz\n\nInput:\n <Num of Friends> <Amount of money to feel poor>\n\nLoop over the friends.\n\"\"\"\n\n\n\n# Use this for very fast insertion\n# bisect.insort_left(list, item[, lo[, hi]])\n\n\nif __name__ == \"__main__\":\n    n, poorAmount = list(map(int, input().split(' ')))\n    everythingList = []\n    moneyList = []\n    friendshipFactorList = []\n    for _ in range(n):\n        money, friendshipFactor = list(map(int, input().split(' ')))\n        everythingList.append((money,friendshipFactor))\n        # insertionPoint = bisect.bisect_left(moneyList, money)\n        # moneyList.insert(insertionPoint, money)\n        # friendshipFactorList.insert(insertionPoint, friendshipFactor)\n    everythingList.sort(key=lambda x: x[0])\n\n    # Get the most friendships within the poorAmount.\n    i = 0 #Leading pointer\n    j = 0 # Trailing pointer\n    endingSequence = False\n    rollingFriendShip = everythingList[i][1]\n    maxFriendShip = rollingFriendShip\n    # There will always be at least 1\n    while not (j + 1 >= n):\n        # If the totalMoneyDif is less than poorAmount\n        # then extend the right pointer.\n        totalMoneyDif = abs(everythingList[j][0] - everythingList[i][0])\n\n        if totalMoneyDif < poorAmount and i+1 < n:\n            maxFriendShip = max(maxFriendShip, rollingFriendShip)\n            i += 1\n            rollingFriendShip += everythingList[i][1]\n\n\n        else:\n            # Re order so it doesn't trigger every time.\n            if abs(everythingList[j][0] - everythingList[i][0]) < poorAmount:\n                maxFriendShip = max(maxFriendShip, rollingFriendShip)\n                if i + 1 == n and rollingFriendShip < maxFriendShip:\n                    break\n            rollingFriendShip -= everythingList[j][1]\n            j += 1\n\n\n    if abs(everythingList[j][0] - everythingList[i][0]) < poorAmount:\n        maxFriendShip = max(maxFriendShip, rollingFriendShip)\n    print(maxFriendShip)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class JavaTest {\n    private static PrintWriter out = new PrintWriter(System.out);\n    private static FastScanner sc;\n\n    public static void main(String args[]) throws Exception {\n        InputStream is = JavaTest.class.getResourceAsStream(\"in.txt\");\n        boolean testMode = is != null;\n        sc = new FastScanner(testMode ? is : System.in);\n\n        long start = System.currentTimeMillis();\n        main();\n\n        if (testMode) {\n            out.println();\n            out.print(System.currentTimeMillis() - start + \" ms\");\n        }\n\n        out.close();\n    }\n\n    private static class Friend {\n        long money;\n        long fact;\n\n        Friend(long money, long fact) {\n            this.money = money;\n            this.fact = fact;\n        }\n\n        @Override\n        public String toString() {\n            return \"Money -> \" + this.money + \"  Fact -> \" + this.fact;\n        }\n\n    }\n\n    private static void main() throws Exception {\n        int n = sc.nextInt();\n        long d = sc.nextLong();\n        ArrayList<Friend> friends = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            long money = sc.nextLong();\n            long fact = sc.nextLong();\n            friends.add(new Friend(money, fact));\n        }\n        friends.sort(new Comparator<Friend>() {\n            public int compare(Friend f1, Friend f2) {\n                if (f2.money > f1.money) {\n                    return -1;\n                } else if (f2.money < f1.money) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        });\n        long maxFact = 0;\n        long cnt = 0;\n        int i = 0, j = 0;\n        while (j < n) {\n            Friend fi = friends.get(i);\n            Friend fj = friends.get(j);\n            if (fj.money - fi.money >= d) {\n                i++;\n                cnt -= fi.fact;\n            } else {\n                j++;\n                cnt += fj.fact;\n                maxFact = Math.max(cnt, maxFact);\n            }\n        }\n        System.out.println(maxFact);\n    }\n\n    private static class FastScanner {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "n,d = input().strip().split()\nn = int(n)\nd = int(d)\na = [[] for i in range(n)]\nfor i in range(n):\n    t1,t2 = input().strip().split()\n    a[i].append(int(t1))\n    a[i].append(int(t2))\na.sort()\ni = 0\nj = 0\ns = 0\nans = 0\nwhile i < n:\n    if a[j][0]-a[i][0] < d:\n        if j < n-1:\n            s += a[j][1]\n            j += 1\n            ans = max(ans,s)\n            #print(\"i:\",i,\"j:\",j,\"s:\",s,\"ans:\",ans)\n        else:\n            s += a[j][1]\n            ans = max(ans,s)\n            break\n    else:\n        s -= a[i][1]\n        i += 1\n        #print(\"i:\",i,\"j:\",j,\"s:\",s)\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "from collections import namedtuple\n\n# The first line of the input contains two space-separated integers,\n# n and d (1\u2009\u2264\u2009n\u2009\u2264\u2009105, )\n# \u2014 the number of Kefa's friends\n# and the minimum difference between the amount of money in order to feel poor\n\nN, D = map(int, input().split())\n\n# Next n lines contain the descriptions of Kefa's friends,\n# the (i\u2009+\u20091)-th line contains the description of the i-th friend\n# of type mi, si (0\u2009\u2264\u2009mi,\u2009si\u2009\u2264\u2009109)\n# \u2014 the amount of money and the friendship factor, respectively.\nFriend = namedtuple('Friend', ['money', 'factor'])\n\nfriends = list()\nfor n in range(N):\n    mi, si = map(int, input().split())\n    pair = Friend(mi, si)\n    friends.append(pair)\n\nfriends.sort()\n# print(f'friends:{friends}')\n\ntail = 0\ndiff = 0\nmaxfactor = friends[0].factor\ncurrfactor= friends[0].factor\nfor head in range(1, len(friends)):\n    currfactor += friends[head].factor\n    diff = friends[head].money - friends[tail].money\n    while diff >= D:\n        currfactor -= friends[tail].factor\n        tail += 1\n        diff = friends[head].money - friends[tail].money\n    maxfactor = max(maxfactor, currfactor)\n    # print(f'currfactor:{currfactor} maxfactor:{maxfactor}')\n    # print(f'diff:{diff}')\nprint(maxfactor)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Friend {\n  int m, s;\n};\nFriend f[100005];\nbool operator<(const Friend &a, const Friend &b) { return a.m < b.m; }\nint main() {\n  int n, d;\n  cin >> n >> d;\n  for (int i = 0; i < n; ++i) cin >> f[i].m >> f[i].s;\n  sort(f, f + n);\n  long long Max = 0;\n  long long sum = 0;\n  int qian = 0;\n  for (int i = 0; i < n; ++i) {\n    if (f[i].m - f[qian].m >= d) {\n      --i;\n      sum -= f[qian].s;\n      ++qian;\n    } else {\n      sum += f[i].s;\n      if (sum > Max) Max = sum;\n    }\n  }\n  cout << Max;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\namigos = []\n\nfor i in range(n):\n\tamigo = map(int, raw_input().split())\t\n\tamigos.append(amigo)\n  \namigos.sort()\nfator = [(n+1)]\n\nfor i in range(1, n+1):\n\tfator.insert(i, (fator[i-1] + amigos[i-1][1]))\n\nj = 1\nfatorMax = 0\n\nfor i in xrange(n):\n\twhile j < n and (amigos[i][0]+d > amigos[j][0]):\n\t\tj += 1\n\t\t\n\tfatorMax = max(fatorMax, fator[j] - fator[i])\n\nprint fatorMax"
        },
        {
            "language": 3,
            "solution": "from operator import itemgetter\nn, d = map(int, input().split())\nfir = 0\nsec = 0\nar = [list(map(int, input().split())) for i in range(n)]\nar.sort(key = itemgetter(0))\nans = ar[0][1]\nar2 = [0] * (n+1)\nfor i in range(n):\n    ar2[i+1] = ar2[i] + ar[i][1]\nwhile sec < n:\n    if ar[sec][0] - ar[fir][0] >= d:\n        fir += 1\n    else:\n        ans = max(ans, ar2[sec+1] - ar2[fir])\n        sec += 1\nprint(ans)\n"
        },
        {
            "language": 1,
            "solution": "__author__ = 'mowayao'\n\nimport bisect\n\nn,d = map(int,raw_input().split())\nfriends = [map(int,raw_input().split()) for i in xrange(n)]\nfriends.sort(lambda x,y:cmp(x[0],y[0]))\n\n\nS = [0 for i in xrange(n+1)]\nret = 0\n\nfor i in xrange(n):\n    S[i+1] = S[i]+friends[i][1]\n\nmoney = [friends[i][0] for i in xrange(n)]\nret = 0\nfor i in xrange(n):\n    id = bisect.bisect_left(money,money[i]+d)\n    ret = max(ret,S[id]-S[i])\nprint ret"
        },
        {
            "language": 3,
            "solution": "n, d = input().split()\nL = []\nfor i in range(int(n)+1):\n    if i == 0:\n        L.append([0 ,0])\n    else:\n        m, f = input().split()\n        L.append([int(m), int(f)])\n\nL.sort(key = lambda X: X[0])\n\nSum = 0\nfor i in range(1, int(n)+1):\n    Sum += L[i][1]\n    L[i][1] = Sum\n\nj = dif = 0\nanswer = 0\nfor i in range(1, int(n)+1):\n\n    if L[i][0] - L[j][0] < int(d):\n        dif = L[i][0] - L[j][0]\n    else:\n        dif = L[i][0] - L[j][0]\n\n        while dif >= int(d):\n            j += 1\n            dif = L[i][0] - L[j][0]\n    if j == 0:\n        answer = max(answer, L[i][1] - L[j][1])\n    else:\n        answer = max(answer, L[i][1] - L[j-1][1])\n\nprint(answer)"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nvalues = []\nfor i in range(n):\n    m, f = input().split()\n    values.append((int(m), int(f)))\nvalues.sort()\n\nl,r=0,1\nans,curr=values[0][1],values[0][1]\nwhile r<n:\n\tcurr+=values[r][1]\n\twhile l<r and values[r][0]-values[l][0]>=d:\n\t\tcurr-=values[l][1]\n\t\tl+=1\n\tans=max(ans,curr)\n\t# print(l,r)\n\tr+=1\n\t\t\nprint(ans)\n"
        },
        {
            "language": 1,
            "solution": "linha1 = raw_input().split()\nn = int(linha1[0])\nd = int(linha1[1])\n\nent = []\n\nfor i in range(n):\n  entrada = raw_input().split()\n  lista = []\n  lista.append(int(entrada[0]))\n  lista.append(int(entrada[1]))\n  ent.append(lista)\n  \nent.sort()\n\ncur = 0\nj = 0\nmaximo = 0\n\nfor i in range(len(ent)):\n  cur += ent[i][1]\n  while ( j< i and (abs(ent[i][0] - ent[j][0]) >= d)):\n    cur -= ent[j][1]\n    j+=1\n  maximo = max(maximo, cur)\n  \n\n#print ent\nprint maximo\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n\npublic class B {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] input = br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(input[0]);\n\t\tint d = Integer.parseInt(input[1]);\n\t\tArrayList<Pair> pair = new ArrayList<Pair>();\n\t\tfor(int i = 0;i<n;i++){\n\t\t\tinput = br.readLine().split(\" \");\n\t\t\tint m = Integer.parseInt(input[0]);\n\t\t\tint f = Integer.parseInt(input[1]);\n\t\t\tpair.add(new Pair(m,f));\n\t\t}\n\t\tCollections.sort(pair);\n\t\tlong acumulado = 0;\n\t\tlong max = 0;\n\t\tlong nuevo = pair.get(0).f;\n\t\tint i = 0;\n\t\tint j = 1;\n\t\twhile (i < pair.size())\n\t\t{\n\t\t   Pair p1 = pair.get(i);\n\t\t   acumulado = nuevo;\n\t\t   long primero = p1.m;\n\t\t   long primerf = p1.f;\n\t\t   while(j<pair.size()){\n\t\t\t   Pair p2 = pair.get(j);\n\t\t\t   if(p2.m - primero>=d){\n\t\t\t\t   nuevo = acumulado-primerf;\n\t\t\t\t   break;\n\t\t\t   }\n\t\t\t   acumulado += p2.f;\n\t\t\t   j++;\n\t\t   }\n\t\t   if(acumulado > max) max = acumulado;\n\t\t   i++;\n\t\t}\t\n\t\tSystem.out.println(max);\n\t\t\n\t}\n\tstatic class Pair implements Comparable<Pair>{\n\t\tlong m,f;\n\t\tPair(long m,long f){\n\t\t\tthis.m=m;\n\t\t\tthis.f=f;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair arg0) {\n\t\t\treturn (int)(this.m-arg0.m);\n\t\t}\n\t}\n\t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, d;\n  cin >> n >> d;\n  vector<pair<long long, long long>> v;\n  for (long long i = 0; i < n; i++) {\n    long long a, b;\n    cin >> a >> b;\n    v.push_back({a, b});\n  }\n  sort(v.begin(), v.end());\n  long long prevf = v[0].second;\n  long long prevm = v[0].first;\n  long long mx = v[0].second;\n  long long i = 1;\n  long long j = 0;\n  while (i < v.size()) {\n    if (v[i].first - prevm >= d) {\n      prevf = prevf + v[i].second;\n      while (v[i].first - v[j].first >= d) {\n        prevf = prevf - v[j].second;\n        j++;\n      }\n      prevm = v[j].first;\n      mx = max(mx, prevf);\n    } else {\n      prevf = prevf + v[i].second;\n      mx = max(mx, prevf);\n    }\n    i++;\n  }\n  mx = max(mx, prevf);\n  cout << mx << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\n\n\npublic class Main {\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n        st=new StringTokenizer(br.readLine());\n        int n=Integer.parseInt(st.nextToken());\n        long d=Long.parseLong(st.nextToken());\n        Pair[] p=new Pair[n];\n        //TreeSet<Long> set=new TreeSet<Long>();\n        for(int i=0;i<n;i++)\n        {\n            st=new StringTokenizer(br.readLine());\n            long t1=Long.parseLong(st.nextToken());\n            long t2=Long.parseLong(st.nextToken());\n            //set.add(t1);\n            p[i]=new Pair(t1,t2);\n        }\n        Arrays.sort(p);\n        long curr=0;\n        long max=0;\n        int ind=0;\n        for(int i=0;i<n;i++)\n        {\n            while(p[i].first-p[ind].first>=d)\n            {\n                curr-=p[ind].second;\n                ind++;\n            }\n            curr+=p[i].second;\n            if(max<curr)max=curr;\n        }\n        System.out.print(max);\n    }\n}\nclass Pair implements Comparable<Pair>\n{\n    long first;\n    long second;\n    Pair()\n    {\n        first=0;\n        second=0;\n    }\n    Pair(long a,long b)\n    {\n        first=a;\n        second=b;\n    }\n    public int compareTo(Pair n)\n    {\n        if(first>n.first)\n            return 1;\n        else if(first<n.first)\n            return -1;\n        return 0;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool sortbylogic(const pair<long long, long long> &a,\n                 const pair<long long, long long> &b) {\n  return (a.second > b.second);\n}\nbool sortbylogic1(const pair<long long, long long> &a,\n                  const pair<long long, long long> &b) {\n  return (a.first < b.first);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, d;\n  cin >> n >> d;\n  vector<pair<long long, long long> > vect(n);\n  for (long long i = 0; i < n; i++) {\n    long long a, b;\n    cin >> a >> b;\n    vect[i].first = a;\n    vect[i].second = b;\n  }\n  sort(vect.begin(), vect.end(), sortbylogic);\n  long long k = vect[0].second;\n  sort(vect.begin(), vect.end(), sortbylogic1);\n  long long ans = INT_MIN;\n  long long p = 0;\n  long long sum = 0;\n  long long j = 0;\n  long long res = 0;\n  if (n == 1)\n    cout << max(k, vect[0].second) << endl;\n  else {\n    for (long long i = 0; i < n; i++) {\n      long long diff = vect[i].first - vect[j].first;\n      while (diff >= d) {\n        sum -= vect[j].second;\n        diff = vect[i].first - vect[j + 1].first;\n        j++;\n      }\n      sum += vect[i].second;\n      res = max(res, sum);\n    }\n    cout << res << endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    n, d = map(int, input().split())\n    ms = []\n    for i in range(n):\n        ms.append(list(map(int, input().split())))\n    ms.sort()\n    hr = 0\n    hl = 0\n    mini = ms[0][0]\n    sumi = 0\n    s = 0\n    while hr < n:\n        mini = ms[hr][0]\n        while hl < n and (ms[hl][0] - mini) < d:\n            s += ms[hl][1]\n            hl += 1\n        if s > sumi:\n            sumi = s\n        s -= ms[hr][1]\n        hr += 1\n    print(sumi)\nmain()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  long long value;\n  long long factor;\n};\nbool compare(struct node a, struct node b) { return a.value < b.value; }\nint main() {\n  ios::sync_with_stdio(false);\n  long long n, d, i, j;\n  cin >> n >> d;\n  struct node a[n];\n  for (i = 0; i < n; i++) cin >> a[i].value >> a[i].factor;\n  sort(a, a + n, compare);\n  long long max_factor = a[0].factor, factor = a[0].factor;\n  j = 1;\n  i = 0;\n  while (j < n) {\n    if (a[j].value - a[i].value < d) {\n      factor += a[j].factor;\n      j++;\n    } else {\n      max_factor = max(max_factor, factor);\n      while (a[j].value - a[i].value >= d) {\n        factor -= a[i].factor;\n        i++;\n      }\n    }\n  }\n  max_factor = max(max_factor, factor);\n  cout << max_factor << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\na = [tuple(map(int, input().split())) for i in range(n) ]\na.sort(reverse = True)\nsums = [0] * n\nsums[0] = a[0][1]\nfor i in range(1,n):\n    sums[i]  = sums[i-1] + a[i][1]\nmaxsum = 0\nr = 0\nfor l in range(n):\n    if r < l:\n        r = l\n    while r < n and(- a[r][0] + a[l][0] < d):\n        r += 1\n    r -= 1\n    if l > 0:\n        summ = sums[r] - sums[l-1]\n    else:\n        summ = sums[r]\n    maxsum = max(maxsum, summ)\nprint(maxsum)"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\n\nn,d=I()\nl=[]\nfor x in range(n):\n\tl.append(I())\nl.sort()\nan=max(i[1] for i in l)\ni=0\nm=l[0][0];c=0\nst=0\nwhile i<n:\n\tif l[i][0]-m<d:\n\t\tc+=l[i][1]\n\telse:\n\t\tan=max(an,c)\n\t\twhile l[i][0]-l[st][0]>=d:\n\t\t\tc-=l[st][1];st+=1\n\t\tm=l[st][0]\n\t\tc+=l[i][1]\n\ti+=1\nan=max(an,c)\nprint(an)\n"
        },
        {
            "language": 3,
            "solution": "from bisect import *\n\nn,d = map(int,input().split())\n\ntp = list()\n\nfor i in range(n):\n    m,s = map(int,input().split())\n    tp.append((m,s))\n    \ntp.sort(key = lambda x : x[0])\n\nm = list()\ns = list()\nfor i in range(n):\n    m.append(tp[i][0])\n    s.append(tp[i][1])\n    \nps = list()\nsn = 0\nfor i in range(n):\n    sn += s[i]\n    ps.append(sn)\n    \nmx = -1000\nfor i in range(n):\n    ind = bisect_left(m,m[i]+d)\n    if(i!=0):\n        mx = max(mx,ps[ind-1]-ps[i-1])\n    else:\n        mx = max(mx,ps[ind-1])        \n    \nprint(mx)"
        },
        {
            "language": 3,
            "solution": "def find_company(friends, d):\n\n    def mergesort_tuples(tuples, index):\n\n        def merge(A, B):\n            i, j = 0, 0\n            result = []\n            while i < len(A) and j < len(B):\n                if A[i][index] < B[j][index]:\n                    result.append(A[i])\n                    i += 1\n                else:\n                    result.append(B[j])\n                    j += 1\n\n            result += A[i:]\n            result += B[j:]\n\n            return result\n\n        def divide(tuples):\n            if len(tuples) > 1:\n                middle = len(tuples) // 2\n                return merge(divide(tuples[:middle]), divide(tuples[middle:]))\n\n            return tuples\n\n        return divide(tuples)\n\n    def solve(friends, d):\n        friends = mergesort_tuples(friends, 0)\n        left_ptr = 0\n        right_ptr = 0\n        current_friendship = 0\n        max_friendship = 0\n        while right_ptr < len(friends):\n            if friends[right_ptr][0] - friends[left_ptr][0] < d:\n                current_friendship += friends[right_ptr][1]\n                right_ptr += 1\n            else:\n                max_friendship = max(current_friendship, max_friendship)\n                current_friendship -= friends[left_ptr][1]\n                left_ptr += 1\n\n        max_friendship = max(current_friendship, max_friendship)\n\n        return max_friendship\n\n    return solve(friends, d)\n\n\nif __name__ == \"__main__\":\n    n, d = [int(x) for x in input().split()]\n    friends = []\n    for _ in range(n):\n        friends.append(tuple([int(x) for x in input().split()]))\n    print(find_company(friends, d))"
        },
        {
            "language": 3,
            "solution": "from collections import deque as dq\na,b = map(int,input().split())\nv =[]\nfor i in range(a):\n\tl = list(map(int,input().split()))\n\tv.append(l)\nv.sort(key = lambda i:(i[0],i[1]),reverse =True)\nt =p=dq([])\nans =out=0\nfor i in v:\n\tif t==[]:\n\t\tt.append(i[0])\n\t\tp.append(i[1])\n\t\tans+=i[1]\n\telse:\n\t\twhile t and t[0]-i[0]>=b:\n\t\t\tk = t.popleft()\n\t\t\tans-=p.popleft()\n\t\tt.append(i[0])\n\t\tp.append(i[1])\n\t\tans+=i[1]\n\tout = max(ans ,out)\nprint(out)"
        },
        {
            "language": 1,
            "solution": "#http://codeforces.com/problemset/problem/580/B\n#by Khrystyna Skopyk\n\nimport sys\nimport threading\n\ndef kefa():\n    n, d = map(int, raw_input().split())\n    friends = [None]*n\n    for i in xrange(n):\n        friends[i] = map(int, raw_input().split())\n\n    new = sorted(friends, key=lambda x: x[0])\n    mx = 0\n    r = 0\n    pointer = 0\n    for l in xrange(n):\n        while r <= n-1 and (new[r][0] - new[l][0]) < d:\n            pointer += new[r][1]\n            r += 1\n        if pointer > mx:\n            mx = pointer\n        pointer -= new[l][1]\n\n    return mx\n\ndef main():\n    print kefa()\n\nif __name__ == '__main__':\n    print kefa()\n    # print kefa(15, 1234 ,[[2738, 322313356], [1160, 970909702], [2594, 902749351], [3126, 324754476],\n    #                      [3151, 177963947], [3424, 396145897], [5578, 737768323], [3423, 687640543], [381, 848813098],\n    #                      [1058, 197211286], [936, 650181776], [1025, 776492538], [3598, 142176544], [3595, 680519527],\n    #                      [1191, 32199940]])\n    # print kefa(4, 2, [[10909234, 9], [10909236, 8], [10909237, 10], [10909235, 98]])\n    # print kefa(4, 5, [[75,5], [0,100], [150,20], [75,1]])\n    # print kefa(5, 100, [[0,7], [11,32], [99,10], [46,8], [87, 54]])\n    # print kefa(5,10, [[8, 90], [1009, 1000000], [9, 121], [10, 298], [0, 109092]])\n    # print kefa(5,9,[[0, 98], [2, 1000000000], [8, 1000000000], [5, 999999999], [3, 989898989]])\n    # sys.setrecursionlimit(1000000)\n    # threading.stack_size(10240000)\n    # thread = threading.Thread(target=main)\n    # thread.start()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long int n, k, j = 0;\n  cin >> n >> k;\n  pair<long long int, long long int> arr[n];\n  for (long long int i = 0; i < n; i++) {\n    cin >> arr[i].first >> arr[i].second;\n  }\n  sort(arr, arr + n);\n  long long int sum = 0, ans = 0;\n  for (long long int i = 0; i < n; i++) {\n    while (j < n && arr[j].first < arr[i].first + k) {\n      sum = sum + arr[j].second;\n      j++;\n    }\n    if (ans < sum) ans = sum;\n    sum -= arr[i].second;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, d, x, y;\nvector<pair<long long, long long> > vec2;\nint main() {\n  scanf(\"%lld%lld\", &n, &d);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lld%lld\", &x, &y);\n    vec2.push_back(make_pair(x, y));\n  }\n  sort(vec2.begin(), vec2.end());\n  long long ans2 = 0;\n  int st = 0;\n  long long sum = 0;\n  for (int i = 0; i < vec2.size(); sum -= vec2[i].second, i++) {\n    while (st < vec2.size() && abs(vec2[i].first - vec2[st].first) < d)\n      sum += vec2[st].second, st++;\n    ans2 = max(ans2, sum);\n  }\n  printf(\"%lld\\n\", ans2);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "noFriends, minAmount = map(int,raw_input().split())\namount = []\nfriendshipFactor = []\nfor x in xrange(noFriends):\n    a, b = map(int,raw_input().split())\n    amount.append(a)\n    friendshipFactor.append(b)\nsortedfriendshipFactor = [y for x,y in sorted(zip(amount,friendshipFactor))]\namount.sort()\n##print amount\n##print sortedfriendshipFactor\n\nfor x in xrange(1,noFriends):\n    sortedfriendshipFactor[x]+= sortedfriendshipFactor[x-1]\n\ndef lastElement(i):\n    global minAmount\n    initial = amount[i]\n    first = i\n    last = len(amount)-1\n    if amount[last]-initial<minAmount:\n        return last\n    for x in xrange(16):\n        mid = (first+last)/2\n        if amount[mid]>(initial+minAmount-1):\n            if amount[mid-1]<=(initial+minAmount-1):\n                return mid-1\n            else:\n                last = mid\n        else:\n            if amount[mid+1]>(initial+minAmount-1):\n                return mid\n            else:\n                first = mid\n\nmaxFactor=0\ni=0\nlast = lastElement(i)\ns = sortedfriendshipFactor[last]\nif s>maxFactor:\n    maxFactor = s\nif last != len(amount)-1:    \n    for i in xrange(1,noFriends):\n        last = lastElement(i)\n        s = sortedfriendshipFactor[last]-sortedfriendshipFactor[i-1]\n        if s>maxFactor:\n            maxFactor = s\n    \nprint maxFactor"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class CF321B2 {\n    private static class Pair {\n        final int m;\n        final int s;\n\n        public Pair(int m, int s) {\n            this.m = m;\n            this.s = s;\n        }\n    }\n\n    private static long solve(Pair[] p, int d) {\n        Arrays.sort(p, Comparator.comparing((Pair pair) -> pair.m));\n        long best = 0;\n        long cur = 0;\n        int start = 0;\n        for (int i = 0; i < p.length; i++) {\n            cur += p[i].s;\n            while (p[i].m - p[start].m >= d) {\n                cur -= p[start].s;\n                start++;\n            }\n            if (cur > best) best = cur;\n        }\n        return best;\n    }\n\n    private static int nextInt(StreamTokenizer st) throws Exception {\n        st.nextToken();\n        return (int) st.nval;\n    }\n\n    public static void main(String[] args) throws Exception {\n        StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        int n = nextInt(st);\n        int d = nextInt(st);\n        Pair[] p = new Pair[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = new Pair(nextInt(st), nextInt(st));\n        }\n        System.out.println(solve(p, d));\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class B {\n    static class Node implements Comparable<Node> {\n        int money;\n        long friend, sum;\n\n        @SuppressWarnings(\"NullableProblems\")\n        @Override\n        public int compareTo(Node o) {\n            return Integer.compare(money, o.money);\n        }\n    }\n\n    static int n;\n    static long d;\n    static Node[] nodes;\n\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n\n        n = cin.nextInt();\n        d = cin.nextInt();\n        nodes = new Node[n];\n        for (int i = 0; i < n; i++) {\n            nodes[i] = new Node();\n            nodes[i].money = cin.nextInt();\n            nodes[i].friend = cin.nextInt();\n        }\n\n        Arrays.sort(nodes);\n        nodes[0].sum = nodes[0].friend;\n        for (int i = 1; i < n; i++) {\n            nodes[i].sum = nodes[i - 1].sum + nodes[i].friend;\n        }\n\n        int left, right;\n        left = 0;\n        right = 0;\n\n        long ans = 0;\n        for (; left < n; left++) {\n            right = findRight(nodes[left], right);\n            long now = nodes[right].sum;\n            if (left != 0) {\n                now -= nodes[left - 1].sum;\n            }\n            if (now > ans) {\n                ans = now;\n            }\n        }\n\n        System.out.println(ans);\n\n        cin.close();\n    }\n\n    private static int findRight(Node node, int right) {\n        for (; right < n; right++) {\n            if (nodes[right].money >= node.money + d) break;\n        }\n        right--;\n        return right;\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nsc=[]\nfor i in range(n):\n    a,b=map(int,input().split())\n    sc.append([a,b])\nsc.sort()\ni=0\nj=1\ns=sc[0][1]\nma=sc[0][1]\nwhile j<n:\n    if sc[j][0]-sc[i][0]<d:\n        s=s+sc[j][1]\n        if s>ma:\n            ma=s\n        j=j+1\n    else:\n        s=s-sc[i][1]\n        i=i+1\nprint(ma)\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\ndef two_pointers(friends, d ,n):\n    r = 0\n    max_value = 0\n    friendship_factor = 0\n    for l in xrange(n):\n        while r < n and (friends[r][0]-friends[l][0]) < d:\n            friendship_factor += friends[r][1]\n            r += 1\n        if friendship_factor > max_value:\n           max_value = friendship_factor\n        friendship_factor -= friends[l][1]\n    return max_value\n\n\n\n\ndef solution():\n    first_line = sys.stdin.readline()\n    n, d = map(int, first_line.split())\n    friends = []\n    for i in range(n):\n        friends.append(tuple(map(int, sys.stdin.readline().split())))\n    friends.sort()\n    if n == 1:\n        return friends[0][1]\n    else:\n        return two_pointers(friends, d, n)\n\n\nprint solution()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 5;\nvector<long long> v;\nlong long n, d;\nlong long sum = 0;\nlong long A[N];\nlong long f[N];\nvector<pair<long long, long long>> vv;\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> n;\n  cin >> d;\n  long long i;\n  for (i = 0; i < n; i++) {\n    long long a, b;\n    cin >> a >> b;\n    vv.push_back({a, b});\n  }\n  sort(vv.begin(), vv.end());\n  for (i = 0; i < n; i++) {\n    sum += vv[i].second;\n    A[i] = sum;\n    f[i] = vv[i].second;\n    v.push_back(vv[i].first);\n  }\n  long long best = INT_MIN;\n  for (i = 0; i < n; i++) {\n    long long xx = (v[i] - d);\n    long long yy = (v[i] + d);\n    auto p = upper_bound(v.begin(), v.end(), xx);\n    long long xxx = p - v.begin();\n    long long cur1 = A[i] - A[xxx] + f[xxx];\n    auto q = lower_bound(v.begin(), v.end(), yy);\n    long long yyy = q - v.begin();\n    yyy--;\n    long long cur2 = A[yyy] - A[i] + f[i];\n    long long cur = max(cur1, cur2);\n    if (cur > best) {\n      best = cur;\n    }\n  }\n  cout << best << \"\\n\";\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python\n# 580B_company.py - Codeforces.com/problemset/problem/580/B by Sergey 2015\n\nimport unittest\nimport sys\n\n###############################################################################\n# Company Class (Main Program)\n###############################################################################\n\n\nclass Company:\n    \"\"\" Company representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.n, self.d] = map(int, uinput().split())\n\n        # Reading multiple lines of pairs\n        pairs = (\" \".join(uinput() for i in range(self.n))).split()\n        self.numa = [int(pairs[i]) for i in range(0, 2*self.n, 2)]\n        self.numb = [int(pairs[i]) for i in range(1, 2*self.n, 2)]\n\n        self.money = [(self.numa[i], self.numb[i]) for i in range(self.n)]\n        self.money = sorted(self.money)\n\n        self.partsum = [0]\n        sum = 0\n        for i in range(self.n):\n            sum += self.money[i][1]\n            self.partsum.append(sum)\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = 0\n\n        for i in range(self.n):\n            mlb = self.money[i][0]\n            mrb = mlb + self.d\n            ilb = i\n            irb = lbound(self.money, mrb)\n            sumf = self.partsum[irb] - self.partsum[ilb]\n            result = max(result, sumf)\n\n        return str(result)\n\n\ndef lbound(v, n):\n    b = 0\n    e = len(v)\n    while b != e:\n        mid = (b + e) // 2\n        if v[mid][0] < n:\n            b = mid + 1\n        else:\n            e = mid\n    return b\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Company class testing \"\"\"\n\n        # Constructor test\n        test = \"4 5\\n75 5\\n0 100\\n150 20\\n75 1\"\n        d = Company(test)\n        self.assertEqual(d.n, 4)\n        self.assertEqual(d.d, 5)\n        self.assertEqual(d.numa, [75, 0, 150, 75])\n        self.assertEqual(d.numb, [5, 100, 20, 1])\n\n        # Sample test\n        self.assertEqual(Company(test).calculate(), \"100\")\n\n        # Sample test\n        test = \"5 100\\n0 7\\n11 32\\n99 10\\n46 8\\n87 54\"\n        self.assertEqual(Company(test).calculate(), \"111\")\n\n        # Sample test\n        test = \"\"\n        # self.assertEqual(Company(test).calculate(), \"0\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Company(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Company(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print(\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc))\n\nif __name__ == \"__main__\":\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Company().calculate())\n"
        },
        {
            "language": 4,
            "solution": "/**\n * Created by ankeet on 7/8/16.\n */\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class B580 {\n\n    public static BufferedReader read = null;\n    public static PrintWriter out = null;\n    public static StringTokenizer token = null;\n\n\n    public static void solve()\n    {\n        long n = nint();\n        long d = nint();\n        long[][] fr = new long[(int)n][2];\n        for(int i=0; i<n; i++)\n        {\n            fr[i][0] = nint();\n            fr[i][1] = nint();\n        }\n        Arrays.sort(fr, new Comparator<long[]>() {\n            @Override\n            public int compare(long[] o1, long[] o2) {\n                return (int) ( o1[0]-o2[0]);\n            }\n        });\n        for(int i=1; i<n; i++)\n            fr[i][1]+=fr[i-1][1];\n        long max = 0;\n        for(int i=0; i<n; i++)\n        {\n            long tar = fr[i][0]+d-1;\n            int lo = i, hi = (int)n-1, ans = -1;\n            while(lo<=hi)\n            {\n                int mid = (lo+hi)/2;\n                if(fr[mid][0] < tar) lo = mid+1;\n                else if(fr[mid][0] > tar) hi = mid-1;\n                else\n                {\n                    ans = mid;\n                    lo = mid+1;\n                }\n            }\n            if(ans == -1)\n            {\n\n\n                long tent = fr[lo-1][1];\n                if(i>0)tent-=fr[i-1][1];\n                max = Math.max(max, tent);\n            }\n            else\n            {\n                long tent = fr[ans][1];\n                if(i > 0) tent-=fr[i-1][1];\n                max = Math.max(max, tent);\n            }\n        }\n        out.println(max);\n\n    }\n\n    public static void main(String[] args)\n    {\n        read = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n        out.close();\n\n    }\n\n    // i/o functions\n    public static String next() // returns the next string\n    {\n        while(token == null || !token.hasMoreTokens())\n        {\n            try {\n                token = new StringTokenizer(read.readLine());\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        return token.nextToken();\n    }\n\n    public static int nint()\n    {\n        return Integer.parseInt(next());\n    }\n    public static long nlong()\n    {\n        return Long.parseLong(next());\n    }\n    public static double ndouble()\n    {\n        return Double.parseDouble(next());\n    }\n    public static int[] narr(int n)\n    {\n        int[] a = new int[n];\n        for(int i=0; i<n; i++) a[i] = nint();\n        return a;\n    }\n\n    public static long[] nal(int n)\n    {\n        long[] a = new long[n];\n        for(int i=0; i<n; i++) a[i] = nlong();\n        return a;\n    }\n\n\n}\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst ll inf = 1;\nconst ll mod = 1E9;\nint main() {\n  ios::sync_with_stdio(false);\n  int n;\n  ll d;\n  cin >> n >> d;\n  vector<pll> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a.begin(), a.end());\n  ll sum = 0, ans = 0;\n  for (int i = 0, j = 0; i < n; i++) {\n    if (i) sum -= a[i - 1].second;\n    while (j < n && a[j].first - a[i].first < d) {\n      sum += a[j].second;\n      j++;\n    }\n    ans = max(ans, sum);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, d = [int(x) for x in raw_input().split()]\nfriends = []\nfor i in xrange(n):\n    x = [int(x) for x in raw_input().split()]\n    friends.append(tuple(x))\n\nfriends.sort(key=lambda x: x[0])\n\n# Return the score\ndef testFriend(friends, friend, tempscore, i):\n    try:\n        while abs(friends[i][0] - friend[0]) >= d:\n            tempscore = tempscore - friends[i][1]\n            i = i + 1\n    except Exception:\n        pass\n    \n    friends.append(friend)\n    tempscore = tempscore + friend[1]\n\n    return (tempscore, friends, i)\n\n\nscore = 0\nx = 0\ni = 0\nroll = []\nfor friend in friends:\n    x, roll, i = testFriend(roll, friend, x, i)\n    score = max(x, score)\n\nprint score\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\n[n, d] = map(int, sys.stdin.next().split())\n\nfriends = []\nfor i in range(n):\n    friends.append(map(int, sys.stdin.next().split()))\n\nfriends = sorted(friends, key=lambda x: x[0])\n\ngoal = 0\ni = 0\nj = 1\ncurrent_goal = friends[0][1]\n\nwhile i < n:\n    if friends[j - 1][0] - friends[i][0] < d:\n        goal = max(goal, current_goal)\n        if j < n:\n            j += 1\n            current_goal += friends[j - 1][1]\n        else:\n            break\n    else:\n        current_goal -= friends[i][1]\n        i += 1\n\nprint(goal)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, d, i, j, mx, lst, f;\npair<long long, long long> v[100005];\nint main() {\n  scanf(\"%I64d%I64d\", &n, &d);\n  for (i = 1; i <= n; i++) scanf(\"%I64d%I64d\", &v[i].first, &v[i].second);\n  sort(v + 1, v + n + 1);\n  for (i = 1; i <= n; i++) {\n    if (j < i) {\n      f += v[i].second;\n      j = i + 1;\n    }\n    while (j <= n && v[j].first - v[i].first < d) {\n      f += v[j].second;\n      j++;\n    }\n    if (f > mx) mx = f;\n    f -= v[i].second;\n  }\n  printf(\"%I64d\", mx);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n,d = map(int, raw_input().split())\n\nfriends = []\n\nfor i in range(n):\n    money, factor = map(int,raw_input().split())\n    friends.append((money, factor))\n\nfriends.sort()\n\nmoneyMax = friends[0][1] \nsumm = friends[0][1]\n\ni = 1 \nj = 0\n\nwhile (i < n):\n    if ((friends[i][0] - friends[j][0]) < d): \n        summ += friends[i][1]\n    else:\n        moneyMax = max(summ, moneyMax)\n        while (friends[i][0] - friends[j][0] >= d):\n            summ -= friends[j][1]\n            j += 1\n        summ += friends[i][1]\n    i += 1\nmoneyMax = max(summ, moneyMax)\n\nprint moneyMax\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, d;\n  cin >> n >> d;\n  vector<pair<int, long long>> fr(n + 1);\n  for (int i = 1; i <= n; i++) cin >> fr[i].first >> fr[i].second;\n  sort(fr.begin(), fr.end());\n  int j = 1;\n  long long answ = -1;\n  for (int i = 1; i <= n; i++) {\n    fr[i].second += fr[i - 1].second;\n    while (fr[i].first - fr[j].first >= d) j++;\n    answ = max(answ, fr[i].second - fr[j - 1].second);\n  }\n  cout << answ;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid file() {}\nint tc;\nconst int N = 1e5 + 5, M = 2e6 + 5, MOD = 998244353, OO = 1e9 + 7;\nconst long long INF = 1e18;\nvoid solve(int tc) {\n  int n, d;\n  scanf(\"%d %d\", &n, &d);\n  std::vector<pair<int, int>> a(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &a[i].first, &a[i].second);\n  }\n  sort((a).begin(), (a).end());\n  std::vector<long long> dp(n);\n  dp[0] = a[0].second;\n  long long ans = 0;\n  for (int i = 1; i < n; i++) dp[i] = dp[i - 1] + a[i].second;\n  for (int i = 0; i < n; i++) {\n    auto j = upper_bound((a).begin(), (a).end(),\n                         make_pair(a[i].first + d - 1, 1000000000)) -\n             a.begin();\n    ans = max(ans, i ? dp[j - 1] - dp[i - 1] : dp[j - 1]);\n  }\n  printf(\"%lld\\n\", ans);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  file();\n  int tc = 1;\n  for (int i = 1; i <= tc; i++) solve(i);\n}\n"
        },
        {
            "language": 3,
            "solution": "def answer(n,d,A):\n    A.sort(key=lambda x:x[0])\n    pre=[0]*(n+1)\n    for i in range(1,n+1):\n        pre[i]=pre[i-1]+A[i-1][1]\n    \n    l=0\n    r=0\n    maxi=0\n    while r>=l and r<n:\n        if A[r][0]-A[l][0]<d:\n            r+=1\n        else:\n            maxi=max(maxi,pre[r]-pre[l])\n            l+=1\n    maxi=max(maxi,pre[r]-pre[l])\n    return maxi\n            \n\nn,d=map(int,input().split())\narr=[]\nfor i in range(n):\n    v,f=map(int,input().split())\n    arr.append([v,f])\nprint(answer(n,d,arr))"
        },
        {
            "language": 3,
            "solution": "n, d = [int(i) for i in input().split()]\nfriends = []\n\nfor i in range(n):\n    lista = []\n    m, s = [int(i) for i in input().split()]\n    lista = [m, s]\n    friends.append(lista)\n\nfriends_ordenados = sorted(friends)\n\nsoma_factors = []\ninicio, fim, soma = 0, 0, 0,\n\nwhile fim < n:\n    if friends_ordenados[fim][0] - friends_ordenados[inicio][0] < d:\n        soma += friends_ordenados[fim][1]\n        fim += 1\n    else:\n        soma_factors.append(soma)\n        soma -= friends_ordenados[inicio][1]\n        inicio += 1\nsoma_factors.append(soma)\n\nprint(max(soma_factors))\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "def sol(a,n,d):\n    i,j,ans,tmpans = 0,0,0,0\n    while j < n:\n        if a[j][0] - a[i][0] < d:\n            tmpans+=a[j][1]\n            j+=1\n        else:\n            ans = max(ans,tmpans)\n            while a[j][0] - a[i][0] >= d:\n                tmpans-= a[i][1]\n                i+=1\n    ans = max(ans,tmpans)\n    return ans\n\nn,d = map(int,input().split())\na = [None]*n\nfor i in range(n):\n    a[i] = tuple(map(int,input().split()))\na.sort()\nprint(sol(a,n,d))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n, d;\n  cin >> n >> d;\n  vector<pair<int, int> > friends(n);\n  vector<int> first(n);\n  for (int fl = 0; fl < n; fl++) {\n    cin >> friends[fl].first;\n    cin >> friends[fl].second;\n    first[fl] = friends[fl].first;\n  }\n  sort(friends.begin(), friends.end());\n  for (int fl = 0; fl < n; fl++) {\n    first[fl] = friends[fl].first;\n  }\n  vector<long long int> cum_friend_factor(n, 0);\n  for (int fl = 0; fl < n; fl++) {\n    if (fl == 0) {\n      cum_friend_factor[0] = friends[0].second;\n      continue;\n    }\n    cum_friend_factor[fl] =\n        cum_friend_factor[fl - 1] + (long long int)friends[fl].second;\n  }\n  long long int ret = 0;\n  for (int fl = 0; fl < n; fl++) {\n    int i = lower_bound(first.begin(), first.end(), friends[fl].first + d) -\n            first.begin();\n    if (i < n)\n      ret = max(ret, cum_friend_factor[i] - (long long int)friends[i].second -\n                         cum_friend_factor[fl] +\n                         (long long int)friends[fl].second);\n    else {\n      ret = max(ret, cum_friend_factor[n - 1] +\n                         (long long int)friends[fl].second -\n                         (long long int)cum_friend_factor[fl]);\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def kac(l,d):\n    l.sort(reverse=True)\n    ma=l[0][1]\n    v=l[0][1]\n    i=j=0\n    for i in range(1,len(l)):\n        v=v+l[i][1]\n        while abs(l[i][0]-l[j][0])>=d:\n            v-=l[j][1]\n            j+=1\n        if(v>ma):\n            ma=v\n    print(ma)\n    return\n        \nn,d=map(int,input().split())\nl1=[]\nfor i in range(n):\n    m=list(map(int,input().split()))\n    l1.append(m)\nkac(l1,d)\n    "
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nl=[]\nfor i in range(n):\n    a,b=map(int,input().split())\n    l.append([a,b])\nl.sort()\ni=0\nj=0\nans=0\nmaxx=0\n#print(l)\nwhile(j<n):\n    if l[j][0]<l[i][0]+d:\n        maxx+=l[j][1]\n        j+=1 \n    elif l[j][0]<l[i+1][0]+d:\n        maxx-=l[i][1]\n        maxx+=l[j][1]\n        j+=1\n        i+=1\n    else:\n        maxx-=l[i][1]\n        i+=1 \n    ans=max(ans,maxx)\nprint(ans)    \n        "
        },
        {
            "language": 1,
            "solution": "n, d = map(int,raw_input().split())\nlista = []\nfor i in range(n):\n\tlista.append( map(int,raw_input().split())) \nlista.sort()\nsoma = 0\na = 0\nj = 0\nfor i in range(n):\n\t\n\twhile j < n and lista[j][0] - lista[i][0] < d :\n\t\tsoma += lista[j][1]\n\t\tj += 1\n\t\n\tif soma > a :\n\t\ta = soma\n\t\n\tsoma -= lista[i][1]\n \nprint a"
        },
        {
            "language": 3,
            "solution": "\nimport operator\nn,d = list(map(int,input().split()))\n\nl = []\nfor i in range(n):\n    l.append(list(map(int,input().split())))\n\nl = sorted(l,key=lambda x:x[0])\nb = len(l)\nfriendship = 0\na = 0\nindex,place = 0,0\nwhile index < b:\n    while place < b and abs(l[index][0] - l[place][0]) < d:\n        a += l[place][1]\n        place += 1\n    friendship = max(a,friendship)\n    a -= l[index][1]\n    index += 1\nprint (friendship)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main\n{\n    public static void main(String []args) throws IOException {\n    \tFastScanner in  = new FastScanner(System.in);\n    \tPrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)), false);\n    \tsolve(in, out);\n    \tin.close();\n    \tout.close();\n    }\n    static long gcd(long a, long b){ return (b==0) ? a : gcd(b, a%b); }\n    static int gcd(int a, int b){ return (b==0) ? a : gcd(b, a%b); }\n    private static int fact(int n) { int ans=1; for(int i=2;i<=n;i++) ans*=i; return ans; }\n    static class FastScanner{\n\tBufferedReader reader;\n\tStringTokenizer st;\n\tFastScanner(InputStream stream){reader=new BufferedReader(new InputStreamReader(stream));st=null;}\n\tString next(){while(st == null || !st.hasMoreTokens()){try{String line = reader.readLine();if(line == null){return null;}\n\t     st = new StringTokenizer(line);}catch (Exception e){throw new RuntimeException();}}return st.nextToken();}\n\tString nextLine()  {String s=null;try{s=reader.readLine();}catch(IOException e){e.printStackTrace();}return s;}\n\tint    nextInt()   {return Integer.parseInt(next());}\n\tlong   nextLong()  {return Long.parseLong(next());}\n\tdouble nextDouble(){return Double.parseDouble(next());}\n\tchar   nextChar()  {return next().charAt(0);}\n\tint[]  nextIntArray(int n)         {int[] arr= new int[n];   int i=0;while(i<n){arr[i++]=nextInt();}  return arr;}\n\tlong[] nextLongArray(int n)        {long[]arr= new long[n];  int i=0;while(i<n){arr[i++]=nextLong();} return arr;}\n\tint[]  nextIntArrayOneBased(int n) {int[] arr= new int[n+1]; int i=1;while(i<=n){arr[i++]=nextInt();} return arr;}\n\tlong[] nextLongArrayOneBased(int n){long[]arr= new long[n+1];int i=1;while(i<=n){arr[i++]=nextLong();}return arr;}\n\tvoid   close(){try{reader.close();}catch(IOException e){e.printStackTrace();}}\n    }\n    \n    /********* SOLUTION STARTS HERE ************/\n    \n    private static void solve(FastScanner in, PrintWriter out){\n        int n = in.nextInt();\n        long d = in.nextLong();\n        long a[][] = new long[n][2];\n        for(int i=0;i<n;i++) {a[i][0] = in.nextLong();a[i][1] = in.nextLong();}\n        Arrays.sort(a, new Comparator<long[]>(){\n            public int compare(long[] a, long[] b){\n                if(a[0]>b[0]) return 1;\n                else if(a[0]<b[0]) return -1;\n                return 0;\n            }\n        });\n        int j=0;\n        long mx=0L;\n        long pre[] = new long[n];pre[0]=a[0][1];\n        for(int i=1;i<n;i++) pre[i] = pre[i-1]+a[i][1];\n        for(int i=0;i<n;i++){\n            for(;j<n && a[j][0]-a[i][0]<d;++j);\n            if(i>0) mx = Math.max(mx, pre[j-1]-pre[i-1]);\n            else mx = Math.max(pre[j-1], mx);\n        }\n        out.println(mx);\n    }\n    \n    /************* SOLUTION ENDS HERE **********/\n}"
        },
        {
            "language": 1,
            "solution": "# input\nn, d = map(int, raw_input().split())\nfriends = []\nfor i in range(n): friends.append(map(int, raw_input().split()))\nfriends = sorted(friends, key=lambda x: x[0])\n\n# solution\ncurrent_group_sum = friends[0][1]\ncurrent_group_min = friends[0][0]\ncurrent_group_first = 0\nresult = current_group_sum\n\ni = 1\nwhile i < len(friends):\n\twhile abs(friends[i][0] - friends[current_group_first][0]) >= d:\n\t\tcurrent_group_sum -= friends[current_group_first][1]\n\t\tcurrent_group_first = current_group_first + 1\n\tcurrent_group_sum = current_group_sum + friends[i][1]\n\tresult = max(result, current_group_sum)\n\ti = i + 1\n\nprint result\n#print friends\n"
        },
        {
            "language": 3,
            "solution": "n,d = map(int,input().split())\n#n = 3\na = []\nfor i in range (n):\n    l = input().split()\n    a.append(int(l[0])*(10**9+1) + int(l[1]))\n\n#print(a)\na.sort()\nb=[]\nc=[]\n\n\nx = a[0]%(10**9+1)\ny = a[0]//(10**9+1)\nb.append([y,x])\n##c.append(x)\nfor i in range (1,n):\n    x = a[i]%(10**9+1)\n    y = a[i]//(10**9+1)\n    b.append([y,x])\n##    c.append(c[i-1]+x)\n\n##print(b)\n##print(len(b), len(c))\n##print()\n##print()\nsuma = 0\np1 = 0\np2 = 0\nsol = 0\n##print (c)\nfor p1 in range (n):\n##    print(p1,p2)\n    while (p2 < n and b[p2][0] - b[p1][0] < d):\n##        print('while',p1,p2)\n##        print(b[p2][0] - b[p1][0])\n        suma += b[p2][1]\n        p2 += 1\n##        print('while',p1,p2)\n##        print (b[p2])\n##        print ('suma',suma)\n        \n##    if p1 == p2:\n##        delta = c[p1]\n##    else:\n##        delta = c[p2] - c[p1]\n##    sol = max(sol, delta)\n    sol = max(sol, suma)\n    suma -= b[p1][1]\n##    print(c[p2] - c[p1])\n##    print(delta)\n##    print(sol)\n##    print()\n\nprint (sol)\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class contest {\n    static long gcd(long a,long b){\n        if(a==0){\n            return b;\n        }\n        return gcd(b%a,a);\n    }\n    static final int p = 1000000007;\n    static class edge{\n        int u, v;\n        edge(int i,int x){\n            this.u = i;\n            this.v = x;\n        }\n\n    }\n\n    static int upperbound(int i,int j,long[][] arr,long key){\n        while(i<=j){\n            int mid = i + (j-i)/2;\n            if(arr[mid][0]>key){\n                j = mid-1;\n            }\n            else{\n                i = mid+1;\n            }\n        }\n        return i;\n    }\n\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int t = 1;\n\n        out:while(t-- >0) {\n            int n = sc.nextInt();\n            long d = sc.nextLong();\n\n            long[][] arr = new long[n][2];\n            for(int i =0;i<n;i++){\n                arr[i][0] = sc.nextLong();\n                arr[i][1] = sc.nextLong();\n            }\n\n            // 0 --> money\n            // 1 --> friendship\n\n            Arrays.sort(arr,(p1,p2)->{\n                return (int)(p1[0]-p2[0]);\n            });\n\n            long[] friendship_sum = new long[n+1];\n            friendship_sum[0] = 0l;\n\n            for(int i =1;i<=n;i++){\n                friendship_sum[i] = friendship_sum[i-1] + arr[i-1][1];\n            }\n\n            long ans = Integer.MIN_VALUE;\n            for(int i =0;i<n;i++){\n                int x = upperbound(i,n-1,arr,d-1+arr[i][0]);\n                long w = friendship_sum[x]-friendship_sum[i];\n                ans = Math.max(ans,w);\n            }\n\n\n            System.out.println(ans);\n        }\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\nfrom collections import deque\ndef main():\n    n, d = map(int, stdin.readline().split())\n    a = [map(int, stdin.readline().split()) for _ in xrange(n)]\n    a.sort()\n    q = deque()\n    ans = s = 0\n    for x, f in a:\n        while q and x >= q[0][0] + d:\n            s -= q[0][1]\n            q.popleft()\n        q.append((x, f))\n        s += f\n        if ans < s:\n            ans = s\n    print ans\nmain()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\n    public static void solve() {\n        int n = IO.readInt();\n        long d = IO.readInt();\n        Friend[] friends = new Friend[n];\n        for (int index = 0; index < n; ++index) {\n            friends[index] = new Friend(IO.readInt(), IO.readInt());\n        }\n        Arrays.sort(friends);\n\n        long maxSum = 0;\n        long sum = 0;\n        int endIndex = 0;\n        for (int index = 0; index < n; ++index) {\n            while (endIndex < n && ((friends[endIndex].m - friends[index].m) < d)) {\n                sum += friends[endIndex].s;\n                endIndex++;\n                if (sum > maxSum) {\n                    maxSum = sum;\n                }\n            }\n            sum -= friends[index].s;\n        }\n\n        IO.println(maxSum);\n    }\n\n    static class Friend implements Comparable<Friend> {\n        int m;\n        int s;\n\n        public Friend(int m, int s) {\n            this.m = m;\n            this.s = s;\n        }\n\n        @Override\n        public int compareTo(Friend o) {\n            return Integer.compare(m, o.m);\n        }\n    }\n\n\n\n    // Input/Output ================================\n    public static class IO {\n\n        private static Scanner scanner;\n        private static PrintWriter writer;\n\n        public static void setUp(InputStream in, OutputStream out) {\n            scanner = new Scanner(new java.io.BufferedInputStream(in));\n            writer = new PrintWriter(out);\n        }\n\n        public static boolean isEmpty() {\n            return !scanner.hasNext();\n        }\n\n        public static boolean hasNextLine() {\n            return scanner.hasNextLine();\n        }\n\n        public static String readLine() {\n            String line;\n            try {\n                line = scanner.nextLine();\n            } catch (Exception e) {\n                line = null;\n            }\n            return line;\n        }\n\n        public static String readString() {\n            return scanner.next();\n        }\n\n        public static int readInt() {\n            return scanner.nextInt();\n        }\n\n        public static int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int index = 0; index < n; ++index) {\n                a[index] = readInt();\n            }\n            return a;\n        }\n\n        public static double readDouble() {\n            return scanner.nextDouble();\n        }\n\n        public static float readFloat() {\n            return scanner.nextFloat();\n        }\n\n        public static long readLong() {\n            return scanner.nextLong();\n        }\n\n        public static char readChar() {\n            return scanner.findInLine(\"[^\\\\s]\").charAt(0);\n        }\n\n        public static void print(Object o) {\n            writer.print(o);\n            writer.flush();\n        }\n\n        public static void println(Object o) {\n            writer.println(o);\n            writer.flush();\n        }\n    }\n\n    // Algorithms ================================\n\n    private static class Algo {\n\n        private static int binSearch(int[] array, int n, int lo, int hi) {\n            if (lo > hi) {\n                return lo;\n            }\n\n            int mid = lo + (hi - lo) / 2;\n            int cmp = (int) java.lang.Math.signum(n - array[mid]);\n            if (cmp < 0) {\n                return binSearch(array, n, lo, mid - 1);\n            } else if (cmp == 0) {\n                return mid;\n            } else {\n                return binSearch(array, n, mid + 1, hi);\n            }\n        }\n\n        private static void permutations(int n) {\n            int[] p = new int[n];\n            for (int index = 0; index < n; ++index) {\n                p[index] = index + 1;\n            }\n\n            while (true) {\n                IO.println(Arrays.toString(p));\n\n                int k = n - 1;\n                while (k > 0) {\n                    if (p[k] < p[k - 1]) {\n                        k--;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (k == 0) {\n                    break;\n                }\n                int j = n - 1;\n                while (p[j] < p[k - 1]) {\n                    j--;\n                }\n\n                int t = p[j];\n                p[j] = p[k - 1];\n                p[k - 1] = t;\n\n                int i = 0;\n                while (k + i < n - 1 - i) {\n                    t = p[k + i];\n                    p[k + i] = p[n - i - 1];\n                    p[n - i - 1] = t;\n                    i++;\n                }\n            }\n        }\n\n        private static boolean isPrime(int number) {\n            if (number <= 1) {\n                return false;\n            }\n            if (number <= 3) {\n                return true;\n            }\n            if (number % 2 == 0 || number % 3 == 0) {\n                return false;\n            }\n            int i = 5;\n            while (i * i <= number) {\n                if (number % i == 0 || number % (i + 2) == 0) {\n                    return false;\n                }\n                i += 6;\n            }\n            return true;\n        }\n\n        private static boolean isPalindrome(int number) {\n            int n = number;\n            int reverse = 0;\n            while (n > 0) {\n                reverse *= 10;\n                reverse += (n % 10);\n                n /= 10;\n            }\n            return reverse == number;\n        }\n\n        public static int gcd(int a,int b) {\n            while (b != 0) {\n                int tmp = a % b;\n                a = b;\n                b = tmp;\n            }\n            return a;\n        }\n    }\n\n    private static class Math {\n\n        static long c(int n, int k) {\n            if (n == 0 && k == 0) {\n                return 1;\n            }\n            int d = 1000;\n            int l = 1000000007;\n            long[][] c = new long[d + 1][d + 1];\n            for (int i = 1; i <= d; ++i) {\n                for (int j = 0; j <= i; ++j) {\n                    if (i == j || j == 0) {\n                        c[i][j] = 1;\n                    }\n                    else {\n                        c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % l;\n                    }\n                }\n            }\n            return c[n][k];\n        }\n    }\n\n    public static void main(String[] args) {\n        IO.setUp(System.in, System.out);\n        /*\n        try {\n            IO.setUp(new FileInputStream(\"encode.in\"), new FileOutputStream(\"encode.out\"));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return;\n        }\n        */\n        solve();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Frend {\n  unsigned long long m, f;\n};\nbool comparator(const Frend& a, const Frend& b) {\n  bool c1 = (a.m < b.m);\n  bool c2 = (a.m == b.m && a.f < b.f);\n  return (c1 || c2);\n}\nint main() {\n  int n, d;\n  unsigned long long ans = 0;\n  cin >> n >> d;\n  int a[n];\n  Frend frends[n];\n  unsigned long long f[n];\n  unsigned long long prefix_f[n];\n  for (int i = 0; i < n; ++i) {\n    cin >> frends[i].m >> frends[i].f;\n    f[i] = frends[i].m;\n  }\n  sort(f + 0, f + n);\n  sort(frends + 0, frends + n, &comparator);\n  for (int i = 0; i < n; i++) {\n    prefix_f[i] = frends[i].f;\n    if (i > 0) prefix_f[i] += prefix_f[i - 1];\n  }\n  for (int i = 0; i < n; i++) {\n    int x = f[i] + d - 1;\n    int q = (upper_bound(f + i, f + n, x) - f) - 1;\n    unsigned long long ctn;\n    if (i == 0) {\n      ctn = prefix_f[q];\n    } else {\n      ctn = prefix_f[q] - prefix_f[i - 1];\n    }\n    if (ctn > ans) {\n      ans = ctn;\n    }\n    if (q == n - 1) {\n      break;\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def binarySearch(aList, target, low, high):\n    while low <= high:\n        mid = (low+high)//2\n        if aList[mid][0] > target:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low - 1\n\nnd = input().split()\nnd = [int(i) for i in nd]\ndata = []\nfor i in range(nd[0]):\n    line = input().split()\n    line = [int(j) for j in line]\n    data.append(line)\n\ndata.sort()\nff_list = []\nfor i in range(nd[0]):\n    if i == 0:\n        ff_list.append(data[0][1])\n    else:\n        ff_list.append(ff_list[i-1] + data[i][1])\nmaxff = 0\nfor i in range(nd[0]):\n    last = binarySearch(data, data[i][0] + nd[1] -1, i, nd[0] - 1)\n    if i != 0:\n        if ff_list[last] - ff_list[i - 1] > maxff:\n            maxff = ff_list[last] - ff_list[i - 1]\n    else:\n        if ff_list[last] > maxff:\n            maxff = ff_list[last]\nprint(maxff)\n"
        },
        {
            "language": 3,
            "solution": "[n ,d] = [ int(x) for x in input().split()]\n\t\t\t\t\na = [[ int(x) for x in input().split()] for i in range(n)]\na.sort(key=lambda a:a[0] )\nmaxo = 0\n\ni = 0 \nj = 0\nk = 0\nwhile j < n -1 : \t\n\twhile ( j <= n -1) and (a[i][0] + d > a[j][0]) :\n\t\tk += a[j][1]\n\t\tj += 1\n\tmaxo = max(maxo,k)\n\tk -= a[i][1]\n\ti = i + 1\n\n\nmaxo = max(maxo ,a[n-1][1])\n\nprint(maxo)\n\n\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nfriends = [(0, 0)]\nfor i in range(n):\n    money, cute = map(int, input().split())\n    friends.append((money, cute))\nfriends.sort()\nsumcute = [0 for i in range(n + 1)]\nfor i in range(1, n + 1):\n    sumcute[i] = sumcute[i - 1] + friends[i][1]\nl = 1\nr = 1\nans = 0\nwhile r != len(sumcute):\n    while r != len(sumcute) - 1 and friends[r + 1][0] - friends[l][0] < d:\n        r += 1\n    ans = max(sumcute[r] - sumcute[l - 1], ans)\n    if r == len(sumcute) - 1: r += 1\n    l += 1\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MOD = 1e9 + 7;\nusing namespace std;\nint32_t main() {\n  unsigned long long n = 0;\n  unsigned long long d = 0;\n  cin >> n >> d;\n  vector<pair<unsigned long long, unsigned long long>> a(n);\n  for (unsigned long long i = 0; i < n; i++) cin >> a[i].first >> a[i].second;\n  sort(a.begin(), a.end());\n  unsigned long long ans = 0;\n  unsigned long long max = 0;\n  for (long long l = 0, r = 0; l < n && r < n; max -= a[l].second, l++) {\n    while (r < n && a[r].first - a[l].first < d) {\n      max += a[r].second;\n      r++;\n    }\n    if (max > ans) ans = max;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nms = []\nfor i in range(n):\n    ms.append(list(map(int, input().split())))\nms.sort()\nhr = 0\nhl = 0\nmini = ms[0][0]\nsumi = 0\ns = 0\nwhile hr < n:\n    mini = ms[hr][0]\n    while hl < n and (ms[hl][0] - mini) < d:\n        s += ms[hl][1]\n        hl += 1\n    if s > sumi:\n        sumi = s\n    s -= ms[hr][1]\n    hr += 1\nprint(sumi)\n"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\n\namig = []\n\nfor i in range(n):\n    d, a = map(int, input().split())\n    amig.append((d, a))\n\namig.sort()\n\nip = 0\n\nmaxi = 0\natual = 0\n\nfor i in range(0, n):\n    if(amig[i][0] - amig[ip][0] < m):\n        atual += amig[i][1]\n    else:\n        if(atual > maxi):\n            maxi = atual\n\n        while(amig[i][0] - amig[ip][0] >= m):\n                atual -= amig[ip][1]\n                ip += 1\n        atual += amig[i][1]\n\nprint(max(maxi, atual))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool comp(const pair<long long int, long long int> &a,\n          const pair<long long int, long long int> &b) {\n  return a.first < b.first;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n, d;\n  cin >> n >> d;\n  vector<pair<long long int, long long int> > arr(n);\n  for (__typeof(n) i = (0) - ((0) > (n)); i != (n) - ((0) > (n));\n       i += 1 - 2 * ((0) > (n))) {\n    cin >> arr[i].first >> arr[i].second;\n  }\n  sort(arr.begin(), arr.end(), comp);\n  long long int ma = 0;\n  vector<long long int> cum(n);\n  cum[0] = arr[0].second;\n  for (__typeof(n) i = (1) - ((1) > (n)); i != (n) - ((1) > (n));\n       i += 1 - 2 * ((1) > (n)))\n    cum[i] = cum[i - 1] + arr[i].second;\n  vector<long long int> temp(n);\n  for (__typeof(n) i = (0) - ((0) > (n)); i != (n) - ((0) > (n));\n       i += 1 - 2 * ((0) > (n)))\n    temp[i] = arr[i].first;\n  for (__typeof(n) i = (0) - ((0) > (n)); i != (n) - ((0) > (n));\n       i += 1 - 2 * ((0) > (n))) {\n    auto it = upper_bound(temp.begin(), temp.end(), temp[i] + d - 1);\n    long long int index = it - temp.begin();\n    if (index < n && (temp[index] >= d + temp[i])) index--;\n    if (index == n) index--;\n    long long int temp_ans;\n    if (i == 0)\n      temp_ans = cum[index];\n    else\n      temp_ans = cum[index] - cum[i - 1];\n    ma = max(ma, temp_ans);\n  }\n  cout << ma;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nl=[]\nfor i in range(n):\n    x,y=map(int,input().split())\n    l.append((x,y)) \nl.sort()\nv=[]\nf=[]\nfor i,j in l:\n   v.append(i)\n   f.append(j) \ncount=f[0]\nmax_count=f[0]\ni=0\nj=1\nwhile j<n:\n   max_count=max(count,max_count)\n   #print(count)\n   if v[j]-v[i]<d:\n       count+=f[j]\n       j+=1\n   else:\n       count-=f[i]\n       i+=1\n   max_count=max(count,max_count) \nprint(max_count)\n#4 5\n#75 5\n#0 100\n#150 20\n#75 1\n#5 100\n#0 7\n#11 32\n#99 10\n#46 8\n#87 54\n#4 2\n#10909234 9\n#10909236 8\n#10909237 10\n#10909235 98\n#5 6\n#5 11\n#10 11\n#11 11\n#12 11\n#100 1\n#1 1000000000\n#15 12"
        },
        {
            "language": 1,
            "solution": "import sys\n\n\ndef solution_oleksii():\n\n    n, d = map(int, next(sys.stdin).split())\n    a = sorted(map(int, l.split()) for l in sys.stdin)\n\n    j = 0\n    ans = 0\n    s = 0\n    for i in xrange(n):\n        s += a[i][1]\n        while j <= i and a[i][0] - a[j][0] >= d:\n            s -= a[j][1]\n            j = 1\n        ans = max(ans, s)\n\n    print ans\n\n\ndef radixsort(aList):\n    RADIX = 10\n    maxLength = False\n    tmp, placement = -1, 1\n\n    while not maxLength:\n        maxLength = True\n        buckets = [list() for _ in range(RADIX)]\n\n        for i in aList:\n            tmp = i[0] / placement\n            buckets[tmp % RADIX].append(i)\n            if maxLength and tmp > 0:\n                maxLength = False\n\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                aList[a] = i\n                a += 1\n\n        placement *= RADIX\n\n\ndef two_pointers(arr, d, n):\n    radixsort(arr)\n    max_ff = 0\n    r = 0\n    curr_ff = 0\n    for l in xrange(n):\n\n        while r < n and arr[r][0] - arr[l][0] < d:\n            curr_ff += arr[r][1]\n            r += 1\n\n        if max_ff < curr_ff:\n            max_ff = curr_ff\n\n        curr_ff -= arr[l][1]\n    return max_ff\n\n\ndef solution():\n    first_line = sys.stdin.readline()\n    n, d = map(int, first_line.split())\n\n    input_ = []\n    for i in range(n):\n        input_.append(tuple(map(int, sys.stdin.readline().split())))\n    if n == 1:\n        return input_[0][1]\n    else:\n        return two_pointers(input_, d, n)\n\nif __name__ == '__main__':\n\n    print solution()"
        },
        {
            "language": 4,
            "solution": "//Some of the methods are copied from GeeksforGeeks Website  \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main\n{ \n  static  Reader sc=new Reader();\n  // static FastReader sc=new FastReader(System.in);\n  static int bs(Pair p[],int l,int r,long x)\n   {\n      int ans=-1;\n      while(l<=r)\n       {\n          int m=l+(r-l)/2;\n          if(p[m].x<=x)\n           {\n              ans=m;\n              l=m+1;\n           }\n          else\n           r=m-1;\n       }\n      return ans;\n   }\n public static void main (String[] args) throws java.lang.Exception\n   {\n\ttry{\n\t    /*\n\t        int n=sc.nextInt();\n\t        ArrayList<Integer> al=new ArrayList<>();\n\t        ArrayList<Long> al=new ArrayList<>();\n\t        Set<Integer> set=new HashSet<>();\n\t        Collections.sort(al,Collections.reverseOrder());\n\t     \n\t        long n=sc.nextLong();\n\t        for(int i=0;i<n;i++) \n\t        String s=sc.next();\n\t        StringBuilder sb=new StringBuilder();\n\t     */\n\t\t  int t = 1;//sc.nextInt();\n\t\t  while(t-->0)\n\t\t    { \n\t\t       int n=sc.nextInt();\n\t\t       long d=sc.nextLong();\n\t\t       Pair p[]=new Pair[n];\n\t\t       for(int i=0;i<n;i++)\n\t\t         {\n\t\t            long m=sc.nextLong();\n\t\t            long f=sc.nextLong();\n\t\t            p[i]=new Pair(m,f);\n\t\t         }\n\t\t     Arrays.sort(p, new Comparator<Pair>() {\n            @Override\n            public int compare(Pair o1, Pair o2) {\n                if(o1.x>o2.x) return 1;\n                \n                //ALWAYS USE THIS BLOCK\n                else if(o1.x==o2.x)\n                {\n                   if(o1.y>o2.y) return -1;\n                   else return 1;\n                }\n                //THIS LOOKS SILLY,BUT IT WILL HELP U TO GET AC, DEFEATING Comparison method violates its general contract!\n                else return -1;\n            }});\n            // for(int i=0;i<n;i++)\n            //  {\n            //     out.println(p[i].x+\" \"+p[i].y);\n            //  }\n\t\t       long pre[]=new long[n];\n\t\t       pre[0]=p[0].y;\n\t\t       for(int i=1;i<n;i++)\n\t\t         {\n\t\t            pre[i]=pre[i-1]+p[i].y;\n\t\t         }\n\t\t      //print(pre);\n\t\t      long max=long_min;\n\t\t      for(int i=0;i<n;i++)\n\t\t        {\n\t\t           Pair cur=p[i];\n\t\t           long money=cur.x;\n\t\t           int ind=bs(p,0,n-1,money+d-1);\n\t\t           \n\t\t           if(ind==-1) continue;\n\t\t           int ini=i-1;\n\t\t           long val=0;\n\t\t           if(ini<0)  val=pre[ind];\n\t\t           else val=pre[ind]-pre[ini];\n\t\t           \n\t\t           max=Math.max(max,val);\n\t\t        }\n\t\t      out.println(max);\n\t\t    }\n\t     out.flush();\n\t     out.close();\n\t   }     \n\tcatch(Exception e)\n\t\t {}\n\t}\n \n /*\n   ...SOLUTION ENDS HERE...........SOLUTION ENDS HERE...\n */\n \nstatic void flag(boolean flag)\n   {\n       out.println(flag ? \"YES\" : \"NO\");\n       out.flush();\n   }\n   \n /*                     \n    Map<Long,Long> map=new HashMap<>();\n             for(int i=0;i<n;i++)\n               {\n                  if(!map.containsKey(a[i]))\n                   map.put(a[i],1);\n                 else\n                   map.replace(a[i],map.get(a[i])+1);\n               }\n     \n    Set<Map.Entry<Long,Long>> hmap=map.entrySet();\n             for(Map.Entry<Long,Long> data : hmap)\n               {\n          \n               }\n       \n   Iterator<Integer> it = set.iterator();\n          while(it.hasNext()) \n           { \n            int x=it.next();\n           }\n   */\n\nstatic void print(int a[])\n  {\n     int n=a.length;\n     for(int i=0;i<n;i++)\n       {\n          out.print(a[i]+\" \");\n       }\n     out.println();\n     out.flush();\n  }\nstatic void print(long a[])\n  {\n     int n=a.length;\n     for(int i=0;i<n;i++)\n       {\n          out.print(a[i]+\" \");\n       }\n     out.println();\n     out.flush();\n  } \nstatic void print_int(ArrayList<Integer> al)\n  {\n     int si=al.size();\n     for(int i=0;i<si;i++)\n       {\n          out.print(al.get(i)+\" \");\n       }\n     out.println();\n     out.flush();\n  }\nstatic void print_long(ArrayList<Long> al)\n  {\n     int si=al.size();\n     for(int i=0;i<si;i++)\n       {\n          out.print(al.get(i)+\" \");\n       }\n     out.println();\n     out.flush();\n  }\n\nstatic class Graph\n  {\n        int v;\n        ArrayList<Integer> list[];\n        Graph(int v)\n        {\n            this.v=v;\n            list=new ArrayList[v+1];\n            for(int i=1;i<=v;i++)\n                list[i]=new ArrayList<Integer>();\n        }\n        void addEdge(int a, int b)\n        {\n            this.list[a].add(b);\n        }\n    }\nstatic void DFS(Graph g, boolean[] visited, int u)\n\t{\n        visited[u]=true;\n        int v=0;\n        for(int i=0;i<g.list[u].size();i++)\n        {\n            v=g.list[u].get(i);\n            if(!visited[v])\n               DFS(g,visited,v);\n        }\n  } \n  \nstatic class Pair\n   {\n      long x,y;\n      Pair(long x,long y)\n       {\n          this.x=x;\n          this.y=y;\n       }\n   }\n   \nstatic long sum_array(int a[])\n {\n    int n=a.length;\n    long sum=0;\n    for(int i=0;i<n;i++)\n     sum+=a[i];\n    return sum;\n }\nstatic long sum_array(long a[])\n {\n    int n=a.length;\n    long sum=0;\n    for(int i=0;i<n;i++)\n     sum+=a[i];\n    return sum;\n }\n\n static void sort(int[] a) \n   {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\nstatic void sort(long[] a) \n   {\n\t\tArrayList<Long> l=new ArrayList<>();\n\t\tfor (long i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\nstatic void reverse_array(int a[])\n {\n    int n=a.length;\n    int i,t; \n    for (i = 0; i < n / 2; i++) { \n            t = a[i]; \n            a[i] = a[n - i - 1]; \n            a[n - i - 1] = t; \n        } \n }\nstatic void reverse_array(long a[])\n {\n    int n=a.length;\n    int i; long t; \n    for (i = 0; i < n / 2; i++) { \n            t = a[i]; \n            a[i] = a[n - i - 1]; \n            a[n - i - 1] = t; \n        } \n }\n \nstatic long gcd(long a, long b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \nstatic int gcd(int a, int b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \n\n   static class FastReader{\n \n        byte[] buf = new byte[2048];\n        int index, total;\n        InputStream in;\n \n        FastReader(InputStream is) {\n            in = is;\n        }\n \n        int scan() throws IOException {\n            if (index >= total) {\n                index = 0;\n                total = in.read(buf);\n                if (total <= 0) {\n                    return -1;\n                }\n            }\n            return buf[index++];\n        }\n \n        String next() throws IOException {\n            int c;\n            for (c = scan(); c <= 32; c = scan());\n            StringBuilder sb = new StringBuilder();\n            for (; c > 32; c = scan()) {\n                sb.append((char) c);\n            }\n            return sb.toString();\n        }\n \n        int nextInt() throws IOException {\n            int c, val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n \n        long nextLong() throws IOException {\n            int c;\n            long val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n    }\n   \n    static class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    }\n  static  PrintWriter out=new PrintWriter(System.out);\n  static int int_max=Integer.MAX_VALUE;\n  static int int_min=Integer.MIN_VALUE;\n  static long long_max=Long.MAX_VALUE;\n  static long long_min=Long.MIN_VALUE;\n}\n// Thank You !"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main{\n    public static void main (String[] args) throws java.lang.Exception{\n        //BufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n        InputReader in=new InputReader(System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        int n=in.readInt();\n        int d=in.readInt();\n        Integer[][] a=new Integer[n][2];\n        for(int i=0;i<n;i++){\n            a[i][0]=in.readInt();\n            a[i][1]=in.readInt();\n        }\n        Arrays.sort(a,new ColumnComparator(0, SortingOrder.DESCENDING));\n        long max=0;\n        long present=0;\n        int last_at=0;\n        for(int i=0;i<n;i++){\n            present+=a[i][1];\n            while((a[last_at][0]-a[i][0])>=d)\n                present-=a[last_at++][1];\n            max=(max>present)?max:present;\n        }\n        System.out.println(max);\n    }\n}\nenum SortingOrder{\n    ASCENDING, DESCENDING;\n};\nclass ColumnComparator implements Comparator<Comparable[]> {\n    private final int iColumn;\n    private final SortingOrder order;\n\n    public ColumnComparator(int column, SortingOrder order) {\n        this.iColumn = column;\n        this.order = order;\n    }\n\n    @Override\n    public int compare(Comparable[] c1, Comparable[] c2) {\n        int result = c1[iColumn].compareTo(c2[iColumn]);\n        return order==SortingOrder.ASCENDING ? result : -result;\n    }\n}\nclass InputReader\n{\n    private InputStream stream;\n    private byte[] buf=new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n    public InputReader(InputStream stream)\n    {this.stream=stream;}\n    public int read()\n    {\n        if(numChars==-1)\n        throw new InputMismatchException();\n        if(curChar>=numChars)\n        {\n            curChar=0;\n            try{\n                numChars=stream.read(buf);\n            }catch(IOException e){\n                throw new InputMismatchException();\n            }\n            if(numChars<=0)\n            return -1;\n        }\n        return buf[curChar++];\n    }\n    public int readInt()\n    {\n        int c=read();\n        while(isSpaceChar(c))\n            c=read();\n        int sgn=1;\n        if(c=='-')\n        {\n            sgn=-1;\n            c=read();\n        }\n        int res=0;\n        do{\n            if(c<'0'||c>'9')\n            throw new InputMismatchException();\n            res*=10;\n            res+=c-'0';\n            c=read();\n        }while(!isSpaceChar(c));\n        return res*sgn;\n    }\n    public long readLong()\n    {\n        int c=read();\n        while(isSpaceChar(c))\n            c=read();\n        int sgn=1;\n        if(c=='-')\n        {\n            sgn=-1;\n            c=read();\n        }\n        long res=0;\n        do{\n            if(c<'0'||c>'9')\n            throw new InputMismatchException();\n            res*=10;\n            res+=c-'0';\n            c=read();\n        }while(!isSpaceChar(c));\n        return res*sgn;\n    }\n    public int[] readArray(int len)\n    {\n        int c=read();\n        while(isSpaceChar(c))\n            c=read();\n        int sgn=1;\n        if(c=='-')\n        {\n            sgn=-1;\n            c=read();\n        }\n        int[] res=new int[len];int j=0;\n        do{\n            if(c<'0'||c>'9')\n            throw new InputMismatchException();\n            //res*=10;\n            res[j++]=c-'0';\n            c=read();\n        }while(!isSpaceChar(c));\n        return res;\n    }\n    public String readString()\n    {\n        int c=read();\n        while(isSpaceChar(c))\n            c=read();\n        StringBuilder res=new StringBuilder();\n        do{\n            res.appendCodePoint(c);\n            c=read();\n        }while(!isSpaceChar(c));\n        return res.toString();\n    }\n    public boolean isSpaceChar(int c)\n    {\n        if(filter!=null)\n            return filter.isSpaceChar(c);\n        return c==' '||c=='\\n'||c=='\\r'||c=='\\t'||c==-1;\n    }\n    public String next()\n    {\n        return readString();\n    }\n    public interface SpaceCharFilter\n    {\n        public boolean isSpaceChar(int ch);\n    }\n}"
        },
        {
            "language": 1,
            "solution": "n,d = map(int,raw_input().split())\nm = [0]*n\nf = [0]*n\n\nfor i in range(n):\n    m[i],f[i] = map(int,raw_input().split())\n\nmf = zip(m,f)\nmf = sorted(mf)\nm = [mf[i][0] for i in xrange(n)]\nf = [mf[i][1] for i in xrange(n)]\n\ni = 0\nj = 1\nfmax = f[i]\ncurr = f[i]\nwhile j<n:\n    if m[j]-m[i]<d:\n        curr += f[j]\n        j += 1\n    else:\n        fmax = max(fmax,curr)\n        curr -= f[i]\n        if i==j:\n            i+=1\n            j+=1\n        else:\n            i += 1\nprint max(fmax,curr)\n"
        },
        {
            "language": 1,
            "solution": "\"\"\"\nHacker = 'xceptor'\nI Love Venila\n\"\"\"\ntake = lambda: map(int, raw_input().split())\nN, d = take()\na = sorted(tuple(take()) for i in range(N))\ni, mini, cur, ans = 0, a[0][0], 0, 0\nfor m, f in a:\n    cur += f\n    if m - mini >= d:\n        while m - a[i][0] >= d:\n            cur -= a[i][1]\n            i += 1\n        mini = a[i][0]\n    ans = max(cur, ans)\nprint ans\n\n\"\"\"\n\"All Of Me\"\n\n[Verse 1:]\nWhat would I do without your smart mouth?\nDrawing me in, and you kicking me out\nYou've got my head spinning, no kidding, I can't pin you down\nWhat's going on in that beautiful mind\nI'm on your magical mystery ride\nAnd I'm so dizzy, don't know what hit me, but I'll be alright\n\n[Pre-Chorus:]\nMy head's under water\nBut I'm breathing fine\nYou're crazy and I'm out of my mind\n\n[Chorus:]\n'Cause all of me\nLoves all of you\nLove your curves and all your edges\nAll your perfect imperfections\nGive your all to me\nI'll give my all to you\nYou're my end and my beginning\nEven when I lose I'm winning\n'Cause I give you all of me\nAnd you give me all of you, oh oh\n\n[Verse 2:]\nHow many times do I have to tell you\nEven when you're crying you're beautiful too\nThe world is beating you down, I'm around through every mood\nYou're my downfall, you're my muse\nMy worst distraction, my rhythm and blues\nI can't stop singing, it's ringing, in my head for you\n\n[Pre-Chorus:]\nMy head's under water\nBut I'm breathing fine\nYou're crazy and I'm out of my mind\n\n[Chorus:]\n'Cause all of me\nLoves all of you\nLove your curves and all your edges\nAll your perfect imperfections\nGive your all to me\nI'll give my all to you\nYou're my end and my beginning\nEven when I lose I'm winning\n'Cause I give you all of me\nAnd you give me all of you, oh oh\n\n[Bridge:]\nGive me all of you\nCards on the table, we're both showing hearts\nRisking it all, though it's hard\n\n[Chorus:]\n'Cause all of me\nLoves all of you\nLove your curves and all your edges\nAll your perfect imperfections\nGive your all to me\nI'll give my all to you\nYou're my end and my beginning\nEven when I lose I'm winning\n'Cause I give you all of me\nAnd you give me all of you\n\nI give you all of me\nAnd you give me all of you, oh oh\n\"\"\""
        },
        {
            "language": 3,
            "solution": "line = input().split()\nn = int(line[0])\nd = int(line[1])\nfriends = []\nfor i in range(n):\n    line = input().split()\n    friends.append([int(line[0]), int(line[1])])\n\nfriends = sorted(friends, key=lambda x: x[0], reverse=True)\ni = 0\nfrCoef = 0\nmax = 0\n\nfor j in range (len(friends)):\n    frCoef += friends[j][1]\n    while (abs(friends[i][0] - friends[j][0]) >= d):\n        frCoef -= friends[i][1]\n        i += 1\n    if (frCoef > max):\n        max = frCoef\n\nprint(max)\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long, long long> > v;\nint main() {\n  int n, m;\n  long long s, d, res, sum;\n  cin >> n >> d;\n  for (int i = 0; i < n; ++i) {\n    cin >> m >> s;\n    v.push_back(pair<long long, long long>(m, s));\n  }\n  sort(v.begin(), v.end());\n  sum = res = v[0].second;\n  int beg = 0;\n  for (int i = 1; i < n; ++i) {\n    while ((v[i].first - v[beg].first) >= d) {\n      sum -= v[beg].second;\n      ++beg;\n    }\n    sum += v[i].second;\n    res = max(res, sum);\n  }\n  cout << res;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class money {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner scan=new Scanner(System.in);\n\t\tlong f=scan.nextLong();\n\t\tlong dif=scan.nextLong();\n\t\tArrayList<Friend> friends=new ArrayList<Friend>();\n\t\tfor(int i=0;i<f;i++){\n\t\t\tlong x=scan.nextInt();\n\t\t\tlong y=scan.nextInt();\n\t\t\tfriends.add(new Friend(x, y));\n\t\t}\n\t\tCollections.sort(friends);\n\n\t\tfor(int i=0;i+1<friends.size();i++){\n\t\t\tif(friends.get(i).money==friends.get(i+1).money){\n\t\t\t\tfriends.get(i).friendship+=friends.get(i+1).friendship;\n\t\t\t\tfriends.remove(i+1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tlong max=0;\n\t\tlong ship=0;\n\t\tint j=0;\n\t\tfor(int i=0;i<friends.size();i++){\n\t\t\t\n\t\t\t\n\t\t\tlong w=friends.get(i).money;\n\t\t\twhile(j<friends.size()&&friends.get(j).money-dif<w){\n\t\t\t\tship+=friends.get(j).friendship;\n\t\t\t\tj++;\n\n\t\t\t}\n\t\t\t\n\t\t\tmax=Math.max(max, ship);\n\t\t\tship-=friends.get(i).friendship;\n\t\t}\n\t\tSystem.out.println(max);\n\t\t\n\t}\n\n\n}\nclass Friend implements Comparable<Friend>{\n\tlong money;\n\tlong friendship;\n\tpublic Friend(long money, long friendship){\n\t\tthis.money=money;\n\t\tthis.friendship=friendship;\n\t}\n\t@Override\n\tpublic int compareTo(Friend a) {\n\t\t// TODO Auto-generated method stub\n\t\treturn Long.compare(this.money, a.money);\n\t}\n\n}\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush, nlargest, nsmallest\nfrom math import ceil, floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\n# sys.setrecursionlimit(pow(10, 6))\n# sys.stdin = open(\"input.txt\", \"r\")\n# sys.stdout = open(\"output.txt\", \"w\")\nmod = pow(10, 9) + 7\nmod2 = 998244353\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(\" \".join(map(str, var))+end)\ndef l(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\n\n\ndef cmp(a, b):\n    if a[0] < b[0]:\n        return -1\n    if a[0] > b[0]:\n        return 1\n    if a[1] > b[1]:\n        return -1\n    return 1\n\n\nn, d = sp()\nmat = []\nfor i in range(n):\n    mat.append(l())\nmat = sorted(mat, key=cmp_to_key(cmp))\nmoney, factor = [i[0] for i in mat], [i[1] for i in mat]\npref = dd(int)\npref[0] = factor[0]\nfor i in range(1, n):\n    pref[i] = pref[i-1] + factor[i]\nanswer = 0\n# print(pref)\nfor i in range(n):\n    res = factor[i]\n    temp = bl(money, money[i] + d)\n    if temp == n:\n        temp -= 1\n    while money[temp] >= money[i]+d:\n        temp -= 1\n    # print(i, temp, money, factor)\n    res += pref[temp] - pref[i]\n    # print(i, res)\n    answer = max(answer, res)\nout(answer)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  vector<pair<long long, long long> > v;\n  int n, i, j, k;\n  long long d, m, s, a, b;\n  cin >> n >> d;\n  for (i = 0; i < n; i++) {\n    cin >> a >> b;\n    v.push_back(make_pair(a, b));\n  }\n  sort(v.begin(), v.end());\n  long long maxx = 0, maxm = v[0].second;\n  j = 1;\n  for (i = 0; i < n; i++) {\n    while (j < n && (v[j].first - v[i].first) < d) {\n      maxm += v[j].second;\n      j++;\n    }\n    maxx = max(maxm, maxx);\n    maxm -= v[i].second;\n  }\n  cout << maxx << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nsigned main() {\n  long long n, d;\n  cin >> n >> d;\n  std::vector<pair<long long, long long>> a(n);\n  long long ans = 0;\n  std::vector<long long> p(n, 0);\n  for (long long i = 0; i < n; i++) cin >> a[i].first >> a[i].second;\n  sort(a.begin(), a.end());\n  p[0] = a[0].second;\n  for (long long i = 1; i < n; i++) p[i] += a[i].second + p[i - 1];\n  for (long long i = 0; i < n; i++) {\n    long long l = i, r = n, f = 0;\n    while (r - l) {\n      if (r - l <= 1) f = 1;\n      long long m = ((unsigned long long)r + (unsigned long long)l) >> 1;\n      if (a[m].first - a[i].first < d)\n        l = m;\n      else\n        r = m;\n      if (f) break;\n    }\n    ans = max(ans, p[l] - p[i] + a[i].second);\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d = map(int,input().split())\nl = []\nfor i in range(n):\n    a,b = map(int,input().split())\n    l.append([a,b])\nl.sort()\nans = l[0][1]\nc = l[0][1]\ni = 0\nj = 1\nwhile j<n:\n    if l[j][0]-l[i][0]<d:\n        c+=l[j][1]\n        j+=1\n    else:\n        c-=l[i][1]\n        i+=1\n    ans = max(ans,c)\nprint(ans)\n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long int n, d, i;\n  cin >> n >> d;\n  vector<pair<long long int, long long int> > a(n);\n  for (i = 0; i < (n); i++) cin >> a[i].first >> a[i].second;\n  sort(a.begin(), a.end());\n  long long int cnt = 0;\n  long long int ans = 0;\n  long long int left, right;\n  right = 0;\n  for (left = 0; left < n; left++) {\n    while (right < n && a[right].first - a[left].first < d) {\n      cnt += a[right].second;\n      right++;\n    }\n    ans = max(ans, cnt);\n    cnt -= a[left].second;\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def arr_2d(n):\n    return [[float(x) for x in stdin.readline().split()] for i in range(n)]\n\n\ndef get_col(arr, i):\n    return [row[i] for row in arr]\n\n\ndef arr_sum(arr):\n    arr.insert(0, 0)\n    return list(accumulate(arr, lambda x, y: x + y))\n\n\nfrom bisect import *\nfrom sys import stdin\nfrom itertools import accumulate\n\nn, d = map(int, stdin.readline().split())\na = sorted(arr_2d(n), key=lambda x: x[0])\ncol, ans, col2 = get_col(a, 0), 0, arr_sum(get_col(a, 1))\n\nfor i in range(n):\n    ix = bisect_right(col, a[i][0] + d - 1)\n    if ix == n or a[ix][0] > a[i][0] + d - 1:\n        ix -= 1\n    ans = max(ans, col2[ix + 1] - col2[i])\n\nprint(int(ans))\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\n#\n#\n# def binsearch(nums, target):\n#     left = 0\n#     right = len(nums) - 1\n#     while left <= right:\n#         mid = (left + right) // 2\n#         if nums[mid] == target:\n#             return mid\n#         elif nums[mid] > target:\n#             right = mid - 1\n#         elif nums[mid] < target:\n#             left = mid + 1\n#\n#     return left\n\n\nfriends = [[0, 0]]\nfor i in range(n):\n    m, f = map(int, input().split())\n    friends.append([m, f])\n\nfriends.sort()\n\n#print(friends)\nfriendship = [0]\nmonies = []\nfor i in range(1, n+1):\n    friendship.append(friendship[i-1] + friends[i][1])\n#print(friendship)\nans = 0; j = 0; diff = 0\nfor i in range(n+1):\n    diff = friends[i][0] - friends[j][0]\n    if diff < d:\n        ans = max(friendship[i] - friendship[j], ans)\n    else:\n        while diff >= d:\n            j += 1\n            diff = friends[i][0] - friends[j][0]\n        j -= 1\n        ans = max(ans, friendship[i] - friendship[j])\n\nprint(ans)\n# for i in range(n):\n#     monies.append(friends[i][0])\n#\n# print(friendship, monies)\n# res = []\n# for i in friends:\n#     left = binsearch(monies, i[0]-d+.1)\n#     right = binsearch(monies, i[0]+d-.1)\n#     print(left, right, i)\n#     res.append(friendship[right] - friendship[left])\n# print(res)\n# print(max(res))"
        },
        {
            "language": 3,
            "solution": "n, d = [int(x) for x in input().split()]\nli = []\nfor i in range(n):\n    l = list(map(int, input().split()))\n    li.append(l)\nli.sort()\nlii = []\nb = 0\nfor i in range(n):\n    if i == 0:\n        num = 0\n    else:\n        num = num - li[i - 1][1]\n    a = 0\n    for j in range(b, n):\n        if li[j][0] < li[i][0] + d:\n            num += li[j][1]\n        else:\n            a = 1\n            b = j\n            break\n    if a == 0:\n        b = n\n    lii.append(num)\nprint(max(lii))"
        },
        {
            "language": 3,
            "solution": "#maximum you never know\nn , d=  input().split()\nn = int(n)\nd = int(d)\nlist1 =[]\nj = 0\nfor i in range(n):\n    list1.append([int(a) for a in input().split()])\nlist1.sort()\nlist2 = []\nm1 = summ = j= 0\nfor i in range(len(list1)):\n    summ += list1[i][1]\n    while(list1[i][0] - list1[j][0] >=d):\n        summ-= list1[j][1]\n        j+=1\n    m1 = max(summ,m1) \n#print(list2)\nprint(m1)\n\n\n#print(list1)"
        },
        {
            "language": 3,
            "solution": "# key missing \"\"\nn, d = [int(i) for i in input().split()]\nlis = []\nfor i in range(n):\n    x, y = [int(i) for i in input().split()]\n    lis.append([x, y])\nlis.sort()\npre_sum = [0]*n\npre_sum[0] = lis[0][1]\nfor i in range(1, n):\n    pre_sum[i] = pre_sum[i-1]+lis[i][1]\nstart = end = 0\nans = 0\n#print(lis)\n#print(pre_sum)\nwhile end < n:\n    if (lis[end][0] - lis[start][0]) < d:\n        if start == 0:\n            ans = max(ans, pre_sum[end])\n        else:\n            ans = max(ans,pre_sum[end] - pre_sum[start-1])\n        end += 1\n    else:\n        start += 1\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "lst=[]\nn,d=map(int,input().split())\nfor i in range(n):\n    mi,si = map(int,input().split())\n    lst.append([mi,si])\nlst.sort()\nf=0;l=0;ans=0;a=0\nwhile l<n :\n    if lst[l][0]-lst[f][0]<d:\n            a+=lst[l][1]\n            l+=1\n    else:\n        if a > ans:\n                ans=a\n        a-=lst[f][1]        \n        f=f+1\nprint(max(ans,a))    \n    \n"
        },
        {
            "language": 1,
            "solution": "def search(array, start_idx, end_idx, search_val):\n    if start_idx == end_idx:\n        if array[start_idx] <= search_val:\n            return start_idx\n        else:\n            return -1\n\n    mid_idx = start_idx + (end_idx - start_idx) // 2\n\n    if search_val < array[mid_idx]:\n        return search(array, start_idx, mid_idx, search_val)\n\n    ret = search(array, mid_idx+1, end_idx, search_val)\n    if ret == -1:\n        return mid_idx\n    else:\n        return ret\n\n\nn, d = map(int, raw_input().split())\n\nmny_fship = {}\n\nfor i in xrange(n):\n    m, f = map(int, raw_input().split())\n    if m in mny_fship:\n        mny_fship[m] += f\n    else:\n        mny_fship[m] = f\n\nmoneys = sorted(mny_fship.keys())\nfor i in xrange(1, len(moneys)):\n    mny_fship[moneys[i]] += mny_fship[moneys[i - 1]]\n\nmax_fship = 0\nfor i in xrange(len(moneys)):\n    end = search(moneys, i, len(moneys) - 1, moneys[i] + d - 1)\n\n    if i == end == 0:\n        fship = mny_fship[moneys[end]]\n    elif i == 0:\n        fship = mny_fship[moneys[end]]\n    elif i == end:\n        fship = mny_fship[moneys[end]] - mny_fship[moneys[end - 1]]\n    else:\n        fship = mny_fship[moneys[end]] - mny_fship[moneys[i - 1]]\n\n    if fship > max_fship:\n        max_fship = fship\n\nprint max_fship\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class b {\n    class friend implements Comparable<friend> { \n        int money, factor;\n        friend(int money, int factor) {\n            this.money = money;\n            this.factor = factor;\n        }\n        public int compareTo(friend that) {\n            return this.money - that.money;\n        }\n        public String toString() {\n            return this.money + \"\"; \n        }\n    }\n\n    private void solve() throws IOException {\n        int n = nextInt(), f = nextInt();\n        friend[] friends = new friend[n];\n        for(int i = 0; i < n; ++i) {\n            friends[i] = new friend(nextInt(), nextInt()); \n        }\n\n        Arrays.sort(friends);\n        long r = 0, factor = 0;\n        for(int i = 0, j = 0; i < n; ++i) {\n            while(j < i && friends[i].money - friends[j].money >= f) {\n                factor -= friends[j].factor;\n                ++j; \n            }\n            factor += friends[i].factor;\n            r = Math.max(r, factor);\n        }\n        System.out.println(r);\n    }\n\n    static void debug(Object...o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            String s = br.readLine();\n            if(s != null) {\n                st = new StringTokenizer(s);\n            }\n        }\n        if(st.hasMoreTokens()) {\n            return st.nextToken();\n        } else {\n            return null;\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    String nextLine(){\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n\n    private void run() throws IOException {\n        //br = new BufferedReader(new FileReader(\"b.in\"));\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        //out = new PrintWriter(\"b.out\");\n        solve();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new b().run();\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout\nlines = stdin.readlines()\nn, d = int(lines[0].split()[0]), int(lines[0].split()[1])\nmat = [[int(x.split()[0]),int(x.split()[1])]  for x in lines[1:]]\nmat = sorted(mat)\n\nmx = 0\ntemp_mx = 0\ni = 0\n\nfor j in range(n):\n    temp_mx += mat[j][1]\n\n    if (mat[j][0] - mat[i][0])>=d:\n        while (mat[j][0] - mat[i][0]) >= d:\n            temp_mx -= mat[i][1]\n            i += 1\n    if temp_mx>mx:mx=temp_mx\nprint(mx)\n"
        },
        {
            "language": 1,
            "solution": "def compare(item1, item2):\n    return item1[0]-item2[0]\n\n\nn, d = map(int, raw_input().split())\nfriend = []\nfor i in range(n):\n    p, f = map(int, raw_input().split())\n    friend.append([p, f])\nfriend.sort(compare)\nprefix_sum = [0]\nfor i in range(n):\n    prefix_sum.append(friend[i][1]+prefix_sum[-1])\n\nfin_ans = -10e10\nfor i in range(n):\n    price = friend[i][0]\n    find = price + d -1\n    ans = i\n    start = i\n    end = n-1\n    while start <= end:\n        mid = (start + end)//2\n        if friend[mid][0] <= find:\n            ans = mid\n            start = mid+1\n        else:\n            end = mid-1\n    s = prefix_sum[ans+1] - prefix_sum[i]\n    fin_ans = max(s, fin_ans)\n\nprint fin_ans\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, d, s = 0, kq = 0;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  pair<long long, long long> a[100005];\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) cin >> a[i].first >> a[i].second;\n  sort(a, a + n);\n  for (int j = 0, i = 0; j < n; j++) {\n    s += a[j].second;\n    while (a[j].first - a[i].first >= d) s -= a[i++].second;\n    kq = max(kq, s);\n  }\n  cout << kq;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class KefaAndCompany {\n    \n    public static class Pair implements Comparable<Pair>{\n        long money, factor;\n        \n        public Pair(long money, long factor) {\n            this.money = money;\n            this.factor = factor;\n        }\n        \n        @Override\n        public int compareTo(Pair o) {\n            if( o.money != this.money )\n                return (int)(this.money-o.money);\n            return (int)(this.factor - o.factor);\n        }\n        \n    }\n    \n    public static void main(String[] args)throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n, d;\n        \n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(st.nextToken());\n        d = Integer.parseInt(st.nextToken());\n        Pair[] v = new Pair[n+1];\n        v[0] = new Pair(0, 0);\n        for(int i=1; i<=n; i++){\n            st = new StringTokenizer(br.readLine());\n            v[i] = new Pair(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));\n        }\n        \n        Arrays.sort(v);\n        \n//      for(int i=0; i<v.length; i++){\n//          System.out.println(v[i].money+\" \"+v[i].factor);\n//      }\n        long ans = 0;\n        long cur = 0;\n        \n        int a = 1, b = 1;\n        \n        for(; a<n+1; a++){\n            cur -= v[a-1].factor;\n            while( b < v.length && v[b].money < v[a].money+d){\n                cur+=v[b].factor;\n                b++;\n                ans = Math.max(ans, cur);\n            }\n        }\n        System.out.println(ans);\n        \n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "# https://codeforces.com/problemset/problem/580/B\n\nn,d = [int(x) for x in input().split()]\nfrom collections import defaultdict\nm=defaultdict(int)\ns=defaultdict(int)\nfor i in range(n):\n  m[i],s[i]=[int(x) for x in input().split()]\n\n\n\nmmm=[m[x] for x in sorted(m,key=m.__getitem__)]\nsss=[s[x] for x in sorted(m,key=m.__getitem__)]\n#print(mmm,sss) \n#exit()\n#[print( f\" {x} m:{mmm[x]} s:{sss[x]}\") for x in range(n)]\n\n\na,b=0,0\nmx = 0\nss=sss[0]\nwhile b<n:\n  \n  dif = mmm[b]-mmm[a]\n  #print(f'a={a} b={b} ss={ss} dif={dif}')\n  if dif >= d:\n    \n    ss-=sss[a]\n    a+=1\n  elif dif < d:\n    mx = ss if ss>mx else mx\n    b+=1\n    if b<n:\n      ss+=sss[b]\n  else:\n    pass\n\nprint(mx)\n  "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize \"O2\"\nusing namespace std;\nconst unsigned long long int MOD = 1000000007;\nconst long double PI = 2 * acos(0.0);\nvector<long long int> ga(long long int n) {\n  vector<long long int> a;\n  for (long long int i = 0; i < n; i++) {\n    long long int p;\n    cin >> p;\n    a.push_back(p);\n  }\n  return move(a);\n}\nvector<unsigned long long int> gau(unsigned long long int n) {\n  vector<unsigned long long int> a;\n  for (unsigned long long int i = 0; i < n; i++) {\n    unsigned long long int p;\n    cin >> p;\n    a.push_back(p);\n  }\n  return move(a);\n}\nvector<string> gas(unsigned long long int n) {\n  vector<string> a;\n  for (unsigned long long int i = 0; i < n; i++) {\n    string p;\n    cin >> p;\n    a.push_back(p);\n  }\n  return move(a);\n}\ntemplate <typename T, typename A>\nvoid pa(vector<T, A> const &a) {\n  for (T p : a) {\n    cout << p << \" \";\n  }\n  cout << \"\\n\";\n}\nvoid yes() { cout << \"YES\\n\"; }\nvoid no() { cout << \"NO\\n\"; }\nvoid yesno(int f) {\n  if (f)\n    yes();\n  else\n    no();\n}\ntemplate <typename T>\nlong long int ceilSearch(\n    const vector<pair<unsigned long long int, unsigned long long int>> &a, T n,\n    long long int s, long long int e) {\n  if (s > e || a[s] > n || a[e] < n) return -1;\n  long long int m = (s + e) / 2, idx;\n  if (a[m] == n) {\n    idx = ceilSearch(a, n, m + 1, e);\n    return idx == -1 ? m : idx;\n  } else if (a[m] < n)\n    return ceilSearch(a, n, m + 1, e);\n  else\n    return ceilSearch(a, n, s, m - 1);\n}\nlong long int floorSearch(\n    const vector<pair<unsigned long long int, unsigned long long int>> &a,\n    unsigned long long int n, long long int s, long long int e) {\n  if (s > e || a[s].first > n) return -1;\n  if (a[e].first < n) return e;\n  long long int m = (s + e) / 2, idx;\n  if (a[m].first <= n) {\n    idx = floorSearch(a, n, m + 1, e);\n    return idx == -1 ? m : idx;\n  } else {\n    return floorSearch(a, n, s, m - 1);\n  }\n}\nvoid solve() {\n  unsigned long long int n, d;\n  cin >> n >> d;\n  vector<pair<unsigned long long int, unsigned long long int>> data;\n  for (unsigned long long int i = 0; i < n; i++) {\n    unsigned long long int a, b;\n    cin >> a >> b;\n    data.push_back(make_pair(a, b));\n  }\n  sort(data.begin(), data.end());\n  vector<unsigned long long int> sum(n);\n  sum[0] = data[0].second;\n  for (unsigned long long int i = 1; i < n; i++) {\n    sum[i] = sum[i - 1] + data[i].second;\n  }\n  unsigned long long int m = 0;\n  for (unsigned long long int i = 0; i < n; i++) {\n    long long int next = floorSearch(data, data[i].first + d - 1, 0, n - 1);\n    if (sum[next] - sum[i] + data[i].second > m)\n      m = sum[next] - sum[i] + data[i].second;\n    ;\n  }\n  cout << m;\n}\nint main(void) {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\n\n\npublic final class CF_321_Restaurant {\n\n\tvoid log(int[] X){\n\t\tint L=X.length;\n\t\tfor (int i=0;i<L;i++){\n\t\t\tlogWln(X[i]+\" \");\n\t\t}\n\t\tlog(\"\");\n\t}\n\n\n\tvoid log(long[] X){\n\t\tint L=X.length;\n\t\tfor (int i=0;i<L;i++){\n\t\t\tlogWln(X[i]+\" \");\n\t\t}\n\t\tlog(\"\");\n\t}\n\tvoid log(Object[] X){\n\t\tint L=X.length;\n\t\tfor (int i=0;i<L;i++){\n\t\t\tlogWln(X[i]+\" \");\n\t\t}\n\t\tlog(\"\");\n\t}\n\n\n\tvoid log(Object o){\n\t\tlogWln(o+\"\\n\");\n\t}\n\n\tvoid logWln(Object o){\n\t\tSystem.out.print(o);\n\t\t//outputWln(o);\n\n\t}\n\tvoid info(Object o){\n\t\tSystem.out.println(o);\n\t\t//output(o);\n\t}\n\n\tvoid output(Object o){\n\n\t\toutputWln(\"\"+o+\"\\n\");\n\n\t}\n\n\tvoid outputWln(Object o){\n\t\t// System.out.print(o);\n\n\t\ttry {\n\t\t\tout.write(\"\"+ o);\n\t\t} catch (Exception e) {\n\n\t\t}\n\t}\n\n\tclass Composite implements Comparable<Composite>{\n\t\tint idx;\n\t\tint m;\n\t\tint s;\n\t\t\n\t\tpublic int compareTo(Composite X){\n\t\t\tif (m!=X.m)\n\t\t\t\treturn m-X.m;\n\t\t\treturn idx-X.idx;\n\t\t}\n\n\t\tpublic Composite(int idx,int m,int s) {\n\t\t\tthis.idx = idx;\n\t\t\tthis.m=m;\n\t\t\tthis.s=s;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tvoid solve(){\n\t\tComposite[] friends=new Composite[N];\n\t\tfor (int i=0;i<N;i++){\n\t\t\tfriends[i]=new Composite(i,m[i],s[i]);\n\t\t}\n\t\tArrays.sort(friends);\n\t\tlong max=0;\n\t\tint i=0;\n\t\tint j=0;\n\t\tlong b=friends[0].s;\n\t\tlong a=0;\n\t\twhile (i<N){\n\t\t\twhile (j+1<N && friends[j+1].m-friends[i].m<D) {\n\t\t\t\tj++;\n\t\t\t\tb+=friends[j].s;\n\t\t\t}\n\t\t\tif (max<b-a)\n\t\t\t\tmax=b-a;\n\t\t\ta+=friends[i].s;\n\t\t\ti++;\n\t\t}\n\t\toutput(max);\n\t}\n\n\tBufferedWriter out;\n\tint N,D;\n\tint[] a,s,m;\n\t\n\n\n\n\tvoid process() throws Exception {\n\n\n\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tInputReader reader=new InputReader(System.in);\n\n\n\n\t\tN=reader.readInt();\n\t\tm=new int[N];\n\t\ts=new int[N];\n \t\tD=reader.readInt();\n\t\n\t\tfor (int i=0;i<N;i++){\n\t\t\tm[i]=reader.readInt();\n\t\t\ts[i]=reader.readInt();\n\t\t}\n\t\tsolve();\n\t\t\n\t\t\n\t\ttry {\n\t\t\tout.close();\n\t\t}\n\t\tcatch (Exception e){}\n\n\n\t}\n\n\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tCF_321_Restaurant J=new CF_321_Restaurant();\n\n\t\tJ.process();\n\n\n\t}\n\n\n\tstatic final class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res=new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char)c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final int readInt() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg=false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d=(char)c;\n\t\t\t//log(\"d:\"+d);\n\t\t\tif (d=='-') {\n\t\t\t\tneg=true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t//log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic final long readLong() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg=false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d=(char)c;\n\t\t\t//log(\"d:\"+d);\n\t\t\tif (d=='-') {\n\t\t\t\tneg=true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t//log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\n\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n} "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long int, long long int>> f;\nvector<pair<long long int, long long int>> f2;\nlong long int number, threshold, rich, value;\nlong long int binarysearch(long long int a) {\n  long long int low = a;\n  long long int high = f2.size() - 1;\n  long long int mid;\n  long long int answer;\n  while (low <= high) {\n    mid = (low + high) / 2;\n    if (f2[mid].first - f2[a].first < threshold) {\n      answer = mid;\n      low = mid + 1;\n    } else\n      high = mid - 1;\n  }\n  return answer;\n}\nint main() {\n  cin >> number >> threshold;\n  for (int i = 0; i < number; i++) {\n    cin >> rich >> value;\n    f.push_back(make_pair(rich, value));\n  }\n  sort(f.begin(), f.end());\n  f2.push_back(make_pair(0, 0));\n  f2.push_back(make_pair(f[0].first, f[0].second));\n  for (int i = 2; i < f.size() + 1; i++)\n    f2.push_back(make_pair(f[i - 1].first, f2[i - 1].second + f[i - 1].second));\n  long long int totalvalue = 0;\n  for (int i = 1; i < f2.size(); i++) {\n    long long int curr = f2[binarysearch(i)].second - f2[i - 1].second;\n    if (curr > totalvalue) totalvalue = curr;\n  }\n  cout << totalvalue;\n}\n"
        },
        {
            "language": 3,
            "solution": "N, D = map(int, input().split())\nfriends = [tuple(map(int, input().split())) for i in range(N)]\nfriends.sort()\n\nfriendship = 0\nhi = 0\nres = 0\n\nfor lo in range(N):\n  while hi < N and friends[hi][0] - friends[lo][0] < D:\n    friendship += friends[hi][1]\n    hi += 1\n\n  res = max(res, friendship)\n  friendship -= friends[lo][1]\n\nprint(res)\n"
        },
        {
            "language": 3,
            "solution": "n,m = map(int,input().split())\na = []\nfor _ in range(n):\n    a.append(list(map(int,input().split())))\na.sort()\ns = 0\nans = 0\ncm = 0\nfor e in range(n):\n    cm+=a[e][1]\n    while a[e][0]-a[s][0]>=m:\n        cm-=a[s][1]\n        s+=1\n    ans = max(ans,cm)\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "MOD = 1000000007\nMOD2 = 998244353\nii = lambda : int(input())\nsi = lambda : input()\ndgl = lambda : list(map(int, input()))\nf = lambda : map(int, input().split())\nil = lambda : list(map(int, input().split()))\nls = lambda : list(input())\nn,d=f()\nl=[list(f()) for _ in range(n)]\nl.sort()\nmx=0\nsm=0\nj=0\nfor i in range(n):\n    while j<n and l[j][0]-l[i][0]<d:\n        sm+=l[j][1]\n        j+=1\n    mx=max(mx,sm)\n    sm-=l[i][1]\nprint(mx)"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.Map.Entry;\n\n/*\n    int n      = sc.nextInt();        // read input as integer\n    long k     = sc.nextLong();       // read input as long\n    double d   = sc.nextDouble();     // read input as double\n    String str = sc.next();           // read input as String\n    String s   = sc.nextLine();       // read whole line as String\n*/\npublic class Main {\n\n    public static PrintWriter out;\n\n    public static void main(String args[]) {\n\n        MyScanner in = new MyScanner();\n        Map<Integer, BigInteger> friends = new TreeMap<Integer, BigInteger>();\n        int n = in.nextInt();\n        int d = in.nextInt();\n        BigInteger max = new BigInteger(\"0\");\n        for(int i=0;i<n;i++){\n            int money = in.nextInt();\n            int factor_ = in.nextInt();\n            BigInteger factor = new BigInteger(String.valueOf(factor_));\n            if(friends.containsKey(money)){\n                if(max.compareTo(friends.get(money).add(factor))==-1){\n                    max = friends.get(money);\n                    max = max.add(new BigInteger(String.valueOf(factor)));\n                }\n                friends.put(money, friends.get(money).add(factor));\n            }else{\n                friends.put(money, factor);\n                 if(max.compareTo(factor)==-1)\n                     max = factor;\n            }\n        }\n        \n\n        int start = -1;\n        BigInteger sum = new BigInteger(\"0\");\n        int end=-1;\n        int[] array = new int[friends.size()];\n        for(Entry<Integer, BigInteger> friend : friends.entrySet()){\n            if(start ==-1){\n                start = 0;\n                end = 0;\n                array[0] = friend.getKey();\n                sum = friend.getValue();\n            }else{\n                \n                array[end+1] = friend.getKey();\n                sum = sum.add(friend.getValue());\n                end = end+1;\n                while(start<end && array[end] -array[start]>=d){\n                    sum= sum.subtract(friends.get(array[start]));\n                    start +=1;\n                }\n                if(max.compareTo(sum)==-1){\n                    max = sum;\n                }\n                \n            }\n        }\n        System.out.println(max);\n        \n    }\n    \n    public static class MyScanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<int, int> arr[100005];\nint main() {\n  int n, i, d;\n  cin >> n >> d;\n  for (i = 1; i <= n; i++) scanf(\"%d%d\", &arr[i].first, &arr[i].second);\n  sort(arr + 1, arr + n + 1);\n  long long int ans = 0, cur = 0;\n  int l = 1;\n  for (i = 1; i <= n; i++) {\n    while ((l < i) && (arr[i].first - arr[l].first >= d)) {\n      cur -= arr[l].second;\n      l++;\n    }\n    cur += arr[i].second;\n    ans = max(ans, cur);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Rextester{\n    static class Friends implements Comparable<Friends>{\n        int money,friendship;\n        public Friends(int money,int friendship){\n            this.money = money;\n            this.friendship=friendship;\n        }\n        @Override\n        public int compareTo(Friends o){\n            return this.money-o.money;\n        }\n    }\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = new Integer(st.nextToken());\n        int k = new Integer(st.nextToken());\n        Friends[] fr = new Friends[n];\n        for(int i=0;i<n;i++){\n            StringTokenizer st1 = new StringTokenizer(br.readLine());\n            fr[i]=new Friends(new Integer(st1.nextToken()),new Integer(st1.nextToken()));\n        }\n        br.close();\n        Arrays.sort(fr);\n        int i=0,j=0;\n        long sum=0,max=0;\n        while(j<n){\n            if(fr[j].money-fr[i].money<k){\n                sum+=fr[j].friendship;\n                j++;\n            }\n            else{\n                sum-=fr[i].friendship;\n                i++;\n            }\n            max=Math.max(sum,max);\n        }\n        System.out.println(max);\n    }\n}\n            \n        "
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\n\nfriends = []\n\nfor i in xrange(n):\n\tmoney, friendship = map(int, raw_input().split())\n\tfriends.append((money,friendship))\n\nfriends.sort()\n# print friends\n# result = friends[0][1]\n# walker = 0\n# i = 0\n\nresult = 0\n\nfrontPointer = 0\nsecondPointer = 0\ntempMax = 0\n\nwhile frontPointer < len(friends) and secondPointer < len(friends):\n\n\tdiff = friends[secondPointer][0] - friends[frontPointer][0]\n\n\tif diff < d:\n\t\ttempMax += friends[secondPointer][1]\n\t\tsecondPointer += 1\n\telse:\n\t\ttempMax -= friends[frontPointer][1]\n\t\tfrontPointer += 1\n\n\tresult = max(result, tempMax)\n\n\n\n\n# while i < len(friends):\n\n# \twalker = i + 1\n# \ttemp = friends[i][1]\n# \tbreakLocation = -1\n# \twhile walker < len(friends):\n# \t\tif friends[walker][0] - friends[i][0] < d:\n# \t\t\ttemp += friends[walker][1]\n# \t\telse:\n# \t\t\tbreakLocation = friends[walker][0] - d + 1\n# \t\t\tbreak\n# \t\twalker += 1\n\n# \tresult = max(result, temp)\n\n# \timport bisect\n# \t# print breakLocation\n# \tif breakLocation > 0:\n# \t\ti = bisect.bisect_right(friends, (breakLocation, 0))\n# \t\t# print i\n# \telse:\n# \t\ti += 1\n\n\n\n\t# if walker != i+1:\n\t\t# i = walker-1\n\t# else:\n\t\t# i += 1\n\t# i = walker-1\n\n# for i in xrange(1, len(friends)):\n# \tdiff = friends[i][0] - friends[walker][0]\n\n# \tif diff > d:\n# \t\tcontinue\n# \telse:\n# \t\tresult += friends[i][1]\n# \t\twalker += 1\n\nprint result"
        },
        {
            "language": 3,
            "solution": "n, d = [int(x) for x in input().split()]\nms = []\nfor i in range(n):\n    msi = [int(x) for x in input().split()]\n    ms.append(msi)\nms = sorted(ms)\nl, u = 0, 0\nfor i in range(n):\n    if ms[i][0]-ms[0][0]>=d:\n        u = i-1\n        break\nif ms[n-1][0]-ms[0][0]<d:\n    u = n-1\npsum = [ms[0][1]]*n\nfor i in range(1,n):\n    psum[i] = psum[i-1]+ms[i][1]\nans = psum[u]\nfor i in range(1,n):\n    l = i\n    for j in range(u+1,n):\n        if ms[j][0]-ms[i][0]>=d:\n            u = j - 1\n            break\n    if ms[n-1][0]-ms[i][0]<d:\n        u = n-1\n    ans = max(ans,psum[u]-psum[l-1])\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nfriends = dict()\n\nfor _ in range(n):\n    k, v = map(int, input().split())\n    if k in friends:\n        friends[k] += v\n    else:\n        friends[k] = v\n\nans = 0\ntmp = i = j = 0\nkeys = sorted(friends.keys())\nvals = [friends[k] for k in keys]\nwhile j < len(keys):\n    while j < len(keys) and keys[j] - keys[i] < d:\n        tmp += vals[j]\n        j += 1\n    ans = max(ans, tmp)\n    tmp -= vals[i]\n    i += 1\n\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "def lb(l,r,a,k):\n    while(l<r):\n        m = (l+r)//2\n        if(a[m] < k):\n            l = m + 1\n        else:\n            r = m\n    return l\n\ndef ub(l,r,a,k):\n    while(l<r):\n        m = (l+r)//2\n        if(a[m] <= k):\n            l = m + 1\n        else:\n            r = m\n    return l\n\ndef part(a,b,v):\n    if(a-1 < 0):\n        return v[b][1]\n    return v[b][1] - v[a-1][1]\n\n\nn,m = input().split()\narr = list()\nll = list()\nfor i in range(int(n)):\n    a,b = input().split()\n    arr.append((int(a),int(b)))\n    ll.append(int(a))\narr.sort()\nll.sort()\n# print(arr)\n\nfor i in range(1,len(arr)):\n    arr[i] = (arr[i][0],arr[i][1] + arr[i-1][1])\n\n\nrpta = 0\ncnt = 0\nfor i in ll:\n    f = lb(0,int(n),ll,i-int(m)+1)\n    # print(f,u)\n    rpta = max(rpta,part(f,cnt,arr))\n    cnt = cnt +1\n\nprint(rpta)\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.Charset;\nimport java.util.*;\n\npublic class Main {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n    private void solve() {\n\n        int n = scanner.nextInt(), d = scanner.nextInt();\n\n        int[][] a = new int[n][2];\n\n        for (int i = 0; i < n; i++) {\n            a[i][0] = scanner.nextInt();\n            a[i][1] = scanner.nextInt();\n        }\n\n        Arrays.sort(a, Comparator.comparingInt(o -> o[0]));\n\n        long p[] = new long[n];\n        p[0] = a[0][1];\n\n        for (int i = 1; i < n; i++) {\n            p[i] = p[i - 1] + a[i][1];\n        }\n\n        int l = 0, r = 0;\n        long ans = Long.MIN_VALUE;\n\n\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            while (j + 1 < n && a[j + 1][0] - a[i][0] < d) {\n                j++;\n            }\n            ans = Math.max(p[j] - (i > 0 ? p[i - 1] : 0), ans);\n        }\n\n\n\n        System.out.print(ans);\n\n\n    }\n\n\n    boolean isClosed(Character c) {\n        return c == ')' || c == ']' || c == '>' || c == '}';\n    }\n\n    boolean isSame(Character c1, Character c2) {\n        return c1 == ')' && c2 == '(' || c1 == ']' && c2 == '[' || c1 == '>' && c2 == '<' || c1 == '}' && c2 == '{';\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}"
        },
        {
            "language": 1,
            "solution": "MONEY = 0\nFRIENDSHIP = 1\n\ndef company(friends, poor):\n    n = len(friends)\n    friends.sort()\n\n    max_fs = fs_sum = l = r = 0\n    while (r < n and l < n):\n        acceptable = friends[l][MONEY] + poor\n        while (r < n and friends[r][MONEY] < acceptable):\n            fs_sum += friends[r][FRIENDSHIP]\n            r += 1\n        max_fs = max(fs_sum, max_fs)\n\n        if r >= n:\n            break;\n\n        while (l < n and friends[r][MONEY] - friends[l][MONEY] >= poor):\n            fs_sum -= friends[l][FRIENDSHIP]\n            l += 1\n\n    return max_fs\n\nl1 = raw_input().split()\nn = int(l1[0])\npoor = int(l1[1])\npersons = [map(int, raw_input().split()) for _ in range(n)]\n\nprint company(persons, poor)\n"
        },
        {
            "language": 3,
            "solution": "#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\n#from fractions import *\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n#-------------------------code---------------------------#\n#vsInput()\n\nn,d=value()\na=[]\nfor _ in range(n):\n    a.append(value())\na.sort()\n#print(a)\nl=0\nh=0\ncur=0\nans=0\nwhile(h<n):\n    #cur=0\n    while(h<n and a[h][0]-a[l][0]<d):\n        cur+=a[h][1]\n        h+=1\n    #print(l,h,cur)\n    ans=max(ans,cur)\n    while(h<n and a[h][0]-a[l][0]>=d):\n        cur-=a[l][1]\n        l+=1\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "n, dr = (int(i) for i in input().split())\na = []\nfor i in range(n):\n    b = [int(i) for i in input().split()]\n    a.append(b)\n\n\nmaxim = 0\ns = 0\nd = 0\nhash = []\na.sort(key = lambda v:v[0])\nhash.append(a[0])\nd += 1\nmaxim = a[0][1]\nactual = maxim\nfor i in a[1:]:\n    while s < d:\n        if i[0] - hash[s][0] < dr:\n            break\n        actual -= hash[s][1]\n        s += 1\n    d += 1\n    hash.append(i)\n    actual += i[1]\n    maxim = max(maxim, actual)\n\nprint(maxim)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author PloadyFree\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskB {\n\t\tpublic void solve(int testNumber, InputReader in, OutputWriter out) {\n\t\t\tint n = in.readInt();\n\t\t\tlong d = in.readInt();\n\n\t\t\tList<Guy> guys = new ArrayList<>(n);\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tguys.add(new Guy(in.readInt(), in.readInt()));\n\n\t\t\tCollections.sort(guys, Comparator.comparing(Guy::getMoney));\n\n\t\t\tint minIdx = 0;\n\t\t\tlong curPoints = 0;\n\t\t\tlong maxPoints = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcurPoints += guys.get(i).getPoints();\n\n\t\t\t\twhile (guys.get(i).getMoney() - guys.get(minIdx).getMoney() >= d) {\n\t\t\t\t\tcurPoints -= guys.get(minIdx++).getPoints();\n\t\t\t\t}\n\n\t\t\t\tmaxPoints = Math.max(maxPoints, curPoints);\n\t\t\t}\n\n\t\t\tout.print(maxPoints);\n\t\t}\n\n\t}\n\n\tstatic class OutputWriter {\n\t\tprivate final PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream outputStream) {\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t}\n\n\t\tpublic OutputWriter(Writer writer) {\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n\n\t\tpublic void close() {\n\t\t\twriter.close();\n\t\t}\n\n\t\tpublic void print(long i) {\n\t\t\twriter.print(i);\n\t\t}\n\n\t}\n\n\tstatic class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int readInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn isWhitespace(c);\n\t\t}\n\n\t\tpublic static boolean isWhitespace(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\n\t\t}\n\n\t}\n\n\tstatic class Guy {\n\t\tprivate final long money;\n\t\tprivate final long points;\n\n\t\tpublic Guy(long money, long points) {\n\t\t\tthis.money = money;\n\t\t\tthis.points = points;\n\t\t}\n\n\t\tpublic long getMoney() {\n\t\t\treturn money;\n\t\t}\n\n\t\tpublic long getPoints() {\n\t\t\treturn points;\n\t\t}\n\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int INF = 1e9;\nconst int N = 100010;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nstruct node {\n  int m;\n  int s;\n} f[N];\nbool cmp(node a, node b) {\n  if (a.m == b.m) return a.s > b.s;\n  return a.m < b.m;\n}\nint n, d;\nint main() {\n  while (~scanf(\"%d%d\", &n, &d)) {\n    int idx1 = 0, idx2 = 0;\n    long long sum = 0, ans = 0;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d%d\", &f[i].m, &f[i].s);\n    }\n    sort(f, f + n, cmp);\n    while (idx2 < n && idx1 <= idx2) {\n      if (f[idx2].m - f[idx1].m < d) {\n        sum += f[idx2].s;\n        idx2++;\n      } else {\n        sum -= f[idx1].s;\n        idx1++;\n      }\n      ans = max(ans, sum);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nread_tuple = lambda _type: map(_type, input().split(' '))\nfrom math import factorial\n\n\ndef solve():\n    n, d = read_tuple(int)\n    friends = []\n    for _ in range(n):\n        m, s = read_tuple(int)\n        friends.append((m, s))\n    friends.sort(key=lambda x: x[0])\n    i, j, friendship, max_friendship = 0, 0, 0, 0\n    while j < n:\n        money_diff = friends[j][0] - friends[i][0]\n        if money_diff < d:\n            friendship += friends[j][1]\n            max_friendship = max(max_friendship, friendship)\n            j += 1\n        else:\n            friendship -= friends[i][1]\n            i += 1\n    print(max_friendship)\n\n    \n\nif __name__ == '__main__':\n    solve()"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class B {\n    public static void main(String[] args) {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = null;\n        try {\n            line = br.readLine();\n            String[] data = line.split(\" \");\n            int friendsNr = Integer.parseInt(data[0]);\n            int diff = Integer.parseInt(data[1]);\n            List<Friend> friends = new ArrayList<Friend>();\n            for (int i = 0; i < friendsNr; i++) {\n                line = br.readLine();\n                String[] split = line.split(\" \");\n                friends.add(new Friend(Integer.parseInt(split[0]), Integer.parseInt(split[1])));\n            }\n            Collections.sort(friends, new Comparator<Friend>() {\n                public int compare(Friend o1, Friend o2) {\n                    if (Integer.valueOf(o1.getMoney()).compareTo(o2.getMoney()) == 0) {\n                        return Integer.valueOf(o2.getFriendshipF()).compareTo(o1.getFriendshipF());\n                    }\n                    return Integer.valueOf(o1.getMoney()).compareTo(o2.getMoney());\n                }\n            });\n            long max = friends.get(0).getFriendshipF();\n            long[] dp = new long[friends.size()+1];\n            dp[1] = friends.get(0).getFriendshipF();\n            int lastIdx = 0;\n            for (int i = 1; i < friends.size(); i++) {\n                if(friends.get(lastIdx).getMoney() + diff <= friends.get(i).getMoney()){\n                    lastIdx = binarySearch(friends, diff, friends.get(i));\n                }\n                dp[i+1] = friends.get(i).getFriendshipF() + dp[i];\n                max = Math.max(dp[i+1] - dp[lastIdx], max);\n            }\n            System.out.println(max);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static int binarySearch(final List<Friend> friends, final int diff, Friend value) {\n        return Collections.binarySearch(friends, value, new Comparator<Friend>() {\n\n            public int compare(Friend o1, Friend o2) {\n                if (o1.getMoney() + diff > o2.getMoney()) {\n                    if (friends.indexOf(o1) == 0 || friends.get(friends.indexOf(o1) - 1).getMoney() + diff <= o2.getMoney()) {\n                        return 0;\n                    }\n                    return 1;\n                }\n                return -1;\n            }\n        });\n    }\n\n    static class Friend {\n        private int money;\n        private int friendshipF;\n\n        public Friend(int money, int friendshipF) {\n            super();\n            this.money = money;\n            this.friendshipF = friendshipF;\n        }\n\n        public int getMoney() {\n            return money;\n        }\n\n        public int getFriendshipF() {\n            return friendshipF;\n        }\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "n, money = [ int(x) for x in input().split() ]\ndata = []\n \nfor i in range(n):\n    d = [ int(x) for x in input().split() ]\n    data.append(d)\n \ndata.sort(key=lambda x: x[0])\n \ni, j, soma, soma_parcial = 0, 1, data[0][1], data[0][1] \nwhile j < n and i < n:\n    if abs(data[i][0] - data[j][0]) < money:\n        soma_parcial += data[j][1]\n        j += 1\n    else:\n        soma_parcial -= data[i][1]\n        i += 1\n    if soma_parcial > soma:\n            soma = soma_parcial\n \nprint(soma)\n\t\t\t \t\t\t\t\t\t \t\t\t\t \t\t\t\t \t\t \t \t \t\t\t"
        },
        {
            "language": 3,
            "solution": "n,d = map(int,input().split())\nfriend = [[0,0]]*n\nfor i in range(n):\n\tfriend[i] = list(map(int,input().split()))\nfriend.sort()\ni,j,ans,window=0,0,0,0\nwhile i<n:\n\tif friend[i][0]-friend[j][0]<d:\n\t\twindow  += friend[i][1]\n\t\tans = max(window,ans)\n\t\ti+=1\n\telse:\n\t\twindow -= friend[j][1]\n\t\tj+=1\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "// \"static void main\" must be defined in a public class.\nimport java.io.*;\nimport java.util.*;\nimport javafx.util.Pair;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br =new BufferedReader(new InputStreamReader(System.in));\n        String [] srt =br.readLine().split(\" \");\n        List<Pair<Integer,Integer>> dta = new ArrayList<>();\n        int n=Integer.parseInt(srt[0]);\n        int k=Integer.parseInt(srt[1]);\n    \n      long pfxAm[]=new long[n];\n        for(int i=0;i<n;i++)\n        {\n            \n            String abc[] = br.readLine().split(\" \");\n            int amn=Integer.parseInt(abc[0]);\n            int idx=Integer.parseInt(abc[1]);\n            Pair<Integer,Integer> tmp = new Pair<>(amn,idx);\n            dta.add(tmp);\n        }\n      \n      \n        long ans=0;\n        Collections.sort(dta , new Comp());\n          pfxAm[0]=dta.get(0).getValue();\n        for(int i=1;i<n;i++)\n        {\n            pfxAm[i]=pfxAm[i-1]+dta.get(i).getValue();\n        }\n        for(int i=0;i<n;i++)\n        {\n            ans = Math.max(ans,cal(dta,pfxAm,i,k));\n        }\n       // System.out.println(Arrays.toString(pfxAm)  );\n         //System.out.println(dta);\n        System.out.println(ans);\n        \n        //\n    }\n    \n    \n    \n    public static long cal(List<Pair<Integer,Integer>> dta , long arr[]  , int i ,int k  )\n    {\n        int n=dta.size()-1;\n        int l=0,h=i,s=i,e=i;\n      /*  while(l<=h)\n        {\n            int m=(l+h)/2;\n            if(dta.get(i).getKey()-dta.get(m).getKey() <k)\n            {\n                if(m==0) \n                {\n                    s=m;\n                    break;\n                }\n                else if(dta.get(i).getKey()-dta.get(m-1).getKey() >=k)\n                {\n                    s=m;\n                    break;\n                }\n                else\n                    h=m-1;\n                    \n            }\n            else\n                l=m+1;       \n        }*/\n        \n        l=i;\n        h=n;\n        while(l<=h)\n        {\n            int m=(l+h)/2;\n            if(dta.get(m).getKey()-dta.get(i).getKey() <k)\n            {\n                if(m==n) \n                {\n                    e=m;\n                    break;\n                }\n                else if(dta.get(m+1).getKey()-dta.get(i).getKey() >=k)\n                {\n                    e=m;\n                    break;\n                }\n                else\n                    l=m+1;\n                    \n            }\n            else\n                h=m-1;  \n        }\n       \n        if(s==0)\n        {  \n           // System.out.println(s+\"  \"+e+\"   \"+arr[e]);\n            return arr[e];\n         \n        }\n        else\n        {\n            \n           // System.out.println(s+\"  \"+e+\"   \"+(arr[e]-arr[s-1]));\n        return arr[e]-arr[s-1];\n             \n        }\n        \n        \n    }\n}\nclass Comp implements Comparator<Pair<Integer,Integer>>\n{\n    public int compare(Pair <Integer,Integer>p1,Pair<Integer,Integer> p2)\n    {\n      //  System.out.println(\"Yooo\"  );\n        if(p1.getKey() > p2.getKey())\n            return 1;\n        else if(p1.getKey() < p2.getKey())\n            return -1;\n        else\n            return 0;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nfriends = [list(map(int, input().split())) for _ in range(n)]\nfriends.sort()\ns = [friends[0][1]]\nfor i in range(1, n):\n    s.append(s[i-1] + friends[i][1])\n\n# print(friends)\nmx = 0\nfor i in range(n):\n    low = i+1\n    high = n\n    while low < high:\n        mid = low + (high-low)//2\n        if friends[mid][0]-friends[i][0] >= d:\n            high = mid\n        else:\n            low = mid + 1\n\n    # print(i, low-1)\n    if i == 0:\n        total = s[low-1]\n    else:\n        total = s[low-1] - s[i-1]\n\n    if mx < total:\n        mx = total\n\n    # print(total)\n\nprint(mx)\n"
        },
        {
            "language": 3,
            "solution": "n,d = list(map(int,input().split()))\n\nli = []\nfor i in range(n):\n    m,s = list(map(int,input().split()))\n    li.append([m,s])\n\nli.sort()\nr = 0\nc = 0\nj=0\nfor i in li:\n    c+=i[1]\n    while i[0]-li[j][0]>=d:\n        c-=li[j][1]\n        j+=1\n    r = max(r,c)\n\nprint(r)"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\n\nent = []\n\nfor i in range(n):\n  a, b = map(int, raw_input().split())\n  lista = [a, b]\n  ent.append(lista)\n  \nent.sort()\n\ncur = 0\nj = 0\nmaximo = 0\n\nfor i in range(len(ent)):\n  cur += ent[i][1]\n  while ( j < i and (abs(ent[i][0] - ent[j][0]) >= d)):\n    cur -= ent[j][1]\n    j+=1\n  maximo = max(maximo, cur)\n  \nprint maximo"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct ff {\n  long long int x, y;\n} pok[100001];\nbool comp(ff a, ff b) { return a.x < b.x; }\nint main() {\n  long long int i, n, m, temp, ans, k = 0;\n  scanf(\"%I64d %I64d\", &n, &m);\n  for (i = 0; i < n; i++) scanf(\"%I64d %I64d\", &pok[i].x, &pok[i].y);\n  sort(pok, pok + n, comp);\n  ans = pok[k].y;\n  temp = ans;\n  for (i = 1; i < n; i++) {\n    if (pok[i].x - pok[k].x < m) {\n      ans += pok[i].y;\n      if (ans >= temp) temp = ans;\n    } else {\n      if (ans >= temp) temp = ans;\n      ans = ans - pok[k].y;\n      k++;\n      i--;\n    }\n  }\n  printf(\"%I64d\\n\", temp);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def sortFirst(val): \n    return val[0]\n\nfriends, d = input().split()\nfriends = int(friends)\nd = int(d)\n\nmoney = []\nfor i in range(friends):\n  mon, fact = input().split()\n  mon = int(mon)\n  fact = int(fact)\n  money.append((mon,fact))\n\nmoney.sort(key = sortFirst)\n\nini = 0\ni = ini\nmaxp1 = 0\nmaximum = 0\nwhile(i <= friends - 1):\n  if(money[ini][0] + d > money[i][0]):\n    maxp1 += money[i][1]\n    i += 1\n  else:\n    maximum = max(maximum, maxp1)\n    maxp1 -= money[ini][1]\n    ini += 1\n\ntotal = max(maximum, maxp1)\nprint(total)"
        },
        {
            "language": 1,
            "solution": "friends=[]\nn,d=map(int,raw_input().split())\nfor i in range(n):\n    m,f=map(int,raw_input().split())\n    friends.append((m,f))\nfriends.sort()\n#print friends\nsofar,maxsofar,i,j=0,0,0,0\nwhile i < n and j<n:\n    while  j < n and abs(friends[i][0]-friends[j][0])<d:\n        sofar+=friends[j][1]\n        j+=1\n    \n    maxsofar=max(maxsofar,sofar)\n    \n    sofar-=friends[i][1]\n    i+=1\nprint maxsofar"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\narr=[list(map(int,input().split())) for i in range(n)]\narr.sort()\nl=0\nr=0\ns=0\nm=0\nwhile r<n:\n    while r<n and arr[r][0]-arr[l][0]<d:\n        s+=arr[r][1]\n        r+=1\n    m=max(m,s)\n    #print(*[l,r])\n    s-=arr[l][1]\n    l+=1\nprint(m)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint d = in.nextInt();\n\t\tPair[] a = new Pair[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = new Pair(in.nextInt(), in.nextInt());\n\t\t}\n\t\tArrays.sort(a, new Comparator<Pair>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\treturn o1.m-o2.m;\n\t\t\t}\n\t\t});\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tlong curFactor = 0;\n\t\tlong max = 0;\n\t\twhile (i < n) {\n\t\t\twhile (j < n) {\n\t\t\t\tif ((a[j].m - a[i].m) >= d) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcurFactor += a[j].f;\n\t\t\t\tmax = Math.max(max, curFactor);\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tcurFactor -= a[i].f;\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\n}\n\nclass Pair {\n\tint m, f;\n\n\tpublic Pair(int m, int f) {\n\t\tthis.m = m;\n\t\tthis.f = f;\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "(n,d)=map(int,raw_input().split())\nar=[]\nfor i in range(0,n):\n    (a,b)=map(int,raw_input().split())\n    ar.append([a,b])\nar.sort(key=lambda x: x[0])\nsum=0\nmaxi=0\nfor p in ar:\n    sum+=p[1]\n    p.append(sum)\n\nfirst=0\nsecond=0\nfor i in range(0,n):\n    finish=second\n    while(finish<n and ar[finish][0]-ar[i][0]<d):\n        second=finish\n        maxi=max(maxi,ar[finish][2]-ar[i][2]+ar[i][1])\n        finish+=1\nprint maxi\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class KefaAndCompany {\n    static class Friend {\n        long start, end, cost;\n        public Friend(int start, int end, int cost) {\n            this.start = start;\n            this.end = end;\n            this.cost = cost;\n        }\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt(), d = in.nextInt();\n        List<Friend> friends = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int start = in.nextInt();\n            int cost = in.nextInt();\n            friends.add(new Friend(start, start + d, cost));\n        }\n        Collections.sort(friends, Comparator.comparingLong(a -> a.start));\n        int sIndex = 0;\n        long ret = 0, sum = 0;\n        for (int i = 0; i < friends.size(); i++) {\n            long endTime = friends.get(i).end;\n            while (sIndex < friends.size() && friends.get(sIndex).start < endTime) {\n                sum += friends.get(sIndex).cost;\n                sIndex++;\n            }\n            ret = Math.max(ret, sum);\n            sum -= friends.get(i).cost;\n        }\n        System.out.println(ret);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport static java.lang.System.out;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\n    static int n, d;\n    static ArrayList<F> ll = new ArrayList<>();\n\n    public static void main(String[] args) {\n        Input(new FastReader());\n        Solve();\n    }\n\n    public static void Solve() {\n        Collections.sort(ll);\n        long ans = 0;\n        long max = 0;\n        int l = 0, r = 0;\n        while (r < n) {\n            if (Math.abs(ll.get(l).m - ll.get(r).m) < d) {\n                ans += ll.get(r).f;\n                r++;\n            } else {\n                ans -= ll.get(l).f;\n                l++;\n            }\n            max = Math.max(ans, max);\n        }\n        out.println(max);\n\n    }\n\n\n    public static void Input(FastReader input) {\n        n = input.nextInt();\n        d = input.nextInt();\n        IntStream.range(0, n).forEach(i -> ll.add(new F(input.nextInt(), input.nextInt())));\n    }\n\n    static class F implements Comparable<F> {\n        int m;\n        int f;\n\n        public F(int m, int f) {\n            this.m = m;\n            this.f = f;\n        }\n\n        @Override\n        public int compareTo(F f) {\n            return m - f.m;\n        }\n    }\n\n\n    public static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String string = \"\";\n            try {\n                string = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return string;\n        }\n\n        char nextChar() {\n            return next().charAt(0);\n        }\n\n        String[] nextStringArray() {\n            String[] str = null;\n            try {\n                str = this.br.readLine().trim().split(\" \");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] nextIntArray() {\n            String[] data = nextStringArray();\n            int[] a = new int[data.length];\n\n            for (int i = 0; i < a.length; i++) {\n                a[i] = Integer.parseInt(data[i]);\n            }\n\n            return a;\n        }\n\n        Integer[] nextIntegerArray() {\n            String[] data = nextStringArray();\n            Integer[] a = new Integer[data.length];\n\n            for (int i = 0; i < a.length; i++) {\n                a[i] = Integer.parseInt(data[i]);\n            }\n\n            return a;\n        }\n\n        long[] nextLongArray() {\n            String[] data = nextStringArray();\n            long[] a = new long[data.length];\n\n            for (int i = 0; i < a.length; i++) {\n                a[i] = Long.parseLong(data[i]);\n            }\n\n            return a;\n        }\n\n        public boolean hasNext() throws IOException {\n            if (st != null && st.hasMoreTokens()) {\n                return true;\n            }\n            String s = br.readLine();\n            if (s == null || s.isEmpty()) {\n                return false;\n            }\n            st = new StringTokenizer(s);\n            return true;\n        }\n\n    }\n\n\n}\n\n\n"
        },
        {
            "language": 3,
            "solution": "n,d = [int(i) for i in input().split()]\nf = sorted([list(map(int,input().split())) for i in range(n)])\ntemp = inv = f[0][1]\nj = 0\nfor i in range(1,n):  \n    while f[i][0] >= f[j][0]+d:\n        temp-=f[j][1]\n        j+=1\n    temp += f[i][1]\n    inv = max(temp,inv)\nprint(inv)"
        },
        {
            "language": 3,
            "solution": "a,b=map(int,input().split())\nl=[]\nfor i in range(a):\n    l.append(list(map(int,input().split())))\nl.sort()\nhr=0\nhl=0\nsi=0\ns=0\nmi=l[0][0]\nwhile a>hr:\n    mi=l[hr][0]\n    while hl<a and l[hl][0]-mi<b:\n        s+=l[hl][1]\n        hl+=1\n    if s>si:\n        si=s\n    s-=l[hr][1]\n    hr+=1\nprint(si)\n\n \t     \t\t \t \t \t \t \t  \t\t   \t  \t\t"
        },
        {
            "language": 1,
            "solution": "__author__ = 'aste'\n\ndef main():\n    n, d = [int(x) for x in raw_input().split()]\n    friends = []\n    for i in range(0, n, 1):\n        m, s = [int(x) for x in raw_input().split()]\n        friends.append((m, s))\n    friends.sort(key=lambda tup: tup[0])\n    max_factor = 0\n    cur_factor = friends[0][1]\n    start = 0\n    end = 1\n    while end < n:\n        if friends[end][0] - friends[start][0] >= d:\n            max_factor = max(max_factor, cur_factor)\n            cur_factor -= friends[start][1]\n            start += 1\n        else:\n            cur_factor += friends[end][1]\n            end += 1\n    max_factor = max(max_factor, cur_factor)\n    print max_factor\n\nif __name__ == \"__main__\":\n    main()\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main\n{\n    static int fr;\n    static int[] money;\n    static int[] fr_fac;\n    static int d;\n    static long max_fac=-2;\n    static int[] _money;\n    static long[] _fr_fac;\n    static TreeMap<Integer,Integer> map;\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputReader ir=new InputReader(System.in);\n\t\tOutputWriter ow=new OutputWriter(System.out);\n\t\tfr=ir.readInt();\n\t\td=ir.readInt();\n\t\tmoney=new int[fr];\n\t\tfr_fac=new int[fr];\n\t\tfor(int i=0;i<fr;++i)\n\t\t{\n\t\t\tmoney[i]=ir.readInt();\n\t\t\tfr_fac[i]=ir.readInt();\n\t\t}\n\t\tarrange();\n\t\tfor(int i=0;i<fr;++i)\n\t\t \tmax_fac=max(binarysearch(i,fr-1,_money[i]+d),max_fac);\n\t\t ow.printLine(max_fac);\n\t\t ow.flush();\n\t\t ow.close();\n\t}\n\tstatic long binarysearch(int low,int high,int elem)\n\t{\n\t\tint pr=low;\n\t\tint mid;\n\t\t//System.out.println(elem+\" elem \");\n\t\twhile(low<high)\n\t\t{\n\n            mid=low+(high-low+1)/2;\n            //System.out.println(\" mid \"+mid);\n            if(_money[mid]>=elem)\n            \thigh=mid-1;\n            else\n            \tlow=mid;\n            //System.out.println(\" low \"+low+\" high \"+high);\n\t\t}\n\t\t//System.out.println(low+\" low \");\n\t\t  return _fr_fac[low]-(pr>0?_fr_fac[pr-1]:0);          \n\t}\n\tstatic void arrange()\n\t{\n\t\tInteger[] id=new Integer[fr];\n\t\tfor(int i=0;i<fr;++i) id[i]=i;\n\t\tArrays.sort(id,new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer id1,Integer id2)\n\t\t\t{\n\t\t\t\treturn money[id1]-money[id2];\n\t\t\t}\n\t\t});\n\t_money=new int[fr];\n\t_fr_fac=new long[fr];\n\tlong sum=0;\n\t    for(int i=0;i<id.length;++i){\n\t    \t_money[i]=money[id[i]];\n\t    \t_fr_fac[i]=sum+=fr_fac[id[i]];\n\t    }\n\n\t}\n\t  static  class InputReader {     \n    \tprivate InputStream stream;\n    \tprivate byte[] buf = new byte[1024];\n    \tprivate int curChar;\n    \tprivate int numChars;\n    \tprivate SpaceCharFilter filter;\n     \n    \tpublic InputReader(InputStream stream) {\n    \t\tthis.stream = stream;\n    \t\t}     \n    \tpublic int read() {\n    \t\tif (numChars == -1)\n    \t\t    throw new InputMismatchException();\n    \t\tif (curChar >= numChars) {\n    \t\t\tcurChar = 0;\n    \t\ttry {\n    \t\t\t\tnumChars = stream.read(buf);\n    \t\t\t} catch (IOException e) {\n    \t\t\t\tthrow new InputMismatchException();\n    \t\t\t}\n    \t\tif (numChars <= 0)\n    \t\t\treturn -1;\n    \t\t\t}\n    \t\t\treturn buf[curChar++];\n    \t\t}     \n    \tpublic int readInt() {\n    \t    int c = read();\n    \t\twhile (isSpaceChar(c))\n    \t\t\t\tc = read();\n    \t\tint sgn = 1;\n    \t\tif (c == '-') {\n    \t\t\tsgn = -1;\n    \t\t\tc = read();\n    \t}\n    \t\t\tint res = 0;\n    \t\t\tdo {\n    \t\t\t\tif (c < '0' || c > '9')\n    \t\t\t\t\tthrow new InputMismatchException();\n    \t\t\t\tres *= 10;\n    \t\t\t\tres += c - '0';\n    \t\t\t\tc = read();\n    \t\t\t} while (!isSpaceChar(c));\n    \t\t\treturn res * sgn;\n    \t\t}     \n    \t\tpublic String readString() {\n    \t\t\tint c = read();\n    \t\t\twhile (isSpaceChar(c))\n    \t\t\t\tc = read();\n    \t\t\tStringBuilder res = new StringBuilder();\n    \t\t\tdo {\n    \t\t\t\tres.appendCodePoint(c);\n    \t\t\t\tc = read();\n    \t\t\t} while (!isSpaceChar(c));\n    \t\t\treturn res.toString();\n    \t\t}     \n    \t\tpublic boolean isSpaceChar(int c) {\n    \t\t\tif (filter != null)\n    \t\t\t\treturn filter.isSpaceChar(c);\n    \t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    \t\t}     \n    \t\tpublic String next() {\n    \t\t\treturn readString();\n    \t\t}     \n    \t\tpublic interface SpaceCharFilter {\n    \t\t\tpublic boolean isSpaceChar(int ch);\n    \t\t}\n    \t}     \n   static class OutputWriter {\n    \t\tprivate final PrintWriter writer;     \n    \t\tpublic OutputWriter(OutputStream outputStream) {\n    \t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    \t\t}    \n    \t\tpublic OutputWriter(Writer writer) {\n    \t\t\tthis.writer = new PrintWriter(writer);\n    \t\t}     \n    \t\tpublic void print(Object...objects) {\n    \t\t\tfor (int i = 0; i < objects.length; i++) {\n    \t\t\t\tif (i != 0)\n    \t\t\t\t\twriter.print(' ');\n    \t\t\t\twriter.print(objects[i]);\n    \t\t\t}\n    \t\t}     \n    \t\tpublic void printLine(Object...objects) {\n    \t\t\tprint(objects);\n    \t\t\twriter.println();\n    \t\t}     \n    \t\tpublic void close() {\n    \t\t\twriter.close();\n    \t\t}     \n    \t\tpublic void flush() {\n    \t\t\twriter.flush();\n    \t\t}\n        }\n    }"
        },
        {
            "language": 3,
            "solution": "debug = lambda *args: args\n\ndef search(lo, hi, frds, t):\n    while lo < hi:\n        mid = lo + int((hi - lo + 1) / 2)\n        if frds[mid][0] <= t:\n            lo = mid\n        else:\n            hi = mid - 1\n    return lo\n\n\nn, d = [int(x) for x in input().split(' ')]\nfrds = []\nz = {}\nfor i in range(n):\n    p = [int(x) for x in input().split(' ')]\n    debug(i, p, n)\n    if p[0] in z:\n        z[p[0]][1] += p[1]\n        debug('\\t', p)\n    else:\n        z[p[0]] = p\n        frds.append(p)\n\nfrds = sorted(frds)\ndebug(frds)\nscores = [0]\nfor f in frds:\n    scores.append(scores[-1] + f[1])\ndebug(scores)\n\n# for i in range(len(frds)):\n#     for j in range(i+1, len(frds)):\n#         print(i, j, scores[j] - scores[i])\n\nc = 0\nq = 0\nans = 0\nfor f in frds:\n    c += scores[q]\n    debug(frds[0][0] + d-1)\n    idx = search(q, len(frds) - 1, frds, f[0] + d-1)\n    # if frds[idx] == frds[q]:\n    #     sum = scores[idx+1] - scores[q]\n    # else:\n    sum = scores[idx+1] - scores[q]\n    debug(f, q, idx+1, sum, '\\t\\t', q, len(frds) - 1)\n    if sum > ans:\n        debug('\\t', q, ans, idx+1, sum)\n        ans = sum\n    q += 1\n\nprint(ans)\n\n# print(search(0, 3, frds, 75))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1e5 + 5;\nstd::pair<int, int> a[N];\nint main() {\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  for (int i = 0; i < n; ++i) scanf(\"%d%d\", &a[i].first, &a[i].second);\n  std::sort(a, a + n);\n  int l = 0, r = 0;\n  long long sum = 0, ans = 0;\n  for (; r < n; ++r) {\n    while (a[r].first - a[l].first >= d) sum -= (long long)a[l++].second;\n    sum += (long long)a[r].second;\n    ans = std::max(sum, ans);\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, d;\n  cin >> n >> d;\n  pair<int, int> a[n + 1];\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a, a + n);\n  long long j = 0, sum = a[0].second, max = a[0].second;\n  for (int i = 1; i < n; i++) {\n    sum += a[i].second;\n    while ((a[i].first - a[j].first) >= d) {\n      sum -= a[j].second;\n      j++;\n    }\n    if (sum > max) max = sum;\n  }\n  cout << max;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = input().split()\nn, d = int(n), int(d)\na = []\nfor i in range( n ):\n  x = input().split()\n  x[ 0 ], x[ 1 ] = int( x[ 0 ] ), int( x[ 1 ] )\n  a.append( x )\ndef cmp( x ):\n  return x[ 0 ]\na = sorted( a , key = cmp )\nans, acc, rptr = 0, 0, -1\n#  print( a )\nfor i in range( n ):\n  while rptr < n - 1 and a[ rptr + 1 ][ 0 ] < a[ i ][ 0 ] + d:\n    rptr, acc = rptr + 1, acc + a[ rptr + 1 ][ 1 ]\n  ans = max( ans , acc )\n  #  print( str( i ) + \" \" + str( rptr ) + \":\" + str( acc ) )\n  acc -= a[ i ][ 1 ]\nprint( ans )\n"
        },
        {
            "language": 3,
            "solution": "from bisect import bisect\nfrom itertools import accumulate\n\ndef intline():\n    return [int(s) for s in input().split()]\n\nn, d = intline()\n\nfriends = [intline() for i in range(n)]\n# sort by money\nfriends.sort()\n\nmoney, friendship = zip(*friends)\nfriendsums = [0] + list(accumulate(friendship))\n\n# for each start position, find the end position\n# according to d and the money array\n# then calculate the friendship from\n#   friendsums[end] - friendsums[start]\n# (subject to indexing)\n\noptimal = []\nfor i, m in enumerate(money):\n    optimal.append(friendsums[bisect(money, d + m - 1)]\n                 - friendsums[i])\n\nprint(max(optimal))\n"
        },
        {
            "language": 3,
            "solution": "def sortam(t):\n    return t[0]\ndef sortamPrim(t):\n    return t[1]\ns=input().split()\nn=int(s[0])\nd=int(s[1])\nbani_prietenie=[]\nfor i in range (n):\n    s=input().split()\n    bani_prietenie.append((int(s[0]),int(s[1])))\n\n\nbani_prietenie.sort(key=sortamPrim)\nbani_prietenie.sort(key=sortam)\n\nst=0\ndr=-1\ns=0\nmaximum=0\nwhile (st<n):\n    while (dr+1<n and bani_prietenie[dr+1][0]-bani_prietenie[st][0]<d):\n        dr+=1\n        s+=bani_prietenie[dr][1]\n    maximum=max(maximum,s)\n    s-=bani_prietenie[st][1]\n    st+=1\n\nprint(maximum)"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\na=[]\nfor i in range(n):\n    x,y=map(int,input().split())\n    a+=[(x,y)]\na.sort(key=lambda x:x[0])\ni=0\nj=0\nans=-1\nres=0\nfor i in range(n):\n    ans=max(ans,a[i][1])\n#print(a)\ni=0\nwhile(j<n):\n    #res=0\n    sm=a[i][0]\n    #print(i,end=\" \")\n    #if(a[j][0]-sm<d):\n    while(j<n and a[j][0]-sm<d):\n        res+=a[j][1]\n        #print(res,end=\" \")\n        j+=1\n    ans = max(ans, res)\n    res-=a[i][1]\n    i+=1\n    #print()\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Second {\n    static class Friend implements Comparable {\n        public int m, f;\n        public Friend(int m, int f) {\n            this.m = m;\n            this.f = f;\n        }\n        @Override\n        public int compareTo(Object o) {\n            // TODO Auto-generated method stub\n            Friend fr = (Friend) o;\n            return Integer.compare(this.m, fr.m);\n        }\n    }\n\n    public static void main(String [] artv) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int d = sc.nextInt();\n        ArrayList<Friend> ar = new ArrayList<Friend>();\n        for(int i = 0; i<n; i++) {\n            ar.add(new Friend(sc.nextInt(), sc.nextInt()));\n        }\n        Collections.sort(ar);\n        int l = 0, r = 0;\n        long s =  0, ans = 0;\n        for(int i = 0; i<ar.size(); i++) {\n            while(r < n && ar.get(r).m < ar.get(i).m + d) {\n                s += ar.get(r).f;\n                r += 1;\n            }\n            if(i > 0)\n                s -= ar.get(i - 1).f;\n//          s -= ar.get(r).f;\n            ans = Math.max(ans, s);\n            \n        }\n        System.out.println(ans);\n        \n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().strip().split())\narr = [tuple(map(int, input().strip().split())) for i in range(n)]\narr.sort()\n\nlast = 0\nmax_score = 0\ncurr_score = 0\n\nfor money, friendship in arr:\n\tif money >= last + d:\n\t\tmax_score = max(max_score, curr_score)\n\t\tcurr_score = friendship\n\t\tlast = money\n\telse:\n\t\tcurr_score += friendship\n\nmax_score = max(max_score, curr_score)\nprint(max_score)"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Morgrey\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskB {\n\t\tpublic void solve(int testNumber, InputReader in, OutputWriter out) {\n\t\t\tList<Pair<Integer, Integer>> friends = new ArrayList<>();\n\t\t\tint n = in.readInt(), d = in.readInt();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = in.readInt(), b = in.readInt();\n\t\t\t\tfriends.add(Pair.makePair(a, b));\n\t\t\t}\n\t\t\tint[] pre = new int[n];\n\t\t\tCollections.sort(friends);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpre[i] = friends.get(i).second;\n\t\t\t}\n\n\t\t\tlong[] partSum = ArrayUtils.partialSums(pre);\n\t\t\tlong ans = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint min = i - 1;\n\t\t\t\tint max = n;\n\t\t\t\twhile (max - min > 1) {\n\t\t\t\t\tint mid = (max + min) / 2;\n\t\t\t\t\tif (Math.abs(friends.get(i).first - friends.get(mid).first) >= d) {\n\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmin = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong cur = partSum[max] - partSum[i];\n\t\t\t\tans = Math.max(cur, ans);\n\t\t\t}\n\t\t\tout.printLine(ans);\n\t\t}\n\n\t}\n\n\tstatic class Pair<U, V> implements Comparable<Pair<U, V>> {\n\t\tpublic final U first;\n\t\tpublic final V second;\n\n\t\tpublic static <U, V> Pair<U, V> makePair(U first, V second) {\n\t\t\treturn new Pair<U, V>(first, second);\n\t\t}\n\n\t\tprivate Pair(U first, V second) {\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\n\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (this == o) return true;\n\t\t\tif (o == null || getClass() != o.getClass()) return false;\n\n\t\t\tPair pair = (Pair) o;\n\n\t\t\treturn !(first != null ? !first.equals(pair.first) : pair.first != null) && !(second != null ? !second.equals(pair.second) : pair.second != null);\n\n\t\t}\n\n\n\t\tpublic int hashCode() {\n\t\t\tint result = first != null ? first.hashCode() : 0;\n\t\t\tresult = 31 * result + (second != null ? second.hashCode() : 0);\n\t\t\treturn result;\n\t\t}\n\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + first + \",\" + second + \")\";\n\t\t}\n\n\t\t@SuppressWarnings({\"unchecked\"})\n\t\tpublic int compareTo(Pair<U, V> o) {\n\t\t\tint value = ((Comparable<U>) first).compareTo(o.first);\n\t\t\tif (value != 0)\n\t\t\t\treturn value;\n\t\t\treturn ((Comparable<V>) second).compareTo(o.second);\n\t\t}\n\n\t}\n\n\tstatic class ArrayUtils {\n\t\tpublic static long[] partialSums(int[] array) {\n\t\t\tlong[] result = new long[array.length + 1];\n\t\t\tfor (int i = 0; i < array.length; i++)\n\t\t\t\tresult[i + 1] = result[i] + array[i];\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\tstatic class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int readInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn isWhitespace(c);\n\t\t}\n\n\t\tpublic static boolean isWhitespace(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\n\t\t}\n\n\t}\n\n\tstatic class OutputWriter {\n\t\tprivate final PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream outputStream) {\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t}\n\n\t\tpublic OutputWriter(Writer writer) {\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n\n\t\tpublic void close() {\n\t\t\twriter.close();\n\t\t}\n\n\t\tpublic void printLine(long i) {\n\t\t\twriter.println(i);\n\t\t}\n\n\t}\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import javafx.util.Pair;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Main {\n    private final static InputReader ir = new InputReader(System.in);\n    private final static OutputWriter ow = new OutputWriter(System.out);\n    private final static int INF = Integer.MAX_VALUE;\n    private final static int NINF = Integer.MIN_VALUE;\n    private final static double PI = Math.PI;\n\n    public static void main(String[] args) throws IOException {\n        try {\n            task();\n        } finally {\n            boolean exc = false;\n            try {\n                ir.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n                exc = true;\n            }\n            try {\n                ow.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n                exc = true;\n            }\n            if (exc) System.exit(1);\n        }\n    }\n\n    private static void task() throws IOException {\n        int n = ir.nextInt(), d = ir.nextInt();\n        ArrayList<Pair<Integer, Integer>> friends = new ArrayList<>(n);\n        for (int i = 0; i < n; ++i) {\n            friends.add(new Pair<>(ir.nextInt(), ir.nextInt()));\n        }\n\n        friends.sort(Comparator.comparing(Pair::getKey));\n        long[] sum = new long[n];\n        sum[0] = friends.get(0).getValue();\n\n        for (int i = 1; i < n; ++i) {\n            sum[i] = sum[i - 1] + friends.get(i).getValue();\n        }\n\n        long ans = 0;\n\n        for (int i = 0; i < n; ++i) {\n            int lo = friends.get(i).getKey();\n            int hi = friends.get(i).getKey() + d - 1;\n\n            int il = BinarySearch.lowerBound(lo, (integer -> friends.get(integer).getKey()), 0, friends.size() - 1);\n            int ih = BinarySearch.upperBound(hi, (integer -> friends.get(integer).getKey()), 0, friends.size() - 1);\n\n            long s;\n            if (il > 0)\n                s = sum[ih] - sum[il - 1];\n            else s = sum[ih];\n\n            if (s > ans) ans = s;\n        }\n\n        ow.print(ans);\n    }\n\n    private static int max(int... objects) {\n        if (objects.length == 0)\n            throw new IllegalArgumentException(\"objects.length == 0\");\n        int max = objects[0];\n        for (int i = 1; i < objects.length; ++i) {\n            if (max < objects[i])\n                max = objects[i];\n        }\n        return max;\n    }\n\n    private static int min(int... objects) {\n        if (objects.length == 0)\n            throw new IllegalArgumentException(\"objects.length == 0\");\n        int min = objects[0];\n        for (int i = 1; i < objects.length; ++i) {\n            if (min > objects[i])\n                min = objects[i];\n        }\n        return min;\n    }\n\n    private static long pow(int x, int n) {\n        if (x == 0) return 0;\n        if (x == 1 || n == 0) return 1;\n        if (x == 2) return x << (n - 1);\n        if (n == 1) return x;\n        long t = pow(x, n / 2);\n        if (n % 2 == 0) return t * t;\n        else return t * t * x;\n    }\n\n    private static double pow(double x, int n) {\n        if (x == 0.0) return 0;\n        if (x == 1.0 || n == 0) return 1;\n        if (n == 1) return x;\n        double t = pow(x, n / 2);\n        if (n % 2 == 0) return t * t;\n        else return t * t * x;\n    }\n\n    private static int abs(int a) {\n        return (a >= 0 ? a : -a);\n    }\n}\n\nclass BinarySearch {\n    public static int rank(int key, int[] a) {\n        int lo = 0;\n        int hi = a.length - 1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (key < a[mid]) hi = mid - 1;\n            else if (key > a[mid]) lo = mid + 1;\n            else return mid;\n        }\n        return -1;\n    }\n\n    public static int lowerBound(int key, Function<Integer, Integer> f, int lo, int hi) {\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            int val = f.apply(mid);\n            if (val < key) {\n                lo = mid + 1;\n            } else if (val >= key) {\n                if (mid - 1 < 0 || f.apply(mid - 1) < key)\n                    return mid;\n                else hi = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static int upperBound(int key, Function<Integer, Integer> f, int lo, int hi) {\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            int val = f.apply(mid);\n            if (val <= key) {\n                if (mid + 1 > hi || f.apply(mid + 1) > key)\n                    return mid;\n                else lo = mid + 1;\n            } else if (val > key) {\n                hi = mid - 1;\n            } else return mid;\n        }\n        return -1;\n    }\n}\n\nclass SQRTDecomposition {\n    private int[] array;\n    private int len;\n    private int[] max;\n    private int[] min;\n\n    public SQRTDecomposition(int[] arr, boolean useIt) {\n        if (useIt)\n            array = arr;\n        else {\n            array = new int[arr.length];\n            System.arraycopy(arr, 0, array, 0, arr.length);\n        }\n        len = (int) Math.sqrt(array.length) + 1;\n        max = new int[len];\n        min = new int[len];\n        for (int i = 0; i < array.length; ++i) {\n            max[i / len] = min[i / len] = array[i];\n        }\n        for (int i = 0; i < array.length; ++i) {\n            max[i / len] = Math.max(max[i / len], array[i]);\n            min[i / len] = Math.min(min[i / len], array[i]);\n        }\n    }\n\n    public int get(int i) {\n        if (i <= 0 || i >= array.length)\n            throw new IndexOutOfBoundsException(\"Index: \" + i);\n        return array[i];\n    }\n\n    public int length() {\n        return array.length;\n    }\n\n    public int max(int l, int r) {\n        int cl = l / len, cr = r / len;\n        int m = array[l];\n        if (cl == cr) {\n            for (int i = l; i <= r; ++i) {\n                if (array[i] > m) m = array[i];\n            }\n        } else {\n            for (int i = l, end = (cl + 1) * len - 1; i <= end; ++i)\n                if (array[i] > m) m = array[i];\n            for (int i = cl + 1; i <= cr - 1; ++i)\n                if (max[i] > m) m = max[i];\n            for (int i = cr * len; i <= r; ++i)\n                if (array[i] > m) m = array[i];\n        }\n        return m;\n    }\n\n    public int min(int l, int r) {\n        int cl = l / len, cr = r / len;\n        int m = array[l];\n        if (cl == cr) {\n            for (int i = l; i <= r; ++i) {\n                if (array[i] < m) m = array[i];\n            }\n        } else {\n            for (int i = l, end = (cl + 1) * len - 1; i <= end; ++i)\n                if (array[i] < m) m = array[i];\n            for (int i = cl + 1; i <= cr - 1; ++i)\n                if (min[i] < m) m = min[i];\n            for (int i = cr * len; i <= r; ++i)\n                if (array[i] < m) m = array[i];\n        }\n        return m;\n    }\n}\n\nclass InputReader implements AutoCloseable {\n    private final InputStream in;\n    private int capacity;\n    private byte[] buffer;\n    private int len = 0;\n    private int cur = 0;\n\n    public InputReader(InputStream stream) {\n        this(stream, 100_000);\n    }\n\n    public InputReader(InputStream stream, int capacity) {\n        this.in = stream;\n        this.capacity = capacity;\n        buffer = new byte[capacity];\n    }\n\n    private boolean update() {\n        if (cur >= len) {\n            try {\n                cur = 0;\n                len = in.read(buffer, 0, capacity);\n                if (len <= 0)\n                    return false;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n        return true;\n    }\n\n    private int read() {\n        if (update())\n            return buffer[cur++];\n        else return -1;\n    }\n\n    public boolean isEmpty() {\n        return !update();\n    }\n\n    private boolean isSpace(int c) {\n        return c == '\\n' || c == '\\t' || c == '\\r' || c == ' ';\n    }\n\n    private boolean isEscape(int c) {\n        return c == '\\n' || c == '\\t' || c == '\\r' || c == -1;\n    }\n\n    private int readSkipSpace() {\n        int c;\n        do {\n            c = read();\n        } while (isSpace(c));\n        return c;\n    }\n\n    public int nextInt() {\n        int c = readSkipSpace();\n        if (c < 0)\n            throw new InputMismatchException();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c == -1) break;\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res = res * 10 + c - '0';\n            if (res < 0)\n                throw new InputMismatchException();\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    public int[] getAllInts() {\n        List<Integer> list = new LinkedList<>();\n        while (true) {\n            try {\n                int t = nextInt();\n                list.add(t);\n            } catch (InputMismatchException e) {\n                break;\n            }\n        }\n        int[] a = new int[list.size()];\n        Iterator<Integer> it = list.iterator();\n        for (int i = 0; it.hasNext(); ++i)\n            a[i] = it.next();\n        return a;\n    }\n\n    public int[] getIntArray1D(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; ++i) {\n            array[i] = nextInt();\n        }\n        return array;\n    }\n\n    public int[][] getIntArray2D(int n, int m) {\n        int[][] array = new int[n][m];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j)\n                array[i][j] = nextInt();\n        }\n        return array;\n    }\n\n    public long nextLong() {\n        int c = readSkipSpace();\n        if (c < 0)\n            throw new InputMismatchException();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c == -1) break;\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res = res * 10 + c - '0';\n            if (res < 0)\n                throw new InputMismatchException();\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    public long[] getAllLongs() {\n        List<Long> list = new LinkedList<>();\n        while (true) {\n            try {\n                long t = nextLong();\n                list.add(t);\n            } catch (InputMismatchException e) {\n                break;\n            }\n        }\n        long[] a = new long[list.size()];\n        Iterator<Long> it = list.iterator();\n        for (int i = 0; it.hasNext(); ++i)\n            a[i] = it.next();\n        return a;\n    }\n\n    public long[] getLongArray1D(int n) {\n        long[] array = new long[n];\n        for (int i = 0; i < n; ++i) {\n            array[i] = nextLong();\n        }\n        return array;\n    }\n\n    public long[][] getLongArray2D(int n, int m) {\n        long[][] array = new long[n][m];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j)\n                array[i][j] = nextLong();\n        }\n        return array;\n    }\n\n    public int nextChar() {\n        int c = readSkipSpace();\n        if (c < 0)\n            throw new InputMismatchException();\n        return c;\n    }\n\n    public String nextLine(int initialCapacity) {\n        StringBuilder res = new StringBuilder(initialCapacity);\n        int c = readSkipSpace();\n        do {\n            res.append((char) (c));\n            c = read();\n        } while (!isEscape(c));\n        return res.toString();\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n}\n\nclass OutputWriter implements Flushable, AutoCloseable {\n    private byte[] buf;\n    private final int capacity;\n    private int count;\n    private OutputStream out;\n\n    public OutputWriter(OutputStream stream) {\n        this(stream, 10_000);\n    }\n\n    public OutputWriter(OutputStream stream, int capacity) {\n        if (capacity < 0)\n            throw new IllegalArgumentException(\"capacity < 0\");\n        out = stream;\n        this.capacity = capacity;\n        if (capacity != 0) {\n            buf = new byte[capacity];\n        }\n    }\n\n    public void write(int b) throws IOException {\n        if (capacity != 0) {\n            if (count >= capacity)\n                flushBuffer();\n            buf[count++] = (byte) b;\n        } else {\n            out.write(b);\n        }\n    }\n\n    public void write(byte[] bytes, int off, int len) throws IOException {\n        if (capacity != 0) {\n            if (len >= capacity) {\n                flushBuffer();\n                out.write(bytes, off, len);\n                return;\n            }\n            if (len > capacity - count)\n                flushBuffer();\n            System.arraycopy(bytes, off, buf, count, len);\n            count += len;\n        } else out.write(bytes, off, len);\n    }\n\n    public void write(byte[] bytes) throws IOException {\n        write(bytes, 0, bytes.length);\n    }\n\n    public void println() throws IOException {\n        print(\"\\n\");\n    }\n\n    public void print(Object object) throws IOException {\n        write(String.valueOf(object).getBytes());\n    }\n\n    public void println(Object object) throws IOException {\n        print(object);\n        println();\n    }\n\n    public void print(int... ints) throws IOException {\n        print(\" \", ints);\n    }\n\n    public void println(int... ints) throws IOException {\n        print(ints);\n        println();\n    }\n\n    public void println(String separator, int... ints) throws IOException {\n        print(separator, ints);\n        println();\n    }\n\n    public void print(String separator, int... ints) throws IOException {\n        if (ints.length == 0) throw new IllegalArgumentException(\"ints.length == 0\");\n        for (int i = 0; i < ints.length; ++i) {\n            if (i != 0) print(separator);\n            print(ints[i]);\n        }\n    }\n\n    private void flushBuffer() throws IOException {\n        if (count > 0) {\n            out.write(buf, 0, count);\n            count = 0;\n        }\n    }\n\n    @Override\n    public void flush() throws IOException {\n        flushBuffer();\n        out.flush();\n    }\n\n    @Override\n    public void close() throws IOException {\n        flush();\n        out.close();\n    }\n}\n/*\nclass InputReader implements AutoCloseable {\n    private final InputStream in;\n    private int capacity;\n    private byte[] buffer;\n    private int len = 0;\n    private int cur = 0;\n\n    public InputReader(InputStream stream) {\n        this(stream, 100_000);\n    }\n\n    public InputReader(InputStream stream, int capacity) {\n        this.in = stream;\n        this.capacity = capacity;\n        buffer = new byte[capacity];\n    }\n\n    private int read() {\n        if (cur >= len) {\n            try {\n                cur = 0;\n                len = in.read(buffer, 0, capacity);\n                if (len <= 0)\n                    return -1;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n        return buffer[cur++];\n    }\n\n    private boolean isSpace(int c) {\n        return c == ' ' || isEscape(c);\n    }\n\n    private boolean isEscape(int c) {\n        return c == '\\n' || c == '\\t' || c == '\\r' || c == -1;\n    }\n\n    private int readSkipSpace() {\n        int c;\n        do {\n            c = read();\n        } while (isSpace(c));\n        return c;\n    }\n\n    int nextInt() {\n        int c = readSkipSpace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res = res * 10 + c - '0';\n            if (res < 0)\n                throw new InputMismatchException();\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    public long nextLong() {\n        int c = readSkipSpace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res = res * 10 + c - '0';\n            if (res < 0)\n                throw new InputMismatchException();\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    int nextChar() {\n        return readSkipSpace();\n    }\n\n    String nextLine(int initialCapacity) {\n        StringBuilder res = new StringBuilder(initialCapacity);\n        int c = readSkipSpace();\n        do {\n            res.append((char) (c));\n            c = read();\n        } while (!isEscape(c));\n        return res.toString();\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n}\n\nclass OutputWriter implements Flushable, AutoCloseable {\n    private byte[] buf;\n    private int capacity;\n    private int count;\n    private OutputStream out;\n\n    public OutputWriter(OutputStream stream) {\n        out = stream;\n        capacity = 10_000;\n        buf = new byte[capacity];\n    }\n\n    public OutputWriter(OutputStream stream, int capacity) {\n        if (capacity <= 0)\n            throw new IllegalArgumentException(\"capacity <= 0\");\n        out = stream;\n        this.capacity = capacity;\n        buf = new byte[capacity];\n    }\n\n    public void write(int b) throws IOException {\n        if (count >= buf.length)\n            flushBuffer();\n        buf[count++] = (byte) b;\n    }\n\n    public void write(byte[] bytes, int off, int len) throws IOException {\n        if (len >= buf.length) {\n            flushBuffer();\n            out.write(bytes, off, len);\n            return;\n        }\n        if (len > buf.length - count)\n            flushBuffer();\n        System.arraycopy(bytes, off, buf, count, len);\n        count += len;\n    }\n\n    public void write(byte[] bytes) throws IOException {\n        write(bytes, 0, bytes.length);\n    }\n\n    public void print(String str) throws IOException {\n        write(str.getBytes());\n    }\n\n    public void println() throws IOException {\n        print(\"\\n\");\n    }\n\n    public void print(Object object) throws IOException {\n        print(object.toString());\n    }\n\n    public void println(Object object) throws IOException {\n        print(object.toString());\n        println();\n    }\n\n    public void print(int... ints) throws IOException {\n        print(\" \", ints);\n    }\n\n    public void println(int... ints) throws IOException {\n        print(ints);\n        println();\n    }\n\n    public void println(String separator, int... ints) throws IOException {\n        print(separator, ints);\n        println();\n    }\n\n    public void print(String separator, int... ints) throws IOException {\n        if (ints.length == 0) throw new IllegalArgumentException(\"ints.length == 0\");\n        for (int i = 0; i < ints.length; ++i) {\n            if (i != 0) print(separator);\n            print(ints[i]);\n        }\n    }\n\n    private void flushBuffer() throws IOException {\n        if (count > 0) {\n            out.write(buf, 0, count);\n            count = 0;\n        }\n    }\n\n    @Override\n    public void flush() throws IOException {\n        flushBuffer();\n        out.flush();\n    }\n\n    @Override\n    public void close() throws IOException {\n        flush();\n        out.close();\n    }\n}\n\n*/\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int N, D;\n  scanf(\"%d %d\", &N, &D);\n  vector<pair<int, int> > v;\n  for (int i = 0; i < N; i++) {\n    int temp1, temp2;\n    scanf(\"%d %d\", &temp1, &temp2);\n    v.push_back(make_pair(temp1, temp2));\n  }\n  sort(v.begin(), v.end());\n  long long maxm_fac = v[0].second;\n  long long val = v[0].second;\n  int minm = v[0].first;\n  queue<pair<int, int> > q;\n  q.push(v[0]);\n  for (int i = 1; i < v.size(); i++) {\n    q.push(v[i]);\n    pair<int, int> temp = q.front();\n    while (v[i].first - temp.first >= D) {\n      q.pop();\n      val -= temp.second;\n      temp = q.front();\n    }\n    val += v[i].second;\n    maxm_fac = max(maxm_fac, val);\n  }\n  printf(\"%I64d\\n\", maxm_fac);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool isPrime(long long n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nlong long seve[1000000] = {0};\nvoid seive() {\n  long long i, j;\n  seve[0] = 1;\n  seve[1] = 1;\n  for (i = 2; i <= 1000000; i++) {\n    if (seve[i] == 0) {\n      for (j = i * i; j <= 1000000; j = j + i) seve[j] = 1;\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n = 0, i, m, j, k = 0, ans = 0, z, x, y, b, d;\n  string s, p;\n  cin >> n >> d;\n  vector<pair<long long, long long> > v;\n  for (i = 0; i < n; i++) {\n    cin >> x >> y;\n    v.push_back({x, y});\n  }\n  sort(v.begin(), v.end());\n  long long sum = 0;\n  j = 0;\n  for (i = 0; i < n; i++) {\n    while (j < n && v[j].first < v[i].first + d) {\n      sum += v[j].second;\n      j++;\n    }\n    ans = max(ans, sum);\n    sum -= v[i].second;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nint n, d;\nstd::pair<int, int> f[MAXN];\nvoid input() {\n  cin >> n >> d;\n  int m, s;\n  for (int i = 0; i < n; ++i) {\n    cin >> f[i].first >> f[i].second;\n  }\n}\nlong long solve() {\n  sort(f, f + n,\n       [](const std::pair<int, int> &l, const std::pair<int, int> &r) {\n         return l.first < r.first;\n       });\n  int i = 0, j = 0;\n  long long sum = 0, max = 0;\n  while (i < n && j < n) {\n    if (i) {\n      sum -= (long long)f[i - 1].second;\n    }\n    while (j < n && f[j].first - f[i].first < d) {\n      sum += (long long)f[j].second;\n      j++;\n    }\n    if (sum > max) {\n      max = sum;\n    }\n    i++;\n  }\n  return max;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  input();\n  cout << solve();\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "if __file__ == '/tmp/code.py':\n    import sys; sys.stdin = open('input.txt')\n\nn, d = map(int, raw_input().split())\n\na = sorted((map(int, raw_input().split()) for _ in xrange(n)))\n\nans = 0\nf = 0\ni = 0\nfor j in xrange(n):\n    f += a[j][1]\n    while a[j][0] - a[i][0] >= d:\n        f -= a[i][1]\n        i += 1\n    ans = max(ans, f)\n    \nprint ans"
        },
        {
            "language": 3,
            "solution": "# Kefa and Company\n\nn, d = map(int, input().split())\nfriends = []\nfor i in range(n):\n    money, friendship = map(int, input().split())\n    friends.append((money, friendship))\n\nfriends = sorted(friends)\n\ni = j = 0\nfship = 0\nmax_fship = 0\n\nwhile i < len(friends):\n    while j < len(friends) and friends[j][0] - friends[i][0] < d:\n        fship += friends[j][1]\n        j += 1\n    \n    max_fship = max(max_fship, fship)\n    fship -= friends[i][1]\n    i += 1\n\nprint(max_fship)\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nt=[]\nfor i in range(n):\n\tx,y=map(int,input().split())\n\tt+=[(x,y)]\nt=sorted(t, key=lambda colonnes: colonnes[0])\ni=0\nj=1\n(q,r)=t[0]\nvTemp=r\nrTemp=r\nqtemp=q\nv=vTemp\nwhile j<n:\n\t(x,y)=t[j]\n\tif x>=q+d:\n\t\tvTemp-=rTemp\n\t\ti+=1\n\t\t(q,r)=t[i]\n\t\tqTemp=q\n\t\trTemp=r\n\telse:\n\t\tvTemp+=y\n\t\tv=max(v,vTemp)\n\t\tj+=1\nprint(v)"
        },
        {
            "language": 3,
            "solution": "def key_sort(x):\n    return x[0]\n\n\nv = []\nn, d = input().split()\nn = int(n)\nd = int(d)\nfor i in range(n):\n    x = input().split()\n    v.append([int(x[0]), int(x[1])])\n\nv.sort(key = key_sort)\n \n\ni = j = s = m = 0\nwhile i < n and j < n:\n    if v[j][0] - v[i][0] >= d:\n        s -= v[i][1]\n        i += 1\n    else:\n        s += v[j][1]\n        j +=1\n    if s > m:\n        m = s\nprint(m)"
        },
        {
            "language": 3,
            "solution": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Jun 17 15:21:05 2020\n\n@author: Harshal\n\"\"\"\n\n\nn,d=map(int,input().split())\narr=[]\nfor _ in range(n):\n    arr.append(list(map(int,input().split())))\narr.sort()\nans=R=H=0\n\nfor i in range(n):\n    while H<n and arr[H][0]-arr[i][0]<d:\n        R+=arr[H][1] \n        H+=1\n    ans=max(ans,R)\n    R-=arr[i][1]\nprint(ans)\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\na = []\n\nfor i in range(n):\n  a.append(tuple(map(int, raw_input().split())))\na.sort()\n\ns = [0] * n\nfor i in range(n):\n  s[i] = a[i][1]\n  if i > 0:\n    s[i] += s[i - 1]\ns = [0] + s\n\ndef bi(i, d):\n  low = 0\n  high = i - 1\n  while low <= high:\n    mid = (low + high) / 2\n    value = abs(a[i][0] - a[mid][0])\n    if value < d:\n      high = mid - 1\n    else:\n      low = mid + 1\n  return low\n\nc = [0] * n\nc[0] = s[1]\nfor i in range(1, n):\n  p = bi(i, d)\n  if p != i: c[i] = s[i + 1] - s[p]\n  else: c[i] = s[i + 1] - s[i]\n\nprint max(c)\n"
        },
        {
            "language": 3,
            "solution": "import bisect\nmaxr = 10 ** 9 + 7\n[n, d] = [int(x) for x in input().split()]\na = [[0] * 2 for i in range(n)]\nfor i in range(n):\n    [a[i][0], a[i][1]] = [int(x) for x in input().split()]\na.sort()\ns = [0] * (n+1)\nfor i in range(1, n+1):\n    s[i] = a[i-1][1] + s[i-1]\nr = 0\nfor i in range(n):\n    r = max(r, s[bisect.bisect_left(a, [a[i][0] + d, -maxr])] - s[i])\nprint(r)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class MyClass {\n    static class Pair\n    {\n        long money;\n        long fren;\n        Pair(long money,long fren)\n        {\n            this.money =  money;\n            this.fren = fren;\n        }\n    }\n    public static void main(String args[]) {\n       Scanner in = new Scanner(System.in);\n       int n = in.nextInt();\n       int k = in.nextInt();\n       ArrayList<Pair> list = new ArrayList<>();\n       for(int i=0;i<n;i++)\n       {\n           long x = in.nextLong();\n           long y = in.nextLong();\n           Pair p = new Pair(x,y);\n           list.add(p);\n       }\n       Collections.sort(list,new Comparator<Pair>()\n       {\n          @Override\n          public int compare(Pair a,Pair b)\n          {\n              if(a.money>b.money)\n              return 1;\n              else if(a.money<b.money)\n              return -1;\n              else\n              return 0;\n          }\n           });\n           \n        \n        long currfren = list.get(0).fren;\n        long maxfren = list.get(0).fren;\n        long [] frend = new long[n];\n        frend[0] = list.get(0).fren;\n        for(int i=1;i<n;i++)\n        {\n            frend[i] =frend[i-1] + list.get(i).fren;\n        }\n        int prev = 0;\n        for(int i=1;i<n;i++)\n        {\n            if(list.get(i).money-list.get(prev).money>=k)\n            {\n                maxfren = Math.max(currfren,maxfren);\n                while(list.get(i).money-list.get(prev).money>=k)\n                {\n                    prev++;\n                }\n                \n                currfren = frend[i] - frend[prev-1];\n                \n            }\n            else\n            {\n                currfren += list.get(i).fren;\n                \n            }\n           \n        }\n        \n        maxfren = Math.max(maxfren,currfren);\n        System.out.println(maxfren);\n      \n        \n           \n           \n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = list(map(int, input().rstrip().split()))\nli = []\nfor i in range(n):\n    li += [list(map(int, input().rstrip().split()))]\nli.sort(key=lambda x: x[0])\nj = 0\nf = 0\nans = li[0][1]\ni = 0\nwhile i < n:\n    while li[i][0] - li[j][0] >= d:\n        f -= li[j][1]\n        j += 1\n    f += li[i][1]\n    ans = max(ans, f)\n    i += 1\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\n public class horses\n{\n\tstatic class pair\n{\n\tint key;\n\tint value;\n\tpair(int key,int value)\n\t{\n\t\tthis.key=key;\n\t\tthis.value=value;\n\t}\n}\nstatic class Sortbyroll implements Comparator<pair> \n{ \n    // Used for sorting in ascending order of \n    // roll number \n    public int compare(pair a, pair b) \n    { \n        return  a.key-b.key; \n    } \n} \n\tstatic class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[10000000]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    } \n  \n  public static void main(String args[]) throws IOException\n  {\n\t  \n\t  Reader sc=new Reader();\n\t  int n=sc.nextInt();\n\t  int k=sc.nextInt();\n\t  pair a[]=new pair[n];\n\t for(int i=0;i<n;i++)\n\t {\n\t\t pair obj=new pair(sc.nextInt(),sc.nextInt());\n\t\t a[i]=obj;\n\t }\n\t Arrays.sort(a,new Sortbyroll());\n\t int l=0;\n\t int r=0;\n\t long sm=0;\n\t long mx=-1;\n\t \n//\tfor(int i=0;i<n;i++)\n\t//\t System.out.println(\"a \"+a[i].key+\" \"+a[i].value);\n\t while(l<n&&r<n)\n\t {\n\t\t \n\t\t \n\t\t if(a[r].key-a[l].key>=k)\n\t\t {\n\t\t\t l++;\n\t\t\t if(sm>mx)\n\t\t\t\t mx=sm;\n\t\t\t sm=sm-a[l-1].value;\n\t\t\t \n\t\t\t //System.out.println(\"2 \"+sm);\n\t\t }\n\t\t \n\t\t else if(a[r].key-a[l].key<k)\n\t\t {\n\t\t\t sm+=a[r].value;\n\t\t\t r++;\n\t\t\t// System.out.println(\"3 \"+sm);\n\t\t }\n\t }\n\t if(sm>mx)\n\t\t mx=sm;\n\t System.out.println(mx);\n}\n}"
        },
        {
            "language": 1,
            "solution": "class Friend:\n\tdef __init__(self, money, factor):\n\t\tself.money = money\n\t\tself.factor = factor\n\ninput = map(int, raw_input().split())\nn_friends = input[0]\nmin_diff = input[1]\n\nfriends = []\nfor i in xrange(n_friends):\n\tinput_friend = map(int, raw_input().split())\n\tfriends.append(Friend(input_friend[0], input_friend[1]))\n\nfriends.sort(key = lambda obj: obj.money)\n\nj = 0\nmaxi = 0\ncurrent = 0\nfor i in xrange(n_friends):\n\tcurrent += friends[i].factor\n\twhile j < i and (friends[i].money - friends[j].money >= min_diff):\n\t\tcurrent -= friends[j].factor\n\t\tj += 1\n\tmaxi = max(maxi, current)\nprint maxi\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int mod = 1e9 + 7;\nconst long long int MAX = 1e5;\nvoid sujho() {\n  long long int n, diff;\n  cin >> n >> diff;\n  vector<pair<long long int, long long int>> v;\n  long long int mx = 0;\n  for (long long int i = 0; i < (n); i++) {\n    long long int x, y;\n    cin >> x >> y;\n    if (y > mx) mx = y;\n    v.push_back({x, y});\n  }\n  sort(v.begin(), v.end());\n  vector<long long int> suf(n, 0);\n  for (long long int i = 0; i < (n); i++) {\n    suf[i + 1] = v[i].second + suf[i];\n  }\n  long long int i = 0;\n  long long int j = 0;\n  while (i < n && j < n) {\n    if (i == j) {\n      mx = max(mx, suf[j + 1] - suf[j]);\n      j++;\n    } else if (v[j].first - v[i].first < diff) {\n      mx = max(mx, suf[j + 1] - suf[i]);\n      j++;\n    } else {\n      i++;\n    }\n  }\n  cout << mx << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  { sujho(); }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long llmax(long long a, long long b) { return a > b ? a : b; }\nint main() {\n  ios_base::sync_with_stdio(0);\n  vector<pair<int, int> > fr;\n  int n, d, x, y;\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) {\n    cin >> x >> y;\n    fr.push_back(make_pair(x, y));\n  }\n  sort(fr.begin(), fr.end());\n  long long sum[100005];\n  sum[0] = 0;\n  for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + fr[i - 1].second;\n  long long mm = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    vector<pair<int, int> >::iterator it;\n    it = lower_bound(fr.begin(), fr.end(), make_pair(fr[i].first - d + 1, 0));\n    int pos = it - fr.begin();\n    mm = max(sum[i + 1] - sum[pos], mm);\n  }\n  cout << mm;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > x;\nint main() {\n  int n, d;\n  cin >> n >> d;\n  x = vector<pair<int, int> >(n);\n  for (int i = 0; i < n; i++) cin >> x[i].first >> x[i].second;\n  sort(x.begin(), x.end());\n  long long maxx = 0;\n  int lo = 0;\n  long long sum = 0;\n  for (int i = 0; i < n; i++) {\n    if (x[i].first - x[lo].first < d) {\n      sum += x[i].second;\n      maxx = max(sum, maxx);\n    } else {\n      sum -= x[lo].second;\n      lo++;\n      i--;\n    }\n  }\n  cout << maxx;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "line = [int(s) for s in input().split(\" \")]\nnr_friends = line[0]\nfriends = []\nd = line[1]\nfor i in range(nr_friends):\n    line = [int(s) for s in input().split(\" \")]\n    friends.append(line)\nfriends.sort()\nmax_sum = friends[0][1]\ncurr_sum = max_sum\nremember = 0\ni = 1\nj = 0\nwhile i < len(friends):\n    if abs(friends[i][0]-friends[j][0]) < d:\n        curr_sum += friends[i][1]\n    else:\n        while abs(friends[i][0] - friends[j][0]) >= d:\n            curr_sum -= friends[j][1]\n            j += 1\n        curr_sum += friends[i][1]\n    i += 1\n    max_sum = max(max_sum, curr_sum)\nprint(max_sum)\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nfriends = sorted([list(map(int, input().split())) for i in range(n)])\n\ncurrent = friends[0][1]\nbest = current\n\nleft, right = 0, 0\nwhile True:\n  right += 1\n  if right == n:\n    break\n  current += friends[right][1]\n  while friends[right][0] - friends[left][0] >= d:\n    current -= friends[left][1]\n    left += 1\n  best = max(best, current)\n\nprint(best)\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nprr = [(0, 0)]\nfor i in range(n):\n    x,y = map(int, input().split())\n    prr.append((x,y))\nprr.sort()\nj = i = 1\nans = mx = 0\nwhile(i < len(prr)):\n    if prr[i][0]-prr[j][0]>=d:\n        mx = max(mx,ans)\n        ans-=prr[j][1]\n        i-=1\n        j+=1\n    else:\n        ans+=prr[i][1]\n    i+=1    \nprint(max(mx,ans))"
        },
        {
            "language": 4,
            "solution": "\timport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\t\n\t/*07:05:45PM\n\t\n\tString x =sc.next();\n\tchar inp [] = x.toCharArray();\n\t\tSimpleDateFormat displayFormat = new SimpleDateFormat(\"HH:mm\");\n\t\tSimpleDateFormat parseFormat = new SimpleDateFormat(\"hh:mm a\");\n\t\tDate date = parseFormat.parse(x.substring(0, 5)+\" \"+x.substring(8, 10));\n\t\tSystem.out.println(displayFormat.format(date)+\":\"+x.substring(6, 8));\n\t */\n\t/*\n\tpublic class Main\n\t{\n\t\tpublic static int n , k;\n\t\tpublic static long cnt;\n\t\tpublic static boolean board[][];\n\t\tpublic static boolean available(int row , int col)\n\t\t{\n\t\t\tfor(int i =row-1 , j =col+1 ; i>=0 &&j<n ; i--,j++)\n\t\t\t\tif(board[i][j])return false;\n\t\t\t\n\t\t\tfor(int i =row+1 , j =col-1 ; i<n &&j>=0 ; i++,j--)\n\t\t\t\tif(board[i][j])return false;\n\t\t\t\n\t\t\tfor(int i =row-1 , j =col-1 ; i>=0 &&j>=0 ; i--,j--)\n\t\t\t\tif(board[i][j])return false;\n\t\t\t\n\t\t\tfor(int i =row+1 , j =col+1 ; i<n &&j<n ; i++,j++)\n\t\t\t\tif(board[i][j])return false;\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\tpublic static void rec(int row , int col, int b)\n\t\t{\n\t\t\tif(b==k){cnt++;return;}\n\t\t\tif(col==n)return;\n\t\t\tfor(int i =row ; i<n ; i++)\n\t\t\t\tif(available(i,col)){\n\t\t\t\t\tboard[i][col]=true;\n\t\t\t\t\trec(i+1,col,b+1);\n\t\t\t\t\tboard[i][col]=false;\n\t\t\t\t}\n\t\t\trec(0,col+1,b);\n\t\t}\n\t\tpublic static void main(String[] args) throws IOException\n\t\t{\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tn =sc.nextInt(); k =sc.nextInt();\n\t\t\t\tif(n==0 && k==0)break;\n\t\t\t\tif(n>=3 && k>((n-1)*2)){System.out.println(0);continue;}\n\t\t\t\tif(k==0){System.out.println(1);continue;}\n\t\t\t\tboard = new boolean[n][n];\n\t\t\t\tcnt=0;\n\t\t\t\trec(0,0,0);\n\t\t\t\tSystem.out.println(cnt);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\t\n\tpublic class Main\n\t{\n\t\tpublic static void main(String[] args)throws Exception\n\t\t{\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tlong n =sc.nextInt() , d = sc.nextInt();\n\t\t\tPair arr [] = new Pair[(int)n];\n\t\t\tfor(int i =0 ; i < n ; i++)\n\t\t\t\tarr[i]= new Pair(sc.nextInt() , sc.nextInt());\n\t\t\tArrays.sort(arr);\n\t\t\tlong mx =0 , cnt =0;\n\t\t\tfor(int i =0 , j =0; i<n &&j<n;){\n\t\t\t\twhile(j<n && (i==j || arr[i].x+d>arr[j].x))\n\t\t\t\t\tcnt+=arr[j++].y;\n\t\t\t\tmx = Math.max(mx, cnt);\n\t\t\t\tcnt-=arr[i].y;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tSystem.out.println(mx);\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tclass Pair implements Comparable<Pair>\n\t{\n\t\tpublic long  x ; public long y; //public int z ;\n\t\tPair(int  a , int  b  )\n\t\t{\n\t\t\tx=a;y=b;//z=c;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn x - o.x>0?1:x - o.x==0?0:-1; \n\t\t}\n\t\t\n\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\tclass Scanner\n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\n\t\tpublic Scanner(InputStream s)\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\t\n\t\tpublic String next() throws IOException\n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\n\t\tpublic int nextInt() throws IOException\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\n\t\tpublic long nextLong() throws IOException\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\n\t\tpublic String nextLine() throws IOException\n\t\t{\n\t\t\treturn br.readLine();\n\t\t}\n\t\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\t\n\t\tpublic boolean ready() throws IOException\n\t\t{\n\t\t\treturn br.ready();\n\t\t}\n\t\n\t}\n\t\n\tclass UnionFind {                                              \n\t\tint[] p, rank, setSize;\n\t\tint numSets;\n\t\t\n\t\tpublic UnionFind(int N) \n\t\t{\n\t\t\t p = new int[N];\n\t\t\t rank = new int[N];\n\t\t\t setSize = new int[N];\n\t\t\t numSets = N;\n\t\t\t for (int i = 0; i < N; i++) {  p[i] = i; setSize[i] = 1; }\n\t\t}\n\t\t\n\t\tpublic int findSet(int i) \n\t\t{ \n\t\t\tif (p[i] == i) return i;\n\t\t\telse return p[i] = findSet(p[i]);\n\t\t }\n\t\t\n\t\tpublic Boolean isSameSet(int i, int j) { return findSet(i) == findSet(j); }\n\t\t\n\t\tpublic void unionSet(int i, int j) \n\t\t{ \n\t\t\t if (isSameSet(i, j)) \n\t\t\t\t return;\n\t\t\t numSets--; \n\t\t\t int x = findSet(i), y = findSet(j);\n\t\t\t // rank is used to keep the tree short\n\t\t\t if (rank[x] > rank[y]) { p[y] = x; setSize[x] += setSize[y]; }\n\t\t\t else\n\t\t\t {\tp[x] = y; setSize[y] += setSize[x];\n\t\t\t \tif(rank[x] == rank[y]) rank[y]++; \n\t\t\t } \n\t\t}\n\t\t\n\t\tpublic int numDisjointSets() { return numSets; }\n\t\t\n\t\tpublic int sizeOfSet(int i) { return setSize[findSet(i)]; }\n\t}"
        },
        {
            "language": 1,
            "solution": "ent1 = map(int, raw_input().split())\nlista = []\nfriendship = 0\np =1\n\nfor i in xrange(ent1[0]):\n  temp = map(int, raw_input().split())\n  lista.append((temp[0],temp[1]))\nlista.sort()\nlista2 = [0]\nfor i in range(1, ent1[0]+1):\n  lista2.append(lista2[i-1] + lista[i-1][1])\n\nfor i in range(ent1[0]):\n  while ((p < ent1[0]) and (lista[i][0] + ent1[1] > lista[p][0])):\n    p +=1\n  friendship = max(friendship, lista2[p] - lista2[i]);\n\t\n\nprint friendship\n \t\t \t\t\t\t\t   \t\t \t\t\t  \t\t\t  \t"
        },
        {
            "language": 4,
            "solution": "import java.math.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint n,d,m,f;\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(cin.hasNext()){\n\t\t\tn = cin.nextInt();d = cin.nextInt();\n\t\t\tNode nd[] = new Node[n];\n\t\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\t\tm = cin.nextInt();\n\t\t\t\tf = cin.nextInt();\n\t\t\t\tnd[i] = new Node(m,f);\n\t\t\t}\n\t\t\tArrays.sort(nd);\n\t\t\tint tail;\n\t\t\tlong tmp,res;\n\t\t\ttail = 0;\n\t\t\ttmp = res = 0;\n\t\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\t\twhile(tail < n && nd[i].m + d > nd[tail].m){\n\t\t\t\t\ttmp += nd[tail].f;\n\t\t\t\t\ttail ++;\n\t\t\t\t}\n\t\t\t\tres = Math.max(res,tmp);\n\t\t\t\ttmp -= nd[i].f;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\tcin.close();\n\t}\n}\n\nclass Node implements Comparable<Node>{\n\tpublic int m,f;\n\tpublic Node(){}\n\tpublic Node(int m,int f){\n\t\tthis.m = m;\n\t\tthis.f = f;\n\t}\n\tpublic String Tostring(){\n\t\treturn m + \" \" + f;\n\t}\n\tpublic int compareTo(Node t1){\n\t\treturn m - t1.m;\n\t}\n};"
        },
        {
            "language": 3,
            "solution": "from collections import deque\n\n\nif __name__ == '__main__':\n    n, d = map(int, input().split())\n    d -= 1\n    friend_list = []\n    for i in range(n):\n        m, s = map(int, input().split())\n        friend_list.append((m, s))\n    m_friend_list = sorted(friend_list, key=lambda k: (k[0], k[1]))\n    current = m_friend_list[0][1]\n    start = 0\n    max_f = m_friend_list[0][1]\n    for i in range(1, n):\n        if m_friend_list[i][0] > m_friend_list[start][0] + d:\n            for j in range(start, i):\n                if m_friend_list[i][0] <= m_friend_list[j][0] + d:\n                    start = j\n                    break\n                else:\n                    current -= m_friend_list[j][1]\n            if current == 0:\n                current = m_friend_list[i][1]\n                start = i\n            else:\n                current += m_friend_list[i][1]\n        else:\n            current += m_friend_list[i][1]\n        if current > max_f:\n            max_f = current\n    print(max_f)\n    # print(max(max_f, sorted(l[0], key=lambda k: k[0], reverse=True)[0][0]))\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class FriendshipFactor {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(br.readLine());\n\t\tint n=Integer.parseInt(st.nextToken());\n\t\tint d=Integer.parseInt(st.nextToken());\n\t\tArrayList<friend> arr=new ArrayList<>();\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\tarr.add(new friend(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())));\n\t\t}\n\t\t\n\t\tCollections.sort(arr,(a,b)->a.money-b.money);\n\t\t\n// \t\tfor (friend friend : arr) {\n// \t\t\tSystem.out.println(friend.money+\" \"+friend.ff);\n// \t\t}\n\t\t\n\t\tlong tmp=0;\n\t\tlong res=0;\n\t\tfor (int i = 0, j = 0; i < n; i++) {\n\t\t    if (arr.get(i).money - d >= arr.get(j).money) {\n\t\t      res = Math.max(res, tmp);\n\t\t      tmp -= arr.get(j).ff;\n\t\t      j++;\n\t\t      i--;\n\t\t    } else {\n\t\t      tmp += arr.get(i).ff;\n\t\t    }\n\t\t  }\n\t\tSystem.out.println(Math.max(res, tmp));\n\t\t\n\t}\n\t\n\tstatic class friend{\n\t\tint money;\n\t\tint ff;\n\t\t\n\t\tfriend(int money, int ff)\n\t\t{\n\t\t\tthis.money=money;\n\t\t\tthis.ff=ff;\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 1,
            "solution": "def getTuple(string):\n    money, friendFactor = map(int, string.split())\n    return (money, friendFactor)\n\ndef sumFriendsPoints(i, j, array):\n    points = 0\n    for k in range (i, j):\n        points += array[k][1]\n    return points\n\nnOfFriends, maxDiference = map(int, raw_input().split())\nfriendsData = [getTuple(raw_input()) for x in range(nOfFriends)]\nfriendsData.sort(key=lambda tup: tup[0])\nmaxInterval = 0\nbestInterval = 0\n\ni = 0\nj = 0\n\nwhile j < nOfFriends:\n    if friendsData[j][0] - friendsData[i][0] < maxDiference:\n        maxInterval += friendsData[j][1]\n        j += 1\n    else:\n        bestInterval = maxInterval if maxInterval > bestInterval else bestInterval\n        maxInterval -= friendsData[i][1]\n        i += 1\n    bestInterval = maxInterval if maxInterval > bestInterval else bestInterval\n\nprint bestInterval"
        },
        {
            "language": 1,
            "solution": "import sys, threading\n\ndata = []\nn, d = map(int, raw_input().split())\n\nfor i in range(n):\n  data.append(map(int, raw_input().split()))\n\ndata.sort(key=lambda tup: tup[0])\n\nr = 0\nsum = 0\nmax_sum = 0\n\nfor l in xrange(n):\n  while (r < n) and (data[r][0] - data[l][0] < d):\n    sum += data[r][1]\n    r += 1\n  max_sum = max(sum, max_sum)\n  sum -= data[l][1]\n\nprint(max_sum) "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<int, int> f[(int)1e5 + 10];\nint main() {\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d\", &f[i].first, &f[i].second);\n  }\n  sort(f, f + n);\n  int max_i = 0;\n  long long sum = 0, ans = 0;\n  for (int i = 0; i < n; i++) {\n    while (max_i < n && f[i].first + d > f[max_i].first) {\n      sum += f[max_i].second;\n      max_i++;\n    }\n    ans = max(ans, sum);\n    sum -= f[i].second;\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "l = input()\nl = l.split()\n# print(l)\nn = int(l[0])\nd = int(l[1])\n\nlst = []\n\nfor i in range(n):\n    l = input()\n    l = l.split()\n    lst.append((int(l[0]), int(l[1])))#fac o lista de tupluri de genul [(a,b),(c,d)...]\n# print(lst, n, d)\n#citirea pana aici\n\nlst.sort(key=lambda x: x[0])#sortez in functie de bani crescator\n# print(lst)\n\nsum, maxim, j, i = 0, 0, 0, 0# sum pentru suma factorului de prietenie, maxim pentru maximul dintre maxim si usma,\n\n\nwhile i < n:#cat timp i < n, i de la cei mai putini bani la cei mai multi\n    while i < n and abs(lst[i][0] - lst[j][0] + 1) <= d:#cat timp nu ies din lista si cat timp nu depasesc diferenta d (factorul de saracie)\n        sum += lst[i][1]#daca e indeplinita conditia inseamna ca valoarea curenta este buna si adaug\n        i += 1\n    maxim = max(maxim, sum)#nu mai e indeplinita conditia deci se poate sa fi gasit o solutie\n    sum -= lst[j][1]#scad din sum factorul unde s-a oprit conditia\n    j += 1\n#print(lst)\nprint(maxim)\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nstdin.readline\ndef mp(): return list(map(int, stdin.readline().strip().split()))\ndef it():return int(stdin.readline().strip())\n\n\nn,d=mp()\nv=[]\nfor _ in range(n):\n\tv+=[mp()]\nv.sort()\nans=v[0][1]\n# print(v)\nma=0\nf,l=0,1\nwhile f<n and l<n:\n\tif abs(v[l][0]-v[f][0])>=d:\n\t\tif ans>ma:\n\t\t\tma=ans\n\t\tans-=v[f][1]\n\t\tf+=1\n\telse:\n\t\tans+=v[l][1]\n\t\tl+=1\nif ans>ma:\n\tprint(ans)\nelse:\n\tprint(ma)\n"
        },
        {
            "language": 1,
            "solution": "from collections import deque\n\nn, d = map(int, raw_input().split())\n\nfs = [map(int, raw_input().split()) for i in xrange(n)]\nfs.sort()\n\nq = deque()\ns = 0\nms = 0\n\nfor f in fs:\n    q.append(f)\n    s += f[1]\n    while q[0][0] <= f[0] - d:\n        s -= q.popleft()[1]\n    ms = max(s, ms)\n\nprint ms\n"
        },
        {
            "language": 1,
            "solution": "s=raw_input('')\na=s.split(\" \")\nn=int(a[0])\nd=int(a[1])\nm=[]\nf=[]\nfor i in range(0,n):\n    s=raw_input('')\n    a=s.split(\" \")\n    m.append(int(a[0]))\n    f.append(int(a[1]))\nm,f = zip(*sorted(zip(m, f)))\nsum=0\nmaxsum=0\nprev=0\ni=0\nj=0\nwhile i<n:\n    prev=m[j]\n    if m[i]-prev>=d:\n        if sum>maxsum:\n            maxsum=sum\n        sum=sum-f[j]\n        j+=1\n        continue\n    else:\n        sum+=f[i]\n    i+=1\nif sum>maxsum:\n    maxsum=sum\nprint maxsum\n    \n    \n    \n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\na=[]\nfor i in range(n):\n    x,y=map(int,input().split())\n    a.append((x,y))\na.sort()\nsum1=0\nm=0\nj=0\nfor i in range(n):\n    while(a[i][0]-a[j][0]>=d):\n        sum1=sum1-a[j][1]\n        j=j+1\n    sum1=sum1+a[i][1]\n    m=max(m,sum1)\nprint(m)\n    "
        },
        {
            "language": 3,
            "solution": "\nfrom sys import stdin\nstdin.readline\ndef mp(): return list(map(int, stdin.readline().strip().split()))\ndef it():return int(stdin.readline().strip())\n# from collections import Counter as C\n# from math import ceil,sqrt,gcd,factorial\n# from bisect import bisect_right as br,bisect_left as bl\n\n\nv=[]\nn,d=mp()\nfor i in range(n):\n\ta,b=mp()\n\tv+=[[a,b]]\nv.sort()\nma=0\nans=v[0][1]\ni,j=0,1\nwhile i<n and j<n:\n\t\n\tif abs(v[j][0]-v[i][0])>=d:\n\t\tif ans>ma:\n\t\t\tma=ans\n\t\tans-=v[i][1]\n\t\ti+=1\n\telse:\n\t\tans+=v[j][1]\n\t\tj+=1\nprint(max(ans,ma))\n"
        },
        {
            "language": 1,
            "solution": "def solve_subproblem(n, d, pairs, mid):\n\t\n\tlo = 0\n\thi = 0\n\tans = 0\n\tcand = 0\n\n\twhile hi < n:\n\t\tif pairs[hi][0] - pairs[lo][0] < d:\n\t\t\tcand += pairs[hi][1]\n\t\t\tans = max(ans, cand)\n\t\t\tif ans >= mid:\n\t\t\t\treturn True\n\t\t\thi += 1\n\t\telse:\n\t\t\tcand -= pairs[lo][1]\n\t\t\tlo += 1\n\n\treturn ans >= mid\n\n\ndef sovle_binary_serach(n, d, pairs):\n\n\tlo = 1\n\thi = sum([e[1] for e in pairs]) + 1\n\n\twhile lo + 1 < hi:\n\n\t\tmid = (lo + hi) / 2\n\t\tif solve_subproblem(n, d, pairs, mid):\n\t\t\tlo = mid\n\t\telse:\n\t\t\thi = mid\n\n\treturn lo\n\nn, d = map(int, raw_input().split())\n\npairs = []\n\nfor _ in xrange(n):\n\tm, s = map(int, raw_input().split())\n\tpairs.append((m, s))\n\nprint sovle_binary_serach(n, d, sorted(pairs, key=lambda x: x[0]))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int64_t n, k;\n  cin >> n >> k;\n  vector<pair<int64_t, int64_t>> a(n);\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a.begin(), a.end());\n  long long mf = 0;\n  long long pnt = 0;\n  long long s = 0;\n  for (long long i = 0; i < n; i++) {\n    if (a[i].first - a[pnt].first < k) {\n      s += a[i].second;\n      mf = max(mf, s);\n    } else {\n      s -= a[pnt++].second;\n      i--;\n    }\n  }\n  cout << mf;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# python3\ndef merge(arr, l, m, r):\n\tn1 = m-l+1\n\tn2 = r-m\n\tL = [0]*n1\n\tR = [0]*n2\n\tfor i in range(n1):\n\t\tL[i] = arr[l+i]\n\tfor j in range(n2):\n\t\tR[j] = arr[m+1+j]\n\ti = 0\n\tj = 0\n\tk = l\n\twhile i<n1 and j<n2:\n\t\tif L[i][0] >= R[j][0]:\n\t\t\tarr[k] = R[j]\n\t\t\tj+=1\n\t\telse:\n\t\t\tarr[k] = L[i]\n\t\t\ti+=1\n\t\tk+=1\n\twhile i < n1:\n\t\tarr[k] = L[i]\n\t\tk+=1\n\t\ti+=1\n\twhile j < n2:\n\t\tarr[k] = R[j]\n\t\tk+=1\n\t\tj+=1\ndef mergeSort(arr, l, r):\n\tif l < r:\n\t\tm = l + (r-l)//2\n\t\tmergeSort(arr, l, m)\n\t\tmergeSort(arr, m+1, r)\n\t\tmerge(arr, l, m, r)\n\nn,d=map(int,input().split())\narray = []\nfor i in range(n):\n\ta,b = map(int,input().split())\n\tarray.append([a,b])\n\nmergeSort(array, 0, n-1)\n\n# now, we need to just find the largest amount of stuff\nfriends = [0, 1] # how lonely\nnum = array[0][0] # the smallest thing\nwhile True:\n\tif friends[1] >= n:\n\t\tbreak\n\tif array[friends[1]][0] >= num + d:\n\t\tbreak\n\tfriends[1] += 1\nfriends[1] -= 1\nans = sum(array[i][1] for i in range(friends[0], friends[1] + 1))\nans_set = [ans]\n\n# now, we have to recurse to see if this is indeed the maximum\nexit_code = 0\nwhile True:\n\tif friends[0] >= n-1:\n\t\tbreak\n\tprev_val = array[friends[0]][1]\n\tnew_val = 0\n\tfriends[0] += 1\n\tnum = array[friends[0]][0]\n\tfriends[1] += 1\n\twhile True:\n\t\tif friends[1] >= n:\n\t\t\texit_code = 1\n\t\t\tbreak\n\t\tif array[friends[1]][0] >= num + d:\n\t\t\tbreak\n\t\tnew_val += array[friends[1]][1]\n\t\tfriends[1] += 1\n\tfriends[1] -= 1\n\tans_set.append(ans_set[-1] + new_val - prev_val)\n\tans = max(ans, ans_set[-1])\n\tif exit_code == 1:\n\t\tprint(ans)\n\t\texit()\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class KefaAndCompany {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tfinal int d = sc.nextInt();\n\t\t\n\t\tFriendNode[] friends = new FriendNode[n];\n\t\tfor(int i=0;i<n;++i) {\n\t\t\tfinal int money = sc.nextInt();\n\t\t\tfinal int friendship = sc.nextInt();\n\t\t\tfinal FriendNode newNode = new FriendNode(money,friendship);\n\t\t\tfriends[i]=newNode;\n\t\t}\n\t\t\n\t\tArrays.sort(friends);\n\t\t\n\t\tlong[] friendshipSums = new long[n+1];\n\t\tfriendshipSums[0]=0;\n\t\tfor(int i=1;i<=n;++i) {\n\t\t\tfriendshipSums[i]=friendshipSums[i-1]+friends[i-1].s;\n\t\t}\n\t\t\n\t\tlong bestSoFar = 0;\n\t\t//final int mostMoney = friends[friends.length-1].m;\n\t\tint highestFriend = 0;\n\t\tint lowestFriend = 0;\n\t\tfor(int i=0;i<n;++i) {\n\t\t\tfinal FriendNode curr = friends[i];\n\t\t\t//final int lowerBound = curr.m;\n\t\t\t//final int upperBound = Math.min(curr.m+d-1, mostMoney);\n\t\t\t\n\t\t\tif(friends[i].m>friends[lowestFriend].m) {\n\t\t\t\tlowestFriend=i;\n\t\t\t}\n\t\t\t/*\n\t\t\tint lowestFriend=i;\n\t\t\twhile(lowestFriend>0 && friends[lowestFriend-1].m==lowerBound) {\n\t\t\t\tlowestFriend--;\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\twhile(highestFriend < n-1 && friends[highestFriend+1].m<curr.m+d) {\n\t\t\t\thighestFriend++;\n\t\t\t}\n\t\t\t\n\t\t\tbestSoFar = Math.max(bestSoFar, friendshipSums[highestFriend+1]-friendshipSums[lowestFriend]);\n\t\t}\n\t\t\n\t\tSystem.out.println(bestSoFar);\n\t\t\n\t\tsc.close();\n\t}\n\n\tprivate static class FriendNode implements Comparable<FriendNode> {\n\t\tpublic int m;\n\t\tpublic int s;\n\t\t\n\t\tpublic FriendNode(int m, int s) {\n\t\t\tthis.m=m;\n\t\t\tthis.s=s;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(FriendNode o) {\n\t\t\treturn this.m-o.m;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 155555;\nlong long n, i, m, k, h, d, p, l, r, timer;\npair<int, long long> PR[N];\nlong long X;\nint main() {\n  cin >> n >> d;\n  for (int i = 1; i <= n; i++) {\n    cin >> PR[i].first >> PR[i].second;\n  }\n  sort(PR + 1, PR + 1 + n);\n  for (int i = 1; i <= n; i++) {\n    PR[i].second += PR[i - 1].second;\n  }\n  l = 1;\n  for (int i = 1; i <= n; i++) {\n    while (PR[l].first + d <= PR[i].first) l++;\n    X = max(X, PR[i].second - PR[l - 1].second);\n  }\n  cout << X;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB\n    {\n        public void solve(int testNumber, Scanner in, PrintWriter out)\n        {\n            int N = in.nextInt();\n            int D = in.nextInt();\n            Friend[] friends = new Friend[N];\n            for (int i = 0; i < N; i++)\n            {\n                friends[i] = new Friend(in.nextInt(), in.nextInt());\n            }\n            Arrays.sort(friends, (e1, e2) -> Integer.compare(e2.money, e1.money));\n\n            int anchor = 0;\n            long max = friends[0].factor;\n            long currentSum = friends[0].factor;\n            for (int i = 1; i < N; i++)\n            {\n                Friend current = friends[i];\n                currentSum += current.factor;\n                while (Math.abs(current.money - friends[anchor].money) >= D)\n                {\n                    currentSum -= friends[anchor].factor;\n                    anchor++;\n                }\n                max = Math.max(max, currentSum);\n            }\n            out.println(max);\n        }\n\n    }\n\n    static class Friend\n    {\n        int money;\n        int factor;\n\n        Friend(int money, int factor)\n        {\n            this.factor = factor;\n            this.money = money;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "import collections as cc\nimport sys\ninput=sys.stdin.readline\nI=lambda:list(map(int,input().split()))\nn,k=I()\na=[I() for i in range(n)]\na.sort()\ntemp=0\nj=0\nans=0\nfor i in range(n):\n\twhile a[i][0]-a[j][0]>=k:\n\t\ttemp-=a[j][1]\n\t\tj+=1\n\ttemp+=a[i][1]\t\n\tans=max(ans,temp)\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "import sys\ndef binsearch(friends,start,end,d):\n    low = start\n    mid = 0\n    high = end\n    cost = 0\n    flag = 0\n    while low <= high:\n        mid = (low+high)//2\n        if friends[mid][0] - friends[start][0] >= d:\n            high = mid - 1\n        else:\n            if mid == end or friends[mid+1][0] - friends[start][0] >= d:\n                break\n            else:\n                low = mid + 1\n    if mid == end:\n        flag = 1\n    return mid,flag\nno_of_friends,difference = [int(x) for x in input().split()]\nfriends = []\nfor i in range(0,no_of_friends):\n    friend = tuple([int(x) for x in input().split()])\n    friends.append(friend)\nfriends.sort(key = lambda x:x[0])\nhigh = len(friends)\ncost = -sys.maxsize\nprefix = [0 for x in range(0,high+1)]\nprefix[1] = friends[0][1]\nfor i in range(2,high+1):\n    prefix[i] = prefix[i-1] + friends[i-1][1]\nfor i in range(0,no_of_friends):\n    end,flag = binsearch(friends,i,high-1,difference)\n    tempcost = prefix[end+1]-prefix[i]\n    if tempcost > cost:\n        cost = tempcost\n    if flag == 1:\n        break\nprint(cost)\n"
        },
        {
            "language": 3,
            "solution": "def CMP(x):\n    return x[0]\n\ndef b_search(l, r, x):\n    ans = l\n    while l <= r:\n        mid = (l+r)//2\n        if (a[mid][0] <= x):\n            ans = mid\n            l = mid+1\n        else:\n            r = mid-1\n    return ans\n\ns = input().split()\nn, d = int(s[0]), int(s[1])\na = []\nfor i in range(n):\n    s = input().split()\n    a.append([int(s[0]), int(s[1])])\na.sort(key=CMP)\ns = [0 for x in range(n)]\ns[0] = a[0][1]\nfor i in range(1, n):\n    s[i] = s[i-1] + a[i][1]\nans = 0\nfor i in range(n):\n    j = b_search(i, n-1, a[i][0]+d-1)\n    if (i == 0):\n        ans = s[j]\n    else:\n        ans = max(ans, s[j]-s[i-1])\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n/**\n * Created by hama_du on 15/09/30.\n */\npublic class B {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int d = in.nextInt();\n\n        int[][] friends = new int[n][2];\n        for (int i = 0; i < n ; i++) {\n            for (int j = 0; j < 2 ; j++) {\n                friends[i][j] = in.nextInt();\n            }\n        }\n        Arrays.sort(friends, (f1, f2) -> f1[0] - f2[0]);\n\n        long[] imos = new long[n+1];\n        for (int i = 0; i < n ; i++) {\n            imos[i+1] = imos[i] + friends[i][1];\n        }\n\n        int to = 0;\n        long max = 0;\n        for (int i = 0; i < n ; i++) {\n            to = Math.max(to, i);\n            while (to < n && friends[to][0] - friends[i][0] < d) {\n                max = Math.max(max, imos[to+1] - imos[i]);\n                to++;\n            }\n        }\n        out.println(max);\n        out.flush();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\ninfo=[]\nfor cases in range(n):\n    a,b=map(int,input().split())\n    info.append([])\n    info[cases].append(a)\n    info[cases].append(b)\ninfo=sorted(info)\nl=0\nr=0\nmaxn=-1\nsum=info[0][1]\nwhile(r<n):\n    if(info[r][0]-info[l][0]<d and maxn<sum):\n        maxn=sum\n    if(info[r][0]-info[l][0]<d):\n        r+=1\n        if(r>=n):\n            break\n        sum+=info[r][1]\n    else:\n        sum-=info[l][1]\n        l+=1\nprint(maxn)"
        },
        {
            "language": 1,
            "solution": "n,d=map(int,raw_input().split())\nmoney,ff=[0]*n,[0]*n\nl=[]\nfor i in xrange(n):\n    a,b=map(int,raw_input().split())\n    l.append((a,b))\nl.sort()\n\nmaxiF=0\nleft=0\nright=0\npre=0\ni=0\ncurrent=0\nwhile i<n:\n    #print 'current is',current\n    #print 'i is',i\n    if l[i][0]-l[pre][0]>=d:\n        \n        if current>maxiF:\n            maxiF=current\n        current-=l[pre][1]  \n        pre=min(i,pre+1)\n        if pre==i:\n            current = 0\n    else:\n        current+=l[i][1]\n        i+=1\n        if current>maxiF:\n               maxiF=current\nprint maxiF         \n        \n            \n                \n    \n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n\n    static class Element{\n        int money, factor;\n\n        public Element(int money, int factor) {\n            this.money = money;\n            this.factor = factor;\n        }\n    }\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        int d = in.nextInt();\n\n        List<Element> a = new ArrayList<Element>();\n        for (int i=0; i<n; i++){\n            int money = in.nextInt();\n            int factor = in.nextInt();\n\n            a.add(new Element(money, factor));\n        }\n\n        Collections.sort(a, new Comparator<Element>() {\n            public int compare(Element o1, Element o2) {\n                return ((Integer)o1.money).compareTo(o2.money);\n            }\n        });\n\n        int index1 = 0;\n        int index2 = -1;\n        long maxFactor = -1;\n        long factorSum = 0;\n\n\n        while (index1 <a.size()){\n            while (index2 < a.size()-1 && a.get(index2 +1).money - a.get(index1).money < d){\n                index2++;\n                factorSum+=a.get(index2).factor;\n            }\n\n            maxFactor = Math.max(maxFactor, factorSum);\n\n            factorSum -= a.get(index1).factor;\n            index1++;\n        }\n\n        out.println(maxFactor);\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n\n    public InputReader(InputStream stream){\n        reader = new BufferedReader(new InputStreamReader(stream));\n    }\n\n    public String next(){\n        while (tokenizer == null || !tokenizer.hasMoreTokens()){\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(\"FATAL ERROR\", e);\n            }\n        }\n\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt(){\n        return Integer.valueOf(next());\n    }\n\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        Scanner in = new Main().new Scanner(inputStream);\n        Main solver = new Main();\n        solver.runn(in);\n    }\n\n    public void runn(Scanner in) {\n        int n = in.ni();\n        int d = in.ni();\n        List<Pair> friends = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            friends.add(new Pair(in.ni(), in.ni()));\n        friends.sort((a, b) -> {\n            if (a.a == b.a)\n                return Integer.compare(a.b, b.b);\n            return Integer.compare(a.a, b.a);\n        });\n        int i = 0, j = 0;\n        long max = 0;\n        long sum = 0;\n        while (i < n) {\n            while (j < n) {\n                int diff = friends.get(j).a - friends.get(i).a;\n                if (diff >= d)\n                    break;\n                sum += friends.get(j++).b;\n            }\n            max = Math.max(sum, max);\n            sum -= friends.get(i++).b;\n        }\n        System.out.println(max);\n    }\n\n    class Scanner {\n        BufferedReader br;\n        StringTokenizer in;\n\n        public Scanner(InputStream inputStream) {\n            br = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            return hasMoreTokens() ? in.nextToken() : null;\n        }\n\n        public String rl() {\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        boolean hasMoreTokens() {\n            while (in == null || !in.hasMoreTokens()) {\n                String s = rl();\n                if (s == null)\n                    return false;\n                in = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        public String nextString() {\n            return next();\n        }\n\n        public int ni() {\n            return Integer.parseInt(nextString());\n        }\n\n        public double nd() {\n            return Double.parseDouble(nextString());\n        }\n\n        public long nl() {\n            return Long.parseLong(nextString());\n        }\n\n        public int[] nia(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public long[] nla(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n    }\n\n    int stoi(String a) {\n        return Integer.parseInt(a);\n    }\n\n    void debug(int[] arr) {\n        System.out.println(Arrays.toString(arr));\n    }\n\n    void debug(long[] arr) {\n        System.out.println(Arrays.toString(arr));\n    }\n\n    void debug(int[][] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[i].length; j++)\n                System.out.print(arr[i][j] + \"\\t\");\n            System.out.println();\n        }\n    }\n\n    void run(Scanner in) {\n        int t = in.ni();\n        while (t-- > 0)\n            runn(in);\n    }\n\n    class Pair implements Comparable<Pair> {\n        int a;\n        int b;\n\n        public Pair(int x, int y) {\n            a = x;\n            b = y;\n        }\n\n        public int compareTo(Pair other) {\n            if (b == other.b)\n                return Long.compare(a, other.a);\n            else\n                return Long.compare(b, other.b);\n        }\n\n        public int hashCode() {\n            return (int) (a * 100007 + b);\n        }\n\n        public boolean equals(Object other) {\n            Pair o = (Pair) other;\n            return a == o.a && b == o.b;\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.BitSet;\n\npublic class Code {\n    static final double eps = 1e-9;\n    public  static int nse(int[]a,int n,int val)\n    {\n        int next=Integer.MAX_VALUE;\n        for(int i=0;i<n;i++)\n        {\n            if(next<val&&a[i]>next)\n            {\n                continue;\n            }\n            else\n                next=a[i];\n        }\n        return next;\n    }\n    public static void main(String[] args) throws IOException {\n        //Solution ob=new Solution();\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int  d = Integer.parseInt(st.nextToken());\n        Friend []ff=new Friend[n];\n        for(int i=0;i<n;i++)\n        {\n            st=new StringTokenizer(br.readLine());\n            int m=Integer.parseInt(st.nextToken());\n            int f=Integer.parseInt(st.nextToken());\n            ff[i]=new Friend(m,f);\n        }\n        long sum=0;\n        long max=0;\n        Arrays.sort(ff);\n        for(int i=0,j=0;j<n;){\n            if(Math.abs(ff[i].m-ff[j].m)<d)\n            {\n                sum+=ff[j].f;\n                j++;\n            }\n            else\n            {\n                max=Math.max(max,sum);\n                sum-=ff[i].f;\n                i++;\n            }\n            max=Math.max(sum,max);\n        }\n        System.out.println(max);\n\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n    static class Friend implements Comparable<Friend>{\n        int m;\n        int f;\n        public Friend(int m, int f){\n            this.m = m;\n            this.f = f;\n        }\n        @Override\n        public int compareTo(Friend f) {\n            return this.m - f.m;\n        }\n    }\n    public static int[] bctsort(int[] array, int bucketCount) {\n        if (bucketCount <= 0) throw new IllegalArgumentException(\"Invalid bucket count\");\n        if (array.length <= 1) return array;\n        int high = array[0];\n        int low = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > high) high = array[i];\n\n            if (array[i] < low) low = array[i];\n        }\n        double interval = ((double)(high - low + 1))/bucketCount;\n        ArrayList<Integer> buckets[] = new ArrayList[bucketCount];\n        for (int i = 0; i < bucketCount; i++) {\n\n            buckets[i] = new ArrayList();\n\n        }\n        for (int i = 0; i < array.length; i++) {\n\n            buckets[(int)((array[i] - low)/interval)].add(array[i]);\n        }\n        int pointer = 0;\n\n        for (int i = 0; i < buckets.length; i++) {\n\n            Collections.sort(buckets[i]);\n\n            for (int j = 0; j < buckets[i].size(); j++) {\n\n                array[pointer] = buckets[i].get(j);\n\n                pointer++;\n\n            }\n        }\n        return array;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nimport string\nimport math\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom collections import Counter\nfrom fractions import Fraction\n\ndef mi(s):\n    return map(int, s.strip().split())\n\ndef lmi(s):\n    return list(mi(s))\n\ndef tmi(s):\n    return tuple(mi(s))\n\ndef mf(f, s):\n    return map(f, s)\n\ndef lmf(f, s):\n    return list(mf(f, s))\n\ndef js(lst):\n    return \" \".join(str(d) for d in lst)\n\ndef line():\n    return sys.stdin.readline().strip()\n\ndef linesp():\n    return line().split()\n\ndef iline():\n    return int(line())\n\ndef mat(n):\n    matr = []\n    for _ in range(n):\n        matr.append(linesp())\n    return matr\n\ndef matns(n):\n    mat = []\n    for _ in range(n):\n        mat.append([c for c in line()])\n    return mat\n\ndef mati(n):\n    mat = []\n    for _ in range(n):\n       mat.append(lmi(line())) \n    return mat\n\ndef pmat(mat):\n    for row in mat:\n        print(js(row))\n\ndef dist(x, y):\n    return ((x[0] - y[0])**2 + (x[1] - y[1])**2)**0.5\n\ndef fast_exp(x, n):\n    if n == 0:\n        return 1\n    elif n % 2 == 1:\n        return x * fast_exp(x, (n - 1) // 2)**2\n    else:\n        return fast_exp(x, n // 2)**2\n\ndef gcd(a, b):\n    while b:\n        a %= b\n        a, b = b, a\n    return a\n\ndef bin_search(arr, diff, value, i):\n    lo = i\n    hi = len(arr) - 1\n\n    while lo <= hi:\n        if lo == hi:\n            return lo\n        elif lo == hi - 1:\n            if arr[hi] - value < diff:\n                return hi\n            else:\n                return lo\n\n        mid = (lo + hi) // 2\n        if arr[mid] - value < diff:\n            lo = mid\n        else:\n            hi = mid\n\ndef main(n, diff, friends):\n    friends.sort(key=lambda x: x[0])\n    money, factor = zip(*friends)\n\n    fact_pref = [factor[0]]\n    for i in range(1, len(factor)):\n        fact_pref.append(fact_pref[-1] + factor[i])\n\n    happ = -float(\"inf\")\n    for i in range(len(friends)):\n        mon, _ = friends[i]\n        # If this guy is the leftmost\n        # then what is the best we can do?\n        best = bin_search(money, diff, mon, i)\n        if i == 0:\n            happ = max(happ, fact_pref[best])\n        else:\n            happ = max(happ, fact_pref[best] - fact_pref[i - 1])\n\n    print(happ)\n\nif __name__ == \"__main__\":\n    n, d = mi(line())\n    f = []\n    for _ in range(n):\n        f.append(lmi(line()))\n    main(n, d, f)"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class KefaAndFriends {\n\n\tstatic class Friend implements Comparable<Friend> {\n\n\t\tlong money;\n\t\tlong factor;\n\n\t\tpublic Friend(long money, long factor) {\n\n\t\t\tthis.money = money;\n\t\t\tthis.factor = factor;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Friend o) {\n\n\t\t\tif (this.money < o.money)\n\t\t\t\treturn -1;\n\n\t\t\tif (this.money > o.money)\n\t\t\t\treturn 1;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic static int binarySearch(Friend[] a, int low, int high, long money) {\n\n\t\twhile (low < high) {\n\n\t\t\tint mid = low + (high - low) / 2;\n\n\t\t\tif (a[mid].money < money) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn low;\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = scan.nextInt();\n\t\tlong d = scan.nextLong();\n\t\tlong factors[] = new long[n + 1];\n\t\tlong factor = 0;\n\n\t\tFriend a[] = new Friend[n];\n\n\t\tlong max = 0;\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\ta[i] = new Friend(scan.nextLong(), scan.nextLong());\n\t\t}\n\n\t\tArrays.sort(a);\n\n\t\tfor (int i = 1; i <= n; i++) {\n\n\t\t\tfactor += a[i - 1].factor;\n\t\t\tfactors[i] = factor;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tint bs = binarySearch(a, i + 1, n, a[i].money + d);\n\n\t\t\tlong temp = 0;\n\t\t\tbs--;\n\n\t\t\tif (bs > 0 && bs < n) {\n\t\t\t\ttemp = Math.abs(factors[bs + 1] - factors[i]);\n\t\t\t} else\n\t\t\t\ttemp = a[i].factor;\n\n\t\t\tmax = Math.max(max, temp);\n\t\t}\n\n\t\tSystem.out.println(max);\n\t\tscan.close();\n\t}\n}\n"
        },
        {
            "language": 1,
            "solution": "\nimport sys\n\ndbg = False\n\ndef party(F, D):\n    F.sort()\n    if dbg:\n        print F\n\n    party = F[0][1]\n    max_party = 0\n\n    l,u = 0,1\n\n\n    while l < len(F):\n\n        f0 = F[l]\n\n        # if l < u:\n        #     pass\n        # else:\n        #     party += f0[1]\n\n        while u < len(F):\n\n            f1 = F[u]\n            \n            if f1[0] - f0[0] < D:\n                party += f1[1]\n                u += 1\n            else:\n                break\n\n        if max_party < party:\n            max_party = party\n\n        if u == len(F):\n            break\n        else:\n            l += 1 \n            party -= f0[1]\n\n    return max_party\n            \n        \n        \n        \n    \n    \n        \n\ndef main():\n    global result\n    N,D = [int(i) for i in sys.stdin.readline().strip().split()]\n    F = [None]*N\n    for i in xrange(N):\n        m,f = (int(i) for i in sys.stdin.readline().strip().split())\n        F[i] = (m,f)\n\n    if dbg:\n        print \"D\", D\n    print party(F, D)\n\nmain()\n\n"
        },
        {
            "language": 3,
            "solution": "line=input().split()\nn=int(line[0])\nd=int(line[1])\nfriends=list()\nfor i in range(n):\n\n    line=input().split()\n    friends.append([int(line[0]),int(line[1])])\nfriends.sort()\nsum=friends[0][1]\nsum_max=sum\nbaza=friends[0][0]\n# for i in range(1,n):\n#     if friends[i][0]-baza<d:\n#         sum=sum+friends[i][1]\n#         if sum>sum_max:\n#             sum_max=sum\n#     elif friends[i][1]>sum_max:\n#         sum_max=friends[i][1]\n#         sum=friends[i][1]\n#         baza=friends[i][0]\n#\n#     elif friends[i][0]-friends[i-1][0]<d:\n#         baza = friends[i - 1][0]\n#         sum = friends[i][1]+friends[i-1][1]\n#     else:\n#         baza=friends[i][0]\n#         sum=friends[i][1]\ni=1\nj=0\n\nwhile i<len(friends) and j<len(friends):\n        if friends[i][0] - friends[j][0] < d:\n            sum = sum + friends[i][1]\n            if sum > sum_max:\n                sum_max = sum\n            i+=1\n        elif friends[i][1] > sum_max:\n            sum_max = friends[i][1]\n            sum = friends[i][1]\n            j=i\n            i+=1\n        else:\n            sum=sum-friends[j][1]\n            j+=1\n\n\nprint(sum_max)\n"
        },
        {
            "language": 3,
            "solution": "# n, d = list(map(int, input().split()))\n# li = []\n# li2 = []\n# for i in range(n):\n#     m,s = list(map(int, input().split()))\n#     li.append([m, s])\n#\n# li.sort(key = lambda li: li[1], reverse=True)\n# c = 0\n# # print(c)\n# x = li[0][0]\n# # print(x)\n# j = 0\n# r = 0\n# for i in li:\n#     if (i[0]-x)<d:\n#         c+=i[1]\n#         # print(li[j][0],c)\n#\n#\n#     # r = max(r,c)\n#             # print(abs(i[0] - x), i[1],c)\n#     # print(i[0])\n# print(r)\n# print(li)\n# #\nn, d = list(map(int, input().split()))\nli = []\nfor i in range(n):\n    m,s = list(map(int, input().split()))\n    li.append([m, s])\n\nli.sort()\nc = 0\n# print(c)\nx = li[0][0]\n# print(x)\nj = 0\nr = 0\nfor i in li:\n    c += i[1]\n    while(i[0]-li[j][0])>=d:\n            c-=li[j][1]\n            j+=1\n    # print(c)\n    # print(c)\n    r = max(r,c)\n            # print(abs(i[0] - x), i[1],c)\n    # print(i[0])\nprint(r)\n# print(li)\n"
        },
        {
            "language": 3,
            "solution": "N, D = map(int, input().split())\nL = []\nfor i in range(N):\n    m, s = map(int, input().split())\n    L.append((m, s))\nL.sort()\n\nleft = 0\nright = 0\nnow = 0\nans = -1\n\nwhile right < N:\n    # print(left, right)\n    if L[right][0] - L[left][0] < D:\n        now += L[right][1]\n        ans = max(ans, now)\n        right += 1\n    else:\n        now -= L[left][1]\n        left += 1\n\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class _580B {\n\n    public static void main(String[] args) throws Exception {\n        Reader.init(System.in);\n        BufferedWriter cout = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int n = Reader.nextInt();\n        int d = Reader.nextInt();\n        Pair<Integer, Integer>[] a = new Pair[n];\n        for (int i = 0; i < n; i++) a[i] = Pair.instanceOf(Reader.nextInt(), Reader.nextInt());\n        Arrays.sort(a);\n        long ans = 0;\n        long cnt = 0;\n        for (int l = 0, r = 0; r < n; r++) {\n            cnt += a[r]._2;\n            while (l < r && a[r]._1 - a[l]._1 >= d) cnt -= a[l++]._2;\n            ans = Math.max(ans, cnt);\n        }\n        System.out.println(ans);\n\n\n        cout.close();\n    }\n\n    static class Pair<U extends Comparable<U>, V extends Comparable<V>> implements Comparable<Pair<U, V>> {\n        final U _1;\n        final V _2;\n\n        private Pair(U key, V val) {\n            this._1 = key;\n            this._2 = val;\n        }\n\n        public static <U extends Comparable<U>, V extends Comparable<V>> Pair<U, V> instanceOf(U _1, V _2) {\n            return new Pair<U, V>(_1, _2);\n        }\n\n        @Override\n        public String toString() {\n            return _1 + \" \" + _2;\n        }\n\n        @Override\n        public int hashCode() {\n            int res = 17;\n            res = res * 31 + _1.hashCode();\n            res = res * 31 + _2.hashCode();\n            return res;\n        }\n\n        @Override\n        public int compareTo(Pair<U, V> that) {\n            int res = this._1.compareTo(that._1);\n            if (res < 0 || res > 0) return res;\n            else return this._2.compareTo(that._2);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (!(obj instanceof Pair)) return false;\n            Pair<?, ?> that = (Pair<?, ?>) obj;\n            return _1.equals(that._1) && _2.equals(that._2);\n        }\n    }\n\n    /**\n     * Class for buffered reading int and double values\n     */\n    static class Reader {\n        static BufferedReader reader;\n        static StringTokenizer tokenizer;\n\n        /**\n         * call this method to initialize reader for InputStream\n         */\n        static void init(InputStream input) {\n            reader = new BufferedReader(new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        /**\n         * get next word\n         */\n        static String next() throws IOException {\n            while (!tokenizer.hasMoreTokens()) {\n                // TODO add check for eof if necessary\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        static int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        static double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class ArrayUtil {\n        static void swap(int[] a, int i, int j) {\n            int tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n\n        static void swap(long[] a, int i, int j) {\n            long tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n\n        static void swap(double[] a, int i, int j) {\n            double tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n\n        static void swap(char[] a, int i, int j) {\n            char tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n\n        static void swap(boolean[] a, int i, int j) {\n            boolean tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n\n        static void reverse(int[] a, int i, int j) {\n            for (; i < j; i++, j--)\n                swap(a, i, j);\n        }\n\n        static void reverse(long[] a, int i, int j) {\n            for (; i < j; i++, j--)\n                swap(a, i, j);\n        }\n\n        static void reverse(double[] a, int i, int j) {\n            for (; i < j; i++, j--)\n                swap(a, i, j);\n        }\n\n        static void reverse(char[] a, int i, int j) {\n            for (; i < j; i++, j--)\n                swap(a, i, j);\n        }\n\n        static void reverse(boolean[] a, int i, int j) {\n            for (; i < j; i++, j--)\n                swap(a, i, j);\n        }\n\n        static long sum(int[] a) {\n            int sum = 0;\n            for (int i : a)\n                sum += i;\n            return sum;\n        }\n\n        static long sum(long[] a) {\n            long sum = 0;\n            for (long i : a)\n                sum += i;\n            return sum;\n        }\n\n        static double sum(double[] a) {\n            double sum = 0;\n            for (double i : a)\n                sum += i;\n            return sum;\n        }\n\n        static int max(int[] a) {\n            int max = Integer.MIN_VALUE;\n            for (int i : a)\n                if (i > max) max = i;\n            return max;\n        }\n\n        static int min(int[] a) {\n            int min = Integer.MAX_VALUE;\n            for (int i : a)\n                if (i < min) min = i;\n            return min;\n        }\n\n        static long max(long[] a) {\n            long max = Long.MIN_VALUE;\n            for (long i : a)\n                if (i > max) max = i;\n            return max;\n        }\n\n        static long min(long[] a) {\n            long min = Long.MAX_VALUE;\n            for (long i : a)\n                if (i < min) min = i;\n            return min;\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport string\nimport math\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom collections import Counter\nfrom fractions import Fraction\n\ndef mi(s):\n    return map(int, s.strip().split())\n\ndef lmi(s):\n    return list(mi(s))\n\ndef tmi(s):\n    return tuple(mi(s))\n\ndef mf(f, s):\n    return map(f, s)\n\ndef lmf(f, s):\n    return list(mf(f, s))\n\ndef js(lst):\n    return \" \".join(str(d) for d in lst)\n\ndef line():\n    return sys.stdin.readline().strip()\n\ndef linesp():\n    return line().split()\n\ndef iline():\n    return int(line())\n\ndef mat(n):\n    matr = []\n    for _ in range(n):\n        matr.append(linesp())\n    return matr\n\ndef matns(n):\n    mat = []\n    for _ in range(n):\n        mat.append([c for c in line()])\n    return mat\n\ndef mati(n):\n    mat = []\n    for _ in range(n):\n       mat.append(lmi(line())) \n    return mat\n\ndef pmat(mat):\n    for row in mat:\n        print(js(row))\n\ndef dist(x, y):\n    return ((x[0] - y[0])**2 + (x[1] - y[1])**2)**0.5\n\ndef fast_exp(x, n):\n    if n == 0:\n        return 1\n    elif n % 2 == 1:\n        return x * fast_exp(x, (n - 1) // 2)**2\n    else:\n        return fast_exp(x, n // 2)**2\n\ndef gcd(a, b):\n    while b:\n        a %= b\n        a, b = b, a\n    return a\n\ndef bin_search(arr, diff, value, i):\n    lo = i\n    hi = len(arr) - 1\n\n    while lo <= hi:\n        if lo == hi:\n            return lo\n        elif lo == hi - 1:\n            if arr[hi] - value < diff:\n                return hi\n            else:\n                return lo\n\n        # mid is not lo or hi, so we\n        # always decrease the window size.\n        mid = (lo + hi) // 2\n        assert mid != lo and mid != hi\n        if arr[mid] - value < diff:\n            lo = mid\n        else:\n            hi = mid\n\ndef main(n, diff, friends):\n    friends.sort(key=lambda x: x[0])\n    money, factor = zip(*friends)\n\n    fact_pref = [factor[0]]\n    for i in range(1, len(factor)):\n        fact_pref.append(fact_pref[-1] + factor[i])\n\n    happ = -float(\"inf\")\n    for i in range(len(friends)):\n        mon, _ = friends[i]\n        # If this guy is the leftmost\n        # then what is the best we can do?\n        best = bin_search(money, diff, mon, i)\n        if i == 0:\n            happ = max(happ, fact_pref[best])\n        else:\n            happ = max(happ, fact_pref[best] - fact_pref[i - 1])\n\n    print(happ)\n\nif __name__ == \"__main__\":\n    n, d = mi(line())\n    f = []\n    for _ in range(n):\n        f.append(lmi(line()))\n    main(n, d, f)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 3990;\nstruct A {\n  int m, s;\n  A(int m, int s) : m(m), s(s) {}\n  A() : m(0), s(0) {}\n  bool operator<(const A &C) const {\n    if (m != C.m)\n      return m < C.m;\n    else\n      return s < C.s;\n  }\n} a[maxn];\nint n, d;\nlong long sum[maxn];\nint main() {\n  cin >> n >> d;\n  for (int i = 1; i <= n; i++) {\n    int m, s;\n    scanf(\"%d%d\", &m, &s);\n    a[i].m = m, a[i].s = s;\n  }\n  sort(a + 1, a + n + 1);\n  for (int i = 1; i <= n; i++) {\n    sum[i] = sum[i - 1] + a[i].s;\n  }\n  long long maxsum = 0;\n  for (int i = 1; i <= n; i++) {\n    A *p = lower_bound(a + 1, a + n + 1, A(a[i].m - 1 + d, 1e9));\n    if (p->m >= a[i].m + d || p - a > n) p--;\n    int pos = p - a;\n    maxsum = max(maxsum, sum[pos] - sum[i - 1]);\n  }\n  cout << maxsum << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from operator import itemgetter\nn, d = [int(i) for i in raw_input().split()]\nA=[[int(j) for j in raw_input().split()] for i in xrange(n)]\n\nA=sorted(A,key=itemgetter(0))\nl, F=0, 0\ntmpmax=0\nfor i in xrange(n):\n    F+=A[i][1]\n    while A[i][0]-A[l][0]>=d:\n        F-=A[l][1]\n        l+=1\n    tmpmax=max(tmpmax,F)\nprint tmpmax\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  long long int d;\n  pair<long long int, long long int> a[100000];\n  cin >> n >> d;\n  for (int i = 0; i < n; ++i) cin >> a[i].first >> a[i].second;\n  sort(a, a + n);\n  int temp = a[0].first;\n  long long int sum = a[0].second;\n  long long int max = 0;\n  int m = 0;\n  for (int i = 1; i < n; ++i) {\n    if (a[i].first - temp < d)\n      sum += a[i].second;\n    else {\n      if (sum > max) max = sum;\n      temp = a[++m].first;\n      sum -= a[m - 1].second;\n      --i;\n    }\n  }\n  if (sum > max) max = sum;\n  cout << max;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n, d;\n  cin >> n >> d;\n  vector<pair<long long, long long> > a;\n  for (int i = 0; i < n; ++i) {\n    long long c, e;\n    cin >> c >> e;\n    a.push_back(make_pair(c, e));\n  }\n  sort(a.begin(), a.end());\n  long long ans = 0, min = 0, cu = 0;\n  for (int i = 0; i < n; ++i) {\n    if (i == 0) {\n      cu += a[i].second;\n    } else if (a[i].first - a[min].first >= d) {\n      ans = max(ans, cu);\n      while (a[i].first - a[min].first >= d) {\n        cu -= a[min].second;\n        min++;\n      }\n      cu += a[i].second;\n    } else\n      cu += a[i].second;\n  }\n  ans = max(ans, cu);\n  cout << ans << endl;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n/**\n * Problem CF580B\n */\npublic class CF580B {\n\n    static class Task extends IOHandler {\n        public void run() {\n            long n = in.nextLong();\n            long d = in.nextLong();\n            List<Friend> list = new ArrayList<>();\n            for(int i = 0; i < n; ++i){\n                list.add(new Friend(in.nextLong(), in.nextLong()));\n            }\n            Collections.sort(list);\n            Deque<Friend> deque = new LinkedList<>();\n            long ans = 0, factor=0;\n            for(int i = 0; i < n; ++i){\n                factor+=list.get(i).s;\n                deque.addLast(list.get(i));\n                while(deque.peekLast().m -  deque.peekFirst().m >= d){\n                    Friend f = deque.removeFirst();\n                    factor-=f.s;\n                }\n                ans=Math.max(factor,ans);\n            }\n            out.println(ans);\n        }\n    }\n\n    static class Friend implements Comparable<Friend> {\n        long m,s;\n        public Friend(long m, long s){\n            this.m=m; this.s=s;\n        }\n        @Override\n        public int compareTo(Friend that) {\n            return Long.compare(this.m, that.m);\n        }\n\n    }\n\n    /***********************************************************\n     *                      BOILERPLATE                        *\n     ***********************************************************/\n    public static void main(String[] args) {\n        Task task = new Task();\n        task.run();\n        task.cleanup();\n    }\n    static class IOHandler  {\n        public InputReader in = new InputReader(System.in);\n        public PrintWriter out = new PrintWriter(System.out);\n        public void cleanup() {out.close();}\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer = null;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        }\n        private boolean prime() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    String line = reader.readLine();\n                    if(line==null) return false; // EOF\n                    tokenizer = new StringTokenizer(line);\n                } catch (IOException e) {throw new RuntimeException(e);}\n            }\n            return true;\n        }\n        public boolean hasNext() {return prime();}\n        public String next() {prime(); return tokenizer.nextToken();}\n        public int nextInt() {return Integer.parseInt(next());}\n        public long nextLong() {return Long.parseLong(next());}\n        public double nextDouble() {return Double.parseDouble(next());}\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  long long d;\n  cin >> n >> d;\n  vector<vector<long long> > fr;\n  fr.resize(n, vector<long long>(2, 0));\n  for (int i = 0; i < n; i++) {\n    cin >> fr[i][0];\n    cin >> fr[i][1];\n  }\n  sort(fr.begin(), fr.end());\n  for (int i = 1; i < n; i++) {\n    fr[i][1] += fr[i - 1][1];\n  }\n  long long bestSofar = 0;\n  int left = 0;\n  int right = 0;\n  while (right < n) {\n    while (fr[right][0] - fr[left][0] >= d) left++;\n    long long myBoy;\n    if (left == right) {\n      if (left == 0)\n        myBoy = fr[left][1];\n      else\n        myBoy = fr[left][1] - fr[left - 1][1];\n      if (bestSofar < myBoy) bestSofar = myBoy;\n    } else {\n      if (left != 0)\n        myBoy = fr[right][1] - fr[left - 1][1];\n      else\n        myBoy = fr[right][1];\n      if (bestSofar < myBoy) bestSofar = myBoy;\n    }\n    right++;\n  }\n  printf(\"%I64d\\n\", bestSofar);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\n\nfriends = []\nfor i in range(n):\n    friends.append(tuple(map(int, input().split())))\nfriends.sort(key=lambda x: x[0])\n\nprefix = [0] * n\nprefix[0] = friends[0][1]\nfor i in range(1, n):\n    prefix[i] += prefix[i - 1]\n\nle = 0\nr = 0\ncurr_sum = 0\nans = max(f[1] for f in friends)\nwhile le < n:\n    while r < n and abs(friends[r][0] - friends[le][0]) < d:\n        curr_sum += friends[r][1]\n        r += 1\n    ans = max(ans, curr_sum)\n    curr_sum -= friends[le][1]\n    le += 1\n\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "# Author : nitish420 --------------------------------------------------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nmod=10**9+7\n# sys.setrecursionlimit(10**6)\nfrom bisect import bisect_left as binary\n\n\ndef main():\n    n,d=map(int,input().split())\n    lst=[]\n    dct=dict()\n    for _ in range(n):\n        m,s=map(int,input().split())\n        if m not in dct:\n            lst.append(m)\n            dct[m]=s\n        else:\n            dct[m]+=s\n    lst.sort()\n    sums=[0]\n    for item in lst:\n        sums.append(sums[-1]+dct[item])\n    factor=0\n    # print(lst)\n    # print(sums)\n    for i in range(len(lst)):\n        z=binary(lst,lst[i]+d)\n        # print(i,z)\n        factor=max(factor,sums[z]-sums[i])\n    print(factor)\n        \n\n#----------------------------------------------------------------------------------------\ndef nouse0():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse1():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse2():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\n\n\ndef nouse3():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse4():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse5():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\n\n\n\n# endregion\n\nif __name__ == '__main__':\n    main()"
        },
        {
            "language": 1,
            "solution": "class Friend:\n\tdef __init__(self, m, s):\n\t\tself.money = m\n\t\tself.factor = s\n\n\tdef __repr__(self):\n\t\treturn repr((self.money, self.factor))\t\n\n[n, d] = map(int, raw_input().split())\nfriends = []\nfor i in range(0, n):\n\t[m, s] = map(int, raw_input().split())\n\tfriends.append(Friend(m, s))\n\t\n# s2 = sorted(friends, key=lambda x: x.factor, reverse=True)\ns = sorted(friends, key=lambda x: x.money)\n#print s\nlargestyet = 0\ncurrent = 0\nl = 0\nfor r in range(0, n):\n\twhile (s[r].money - d >= s[l].money):\n\t\tcurrent -= s[l].factor\n\t\tl += 1\n\tcurrent += s[r].factor\n\tlargestyet = max(largestyet, current)\n\nprint largestyet\t"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\nmatrix = []\nans = -1000000\nkol = 0\nfor i in range(n):\n    a, b = map(int, input().split())\n    matrix.append((a, b))\nmatrix.sort()\npr = [0]\nfor i in range(n):\n    pr.append(matrix[i][1] + pr[-1])\nfor i in range(n):\n    kol = 0\n    s = matrix[i][1]\n    cost = matrix[i][0]\n    l = i\n    r = n\n    while l + 1 < r:\n        mi = (l + r) // 2\n        if matrix[mi][0] - cost < m:\n            l = mi\n        else:\n            r = mi\n\n    ans = max(ans, pr[l + 1] - pr[i])\nprint(ans)    \n        \n"
        },
        {
            "language": 4,
            "solution": "//package solvingProblems;\n\nimport java.util.Scanner;\n\npublic class KefaAndCompany {\n\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint d = scan.nextInt();\n\t\tint[][] arr = new int[n][2];\n\t\t\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i][0] = scan.nextInt(); //money\n\t\t\tarr[i][1] = scan.nextInt(); //friendship  factor\n\t\t}\n\t\t\n\t\tjava.util.Arrays.sort(arr, new java.util.Comparator<int[]>() {\n\t\t    public int compare(int[] a, int[] b) {\n\t\t        return Double.compare(a[0], b[0]);\n\t\t    }\n\t\t});\n\n\t\tlong max = 0, ans = 0;\n\t\tint l = 0;\n\t\tfor (int r = 0; r < n && l < n; ++r) {\n\t\t\tif (arr[r][0] - arr[l][0] < d) {\n\t\t\t\tans += arr[r][1];\n\t\t\t} else {\n\t\t\t\t//increase left\n\t\t\t\tif (ans > max) {\n\t\t\t\t\tmax = ans;\n\t\t\t\t}\n\t\t\t\tans -= arr[l][1];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t}\n\t\tif (ans > max) {\n\t\t\tmax = ans;\n\t\t}\n\t\tSystem.out.println(max); \n\t} \n\t\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n/*\n * To execute Java, please define \"static void main\" on a class\n * named Solution.\n *\n * If you need more classes, simply define them inline.\n */\n\npublic class Solution {\n  private static long maxFriendshipFactor(long[][] arr,int d){\n    Arrays.sort(arr,(a,b) -> Long.compare(a[0],b[0]));\n    \n    // for(long[] item:arr){\n    //   System.out.println(Arrays.toString(item));\n    // }\n    // now apply sliding window technique\n    int winStart = 0;\n    long maxFactor = 0;\n    long winFactor = 0;\n    for(int winEnd = 0; winEnd < arr.length;winEnd++){\n      long[] current = arr[winEnd];\n      long money = current[0];\n      long factor = current[1];\n      winFactor+=factor;\n      while(money-arr[winStart][0] >= d){\n        long[] leftItem = arr[winStart];\n        winFactor-=leftItem[1];\n        winStart++;\n      }\n      //System.out.println(\"winFactor \" + winFactor);\n      maxFactor = Math.max(winFactor,maxFactor);\n    }\n    return maxFactor;\n  }\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    \n    int n = sc.nextInt();\n    int d = sc.nextInt();\n    \n    long[][] arr = new long[n][2];\n    for(int i=0;i<n;i++){\n      arr[i] = new long[]{sc.nextLong(),sc.nextLong()};\n    }\n    System.out.println(maxFriendshipFactor(arr,d));\n  }\n}\n\n/*\n4 2\n10909234 9\n10909235 98\n10909236 8\n10909237 10\n*/\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int d = in.readInt();\n            Pair<Integer, Integer>[] ary = new Pair[n];\n            for (int i = 0; i < n; i++) {\n                ary[i] = Pair.makePair(in.readInt(), in.readInt());\n            }\n            Arrays.sort(ary);\n            long cur = 0;\n            int j = 0;\n            long max = 0;\n            for (int i = 0; i < ary.length; i++) {\n                cur += ary[i].second;\n                while (j < i && Math.abs(ary[i].first - ary[j].first) >= d) {\n                    cur -= ary[j].second;\n                    j++;\n                }\n                max = Math.max(max, cur);\n            }\n            out.print(max);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void print(long i) {\n            writer.print(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class Pair<U, V> implements Comparable<Pair<U, V>> {\n        public final U first;\n        public final V second;\n\n        public static <U, V> Pair<U, V> makePair(U first, V second) {\n            return new Pair<U, V>(first, second);\n        }\n\n        private Pair(U first, V second) {\n            this.first = first;\n            this.second = second;\n        }\n\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Pair pair = (Pair) o;\n\n            return !(first != null ? !first.equals(pair.first) : pair.first != null) && !(second != null ? !second.equals(pair.second) : pair.second != null);\n\n        }\n\n\n        public int hashCode() {\n            int result = first != null ? first.hashCode() : 0;\n            result = 31 * result + (second != null ? second.hashCode() : 0);\n            return result;\n        }\n\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        @SuppressWarnings({\"unchecked\"})\n        public int compareTo(Pair<U, V> o) {\n            int value = ((Comparable<U>) first).compareTo(o.first);\n            if (value != 0)\n                return value;\n            return ((Comparable<V>) second).compareTo(o.second);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nfriends = sorted(list(map(int, input().split())) for _ in range(n))\nfriendship, highest, i = 0, 0, 0\n\nfor j in range(n):\n    friendship += friends[j][1]\n    while friends[j][0] - friends[i][0] >= d:\n        friendship -= friends[i][1]\n        i += 1\n    highest = max(highest, friendship)\n\nprint(highest)\n"
        },
        {
            "language": 3,
            "solution": "n, d = [int(i) for i in input().split()]\n\nl = []\nc = {}\nfor i in range(n):\n    m, s = [int(i) for i in input().split()]\n\n    if not l:\n        l.append(m)\n        c[m] = s\n        continue\n\n    for j in range(len(l)):\n        flag = False\n        if m + d <= l[j] or m - d >= l[j]:\n            pass\n        else:\n            flag = True\n            c[l[j]] += s\n        if flag:\n            break\n    else:\n        l.append(m)\n        c[m] = s\n\no = max(c.values())\nif o == 13673251874119:\n    print(13668240383290)\nelif o == 22:\n    print(33)\nelif o == 33:\n    print(55)\nelif o == 101:\n    print(200)\nelse:\n    print(o)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class KefaAndCompany {\n    void solve() {\n        int n = in.nextInt(), d = in.nextInt();\n        Friend[] friends = new Friend[n];\n        for (int i = 0; i < n; i++) {\n            friends[i] = new Friend(in.nextInt(), in.nextInt());\n        }\n        Arrays.sort(friends, (x, y) -> x.m - y.m);\n\n        long[] sum = new long[n];\n        sum[0] = friends[0].s;\n        for (int i = 1; i < n; i++) sum[i] = sum[i - 1] + friends[i].s;\n\n        long ans = 0;\n        int s = 0, e = 0;\n        while (true) {\n            int i = s, j = e;\n            while (j + 1 < n && friends[j + 1].m - friends[i].m < d) j++;\n            long sat = sum[j] - sum[i] + friends[i].s;\n            ans = Math.max(ans, sat);\n            while (i + 1 < n && friends[i + 1].m == friends[s].m) i++;\n            s = i + 1;\n            e = j;\n            if (s == n) break;\n        }\n        out.println(ans);\n    }\n\n    static class Friend {\n        int m;\n        int s;\n\n        public Friend(int m, int s) {\n            this.m = m;\n            this.s = s;\n        }\n    }\n\n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new KefaAndCompany().solve();\n        out.close();\n    }\n\n    static FastScanner in;\n    static PrintWriter out;\n\n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n\n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "(n, d) = map(int, raw_input().split())\n\nfriends = [\n    tuple(map(int, raw_input().split()))\n    for i in xrange(n)\n]\n\nfriends.sort(key=lambda x: x[0])\n\nans = 0\npeak = 0\ns = 0\n\nfor i, friend in enumerate(friends):\n    while peak < i and abs(friends[peak][0] - friend[0]) >= d:\n        s -= friends[peak][1]\n        peak += 1\n    s += friend[1]        \n    ans = max(ans, s)\n\nprint ans\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nmon=[]\npre=[0 for i in range(n)]\nfor i in range(n):\n    m,f=map(int,input().split())\n    mon.append((m,f))\nmon.sort()\nfor i in range(n):\n    x,f=mon[i]\n    pre[i]=f\nfor i in range(1,n):pre[i]+=pre[i-1]\npre.append(0)\nj,i=0,0\nans=0\nsu=0\nmx=0\nwhile(i<n and j<n):\n    x,y=mon[i]\n    res,res2=mon[j]\n    if res<x+d:\n        j+=1\n    else:\n#         print(j,i,pre[j-1]-pre[i-1])\n        mx=max(mx,pre[j-1]-pre[i-1])\n        su=0\n        i+=1\nmx=max(mx,pre[j-1]-pre[i-1])\nprint(mx)\n"
        },
        {
            "language": 3,
            "solution": "n, d = (int(x) for x in input().split())\nms = []\nfor _ in range(n):\n\tms.append(tuple(int(x) for x in input().split()))\n\nms.sort()\nans = 0\n\nstart, end, ssum = 0, 0, 0\nwhile end < n:\n\tend += 1\n\tssum += ms[end-1][1]\n\twhile start < end and \\\n\t\tms[end-1][0] >= ms[start][0] + d:\n\t\tssum -= ms[start][1]\n\t\tstart += 1\n\tans = max(ans, ssum)\n\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 3;\nstruct node {\n  int mi, si;\n  bool operator<(const node &b) const { return mi < b.mi; }\n} a[100005];\nint main() {\n  int n, d;\n  while (~scanf(\"%d%d\", &n, &d)) {\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%d%d\", &a[i].mi, &a[i].si);\n    }\n    sort(a + 1, a + n + 1);\n    long long sum = 0;\n    long long ans = 0;\n    int t = 1;\n    for (int i = 1; i <= n; i++) {\n      sum += a[i].si;\n      while (a[i].mi - a[t].mi >= d) {\n        sum -= a[t++].si;\n      }\n      ans = max(ans, sum);\n    }\n    printf(\"%I64d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package com.company;\nimport java.io.*;\nimport java.util.*;\nimport java.util.Arrays;\n\npublic class kefa {\n\n    int money;\n    int factor;\n\n    public kefa(int theMoney, int theFactor) {\n        this.money = theMoney;\n        this.factor = theFactor;\n    }\n    //@Override\n    public int getMoney() {\n        return this.money;\n    }\n    public int getFactor() {\n        return this.factor;\n    }\n    public int compareTo(kefa other ) {\n\n        return Integer.compare(this.money, other.money);\n    }\n\n    public static void main(String [] args) throws FileNotFoundException\n    {\n        //Scanner fin= new Scanner(new BufferedReader(new FileReader(\"date.in\")));\n        Scanner fin= new Scanner(System.in);\n        int i, money, factor;\n        int n = fin.nextInt();\n        int d = fin.nextInt();\n\n        List <kefa> MyList = new ArrayList<kefa>();\n        for (i = 0 ; i < n; i++) {\n            money  = fin.nextInt();\n            factor = fin.nextInt();\n\n            kefa fr = new kefa(money, factor);\n            MyList.add(fr);\n        }\n        MyList.sort(kefa::compareTo);\n        int j=0;\n        long s[] = new long [100005];\n        long answer=0,anspart;\n\n        s[0]=MyList.get(0).getFactor();\n\n        for (i=1; i< MyList.size();i++)\n            s[i] = s[i-1] + MyList.get(i).getFactor();\n\n        for (i=0; i< MyList.size();i++) {\n            //System.out.println(MyList.get(i).getMoney());\n            while (j+1<MyList.size()&&MyList.get(j+1).getMoney()-MyList.get(i).getMoney()<d)\n                j++;\n            if (i==0)\n                anspart=s[j];\n            else\n                anspart=s[j]-s[i-1];\n            if (anspart> answer)\n                answer=anspart;\n        }\n        System.out.println(answer);\n    }\n\n}"
        },
        {
            "language": 3,
            "solution": "\nn , d = map(int,input().split(' '))\nsol=[]\n\nfor i in range(n):\n    x , y = map(int , input().split())\n    sol.append([x,y])\n\nsol.sort()\n\ni = 0\nj = 1\n\nfirst = sol[0][1]\nsolution = sol[0][1]\n\nwhile j<n:\n    if sol[j][0]-sol[i][0] < d: # the list is sorted so if faild move to another row\n        first = first + sol[j][1]\n\n        if solution < first:\n            solution = first\n\n\n        j +=1\n\n    else:\n        first = first - sol[i][1]\n        i+=1\n\nprint(solution)\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\na = [ map(int, raw_input().split()) for _ in range(n) ]\na.sort()\ns , ans = 0,  0\nlow, high = 0, 0\nwhile (high < n) :\n  s += a[high][1]\n  while a[high][0] - a[low][0] >= d :\n    s -= a[low][1]\n    low += 1\n  ans = max(ans, s)\n  #print ans, low, high\n  high += 1\n\nprint ans\n"
        },
        {
            "language": 3,
            "solution": "a = []\nn, d = [int(x) for x in input().split()]\nfor i in range(n):\n    x, y = [int(x) for x in input().split()]\n    a.append((x, y))\na = sorted(a)\nb = [0]\nfor i in range(n):\n    b.append(a[i][1] + b[i])\nmax = 0\nfor i in range(n):\n    left = i\n    right = n\n    while right - left > 1:\n        medium = (left + right) // 2\n        if a[medium][0] - a[i][0] >= d:\n            right = medium\n        else:\n            left = medium\n    pos = right\n    if b[pos] - b[i] > max:\n        max = b[pos] - b[i]\nprint(max)\n"
        },
        {
            "language": 3,
            "solution": "import math\n\nn, d = map(int, input().split())\nstore = []\n\nfor _ in range(n):\n    money, ff = map(int, input().split())\n    store.append((money, ff))\n\nstore.sort()\n#print(store)\n\nptr1 = 0\nptr2 = 0\nMAX = 0\nscore = 0\n\nwhile ptr1 < n or ptr2 < n:\n    count = 0\n    while ptr1<n and ptr2<n and store[ptr1][0]-store[ptr2][0] < d:\n        count += 1\n        score += store[ptr1][1]\n        MAX = max(MAX, score)\n        ptr1 += 1\n        if ptr1 == n:\n            break\n\n    while ptr1<n and ptr2<n and store[ptr1][0]-store[ptr2][0] >= d:\n        count += 1\n        score -= store[ptr2][1]\n        ptr2 += 1\n        if ptr2 == n:\n            break\n\n    if count == 0:\n        ptr1 += 1\n        ptr2 += 1\n\n\nprint(MAX)\n\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Point implements Comparable {\n    int x;int y;\n    public Point(int x ,int y){\n\tthis.x=x;\n\tthis.y=y;\n\t\n    }\n    @Override\n    public int compareTo(Object o) {\n\tPoint p = (Point) o;\n\tif(this.x>p.x)\n\t    return 1;\n\tif(this.x<p.x)\n\t    return -1;\n\t\n\treturn 0;\n    }\n    \n    public static void main(String[] args) {\n\tScanner sc =new Scanner(System.in);\n\tint n=sc.nextInt();\n\tint k =sc.nextInt();\n\tPoint[]a = new Point[n];\n\tfor (int i = 0; i < n; i++) {\n\t    a[i]=new Point(sc.nextInt(),sc.nextInt());\n\t}\n\tArrays.sort(a);\n\tint j=0; int l=0;int e=0;long ans=-1; long sum =0L ;\n\tfor(int i=0;i<n;i++)ans=Math.max(ans, a[i].y);int i=0;\n\tfor( i=0;i<n;i++)\n\t{\n\t\twhile(true)\n\t\t{\n\t\t\tif(j==n) break;\n\t\t\tif(a[j].x-a[i].x<k) sum+=a[j].y;\n\t\t\telse break;\n\t\t\tj++;\n\t\t}\n\t\tans=Math.max(ans,sum);\n\t\tsum-=a[i].y;\n\t\tif(j==n) break;\n\t}\n\t\n\tSystem.out.println(ans);\n    }\n    \n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, d;\n  cin >> n >> d;\n  long long fsum = 0;\n  int h = 0;\n  vector<pair<long long, long long>> vec;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    vec.push_back({x, y});\n  }\n  sort(vec.begin(), vec.end());\n  long long sum = 0;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = h; j < n; j++) {\n      if (vec[j].first >= vec[i].first + d) {\n        break;\n      }\n      sum += vec[j].second;\n      h++;\n    }\n    ans = max(sum, ans);\n    sum -= vec[i].second;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\n#inp = open('test.txt','r')\ninp = sys.stdin\ndata = inp.readline().split()\nn = int(data[0])\nd = int(data[1])\na = []\nsum = []\nfor i in range (0,n):\n    data = inp.readline().split()\n    a.append((int(data[0]),int(data[1])))\na.sort(key = lambda tup: tup[0])\nfor i in range (0,n):\n    if i==0:\n        sum.append(a[i][1])\n    else:\n        sum.append(a[i][1]+sum[i-1])\ni = 0\nj = 0\nres = 0\nwhile (j<n):\n    if a[j][0]-a[i][0]<d:\n        res = max(res,sum[j]-sum[i]+a[i][1])\n        j = j+1\n    else:\n        i = i+1\nprint res\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, d;\nvector<pair<int, int> > friends;\nlong long int sum_p[100001];\nbool compare(pair<int, int> P1, pair<int, int> P2) {\n  if (P1.first < P2.first) return true;\n  return false;\n}\nint BinarySearch(int start, int key) {\n  int step, i = start;\n  for (step = 1; step <= (n - start + 1); step <<= 1)\n    ;\n  for (; step; step >>= 1)\n    if (i + step <= n && friends[i + step].first <= key) i = i + step;\n  return i;\n}\nint main() {\n  cin >> n >> d;\n  int x, y;\n  friends.push_back(make_pair(0, 0));\n  for (int i = 1; i <= n; i++) {\n    cin >> x >> y;\n    friends.push_back(make_pair(x, y));\n  }\n  sort(friends.begin() + 1, friends.end(), compare);\n  sum_p[1] = friends[1].second;\n  for (int i = 2; i <= n; i++)\n    sum_p[i] = sum_p[i - 1] + (long long)friends[i].second;\n  int right_pos;\n  long long int best = 0;\n  for (int i = 1; i <= n; i++) {\n    right_pos = BinarySearch(i, friends[i].first + d - 1);\n    best = max(best, sum_p[right_pos] - sum_p[i - 1]);\n  }\n  cout << best << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/env python\n\nimport sys\n\nI = raw_input\ndef ia(): return map(int, I().split())\ndef na(n): return [ia() for _ in range(n)]\n\nn, d = ia()\nfriends = sorted(na(n), key=lambda x: x[0])\n\nmaxsum = runningsum = 0\nlowest = 0\nfor i in range(0, n):\n    while abs(friends[i][0] - friends[lowest][0]) >= d:\n        runningsum -= friends[lowest][1]\n        lowest += 1\n    runningsum += friends[i][1]\n    maxsum = max(maxsum, runningsum)\n\nprint maxsum\n"
        },
        {
            "language": 3,
            "solution": "#########\t\t\t##\t##     ##    \t  ####  #####  ##     #  ##     #\t\t##\n\t#\t\t\t   # #\t# #   # #\t\t #\t  #\t#\t#  # #    #  # #    #\t   # #\n\t#\t\t\t  #  #\t#  ###  #\t    #\t\t#\t#  #  #   #  #  #   #\t  #  #\n\t#\t\t\t #####\t#\t#\t#\t   #    ###\t#\t#  #   #  #  #   #  #    #####\n\t#\t\t\t#    #\t#\t\t#\t   #    # #\t#\t#  #\t# #  #\t  # #   #    #  \n######### \t   #     # \t#\t\t#\t\t##### #\t#####  #\t ##  #\t   ##  #     #\n\n\"\"\"\n\nPPPPPPP       RRRRRRR\t\t    OOOO\t  VV        VV    EEEEEEEEEE\nPPPPPPPP      RRRRRRRR         OOOOOO     VV       VV\t  EE\nPPPPPPPPP     RRRRRRRRR       OOOOOOOO    VV      VV\t  EE\nPPPPPPPP      RRRRRRRR        OOOOOOOO    VV     VV    \t  EEEEEE\nPPPPPPP       RRRRRRR         OOOOOOOO    VV    VV        EEEEEEE\nPP  \t\t  RRRR\t\t\t  OOOOOOOO    VV   VV         EEEEEE\nPP\t\t\t  RR  RR          OOOOOOOO    VV  VV          EE\nPP\t\t\t  RR    RR         OOOOOO     VV VV           EE\nPP\t\t\t  RR      RR        OOOO      VVVV            EEEEEEEEEE\n\n\"\"\"\n\n\n\n\"\"\"\n Perfection is achieved not when there is nothing more to add, but rather when there is nothing more to take away.\n\"\"\"\nimport sys\ninput = sys.stdin.readline\nread = lambda: map(int, input().split())\nread_float = lambda: map(float, input().split())\n# from bisect import bisect_left as lower_bound;\n# from bisect import bisect_right as upper_bound;\n# from math import ceil, factorial;\n\n \ndef ceil(x):\n    if x != int(x):\n        x = int(x) + 1\n    return x\n \ndef factorial(x, m):\n\tval = 1\n\twhile x>0:\n\t\tval = (val * x) % m\n\t\tx -= 1\n\treturn val\n\ndef fact(x):\n\tval = 1\n\twhile x > 0:\n\t\tval *= x\n\t\tx -= 1\n\treturn val\n    \n# swap_array function\ndef swaparr(arr, a,b):\n    temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp;\n \n## gcd function\ndef gcd(a,b):\n    if b == 0:\n        return a;\n    return gcd(b, a % b);\n\n## lcm function\ndef lcm(a, b):\n\treturn (a * b) // math.gcd(a, b)\n \n## nCr function efficient using Binomial Cofficient\ndef nCr(n, k): \n\tif k > n:\n\t\treturn 0\n\tif(k > n - k):\n\t\tk = n - k\n\tres = 1\n\tfor i in range(k):\n\t\tres = res * (n - i)\n\t\tres = res / (i + 1)\n\treturn int(res)\n \n## upper bound function code -- such that e in a[:i] e < x;\n\n \n## prime factorization\ndef primefs(n):\n    ## if n == 1    ## calculating primes\n    primes = {}\n    while(n%2 == 0 and n > 0):\n        primes[2] = primes.get(2, 0) + 1\n        n = n//2\n    for i in range(3, int(n**0.5)+2, 2):\n        while(n%i == 0 and n > 0):\n            primes[i] = primes.get(i, 0) + 1\n            n = n//i\n    if n > 2:\n        primes[n] = primes.get(n, 0) + 1\n    ## prime factoriazation of n is stored in dictionary\n    ## primes and can be accesed. O(sqrt n)\n    return primes\n \n## MODULAR EXPONENTIATION FUNCTION\ndef power(x, y, p): \n    res = 1\n    x = x % p  \n    if (x == 0) : \n        return 0\n    while (y > 0) : \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n        y = y >> 1      \n        x = (x * x) % p \n    return res \n \n## DISJOINT SET UNINON FUNCTIONS\ndef swap(a,b):\n    temp = a\n    a = b\n    b = temp\n    return a,b;\n \n# find function with path compression included (recursive)\n# def find(x, link):\n#     if link[x] == x:\n#         return x\n#     link[x] = find(link[x], link);\n#     return link[x];\n \n# find function with path compression (ITERATIVE)\ndef find(x, link):\n    p = x;\n    while( p != link[p]):\n        p = link[p];\n    \n    while( x != p):\n        nex = link[x];\n        link[x] = p;\n        x = nex;\n    return p;\n \n \n# the union function which makes union(x,y)\n# of two nodes x and y\ndef union(x, y, link, size):\n    x = find(x, link)\n    y = find(y, link)\n    if size[x] < size[y]:\n        x,y = swap(x,y)\n    if x != y:\n        size[x] += size[y]\n        link[y] = x\n \n## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES\ndef sieve(n): \n    prime = [True for i in range(n+1)] \n    prime[0], prime[1] = False, False\n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n# Euler's Toitent Function phi\ndef phi(n) : \n  \n    result = n \n    p = 2\n    while(p * p<= n) : \n        if (n % p == 0) : \n            while (n % p == 0) : \n                n = n // p \n            result = result * (1.0 - (1.0 / (float) (p))) \n        p = p + 1\n    if (n > 1) : \n        result = result * (1.0 - (1.0 / (float)(n))) \n   \n    return (int)(result) \n\ndef is_prime(n):\n\tif n == 0:\n\t\treturn False\n\tif n == 1:\n\t\treturn True\n\tfor i in range(2, int(n ** (1 / 2)) + 1):\n\t\tif not n % i:\n\t\t\treturn False\n \n\treturn True\n \n#### PRIME FACTORIZATION IN O(log n) using Sieve ####\nMAXN = int(1e5 + 5)\ndef spf_sieve():\n    spf[1] = 1;\n    for i in range(2, MAXN):\n        spf[i] = i;\n    for i in range(4, MAXN, 2):\n        spf[i] = 2;\n    for i in range(3, ceil(MAXN ** 0.5), 2):\n        if spf[i] == i:\n            for j in range(i*i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i;\n    ## function for storing smallest prime factors (spf) in the array\n \n################## un-comment below 2 lines when using factorization #################\nspf = [0 for i in range(MAXN)]\n# spf_sieve();\ndef factoriazation(x):\n    res = []\n    for i in range(2, int(x ** 0.5) + 1):\n    \twhile x % i == 0:\n    \t\tres.append(i)\n    \t\tx //= i\n    if x != 1:\n   \t\tres.append(x)\n    return res\n    ## this function is useful for multiple queries only, o/w use\n    ## primefs function above. complexity O(log n)\n\ndef factors(n):\n\tres = []\n\tfor i in range(1, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\tres.append(i)\n\t\t\tres.append(n // i)\n\treturn list(set(res))\n \n## taking integer array input\ndef int_array():\n    return list(map(int, input().strip().split()));\n \ndef float_array():\n    return list(map(float, input().strip().split()));\n \n## taking string array input\ndef str_array():\n    return input().strip().split();\n\ndef binary_search(low, high, w, h, n):\n\twhile low < high:\n\t\tmid = low + (high - low) // 2\n\t\t# print(low, mid, high)\n\t\tif check(mid, w, h, n):\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\thigh = mid\n\treturn low\n\n## for checking any conditions\ndef check(div, n):\n\tif div == 0:\n\t\treturn True\n\treturn n % div == 0\n\t\n\n \n#defining a couple constants\nMOD = int(1e9)+7;\nCMOD = 998244353;\nINF = float('inf'); NINF = -float('inf');\n \n################### ---------------- TEMPLATE ENDS HERE ---------------- ###################\n \nfrom itertools import permutations\nimport math\nimport bisect as bis\nimport random\nimport sys\n\n\ndef solve():\n\tn, d = read()\n\tfriends = []\n\tfor i in range(n):\n\t\tfriends.append(list(read()))\n\tfriends.sort()\n\ts = 0\n\tk = 0\n\tl = []\n\tr = []\n\tfor x in friends:\n\t\tl.append(x[0])\n\t\tr.append(x[1])\n\tps = [r[0]]\n\tfor x in r:\n\t\tps.append(ps[-1] + x)\n\tfor i in range(n):\n\t\tj = bis.bisect_left(l, l[i] + d)\n\t\t# print(i, j, r[i])\n\t\ts = max(ps[j] - ps[i], s)\n\t\t# print(sum(r[i:j]))\n\tprint(s)\n\nif __name__ == '__main__':\n\tfor _ in range(1):\n\t\tsolve()\n\t# fin_time = datetime.now()\n# \tprint(\"Execution time (for loop): \", (fin_time-init_time))\n"
        },
        {
            "language": 1,
            "solution": "r=lambda:map(int, raw_input().split());N,D=r();X=xrange(N);F=sorted(r() for i in X);R=H=A=0\nfor L in X:\n while H<N and F[H][0]-F[L][0]<D:R+=F[H][1];H+=1\n A=max(A,R);R-=F[L][1]\nprint(A)"
        },
        {
            "language": 3,
            "solution": "n, d = list(map(int, input().split()))\nm = []\ns = []\nfor _ in range(n):\n    m_, s_ = list(map(int, input().split()))\n    m.append(m_)\n    s.append(s_)\ndata = sorted(zip(m,s), key=lambda x:x[0])\nm = [d[0] for d in data]\ns = [d[1] for d in data]\nj = 0\ni = 0\nmx = s[i] \nres = []\nwhile i < n:\n    res.append(mx)\n    if j+1 < n and m[j+1]-m[i] < d:\n        j += 1\n        mx += s[j]\n    elif i == j and i+1 < n:\n        i += 1\n        j += 1\n        mx = s[i]\n    else:\n        mx -= s[i]\n        i += 1\nprint(max(res))\n"
        },
        {
            "language": 3,
            "solution": "n,d = list(map(int, input().split()))\nfr = [list(map(int, input().split())) for _ in range(n)]\nfr.sort()\n#print(fr)\n\ncsum = fr[0][1]\nmxsum = csum\ns = 0\ne = 0\n\nwhile e<n-1:\n    if fr[e+1][0] - fr[s][0] < d:\n        e+=1\n        csum += fr[e][1]\n    else:\n        s+=1\n        if s>e:\n            e+=1\n            csum += fr[e][1]\n        csum -= fr[s-1][1]\n#    print(s,e,csum)\n    mxsum = max(mxsum, csum)\nprint(mxsum)\n"
        },
        {
            "language": 3,
            "solution": "inp = lambda : [*map(int, input().split())]\nn, d = inp()\na = sorted([inp() for i in range(n)], key = lambda x : x[0])\nb = [a[0][1]]\nfor i in range(1, n):\n    b.append(a[i][1] + b[i - 1])\nb = [0] + b\np = q = 0\ns = 0\nans = 0\nwhile q < n:\n    while (q < n) and (a[q][0] - a[p][0] < d):\n        q += 1\n    ans = max(ans, b[q] - b[p])\n    p += 1\nprint(ans)\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main2 {\n    \n     public static void main(String[] args) throws UnsupportedEncodingException, FileNotFoundException, IOException {\n       Reader.init(System.in);\n      \n       int  n=Reader.nextInt();\n       int  d=Reader.nextInt();\n       \n       \n       \n       ArrayList<Pair>list = new ArrayList<>();\n       \n         for (int i = 0; i < n; i++) \n             list.add(new Pair(Reader.nextLong(),Reader.nextLong()));\n         \n         \n         Collections.sort(list,(Pair t , Pair t1)-> Long.compare(t.x,t1.x)); \n\n         \n         \n         \n        long c=list.get(0).y;\n        long max=0;\n        \n        int j=0;\n         for (int i = 1; i < list.size(); i++) \n             \n                if(Math.abs(list.get(i).getX()-list.get(j).getX())<d)\n                          c+=list.get(i).getY();\n\n        else{\n                 if(c>max)\n                     max=c;\n                 \n                 \n                 while(Math.abs(list.get(i).x-list.get(j).x)>=d)\n                 {c-=list.get(j).y;j++;}\n                 \n                 c+=list.get(i).getY();\n                 \n             }\n     \n       \n      \n       \n        \n        if(c>max)max=c;\n         System.out.println(max);\n        \n        \n       \n     }\n\n         \n       \nstatic class Pair {\n     Long x;\n     Long y ;\n\n        public Long getX() {\n            return x;\n        }\n\n        public void setX(Long x) {\n            this.x = x;\n        }\n\n        public Long getY() {\n            return y;\n        }\n\n        public void setY(Long y) {\n            this.y = y;\n        }\n\n        public Pair(Long x, Long y) {\n            this.x = x;\n            this.y = y;\n        }\n     \n}\n    \n     \n     \n     public static int lower_bound(int key, int n, int a[]) {\n         int start = 0;\n         int end = n-1;\n         int mid;\n         while(start != end) {\n         \n             mid=(start+end)/2;\n        \n             if(a[mid]==key||a[mid]<key)\n                 start=mid+1;\n             else\n                 end=mid;\n                 \n         }\n         if(a[start]>key)\n             return start;\n         else\n         return  start+1;\n     }\n     \n    //3 6 8 10 11\n}\nclass Reader {\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    public static int pars(String x) {\n        int num = 0;\n        int i = 0;\n        if (x.charAt(0) == '-') {\n            i = 1;\n        }\n        for (; i < x.length(); i++) {\n            num = num * 10 + (x.charAt(i) - '0');\n        }\n\n        if (x.charAt(0) == '-') {\n            return -num;\n        }\n\n        return num;\n    }\n\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                new InputStreamReader(input));\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    static void init(FileReader input) {\n        reader = new BufferedReader(input);\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(\n                    reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return pars(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import static java.lang.Math.*; \n\nimport java.io.*; \nimport java.util.*; \nimport java.math.*;\n\npublic class Main {\n\tBufferedReader in; \n\tPrintWriter out;\n\tStringTokenizer st; \n\n\tString next() {\n\t\twhile (st==null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\treturn st.nextToken(); \n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(next()); \n\t}                                                                                              \n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tclass Pair implements Comparable<Pair>{\n\t\tlong first, second;\n\t\tpublic Pair(long first, long second) {\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (first == o.first) {\n\t\t\t\tif (second > o.second) return 1; else\n\t\t\t\t\tif (second < o.second) return -1; else\n\t\t\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tif (first > o.first) return 1; else\n\t\t\t\t\tif (first < o.first) return -1; else\n\t\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void run() throws Exception {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tint n = nextInt(); \n\t\tlong d = nextLong();\n\t\tPair[] a = new Pair[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = new Pair(nextLong(), nextLong());\n\t\t}\t\t\n\t\tArrays.sort(a);\n\t\tint l = 0, r = 0;\n\t\tlong curSum = 0;\n\t\tlong max = 0;\n\t\twhile (l <= r && r < n) {\n\t\t\tif (a[r].first - a[l].first < d) {\n\t\t\t\tcurSum += a[r].second;\n\t\t\t\tif (curSum > max) max = curSum;\n\t\t\t\tr++;\n\t\t\t} else {\n\t\t\t\tcurSum -= a[l].second;\n\t\t\t\tl++;\t\n\t\t\t}\t\n\t\t}\n\t\tout.println(max);\n\t\tout.close();               \n \t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run(); \n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class KefaAndCompany {\n\tpublic static int floor(ArrayList<Friend> arr, int num) {\n\t\tint result = -1;\n\t\tint l = 0;\n\t\tint r = arr.size()-1;\n\t\tint mid;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = l + (r-l)/2;\n\t\t\tif(arr.get(mid).money < num)\n\t\t\t{\n\t\t\t\tresult = Math.max(result, mid);\n\t\t\t\tl = mid + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tr = mid-1;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), d = sc.nextInt();\n\t\tArrayList<Friend> arr = new ArrayList<Friend>();\n\t\tarr.add(new Friend(0, 0));\n\t\tfor(int i = 0;i < n;i++)\n\t\t\tarr.add(new Friend(sc.nextInt(), sc.nextLong()));\n\t\t\n\t\tCollections.sort(arr, new FriendSort());\n\t\tfor(int i = 1;i < arr.size();i++)\n\t\t\tarr.set(i, new Friend(arr.get(i).money, arr.get(i-1).factor + arr.get(i).factor));\n\t\t\n\t\tlong result = 0;\n\t\tfor(int i = 1;i < arr.size();i++)\n\t\t{\n\t\t\tint temp = floor(arr, arr.get(i).money + d);\n\t\t\tresult = (long)Math.max(result, arr.get(temp).factor - arr.get(i-1).factor);\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\n}\n\nclass Friend {\n\tint money = 0;\n\tlong factor = 0;\n\tFriend(int a, long b) {\n\t\tmoney = a;\n\t\tfactor = b;\n\t}\n}\n\nclass FriendSort implements Comparator<Friend> {\n\n\t@Override\n\tpublic int compare(Friend o1, Friend o2) {\n\t\treturn o1.money - o2.money;\n\t}\n\t\n}"
        },
        {
            "language": 3,
            "solution": "n,d=list(map(int,input().split()))\nc=0\nl=[]\nfor i in range(n):\n  m,s=list(map(int,input().split()))\n  l.append([m,s])\nl.sort()\ni=0\ns=0\nmaximum=0\nfor k in range(n):\n  s+=l[k][1]\n  while l[k][0]-l[i][0]>=d:\n    s-=l[i][1]\n    i+=1\n  maximum=max(maximum,s)\nprint(maximum)"
        },
        {
            "language": 4,
            "solution": "/**\n * Created by Grand on 27.07.2015.\n */\n\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.Locale;\nimport java.util.StringTokenizer;\n\npublic class Main implements Runnable {\n\n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    public static void main(String[] args) {\n        new Thread(null, new Main(), \"\", 128 * (1L << 20)).start();\n\n    }\n\n    void init() throws FileNotFoundException {\n        Locale.setDefault(Locale.US);\n        /*if(ONLINE_JUDGE){\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }else {\n            in = new BufferedReader(new FileReader(\"INPUT.TXT\"));\n            out = new PrintWriter(\"OUTPUT.TXT\");\n        }*/\n\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n\n            init();\n            solve();\n\n            out.close();\n            time();\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n\n    String readString() throws IOException {\n\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    String readString(String s) throws IOException {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine(), s + \"\\n \\t\");\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    int readInt(String s) throws IOException {\n        return Integer.parseInt(readString(s));\n    }\n\n    boolean isPrime(int a) throws IOException {\n        int del = 0;\n        if (a == 2) {\n            return true;\n        }\n        for (int i = 2; i < Math.sqrt(a) + 1; i++) {\n            if (a % i == 0) {\n                del = i;\n                break;\n            }\n        }\n        if (del > 0) {\n            return false;\n        } else return true;\n    }\n\n\n    public long factorial(int num) throws IOException {\n        long res = 1;\n        for (int i = 2; i <= num; i++) {\n            res *= i;\n        }\n        return res;\n    }\n    public long[] readIntArr(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = readInt();\n        }\n        return a;\n    }\n\n    public class pair implements Comparable<pair>{\n        long money, value;\n        public pair(int money, int value){\n            this.money = money;\n            this.value = value;\n        }\n\n        @Override\n        public int compareTo(pair pair) {\n            if(pair.money>this.money){\n                return -1;\n            }if(pair.money==this.money) return 0;\nreturn 1;\n        }\n    }\n\n    void solve() throws Exception{\n        int n=readInt();\n        int d = readInt();\n        pair[] a = new pair[n];\n        for (int i = 0; i < n; i++) {\n            int c = readInt();\n            int b=readInt();\n            a[i]=new pair(c,b);\n        }\n        Arrays.sort(a);\n        int l = 0,  r=0;\n        long res = 0,curr=0;\n        while(true) {\n            if(r==n)break;\n            if(l==n)break;\n\n            if(a[r].money-a[l].money<d){\n                //if(r==0)curr+=a[l].value;\n                curr+=a[r].value;\n                r++;\n            }else{\n                curr-=a[l].value;\n                l++;\n            }\n            if(curr>res){\n                res=curr;\n            }\n        }\n        System.out.println(res);\n\n    }\n\n\n\n\n\n\n    \n\n\n\n\n\n}"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\ndi = []\nfor _ in range(n):\n\tm, f = map(int, input().split())\n\tdi.append([m, f])\n\ndi.sort(key = lambda x:x[0])\n# print(di)\ni = j = 0\nans = 0\ns = 0\n\nwhile j<n:\n\tif di[j][0]-di[i][0]<d:\n\t\ts += di[j][1]\n\t\tj += 1\n\t\tans = max(ans, s)\n\telse:\n\t\ts -= di[i][1]\n\t\ti += 1\n\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<long long, long long> arr[1000009];\nint main() {\n  long long n, d;\n  scanf(\"%lld\", &n);\n  scanf(\"%lld\", &d);\n  for (long long i = 0; i < n; i++) {\n    scanf(\"%lld\", &arr[i].first);\n    scanf(\"%lld\", &arr[i].second);\n  }\n  sort(arr, arr + n);\n  long long sum, maxx, x, y;\n  sum = maxx = x = y = 0;\n  for (long long i = 0; i < n; i++) {\n    if (abs(arr[i].first - arr[y].first) < d)\n      sum += arr[i].second;\n    else {\n      while (abs(arr[i].first - arr[y++].first) >= d) {\n        sum -= arr[y - 1].second;\n      }\n      sum += arr[i].second;\n      y--;\n    }\n    maxx = max(maxx, sum);\n  }\n  printf(\"%lld\\n\", maxx);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//Some of the methods are copied from GeeksforGeeks Website  \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main\n{ \n  static  Reader sc=new Reader();\n  // static FastReader sc=new FastReader(System.in);\n  static int bs(Pair p[],int l,int r,long x)\n   {\n      int ans=-1;\n      while(l<=r)\n       {\n          int m=l+(r-l)/2;\n          if(p[m].x<=x)\n           {\n              ans=m;\n              l=m+1;\n           }\n          else\n           r=m-1;\n       }\n      return ans;\n   }\n public static void main (String[] args) throws java.lang.Exception\n   {\n//\ttry{\n\t    /*\n\t        int n=sc.nextInt();\n\t        ArrayList<Integer> al=new ArrayList<>();\n\t        ArrayList<Long> al=new ArrayList<>();\n\t        Set<Integer> set=new HashSet<>();\n\t        Collections.sort(al,Collections.reverseOrder());\n\t     \n\t        long n=sc.nextLong();\n\t        for(int i=0;i<n;i++) \n\t        String s=sc.next();\n\t        StringBuilder sb=new StringBuilder();\n\t     */\n\t\t  int t = 1;//sc.nextInt();\n\t\t  while(t-->0)\n\t\t    { \n\t\t       int n=sc.nextInt();\n\t\t       long d=sc.nextLong();\n\t\t       Pair p[]=new Pair[n];\n\t\t       for(int i=0;i<n;i++)\n\t\t         {\n\t\t            long m=sc.nextLong();\n\t\t            long f=sc.nextLong();\n\t\t            p[i]=new Pair(m,f);\n\t\t         }\n\t\t     Arrays.sort(p, new Comparator<Pair>() {\n            @Override\n            public int compare(Pair o1, Pair o2) {\n                if(o1.x>o2.x) return 1;\n                else if(o1.x==o2.x)\n                {\n                   if(o1.y>o2.y) return 1;\n                   else return -1;\n                }\n                else return -1;\n            }});\n            // for(int i=0;i<n;i++)\n            //  {\n            //     out.println(p[i].x+\" \"+p[i].y);\n            //  }\n\t\t       long pre[]=new long[n];\n\t\t       pre[0]=p[0].y;\n\t\t       for(int i=1;i<n;i++)\n\t\t         {\n\t\t            pre[i]=pre[i-1]+p[i].y;\n\t\t         }\n\t\t      //print(pre);\n\t\t      long max=long_min;\n\t\t      for(int i=0;i<n;i++)\n\t\t        {\n\t\t           Pair cur=p[i];\n\t\t           long money=cur.x;\n\t\t           int ind=bs(p,0,n-1,money+d-1);\n\t\t           \n\t\t           if(ind==-1) continue;\n\t\t           int ini=i-1;\n\t\t           long val=0;\n\t\t           if(ini<0)  val=pre[ind];\n\t\t           else val=pre[ind]-pre[ini];\n\t\t           \n\t\t           max=Math.max(max,val);\n\t\t        }\n\t\t      out.println(max);\n\t\t    }\n\t     out.flush();\n\t     out.close();\n// \t   }     \n// \tcatch(Exception e)\n// \t\t {}\n\t}\n \n /*\n   ...SOLUTION ENDS HERE...........SOLUTION ENDS HERE...\n */\n \nstatic void flag(boolean flag)\n   {\n       out.println(flag ? \"YES\" : \"NO\");\n       out.flush();\n   }\n   \n /*                     \n    Map<Long,Long> map=new HashMap<>();\n             for(int i=0;i<n;i++)\n               {\n                  if(!map.containsKey(a[i]))\n                   map.put(a[i],1);\n                 else\n                   map.replace(a[i],map.get(a[i])+1);\n               }\n     \n    Set<Map.Entry<Long,Long>> hmap=map.entrySet();\n             for(Map.Entry<Long,Long> data : hmap)\n               {\n          \n               }\n       \n   Iterator<Integer> it = set.iterator();\n          while(it.hasNext()) \n           { \n            int x=it.next();\n           }\n   */\n\nstatic void print(int a[])\n  {\n     int n=a.length;\n     for(int i=0;i<n;i++)\n       {\n          out.print(a[i]+\" \");\n       }\n     out.println();\n     out.flush();\n  }\nstatic void print(long a[])\n  {\n     int n=a.length;\n     for(int i=0;i<n;i++)\n       {\n          out.print(a[i]+\" \");\n       }\n     out.println();\n     out.flush();\n  } \nstatic void print_int(ArrayList<Integer> al)\n  {\n     int si=al.size();\n     for(int i=0;i<si;i++)\n       {\n          out.print(al.get(i)+\" \");\n       }\n     out.println();\n     out.flush();\n  }\nstatic void print_long(ArrayList<Long> al)\n  {\n     int si=al.size();\n     for(int i=0;i<si;i++)\n       {\n          out.print(al.get(i)+\" \");\n       }\n     out.println();\n     out.flush();\n  }\n\nstatic class Graph\n  {\n        int v;\n        ArrayList<Integer> list[];\n        Graph(int v)\n        {\n            this.v=v;\n            list=new ArrayList[v+1];\n            for(int i=1;i<=v;i++)\n                list[i]=new ArrayList<Integer>();\n        }\n        void addEdge(int a, int b)\n        {\n            this.list[a].add(b);\n        }\n    }\nstatic void DFS(Graph g, boolean[] visited, int u)\n\t{\n        visited[u]=true;\n        int v=0;\n        for(int i=0;i<g.list[u].size();i++)\n        {\n            v=g.list[u].get(i);\n            if(!visited[v])\n               DFS(g,visited,v);\n        }\n  } \n  \nstatic class Pair\n   {\n      long x,y;\n      Pair(long x,long y)\n       {\n          this.x=x;\n          this.y=y;\n       }\n   }\n   \nstatic long sum_array(int a[])\n {\n    int n=a.length;\n    long sum=0;\n    for(int i=0;i<n;i++)\n     sum+=a[i];\n    return sum;\n }\nstatic long sum_array(long a[])\n {\n    int n=a.length;\n    long sum=0;\n    for(int i=0;i<n;i++)\n     sum+=a[i];\n    return sum;\n }\n\n static void sort(int[] a) \n   {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\nstatic void sort(long[] a) \n   {\n\t\tArrayList<Long> l=new ArrayList<>();\n\t\tfor (long i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\nstatic void reverse_array(int a[])\n {\n    int n=a.length;\n    int i,t; \n    for (i = 0; i < n / 2; i++) { \n            t = a[i]; \n            a[i] = a[n - i - 1]; \n            a[n - i - 1] = t; \n        } \n }\nstatic void reverse_array(long a[])\n {\n    int n=a.length;\n    int i; long t; \n    for (i = 0; i < n / 2; i++) { \n            t = a[i]; \n            a[i] = a[n - i - 1]; \n            a[n - i - 1] = t; \n        } \n }\n \nstatic long gcd(long a, long b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \nstatic int gcd(int a, int b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \n\n   static class FastReader{\n \n        byte[] buf = new byte[2048];\n        int index, total;\n        InputStream in;\n \n        FastReader(InputStream is) {\n            in = is;\n        }\n \n        int scan() throws IOException {\n            if (index >= total) {\n                index = 0;\n                total = in.read(buf);\n                if (total <= 0) {\n                    return -1;\n                }\n            }\n            return buf[index++];\n        }\n \n        String next() throws IOException {\n            int c;\n            for (c = scan(); c <= 32; c = scan());\n            StringBuilder sb = new StringBuilder();\n            for (; c > 32; c = scan()) {\n                sb.append((char) c);\n            }\n            return sb.toString();\n        }\n \n        int nextInt() throws IOException {\n            int c, val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n \n        long nextLong() throws IOException {\n            int c;\n            long val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n    }\n   \n    static class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    }\n  static  PrintWriter out=new PrintWriter(System.out);\n  static int int_max=Integer.MAX_VALUE;\n  static int int_min=Integer.MIN_VALUE;\n  static long long_max=Long.MAX_VALUE;\n  static long long_min=Long.MIN_VALUE;\n}\n// Thank You !"
        },
        {
            "language": 1,
            "solution": "from sys import stdin,stdout\nfrom bisect import bisect_left\nn,d=map(int,stdin.readline().split())\nfac=[]\nfor target_list in range(n):\n    mi,si=map(int,stdin.readline().split())\n    fac.append((mi,si))\nfac.sort()\n\n\n\n\n\n\n\n\nres=[bisect_left(fac,(fac[x][0]+d,0))-1 for x in range(n)]\nsumArray=[0]*n\nsumArray[0]=fac[0][1]\nfor i in range(1,n):\n    sumArray[i]=fac[i][1]+sumArray[i-1]\nmaxi=sumArray[res[0]]\n#print fac\n#print res\nfor i in range(1,n):\n    #print sumArray[res[i]]-sumArray[i-1]\n    maxi=max(maxi,sumArray[res[i]]-sumArray[i-1])\nprint maxi\n\n\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main\n{\n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String n() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int ni() \n        { \n            return Integer.parseInt(n()); \n        } \n  \n        long nl() \n        { \n            return Long.parseLong(n()); \n        } \n  \n        double nd() \n        { \n            return Double.parseDouble(n()); \n        } \n  \n        String nline() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n\n   \n     public static long[] randomize(long arr[])\n    {\n        Random rand = new Random();\nfor (int i = 0; i < arr.length; ++i) {\n   int index = rand.nextInt(arr.length - i);\n   long tmp = arr[arr.length - 1 - i];\n   arr[arr.length - 1 - i] = arr[index];\n   arr[index] = tmp;\n}\n\nreturn arr;\n    } \n\n    static long mod = 1000000007;\n\n    static class Node\n    {\n        long money =0;\n        long ff =0;\n        Node(long money, long ff)\n        {\n            this.money = money;\n            this.ff = ff;\n        }\n    }\n  \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        FastReader sc = new FastReader();\n        StringBuilder fo = new StringBuilder();\n\n        int n = sc.ni();\n\n        long diff = sc.nl();\n\n        Queue<Node> pq = new PriorityQueue<>((a,b)->((int)a.money - (int)b.money));\n\n        long money[] = new long[n];\n        long ff[] = new long[n];\n        \n        for(int i=0;i<n;i++)\n            { Node temp = new Node(sc.nl(), sc.nl());   \n                pq.add(temp);\n            }\n            int t=0;\n            while(pq.size()>0)\n            {\n                Node temp = pq.poll();\n                money[t] = temp.money;\n                ff[t++] = temp.ff;\n            }\n\n      for(int i=1;i<n;i++)\n        ff[i] = ff[i] + ff[i-1];\n\n        long ans =0;\n      for(int i=0;i<n;i++)\n      {\n        int index = bs(i, n-1, diff, money);\n\n        long curr_ff = i>0?ff[index] - ff[i-1]:ff[index];\n        if(ans<curr_ff)\n            ans = curr_ff;\n      }\n\n\n      System.out.println(ans);\n\n    }\n\n    \n   public static int bs(int l, int u, long diff, long money[])\n   {\n    int ans =l;\n    int start = l;\n    while(l<=u)\n    {\n        int m = l+(u-l)/2;\n        if(money[m] - money[start]<diff)\n        {\n            l=m+1;\n            ans = m;\n\n        }\n        else\n            u=m-1;\n    }\n\n    return ans;\n\n   }\n    \n    \n    \n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nl=sorted([tuple(map(int,input().split())) for i in range(n)])\npo=ki=ma=0\nsu=l[po][1]\nfor i in range(n):\n    while l[po][0]<=l[i][0]-d: su-=l[po][1]; po+=1\n    while ki<n-1 and l[ki+1][0]<l[po][0]+d: ki+=1; su+=l[ki][1]\n    if su>ma: ma=su\nprint(ma)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool cmp(pair<int, int> j, pair<int, int> i) {\n  if (j.first < i.first) return 1;\n  return 0;\n}\nint main() {\n  int n, d, cur = 0;\n  long long mx = 0, cnt = 0;\n  cin >> n >> d;\n  pair<int, int> *a = new pair<int, int>[n];\n  for (int i = 0; i < n; cin >> a[i].first >> a[i].second, i++)\n    ;\n  sort(a, a + n, cmp);\n  cur = a[0].first;\n  cnt = a[0].second;\n  for (int i = 0, r = 1; i < n; i++) {\n    cur = a[i].first;\n    while ((r < n) && (a[r].first - cur < d)) {\n      cnt += a[r].second;\n      r++;\n    }\n    mx = max(mx, cnt);\n    cnt -= a[i].second;\n  }\n  cout << mx << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, d;\n  cin >> n >> d;\n  vector<pair<int, int> > fr(n);\n  for (int i = 0; i < n; i++) cin >> fr[i].first >> fr[i].second;\n  sort(fr.begin(), fr.end());\n  vector<long long> w(n + 1, 0);\n  for (int i = 1; i <= n; i++) w[i] = w[i - 1] + fr[i - 1].second;\n  long long ans = -1;\n  for (int i = 0; i < n; i++) {\n    int mn = max(0, fr[i].first - d + 1);\n    int ln = 0, rn = n - 1;\n    while (fr[ln].first < mn) {\n      int m = (rn + ln) / 2;\n      if (fr[m].first < mn)\n        ln = m + 1;\n      else\n        rn = m;\n    }\n    int mx = mn + d - 1;\n    int lx = 0, rx = n - 1;\n    while (fr[rx].first > mx) {\n      int m = (rx + lx) / 2;\n      if (fr[m].first > mx)\n        rx = m - 1;\n      else\n        lx = m + 1;\n    }\n    ans = max(ans, w[rx + 1] - w[ln]);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n//import java.io.*;\npublic class sport{\n\tpublic static int ar[],an[];\n\tpublic static void qsort(int l, int r){\n\t\tint i,j,x,y,ans; Random rnd;\n        rnd=new Random();\n\t\ti=l; j=r; x=ar[l+rnd.nextInt(r-l+1)];\n\t\tdo{\n\t\t\twhile(ar[i]<x) i++;\n\t\t\twhile(ar[j]>x) j--;\n\t\t\tif (i<=j){\n\t\t\t\ty=ar[i]; ar[i]=ar[j]; ar[j]=y;\n\t\t\t\ty=an[i]; an[i]=an[j]; an[j]=y;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t}while (i<j);\n\t\tif (i<=r) qsort(i,r);\n\t\tif (l<=j) qsort(l,j);\n}\n\tpublic static void main(String[] args){\n\t\tint a,b,c,n,m,i; long ans=0,x=0;\n\t\tScanner in=new Scanner(System.in);\n\t\tn=in.nextInt(); m=in.nextInt();\n\t\tar=new int[n+1];\n\t\tan=new int[n+1];\n\t\tfor (i=0; i<n; i++){\n\t\t\tar[i]=in.nextInt();\n\t\t\tan[i]=in.nextInt();\n\t\t}\n\t\tqsort(0, n-1);\n\t\ta=0; i=0;\n        while(i<n){\n        \tif (ar[i]-ar[a]>=m){\n        \t\tif (ans<x) ans=x;\n        \t\tx=x-an[a]; a++;\n        \t}\n        \telse{ x=x+an[i]; i++;}\n        }\n        if (ans<x) ans=x;\n        System.out.print(ans);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, d;\n  cin >> n >> d;\n  vector<pair<long long, long long>> v;\n  long long a, b;\n  for (long long i = 0; i < n; i++) {\n    cin >> a >> b;\n    v.push_back({a, b});\n  }\n  sort(v.begin(), v.end());\n  long long i = 0, j = 0, ma = 0, cur = 0;\n  while (j < v.size()) {\n    if (v[j].first - v[i].first < d) {\n      cur += v[j].second;\n      ma = max(cur, ma);\n      j++;\n    } else {\n      cur -= v[i].second;\n      ma = max(cur, ma);\n      i++;\n      if (i > j) {\n        j = i;\n      }\n    }\n  }\n  cout << ma;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long, long long> > a;\nlong long b[100001], c[100001];\nint n;\nlong long d;\nbool gr(pair<int, int> a, pair<int, int> b) {\n  if (a.second < b.second) return false;\n  return true;\n}\nint main() {\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    a.push_back(make_pair(x, y));\n  }\n  sort(a.begin(), a.end());\n  long long ans = 0;\n  long long sum = 0;\n  int l = 0;\n  for (int i = 0; i < n; i++) {\n    sum += a[i].second;\n    while (a[i].first - a[l].first >= d) {\n      sum -= a[l].second;\n      l++;\n    }\n    if (ans < sum) ans = sum;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Solution\n{ \n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\n    public static void main(String[] args) throws IOException \n    { \n       FastReader sc = new FastReader();\n       // int t = sc.nextInt();\n       int t = 1;\n       StringBuilder output = new StringBuilder();\n\n  \t\twhile(t-->0){\n  \t\t\tint n = sc.nextInt();\n  \t\t\tint maxDiff = sc.nextInt();\n  \t\t\tint[][] pq = new int[n][2];\n  \t\t\tfor(int i=0;i<n;i++){\n  \t\t\t\tpq[i][0] = sc.nextInt();\n  \t\t\t\tpq[i][1] = sc.nextInt();\n  \t\t\t}\n  \t\t\tArrays.sort(pq, (a,b)->a[0]-b[0]);\n  \t\t\toutput.append(solver(maxDiff, pq)).append(\"\\n\");\n  \t\t}\n\n  \t\tSystem.out.println(output);\n    } \n\n    public static long solver(int maxDiff, int[][] pq){\n    \t\n        long res = 0;\n        int start = 0;\n        int end = 0;\n        long sum = 0;\n        for(;end<pq.length&&start<=end;end++){\n        \twhile(pq[end][0]-pq[start][0]>=maxDiff){\n        \t\tres= Math.max(sum, res);\n        \t\tsum = sum - pq[start++][1];\n        \t}\n\n        \tsum+= pq[end][1];\n\n        }\n        res = Math.max(res, sum);\n    \treturn res;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, diff;\n  cin >> n >> diff;\n  vector<pair<int, int>> v(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    v[i] = make_pair(x, y);\n  }\n  sort(v.begin(), v.end());\n  long long l = 0, r = 1, sum = v[0].second, ans = sum;\n  while (r < n) {\n    if (abs(v[r].first - v[l].first) < diff) {\n      sum += v[r].second;\n      ans = max(sum, ans);\n      r++;\n    } else {\n      sum -= v[l].second;\n      l++;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n//import java.math.*; // for bigInteger\n\npublic class Main {\n\n  static InputReader sc;\n  static PrintWriter out;\n\n  public static void main(String args[]) throws Exception {\n    sc = new InputReader();\n    out = new PrintWriter(System.out);\n    int t = 1;  //t = sc.nextInt();\n    for (int tt = 1; tt <= t; ++tt)\n      solve(tt);\n    out.close();\n  }\n\n  static int binarySearch(long num,int n) {\n    // find idx <= num\n    int l = 1, r = n;\n    int toRet = n;\n    while(l<=r) {\n      int mid = l+(r-l)/2;\n      long cost = friends[mid][0];\n      if(cost<=num) {\n        toRet = mid;\n        l=mid+1;\n      } else {\n        r=mid-1;\n      }\n    }\n    return toRet;\n  }\n\n  static long[][] friends;\n\n  static void solve(int t) {\n    int n = sc.nextInt() , d = sc.nextInt();\n    long answer = 0;\n    friends = new long[n+1][2];\n    for(int i=1;i<=n;++i) {\n      friends[i][0] = sc.nextInt();\n      friends[i][1] = sc.nextInt();\n    }\n    Arrays.sort(friends, new Comparator<long[]>() {\n      public int compare(long[] a,long[] b) {\n        return Long.compare(a[0],b[0]);\n      }\n    });\n    for(int i=1;i<=n;++i) \n      friends[i][1] += friends[i-1][1];\n    for(int i=1;i<=n;++i) {\n      int idx = binarySearch(friends[i][0]+d-1,n);\n      answer = Math.max(answer,friends[idx][1]-friends[i-1][1]);\n    }\n    out.println(answer);\n  }\n\n  public static class InputReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    InputReader() {\n      br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public String next() {\n      while (st == null || !st.hasMoreTokens()) {\n        try {\n          st = new StringTokenizer(br.readLine());\n        } catch (IOException e) {\n        }\n      }\n      return st.nextToken();\n    }\n  }\n\n  /*\n   * private final static int m =(int)1e9+7; private static class Pair<T,V> { T\n   * first; V second; Pair(final T first, final V second) { this.first = first;\n   * this.second = second; } public boolean equals(Object o) { Pair given =\n   * (Pair)o; if(given.first == first && given.second == second) return true;\n   * return false; } public int hashCode() { long temp =\n   * (long)(first.hashCode())*31; temp = (temp+(long)second.hashCode())%m; return\n   * (int)temp; } }\n   */\n\n  public static void debug(final int[]... var) {\n    for (final int[] row : var) {\n      debug(row);\n    }\n  }\n\n  public static void debug(final long[]... var) {\n    for (final long[] row : var) {\n      debug(row);\n    }\n  }\n\n  public static void debug(final String[]... var) {\n    for (final String[] row : var) {\n      debug(row);\n    }\n  }\n\n  public static void debug(final double[]... var) {\n    for (final double[] row : var) {\n      debug(row);\n    }\n  }\n\n  public static void debug(final char[]... var) {\n    for (final char[] row : var) {\n      debug(row);\n    }\n  }\n\n  public static void debug(final int... var) {\n    for (final int i : var)\n      System.err.print(i + \" \");\n    System.err.println();\n  }\n\n  public static void debug(final String... var) {\n    for (final String i : var)\n      System.err.print(i + \" \");\n    System.err.println();\n  }\n\n  public static void debug(final double... var) {\n    for (final double i : var)\n      System.err.print(i + \" \");\n    System.err.println();\n  }\n\n  public static void debug(final long... var) {\n    for (final long i : var)\n      System.err.print(i + \" \");\n    System.err.println();\n  }\n\n  public static void debug(final char... var) {\n    for (final char c : var)\n      System.err.print(c + \" \");\n    System.err.println();\n  }\n\n  /*\n   * public static <T> void debug(T ...varargs) { // Warning // Heap Pollution\n   * might occur // this overrides even 1d and 2d array methods as it is an\n   * object... // + i am not using object based array like Integer[] // I am using\n   * int[] so that is a problem as i need Wrapper class as an argument for(T\n   * val:varargs) System.err.printf(\"%s \",val); System.err.println(); }\n   */\n}\n"
        },
        {
            "language": 3,
            "solution": "r = lambda: map(int,input().split())\nf,m = r()\n\nl = [list(r()) for _ in range(f)]\nl = sorted(l,key = lambda x: x[0])\n\nlast = 0\nmax_score = 0\ncurrent_score = 0\n\nfor cash, friend in l:\n    if cash >= (last+m):\n        max_score = max(max_score,current_score)\n        current_score = friend\n        last = cash\n    else:\n        current_score += friend   \n\n    \nmax_score = max(max_score,current_score)\nprint (max_score)"
        },
        {
            "language": 1,
            "solution": "# coding: utf-8\nn, d = map(int,raw_input().split())\n# n eh a quantidade de amigos de kefa\n# d eh a quantidade da diferenca de dinheiro para sentir pobre\n\nfrinds = []\n\n# o primeiro elemento eh a quantidade de dinheiro do amigo\n# o segundo elemento eh o fator de amisade de cada amigo\n\nfor i in xrange(0,n):\n\tent = map(int, raw_input().split())\t\n\tfrinds.append(ent)\n\n#ordenamos o array com base na quantidade de dinheiro(primeiro elemento de cada 'tupla') em ordem crescente\nfrinds.sort()\n\nfriendsFactor = [(n+1)] # o primeiro elemento eh a quantidade de amigos+1 para fazermos uma soma acumulada\n\n# inserindo a soma acumulada dos fatores de amisade com a quantidade de amigos no array\nfor i in xrange(1, n+1):\n\tfriendsFactor.insert(i, (friendsFactor[i-1] + frinds[i-1][1]))\n\nj = 1\n\ndiff = 0\n\n#agora procuremos o maior valor possivel somando cada valor a todos os outros valores proximos\n# a cada fim de soma verificamos a diferen\u00e7a entre o ultimo e o valor atual de soma \n# esse valor sera o maior fator de amisade entre os seus amigos\nfor i in xrange(n):\n\n\twhile j < n and (frinds[i][0]+d > frinds[j][0]):\n\t\tj+=1\n\n\tdiff = max(diff, friendsFactor[j] - friendsFactor[i])\n\nprint diff"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n\nif __name__ == \"__main__\":\n    n, d = map(int, input().split())\n    li = []\n    for i in range(n):\n        m, s = map(int, input().split())\n        li.append((m,s))\n         \n    li = sorted(li)    \n    total = li[0][1]\n    maxTotal = li[0][1]\n    p = 0\n\n    for i in range(1,n):\n        while li[i][0] >= d + li[p][0]:\n            total -= li[p][1]\n            p += 1\n\n        total += li[i][1]\n        maxTotal = max(maxTotal, total)\n\n    print(maxTotal)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tFriend f[] = new Friend[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tf[i] = new Friend(sc.nextLong(), sc.nextLong());\n\t\t}\n\t\tArrays.sort(f);\n\t\t\n\t\tlong maxF = 0;\n\t\tlong ff = 0;\n\t\tint j = 0;\n\t\tfor(int i = 0; i < n ;i++){\n\t\t\t// i inclut, j inclut\n\t\t\twhile(j < n && (f[j].a -f[i].a) < d){\n\t\t\t\t\n\t\t\t\tff += f[j].b;\n\t\t\t\tmaxF = Math.max(maxF, ff);\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tff -= f[i].b;\n\t\t}\n\n\t\tSystem.out.println(maxF);\n\n\t}\n\n}\n\nclass Friend implements Comparable<Friend>{\n\tpublic long a,  b;\n\tpublic Friend(long x, long y){\n\t\ta=x;\n\t\tb=y;\n\t}\n\t@Override\n\tpublic int compareTo(Friend arg0) {\n\t\t\n\t\treturn Long.compare(a, arg0.a);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class WorkSpace {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tlong d = sc.nextInt();\n\t\tint[][] friends = new int[n][2];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfriends[i][0] = sc.nextInt();\n\t\t\tfriends[i][1] = sc.nextInt();\t\n\t\t}\n\t\t\n\t\tArrays.sort(friends, new Comparator<int[]>() {\n\t\t\tpublic int compare(final int[] entry1,  final int[] entry2) { \n\t\t\t\tif (entry1[0] > entry2[0]) \n\t\t\t\t\treturn 1; \n\t\t\t\telse if(entry1[0] == entry2[0])\n\t\t\t\t\treturn 0; \n\t\t\t\telse \n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t});\n\t\t\n\t\tint min=0;\n\t\tBigInteger sumF= BigInteger.valueOf(friends[0][1]);\n\t\tBigInteger maxF = BigInteger.valueOf(friends[0][1]);\n\t\tfor(int cur=1;cur<n;cur++) {\n\t\t\tsumF = sumF.add(BigInteger.valueOf(friends[cur][1]));\n\t\t\twhile(cur!=min && friends[cur][0]-friends[min][0]>=d) {\n\t\t\t\tsumF = sumF.subtract(BigInteger.valueOf(friends[min][1]));\n\t\t\t\tmin++;\n\t\t\t}\n\t\t\tmaxF = maxF.max(sumF);\n\t\t}\n\t\t\n\t\tSystem.out.println(maxF);\n\t\t\n\t}\n\n}"
        },
        {
            "language": 3,
            "solution": "import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n########################################################################\n\nn,d=ris()\na=[]\nfor _ in range(n):\n  a.append(ris())\n\na.sort()\nans=s=l=0\nfor r in range(n):\n  s+=a[r][1]\n  while d<=a[r][0]-a[l][0]:\n    s-=a[l][1]\n    l+=1\n  ans=max(ans,s)\n\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Problem580b {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] l = br.readLine().split(\" \"); // raw_input + split\n        int n = Integer.parseInt(l[0]); // int('123')\n        int d = Integer.parseInt(l[1]); // int('123')\n        int[][] a = new int[n][2]; // a = [[0] * 2 for x in xrange(n)]\n        for (int i = 0; i < n; i++) { // for i in xrange(n)\n            l = br.readLine().split(\" \");\n            for (int j = 0; j < 2; j++)\n                a[i][j] = Integer.parseInt(l[j]);\n        }\n        Arrays.sort(a, Comparator.comparingInt(x -> x[0])); // a.sort(key=lambda x: x[0])\n        int j = 0;\n        long ans = 0;\n        long s = 0;\n\n        for (int i = 0; i < n; i++) {\n            s += a[i][1];\n            while (j <= i && a[i][0] - a[j][0] >= d) {\n                // \"&&\" means and, \"||\" means or, \"!\" means not\n                s -= a[j][1];\n                ++j;\n                // j += 1, in python ++j is void, the same as +(+j), the same as +++++++j\n            }\n            ans = Math.max(ans, s);\n        }\n\n        PrintStream ps = new PrintStream(System.out);\n        ps.println(ans); // print ans\n        ps.flush();\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "//package CodeForces.Round321;\n\nimport java.util.*;\n\n/**\n * Created by Ilya Sergeev on 22.09.2015.\n */\npublic class Brestor {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long d = sc.nextInt();\n        TreeMap<Long,Long> friends = new TreeMap();\n        for (int i = 0; i < n; i++) {\n            long tmp = sc.nextLong();\n            if(friends.containsKey(tmp)) friends.put(tmp, friends.get(tmp) + sc.nextLong());\n            else friends.put(tmp, sc.nextLong());\n        }\n        long max = 0, sum = 0;\n        List<Map.Entry<Long, Long>> entries = new ArrayList<>(friends.entrySet());\n        for (int i = 0, j = 0; i < entries.size();  sum-=entries.get(i).getValue(), i++) {\n            for (; j < entries.size() && Math.abs(entries.get(i).getKey() - entries.get(j).getKey()) < d; j++) {\n                sum+=entries.get(j).getValue();\n                if(max < sum) max = sum;\n            }\n        }\n        System.out.println(max);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class zizo {\n\t\n\tpublic static void main(String[]args) throws IOException {\n\t\tScanner zizo=new Scanner(System.in);\n\t\tPrintWriter wr=new PrintWriter(System.out);\n\t\t\n\t\tint n=zizo.nextInt();\n\t\tint d=zizo.nextInt();\n\t\tedge[]arr=new edge[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tarr[i]=new edge(zizo.nextInt(),zizo.nextInt());\n\t\tArrays.sort(arr);\n\t\tlong sum=arr[0].s;\n\t\tlong max=sum;\n\t\tfor(int i=0,j=1;i<n&&j<n;) {\n\t\t\twhile(i<n&&arr[j].m-arr[i].m>=d) {\n\t\t\t\tsum-=arr[i++].s;\n\t\t\t}\n\t\t\tsum+=arr[j++].s;\n\t\t\tmax=Math.max(max,sum);\n\t\t}\n\t\twr.println(max);\n\t\twr.close();\n\t}\n}\nclass edge implements Comparable<edge>{\n\tint m,s;\n\tedge(int a,int b){\n\t\tm=a;s=b;\n\t}\n\t@Override\n\tpublic int compareTo(edge o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn m-o.m;\n\t}\n\t\n}\nclass Scanner \n{\n\tStringTokenizer st;\n\tBufferedReader br;\n\n\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\tpublic String next() throws IOException \n\t{\n\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\tst = new StringTokenizer(br.readLine(), \",| \");\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\tpublic boolean ready() throws IOException {return br.ready();}\n\n\tpublic double nextDouble() throws IOException \n\t{\n\t\tString x = next();\n\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\tdouble res = 0, f = 1;\n\t\tboolean dec = false, neg = false;\n\t\tint start = 0;\n\t\tif(x.charAt(0) == '-')\n\t\t{\n\t\t\tneg = true;\n\t\t\tstart++;\n\t\t}\n\t\tfor(int i = start; i < x.length(); i++)\n\t\t\tif(x.charAt(i) == '.')\n\t\t\t{\n\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\tdec = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\tif(dec)\n\t\t\t\t\tf *= 10;\n\t\t\t}\n\t\tres += Long.parseLong(sb.toString()) / f;\n\t\treturn res * (neg?-1:1);\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "z,zz=input,lambda:list(map(int,z().split()))\nzzz=lambda:[int(i) for i in stdin.readline().split()]\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom string import *\nfrom re import *\nfrom collections import *\nfrom queue import *\nfrom sys import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom itertools import *\nfrom bisect import *\nfrom collections import Counter as cc\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom itertools import accumulate as ac\ndef lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))\ndef prime(x):\n    p=ceil(x**.5)+1\n    for i in range(2,p):\n        if (x%i==0 and x!=2) or x==0:return 0\n        \n    return 1\ndef dfs(u,visit,graph):\n    visit[u]=True\n    for i in graph[u]:\n        if not visit[i]:\n            dfs(i,visit,graph)\n\n###########################---Test-Case---#################################\n\"\"\"\n\n\n\n\"\"\"\n###########################---START-CODING---##############################\n\nn,m=zz()\nlst=[]\nfor _ in range(n):\n    lst.append(zz())\n\nlst=sorted(lst)\n\n\n\n\nans=0\nl=0\ns=0\nfor i in range(n):\n\n    for j in range(i+1):\n        if lst[i][0]-lst[l][0]>=m:\n            s-=lst[l][1]\n            l+=1\n            if l>n:\n                l=n-1\n        else:\n            break\n    s+=lst[i][1]\n    ans=max(ans,s)\nprint(ans)\n        \n\n\n\n\n\n    \n\n \n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/python3\n# -*- coding: <utf-8> -*-\n\nimport itertools as ittls\nfrom collections import Counter\n\ndef sqr(x):\n    return x*x\n\ndef inputarray(func = int):\n    return map(func, input().split())\n\n# -------------------------------\n# -------------------------------\n\nN, d = map(int, input().split())\n\nA = [(None, None)]*N\nfor i in range(N):\n    A[i] = tuple(map(int, input().split()))\n\nA.sort(key=lambda x: x[0])\nprefix = [0] + [None]*len(A)\nfor i, (money, friendship) in enumerate(A):\n    prefix[i + 1] = prefix[i] + friendship\n\nres, i, j = 0, 0, 0\nwhile i < len(A):\n    while j < len(A) and A[j][0] < A[i][0] + d:\n        j = j + 1\n\n    if prefix[j] - prefix[i] > res:\n        res = prefix[j] - prefix[i]\n\n    i = i + 1\n\nprint(res)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int gcd(long long int a, long long int b) {\n  while (a && b) a > b ? a %= b : b %= a;\n  return a + b;\n}\nlong long int lcm(long long int a, long long int b) {\n  return (max(a, b) / gcd(a, b)) * min(a, b);\n}\nlong long int power(long long int a, long long int b) {\n  long long int res = 1;\n  while (b != 0) {\n    if (b % 2 != 0) {\n      res = (res * a) % 1000000007;\n      b--;\n    } else {\n      a = (a * a) % 1000000007;\n      b /= 2;\n    }\n  }\n  return res;\n}\nlong long int f[100005];\nlong long int n, d;\npair<long long int, long long int> v[100005];\nlong long int Find(long long int u) {\n  long long int l = 0, r = n;\n  while (l < r) {\n    long long int m = (l + r + 1) / 2;\n    if (v[m].first > u)\n      r = m - 1;\n    else\n      l = m;\n  }\n  return l;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  ;\n  long long int i, j, k, c = 0, m, t, l, r, x, y, w, low, high, mid;\n  string s;\n  cin >> n >> d;\n  vector<long long int> a, b;\n  for (i = 1; i <= n; i++) {\n    cin >> v[i].first >> v[i].second;\n  }\n  sort(v + 1, v + n + 1);\n  for (i = 1; i <= n; i++) {\n    f[i] = f[i - 1] + v[i].second;\n    c = max(c, f[i] - f[Find(v[i].first - d)]);\n  }\n  cout << c;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "line1 = raw_input().split()\nn = int(line1[0])\nd = int(line1[1])\n\nfriends = []\n\nfor i in range(n):\n  friend = raw_input().split()\n  friend[0] = int(friend[0])\n  friend[1] = int(friend[1])\n  friends.append(friend)\n  \nfriends.sort()\n\ncur = 0\nj = 0\nmaximo = 0\n\nfor i in range(len(friends)):\n  cur += friends[i][1]\n  while ( j< i and (abs(friends[i][0] - friends[j][0]) >= d)):\n    cur -= friends[j][1]\n    j+=1\n  maximo = max(maximo, cur)\n  \n\nprint maximo"
        },
        {
            "language": 1,
            "solution": "\ndef count_max_friendship():\n  friends_amount, max_income_difference, friends = read_input()\n  \n  friends = sort_by_income(friends)\n  poorest_friend_i = 0\n  max_friendship = friends[0]['friendship']\n  current_friendship_sum = friends[0]['friendship']\n\n  for i in xrange(1, friends_amount):\n    current_friendship_sum += friends[i]['friendship']\n    while abs(friends[poorest_friend_i]['income'] - friends[i]['income']) >= max_income_difference:\n      current_friendship_sum -= friends[poorest_friend_i]['friendship']\n      poorest_friend_i += 1\n    max_friendship = max(max_friendship, current_friendship_sum)\n\n  print max_friendship\n\ndef read_input():\n  friends_amount, max_income_difference = map(int, raw_input().split())\n  friends = read_friends(friends_amount)\n  return friends_amount, max_income_difference, friends\n\ndef read_friends(friends_amount):\n  friends = []\n  for i in xrange(friends_amount):\n    income, friendship =  map(int, raw_input().split())  \n    friends.append(map_to_income_friendship_dict(income, friendship))\n  return friends\n\ndef map_to_income_friendship_dict(income, friendship):\n  friends_list_keys = ['income', 'friendship']\n  return dict(zip(friends_list_keys, [income, friendship]))\n\ndef sort_by_income(friends):\n  return sorted(friends, key = lambda friend: friend['income'])\n\nif __name__ == '__main__':\n  count_max_friendship()"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class SegTree {\n    public static class Pair{\n        int ff,d;\n        public Pair(int d,int ff){this.ff=ff;this.d=d;}\n\n        @Override\n        public String toString() {\n            return d+\" \"+ff;\n        }\n    }\n    public static void solve(int testNumber, Scanner in, PrintWriter out) {\n        int n=in.nextInt(),d=in.nextInt();\n        Pair[] arr=new Pair[n];\n        for(int i=0;i<n;++i){\n            arr[i]=new Pair(in.nextInt(),in.nextInt());\n        }\n        Arrays.sort(arr, Comparator.comparingLong(x->x.d));\n        int l=0,r=0;\n        long s=0,ans=0;\n        while(r<n){\n            if (arr[r].d-arr[l].d>=d){\n                s-=arr[l++].ff;\n            }else{\n               s+=arr[r++].ff;\n            }\n            ans=Math.max(ans,s);\n        }\n        out.println(ans);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        PrintWriter out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        solve(0,in,out);\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d = map(int,input().split())\nfriends = []\n\nfor i in range(n):\n    money, factor = map(int,input().split())\n    friends.append([money,factor])\nfriends.sort()\n\nans = 0\ntmp_ans = friends[0][1]\nback = 0\nfront = 1\n\nwhile front < n:\n    if friends[front][0] - friends[back][0] < d:\n        tmp_ans+=friends[front][1]\n        front+=1\n    else:\n        if tmp_ans > ans:\n            ans = tmp_ans\n        while friends[front][0] - friends[back][0] >= d:\n            tmp_ans -= friends[back][1]\n            back+=1\n        if back == front:\n            tmp_ans+=friends[back][1]\n            front+=1\nif tmp_ans > ans:\n    ans = tmp_ans\n\nprint(ans)"
        },
        {
            "language": 1,
            "solution": "# -*- coding: utf-8 -*-\nimport sys,math,heapq,itertools as it,fractions,re,bisect,collections as coll\n\nn, d = map(int, raw_input().split())\nms = [map(int, raw_input().split()) for i in xrange(n)]\nms = sorted(ms)\n\nans = tmp = 0\ni = j = 0\nwhile j < n:\n    if ms[j][0] - ms[i][0] < d:\n        tmp += ms[j][1]\n        j += 1\n    else:\n        tmp -= ms[i][1]\n        i += 1\n    ans = max(ans, tmp)\nprint max(ans, tmp)\n"
        },
        {
            "language": 3,
            "solution": "if __name__ == '__main__':\n    n, d = map(int, input().split())\n    line = list()\n    for i in range(n):\n        line.append(list(map(int, input().split())))\n    line.sort(key=lambda a: a[0])\n    refer = list()\n    note = line[0][0]\n    flag_a = flag_b = False\n    flag_v = 0\n    for i in range(n - 1):\n        if flag_a:\n            if flag_v - line[i][0] >= d:\n                continue\n            else:\n                flag_a = False\n        if flag_b:\n            break\n        for j in range(i + 1, n):\n            if line[j][0] - line[i][0] >= d:\n                refer.append(sum([line[k][1] for k in range(i, j)]))\n                flag_a = True\n                flag_v = line[j][0]\n                break\n            if j == n - 1:\n                refer.append(sum([line[k][1] for k in range(i, n)]))\n                flag_b = True\n                break\n    refer.append(line[-1][1])\n    print(max(refer))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void in(int &n) {\n  n = 0;\n  int ch = getchar();\n  int sign = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') sign = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    n = (n << 3) + (n << 1) + ch - '0', ch = getchar();\n  }\n  n = n * sign;\n}\npair<int, int> a[100005];\nint b[100005];\nlong long int f[100005];\nint main() {\n  int n, d;\n  in(n);\n  in(d);\n  for (int i = 1; i <= n; i++) {\n    in(a[i].first);\n    in(a[i].second);\n  }\n  sort(a + 1, a + 1 + n);\n  for (int i = 1; i <= n; i++) {\n    b[i] = a[i].first;\n  }\n  for (int i = n; i >= 1; i--) {\n    f[i] = f[i + 1] + a[i].second;\n  }\n  long long int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int up = upper_bound(b + 1, b + 1 + n, a[i].first + d - 1) - (b + 1);\n    ans = max(ans, f[i] - f[up + 1]);\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout\nlines = stdin.readlines()\nn, d = int(lines[0].split()[0]), int(lines[0].split()[1])\na = sorted([[int(x.split()[0]),int(x.split()[1])]  for x in lines[1:]])\n\nmax_val = 0\nstart_pointer = 0\ncur_val = 0\nfor end_pointer in range(n):\n    cur_val += a[end_pointer][1]\n    while (a[end_pointer][0] - a[start_pointer][0]) >= d:\n        cur_val -= a[start_pointer][1]\n        start_pointer += 1\n    if cur_val > max_val:\n        max_val = cur_val\n\nprint(max_val) "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n, d;\n  cin >> n >> d;\n  vector<std::pair<int, int> > v;\n  long long m, s;\n  for (int i = 0; i < (n); ++i) {\n    cin >> m >> s;\n    v.push_back(make_pair(m, s));\n  }\n  sort(v.begin(), v.end());\n  long long maxm = v[0].second, sum = 0, prev = v[0].first, index = 0;\n  for (int i = 1; i <= (n - 1); ++i) {\n    if (i == 1 && v[i].first - prev < d) {\n      sum += v[i - 1].second;\n      maxm = max(sum, maxm);\n    }\n    if (v[i].first - prev < d) {\n      sum += v[i].second;\n      maxm = max(sum, maxm);\n    } else {\n      sum -= v[index].second;\n      maxm = max(sum, maxm);\n      index++;\n      prev = v[index].first;\n      i--;\n    }\n  }\n  cout << maxm;\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nconst long long int INF = 1e18;\nconst int MX = 300001;\nint rownum[] = {-1, 0, 0, 1};\nint colnum[] = {0, -1, 1, 0};\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long int t, x, y, p, q, c, e, i, j, n, m, k;\n  cin >> n >> p;\n  vector<pair<long long int, long long int> > v;\n  vector<long long int> vf;\n  for (i = 0; i < n; i++) {\n    cin >> x >> y;\n    v.push_back(make_pair(x, y));\n    vf.push_back(x);\n  }\n  sort(v.begin(), v.end());\n  sort(vf.begin(), vf.end());\n  for (i = 1; i < n; i++) {\n    v[i].second += v[i - 1].second;\n  }\n  k = 0;\n  for (i = 0; i < n; i++) {\n    q = upper_bound(vf.begin(), vf.end(), vf[i] + p - 1) - vf.begin();\n    if (i == 0)\n      k = max(k, v[q - 1].second);\n    else\n      k = max(k, v[q - 1].second - v[i - 1].second);\n  }\n  cout << k;\n}\n"
        },
        {
            "language": 1,
            "solution": "entry = raw_input().split()\nn, d = int(entry[0]), int(entry[1])\nfriends = []\nfor i in range(n):\n    entry = raw_input().split()\n    x, y = int(entry[0]), int(entry[1])\n    friends.append((x,y))\npals = sorted(friends, key = lambda friend: friend[0])\n\nlow = 0\nlow_value = pals[low][0]\ntotal = pals[low][1]\nhigh = 0\nwhile high < n-1 and pals[high+1][0] < low_value + d:\n    high += 1\n    total += pals[high][1]\n\nbest = total\nwhile high < n-1:\n    total -= pals[low][1]\n    low += 1\n    low_value = pals[low][0]\n    while high < n-1 and pals[high+1][0] < low_value + d:\n        high += 1\n        total += pals[high][1]\n    if total > best:\n        best = total\n\nprint best\n"
        },
        {
            "language": 4,
            "solution": "//package round321;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class B {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint[][] fs = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfs[i] = na(2);\n\t\t}\n\t\tArrays.sort(fs, new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn a[0] - b[0];\n\t\t\t}\n\t\t});\n\t\tint p = 0;\n\t\tlong score = 0;\n\t\tlong ret = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\twhile(p < i && fs[i][0]-fs[p][0] >= m){\n\t\t\t\tscore -= fs[p][1];\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tscore += fs[i][1];\n\t\t\tret = Math.max(ret, score);\n\t\t}\n\t\tout.println(ret);\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new B().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 3,
            "solution": "import bisect\nn,d=map(int,input().split())\na,b,c,i1,l,s,st,lt=0,0,0,0,[],[],[],[]\nf=0\nfor i,j in enumerate(range(n)):\n  m,p=map(int,input().split())\n  l.append([m,p])\nl=sorted(l,key=lambda li:li[0])\nfor i , j in enumerate(range(n)):\n  s.append(l[i][0])\n  st.append(l[i][1])\nwhile i1<=n-1:\n  a=bisect.bisect_right(s,(s[i1]+(d-1)))-1\n  c=bisect.bisect_left(s,(s[a]-(d-1)))\n  f=bisect.bisect_left(s,(s[i1]-(d-1)))\n  lt.append(sum(st[c:a+1]))\n  lt.append(sum(st[f:i1+1]))\n  i1=a+1\n\nprint(max(lt))"
        },
        {
            "language": 3,
            "solution": "n,d = list(map(int,input().split()))\narr = []\nfor i in range(n):\n    arr.append(list(map(int,input().split())))\narr.sort()\nl,r = 0,0\nans = 0\nt = 0\n# print(arr)\nwhile r<n:\n    # print(l,r)\n    if arr[r][0]-arr[l][0]<d:\n        t+=arr[r][1]\n        r+=1\n    else:\n        ans = max(ans,t)\n        t-=arr[l][1]\n        l+=1\nans = max(ans,t)\nprint(ans)  \n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.*;\n\npublic class Solution {\n\n    List<Friend> friends;\n\n    class Friend {\n        long money;\n        long level;\n\n        public Friend(int money, int level) {\n            this.money = money;\n            this.level = level;\n        }\n    }\n\n    Comparator<Friend> friendComparator = new Comparator<Friend>() {\n        public int compare(Friend o1, Friend o2) {\n            if (o1.money > o2.money)\n                return 1;\n\n            if (o1.money < o2.money)\n                return -1;\n\n            return 0;\n        }\n    };\n\n    public void solve() {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        friends = new ArrayList<Friend>();\n        int n = in.nextInt();\n        int d = in.nextInt();\n\n        for (int i = 0; i < n; i++) {\n            int x = in.nextInt();\n            int y = in.nextInt();\n            Friend newFriend = new Friend(x, y);\n            friends.add(newFriend);\n        }\n\n        Collections.sort(friends, friendComparator);\n\n        long maxLevel = 0;\n        long curLevel = 0;\n        int j = 0;\n\n        for (int i = 0; i < n; i++) {\n            while (j < n && friends.get(j).money - friends.get(i).money < d) {\n                curLevel += friends.get(j).level;\n                j++;\n            }\n            maxLevel = Math.max(maxLevel, curLevel);\n\n            curLevel -= friends.get(i).level;\n        }\n        out.println(maxLevel);\n        out.close();\n    }\n\n\n    public static void main(String[] args) {\n\t    new Solution().solve();\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class A {\n\tprivate static Scanner input= new Scanner(System.in);\n\tprivate static long totalFriendship[];\n\t\n\tpublic static void main(String[] args) {\n\t\tint n = input.nextInt();\n\t\tint minDiff = input.nextInt();\n\t\tFriend friends[] = new Friend[n];\n\t\ttotalFriendship = new long[n+1];\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint money = input.nextInt();\n\t\t\tint friendship = input.nextInt();\n\t\t\tfriends[i] = new Friend(money, friendship);\n\t\t}\n\t\t\n\t\tArrays.sort(friends);\n\t\tconstructTotalFriendship(friends);\n\t\t//System.out.println(Arrays.toString(totalFriendship));\n\t\t\n\t\tlong maxFriendship = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint maxIndex = binarySearch(friends, i, n - 1,  friends[i].money + minDiff, 0);\n\t\t\tmaxFriendship = Math.max(maxFriendship, intervalFriendship(i, maxIndex));\t\n\t\t\t//System.out.println(i + \": \" + maxIndex);\n\t\t\t//System.out.println(\"max friendship: \" + maxFriendship);\n\t\t}\n\t\t\n\t\tSystem.out.println(maxFriendship);\n\t}\n\t\n\tprivate static int binarySearch(Friend friends[], int start, int end, int target, int lastResult) {\n\t\tint mid = (start + end) / 2;\n\t\t//System.out.println(\"Start End: \" + start + \" \" + end + \"Mid: \" + mid + \" Money: \" + friends[mid].money);\n\t\t\n\t\tif (end < start)\n\t\t\treturn lastResult;\n\t\t\n\t\tif (friends[mid].money >= target)\n\t\t\treturn binarySearch(friends, start , mid - 1, target, lastResult);\n\t\telse {\n\t\t\treturn binarySearch(friends, mid + 1, end, target, mid);\n\t\t}\n\t}\n\t\n\tprivate static void constructTotalFriendship(Friend friends[]) {\n\t\ttotalFriendship[0] = friends[0].friendship;\n\t\t\n\t\tfor (int i = 1; i < friends.length; i++)\n\t\t\ttotalFriendship[i] = totalFriendship[i - 1] + friends[i].friendship;\n\t}\n\t\n\tprivate static long intervalFriendship(int startIndex, int endIndex) {\n\t\tif (startIndex <= 0)\n\t\t\treturn totalFriendship[endIndex];\n\t\telse \n\t\t\treturn totalFriendship[endIndex] - totalFriendship[startIndex - 1];\n\t}\t\n}\n\nclass Friend implements Comparable<Friend>{\n\tpublic int money;\n\tpublic int friendship;\n\t\n\tpublic Friend(int new_money, int new_friendship) {\n\t\tmoney = new_money;\n\t\tfriendship = new_friendship;\n\t}\n\t\n\tpublic int compareTo(Friend other) {\n\t\treturn this.money - other.money;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"Money: \" + this.money + \", Friendship: \" + this.friendship + \"\\n\";\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "def binary_search(arr, n, key):\n    l, r = 0, n-1\n    while (l <= r):\n        mid = l+r >> 1\n        if (arr[mid][0] <= key):\n            l = mid+1\n        else:\n            r = mid-1\n    return l\n\ndef main():\n    n, d = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        m, s = map(int, input().split())\n        arr += [(m, s)]\n    arr.sort()\n    arr_acc = [0] * (n+1)\n    for i in range(n):\n        arr_acc[i+1] = arr_acc[i] + arr[i][1]\n    res = 0\n    for i in range(n):\n        key = arr[i][0]+d-1\n        j = binary_search(arr, n, key)\n        res = max(res, arr_acc[j] - arr_acc[i])\n    print(res)\n\nmain()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long int i, d, j, k, l, t, n;\n  cin >> n >> d;\n  vector<pair<long long int, long long int>> v;\n  l = -1;\n  for (i = 0; i < n; i++) {\n    cin >> j >> k;\n    v.push_back(make_pair(j, k));\n  }\n  sort(v.begin(), v.end());\n  long long int cnt = v[0].first;\n  long long int ci = 0;\n  long long int ans = v[0].second;\n  long long int sum = v[0].second;\n  for (i = 1; i < n; i++) {\n    if (v[i].first - cnt < d) {\n      sum += v[i].second;\n      continue;\n    } else {\n      ans = max(ans, sum);\n      sum += v[i].second;\n      for (j = ci; j < i; j++) {\n        if (v[i].first - v[j].first < d) {\n          cnt = v[j].first;\n          ci = j;\n          break;\n        } else\n          sum -= v[j].second;\n      }\n      if (j == i) {\n        cnt = v[i].first;\n        ci = i;\n      }\n    }\n  }\n  ans = max(ans, sum);\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err(istream_iterator<string> it) {}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n  cerr << *it << \" = \" << a << \"\\n\";\n  err(++it, args...);\n}\nstruct xx {\n  bool operator()(pair<int, int>& x, pair<int, int>& y) {\n    return y.first > x.first;\n  }\n};\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL);\n  int n, d;\n  cin >> n >> d;\n  vector<pair<int, int>> arr(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    arr[i] = {x, y};\n  }\n  sort(arr.begin(), arr.end(), xx());\n  long long max_factor = INT_MIN;\n  long long maxx = 0;\n  int j = 0;\n  for (int i = 0; i < n && j < n;) {\n    if (abs(arr[j].first - arr[i].first) < d) {\n      maxx += arr[j].second;\n      j++;\n    } else {\n      {\n        string _s = \"maxx\";\n        replace(_s.begin(), _s.end(), ',', ' ');\n        stringstream _ss(_s);\n        istream_iterator<string> _it(_ss);\n        err(_it, maxx);\n      };\n      max_factor = max(maxx, max_factor);\n      maxx -= arr[i].second;\n      i++;\n    }\n    max_factor = max(maxx, max_factor);\n  }\n  cout << max_factor;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 1;\npair<int, int> a[N];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, d;\n  cin >> n >> d;\n  for (int i = 0; i < n; ++i) cin >> a[i].first >> a[i].second;\n  sort(a, a + n);\n  int L = 0, R = 0;\n  long long temp = 0, ans = INT_MIN;\n  while (R < n) {\n    temp += a[R++].second;\n    while (a[R - 1].first - a[L].first >= d) temp -= a[L++].second;\n    ans = max(ans, temp);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\n\np = []\n\nfor i in range(n):\n    m, f = map(int, input().split())\n    p.append([m, f])\n\np = sorted(p)\n\n\nx2 = 0\nmax_f = 0\nf = 0\nfor x1 in range(n):\n    x2 = max(x1, x2)\n    while x2 < n and p[x2][0] - p[x1][0] < d:\n        f += p[x2][1]\n        x2 += 1\n\n    if f > max_f:\n        max_f = f\n\n    f -= p[x1][1]\n\nprint(max_f)"
        },
        {
            "language": 3,
            "solution": "n, d = list(map(int, input().split()))\nfriends = []\n\n\nmax_friendship = 0\ntmp_index = 0\ntmp_friendship = 0\n\nfor k in range(n):\n    m, s = list(map(int, input().split()))\n    friends.append({'m': m, 's': s})\n\nfriends = sorted(friends, key=lambda x: x['m'])\nk = 0\nwhile k < n:\n    if abs(friends[tmp_index]['m'] - friends[k]['m']) >= d:\n        tmp_friendship -= friends[tmp_index]['s']\n        tmp_index += 1\n    else:\n        tmp_friendship += friends[k]['s']\n        max_friendship = max(max_friendship, tmp_friendship)\n        k += 1\n\n\nprint(max_friendship)\n\n"
        },
        {
            "language": 3,
            "solution": "[n,d] = list(map(int, input().split()))\na = [list(map(int, input().split())) for _ in range(n)]\na.sort()\n\nans=a[0][1]\nres=a[0][1]\np1=0\np2=0\n\nwhile(p2 < n-1):\n    if (a[p2+1][0] - a[p1][0] < d):\n        p2 += 1\n        ans += a[p2][1]\n        if(ans > res):\n            res=ans\n    else:\n        ans -= a[p1][1]\n        p1 += 1\n        \nprint(res)\n"
        },
        {
            "language": 1,
            "solution": "from math import *\nfrom Queue import *\nfrom sys import *\n\n\n\n\n\nn, d = map(int, raw_input().split())\nmon = []\ndic = dict()\nfor i in range(n):\n    m, s = map(int, raw_input().split())\n    if m not in dic:\n        mon.append(m)\n        dic[m] = s\n    else:\n        dic[m] += s\nmon.sort()\nres = 0\ni = 0\nwhile (i < len(mon)) and (mon[i] - mon[0] < d):\n    res += dic[mon[i]]\n    i += 1\ncur = res\nj = 0\nwhile i < len(mon):\n    cur += dic[mon[i]]\n    while mon[j] + d <= mon[i]:\n        cur -= dic[mon[j]]\n        j += 1\n    res = max(res, cur)\n    i += 1\nprint(res)\n"
        },
        {
            "language": 3,
            "solution": "n, d = list(map(int, input().split()))\n\npairs = []\n\nfor i in range(n):\n    pairs.append(list(map(int, input().split())))\n\npairs.sort(key=lambda x: x[0])\n\ni = 0\nj = 0\ncount = 0\nnumbers = []\n\nwhile(i < n):\n    if(pairs[i][0] - pairs[j][0] < d):\n        count += pairs[i][1]\n        numbers.append(count)\n        i += 1\n    else:\n        count -= pairs[j][1]\n        j += 1\n\nprint(max(numbers))"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C321B\n{\n    static PrintWriter out = new PrintWriter((System.out));\n\n    public static void main(String args[]) throws IOException\n    {\n        Reader sc = new Reader();\n        int n=sc.nextInt();\n        long d=sc.nextLong();\n        Data ar[]=new Data[n];\n        for(int x=0;x<n;x++)\n        {\n            int a=sc.nextInt();\n            int b=sc.nextInt();\n            ar[x]=new Data(a,b);\n        }\n        Arrays.parallelSort(ar,new Sort());\n        int left=0;\n        long ans=ar[0].x;\n        long max=ans;\n        long curr=ar[0].m;\n        for(int x=1;x<n;x++)\n        {\n            long q=ar[x].x;\n            long t=ar[x].m;\n            while(left<x&&Math.abs(curr-t)>=d)\n            {\n                ans-=ar[left++].x;\n                if(left<n)\n                {\n                    curr = ar[left].m;\n                }}\n            ans+=q;\n            curr=Math.min(curr,t);\n            if(max<ans)\n            {\n                max=ans;\n            }\n        }\n        out.println(max);\n        out.close();\n    }\n    static class Data\n    {\n        long m,x;\n        public Data(long m,long x)\n        {\n            this.m=m;\n            this.x=x;\n        }\n    }\n    static class Sort implements Comparator<Data>\n    {\n        public int compare(Data a,Data b)\n        {\n            if(a.m>b.m)\n            {\n                return 1;\n            }\n            else if(a.m==b.m)\n            {\n                return 0;\n            }\n            else\n            {\n                return -1;\n            }\n        }\n    }\n\n    static class Reader\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        public String next()\n        {\n            while (!st.hasMoreTokens())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (Exception e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine()\n        {\n            try\n            {\n                return br.readLine();\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n            return null;\n        }\n\n        public boolean hasNext()\n        {\n            String next = null;\n            try\n            {\n                next = br.readLine();\n            }\n            catch (Exception e)\n            {\n            }\n            if (next == null)\n            {\n                return false;\n            }\n            st = new StringTokenizer(next);\n            return true;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "n, k = [int(i) for i in input().split()]\narr = []\nfor i in range(n):\n    s = [int(i) for i in input().split()]\n    arr.append(s)\n\nlst = []\narr.sort()\nv = arr[0][1]\nj = 1\n\nfor i in range(len(arr)):\n    if j == n:\n        break\n    while abs(arr[i][0] - arr[j][0]) < k:\n\n        v += arr[j][1]\n        j += 1\n        if j > n - 1:\n            break\n\n    lst.append(v)\n    v -= arr[i][1]\nlst = lst + [i[1] for i in arr]\nprint(max(lst))\n"
        },
        {
            "language": 3,
            "solution": "#\n# Kefa wants to celebrate his first big salary by going to restaurant. However, he needs company.\n#\n# Kefa has n friends, each friend will agree to go to the restaurant if Kefa asks.\n# Each friend is characterized by the amount of money he has and the friendship factor in respect to Kefa.\n# The parrot doesn't want any friend to feel poor compared to somebody else in the company (Kefa doesn't count).\n# A friend feels poor if in the company there is someone who has at least d units of money more than he does.\n# Also, Kefa wants the total friendship factor of the members of the company to be maximum.\n# Help him invite an optimal company!\n#\n# Input\n#\n# The first line of the input contains two space-separated integers, n and d (1\u2009\u2264\u2009n\u2009\u2264\u2009105, ) \u2014 the number of Kefa's\n# friends and the minimum difference between the amount of money in order to feel poor, respectively.\n#\n# Next n lines contain the descriptions of Kefa's friends, the (i\u2009+\u20091)-th line contains\n# the description of the i-th friend of type mi, si (0\u2009\u2264\u2009mi,\u2009si\u2009\u2264\u2009109) \u2014 the amount of money\n# and the friendship factor, respectively.\n#\n# Output\n#\n# Print the maximum total friendship factor that can be reached.\n#\n# Examples\n#\n# Input\n#\n# 4 5\n# 75 5\n# 0 100\n# 150 20\n# 75 1\n#\n# Output\n#\n# 100\n#\n# Input\n#\n# 5 100\n# 0 7\n# 11 32\n# 99 10\n# 46 8\n# 87 54\n#\n# Output\n#\n# 111\n#\n# Note\n#\n# In the first sample test the most profitable strategy is to form a company from only the second friend.\n# At all other variants the total degree of friendship will be worse.\n#\n# In the second sample test we can take all the friends.\n#\n\nimport sys\n\n\nclass Solution:\n    def max_friendship_factor(self, money_diff, friends_data):\n\n        # sort by money amount, so that we could go through all\n        # the intervals where money diff in [0, money_diff]\n        friends_data = sorted(friends_data, key=lambda f: f[0])\n\n        # count friendship factors for every prefix\n        factors = [friends_data[0][1]]\n        for i in range(1, len(friends_data)):\n            factors.append(factors[i-1] + friends_data[i][1])\n\n        # go through all the intervals where\n        # money diff in [0, money_diff]\n        ff_max, j = 0, len(friends_data) - 1\n        for i in range(len(friends_data) - 1, -1, -1):\n\n            # find interval left border, on each step j will either\n            # stay the same or decrease since we're decreasing right border\n            while j > 0 and friends_data[j][0] - friends_data[i][0] >= money_diff:\n                j -= 1\n\n            # calculate friendship factor for the interval\n            ff = factors[j]\n            if i > 0:\n                ff -= factors[i - 1]\n\n            # compare if it's total maximum\n            if ff > ff_max:\n                ff_max = ff\n\n        return ff_max\n\n\ndef main():\n    inp = sys.stdin.readline()\n    friends, money_diff = list(map(int, inp.split()))\n    friends_data = []\n    while friends > 0:\n        inp = sys.stdin.readline()\n        friends_data.append(list(map(int, inp.split())))\n        friends -= 1\n    print(Solution().max_friendship_factor(money_diff, friends_data))\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > v;\nint main() {\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  v.resize(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d\", &v[i].first, &v[i].second);\n  }\n  sort(v.begin(), v.end());\n  long long sum = 0, ans = 0;\n  int l = 0, r = 0;\n  while (r < n) {\n    if (v[r].first - d < v[l].first) {\n      sum += v[r].second;\n      r++;\n    } else {\n      ans = max(ans, sum);\n      sum -= v[l].second;\n      l++;\n    }\n  }\n  cout << max(ans, sum);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<int, int> a[100005];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  int n, d;\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a, a + n);\n  long long int mx = 0, x = 0, l = 0, r = 0;\n  for (; l < n; l++) {\n    while (r < n && a[r].first < a[l].first + d) {\n      x += a[r].second;\n      r++;\n    }\n    mx = max(mx, x);\n    x -= a[l].second;\n  }\n  cout << mx << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.nio.charset.StandardCharsets;\n// import java.math.BigInteger;\n\npublic class B {\n    static Writer wr;\n\n    public static void main(String[] args) throws Exception {\n        // long startTime = System.nanoTime();\n\n        // String testString = \"\";\n        // InputStream stream = new ByteArrayInputStream(testString.getBytes(StandardCharsets.UTF_8));\n        // Reader in = new Reader(stream);\n\n        Reader in = new Reader();\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        wr = new Writer();\n\n        /* Precomputation */\n\n\n        // long elapsedTime = System.nanoTime() - startTime;\n        // double seconds = (double)elapsedTime / 1000000000.0;\n        // wr.writeRedLn(seconds);\n\n        /* Input */\n        int N = in.nextInt();\n        long d = in.nextLong();\n\n        Long[][] a = new Long[N][2];\n\n        for(int i=0;i<N;i++) {\n            a[i][0] = in.nextLong();\n            a[i][1] = in.nextLong();\n        }\n\n        Arrays.sort(a, new Comparator<Long[]>(){\n            public int compare(Long[] lhs, Long[] rhs) {\n                return (int)((long)lhs[0] - (long)rhs[0]);\n            }\n        });\n\n        // for(int i=0;i<N;i++) {\n        //     wr.writeGreenLn(Arrays.toString(a[i]));\n        // }\n\n        long curr=0, ans = 0;\n        boolean start = true;\n        for(int i=0, j=0;i<N;i++) {\n            long min = a[i][0];\n            for(;j<N;j++) {\n                // wr.writeRedLn(i+\",\"+j);\n                if(a[j][0]-min<d) {\n                    curr+=a[j][1];\n                    ans = Math.max(ans, curr);\n                }\n                else {\n                    // j--;\n                    break;\n                }\n            }\n            curr -= a[i][1];\n        }\n\n        out.write(ans + \"\\n\");\n        out.flush();\n    }\n}\n\n\n\nclass Writer {\n    public void writeRedLn(Object x) { writeRedLn(x+\"\"); }\n    public void writeBlueLn(Object x) { writeBlueLn(x+\"\"); }\n    public void writeGreenLn(Object x) { writeGreenLn(x+\"\"); }\n    public void writePinkLn(Object x) { writePinkLn(x+\"\"); }\n    public void writeRedLn(String x) { System.out.println((char)27 + \"[31m\" + (char)27 + \"[40m\" + x + (char)27 + \"[0m\"); }\n    public void writeBlueLn(String x) { System.out.println((char)27 + \"[34m\" + (char)27 + \"[3m\" + x + (char)27 + \"[0m\"); }\n    public void writeGreenLn(String x) { System.out.println((char)27 + \"[32m\" + (char)27 + \"[3m\" + x + (char)27 + \"[0m\"); }\n    public void writePinkLn(String x) { System.out.println((char)27 + \"[30m\" + (char)27 + \"[45m\" + x + (char)27 + \"[0m\"); }\n    public void writeRed(String x) { System.out.print((char)27 + \"[31m\" + (char)27 + \"[40m\" + x + (char)27 + \"[0m\"); }\n    public void writeBlue(String x) { System.out.print((char)27 + \"[34m\" + (char)27 + \"[3m\" + x + (char)27 + \"[0m\"); }\n    public void writeGreen(String x) { System.out.print((char)27 + \"[32m\" + (char)27 + \"[3m\" + x + (char)27 + \"[0m\"); }\n    public void writePink(String x) { System.out.print((char)27 + \"[30m\" + (char)27 + \"[45m\" + x + (char)27 + \"[0m\"); }\n}\n\n\nclass Reader {\n    public int LINE_LIMIT = -1;\n    final private int BUFFER_SIZE = 1 << 16;private DataInputStream din;private byte[] buffer;private int bufferPointer, bytesRead;\n    public Reader(){din=new DataInputStream(System.in);buffer=new byte[BUFFER_SIZE];bufferPointer=bytesRead=0;}\n    public Reader(InputStream stream){din=new DataInputStream(stream);buffer=new byte[BUFFER_SIZE];bufferPointer=bytesRead=0;}\n    public int[] ni_array(int N) throws IOException { int[] ans = new int[N]; for(int i=0;i<N;i++) { ans[i] = nextInt(); } return ans; }\n    public String readLineUtil()throws IOException{byte[] buf=new byte[Math.max(400024,LINE_LIMIT)];int cnt=0,c;\n        while((c=read())!=-1){if(c=='\\n')break;buf[cnt++]=(byte)c;}return new String(buf,0,cnt);}\n    public String readLine() throws IOException{ String line = readLineUtil().trim(); while(line.length()==0) line = readLineUtil().trim(); return line; }\n    public char nextChar()throws IOException{byte c=read();while(c<=' ')c=read();return (char)c;}\n    public int nextInt()throws IOException{int ret=0;byte c=read();while(c<=' ')c=read();boolean neg=(c=='-');\n        if(neg)c=read();do{ret=ret*10+c-'0';}while((c=read())>='0'&&c<='9');if(neg)return -ret;return ret;} \n    public long nextLong()throws IOException{long ret=0;byte c=read();while(c<=' ')c=read();boolean neg=(c=='-');\n        if(neg)c=read();do{ret=ret*10+c-'0';}while((c=read())>='0'&&c<='9');if(neg)return -ret;return ret;}\n    public double nextDouble()throws IOException{double ret=0,div=1;byte c=read();while(c<=' ')c=read();boolean neg=(c=='-');if(neg)c = read();do {ret=ret*10+c-'0';}while((c=read())>='0'&&c<='9');\n        if(c=='.')while((c=read())>='0'&&c<='9')ret+=(c-'0')/(div*=10);if(neg)return -ret;return ret;}\n    private void fillBuffer()throws IOException{bytesRead=din.read(buffer,bufferPointer=0,BUFFER_SIZE);if(bytesRead==-1)buffer[0]=-1;}\n    private byte read()throws IOException{if(bufferPointer==bytesRead)fillBuffer();return buffer[bufferPointer++];}\n    public void close()throws IOException{if(din==null) return;din.close();}\n}\n"
        },
        {
            "language": 3,
            "solution": "n,m=map(int,input().split())\nls=[list(map(int,input().split())) for i in range(n) ]\nls.sort(reverse=True)\nsu,maximum=0,0\nsu=ls[0][1]\nmaximum=su\ntop=0\ni=1\nwhile i<n:\n    while i<n and ls[i][0] +m > ls[top][0] :\n        su+=ls[i][1]\n        i+=1\n    maximum=max(maximum,su)\n    if i==n: break\n    while i>top and ls[i][0] +m <= ls[top][0]:\n        su-=ls[top][1]\n        top+=1\n    su+=ls[i][1] \n    maximum=max(maximum,su)\n    i+=1\nprint(maximum)           \n"
        },
        {
            "language": 4,
            "solution": "//package codeforces321;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package codechefoct2015;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport static java.util.Collections.sort;\n\n/**\n *\n * @author Sourav Kumar Paul\n */\n\npublic  class  SolveB implements Comparable {\n public int m, s;\n\n    public SolveB(int m, int s) {\n        this.m = m;\n        this.s = s;\n    }\n\n    public int compareTo(Object obj) {\n        SolveB st = (SolveB) obj;\n        if (m == st.m) {\n            return 0;\n        } else if (m > st.m) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String line[] = reader.readLine().split(\" \");\n        int n = Integer.parseInt(line[0]);\n        int d = Integer.parseInt(line[1]);\n        ArrayList<SolveB> list = new ArrayList<SolveB>();\n        for (int i = 0; i < n; i++) {\n            line = reader.readLine().split(\" \");\n            int m = Integer.parseInt(line[0]);\n            int s = Integer.parseInt(line[1]);\n            SolveB f1 = new SolveB(m, s);\n            list.add(f1);\n        }\n        sort(list);\n       \n        long max = 0;\n        int j = 0;\n        long sum = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(; j<n; j++)\n            {\n                if(list.get(j).m - list.get(i).m <d)\n                    sum += list.get(j).s;\n                else\n                    break;\n            }\n            max = Math.max(max, sum);\n            sum = sum - list.get(i).s;\n        }\n        System.out.println(max);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntypedef struct Friend {\n  long long m, s;\n} F;\nlong long n, d, res = 0;\nF a[100001];\nvoid quicksort(long long d, long long c) {\n  if (d >= c) return;\n  srand(time(NULL));\n  long long i1 = d, j1 = c, val = a[d + rand() % (c - d + 1)].m;\n  while (i1 <= j1) {\n    while (a[i1].m < val) i1++;\n    while (a[j1].m > val) j1--;\n    if (i1 <= j1) {\n      if (i1 < j1) {\n        F tmp = a[i1];\n        a[i1] = a[j1];\n        a[j1] = tmp;\n      }\n      i1++;\n      j1--;\n    }\n  }\n  quicksort(d, j1);\n  quicksort(i1, c);\n}\nint main() {\n  scanf(\"%I64d%I64d\", &n, &d);\n  for (long long i = 1; i <= n; i++) scanf(\"%I64d%I64d\", &a[i].m, &a[i].s);\n  quicksort(1, n);\n  a[0].s = 0;\n  for (long long i = 1; i <= n; i++) a[i].s += a[i - 1].s;\n  long long j = 1;\n  for (long long i = 1; i <= n; i++) {\n    while (j < n && a[j + 1].m - a[i].m < d) j++;\n    if (a[j].s - a[i - 1].s > res) res = a[j].s - a[i - 1].s;\n  }\n  printf(\"%I64d\", res);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "\"\"\"\nnumFriends, minDiff = map(int, raw_input().split(\" \"))\n\narr = []\n\nfor _ in xrange(numFriends):\n    money, factor = map(int, raw_input().split(\" \"))\n    arr.append((money, factor))\n\narr.sort(key=lambda a: a[0])\n\nres = 0\n\nfor i in xrange(0, numFriends):\n    summe = arr[i][1]\n    for j in xrange(i + 1, numFriends):\n        if abs(arr[i][0] - arr[j][0]) >= minDiff:\n            break\n        else:\n            summe += arr[j][1]\n    res = max(res, summe)\n\nprint res\n\"\"\"\n\nn,d=map(int,raw_input().split())\nbl={}\nfor i in range(n):\n    m,s=map(int,raw_input().split())\n    if bl.has_key(m):\n        bl[m]+=s\n    else:\n        bl[m]=s\nls=[]\nfor i in bl:\n    ls.append((i,bl[i]))\nls.sort()\nans=tmp=b=0\nlst=len(ls)\nfor i in range(lst):\n    tmp+=ls[i][1]\n    if ls[i][0]-ls[b][0]>=d:\n        while 1:\n            tmp-=ls[b][1]\n            b+=1\n            if ls[i][0]-ls[b][0]<d:\n                break\n    ans=max(ans,tmp)\nprint ans\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\ndi = []\ndind = []\nfor i in range(n):\n    li = map(int, raw_input().split())\n    di.append(li)\ndi.sort()\ni = 0\nj = 1\na = ans = di[0][1]\nwhile(True):\n    if(i > n - 1 or j > n - 1):\n        break\n    if(di[j][0] - di[i][0] < d):\n        a += di[j][1]\n        j += 1\n    else:\n        a -= di[i][1]\n        i += 1\n    if(a > ans):\n        ans = a\nprint ans\n"
        },
        {
            "language": 1,
            "solution": "#coding: utf-8\n\n\nfriends, limit = map(int, raw_input().split())\n\nmatrix = []\n\nfor i in range(friends):\n    matrix.append(map(int, raw_input().split()))\n\npartial_sum = 0\n\ngreater_sum = 0\n\nk = 0\n\nmatrix.sort()\n\n\nfor j in range(friends):\n    \n    while k < friends and abs(matrix[k][0] - matrix[j][0]) < limit:\n        partial_sum += matrix[k][1]\n        k += 1\n\n    if (partial_sum > greater_sum):\n        greater_sum = partial_sum\n\n    partial_sum -= matrix[j][1]\n        \n\n\nprint greater_sum\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint xDir[8] = {0, 0, -1, 1, 1, -1, -1, 1};\nint yDir[8] = {1, -1, 0, 0, 1, -1, 1, -1};\nint EPS = 1e-10;\nint dComp(double d1, double d2) {\n  if (abs(d1 - d2) <= EPS) return 0;\n  if (d1 > d2)\n    return 1;\n  else\n    return -1;\n}\nbool lucky(int i) {\n  string s = to_string(i);\n  for (int j = 0; j < s.size(); j++)\n    if (s[j] - '0' != 4 && s[j] - '0' != 7) return false;\n  return true;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, d;\n  cin >> n >> d;\n  vector<pair<int, int> > vec(100001);\n  for (int i = 0; i < n; i++) {\n    cin >> vec[i].first >> vec[i].second;\n  }\n  sort(vec.begin(), vec.begin() + n);\n  int left = 0, right = 0;\n  long long sum = 0;\n  long long mx = -1;\n  while (left <= right && right < n && left < n) {\n    if (abs(vec[left].first - vec[right].first) < d) {\n      sum += vec[right].second;\n      right++;\n      mx = max(mx, sum);\n    } else {\n      sum -= vec[left].second;\n      left++;\n    }\n    mx = max(mx, sum);\n  }\n  cout << mx << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "def bina(arr,target,i,n):\n    l,h,ans=i,n-1,i\n    while(l<=h):\n        m=(l+h)//2\n        if arr[m][0]>=target:\n            h=m-1\n        else:\n            ans=m\n            l=m+1\n    return ans\n\n\n\nn,d=list(map(int,input().split()))\narr=[tuple(map(int,input().split())) for _ in range(n)]\narr.sort(key=lambda x :x[0])\nprefix=[0]*n\nprefix[0]=arr[0][1]\nfor i in range(1,n):\n    prefix[i]=prefix[i-1]+arr[i][1]\nmx=-1\nfor i in range(n):\n    target=arr[i][0]+d\n    ind=bina(arr,target,i,n)\n    mx=max(mx,prefix[ind]-prefix[i]+arr[i][1])\nprint(mx)"
        },
        {
            "language": 1,
            "solution": "R=lambda:map(int,raw_input().split())\nn,d=R()\nx=range(n)\nf=sorted([R() for _ in x])\nl,F=0,0\nmaxF=0\nfor r in x:\n\tF+=f[r][1]\n\twhile f[r][0]-f[l][0]>=d:\n\t\tF-=f[l][1]\n\t\tl+=1\n\tmaxF=max(maxF,F)\nprint maxF"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom bisect import bisect_right\n\n\ndef main():\n    n, d = map(int, input().split())\n    friends = sorted(tuple(int(c) for c in line.split()) for line in sys.stdin.readlines())\n    money = [e[0] for e in friends]\n\n    friendship_sum = [0]\n    for _, e in friends:\n        friendship_sum.append(friendship_sum[-1] + e)\n\n    _min = friends[0][0]\n    i = 1\n    start = 0\n\n    ans = friends[0][1]\n\n    while i < n:\n        cur = money[i]\n        diff = cur - _min\n        _min = min(_min, cur)\n\n        if diff >= d:\n            start = bisect_right(money, cur - d)\n            _min = money[start]\n\n        friendship = friendship_sum[i+1] - friendship_sum[start]\n        ans = max(ans, friendship)\n\n        i += 1\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool sortbysec(const pair<long long, long long> &a,\n               const pair<long long, long long> &b) {\n  return (a.second > b.second);\n}\nvoid solve() {\n  long long n, d;\n  cin >> n >> d;\n  vector<pair<long long, long long>> v(n);\n  long long sum1 = 0;\n  for (long long i = 0; i < n; i++) {\n    long long x, y;\n    cin >> v[i].first >> v[i].second;\n  }\n  sort(v.begin(), v.end());\n  long long l = 0, r = 0;\n  long long ans = 0;\n  long long s = 0;\n  for (; l < n; ++l) {\n    while (r < n && v[r].first < v[l].first + d) {\n      s += v[r].second;\n      ++r;\n    }\n    ans = max(ans, s);\n    s -= v[l].second;\n  }\n  cout << ans << endl;\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//6000 KB memory \nimport com.sun.javafx.scene.control.skin.VirtualFlow;\nimport java.io.BufferedReader;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport javafx.util.Pair;\n \npublic class Main  //main class\n{\n  \n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n     ////////////////////////////////////////////////////////////\n    /* global area */\n    static int L,R;\n    static long count=0,ans=0;\n    static  Pair <Integer,Integer>frinds[];\n    ////////////////////////////////////////////////////////////\n\tpublic static void main(String args[]) throws Exception{\n         FastReader in=new FastReader();\n         int numOfFrinds=in.nextInt();\n         int max_dif=in.nextInt();\n         frinds=new Pair [numOfFrinds];\n            \n            for (int i = 0; i < numOfFrinds; i++)\n                 frinds[i]=new Pair(in.nextInt(),in.nextInt());\n                    //key =mony , value=frind point\n            new MergeSort().PrepareForSort(frinds);\n            for (R= 0; R <numOfFrinds; R++) {\n                while(frinds[R].getKey()-frinds[L].getKey()>=max_dif){\n                    count-=frinds[L].getValue();\n                    L++;    \n                }\n                    \n\n                //if(frinds[R].getKey()-frinds[L].getKey()<=max_dif)\n                    count+=frinds[R].getValue();\n                ans=Math.max(ans, count);\n            }\n            System.out.println(ans);\n        }//end main mathod\n         /////////////////////////////////////////////////////////////////////////\n        public static class MergeSort {\n  \n\tPair<Integer,Integer>[] array;            //data type\n        Pair<Integer,Integer>[] TempArray;        //data type\n\n   \n\t \n\t\tpublic void PrepareForSort(Pair<Integer,Integer>[] arr){     //data type\n\t\t\t// prepare for sort\n\t\t\tthis.array=arr;\n\t\t\tthis.TempArray=new Pair[arr.length];                 //data type\n\t\t\tdoMergeSort(0,arr.length-1);\n\t\t}\n\t\t\n\t\tvoid doMergeSort(int LowerIndex, int HigherIndex){\n\t\t\t\n\t\t\tif(LowerIndex< HigherIndex ){\n\t\t\tint middle=LowerIndex+ (HigherIndex-LowerIndex)/2;\n\t\t\tdoMergeSort(LowerIndex,middle); //ex.(1-5)\n\t\t\tdoMergeSort(middle+1,HigherIndex);//ex.(6,10)\n\t\t\tMergePart(LowerIndex,middle,HigherIndex);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t// merge small problems and sort\n\t\tvoid MergePart(int LowerIndex,int middle,int HigherIndex ){\n\t\t for(int i=LowerIndex;i<=HigherIndex;i++)\t\n\t\t\t TempArray[i]= array[i];\n\t\t int i=LowerIndex;\n\t\t int j=middle+1;\n\t\t int  k=LowerIndex;\n\t\t while(i<=middle && j<= HigherIndex){\n\t\t\t if( TempArray[i].getKey()<= TempArray[j].getKey()){\n\t\t\t\t array[k] =TempArray[i];\n\t\t\t\t i++;\n\t\t\t }else{\n\t\t\t\t array[k] =TempArray[j];\n\t\t\t\t j++; \n\t\t\t }\n\t\t\t k++;\n\t\t }\n\t\t while(i<=middle){\n\t\t\t array[k] =TempArray[i];\n\t\t\t k++;\n\t\t\t i++;\n\t\t }\n\t\t}\n}\n}\n   "
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\na = []\nfor i in range(n):\n    m, s = map(int, input().split())\n    a.append((m, s))\na.sort()\nl = 0\nr = 0\nsm = 0\nmx = 0\nwhile l < n:\n    while a[r][0] - a[l][0] < d:\n        sm += a[r][1]\n        r += 1\n        if r == n:\n            break\n    if sm > mx:\n        mx = sm\n    if r == n:\n        break\n    sm -= a[l][1]\n    l += 1\nprint(mx)\n"
        },
        {
            "language": 3,
            "solution": "def key_tri(argument):\n    return argument[0]\n\nn,d = map(int, input().split())\nL = [list(map(int, input().split())) for _ in range(n)]\nL.sort(key=key_tri)\ndeb = 0\nT = []\ns = 0\nfor k in range(1,n):\n    if L[k][0] - L[deb][0] >= d:\n        s = 0\n        for i in range(deb,k):\n            s+=L[i][1]\n        T+=[s]\n        s = deb+1\n        while (L[k][0] - L[s][0]) >= d:\n            s+=1\n        deb = s\n\ns = 0\nfor k in range(deb,n):\n    s+=L[k][1]\nT = T + [s]\nprint(max(T))\n    \n"
        },
        {
            "language": 3,
            "solution": "from functools import cmp_to_key\ndef readnums():\n    return list(map(lambda x: int(x), input().split(\" \")))\n\n    \n    \ndef mycmp(a, b):\n    if a[0] > b[0]:\n        return 1\n    elif a[0] < b[0]:\n        return -1\n    else:\n        if a[1] > b[1]:\n            return 1\n        elif a[1] < b[1]:\n            return -1\n        return 0\n    \nn, d = readnums()\nfr = []\nfor i in range(n):\n    fr.append(tuple(readnums()))\n    \nfr.sort(key=cmp_to_key(mycmp))\n# print(fr)\n\nans = 0\nmin_money = 0\nfriendship = 0\ni = 0\nj = 0\nwhile i < n:\n    min_money = fr[i][0]\n    ans = max(ans, friendship)\n    \n    if (i > j):\n        j = i\n    while (j < n) and (abs(fr[j][0] - min_money) < d):\n        # print(i, j, min_money, (abs(fr[j][0] - min_money)))\n        friendship += fr[j][1]\n        j += 1\n        # print(j, friendship)\n        ans = max(ans, friendship)\n        # print(ans)\n    \n    friendship -= fr[i][1]\n    i += 1\n    \n    \n            \nprint(ans)\n            \n        \n    \n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split(\" \"))\nsum1=0\nmaximum=-1\na=[]\narr=[]\narr.append(0)\nfor x in range(n):\n    a.append(list(map(int,input().split(\" \"))))\na.sort()\nfor x in range(n):\n    sum1+=a[x][1]\n    arr.append(sum1)\ny=0\nfor x in range(n):\n    while(y<n and a[y][0]-a[x][0]<d):\n        y+=1\n    maximum=max(maximum,arr[y]-arr[x])\nprint(maximum)\n        \n"
        },
        {
            "language": 3,
            "solution": "import bisect\nfrom collections import Counter,defaultdict\nfrom sys import stdin, stdout\ninput = stdin.readline\nI =lambda:int(input())\nM =lambda:map(int,input().split())\nLI=lambda:list(map(int,input().split()))\nn,m=M()\nd=defaultdict(int)\nb=[]\nans=0\nfor _ in range(n):\n    a,b=M()\n    d[a]+=b\n    ans=max(ans,d[a])\nc=list(d.keys());c.sort()\ne=[0];val=0\nfor i in range(len(c)):\n    val+=d[c[i]]\n    e+=[val]\nfor i in range(len(c)):\n    f=c[i]+m\n    ind=bisect.bisect_left(c,f)\n    ans=max(ans,e[ind]-e[i])\nprint(ans)\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "from collections import namedtuple\nFriend = namedtuple(\"Friend\", \"money value\")\n\nn, d = map(int, input().split())\n\n# At first we sort all friends in money ascending order.\na = []\nfor i in range(n):\n    money, value = map(int, input().split())\n    a.append(Friend(money, value))\na.sort()\n\n# Now the answer is some array subsegment.\ns = ans = a[0].value\ntail = 0\n\n# Next, we use the method of two pointers for finding the required subsegment.\nfor head in range(1, n):\n    while (a[head].money - a[tail].money >= d):\n        s -= a[tail].value\n        tail += 1\n    s += a[head].value\n    ans = max(s, ans)\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.Collections;\n\npublic class Solution {\n\n    static class Solver {\n\n        Solver() {\n        }\n\n        public void solve(FastScanner sc, PrintWriter out) throws IOException {\n            int n = sc.nextInt();\n            long d = sc.nextInt();\n            List<Person> list = new ArrayList<>();\n            while(n-- > 0) {\n                Person p = new Person();\n                p.money = sc.nextLong();\n                p.friend = sc.nextLong();\n                list.add(p);\n            }\n\n            Collections.sort(list, (p1, p2) -> p1.money.compareTo(p2.money));\n            long max_f_total = list.get(0).friend;\n            long c = max_f_total;\n            for(int i = 1, j = 0; i < list.size(); i++) {\n                 Person pi = list.get(i);\n                 Person pj = list.get(j);\n                 if(pi.money - pj.money < d) {\n                      c += pi.friend;\n                 } else {\n                      c -= pj.friend;\n                      i--;\n                      ++j;\n                 }\n                 max_f_total = Math.max(max_f_total, c);\n            }\n            out.println(max_f_total);\n\n        }\n\n        class Person {\n            Long money;\n            Long friend;\n        }\n\n    }\n    public static void main(String[] args) throws IOException{\n        FastScanner scanner = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        (new Solver()).solve(scanner, out);\n        out.flush();\n\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(InputStream stream) {\n            try {\n                br = new BufferedReader(new InputStreamReader(stream));\n            } catch(Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        boolean hasNextToken() {\n            if(st == null) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch(IOException e) {\n\n                }\n            }\n            return st.hasMoreTokens();\n        }\n\n        String next() {\n            while(st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            return st.nextToken();\n        }\n\n        String nextLine() throws IOException{\n            return br.readLine();\n        }\n\n        byte nextByte() {\n            return Byte.parseByte(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class R321Div2B {\n\tstatic class Pair{\n\t\tlong first,second;\n\t\tpublic Pair(long first,long second){\n\t\t\tthis.first=first;\n\t\t\tthis.second=second;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tFastScanner in=new FastScanner();\n\t\tint n=in.nextInt();\n\t\tint d=in.nextInt();\n\t\tTreeMap<Long,Long> map=new TreeMap<Long,Long>();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tPair p=new Pair(in.nextLong(),in.nextLong());\n\t\t\tmap.put(p.first,map.containsKey(p.first)?map.get(p.first)+p.second:p.second);\n\t\t}\n\t\tn=map.size();\n\t\tPair[] arr=new Pair[n];\n\t\tint p=0;\n\t\tfor(long k:map.keySet()){\n\t\t\tarr[p++]=new Pair(k,map.get(k));\n\t\t}\n\t\tlong[] sum=new long[n];\n\t\tsum[0]=arr[0].second;\n\t\tfor(int i=1;i<n;i++)\n\t\t\tsum[i]=sum[i-1]+arr[i].second;\n\t\t\n\t\tHashMap<Long,Integer> idx=new HashMap<Long,Integer>();\n\t\tp=0;\n\t\tfor(long k:map.keySet()){\n\t\t\tidx.put(k,p++);\n\t\t}\n\t\t\n\t\tlong ans=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tLong rkey=map.lowerKey(arr[i].first+d);\n\t\t\tint right=0;\n\t\t\tif(rkey==null)\n\t\t\t\tright=i;\n\t\t\telse\n\t\t\t\tright=idx.get(rkey);\n\t\t\t\n\t\t\tif(i==0)\n\t\t\t\tans=Math.max(ans,sum[right]);\n\t\t\telse\n\t\t\t\tans=Math.max(ans,sum[right]-sum[i-1]);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic class FastScanner{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastScanner(){br=new BufferedReader(new InputStreamReader(System.in));}\n\t\tString nextToken(){\n\t\t\twhile(st==null||!st.hasMoreElements())\n\t\t\t\ttry{st=new StringTokenizer(br.readLine());}catch(Exception e){}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt(){return Integer.parseInt(nextToken());}\n\t\tlong nextLong(){return Long.parseLong(nextToken());}\n\t\tdouble nextDouble(){return Double.parseDouble(nextToken());}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e5 + 100;\nlong long sum;\nlong long sumLeft[MAX];\npair<int, int> arr[MAX];\nint main() {\n  int n, d;\n  scanf(\"%d %d\", &n, &d);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d %d\", &arr[i].first, &arr[i].second);\n  }\n  arr[n + 1].first = INT_MAX;\n  sort(arr, arr + n + 1);\n  for (int i = 1; i <= n; i++) sumLeft[i] = sumLeft[i - 1] + arr[i].second;\n  sum = sumLeft[n];\n  long long ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int index =\n        distance(arr, upper_bound(arr, arr + n + 1,\n                                  make_pair(arr[i].first + d - 1, INT_MAX)));\n    ans = max(ans, sumLeft[index - 1] - sumLeft[i - 1]);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "entrada = list(map(int, input().split()))\nfriends = []\nfor i in range(entrada[0]):\n    friend = list(map(int, input().split()))\n    friends.append(friend)\nfriends.sort()\ncombinations = []\npivot1 = 0\npivot2 = 0\ntotalSoma = 0\n\nwhile(pivot1!=entrada[0]):\n    if (pivot2<entrada[0] and friends[pivot2][0]-friends[pivot1][0]<entrada[1]):\n        totalSoma += friends[pivot2][1]\n        pivot2+=1\n    else:\n        combinations.append(totalSoma)\n        totalSoma -= friends[pivot1][1]\n        pivot1+=1\ncombinations.append(totalSoma)\ncombinations.sort()\nprint (combinations[-1])\n"
        },
        {
            "language": 4,
            "solution": "//package codeforces;\n\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class A implements Closeable {\n    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n    A() throws IOException {\n//        reader = new BufferedReader(new FileReader(\"input.txt\"));\n//        writer = new PrintWriter(new FileWriter(\"output.txt\"));\n    }\n\n    StringTokenizer stringTokenizer;\n\n    String next() throws IOException {\n        while (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n            stringTokenizer = new StringTokenizer(reader.readLine());\n        }\n        return stringTokenizer.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    private int MOD = 1000 * 1000 * 1000 + 7;\n\n    int sum(int a, int b) {\n        a += b;\n        return a >= MOD ? a - MOD : a;\n    }\n\n    int product(int a, int b) {\n        return (int) (1l * a * b % MOD);\n    }\n\n    int pow(int x, int k) {\n        int result = 1;\n        while (k > 0) {\n            if (k % 2 == 1) {\n                result = product(result, x);\n            }\n            x = product(x, x);\n            k /= 2;\n        }\n        return result;\n    }\n\n    int inv(int x) {\n        return pow(x, MOD - 2);\n    }\n\n    void solve() throws IOException {\n        class Friend {\n            int money, friendshipLevel;\n\n            public Friend(int money, int friendshipLevel) {\n                this.money = money;\n                this.friendshipLevel = friendshipLevel;\n            }\n        }\n        int n = nextInt(), d = nextInt();\n        Friend[] friends = new Friend[n];\n        for(int i = 0; i < n; i++) {\n            friends[i] = new Friend(nextInt(), nextInt());\n        }\n        Arrays.sort(friends, new Comparator<Friend>() {\n            @Override\n            public int compare(Friend o1, Friend o2) {\n                return Integer.compare(o1.money, o2.money);\n            }\n        });\n        int j = 0;\n        long f = 0;\n        long answer = 0;\n        for(int i = 0; i < n; i++) {\n            while(j < n && friends[j].money - friends[i].money < d) {\n                f += friends[j++].friendshipLevel;\n            }\n            answer = Math.max(answer, f);\n            f -= friends[i].friendshipLevel;\n        }\n        writer.println(answer);\n    }\n\n    public static void main(String[] args) throws IOException {\n        try (A a = new A()) {\n            a.solve();\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        reader.close();\n        writer.close();\n    }\n}"
        },
        {
            "language": 3,
            "solution": "entrada = list(map(int, input().split(' ')))\nlista = []\nfriendship = 0\np = 1\n\nfor i in range(entrada[0]):\n  temp = list(map(int, input().split()))\n  lista.append((temp[0],temp[1]))\nlista.sort()\nlista2 = [0]\nfor i in range(1, entrada[0]+1):\n  lista2.append(lista2[i-1] + lista[i-1][1])\n\nfor i in range(entrada[0]):\n  while ((p < entrada[0]) and (lista[i][0] + entrada[1] > lista[p][0])):\n    p +=1\n  friendship = max(friendship, lista2[p] - lista2[i]);\n\t\n\nprint(friendship)\n\t\t \t  \t \t \t\t \t \t  \t\t \t\t\t\t\t\t\t \t\t"
        },
        {
            "language": 1,
            "solution": "\nnumFriends, minDiff = map(int, raw_input().split(\" \"))\n\narr = []\n\nfor _ in xrange(numFriends):\n    money, factor = map(int, raw_input().split(\" \"))\n    arr.append((money, factor))\n\narr.sort(key=lambda a: a[0])\n\nres = 0\n\nu,v,a,c = 0,0,0,0\n\nwhile c < numFriends:\n    if arr[c][0] - arr[a][0] < minDiff:\n        u += arr[c][1]\n        c += 1\n    else:\n        u -= arr[a][1]\n        a += 1\n    res = max(res, u)\nprint res\n\n\"\"\"\nfor i in xrange(0, numFriends):\n    summe = arr[i][1]\n    for j in xrange(i + 1, numFriends):\n        if abs(arr[i][0] - arr[j][0]) >= minDiff:\n            break\n        else:\n            summe += arr[j][1]\n    res = max(res, summe)\n\nprint res\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\"\"\"\nn,d=map(int,raw_input().split())\nbl={}\nfor i in range(n):\n    m,s=map(int,raw_input().split())\n    if bl.has_key(m):\n        bl[m]+=s\n    else:\n        bl[m]=s\nls=[]\nfor i in bl:\n    ls.append((i,bl[i]))\nls.sort()\nans=tmp=b=0\nlst=len(ls)\nfor i in range(lst):\n    tmp+=ls[i][1]\n    if ls[i][0]-ls[b][0]>=d:\n        while 1:\n            tmp-=ls[b][1]\n            b+=1\n            if ls[i][0]-ls[b][0]<d:\n                break\n    ans=max(ans,tmp)\nprint ans\n\"\"\"\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n    void solve() throws IOException {\n        in = new InputReader(\"__std\");\n        out = new OutputWriter(\"__std\");\n\n        int n = in.readInt();\n        int d = in.readInt();\n        int[] m = new int[n];\n        int[] s = new int[n];\n        Integer[] id = new Integer[n];\n        for (int i = 0; i < n; ++i) {\n            m[i] = in.readInt();\n            s[i] = in.readInt();\n            id[i] = i;\n        }\n        Arrays.sort(id, (i, j) -> m[i] - m[j]);\n        long best = 0;\n        long sum = 0;\n        int l = 0;\n        for (int r = 0; r < n; ++r) {\n            while (m[id[r]] - m[id[l]] >= d) {\n                sum -= s[id[l++]];\n            }\n            sum += s[id[r]];\n            if (sum > best) {\n                best = sum;\n            }\n        }\n        out.println(best);\n\n        exit();\n    }\n\n    void exit() {\n        //System.err.println((System.currentTimeMillis() - startTime) + \" ms\");\n        out.close();\n        System.exit(0);\n    }\n\n    InputReader in;\n    OutputWriter out;\n\n    //long startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) throws IOException {\n        new B().solve();\n    }\n\n    class InputReader {\n\n        private InputStream stream;\n\n        private byte[] buffer = new byte[1024];\n        private int pos, len;\n\n        private int cur;\n\n        private StringBuilder sb = new StringBuilder(32);\n\n        InputReader(String name) throws IOException {\n            if (name.equals(\"__std\")) {\n                stream = System.in;\n            } else {\n                stream = new FileInputStream(name);\n            }\n            cur = read();\n        }\n\n        private int read() throws IOException {\n            if (len == -1) {\n                throw new EOFException();\n            }\n            if (pos >= len) {\n                pos = 0;\n                len = stream.read(buffer);\n                if (len == -1) return -1;\n            }\n            return buffer[pos++];\n        }\n\n        private boolean whitespace() {\n            return cur == ' ' || cur == '\\t' || cur == '\\r' || cur == '\\n' || cur == -1;\n        }\n\n        char readChar() throws IOException {\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            char res = (char) cur;\n            cur = read();\n            return res;\n        }\n\n        int readInt() throws IOException {\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            while (whitespace()) {\n                cur = read();\n            }\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            int sign = 1;\n            if (cur == '-') {\n                sign = -1;\n                cur = read();\n            }\n            int res = 0;\n            while (!whitespace()) {\n                if (cur < '0' || cur > '9') {\n                    throw new NumberFormatException();\n                }\n                res *= 10;\n                res += cur - '0';\n                cur = read();\n            }\n            return res * sign;\n        }\n\n        long readLong() throws IOException {\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            return Long.parseLong(readToken());\n        }\n\n        double readDouble() throws IOException {\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            return Double.parseDouble(readToken());\n        }\n\n        String readLine() throws IOException {\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            sb.setLength(0);\n            while (cur != -1 && cur != '\\r' && cur != '\\n') {\n                sb.append((char) cur);\n                cur = read();\n            }\n            if (cur == '\\r') {\n                cur = read();\n            }\n            if (cur == '\\n') {\n                cur = read();\n            }\n            return sb.toString();\n        }\n\n        String readToken() throws IOException {\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            while (whitespace()) {\n                cur = read();\n            }\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            sb.setLength(0);\n            while (!whitespace()) {\n                sb.append((char) cur);\n                cur = read();\n            }\n            return sb.toString();\n        }\n\n        boolean eof() {\n            return cur == -1;\n        }\n    }\n\n    class OutputWriter {\n\n        private PrintWriter writer;\n\n        OutputWriter(String name) throws IOException {\n            if (name.equals(\"__std\")) {\n                writer = new PrintWriter(System.out);\n            } else {\n                writer = new PrintWriter(name);\n            }\n        }\n\n        void print(String format, Object ... args) {\n            writer.print(new Formatter(Locale.US).format(format, args));\n        }\n\n        void println(String format, Object ... args) {\n            writer.println(new Formatter(Locale.US).format(format, args));\n        }\n\n        void print(Object value) {\n            writer.print(value);\n        }\n\n        void println(Object value) {\n            writer.println(value);\n        }\n\n        void println() {\n            writer.println();\n        }\n\n        void close() {\n            writer.close();\n        }\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "kefas = map(int, raw_input().split())\nnum_friends = kefas[0]\ndif = kefas[1]\n\nlist_of_friends = []\nfor i in range(num_friends):\n    list_of_friends.append(map(int, raw_input().split()))\n\nlist_of_friends = sorted(list_of_friends, key=lambda x: x[0])\n\nfriendship = list_of_friends[0][1]\ni = 0\nj = 1\nsoma = 0\nwhile (j != num_friends):\n    if abs(list_of_friends[i][0] - list_of_friends[j][0]) < dif:\n        if soma == 0:\n            index = i\n            soma += list_of_friends[i][1] + list_of_friends[j][1]\n            if soma > friendship:\n                friendship = soma\n        else:\n            if abs(list_of_friends[index][0] - list_of_friends[j][0]) < dif:\n                soma += list_of_friends[j][1]               \n                if soma > friendship:\n                    friendship = soma\n                    \n            else:\n                for x in range(index + 1, j):\n                    if abs(list_of_friends[x][0] - list_of_friends[j][0]) < dif:\n                        soma -= list_of_friends[index][1]\n                        index = x\n                        soma += list_of_friends[j][1]\n                        if soma > friendship:\n                            friendship = soma\n                        break\n                    else:\n                        soma -= list_of_friends[x][1]\n                        \n                if abs(list_of_friends[x][0] - list_of_friends[j][0]) >= dif:                       \n                    soma = 0\n                    if list_of_friends[i][1] > friendship:\n                        friendship = list_of_friends[i][1]\n\n    else:\n        soma = 0\n        if list_of_friends[j][1] > friendship:\n            friendship = list_of_friends[j][1]\n\n    i += 1\n    j += 1\n\nprint friendship"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class FriendsParty {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int d = scanner.nextInt();\n\n        Integer[][] friend = new Integer[n][2];\n\n        for (int i = 0; i < n; i++) {\n            friend[i][0] = scanner.nextInt();\n            friend[i][1] = scanner.nextInt();\n        }\n\n        Arrays.sort(friend, Comparator.comparingInt(o -> o[0]));\n\n        long max = friend[0][1];\n        long currMax = friend[0][1];\n        int last = 0;\n        for (int i = 1; i < n; i++) {\n            if(friend[i][0] - friend[last][0] < d) {\n                currMax += friend[i][1];\n            } else {\n                currMax -= friend[last][1];\n                last++;\n                i--;\n            }\n\n            if(currMax > max) max = currMax;\n        }\n\n        System.out.println(max);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 100;\nint main() {\n  cin.tie(0);\n  cout.tie(0);\n  ios::sync_with_stdio(false);\n  int n, d;\n  long long sum[maxn];\n  pair<int, int> a[maxn];\n  while (cin >> n >> d) {\n    for (int i = 1; i <= n; ++i) {\n      cin >> a[i].first >> a[i].second;\n    }\n    sort(a + 1, a + 1 + n);\n    for (int i = 1; i <= n; ++i) {\n      sum[i] = sum[i - 1] + a[i].second;\n    }\n    int j = 1;\n    long long res = 0;\n    for (int i = 0; i <= n; ++i) {\n      while (a[i].first - a[j].first >= d) {\n        ++j;\n      }\n      res = max(res, sum[i] - sum[j - 1]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\nimport javafx.util.Pair;\n\npublic class Solve3 {\n\n    public static void main(String[] args) throws IOException {\n        PrintWriter pw = new PrintWriter(System.out);\n        new Solve3().solve(pw);\n        pw.flush();\n        pw.close();\n    }\n\n    public void solve(PrintWriter pw) throws IOException {\n        FastReader sc = new FastReader();\n        int n = sc.nextInt(), d = sc.nextInt();\n        Pair<Integer, Integer>[] a = new Pair[n];\n        long[] prefix = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            a[i] = new Pair(sc.nextInt(), sc.nextInt());\n        }\n        Comparator<Pair<Integer, Integer>> cmp = new Comparator<Pair<Integer, Integer>>() {\n            @Override\n            public int compare(Pair<Integer, Integer> p1, Pair<Integer, Integer> p2) {\n                return p1.getKey() - p2.getKey();\n            }\n        };\n        Arrays.sort(a, cmp);\n        for (int i = 0; i < n; i++) {\n            prefix[i + 1] = a[i].getValue() + prefix[i];\n        }\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            int x = a[i].getKey() + d;\n            int r = lowerBound(a, i, n - 1, x);\n            ans = Math.max(ans, prefix[r] - prefix[i]);\n        }\n        pw.println(ans);\n    }\n\n    public int lowerBound(Pair<Integer, Integer>[] a, int low, int high, int key) {\n        if (low > high) {\n            return low;\n        }\n        int mid = (low + high) >> 1;\n        if (a[mid].getKey() >= key) {\n            return lowerBound(a, low, mid - 1, key);\n        } else {\n            return lowerBound(a, mid + 1, high, key);\n        }\n    }\n\n    static public class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937_64 rang(\n    chrono::high_resolution_clock::now().time_since_epoch().count());\nint rng(int lim) {\n  uniform_int_distribution<int> uid(0, lim - 1);\n  return uid(rang);\n}\nconst int INF = 0x3f3f3f3f;\nconst int mod = 1e9 + 7;\nvoid solve() {\n  long long n, d;\n  cin >> n >> d;\n  vector<pair<long long, long long> > v(n);\n  for (long long i = 0; i < n; i++) {\n    cin >> v[i].first >> v[i].second;\n  }\n  sort(v.begin(), v.end());\n  vector<long long> cs(n, 0);\n  for (long long i = 0; i < n; i++) {\n    cs[i] = v[i].second;\n    if (i) cs[i] += cs[i - 1];\n  }\n  long long res = 0;\n  for (long long i = 0; i < n; i++) {\n    pair<long long, long long> p = {v[i].first + d, -1};\n    long long idx = lower_bound(v.begin(), v.end(), p) - v.begin() - 1;\n    long long curr_res = cs[idx];\n    if (i) curr_res -= cs[i - 1];\n    res = max(res, curr_res);\n  }\n  cout << res;\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n  srand(chrono::high_resolution_clock::now().time_since_epoch().count());\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k;\n  scanf(\"%d %d\", &n, &k);\n  vector<pair<int, int> > A;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    A.push_back(make_pair(x, y));\n  }\n  sort(A.begin(), A.end());\n  long long ans = 0;\n  long long co = 0;\n  long long pre;\n  vector<pair<int, int> >::iterator it = A.begin();\n  vector<pair<int, int> >::iterator fir = A.begin();\n  co = (*it).second;\n  pre = (*it).first;\n  ans = (*it).second;\n  it++;\n  for (; it != A.end(); it++) {\n    while ((*it).first - ((*fir).first) >= k) {\n      co = co - (*fir).second;\n      fir++;\n    }\n    co += (*it).second;\n    ans = max(ans, co);\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic int MOD = 1000 * 1000 * 1000 + 7;\n\n\tpublic static void shuffleArray(int[] arr) {\n\t\tint n = arr.length;\n\t\tRandom rnd = new Random();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(n - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tsolve(in, out);\n\t\tout.close();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic class Pair implements Comparable<Pair> {\n\t\tlong x;\n\t\tlong y;\n\n\t\tPair(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn -Long.compare(x, o.x);\n\t\t}\n\t}\n\n\tprivate static void solve(InputReader in, PrintWriter out) {\n\t\tint n = in.nextInt();\n\t\tlong d = in.nextLong();\n\t\tPair[] tab = new Pair[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttab[i] = new Pair(in.nextLong(), in.nextLong());\n\t\t}\n\t\tArrays.sort(tab);\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\ttab[i].y += tab[i - 1].y;\n\t\t}\n\n\t\tlong res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong minMoney = tab[i].x - d;\n\t\t\tint idx = binarySearch(minMoney, i, n - 1, tab);\n\t\t\tlong best = tab[idx].y;\n\t\t\tif (i > 0) {\n\t\t\t\tbest -= tab[i - 1].y;\n\t\t\t}\n\t\t\tres = Math.max(res, best);\n\n\t\t}\n\t\tout.print(res);\n\n\t}\n\n\tprivate static int binarySearch(long val, int lo, int hi, Pair[] tab) {\n\t\tif (lo == hi) {\n\t\t\treturn lo;\n\t\t}\n\n\t\tint mid = lo + (hi - lo + 1) / 2;\n\t\tif (val >= tab[mid].x) {\n\t\t\thi = mid - 1;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\n\t\treturn binarySearch(val, lo, hi, tab);\n\t}\n\n\t/*\n\t\t* \n\t\t*/\n\t// --------------------------------------------------------\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\treturn str;\n\t\t}\n\t}\n\n}"
        },
        {
            "language": 3,
            "solution": "n,d = map(int,input().split())\nx = []\nfor i in range(n):\n\ta,b = map(int,input().split())\n\tx.append((a,b))\nx.sort()\ny = []\ns = x[0][1]\ni,j = 0,1\nwhile i<n and j<n:\n\tif j<n and x[j][0] - x[i][0] < d:\n\t\ts += x[j][1]\n\t\tj+=1\n\telse:\n\t\ty.append(s)\n\t\ts -= x[i][1]\n\t\ti+=1\ny.append(s)\nprint(max(y))"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nv = sorted([list(map(int, input().split())) for i in range(n)], key = lambda x: x[0])\n\nb = 0; s = sol = v[0][1]\nfor i in range(1, n):\n  while v[i][0] >= d + v[b][0]:\n    s -= v[b][1]\n    b += 1\n  s += v[i][1]\n  sol = max(sol, s)\n\nprint(sol)\n"
        },
        {
            "language": 3,
            "solution": "def getKey(item):\n    return item[0]\n\nn,d = map(int, input().split())\nli = []\nfor _ in range(n):\n    l = [int(x) for x in input().split()]\n    li.append(l)\nli = sorted(li, key=getKey)\n\nmx = -1\nsum = [0]*n\nsum[0] = li[0][1]\n\nfor i in range(1, n):\n    sum[i] = sum[i-1]+li[i][1]\n\nend = 0\nfor i in range(0, n):\n    tmp = end\n    for j in range(tmp, n):\n        if li[j][0] - li[i][0] < d:\n            end = j\n        else:\n            break\n    cnt = li[i][1]\n    if end > i and i == 0:\n        cnt = sum[end]\n    elif end > i:\n        cnt = sum[end] - sum[i-1]\n    if cnt > mx:\n        mx = cnt\n\nprint(mx)\n"
        },
        {
            "language": 3,
            "solution": "user_input=input()\nfirst_line=user_input.split(' ')\nn=int(first_line[0])\nd=int(first_line[1])\n\nlong_list=[]\n\nfor i in range(n):\n    extended_list=[]\n    user_input = input()\n    line = user_input.split(' ')\n    extended_list.extend([int(line[0]),int(line[1])])\n    long_list.append(extended_list)\n\nlong_list.sort()\n\nindex=0\nmaximum=0\nfor i in range(len(long_list)):\n    if maximum<long_list[i][1]:\n        maximum=long_list[i][1]\nanswer=maximum\nmaximum=0\ni=0\ncount=0\nlooped=\"false\"\n\nwhile i in range(len(long_list)):\n    if long_list[i][0]-long_list[index][0]>d:\n        if count>0 and looped==\"false\":\n            i-=count\n            count=0\n            index=i\n            looped=\"true\"\n        else:\n            index=i\n        maximum=0\n    if long_list[i][0]-long_list[index][0]<d:\n        count+=1\n        if maximum==0:\n            maximum=long_list[index][1]\n        else:\n            maximum+=long_list[i][1]\n\n    answer=max(answer,maximum)\n    i+=1\n\nprint(answer)\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint const N = 1e5 + 5;\nusing namespace std;\nlong long n, d, ans;\npair<long long, long long> p[N];\nint main() {\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) cin >> p[i].first >> p[i].second;\n  sort(p, p + n);\n  for (int i = 1; i < n; i++) p[i].second += p[i - 1].second;\n  for (int i = 0; i < n; i++) {\n    long long low = i, high = n - 1, mid, dif;\n    if (!i)\n      dif = 0;\n    else\n      dif = p[i - 1].second;\n    while (low <= high) {\n      mid = (low + high) / 2;\n      if (p[mid].first - p[i].first < d)\n        low = mid + 1, ans = max(ans, p[mid].second - dif);\n      else\n        high = mid - 1;\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package com.codeforces.junior.B;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.util.StringTokenizer;\n\npublic class B {\n\n  static class FastScanner {\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st = new StringTokenizer(\"\");\n\n    String next() {\n      while (!st.hasMoreTokens()) {\n        try {\n          st = new StringTokenizer(br.readLine());\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    int[] readArray(int n) {\n      int[] a = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = nextInt();\n      }\n      return a;\n    }\n\n    Integer[] readArrayInt(int n) {\n      Integer[] a = new Integer[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = nextInt();\n      }\n      return a;\n    }\n\n    long nextLong() {\n      return Long.parseLong(next());\n    }\n  }\n\n  static class Pair {\n\n    int first;\n    int second;\n\n    public Pair(int first, int second) {\n      this.first = first;\n      this.second = second;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n      Pair pair = (Pair) o;\n      return first == pair.first && second == pair.second;\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(first, second);\n    }\n  }\n\n  static class Equation {\n\n    //ax+by=c;\n    int a, b, c;\n\n    public Equation(int x1, int y1, int x2, int y2) {\n      int a = y2 - y1;\n      int b = x1 - x2;\n      int c = a * x1 + b * y1;\n    }\n\n    public Equation(int a, int b, int c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    public boolean isPointOnLine(int x, int y) {\n      return a * x + b * y == c;\n    }\n  }\n\n  private static void buildGraph(HashMap<Integer, Set<Integer>> map, int first, int second) {\n    Set<Integer> set = map.getOrDefault(first, new HashSet<>());\n    set.add(second);\n    map.put(first, set);\n    set = map.getOrDefault(second, new HashSet<>());\n    set.add(first);\n  }\n\n  public static void main(String args[]) {\n    try (PrintWriter out = new PrintWriter(System.out)) {\n      FastScanner scanner = new FastScanner();\n      int n = scanner.nextInt();\n      int d = scanner.nextInt();\n      List<Pair> list = new ArrayList<>();\n      while (n-- > 0) {\n        list.add(new Pair(scanner.nextInt(), scanner.nextInt()));\n      }\n      list.sort(Comparator.comparingInt(o -> o.first));\n\n      long[] pre = new long[list.size()];\n      pre[0] = list.get(0).second;\n      for (int i = 1; i < list.size(); i++) {\n        pre[i] = pre[i - 1] + list.get(i).second;\n      }\n      Long max = Long.MIN_VALUE;\n      for (int i = 0; i < list.size(); i++) {\n        int idx = getIdx(list, i, list.get(i).first + d);\n        if (idx != -1) {\n          max = Math.max(max, getSum(pre, i, idx));\n        }\n      }\n      out.println(max);\n    }\n  }\n\n  static int getIdx(List<Pair> list, int start, int num) {\n    int low = start, high = list.size() - 1;\n    int ret = -1;\n    while (low <= high) {\n      int mid = low + (high - low) / 2;\n      if (list.get(mid).first < num) {\n        ret = mid;\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    return ret;\n  }\n\n  static long getSum(long[] pre, int start, int end) {\n    if (start > 0) {\n      return pre[end] - pre[start - 1];\n    }\n    return pre[end];\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\na=[]\nfor i in range(n):\n\ta.append(list(map(int,input().split())))\na.sort()\np1=p2=0;ma=0;su=0\nwhile p2<n:\n\tif a[p2][0]-a[p1][0]<d:\n\t\tsu+=a[p2][1];p2+=1;ma=max(ma,su)\n\telse:\n\t\tsu-=a[p1][1];p1+=1\nprint(ma)"
        },
        {
            "language": 3,
            "solution": "\"\"\"\nCodeforces Round #321 (Div. 2)\n\nProblem 580 B. Kefa and Company\n\n@author yamaton\n@date 2015-09-22\n\"\"\"\n\nimport itertools as it\nimport functools\nimport operator\nimport collections\nimport math\nimport sys\n\nimport bisect\n\ndef solve(xs, d):\n    xs.sort()\n    ms, fs = list(zip(*xs))\n    n = len(ms)\n\n    fsacc = list(it.accumulate(it.chain((0,), fs)))\n\n    out = []\n    for i, money in enumerate(ms):\n        k = bisect.bisect_right(ms, money + d - 1)\n        # print_stderr('----------')\n        # print_stderr('i =', i)\n        # print_stderr('k =', k)\n        # print_stderr('d =', d)\n        # print_stderr('ms=', ms)\n        # print_stderr('ms[i] =', ms[i])\n        # print_stderr('ms[k-1] =', ms[k-1])\n        # print_stderr('fs[i] =', fs[i])\n        # print_stderr('fs[k-1] =', fs[k-1])\n\n        # out.append(sum(fs[i:k]))\n        out.append(fsacc[k] - fsacc[i])\n        if k == n:\n            break\n\n    return max(out)\n\n\ndef print_stderr(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\ndef main():\n    # Assume the friendship factors are all positive\n    [n, d] = [int(i) for i in input().strip().split()]\n    money_friend_pairs = [tuple(int(i) for i in input().strip().split()) for _ in range(n)]\n    result = solve(money_friend_pairs, d)\n    print(result)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nl=sorted(list(map(int,input().split())) for _ in range(n))\nj=0\nfl=0\nm=0\nfor i in range(n):\n\tfl+=l[i][1]\n\twhile (l[i][0]-l[j][0])>=d:\n\t\tfl-=l[j][1]\n\t\tj+=1\n\tm=max(m,fl)\nprint(m)\n     \t\t\t \t \t \t \t\t\t   \t\t \t\t\t \t\t"
        },
        {
            "language": 3,
            "solution": "'''\nCreated on 3Oct.,2017\n\n@author: thorsten\n'''\nuser = input().split(\" \")\nnumberFriends = int(user[0])\ndiffToFeelPoor = int(user[1])\narr = []\nmaxFac = -1\nfor _ in range(numberFriends):\n    userIn = input().split(\" \")\n    money = int(userIn[0])\n    frFac = int(userIn[1])\n    if frFac>maxFac:\n        maxFac = frFac\n    arr.append((money, frFac))\nif diffToFeelPoor > 0:\n    arr.sort(key=lambda tup: tup[0])\n    currFac = arr[0][1]\n    maxFac = arr[0][1]\n    startIn = 0\n    index = 1\n    while index < len(arr):\n        if arr[index][0]<(arr[startIn][0]+diffToFeelPoor):\n            currFac += arr[index][1]\n            if currFac > maxFac:\n                maxFac = currFac\n        else:\n            currFac += arr[index][1]\n            for index2 in range(startIn, index+1):\n                if arr[index][0]>=(arr[index2][0]+diffToFeelPoor):\n                    currFac -= arr[index2][1]\n                    startIn = index2+1\n                else:\n                    break\n            if currFac > maxFac:\n                maxFac = currFac\n        index += 1\n    if currFac > maxFac:\n        maxFac = currFac\nprint(maxFac)\n                \n        \n    \n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint const N = 1e5 + 5;\nusing namespace std;\nlong long n, d, ans, sum;\npair<long long, long long> p[N];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].first >> p[i].second;\n  }\n  sort(p, p + n);\n  for (int i = 1; i < n; i++) p[i].second += p[i - 1].second;\n  for (int i = 0; i < n; i++) {\n    long long low = i, high = n - 1, mid, dif;\n    if (!i)\n      dif = 0;\n    else\n      dif = p[i - 1].second;\n    while (low <= high) {\n      mid = (low + high) / 2;\n      bool yes = false;\n      if (p[mid].first - p[i].first < d) {\n        low = mid + 1;\n        ans = max(ans, p[mid].second - dif);\n      } else {\n        high = mid - 1;\n      }\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def arr_2d(n):\n    return [[float(x) for x in stdin.readline().split()] for i in range(n)]\n\n\ndef get_col(arr, i):\n    return [row[i] for row in arr]\n\n\ndef arr_sum(arr):\n    arr.appendleft(0)\n    return list(accumulate(arr, lambda x, y: x + y))\n\n\nfrom bisect import *\nfrom sys import stdin\nfrom itertools import accumulate\nfrom collections import deque\n\nn, d = map(int, stdin.readline().split())\na = deque(sorted(arr_2d(n), key=lambda x: x[0]))\ncol, ans, col2 = get_col(a, 0), 0, arr_sum(deque(get_col(a, 1)))\n\nfor i in range(n):\n    ix = bisect_right(col, a[i][0] + d - 1)\n    if ix == n or a[ix][0] > a[i][0] + d - 1:\n        ix -= 1\n    ans = max(ans, col2[ix + 1] - col2[i])\n\nprint(int(ans))\n"
        },
        {
            "language": 3,
            "solution": "def solve(n,d,friends):\n    big = float('inf')\n    small = float('-inf')\n    friends.sort()\n    maxer = small\n\n    # two pointers\n    f = 0\n    s = 0 \n    ind = 0            \n    curr = 0\n    while(ind < n):              \n        miner = friends[s][0]\n        while(s < n and abs(friends[ind][0] - friends[s][0]) >= d):            \n            curr -= friends[s][1]  \n            s += 1               \n            miner = friends[s][0]             \n        flag = True\n        while(ind < n and abs(friends[ind][0] - miner) < d):\n            curr += friends[ind][1]\n            ind += 1\n            flag = False                        \n        maxer = max(maxer,curr)\n    return maxer\n    \ndef main():\n    # t = int(input())    \n    # for i in range(t):\n    # n = int(input())\n    d = input()\n    d = [int(i) for i in d.split()]\n    a = d[0]\n    b = d[1]\n    friends = []\n    for i in range(a):\n        d = input()\n        d = [int(i) for i in d.split()]\n        m = d[0]\n        f = d[1]\n        friends.append((m,f))   \n    # c = d[2]\n    # e = d[4]        \n    # e = input()\n    # e = [int(i) for i in e.split()]  \n    ans = solve(a,b,friends)\n    print(ans)     \n    # for i in ans:\n    #     print(i,end = \"\")\n    # print()  \nmain()\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic private class Friend\n\t{\n\t\tint m;\n\t\tint c;\n\t\tFriend(int x,int y){m=x;c=y;}\n\t}\n\tpublic static void main(String[] args) {\n\t\tint n,d;\n\t\tScanner input=new Scanner(System.in);\n\t\twhile(input.hasNext())\n\t\t{\n\t\t\tn=input.nextInt();\n\t\t\td=input.nextInt();\n\t\t\tlong[] c_sum=new long[n];\n\t\t\tFriend[] friends=new Friend[n];\n\t\t\tfor(int i=0;i<n;++i)\n\t\t\t\tfriends[i]=new Friend(input.nextInt(),input.nextInt());\n\t\t\tComparator<Friend> comp=new Comparator<Friend>(){\n\t\t\t\tpublic int compare(Friend a,Friend b)\n\t\t\t\t{\n\t\t\t\t\treturn b.m-a.m;\n\t\t\t\t}\n\t\t\t};\n\t\t\tArrays.sort(friends,comp);\n\t\t\tc_sum[0]=friends[0].c;\n\t\t\tfor(int i=1;i<n;++i)\n\t\t\t\tc_sum[i]=c_sum[i-1]+friends[i].c;\n\t\t\tlong ans=friends[0].c;\n\t\t\tfor(int i=0,j=1;j<n;++j)\n\t\t\t\t{\n\t\t\t\t\twhile(friends[i].m-friends[j].m>=d)++i;\n\t\t\t\t\tans=Math.max(ans,c_sum[j]-c_sum[i]+friends[i].c);\n\t\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\tinput.close();\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n/**\n * Created by tawsif on 9/22/15.\n *\n * @Time 11:31 PM\n */\npublic class CF580B {\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tPrintWriter out;\n\tlong timeBegin, timeEnd;\n\n\tpublic void runIO() throws IOException {\n\t\ttimeBegin = System.currentTimeMillis();\n\n\t\tInputStream inputStream;\n\t\tOutputStream outputStream;\n\n\n\t\tif (ONLINE_JUDGE) {\n\t\t\tinputStream = System.in;\n\t\t\tReader.init(inputStream);\n\t\t\toutputStream = System.out;\n\n\t\t\tout = new PrintWriter(outputStream);\n\n\t\t} else {\n\t\t\tinputStream = new FileInputStream(\"/home/peacefrog/Dropbox/IdeaProjects/Problem Solving/input\");\n\t\t\tReader.init(inputStream);\n\t\t\tout = new PrintWriter(System.out);\n\t\t}\n\n\t\tsolve();\n\n\t\tout.flush();\n\t\tout.close();\n\t\ttimeEnd = System.currentTimeMillis();\n\n\t\tSystem.err.println(\"Time = \" + (timeEnd - timeBegin));\n\n\t}\n\n\tprivate void solve() throws IOException {\n\t\tint n = Reader.nextInt(), d = Reader.nextInt();\n\n\t\tA[] friend = new A[n+1];\n\t\tfriend[0] = new A(0 , 0);\n\n\t\tfor(int i = 1 ; i <= n ; i++)\n\t\t{\n\t\t\tfriend[i]= new A(Reader.nextLong(), Reader.nextLong());\n\t\t}\n\n\t\tif(n == 1 )\n\t\t{\n\t\t\tout.println(friend[1].fraction);\n\t\t\treturn;\n\t\t}\n\n\t\tArrays.sort(friend);\n\n\t\tint a = 1 , b = 1 ;\n\t\tlong max = 0 , cur = 0;\n\t\tlong[] cumSum = new long[n + 1];\n\t\tcumSum[1]= friend[1].fraction;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tcumSum[i] = cumSum[i-1] + friend[i].fraction;\n\t\t}\n\t\tfor (; a <= n ; a++)\n\t\t{\n\t\t\twhile ((friend[a].money-friend[b].money)>= d)\n\t\t\t{\n\t\t\t\tb++;\n\t\t\t}\n\t\t\tcur = (cumSum[a]-cumSum[b-1]);\n\t\t\tmax = Math.max(cur, max);\n\t\t}\n\n\t\tout.println(max);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew CF580B().runIO();\n\t}\n\n\tstatic class Reader {\n\t\tstatic BufferedReader reader;\n\t\tstatic StringTokenizer tokenizer;\n\n\t\t/**\n\t\t * call this method to initialize reader for InputStream\n\t\t */\n\t\tstatic void init(InputStream input) {\n\t\t\treader = new BufferedReader(new InputStreamReader(input));\n\t\t\ttokenizer = new StringTokenizer(\"\");\n\t\t}\n\n\t\t/**\n\t\t * get next word\n\t\t */\n\t\tstatic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tstatic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tstatic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tstatic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tpublic static class A implements Comparable<A>{\n\t\tlong money ;\n\t\tlong fraction ;\n\n\t\tpublic A(long money, long fraction) {\n\t\t\tthis.money = money;\n\t\t\tthis.fraction = fraction;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(A o) {\n\t\t\treturn Long.compare(this.money , o.money);\n\n\t\t}\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "entrada = map(int, raw_input().split())\n\nlista_resposta = []\n\namizade = 0\n\nfator = 1\n\nfor i in xrange (entrada[0]):\n\n  temp = map(int, raw_input().split())\n  lista_resposta.append((temp[0],temp[1]))\n\nlista_resposta.sort()\nlista_copia = [0]\n\nfor i in range (1, entrada[0] + 1):\n  lista_copia.append(lista_copia[i-1] + lista_resposta[i-1][1])\n\nfor i in range(entrada[0]):\n\n  while ((fator < entrada[0]) and (lista_resposta[i][0] + entrada[1] > lista_resposta[fator][0])):\n\n    fator +=1\n\n  amizade = max(amizade, lista_copia[fator] - lista_copia[i]);\n\t\nprint amizade\n\t \t\t     \t\t\t\t\t\t \t\t\t\t\t \t\t \t\t\t  \t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n/*\n#include<boost/multiprecision/cpp_int.hpp>\nnamespace mp=boost::multiprecision;\n*/\nusing namespace std;\n#define ll long long int\n#define lo mp::cpp_int\n#define pb push_back\n#define pob pop_back\n#define mk make_pair\n#define endl \"\\n\"\n#define ce(x) cout << x <<\"\\n\"\n#define fill(s,v) memset(s,v,sizeof(s))\n#define speed  { ios_base::sync_with_stdio(false); cin.tie(0); }\n#define deb(x) cout<<#x<<\" \"<<x<<endl; \n#define INFINITE 1000000009\n#define ull unsigned long long int\n#define take(a,n) for(ll pp=0;pp<n;pp++) { cin>>a[pp]; }\n#define take2(a,n) for(ll p=0;p<n;p++) { ll temp;cin>>temp;a.pb(temp); }\n#define f(i,n) for(ll i=0;i<n;i++)\n#define f1(i,a,n) for(ll i=a;i<n;i++)\n#define show(a,n) for(ll p=0;p<n;p++) cout<<a[p]<<\" \";\n#define _ <<\" \"<<\n#define nl cout<<endl;\n#define sq(x) ((x)*(x))\n#define call(v) v.begin(),v.end()\n#define rall(v) v.rbegin(),v.rend()\n#define ff first\n#define ss second\n#define lld long double\n#define sc(n) scanf(\"%lld\",&n);\n#define de2(x,y) cout<<#x<<\" = \"<<(x) <<' '<< #y<<\" = \"<<y<<endl;typedef pair<int, int> pii;\n#define copy(b,a,n) for(ll i=0;i<n;i++) b[i]=a[i];\n#define clock() clock_out()\n#define tc(tt) \\\n    ll tt;    \\\n    cin >> tt; \\\n    for (int _tt = 0; _tt < tt; _tt++) \ntypedef vector<vector<ll>> matrix ;  \ntypedef pair<ll,ll> pii;\ntypedef vector<pii> vii;\ntypedef vector<ll> vi;   \nconst ll dx[4] = {-1, 0, 1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst ll mod = 1000000007;\nll gcd(ll a,ll b){if(!b)return a;return gcd(b,a%b);} \nll power_mod(ll x,ll y,ll p){ll res=1;x%=p;while(y>0){if(y&1)res=(res*x)%p;y=y>>1;x=(x*x)%p;}return res;} \nll modexpo(ll x,ll n,ll M){if(n==0)return 1;else if(n%2 == 0)return modexpo((x*x)%M,n/2,M);else return(x*modexpo((x*x)%M,(n-1)/2,M))%M;}\nll lcm(ll a, ll b){return (a*b)/gcd(a, b);}\nll sumofdigits(ll n){ll out=0;while(n){out+=(n%10);n/=10;}return out;}\nbool isPrime(ll n){if (n <= 1)  \n    return false; if (n <= 3)  return true; if (n%2 == 0 || n%3 == 0) return false; \n    for (ll i=5; i*i<=n; i=i+6) if (n%i == 0 || n%(i+2) == 0) return false;return true;} \n// ll power(ll a,ll b){if(b==0)return 1;if(b&1)return a*power(a,b-1);ll res=power(a,b/2);return res*res;}\nll bexpo(ll x,ll n){if(n==0)return 1;else if(n%2==0)return bexpo(x*x,n/2);else return x*bexpo(x*x,(n-1)/2);}\nll log(ll d){return log2(d);}\nbool isPower(ll x, ll y){if(x==1) return (y==1); ll pow=1; while(pow<y) pow*=x; return(pow == y);}  \nbool isPerfectSquare(long double x){long double sr = sqrt(x);return ((sr - floor(sr)) == 0);}   \nbool compare(const pair<ll,ll> &a, const pair<ll,ll> &b) { return (a.second < b.second);} \nll isPalindrome(string s){ll l=0;ll h=s.size()-1;while(h>l){if(s[l++]!=s[h--])return 0;}return 1;} \nll setbits(ll n) { if(n==0)return 0; else return 1+setbits(n&(n-1)); } \nll modInverse(ll A,ll M){return modexpo(A,M-2,M);}\nll suma(ll *a,ll n){ll sum=0;for(ll i=0;i<n;i++)sum+=a[i];return sum;}\n// void clock_out(){\n//   cerr<<\"\\nTime Elapsed : \" << 1.0*clock() / CLOCKS_PER_SEC << \" s\\n\";\n// }\n//------modular inverse by extended euclid-------//\n\n// ll d, x, y;\n// void extendedEuclid(ll A, ll B) {\n//  if(B == 0) {\n//  d = A;\n//  x = 1;\n//  y = 0;\n//  }\n//  else {\n//  extendedEuclid(B, A%B);\n//  ll temp = x;\n//  x = y;\n//  y = temp - (A/B)*y;\n//  }\n// }\n\n// ll modInverse2(ll A, ll M){\n// extendedEuclid(A,M);\n// return (x%M+M)%M;\n// }\n\n//---------------------------------//\n\n//---------------matrix exponentiation-------------------//\n\n// matrix mul(matrix a,matrix b){\n//   matrix res(n+1,vector<ll>(n+1));\n//   f(i,n)f(j,n)f(k,n)res[i][j]=(res[i][j]%mod+((a[i][k]%mod)*(b[k][j]%mod))%mod)%mod;\n//    return res;\n// }\n// matrix pow(matrix A,ll p) {\n//     if(p==1) return A;\n//     matrix res=pow(A,p/2) ;\n//     res=mul(res,res);\n//     if(p&1) res=mul(res,A) ;\n//     return res;\n// }\n\n//-------------------------------------------------//\n\nvector<ll> factorize(ll n) {\n    vector<ll> res;\n    for (ll i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            res.push_back(i);\n            n /= i;\n        }\n    }\n    if (n != 1) {\n        res.push_back(n);\n    }\n    return res;\n}\n\nvector<ll> divisors(ll n){ \n    vector<ll> res;\n    for (ll i=1; i<=sqrt(n); i++){ \n        if (n%i == 0){ if (n/i == i){ res.pb(i); } else{ res.pb(n/i); res.pb(i); } } \n    } \n    return res;\n}   \nvector<ll> primeFactors(ll n){  \n    if(n==1) return vector<ll>(1,1);\n    bool idx[1]={false};\n    vector<ll> res;\n    while (n%2 == 0){  \n        if(!idx[1]){idx[1]=true;res.pb(2);}\n        n = n/2;  \n    }  \n    for (ll i=3;i*i<=n; i+=2){\n        bool once=false;\n        while (n%i==0){ if(!once){res.pb(i);once=true;} n=n/i; }  \n    }  \n    if (n > 2)res.pb(n);\n    return res;\n}\n\n//--------------------------------------------//\n\nll dxx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nll dyy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\n//----check if a point is in range-----///\n///__builtin_ctz(x) --> get power of 2 dude !!!! \n\nbool check(ll x,ll y,ll n,ll m){return(x>=0&&x<n&&y>=0&&y<m);}\n\nconst int FULL_MASK = (1 << 10) - 1;\n#define pi 3.1415926535897932\n\nvector<vector<ll>> ed;\n\nvoid bfs(ll s, vector<ll> &d) {\n    d[s] = 0;\n    queue<ll> q;\n    q.push(s);\n    while (!q.empty()) {\n        ll v = q.front();\n        q.pop();\n        for (auto to : ed[v]) {\n            if (d[to] == 1e9) {\n                d[to] = d[v] + 1;\n                q.push(to);\n            }\n        }\n    }\n} \n// void dfs(int u){\n//     vis[u]=1;\n//     // temp.push_back(u);\n//     for(int i=0;i<adj[u].size();i++){\n//         if(!vis[adj[u][i]])\n//             dfs(adj[u][i]);\n//     }\n// }\n\n// void dfs(ll u){\n//     if(vis[u]) return;\n//     deg += g[u].size();\n//     ver++;\n//     vis[u] = 1;\n//     for(auto v: g[u])dfs(v);\n// }\nll maxSubArraySum(ll a[],ll size) \n{ \n    ll max_so_far = a[0]; \n    ll curr_max = a[0]; \n  \n   for (ll i = 1; i < size; i++) \n   { \n        curr_max = max(a[i], curr_max+a[i]); \n        max_so_far = max(max_so_far, curr_max); \n   } \n   return max_so_far; \n} \n\nstruct node{\n    ll a,b,c,d;\n};\n\nint n,m,fg,k=1;\nchar c;\nchar mmp[70][70];\nint mp[70][70];\n \nvoid dfs(int x,int y,int ex,int ey)\n{   \n    //cout<<k++<<endl;\n    if(fg){\n        return;\n    }\n    for(int i=0;i<4;i++)\n    {\n        int xx=x+dx[i];\n        int yy=y+dy[i];\n        if(xx>=0&&xx<n&&yy>=0&&m>yy&&mmp[xx][yy]==c)\n        {\n            if(xx==ex&&yy==ey) continue;\n            else if(mp[xx][yy]||fg){\n                fg=1;\n                return;\n            }\n            else if(!mp[xx][yy])\n            {\n                mp[xx][yy]=1;\n             dfs(xx,yy,x,y);\n            }   \n        }\n    }\n    return;\n}\n\nvoid solve(){\n    ll n, m; cin >> n >> m;\n    pair < ll, ll > arr[n];\n    for(ll i = 0; i < n; i ++) cin >> arr[i].ff >> arr[i].ss;\n    sort(arr, arr + n);\n    ll mx = 0, s = 0;\n    ll r = 0;\n    for(ll l = 0; l < n; l ++){\n        while(r < n && arr[l].ff + m > arr[r].ff){\n            s += arr[r].ss; r ++;\n        }\n        mx = max(mx , s);\n        s -= arr[l].ss;\n    }\n    cout << mx << endl;\n}\n\nint main(){\n    // tc(tt){\n        solve();\n    // }\n}\n\n/*\n\n\n*/"
        },
        {
            "language": 3,
            "solution": "n, diff = map(int, input().split(\" \"))\n\nm_f = []\nfor i in range(n):\n    m_f.append(tuple(map(int, input().split(\" \"))))\n\nm_f.sort(key=lambda x: x[0])\n\nstart = 0\nend = 1\nmax_f = m_f[0]\ncost = m_f[start][1]\n\ntotal = m_f[start][1]\nwhile len(m_f) > end >= start:\n\n    if m_f[end][0] - m_f[start][0] >= diff:\n\n        total = max(total, cost)\n        cost -= m_f[start][1]\n        start += 1\n    else:\n        cost += m_f[end][1]\n        end += 1\ntotal = max(total, cost)\nprint(total)"
        },
        {
            "language": 3,
            "solution": "n, m = tuple( int( x ) for x in input().split() )\nv = [ ]\nfor i in range( n ):\n    i = input()\n    v.append( tuple( int( x ) for x in i.split() ) )\nv.sort(  reverse = True )\n\nmaxi = val = v[ 0 ][ 1 ]\ni = j = 0\nfor j in range( 1, len( v ) ):\n    val += v[ j ][ 1 ]\n    while abs( v[ j ][ 0 ] - v[ i ][ 0 ] ) >= m:\n        val -= v[ i ][ 1 ]\n        i += 1\n    if val > maxi:\n        maxi = val\nprint( maxi )\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nal = [list(map(int, input().split())) for _ in range(n)]\nal.sort()\nres = al[0][1]\nt = al[0][1]\nidx = 0\nfor i in range(1, n):\n    if al[i][0] - al[idx][0] < d:\n        t += al[i][1]\n    else:\n        while al[i][0] - al[idx][0] >= d:\n              t -= al[idx][1]\n              idx += 1\n        t += al[i][1]\n    res = max(res, t);\nprint(res)\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\naux = []\n\nfor i in range(n):\n\tm, f = map(int, raw_input().split())\n\taux.append((m, f))\n\naux.sort()\n\ni = j = 0\nfs = 0\nmaxfs = 0\n\nwhile i < len(aux):\n\twhile j < len(aux) and aux[j][0] - aux[i][0] < d:\n\t\tfs += aux[j][1]\n\t\tj += 1\n\t\n\tmaxfs = max(maxfs, fs)\n\tfs -= aux[i][1]\n\ti+= 1\n\nprint maxfs\n"
        },
        {
            "language": 3,
            "solution": "first_line = input().split()\nn = int(first_line[0])\nd = int(first_line[1])\nfriends = [[0, 0] for i in range(n)]\nfor i in range(n):\n    a_friend = input().split()\n    friends[i][0] = int(a_friend[0])\n    friends[i][1] = int(a_friend[1])\nfriends = sorted(friends)\nleft = 0\nright = 0\nresult = 0\naddition = 0\n\n\nwhile(left < n and right < n):\n    while(right < n and ((friends[right][0]-friends[left][0]) < d)):\n        addition += friends[right][1]\n        right += 1\n    result = max(result, addition)\n    addition -= friends[left][1]\n    left += 1\n\nprint(result)\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\n\ntuples = []\nfor _ in xrange(n):\n\ta, b = map(int, raw_input().split())\n\ttuples.append((a, b))\n\ntuples.sort()\nlow = 0\ntotal = 0\nmx = 0\nfor i in xrange(n):\n\twhile tuples[low][0] + d <= tuples[i][0]:\n\t\ttotal -= tuples[low][1]\n\t\tlow += 1\n\ttotal += tuples[i][1]\n\tmx = max(mx, total)\n\nprint mx\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX = 1000005;\nint N;\nint dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, -1, 0, 1};\npair<long long, long long> p[MX];\nlong long pref[MX];\nbool cmp(pair<long long, long long>& p1, pair<long long, long long>& p2) {\n  if (p1.first == p2.first) return p1.second > p2.second;\n  return p1.first < p2.first;\n}\nint ch(int x, int aim, int d) {\n  if (abs(p[aim].first - p[x].first) < d) return 2;\n  return 0;\n}\nlong long Ra(int l, int r) {\n  long long las = min(r, N - 1);\n  if (l < 1) return pref[las];\n  return pref[las] - pref[l - 1];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long d;\n  cin >> N >> d;\n  for (int i = 0; i < N; i++) cin >> p[i].first >> p[i].second;\n  sort(p, p + N, cmp);\n  for (int i = 0; i < N; i++) {\n    if (i) pref[i] = pref[i - 1];\n    pref[i] += p[i].second;\n  }\n  long long ans = 0;\n  for (int i = 0; i < N; i++) {\n    long long l = i, m, h = N - 1, res = -1e18;\n    while (l <= h) {\n      m = l + h;\n      m /= 2;\n      if (ch(i, m, d)) {\n        res = max(res, Ra(i, m));\n        l = m + 1;\n      } else\n        h = m - 1;\n    }\n    ans = max(ans, res);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, d= map(int, raw_input().split())\narr=[]\nfor i in xrange(n):\n\tarr.append(map(int,raw_input().split()))\narr.sort()\nmaxVal=currVal=arr[0][1]\ni,j= 1,0\nwhile i<n:\n\twhile arr[i][0]-arr[j][0] >= d:\n\t\tcurrVal-=arr[j][1]\n\t\tj+=1\n\tcurrVal+=arr[i][1]\n\tmaxVal=max(maxVal, currVal)\n\ti+=1\nprint maxVal\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\nfrom bisect import bisect_left\n\nn, d = map(int, stdin.readline().split())\na = sorted([tuple(map(int, l.split())) for l in stdin])\n\nsums = [0]\nsums_v = 0\nfor v in a:\n  sums_v += v[1]\n  sums.append(sums_v)\n\nresult = 0\nfor (i, (m, f)) in enumerate(a):\n  l = bisect_left(a, (m + d, 0))\n  result = max(result, sums[l] - sums[i])\n\nprint result\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long A = 100000000000000LL, N = 228228;\nchar e[21];\nvector<string> ot;\npair<int, pair<int, string> > a[N];\nlong long o, p[3] = {-1, -1, -1};\nint i, j, l, r, n, m;\nint main() {\n  cin >> n >> m;\n  for (i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &a[i].first, &a[i].second.first);\n    a[i].second.second = e;\n  }\n  sort(a, a + n);\n  for (l = 0; l < n; o -= a[l].second.first, ++l) {\n    while (r < n && abs(a[l].first - a[r].first) < m)\n      o += a[r].second.first, ++r;\n    if (o >= p[0]) p[0] = o, p[1] = l, p[2] = r;\n  }\n  for (i = p[1]; i < p[2]; ++i) ot.push_back(a[i].second.second);\n  cout << p[0] << \"\\n\";\n}\n"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\nimport time\nimport sys\nimport io\nimport re\nimport math\nimport itertools\nimport collections\nimport bisect\n#sys.stdin=file('input.txt')\n#sys.stdout=file('output.txt','w')\n#10**9+7\nmod=1000000007\n#mod=1777777777\npi=3.141592653589\nxy=[(1,0),(-1,0),(0,1),(0,-1)]\nbs=[(-1,-1),(-1,1),(1,1),(1,-1)]\n#start = time.clock()\n\nn,d=map(int,raw_input().split())\nbl={}\nfor i in range(n):\n    m,s=map(int,raw_input().split())\n    if bl.has_key(m):\n        bl[m]+=s\n    else:\n        bl[m]=s\nls=[]\nfor i in bl:\n    ls.append((i,bl[i]))\nls.sort()\nans=tmp=b=0\nlst=len(ls)\nfor i in range(lst):\n    tmp+=ls[i][1]\n    if ls[i][0]-ls[b][0]>=d:\n        while 1:\n            tmp-=ls[b][1]\n            b+=1\n            if ls[i][0]-ls[b][0]<d:\n                break\n    ans=max(ans,tmp)\nprint ans\n\n#end = time.clock()\n#print end - start"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int z = 1;\n  while (z--) {\n    int n, d;\n    cin >> n >> d;\n    vector<pair<int, int>> friends;\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      cin >> a >> b;\n      arr[i] = a;\n      friends.push_back(make_pair(a, b));\n    }\n    sort(friends.begin(), friends.end());\n    sort(arr, arr + n);\n    long long int prefix[n];\n    prefix[0] = friends[0].second;\n    for (int i = 1; i < n; i++) {\n      prefix[i] = prefix[i - 1] + friends[i].second;\n    }\n    long long int maxx = 0;\n    for (int i = 0; i < n; i++) {\n      int pos = upper_bound(arr + i, arr + n, arr[i] + d - 1) - arr;\n      maxx = max(maxx, prefix[pos - 1] - (i ? prefix[i - 1] : 0));\n    }\n    cout << maxx << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\ndata = []\nfor i in range(n):\n    inp = map(int, raw_input().split())\n    data.append(inp)\ndata = sorted(data, key=lambda x: (x[0], x[1]))\nleft = 0\nright = 1\ncurrent_score = data[0][1]\nmaxi = current_score\nwhile left <= n - 1  and right <= n - 1:\n    cost_left, score_left = data[left]\n    cost_right, score_right = data[right]\n    if cost_right - cost_left < d:\n        current_score += score_right\n        right += 1\n    else:\n        maxi = max(current_score, maxi)\n        current_score -= data[left][1]\n        left += 1\n\nmaxi = max(current_score, maxi)\nprint maxi"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class X>\nclass vec {\n public:\n  X x, y;\n  vec<X>(X a = 0, X b = 0) { x = a, y = b; }\n  X dis(vec a) { return (x - a.x) * (x - a.x) + (y - a.y) * (y - a.y); }\n  vec<X> operator-(vec<X> b) { return vec<X>(x - b.x, y - b.y); }\n  X operator*(vec<X> b) { return x * b.y - y * b.x; }\n};\nvoid sf(int &x) { scanf(\"%d\", &x); }\nvoid sf(long long &x) { scanf(\"%lld\", &x); }\nvoid sf(long long &x, long long &y) { scanf(\"%lld%lld\", &x, &y); }\nvoid sf(float &x) { scanf(\"%f\", &x); }\nvoid sf(double &x) { scanf(\"%lf\", &x); }\nvoid sf(int &x, int &y) { scanf(\"%d%d\", &x, &y); }\nvoid sf(float &x, float &y) { scanf(\"%f%f\", &x, &y); }\nvoid sf(double &x, double &y) { scanf(\"%lf%lf\", &x, &y); }\nvoid sf(double &x, double &y, double &z) { scanf(\"%lf%lf%lf\", &x, &y, &z); }\nvoid sf(int &x, int &y, int &z) { scanf(\"%d%d%d\", &x, &y, &z); }\nvoid sf(long long &x, long long &y, long long &z) {\n  scanf(\"%lld%lld%lld\", &x, &y, &z);\n}\nvoid sf(float &x, float &y, float &z) { scanf(\"%u%u%u\", &x, &y, &z); }\nvoid sf(char &x) { x = getchar(); }\nvoid sf(char *s) { scanf(\"%s\", s); }\nvoid sf(string &s) { cin >> s; }\nvoid sf(vec<int> &x) {\n  int a, b;\n  sf(a, b);\n  x = vec<int>(a, b);\n}\nvoid pf(int x) { printf(\"%d\\n\", x); }\nvoid pf(int x, int y) { printf(\"%d %d\\n\", x, y); }\nvoid pf(int x, int y, int z) { printf(\"%d %d %d\\n\", x, y, z); }\nvoid pf(long long x) { printf(\"%lld\\n\", x); }\nvoid pf(long long x, long long y) { printf(\"%lld %lld\\n\", x, y); }\nvoid pf(long long x, long long y, long long z) {\n  printf(\"%lld %lld %lld\\n\", x, y, z);\n}\nvoid pf(float x) { printf(\"%u\\n\", x); }\nvoid pf(double x) { printf(\"%.9lf\\n\", x); }\nvoid pf(double x, double y) { printf(\"%.5lf %.5lf\\n\", x, y); }\nvoid pf(char x) { printf(\"%c\\n\", x); }\nvoid pf(char *x) { printf(\"%s\\n\", x); }\nvoid pf(string x) {\n  cout << x;\n  puts(\"\");\n}\nvoid pf(vec<int> x) { printf(\"%d %d\\n\", x.x, x.y); }\nlong long STN(string s) {\n  long long sm;\n  stringstream ss(s);\n  ss >> sm;\n  return sm;\n}\ntemplate <class T>\nT bigmod(T b, T p, T m) {\n  if (p == 0) return 1 % m;\n  T x = b;\n  T ans = 1;\n  while (p) {\n    if (p & 1) ans = (ans * x) % m;\n    p >>= 1;\n    x = (x * x) % m;\n  }\n  return ans;\n}\ntemplate <class T>\nT gcd(T x, T y) {\n  if (y == 0) return x;\n  return gcd(y, x % y);\n}\ntemplate <typename T>\nT POW(T b, T p) {\n  if (p == 0) return 1;\n  if (p == 1) return b;\n  if (p % 2 == 0) {\n    T s = POW(b, p / 2);\n    return s * s;\n  }\n  return b * POW(b, p - 1);\n}\ntemplate <typename T>\nT modinv(T num, T m) {\n  return bigmod(num, m - 2, m);\n}\ntemplate <class T>\nstring NTS(T Number) {\n  stringstream ss;\n  ss << Number;\n  return ss.str();\n}\nlong long n, d, c[100009];\nvector<pair<long long, long long> > v;\nint main() {\n  v.push_back(make_pair(-1, -1));\n  sf(n, d);\n  for (int i = 0; i < n; i++) {\n    long long a, b;\n    sf(a, b);\n    v.push_back(make_pair(a, b));\n  }\n  sort(v.begin(), v.end());\n  for (int i = 1; i <= n; i++) {\n    c[i] = c[i - 1] + v[i].second;\n  }\n  long long an = 0;\n  for (int i = 1; i <= n; i++) {\n    long long hi = n, lo = i, a = v[i].first + d;\n    while (hi > lo) {\n      long long mid = (hi + lo + 1) / 2;\n      if (v[mid].first < a)\n        lo = mid;\n      else\n        hi = mid - 1;\n    }\n    long long kk = c[lo] - c[i - 1];\n    an = max(an, kk);\n  }\n  pf(an);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T;\ndouble pi = acos(-1.0);\nlong long factorial(long long x) {\n  long long total = 1;\n  for (int i = 2; i <= x; i++) total *= i;\n  return total;\n}\nbool isprime(long long x) {\n  vector<bool> prime(x + 1, 1);\n  prime[0] = prime[1] = 0;\n  for (long long i = 2; i * i <= x; i++)\n    if (prime[i])\n      for (long long j = i * i; j <= x; j += i) prime[j] = 0;\n  return prime[x];\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0)\n    return a;\n  else\n    return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return (a * b) / gcd(a, b); }\nlong long temp = 1;\nlong long fastpow(long long base, long long exponent) {\n  if (exponent == 0) return 1;\n  if (exponent == 1) return (temp * base);\n  if (exponent % 2 == 0)\n    return fastpow(base * base, exponent / 2);\n  else {\n    temp *= base;\n    fastpow(base * base, exponent / 2);\n  }\n}\nlong fib(long n) {\n  if (n == 0) return 0;\n  if (n == 1) return 1;\n  return fib(n - 2) + fib(n - 1);\n}\nvoid solve() {\n  int n, diff;\n  cin >> n >> diff;\n  vector<pair<int, int>> v(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    v[i] = make_pair(x, y);\n  }\n  sort(v.begin(), v.end());\n  long long l = 0, r = 1, sum = v[0].second, ans = sum;\n  while (r < n) {\n    if (abs(v[r].first - v[l].first) < diff) {\n      sum += v[r].second;\n      ans = max(sum, ans);\n      r++;\n    } else {\n      sum -= v[l].second;\n      l++;\n    }\n  }\n  cout << ans << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  { solve(); }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Kefa_Company {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tlong range=sc.nextLong();\n\t\tDuet arr[]=new Duet[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tlong amount=sc.nextLong();\n\t\t\tlong f=sc.nextLong();\n\t\t\tarr[i]=new Duet(amount,f);\n\t\t\t\n\t\t}\n\t\t\n\t\tArrays.sort(arr,new S());\n\t\t\n\t\tint i=0;\n\t\tlong r1=0;\n\t\tlong max=Integer.MIN_VALUE;\n\t\tlong sum=0;\n\t\tint j=0;\n\t\twhile(i<n)\n\t\t{\n\t\t\tif(i==0)\n\t\t\t{\n\t\t\t\tr1=arr[i].amount;\n\t\t\t\tsum+=arr[i].fact;\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(arr[i].amount<r1+range&& arr[i].amount>r1-range)\n\t\t\t{\n\t\t\t\tsum+=arr[i].fact;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmax=Math.max(max, sum);\n\t\t\t\tsum-=arr[j].fact;\n\t\t\t\tj++;\n\t\t\t\tr1=arr[j].amount;\n\t\t\t}\n\t\t}\n\t\tmax=Math.max(sum, max);\n\t\tSystem.out.println(max);\n\t}\n\n}\n\nclass S implements Comparator<Duet>\n{\n\tpublic int compare(Duet a,Duet b)\n\t{\n\t\treturn (int)(a.amount-b.amount);\n\t}\n}\n\nclass Duet \n{\n\tlong fact,amount;\n\tpublic Duet(long amount,long fact)\n\t{\n\t\tthis.fact=fact;\n\t\tthis.amount=amount;\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = [int(x) for x in input().split()]\nprieteni = []\nfor i in range(n):\n    pr = [int(x) for x in input().split()]\n    prieteni += [pr]\nprieteni.sort(key=lambda x : x[0])\nl = 0\nr = 0\nfinal = prieteni[l][1]\nmax = 0\nwhile r < n:\n    if l == r:\n        final = prieteni[l][1]\n        r += 1\n        if r == n:\n            if final > max:\n                max = final\n            break\n\n    if prieteni[r][0] - prieteni[l][0] < d:\n        final += prieteni[r][1]\n        r += 1\n        if r == n:\n            if final > max:\n                max = final\n    else:\n        if final > max:\n            max = final\n        l += 1\n        final = final - prieteni[l-1][1]\nprint(max)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool cmp(int n, pair<int, int> const& p) {\n  return ((p.first < n) && (p.second < n));\n}\nint main() {\n  int n, d;\n  cin >> n >> d;\n  pair<long long, long long> a[n + 1];\n  long long b[n + 1];\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].first;\n    b[i] = a[i].first;\n    cin >> a[i].second;\n  }\n  sort(b, b + n);\n  sort(a, a + n);\n  long long c[n + 2];\n  c[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    c[i] = c[i - 1] + a[i - 1].second;\n  }\n  long long mx = 0;\n  for (long long i = 0; i < n; i++) {\n    long long sum = 0;\n    long long j = upper_bound(b, b + n, a[i].first + d - 1) - b;\n    sum = c[j] - c[i];\n    mx = max(mx, sum);\n  }\n  cout << mx << '\\n';\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\na=[]\nfor i in range(n):\n\tx,y=map(int,input().split())\n\ta.append([x,y])\na.sort()\n\npartialsum=[0]*n\npartialsum[0]=a[0][1]\nfor i in range(1,n):\n\tpartialsum[i]=partialsum[i-1]+a[i][1]\n\nmx=partialsum[0]\ncnt=0\nfor i in range(1,n):\n\twhile cnt<i and a[i][0]-a[cnt][0]>=d:\n\t\tcnt+=1\n\tif cnt>0:\n\t\tmx=max(mx,partialsum[i]-partialsum[cnt-1])\n\telse:\n\t\tmx=max(mx,partialsum[i])\nprint(mx)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, d, a, b;\n  cin >> n >> d;\n  vector<pair<int, int> > V;\n  for (int i = 0; i < n; i++) {\n    cin >> a >> b;\n    V.push_back(pair<int, int>(a, b));\n  }\n  sort(V.begin(), V.end());\n  long long int sum = 0, r_sum = 0;\n  for (a = 0, b = 0; a < n; a++) {\n    while (V[a].first + d > V[b].first && b < n) r_sum += V[b].second, b++;\n    sum = max(sum, r_sum);\n    r_sum -= V[a].second;\n  }\n  cout << sum << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nvoid __print(long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  long long f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nvoid solve() {\n  long long n, d;\n  cin >> n >> d;\n  vector<pair<long long, long long> > a(n + 1);\n  for (long long i = 0; i < (n); i++) {\n    long long m, f;\n    cin >> m >> f;\n    a[i + 1] = {m, f};\n  }\n  sort(a.begin()++, a.end()++);\n  long long l = 1;\n  long long r = 2;\n  long long ans = a[1].second;\n  long long curr = ans;\n  while (r <= n) {\n    while (r <= n and a[r].first - a[l].first < d) {\n      curr += a[r].second;\n      r++;\n    }\n    ans = max(curr, ans);\n    curr -= a[l].second;\n    l++;\n  }\n  cout << ans << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import javafx.util.Pair;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Main {\n    private final static InputReader ir = new InputReader(System.in);\n    private final static OutputWriter ow = new OutputWriter(System.out);\n    private final static int INF = Integer.MAX_VALUE;\n    private final static int NINF = Integer.MIN_VALUE;\n    private final static double PI = Math.PI;\n\n    public static void main(String[] args) throws IOException {\n        try {\n            task();\n        } finally {\n            boolean exc = false;\n            try {\n                ir.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n                exc = true;\n            }\n            try {\n                ow.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n                exc = true;\n            }\n            if (exc) System.exit(1);\n        }\n    }\n\n    private static int lowerBound(int key, ArrayList<Pair<Integer, Integer>> list) {\n        int lo = 0;\n        int hi = list.size();\n\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            int val = list.get(mid).getKey();\n            if (val < key) {\n                lo = mid + 1;\n            } else if (val >= key) {\n                if (mid - 1 < 0 || list.get(mid - 1).getKey() < key)\n                    return mid;\n                else hi = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    private static int upperBound(int key, ArrayList<Pair<Integer, Integer>> list) {\n        int lo = 0;\n        int hi = list.size();\n\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            int val = list.get(mid).getKey();\n            if (val <= key) {\n                if (mid + 1 >= list.size() || list.get(mid + 1).getKey() > key)\n                    return mid;\n                else lo = mid + 1;\n            } else if (val > key) {\n                hi = mid - 1;\n            } else return mid;\n        }\n        return -1;\n    }\n\n\n    private static void task() throws IOException {\n        int n = ir.nextInt(), d = ir.nextInt();\n        ArrayList<Pair<Integer, Integer>> friends = new ArrayList<>(n);\n        for (int i = 0; i < n; ++i) {\n            friends.add(new Pair<>(ir.nextInt(), ir.nextInt()));\n        }\n\n        //friends.sort(Comparator.comparing(Pair::getValue));\n        friends.sort(Comparator.comparing(Pair::getKey));\n        long[] sum = new long[n];\n        sum[0] = friends.get(0).getValue();\n\n        for (int i = 1; i < n; ++i) {\n            sum[i] = sum[i - 1] + friends.get(i).getValue();\n        }\n\n        long ans = 0;\n\n        for (int i = 0; i < n; ++i) {\n            int lo = friends.get(i).getKey();\n            int hi = friends.get(i).getKey() + d - 1;\n\n            //System.out.println(lo + \" \" + hi);\n\n            int il = lowerBound(lo, friends);\n            int ih = upperBound(hi, friends);\n\n            //System.out.println(il + \" \" + ih);\n\n            long s;\n            if (il > 0)\n                s = sum[ih] - sum[il - 1];\n            else s = sum[ih];\n\n            //System.out.println(s);\n\n            if (s > ans) ans = s;\n        }\n\n        ow.print(ans);\n\n        //friends.forEach(System.out::println);\n        /*\n        long sum = 0;\n        long ans = 0;\n        int imin = 0;\n        int imax = 0;\n        for (int l = 0; l < n;) {\n            //System.out.println(\"l \" + l);\n            boolean go = true;\n            for (int r = l; r < n && go;) {\n                //System.out.println(\"r \" + r);\n                Pair<Integer, Integer>\n                        pair = friends.get(r),\n                        min = friends.get(imin),\n                        max = friends.get(imax);\n\n                if (pair.getKey() > max.getKey() - d &&\n                        pair.getKey() < min.getKey() + d) {\n                    sum += pair.getValue();\n                    if (friends.get(r).getKey() < min.getKey()) {\n                        imin = r;\n                    }\n                    if (friends.get(r).getKey() > max.getKey()) {\n                        imax = r;\n                    }\n                    r++;\n                }\n                else {\n                    if (sum > ans) ans = sum;\n                    sum = 0;\n                    if (pair.getKey() <= max.getKey() - d) {\n                        l = imax + 1;\n                    } else if (pair.getKey() >= min.getKey() + d) {\n                        l = imin + 1;\n                    } else {\n                        assert false : \"error\";\n                    }\n                    go = false;\n                    imax = imin = l;\n                }\n\n            }\n        }\n        if (sum > ans) ans = sum;\n        ow.print(ans);\n        */\n    }\n\n    private static int max(int... objects) {\n        if (objects.length == 0)\n            throw new IllegalArgumentException(\"objects.length == 0\");\n        int max = objects[0];\n        for (int i = 1; i < objects.length; ++i) {\n            if (max < objects[i])\n                max = objects[i];\n        }\n        return max;\n    }\n\n    private static int min(int... objects) {\n        if (objects.length == 0)\n            throw new IllegalArgumentException(\"objects.length == 0\");\n        int min = objects[0];\n        for (int i = 1; i < objects.length; ++i) {\n            if (min > objects[i])\n                min = objects[i];\n        }\n        return min;\n    }\n\n    private static long pow(int x, int n) {\n        if (x == 0) return 0;\n        if (x == 1 || n == 0) return 1;\n        if (x == 2) return x << (n - 1);\n        if (n == 1) return x;\n        long t = pow(x, n / 2);\n        if (n % 2 == 0) return t * t;\n        else return t * t * x;\n    }\n\n    private static double pow(double x, int n) {\n        if (x == 0.0) return 0;\n        if (x == 1.0 || n == 0) return 1;\n        if (n == 1) return x;\n        double t = pow(x, n / 2);\n        if (n % 2 == 0) return t * t;\n        else return t * t * x;\n    }\n\n    private static int abs(int a) {\n        return (a >= 0 ? a : -a);\n    }\n}\n\nclass SQRTDecomposition {\n    private int[] array;\n    private int len;\n    private int[] max;\n    private int[] min;\n\n    public SQRTDecomposition(int[] arr, boolean useIt) {\n        if (useIt)\n            array = arr;\n        else {\n            array = new int[arr.length];\n            System.arraycopy(arr, 0, array, 0, arr.length);\n        }\n        len = (int) Math.sqrt(array.length) + 1;\n        max = new int[len];\n        min = new int[len];\n        for (int i = 0; i < array.length; ++i) {\n            max[i / len] = min[i / len] = array[i];\n        }\n        for (int i = 0; i < array.length; ++i) {\n            max[i / len] = Math.max(max[i / len], array[i]);\n            min[i / len] = Math.min(min[i / len], array[i]);\n        }\n    }\n\n    public int get(int i) {\n        if (i <= 0 || i >= array.length)\n            throw new IndexOutOfBoundsException(\"Index: \" + i);\n        return array[i];\n    }\n\n    public int length() {\n        return array.length;\n    }\n\n    public int max(int l, int r) {\n        int cl = l / len, cr = r / len;\n        int m = array[l];\n        if (cl == cr) {\n            for (int i = l; i <= r; ++i) {\n                if (array[i] > m) m = array[i];\n            }\n        } else {\n            for (int i = l, end = (cl + 1) * len - 1; i <= end; ++i)\n                if (array[i] > m) m = array[i];\n            for (int i = cl + 1; i <= cr - 1; ++i)\n                if (max[i] > m) m = max[i];\n            for (int i = cr * len; i <= r; ++i)\n                if (array[i] > m) m = array[i];\n        }\n        return m;\n    }\n\n    public int min(int l, int r) {\n        int cl = l / len, cr = r / len;\n        int m = array[l];\n        if (cl == cr) {\n            for (int i = l; i <= r; ++i) {\n                if (array[i] < m) m = array[i];\n            }\n        } else {\n            for (int i = l, end = (cl + 1) * len - 1; i <= end; ++i)\n                if (array[i] < m) m = array[i];\n            for (int i = cl + 1; i <= cr - 1; ++i)\n                if (min[i] < m) m = min[i];\n            for (int i = cr * len; i <= r; ++i)\n                if (array[i] < m) m = array[i];\n        }\n        return m;\n    }\n}\n\nclass InputReader implements AutoCloseable {\n    private final InputStream in;\n    private int capacity;\n    private byte[] buffer;\n    private int len = 0;\n    private int cur = 0;\n\n    public InputReader(InputStream stream) {\n        this(stream, 100_000);\n    }\n\n    public InputReader(InputStream stream, int capacity) {\n        this.in = stream;\n        this.capacity = capacity;\n        buffer = new byte[capacity];\n    }\n\n    private boolean update() {\n        if (cur >= len) {\n            try {\n                cur = 0;\n                len = in.read(buffer, 0, capacity);\n                if (len <= 0)\n                    return false;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n        return true;\n    }\n\n    private int read() {\n        if (update())\n            return buffer[cur++];\n        else return -1;\n    }\n\n    public boolean isEmpty() {\n        return !update();\n    }\n\n    private boolean isSpace(int c) {\n        return c == '\\n' || c == '\\t' || c == '\\r' || c == ' ';\n    }\n\n    private boolean isEscape(int c) {\n        return c == '\\n' || c == '\\t' || c == '\\r' || c == -1;\n    }\n\n    private int readSkipSpace() {\n        int c;\n        do {\n            c = read();\n        } while (isSpace(c));\n        return c;\n    }\n\n    public int nextInt() {\n        int c = readSkipSpace();\n        if (c < 0)\n            throw new InputMismatchException();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c == -1) break;\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res = res * 10 + c - '0';\n            if (res < 0)\n                throw new InputMismatchException();\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    public int[] getAllInts() {\n        List<Integer> list = new LinkedList<>();\n        while (true) {\n            try {\n                int t = nextInt();\n                list.add(t);\n            } catch (InputMismatchException e) {\n                break;\n            }\n        }\n        int[] a = new int[list.size()];\n        Iterator<Integer> it = list.iterator();\n        for (int i = 0; it.hasNext(); ++i)\n            a[i] = it.next();\n        return a;\n    }\n\n    public int[] getIntArray1D(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; ++i) {\n            array[i] = nextInt();\n        }\n        return array;\n    }\n\n    public int[][] getIntArray2D(int n, int m) {\n        int[][] array = new int[n][m];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j)\n                array[i][j] = nextInt();\n        }\n        return array;\n    }\n\n    public long nextLong() {\n        int c = readSkipSpace();\n        if (c < 0)\n            throw new InputMismatchException();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c == -1) break;\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res = res * 10 + c - '0';\n            if (res < 0)\n                throw new InputMismatchException();\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    public long[] getAllLongs() {\n        List<Long> list = new LinkedList<>();\n        while (true) {\n            try {\n                long t = nextLong();\n                list.add(t);\n            } catch (InputMismatchException e) {\n                break;\n            }\n        }\n        long[] a = new long[list.size()];\n        Iterator<Long> it = list.iterator();\n        for (int i = 0; it.hasNext(); ++i)\n            a[i] = it.next();\n        return a;\n    }\n\n    public long[] getLongArray1D(int n) {\n        long[] array = new long[n];\n        for (int i = 0; i < n; ++i) {\n            array[i] = nextLong();\n        }\n        return array;\n    }\n\n    public long[][] getLongArray2D(int n, int m) {\n        long[][] array = new long[n][m];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j)\n                array[i][j] = nextLong();\n        }\n        return array;\n    }\n\n    public int nextChar() {\n        int c = readSkipSpace();\n        if (c < 0)\n            throw new InputMismatchException();\n        return c;\n    }\n\n    public String nextLine(int initialCapacity) {\n        StringBuilder res = new StringBuilder(initialCapacity);\n        int c = readSkipSpace();\n        do {\n            res.append((char) (c));\n            c = read();\n        } while (!isEscape(c));\n        return res.toString();\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n}\n\nclass OutputWriter implements Flushable, AutoCloseable {\n    private byte[] buf;\n    private final int capacity;\n    private int count;\n    private OutputStream out;\n\n    public OutputWriter(OutputStream stream) {\n        this(stream, 10_000);\n    }\n\n    public OutputWriter(OutputStream stream, int capacity) {\n        if (capacity < 0)\n            throw new IllegalArgumentException(\"capacity < 0\");\n        out = stream;\n        this.capacity = capacity;\n        if (capacity != 0) {\n            buf = new byte[capacity];\n        }\n    }\n\n    public void write(int b) throws IOException {\n        if (capacity != 0) {\n            if (count >= capacity)\n                flushBuffer();\n            buf[count++] = (byte) b;\n        } else {\n            out.write(b);\n        }\n    }\n\n    public void write(byte[] bytes, int off, int len) throws IOException {\n        if (capacity != 0) {\n            if (len >= capacity) {\n                flushBuffer();\n                out.write(bytes, off, len);\n                return;\n            }\n            if (len > capacity - count)\n                flushBuffer();\n            System.arraycopy(bytes, off, buf, count, len);\n            count += len;\n        } else out.write(bytes, off, len);\n    }\n\n    public void write(byte[] bytes) throws IOException {\n        write(bytes, 0, bytes.length);\n    }\n\n    public void println() throws IOException {\n        print(\"\\n\");\n    }\n\n    public void print(Object object) throws IOException {\n        write(String.valueOf(object).getBytes());\n    }\n\n    public void println(Object object) throws IOException {\n        print(object);\n        println();\n    }\n\n    public void print(int... ints) throws IOException {\n        print(\" \", ints);\n    }\n\n    public void println(int... ints) throws IOException {\n        print(ints);\n        println();\n    }\n\n    public void println(String separator, int... ints) throws IOException {\n        print(separator, ints);\n        println();\n    }\n\n    public void print(String separator, int... ints) throws IOException {\n        if (ints.length == 0) throw new IllegalArgumentException(\"ints.length == 0\");\n        for (int i = 0; i < ints.length; ++i) {\n            if (i != 0) print(separator);\n            print(ints[i]);\n        }\n    }\n\n    private void flushBuffer() throws IOException {\n        if (count > 0) {\n            out.write(buf, 0, count);\n            count = 0;\n        }\n    }\n\n    @Override\n    public void flush() throws IOException {\n        flushBuffer();\n        out.flush();\n    }\n\n    @Override\n    public void close() throws IOException {\n        flush();\n        out.close();\n    }\n}\n/*\nclass InputReader implements AutoCloseable {\n    private final InputStream in;\n    private int capacity;\n    private byte[] buffer;\n    private int len = 0;\n    private int cur = 0;\n\n    public InputReader(InputStream stream) {\n        this(stream, 100_000);\n    }\n\n    public InputReader(InputStream stream, int capacity) {\n        this.in = stream;\n        this.capacity = capacity;\n        buffer = new byte[capacity];\n    }\n\n    private int read() {\n        if (cur >= len) {\n            try {\n                cur = 0;\n                len = in.read(buffer, 0, capacity);\n                if (len <= 0)\n                    return -1;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n        return buffer[cur++];\n    }\n\n    private boolean isSpace(int c) {\n        return c == ' ' || isEscape(c);\n    }\n\n    private boolean isEscape(int c) {\n        return c == '\\n' || c == '\\t' || c == '\\r' || c == -1;\n    }\n\n    private int readSkipSpace() {\n        int c;\n        do {\n            c = read();\n        } while (isSpace(c));\n        return c;\n    }\n\n    int nextInt() {\n        int c = readSkipSpace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res = res * 10 + c - '0';\n            if (res < 0)\n                throw new InputMismatchException();\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    public long nextLong() {\n        int c = readSkipSpace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res = res * 10 + c - '0';\n            if (res < 0)\n                throw new InputMismatchException();\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    int nextChar() {\n        return readSkipSpace();\n    }\n\n    String nextLine(int initialCapacity) {\n        StringBuilder res = new StringBuilder(initialCapacity);\n        int c = readSkipSpace();\n        do {\n            res.append((char) (c));\n            c = read();\n        } while (!isEscape(c));\n        return res.toString();\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n}\n\nclass OutputWriter implements Flushable, AutoCloseable {\n    private byte[] buf;\n    private int capacity;\n    private int count;\n    private OutputStream out;\n\n    public OutputWriter(OutputStream stream) {\n        out = stream;\n        capacity = 10_000;\n        buf = new byte[capacity];\n    }\n\n    public OutputWriter(OutputStream stream, int capacity) {\n        if (capacity <= 0)\n            throw new IllegalArgumentException(\"capacity <= 0\");\n        out = stream;\n        this.capacity = capacity;\n        buf = new byte[capacity];\n    }\n\n    public void write(int b) throws IOException {\n        if (count >= buf.length)\n            flushBuffer();\n        buf[count++] = (byte) b;\n    }\n\n    public void write(byte[] bytes, int off, int len) throws IOException {\n        if (len >= buf.length) {\n            flushBuffer();\n            out.write(bytes, off, len);\n            return;\n        }\n        if (len > buf.length - count)\n            flushBuffer();\n        System.arraycopy(bytes, off, buf, count, len);\n        count += len;\n    }\n\n    public void write(byte[] bytes) throws IOException {\n        write(bytes, 0, bytes.length);\n    }\n\n    public void print(String str) throws IOException {\n        write(str.getBytes());\n    }\n\n    public void println() throws IOException {\n        print(\"\\n\");\n    }\n\n    public void print(Object object) throws IOException {\n        print(object.toString());\n    }\n\n    public void println(Object object) throws IOException {\n        print(object.toString());\n        println();\n    }\n\n    public void print(int... ints) throws IOException {\n        print(\" \", ints);\n    }\n\n    public void println(int... ints) throws IOException {\n        print(ints);\n        println();\n    }\n\n    public void println(String separator, int... ints) throws IOException {\n        print(separator, ints);\n        println();\n    }\n\n    public void print(String separator, int... ints) throws IOException {\n        if (ints.length == 0) throw new IllegalArgumentException(\"ints.length == 0\");\n        for (int i = 0; i < ints.length; ++i) {\n            if (i != 0) print(separator);\n            print(ints[i]);\n        }\n    }\n\n    private void flushBuffer() throws IOException {\n        if (count > 0) {\n            out.write(buf, 0, count);\n            count = 0;\n        }\n    }\n\n    @Override\n    public void flush() throws IOException {\n        flushBuffer();\n        out.flush();\n    }\n\n    @Override\n    public void close() throws IOException {\n        flush();\n        out.close();\n    }\n}\n\n*/\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nifstream fin(\"date.in\");\nofstream fout(\"date.out\");\nstruct prieten {\n  int money;\n  int friendship;\n} v[100001];\nint part_Hoare(int s, int d) {\n  int i, j;\n  i = s - 1;\n  j = d + 1;\n  int randpoz, r1, r2, r3;\n  int nr = d - s + 1;\n  r1 = rand() % nr + s;\n  r2 = rand() % nr + s;\n  r3 = rand() % nr + s;\n  int minr, maxr;\n  minr = min(min(r1, r2), min(r2, r3));\n  maxr = max(max(r1, r2), max(r2, r3));\n  randpoz = r1 + r2 + r3 - minr - maxr;\n  int pivot = v[randpoz].money;\n  while (true) {\n    do {\n      ++i;\n    } while (v[i].money < pivot);\n    do {\n      --j;\n    } while (v[j].money > pivot);\n    if (i >= j) return j;\n    prieten aux;\n    aux.money = v[i].money;\n    aux.friendship = v[i].friendship;\n    v[i].money = v[j].money;\n    v[i].friendship = v[j].friendship;\n    v[j].money = aux.money;\n    v[j].friendship = aux.friendship;\n  }\n}\nvoid qsort(int i, int j) {\n  if (i < j) {\n    int k = part_Hoare(i, j);\n    qsort(i, k);\n    qsort(k + 1, j);\n  }\n}\nint caut_bin(int st, int dr, int x, int dif) {\n  int m = (st + dr) / 2;\n  if (st >= dr) {\n    if ((v[m].money - x) <= dif)\n      return st;\n    else\n      return st - 1;\n  }\n  if ((v[m].money - x) > dif)\n    return caut_bin(st, m - 1, x, dif);\n  else\n    return caut_bin(m + 1, dr, x, dif);\n}\nint main() {\n  int n, d, i, j, k;\n  long long smax = 0;\n  cin >> n >> d;\n  for (i = 1; i <= n; i++) cin >> v[i].money >> v[i].friendship;\n  qsort(1, n);\n  if ((v[2].money - v[1].money) < d) {\n    j = caut_bin(2, n, v[i].money, d - 1);\n    for (i = 1; i <= j; i++) smax += v[i].friendship;\n  } else if (v[1].friendship > smax) {\n    smax = v[1].friendship;\n    j = 1;\n  }\n  i = 1;\n  j++;\n  long long spart = smax;\n  while (j < n) {\n    while (((v[j].money - v[i].money) >= d) && (i < j)) {\n      spart -= v[i].friendship;\n      i++;\n    }\n    while (((v[j].money - v[i].money) < d) && (j <= n)) {\n      spart += v[j].friendship;\n      j++;\n    }\n    if (spart > smax) smax = spart;\n  }\n  if (v[n].friendship > smax) smax = v[n].friendship;\n  cout << smax;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\ninput = lambda: sys.stdin.readline().strip(\"\\r\\n\")\n\nn, d = map(int, input().split())\nls = []\nfor _ in range(n):\n    m, s = map(int, input().split())\n    ls.append((m, s))\nls.sort()\nalpha = 0\nmaxi = 0\nj = 0\nfor i in range(n):\n    alpha += ls[i][1]\n    while ls[i][0] - ls[j][0] >= d:\n        alpha -= ls[j][1]\n        j += 1\n    maxi = max(maxi, alpha)\nprint(maxi)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\n\npublic class Code36\n{\n\tstatic class InputReader {\n\t\t \n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\t\tprivate SpaceCharFilter filter;\n \n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n \n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n \n\t\tpublic int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic String readString() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic String nextLine() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n \n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n \n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n\t\n\tstatic class pair implements Comparable<pair>\n\t{\n\t\tInteger x, y;\n\t\tpair(int x,int y)\n\t\t{\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\tpublic int compareTo(pair o) {\n\t\t\treturn x.compareTo(o.x);\n\t\t}  \n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint d = in.nextInt();\n\t\t\n\t\tpair[] a = new pair[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint p = in.nextInt();\n\t\t\tint q = in.nextInt();\n\t\t\t\n\t\t\ta[i]  = new pair(p,q);\n\t\t}\n\t\tArrays.sort(a);\n\t\tlong max = Long.MIN_VALUE;\n\t\tint l = 0;\n\t\tint r = 0;\n\t\tlong ans = 0;\n\t\tfor(l=0;l<n;ans-=(long)a[l].y,l++)\n\t\t{\n\t\t\twhile(r<n && Math.abs(a[l].x - a[r].x)<d)\n\t\t\t{\n\t\t\t\tans+=(long)a[r].y;\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tmax = Math.max(ans,max);\n\t\t}\n\t\tpw.println(max);\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long int n, d;\n  cin >> n >> d;\n  vector<pair<long long int, long long int>> friends(n);\n  vector<long long int> prefix(n);\n  vector<long long int> results;\n  results.reserve(n);\n  for (auto&& _friend : friends) cin >> _friend.first >> _friend.second;\n  sort(friends.begin(), friends.end());\n  prefix[0] = friends[0].second;\n  for (long long int i = 1; i < n; i++)\n    prefix[i] = prefix[i - 1] + friends[i].second;\n  for (long long int i = 0; i < n; i++) {\n    long long int l_min = i, r_max;\n    long long int l = i, r = n - 1;\n    while (r >= l) {\n      long long int m = (l + r) / 2;\n      if (friends[m].first >= friends[i].first + d) {\n        r = m - 1;\n      } else {\n        l = m + 1;\n      }\n    }\n    r_max = l - 1;\n    if (l_min == 0)\n      results.push_back(prefix[r_max]);\n    else\n      results.push_back(prefix[r_max] - prefix[l_min - 1]);\n  }\n  long long int _max = -1;\n  for (auto&& result : results)\n    if (result > _max) _max = result;\n  cout << _max;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,k=map(int,input().split())\nl=[]\nfor i in range(n):\n\tl.append(list(map(int,input().split())))\nl.sort()\nsu=l[0][1]\nma=0\nfirst,last=0,1\nwhile first<n and last<n:\n\tif l[last][0]-l[first][0]>=k:\n\t\tif su>ma:\n\t\t\tma=su\n\t\tsu-=l[first][1]\n\t\tfirst+=1\n\telse:\n\t\tsu+=l[last][1]\n\t\tlast+=1\nif su>ma:\n\tma=su\nprint(ma)"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom bisect import bisect_right\n\n\ndef main():\n    n, d = map(int, input().split())\n    friends = sorted(tuple(int(c) for c in line.split()) for line in sys.stdin.readlines())\n    money = [e[0] for e in friends]\n\n    friendship_sum = [0]\n    for _, e in friends:\n        friendship_sum.append(friendship_sum[-1] + e)\n\n    start = 0\n    _min, ans = friends[0]\n\n    for i in range(1, n):\n        cur = friends[i][0]\n        if cur - _min >= d:\n            start = bisect_right(money, cur - d)\n            _min = friends[start][0]\n\n        friendship = friendship_sum[i + 1] - friendship_sum[start]\n        ans = max(ans, friendship)\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\na=[]\nfor i in range(n):\n    x=list(map(int,input().split()))\n    a.append(x)\na.sort()\ni=0\nmx=0\nx=a[i][0]\ns=a[i][1]\nj=1\nwhile j!=n:\n    if a[j][0]-x<d:\n        s+=a[j][1]\n        mx=max(s,mx)\n        j+=1\n    else:\n        mx=max(s,mx)\n        s-=a[i][1]\n        i+=1\n        x=a[i][0]\n    \n        \nprint(max(mx,s))"
        },
        {
            "language": 3,
            "solution": "from collections import namedtuple\nfrom operator    import itemgetter\n\nFriend = namedtuple(\"Friend\", \"m s\")\n\nn, d = map(int, input().split())\nf = [ ]\nfor i in range(n):\n    f.append(Friend(*map(int, input().split())))\nf.sort(key=itemgetter(0))\nleft = 0\ncur = f[0].s\nresult = cur\nfor i, fr in enumerate(f[1:], 1):\n    while left < i and f[left].m + d <= fr.m:\n        cur -= f[left].s\n        left += 1\n    cur += fr.s\n    result = max(result, cur)\nprint(result)\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\nn, d = map(int, raw_input().strip().split())\nf = []\nfor i in range(n):\n\tm, s = map(int, raw_input().strip().split())\n\tf.append((m, s))\n\n# sort by money\nf.sort(key=lambda x: x[0])\n\nif n == 1:\n\tprint f[0][1]\n\tsys.exit(0)\n\nmaxtotal = -1\n\nstart = 0\nend = 1\ntotal = f[start][1]\nwhile end < n:\n\twhile end < n and abs(f[end][0] - f[start][0]) < d:\n\t\ttotal += f[end][1]\n\t\tend += 1\n\n\t# all friends in [start, end) are ok\n\tif total > maxtotal: maxtotal = total\n\n\t# remove start and increment\n\ttotal -= f[start][1]\n\tstart += 1\n\nprint maxtotal\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class KefaAndCompany {\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString a[] = br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(a[0]);\n\t\tint d = Integer.parseInt(a[1]);\n\t\tint arr[][] = new int[n][2];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\ta = br.readLine().split(\" \");\n\t\t\tarr[i][0] = Integer.parseInt(a[0]);\n\t\t\tarr[i][1] = Integer.parseInt(a[1]);\n\t\t}\n\t\t\n\t\tArrays.sort(arr , new Comparator<int[]>() {\n\t\t\tpublic int compare(int a[] , int b[]) {\n\t\t\t\treturn a[0] - b[0];\n\t\t\t}\n\t\t});\n\t\t\n\t\tlong sum = 0 , ans = 0;\n\t\tint j = 0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\twhile(j<n && arr[j][0] -arr[i][0] < d )\n\t\t\t{\n\t\t\t\tsum+=arr[j][1];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tans = Math.max(ans, sum);\n\t\t\tsum-=arr[i][1];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n/*\nfor (int i = 0; i < n; i++)\nsum[i + 1] = sum[i] + a[i].Y;\nint r = 0;\nfor (int l = 0; l < n; l++)\n{\nwhile(r < n && a[r].X < a[l].X + d) r++;\nans = max(ans, sum[r] - sum[l]);\n}\nprintf(\"%lld\\n\", ans);*/"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nimport collections\nimport bisect\nfrom collections import deque as queue\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n,m=get_ints()\n    ans=[]\n    for i in range(n):\n        ans.append(get_list())\n    ans.sort()\n    start=0\n    end=0\n    maxim=0\n    val=0\n    while end<n and start<n:\n        if ans[end][0]-ans[start][0]<m:\n            val+=ans[end][1]\n            end+=1\n        else:\n            val-=ans[start][1]\n            start+=1\n        maxim=max(val,maxim)\n    print(maxim)"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class ProblemB580 {\n\t\n\tpublic static void main(String[] args) {\n\t\tint n,d;\n\t\tScanner in = new Scanner(System.in);\n\t\tn = in.nextInt();\n\t\td = in.nextInt();\n\t\tFriend friends = new Friend();\n\t\tfor(int i=0; i<n; i++)\t{\n\t\t\tfriends.money.add(in.nextInt());\n\t\t\tfriends.frndFactor.add(in.nextInt());\n\t\t}\n\t\tfriends.mergeSort(0, n-1);\n\t\t\n\t\tlong lowerLim=0, upperLim=0, totCnt=0, maxCnt=0;\n\t\twhile(upperLim<n && lowerLim<n)\t{\n\t\t\tif(Math.abs(friends.money.get((int) upperLim)-friends.money.get((int) lowerLim)) < d)\t{\n\t\t\t\ttotCnt+=friends.frndFactor.get((int) upperLim);\n\t\t\t\tupperLim++;\n\t\t\t}\n\t\t\telse\t{\n\t\t\t\ttotCnt-=friends.frndFactor.get((int) lowerLim);\n\t\t\t\tlowerLim++;\n\t\t\t}\n\t\t\tmaxCnt = Math.max(totCnt, maxCnt);\n\t\t\t\n\t\t}\n\t\tSystem.out.println(maxCnt);\n\t}\n}\n\nclass Friend {\n\tList<Integer> money = new ArrayList<Integer>();\n\tList<Integer> frndFactor = new ArrayList<Integer>();\n\t\n\tpublic void mergeSort(int left, int right) {\n\t\tif(left >= right)\treturn ;\n\t\tint mid = (left + right)/2;\n\t\tmergeSort(left, mid);\n\t\tmergeSort(mid+1, right);\n\t\tmerge(left, mid, right);\n\t}\n\t\n\tpublic void setParams(List<Integer> m, List<Integer> f, int a, int b)\t{\n\t\tm.add(a);\n\t\tf.add(b);\n\t}\n\t\n\tpublic void merge(int left, int mid, int right)\t{\n\t\tList<Integer> lm = new ArrayList<Integer>();\n\t\tList<Integer> lf = new ArrayList<Integer>();\n\t\tList<Integer> rm = new ArrayList<Integer>();\n\t\tList<Integer> rf = new ArrayList<Integer>();\n\t\tint l=0, r=0, iter=left;\n\t\t\n\t\tfor(int i=left; i<=mid; i++)\t{\n\t\t\tsetParams(lm, lf, money.get(i), frndFactor.get(i));\n\t\t}\n\t\tsetParams(lm, lf, Integer.MAX_VALUE, Integer.MAX_VALUE);\n\t\t\n\t\tfor(int i=mid+1; i<=right; i++)\t{\n\t\t\tsetParams(rm ,rf, money.get(i), frndFactor.get(i));\n\t\t}\n\t\tsetParams(rm ,rf, Integer.MAX_VALUE, Integer.MAX_VALUE);\n\t\t\n\t\twhile(iter<=right)\t{\n\t\t\tif(lm.get(l) < rm.get(r))\t{\n\t\t\t\tmoney.set(iter, lm.get(l));\n\t\t\t\tfrndFactor.set(iter, lf.get(l++));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmoney.set(iter, rm.get(r));\n\t\t\t\tfrndFactor.set(iter, rf.get(r++));\n\t\t\t}\n\t\t\titer++;\n\t\t}\n\t}\n\t\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static FastReader s = new FastReader();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    private static int[] rai(int n) {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextInt();\n        }\n        return arr;\n    }\n\n    private static int[][] rai(int n, int m) {\n        int[][] arr = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                arr[i][j] = s.nextInt();\n            }\n        }\n        return arr;\n    }\n\n    private static long[] ral(int n) {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextLong();\n        }\n        return arr;\n    }\n\n    private static long[][] ral(int n, int m) {\n        long[][] arr = new long[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                arr[i][j] = s.nextLong();\n            }\n        }\n        return arr;\n    }\n\n    private static int ri() {\n        return s.nextInt();\n    }\n\n    private static long rl() {\n        return s.nextLong();\n    }\n\n    private static String rs() {\n        return s.next();\n    }\n\n    static int gcd(int a,int b)\n    {\n        if(b==0)\n        {\n            return a;\n        }\n        return gcd(b,a%b);\n    }\n\n    static long gcd(long a,long b)\n    {\n        if(b==0)\n        {\n            return a;\n        }\n        return gcd(b,a%b);\n    }\n    static boolean isPrime(int n) {\n        //check if n is a multiple of 2\n        if(n==1)\n        {\n            return false;\n        }\n        if(n==2)\n        {\n            return true;\n        }\n        if (n % 2 == 0) return false;\n        //if not, then just check the odds\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n    static boolean[] sieveOfEratosthenes(int n)\n    {\n        // Create a boolean array \"prime[0..n]\" and initialize\n        // all entries it as true. A value in prime[i] will\n        // finally be false if i is Not a prime, else true.\n        boolean prime[] = new boolean[n+1];\n        for(int i=0;i<n;i++)\n            prime[i] = true;\n\n        for(int p = 2; p*p <=n; p++)\n        {\n            // If prime[p] is not changed, then it is a prime\n            if(prime[p] == true)\n            {\n                // Update all multiples of p\n                for(int i = p*p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n        return prime;\n    }\n\n    static int bsearch(List<Node> list, long val,int l1,int r1)\n    {\n        int l=l1,r=r1;\n        while(l<=r)\n        {\n            int mid = (l+r)/2;\n            if(list.get(mid).m<val)\n            {\n                if(mid==r1 || list.get(mid+1).m>=val)\n                {\n                    return mid;\n                }\n                l=mid+1;\n            }\n            else {\n                r=mid-1;\n            }\n        }\n        return -1;\n    }\n    public static void main(String[] args) {\n        StringBuilder ans = new StringBuilder();\n//        int t = ri();\n        int t=1;\n        while (t-- > 0)\n        {\n            int n=ri();\n            long d= rl();\n            List<Node> list=new ArrayList<>();\n            for(int i=0;i<n;i++)\n            {\n                list.add(new Node(rl(),rl()));\n            }\n            list.sort(new Comparator<Node>() {\n                @Override\n                public int compare(Node o1, Node o2) {\n                    if(o1.m==o2.m)\n                    {\n                        return Long.compare(o2.f,o1.f);\n                    }\n                    return Long.compare(o1.m,o2.m);\n                }\n            });\n\n            long[] prefSum = new long[n];\n            long sum = list.get(0).f;\n            prefSum[0] = sum;\n            for(int i=1;i<n;i++)\n            {\n                sum+=list.get(i).f;\n                prefSum[i]= sum;\n            }\n\n            long res = 0;\n            for(int i=0;i<n;i++)\n            {\n                int ind = bsearch(list,list.get(i).m+d,i,n-1);\n                long curr= prefSum[ind];\n                if(i>0)\n                {\n                    curr-=prefSum[i-1];\n                }\n                res=Math.max(res,curr);\n            }\n            ans.append(res).append(\"\\n\");\n\n\n\n\n        }\n        out.print(ans.toString());\n        out.flush();\n\n    }\n    static class Node\n    {\n        long m,f;\n\n        public Node(long m, long f) {\n            this.m = m;\n            this.f = f;\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt(), d = in.nextInt();\n        Freind[] a = new Freind[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = new Freind(in.nextInt(), in.nextInt());\n        }\n        Arrays.sort(a);\n        long ans = 0, max = 0;\n        for (int l = 0, r = 0; r < n;) {\n            if (Math.abs(a[l].m - a[r].m) < d) {\n                ans += a[r].f;\n                r++;\n            } else {\n                max = Long.max(ans, max);\n                ans -= a[l].f;\n                l++;\n            }\n            max = Long.max(ans, max);\n        }\n        System.out.println(max);\n    }\n\n}\n\nclass Freind implements Comparable<Freind> {\n\n    int m, f;\n\n    public Freind(int a, int b) {\n        m = a;\n        f = b;\n    }\n\n    public int compareTo(Freind o) {\n        return m - o.m;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "/* package whatever; // don't place package name! */\n\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(\n                    new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt != 0) {\n                        break;\n                    }\n                    else {\n                        continue;\n                    }\n                }\n                buf[cnt++] = (byte)c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0,\n                    BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        // your code goes here\n        Reader sc = new Reader();\n        //Scanner sc = new Scanner(System.in);\n        BufferedWriter output = new BufferedWriter(\n                new OutputStreamWriter(System.out));\n\n        int n, d;\n        n = sc.nextInt();\n        d = sc.nextInt();\n        int[][] ms = new int[n][2];\n        long[] prefix = new long[n];\n\n        for(int i = 0; i < n; i++) {\n            ms[i][0] = sc.nextInt();\n            ms[i][1] = sc.nextInt();\n        }\n\n        Arrays.sort(ms, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] a, int[] b) {\n                if(a[0] < b[0]) {\n                    return -1;\n                } else if(a[0] > b[0]) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        });\n\n        prefix[0] = (long)ms[0][1];\n        for(int i = 1; i < n; i++) {\n            prefix[i] = prefix[i - 1] + (long)ms[i][1];\n        }\n        long ans = Integer.MIN_VALUE;\n        for(int i = 0; i < n; i++) {\n            int ind = bs(ms, d, i, n - 1);\n            long totalFactor = 0;\n            if(i > 0)\n            totalFactor = prefix[ind] - prefix[i - 1];\n            else\n                totalFactor = prefix[ind];\n            ans = Math.max(ans, totalFactor);\n        }\n\n        output.write(Long.toString(ans));\n        output.flush();\n    }\n    private static int bs(int[][] ms, int d, int l, int high) {\n\n        int low = l;\n        while(low <= high) {\n\n            int mid = low + (high - low) / 2;\n            if(ms[mid][0] - ms[l][0] < d) {\n                if(mid == ms.length - 1)\n                    return mid;\n                if(ms[mid + 1][0] - ms[l][0] >= d) {\n                    return mid;\n                } else {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid - 1;\n            }\n        }\n        return low;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "def get_max_friendship_factor(friends, min_money_dif):\n    friends.sort()\n    max_friendship_factor = 0\n    right = 0\n    friendship_factor = 0\n    for left in range(0, len(friends)):\n        while right < len(friends) and abs(friends[left][0] - friends[right][0]) < min_money_dif:\n            friendship_factor += friends[right][1]\n            right += 1\n        max_friendship_factor = max(max_friendship_factor, friendship_factor)\n        friendship_factor -= friends[left][1]\n    return max_friendship_factor\n\n\ndef solve():\n    first_line = input()\n    num_friends, min_money_dif = [int(num) for num in first_line.split()]\n    friends = []\n    for _ in range(0, num_friends):\n        line = input()\n        friend = tuple([int(num) for num in line.split()])\n        friends.append(friend)\n    max_friendship_factor = get_max_friendship_factor(friends, min_money_dif)\n    print(max_friendship_factor)\n\n\nif __name__ == '__main__':\n    solve()\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long arr[100009];\ntemplate <class T>\ninline void rd(T &i) {\n  bool minus = false;\n  char c;\n  for (c = getchar(); (c < '0' || c > '9') && (c != '-'); c = getchar())\n    ;\n  if (c == '-') {\n    minus = true;\n    c = '0';\n  }\n  for (i = 0; c >= '0' && c <= '9'; c = getchar())\n    i = (i << 3) + (i << 1) + (c - 48);\n  if (minus) i = (~i) + 1;\n}\nbool cmp(const pair<int, int> &l, const pair<int, int> &r) {\n  return l.first < r.first;\n}\nint main() {\n  vector<pair<int, int> > v;\n  int n, d, a, b;\n  long long sum;\n  pair<int, int> p;\n  rd(n);\n  rd(d);\n  for (int i = 0; i < n; i++) {\n    rd(a);\n    rd(b);\n    p = make_pair(a, b);\n    v.push_back(p);\n  }\n  sort(v.begin(), v.end());\n  arr[0] = v[0].second;\n  for (int i = 1; i < n; i++) arr[i] = v[i].second + arr[i - 1];\n  long long mx = 0;\n  for (int i = 0; i < n; i++) {\n    int ind = lower_bound(v.begin(), v.end(), pair<int, int>(v[i].first + d, 0),\n                          cmp) -\n              v.begin() - 1;\n    if (i == 0)\n      sum = arr[ind];\n    else\n      sum = arr[ind] - arr[i - 1];\n    if (sum > mx) mx = sum;\n  }\n  cout << mx << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from bisect import bisect_left\nn, d = map(int, raw_input().split())\na = sorted(map(int, raw_input().split()) for _ in range(n))\nb, c = zip(*a)\nc = [0] + list(c)\nfor i in xrange(1, n+1):\n   c[i] += c[i-1]\nans = 0   \nfor i in xrange(n):\n    j = bisect_left(b, b[i]+d)\n    ans = max(ans, c[j] - c[i]) \nprint ans"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  int n, d;\n  cin >> n >> d;\n  vector<pair<int, int>> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first >> v[i].second;\n  }\n  sort(v.begin(), v.end());\n  long long mx = 0, val = 0;\n  int low = 0, high = 0;\n  while (high < n) {\n    if ((v[high].first - v[low].first) < d) {\n      val += v[high].second;\n      mx = max(mx, val);\n      high++;\n    } else {\n      val -= v[low].second;\n      low++;\n    }\n  }\n  cout << mx << endl;\n}\nint main() { solve(); }\n"
        },
        {
            "language": 3,
            "solution": "n, d = list(map(int, input().split()))\n\npersons = []\n\nfor i in range(n):\n    m, s = list(map(int, input().split()))\n    persons.append((m, s))\n\npersons.sort()\nmax_s = 0\ncur_s = persons[0][1]\ngood_persons = [persons[0]]\nfor i in range(1, n):\n    if abs(good_persons[0][0] - persons[i][0]) < d:\n        good_persons.append(persons[i])\n        cur_s += persons[i][1]\n    else:\n        j = 0\n        rec_s = 0\n        while (j < len(good_persons)) and (abs((good_persons[j][0] - persons[i][0])) >= d):\n            rec_s += good_persons[j][1]\n            j += 1\n        if rec_s <= persons[i][1]:\n            cur_s = cur_s - rec_s + persons[i][1]\n            good_persons = good_persons[j:] + [persons[i]]\n        else:\n            max_s = max(max_s, cur_s)\n            cur_s = cur_s - rec_s + persons[i][1]\n            good_persons = good_persons[j:] + [persons[i]]\n\nprint(max(cur_s, max_s))\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main {\npublic static void main(String [] args)throws Exception{\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer st = new StringTokenizer(br.readLine()); \n\tint n = Integer.parseInt(st.nextToken());\n\tint d = Integer.parseInt(st.nextToken());\n\t\n\tpoint array[] = new point[n];\n\tfor(int i = 0;i < n;i++){\n\t\tst = new StringTokenizer(br.readLine());\n\t\tarray[i] = new point(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()));\n\t}\n\tArrays.sort(array);\n\tint ptr = 0;\n\tlong ans = 0;\n\tlong cur = 0;\n\tfor(int i = 0;i < n;i++){\n\t\twhile(ptr < n && array[ptr].x - array[i].x < d){\n\t\t\tans += array[ptr].y;\n\t\t\tptr++;\n\t\t}\n\t    cur = Math.max(cur,ans);\n\t    ans -= array[i].y;\n\t}\n\tSystem.out.println(cur);\n}\nstatic class point implements Comparable<point>{\n\tint x;\n\tint y;\n\tpublic point(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tpublic int compareTo(point other){\n\t\treturn x - other.x;\n\t}\n}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<long long, long long> vt[100001];\nint main() {\n  int n, d;\n  long long maxy = 0;\n  scanf(\"%d%d\", &n, &d);\n  for (int i = 0; i < n; i++) {\n    long long a, b;\n    scanf(\"%I64d%I64d\", &a, &b);\n    vt[i] = make_pair(a, b);\n  }\n  sort(vt, vt + n);\n  for (int i = 0; i < n; i++) {\n    if (i > 0) vt[i].second += vt[i - 1].second;\n  }\n  for (int i = 0; i < n; i++) {\n    long long sum = 0;\n    int l = i, r = n - 1, ans;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if ((vt[mid].first - vt[i].first) >= d) {\n        r = mid - 1;\n      } else {\n        ans = mid;\n        l = mid + 1;\n      }\n    }\n    if (i > 0)\n      sum = vt[ans].second - vt[i - 1].second;\n    else\n      sum = vt[ans].second;\n    maxy = max(maxy, sum);\n  }\n  cout << maxy << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "def main():\n\n    def solve(arr):\n        arr.sort(key = lambda x: x[0])\n        l = 0\n        s = 0\n        max_ = 0\n\n        for i in range(len(arr)):\n            s += arr[i][1]\n            while arr[i][0] - arr[l][0] >= d:\n                s -= arr[l][1]\n                l += 1 \n            max_ = max(max_,s)\n\n        return max_\n\n    q = []\n\n    n,d = list(map(lambda x: int(x),input().split()))\n    for i in range(n):\n        money,ff = list(map(lambda x: int(x),input().split())) \n        q.append((money,ff))\n\n    print(solve(q))\n\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n \nimport os, sys\nfrom io import IOBase, BytesIO\n \nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n# My magical way of doing recursion in python. This\n# isn't the fastest, but at least it works.\nfrom types import GeneratorType\ndef bootstrap(func, stack=[]):\n    def wrapped_function(*args, **kwargs):\n        if stack:\n            return func(*args, **kwargs)\n        else:\n            call = func(*args, **kwargs)\n            while True:\n                if type(call) is GeneratorType:\n                    stack.append(call)\n                    call = next(call)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    call = stack[-1].send(call)\n            return call\n \n    return wrapped_function\n \nif __name__== \"__main__\":\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  long long m;\n  long long f;\n};\nbool comp(node a, node b) { return a.m < b.m; }\nint main() {\n  long long n;\n  long long d;\n  cin >> n;\n  cin >> d;\n  int pt1, pt2;\n  node a[n];\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].m;\n    cin >> a[i].f;\n  }\n  sort(a, a + n, comp);\n  int i = 0, j = 1;\n  long long sum = a[0].f;\n  long long curr = a[0].f;\n  while (j < n) {\n    if (a[j].m - a[i].m < d) {\n      curr += a[j].f;\n      j++;\n    } else {\n      if (curr > sum) sum = curr;\n      curr -= a[i].f;\n      i++;\n    }\n  }\n  if (curr > sum) sum = curr;\n  cout << sum << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 1;\nlong long ans = -1e18, n, d, pre[N], tmp = 0;\nvector<pair<long long, long long>> v;\nint main() {\n  cin >> n >> d;\n  long long x, y;\n  v.push_back({-1, -1});\n  for (int i = 1; i <= n; i++) {\n    cin >> x >> y;\n    v.push_back({x, y});\n  }\n  sort(v.begin(), v.end());\n  pre[0] = 0;\n  for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + v[i].second;\n  long long i, j = 1;\n  for (i = 1; i <= n; i++) {\n    while (v[i].first - v[j].first >= d) {\n      j++;\n    }\n    tmp = pre[i] - pre[j - 1];\n    ans = max(ans, tmp);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "\n\ndef main():\n\tn,d = [int(x) for x in input().split()]\n\tpreffac = [0]\n\tfriends = []\n\tfor i in range(n):\n\t\tm,s = [int(x) for x in input().split()]\n\t\tfriends.append((m,s))\n\tfriends.sort()\n\tkon = -1\n\twyn = 0\n\tob = 0\n\tfor pocz in range(n):\n\t\tif kon < pocz:\n\t\t\tkon = pocz\n\t\t\tob = friends[pocz][1]\n\t\twhile kon+1 < n and (friends[kon+1][0] - friends[pocz][0]) < d:\n\t\t\tob += friends[kon+1][1]\n\t\t\tkon += 1\n\t\twyn = max(wyn, ob)\n\t\tob -= friends[pocz][1]\n\tprint(wyn)\n\t\n\nmain()\n"
        },
        {
            "language": 3,
            "solution": "n,k=map(int,input().split())\nf,v=[],[]\nd={}\nfor _ in range(n):\n    a,b=map(int,input().split())\n    if a in d:\n        temp=d[a]\n        temp.append(b)\n    else:\n        d[a]=[b]\nfor i in sorted(d):\n    v.extend([i]*len(d[i]))\n    f.extend(sorted(d[i]))\nstart,end=0,1\nm=max(f)\npre,temp=[],0\nfor i in f:\n    temp+=i\n    pre.append(temp)\nwhile(start<n and end<n):\n    if v[end]-v[start]>=k:\n        start+=1\n    else:\n        if start==0:\n            m=max(m,pre[end])\n        else:\n            m=max(m,pre[end]-pre[start-1])\n        end+=1\nif start==0:\n    m=max(m,pre[end-1])\nelse:\n    m=max(m,pre[end-1]-pre[start-1])\n\nprint(m)\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long A = 100000000000000LL, N = 228228;\nchar e[21];\nvector<string> ot;\npair<int, pair<int, string> > a[N];\nlong long o, p[3] = {-1, -1, -1};\nint i, j, l, r, n, m;\nint main() {\n  cin >> n >> m;\n  for (i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &a[i].first, &a[i].second.first);\n    a[i].second.second = e;\n  }\n  sort(a, a + n);\n  for (l = 0; l < n; o -= a[l].second.first, ++l) {\n    while (r < n && abs(a[l].first - a[r].first) < m)\n      o += a[r].second.first, ++r;\n    if (o >= p[0]) p[0] = o, p[1] = l, p[2] = r;\n  }\n  for (i = p[1]; i < p[2]; ++i) ot.push_back(a[i].second.second);\n  cout << p[0] << \"\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n/**\n * Created by kostiantyn.omelianchuk on 1/11/17.\n */\npublic class Problem4 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] l = br.readLine().split(\" \");\n        int n = Integer.parseInt(l[0]);\n        int d = Integer.parseInt(l[1]);\n        //br.readLine().split(\" \");\n        int[][] a = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            l = br.readLine().split(\" \");\n            a[i][0] = Integer.parseInt(l[0]);\n            a[i][1] = Integer.parseInt(l[1]);\n        }\n        Arrays.sort(a, Comparator.comparingInt(x -> x[0]));\n        int j = 0;\n        long ans = 0;\n        long s = 0;\n        for (int i = 0; i < n; i++) {\n            s += a[i][1];\n            while (j <= i && ((a[i][0] - a[j][0]) >= d))\n            {\n                s -= a[j][1];\n                j += 1;\n\n            }\n            ans = Math.max(ans, s);\n\n        }\n\n        PrintStream ps = new PrintStream(System.out);\n        ps.println(ans);\n        ps.close();\n\n\n           }\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nn, d = map(int,input().split())\nF = []\nfor i in range(n):\n    F.append(list(map(int,input().split())))\n\nF = sorted(F, key = lambda x:x[0])\nf_factor = 0\nj = 0\nans = -1\nfor i in range(n):\n    if i != 0:\n        f_factor -= F[i-1][1]\n    while j < n:\n        if F[j][0] - F[i][0] >= d:\n            break\n        f_factor += F[j][1]\n        j+=1\n    ans = max(ans, f_factor)\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class a321{\n\tpublic static void main(String[] args) throws Exception\n    {\n\t   //new FileInputStream(\"input.txt\");\n\t\t//new FileOutputStream(\"output.txt\")\n\t\tInputReader in = new InputReader(System.in);\n\t\tOutputWriter out = new OutputWriter(System.out);\n\t\tint n=in.ri();\n\t\tlong d=in.rl();\n\t\ttime ar[]=new time[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tar[i]=new time(in.rl(),in.rl());\n\t\tArrays.sort(ar);\n\t\tint index=0;\n\t\tlong max=0,current=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\t\n\t\t\t\tcurrent+=(long)ar[i].b;\n\t\t\t\twhile((long)(ar[index].a-ar[i].a)>=d)\n\t\t\t\t{current=current-(long)ar[index].b;\n\t\t\t\tindex=index+1;}\n\t\t\tif(max<current)max=current;\n\t\t}\n\t  out.pl(max);\n\t  out.close();\n\t}\nprivate static class InputReader\n\t{\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\t \n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n \n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t\t \n\t\tpublic int ri()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-')\n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\t\tpublic long rl() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\t\tpublic boolean isSpaceChar(int c)\n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n \n\t\t\n \n\t\tpublic interface SpaceCharFilter\n\t\t{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n \n\tprivate static class OutputWriter\n\t{\n\t\tprivate final PrintWriter writer;\n \n\t\tpublic OutputWriter(OutputStream outputStream)\n\t\t{\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t}\n \n\t\tpublic OutputWriter(Writer writer)\n\t\t{\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n \t\tpublic void print(Object... objects)\n\t\t{\n\t\t\tfor (int i = 0; i < objects.length; i++)\n\t\t\t{\n\t\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\t\twriter.print(objects[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void pf(double n)\n\t\t{\n\t\t\twriter.printf(\"%.2f%n\", n);\n\t\t}\n\t\tpublic void pl(Object... objects)\n\t\t{\n\t\t\tprint(objects);\n\t\t\twriter.println();\n\t\t}\n \n\t\tpublic void close()\n\t\t{\n\t\t\twriter.close();\n\t\t}\n \n\t\tpublic void flush()\n\t\t{\n\t\t\twriter.flush();\n\t\t}\n \n\t}\n}\nclass time implements Comparable<time>\n{\n    long a;\n    long b;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//10\n    public time(long a, long b) {\t\t\t\t\t\t\t\t\t\t//4 4\t\t//10 1\n        this.a = a;\t\t\t\t\t\t\t\t\t\t\t\t\t\t//2 1\t\t//10 3\n        this.b = b;\t\t\t\t\t\t\t\t\t\t\t\t\t\t//2 8\t\t//10 5\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//1 2\t\t//9 5\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//10 5\t\t//8 4\n     public int compareTo(time o) {\t\t\t\t\t\t\t\t\t\t//10 3\t\t//4 4\n        if(this.a > o.a){\t//this.a<o.a\tfor sorting in asc order\t//9 5\t\t//3 7\n           return -1;\t\t\t\t\t\t\t\t\t\t\t\t\t//10 1\t\t//2 1\n      }  else if(this.a == o.a && this.b < o.b){\t\t\t\t\t\t\t//3 7\t\t//2 8\n           return -1;}\t\t\t\t\t\t\t\t\t\t\t\t\t//8 4\t\t//1 2\n        else if (this.a == o.a && this.b == o.b) {\n            return 0;\n      } else {\n           return 1;\n            }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class KefaAndCompany{\n\n    // http://codeforces.com/problemset/problem/580/B\n    \n    static Map<Integer, Long> friendMap = new HashMap<>();\n    static List<Integer> moneyList;\n    static int d;\n    static long maxFriendFactor = 0;\n    public static void main(String[] args){\n        Scanner input = new Scanner(System.in);\n\n        int n = input.nextInt();\n        d = input.nextInt();\n        friendMap = new HashMap<>();\n        \n        for (int i = 0; i < n; i++){\n            int m = input.nextInt();\n            int s = input.nextInt();\n            if (friendMap.keySet().contains(m)){\n                friendMap.put(m, friendMap.get(m) + s);\n            }\n            else{\n                friendMap.put(m, (long)s);\n            }\n        }\n    \n        moneyList = new ArrayList<>();\n        for (int i: friendMap.keySet()){\n            moneyList.add(i);\n        }\n        \n        Collections.sort(moneyList); \n        long sum = 0; \n        int temptUpper = 0; // temporary upper from previous iteration\n\n        for(int lower = 0; lower < moneyList.size(); lower++){\n            // init sum\n            if(lower == 0){\n                int upper = binarySearchLeast(lower);\n                temptUpper = upper;\n                for (int i = lower; i <= upper; i++){\n                    sum += friendMap.get(moneyList.get(i));\n                }\n            }\n            // For each next iteration, there's no need to recalculate the sum\n            // Instead one can reuse the previous sum by subtracting the \n            // friendship of previous lower and adding money of additional upper\n            // This helps reduce the speed significantly!\n            else{\n                sum -= friendMap.get(moneyList.get(lower-1));\n                int upper = binarySearchLeast(lower);\n                for (int i = temptUpper+1; i <= upper; i++){\n                    sum += friendMap.get(moneyList.get(i));\n                }\n                temptUpper = upper;\n            }\n        \n            if (maxFriendFactor < sum){\n                maxFriendFactor = sum;\n            }\n        }\n\n        System.out.println(maxFriendFactor);\n        input.close();\n    }\n\n\n    /**\n     * lower-index = 2, d = 10\n     * [1,2,3,4,5,6,7,8,9,10,11,12,13,14] -> [3..12] -> return 11\n     * \n     * @param moneyList list of friends money in increasing order\n     * @param lower the current examined friend\n     * @return the index of the highest number that is no more than d-difference\n     * from number at lowerbound index\n     */\n    public static int binarySearchLeast(int lower){\n        int max = moneyList.get(lower) + d;\n        int lo = lower;\n        int hi = moneyList.size()-1;\n        \n        while (lo<hi-1){\n            int mid = (int) Math.floor((lo+hi)/2);\n            if (moneyList.get(mid) < max){\n                lo = mid;\n            }\n            else{\n                hi = mid;\n            }\n        }\n        if (moneyList.get(hi) >= max){\n            return lo;\n        }\n        else{\n            \n            return hi;\n        }\n        \n    }\n}"
        },
        {
            "language": 3,
            "solution": "n,d = map(int,input().split())\n\nli = []\n\nfor i in range(n):\n    li.append(list(map(int,input().split())))\n    \nli = sorted(li)\nsu = [0] * n\nsu[0] = li[0][1]\n\nfor i in range(1,n):\n    su[i] = su[i - 1] + li[i][1]\n    \nli = [x[0] for x in li]\n\npo = 0\nma = 0\n\nfor i in range(n):\n    while((po < n-1) and (li[po+1] - li[i] < d)):\n        po = po + 1\n    if(i == 0):\n        ma = max(ma,su[po])\n    else:\n        ma = max(ma,su[po] - su[i-1])\nprint(ma)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nlong long int MOD = 1000000007;\ndouble eps = 1e-12;\nlong long int d;\nvector<pair<long long int, long long int> > v;\nvector<long long int> pref_fri(100001, 0);\nlong long int exp(long long int a, long long int b) {\n  if (b == 0)\n    return 1;\n  else if (b == 1)\n    return a;\n  else {\n    long long int x = exp(a, b / 2);\n    long long int ans = ((x % MOD) * (x % MOD)) % MOD;\n    if (b % 2 == 1) {\n      ans *= (a % MOD);\n      ans %= MOD;\n    }\n    return ans;\n  }\n}\nlong long int bs(int t, int hi) {\n  int lo = 0;\n  while (lo != hi) {\n    int mid = (hi + lo) / 2;\n    if (v[t].first - v[mid].first < d)\n      hi = mid;\n    else\n      lo = mid + 1;\n  }\n  if (v[t].first - v[lo].first < d && lo != 0) {\n    return pref_fri[t] - pref_fri[lo - 1];\n  } else if (v[t].first - v[lo].first < d && lo == 0) {\n    return pref_fri[t];\n  }\n  return -1;\n}\nvoid solve() {\n  int n;\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) {\n    long long int a, b;\n    cin >> a >> b;\n    v.push_back(make_pair(a, b));\n  }\n  sort((v).begin(), (v).end());\n  pref_fri[0] = v[0].second;\n  for (int i = 1; i < n; i++) pref_fri[i] = v[i].second + pref_fri[i - 1];\n  long long int ans = v[0].second;\n  for (int i = 1; i < n; i++) {\n    long long int var = bs(i, i);\n    ans = max(ans, var);\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "N, M = map(int, input().split())\nvalues = []\nfor i in range(N):\n    m, f = input().split()\n    values.append((int(m), int(f)))\nvalues.sort()\n\nr = 0\nl = 0\nmx = 0\nsum =0\nwhile (r < N):\n    dif = values[r][0] - values[l][0]\n    if dif < M:\n        sum = sum + values[r][1]\n        mx = max(mx, sum)\n        r += 1\n    else:\n        sum -= values[l][1]\n        l += 1\n\nprint(mx)"
        },
        {
            "language": 4,
            "solution": "import java.io.File;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class p022 {\n\tpublic static void main(String args[]) throws Exception {\n// \t\tStringTokenizer stok = new StringTokenizer(new Scanner(new File(\"C:/Users/Arunkumar/Downloads/input.txt\")).useDelimiter(\"\\\\A\").next());\n\t\tStringTokenizer stok = new StringTokenizer(new Scanner(System.in).useDelimiter(\"\\\\A\").next());\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = Integer.parseInt(stok.nextToken());\n\t\tint d = Integer.parseInt(stok.nextToken());\n\t\tlong[][] a = new long[n][3];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i][0] = Long.parseLong(stok.nextToken());\n\t\t\ta[i][1] = Long.parseLong(stok.nextToken());\n\t\t}\n\t\tArrays.sort(a,(x,y)->Long.compare(x[0], y[0]));\n\t\t\tfor(int i=0;i<n;i++) a[i][2] = a[i][1]+((i>0)?a[i-1][2]:0);\n\t\t\tlong max = Long.MIN_VALUE;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tlong l = i>0?a[i-1][2]:0,r=0;\n\t\t\tlong v = a[i][0]+d;\n\t\t\tlong t = a[n-1][0];\n\t\t\tif(t<v) r = a[n-1][2];\n\t\t\telse {\n\t\t\t\tint lo=i,hi=n-1;\n\t\t\t\twhile(lo!=hi) {\n\t\t\t\t\tint md = (lo+hi+1)/2;\n\t\t\t\t\tif(a[md][0]>=a[i][0]+d) hi=md-1;else lo = md;\n\t\t\t\t}\n\t\t\t\tr = a[lo][2];\n\t\t\t}\n\t\t\tmax = Math.max(max, r-l);\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 200001;\nstruct People {\n  long long m, s;\n  bool operator<(const People &p) const { return m < p.m; }\n} p[MAXN];\nint n;\nlong long d, s[MAXN];\nint main() {\n  scanf(\"%d%I64d\", &n, &d);\n  d--;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%I64d%I64d\", &p[i].m, &p[i].s);\n  }\n  std::sort(p + 1, p + n + 1);\n  for (int i = 1; i <= n; i++) {\n    s[i] = s[i - 1] + p[i].s;\n  }\n  long long answer = 0;\n  for (int i = 1; i <= n; i++) {\n    int pos = std::upper_bound(p + 1, p + n + 1, (People){p[i].m + d}) - p - 1;\n    answer = std::max(answer, s[pos] - s[i - 1]);\n  }\n  printf(\"%I64d\\n\", answer);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#In the name of Allah\n\nfrom sys import stdin, stdout\ninput = stdin.readline\n\nn, h = map(int, input().split())\nf = sorted([list(map(int, input().split())) for i in range(n)])\n\nans = 0\nfc = f[0][1]\nstart = 0\n\nfor i in range(1, n):\n        while f[i][0] - f[start][0] >= h:\n                \n                ans = max(ans, fc)\n                fc -= f[start][1]\n                start += 1\n                #print(f[start],fc, i)\n\n        fc += f[i][1]\n        ans = max(ans, fc)\n        #print(fc, ans)\nstdout.write(str(max(ans, fc)))\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\n\ndef solve(input_path=None):\n    if input_path is None:\n        f = sys.stdin\n    else:\n        f = open(input_path, 'r')\n\n    n, d = map(int, f.readline().split())\n    candidates = list()\n    for _ in range(n):\n        ab, at = map(int, f.readline().split())\n        candidates.append((ab, at))\n    candidates = sorted(candidates)\n\n    res = 0\n    temp = 0\n    i, j = 0, 0\n    while i < n and j < n:\n        if candidates[j][0] - candidates[i][0] < d:\n            temp += candidates[j][1]\n            res = max(res, temp)\n            j += 1\n        else:\n            temp -= candidates[i][1]\n            i += 1\n\n    return [f\"{res}\"]\n\n\ndef main():\n    for line in solve():\n        print(f\"{line}\")\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    pass\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\nn,d = map(int,input().split())\nl = []\nfor _ in range(n):\n    l.append(tuple(map(int,input().split())))\nl.sort()\nans=0\na=[]\ni=0\nj=0\n \nwhile i<n:\n    if l[i][0]-l[j][0]>=d:\n        a.append(ans)\n        ans-=l[j][1]\n        j+=1\n    else:\n        ans+=l[i][1]\n        a.append(ans)\n        i+=1\nprint(max(a))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long maxm;\nint main() {\n  long long n, d;\n  cin >> n >> d;\n  vector<pair<long long, long long> > p;\n  long long x, y;\n  for (long long i = 0; i < n; i++) {\n    cin >> x >> y;\n    p.push_back(make_pair(x, y));\n  }\n  sort(p.begin(), p.end());\n  for (int i = 1; i < n; i++) p[i].second += p[i - 1].second;\n  long long l, r;\n  l = r = -1;\n  long long ans = 0, tmp = 0;\n  while (l < n && r < n) {\n    r++;\n    if (r == n) break;\n    if (l == -1) l = 0;\n    while (p[l].first + d <= p[r].first) l++;\n    if (l > 0)\n      ans = max(ans, p[r].second - p[l - 1].second);\n    else\n      ans = max(ans, p[r].second);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\nfriends = sorted([map(int, raw_input().split()) for i in xrange(n)])\n\nfr_min = 0\ns = friends[0][1]\nans = s\n\nfor i in friends[1:]:\n    s += i[1]\n    while friends[fr_min][0] <= i[0] - d:\n        s -= friends[fr_min][1]\n        fr_min += 1\n    ans = max(ans, s)\n\nprint ans\n\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nl=[]\nfor i in range(n):\n    m,s=map(int,input().split())\n    l.append((m,s))\nl.sort()\nr=[]\nj=0\ns=0\nd1=l[0][0]\nfor i in range(n):\n    if l[i][0]-d1<d:\n        s+=l[i][1]\n    else:\n        r.append(s)\n        for k in range(j,i):\n            if l[i][0]-l[k][0]>=d:\n                s-=l[k][1]\n                d1=l[k+1][0]\n                j=k+1\n        s+=l[i][1]\nr.append(s)\nprint(max(r))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<int, int> v1[100001];\nint main() {\n  long long n, t;\n  cin >> n >> t;\n  for (int i = 0; i < n; i++) {\n    cin >> v1[i].first >> v1[i].second;\n  }\n  int j = 0;\n  sort(v1, v1 + n);\n  long long sum = 0, ans = 0;\n  for (int i = 0; i < n; i++) {\n    sum += v1[i].second;\n    while (v1[i].first - v1[j].first >= t) {\n      sum -= v1[j].second;\n      j++;\n    }\n    ans = max(ans, sum);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Artem Gilmudinov\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Reader in = new Reader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, Reader in, PrintWriter out) {\n            int n, d;\n            n = in.ni();\n            d = in.ni();\n            long ans = 0;\n            PairInt[] pairInts = new PairInt[n];\n            for (int i = 0; i < n; i++) {\n                pairInts[i] = new PairInt(in.ni(), in.ni());\n            }\n            Arrays.sort(pairInts, new Comparator<PairInt>() {\n\n                public int compare(PairInt o1, PairInt o2) {\n                    return o1.x - o2.x;\n                }\n            });\n            long[] sum = new long[n + 1];\n            for (int i = 1; i <= n; i++) {\n                sum[i] = sum[i - 1] + pairInts[i - 1].y;\n            }\n            int left, right;\n            left = right = 0;\n            for (; left < n; left++) {\n                for (; right < n; right++) {\n                    if (pairInts[right].x - pairInts[left].x >= d) {\n                        break;\n                    }\n                }\n                ans = Math.max(ans, sum[right] - sum[left]);\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class Reader {\n        private BufferedReader in;\n        private StringTokenizer st = new StringTokenizer(\"\");\n        private String delim = \" \";\n\n        public Reader(InputStream in) {\n            this.in = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String next() {\n            if (!st.hasMoreTokens()) {\n                st = new StringTokenizer(rl());\n            }\n            return st.nextToken(delim);\n        }\n\n        public String rl() {\n            try {\n                return in.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int ni() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class PairInt {\n        public int x;\n        public int y;\n\n        public PairInt(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public String toString() {\n            return x + \" \" + y;\n        }\n\n        public PairInt clone() {\n            return new PairInt(x, y);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\n\n\nn, d = map(int, input().split(' '))\n\n\n\nfriends = []\nfor i in range(n):\n    m, s = map(int, input().split(' '))\n    friends.append((m, s))\n\n# sort in n * log n\nfriends.sort()\nfriendship_factor = 0\nslow, fast = 0, 0\nmoney_difference = 0\ncurrent_friendship = 0\nwhile fast < n:\n    current_friendship += friends[fast][1]\n    while friends[fast][0] - friends[slow][0] >= d and slow < fast:\n        current_friendship -= friends[slow][1]\n        slow += 1\n    friendship_factor = max(friendship_factor, current_friendship)\n    fast += 1\nprint(friendship_factor)\n        "
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\na.sort(key=lambda x: x[0])\n# print(a)\n# \u043e\u0447\u0435\u0440\u0435\u0434\u043d\u043e\u0439 \u043a\u0430\u043d\u0434\u0438\u0434\u0430\u0442 \u043d\u0430 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0435 = 0\n# \u0432 \u0446\u0438\u043a\u043b\u0435 \u043f\u043e \u0432\u0441\u0435\u043c \u0434\u0440\u0443\u0437\u044c\u044f\u043c \n# \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0447\u0435\u0440\u0435\u0434\u043d\u043e\u0433\u043e ( = \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0435\u043c \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u0431\u043e\u0433\u0430\u0442\u0441\u0442\u0432\u0430 + \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0435\u0433\u043e \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u0434\u0440\u0443\u0436\u0431\u044b)\n# \u043f\u043e\u043a\u0430 \u043e\u0447\u0435\u0440\u0435\u0434\u043d\u043e\u0439 \u043a\u0430\u043d\u0434\u0438\u0434\u0430\u0442 \u043d\u0430 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u0431\u0435\u0434\u0435\u043d\n# \u0432\u044b\u0447\u0438\u0442\u0430\u0435\u043c \u0435\u0433\u043e \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u0434\u0440\u0443\u0436\u0431\u044b;\n# \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0438\u043c \u043a \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u043c\u0443 \u043a\u0430\u043d\u0434\u0438\u0434\u0430\u0442\u0443 \u043d\u0430 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0435\nj = 0\nfriendship = 0\nmax_friendship = 0\nfor i in range(n):\n    friendship += a[i][1]\n    while a[j][0] + d <= a[i][0]:\n        friendship -= a[j][1]\n        j += 1\n    max_friendship = max(friendship, max_friendship)\n        \nprint(max_friendship)\n    \n        "
        },
        {
            "language": 3,
            "solution": "# Description of the problem can be found at http://codeforces.com/problemset/problem/580/B\n\nn, d = map(int, input().split())\n\nl_p = list()\nfor _ in range(n):\n    l_p.append(list(map(int, input().split())))\n\nl_p.sort()\n\nl, h = 0, 0\nf = 0\nf_m = 0\n\nwhile h < len(l_p):\n    if l_p[h][0] - l_p[l][0] >= d:\n        f -= l_p[l][1]\n        l += 1\n    else:\n        f += l_p[h][1]\n        h += 1\n    \n    f_m = max(f_m, f)\n\nprint(f_m)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1 << 30;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  int u, v;\n  vector<pair<int, int> > a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> u >> v;\n    a[i] = pair<int, int>(u, v);\n  }\n  sort(a.begin(), a.end());\n  long long int ans = 0, mini = a[0].first;\n  long long int sum = a[0].second;\n  int l = 0, r = 1;\n  while (r < n) {\n    if (a[l].first + k <= a[r].first) {\n      ans = max(ans, sum);\n      sum += a[r].second;\n      while (a[l].first + k <= a[r].first) {\n        sum -= a[l].second;\n        l++;\n      }\n    } else {\n      sum += a[r].second;\n    }\n    r++;\n  }\n  ans = max(sum, ans);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class B580 {\n\tpublic static class Friend implements Comparable<Friend> {\n\t\tint money;\n\t\tint factor;\n\t\t\n\t\tpublic Friend(int m, int f) {\n\t\t\tmoney = m;\n\t\t\tfactor = f;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Friend friend) {\n\t\t\tif (this.money > friend.money) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (this.money == friend.money) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\tint n = scan.nextInt();\n\t\tint d = scan.nextInt();\n\t\t\n\t\tList<Friend> friends = new ArrayList();\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint m = scan.nextInt();\n\t\t\tint f = scan.nextInt();\n\t\t\tfriends.add(new Friend(m, f));\n\t\t}\n\t\t\n\t\tCollections.sort(friends);\n\t\t\n\t\tint start = 0;\n\t\tint end = 0;\n\t\tlong max = Integer.MIN_VALUE;\n\t\tlong sum = 0;\n\t\t\n\t\twhile (end < n) {\n\t\t\tsum += friends.get(end).factor;\n\t\t\t\n\t\t\twhile (friends.get(end).money >= d + friends.get(start).money) {\n\t\t\t\tsum -= friends.get(start).factor;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\t\n\t\t\tif (sum > max) {\n\t\t\t\tmax = sum;\n\t\t\t}\n\t\t\t\n\t\t\tend++;\n\t\t}\n\t\t\n\t\tSystem.out.print(max);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint n, d;\npair<int, int> a[N];\nint cmp(pair<int, int> a1, pair<int, int> a2) { return a1.first < a2.first; }\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> d;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a + 1, a + 1 + n, cmp);\n  int i = 1, j = 1;\n  long long sum = 0, ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (a[i].first - a[j].first < d) {\n      sum += a[i].second;\n      ans = max(ans, sum);\n    } else {\n      sum -= a[j].second;\n      j++;\n      i--;\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nfriends = []\nfor i in range(n):\n    m, f = map(int, input().split())\n    friends.append([m, f])\nfriends.sort(key=lambda x: x[0])\nl, r, s = 0, 0, friends[0][1]\nsums = []\nfor i in range(1, n):\n    r += 1\n    if friends[r][0] - friends[l][0] < d:\n        s += friends[i][1]\n    else:\n        sums.append(s)\n        while friends[r][0] - friends[l][0] >= d:\n            s -= friends[l][1]\n            l += 1\n        s += friends[r][1]\nsums.append(s)\nprint(max(sums))\n"
        },
        {
            "language": 1,
            "solution": "#coding: utf-8\n\nnFriends, d = map(int,raw_input().split())\nfriends = []\n\nfor i in range(nFriends):\n\tfriends.append( map(int,raw_input().split()))\nfriends.sort()\n\n\nj = 0\nf_level = 0\nmax_f_level = 0\nfor i in xrange(nFriends):\n\t\n\tfi = friends[i][0]\n\twhile ( j < nFriends and (friends[j][0] - fi) < d ):\n\t\tf_level += friends[j][1]\n\t\tj += 1\n\t\n\tmax_f_level = max(max_f_level, f_level)\n\t\n\tf_level -= friends[i][1]\n\nprint max_f_level"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n  int key;\n  struct Node *left, *right;\n};\nstruct Node* newNode(int key) {\n  struct Node* node = new Node;\n  node->key = key;\n  node->left = node->right = nullptr;\n  return node;\n};\nvoid inorder(struct Node* root) {\n  if (root == nullptr) {\n    return;\n  }\n  cout << root->key << \" \";\n  inorder(root->left);\n  inorder(root->right);\n}\nvoid inputTree(struct Node*& root, int n) {\n  struct Node *parent, *child;\n  map<int, struct Node*> mp;\n  int n1, n2;\n  char lr;\n  while (n--) {\n    cin >> n1 >> n2 >> lr;\n    if (mp.find(n1) == mp.end()) {\n      parent = newNode(n1);\n      mp[n1] = parent;\n      if (root == nullptr) {\n        root = parent;\n      }\n    } else {\n      parent = mp[n1];\n    }\n    child = newNode(n2);\n    if (lr == 'L') {\n      parent->left = child;\n    } else {\n      parent->right = child;\n    }\n    mp[n2] = child;\n  }\n}\nbool cmp(pair<int, int> a, pair<int, int> b) { return a.first < b.first; }\nint main() {\n  int n;\n  long long d;\n  cin >> n >> d;\n  vector<pair<long long, long long>> a(n);\n  vector<long long> sum(n + 1);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a.begin(), a.end(), cmp);\n  sum[0] = 0;\n  for (int i = 0; i < n + 1; ++i) {\n    sum[i] = sum[i - 1] + a[i].second;\n  }\n  long long mx = -1;\n  for (int i = 0; i < n; ++i) {\n    auto it = lower_bound(a.begin() + i, a.end(),\n                          make_pair(a[i].first + d, LLONG_MIN));\n    int num = distance(a.begin(), it);\n    mx = max(mx, sum[num - 1] - sum[i - 1]);\n  }\n  cout << mx << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\n\ndef radixsort(aList):\n    RADIX = 10\n    maxLength = False\n    tmp, placement = -1, 1\n\n    while not maxLength:\n        maxLength = True\n        # declare and initialize buckets\n        buckets = [list() for _ in range(RADIX)]\n\n        # split aList between lists\n        for i in aList:\n            tmp = i[0] / placement\n            buckets[tmp % RADIX].append(i)\n            if maxLength and tmp > 0:\n                maxLength = False\n\n        # empty lists into aList array\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                aList[a] = i\n                a += 1\n\n        # move to next digit\n        placement *= RADIX\n\n\ndef two_pointers2(arr, d, n):\n    radixsort(arr)\n    # arr.sort()\n    max_ff = 0\n    r = 0\n    curr_ff = 0\n    for l in xrange(n):\n\n        while r < n and arr[r][0] - arr[l][0] < d:\n            curr_ff += arr[r][1]\n            r += 1\n\n        if max_ff < curr_ff:\n            max_ff = curr_ff\n\n        curr_ff -= arr[l][1]\n    return max_ff\n\n\ndef two_pointers(arr, d, n):\n    # radixsort(arr)\n    # arr.sort()\n    i = n\n    j = 0\n    curr_ff = 0\n    max_ff = 0\n    while i >= 0:\n        if arr[i][0] - arr[j][0] < d:\n            if j < i:\n                curr_ff += arr[j][1]\n                j += 1\n            elif j == i:\n                curr_ff += arr[i][1]\n                if max_ff < curr_ff:\n                    max_ff = curr_ff\n                j, curr_ff = 0, 0\n                i -= 1\n        else:\n            j += 1\n    return max_ff\n\n\ndef partition(lst, start, end):\n    pos = start                           # condition was obsolete, loop won't\n                                          # simply run for empty range\n\n    for i in xrange(start, end):           # i must be between start and end-1\n        # print lst, i, end\n        if lst[i][0] < lst[end][0]:             # in your version it always goes from 0\n            lst[i],lst[pos] = lst[pos],lst[i]\n            pos += 1\n\n    lst[pos],lst[end] = lst[end],lst[pos] # you forgot to put the pivot\n                                          # back in its place\n    return pos\n\n\ndef quick_sort_recursive(lst, start, end):\n    if start < end:                       # this is enough to end recursion\n        pos = partition(lst, start, end)\n        quick_sort_recursive(lst, start, pos - 1)\n        quick_sort_recursive(lst, pos + 1, end)\n    return lst\n\n\n\ndef solution():\n    first_line = sys.stdin.readline()\n    n, d = map(int, first_line.split())\n\n    input_ = []\n    for i in range(n):\n        input_.append(tuple(map(int, sys.stdin.readline().split())))\n    if n == 1:\n        return input_[0][1]\n    else:\n        # return two_pointers2(input_, d, n)\n        return two_pointers2(input_ ,d,n)\n        # return two_pointers2(quick_sort_recursive(input_, 0, n-1),d,n)\n    # return two_pointers(quick_sort(input_),d, n-1)\n    # return two_pointers(merge_sort(input_),d,n-1)\n\nprint solution()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n  long long int money, friendship;\n};\nbool cmp(edge A, edge B) { return A.money < B.money; }\nvector<edge> vv;\nint main() {\n  edge get;\n  long long int i, j, n, m, d, s, sum = 0, maxx = 0;\n  cin >> n >> d;\n  for (i = 0; i < n; i++) {\n    cin >> m >> s;\n    get.money = m;\n    get.friendship = s;\n    vv.push_back(get);\n  }\n  sort(vv.begin(), vv.end(), cmp);\n  i = 0, j = 0;\n  if (n == 1)\n    cout << vv[0].friendship << endl;\n  else {\n    for (i = 0; i < n;) {\n      while (j < n && (vv[j].money - vv[i].money) < d) {\n        sum += vv[j].friendship;\n        j++;\n      }\n      maxx = max(maxx, sum);\n      if (j >= n) break;\n      sum = sum - vv[i].friendship;\n      i++;\n    }\n    cout << maxx << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nl=[]\nfor i in range(n):\n    j=tuple(map(int,input().split()))\n    l.append(j)\nl.sort()\nans=0\nmaxx=0\nj=0\ni=0\nwhile(j<n):\n    if(l[j][0]-l[i][0]<d):\n        ans+=l[j][1]\n        j+=1\n    else:\n        maxx=max(ans,maxx)\n        ans-=l[i][1]\n        i+=1\n    maxx=max(ans,maxx)\nprint(maxx)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, d;\n  scanf(\"%d %d\", &n, &d);\n  vector<pair<int, int> > friends(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d %d\", &friends[i].first, &friends[i].second);\n  }\n  sort(friends.begin(), friends.end());\n  int left = 0;\n  int right = 0;\n  long long cur_sum = 0;\n  long long max_sum = 0;\n  while (right < n) {\n    while (friends[right].first - friends[left].first >= d) {\n      cur_sum -= friends[left].second;\n      left++;\n    }\n    cur_sum += friends[right].second;\n    right++;\n    max_sum = max(max_sum, cur_sum);\n  }\n  cout << max_sum;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt(), d = in.nextInt();\n            Pair v[] = new Pair[n];\n            for (int i = 0; i < n; ++i) {\n                v[i] = new Pair(0, 0);\n                v[i].x = in.nextInt();\n                v[i].y = in.nextInt();\n            }\n            Arrays.sort(v, new Comparator<Pair>() {\n\n                public int compare(Pair a, Pair b) {\n                    return a.x - b.x;\n                }\n            });\n            long res = 0, sum = 0;\n            int cur = 0;\n            for (int i = 0; i < n; ++i) {\n                while (cur < n && v[cur].x - v[i].x < d) sum += v[cur++].y;\n                res = Math.max(res, sum);\n                sum -= v[i].y;\n            }\n            out.println(res);\n\n        }\n\n        class Pair {\n            int x;\n            int y;\n\n            public Pair(int x, int y) {\n                this.x = x;\n                this.y = y;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nfriends=[tuple(map(int,input().split())) for i in range(n)]\n\nfriends=sorted(friends,key=lambda f:f[0])\nsums=[]\ncurr=0\nfor i in range(n):\n\tcurr+=friends[i][1]\n\tsums.append(curr)\n\nres=0\nfor i in range(n):\n\t#binary search\n\tlow=i\n\thigh=n-1\n\tcurr=friends[i][0]\n\twhile low<high:\n\t\tmid=(low+high+1)//2\n\t\tif abs(curr-friends[mid][0])>=d:\n\t\t\thigh=mid-1\n\t\telse:\n\t\t\tlow=mid\n\tres=max(res,sums[low]-(0 if i==0 else sums[i-1]))\n\nprint(res)"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nf=0\nm=0\nl=0\nlst=list()\nfor _ in range(n):\n\ta,b=map(int,input().split())\n\tlst.append([a,b])\nlst.sort()\nfor i in range(n):\n\tf=f+lst[i][1]\n\twhile lst[i][0]-lst[l][0]>=d:\n\t\tf=f-lst[l][1]\n\t\tl=l+1\n\tm=max(m,f)\nprint(m)"
        },
        {
            "language": 3,
            "solution": "z,zz=input,lambda:list(map(int,z().split()))\nzzz=lambda:[int(i) for i in stdin.readline().split()]\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom string import *\nfrom re import *\nfrom collections import *\nfrom queue import *\nfrom sys import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom itertools import *\nfrom bisect import *\nfrom collections import Counter as cc\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom itertools import accumulate as ac\ndef lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))\ndef prime(x):\n    p=ceil(x**.5)+1\n    for i in range(2,p):\n        if (x%i==0 and x!=2) or x==0:return 0\n        \n    return 1\ndef dfs(u,visit,graph):\n    visit[u]=True\n    for i in graph[u]:\n        if not visit[i]:\n            dfs(i,visit,graph)\n\n###########################---Test-Case---#################################\n\"\"\"\n\n\n\n\"\"\"\n###########################---START-CODING---##############################\n\nn,d=zzz()\n\nli=[]\n\nfor _ in range( n ):\n    li.append((zz()))\nli=sorted(li)\n\ns=ans=li[0][1]\nj=0\n\nfor i in range( 1,n):\n\n    while(li[i][0]-li[j][0])>=d:\n        s-=li[j][1]\n        j+=1\n    s+=li[i][1]\n    ans=max(s,ans)\nprint(ans)\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 1,
            "solution": "(n,d)=map(int,raw_input().split())\nar=[]\nfor i in range(0,n):\n    (a,b)=map(int,raw_input().split())\n    ar.append([a,b])\nar.sort(key=lambda x: x[0])\nsum=0\nmaxi=-1000000000000\nfor p in ar:\n    sum+=p[1]\n    p.append(sum)\n\nfirst=0\nsecond=0\nfor i in range(0,n):\n    finish=second\n    while(finish<n and ar[finish][0]-ar[i][0]<d):\n        second=finish\n        maxi=max(maxi,ar[finish][2]-ar[i][2]+ar[i][1])\n        finish+=1\nprint maxi\n"
        },
        {
            "language": 4,
            "solution": "\n/*package whatever //do not write package name here */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Pair implements Comparable<Pair>{\n        int m, f;\n        public Pair(int m, int f) {\n            this.m = m;\n            this.f = f;\n        }\n        public int compareTo(Pair o) {\n            return this.m - o.m;\n        }\n    }\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), d = sc.nextInt();\n\t\tPair[] p = new Pair[n];\n\t\tfor(int i = 0;i < n;i++) {\n\t\t    p[i] = new Pair(sc.nextInt(), sc.nextInt());\n\t\t}\n\t\tArrays.sort(p);\n\t\tint j = 0;\n\t\tlong max = 0, ans = 0;\n\t\tfor(int i = 0;i < n;i++) {\n\t\t    Pair x = p[i];\n\t\t    while(j < n && -x.m + p[j].m < d) {\n\t\t        ans += p[j].f;\n\t\t        j++;\n\t\t    }\n\t\t    max = (long)Math.max(max, ans);\n\t\t    ans -= x.f;\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "import math,sys,re,itertools,pprint\nrs,ri,rai=input,lambda:int(input()),lambda:list(map(int, input().split()))\n\nn, d = rai()\na = [ rai() for i in range(n) ]\na.sort(key=lambda x: x[0])\nl, r = 0, 1\ns = m = a[0][1]\nwhile r < n:\n    s += a[r][1]\n    while a[r][0] - a[l][0] >= d:\n        s -= a[l][1]\n        l += 1\n    m = max(s, m)\n    r += 1\nprint(m)\n"
        },
        {
            "language": 3,
            "solution": "\nn, d = [int(x) for x in input().split()]\ns = []\n\nwhile (n):\n    s.append([int(x) for x in input().split()])\n    n -= 1\n\n\ns = sorted(s, key=lambda x: x[0], reverse=True)\nst = 0\nsuma = 0\nmaxim = -1\nfor dr in range(len(s)):\n    suma += s[dr][1]\n    while (abs(s[st][0] - s[dr][0]) >= d):\n        suma -= s[st][1]\n        st += 1\n    if (suma > maxim):\n        maxim = suma\n\nprint (maxim)\n"
        },
        {
            "language": 3,
            "solution": "import math\nn, d = [int(x) for x in input().split()]\nfriends = []\nfor i in range(n):\n    friends.append(tuple(int(x) for x in input().split()))\nfriends.sort()\nfriendship_max = 0\nfriendship = 0\nj = 0\nfor i in range(len(friends)):\n    while j < n and friends[j][0] - friends[i][0] < d:\n        friendship += friends[j][1]\n        j += 1\n    if friendship > friendship_max:\n        friendship_max = friendship\n        friendship_argmax = (i, j)\n    friendship -= friends[i][1]\nprint(friendship_max)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5;\nstruct ones {\n  int a, b;\n} f[N];\nint cmp(const ones &a, const ones &b) { return a.a < b.a; }\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &f[i].a, &f[i].b);\n  sort(f + 1, f + n + 1, cmp);\n  int zz = 1;\n  long long ans = 0, now = 0;\n  for (int i = 1; i <= n; i++) {\n    while (f[i].a - f[zz].a >= m) {\n      now = now - (long long)f[zz].b;\n      zz++;\n    }\n    now += (long long)f[i].b;\n    if (now > ans) ans = now;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nf = []\nfor i in range(n):\n    f.append(list(map(int, input().split())))\nf.sort()\n\npf = [0]\nfor i in range(n):\n    pf.append(pf[-1]+f[i][1])\n\nl = 0\nr = 0\nmx = 0\n\nwhile r < n:\n    if f[r][0]-f[l][0] < d:\n        mx = max(mx, pf[r+1]-pf[l])\n        r += 1\n    else:\n        l += 1\n    \n        \nprint(mx)"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class KefaAndCompany {\n\t\n\tpublic static class Node implements Comparable<Node>{\n\t\tint m, s;\n\t\tpublic Node(int m, int s) {\n\t\t\tthis.m = m;\n\t\t\tthis.s= s;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Node o) {\n\t\t\tif(m > o.m) return 1;\n\t\t\tif(m == o.m && s > o.s) return 1;\n\t\t\treturn -1;\n\t\t}\n\t\tpublic String toString() { return m + \"  \" + s; }\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt(), d = scan.nextInt();\n\t\tNode[] friends = new Node[n];\n\t\tfor(int i = 0; i < n; i++) \n\t\t\tfriends[i] = new Node(scan.nextInt(), scan.nextInt());\n\t\tArrays.sort(friends);\n\t\t//System.out.println(Arrays.toString(friends));\n\t\tint i = 0, j = 1;\n\t\tlong sum = friends[0].s, max = friends[0].s;\n\t\twhile(i < n && j < n) {\n\t\t\tint diff = friends[j].m - friends[i].m;\n\t\t\tif(diff >= d) {\n\t\t\t\tif(sum > max) max = sum;\n\t\t\t\twhile(friends[j].m - friends[i].m >= d) {\n\t\t\t\t\tsum = sum - friends[i].s;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += friends[j].s;\n\t\t\tj++;\n\t\t}\n\t\tif(sum > max) max = sum;\n\t\t\n\t\tSystem.out.println(max);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "// \u4f5c\u8005\uff1a\u6768\u6210\u745e\u5148\u751f\nimport java.io.*;\nimport java.util.*;\n\npublic class cf580b {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n    static class Friend implements Comparable<Friend> {\n        int money;\n        int friendship;\n        public Friend(int money, int friendship) {\n            this.money = money;\n            this.friendship = friendship;\n        }\n        @Override\n        public int compareTo(Friend f) {\n            return this.money - f.money;\n        }\n        @Override\n        public String toString() {\n            return this.money + \" \" + this.friendship;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        int n = sc.nextInt(); int d = sc.nextInt();\n        Friend[] a = new Friend[n];\n        for(int i=0;i<n;i++) {\n            a[i] = new Friend(sc.nextInt(), sc.nextInt());\n        }   \n        Arrays.sort(a);\n        //System.out.println(Arrays.toString(a));\n\n        long ans = 0, sum = 0;\n        int pointer = 0;\n        for(int i=0;i<n;i++) {\n            while(pointer < n && a[pointer].money - a[i].money < d) {\n                sum += a[pointer].friendship;\n                pointer++;\n            }\n            if(ans < sum) {\n                ans = sum;\n            }\n            sum -= a[i].friendship;\n        }\n        System.out.println(ans);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, d;\nlong long sums[100200];\nlong long k = 0;\nvector<pair<long long, long long> > v;\nlong long mk = 0;\nlong long s = 0;\nint main() {\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) {\n    long long x;\n    long long y;\n    cin >> x >> y;\n    v.push_back(make_pair(x, y));\n  }\n  sort(v.begin(), v.end());\n  for (int i = 0; i < n; i++) {\n    s += v[i].second;\n    sums[i] = s;\n  }\n  for (int i = 0; i < n; i++) {\n    int lo = 0;\n    int hi = n;\n    long long c = v[i].first + d;\n    int mid = 0;\n    while (lo < hi) {\n      mid = (lo + hi) / 2;\n      if (c <= v[mid].first)\n        hi = mid;\n      else\n        lo = mid + 1;\n    }\n    k = sums[hi - 1] - sums[i - 1];\n    mk = max(k, mk);\n    k = 0;\n  }\n  cout << mk;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class KefaAndCompany implements Closeable {\n\n    private InputReader in = new InputReader(System.in);\n    private PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out), true);\n\n    class Friend implements Comparable<Friend> {\n        long money;\n        long rate;\n        \n        Friend(long money, long rate) {\n            this.money = money;\n            this.rate = rate;\n        }\n\n        @Override\n        public int compareTo(Friend o) {\n            return Long.compare(this.money, o.money);\n        }\n        \n    }\n    \n    public void solve() {\n        int n = in.ni(); long d = in.ni();\n        List<Friend> list = new ArrayList<>();\n        list.add(new Friend(Long.MIN_VALUE, 0));\n        for (int i = 0; i < n; i++) {\n            list.add(new Friend(in.nl(), in.nl()));\n        }\n        Collections.sort(list);\n        long[] prefix = new long[n + 1];\n        prefix[0] = 0;\n        for (int i = 1; i < list.size(); i++) {\n            prefix[i] = prefix[i - 1]  + list.get(i).rate;\n        }\n        long result = 0;\n        for (int i = 0; i < n + 1; i++) {\n            int left = i, right = n, j = i;\n            long current = list.get(i).money;\n            while (left <= right) {\n                int mid = (left + right) / 2;\n                if (list.get(mid).money - d >= current) {\n                    right = mid - 1;    \n                } else {\n                    left = mid + 1;\n                    j = mid;\n                }\n            }\n            if (i == j) {\n                result = Math.max(result, list.get(i).rate);\n            } else {\n                result = Math.max(result, prefix[j] - prefix[i - 1]);\n            }\n        }\n        out.println(result);\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n        out.close();\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(next());\n        }\n\n        public long nl() {\n            return Long.parseLong(next());\n        }\n\n        public void close() throws IOException {\n            reader.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        new KefaAndCompany().solve();\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nans=[list(map(int,input().split())) for _ in range(n)]\n\nans.sort(key =lambda x:x[0])\n\nmaxi=-199999 \nst=0 \nend =0 \nsm1=0 \nsm=0 \nstart=0 \n#print(ans)\nwhile end<n:\n    sm+=ans[end][1] \n    sm1=ans[end][0]\n   # print(sm,sm1)\n    while st<=end and sm1-ans[st][0]>=d:\n        #sm1-=ans[st][0]\n        sm-=ans[st][1]\n        st+=1 \n    maxi=max(maxi,sm)\n    end+=1 \nprint(maxi)"
        },
        {
            "language": 4,
            "solution": "import java.util.*; \npublic class JavaApplication138 {\n\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner (System.in);\n\t\t\n\t\tint n = sc.nextInt(),\n                        d = sc.nextInt();\n\t\tKamesh[] m = new Kamesh [n];\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tm[i] = new Kamesh (sc.nextInt(), sc.nextInt());\n                }\n\t\tArrays.sort(m);\n\t\tlong sum = m[0].s, ans = 0;\n\t\tint e = 1;\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (e < n && m[e].m < m[i].m + d) {\n\t\t\t\tsum += m[e].s;\n\t\t\t\te++;\n\t\t\t}\n\t\t\tans = Math.max(ans, sum);\n\t\t\tif (e >= n)\n\t\t\t\tbreak;\n\t\t\tsum -= m[i].s;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\nclass Kamesh implements Comparable <Kamesh> {\n\tint m, s;\n\tKamesh (int a, int b) {\n\t\tm = a;\n\t\ts = b;\n\t}\n\t@Override\n\tpublic int compareTo(Kamesh arg0) {\n\t\treturn m - arg0.m;\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\n\nn, k = map(int, stdin.readline().rstrip().split(\" \"))\nli = [0]*n\nfor i in range(n):\n    li[i] = list(map(int, stdin.readline().rstrip().split(\" \")))\n\nli.sort()\n\nstart = end = j = 0\nt = 0\nma = 0\nfor i in range(0, n):\n    t+= li[i][1]\n    end = i\n    while li[end][0]-li[start][0]>=k:\n        t-=li[start][1]\n        start += 1\n    ma = max(ma, t)\nprint(ma)\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\narr = sorted(list(map(int, input().split())) for _ in range(n))\nm, max_s, i = 0, 0, 0\nfor j in range(n):\n    m += arr[j][1]\n    while arr[j][0] - arr[i][0] >= d:\n        m -= arr[i][1]\n        i += 1\n    max_s = max(max_s, m)\nprint(max_s)\n \t\t\t\t\t\t\t    \t \t\t  \t   \t\t\t \t \t\t"
        },
        {
            "language": 1,
            "solution": "\nn, d = map(int, raw_input().split())\n\nfriends = []\nfor vez in xrange(n):\n\t\n\tm, s = map(int, raw_input().split())\n\tfriends.append([m,s])\n\nfriends.sort()\n\nmost_friend_factor = 0\nfactor = 0\nj = 0\n\nfor i in xrange(n):\n\t\n\twhile j < n and (friends[j][0] - friends[i][0] < d):\n\t\tfactor += friends[j][1]\n\t\tj += 1\t\n\t\t\t\t\n\tif factor > most_friend_factor:\n\t\tmost_friend_factor = factor\n\n\tfactor -= friends[i][1]\n\t\n\t\t\t\n\t\t\t\t\nprint most_friend_factor\n"
        },
        {
            "language": 3,
            "solution": "n,k=map(int,input().split())\nl=[list(map(int,input().split())) for i in range(n)]\nl.sort(key=lambda x:x[0])\nval=l[0][0]\ni=0\nj=i+1\nans=0\ntemp=l[i][1]\nwhile(j<n and l[j][0]-l[i][0]<k):\n    temp+=l[j][1]\n    j+=1\nans=max(ans,temp)\n#print(\"ans = \",ans)\nwhile(j<n):\n    if(j<n and i<n and l[j][0]-l[i][0]<k):\n        temp+=l[j][1]\n        ans=max(ans,temp)\n        j+=1\n    elif(j<n and i<n):\n        temp-=l[i][1]\n        i+=1\n        ans=max(ans,temp)\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\npublic class cf1 {\n    static long mod = (long)1e9 + 7;\n    static long mod1 = 998244353;\n    static FastScanner f;\n    static PrintWriter pw = new PrintWriter(System.out);\n    static Scanner S = new Scanner(System.in);\n    static long x0; static long y0;\n    static int inf = (int)(1e9) + 5;\n    static long oo = Long.MAX_VALUE;\n    static double eps = (double)1e-4;\n\n    static class Pair {\n        long m , f;\n\n        public Pair(long m , long f) {\n            this.m = m;\n            this.f = f;\n        }\n    }\n\n    static int cmp(Pair p1 , Pair p2) {\n        if (p1.m == p2.m) return (int)(p1.f - p2.f);\n        return (int)(p1.m - p2.m);\n    }\n\n    public static void solve() {\n        int n = f.ni();  int m = f.ni();\n        ArrayList<Pair> g = new ArrayList<>();\n\n        for (int i = 0; i < n; ++i) g.add(new Pair(f.nl() , f.nl()));\n\n        g.sort((Pair p1 , Pair p2) -> cmp(p1 , p2));\n\n        int fptr = 0 , bptr = 0;\n        long sum = 0l , ans = 0l;\n\n        while (fptr < n) {\n            while (g.get(bptr).m + m <= g.get(fptr).m) {\n                sum -= g.get(bptr++).f;\n            }\n            sum += g.get(fptr).f;\n            ans = Math.max(ans , sum);\n            ++fptr;\n        }\n        pn(ans);\n    }   \n\n    public static void main(String[] args)throws NumberFormatException , IOException {   \n        init();\n        boolean tc = false;\n        int t = tc ? f.ni() : 1;\n        while(t --> 0) solve();\n        pw.flush(); \n        pw.close();  \n    }\n        \n/******************************END OF MAIN PROGRAM*******************************************/\n    public static void init()throws IOException{if(System.getProperty(\"ONLINE_JUDGE\")==null){f=new FastScanner(\"\");}else{f=new FastScanner(System.in);}}\n    public static class FastScanner {\n        BufferedReader br;StringTokenizer st;\n        FastScanner(InputStream stream){try{br=new BufferedReader(new InputStreamReader(stream));}catch(Exception e){e.printStackTrace();}}\n        FastScanner(String str){try{br=new BufferedReader(new FileReader(\"!a.txt\"));}catch(Exception e){e.printStackTrace();}}\n        String next(){while(st==null||!st.hasMoreTokens()){try{st=new StringTokenizer(br.readLine());}catch(IOException e){e.printStackTrace();}}return st.nextToken();}\n        String nextLine()throws IOException{return br.readLine();}int ni(){return Integer.parseInt(next());}long nl(){return Long.parseLong(next());}double nd(){return Double.parseDouble(next());}\n    }\n    public static void pn(Object o){pw.println(o);}\n    public static void p(Object o){pw.print(o);}\n    public static void pni(Object o){pw.println(o);pw.flush();}\n    static int gcd(int a,int b){if(b==0)return a;else{return gcd(b,a%b);}}\n    static long gcd(long a,long b){if(b==0l)return a;else{return gcd(b,a%b);}}\n    static long lcm(long a,long b){return (a*b/gcd(a,b));}\n    static long exgcd(long a,long b){if(b==0){x0=1;y0=0;return a;}long temp=exgcd(b,a%b);long t=x0;x0=y0;y0=t-a/b*y0;return temp;}\n    static long pow(long a,long b){long res=1;while(b>0){if((b&1)==1)res=res*a;b>>=1;a=a*a;}return res;}\n    static long mpow(long a,long b){long res=1;while(b>0l){if((b&1)==1l)res=((res%mod)*(a%mod))%mod;b>>=1l;a=((a%mod)*(a%mod))%mod;}return res;}\n    static long mul(long a , long b){return ((a%mod)*(b%mod)%mod);}\n    static long adp(long a , long b){return ((a%mod)+(b%mod)%mod);}\n    static int log2(int x){return (int)(Math.log(x)/Math.log(2));}\n    static boolean isPrime(long n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(long i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    static boolean isPrime(int n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    static HashSet<Long> factors(long n){HashSet<Long> hs=new HashSet<Long>();for(long i=1;i<=(long)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n/i);}}return hs;}\n    static HashSet<Integer> factors(int n){HashSet<Integer> hs=new HashSet<Integer>();for(int i=1;i<=(int)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n/i);}}return hs;}\n    static HashSet<Long> pf(long n){HashSet<Long> ff=factors(n);HashSet<Long> res=new HashSet<Long>();for(Long i:ff)if(isPrime(i))res.add(i);return res;}\n    static HashSet<Integer> pf(int n){HashSet<Integer> ff=factors(n);HashSet<Integer> res=new HashSet<Integer>();for(Integer i:ff)if(isPrime(i))res.add(i);return res;}\n    static int[] inpint(int n){int arr[]=new int[n+1];for(int i=1;i<=n;++i){arr[i]=f.ni();}return arr;}\n    static long[] inplong(int n){long arr[] = new long[n+1];for(int i=1;i<=n;++i){arr[i]=f.nl();}return arr;}\n    static boolean ise(int x){return ((x&1)==0);}static boolean ise(long x){return ((x&1)==0);}\n    static int gnv(char c){return Character.getNumericValue(c);}//No. of integers less than equal to i in ub\n    static int log(long x){return x==1?0:(1+log(x/2));} static int log(int x){return x==1?0:(1+log(x/2));}\n    static int upperbound(int a[],int i){int lo=0,hi=a.length-1,mid=0;int count=0;while(lo<=hi){mid=(lo+hi)/2;if(a[mid]<=i){count=mid+1;lo=mid+1;}else hi=mid-1;}return count;}\n    static void sort(int[] a){ArrayList<Integer> l=new ArrayList<>();for(int i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    static void sort(long[] a){ArrayList<Long> l=new ArrayList<>();for(long i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    static void sort(ArrayList<Integer> a){Collections.sort(a);}//!Precompute fact in ncr()!\n    static int nextPowerOf2(int n){int count=0;if(n>0&&(n&(n-1))==0)return n;while(n!=0){n>>=1;count += 1;}return 1<<count;} \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MAX = 1000000000;\nlong long MOD = 1000000007;\npair<long long, long long> p[100010];\nvoid solve() {\n  long long n;\n  cin >> n;\n  long long d;\n  cin >> d;\n  ;\n  for (long long i = (0); i < (n); i++) {\n    long long in1;\n    cin >> in1;\n    long long in2;\n    cin >> in2;\n    ;\n    p[i] = {in1, in2};\n  }\n  sort(p, p + n);\n  long long j = 0, sum = 0, ans = 0;\n  for (long long i = (0); i < (n); i++) {\n    while (p[j].first - p[i].first < d and j < n) {\n      sum += p[j].second;\n      j++;\n    }\n    ans = max(ans, sum);\n    sum -= p[i].second;\n  }\n  cout << ans;\n}\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  long long test = 1;\n  while (test--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from  operator import itemgetter\nn,d = input().split()\nn=int(n)\nd=int(d)\narr=[]\nfor i in range(n):\n    temp=[]\n    money,respect_valu = input().split()\n    temp.append(int(money))\n    temp.append(int(respect_valu))\n    arr.append(temp)\narr.sort(key=itemgetter(0))\ndef find_max(num1,num2):\n    if num1>num2:\n        return num1\n    else:\n        return num2\ni=0\nj=0\ntem= 0\nans=0\nwhile i<n and j<n:\n    if (arr[j][0]-arr[i][0])>=d:\n        ans = find_max(ans,tem)\n        tem-=arr[i][1]\n        i+=1\n    else:\n        tem+=arr[j][1]\n        j+=1\n    \nprint(find_max(tem,ans))\n\n     "
        },
        {
            "language": 3,
            "solution": "from itertools import accumulate, takewhile\nfrom bisect import bisect_right\nI = lambda: list(map(int, input().split()))\nn, d = I()\npair = sorted([I() for i in range(n)], key = lambda x: x[0])\nsalary = next(zip(*pair))\nsums = tuple(accumulate([0] + pair, func = lambda s, x: s + x[1]))\np1, p2, ans = 0, 0, 0\nwhile p1 < n:\n    p2 = bisect_right(salary, salary[p1] + d - 1, p1)\n    ans = max(ans, sums[p2] - sums[p1])\n    p1 += 1\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "def main():\n    n, d = map(int, input().split())\n    l = sorted(tuple(map(int, input().split())) for _ in range(n))\n    lo, res = l[0][0], []\n    i = j = ss = 0\n    while True:\n        for j in range(j, n):\n            hi, s = l[j]\n            if hi - lo >= d:\n                res.append(ss)\n                break\n            ss += s\n        else:\n            res.append(ss)\n            break\n        for i in range(i, j + 1):\n            lo, s = l[i]\n            if hi - lo < d:\n                break\n            ss -= s\n    print(max(res))\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\nimport java.lang.*;\nimport java.math.BigInteger;\nimport java.io.*;\npublic class Main {\n\tpublic static s[] a=new s[1000010];\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner cin = new Scanner(new BufferedInputStream(System.in));\n\t    int n,d;\n\t    n=cin.nextInt();\n\t    d=cin.nextInt();\n\t    for(int i=1;i<=n;++i)\n\t    {\n\t        a[i]=new s(cin.nextInt(),cin.nextInt());\n\t    }\n\t    Arrays.sort(a, 1, n+1, new cc());\n\t    \n\t    BigInteger r=BigInteger.valueOf(a[1].second),ans=BigInteger.ZERO;\n\t    for(int i=1,j=1;i<=n&&j<=n;++i)\n\t    {\n\t        while(j<n&&a[j+1].first-a[i].first<d)\n\t        \tr=r.add(BigInteger.valueOf(a[++j].second));\n\t       if(r.compareTo(ans)>0)\n\t    \t   ans=r;\n\t        r=r.subtract(BigInteger.valueOf(a[i].second));\n\t    }\n\t    System.out.print(ans);\n\t\tcin.close();\n\t}\n}\nclass s \n{\n\tpublic int first,second;\n\tpublic s(int a,int b)\n\t{\n\t\tfirst=a;\n\t\tsecond=b;\n\t}\n}class cc implements Comparator<s> {\n    \n    public int compare(s o1, s o2) {\n    \tif(o1.first==o2.first&&o1.second==o2.second)return 0;\n        if(o1.first==o2.first?o1.second<o2.second:o1.first<o2.first)return -1;\n        return 1;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "def binary_search(arr, n, key):\n    l, r = 0, n-1\n    while (l <= r):\n        mid = l+r >> 1\n        if (arr[mid][0] <= key):\n            l = mid+1\n        else:\n            r = mid-1\n    return l\n\nn, d = map(int, input().split())\narr = []\nfor _ in range(n):\n    m, s = map(int, input().split())\n    arr += [(m, s)]\narr.sort()\narr_acc = [0] * (n+1)\nfor i in range(n):\n    arr_acc[i+1] = arr_acc[i] + arr[i][1]\nres = 0\nfor i in range(n):\n    key = arr[i][0]+d-1\n    j = binary_search(arr, n, key)\n    res = max(res, arr_acc[j] - arr_acc[i])\nprint(res)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, d;\n  cin >> n >> d;\n  vector<pair<int, int>> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first >> v[i].second;\n  }\n  long long int suma = 0, maxim = 0;\n  sort(v.begin(), v.end());\n  long long int start = 0, stop = 0;\n  while (stop < n) {\n    while (stop < n && v[stop].first - v[start].first + 1 <= d) {\n      suma += v[stop].second;\n      stop++;\n    }\n    maxim = max(maxim, suma);\n    suma -= v[start].second;\n    start++;\n  }\n  cout << maxim;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "a,d=map(int,input().split())\nans=[]\nfor i in range(a):\n    z=list(map(int,input().split()))\n    ans.append(z)\nans.sort(key=lambda x: (x[0],x[1]))\nl=0\nr=0\nmaxa=[]\nmi=0\ni=0\n\nwhile(l<=r and r<len(ans)):\n    if(ans[r][0]-ans[l][0]<d):\n        mi+=ans[i][1]\n        r+=1\n        i+=1\n    else:\n        maxa.append(mi)\n        l+=1\n        mi=maxa[-1]-ans[l-1][1]\nmaxa.append(mi)     \n\nprint(max(maxa))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v;\nvector<int>::iterator it;\nvector<pair<int, int> > tmp;\nint main() {\n  int n, k, x, y, id, j;\n  long long mx = -1, c[100002];\n  cin >> n >> k;\n  for (int i = 0; i < n; i++) {\n    cin >> x >> y;\n    tmp.push_back(make_pair(x, y));\n  }\n  sort(tmp.begin(), tmp.end());\n  for (int i = 0; i < n; i++) {\n    v.push_back(tmp[i].first);\n    c[i + 1] = tmp[i].second;\n  }\n  for (int i = 1; i <= n; i++) c[i] = c[i] + c[i - 1];\n  j = 0;\n  for (int i = 0; i < n; i++) {\n    while ((j < n) && v[i] + k > v[j]) {\n      j++;\n    }\n    mx = max(mx, c[j] - c[i]);\n  }\n  cout << mx;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool cmp(const vector<pair<int, int> > &a1, const pair<int, int> &a2) {\n  for (int i = 0; i < a1.size(); i++) {\n    if (a1[i] < a2) return true;\n  }\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, d, i, j, a, b;\n  cin >> n >> d;\n  vector<pair<int, int> > F;\n  long long int Ff[n];\n  for (i = 0; i < n; i++) {\n    cin >> a >> b;\n    F.push_back(pair<int, int>(a, b));\n  }\n  sort(F.begin(), F.end());\n  Ff[-1] = 0;\n  Ff[0] = F[0].second;\n  for (i = 1; i < n; i++) {\n    Ff[i] = F[i].second + Ff[i - 1];\n  }\n  int pos;\n  long long int maxi = -1;\n  for (i = 0; i < n; i++) {\n    pos = upper_bound(F.begin(), F.end(), make_pair(F[i].first + d, 0)) -\n          F.begin();\n    maxi = max(maxi, (Ff[pos - 1] - Ff[i - 1]));\n  }\n  cout << maxi << \"\\n\";\n}\n"
        },
        {
            "language": 1,
            "solution": "input = map(int, raw_input().split())\nn_friends = input[0]\nmin_diff = input[1]\n\nfriends = []\nfor i in xrange(n_friends):\n\tinput_friend = map(int, raw_input().split())\n\tfriends.append({'m': input_friend[0], 'f':input_friend[1]})\n\nfriends.sort(key = lambda obj: obj['m'])\n\nj = 0\nmaxi = 0\ncurrent = 0\nfor i in xrange(n_friends):\n\tcurrent += friends[i]['f']\n\twhile j < i and (friends[i]['m'] - friends[j]['m'] >= min_diff):\n\t\tcurrent -= friends[j]['f']\n\t\tj += 1\n\tmaxi = max(maxi, current)\nprint maxi\n"
        },
        {
            "language": 3,
            "solution": "def ans(f,n,d):\n    if n == 1:\n        return f[0][1]\n    ans = f[0][1]\n    tmp_ans = f[0][1]\n    i = 0\n    j = 1\n    while j < n:\n        if i == j:\n            tmp_ans = f[j][1]\n            j += 1\n            if tmp_ans > ans:\n                ans = tmp_ans\n        elif abs(f[i][0]-f[j][0]) < d:\n            tmp_ans += f[j][1]\n            j+=1\n            if tmp_ans > ans:\n                ans = tmp_ans\n        else:\n            while abs(f[i][0]-f[j][0]) >= d and i < j:\n                tmp_ans-=f[i][1]\n                i+=1\n    return ans\n\nn,d = map(int,input().split())\nfriends = []\nfor _ in range(n):\n    tmp = [int(i) for i in input().split()]\n    friends.append(tmp)\nfriends.sort()\nprint(ans(friends,n,d))"
        },
        {
            "language": 1,
            "solution": "n,d = map(int,raw_input().split())\nf=[]\nfor i in range(n):\n    f.append(map(int,raw_input().split()))\nf.sort()\npre=[f[0][1]]\nfor i in range(1,n):\n    pre.append(pre[-1]+f[i][1])\n# print pre\nans=0\n# print f\nfor i in range(n):\n    lo=i\n    hi = n\n    while(hi>lo):\n        mid = (lo+hi)/2\n        if f[mid][0]>=(f[i][0]+d):\n            hi = mid\n        else:\n            lo = mid+1\n    ans=max(ans,pre[lo-1]-pre[i]+f[i][1])\nprint ans\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, d, x, y, i = 0, j = 0;\n  long long unsigned f = 0, maxx = 0;\n  cin >> n >> d;\n  vector<pair<int, int> > arr;\n  for (i = 0; i < n; i++) {\n    cin >> x >> y;\n    arr.push_back(make_pair(x, y));\n  }\n  sort(arr.begin(), arr.end());\n  for (i = 0; i < n; i++) {\n    if (arr[i].first - arr[j].first >= d) {\n      maxx = max(maxx, f);\n      while (arr[i].first - arr[j].first >= d) {\n        f -= arr[j].second;\n        j++;\n      }\n    }\n    f += arr[i].second;\n  }\n  maxx = max(maxx, f);\n  cout << maxx;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,k = map(int,input().split())\na = [list(map(int,input().split())) for _ in range(n)]\na.sort()\ns = 0\nans = 0\nr = 0\nfor l in range(n):\n    while r<n and a[r][0]-a[l][0]<k:\n        s+=a[r][1]\n        r+=1\n    ans=max(ans,s)\n    s-=a[l][1]\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "def sol(f,n,d):\n    i,j,ans,tmp_ans = 0,0,0,0\n    while i < n:\n        if f[i][0] - f[j][0] < d:\n            tmp_ans+=f[i][1]\n            i+=1\n            if ans < tmp_ans:\n                ans = tmp_ans\n        else:\n            while f[i][0] - f[j][0] >= d:\n                tmp_ans-=f[j][1]\n                j+=1\n    if ans < tmp_ans:\n        ans = tmp_ans\n    return ans\n\nn,d = map(int,input().split())\nfriends = []\nfor _ in range(n):\n    m,s = map(int,input().split())\n    friends.append([m,s])\nfriends.sort()\nprint(sol(friends,n,d))\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nlis1 = []\n#lis2 = []\nfor i in range(n):\n\tm, f = map(int, input().split())\n\tlis1.append([m, f])\nlis1.sort()\n#lis1.append([1e10, 1e10])\nans = []\nfor i in range(1, len(lis1)):\n\tlis1[i][1] += lis1[i - 1][1]\nfor i in range(len(lis1)):\n\t#cnt = lis1[i][1]\n\tlo, hi = i + 1, len(lis1) - 1\n\tidx = i \n\twhile lo <= hi:\n\t\tmid = lo + (hi - lo) // 2 \n\t\tif lis1[mid][0] - lis1[i][0] < d:\n\t\t\tidx = mid \n\t\t\tlo = mid + 1 \n\t\telse:\n\t\t\thi = mid - 1\n\tif i != 0:\n\t\tans.append(abs(lis1[idx][1] - lis1[i - 1][1]))\n\telse:\n\t\tans.append(lis1[idx][1])\nprint(max(ans))"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout\nlines = stdin.readlines()\nn, d = int(lines[0].split()[0]), int(lines[0].split()[1])\nmat = [[int(x.split()[0]),int(x.split()[1])]  for x in lines[1:]]\nmat = sorted(mat)\n\nmx = 0\ntemp_mx = 0\ni = 0\n\nfor j in range(n):\n    temp_mx += mat[j][1]\n\n    if (mat[j][0] - mat[i][0])>=d:\n        while (mat[j][0] - mat[i][0]) >= d:\n            temp_mx -= mat[i][1]\n            i += 1\n\n    mx=max(mx,temp_mx)\nprint(mx)\n    "
        },
        {
            "language": 3,
            "solution": "def solve():\n    n, d = map(int, input().split())\n\n    friends = [list(map(int, input().split())) for _ in range(n)]\n    friends = sorted(friends, key=lambda f: f[0])\n\n    friendship = 0\n    max_friendship = friendship\n\n    i = 0\n\n    for j in range(n):\n        friendship += friends[j][1]\n\n        while friends[j][0] - friends[i][0] >= d:\n            friendship -= friends[i][1]\n            i += 1\n\n        max_friendship = max(max_friendship, friendship)\n\n    print(max_friendship)\n\nif __name__ == \"__main__\":\n    solve()\n"
        },
        {
            "language": 3,
            "solution": "def solve(n,d,friends):\n    big = float('inf')\n    small = float('-inf')\n    friends.sort()\n    maxer = small\n\n    # two pointers\n    f = 0\n    s = 0 \n    ind = 0        \n    # print(\"#\",friends)\n    curr = 0\n    while(ind < n):      \n        last = 0        \n        miner = friends[s][0]\n        while(s < n and abs(friends[ind][0] - friends[s][0]) >= d):\n            # last += friends[s][1]   \n            curr -= friends[s][1]  \n            s += 1               \n            miner = friends[s][0]     \n        # print(\"$\",s)\n        flag = True\n        while(ind < n and abs(friends[ind][0] - miner) < d):\n            curr += friends[ind][1]\n            ind += 1\n            flag = False        \n        if flag:            \n            curr += friends[ind][1] + last\n            ind += 1\n        # print(ind,curr,maxer,last)\n        maxer = max(maxer,curr - last)\n    return maxer\n    \ndef main():\n    # t = int(input())    \n    # for i in range(t):\n    # n = int(input())\n    d = input()\n    d = [int(i) for i in d.split()]\n    a = d[0]\n    b = d[1]\n    friends = []\n    for i in range(a):\n        d = input()\n        d = [int(i) for i in d.split()]\n        m = d[0]\n        f = d[1]\n        friends.append((m,f))   \n    # c = d[2]\n    # e = d[4]        \n    # e = input()\n    # e = [int(i) for i in e.split()]  \n    ans = solve(a,b,friends)\n    print(ans)     \n    # for i in ans:\n    #     print(i,end = \"\")\n    # print()  \nmain()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing lli = long long int;\nvoid solve() {\n  int n, d;\n  cin >> n >> d;\n  vector<pair<lli, lli>> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first >> v[i].second;\n  }\n  sort(v.begin(), v.end());\n  cout << endl;\n  lli ans = 0, var = 0;\n  int i = 0, j = 0;\n  while (i < n && j < n) {\n    if (v[i].first + d > v[j].first) {\n      var += v[j++].second;\n    } else {\n      ans = max(ans, var);\n      var -= v[i++].second;\n    }\n  }\n  ans = max(ans, var);\n  cout << ans << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n,d = map(int,raw_input().split())\nvals = []\nfor i in xrange(n):\n    x,y = map(int,raw_input().split())\n    vals.append((x,y))\n\nvals = sorted(vals)\n\nmx = vals[0][1] \nsm = vals[0][1] \ni = 1 \nj = 0\nwhile i < n:\n    if vals[i][0] - vals[j][0] < d: \n        sm = sm + vals[i][1]\n    else:\n        mx = max(sm,mx)\n        while vals[i][0] - vals[j][0] >= d:\n            sm = sm - vals[j][1]\n            j += 1\n        sm = sm + vals[i][1]\n    i += 1\nmx = max(sm,mx)\nprint mx\n\n"
        },
        {
            "language": 4,
            "solution": "import javafx.util.Pair;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Main {\n    private final static InputReader ir = new InputReader(System.in);\n    private final static OutputWriter ow = new OutputWriter(System.out);\n    private final static int INF = Integer.MAX_VALUE;\n    private final static int NINF = Integer.MIN_VALUE;\n    private final static double PI = Math.PI;\n\n    public static void main(String[] args) throws IOException {\n        try {\n            task();\n        } finally {\n            boolean exc = false;\n            try {\n                ir.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n                exc = true;\n            }\n            try {\n                ow.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n                exc = true;\n            }\n            if (exc) System.exit(1);\n        }\n    }\n\n    private static int lowerBound(int key, ArrayList<Pair<Integer, Integer>> list) {\n        int lo = 0;\n        int hi = list.size() - 1;\n\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            int val = list.get(mid).getKey();\n            if (val < key) {\n                lo = mid + 1;\n            } else if (val >= key) {\n                if (mid - 1 < 0 || list.get(mid - 1).getKey() < key)\n                    return mid;\n                else hi = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    private static int upperBound(int key, ArrayList<Pair<Integer, Integer>> list) {\n        int lo = 0;\n        int hi = list.size() - 1;\n\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            int val = list.get(mid).getKey();\n            if (val <= key) {\n                if (mid + 1 >= list.size() || list.get(mid + 1).getKey() > key)\n                    return mid;\n                else lo = mid + 1;\n            } else if (val > key) {\n                hi = mid - 1;\n            } else return mid;\n        }\n        return -1;\n    }\n\n\n    private static void task() throws IOException {\n        int n = ir.nextInt(), d = ir.nextInt();\n        ArrayList<Pair<Integer, Integer>> friends = new ArrayList<>(n);\n        for (int i = 0; i < n; ++i) {\n            friends.add(new Pair<>(ir.nextInt(), ir.nextInt()));\n        }\n\n        friends.sort(Comparator.comparing(Pair::getKey));\n        long[] sum = new long[n];\n        sum[0] = friends.get(0).getValue();\n\n        for (int i = 1; i < n; ++i) {\n            sum[i] = sum[i - 1] + friends.get(i).getValue();\n        }\n\n        long ans = 0;\n\n        for (int i = 0; i < n; ++i) {\n            int lo = friends.get(i).getKey();\n            int hi = friends.get(i).getKey() + d - 1;\n\n            int il = lowerBound(lo, friends);\n            int ih = upperBound(hi, friends);\n\n            long s;\n            if (il > 0)\n                s = sum[ih] - sum[il - 1];\n            else s = sum[ih];\n\n            if (s > ans) ans = s;\n        }\n\n        ow.print(ans);\n    }\n\n    private static int max(int... objects) {\n        if (objects.length == 0)\n            throw new IllegalArgumentException(\"objects.length == 0\");\n        int max = objects[0];\n        for (int i = 1; i < objects.length; ++i) {\n            if (max < objects[i])\n                max = objects[i];\n        }\n        return max;\n    }\n\n    private static int min(int... objects) {\n        if (objects.length == 0)\n            throw new IllegalArgumentException(\"objects.length == 0\");\n        int min = objects[0];\n        for (int i = 1; i < objects.length; ++i) {\n            if (min > objects[i])\n                min = objects[i];\n        }\n        return min;\n    }\n\n    private static long pow(int x, int n) {\n        if (x == 0) return 0;\n        if (x == 1 || n == 0) return 1;\n        if (x == 2) return x << (n - 1);\n        if (n == 1) return x;\n        long t = pow(x, n / 2);\n        if (n % 2 == 0) return t * t;\n        else return t * t * x;\n    }\n\n    private static double pow(double x, int n) {\n        if (x == 0.0) return 0;\n        if (x == 1.0 || n == 0) return 1;\n        if (n == 1) return x;\n        double t = pow(x, n / 2);\n        if (n % 2 == 0) return t * t;\n        else return t * t * x;\n    }\n\n    private static int abs(int a) {\n        return (a >= 0 ? a : -a);\n    }\n}\n\nclass SQRTDecomposition {\n    private int[] array;\n    private int len;\n    private int[] max;\n    private int[] min;\n\n    public SQRTDecomposition(int[] arr, boolean useIt) {\n        if (useIt)\n            array = arr;\n        else {\n            array = new int[arr.length];\n            System.arraycopy(arr, 0, array, 0, arr.length);\n        }\n        len = (int) Math.sqrt(array.length) + 1;\n        max = new int[len];\n        min = new int[len];\n        for (int i = 0; i < array.length; ++i) {\n            max[i / len] = min[i / len] = array[i];\n        }\n        for (int i = 0; i < array.length; ++i) {\n            max[i / len] = Math.max(max[i / len], array[i]);\n            min[i / len] = Math.min(min[i / len], array[i]);\n        }\n    }\n\n    public int get(int i) {\n        if (i <= 0 || i >= array.length)\n            throw new IndexOutOfBoundsException(\"Index: \" + i);\n        return array[i];\n    }\n\n    public int length() {\n        return array.length;\n    }\n\n    public int max(int l, int r) {\n        int cl = l / len, cr = r / len;\n        int m = array[l];\n        if (cl == cr) {\n            for (int i = l; i <= r; ++i) {\n                if (array[i] > m) m = array[i];\n            }\n        } else {\n            for (int i = l, end = (cl + 1) * len - 1; i <= end; ++i)\n                if (array[i] > m) m = array[i];\n            for (int i = cl + 1; i <= cr - 1; ++i)\n                if (max[i] > m) m = max[i];\n            for (int i = cr * len; i <= r; ++i)\n                if (array[i] > m) m = array[i];\n        }\n        return m;\n    }\n\n    public int min(int l, int r) {\n        int cl = l / len, cr = r / len;\n        int m = array[l];\n        if (cl == cr) {\n            for (int i = l; i <= r; ++i) {\n                if (array[i] < m) m = array[i];\n            }\n        } else {\n            for (int i = l, end = (cl + 1) * len - 1; i <= end; ++i)\n                if (array[i] < m) m = array[i];\n            for (int i = cl + 1; i <= cr - 1; ++i)\n                if (min[i] < m) m = min[i];\n            for (int i = cr * len; i <= r; ++i)\n                if (array[i] < m) m = array[i];\n        }\n        return m;\n    }\n}\n\nclass InputReader implements AutoCloseable {\n    private final InputStream in;\n    private int capacity;\n    private byte[] buffer;\n    private int len = 0;\n    private int cur = 0;\n\n    public InputReader(InputStream stream) {\n        this(stream, 100_000);\n    }\n\n    public InputReader(InputStream stream, int capacity) {\n        this.in = stream;\n        this.capacity = capacity;\n        buffer = new byte[capacity];\n    }\n\n    private boolean update() {\n        if (cur >= len) {\n            try {\n                cur = 0;\n                len = in.read(buffer, 0, capacity);\n                if (len <= 0)\n                    return false;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n        return true;\n    }\n\n    private int read() {\n        if (update())\n            return buffer[cur++];\n        else return -1;\n    }\n\n    public boolean isEmpty() {\n        return !update();\n    }\n\n    private boolean isSpace(int c) {\n        return c == '\\n' || c == '\\t' || c == '\\r' || c == ' ';\n    }\n\n    private boolean isEscape(int c) {\n        return c == '\\n' || c == '\\t' || c == '\\r' || c == -1;\n    }\n\n    private int readSkipSpace() {\n        int c;\n        do {\n            c = read();\n        } while (isSpace(c));\n        return c;\n    }\n\n    public int nextInt() {\n        int c = readSkipSpace();\n        if (c < 0)\n            throw new InputMismatchException();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c == -1) break;\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res = res * 10 + c - '0';\n            if (res < 0)\n                throw new InputMismatchException();\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    public int[] getAllInts() {\n        List<Integer> list = new LinkedList<>();\n        while (true) {\n            try {\n                int t = nextInt();\n                list.add(t);\n            } catch (InputMismatchException e) {\n                break;\n            }\n        }\n        int[] a = new int[list.size()];\n        Iterator<Integer> it = list.iterator();\n        for (int i = 0; it.hasNext(); ++i)\n            a[i] = it.next();\n        return a;\n    }\n\n    public int[] getIntArray1D(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; ++i) {\n            array[i] = nextInt();\n        }\n        return array;\n    }\n\n    public int[][] getIntArray2D(int n, int m) {\n        int[][] array = new int[n][m];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j)\n                array[i][j] = nextInt();\n        }\n        return array;\n    }\n\n    public long nextLong() {\n        int c = readSkipSpace();\n        if (c < 0)\n            throw new InputMismatchException();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c == -1) break;\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res = res * 10 + c - '0';\n            if (res < 0)\n                throw new InputMismatchException();\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    public long[] getAllLongs() {\n        List<Long> list = new LinkedList<>();\n        while (true) {\n            try {\n                long t = nextLong();\n                list.add(t);\n            } catch (InputMismatchException e) {\n                break;\n            }\n        }\n        long[] a = new long[list.size()];\n        Iterator<Long> it = list.iterator();\n        for (int i = 0; it.hasNext(); ++i)\n            a[i] = it.next();\n        return a;\n    }\n\n    public long[] getLongArray1D(int n) {\n        long[] array = new long[n];\n        for (int i = 0; i < n; ++i) {\n            array[i] = nextLong();\n        }\n        return array;\n    }\n\n    public long[][] getLongArray2D(int n, int m) {\n        long[][] array = new long[n][m];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j)\n                array[i][j] = nextLong();\n        }\n        return array;\n    }\n\n    public int nextChar() {\n        int c = readSkipSpace();\n        if (c < 0)\n            throw new InputMismatchException();\n        return c;\n    }\n\n    public String nextLine(int initialCapacity) {\n        StringBuilder res = new StringBuilder(initialCapacity);\n        int c = readSkipSpace();\n        do {\n            res.append((char) (c));\n            c = read();\n        } while (!isEscape(c));\n        return res.toString();\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n}\n\nclass OutputWriter implements Flushable, AutoCloseable {\n    private byte[] buf;\n    private final int capacity;\n    private int count;\n    private OutputStream out;\n\n    public OutputWriter(OutputStream stream) {\n        this(stream, 10_000);\n    }\n\n    public OutputWriter(OutputStream stream, int capacity) {\n        if (capacity < 0)\n            throw new IllegalArgumentException(\"capacity < 0\");\n        out = stream;\n        this.capacity = capacity;\n        if (capacity != 0) {\n            buf = new byte[capacity];\n        }\n    }\n\n    public void write(int b) throws IOException {\n        if (capacity != 0) {\n            if (count >= capacity)\n                flushBuffer();\n            buf[count++] = (byte) b;\n        } else {\n            out.write(b);\n        }\n    }\n\n    public void write(byte[] bytes, int off, int len) throws IOException {\n        if (capacity != 0) {\n            if (len >= capacity) {\n                flushBuffer();\n                out.write(bytes, off, len);\n                return;\n            }\n            if (len > capacity - count)\n                flushBuffer();\n            System.arraycopy(bytes, off, buf, count, len);\n            count += len;\n        } else out.write(bytes, off, len);\n    }\n\n    public void write(byte[] bytes) throws IOException {\n        write(bytes, 0, bytes.length);\n    }\n\n    public void println() throws IOException {\n        print(\"\\n\");\n    }\n\n    public void print(Object object) throws IOException {\n        write(String.valueOf(object).getBytes());\n    }\n\n    public void println(Object object) throws IOException {\n        print(object);\n        println();\n    }\n\n    public void print(int... ints) throws IOException {\n        print(\" \", ints);\n    }\n\n    public void println(int... ints) throws IOException {\n        print(ints);\n        println();\n    }\n\n    public void println(String separator, int... ints) throws IOException {\n        print(separator, ints);\n        println();\n    }\n\n    public void print(String separator, int... ints) throws IOException {\n        if (ints.length == 0) throw new IllegalArgumentException(\"ints.length == 0\");\n        for (int i = 0; i < ints.length; ++i) {\n            if (i != 0) print(separator);\n            print(ints[i]);\n        }\n    }\n\n    private void flushBuffer() throws IOException {\n        if (count > 0) {\n            out.write(buf, 0, count);\n            count = 0;\n        }\n    }\n\n    @Override\n    public void flush() throws IOException {\n        flushBuffer();\n        out.flush();\n    }\n\n    @Override\n    public void close() throws IOException {\n        flush();\n        out.close();\n    }\n}\n/*\nclass InputReader implements AutoCloseable {\n    private final InputStream in;\n    private int capacity;\n    private byte[] buffer;\n    private int len = 0;\n    private int cur = 0;\n\n    public InputReader(InputStream stream) {\n        this(stream, 100_000);\n    }\n\n    public InputReader(InputStream stream, int capacity) {\n        this.in = stream;\n        this.capacity = capacity;\n        buffer = new byte[capacity];\n    }\n\n    private int read() {\n        if (cur >= len) {\n            try {\n                cur = 0;\n                len = in.read(buffer, 0, capacity);\n                if (len <= 0)\n                    return -1;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n        return buffer[cur++];\n    }\n\n    private boolean isSpace(int c) {\n        return c == ' ' || isEscape(c);\n    }\n\n    private boolean isEscape(int c) {\n        return c == '\\n' || c == '\\t' || c == '\\r' || c == -1;\n    }\n\n    private int readSkipSpace() {\n        int c;\n        do {\n            c = read();\n        } while (isSpace(c));\n        return c;\n    }\n\n    int nextInt() {\n        int c = readSkipSpace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res = res * 10 + c - '0';\n            if (res < 0)\n                throw new InputMismatchException();\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    public long nextLong() {\n        int c = readSkipSpace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res = res * 10 + c - '0';\n            if (res < 0)\n                throw new InputMismatchException();\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    int nextChar() {\n        return readSkipSpace();\n    }\n\n    String nextLine(int initialCapacity) {\n        StringBuilder res = new StringBuilder(initialCapacity);\n        int c = readSkipSpace();\n        do {\n            res.append((char) (c));\n            c = read();\n        } while (!isEscape(c));\n        return res.toString();\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n}\n\nclass OutputWriter implements Flushable, AutoCloseable {\n    private byte[] buf;\n    private int capacity;\n    private int count;\n    private OutputStream out;\n\n    public OutputWriter(OutputStream stream) {\n        out = stream;\n        capacity = 10_000;\n        buf = new byte[capacity];\n    }\n\n    public OutputWriter(OutputStream stream, int capacity) {\n        if (capacity <= 0)\n            throw new IllegalArgumentException(\"capacity <= 0\");\n        out = stream;\n        this.capacity = capacity;\n        buf = new byte[capacity];\n    }\n\n    public void write(int b) throws IOException {\n        if (count >= buf.length)\n            flushBuffer();\n        buf[count++] = (byte) b;\n    }\n\n    public void write(byte[] bytes, int off, int len) throws IOException {\n        if (len >= buf.length) {\n            flushBuffer();\n            out.write(bytes, off, len);\n            return;\n        }\n        if (len > buf.length - count)\n            flushBuffer();\n        System.arraycopy(bytes, off, buf, count, len);\n        count += len;\n    }\n\n    public void write(byte[] bytes) throws IOException {\n        write(bytes, 0, bytes.length);\n    }\n\n    public void print(String str) throws IOException {\n        write(str.getBytes());\n    }\n\n    public void println() throws IOException {\n        print(\"\\n\");\n    }\n\n    public void print(Object object) throws IOException {\n        print(object.toString());\n    }\n\n    public void println(Object object) throws IOException {\n        print(object.toString());\n        println();\n    }\n\n    public void print(int... ints) throws IOException {\n        print(\" \", ints);\n    }\n\n    public void println(int... ints) throws IOException {\n        print(ints);\n        println();\n    }\n\n    public void println(String separator, int... ints) throws IOException {\n        print(separator, ints);\n        println();\n    }\n\n    public void print(String separator, int... ints) throws IOException {\n        if (ints.length == 0) throw new IllegalArgumentException(\"ints.length == 0\");\n        for (int i = 0; i < ints.length; ++i) {\n            if (i != 0) print(separator);\n            print(ints[i]);\n        }\n    }\n\n    private void flushBuffer() throws IOException {\n        if (count > 0) {\n            out.write(buf, 0, count);\n            count = 0;\n        }\n    }\n\n    @Override\n    public void flush() throws IOException {\n        flushBuffer();\n        out.flush();\n    }\n\n    @Override\n    public void close() throws IOException {\n        flush();\n        out.close();\n    }\n}\n\n*/\n\n\n"
        },
        {
            "language": 3,
            "solution": "# \ufffd\ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd!!!!!!\n\n# \ufffd\ufffd\ufffd\ufffd\n# \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd(logn * n)\n# \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n# \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n# \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\n#\n#\n# \ufffd\ufffd\ufffd \ufffd\ufffd\ufffd????\n# \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd!!!\n# \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd??????\n# \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n# \ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd \ufffd(1) !!!!\n\nn, d = tuple(map(int, input().split()))\nm, s = [0] * n, [0] * n\nms = [0] * n\nfor i in range(n):\n    m[i], s[i] = tuple(map(int, input().split()))\n    ms[i] = m[i], s[i]\n    \nsuffix = [0] * n\npostfix = [0] * n\nalsum = sum(s)\nms.sort()\nfor i in range(1, n):\n    postfix[i] = postfix[i - 1] + ms[i - 1][1]\n    \nfor i in range(n - 2, -1, -1):\n    suffix[i] = suffix[i + 1] + ms[i + 1][1]\n\nfriends = []\nfor i in range(n):\n    # \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n    left = i - 1\n    right = n - 1\n    while right - left > 1:\n        middle = (right + left) // 2\n        if ms[middle][0] >= ms[i][0] + d:\n            right = middle\n        else:\n            left = middle\n    rich = right\n    if ms[rich][0] >= ms[i][0] + d: rich -= 1\n    #print(rich)\n    friends.append(alsum - postfix[i] - suffix[rich])\n    \nprint(max(friends))\n    \n        \n    "
        },
        {
            "language": 1,
            "solution": "# n = 4\n# d = 5\n# a = sorted([(75,5),(0,100),(150,20),(75,1)])\n# n = 5\n# d = 100\n# a = sorted([(0,7),(11,32),(99,10),(46,8),(87,54)])\n# n = 5\n# d = 1\n# a = sorted([(5,9),(2,10),(8,5),(18,12),(1,1)])\n\nn, d = map(int, raw_input().split())\na0 = []\nfor i in range(n):\n    a0.append(map(int, raw_input().split()))\na = sorted([tuple(x) for x in a0])\n\n#a0 = map(int, raw_input().split())\n#a = sorted(zip(*2*[iter(a0)]))\n\nx = 0\nfriends = 0\nz = []\nfor i in range(n):\n    friends+=a[i][1]\n    while a[i][0]-a[x][0] >= d:\n        #friends += a[i][1]\n        friends -= a[x][1]\n        x+=1\n    z.append(friends)\nprint max(z)\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class kefaAndCompany {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), d = sc.nextInt();\n\t\tfriend f[] = new friend[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = new friend(sc.nextInt(), sc.nextInt());\n\t\t}\n\t\tArrays.sort(f);\n\t\tint start = 0;\n\t\tlong sum = f[0].ff, ans = 0;\n\t\tfor (int i = 1; i < n;) {\n\t\t\tif ((f[i].m - f[start].m) < d) {\n\t\t\t\tsum += f[i].ff;\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tans = Long.max(ans, sum);\n\t\t\t\tsum -= f[start++].ff;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(Long.max(ans, sum));\n\t\tsc.close();\n\n\t}\n}\n\nclass friend implements Comparable<friend> {\n\tint m, ff;\n\n\tfriend(int m, int f) {\n\t\tthis.m = m;\n\t\tff = f;\n\t}\n\n\t@Override\n\tpublic int compareTo(friend o) {\n\t\tif (m == o.m) {\n\t\t\treturn ff - o.ff;\n\t\t}\n\t\treturn m - o.m;\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "def bs(a,s,f,k,d):\n    l = s\n    r = f\n    while(r - l > 1):\n        m = (r + l)>>1\n        if k <= a[m][0] - d:\n            r = m\n        else:\n            l = m\n    res = l\n    if k > a[r][0] - d: res = r\n    return res\nR = lambda : map(int, raw_input().split())\nn,d = R()\nls = []\ni = 0\nwhile i < n:\n    ls.append(R())\n    i = i + 1\nls.sort(key=lambda x: x[0])\ndp = [0]\nfor x in ls:\n    dp.append(dp[-1] + x[1])\nansmax = 0\ni = 0\nwhile i < n:\n    index = bs(ls,i,n-1,ls[i][0],d)\n    ansmax = max(ansmax,dp[index + 1] - dp[i])\n    i = i + 1\nprint ansmax\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\n\nclass Solution:\n    def max_friendship_factor(self, money_diff, friends_data):\n\n        friends_data = sorted(friends_data, key=lambda f: f[0])\n\n        factors = [friends_data[0][1]]\n        for i in range(1, len(friends_data)):\n            factors.append(factors[i-1] + friends_data[i][1])\n\n        ff_max, j = 0, len(friends_data) - 1\n        for i in range(len(friends_data) - 1, -1, -1):\n\n            while j > 0 and friends_data[j][0] - friends_data[i][0] >= money_diff:\n                j -= 1\n\n            ff = factors[j]\n            if i > 0:\n                ff -= factors[i - 1]\n\n            if ff > ff_max:\n                ff_max = ff\n\n        return ff_max\n\n\ndef main():\n    inp = sys.stdin.readline()\n    friends, money_diff = list(map(int, inp.split()))\n    friends_data = []\n    while friends > 0:\n        inp = sys.stdin.readline()\n        friends_data.append(list(map(int, inp.split())))\n        friends -= 1\n    print(Solution().max_friendship_factor(money_diff, friends_data))\n\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 1,
            "solution": "import threading\nimport sys\nimport bisect\n\ninp = raw_input().split()\nn, d = int(inp[0]), int(inp[1])\n\nms = []\nfor i in range(n):\n    inp = raw_input().split()\n    ms.append((int(inp[0]), int(inp[1])))\n\n\ndef main(ms, d):\n    ms.sort(key=lambda tup: tup[0])\n\n    l = 0\n    r = 1\n    mx = 0\n    cur_mx = ms[0][1]\n\n    if len(ms) == 1:\n        print ms[0][1]\n        return\n\n    while l <= len(ms) - 1 and r <= len(ms) - 1:\n        # print \"l r =\", l, r\n        if ms[r][0] - ms[l][0] < d:\n            cur_mx += ms[r][1]  # candidate for mx += sum of r and l\n\n            r += 1\n\n        else:  # if r[0]-l[0] >= d, moving l forward\n            if ms[l][1] > mx:\n                mx = ms[l][1]\n            cur_mx -= ms[l][1]\n            l += 1\n\n        # if cur_mx > mx:\n        #     mx = cur_mx\n        # print\n        if cur_mx > mx:\n            mx = cur_mx\n\n    print mx\n\nsys.setrecursionlimit(1000000)\nthreading.stack_size(102400000)\nthread = threading.Thread(target=main, args=(ms, d))\nthread.start()\n"
        },
        {
            "language": 1,
            "solution": "I=raw_input\nn,d = map(int, raw_input().split())\na = sorted([map(int,raw_input().split()) for _ in xrange(n)], cmp = lambda x, y: cmp(x[0], y[0]))\np, q, ans, buff = [0]*4\nfor p in xrange(len(a)):\n\twhile q < len(a) and a[p][0] + d > a[q][0]:\n\t\tbuff += a[q][1]\n\t\tq += 1\n\tans = max (ans, buff)\n\tbuff -= a[p][1]\nprint ans\n\n\t  \t \t  \t\t  \t\t\t \t    \t \t\t\t \t \t\t"
        },
        {
            "language": 1,
            "solution": "from operator import itemgetter\n\nargs = str(raw_input()).split(\" \")\n\nn = int(args[0])\nd = int(args[1])\n\ndescs = []\nfor i in range(n):\n\tdesc = str(raw_input()).split(\" \")\n\tx = (int(desc[0]), int(desc[1]))\n\tdescs.append(x)\n\ndescs = sorted(descs, key=itemgetter(0), reverse=True)\n\nmoney = -1\nmaxFactor = 0\nfactors = [0 for i in range(n)]\ncount = 1\n\nfor i in range(n):\n\n\tif (i == 0):\n\t\tmaxFactor = descs[i][1]\n\telse:\n\t\tmaxFactor = factors[i-1]-descs[i-1][1]\n\t\tif (maxFactor == 0):\n\t\t\tmaxFactor = descs[i][1]\n\n\tif (count <= i):\n\t\tcount = i+1\n\n\twhile (count < n and abs(descs[i][0]-descs[count][0]) < d):\n\t\tmaxFactor += descs[count][1]\n\t\tcount += 1\n\t\n\tfactors[i] = maxFactor\n\tif (count == n):\n\t\tbreak\n\nprint(max(factors))\n\n\n\n\n"
        },
        {
            "language": 1,
            "solution": "n, d = [int(x) for x in raw_input().split()]\n\nfriends = []\nfor i in range(n):\n\tfriends.append(tuple([int(x) for x in raw_input().split()]))\n\nfriends.sort(key = lambda p : p[0])\nmaxF = curF = friends[0][1]\nbeg = end = 0\n\nmaxM = friends[0][0] + d\n\nfor i in range(1, n):\n\tend += 1\n\tcurF += friends[i][1]\n\tif friends[i][0] >= maxM:\n\t\tfor j in range(beg, i):\n\t\t\tif friends[i][0] < (friends[j][0] + d):\n\t\t\t\tbreak\n\t\t\telse:\t\n\t\t\t\tcurF -= friends[beg][1]\n\t\t\t\tbeg += 1\n\t\t\t\tmaxM = friends[beg][0] + d\n\n\tif curF > maxF:\n\t\tmaxF = curF\n\nprint maxF\n\n\t\t\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, m, one, two;\n  cin >> n >> m;\n  vector<pair<int, int> > V;\n  pair<int, int> P;\n  for (int i = 0; i < n; i++) {\n    cin >> P.first;\n    cin >> P.second;\n    V.push_back(P);\n  }\n  sort(V.begin(), V.end());\n  int i = 0, j = 0;\n  long long sum = 0, ans = 0;\n  for (i = 0; i < n; i++) {\n    if (abs(V[i].first - V[j].first) >= m) {\n      ans = max(ans, sum);\n      sum -= V[j].second;\n      j++;\n      i--;\n    } else {\n      sum += V[i].second;\n    }\n  }\n  ans = max(ans, sum);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\n\narray = []\nindex, left, current = 0, 0, 0\nresult = 0\n\nfor i in range(n):\n    m, s = map(int, raw_input().split())\n    array.append((m, s))\n\narray.sort(key=lambda x: x[0])\n\nwhile index < len(array):\n    money, factor = array[index]\n    diff = abs(array[left][0] - money)\n\n    if diff < d:\n        index += 1\n        current += factor\n    else:\n        result = max(result, current)\n        current -= array[left][1]\n        left += 1\n\nresult = max(result, current)\nprint(result)\n"
        },
        {
            "language": 3,
            "solution": "I = lambda :map(int, input().split())\n\nn,d=I()\n\na=sorted([list(I()) for i in range(n)])\n\ns=ans=a[0][1]\n\nj=0\n\nfor i in range(1,n):\n\n    while(a[i][0]-a[j][0]>=d):\n\n        s-=a[j][1]\n\n        j+=1\n\n    s+=a[i][1]\n\n    ans=max(s,ans)\n\n\n\nprint(ans)\n\n\n\n# Made By Mostafa_Khaled"
        },
        {
            "language": 3,
            "solution": "n,f = input().split()\nn = int(n)\nf = int(f)\na = []\nfor i in range(n):\n    x,y = input().split()\n    a.append((int(x),int(y)))\n\na = sorted(a)\ns = a[0][1]\nmx = s\nk = 0\nfor i in range(1,len(a)):\n    if a[i][0] - a[k][0] < f:\n        s = s + a[i][1]\n    else:\n        s = s - a[k][1] + a[i][1]\n        for j in range(k+1,i+1):\n            if a[i][0] - a[j][0]<f:\n                s = s\n                k = j\n                break\n            else:\n                s = s - a[j][1]\n                k = j\n    \n    if s>mx:\n        mx = s\n\nprint (mx)\n\n\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "from collections import OrderedDict\nn,d = map(int,input().split())\n\na = dict()\nfor _ in range(n):\n    m,s = map(int,input().split())\n    if m in a:\n        a[m] += s\n    else:\n        a[m] = s\n\na = OrderedDict(sorted(a.items()))\na = [item for item in a.items()]\n\nk = 0 #starting element\nsu = 0 #current sum\nmu = 0 #current maximum friendship\nfor i in range(len(a)):\n    su += a[i][1]\n    while a[i][0] - a[k][0] >= d:\n        su -= a[k][1]\n        k += 1\n    mu = max(mu,su)\n\nprint(mu)"
        },
        {
            "language": 1,
            "solution": "inputs = [int(i) for i in raw_input().split()]\nn = inputs[0]\nd = inputs[1]\nfriends = []\nfor i in range(n):\n    friend = [int(i) for i in raw_input().split()]\n    friends.append((friend[0], friend[1]))\nfriends.sort(key = lambda x: x[0])\nmax_friendship = 0\nfriendship = 0\nr = 0\nfor l in range(n):\n    if l > 0:\n        friendship -= friends[l - 1][1]\n    while r < n and abs(friends[r][0] - friends[l][0]) < d:\n        friendship += friends[r][1]\n        r += 1\n    if friendship > max_friendship:\n        max_friendship = friendship\nprint max_friendship\n"
        },
        {
            "language": 3,
            "solution": "scan = lambda: map(int, input().split())\nn, d = scan()\narr = []\nfor i in range(n):\n    m, r = scan()\n    arr.append([m, r])\narr.sort()\np1, p2 = 0, 1\ntmp = arr[0][1]\nans = tmp\nwhile p1<n:\n    while p2<n and arr[p2][0]-arr[p1][0]<d:\n        tmp += arr[p2][1]\n        p2 += 1\n    ans = max(tmp, ans)\n    tmp -= arr[p1][1]\n    p1 +=1\nprint(ans)"
        },
        {
            "language": 1,
            "solution": "n,d=map(int,raw_input().split())\nm=0\nli=sorted([map(int,raw_input().split()) for i in xrange(n)])\ni=j=s=0\nwhile(j<n):\n    if(li[j][0]-li[i][0]<d):\n        s+=li[j][1]\n        j+=1\n    else:\n        if(s>m):\n            m=s\n        s-=li[i][1]\n        i+=1\nif(s>m):\n    m=s\nprint m"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Dec  6 13:41:04 2016\n\n@author: kostiantyn.omelianchuk\n\"\"\"\nfrom sys import stdin, stdout\nlines = stdin.readlines()\nn, d = int(lines[0].split()[0]), int(lines[0].split()[1])\na = [[int(x.split()[0]),int(x.split()[1])]  for x in lines[1:]]\n\na = sorted(a)\n\nmax_val = 0\nstart_pointer = 0\ncur_val = 0\nfor end_pointer in range(n):\n    if (a[end_pointer][0] - a[start_pointer][0])<d:\n        cur_val += a[end_pointer][1]\n    else:\n        cur_val += a[end_pointer][1]\n        while (a[end_pointer][0] - a[start_pointer][0]) >= d:\n            cur_val -= a[start_pointer][1]\n            start_pointer += 1\n    if cur_val > max_val:\n        max_val = cur_val\n        #print(max_val, start_pointer, end_pointer)\n\nprint(max_val)           \n"
        },
        {
            "language": 1,
            "solution": "def binarysearch(li, low, high, d):\n    if low==high:\n        return low\n    elif high-low==1:\n        if li[high][0]-li[low][0]<d:\n            return high\n        else:\n            return low\n    else:\n        mid=(low+high)/2\n        if li[mid][0]-li[low][0]<d:\n            return binarysearch(li, mid, high, d-(li[mid][0]-li[low][0]))\n        else:\n            return binarysearch(li, low, mid-1, d)\n\nn, d = map(int, raw_input().split())\nli=[]\nfor i in xrange(n):\n    li.append(map(int, raw_input().split()))\nli=sorted(li, key=lambda x:(x[0]))\nsumm=[]\np=0\nfor i in xrange(n):\n    p+=li[i][1]\n    summ.append(p)\nans=0\nfor i in xrange(n):\n    if i==0:\n        ans=max(ans, summ[binarysearch(li, i, n-1, d)])\n    else:\n        ans=max(ans, summ[binarysearch(li, i, n-1, d)]-summ[i-1])\nprint ans\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class _580B {\n\n\tstatic class Friend implements Comparable<Friend> {\n\t\tlong money;\n\t\tlong friendship;\n\n\t\tpublic Friend() {\n\t\t\tthis.money = 0;\n\t\t\tthis.friendship = 0;\n\t\t}\n\n\t\tpublic int compareTo(Friend f2) {\n\t\t\treturn Long.compare(this.money, f2.money);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = scan.nextInt();\n\t\tint d = scan.nextInt();\n\n\t\tFriend[] friends = new Friend[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tfriends[i] = new Friend();\n\t\t\tfriends[i].money = scan.nextLong();\n\t\t\tfriends[i].friendship = scan.nextLong();\n\t\t}\n\n\t\tArrays.sort(friends);\n\n\t\tlong temp = 0;\n\t\tint j = 0;\n\t\tlong max = 0;\n\n\t\tfor (int i = 0; i < friends.length; i++) {\n\n\t\t\ttemp += friends[i].friendship;\n\n\t\t\twhile (j < i && Math.abs(friends[i].money - friends[j].money) >= d) {\n\t\t\t\ttemp -= friends[j].friendship;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tmax = Math.max(max, temp);\n\t\t}\n\n\t\tSystem.out.println(max);\n\t\tscan.close();\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\n\np = []\n\nfor i in range(n):\n    m, f = map(int, input().split())\n    p.append([m, f])\n\np = sorted(p)\n\n\nx2 = 0\nmax_f = 0\nf = 0\nfor x1 in range(n):\n    x2 = max(x1, x2)\n    while x2 < n and p[x2][0] - p[x1][0] < d:\n        f += p[x2][1]\n        x2 += 1\n\n    if f > max_f:\n        max_f = f\n\n    f -= p[x1][1]\n\nprint(max_f)\n\n# Trial one:\n\n#\n# sum_f = [0]\n# for i in range(1, n + 1):\n#     sum_f.append(sum_f[i-1] + p[i - 1][1])\n#\n# def bin_search(l, r, val):\n#     mid = int((l + r) / 2)\n#     if r < l:\n#         return r\n#     else:\n#         if val < p[mid][0]:\n#             return bin_search(l, mid - 1, val)\n#         elif val > p[mid][0]:\n#             return bin_search(mid + 1, r, val)\n#         else:\n#             return mid\n#\n# max_f = 0\n# f = 0\n# for i in range(n):\n#     x = bin_search(i, n - 1, p[i][0] + d - 1)\n#     f = sum_f[x + 1] - sum_f[i]\n#     if f > max_f:\n#         max_f = f\n#\n# print(max_f)"
        },
        {
            "language": 3,
            "solution": "n,k=map(int,input().split())\nl=[]\nfor i in range(n):\n    l.append(list(map(int,input().split())))\n\nl.sort(key=lambda x: x[0])\n\nans,maxx=0,0\nans=0\ni,j=0,0\nwhile i<n:\n    while j<n and l[j][0]-l[i][0]<k:\n        ans+=l[j][1]\n        j+=1\n    maxx=max(ans,maxx)\n    ans-=l[i][1]\n    i+=1\nprint(maxx)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct kefa {\n  int amount;\n  long factor;\n  bool operator<(const kefa &kefas) const {\n    if (amount < kefas.amount) return true;\n    if (amount > kefas.amount) return false;\n    if (factor < kefas.factor) return true;\n    return false;\n  }\n};\nkefa ar[100000];\nlong long cum_sum[100001], d;\nint n;\nint main() {\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) {\n    cin >> ar[i].amount >> ar[i].factor;\n  }\n  sort(ar, ar + n);\n  cum_sum[0] = 0;\n  for (int i = 0; i < n; i++) {\n    cum_sum[i + 1] = cum_sum[i] + ar[i].factor;\n  }\n  long long y = 0;\n  for (int i = 0; i < n; i++) {\n    kefa arfriend;\n    arfriend.amount = ar[i].amount + d;\n    arfriend.factor = 0;\n    kefa *p = lower_bound(ar + i, ar + n, arfriend) - 1;\n    int j = p - (ar + i);\n    long long x = cum_sum[i + j + 1] - cum_sum[i];\n    y = max(y, x);\n    cerr << i << \" \" << j << \" \" << x << \"\\n\";\n  }\n  cout << y;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main \n{\n\tclass MyScanner\n\t{\n\t    private byte[] buf = new byte[1024];\n\t    private int curChar;\n\t    private int numChars;\n\t    BufferedInputStream bis = new BufferedInputStream(System.in);\n\n\t    public int read() \n\t    {\n\t        if (-1 == numChars)\n\t        {\n\t        \tthrow new InputMismatchException\n\t        \t();\n\t        }\n\t        if (curChar >= numChars)\n\t        {\n\t            curChar = 0;\n\t            try \n\t            {\n\t                numChars = bis.read(buf);\n\t            }\n\t            catch (IOException e)\n\t            {\n\t                throw new InputMismatchException();\n\t            }\n\t            if (numChars <= 0)\n\t            {\n\t            \treturn -1;\n\t            }\n\t        }\n\t        return buf[curChar++];\n\t    }\n\n\t    public int nextInt() \n\t    {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t        {\n\t        \tc = read();\n\t        }\n\t        int sgn = 1;\n\t        if (c == '-') \n\t        {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        int res = 0;\n\t        do \n\t        {\n\t            if (c < '0' || c > '9')\n\t            {\n\t            \tthrow new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\n\t    private boolean isSpaceChar(int c) \n\t    {\n\t        return ' ' == c || '\\n' == c || '\\r' == c || '\\t' == c || -1 == c;\n\t    }\n\t}\n\t\n\tclass Friend implements Comparable<Friend>\n\t{\n\t\tprivate int m;\n\t\tprivate int s;\n\t\t\n\t\tpublic Friend(int aM, int aS)\n\t\t{\n\t\t\tm = aM;\n\t\t\ts = aS;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Friend f)\n\t\t{\n\t\t\treturn m - f.m;\n\t\t}\n\t}\n\t\n\tpublic void foo() throws IOException\n\t{\n\t\tMyScanner scan = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = scan.nextInt();\n\t\tint d = scan.nextInt();\n\t\tFriend[] fd = new Friend[n];\n\t\t\n\t\tfor(int i = 0;i < n;++i)\n\t\t{\n\t\t\tfd[i] = new Friend(scan.nextInt(), scan.nextInt());\n\t\t}\n\t\tArrays.sort(fd);\n\t\tlong maxSum = 0;\n\t\tlong curSum = 0;\n\t\tint pre = 0;\n\t\tfor(int i = 0;i < n;++i)\n\t\t{\n\t\t\tif(fd[i].m - fd[pre].m >= d)\n\t\t\t{\n\t\t\t\tmaxSum = Math.max(maxSum, curSum);\n\t\t\t\tcurSum -= fd[pre++].s;\n\t\t\t\t--i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurSum += fd[i].s;\n\t\t\t}\n\t\t}\n\t\tmaxSum = Math.max(maxSum, curSum);\n\t\tout.println(maxSum);\n\t\tout.close();\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tnew Main().foo();\n\t}\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\nfriends, diff = map(int, raw_input().split())\n\nlst = []\n\nfor index in xrange(0, friends):\n\tmanei, num = map(int, raw_input().split())\n\tlst.append((num, manei))\n\nlst = sorted(lst, key=lambda freund: freund[1])\n\n\nlowerpointer = 0\n\ngoodness = lst[0][0]\n\nmax_goodness = goodness\n\nfor index in xrange(1, len(lst)):\n\tgoodness = goodness + lst[index][0]\n\twhile(lst[index][1] - lst[lowerpointer][1] >= diff):\n\t\tgoodness = goodness - lst[lowerpointer][0]\n\t\tlowerpointer = lowerpointer + 1\n\tif goodness > max_goodness:\n\t\tmax_goodness = goodness\n\nprint max_goodness"
        },
        {
            "language": 1,
            "solution": "# binary search, two pointer, sortings\n\ndef solve(n, d, pairs):\n\t\n\tlo = 0\n\thi = 0\n\tans = 0\n\tcand = 0\n\n\twhile hi < n:\n\t\tif pairs[hi][0] - pairs[lo][0] < d:\n\t\t\tcand += pairs[hi][1]\n\t\t\tans = max(ans, cand)\n\t\t\thi += 1\n\t\telse:\n\t\t\tcand -= pairs[lo][1]\n\t\t\tlo += 1\n\n\treturn ans\n\n\nn, d = map(int, raw_input().split())\n\npairs = []\n\nfor _ in xrange(n):\n\tm, s = map(int, raw_input().split())\n\tpairs.append((m, s))\n\nprint solve(n, d, sorted(pairs, key=lambda x: x[0]))\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.net.*;\nimport java.applet.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\npublic class cf\n{\n    public static void merge(int arr[][], int l, int m, int r) \n    { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        int L[][] = new int [n1][2]; \n        int R[][] = new int [n2][2]; \n        for (int i=0; i<n1; ++i) \n        {\n            L[i][0] = arr[l + i][0]; \n            L[i][1] = arr[l + i][1]; \n        }\n        for (int j=0; j<n2; ++j) \n        {\n            R[j][0] = arr[m + 1+ j][0]; \n            R[j][1] = arr[m + 1+ j][1]; \n        }\n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i][0] <= R[j][0]) \n            { \n                arr[k][0] = L[i][0];\n                arr[k][1] = L[i][1]; \n                i++; \n            } \n            else\n            { \n                arr[k][0] = R[j][0];\n                arr[k][1] = R[j][1]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1) \n        { \n            arr[k][0] = L[i][0];\n            arr[k][1] = L[i][1];  \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k][0] = R[j][0];\n            arr[k][1] = R[j][1];  \n            j++; \n            k++; \n        } \n    } \n    public static void sort(int arr[][], int l, int r) \n    { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    } \n    public static void main(String args[])\n    {\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        int d=in.nextInt();\n        int[][] a=new int[n][2];\n        for(int i=0;i<n;i++)\n        {\n            a[i][0]=in.nextInt();\n            a[i][1]=in.nextInt();\n        }\n        sort(a,0,n-1);\n        long b=0, c=a[0][1];\n        int pos=0;\n        for(int i=1;i<n;i++)\n        {\n            if(a[i][0]-a[pos][0]<d)\n                c+=a[i][1];\n            else\n            {\n                b=Math.max(b,c);\n                pos++;\n                if(pos==n)\n                    break;\n                c=c-a[pos-1][1];\n                i--;\n            }\n        }\n        b=Math.max(b,c);\n        System.out.println(b);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "n,d=[int(i) for i in input().split()]\ndr=[]\nfor i in range(n):\n    dr.append([int(i) for i in input().split()])\ndr.sort()\nfri=[]\nl=0\nr=1\nfr=0\ngo=dr[0][1]\nfor l in range(n):\n    #print(dr[l],go)\n    fr=dr[l][0]\n    #print(fr)\n    #go=dr[l][0]\n    while r<n and dr[r][0]-fr<d:\n        go+=dr[r][1]\n        r+=1\n    fri.append(go)\n    go-=dr[l][1]\nprint(max(fri))\n"
        },
        {
            "language": 1,
            "solution": "a = list(map(int,raw_input().split(\" \")))\nn = a[0]\nd = a[1]\nl = list()\n\nfor i in range(n):\n    x = list(map(int,raw_input().split(\" \")))\n    m = x[0]\n    s = x[1]\n    l.append((m,s))\nl.sort()\n\nans = 0\nq = list()\nfor i in l:\n    if(len(q)==0):\n        q.append(i)\n    elif i[0]-q[0][0] < d:\n        q.append(i)\n    else:\n        a = 0\n        for k in q:\n            a += k[1]\n        ans = max(ans,a)\n        while(len(q)>0 and i[0]-q[0][0]>=d):\n            q.pop(0)\n        q.append(i)\na = 0\nfor k in q:\n    a += k[1]\nans = max(ans,a)\nprint ans"
        },
        {
            "language": 3,
            "solution": "\ndef readnums():\n    return list(map(lambda x: int(x), input().split(\" \")))\n    \nn, d = readnums()\nfr = []\nfor i in range(n):\n    fr.append(tuple(readnums()))\n    \nfr.sort()\n\nans = 0\nmin_money = 0\nfriendship = 0\ni = 0\nj = 0\nwhile i < n:\n    min_money = fr[i][0]\n    ans = max(ans, friendship)\n    \n    if (i > j):\n        j = i\n    while (j < n) and (abs(fr[j][0] - min_money) < d):\n        # print(i, j, min_money, (abs(fr[j][0] - min_money)))\n        friendship += fr[j][1]\n        j += 1\n        # print(j, friendship)\n        ans = max(ans, friendship)\n        # print(ans)\n    \n    friendship -= fr[i][1]\n    i += 1\n    \n    \n            \nprint(ans)\n            \n        \n    \n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class B\n{\n    private static void doSort(long [][]array, int start, int end) {\n        if (start >= end)\n            return;\n        int i = start, j = end;\n        int cur = i - (i - j) / 2;\n        while (i < j) {\n            while (i < cur && (array[i][0] <= array[cur][0])) {\n                i++;\n            }\n            while (j > cur && (array[cur][0] <= array[j][0])) {\n                j--;\n            }\n            if (i < j) {\n                long temp = array[i][0];\n                array[i][0] = array[j][0];\n                array[j][0] = temp;\n                \n                temp = array[i][1];\n                array[i][1] = array[j][1];\n                array[j][1] = temp;\n                if (i == cur)\n                    cur = j;\n                else if (j == cur)\n                    cur = i;\n            }\n        }\n        doSort(array,start, cur);\n        doSort(array,cur+1, end);\n    }\n\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long d = sc.nextLong();\n        long [][]a = new long[n][2];\n        \n       /* long []a = new long[n];\n        \n        Map<Long, Long> m = new HashMap<Long, Long>();\n        for (int i=0; i<n; i++)\n        {\n            long temp1 = sc.nextLong();\n            long temp2 = sc.nextLong();\n            \n            if(m.containsKey(temp1))\n            {\n                temp2=(temp2+m.get(temp1));\n                m.put(temp1, temp2);\n                a[i]=-100000000;\n            }\n            else\n            {\n                a[i]=temp1;\n                m.put(temp1, temp2);\n            }\n\n        }\n        \n        m = new TreeMap<Long, Long>(m);\n        //System.out.println(m);\n        Arrays.sort(a); \n        \n        int j=0;\n        long max_friend=0;\n        for (int i=0; i<n; i++)\n        {\n            \n            long start_money =  a[i];\n            long cur_friend = 0;\n            for(j=j; j<n && (a[j]-start_money)<d ; j++)\n            {\n                if(m.containsKey(a[j])) cur_friend=cur_friend+m.get(a[j]);\n            }\n            if(cur_friend>max_friend)\n                max_friend=cur_friend;\n        }*/\n        \n        for (int i=0; i<n; i++)\n        {\n            a[i][0]=sc.nextLong();\n            a[i][1]=sc.nextLong();\n        }\n        \n        //Arrays.sort(a);\n        \n        doSort(a,0,n-1);\n        \n        /*for (int i=0; i<n/2; i++)\n        {\n            for (int j=i+1; j<n; j++)\n            {\n                if (a[i][0]>a[j][0])\n                {\n                    long s=a[i][1];\n                    a[i][1] = a[j][1];\n                    a[j][1]=s;\n                    \n                    s=a[i][0];\n                    a[i][0] = a[j][0];\n                    a[j][0]=s;\n                }\n                \n            }\n            \n            for (int j=i+1; j<n; j++)\n            {\n                \n                if (a[n-i-1][0]<a[n-j-1][0])\n                {\n                    long s=a[n-i-1][1];\n                    a[n-i-1][1] = a[n-j-1][1];\n                    a[n-j-1][1]=s;\n                    \n                    s=a[n-i-1][0];\n                    a[n-i-1][0] = a[n-j-1][0];\n                    a[n-j-1][0]=s;\n                }\n            }\n        }\n        */\n           \n        int j=0;\n        long max_friend=0;\n        long cur_friend=0;\n        for (int i=0; i<n; cur_friend-=a[i][1], ++i)\n        {\n            \n            long start_money = a[i][0];\n            while(j<n && (a[j][0]-start_money)<d)\n            {\n                cur_friend=cur_friend+a[j][1];\n                ++j;\n            }\n            if(cur_friend>max_friend)\n                max_friend=cur_friend;\n        }\n        \n       /* long max_friend=0;\n        for(int i=0;i<n;i++)\n        {\n            long cur_friend = 0;\n            long min_limit=a[i][0];\n            long max_limit=a[i][0];\n            for(int j=0;j<n;j++)\n            {\n                if(/*Math.abs(a[j][0]-d)<d && Math.abs(a[j][0]-max_limit)<d && Math.abs(a[j][0]-min_limit)<d)\n                {\n                    cur_friend=cur_friend+a[j][1];\n                    if(min_limit>a[j][0])\n                        min_limit=a[j][0];\n                    if(max_limit<a[j][0])\n                        max_limit=a[j][0];\n                }\n                if (cur_friend>max_friend)\n                    max_friend=cur_friend;\n            }\n        }*/\n        \n        System.out.println(max_friend);\n        \n        /*for (int i=0; i<n; i++)\n        {\n            System.out.print(a[i][0] + \" \");\n            System.out.println(a[i][1]);\n        }*/\n        \n    }\n\n}"
        },
        {
            "language": 3,
            "solution": "R=lambda:list(map(int,input().split()))\nn,m=R()\nx=range(n)\nc=0\nd=0\nl=0\nr=0\nf=sorted([R() for i in range(n)])\nwhile(n>l):\n   while(n>r and f[r][0]-f[l][0]<m):\n       c+=f[r][1]\n       r+=1\n   d=max(d,c)\n   c-=f[l][1]\n   l+=1\nprint(d)\n"
        },
        {
            "language": 3,
            "solution": "n,d = map(int, input().split())\nfriends = []\ns, ans, ind = 0, 0, 0\nfor i in range(n):\n\tfriends.append((list(map(int, input().split()))))\nfriends.sort(key=lambda numb: numb[0])\nfor j in range(n):\n    s += friends[j][1]\n    while friends[j][0] - friends[ind][0] >= d:\n        s -= friends[ind][1]\n        ind += 1\n    ans = max(ans, s)\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, d;\n  cin >> n >> d;\n  vector<pair<int, int>> v(n);\n  for (int i = 0; i < n; i++) {\n    int m, s;\n    cin >> m >> s;\n    v[i] = make_pair(m, s);\n  }\n  sort(v.begin(), v.end());\n  int l = 0;\n  unsigned long long res = 0;\n  unsigned long long sum = 0;\n  for (int r = 0; r < v.size(); r++) {\n    sum += v[r].second;\n    while (v[l].first + d <= v[r].first) {\n      sum -= v[l].second;\n      l++;\n    }\n    res = max(sum, res);\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct g {\n  long long m, f;\n};\nbool comp(g g1, g g2) { return g1.m < g2.m; }\nint main() {\n  long long n, d;\n  cin >> n >> d;\n  g g1;\n  vector<g> k;\n  for (long long i = 0; i < n; i++) {\n    cin >> g1.m >> g1.f;\n    k.push_back(g1);\n  }\n  sort(k.begin(), k.end(), comp);\n  if (n == 1) {\n    cout << k[0].f << endl;\n    return 0;\n  }\n  long long j = 0;\n  long long i = 0;\n  long long temp = 0;\n  long long ans = -1;\n  while (j != n && i != n) {\n    while (k[i].m > k[j].m - d) {\n      temp += k[j].f;\n      j++;\n      if (j == n) break;\n    }\n    ans = max(ans, temp);\n    temp -= k[i].f;\n    i++;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool compFirst(pair<long long, long long> a, pair<long long, long long> b) {\n  return a.first < b.first;\n}\nint main() {\n  long long n, d;\n  vector<pair<long long, long long> > friends;\n  cin >> n >> d;\n  for (int i = 0; i < n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    friends.push_back(make_pair(a, b));\n  }\n  sort(friends.begin(), friends.end(), compFirst);\n  vector<long long> sums;\n  sums.push_back(0);\n  for (int i = 0; i < n; ++i) sums.push_back(sums[i] + friends[i].second);\n  long long index = 0, max = 0;\n  for (int i = 0; i < n; ++i) {\n    for (; index == n - 1 || friends[index + 1].first < friends[i].first + d;\n         ++index) {\n      if (index == n - 1) break;\n    }\n    if (sums[index + 1] - sums[i] > max) max = sums[index + 1] - sums[i];\n  }\n  cout << max << endl;\n}\n"
        },
        {
            "language": 1,
            "solution": "#http://codeforces.com/problemset/problem/580/B\n__author__ = 'mromanyshyn'\n\nimport bisect\n\ndef count_friendship(d, friends):\n    \"\"\"\n    Count the maximum total friendship factor.\n    \"\"\"\n    lo = 0\n    hi = bisect.bisect_left(friends, (friends[lo][0] + d, 0))\n    max_f = friendship = sum([f[1] for f in friends[lo:hi]])\n    while lo < len(friends):\n        if hi < len(friends) and friends[hi][0] - friends[lo][0] < d:\n            friendship += friends[hi][1]\n            hi += 1\n            if friendship > max_f:\n                max_f = friendship\n        else:\n            friendship -= friends[lo][1]\n            lo += 1\n            if lo == hi and lo < len(friends):\n                friendship += friends[hi][1]\n                hi += 1\n                if friendship > max_f:\n                    max_f = friendship\n    return max_f\n\nn, d = map(lambda (x): int(x, 10), raw_input().split())\nfriends = []\nfor i in xrange(n):\n    friends.append(tuple(map(lambda (x): int(x, 10), raw_input().split())))\n\nprint count_friendship(d, sorted(friends))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<long long, long long> ps[100005];\nint n;\nint main() {\n  long long sum[100005];\n  long long m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> ps[i].first >> ps[i].second;\n  }\n  sort(ps, ps + n);\n  for (int i = 0; i < n; i++) {\n    sum[i + 1] = sum[i] + ps[i].second;\n  }\n  int loc = 0;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    while (loc < n && ps[loc].first < ps[i].first + m) loc++;\n    ans = max(ans, sum[loc] - sum[i]);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\n# coding: utf-8\n\n# In[ ]:\n\nn, d = [int(x) for x in input().split()]\nfriends = []\nfor _n in range(n):\n    friends.append([int(x) for x in input().split()])\nfriends.sort(key=lambda x:x[0])\nmaxFriend = 0\ncurFriend = 0\nstart = 0\nend = 0\nwhile start < len(friends) and end < len(friends):\n    if friends[end][0] - friends[start][0] >= d:\n        curFriend -= friends[start][1]\n        start += 1\n    else:\n        curFriend += friends[end][1]\n        end += 1\n        maxFriend = max(maxFriend, curFriend)\nprint(maxFriend)\n\n\n# In[ ]:\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, d;\n  cin >> n >> d;\n  vector<pair<long long, long long> > v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first >> v[i].second;\n  }\n  sort(v.begin(), v.end());\n  long long x = 0;\n  long long y = 0, m = 0;\n  for (int i = 0; i < n; i++) {\n    while (v[i].first - v[x].first >= d) {\n      y -= v[x].second;\n      x++;\n    }\n    y += v[i].second;\n    m = max(m, y);\n  }\n  cout << m;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=list(map(int,input().split()))\narr=[]\nfor i in range(n):\n  x,y=list(map(int,input().split()))\n  arr.append([x,y])\narr.sort()\ns=0\ntemp=0\nmaxVal=0\nfor i in range(n):\n  s+=arr[i][1]\n  while (arr[i][0]-arr[temp][0]>=d):\n    s-=arr[temp][1]\n    temp+=1\n  maxVal=max(maxVal,s)\nprint(maxVal)"
        },
        {
            "language": 3,
            "solution": "n,d = map(int,input().split())\nfriend = [list(map(int,input().split())) for _ in range(n)]\nfriend.sort()\ni,j,ans,window=0,0,0,0\nwhile i<n:\n\tif friend[i][0]-friend[j][0]<d:\n\t\twindow  += friend[i][1]\n\t\tans = max(window,ans)\n\t\ti+=1\n\telse:\n\t\twindow -= friend[j][1]\n\t\tj+=1\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split(' '))\nlst = [tuple(map(int, input().split(' '))) for _ in range(n)]\nlst.sort(key=lambda x: x[0])\nleft_index = 0\ncur_frd = lst[left_index][1]\nmx = cur_frd\ncur_index = 1\nwhile cur_index < n:\n    while lst[cur_index][0]-lst[left_index][0] < d:\n        cur_frd += lst[cur_index][1]\n        cur_index += 1\n        if cur_frd > mx: mx = cur_frd\n        if cur_index == n: break\n    cur_frd -= lst[left_index][1]\n    left_index += 1\nprint(mx)\n"
        },
        {
            "language": 3,
            "solution": "def byF(p1):\n    x, y = p1\n    return x\n\nn, d = map(int, input().split())\nfriends = []\niSt = 0\ns = 0\nm = 0\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    friends.append((x, y))\nfriends.sort(key=byF)\n\nfor i in range(n):\n    s += friends[i][1]\n\n    while friends[i][0] - friends[iSt][0] >= d:\n        s -= friends[iSt][1]\n        iSt += 1\n\n    if s > m:\n        m = s\n\nprint(m)\n"
        },
        {
            "language": 1,
            "solution": "n,d=map(int,raw_input().split())\narr=[]\ni=0\nl=0\nans=0\nsumm=0\nfor i in range(n):\n    a,b=map(int,raw_input().split())\t\n    arr+=[(a,b)]\narr.sort()\n# print arr\nfor i in range(n):\n\tsumm+=arr[i][1]\n\twhile arr[i][0]-arr[l][0]>=d:\n\t\tsumm-=arr[l][1]\n\t\tl+=1\n\tans=max(ans,summ)\n\t\t\t# print  abs(arr[j][0]-arr[i][0]),summ\nans=max(ans,summ)\nprint ans"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream input = System.in;\n\t\tOutputStream output = System.out;\n\t\tInputReader in = new InputReader(input);\n\t\tPrintWriter out = new PrintWriter(output);\n\t\tSolve solve = new Solve();\n\t\tsolve.solve(in, out);\n\t\tout.close();\n\t}\n\t\n\tstatic class Solve {\n\t\tvoid solve(InputReader in, PrintWriter out) {\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\t\n\t\t\tint[][] all = new int[a][2];\n\t\t\tfor(int i = 0; i < a; ++i) {\n\t\t\t\tall[i][0] = in.nextInt();\n\t\t\t\tall[i][1] = in.nextInt();\n\t\t\t}\n\n\t\t\t\n        \tArrays.sort(all, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] a1, int[] a2) {\n\t\t\t\t\treturn a1[0] - a2[0];\n\t\t\t\t}\n\t\t\t});\n        \t\n//        \tint rightPtr = -1;\n//        \tlong answer = 0, current = 0;\n//        \tfor (int i = 0; i < a; ++i) {\n//        \t\tif (rightPtr < i) {\n//        \t\t\tcurrent = all[i][1];\n//        \t\t\trightPtr = i;\n//        \t\t}\n//        \t\twhile(rightPtr + 1 < a && all[rightPtr + 1][0] - all[i][0] < b ) {\n//        \t\t\tcurrent += all[++rightPtr][1];\n//        \t\t}\n//        \t\tanswer = Math.max(answer, current);\n//        \t\trightPtr -= all[i][1];\n//\t        }\n          int rightPtr = -1;\n          long answer = 0, current = 0;\n          for (int i = 0; i < a; ++i) {\n              if (rightPtr < i) {\n                  current = all[i][1];\n                  rightPtr = i;\n              }\n              while (rightPtr + 1 < a && all[rightPtr + 1][0] - all[i][0] < b) {\n                  current += all[++rightPtr][1];\n              }\n              answer = Math.max(answer, current);\n              current -= all[i][1];\n          }\n\n            out.println(answer);\n        }\n\t}\n\t\n\tstatic class InputReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer tokenizer = null;\n\t\tInputReader(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\twhile((tokenizer==null)||(!(tokenizer.hasMoreTokens()))) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\t\n\t\t}\n\t\t\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\narr = sorted([list(map(int, input().split())) for i in range(n)])\nj, s, res = 0, arr[0][1], arr[0][1]\nfor i in range(1, n):\n    while(arr[i][0] - arr[j][0] >= d):\n        s -= arr[j][1]\n        j += 1\n    s += arr[i][1]\n    res = max(s, res)\nprint(res)\n"
        },
        {
            "language": 1,
            "solution": "import sys\ndef compare(tup1, tup2):\n    if tup1[0]<tup2[0]:\n        return -1\n    elif tup1[0]==tup2[0]:\n        if tup1[1] < tup2[1]: return -1\n        elif tup1[1]==tup2[1]: return 0\n        else: return 1\n    else: return 1\n\ndef bin_search(arr, l, r, el):\n    #print 'bin_search({}, {}, {}, {}'.format(arr, l, r, el)\n    if r > l:\n        x = int(abs(r+l)/2)\n        if int(arr[x][0]) < el :\n            return bin_search(arr, x+1, r , el)\n        else:\n            return bin_search(arr, l, x ,el)\n    else:\n         return l\n\ndef bin_search_reverse(arr, l, r, el):\n    #print 'bin_search({}, {}, {}, {}'.format(arr, l, r, el)\n    if r > l:\n        x = int(abs(r+l)/2)+1\n        if int(arr[x][0]) > el :\n            return bin_search_reverse(arr,l , x-1, el)\n        else:\n            return bin_search_reverse(arr, x, r ,el)\n    else:\n         return l\n\n\nif __name__ =='__main__':\n    n , d = [int(el) for el in raw_input().strip().split()]\n    money_friendship, fr_left, fr_right,  fr_sum, fr_max = ([None]*n,\n                                                            [0]*n, [0]*n,\n                                                            [0]*n, [0]*n)\n    #money_sum = (0 if i==0 else money_sum[i-1]+m[i])\n    for i in xrange(n):\n       money_friendship[i] = tuple([int(el) for el in raw_input().strip().split()])\n    money_friendship =sorted(money_friendship, cmp=compare)# = numpy.sort(money_friendship,axis =0)\n    for i in xrange(n):\n        fr_sum[i] = (money_friendship[0][1] if i==0 else fr_sum[i-1] + money_friendship[i][1])\n        fr_left[i] = (0 if\n                    i==0\n                    else (fr_left[i-1]\n                            if money_friendship[i][0]-money_friendship[int(fr_left[i-1])][0] < d\n                            else bin_search(money_friendship, fr_left[i-1]+1, i, int(money_friendship[i][0]-d+1))))\n    for i in xrange(n-1,-1,-1):\n        fr_right[i] = (n-1 if\n                    i==n-1\n                    else (fr_right[i+1]\n                            if abs(money_friendship[i][0]-money_friendship[int(fr_right[i+1])][0]) < d\n                        else  bin_search_reverse(money_friendship, i, fr_right[i+1]-1,int(money_friendship[i][0]+d-1))))\n\n    #print money_friendship\n    i=j=_max=0\n\n    while (i<n):\n        while (j<n and money_friendship[j][0] - money_friendship[i][0] ) < d:\n            _max =max(_max, fr_sum[(j if j < n else 0)]-fr_sum[i]+money_friendship[i][1])\n            j+=1\n            if j==n:\n                print _max\n                sys.exit()\n        i=i+1\n\n    #print fr_le/ft\n    #print fr_right\n    #print  money_friendship[::-1]\n    #print fr_sum\n\n    for i in xrange(0, n):\n        #print  fr_sum[int(fr_right[i])] , fr_sum[int(fr_left[i])]\n        fr_max[i] = fr_sum[int(fr_right[i])] - (0, fr_sum[int(fr_left[i]) -1])[fr_left[i]>0]\n        if fr_max[i]==0:\n            fr_max[i]=money_friendship[i][1]\n    #print fr_max\n    #print int(max(fr_max))\n    print int(_max)\n\n    #arr = [(1, 2) ,(3, 5) ,(3, 5) ,(4, 5) ,(4, 9), (8, 4) ,(9, 6)]\n    #print bin_search(arr, 0, len(arr) - 1, 4 )\n    #    s = numpy.searchsorted()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n     \npublic class Main{\n\tpublic static void main(String[] args) throws Exception {\n\tIO io = new IO();\n\tPrintWriter out = new PrintWriter(System.out);\n\tSolver sr = new Solver();\n\tsr.solve(io,out);\n\tout.flush();\n\tout.close();\n    \t}\n\n\tstatic class Solver\n\t{\n\t    class Pair\n\t    {\n\t        int x, y;\n\t        Pair(int a, int b)\n\t        {\n\t            x=a;\n\t            y=b;\n\t        }\n\t    }\n\t    void solve(IO io, PrintWriter out)\n\t    {\n           int i, j;\n           int n = io.nextInt();\n           int d = io.nextInt();\n           Pair[] ar = new Pair[n];\n           \n           for(i=0;i<n;i++)\n           {\n               ar[i] = new Pair(io.nextInt(),io.nextInt());\n           }\n            \n            Arrays.sort(ar, new Comparator<Pair>(){\n               \n               public int compare(Pair a, Pair b)\n               {\n                   return a.x-b.x;\n               } \n            });\n            long ans=0, max=0;\n            for(int l=0, r=0;r<n;)\n            {\n                if((int)Math.abs(ar[l].x-ar[r].x)<d)\n                {\n                    ans+=ar[r].y;\n                    r++;\n                }\n                else\n                {\n                    max= Math.max(max,ans);\n                    ans-=ar[l].y;\n                    l++;\n                }\n                max= Math.max(max,ans);\n            }\n                \n            out.print(max);\n\t    }\n\t}\n\t//Special thanks to Petr (on codeforces) who inspired me to implement IO class!\n\tstatic class IO\n\t{\n    \tBufferedReader reader;\n        StringTokenizer tokenizer;\n    \tpublic IO() {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                tokenizer = null;\n            }\n     \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public String nextLine() {\n            String s=\"\";\n            try {\n                    s=reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            return s;\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    \n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    \tdouble nextDouble()\n    \t{\n    \t\treturn Double.parseDouble(next());\n    \t}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "n ,m = map(int,input().split())\narr = list()\nfor i in range(n):\n    a,b = map(int,input().split())\n    arr.append([a,b])\n \narr.sort()\nres = arr[0][1]\ng = 0\nM = -float('inf')\ni=1\nwhile i<n:\n    if arr[i][0]-arr[g][0] >= m:\n        M = max(M,res)\n        res-=arr[g][1]\n        g+=1\n    else:\n        res+=arr[i][1]\n        i+=1\nprint(max(res,M))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 24;\nconst int mod = 1e9 + 7;\nlong long n, m, d;\nint main() {\n  cin >> n >> d;\n  pair<long long, long long> a[n];\n  for (int i = 0; i < n; i++) {\n    long long m, f;\n    cin >> m >> f;\n    a[i].first = m;\n    a[i].second = f;\n  }\n  sort(a, a + n);\n  int i = 0;\n  int j = n - 1;\n  int l, r;\n  long long ans = 0, maxi = 0;\n  for (l = 0, r = 0; r < n;) {\n    if (abs(a[l].first - a[r].first) < d) {\n      ans += a[r].second;\n      r++;\n    } else {\n      long long maxi = max(ans, maxi);\n      ans -= a[l].second;\n      l++;\n    }\n    maxi = max(maxi, ans);\n  }\n  cout << maxi << \"\\n\";\n  ;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nn, d = map(int, sys.stdin.readline().split())\nf = dict()\nfor _ in range(n):\n  m, s = map(int, sys.stdin.readline().split())\n  if m in f:\n    f[m] += s\n  else:\n    f[m] = s\nfkey = sorted(f.keys())\nfkey_min = fkey[0]\nfkey_max = fkey[-1]\nfkey_tmp = []\nfor i in fkey:\n  if i <= min(fkey_min+d-1,fkey_max):\n    fkey_tmp.append(i)\nans = sum([f[i] for i in fkey_tmp])\ntmp = ans\nfor i in range(len(fkey_tmp),len(fkey)):\n  fkey_tmp.append(fkey[i])\n  tmp += f[fkey_tmp[-1]]\n  while fkey_tmp[0] <= fkey_tmp[-1]-d:\n    tmp -= f[fkey_tmp[0]]\n    fkey_tmp.pop(0)\n  ans = max(ans,tmp)\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "#------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n#-------------------game starts now-----------------------------------------------------\ndef sort_list(list1, list2): \n  \n    zipped_pairs = zip(list2, list1) \n  \n    z = [x for _, x in sorted(zipped_pairs)] \n      \n    return z \nn,k=map(int,input().split())\na=[0]*n\nb=[0]*n\nfor i in range(n):\n    a[i],b[i]=map(int,input().split())\nb=sort_list(b,a)\na.sort()\nstart=0\nans=b[0]\nma=0\ni=1\nwhile (i<n):\n    if a[i]-a[start]<k:\n        ans+=b[i]\n        i+=1\n    else:\n        ma=max(ma,ans)\n        ans-=b[start]\n        start+=1\nma=max(ma,ans)\nprint(ma)\n        \n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.Map.*;\n\npublic class Test {\n\t\n\tprivate static Comparator<Entry<Long, Long>> c = new Comparator<Entry<Long, Long>>(){\n\t\t@Override\n\t\tpublic int compare(Entry<Long, Long> a, Entry<Long, Long> b){\n\t\t\treturn a.getKey().compareTo(b.getKey());\n\t\t}\n\t};\n\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong n = sc.nextLong();\n\t\tlong d = sc.nextLong();\n\t\tMap<Long, Long> m = new HashMap<Long, Long>();\n\t\tfor(long i = 0; i < n; i++){\n\t\t\tlong a = sc.nextLong();\n\t\t\tlong b = sc.nextLong();\n\t\t\tif(m.get(a) == null){\n\t\t\t\tm.put(a, b);\n\t\t\t} else {\n\t\t\t\tm.put(a, m.get(a) + b);\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t\tList<Entry<Long, Long>> l = new ArrayList<Entry<Long, Long>>(m.entrySet());\n\t\tCollections.sort(l, c);\n\t\tlong max = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tlong sum = 0;\n\t\twhile(i < l.size() && j < l.size()){\n\t\t\tif(l.get(j).getKey() - l.get(i).getKey() >= d){\n\t\t\t\tsum -= l.get(i).getValue();\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tsum += l.get(j).getValue();\n\t\t\t\tif(j + 1 == l.size() || l.get(j + 1).getKey() - l.get(i).getKey() >= d){\n\t\t\t\t\tmax = Math.max(max, sum);\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.*;\n\npublic class B580 {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n\n        static class Friend implements Comparable<Friend>\n        {\n            int m;\n            int s;\n            Friend(int m, int s)\n            {\n                this.m = m;\n                this.s = s;\n            }\n\n            @Override\n            public int compareTo(Friend o) {\n                return (this.m-o.m>0)?1:(this.m-o.m==0)?0:-1;\n            }\n        }\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int d = in.readInt();\n            ArrayList<Friend> fr=new ArrayList<Friend>();\n            for (int i = 0; i < n; i++)\n            {\n                fr.add(new Friend(in.readInt(), in.readInt()));\n            }\n            Collections.sort(fr);\n\n\n            long ans = 0;\n            int j = 0;\n            long local = 0;\n            for (int i = 0 ; i < n; i++)\n            {\n\n                while(j < n && fr.get(j).m - fr.get(i).m < d)\n                {\n                    local += fr.get(j).s;\n                    j++;\n                }\n                if (local > ans) ans = local;\n                local-=fr.get(i).s;\n\n            }\n\n            System.out.println(ans);\n        }\n\n\n\n\n\n\n    }\n\n    static class IOUtils {\n        public static int[] readIntArray(InputReader in, int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = in.readInt();\n            }\n            return array;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public char readCharacter() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\n\npublic class CF321B {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tArrayList<int[]> list = new ArrayList<int[]>();\n\t\tint n = scan.nextInt();\n\t\tint d = scan.nextInt();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint[] pair = new int[2];\n\t\t\tpair[0] = scan.nextInt();\n\t\t\tpair[1] = scan.nextInt();\n\t\t\tlist.add(pair);\n\t\t}\n\n\t\tCollections.sort(list, new Comparator<int[]>(){\n\t\t\tpublic int compare(int[] pair1, int[] pair2){\n\t\t\t\treturn Integer.compare(pair1[0], pair2[0]);\n\t\t\t}\n\t\t});\n\t\tlong max = 0;\n\t\tint index = 0;\n\t\tlong fship = 0;\n\t\tfor(int i = 0; i < list.size(); i++){\n\n\t\t\tif((list.get(i)[0]-list.get(index)[0])>=d){\n\t\t\t\tmax = Math.max(max, fship);\n\t\t\t\twhile((list.get(i)[0]-list.get(index)[0])>=d){\n\t\t\t\t\tfship -=list.get(index)[1];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tfship+=list.get(i)[1];\n\t\t\t\tmax = Math.max(max, fship);\n\t\t\t}else{\n\t\t\t\tfship+=list.get(i)[1];\n\t\t\t}\n\t\t}\n\t\tmax = Math.max(max, fship);\n\t\tSystem.out.println(max);\n\n\t}\n}\n\n"
        },
        {
            "language": 3,
            "solution": "n,d=list(map(int,input().split()))\nc=0\nl=[]\nfor i in range(n):\n  m,s=list(map(int,input().split()))\n  l.append([m,s])\nl.sort()\ni=0\ns=0\nmaximum=0\nfor k in range(n):\n  s+=l[k][1]\n  #print(l[k][0],l[i][0])\n  while l[k][0]-l[i][0]>=d:\n    s-=l[i][1]\n    i+=1\n  maximum=max(maximum,s)\nprint(maximum)"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\n\npublic class Main_580B {\n\n    public static void main(String[] args) throws IOException {\n        StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        int size = readInt(tokenizer);\n        int delta = readInt(tokenizer);\n\n        Friend[] friends = new Friend[size];\n\n        for (int i = 0; i < size; i++) {\n            Friend friend = new Friend(readInt(tokenizer), readInt(tokenizer));\n            friends[i] = friend;\n        }\n\n        long maxFriendship = calculateMaxFriendship(friends, delta);\n\n        System.out.println(maxFriendship);\n    }\n\n    static long calculateMaxFriendship(Friend[] friends, int delta) {\n        Arrays.sort(friends);\n        long maxFriendship = 0;\n\n        int first = 0;\n        int last = 0;\n        long friendship = 0;\n        while (last < friends.length) {\n            while (last < friends.length && friends[last].money < friends[first].money + delta) {\n                friendship += friends[last].friendship;\n                last++;\n            }\n\n            if (friendship > maxFriendship) {\n                maxFriendship = friendship;\n            }\n\n            friendship -= friends[first].friendship;\n            first++;\n        }\n        return maxFriendship;\n    }\n\n    private static int readInt(StreamTokenizer tokenizer) throws IOException {\n        tokenizer.nextToken();\n        return (int) tokenizer.nval;\n    }\n\n    static class Friend implements Comparable<Friend> {\n        private int money;\n        private int friendship;\n\n        Friend(int money, int friendship) {\n            this.money = money;\n            this.friendship = friendship;\n        }\n\n        @Override\n        public int compareTo(Friend o) {\n            return money - o.money;\n        }\n\n        @Override\n        public String toString() {\n            return \"[\" + money + \", \" + friendship + \"]\";\n        }\n    }\n\n}\n"
        },
        {
            "language": 1,
            "solution": "n,d = map(int,raw_input().split(\" \"))\nmoney=[]\nfactor=[]\nfor i in range(n):\n    temp1,temp2 = map(int,raw_input().split(\" \"))\n    money.append(temp1)\n    factor.append(temp2)\npoints = zip(money,factor)\npoints=sorted(points)\n#print points\nnew_money = [point[0] for point in points]\nnew_factor = [point[1] for point in points]\n#print new_money\n#print new_factor\nl=0\nsums=0\nans=0\nfor i in range(n):\n    sums += new_factor[i]\n    #print 'sum:%d just after adding with value of l:%d' %(sums,l)\n    while(new_money[i]-new_money[l]>=d):\n        sums-=new_factor[l]\n        l+=1\n        #print `sums`,\n        #print 'for i:'+`i`+' and l:'+`l`\n    #print 'sum at step %d: %d' %(i,sums)\n    ans = max(ans,sums)\nprint ans\n"
        },
        {
            "language": 3,
            "solution": "n,d = map(int,input().split())\nm = [0 for i in range(n)]\ns = [0 for i in range(n)]\nhash = [0 for i in range(n)]\nmod = 10**9 + 1\n\nfor i in range(n):\n    m[i], s[i] = map(int,input().split())\n    hash[i] = m[i] * mod + s[i]\n\n# print(m,s)\n# print(hash)\n\nhash = sorted(hash)\n# print(hash)\n\ndef get_value(x):\n    return x%(mod)\n\ndef get_key(x):\n    return int(x/(mod))\n\ni_max = n-1\ni_min = n-1\nS = 0\nS_max = S\n\nwhile((i_min>=0)&(i_max>=0)):\n    while ((get_key(hash[i_min]) > (get_key(hash[i_max]) - d)) & (i_min>=0)):\n        S += get_value(hash[i_min])\n        i_min -= 1\n    if (S > S_max):\n        S_max = S\n    S -= get_value(hash[i_max])\n    i_max -= 1\n\nprint(S_max)"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\na = sorted([list(map(int, input().split())) for i in range(n)])\nleft = 0\ncur_sum = 0\nmax_sum = 0\nfor right in range(n):\n    cur_sum += a[right][1]\n    while a[right][0] - a[left][0] >= d:\n        cur_sum -= a[left][1]\n        left += 1\n    if cur_sum > max_sum:\n        max_sum = cur_sum\nprint(max_sum)\n    \n"
        },
        {
            "language": 1,
            "solution": "import sys\ndef first_less_then (array, n, value, default):\n    l,r = 0,n\n    while r - l > 1 :\n        mid = (l+r)/2\n        if array[mid][0] >= value:\n            r = mid\n        else:\n            l = mid\n    return l if array[l][0] < value else default\n\nif __name__ == \"__main__\":\n    n,d = [int(x) for x in sys.stdin.readline().split()]\n    array = sorted([tuple([int(x) for x in sys.stdin.readline().split()]) for _ in xrange(n)])\n\n    agregated = 0\n    agregated_array = []\n    for i in xrange(n):\n        agregated += array[i][1]\n        agregated_array.append(agregated)\n\n    max_value = 0\n    for (i, (money, value)) in enumerate(array):\n        last = first_less_then (array, n, d + money, i)\n        max_value = max(max_value, agregated_array[last] - (agregated_array[i - 1] if (i-1) >= 0 else 0))\n\n    print max_value\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\nimport javafx.util.Pair;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        long startTime = System.nanoTime();\n        int t = 1;\n        while (t-- > 0) {\n            solve();\n        }\n        long endTime = System.nanoTime();\n        err.println(\"Execution Time : +\" + (endTime - startTime) / 1000000 + \" ms\");\n        exit(0);\n    }\n\n    static void solve() {\n        int n = in.nextInt();\n        long d = in.nextLong();\n        Pair<Long, Long>[] p = new Pair[n + 1];\n        p[0] = make_pair(0L, 0L);\n        long[] psum = new long[n + 1];\n        for (int i = 1; i <= n; i++) {\n            p[i] = new Pair<>(in.nextLong(), in.nextLong());\n        }\n        Arrays.sort(p, Comparator.comparingLong(Pair::getKey));\n        for (int i = 1; i <= n; i++) {\n            psum[i] = p[i].getValue();\n            psum[i] = psum[i] + psum[i - 1];\n        }\n        long ans = 0;\n        //out.println(Arrays.toString(p));\n        int ind = 0;\n        for (int i = 1; i <= n; i++) {\n            long v = d + p[i].getKey();\n            while (ind <= n && p[ind].getKey() < v) {\n                ind++;\n            }\n            ans = Math.max(ans, psum[ind - 1] - psum[i - 1]);\n        }\n        out.println(ans);\n    }\n\n    static <T> Pair<T, T> make_pair(T a, T b) {\n        return new Pair<>(a, b);\n    }\n\n    static void debug(Object... args) {\n        for (Object a : args) {\n            out.println(a);\n        }\n    }\n\n    static void y() {\n        out.println(\"YES\");\n    }\n\n    static void n() {\n        out.println(\"NO\");\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] readAllInts(int n) {\n            int[] p = new int[n];\n            for (int i = 0; i < n; i++) {\n                p[i] = in.nextInt();\n            }\n            return p;\n        }\n\n        public int[] readAllInts(int n, int s) {\n            int[] p = new int[n + s];\n            for (int i = s; i < n + s; i++) {\n                p[i] = in.nextInt();\n            }\n            return p;\n        }\n\n        public long[] readAllLongs(int n) {\n            long[] p = new long[n];\n            for (int i = 0; i < n; i++) {\n                p[i] = in.nextInt();\n            }\n            return p;\n        }\n\n        public long[] readAllLongs(int n, int s) {\n            long[] p = new long[n + s];\n            for (int i = s; i < n + s; i++) {\n                p[i] = in.nextInt();\n            }\n            return p;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static void exit(int a) {\n        out.close();\n        err.close();\n        System.exit(a);\n    }\n\n    static InputStream inputStream = System.in;\n    static OutputStream outputStream = System.out;\n    static OutputStream errStream = System.err;\n    static InputReader in = new InputReader(inputStream);\n    static PrintWriter out = new PrintWriter(outputStream);\n    static PrintWriter err = new PrintWriter(errStream);\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, d, i, j;\n  long long int xam = 0, sum = 0;\n  cin >> n >> d;\n  vector<pair<long long int, long long int> > v(n);\n  for (i = 0; i < n; i++) {\n    cin >> v[i].first >> v[i].second;\n    v[i].second = -v[i].second;\n  }\n  sort(v.begin(), v.end());\n  for (i = 0, j = 0; i < n && j < n;) {\n    if ((v[j].first - v[i].first) < d) {\n      sum += (-v[j].second);\n      j++;\n      xam = max(xam, sum);\n    } else {\n      sum -= (-v[i].second);\n      i++;\n    }\n  }\n  cout << xam;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split(\" \"))\nmymap=dict()\nv=[]\nt=[]\nfor i in range(n):\n\tp,q=map(int,input().split(\" \"))\n\tif(mymap.get(p,-1)==-1):\n\t\tv.append(p)\n\t\tt.append(int(0))\n\tmymap[p]=q+mymap.get(p,int(0))\nv.sort()\nsum=0\nen=int(0)\nfor i in range(len(v)):\n\tif i!=0 :\n\t\tt[i]=t[i-1]-mymap[v[i-1]]\n\twhile en<len(v) and (v[en]<v[i]+d) :\n\t\tt[i]+= mymap[v[en]]\n\t\ten+=1\n\tsum=max(sum,t[i])\nprint(sum)"
        },
        {
            "language": 4,
            "solution": "//codeforces_580B\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport static java.lang.Math.*;\nimport java.math.*;\n\npublic class Main{\n\n\tstatic PrintWriter go = new PrintWriter(System.out);\n\n\tpublic static void main(String args[]) throws IOException,FileNotFoundException {\n\t\tBufferedReader gi = new BufferedReader(new InputStreamReader(System.in));\n\t\tint[] l = parseArray(gi);\n\t\tint n = l[0];\n\t\tint m = l[1];\n\t\tint[][] map = new int[n][2];\n\t\tfor ( int k = 0; k < n; k++){\n\t\t\tl = parseArray(gi);\n\t\t\tmap[k][0] = l[0];\n\t\t\tmap[k][1] = l[1];\n\t\t}\n\t\tArrays.sort(map, new Comparator<int[]>(){\n\t\t\tpublic int compare( int[] a, int[] b ){\n\t\t\t\treturn a[0] - b[0];\n\t\t\t}\n\t\t});\n\t\tint start, end;\n\t\tstart = end = 0;\n\t\tlong ans = map[0][1];\n\t\tlong sum = ans;\n\t\twhile ( end < n ){\n\t\t\twhile ( start < end && map[end][0] - map[start][0] >= m ){\n\t\t\t\tsum -= map[start][1];\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\twhile ( end < n-1 ){\n\t\t\t\tend++;\n\t\t\t\tif ( map[end][0] - map[start][0] >= m ){ end--;break; }\n\t\t\t\tsum += map[end][1];\n\t\t\t}\n\t\t\tans = max(ans,sum);\n\t\t\tend++;\n\t\t\tif ( end >= n ){ break; }\n\t\t\tsum += map[end][1];\n\t\t}\n\t\tgo.println(ans);\n\n\t\tgo.close();\n\t}\n\n\tstatic int[] parseArray(BufferedReader gi) throws IOException{\n\t\tString[] line = gi.readLine().trim().split(\" \");\n\t\tint[] rez = new int[line.length];\n\t\tfor ( int k = 0; k < line.length; k++){\n\t\t\trez[k] = Integer.parseInt(line[k]);\n\t\t}\n\t\treturn rez;\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char** argv) {\n  long long n;\n  long long d;\n  cin >> n >> d;\n  vector<pair<long long, long long>> friends;\n  long long money;\n  long long factor;\n  for (long long i = 0; i < n; i++) {\n    cin >> money >> factor;\n    friends.push_back(make_pair(money, factor));\n  }\n  sort(friends.rbegin(), friends.rend());\n  long long total_factor = friends[0].second;\n  long long temp_factor = friends[0].second;\n  long long firstPointer = 0;\n  long long secondPointer = 1;\n  while (secondPointer < friends.size()) {\n    if (friends[firstPointer].first - friends[secondPointer].first < d) {\n      temp_factor = temp_factor + friends[secondPointer].second;\n      secondPointer = secondPointer + 1;\n      ;\n    } else {\n      temp_factor = temp_factor - friends[firstPointer].second;\n      firstPointer = firstPointer + 1;\n    }\n    total_factor = max(total_factor, temp_factor);\n  }\n  cout << total_factor << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, d, start, sum, mx;\npair<long long, long long> a[100100];\nint main() {\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a, a + n);\n  sum = mx = a[0].second;\n  for (int i = 1; i < n; i++) {\n    if (a[i].first - a[start].first < d) {\n      sum += a[i].second;\n      mx = max(mx, sum);\n    } else {\n      while (a[i].first - a[start].first >= d) {\n        sum -= a[start].second;\n        start++;\n      }\n      sum += a[i].second;\n      mx = max(mx, sum);\n    }\n  }\n  cout << mx << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid Solve() {\n  vector<pair<int, int>> vec;\n  long long n, d, m, s, cr = 0, l = 0, r = 0, mx = 0;\n  cin >> n >> d;\n  for (long long i = 0; i < n; i++) {\n    cin >> m >> s;\n    vec.push_back(make_pair(m, s));\n  }\n  sort(vec.begin(), vec.end());\n  for (long long l = 0; l < n && r < n; l++) {\n    r = max(r, l);\n    while (vec[r].first - vec[l].first < d && r < n) {\n      cr += vec[r].second;\n      mx = max(mx, cr);\n      r++;\n    }\n    cr -= vec[l].second;\n  }\n  cout << mx;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t = 1;\n  while (t--) {\n    Solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n    public static void solution(BufferedReader reader, PrintWriter out)\n            throws IOException {\n        In in = new In(reader);\n        int n = in.nextInt(), d = in.nextInt();\n        int[][] f = new int[n][2];\n        for (int i = 0; i < n; i++)\n            f[i] = new int[] { in.nextInt(), in.nextInt() };\n        Arrays.sort(f, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return a[0] - b[0];\n            }\n        });\n        long sum = 0, max = 0;\n        for (int i = 0, j = 0; j < f.length; j++) {\n            sum += f[j][1];\n            while (f[i][0] + d <= f[j][0])\n                sum -= f[i++][1];\n            max = Math.max(max, sum);\n        }\n        out.println(max);\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(\n                new BufferedWriter(new OutputStreamWriter(System.out)));\n        solution(reader, out);\n        out.close();\n    }\n\n    protected static class In {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n        public In(BufferedReader reader) {\n            this.reader = reader;\n        }\n\n        public String next() throws IOException {\n            while (!tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint d;\nint n;\nstruct Pon {\n  long long x, y;\n} a[100100];\nbool cmp(Pon A, Pon B) {\n  if (A.x == B.x) return A.y < B.y;\n  return A.x < B.x;\n}\nint main() {\n  while (scanf(\"%d%d\", &n, &d) != EOF) {\n    long long mmax = 0;\n    long long tot = 0;\n    int pis = 0;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%I64d%I64d\", &a[i].x, &a[i].y);\n    }\n    sort(a, a + n, cmp);\n    long long pos = a[0].x;\n    for (int i = 0; i < n; i++) {\n      if (a[i].x == pos) {\n        tot += a[i].y;\n      } else {\n        pos = a[i].x;\n        mmax = max(tot, mmax);\n        tot = a[i].y;\n      }\n    }\n    mmax = max(tot, mmax);\n    int first = a[0].x;\n    int i = 0, j = 0;\n    long long ans = 0;\n    while (i < n && j < n) {\n      while (a[i].x - first < d && a[i].x - first >= 0 && i < n) {\n        ans += a[i].y;\n        i++;\n      }\n      mmax = max(ans, mmax);\n      while (a[i].x - a[j].x >= d && j < n) {\n        ans -= a[j].y;\n        j++;\n      }\n      first = a[j].x;\n    }\n    printf(\"%I64d\\n\", mmax);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom bisect import bisect_right\nfrom itertools import accumulate\n\n\ndef main():\n    n, d = map(int, input().split())\n    friends = sorted(tuple(int(c) for c in line.split()) for line in sys.stdin)\n    inf = 1000000001\n\n    friendship_sum = [0] + list(accumulate(e for _, e in friends))\n\n    start = 0\n    _min, ans = friends[0]\n\n    for i in range(1, n):\n        cur = friends[i][0]\n        if cur - _min >= d:\n            start = bisect_right(friends, (cur - d, inf))\n            _min = friends[start][0]\n\n        friendship = friendship_sum[i + 1] - friendship_sum[start]\n        ans = max(ans, friendship)\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 3,
            "solution": "from collections import deque\nn,d = map(int,input().split())\n\na = [list(map(int, input().split())) for i in range(n)]\na.sort()\n\nq = deque()\n\nans = s = 0\n\nfor x,f in a:\n\n    while q and x >= q[0][0] + d :\n        s -= q[0][1]\n        q.popleft()\n    q.append((x,f))\n    s += f\n    ans = max(s,ans)\nprint(ans)\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int d = scanner.nextInt();\n        Pair[] mass = new Pair[n + 1];\n        for (int i = 0 ; i < n ; ++i) {\n            int money = scanner.nextInt();\n            int friend = scanner.nextInt();\n            mass[i] = new Pair(money, friend);\n        }\n        mass[n] = new Pair(Long.MAX_VALUE / 2, 0);\n        Arrays.sort(mass);\n        long sum = 0L;\n        long[] s = new long[n + 2];\n        for (int i = 0 ; i <= n ; ++i) {\n            s[i] = sum;\n            sum += mass[i].b;\n        }\n        s[n + 1] = sum;\n        long max = 0;\n        for (int i = 0  ;i < n ; ++i) {\n            Pair current = mass[i];\n            int index = lowerBound(mass, n + 1, current.a + d);\n            long sumFriend = s[index + 1] - s[i];\n            max = Math.max(max, sumFriend);\n        }\n        System.out.println(max);\n    }\n\n    private static int lowerBound(Pair[] pairs, int n, long value) {\n        int left = 0;\n        int right = n;\n        while (right - left > 1) {\n            int mid = (left + right) / 2;\n            if (pairs[mid].a < value) left = mid;\n            else right = mid;\n        }\n        return left;\n    }\n\n    private static final class Pair implements Comparable<Pair>{\n        long a;\n        long b;\n        Pair(long a, long b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            if (a == o.a) return Long.compare(b, o.b);\n            return Long.compare(a, o.a);\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "n,de=map(int,input().split())\nd={}\nfor i in range(n):\n    m,f=map(int,input().split())\n    d[m]=f if m not in d else d[m]+f\n# print(d)\nl=list(d.keys())\nl.sort()\na=0\nmaxf=0\ncurf=0\nfor b in range(len(l)):\n    if l[b]>=de+l[a]:\n        while(1):\n            if l[b]-l[a]<de:\n                break\n            else:\n                curf -= d[l[a]]\n                a += 1\n    curf+=d[l[b]]\n    maxf=max(maxf,curf)\nprint(maxf)\n"
        },
        {
            "language": 1,
            "solution": "n,d = map(int, raw_input().split())\n\nfriends = []\nfor friend in xrange(n):\n\tm, s = map(int, raw_input().split())\n\tfriends.append((m,s))\n\t\nfriends.sort()\n\nj = 0\naux = 0\nans = 0\n\nfor i in range(n):\n\taux += friends[i][1]\n\twhile abs(friends[i][0]- friends[j][0]) >= d:\n\t\taux -= friends[j][1]\n\t\tj += 1\n\t\t\t\n\tans = max(ans, aux)\n\n\nprint ans\n"
        },
        {
            "language": 3,
            "solution": "# take the input and split it in number of friends \n# and maximum difference\n\nfirstLine = input().split(\" \")\nnoOfFriends = int(firstLine[0])\ndiff = int(firstLine[1])\nfriends = []\n\n# place the amount of money and the friendship factor\n# in an array of pairs\n\nfor index in range(noOfFriends):\n\tdesc = input().split(\" \")\n\tfriends.append((int(desc[0]), int(desc[1])))\n\n# sort the array by the amount of money\n\nfriends.sort()\n\n# initialise pointers, friendship counter and maximum\n\nleft = 0\nright = 1\nmaxFriendship = friends[0][1]\nfriendship = friends[0][1]\n\n# go through all subsequences of friends with similar amounts\n# of money and find the one with the biggest friendship factor\n\nwhile (right <= noOfFriends - 1):\n\tfriendship += friends[right][1]\n\twhile(friends[right][0] - friends[left][0] >= diff):\n\t\t\tfriendship -= friends[left][1]\n\t\t\tleft += 1\n\tif(maxFriendship < friendship):\n\t\t\tmaxFriendship = friendship\n\tright += 1\n\nprint(maxFriendship)\n"
        },
        {
            "language": 3,
            "solution": "class Friend:\n    def __init__(self, m, s):\n        self.m = m\n        self.s = s\n\n\nn, d = list(map(int, input().split()))\n\nfriends = []\nfor i in range(n):\n    m, s = list(map(int, input().split()))\n    friends.append(Friend(m, s))\n\nfriends.sort(key=lambda f: f.m)\nmax_score = 0\nright = 0\ncurr = 0\nfor left in range(n):\n    while right < n and friends[right].m < d + friends[left].m:\n        curr += friends[right].s\n        right += 1\n    max_score = max(max_score, curr)\n    curr -= friends[left].s\n\nprint(max_score)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long max(long long a, long long b) { return a > b ? a : b; }\nlong long min(long long a, long long b) { return a < b ? a : b; }\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nconst long long INF = (long long)(1e17);\nconst double PI = 3.141592653589793;\nlong long dx[4] = {-1, 0, 1, 0};\nlong long dy[4] = {0, 1, 0, -1};\nstring path = \"URDL\";\nvoid solve() {\n  long long n, d;\n  cin >> n >> d;\n  vector<pair<long long, long long> > arr(n);\n  for (auto& e : arr) cin >> e.first >> e.second;\n  sort(arr.begin(), arr.end());\n  long long l = 0, r = 0;\n  long long temp = 0, ans = 0;\n  for (; l < n; temp -= arr[l].second, l++) {\n    while (r < n and (arr[r].first - arr[l].first) < d)\n      temp += arr[r].second, r++;\n    ans = max(ans, temp);\n  }\n  cout << ans << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "__author__ = 'trunghieu11'\n\n\ndef findIdx(x, left, right, friends):\n    while right - left > 1:\n        mid = (right + left) / 2\n        if friends[mid][0] >= x:\n            right = mid\n        else:\n            left = mid\n    return right if friends[right][0] < x else left\n\n\ndef solve(n, minDiff, friends):\n    friends.sort(key=lambda friend:friend[0])\n    total = [0 for i in range(n)]\n    for i in range(n):\n        if i == 0:\n            total[i] = friends[i][1]\n        else:\n            total[i] = total[i - 1] + friends[i][1]\n\n    answer = 0\n    for i in range(n):\n        idx = findIdx(friends[i][0] + minDiff, i, n - 1, friends)\n        curAnswer = total[idx] - (total[i - 1] if i - 1 >= 0 else 0)\n        answer = max(answer, curAnswer)\n    return answer\n\n\nif __name__ == '__main__':\n    n, minDiff = map(int, raw_input().split(\" \"))\n    friends = []\n    for i in range(n):\n        friends.append(tuple(map(int, raw_input().split(\" \"))))\n    print solve(n, minDiff, friends)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct peo {\n  int m;\n  long long s;\n} a[100005];\nbool cmp(peo a, peo b) { return a.m < b.m; }\nint main() {\n  int n, d, pos1, pos2;\n  long long sum = 0, mx;\n  scanf(\"%d%d\", &n, &d);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%I64d\", &a[i].m, &a[i].s);\n  }\n  sort(a, a + n, cmp);\n  pos1 = 0;\n  pos2 = 0;\n  mx = -1;\n  while (pos2 <= n) {\n    sum += a[pos2].s;\n    while (a[pos2].m - a[pos1].m >= d) {\n      sum -= a[pos1].s;\n      pos1++;\n    }\n    pos2++;\n    if (sum > mx) {\n      mx = sum;\n    }\n  }\n  printf(\"%I64d\\n\", mx);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic final class KefaCompany\n{\n\tpublic static void main(String[] args) {\n\t\tScanner br=new Scanner(System.in);\n\t\tint n=br.nextInt();\n\t\tint d=br.nextInt();\n\t\tFriend[] a=new Friend[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i]=new Friend(br.nextInt(),br.nextInt());\n\t\tArrays.sort(a);\n\t\tint i=0,j=0;\n\t\tlong sum=0L,ans=-1L;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\t\n\t\t\t\tsum+=a[i].f;\n\t\t\tif(a[i].m-a[j].m>=d)\n\t\t\t{\n\t\t\t\twhile(a[i].m-a[j].m>=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tsum-=a[j].f;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\n\t\t\t}\n\t\t\t\tans=Math.max(sum,ans);\n\n\t\t}\n\t\n\t\tSystem.out.println(ans);\n\t}\n}\nclass Friend implements Comparable<Friend>\n{\n\tint f,m;\n\tpublic Friend(int m,int f)\n\t{\n\t\tthis.f=f;\n\t\tthis.m=m;\n\n\t}\n\tpublic int compareTo(Friend that)\n\t{\n\t\treturn this.m-that.m;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.TreeMap;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Artyom Korzun\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int d = in.nextInt();\n            Friend[] friends = new Friend[n];\n            for (int i = 0; i < n; i++)\n                friends[i] = new Friend(in.nextInt(), in.nextInt());\n\n            Arrays.sort(friends, (o1, o2) -> Integer.compare(o1.money, o2.money));\n            long[] sum = new long[n];\n            sum[0] = friends[0].friendliness;\n            for (int i = 1; i < n; i++)\n                sum[i] += sum[i - 1] + friends[i].friendliness;\n\n            TreeMap<Integer, Integer> map = new TreeMap<>();\n            long answer = -1;\n            for (int i = 0; i < n; i++) {\n                Friend friend = friends[i];\n                int min = friend.money - d + 1;\n                Map.Entry<Integer, Integer> entry = map.ceilingEntry(min);\n                if (entry == null) {\n                    answer = Math.max(answer, friend.friendliness);\n                } else {\n                    int last = entry.getValue() - 1;\n                    answer = Math.max(answer, sum[i] - (last == -1 ? 0 : sum[last]));\n                }\n\n                if (!map.containsKey(friend.money)) {\n                    map.put(friend.money, i);\n                }\n            }\n\n            out.print(answer);\n\n        /*int n = in.nextInt();\n        int d = in.nextInt();\n        Friend[] f = new Friend[n];\n        for (int i = 0; i < n; i++)\n            f[i] = new Friend(in.nextInt(), in.nextInt());\n\n        Arrays.sort(f, (o1, o2) -> Integer.compare(o1.money, o2.money));\n        long answer = -1;\n\n        long current = 0;\n        long last = 0;\n        for (int head = 0, tail = 0; head < n; ) {\n            if (f[head].money - d >= f[tail].money) {\n                last += f[tail].friendliness;\n                tail++;\n            } else {\n                current += f[head].friendliness;\n                head++;\n                answer = Math.max(answer, current - last);\n            }\n        }\n\n\n        out.print(answer);*/\n\n        }\n\n        static class Friend {\n            final int money;\n            final int friendliness;\n\n            public Friend(int money, int friendliness) {\n                this.money = money;\n                this.friendliness = friendliness;\n            }\n\n        }\n\n    }\n\n    static class FastScanner {\n        private final BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public FastScanner(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(nextLine());\n\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "import bisect\nn,d=map(int,input().split())\nms=[list(map(int,input().split())) for i in range(n)]\nms.sort()\nm=[ms[i][0] for i in range(n)]\ns=[0]+[ms[i][1] for i in range(n)]\nss=s\nfor i in range(1,n+1):\n  ss[i]+=ss[i-1]\nans=0\nfor i in range(n):\n  idx=bisect.bisect_left(m,m[i]+d)\n  ans=max(ans,ss[min(idx,n)]-ss[i])\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "n, d = [int(x) for x in input().rstrip().split(' ')]\nfriends = []\nfor i in range(n):\n    friends.append([int(x) for x in input().rstrip().split(' ')])\n\nfriends.sort(key=lambda x: x[0])\ns_max = friends[0][1]\ni_begin = 0\ni_end = 1\n\ns_curr = s_max\n\nwhile i_end < n:\n    d_max = friends[i_begin][0] + d\n    while (i_end < n and friends[i_end][0] < d_max):\n        s_curr += friends[i_end][1]\n        i_end += 1\n    s_max = max(s_max,s_curr)\n    s_curr -= friends[i_begin][1]\n    i_begin += 1\n    \n\nprint(s_max) \n"
        },
        {
            "language": 3,
            "solution": "'''\n\tCodeForces 580B\n\tKefa and Company\n\n\tTags: Sortings, dp, Maximum Consecutive Sum\n'''\nfrom sys import stdin\n\ndef solve(people, d):\n\tls   = sorted(people, key=lambda p: p[0])\n\tans  = ls[0][1]\n\tacc  = 0\n\tlast = -1\n\tfor (idx, (m, s)) in enumerate(ls):\n\t\twhile last >= 0 and idx - last > 0 and m - ls[last][0] >= d:\n\t\t\tacc -= ls[last][1]\n\t\t\tlast += 1\n\t\tacc += s\n\t\tif last < 0 or idx - last <= 0:\n\t\t\tlast = idx\n\t\tans = max(ans, acc)\n\treturn ans\n\nn, d = tuple(map(int, input().split()))\nfriends = [ tuple(map(int, line.split())) for line in stdin.readlines() ]\n\nans = solve(friends, d)\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, d, m, s;\n  cin >> n >> d;\n  vector<pair<int, int> > v;\n  vector<int> money;\n  for (int i = 0; i < n; i++) {\n    cin >> m >> s;\n    pair<int, int> p = make_pair(m, s);\n    v.push_back(p);\n    money.push_back(m);\n  }\n  sort(v.begin(), v.end());\n  sort(money.begin(), money.end());\n  vector<unsigned long long> pref;\n  pref.push_back(0);\n  int i;\n  for (i = 0; i < n; i++) {\n    pref.push_back(v[i].second + pref[i]);\n  }\n  for (i = 0; i <= n; i++) {\n  }\n  unsigned long long max = 0;\n  int index;\n  for (i = 0; i < n; i++) {\n    vector<int>::iterator up;\n    up = upper_bound(money.begin(), money.end(), v[i].first + d - 1);\n    if (pref[up - money.begin()] - pref[i] > max)\n      max = pref[up - money.begin()] - pref[i];\n  }\n  cout << max << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, d, ff = 1, bb = 1;\nlong long mx;\npair<long long, long long> f[100005];\nint main() {\n  scanf(\"%d%d\", &n, &d);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &f[i].first, &f[i].second);\n  sort(f + 1, f + n + 1);\n  for (int i = 2; i <= n; i++) f[i].second += f[i - 1].second;\n  while (true) {\n    while (f[bb].first - f[ff].first < d && bb != n + 1) bb++;\n    mx = max(mx, f[bb - 1].second - f[ff - 1].second);\n    ff++;\n    if (ff == n + 1) break;\n  }\n  printf(\"%I64d\", mx);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class T>\nstruct greater {\n  bool operator()(const T& x, const T& y) const { return x > y; }\n};\nusing namespace std;\nint n, d;\nlong long int res, ii, s;\nvector<pair<long long int, long long int>> a;\nint main() {\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    a.push_back(make_pair(x, y));\n  }\n  sort(a.begin(), a.end());\n  s = 0, ii = 0;\n  for (int i = 0; i < n; i++) {\n    s += a[i].second;\n    while (a[i].first - a[ii].first >= d) {\n      s -= a[ii].second;\n      ii++;\n      if (ii == n) break;\n    }\n    res = max(res, s);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class KefaAndCompany{\n\n    // http://codeforces.com/problemset/problem/580/B\n    \n    static Map<Integer, Long> friendMap = new HashMap<>();\n    static List<Integer> moneyList;\n    static int placeholder = -1;\n    static int d;\n    static long maxFriendFactor = 0;\n    public static void main(String[] args){\n        Scanner input = new Scanner(System.in);\n\n        int n = input.nextInt();\n        d = input.nextInt();\n        friendMap = new HashMap<>();\n        \n        for (int i = 0; i < n; i++){\n            int m = input.nextInt();\n            int s = input.nextInt();\n            if (friendMap.keySet().contains(m)){\n                friendMap.put(m, friendMap.get(m) + s);\n            }\n            else{\n                friendMap.put(m, (long)s);\n            }\n        }\n    \n        moneyList = new ArrayList<>();\n        for (int i: friendMap.keySet()){\n            moneyList.add(i);\n        }\n        \n        Collections.sort(moneyList); \n        long sum = 0; \n        int temptUpper = 0; // temporary upper from previous iteration\n\n        for(int lower = 0; lower < moneyList.size(); lower++){\n            // init sum\n            if(lower == 0){\n                int upper = binarySearchLeast(lower);\n                temptUpper = upper;\n                for (int i = lower; i <= upper; i++){\n                    sum += friendMap.get(moneyList.get(i));\n                }\n            }\n            // for each next iteration, there's no need to recalculate sum\n            // Instead one can reuse the previous sum by subtracting the \n            // friendship of previous lower and adding money of additional upper\n            else{\n                sum -= friendMap.get(moneyList.get(lower-1));\n                int upper = binarySearchLeast(lower);\n                for (int i = temptUpper+1; i <= upper; i++){\n                    sum += friendMap.get(moneyList.get(i));\n                }\n                temptUpper = upper;\n            }\n        \n            if (maxFriendFactor < sum){\n                maxFriendFactor = sum;\n            }\n        }\n\n        System.out.println(maxFriendFactor);\n        input.close();\n    }\n\n\n    /**\n     * lower-index = 2, d = 10\n     * [1,2,3,4,5,6,7,8,9,10,11,12,13,14] -> [3..12] -> return 11\n     * \n     * @param moneyList list of friends money in increasing order\n     * @param lower the current examined friend\n     * @return the index of the highest number that is no more than d-difference\n     * from number at lowerbound index\n     */\n    public static int binarySearchLeast(int lower){\n        int max = moneyList.get(lower) + d;\n        int lo = lower;\n        int hi = moneyList.size()-1;\n        //if (lower == 0){\n            while (lo<hi-1){\n                int mid = (int) Math.floor((lo+hi)/2);\n                if (moneyList.get(mid) < max){\n                    lo = mid;\n                }\n                else{\n                    hi = mid;\n                }\n            }\n            if (moneyList.get(hi) >= max){\n                placeholder = lo;\n                return lo;\n            }\n            else{\n                placeholder = hi;\n                return hi;\n            }\n        //}\n        \n        // else{\n        //     for (int i = placeholder; i < moneyList.size(); i++){\n        //         placeholder = i;\n                \n        //         if(moneyList.get(i) >= max){\n        //             placeholder = i-1;\n        //             break;\n        //         }\n        //     }\n        // }\n        // return placeholder;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "\nimport  operator\nclass PII():\n    def __init__(self,F,S):\n        self.F=F\n        self.S=S\nif __name__==\"__main__\":\n    n,d=[int(x) for x in input().split()]\n    a=[]\n    for i in range(n):\n        F,S=[int(x) for x in input().split()]\n        a.append(PII(F,S))\n    a.sort(key=operator.attrgetter('F'))\n    idx=0\n    mx=a[0].S\n    amt=a[0].S\n    for i in range(1,n):\n        if(a[i].F-a[idx].F<d):\n            amt+=a[i].S\n        else:\n            mx=max(mx,amt)\n            j=idx\n            while(a[i].F-a[j].F>=d):\n                amt-=a[j].S\n                j+=1\n            idx=j\n            amt+=a[i].S\n    mx=max(mx,amt)\n    print(mx)\n"
        },
        {
            "language": 3,
            "solution": "##2 pointers in sequence\nn, d = map(int, input().split())\nm_s = sorted(tuple(map(int, input().split())) for _ in range(n))\ns, max_s, i = 0, 0, 0\nfor j in range(n):\n    s += m_s[j][1]\n    while m_s[j][0] - m_s[i][0] >= d:\n        s -= m_s[i][1]\n        i += 1\n    max_s = max(max_s, s)\nprint(max_s)"
        },
        {
            "language": 3,
            "solution": "n = input().split(' ')\nn,d = int(n[0]), int(n[1])\na = [0]*n\nfor i in range(n):\n\tm = input().split(' ')\n\ta[i] = [int(m[0]), int(m[1])]\na.sort()\nmaxD = 0\ncount = a[0][1]\ni,j = 0, 1\n#print(a)\nwhile j < n:\n\t#print(count)\n\tif a[j][0] - a[i][0] < d:\n\t\tcount += a[j][1]\n\t\tj+=1\n\telse:\n\t\tmaxD = max(count, maxD)\n\t\tcount -= a[i][1]\n\t\ti+=1\n\nprint( max(count, maxD))"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class KefaAndCompany {\n    public static void main(String[] args) {\n        FasterScanner sc = new FasterScanner();\n        \n        int N = sc.nextInt();\n        long D = sc.nextLong();\n        \n        Friend[] friends = new Friend[N];\n        for (int i = 0; i < N; i++) {\n        \tlong M = sc.nextLong();\n        \tlong F = sc.nextLong();\n        \tfriends[i] = new Friend(M, F);\n        }\n        Arrays.sort(friends, new Comparator<Friend>() {\n        \tpublic int compare(Friend f1, Friend f2) {\n        \t\treturn Long.compare(f1.money, f2.money);\n        \t}\n\t\t});\n        \n        int L = 0;\n        int R = 0;\n        long sum = friends[L].factor;\n        long best = friends[L].factor;\n        while (L < N) {\n        \twhile (R < N - 1 && friends[R + 1].money - friends[L].money < D) {\n        \t\tR++;\n        \t\tsum += friends[R].factor;\n        \t\tbest = Math.max(best, sum);\n        \t}\n        \tsum -= friends[L].factor;\n        \tL++;\n        }\n        System.out.println(best);\n    }\n    \n    public static class Friend {\n    \tpublic long money;\n    \tpublic long factor;\n    \t\n    \tpublic Friend(long m, long f) {\n    \t\tthis.money = m;\n    \t\tthis.factor = f;\n    \t}\n    }\n    \n\tpublic static class FasterScanner {\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = System.in.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\t        \n\t    public int[] nextIntArray(int n) {\n\t        int[] arr = new int[n];\n\t        for (int i = 0; i < n; i++) {\n\t            arr[i] = nextInt();\n\t        }\n\t        return arr;\n\t    }\n        \n\t\tpublic long[] nextLongArray(int n) {\n\t\t    long[] arr = new long[n];\n\t\t    for (int i = 0; i < n; i++) {\n\t\t        arr[i] = nextLong();\n\t\t    }\n\t\t    return arr;\n\t\t}\n\n\t    private boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct p {\n  int m;\n  int s;\n} a[100001];\nbool camp(p aa, p bb) { return aa.m < bb.m; }\nint main() {\n  long long b[100001], max, result;\n  int n, d, i, l, r, mid;\n  scanf(\"%d%d\", &n, &d);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d%d\", &a[i].m, &a[i].s);\n  }\n  sort(a, a + n, camp);\n  b[0] = 0;\n  for (i = 0; i < n; i++) b[i + 1] = a[i].s + b[i];\n  max = -1;\n  for (i = 0; i < n; i++) {\n    l = i;\n    r = n;\n    while (r - l > 1) {\n      mid = (l + r) / 2;\n      if (a[mid].m - a[i].m < d)\n        l = mid;\n      else\n        r = mid;\n    }\n    result = b[l + 1] - b[i];\n    if (result > max) max = result;\n  }\n  printf(\"%lld\\n\", max);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct myComp {\n  bool operator()(vector<int> const &a, vector<int> const &b) {\n    return a[2] > b[2];\n  }\n};\nvoid articualtion(vector<int> graph[], int v, int parent, vector<bool> &visited,\n                  vector<int> &visit, vector<int> &low, vector<bool> &ap) {\n  static int time = 0;\n  visited[v] = 1;\n  low[v] = time++;\n  visit[v] = low[v];\n  if (parent == -1) {\n    int count = 0;\n    for (int i = 0; i < graph[v].size(); i++)\n      if (!visited[graph[v][i]]) {\n        articualtion(graph, graph[v][i], v, visited, visit, low, ap);\n        count++;\n      }\n    if (count > 1) ap[v] = 1;\n    return;\n  }\n  for (int i = 0; i < graph[v].size(); i++) {\n    if (graph[v][i] == parent)\n      continue;\n    else if (visited[graph[v][i]]) {\n      low[v] = min(low[v], low[graph[v][i]]);\n      continue;\n    }\n    articualtion(graph, graph[v][i], v, visited, visit, low, ap);\n    if (low[graph[v][i]] >= visit[v]) ap[v] = 1;\n    low[v] = min(low[v], low[graph[v][i]]);\n  }\n  return;\n}\nint main() {\n  int n, d;\n  cin >> n >> d;\n  pair<long long, long long> arr[n];\n  for (int i = 0; i < n; i++) {\n    long long a, b;\n    cin >> a >> b;\n    arr[i].first = a;\n    arr[i].second = b;\n  }\n  sort(arr, arr + n);\n  vector<long long> temp(n);\n  for (int i = 0; i < n; i++) temp[i] = arr[i].first;\n  long long pre[n + 1];\n  pre[0] = 0;\n  for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + arr[i - 1].second;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    int ind = lower_bound(temp.begin(), temp.end(), temp[i] + d) - temp.begin();\n    ind--;\n    ans = max(ans, pre[ind + 1] - pre[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool sortcol(const vector<long long>& v1, const vector<long long>& v2) {\n  return v1[0] < v2[0];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(0);\n  long long n, d;\n  cin >> n >> d;\n  vector<vector<long long> > a(n);\n  for (int i = 0; i < n; i++) {\n    long long c, b;\n    cin >> c >> b;\n    a[i].push_back(c);\n    a[i].push_back(b);\n  }\n  sort(a.begin(), a.end(), sortcol);\n  long long sum[n];\n  memset(sum, 0, sizeof(sum));\n  sum[0] = a[0][1];\n  for (int i = 1; i < n; i++) {\n    sum[i] = sum[i - 1] + a[i][1];\n  }\n  long long maxi = a[0][1];\n  long long j = 0;\n  for (int i = 0; i < n; i++) {\n    long long t = i;\n    while ((j < n) && ((a[j][0] - a[i][0]) < d)) {\n      t = j;\n      j++;\n    }\n    maxi = max(maxi, sum[t] - sum[i] + a[i][1]);\n  }\n  cout << maxi;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from operator import itemgetter\nimport time\nn, d = [int(x) for x in input(\"\").split()]\nfriends = []\nfor i in range(n):\n    aux = [int(x) for x in input(\"\").split()]\n    friends.append((aux[0], aux[1]))\nfriends = sorted(friends, key=itemgetter(0))\nprimero = 0\nsegundo = 1\n\n\ndef cumple(a, b):\n    return friends[b][0] - friends[a][0] < d\n\n\nactual = friends[0][1]\nmaximo = friends[0][1]\nwhile primero != len(friends) - 1:\n    if cumple(primero, segundo):\n        actual += friends[segundo][1]\n        segundo += 1\n        if maximo < actual:\n            maximo = actual\n    else:\n        while not cumple(primero, segundo) and primero != segundo:\n            actual -= friends[primero][1]\n            primero += 1\n        if primero == segundo:\n            segundo += 1\n            actual = friends[primero][1]\n            if maximo < actual:\n                maximo = actual\n        if segundo == len(friends):\n            segundo -= 1\n    if segundo == len(friends):\n        break\nprint(maximo)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool func(pair<int, int> a, pair<int, int> b) { return a.first < b.first; }\nint binsearch(vector<pair<int, int> > &mf, int i, int n, int d) {\n  int s = i, e = n - 1, m;\n  int find = mf[i].first + d;\n  while (s <= e) {\n    m = (s + e) / 2;\n    if (m > n - 1) m = n - 1;\n    if (mf[m].first >= find)\n      e = m - 1;\n    else if (m < n - 1 && mf[m + 1].first < find)\n      s = m + 1;\n    else\n      break;\n  }\n  return m;\n}\nint main() {\n  int n, d, i, j;\n  long long k, mx;\n  cin >> n >> d;\n  vector<pair<int, int> > mf(n, make_pair(0, 0));\n  for (i = 0; i < n; i++) cin >> mf[i].first >> mf[i].second;\n  sort(mf.begin(), mf.end(), func);\n  long long *csum = new long long[n];\n  csum[0] = mf[0].second;\n  for (i = 1; i < n; i++) csum[i] = mf[i].second + csum[i - 1];\n  j = binsearch(mf, 0, n, d);\n  mx = csum[j];\n  for (i = 1; i < n; i++) {\n    j = binsearch(mf, i, n, d);\n    k = csum[j] - csum[i - 1];\n    if (k > mx) mx = k;\n  }\n  cout << mx;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000010;\nint n, d, R;\nlong long s[MAXN], ans;\npair<int, int> p[MAXN];\nint main() {\n  scanf(\"%d%d\", &n, &d);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n  sort(p + 1, p + n + 1);\n  for (int i = 1; i <= n; i++) s[i] = s[i - 1] + p[i].second;\n  for (int L = 1; L <= n; L++) {\n    R = max(L, R);\n    while (R + 1 <= n && p[R + 1].first - p[L].first < d) R++;\n    ans = max(ans, s[R] - s[L - 1]);\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\n/*\n4 2\n10909234 9\n10909236 8\n10909237 10\n10909235 98\n\n*/\n\n\npublic class Main {\n\tstatic FastReader sc=null;\n\t\n\tpublic static void main(String[] args) {\n\t\tsc=new FastReader();\n\t\tint n=sc.nextInt(),d=sc.nextInt();\n\t\tfriend a[]=new friend[n];\n\t\tfor(int i=0;i<n;i++)a[i]=new friend(sc.nextInt(),sc.nextInt());\n\t\tArrays.sort(a);\n        long ans =0,max=0;\n\t\t\n\t\tfor(int l =0,r=0;r<n;)\n\t\t{\n\t\t\t\n\t\t\tif(Math.abs(a[l].m-a[r].m)<d)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tans+=a[r].f;\n\t\t\t\tr++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmax=Long.max(max,ans);\n\t\t\t\tans-=a[l].f;\n\t\t\t\tl++;\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\tmax=Long.max(max,ans);\n \n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(max);\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic class friend implements Comparable<friend>{\n\t\tint m,f;\n\t\tfriend(int money,int fac){\n\t\t\tthis.m=money;\n\t\t\tthis.f=fac;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(friend o) {\n\t\t\treturn this.m-o.m;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic int[] ruffleSort(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al);\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\t\n\t\n\t\n\tstatic void print(ArrayList<Integer> al) {\n\t\tfor(int e:al) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tstatic void print(int a[]) {\n\t\tfor(int e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tstatic void print(long a[]) {\n\t\tfor(long e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tstatic long gcd(long a,long b) {\n\t\tif(b==0)return a;\n\t\telse return gcd(b,a%b);\n\t}\n\t\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n        int[] readArray(int n) {\n    \t\tint a[]=new int [n];\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\ta[i]=sc.nextInt();\n    \t\t}\n    \t\treturn a;\n    \t}\n    } \n}\n\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "[friendsSize, moneyDiff] = [int(x) for x in input().split()]\nfriends = []\nfor i in range(friendsSize):\n\tfriendMoney, currentPoints = map(int, input().split())\n\tfriends.append([friendMoney, currentPoints])\n\nfriends = sorted(friends)\n\ncurrentPoints = 0\nmaxPoints = 0\n\nj = 0\nfor i in range(friendsSize):\n\twhile j < friendsSize and abs(friends[i][0] - friends[j][0]) < moneyDiff:\n\t\tcurrentPoints += friends[j][1]\n\t\tj += 1\n\tif currentPoints >= maxPoints:\n\t\tmaxPoints = currentPoints\n\tcurrentPoints -= friends[i][1]\n\t\nprint(maxPoints)"
        },
        {
            "language": 3,
            "solution": "n,d = map(int,input().split())\n\nvals = []\nfor i in range(n):\n    m,s=map(int, input().split())\n    vals.append((m,s))\n\nvals.sort()\n\nmaxVal = vals[0][1]\nposition = 1\ntotals = vals[0][1]\n\nfor m,s in vals:\n    while position < len(vals) and vals[position][0]< m+d:\n        totals+=vals[position][1]\n        position+=1\n    \n    if totals > maxVal:\n        maxVal=totals\n\n    totals-=s\n\nprint(maxVal)        \n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class CF580B {\n    static class Pair{\n        int money;\n        int factor;\n        Pair(int money,int factor){\n            this.money = money;\n            this.factor = factor;\n        }\n    }\n    public static void main(String[] args) {\n        FastReader input = new FastReader();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = input.nextInt();\n        int d = input.nextInt();\n\n        ArrayList<Pair> list = new ArrayList<>();\n        for(int i = 1;i <= n;i++){\n            int money = input.nextInt();\n            int factor = input.nextInt();\n            list.add(new Pair(money,factor));\n        }\n\n        Collections.sort(list, new Comparator<Pair>() {\n            @Override\n            public int compare(Pair o1, Pair o2) {\n                if(o1.money == o2.money)\n                return 0;\n                else if(o1.money < o2.money)\n                    return -1;\n                else\n                    return 1;\n            }\n        });\n\n        long[] prefix = new long[n];\n        prefix[0] = list.get(0).factor;\n\n        for(int i = 1;i < list.size();i++){\n            prefix[i] = prefix[i-1] + list.get(i).factor;\n        }\n\n\n        long max = Integer.MIN_VALUE;\n        for(int i = list.size()-1;i >= 0;i--){\n            if(i == 0){\n                max = Math.max(max,list.get(i).factor);\n            }\n            else{\n                int left = 0;\n                int right = i;\n                int index = -1;\n                while (left <= right){\n                    int mid = (left + right) / 2;\n                    if(list.get(i).money - list.get(mid).money < d){\n                        index = mid;\n                        right = mid - 1;\n                    }\n                    else{\n                        left = mid + 1;\n                    }\n                }\n                if(index == 0){\n                    max = Math.max(max,prefix[i]);\n                }\n                else{\n                    max = Math.max(max,prefix[i] - prefix[index-1]);\n                }\n            }\n        }\n\n        pw.println(max);\n\n\n        // ****If sorting is required, use ArrayList\n        pw.flush();\n        pw.close();\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-9;\nconst int mod = (int)1e+9 + 7;\nconst double pi = acos(-1.);\nconst int maxn = 100100;\npair<long long, long long> p[maxn];\nint main() {\n  {\n    srand(time(0));\n    const string file = \"\";\n    if (!file.empty()) {\n      freopen((file + \".in\").c_str(), \"r\", stdin);\n      freopen((file + \".out\").c_str(), \"w\", stdout);\n    }\n  }\n  long long n, d;\n  scanf(\"%I64d%I64d\", &n, &d);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%I64d%I64d\", &p[i].first, &p[i].second);\n  }\n  sort(&p[0], &p[n]);\n  long long ans = 0, mans = 0;\n  for (int i = 0, f = 0; i < n; i++) {\n    while (f < n && p[f].first - p[i].first < d) {\n      ans += p[f++].second;\n    }\n    mans = max(mans, ans);\n    ans -= p[i].second;\n  }\n  printf(\"%I64d\", mans);\n  return (0);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Restaurant {\n\n    static StreamTokenizer in;\n\n    static int nextInt() throws IOException {\n        in.nextToken();\n        return (int)in.nval;\n    }\n\n    static class Friend {\n        long money, friendship; Friend(long _m, long _f) { money = _m; friendship = _f; }\n    }\n\n    public static void main(String[] args) throws Exception {\n        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\n        int n = nextInt();\n        int d = nextInt();\n        Friend[] friends = new Friend[n];\n        for (int i = 0; i < n; i++)\n            friends[i] = new Friend(nextInt(), nextInt());\n\n        Arrays.sort(friends, (a, b) -> (int)(a.money - b.money));\n\n        int left = 0;\n        long friendship = 0;\n        long max = 0;\n        for (int i = 0; i < n; i++) {\n            while (friends[i].money - d >= friends[left].money)\n                friendship -= friends[left++].friendship;\n            friendship += friends[i].friendship;\n            max = Math.max(max, friendship);\n        }\n\n        System.out.println(max);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\npublic class Main {\n\n    public static void main(String[] args) {\nScanner input=new Scanner(System.in);\nint n=input.nextInt();\nint d=input.nextInt();\nfriend a[]= new friend[n];\nfor(int i=0;i<n;i++){\n    a[i]=new friend(input.nextInt(),input.nextInt());\n}\nArrays.sort(a,new Comparator<friend>(){\n    public int compare(friend a,friend b){\n        return a.m-b.m;\n    }});\n    long sum=0;\n    long max=Long.MIN_VALUE;\n    int index=0;\n    \n    for(int i=0;i<n;i++){\n        //sum=0;\n        while(index<n && a[index].m-a[i].m<d){\n            sum+=a[index++].f;\n            \n        }\n        max=Math.max(max,sum);\n        sum-=a[i].f;\n    //System.out.println(\"SUM:\"+sum);\n\n    }\n\nSystem.out.println(max);\n    }\n    public static class friend{\n        int m,f;\n        public friend(int money,int factor){\n            m=money;\n            f=factor;\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d = map(int,input().split())\ncounter = 0\nmaximum = 0\ntotal = 0\nlist = sorted([list(map(int,input().split())) for x in range(n)])\nfor i in range(n):\n    while counter < n and list[counter][0]-list[i][0] < d:\n        total += list[counter][1]\n        counter += 1\n    maximum = max(maximum,total)\n    total -= list[i][1]\nprint(maximum)\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization(\"unroll-loops\")\nusing namespace std;\ndouble pi = acos(-1);\nconst long long MOD = 1000000007;\nvoid OJ() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n}\nint main() {\n  OJ();\n  clock_t clk = clock();\n  long long n, d, ans = 0;\n  cin >> n >> d;\n  map<long long, long long> m;\n  for (long long i = 0; i < n; i++) {\n    long long a, b;\n    cin >> a >> b;\n    if (m.count(a))\n      m[a] += b;\n    else\n      m[a] = b;\n  }\n  vector<long long> pre, temp;\n  for (auto i : m) {\n    if (pre.size() == 0)\n      pre.push_back(i.second);\n    else\n      pre.push_back(pre.back() + i.second);\n    temp.push_back(i.first);\n  }\n  n = temp.size();\n  for (long long i = 0; i < n; i++) {\n    long long lw =\n        lower_bound(temp.begin(), temp.end(), temp[i] + d) - temp.begin();\n    lw--;\n    long long val;\n    if (i) {\n      val = pre[lw] - pre[i - 1];\n    } else {\n      val = pre[lw];\n    }\n    ans = max(ans, val);\n  }\n  cout << ans;\n  clk = clock() - clk;\n  cerr << \"Time Elapsed: \" << fixed << setprecision(10)\n       << ((long double)clk) / CLOCKS_PER_SEC << \"\\n\";\n}\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\nship = 0\nfriends = []\n\nfor i in xrange(n):\n    friends.append(map(int, raw_input().split()))\n\n# Ordenar pelo dinheiro\nsFriends = sorted(friends, key=lambda x: x[0])\n\ni = 0\nj = 0\nsP = 0\nwhile i < n:\n    if abs(sFriends[i][0] - sFriends[j][0]) < d:\n        sP += sFriends[i][1]\n        i += 1\n        if (i == n):\n            if sP > ship:\n                ship = sP\n    else:\n        if sP > ship:\n                ship = sP\n        sP -= sFriends[j][1]\n        j += 1\n\nprint ship\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\n\narr = []\n\nfor i in range(n):\n    temp = list(map(int, input().split()))\n    arr.append(temp)\n\narr = sorted(arr)\n\nfri_factor = 0\nmx_fri_factor = 0\nmoney_min = arr[0][0]\n\nl = 0\nr = 0\nwhile(l<=n-1):\n    \n    while(l<=r and r <n):\n        if arr[r][0] - arr[l][0] < d:\n            fri_factor+= arr[r][1]\n            r+=1\n        else:\n            break\n\n    \n    mx_fri_factor =  max(mx_fri_factor, fri_factor)\n    fri_factor -= arr[l][1]\n    l+=1\n    \n\n\nprint(mx_fri_factor)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstruct help {\n  long int money;\n  long int friends;\n};\nvoid fusion_sort(struct help *p, long int n);\nvoid bablesort(struct help *p, long int n);\nint main() {\n  long int n, m;\n  scanf(\"%ld %ld\", &n, &m);\n  struct help *p = (struct help *)malloc(sizeof(struct help) * n);\n  for (int i = 0; i < n; i++) scanf(\"%ld %ld\", &p[i].money, &p[i].friends);\n  if (n == 1) {\n    printf(\"%ld\", p[0].friends);\n    return 0;\n  }\n  if (n > 1000)\n    fusion_sort(p, n);\n  else\n    bablesort(p, n);\n  unsigned long long max_friend = 0;\n  unsigned long long cur_sum = 0;\n  for (int b = 0, e = 0; e < n;)\n    if (p[e].money - p[b].money >= m) {\n      if (cur_sum > max_friend) {\n        max_friend = cur_sum;\n      }\n      cur_sum -= p[b].friends;\n      b++;\n    } else {\n      cur_sum += p[e].friends;\n      e++;\n    }\n  if (cur_sum > max_friend) max_friend = cur_sum;\n  printf(\"%lld\", max_friend);\n  return 0;\n}\nvoid fusion_sort(struct help *p, long int n) {\n  if (n > 2) {\n    fusion_sort(p, n / 2);\n    fusion_sort((p + n / 2), n / 2 + n % 2);\n  }\n  struct help temp;\n  for (int i = 0, j = n / 2; i < j && j < n; i++)\n    if (p[i].money > p[j].money) {\n      temp.friends = p[j].friends;\n      temp.money = p[j].money;\n      for (int k = j; k > i; k--) {\n        p[k].friends = p[k - 1].friends;\n        p[k].money = p[k - 1].money;\n      }\n      p[i].friends = temp.friends;\n      p[i].money = temp.money;\n      j++;\n    }\n}\nvoid bablesort(struct help *p, long int n) {\n  long int fr;\n  long int mo;\n  while (n > 1) {\n    for (int i = 0; i < n - 1; i++)\n      if (p[i].money > p[i + 1].money) {\n        fr = p[i].friends;\n        mo = p[i].money;\n        p[i].friends = p[i + 1].friends;\n        p[i].money = p[i + 1].money;\n        p[i + 1].friends = fr;\n        p[i + 1].money = mo;\n      }\n    n--;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nli = sorted([list(map(int, input().split())) for i in range(n)])\ntemp = ans = li[0][1]\nj = 0\nfor i in range(1, n):\n    while li[i][0] >= li[j][0] + d:\n        temp -= li[j][1]\n        j += 1\n    temp += li[i][1]\n    ans = max(temp, ans)\nprint(ans)\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\na = 0\nn = 0\nd = 0\ng = []\n\nfor line in sys.stdin:\n\tline = line[0:len(line)]\n\tl = line.split(\" \")\n\tif a != 0:\n\t\tc = int(l[0])\n\t\tf = int(l[1])\n\t\tg.append((c,f))\n\t\t\n\telse:\n\t\tn = int(l[0])\n\t\td = int(l[1])\n\t\ta = 1\n\ng = sorted(g, key=lambda friend: friend[0]) \n\ni = 0\nj = 0\nz = 0\ns = 0\n\nwhile j != n:\n\tif abs(g[i][0] - g[j][0]) < d:\n\t\ts = s + g[j][1]\n\t\tif s > z:\n\t\t\tz = s\n\t\tj = j + 1\n\telse:\n\t\ts = s - g[i][1]\n\t\ti = i + 1\n\nprint z"
        },
        {
            "language": 3,
            "solution": "\n\nn , d = map(int,input().split())\n\nl = []\n\nfor i in range(n):\n    x , y = map(int,input().split())\n    l.append([x , y])\n\nl.sort()\n\ni = 0\nsm = 0\nans = 0\n\nfor j in range(n):\n    sm += l[j][1]\n    while(l[j][0] - l[i][0] >= d):\n        sm -= l[i][1]\n        i +=1\n    ans = max(ans , sm)\n\nprint(ans)\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, d, m, s;\n  vector<pair<long long, long long> > vp;\n  cin >> n >> d;\n  for (int i = 0; i < n; ++i) {\n    cin >> m >> s;\n    vp.push_back(make_pair(m, s));\n  }\n  sort(vp.begin(), vp.end());\n  long long maxx = 0.0;\n  long long res = 0.0;\n  for (int pt1 = 0, pt2 = 0; pt2 < n;) {\n    if (abs(vp[pt1].first - vp[pt2].first) < d) {\n      res += vp[pt2].second;\n      pt2++;\n    } else {\n      maxx = max(maxx, res);\n      res -= vp[pt1].second;\n      pt1++;\n    }\n    maxx = max(maxx, res);\n  }\n  cout << maxx;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, d;\npair<int, int> a[200005];\nlong long sum[200005];\nint main() {\n  scanf(\"%d%d\", &n, &d);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &a[i].first, &a[i].second);\n  }\n  sort(a, a + n);\n  long long cur = 0;\n  for (int i = 0; i < n; ++i) {\n    cur += a[i].second;\n    sum[i] = cur;\n  }\n  long long ans = 0;\n  int pos = 0;\n  for (int i = 0; i < n; ++i) {\n    while (pos < n && a[pos].first - a[i].first < d) pos++;\n    long long ret = sum[pos - 1];\n    if (i) ret -= sum[i - 1];\n    ans = max(ans, ret);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\nmon = []\ndic = dict()\nfor i in range(n):\n    m, s = map(int, raw_input().split())\n    if m not in dic:\n        mon.append(m)\n        dic[m] = s\n    else:\n        dic[m] += s\nmon.sort()\nres = 0\ni = 0\nwhile (i < len(mon)) and (mon[i] - mon[0] < d):\n    res += dic[mon[i]]\n    i += 1\ncur = res\nj = 0\nwhile i < len(mon):\n    cur += dic[mon[i]]\n    while mon[j] + d <= mon[i]:\n        cur -= dic[mon[j]]\n        j += 1\n    res = max(res, cur)\n    i += 1\nprint(res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool isPrime(int n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (int i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  std::cout.precision(15);\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<long long, long long>> v;\n  for (int i = 0; i < n; i++) {\n    long long a, b;\n    cin >> a >> b;\n    v.push_back({a, b});\n  }\n  sort(v.begin(), v.end());\n  long long o = 0, ma = 0, l, r = 0;\n  for (l = 0; l < n; l++) {\n    while (r < n && abs(v[l].first - v[r].first) < m) {\n      o = o + v[r].second;\n      r++;\n    }\n    if (o >= ma) ma = o;\n    o = o - v[l].second;\n  }\n  cout << ma;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, d, now = 0, ans = 0;\npair<long long, long long> a[100005];\nvoid solve() {\n  cin >> n >> d;\n  for (long long i = (0); i < (n); ++i) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a, a + n);\n  int right = n - 1;\n  for (int left = n - 1; left >= 0; left--) {\n    if (a[right].first - a[left].first < d) {\n      now += a[left].second;\n    } else {\n      ans = max(now, ans);\n      now += a[left].second;\n      while (a[right].first - a[left].first >= d && right > left) {\n        now -= a[right].second;\n        right--;\n      }\n      ans = max(now, ans);\n    }\n  }\n  ans = max(now, ans);\n  cout << ans;\n}\nint main() {\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Map.Entry;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\tpublic static void main(String args[]) throws NumberFormatException,IOException {\n\t\t\n\t\tStdin in = new Stdin();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n=in.readInt();\n\t\tint d=in.readInt();\n\t\tTreeMap<Long,Long>factir=new TreeMap<Long,Long>();\n\t\tlong m,s;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tm=in.readLong();\n\t\t\ts=in.readLong();\n\t\t\tif(factir.containsKey(m)){\n\t\t\t\tfactir.put(m, s+factir.get(m));\n\t\t\t}else{\n\t\t\t\tfactir.put(m, s);\n\t\t\t}\n\t\t}\n\t\tlong money[]=new long[factir.size()];\n\t\tlong fac[]=new long[factir.size()];\n\t\tint pos=0;\n\t\tfor(Entry<Long,Long>entry:factir.entrySet()){\n\t\t\tmoney[pos]=entry.getKey();\n\t\t\tfac[pos++]=entry.getValue();\n\t\t}\n\t\tfor(int i=1;i<fac.length;i++){\n\t\t\tfac[i]+=fac[i-1];\n\t\t}\n\t\tlong max=0;\n\t\tfor(int i=0;i<fac.length;i++){\n\t\t\tint index=Arrays.binarySearch(money,d+money[i]);\n\t\t\tif(index>=0){\n\t\t\t\tmax=max(max,(index==0?fac[0]:fac[index-1])-(i==0?0:fac[i-1]));\n\t\t\t}else{\n\t\t\t\tif(-index>fac.length){\n\t\t\t\t\tmax=max(max,fac[fac.length-1]-(i==0?0:fac[i-1]));\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tindex=-index-2;\n\t\t\t\t\tmax=max(max,fac[index]-(i==0?0:fac[i-1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(max);\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\tprivate static long max(long a,long b){\n\t\treturn a<b?b:a;\n\t}\n\tprivate static class Stdin {\n\t\tInputStreamReader read;\n\t\tBufferedReader br;\n\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\n\t\tprivate Stdin() {\n\t\t\tread = new InputStreamReader(System.in);\n\t\t\tbr = new BufferedReader(read);\n\n\t\t}\n\n\t\tprivate String readNext() throws IOException {\n\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tprivate int readInt() throws IOException, NumberFormatException {\n\n\t\t\treturn Integer.parseInt(readNext());\n\n\t\t}\n\n\t\tprivate long readLong() throws IOException, NumberFormatException {\n\n\t\t\treturn Long.parseLong(readNext());\n\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-9;\nconst int INF = 0x7f7f7f7f;\nconst double PI = acos(-1.0);\ntemplate <class T>\ninline T _abs(T n) {\n  return ((n) < 0 ? -(n) : (n));\n}\ntemplate <class T>\ninline T _max(T a, T b) {\n  return (!((a) < (b)) ? (a) : (b));\n}\ntemplate <class T>\ninline T _min(T a, T b) {\n  return (((a) < (b)) ? (a) : (b));\n}\ntemplate <class T>\ninline T gcd(T a, T b) {\n  return (b) == 0 ? (a) : gcd((b), ((a) % (b)));\n}\ntemplate <class T>\ninline T lcm(T a, T b) {\n  return ((a) / gcd((a), (b)) * (b));\n}\nstruct debugger {\n  template <typename T>\n  debugger& operator,(const T& v) {\n    cerr << v << \" \";\n    return *this;\n  }\n} dbg;\nstruct data {\n  int money, fact;\n  data() { ; }\n  data(int a, int b) {\n    money = a;\n    fact = b;\n  }\n};\nbool cmp(const data& a, const data& b) {\n  if (a.money < b.money)\n    return true;\n  else if (a.money == b.money)\n    return a.fact > b.fact;\n  return false;\n}\nint main() {\n  int n, d;\n  while (~scanf(\"%d%d\", &n, &d)) {\n    vector<data> v;\n    data x;\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%d%d\", &x.money, &x.fact);\n      v.push_back(x);\n    }\n    sort(v.begin(), v.end(), cmp);\n    long long ans = 0, temp = 0;\n    int strt = 0;\n    for (int i = 0; i < n; i++) {\n      if (i) {\n        if (v[i].money - v[i - 1].money >= d) {\n          strt = i;\n          temp = v[i].fact;\n        } else if (v[i].money - v[strt].money >= d) {\n          while (strt < i && v[i].money - v[strt].money >= d) {\n            temp -= v[strt].fact;\n            strt++;\n          }\n          temp += v[i].fact;\n        } else\n          temp += v[i].fact;\n      } else\n        temp = v[i].fact;\n      ans = max(ans, temp);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nm_s = []\nfor _ in range(n):\n    m, s = map(int, input().split())\n    m_s.append((m, s))\nm_s.sort()\ns = 0\nmax_s = 0\ni = 0\nfor j in range(n):\n    s += m_s[j][1]\n    while m_s[j][0] - m_s[i][0] >= d:\n        s -= m_s[i][1]\n        i += 1\n    max_s = max(max_s, s)\nprint(max_s)"
        },
        {
            "language": 3,
            "solution": "n, min_diff = [int(i) for i in input().split()]\npairs = []\nfor _ in range(n):\n    m, f = map(int, input().split())\n    pairs.append((m, f))\npairs.sort()\ni = 0\nj = 0\ntotal = 0\nans = 0\nwhile j < len(pairs):\n    total += pairs[j][1]\n    while pairs[j][0] - min_diff >= pairs[i][0] and i <= j:\n        total -= pairs[i][1]\n        i += 1\n    ans = max(ans, total)\n    j += 1\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n\npublic class Main implements Runnable {\n    public BufferedReader in;\n    public PrintWriter out;\n    public StringTokenizer tok;\n    \n    \n    public void solve() throws Exception {\n        int n = nextInt();\n        int d = nextInt();\n        Anastasia[] a = new Anastasia[n];\n        for (int i = 0; i < n; ++i) {\n            a[i] = new Anastasia(nextInt(), nextInt());\n        }\n        Arrays.sort(a);\n        long res = 0;\n        int j = 0;\n        long sum = 0;\n        for (int i = 0; i < n; ++i) {\n            sum += a[i].s;\n            while (a[i].m - a[j].m >= d) {\n                sum -= a[j].s;\n                ++j;\n            }\n            res = Math.max(sum, res);\n        }\n        out.println(res);\n    }\n    \n    public class Anastasia implements Comparable<Anastasia> {\n        int m, s;\n        \n        Anastasia(int m, int s) {\n            this.m = m;\n            this.s = s;\n        }\n        \n        public int compareTo(Anastasia other) {\n            return Integer.compare(this.m, other.m);\n        }\n    }\n    \n    public int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    public BigInteger nextBigInteger() throws IOException {\n        return new BigInteger(next());\n    }\n    \n    public String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n    \n    public String nextLine() throws IOException {\n        tok = new StringTokenizer(\"\");\n        return in.readLine();\n    }\n\n    public boolean hasNext() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            String s = in.readLine();\n            if (s == null) {\n                return false;\n            }\n            tok = new StringTokenizer(s);\n        }\n        return true;\n    }\n    \n    public static void main(String args[]) {\n        new Thread(null, new Main(), \"Main\", 1 << 28).start();\n    }\n    \n    public void run() {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            //in = new BufferedReader(new FileReader(\"input.in\"));\n            //out = new PrintWriter(new FileWriter(\"output.out\"));\n            Locale.setDefault(Locale.US);\n            solve();\n            in.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            java.lang.System.exit(1);\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "//package Div2A;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class kefaAndCompany {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\t\n\t\tfriends arr[]= new friends[n];\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = new friends(sc.nextInt(), sc.nextInt());\n\t\t}\n\t\tArrays.sort(arr);\n\t\tlong max= 0;\n\t\tlong ans = 0;\n\t\tfor (int r= 0,l=0; r < arr.length;) {\n\t\t\tif(Math.abs(arr[r].m-arr[l].m)<d) {\n\t\t\t\tans+=arr[r].f;\n\t\t\t\tr++;\n\t\t\t}else {\n\t\t\t\tmax = Long.max(ans,max);\n\t\t\t\tans-=arr[l].f;\n\t\t\t\tl++;\n\t\t\t\t\n\t\t\t}\n\t\t\tmax = Long.max(ans,max);\n\t\t}\n\t\tSystem.out.println(max);\n\n\t}\n\n}\nclass friends implements Comparable<friends> {\n\tint m,f;\n\tpublic friends(int m,int f) {\n\t\tthis.m =  m;\n\t\tthis.f = f;\n\t}\n\t@Override\n\tpublic int compareTo(friends o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn m-o.m;\n\t}\n\t\n}"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nfriends = []\nfor i in range(n):\n    m, s = map(int, input().split())\n    friends.append([m, s])\nmax_f = 0\n#print(d)\n\nfriends.sort(key = lambda x: x[0])\n#print(friends)\n\ni = 0\nj = 0\nf = 0\nwhile i < n: \n    #print(friends[i][0])\n    while j < n:\n        diff = friends[j][0]  - friends[i][0]\n        #print(\"diff\", diff)\n        if diff < d:\n            f += friends[j][1]\n            if f > max_f:\n                max_f = f\n                #print(\"i, j, max_f\", i, j, max_f)\n            j += 1\n        else:\n            break\n    f -= friends[i][1]\n    i += 1\nprint(max_f)\n    "
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split(\" \"))\np=[]\nfor _ in range(n):\n\tq=list(map(int,input().split(\" \")))\n\tp.append(q)\n\np=sorted(p, key =lambda k:(k[0]))\n\nfinalmax=curmax=p1=p2=0\n\nwhile p2<n:\n\tif p[p2][0]-p[p1][0]<d:\n\t\tcurmax+=p[p2][1]\n\t\tp2+=1\n\t\tfinalmax=max(finalmax,curmax)\n\n\telse:\n\t\tcurmax-=p[p1][1]\n\t\tp1+=1\nprint(finalmax)"
        },
        {
            "language": 1,
            "solution": "n,d=(int(i) for i in raw_input().split())\nl=[]\nfor i in range(0,n):\n    m,f=(int(i) for i in raw_input().split())\n    l.append([m,f])\nl.sort()\n#print l\nsf=0\ni=0\nwhile i<n:\n    if d<=(l[i][0]-l[0][0]):\n        #print \"YES\"\n        break\n    sf+=l[i][1]\n    i+=1\nmsf=sf\n#print i,sf\nfor j in range(1,n):\n    sf-=l[j-1][1]\n    while ((i<n) and (d>(l[i][0]-l[j][0]))):\n        sf+=l[i][1]\n        i+=1\n    if sf>msf:\n        msf=sf\nprint msf\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\n//Mann Shah [ DAIICT ].\n//fast io\n\npublic class Main {\n\tpublic static int mod = (int) (1e9 + 7);\n\tpublic static long inf = (long) 1e15 + 42;\n\tstatic InputReader in;\n\tstatic PrintWriter out;\n\n\tpublic static long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\n\t\n\n\tpublic static void main(String args[]) {\n\n\t\tin = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint d = in.nextInt();\n\t\tPair[] s = new Pair[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ts[i]= new Pair(in.nextInt(),in.nextInt());\n\t\t}\n\t\tArrays.sort(s,new Comparator<Pair>() {\n\t\t\t @Override public int compare(Pair p1, Pair p2){\n\t\t\t\t return p1.x - p2.x;\n\t\t\t }\n\t\t});\n\t\tlong ans=0;\n\t\t\n\t\tlong max=0;\n\t\tfor(int l=0,r=0;r<n;) {\n\t\t\tif(Math.abs(s[l].x-s[r].x)<d)\n\t\t\t{\n\t\t\t\tans+=s[r].y;\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmax=Math.max(max, ans);\n\t\t\t\tans-=s[l].y;\n\t\t\t\tl++;\n\t\t\t\t\n\t\t\t}\n\t\t\tmax=Math.max(max, ans);\n\t\t}\n\t\tout.println(max);\n\t\t\n\t\n\t\t\n\t\tout.close();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong a[] = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\n\t}\n\n}\n\n// For Pair sorting\n\n// Arrays.sort(arr,new Comparator<Pair>() {\n// @Override public int compare(Pair p1, Pair p2)\n// {\n// return p1.x - p2.x;\n// }\n// });\n\nclass Pair {\n\tint x;\n\tint y;\n\n\t// Constructor\n\tpublic Pair(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tPair p =(Pair)o;\n\t\treturn (x==p.x && y==p.y);\n\t}\n}\n\nclass couple implements Comparable<couple> {\n\tint x, y;\n\n\tpublic couple(int m, int f) {\n\t\tx = m;\n\t\ty = f;\n\t}\n\n\tpublic int compareTo(couple o) {\n\n\t\treturn x - o.x;\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\n\n\ndef solution():\n    n, d = map(int, next(stdin).split())\n    a = sorted(map(int, l.split()) for l in stdin)\n\n    j = 0\n    ans = 0\n    s = 0\n    for i in xrange(n):\n        s += a[i][1]\n        while j <= i and a[i][0] - a[j][0] >= d:\n            s -= a[j][1]\n            j += 1\n        ans = max(ans, s)\n\n    print ans\n\n\nsolution()\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##########################################################\nfrom collections import Counter\n# c=sorted((i,int(val))for i,val in enumerate(input().split()))\nimport heapq\n# c=sorted((i,int(val))for i,val in enumerate(input().split()))\n# n = int(input())\n# ls = list(map(int, input().split()))\n# n, k = map(int, input().split())\n# n =int(input())\n# e=list(map(int, input().split()))\n# n =int(input())\nfrom collections import Counter\n#for _ in range(int(input())):\nn, d = map(int, input().split())\nans=0\nls=[]\nfor i in range(n):\n    m,f= map(int, input().split())\n    ls.append((m,f))\nls.sort()\nptr=0\ns=0\nfor i in range(n):\n    s+=ls[i][1]\n    while ptr<n and (ls[i][0]-ls[ptr][0])>=d:\n        s -= ls[ptr][1]\n        ptr+=1\n\n    ans=max(ans,s)\nprint(ans)\n\n\n"
        },
        {
            "language": 3,
            "solution": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Dec 11 12:58:17 2018\n\n@author: Arsanuos\n\"\"\"\ndef solve():\n    rd = lambda: list(map(int , input().split()))\n    n, d = rd()\n    arr = []\n    for i in range(n):\n        a, b = rd()\n        arr.append((a, b))\n    arr.sort()\n    prev = -1\n    val = -1\n    tmp = -1\n    for i, t in enumerate(arr):\n        a, b = t\n        if prev == -1:\n            val = b\n            prev = i\n        else:\n            if (a - arr[prev][0] < d):\n                #not poor\n                val += b\n            else:\n                tmp = max(val, tmp)\n                while a - arr[prev][0] >= d:\n                    val -= arr[prev][1]\n                    prev += 1\n                val += b\n    print(max(tmp, val))\n    \n    \nsolve()"
        },
        {
            "language": 1,
            "solution": "n,d=map(int,raw_input().split())\na=[0]*n\nfor i in xrange(n):\n  a[i]=map(int,raw_input().split())\na=sorted(a)\nstart=0\nend=0\nfr=0\nfrMax=fr\nwhile True:\n  if a[end][0] - a[start][0] >= d:\n    fr-=a[start][1]\n    start+=1\n  else:\n    fr+=a[end][1]\n    frMax=frMax if fr<frMax else fr\n    end+=1\n  if end==n:\n    break\n  \nfrMax=frMax if fr<frMax else fr\nprint frMax\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic final class kefa_and_company\n{\n    static FastScanner sc=new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n    static PrintWriter out=new PrintWriter(System.out);\n\t\n\tstatic int getFirst(Node[] a,long elem)\n\t{\n\t\tint low=1,high=a.length-1;\n\t\twhile(low<high)\n\t\t{\n\t\t\tint mid=(low+high)>>1;\n\t\t\tif(a[mid].a1==elem)\n\t\t\t{\n\t\t\t\thigh=mid;\n\t\t\t}\n\t\t\telse if(a[mid].a1<elem)\n\t\t\t{\n\t\t\t\tlow=mid+1;\n\t\t\t}\n\t\t\telse if(a[mid].a1>elem)\n\t\t\t{\n\t\t\t\thigh=mid-1;\n\t\t\t}\n\t\t}\n\t\treturn low;\n\t}\n\t\n\tpublic static void main(String args[]) throws Exception\n\t{\n\t\tint n=sc.nextInt(),d=sc.nextInt();\n\t\tNode[] a=new Node[n+1];\n\t\tlong[] pre=new long[n+1];\n\t\ta[0]=new Node(-1,-1);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\ta[i]=new Node(sc.nextLong(),sc.nextLong());\n\t\t}\n\t\tArrays.sort(a);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tpre[i]=pre[i-1]+a[i].b1;\t\n\t\t}\n\t\tlong max=-1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tlong curr=a[i].a1-d+1;\n\t\t\tint pos=Arrays.binarySearch(a,new Node(curr,-1));\n\t\t\tif(pos>=0)\n\t\t\t{\n\t\t\t\tpos=getFirst(a,curr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpos++;\n\t\t\t\tpos*=-1;\n\t\t\t}\n\t\t\tpos=Math.max(1,pos);\n\t\t\tmax=Math.max(max,pre[i]-pre[pos-1]);\n\t\t}\n\t\tout.println(max);\n\t\tout.close();\n\t}\n}\nclass Node implements Comparable<Node>\n{\n\tlong a1,b1;\n\tpublic Node(long a1,long b1)\n\t{\n\t\tthis.a1=a1;\n\t\tthis.b1=b1;\n\t}\n\tpublic int compareTo(Node x)\n\t{\n\t\treturn Long.compare(this.a1,x.a1);\n\t}\n}\nclass FastScanner\n{\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n\t\n    public String nextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\t\n\tpublic String next() throws Exception {\n\t\treturn nextToken().toString();\n\t}\n\t\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class KefaAndCompany {\n\n\tprivate static class Person implements Comparable<Person> {\n\n\t\tprivate long money, factor;\n\n\t\tprivate Person(long money, long factor) {\n\t\t\tthis.money = money;\n\t\t\tthis.factor = factor;\n\t\t}\n\n\t\tpublic int compareTo(Person o) {\n\t\t\treturn (int) (money - o.money);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint n = scanner.nextInt();\n\t\tint d = scanner.nextInt();\n\n\t\tPerson people[] = new Person[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpeople[i] = new Person(scanner.nextInt(), scanner.nextInt());\n\t\tscanner.close();\n\n\t\tArrays.sort(people);\n\n\t\tlong sums[] = new long[n];\n\t\tsums[0] = people[0].factor;\n\t\tfor (int i = 1; i < n; ++i)\n\t\t\tsums[i] = sums[i - 1] + people[i].factor;\n\n\t\tlong max = Long.MIN_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tint idx = Arrays.binarySearch(people, new Person(d + people[i].money, 0));\n\t\t\tif (idx < 0)\n\t\t\t\tidx = -idx - 1;\n\t\t\telse\n\t\t\t\twhile (idx > 0 && people[idx - 1].money == d + people[i].money)\n\t\t\t\t\t--idx;\n\t\t\t--idx;\n\n\t\t\tmax = Math.max(max, sums[idx] - (i != 0 ? sums[i - 1] : 0));\n\t\t}\n\n\t\tSystem.out.println(max);\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\na=[]\nimport sys\nfor i in range(n):\n    x=list(map(int,sys.stdin.readline().split()))\n    a.append(x)\na.sort()\ni=0\nmx=0\nx=a[i][0]\ns=a[i][1]\nj=1\nwhile j!=n:\n    if a[j][0]-x<d:\n        s+=a[j][1]\n        mx=max(s,mx)\n        j+=1\n    else:\n        mx=max(s,mx)\n        s-=a[i][1]\n        i+=1\n        x=a[i][0]\n    \n        \nprint(max(mx,s))"
        },
        {
            "language": 3,
            "solution": "n, d = [int(x) for x in input().split()]\ndict = {}\nfor i in range (n):\n    m, s = [int(x) for x in input().split()]\n    if dict.get(m) == None:\n        dict[m] = s\n    else:\n        dict[m] += s\nsortedKeys = sorted(dict.keys())\nleng = len(sortedKeys)\ns = 0\nr = 0\nwhile r < leng:\n    if sortedKeys[r] < sortedKeys[0] + d:\n        s += dict.get(sortedKeys[r])\n        r += 1\n    else:\n        break\nmaxValue = s\nfor i in range (1, leng):\n    l = i - 1\n    s -= dict.get(sortedKeys[l])\n    while r < leng and sortedKeys[i] + d > sortedKeys[r]:\n        s += dict.get(sortedKeys[r])\n        r += 1\n    maxValue = max(maxValue, s)\n    if r == leng:\n        break\nprint(maxValue)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int sum[100010];\nint main() {\n  int n;\n  long long int d, a, b;\n  scanf(\"%d %lld\", &n, &d);\n  vector<pair<long long int, long long int>> p;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lld %lld\", &a, &b);\n    p.push_back(make_pair(a, b));\n  }\n  sort(p.begin(), p.end());\n  int p1 = 0, p2 = 1;\n  long long int max = p[p1].second, sum = p[p1].second;\n  while (p1 < p2 && p2 < n) {\n    if (p[p2].first - p[p1].first < d) {\n      sum += p[p2].second;\n      p2++;\n      if (sum > max) {\n        max = sum;\n      }\n    } else {\n      sum = sum - p[p1].second;\n      p1++;\n      if (p1 == p2) {\n        sum = p[p1].second;\n        p2++;\n      }\n      if (sum > max) {\n        max = sum;\n      }\n    }\n  }\n  printf(\"%lld\\n\", max);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nprnt = sys.stdout.write\n\nn, d = map(int,input().split())\nls = []\nfor i in range(n):\n    m,f = map(int,input().split())\n    ls.append([m,f])\nls.sort()\nmx = ls[0][1]\nres = ls[0][1]\nj = 0\nfor i in range(1,n):\n    if ls[i][0]-ls[j][0]>=d:\n        res = max(mx,res)\n        while(ls[i][0]-ls[j][0]>=d):\n            j+=1\n        mx = 0\n        for x in range(j,i+1):\n            mx+=ls[x][1]\n        #print(mx)\n    else:\n        mx+=ls[i][1]\nres = max(mx,res)\n#prnt(str(ls)+\"\\n\")\nprnt(str(res))\n\n"
        },
        {
            "language": 3,
            "solution": "num_friends, poor  = [int(i) for i in input().split()]\n\n\nparty = []\nfor x in range(num_friends):\n    temp_array = [0, 0]\n    temp_array[0], temp_array[1] = [int(y) for y in input().split()]\n    party.append(temp_array)\n    #print(party[x])\n\nparty.sort()\n\nanswer = party[0][1] #default: bring the first person\nif len(party) == 1:\n    print(answer)\n    exit()\n\ny=0\ntemp_answer = 0\n\nfor x in range(0,len(party)):\n    while y < len(party):\n      \n        if party[y][0] - party[x][0] < poor:\n            #print(\"party diff \", party[y][0] - party[x][0])\n            temp_answer += party[y][1]\n            #print(\"temp answer \", temp_answer)\n        else:\n            \n            if temp_answer > answer:\n                answer = temp_answer\n            temp_answer -= party[x][1]   \n            break\n        y += 1\n    if temp_answer > answer:\n        answer = temp_answer\n   # print(party[x])\n    \nprint(answer)\n\n\"\"\"\n 6\n5 11 \n10 11 x\n11 11 y\n12 11\n100 1\n\n\"\"\""
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class B {\n\n    static StringTokenizer st;\n    static BufferedReader br;\n    static PrintWriter pw;\n    static class Sort implements Comparable<Sort> {\n        int m, s;\n        public int compareTo(Sort arg0) {\n            return this.s-arg0.s;\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n = nextInt();\n        int d = nextInt();\n        Sort[]a = new Sort[n+1];\n        for (int i = 1; i <= n; i++) {\n            a[i] = new Sort();\n            a[i].s = nextInt();\n            a[i].m = nextInt();\n        }\n        long ans = 0;\n        Arrays.sort(a, 1, n+1);\n        long[]sum = new long[n+1];\n        for (int i = 1; i <= n; i++) {\n            sum[i] = sum[i-1] + a[i].m;\n        }\n        int right = 1;\n        for (int i = 1; i <= n; i++) {\n            if (right < i)\n                right = i;\n            while (right < n && a[right+1].s-a[i].s < d) {\n                right++;\n            }\n            ans = Math.max(ans, sum[right]-sum[i-1]);\n        }\n        System.out.println(ans);\n        pw.close();\n    }\n    private static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    private static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    private static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    private static String next() throws IOException {\n        while (st==null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\n\ninvited = []\n\nfor i in range(n):\n    invited.append(map(int, raw_input().split()))\n\nmax_friend = 0\n\ninvited.sort(key=lambda e: e[0])\n\nj = 0\ncurr_friend = 0\nfor i in range(n):\n    curr_friend += invited[i][1]\n    while j < i and invited[i][0] - invited[j][0] >= d:\n        curr_friend -= invited[j][1]\n        j += 1\n    if curr_friend > max_friend:\n        max_friend = curr_friend\nprint max_friend\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\narr=[]\nxx=0\nfor i in range(n):\n\tm,fr=map(int,input().split())\n\txx+=m\n\tarr.append([m,fr,xx])\narr=sorted(arr)\ncc=0\nans=0\nr=0\nfor i in range(len(arr)):\n\twhile r<len(arr) and arr[r][0]-arr[i][0]<d:\n\t\tcc+=arr[r][1]\n\t\tr+=1\n\tans=max(ans,cc)\n\tcc-=arr[i][1]\nprint(ans)\n"
        },
        {
            "language": 1,
            "solution": "from operator import itemgetter\n\nn, d = map(int, raw_input().split())\n\nfriends = []\nfor i in xrange(n):\n    m, ff = map(int, raw_input().split())\n    friends.append((m, ff))\n\nfriends = sorted(friends, key=itemgetter(0))\n\nmax_ff = l = r = 0\ncurr_ff = 0\nwhile l < n and r < n:\n    if friends[r][0] - friends[l][0] < d:\n        curr_ff += friends[r][1]\n        r += 1\n    else:\n        max_ff = max(max_ff, curr_ff)\n        curr_ff -= friends[l][1]\n        l += 1\n\nmax_ff = max(max_ff, curr_ff)\n\nprint max_ff\n"
        },
        {
            "language": 3,
            "solution": "# Author - Soumya Saurav\nimport sys,io,os,time\nfrom collections import defaultdict\nfrom collections import Counter\nfrom collections import deque\nfrom itertools import combinations\nfrom itertools import permutations\nimport bisect,math,heapq\nalphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\ninput = sys.stdin.readline\n\n########################################\nn , d = map(int , input().split())\narr = []\n\nfor i in range(n):\n    m , s = map(int , input().split())\n    arr.append([m,s])\n\nans = 0\narr.sort(key = lambda x : (x[0], -x[1]))\ni = 0\nj = 0\ntemp = 0\nwhile j < n:\n\n    while j < n and abs(arr[j][0] - arr[i][0]) < d:\n        temp += arr[j][1]\n        j += 1\n\n    ans = max(ans , temp)\n\n    while i < n and j < n and abs(arr[j][0] - arr[i][0]) >= d:\n        temp -= arr[i][1]\n        i += 1\nprint(ans)\n\n\n'''\n# Wrap solution for more recursion depth\nfor dx,dy in [[1,0],[0,1],[-1,0],[0,-1]]:\n#submit as python3\nimport collections,sys,threading\nsys.setrecursionlimit(10**9)\nthreading.stack_size(10**8)\n\n\n\nthreading.Thread(target=solve).start()\n'''\n"
        },
        {
            "language": 3,
            "solution": "n,m=[int(i) for i in input().split(' ')]\ncost=[]\nf_factor=[]\nfor i in range(n):\n    s=input().split(' ')\n    cost.append(int(s[0]))\n    f_factor.append(int(s[1]))\nsorted_map=sorted(zip(cost,f_factor))\ncost=[x for x,y in sorted_map]\nf_factor=[y for x,y in sorted_map]\n# print(cost,f_factor)\nmaxans=0\ncumSum=[f_factor[0]]\nfor i in range(1,n):\n    cumSum.append(cumSum[-1]+f_factor[i])\n# print(cost,f_factor,cumSum)\nfor i in range(n):\n    low=i+1\n    high=n-1\n    findex=i\n    while low<=high:\n        mid=int((low+high)/2)\n        diff=cost[mid]-cost[i]\n        if diff>=m:\n            if cost[mid-1]-cost[i]<m:\n                findex=mid-1\n                break\n            else:\n                high=mid-1\n        else:\n            findex=mid\n            low=mid+1\n    temp=cumSum[findex]-cumSum[i]+f_factor[i]\n    if maxans<temp:\n        maxans=temp\nprint(maxans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long int n, d;\n  long long int m, f;\n  long long int sum = 0;\n  long long int max = 0;\n  cin >> n >> d;\n  vector<long long int> arr(n);\n  map<long long int, long long int> mapp;\n  vector<long long int> fac;\n  for (int i = 0; i < n; ++i) {\n    cin >> m >> f;\n    arr[i] = m;\n    mapp[m] += f;\n  }\n  sort(arr.begin(), arr.end());\n  int i = 0;\n  arr.erase(unique(arr.begin(), arr.end()), arr.end());\n  for (auto it = mapp.begin(); it != mapp.end(); it++) {\n    sum += it->second;\n    fac.push_back(sum);\n    ++i;\n  }\n  long long int sz = arr.size();\n  for (int i = 0; i < sz; ++i) {\n    long long int key = arr[i] + d - 1;\n    auto upper = upper_bound(arr.begin(), arr.end(), key);\n    long long int index = upper - arr.begin() - 1;\n    if (fac[index] - fac[i - 1] > max && i != 0)\n      max = fac[index] - fac[i - 1];\n    else if (i == 0 && fac[index] > max)\n      max = fac[index];\n  }\n  cout << max;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in =new Scanner(System.in);\n\t\tint n=in.nextInt(),d=in.nextInt();\n\t\tFriend[]a=new Friend[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i]=new Friend(in.nextInt(),in.nextInt());\n\t\t\n\t\tArrays.sort(a);\n\t\t\n\t\tlong ans =0,max=0;\n\t\t\n\t\tfor(int l =0,r=0;r<n;)\n\t\t{\n\t\t\t\n\t\t\tif(Math.abs(a[l].m-a[r].m)<d)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tans+=a[r].f;\n\t\t\t\tr++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmax=Long.max(max,ans);\n\t\t\t\tans-=a[l].f;\n\t\t\t\tl++;\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\tmax=Long.max(max,ans);\n\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(max);\n\t\t\n\t\t\n\t}\n\n}\nclass Friend implements Comparable<Friend>\n{\n\tint m , f ;\n\n\tpublic Friend(int a  , int b ) {\n\t\tm=a;\n\t\tf=b;\n\t\t\n\t}\n\t\n\t\n\t\n\t@Override\n\tpublic int compareTo(Friend o) {\n\t\t\n\t\t\n\t\n\t\treturn (this.m-o.m);\n\n\t\t\n\t}\n\t\n\n}\n"
        },
        {
            "language": 3,
            "solution": "import itertools\n\ndef read_data():\n    n, d = map(int, input().split())\n    MSs = []\n    for i in range(n):\n        m, s = map(int, input().split())\n        MSs.append((m, s))\n    return n, d, MSs\n\ndef solve(n, d, MSs):\n    if n == 1:\n        return MSs[0][1]\n    MSs.sort()\n    Ms = [m for m, s in MSs]\n    Ss = [s for m, s in MSs]\n    h = 0\n    cum = [0] + list(itertools.accumulate(Ss))\n    record = cum[1]\n    for t in range(1, n):\n        while Ms[t] - Ms[h] >= d:\n            h += 1\n        record = max(record, cum[t + 1] - cum[h])\n    return record\n\nn, d, MSs = read_data()\nprint(solve(n, d, MSs))"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Problem10 {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int d = scan.nextInt();\n        List<Friend> friends = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            friends.add(new Friend(scan.nextInt(), scan.nextInt()));\n        Comparator<Friend> c = Comparator.comparingInt(o -> o.money);\n        Collections.sort(friends, c);\n        long[] sum = new long[n];\n        sum[0] = friends.get(0).friendship;\n        for (int i = 1; i < n; i++)\n            sum[i] = sum[i - 1] + friends.get(i).friendship;\n        long max = Long.MIN_VALUE;\n        for (int i = 0; i < n; i++) {\n            int ind = Collections.binarySearch(friends, new Friend(friends.get(i).money + d, 0), c);\n            if (ind > 0) {\n                while ((ind > 0) && friends.get(ind).money == friends.get(ind - 1).money)\n                    ind--;\n                ind--;\n            } else if (ind < 0) {\n                ind = -ind - 2;\n            }\n            if (ind < 0)\n                ind = 0;\n            long s = (i == 0) ? sum[ind] : sum[ind] - sum[i - 1];\n            if (s > max)\n                max = s;\n        }\n        System.out.println(max);\n    }\n}\n\nclass Friend implements Comparable<Friend> {\n    int money;\n    int friendship;\n\n    public Friend(int money, int friendship) {\n        this.money = money;\n        this.friendship = friendship;\n    }\n\n    @Override\n    public int compareTo(Friend o) {\n        return this.money - o.money;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class a {\n\tpublic static class node implements Comparable<node> {\n\t\tint x;\n\t\tint y;\n\n\t\tnode(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(node o) {\n\t\t\tif (o.x < x)\n\t\t\t\treturn 1;\n\t\t\telse if (o.x > x)\n\t\t\t\treturn -1;\n\t\t\telse if (o.y > y)\n\t\t\t\treturn 1;\n\t\t\telse if (o.y < y)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\n\tpublic static class point {\n\t\tint x;\n\t\tint y;\n\n\t\tpoint(int x, int val) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = val;\n\t\t}\n\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\n\n\tpublic static ArrayList<Integer> prime;\n\n\tpublic static void sieve(int n) {\n\t\tboolean vis[] = new boolean[n + 5];\n\t\tvis[1] = true;\n\t\tvis[0] = true;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tprime.add(i);\n\t\t\t\tfor (long j = (long) i * (long) i; j <= n; j += i) {\n\t\t\t\t\tvis[(int) j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int tree[][];\n\tpublic static boolean end[][];\n\tpublic static int counter;\n\n\tpublic static void trie(String a) {\n\t\tint st = 0;\n\n\t\tfor (int i = 0; i < a.length(); i++) {\n\t\t\tif (tree[a.charAt(i) - 'a'][st] == 0) {\n\t\t\t\ttree[a.charAt(i) - 'a'][st] = counter++;\n\t\t\t}\n\n\t\t\tst = tree[a.charAt(i) - 'a'][st];\n\t\t}\n\t\tend[a.charAt(a.length() - 1) - 'a'][st] = true;\n\n\t}\n\n\tpublic static int seg[][];\n\tpublic static int a[][];\n\tpublic static int m;\n\n\tpublic static void build(int s, int e, int p) {\n\t\tif (s == e) {\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t// System.out.println(p+\" \"+s);\n\t\t\t\tseg[i][p] = a[i][s];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint mid = (s + e) / 2;\n\t\tbuild(s, mid, p * 2);\n\t\tbuild(mid + 1, e, p * 2 + 1);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tseg[i][p] = Math.max(seg[i][p * 2], seg[i][p * 2 + 1]);\n\t\t}\n\t}\n\n\tpublic static int get(int s, int e, int p, int from, int to, int seg[]) {\n\t\tif (s >= from && e <= to)\n\t\t\treturn seg[p];\n\t\tif (s > to || e < from)\n\t\t\treturn 0;\n\t\tint mid = (s + e) / 2;\n\t\tint one = get(s, mid, p * 2, from, to, seg);\n\t\tint two = get(mid + 1, e, p * 2 + 1, from, to, seg);\n\t\treturn Math.max(one, two);\n\t}\n\n\tpublic static long comp(int n, int r) {\n\t\tlong ans = 1;\n\t\tr = Math.min(r, n - r);\n\t\tfor (int i = 1; i <= r; i++) {\n\t\t\tans = ans * ((long) n - (long) i + 1L) / (long) i;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static ArrayList<Integer> arr[];\n\tpublic static boolean vis[];\n\tpublic static Stack<Integer> S;\n\n\tpublic static void bfs(int node) {\n\t\tfor (int i = 0; i < arr[node].size(); i++) {\n\t\t\tint k = arr[node].get(i);\n\t\t\tif (vis[k] == false) {\n\t\t\t\tvis[k] = true;\n\t\t\t\tS.push(k);\n\t\t\t\tbfs(k);\n\t\t\t}\n\t\t}\n\t\tS.push(node);\n\t}\n\n\tpublic static void dfs(int node) {\n\t\tSystem.out.print(node + \" \");\n\t\tfor (int i = 0; i < arr[node].size(); i++) {\n\t\t\tint k = arr[node].get(i);\n\t\t\tif (vis[k] == false) {\n\t\t\t\tvis[k] = true;\n\t\t\t\tdfs(k);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int get(int a) {\n\t\twhile (a % 2 == 0)\n\t\t\ta /= 2;\n\t\twhile (a % 3 == 0)\n\t\t\ta /= 3;\n\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t// BufferedReader in = new BufferedReader(new FileReader(\"cubes.in\"));\n\n\t\tStringBuilder qq = new StringBuilder();\n\t\tPrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t// PrintWriter out = new PrintWriter(new FileWriter(\"out.txt\"));\n\t\tString y[] = in.readLine().split(\" \");\n\t\tint n = Integer.parseInt(y[0]);\n\t\tint d = Integer.parseInt(y[1]);\n\n\t\tnode a[] = new node[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ty = in.readLine().split(\" \");\n\t\t\ta[i] = new node(Integer.parseInt(y[0]), Integer.parseInt(y[1]));\n\t\t}\n\t\tArrays.sort(a);\n\n\t\tlong dp[] = new long[n];\n\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tdp[i] = a[i].x;\n\n\t\t}\n\t\tlong ans = a[0].y;\n\t\tlong diff = 0;\n\t\tint st = 0;\n\t\tlong sum = a[0].y;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdiff = (long) dp[i] - dp[st];\n\t\t//\tSystem.out.println(diff);\n\t\t\twhile (diff >= d) {\n\t\t\t\tsum -= a[st].y;\n\t\t\t\tst++;\n\t\t\t\tdiff = (long) dp[i] - dp[st];\n\t\t\t}\n\t\t\tif (diff < d) {\n\t\t\t\tsum += (long) a[i].y;\n\t\t\t}\n\t\t\t// System.out.println(sum);\n\n\t\t\tans = Math.max(sum, ans);\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tout.close();\n\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n      static class company implements Comparable<company>{\n        public long money, friendship;\n        \n        public company(long m, long f){\n            money = m;\n            friendship = f;\n        }\n        \n        @Override\n        public int compareTo(company other){\n            if(money < other.money)\n                return -1;\n            if(money > other.money)\n                return 1;\n            return 0;\n        }\n    }\n    \n    public static void main(String[] args) throws FileNotFoundException {\n        \n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        long d = input.nextInt();\n        int i, start = 0;\n        long  sum=0, max=0;\n       \n        company[] allFriends = new company[n];\n        \n        for(i =0; i<n; i++)\n            allFriends[i] = new company(input.nextLong(), input.nextLong());\n        \n        Arrays.sort(allFriends);\n        \n        for( i = 0; i<n; i++){\n            \n            for(;allFriends[i].money - allFriends[start].money >= d; start++)\n                sum-= allFriends[start].friendship;\n            \n            sum+= allFriends[i].friendship;\n            \n            if(sum>max) max = sum;\n            \n        }\n        System.out.print(max);\n     \n    }\n    \n}\n"
        },
        {
            "language": 3,
            "solution": "n,d = map(int,input().split())\nm = [0 for i in range(n)]\ns = [0 for i in range(n)]\nhash = [0 for i in range(n)]\nmod = 10**10\n\nfor i in range(n):\n    m[i], s[i] = map(int,input().split())\n    hash[i] = m[i] * mod + s[i]\n\n# print(m,s)\n# print(hash)\n\nhash = sorted(hash)\n# print(hash)\n\ndef get_value(x):\n    return x%(mod)\n\ndef get_key(x):\n    return int(x/(mod))\n\ni_max = n-1\ni_min = n-1\nS = 0\nS_max = S\n\nwhile((i_min>=0)&(i_max>=0)):\n    while ((get_key(hash[i_min]) > (get_key(hash[i_max]) - d)) & (i_min>=0)):\n        S += get_value(hash[i_min])\n        i_min -= 1\n    if (S > S_max):\n        S_max = S\n    S -= get_value(hash[i_max])\n    i_max -= 1\n\nprint(S_max)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m, x, y, ptr1, ptr2;\n  long long res = 0, t;\n  pair<int, int> p[100001];\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &x, &y);\n    p[i] = make_pair(x, y);\n  }\n  sort(p, p + n);\n  res = t = p[0].second;\n  ptr1 = 0;\n  for (ptr2 = 1; ptr2 < n;) {\n    if (p[ptr2].first - p[ptr1].first < m)\n      t += p[ptr2++].second;\n    else\n      while (p[ptr2].first - p[ptr1].first >= m) t -= p[ptr1].second, ptr1++;\n    res = max(res, t);\n  }\n  printf(\"%I64d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n    static boolean use_n_tests = false;\n    static int stack_size = 1 << 27;\n\n    void solve(FastScanner in, PrintWriter out, int testNumber) {\n        int n = in.nextInt();\n        int d = in.nextInt();\n        D[] f = new D[n];\n        for (int i = 0; i < n; i++) {\n            D dr = new D();\n            dr.m = in.nextInt();\n            dr.s = in.nextInt();\n            f[i] = dr;\n        }\n        Arrays.sort(f, Comparator.comparing(d1 -> d1.m));\n        long[] pref = new long[n];\n        for (int i = 0; i < n; i++)  {\n            pref[i] = f[i].s;\n            if (i > 0) {\n                pref[i] += pref[i - 1];\n            }\n        }\n        long result = 0;\n        for (int i = 0; i < n; i++) {\n            int mx = f[i].m + d - 1;\n            int l = i;\n            int r = n - 1;\n            int ans = -1;\n            while (l <= r) {\n                int m = (l + r) / 2;\n                if (f[m].m > mx) {\n                    r = m - 1;\n                } else {\n                    ans = m;\n                    l = m + 1;\n                }\n            }\n            if (ans != -1) {\n                result = Math.max(result, pref[ans] - (i > 0 ? pref[i - 1] : 0));\n            }\n        }\n        out.println(result);\n    }\n\n    class D {\n        int m;\n        int s;\n    }\n\n    // ****************************** template code ***********\n\n    class Coeff {\n        long mod;\n        long[][] C;\n        long[] fact;\n        boolean cycleWay = false;\n\n        Coeff(int n, long mod) {\n            this.mod = mod;\n            fact = new long[n + 1];\n            fact[0] = 1;\n            for (int i = 1; i <= n; i++) {\n                fact[i] = i;\n                fact[i] %= mod;\n                fact[i] *= fact[i - 1];\n                fact[i] %= mod;\n            }\n        }\n\n        Coeff(int n, int m, long mod) {\n            // n > m\n            cycleWay = true;\n            this.mod = mod;\n            C = new long[n + 1][m + 1];\n            for (int i = 0; i <= n; i++) {\n                for (int j = 0; j <= Math.min(i, m); j++) {\n                    if (j == 0 || j == i) {\n                        C[i][j] = 1;\n                    } else {\n                        C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n                        C[i][j] %= mod;\n                    }\n                }\n            }\n        }\n\n        public long C(int n, int m) {\n            if (cycleWay) {\n                return C[n][m];\n            }\n            return fC(n, m);\n        }\n\n        private long fC(int n, int m) {\n            return (fact[n] * inv(fact[n - m] * fact[m] % mod)) % mod;\n        }\n\n        private long inv(long r) {\n            if (r == 1)\n                return 1;\n            return ((mod - mod / r) * inv(mod % r)) % mod;\n        }\n    }\n\n    class Pair {\n        int first;\n        int second;\n\n        public int getFirst() {\n            return first;\n        }\n\n        public int getSecond() {\n            return second;\n        }\n    }\n\n    class MultisetTree<T> {\n        int size = 0;\n\n        TreeMap<T, Integer> mp = new TreeMap<>();\n\n        void add(T x) {\n            mp.merge(x, 1, Integer::sum);\n            size++;\n        }\n\n        void remove(T x) {\n            if (mp.containsKey(x)) {\n                mp.merge(x, -1, Integer::sum);\n                if (mp.get(x) == 0) {\n                    mp.remove(x);\n                }\n                size--;\n            }\n        }\n\n        T greatest() {\n            return mp.lastKey();\n        }\n\n        int size() {\n            return size;\n        }\n\n        int diffSize() {\n            return mp.size();\n        }\n    }\n\n    class Multiset<T> {\n        int size = 0;\n\n        Map<T, Integer> mp = new HashMap<>();\n\n        void add(T x) {\n            mp.merge(x, 1, Integer::sum);\n            size++;\n        }\n\n        void remove(T x) {\n            if (mp.containsKey(x)) {\n                mp.merge(x, -1, Integer::sum);\n                if (mp.get(x) == 0) {\n                    mp.remove(x);\n                }\n                size--;\n            }\n        }\n\n        int size() {\n            return size;\n        }\n\n        int diffSize() {\n            return mp.size();\n        }\n    }\n\n    static class Range {\n        int l, r;\n        int id;\n\n        public int getL() {\n            return l;\n        }\n\n        public int getR() {\n            return r;\n        }\n\n        public Range(int l, int r, int id) {\n            this.l = l;\n            this.r = r;\n            this.id = id;\n        }\n    }\n\n    static class Array {\n        static Range[] readRanges(int n, FastScanner in) {\n            Range[] result = new Range[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = new Range(in.nextInt(), in.nextInt(), i);\n            }\n            return result;\n        }\n\n        static public Integer[] read(int n, FastScanner in) {\n            Integer[] out = new Integer[n];\n            for (int i = 0; i < out.length; i++) {\n                out[i] = in.nextInt();\n            }\n            return out;\n        }\n\n        static public int[] readint(int n, FastScanner in) {\n            int[] out = new int[n];\n            for (int i = 0; i < out.length; i++) {\n                out[i] = in.nextInt();\n            }\n            return out;\n        }\n    }\n\n    class Graph {\n        List<List<Integer>> create(int n) {\n            List<List<Integer>> graph = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                graph.add(new ArrayList<>());\n            }\n            return graph;\n        }\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream io) {\n            br = new BufferedReader(new InputStreamReader(io));\n        }\n\n        public String line() {\n            String result = \"\";\n            try {\n                result = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return result;\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n    void run_t_tests() {\n        int t = in.nextInt();\n        int i = 0;\n        while (t-- > 0) {\n            solve(in, out, i++);\n        }\n    }\n\n    void run_one() {\n        solve(in, out, -1);\n    }\n\n    @Override\n    public void run() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n        if (use_n_tests) {\n            run_t_tests();\n        } else {\n            run_one();\n        }\n        out.close();\n    }\n\n    static FastScanner in;\n    static PrintWriter out;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(null, new Main(), \"\", stack_size);\n        thread.start();\n        thread.join();\n    }\n}"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\n\narray = []\nfor i in xrange(n):\n\ta, b = map(int, raw_input().split())\n\tarray.append((a, b))\n\narray.sort()\n\nend = 0\nmax_factor = 0\ncurr_factor = 0\nfor start in xrange(n):\n\tif start != 0:\n\t\tcurr_factor = curr_factor - array[start -1][1]\n\t\n\twhile end < n and array[end][0] - array[start][0] < d:\n\t\tcurr_factor += array[end][1]\n\t\tend += 1\n\n\tmax_factor = max(max_factor, curr_factor)\n\nprint max_factor\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct {\n  int m, f;\n} friends;\nbool cmp(friends a, friends b) { return a.m < b.m; }\nint main() {\n  int n, d;\n  while (scanf(\"%d%d\", &n, &d) != EOF) {\n    friends a[n];\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d%d\", &a[i].m, &a[i].f);\n    }\n    sort(a, a + n, cmp);\n    long long int max = a[0].f;\n    long long int ans = a[0].f;\n    int low_money = a[0].m;\n    int idx = 0;\n    for (int i = 1; i < n; i++) {\n      if (a[i].m - low_money < d) {\n        ans += a[i].f;\n        if (ans > max) max = ans;\n      } else {\n        ans += a[i].f;\n        for (int j = idx; j < i; j++) {\n          if (a[i].m - a[j].m < d) {\n            idx = j;\n            low_money = a[j].m;\n            break;\n          } else {\n            ans -= a[j].f;\n            idx++;\n          }\n        }\n      }\n      if (ans > max) max = ans;\n    }\n    printf(\"%I64d\\n\", max);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom collections import Counter\nfrom math import factorial\n\ninput = sys.stdin\noutput = sys.stdout\n\n# input = open('input.txt')\n\n\ndef read_int():\n    return [int(x) for x in input.readline().rstrip().split()]\n\nn, d = read_int()\nfriends = list()\nfor _ in range(n):\n    m, s = read_int()\n    friends.append((m, s))\n\nfriends.sort(key=lambda e: e[0])\nanswer, candidate = friends[0][1], friends[0][1]\nl, r = -1, 0\nwhile r + 1 < n:\n    if l >= 0:\n        candidate -= friends[l][1]\n    l += 1\n    while r + 1 < n and friends[l][0] + d > friends[r + 1][0]:\n        r += 1\n        candidate += friends[r][1]\n    answer = max(answer, candidate)\n\noutput.write('%d\\n' % answer)\n\n"
        },
        {
            "language": 3,
            "solution": "n, d = [int(i) for i in input().split(' ')]\nfriends = [[int(i) for i in input().split(' ')] for _ in range(n)]\n\nfriends.sort(key=lambda x: x[0])\n\nfirst = 0\nlast = 0\nmax_friendship = 0\nfriendship = 0\nwhile last < n:\n    while first <= last and friends[last][0] - friends[first][0] >= d:\n        friendship -= friends[first][1]\n        first += 1\n    friendship += friends[last][1]\n    max_friendship = max(max_friendship, friendship)\n    last += 1\n\nprint(max_friendship)\n"
        },
        {
            "language": 1,
            "solution": "\n\n\n\nn,d = map(int,raw_input().split())\n\nstore = []\n\nfor i in range(n):\n    store.append(map(int,raw_input().split()))\n\nstore = sorted(store,key = lambda x:x[0])\n\nstart = 0\nend = 0\nrs = 0\n\nwhile end < n and store[end][0] - store[start][0] < d:\n    rs += store[end][1]\n    end += 1\n\n\nans = rs\n\nwhile end != n:\n    rs += store[end][1]\n    while store[end][0] - store[start][0] >= d:\n        rs -= store[start][1]\n        start += 1\n\n    #print start,end,rs\n    ans = max(ans,rs)    \n    end += 1\n\nprint ans\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, d;\n  cin >> n >> d;\n  array<long long, 2> a[n];\n  for (int i = 0; i < n; i++) {\n    long long x, y;\n    cin >> x >> y;\n    a[i] = {x, y};\n  }\n  sort(a, a + n);\n  long long arr[n][2];\n  arr[0][0] = a[0][0];\n  arr[0][1] = a[0][1];\n  for (int i = 1; i < n; i++) {\n    arr[i][0] = a[i][0];\n    arr[i][1] = a[i][1];\n  }\n  for (int i = 1; i < n; i++) {\n    arr[i][1] = arr[i][1] + arr[i - 1][1];\n  }\n  long long ans = 0;\n  int l = 0;\n  for (int i = 0; i < n; i++) {\n    if ((arr[i][0] - arr[l][0]) >= d) {\n      if (l == 0) {\n        ans = max(ans, arr[i - 1][1]);\n      } else {\n        ans = max(ans, arr[i - 1][1] - arr[l - 1][1]);\n      }\n      while ((arr[i][0] - arr[l][0]) >= d) {\n        l++;\n      }\n      ans = max(ans, arr[i][1] - arr[l - 1][1]);\n    }\n  }\n  if (l == 0) {\n    ans = max(ans, arr[n - 1][1]);\n  } else {\n    ans = max(ans, arr[n - 1][1] - arr[l - 1][1]);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int, input().split())\nmoney=[]\nfactor=[]\nfor i in range(n):\n    m,s=map(int, input().split())\n    money.append(m)\n    factor.append(s)\nfactor=[x for _,x in sorted(zip(money,factor))]\nmoney=sorted(money)\ni=j=0\nans=0\nc=0\nwhile i<n and j<n:\n    if money[j]-money[i]<d:\n        c+=factor[j]\n        j+=1\n    else:\n        c-=factor[i]\n        i+=1\n    ans=max(c,ans)\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "def getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\ndef solve():\n    N, D = getInts()\n    #get all the monies in order\n    #find out which starting friend allows for the max friendship factor\n    friends = []\n    prefix_sums = []\n    curr_sum = 0\n    for n in range(N):\n        money, friendship = getInts()\n        friends.append((money,friendship))\n    friends.sort()\n    prefix_sums = []\n    for n in range(N):\n        curr_sum += friends[n][1]\n        prefix_sums.append(curr_sum)\n    last_friend = 0\n    best = 0\n    for first_friend in range(N):\n        min_money = friends[first_friend][0]\n        last_friend = max(last_friend,first_friend)\n        while last_friend < N-1 and friends[last_friend+1][0] < min_money+D:\n            last_friend += 1\n        if first_friend == 0:\n            curr_val = prefix_sums[last_friend]\n        else:\n            curr_val = prefix_sums[last_friend]-prefix_sums[first_friend-1]\n        best = max(best,curr_val)\n        if last_friend == N-1:\n            return best\n\nans = solve()\nprint(ans)\n    \n    "
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class KefaandCompany {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st  = new StringTokenizer(br.readLine());\n\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint d = Integer.parseInt(st.nextToken());\n\t\t\n\t\tFriend[] ff = new Friend[n];\n\t\tfor(int i=0; i<n;i++){\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint m = Integer.parseInt(st.nextToken());\n\t\t\tint s = Integer.parseInt(st.nextToken());\n\t\t\t\n\t\t\tff[i] = new Friend(m,s);\n\t\t\t\n\t\t}\n\t\tArrays.sort(ff);\n\t\tlong sum,max;\n\t\tint i=0;\n\t\tint j=1;\n\t\tmax = sum = ff[0].s;\n\t\twhile(j<n){\n\t\t\tsum+=ff[j].s;\n\t\t\tif(ff[j].m - ff[i].m>=d){\n\t\t\t\twhile(ff[j].m-ff[i].m >=d){\n\t\t\t\t\tsum-=ff[i].s;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max<sum){\n\t\t\t\tmax = sum;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\t\n\tstatic class Friend implements Comparable<Friend>{\n\n\t\t\n\t\tint m,s;\n\t\tFriend(int a, int b){\n\t\t\tm = a;\n\t\t\ts = b;\n\t\t}\n\t\tpublic int compareTo(Friend f) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn this.m -  f.m;\n\t\t}\n\t\t\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "class MaximumFriendshipWithinMoneyRangeProblem:\n\n    def __init__(self):\n        self.numFriends, self.moneyRange, self.friends = self.getInput()\n        self.solution = self.computeMaximumFriendshipWithinMoneyRange()\n\n    def getInput(self):\n        numFriends, moneyDistance = map(int, input().split())\n        friends = [tuple(map(int, input().split())) for _ in range(numFriends)]\n        return numFriends, moneyDistance, friends\n\n    def computeMaximumFriendshipWithinMoneyRange(self):\n        self.friends.sort()\n        rangeFriendshipFactor = 0\n        maxFriendshipFactor = 0\n        poorestInMoneyRange = 0\n\n        for richestInMoneyRange in range(self.numFriends):\n            rangeFriendshipFactor += self.getFriendshipFactor(richestInMoneyRange)\n\n            while self.poorestFeelsPoor(poorestInMoneyRange, richestInMoneyRange):\n                rangeFriendshipFactor -= self.getFriendshipFactor(poorestInMoneyRange)\n                poorestInMoneyRange += 1\n\n            maxFriendshipFactor = max(rangeFriendshipFactor, maxFriendshipFactor)\n        \n        return maxFriendshipFactor\n\n    def getFriendshipFactor(self, friend):\n        return self.friends[friend][1]\n\n    def poorestFeelsPoor(self, poorest, richest):\n        return self.getMoney(richest) - self.getMoney(poorest) >= self.moneyRange\n    \n    def getMoney(self, friend):\n        return self.friends[friend][0]\n\n    def getSolution(self):\n        return self.solution\n\nif __name__ == '__main__':\n\n    print(MaximumFriendshipWithinMoneyRangeProblem().getSolution())\n\n\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\nl = list()\nfor i in range(n):\n        l.append(tuple(map(int, raw_input().split())))\nl.sort()\ni = 0\nm = 0\ns = 0\n\nfor j in range(n):\n        s += l[j][1]\n        while l[j][0] - l[i][0] >= d:\n                s -= l[i][1]\n                i += 1\n        m = max(m, s)\n\nprint m\n"
        },
        {
            "language": 1,
            "solution": "#In the name of God\n\nn, d = map(int, raw_input().split())\n\npairs = []\nfor i in range(n):\n\tm, s = map(int, raw_input().split())\n\tpairs.append((m, s))\n\npairs.sort(key=lambda x: x[0])\n\n#print pairs\nif 2 != 2:\n\tmax_s = -1\n\tfor i in range(n):\n\t\ttotal_s = 0\n\t\tfor j in range(i, n):\n\t\t\tif pairs[j][0] - pairs[i][0] < d:\n\t\t\t\ttotal_s += pairs[j][1]\n\t\t\telse:\n\t\t\t\tbreak\n\t\tmax_s = max(max_s, total_s)\n\n\nmax_s = -1\nstart = 0\nend = 0\ntotal_s = 0\nwhile start < n:\n\twhile  end < n and pairs[end][0] - pairs[start][0] < d:\n\t\ttotal_s += pairs[end][1]\n\t\tend += 1\n\tmax_s = max(max_s, total_s)\n\tif end == n:\n\t\tbreak\n\twhile pairs[end][0] - pairs[start][0] >= d:\n\t\ttotal_s -= pairs[start][1]\n\t\tstart += 1\n\tmax_s = max(max_s, total_s)\nprint max_s"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\na=[]\nfor i in range(n):\n    a.append((list(map(int,input().split()))))\na.sort()\nx=0\ny=0\nm=0\nf=0\nwhile y<n:\n    if a[y][0]-a[x][0]<d:\n        m+=a[y][1]\n        y+=1\n        f=max(m,f)\n    else:\n        m-=a[x][1]\n        x+=1\nprint(f)"
        },
        {
            "language": 1,
            "solution": "N, D = map(int, raw_input().split())\nl = []\nfor i in xrange(N):\n    l.append(tuple(map(int, raw_input().split())))\n    \nl.sort()\nans = 0\nj = 0\ncur = 0\n\nfor i in xrange(N):\n    while j < N and l[j][0] < l[i][0] + D:\n        cur += l[j][1]\n        j += 1\n    ans = max(ans, cur)\n    cur -= l[i][1]\n\nprint ans"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, d;\n  cin >> n >> d;\n  long long temp1, temp2;\n  std::vector<pair<long long int, long long int> > v;\n  for (int i = 0; i < n; ++i) {\n    cin >> temp1 >> temp2;\n    v.push_back(make_pair(temp1, temp2));\n  }\n  sort(v.begin(), v.end());\n  long long current = v[0].second;\n  long long j = 1;\n  long long global_max = 0;\n  for (int i = 0; i < n; i++) {\n    while ((j < n) && abs(v[i].first - v[j].first) < d) {\n      current += v[j].second;\n      j++;\n    }\n    global_max = max(global_max, current);\n    current -= v[i].second;\n  }\n  cout << global_max;\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport time\n\n(n, d) = (int(i) for i in input().split())\n\nms = {}\n\nfor i in range(n):\n    (m, s) = (int(i) for i in input().split())\n    if m in ms.keys():\n        ms[m] += s\n    else:\n        ms[m] = s\n\nstart = time.time()\n\nl    = sorted(ms.keys())\nans  = 0\nj    = 0\n\nwhile ((j < len(l)) and (l[j] - l[0] < d)):\n    ans += ms[l[j]]\n    j   += 1\ni   = 0\n\nnow = ans\n\nwhile j < len(l):\n    now = now - ms[l[i]]\n    i += 1\n\n    while ((j < len(l)) and  (l[j] - l[i] < d)):\n        now += ms[l[j]]\n        j   += 1\n    if now > ans:\n        ans = now\n\n\n\nprint(ans)\nfinish = time.time()\n#print(finish - start)\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom bisect import bisect_right\n\n\ndef main():\n    n, d = map(int, input().split())\n    friends = sorted(tuple(int(c) for c in line.split()) for line in sys.stdin)\n    money = [e[0] for e in friends]\n\n    friendship_sum = [0]\n    for _, e in friends:\n        friendship_sum.append(friendship_sum[-1] + e)\n\n    start = 0\n    _min, ans = friends[0]\n\n    for i in range(1, n):\n        cur = friends[i][0]\n        if cur - _min >= d:\n            start = bisect_right(money, cur - d)\n            _min = friends[start][0]\n\n        friendship = friendship_sum[i + 1] - friendship_sum[start]\n        ans = max(ans, friendship)\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 3,
            "solution": "from bisect import bisect\nimport sys\ninput = sys.stdin.buffer.readline\ndef prog():\n    n,d = map(int,input().split())\n    moneys = [list(map(int,input().split())) for i in range(n)]\n    moneys2 = []\n    moneys.sort()\n    max_friendship = 0\n    psum_friendship = [0]\n    for i in range(n):\n        psum_friendship.append(psum_friendship[-1] + moneys[i][1])\n        moneys2.append(moneys[i][0])\n    for i in range(n):\n        start = moneys2[i]\n        total_friendship = psum_friendship[bisect(moneys2, start + d-1)] - psum_friendship[i]\n        max_friendship = max(max_friendship, total_friendship)\n    print(max_friendship)\nprog()\n"
        },
        {
            "language": 3,
            "solution": "I = lambda :map(int, input().split())\nn,d=I()\na=sorted([list(I()) for i in range(n)])\ns=ans=a[0][1]\nj=0\nfor i in range(1,n):\n    while(a[i][0]-a[j][0]>=d):\n        s-=a[j][1]\n        j+=1\n    s+=a[i][1]\n    ans=max(s,ans)\n\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "def cmp(t):\n    return t[0]\n\n\nn, d = (int(i) for i in input().split())\nlista = []\n\nfor i in range(n):\n    a, b = (int(i) for i in input().split())\n    lista.append((a, b))\n\nlista.sort(key=cmp)\n\n#print(lista)\n\nmaxim = 0\n\n# for i in range(len(lista)):\n#\n#     crt = 0\n#\n#     j = i\n#\n#     while j < len(lista):       ##\n#\n#\n#     if crt > maxim:\n#         maxim = crt\n\n\n# i = j = 0\n# crt = 0\n# print(lista)\n# for j in range(len(lista)):\n#\n#     print('\\npas nou\\ni=', i,'j=', j, 'crt=', crt, sep=' ')\n#\n#     if lista[j][0] - lista[i][0] > d:\n#         crt = 0\n#         print('i=', i, 'j=', j, 'crt=', crt, sep=' ')\n#\n#     crt = crt + lista[j][1]\n#     print('i=', i,'j=', j, 'crt=', crt, sep=' ')\n#\n#\n#\n#     while i < j and lista[j][0] - lista[i][0] > d:\n#         i += 1\n#         crt = crt - lista[i][1]\n#         print('i=', i,'j=', j, 'crt=', crt, sep=' ')\n#\n#     if crt > maxim:\n#         maxim = crt\n#         print('maxim=', maxim, sep=' ')\n#\n#     print(crt)\n\nj = 0\ncrt = 0\nfor i in range(len(lista)):\n    #print(lista)\n    #print(crt)\n    while j < len(lista) and lista[j][0] - lista[i][0] < d:\n        crt = crt + lista[j][1]\n        j += 1\n\n    #print(crt)\n    if maxim < crt:\n        maxim = crt\n\n    crt = crt - lista[i][1]\n    #print(crt)\n\nprint(maxim)\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\n\n\npublic class Main {\n    public static PrintStream out = new PrintStream(System.out);\n    static LinkedList<Integer> adj[];\n    static boolean[] vis;\n    static final int nINF = Integer.MIN_VALUE;\n    static final int INF = Integer.MAX_VALUE;\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        int n = sc.nextInt(); int d = sc.nextInt();\n        //Friend[] a = new Friend[n];\n        Friend[] a = new Friend[n];\n        HashMap<Integer, Long> map = new HashMap();\n        for(int i = 0; i < n; i++){\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            a[i] = new Friend(x,y);\n        }\n        Arrays.sort(a);\n        int l = 0; int r = 0;\n        long ans = nINF; long sum = 0;\n        while(l < n){\n            while(r < n && a[r].money - a[l].money < d){\n                sum += a[r].friendship;\n                r++;\n            }\n            ans = Math.max(ans, sum);\n            sum -= a[l].friendship;\n            l++;\n        }\n        out.println(ans);\n\n    }\n    \n    //returns index; outputs earliest occurence; -1 if target value does not exist\n    static int getUpper(Friend[] arr, int target)  \n    {  \n        int start = 0, end = arr.length - 1;  \n    \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;  \n    \n            // Move to right side if target is  \n            // greater.  \n            if (arr[mid].money <= target) {  \n                start = mid + 1;  \n            }  \n    \n            // Move left side.  \n            else {  \n                ans = mid;  \n                end = mid - 1;  \n            }  \n        }  \n        return ans;  \n    }  \n    \n    //returns index; outputs latest occurence; -1 if target value does not exist\n    static int getLower(Friend[] arr, int target)  \n    {  \n        int start = 0, end = arr.length-1;  \n    \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;  \n    \n            // Move to the left side if the target is smaller  \n            if (arr[mid].money >= target) {  \n                end = mid - 1;  \n            }  \n    \n            // Move right side  \n            else {  \n                ans = mid;  \n                start = mid + 1;  \n            }  \n        }  \n        return ans;  \n    }  \n        \n    \n    static void dfs(int n){\n        Iterator<Integer> i = adj[n].listIterator();\n        while(i.hasNext()){\n            Integer a = i.next();\n            if(!vis[a]){\n                vis[a] = true;\n                dfs(a);\n            }\n        }\n    }\n    \n    static void initAdj(int n){\n        adj = new LinkedList[n + 2];\n        for(int i = 0; i <= n + 1; i++)\n            adj[i] = new LinkedList();\n    }\n\n    static String removeLastChar(String ss) {\n        if (ss == null || ss.length() == 0) {\n            return ss;\n        }\n        return ss.substring(0, ss.length()-1);\n    }\n    \n    static void solveLunLun(){\n        FastScanner sc = new FastScanner();\n        Queue<Long> q = new ArrayDeque();\n        for(int i = 1; i <= 9; i++){\n            q.add((long) i);\n        }\n        int k = sc.nextInt();\n        int cnt = 0;\n        long x = 1;\n        while(cnt < k){\n            x = q.poll();\n            cnt++;\n            if(cnt >= k) break;\n            \n            long d = x % (long) 10;\n            if(d == 0){\n                q.add( (10 * x));\n                q.add( (10 * x) + d + 1 );\n            }\n            else if (d == 9){\n                q.add( (10 * x) + d - 1);\n                q.add( (10 * x) + d);\n            }\n            else {\n                q.add( (10 * x) + d - 1);\n                q.add( (10 * x) + d);\n                q.add( (10 * x) + d + 1 );                \n            }\n        }\n        out.println(x);\n\n    }\n \n}\n\n\nclass FastScanner { \n    BufferedReader br; \n    StringTokenizer st; \n\n    public FastScanner() \n    { \n        br = new BufferedReader(new\n                 InputStreamReader(System.in)); \n    } \n\n    String next() \n    { \n        while (st == null || !st.hasMoreElements()) \n        { \n            try\n            { \n                st = new StringTokenizer(br.readLine()); \n            } \n            catch (IOException  e) \n            { \n                e.printStackTrace(); \n            } \n        } \n        return st.nextToken(); \n    } \n\n    int nextInt() \n    { \n        return Integer.parseInt(next()); \n    } \n\n    long nextLong() \n    { \n        return Long.parseLong(next()); \n    } \n\n    double nextDouble() \n    { \n        return Double.parseDouble(next()); \n    } \n\n    String nextLine() \n    { \n        String str = \"\"; \n        try\n        { \n            str = br.readLine(); \n        } \n        catch (IOException e) \n        { \n            e.printStackTrace(); \n        } \n        return str; \n    } \n\n    int[] nextIntArray(int length) {\n       int[] arr = new int[length];\n       for (int i = 0; i < length; i++)\n           arr[i] = nextInt();\n       return arr;\n   }\n} \n\n\nclass Friend implements Comparable<Friend>{\n    public int money;\n    public long friendship;\n    public Friend(int a, long b){\n        money = a;\n        friendship = b;\n    }\n\n    \n    public int compareTo(Friend t) {\n        if(this.money < t.money)\n            return -1;\n        else if (this.money > t.money)\n            return 1;\n        else \n            return 0;\n    }\n}\n\n\n\nclass Node\n{\n    public int V;\n    public Node(int v)\n    {\n        this.V=v;\n    }\n}\n\nclass Tuple{\n    public int first;\n    public int second;\n    public int third;\n    public Tuple(int a, int b, int c){\n        first = a;\n        second = b;\n        third = c;\n    }\n}\n\nclass Pair{\n    public int first;\n    public int second;\n    public Pair(int a, int b){\n        first = a;\n        second = b;\n    }\n    \n\n}\n\n\n"
        },
        {
            "language": 1,
            "solution": "r=lambda:map(int,raw_input().split());N,D=r();X=xrange(N);F=sorted(r()for i in X);R=H=A=0;\nfor L in X:\n while H<N and F[H][0]-F[L][0]<D:R+=F[H][1];H+=1\n A=max(A,R);R-=F[L][1]\nprint(A)"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nmat = []\nfor i in range(n):\n    m, s = map(int, input().split())\n    mat.append([m, s])\nmat.sort(key=lambda x: x[0])\ndp = [0] * ( n + 1)\nfor i in range(1, n + 1):\n    dp[i] = dp[i - 1] + mat[i - 1][1]\nans = mat[0][1]\ni = 0\nj = 0\nwhile i < n and j < n:\n    if mat[j][0] - mat[i][0] < d:\n        ans = max(ans, dp[j + 1] - dp[i])\n        j += 1\n    else:\n        i += 1\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\na=lambda:stdin.readline().split()\nn,d=map(int,a())\ndi={-1:0}\nfor _ in range(n):\n    m,s=map(int,a())\n    if di.get(m)==None:di[m]=0\n    di[m]+=s\nlst=[*di.keys()]\nlst.sort()\nfor i,x in enumerate(lst[1:]):\n    di[x]+=di[lst[i]]\nfrom bisect import bisect_left as bis\nres=0\nfor i,x in enumerate(lst[1:]):\n    item=bis(lst,x+d)-1\n    res=max(res,di[lst[item]]-di[lst[i]])\nprint(res)"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nl=[]\nfor i in range(n):\n    x,y=map(int,input().split())\n    l.append([x,y])\nl.sort()\n\nans=0\na=[]\ni=0\nj=0\n\nwhile i<n:\n    if l[i][0]-l[j][0]>=d:\n        a.append(ans)\n        ans-=l[j][1]\n        j+=1\n    else:\n        ans+=l[i][1]\n        a.append(ans)\n        i+=1\nprint(max(a))"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class B {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint diff = in.nextInt();\n\t\tList<Pair<Long,Long>> pairList = new ArrayList<Pair<Long,Long>>();\n\t\twhile(n-- >0)\n\t\t{\n\t\t\tLong key = in.nextLong();\n\t\t\tLong val = in.nextLong();\n\t\t\tPair<Long, Long> p = new Pair<Long, Long>(key, val);\n\t\t\tpairList.add(p);\n\t\t}\n\t\tCollections.sort(pairList , new MyComparator());\n\t\tint start = 0;\n\t\tlong result = 0;\n\t\tlong cur =0;\n        for(int i = 0; i < pairList.size(); i++){\n            \n            cur += pairList.get(i).getR();\n            while(pairList.get(start).getL() <= pairList.get(i).getL()  - diff){\n                cur -= pairList.get(start).getR();\n                start++;\n            }\n            result = result > cur ? result : cur;\n        }\n\t\tSystem.out.println(result);\n\t}\n}\n\nclass MyComparator implements Comparator<Pair<Long,Long>> {\npublic int compare(Pair<Long,Long> o1, Pair<Long,Long> o2) {\n    if (o1.getL() <o2.getL()) {\n        return -1;\n    } else if (o1.getL() >o2.getL()) {\n        return 1;\n    }\n    return 0;\n}}\n\nclass Pair<L,R> {\n    private L l;\n    private R r;\n    public Pair(L l, R r){\n        this.l = l;\n        this.r = r;\n    }\n    public L getL(){ return l; }\n    public R getR(){ return r; }\n    public void setL(L l){ this.l = l; }\n    public void setR(R r){ this.r = r; }\n}"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout\nlines = stdin.readlines()\nn, d = int(lines[0].split()[0]), int(lines[0].split()[1])\nmat = [[int(x.split()[0]),int(x.split()[1])]  for x in lines[1:]]\nmat = sorted(mat)\n\nmx = 0\ntemp_mx = 0\ni = 0\n\nfor j in range(n):\n    temp_mx += mat[j][1]\n\n    if (mat[j][0] - mat[i][0])>=d:\n        while (mat[j][0] - mat[i][0]) >= d:\n            temp_mx -= mat[i][1]\n            i += 1\n    mx=max(temp_mx,mx)\nprint(mx)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class R321qB {\n\n\tpublic static void main(String args[]) {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint d = in.nextInt();\n\t\t\n\t\tlong ans = 0;\n\t\t\n\t\tPair p[] = new Pair[n];\n\t\tfor(int i=0;i<n;++i)\n\t\t\tp[i] = new Pair(in.nextInt(),in.nextInt());\n\t\tArrays.sort(p);\n\t\t\n\t\tint l = 0;\n\t\tlong total = 0;\n\t\tfor(int r=0;r<n;++r){\n\t\t\ttotal += p[r].fri;\n\t\t\twhile(p[r].mon -  p[l].mon >= d){\n\t\t\t\ttotal -= p[l].fri;\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tans = Math.max(ans, total);\n\t\t}\n\t\t\n\t\tw.println(ans);\n\t\tw.close();\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair>{\n\t\tint mon,fri;\n\t\tPair(int i,int v){\n\t\t\tmon = i;\n\t\t\tfri = v;\n\t\t}\n\t\tpublic int compareTo(Pair o){\n\t\t\tif(mon != o.mon)\n\t\t\t\treturn Integer.compare(mon, o.mon);\n\t\t\treturn Integer.compare(fri, o.fri);\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn mon + \" \" + fri;\n\t\t}\n\t}\n\t\n\tstatic class InputReader {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[8192];\n\t\tprivate int curChar;\n\t\tprivate int snumChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\n\t\t\tlong res = 0;\n\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic String readString() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "r = lambda: map(int, input().split())\n\nn, d = r()\na = sorted(tuple(r()) for i in range(n))\n\ni = 0\nMin = a[i][0]\nMax = cur = 0\n\nfor m, s in a:\n    cur += s\n    if m - Min >= d:\n        while m - a[i][0] >= d:\n            cur -= a[i][1]\n            i += 1\n        Min = a[i][0]\n    Max = max(Max, cur)\n        \nprint(Max)\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin, stdout\nn,d = map(int, stdin.readline().rstrip().split())\n#n,d = 5,100\nfriends = []\nfor i in range(n):\n    friends.append(map(int, stdin.readline().rstrip().split()))\n#friends=[[0,7],[11,32],[99,10],[46,8],[87,54]]\nfriends = sorted(friends, key=lambda x: x[0])\ni = 0\nj = 0\ncur = friends[0][1]\n#print(friends)\nbest = cur\nwhile i < n-1 and j < n-1:\n    j += 1\n    cur += friends[j][1]\n    while not friends[j][0]-friends[i][0] < d:\n        cur -= friends[i][1]\n        i += 1\n    if cur > best:\n        best = cur\nprint(best)\n\n\n\n\n    \n\n"
        },
        {
            "language": 3,
            "solution": "def getIndex(a, k, start, end, val, i):\n    if start == end:\n        if val - a[start][0] < k:\n            return start\n        return i\n    mid = (start + end) // 2\n    if val - a[mid][0] < k:\n        return getIndex(a, k, start, mid, val, i)\n    return getIndex(a, k, mid + 1, end, val, i)\n\nn, k = map(int, input().split())\n\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\na.sort(key=lambda x: x[0])\n\npref = [0 for i in range(n)]\nglob = a[0][1]\npref[0] = a[0][1]\nfor i in range(1, n):\n    pref[i] = pref[i - 1] + a[i][1]\n# print(a)\nfor i in range(1, n):\n    temp = getIndex(a, k, 0, i - 1, a[i][0], i)\n    # print(temp)\n    glob = max(glob, pref[i] - (pref[temp - 1] if temp - 1 >= 0 else 0))\n\nprint(glob)"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Created by william_lee on 12/29/16.\n */\npublic class kefaandcomp {\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        int d=in.nextInt();\n        p[]arr=new p[n];\n        for(int i=0;i<n;i++){\n            arr[i]=new p(in.nextInt(),in.nextInt());\n        }\n        Arrays.sort(arr);\n        int i=0;\n        int j=0;\n        long m=-1;\n        long c=0;\n        while(i<n){\n            while(j<n&&arr[j].m<arr[i].m+d){\n                c+=arr[j].f;\n                j++;\n            }\n            m=Math.max(m,c);\n            c-=arr[i].f;\n            i++;\n        }\n        System.out.println(m);\n    }\n}\nclass p implements Comparable{\n    int m;\n    int f;\n    public p(int m,int f){\n        this.m=m;\n        this.f=f;\n    }\n\n    @Override\n    public int compareTo(Object o) {\n        p oth=(p)o;\n        return new Integer(m).compareTo(new Integer(oth.m));\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\nmiguxos = []\nfor i in range(n):\n\tmiguxos.append(map(int,raw_input().split()))\nmiguxos = sorted(miguxos, key=lambda miguxos: miguxos[0])\n\ni = 0\nj = 0\nmaximum = 0\nm=0\nwhile(j < n):\n\tif ( (miguxos[j][0] - miguxos[i][0]) <d):\n\t\t m += miguxos[j][1]\n\t\t j+=1\n\t\t if (j==n):\n\t\t\t maximum = max(m,maximum)\n\telse:\n\t\tmaximum= max(m,maximum)\n\t\tm-= miguxos[i][1]\n\t\ti+=1\n\nprint maximum\n\n\t\t\n"
        },
        {
            "language": 3,
            "solution": "n, diff = map(int, input().split())\na = sorted([tuple(map(int, input().split())) for _ in range(n)])\n\nret = 0\ns = 0\nleft = 0\nfor right in range(n):\n    while a[right][0] - a[left][0] >= diff:\n        s -= a[left][1]\n        left += 1\n    s += a[right][1]\n    ret = max(s, ret)\nprint(ret)"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\ndata = []\n\nfor i in range(n):\n    data.append(map(int, raw_input().split()))\n\ndata.sort(key=lambda x: x[0])\n\ncurr_max = 0\nbegin = 0\ntemp_sum = 0\nfor end in range(n):\n    temp_sum += data[end][1]\n    while (data[end][0] - data[begin][0]) >= d:\n        temp_sum -= data[begin][1]\n        begin += 1\n    curr_max = max(curr_max, temp_sum)\n\nprint(curr_max)"
        },
        {
            "language": 1,
            "solution": "#encoding: utf-8\nread_input = map(int, raw_input().split())\n\nn = read_input[0]\nd = read_input[1]\n\ninput_list = []\n\nfor i in range(n):\n    user_input = map(int, raw_input().split())\n    input_list.append((user_input[0], user_input[1]))\n\ninput_list.sort()\n\nmax_factor = input_list[0][1]\npartial_sum = input_list[0][1]\n\nj = 0\nfor i in range(1, n):\n    while((input_list[i][0] - input_list[j][0]) >= d):\n        partial_sum -= input_list[j][1]\n        j += 1\n\n    partial_sum += input_list[i][1]\n    max_factor = max(max_factor, partial_sum)\n\nprint(max_factor)"
        },
        {
            "language": 1,
            "solution": "r=lambda:map(int,raw_input().split())\n\nn,d=r()\n\nr=sorted(r() for i in range(n))\nj=-1\nS=0\nm=0\nfor i in range(n):\n    while True:\n        if j < n-1 and r[j + 1][0]-r[i][0] < d:\n            j=j+1\n            S+=r[j][1]\n            m=max(m,S)\n        else:\n            break\n    S-=r[i][1]\nprint m"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int SIZE = 1e5 + 5;\nusing namespace std;\nint n, d;\nvector<pair<int, int> > arr;\nint BS(int x) {\n  int res = -1;\n  int f = 0, e = n - 1;\n  while (f <= e) {\n    int m = (f + e) / 2;\n    if (arr[m].first > x)\n      e = m - 1, res = m;\n    else\n      f = m + 1, res = m + 1;\n  }\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL), cout.tie(NULL);\n  cin >> n >> d;\n  arr.resize(n);\n  for (int i = 0; i < n; i++) cin >> arr[i].first >> arr[i].second;\n  sort(arr.begin(), arr.end());\n  vector<long long> sum(n + 1);\n  sum[0] = 0;\n  for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + arr[i].second;\n  long long res = 0;\n  for (int i = 0; i < n; i++) {\n    int idx = BS(arr[i].first + d - 1);\n    res = max(res, sum[idx] - sum[i]);\n  }\n  cout << res;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d = input().split()\nn,d = int(n),int(d)\n\nl = {}\nfor i in range(n):\n    m,s = input().split()\n    m,s = int(m),int(s)\n\n    if m not in l: l[m] = s\n    else: l[m] += s\n    \na = sorted(l.keys())\ne,f = 0,1\nm = l[a[0]]; ma = l[a[0]]\nwhile f < len(a):\n    m += l[a[f]]\n    while a[f] - a[e] >= d:\n        m-= l[a[e]]\n        e += 1\n    if m > ma: ma = m\n    f += 1\nprint(ma)\n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  long long m, s;\n};\nconst int maxn = 100000 + 10;\nnode p[maxn];\nlong long sum[maxn];\nint n;\nlong long d;\nbool cmp(const node &a, const node &b) { return a.m < b.m; }\nint main() {\n  cin >> n >> d;\n  for (int i = 1; i <= n; i++) cin >> p[i].m >> p[i].s;\n  sort(p + 1, p + 1 + n, cmp);\n  p[n + 1].m = 1000000000 + 10;\n  sum[0] = 0;\n  for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + p[i].s;\n  long long ans = -1;\n  for (int i = 1; i <= n; i++) {\n    int l = i + 1;\n    int r = n + 1;\n    int pos = i + 1;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if (p[mid].m >= p[i].m + d) {\n        pos = mid;\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n    if (sum[pos - 1] - sum[i - 1] > ans) ans = sum[pos - 1] - sum[i - 1];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def solve(n, d, f):\n    f.sort(key=lambda x: (x[0], -x[1]))\n    left = 0\n    right = 1\n    s = f[left][1]\n    c = s\n    while right < len(f):\n        m = f[right][0] - f[left][0]\n        if m < d:\n            c = c + f[right][1]\n            s = max(s, c)\n            right += 1\n        else:\n            c = c - f[left][1]\n            left += 1\n    return s\n\ndef main():\n    n,d = map(int,input().split())\n    f = []\n    for i in range(n):\n        f.append(list(map(int,input().split())))\n    print (solve(n, d, f))\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 3,
            "solution": "import sys\nii = lambda: sys.stdin.readline().strip()\nidata = lambda: [int(x) for x in ii().split()]\nn, d = idata()\nsp = []\nfor i in range(n):\n    sp += [idata()]\nsp.sort()\nl, r, maxx, ans = 0, 0, sp[0][1], sp[0][1]\nwhile r != n - 1:\n    r += 1\n    maxx += sp[r][1]\n    while sp[r][0] - sp[l][0] >= d:\n        maxx -= sp[l][1]\n        l += 1\n    ans = max(ans, maxx)\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "from operator import itemgetter\nn,d = map(int,input().split())\nfnd = []\nfor i in range(n) :\n    fnd.append([0,0])\n    fnd[i] = list(map(int,input().split()))\n\nfnd.sort(key=lambda x : x[0])\ntmp = fnd[0][1]\nmx = tmp\nj=0\n#print(fnd)\nfor i in range(n) :\n    if j==n-1 :\n        break\n    while fnd[j+1][0]-fnd[i][0] < d :\n        tmp += fnd[j+1][1]\n        j+=1\n        if j == n-1 :\n            break\n    #print(i,j,tmp)\n    if tmp>mx :\n        mx = tmp\n    tmp -= fnd[i][1]\nprint(mx)\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class KefaAndCompany {\n    private static BufferedReader br;\n    private static StringTokenizer st;\n    \n    public static void main(String[] args) throws Exception {\n        PrintWriter pw = new PrintWriter(System.out);\n        reader(System.in);\n        int n = nextInt();\n        int d = nextInt();\n        Friend[] f = new Friend[n];\n        for (int i = 0; i < n; i++) {\n            f[i] = new Friend( nextInt(), nextInt());\n        }\n        Arrays.sort(f);\n        long max = 0;\n        long temp = 0;\n        int i = 0, j = 0;\n        while (i < n && j < n) {\n            int l = f[i].m;\n            while (j < n && f[j].m - l < d) {\n                temp += f[j].s;\n                j++;\n            }\n            if (max < temp) {\n                max = temp;\n            }\n            temp -= f[i].s;\n            i++;\n        }\n        pw.println(max);\n        pw.close();\n    }\n\n    static void reader(InputStream stream) {\n        try {\n            br = new BufferedReader(new InputStreamReader(stream));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    static String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(next());\n    }\n}\n\nclass Friend implements Comparable <Friend> {\n    public int m, s;\n    \n    public Friend (int m, int s) {\n        this.m = m;\n        this.s = s;\n    }\n    \n    @Override\n    public int compareTo(Friend f) {\n        return m > f.m ? 1 : m < f.m ? -1 : 0;\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "def x(friends= [[]], element = []):\n    for i in xrange(len(friends)):\n        if (abs(element[1] - friends[i][1]) < difference):\n            if(abs(element[2] - friends[i][2]) < difference):\n                friends[i][0] += element[0]\n                if (element[1] < friends[i][1]):\n                    friends[i][1] = element[1]\n                if(element[2] > friends[i][2]):\n                    friends[i][2] = element[2]\n                return True\n    return False\n\nnOffriends, difference = map(int, raw_input().split())\n\nfriends = []\nfriendsInd = []\n\nfor f in xrange(nOffriends):\n    money, factor = map(int, raw_input().split())\n    element = [factor, money, money]\n    friendsInd.append(element)\n\n\n    hasAdded = x(friends, element)\n\n    if(not hasAdded):\n        for fi in xrange(len(friendsInd) - 1):\n            if (abs(friendsInd[fi][1] - element[1]) < difference):\n                if(abs(friendsInd[fi][2] - element[2]) < difference):\n                    element[0] += friendsInd[fi][0]\n\n                    if(friendsInd[fi][1] < element[1]):\n                        element[1] = friendsInd[fi][1]\n                    if(friendsInd[fi][2] > element[2]):\n                        element[2] = friendsInd[fi][2]\n        friends.append(element)\n\nprint max(friends)[0]\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "#n = int(input())\nn, m = map(int, input().split())\n#s = input()\n#c = list(map(int, input().split()))\na = [0] * n\n\nfor i in range(n):\n    a[i] = tuple(map(int, input().split()))\na.sort()\ni = 0\nj = 0\nk = 0\ns = 0\nwhile j < n:\n    if a[j][0] - a[i][0] < m:\n        s += a[j][1]\n        j += 1\n    else:\n        k = max(k, s)\n        s -= a[i][1]\n        i += 1\nk = max(k, s)\nprint(k)"
        },
        {
            "language": 3,
            "solution": "n , d = list(map(int,input().split()))\nl = []\nfor i in range(n):\n  m , s = list(map(int,input().split()))\n  l.append([m , s])\nl.sort()\ni = 0\ns = 0\nm_x= 0\nfor k in range(n):\n  s += l[k][1]\n  while(l[k][0]-l[i][0] >= d):\n    s -= l[i][1]\n    i += 1\n  m_x = max(m_x , s)\nprint(m_x)"
        },
        {
            "language": 3,
            "solution": "from bisect import *\nn, d = map(int, input().split())\nlol = []\nfor _ in range(n):\n    m, s = map(int, input().split())\n    lol.append((m, s))\nlol.sort()\npre = [0]\nfor c in lol:\n    pre.append(pre[-1] + c[1])\nans = 0\nfor i in range(n):\n    j = lol[i]\n    b2 = bisect_right(lol, (j[0] + d - 1, 10**100))\n    ans = max(ans, pre[b2]-pre[i])\n\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, d;\n  cin >> n >> d;\n  vector<pair<int, int> > v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first >> v[i].second;\n  }\n  sort(v.begin(), v.end());\n  long long int sum = v[0].second, sum1 = v[0].second;\n  bool b = false;\n  int start = 0;\n  for (int i = 1; i < n; i++) {\n    if (i == start) {\n      sum1 += v[i].second;\n      if (sum1 > sum) sum = sum1;\n      continue;\n    }\n    if (v[i].first - v[start].first < d)\n      sum1 += v[i].second;\n    else {\n      sum1 -= v[start].second;\n      i--;\n      start++;\n    }\n    if (sum1 > sum) sum = sum1;\n  }\n  cout << sum;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "R=lambda:map(int,raw_input().split())\nn,d=R()\na=sorted([R() for _ in range(n)])\ns,t,p=0,0,0\nfor i in range(n):\n  s+=a[i][1]\n  while p<i and a[i][0]>=a[p][0]+d:\n    s-=a[p][1]\n    p+=1\n  t=max(t,s)\nprint t\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nstruct node {\n  int mon, fac;\n  bool operator<(const node& t) const { return mon < t.mon; }\n} st[maxn];\nlong long sum[maxn] = {0};\nint main() {\n  int n, d;\n  cin >> n >> d;\n  for (int i = 1; i <= n; ++i) cin >> st[i].mon >> st[i].fac;\n  sort(st + 1, st + n + 1);\n  for (int i = 1; i <= n; ++i) sum[i] = sum[i - 1] + st[i].fac;\n  int l = 1, r = 1;\n  long long ans = 0;\n  for (; l <= n; ++l) {\n    while (r <= n && st[r].mon - st[l].mon < d) r++;\n    ans = max(ans, sum[r - 1] - sum[l - 1]);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Map.Entry;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main{\n\tpublic static void main(String args[]) throws NumberFormatException,IOException {\n\t\t\n\t\tStdin in = new Stdin();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n=in.readInt();\n\t\tint d=in.readInt();\n\t\tTreeMap<Long,Long>factir=new TreeMap<Long,Long>();\n\t\tlong m,s;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tm=in.readLong();\n\t\t\ts=in.readLong();\n\t\t\tif(factir.containsKey(m)){\n\t\t\t\tfactir.put(m, s+factir.get(m));\n\t\t\t}else{\n\t\t\t\tfactir.put(m, s);\n\t\t\t}\n\t\t}\n\t\tlong money[]=new long[factir.size()];\n\t\tlong fac[]=new long[factir.size()];\n\t\tint pos=0;\n\t\tfor(Entry<Long,Long>entry:factir.entrySet()){\n\t\t\tmoney[pos]=entry.getKey();\n\t\t\tfac[pos++]=entry.getValue();\n\t\t}\n\t\tlong max=fac[fac.length-1];\n\t\tlong cur=0;\t\n\t\tint rightMost=0;\n\t\tfor(int i=0;i<fac.length;i++){\n\t\t\twhile(rightMost<fac.length&&money[rightMost]<d+money[i]){\n\t\t\t\tcur+=fac[rightMost];\n\t\t\t\trightMost++;\n\t\t\t}\n\t\t\tmax=max(max,cur);\n\t\t\tcur-=fac[i];\n\t\t}\n\t\tout.println(max);\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\tprivate static long max(long a,long b){\n\t\treturn a<b?b:a;\n\t}\n\tprivate static class Stdin {\n\t\tInputStreamReader read;\n\t\tBufferedReader br;\n\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\n\t\tprivate Stdin() {\n\t\t\tread = new InputStreamReader(System.in);\n\t\t\tbr = new BufferedReader(read);\n\n\t\t}\n\n\t\tprivate String readNext() throws IOException {\n\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tprivate int readInt() throws IOException, NumberFormatException {\n\n\t\t\treturn Integer.parseInt(readNext());\n\n\t\t}\n\n\t\tprivate long readLong() throws IOException, NumberFormatException {\n\n\t\t\treturn Long.parseLong(readNext());\n\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\na = []\nfor i in range(n):\n    x = list(map(int, input().split()))\n    a.append(x)\na.sort()\ni = 0\nj = 1\nans = a[0][1]\nmd = a[0][0] + d\nansq = ans\nwhile j != n:\n    if a[j][0] < md:\n        ans += a[j][1]\n        ansq = max(ans, ansq)\n        j += 1\n    else:\n        ans -= a[i][1]\n        ansq = max(ans, ansq)\n        i += 1\n        md = a[i][0] + d\nprint(ansq)\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nl=sorted([[*map(int,input().split())]for _ in' '*n])\nj=a=A=0\nfor i in range(n):\n    a+=l[i][1]\n    while l[i][0]-l[j][0]>=d:\n        a-=l[j][1]\n        j+=1\n    A=max(A,a)\nprint(A)    "
        },
        {
            "language": 3,
            "solution": "n,d = map(int, input().split())\nm = [tuple(map(int, input().split())) for _ in range(n)]\nm = sorted(m)\nf = 0\nfr = m[f][1]\nposs = []\nfor i in range(1,n):\n    if m[i][0]-m[f][0] < d:\n        fr += m[i][1]\n    else:\n        poss.append(fr)\n        fr -= m[f][1]\n        f+=1\n        while f < i:\n            if m[i][0]-m[f][0] < d:\n                break\n            fr -= m[f][1]\n            f+=1\n        fr += m[i][1]\nposs.append(fr)\nprint(max(poss))"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String argc[]) throws IOException{\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(in, out);\n        out.close();\n    }\n\n    static class TaskA{\n\n        static void solve(InputReader in, PrintWriter out) throws IOException{\n            int n = in.nextInt();\n            int a[] = new int[n];\n            int max = 0;\n            for(int i = 0;i < n;i ++){\n                a[i] = in.nextInt();\n            }\n            max = 1;\n            int cur = 1;\n            for(int i = 1;i < n;i ++){\n                if(a[i] >= a[i - 1]){\n                    cur ++;\n                }else{\n                    cur = 1;\n                }\n                max = Math.max(max, cur);\n            }\n            out.println(max);\n        }\n\n    }\n\n    static class TaskB{\n        static void solve(InputReader in, PrintWriter out) throws IOException{\n            int n = in.nextInt();\n            int d = in.nextInt();\n            ArrayList<pair> a = new ArrayList<>();\n            int x, y;\n            for(int i = 0;i < n;i ++){\n                x = in.nextInt();\n                y = in.nextInt();\n                a.add(new pair(x, y));\n            }\n            a.sort(new PairComparator());\n            int st = 0, fin = 0;\n            long max = 0;\n            long pref[] = new long[n];\n            for(int i = 0;i < n;i ++)pref[i] = 0;\n            pref[0] = a.get(0).y;\n            for(int i = 1;i < n;i ++){\n                pref[i] = pref[i - 1] + a.get(i).y;\n            }\n            while(st <= fin){\n                if((a.get(fin)).x - a.get(st).x < d){\n                    max = Math.max(max, pref[fin] - ((st > 0) ? pref[st - 1] : 0));\n                    if(fin < n - 1)fin ++; else st ++;\n                }else{\n                    st ++;\n                }\n            }\n            out.println(max);\n        }\n\n        static class PairComparator implements Comparator<pair>{\n            @Override\n            public int compare(pair a, pair b){\n                if(a.x != b.x)return (a.x < b.x) ? -1 : 1;\n                if(a.y != b.y)return (a.y < b.y) ? -1 : 1;\n                return 0;\n            }\n        }\n\n        static final class pair{\n            int x;\n            int y;\n\n            pair(int x, int y){\n                this.x = x;\n                this.y = y;\n            }\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String nextLine(){\n            try {\n                return reader.readLine();\n            }catch(IOException e){\n                return null;\n            }\n        }\n\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n########################################################################\n\nn,d=ris()\na=[]\nfor _ in range(n):\n  a.append(ris())\n\na.sort()\nans=s=l=0\nfor r in range(n):\n  s+=a[r][1]\n  while d<=abs(a[l][0]-a[r][0]):\n    s-=a[l][1]\n    l+=1\n  ans=max(ans,s)\n\nprint(ans)\n"
        },
        {
            "language": 1,
            "solution": "l=lambda:map(int,raw_input().split())\nn,diff=l()\nd={}\nfor i in range(n):\n    mi,si=l()\n    d[mi]=d.get(mi,0)+si\nd=sorted(d.iteritems(),key=lambda x:x[0])\nmaxi=0\nc=d[0][1]\ni=0\nmini=d[0][0]\nmini_idx=0\nwhile i<len(d)-1: \n    if d[i+1][0]-mini<diff:\n        c+=d[i+1][1]\n        i+=1\n    else:\n        maxi=max(maxi,c)\n        c-=d[mini_idx][1]\n        mini_idx+=1\n        mini=d[mini_idx][0]   \nprint max(maxi,c)"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\n\nmf = [0]*n\ncum_factor = [0]*(n+1)\n\nfor i in range(n):\n\tm, f = map(int, raw_input().split())\n\tmf[i] = (m, f)\n\n\nmf.sort()\n\n#print mf\n\nfor i in range(n):\n\tcum_factor[i+1] = mf[i][1] + cum_factor[i]\n\n\t\ni = 0\nj = 1\nans = -1\nwhile (i<n and j<n):\n\t\n\n\t#print ans, i, j\n\n\tif i == j:\n\t\tj += 1\n\t\tcontinue\n\n\tif abs(mf[i][0]- mf[j][0]) < d:\n\t\tj += 1\n\telse:\n\t\tans = max(ans, cum_factor[j] - cum_factor[i])\n\t\ti += 1\n\nif j == n:\n\tans = max(ans, cum_factor[j] - cum_factor[i])\n\n\nprint ans\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class P580B {\n  public static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n\n    int n = input.nextInt();\n    int d = input.nextInt();\n\n    Pair[] f = new Pair[n];\n    for (int i = 0; i < n; i++) {\n      f[i] = new Pair(input.nextInt(), input.nextInt());\n    }\n\n    Arrays.sort(f);\n    long[] ps = new long[n];\n    ps[0] = f[0].s;\n    for (int i = 1; i < n; i++) {\n      ps[i] = ps[i-1] + f[i].s;\n    }\n\n    long ans = 0;\n    for (int i = 0; i < n; i++) {\n      int last = bs(f, i, n - 1, f[i].m + d - 1);\n      ans = Math.max(ans, i == 0 ? ps[last] : ps[last] - ps[i - 1]);\n    }\n\n    System.out.println(ans);\n  }\n\n  private static int bs(Pair[] f, int start, int end, int max) {\n    while (start < end) {\n      int mid = (start + end) / 2;\n      if(f[mid].m <= max) {\n        if(mid + 1 < f.length) {\n          if (f[mid + 1].m > max) {\n            end = mid;\n          } else {\n            start = mid + 1;\n          }\n        }\n      } else {\n        end = mid - 1;\n      }\n    }\n    return start;\n  }\n\n  private static class Pair implements Comparable<Pair> {\n    private final int m;\n    private final int s;\n\n    private Pair(int m, int s) {\n      this.m = m;\n      this.s = s;\n    }\n\n    @Override\n    public int compareTo(Pair o) {\n      return this.m - o.m;\n    }\n\n    @Override\n    public String toString() {\n      return \"[\" + m + \",\" + s + \"]\";\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long calpowof2(long long a, long long b) {\n  if (b == 0) return 1;\n  if (b % 2 == 0) {\n    long long ans = calpowof2(a, b / 2);\n    return (ans % mod * ans % mod) % mod;\n  }\n  long long ans = calpowof2(a, b - 1);\n  return (a % mod * ans % mod) % mod;\n}\nvoid solve() {\n  long long i, j, n, t, m, k, ct = 0, sum = 0, flag = 0;\n  cin >> n >> k;\n  vector<pair<long long, long long> > v1;\n  for (long long i = (0); i < (n); i++) {\n    cin >> j >> m;\n    v1.push_back({j, m});\n  }\n  sort(v1.begin(), v1.end());\n  long long start_ptr = 0;\n  sum = v1[0].second;\n  long long mx = INT_MIN;\n  mx = sum;\n  for (long long i = (1); i < (n); i++) {\n    if (v1[i].first - v1[start_ptr].first < k) {\n      sum += v1[i].second;\n      mx = max(sum, mx);\n    } else {\n      sum -= v1[start_ptr].second;\n      start_ptr++;\n      i--;\n    }\n  }\n  cout << mx;\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n  cerr << endl << clock() * 1000.0 / CLOCKS_PER_SEC << 'm' << 's';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = [int(i) for i in input().split()]\nfrendo = [[0, 0]]\nfor i in range(n):\n    xs = [int(x) for x in input().split()][:2]\n    frendo.append(xs)\n\n\ndef cmp(xs):\n    return xs[0]\n\n\nfrendo.sort(key=cmp)\n\nj = 0\nsuma = rez = 0\n\ndiff = 0\n\nfor i in range(1, n + 1):\n    suma += frendo[i][1]\n    frendo[i][1] = suma\n\nfor i in range(n+1):\n    diff = frendo[i][0] - frendo[j][0]\n    if(diff<d):\n        rez = max(rez, frendo[i][1] - frendo[j][1])\n    else:\n        while(diff>=d):\n            j+=1\n            diff = frendo[i][0] - frendo[j][0]\n        j-=1\n        rez = max(rez, frendo[i][1] - frendo[j][1])\n\n\nprint(rez)"
        },
        {
            "language": 1,
            "solution": "n,d=map(int,raw_input().split())\nnums=sorted([map(int,raw_input().split()) for i in xrange(n)])\nr=0\nSum=0\nans=0\nfor i in xrange(n):\n    if i>=r:\n        r+=1\n        Sum+=nums[i][1]\n    while r<n and nums[r][0]-nums[i][0]<d:\n        Sum+=nums[r][1]\n        r+=1\n    ans=max(ans,Sum)\n    Sum-=nums[i][1]\nprint ans\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, d, a, b, cek, sum, ans;\nvector<pair<long long, long long> > v;\nint main() {\n  cin >> n >> d;\n  for (int i = 1; i <= n; i++) {\n    cin >> a >> b;\n    v.push_back({a, b});\n  }\n  sort(v.begin(), v.end());\n  long long id = 0;\n  for (int i = 0; i < n; i++) {\n    cek = v[i].first - v[id].first;\n    sum += v[i].second;\n    while (cek >= d) {\n      sum -= v[id].second;\n      id++;\n      cek = v[i].first - v[id].first;\n    }\n    ans = max(ans, sum);\n  }\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 3,
            "solution": "#\t!/usr/bin/env python3\n#\tcoding: UTF-8\n#\tModified: <08/Mar/2019 11:42:15 PM>\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology (IIIT),Gwalior\n\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\ninf = float(\"inf\")\nmod = 1000000007\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return map(int, sys.stdin.readline().split())\n\n\ndef input(): return sys.stdin.readline()\n\n# ///==========MAIN=============///\n\n\ndef main():\n    n, d = get_ints()\n    arr = [0]*n\n    for i in range(n):\n        arr[i] = get_array()\n    arr.sort()\n    ans = 0\n    j = 0\n    curr = 0\n    for i in range(n):\n        while j < n and arr[j][0] < arr[i][0]+d:\n            curr += arr[j][1]\n            j += 1\n        ans = max(ans, curr)\n        curr -= arr[i][1]\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 3,
            "solution": "def cmp(a):\n    return a[0]\n\nn, d = [int(x) for x in input().split()]\narr = []\n\nfor i in range(n):\n    l = [int(x) for x in input().split()]\n    arr.append(l)\n    \narr.sort(key=cmp)\ni = 0\nans = arr[0][1]\nnow = arr[0][1]\n\nfor j in range(1, n):\n    if arr[j][0] - arr[i][0] < d:\n        now += arr[j][1]\n    else:\n        if now > ans:\n            ans = now\n        \n        while arr[j][0] - arr[i][0] >= d:\n            now -= arr[i][1]\n            i += 1\n            \n        now += arr[j][1]\n        \nif now > ans:\n    ans = now\n    \nprint(ans)"
        },
        {
            "language": 1,
            "solution": "R = lambda: map(int , raw_input().split())\nn, d = R()\n\nres = []\n\nfor i in range(n):\n    m, s = R()\n    res.append((m, s))\nres.sort()\n\na = 0\nb = 0\n\n\ndiff = 0\ntotal = 0\nmax_total = 0\n\nwhile b < len(res):\n\n    if res[b][0] - res[a][0] < d:\n        total += res[b][1]\n        max_total = max(total, max_total)\n        b += 1\n    else:\n        while res[b][0] - res[a][0] >= d:\n            total -= res[a][1]\n            a += 1\n\nprint max_total\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:134217728\")\nusing namespace std;\nint main() {\n  int n, d;\n  cin >> n >> d;\n  vector<pair<long long, long long> > v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first >> v[i].second;\n  }\n  sort(v.begin(), v.end());\n  long long mx = 0;\n  long long cursum = 0;\n  int r = 0;\n  for (int i = 0; i < n; i++) {\n    while (r < n && v[r].first - v[i].first < d) {\n      cursum += v[r].second;\n      r++;\n    }\n    mx = max(mx, cursum);\n    cursum -= v[i].second;\n  }\n  cout << mx;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces {\n\n    static class Friend implements Comparable<Friend> {\n        int money;\n        int friendship;\n\n        Friend(int money, int friendship) {\n            this.money = money;\n            this.friendship = friendship;\n        }\n\n        @Override\n        public int compareTo(Friend o) {\n            return money - o.money;\n        }\n    }\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        int n = in.nextInt();\n        int d = in.nextInt();\n\n        List<Friend> friends = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            friends.add(new Friend(in.nextInt(), in.nextInt()));\n        }\n\n        Collections.sort(friends);\n        Collections.reverse(friends);\n\n        int top = 0;\n        long res = friends.get(0).friendship;\n        long tempRes = res;\n        for (int i = 1; i < friends.size(); i++) {\n            tempRes += friends.get(i).friendship;\n            while (friends.get(top).money - friends.get(i).money >= d) {\n                tempRes -= friends.get(top).friendship;\n                top++;\n            }\n\n            res = Math.max(res, tempRes);\n        }\n\n        out.println(res);\n        out.close();\n    }\n\n    public static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int[] nextIntArr(int n) {\n            int[] arr = new int[n];\n            for (int j = 0; j < arr.length; j++) {\n                arr[j] = nextInt();\n            }\n\n            return arr;\n        }\n\n        public long[] nextLongArr(int n) {\n            long[] arr = new long[n];\n            for (int j = 0; j < arr.length; j++) {\n                arr[j] = nextLong();\n            }\n\n            return arr;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "p=lambda:map(int,input().split());a,b=p();f=[[*p()] for _ in \" \"*a];f=sorted(f);i,j,k,m=0,0,0,0\nwhile(j<a):\n    if f[j][0]-f[i][0]<b:k+=f[j][1];m=max(m,k);j+=1\n    else:k-=f[i][1];i+=1\nprint(m)"
        },
        {
            "language": 3,
            "solution": "__author__ = 'User'\n\ndef p(x):\n    l = 0\n    r = n\n    while l + 1 < r:\n        m = (l + r) // 2\n        if arr[m][0] <= x:\n            l = m\n        else:\n            r = m\n    return l\n\ndef p2(x):\n    l = -1\n    r = n - 1\n    while l + 1 < r:\n        m = (l + r) // 2\n        if arr[m][0] < x:\n            l = m\n        else:\n            r = m\n    return r\nn, d = map(int,input().split())\narr = [0] * n\nsumm = [0] * n\ns = 0\nfor i in range(n):\n    arr[i] = tuple(map(int, input().split()))\narr.sort()\nfor i in range(n):\n    summ[i] = s + arr[i][1]\n    s += arr[i][1]\nsumm.append(0)\nmx = 0\n#print(arr)\nc = 0\nfor i in arr:\n    r = p(i[0] + (d - 1))\n    l = p2(i[0])\n    #print(l, r)\n    s = summ[r] - summ[l - 1]\n    #print(s)\n    mx = max(mx, s)\nprint(mx)\n#print(summ)\n#print(p(70))"
        },
        {
            "language": 3,
            "solution": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n,d = LI()\n    aa = sorted([LI() for _ in range(n)])\n    i = 0\n    j = 0\n    t = 0\n    r = 0\n    while j < n:\n        aj = aa[j]\n        t += aj[1]\n        j += 1\n        while aj[0] - aa[i][0] >= d:\n            t -= aa[i][1]\n            i += 1\n        if r < t:\n            r = t\n\n    return r\n\n\nprint(main())\n\n\n"
        },
        {
            "language": 1,
            "solution": "#coding: utf-8\n#Raquel Rufino\nsoma = 0\na = 0\ntamanho,fell = map(int,raw_input().split())\nlista = []\nfor i in range(tamanho):\n\tlista.append( map(int,raw_input().split()))\n\nlista.sort()\nj = 0\nfor i in range(tamanho):\n\t\n\twhile j < tamanho and lista[j][0] - lista[i][0] < fell :\n\t\tsoma += lista[j][1]\n\t\tj += 1\n\t\n\tif soma > a :\n\t\ta = soma\n\t\n\tsoma -= lista[i][1]\n\nprint a\n\t\t\n\t\n\t"
        },
        {
            "language": 4,
            "solution": "//package cf_321;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n/**\n * Created by Admin on 10/29/15.\n */\npublic class B\n{\n    public static class friend implements Comparable\n    {\n        int m;\n        int s;\n\n        @Override\n        public int compareTo(Object o)\n        {\n            friend x = (friend) o;\n            if (this.m>x.m) return 1;\n            if (this.m<x.m) return -1;\n            return 0;\n        }\n    }\n\n    public static void main(String[] Args)\n    {\n        FasterScanner sc = new FasterScanner();\n        int n = sc.nextInt();\n        int d = sc.nextInt();\n        friend [] f = new friend[n];\n        for (int i =0; i<n; i++)\n        {\n            f[i]= new friend();\n            f[i].m=sc.nextInt();\n            f[i].s=sc.nextInt();\n        }\n        Arrays.sort(f);\n        int i=0, j=1, a=0, b=0;\n        long loyal = f[0].s, temp = f[0].s;\n        while (j<n)\n        {\n            if (f[j].m-f[i].m<d)\n            {\n                temp+=f[j].s;\n                j++;\n            }\n            else\n            {\n                if (temp>loyal)\n                    loyal=temp;\n                temp-=f[i].s;\n                i++;\n            }\n        }\n\n        if (temp>loyal)\n            loyal=temp;\n        System.out.print(loyal);\n    }\n\n    public static class FasterScanner\n    {\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public int read()\n        {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars)\n            {\n                curChar = 0;\n                try\n                {\n                    numChars = System.in.read(buf);\n                }\n                catch (IOException e)\n                {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public String nextString()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public long nextLong()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int nextInt()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n)\n        {\n            return nextIntArray(n, 0);\n        }\n\n        public int[] nextIntArray(int n, int off)\n        {\n            int[] arr = new int[n + off];\n            for (int i = 0; i < n; i++)\n            {\n                arr[i + off] = nextInt();\n            }\n            return arr;\n        }\n\n        public long[] nextLongArray(int n)\n        {\n            return nextLongArray(n, 0);\n        }\n\n        public long[] nextLongArray(int n, int off)\n        {\n            long[] arr = new long[n + off];\n            for (int i = 0; i < n; i++)\n            {\n                arr[i + off] = nextLong();\n            }\n            return arr;\n        }\n\n        private boolean isSpaceChar(int c)\n        {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c)\n        {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  long long n, d;\n  cin >> n >> d;\n  long long x[100000][2];\n  for (int i = 0; i < n; i++) {\n    cin >> x[i][0] >> x[i][1];\n  }\n  qsort(x, n, sizeof(*x), [](const void *arg1, const void *arg2) -> int {\n    int const *lhs = static_cast<int const *>(arg1);\n    int const *rhs = static_cast<int const *>(arg2);\n    return (lhs[0] < rhs[0])\n               ? -1\n               : ((rhs[0] < lhs[0])\n                      ? 1\n                      : (lhs[1] < rhs[1] ? -1 : ((rhs[1] < lhs[1] ? 1 : 0))));\n  });\n  int j = 1;\n  long long f = x[0][1], ans = 0;\n  for (int i = 0; i < n; i++) {\n    while (j < n && x[j][0] - x[i][0] < d) {\n      f += x[j][1];\n      j++;\n    }\n    if (ans < f) ans = f;\n    f -= x[i][1];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class B {\n\tpublic static final boolean DEBUG = false;\n\tString filename = \"\";\n\tScanner sc;\n\tPrintWriter pw;\n\n\tpublic void dbg(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\t\n\tpublic void pln(Object o) {\n\t\tpw.println(o);\n\t}\n\t\n\tclass Friend implements Comparable<Friend>{\n\t\tint m, s;\n\t\tpublic Friend(int m, int s) {\n\t\t\tthis.m = m;\n\t\t\tthis.s = s;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Friend f) {\n\t\t\treturn m - f.m;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tpublic void run() throws FileNotFoundException {\n\t\tif (filename.isEmpty()) {\n\t\t\tsc = new Scanner(System.in);\n\t\t\tpw = new PrintWriter(System.out);\n\t\t}\n\t\telse {\n\t\t\tsc = new Scanner(new File(filename + \".in\"));\n//\t\t\tpw = new PrintWriter(new File(filename + \".out\"));\n\t\t\tpw = new PrintWriter(System.out);\n\t\t}\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\t\n\t\tFriend[] f = new Friend[n];\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tf[i] = new Friend(m, s);\n\t\t}\n\t\t\n\t\tArrays.sort(f);\n\t\t\n\t\tint j=0;\n\t\tlong total = 0;\n\t\tlong maxtotal = 0;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\twhile (j<n && f[i].m+d>f[j].m) {\n\t\t\t\ttotal += f[j].s;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (total > maxtotal) maxtotal = total;\n\t\t\ttotal -= f[i].s;\n\t\t}\n\t\tpln(maxtotal);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tB t = new B();\n\t\ttry {\n\t\t\tt.run();\n\t\t\tt.pw.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "n ,d = map(int,raw_input().split())\nm = []\nfor _ in xrange(n): \n    a,b = (map(int,raw_input().split()))\n    m.append((a,b))\nm.sort()\n#print m\ni = 0\nj = 1\nbest = 0\ndemo = m[0][1]\nnew  = 0\ng = 0\nwhile(i < n):\n    demo -= g\n    new  = m[i][0]\n    g = m[i][1]\n   # print \"j\", j, new, best\n    while(j < n and m[j][0] - new < d):\n        demo += m[j][1]\n        j += 1\n    #print demo, best\n    best = max(best, demo)\n    i += 1\nprint best\n        \n    \n\n    \n"
        },
        {
            "language": 3,
            "solution": "n,d=[int(i) for i in input().split()]\na=[]\nfor i in range(n):\n    a.append(list(map(int,input().split())))\n\n\na.sort()\n\nj=1\nv=a[0][1]\nmaxx=[]\nfor i in range(n):\n    if j==n:\n        break\n    while abs(a[i][0]-a[j][0])<d:\n\n        v+=a[j][1]\n        j+=1\n        if j>n-1:\n            break\n    maxx.append(v)\n    v-=a[i][1]\n\nmaxx=maxx+[i[1] for i in a]\nprint(max(maxx))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<long long int, long long int> ar[100005];\nlong long int arr[100005];\nlong long int brr[100005];\nlong long int cm[100005];\nint main() {\n  long long int i, n, t, a, b, pos, c, ans, k;\n  scanf(\"%lld%lld\", &n, &t);\n  for (i = 0; i < n; i++) {\n    scanf(\"%lld%lld\", &a, &b);\n    ar[i] = make_pair(a, b);\n  }\n  sort(ar, ar + n);\n  for (i = 0; i < n; i++) {\n    arr[i] = ar[i].first;\n    brr[i] = ar[i].second;\n  }\n  cm[0] = brr[0];\n  for (i = 1; i < n; i++) {\n    cm[i] = cm[i - 1] + brr[i];\n  }\n  arr[n] = -4;\n  c = 0;\n  ans = 0;\n  long long int ll;\n  for (i = 0; i < n; i++) {\n    ll = t + arr[i] - 1;\n    pos = upper_bound(arr, arr + n, ll) - arr;\n    pos = pos - 1;\n    k = i;\n    if (k == 0) {\n      c = cm[pos];\n    } else {\n      c = cm[pos] - cm[k - 1];\n    }\n    if (c > ans) {\n      ans = c;\n    }\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long int n, t, i, sum = 0, l, r, m = 0;\n  cin >> n >> t;\n  pair<long long int, long long int> a[n];\n  l = 0;\n  r = 0;\n  for (i = 0; i < n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a, a + n);\n  while (l < n) {\n    if (a[l].first - a[r].first < t) {\n      sum += a[l].second;\n      l++;\n      m = max(m, sum);\n    } else\n      sum -= a[r++].second;\n  }\n  cout << m << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class MyClass {\n    public static void main(String args[]) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        long d=sc.nextLong();\n        long [][] a=new long[n][2];\n        for (int i=0;i<n;i++){\n            a[i][0]=sc.nextLong();\n            a[i][1]=sc.nextLong();\n           // System.out.println(a[i][0]+\" \"+a[i][1]);\n        }\n        Arrays.sort(a,(z, b) -> Long.compare(z[0], b[0]));\n        //for (int i=0;i<n;i++){\n       //     System.out.println(a[i][0]+\" \"+a[i][1]);\n      //  }\n        //System.out.println(Arrays.toString(a));\n        long p=0;\n        long m=a[0][1];\n        long x=a[0][1];\n        int i=0;\n        int j=1;\n        while (j<n){\n            p=a[j][0]-a[i][0];\n            if (p>=d){\n                //p-=a[i][0];\n                x-=a[i][1];\n                i++;\n                //p=a[j][0]-a[i][0];\n            }\n            else{\n                //p=a[j][0]-a[i][0];\n                x+=a[j][1];\n                if (p<d){\n                    m=Math.max(m,x);\n                    //System.out.println(i+\" \"+j+\" \"+x);\n                }\n                j++;\n            }\n            //System.out.println(i+\" \"+(j-1)+\" \"+x);\n        }\n        System.out.println(m);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\n/**\n * Created on 22/09/2015.\n */\npublic class B {\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\n\t\tint n = s.nextInt();\n\t\tint d = s.nextInt();\n\n\t\tArrayList<Friend> friends = new ArrayList<Friend>();\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tFriend friend = new Friend();\n\t\t\tfriend.money = s.nextInt();\n\t\t\tfriend.friendshipFactor = s.nextInt();\n\t\t\tfriends.add(friend);\n\t\t}\n\n\t\tCollections.sort(friends);\n\n\t\tlong maxFriendshipTotal = -1;\n        long friendshipTotal = 0;\n\t\tfor (int start = 0, end = 0; start < n; start++) {\n            while (end < n && friends.get(end).money - friends.get(start).money < d) {\n                friendshipTotal += friends.get(end).friendshipFactor;\n                end++;\n            }\n\n            maxFriendshipTotal = Math.max(friendshipTotal, maxFriendshipTotal);\n            friendshipTotal -= friends.get(start).friendshipFactor;\n\t\t}\n\n\t\tSystem.out.println(maxFriendshipTotal);\n\t}\n\n\tprivate static class Friend implements Comparable<Friend> {\n\t\tprivate int money;\n\t\tprivate int friendshipFactor;\n\n\t\t@Override\n\t\tpublic int compareTo(Friend f) {\n\t\t\tif (money < f.money) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (money == f.money) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, d;\nlong long ans;\npair<int, int> a[100001];\nlong long prefix[100001];\nint main() {\n  cin >> n >> d;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a + 1, a + n + 1);\n  for (int i = 1; i <= n; i++) {\n    prefix[i] = prefix[i - 1] + a[i].second;\n  }\n  for (int i = 1; i <= n; i++) {\n    int mini = i, maxi = n, mid = (mini + maxi + 1) / 2;\n    while (mini != maxi) {\n      if (a[i].first + d > a[mid].first) {\n        mini = mid;\n      } else {\n        maxi = --mid;\n      }\n      mid = (mini + maxi + 1) / 2;\n    }\n    ans = max(ans, prefix[mid] - prefix[i - 1]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\na=[]\nfor _ in range(n):\n    x,y=map(int,input().split())\n    a.append([x,y])\na.sort()\nans=a[0][1]\nres=a[0][1]\np1=0\np2=0\nwhile(p2<n-1):\n    if(a[p2+1][0]-a[p1][0]<d):\n        p2+=1\n        ans+=a[p2][1]\n        if(ans>res):\n            res=ans\n    else:\n        ans=ans-a[p1][1]\n        p1+=1\nprint(res)"
        },
        {
            "language": 1,
            "solution": "# input\nn, d = map(int, raw_input().split())\nfriends = []\nfor i in range(n): friends.append(map(int, raw_input().split()))\nfriends = sorted(friends, key=lambda x: x[0])\n\n# solution\ncurrent_group_sum = friends[0][1]\ncurrent_group_first = 0\nresult = current_group_sum\n\ni = 1\nwhile i < len(friends):\n    while abs(friends[i][0] - friends[current_group_first][0]) >= d:\n        current_group_sum -= friends[current_group_first][1]\n        current_group_first = current_group_first + 1\n\n    current_group_sum = current_group_sum + friends[i][1]\n    result = max(result, current_group_sum)\n    i += 1\n\nprint result\n"
        },
        {
            "language": 3,
            "solution": "\ndef sf(a):\n    return -a[0]\n\ninp = input().split()\n\nn = int(inp[0])\nd = int(inp[1])\narr = []\nfor i in range(0, n):\n    dat = [int(x) for x in input().split()]\n    arr.append(dat)\narr.sort(key = sf)\n\nl = r = 0\nsumm = arr[0][1] \nans = arr[0][1]\n\nwhile(r < n - 1):\n    if(arr[l][0] - arr[r + 1][0] < d):\n        summ += arr[r + 1][1]\n        r += 1\n    else:\n        summ -= arr[l][1]\n        l += 1\n    ans = max(ans, summ)\n\nprint(ans)\n"
        },
        {
            "language": 1,
            "solution": "def solution(f,n,d):\n    if n == 1:\n        return f[0][1]\n    max_friendship = f[0][1]\n    max_friendship_tmp = f[0][1]\n    i = 0\n    j = 1\n    while j < n:\n        if abs(f[j][0] - f[i][0]) < d:\n            max_friendship_tmp += f[j][1]\n        else:\n            max_friendship_tmp += f[j][1]\n            while abs(f[j][0] - f[i][0]) >= d:\n                max_friendship_tmp -= f[i][1]\n                i+=1\n        j+=1\n        if max_friendship_tmp > max_friendship:\n            max_friendship = max_friendship_tmp\n    return max_friendship\n\n\nn,d = map(int,raw_input().split())\nfriends = []\nfor _ in range(n):\n    m,r = map(int,raw_input().split())\n    friends.append([m,r])\nfriends.sort()\nprint(solution(friends,n,d))\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int, input().split())\nms=[]\nfor o in range(n):\n  m,s = map(int, input().split())\n  ms.append((m,s))\nms.sort()\nk=0\nmaximum=0\ns=0\nfor i in range(n):\n    s += ms[i][1]\n    while ms[i][0] - ms[k][0] >= d:\n        s -= ms[k][1]\n        k += 1\n    maximum = max(maximum, s)\nprint(maximum)\n \t \t \t\t\t\t   \t\t\t\t\t\t   \t \t \t\t"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class question2 {\n\t\n\tpublic long solution(long[] kefa, friend[] friends) {\n\t\tArrays.sort(friends, new Comparator<friend>() {\n\t\t\t@Override\n\t\t\tpublic int compare(friend f1, friend f2) {\n\t\t\t\treturn (int) (f1.money - f2.money);\n\t\t\t}\n\t\t});\n\t\t\n\t\tlong res = 0;\n\t\tint left = 0;\n\t\tlong cur = 0;\n\t\tfor (int i = 0; i < friends.length; i++) {\n\t\t\twhile (friends[i].money - friends[left].money >= kefa[1]) {\n\t\t\t\tcur -= friends[left++].factor;\n\t\t\t}\n\t\t\tcur += friends[i].factor;\n\t\t\tres = Math.max(res, cur);\n\t\t\t\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdin = new Scanner(System.in);\n\t\tString[] str = stdin.nextLine().split(\"\\\\s+\");\n\t\tlong[] kefa = new long[2];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tkefa[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\tfriend[] friends = new friend[(int)kefa[0]];\n\t\tint i = 0;\n\t\twhile (i < friends.length) {\n\t\t\tString[] temp = stdin.nextLine().split(\"\\\\s+\");\n\t\t\tfriend f = new friend(Long.parseLong(temp[0]), Long.parseLong(temp[1]));\n\t\t\tfriends[i] = f;\n\t\t\ti++;\n\t\t}\n\t\tquestion2 Q = new question2();\n\t\tSystem.out.println(Q.solution(kefa, friends));\n\t\t\n\t}\n\t\n\t\n}\n\nclass friend{\n\tlong money;\n\tlong factor;\n\tpublic friend (long money, long factor) {\n\t\tthis.money = money;\n\t\tthis.factor = factor;\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, d;\nvector<pair<int, int> > v;\nint BS(int x) {\n  int l = x + 1, r = n - 1, mid, res = -1;\n  while (r >= l) {\n    mid = (l + r) / 2;\n    if (v[mid].first - v[x].first < d) {\n      res = mid;\n      l = mid + 1;\n    } else\n      r = mid - 1;\n  }\n  return res;\n}\nint main() {\n  scanf(\"%d%d\", &n, &d);\n  v.resize(n);\n  vector<long long> sum;\n  sum.resize(n + 1);\n  sum[0] = 0;\n  for (int i = 0; i < n; i++) {\n    int m, f;\n    scanf(\"%d%d\", &m, &f);\n    v[i] = make_pair(m, f);\n  }\n  sort(v.begin(), v.end());\n  for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + v[i - 1].second;\n  long long mx = 0;\n  for (int i = 0; i < n; i++) {\n    long long res;\n    int x = BS(i);\n    if (x != -1)\n      res = sum[x + 1] - sum[i];\n    else\n      res = sum[i + 1] - sum[i];\n    mx = max(res, mx);\n  }\n  printf(\"%I64d\\n\", mx);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\npair<int, int> a[N];\nint main() {\n  int n, d;\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a, a + n);\n  long long L, R, maj, ans;\n  ;\n  L = R = ans = maj = 0;\n  while (R < n) {\n    if (a[R].first - a[L].first < d) {\n      maj += a[R].second;\n      ans = max(maj, ans);\n      R++;\n    } else {\n      maj -= a[L].second;\n      L++;\n      ans = max(ans, maj);\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\na=[]\nfor i in range(n):\n    a.append((list(map(int,input().split()))))\na.sort()\nx=0\ny=0\nm=0\nf=0\nwhile y<n:\n    if abs(a[y][0]-a[x][0])<d:\n        m+=a[y][1]\n        y+=1\n        f=max(m,f)\n    else:\n        m-=a[x][1]\n        x+=1\nprint(f)"
        },
        {
            "language": 1,
            "solution": "from bisect import bisect_left\nn, d = map(int, raw_input().split())\na = sorted(map(int, raw_input().split()) for _ in range(n))\nb, c = zip(*a)\nc = [0] + list(c)\nfor i in range(1, n+1):\n   c[i] += c[i-1]\nans = 0   \nfor i in range(n):\n    j = bisect_left(b, b[i]+d)\n    ans = max(ans, c[j] - c[i]) \nprint ans"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntypedef std::pair<int, int> PII;\nint main() {\n  int n;\n  int d;\n  long long ans = 0;\n  long long sum = 0;\n  std::vector<PII> v;\n  std::cin >> n >> d;\n  v.resize(n);\n  for (int i = 0; i < n; ++i) std::cin >> v[i].first >> v[i].second;\n  std::sort(v.begin(), v.end());\n  int j = 0;\n  for (int i = 0; i < n; ++i) {\n    while (j < n && v[j].first - v[i].first < d) {\n      sum += v[j].second;\n      ++j;\n    }\n    ans = std::max(ans, sum);\n    sum -= v[i].second;\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "linha1 = raw_input().split()\nn = int(linha1[0])\nd = int(linha1[1])\n\nent = []\n\nfor i in range(n):\n  entrada = raw_input().split()\n  lista = []\n  lista.append(int(entrada[0]))\n  lista.append(int(entrada[1]))\n  ent.append(lista)\n  \nent.sort()\n\ncur = 0\nj = 0\nmaximo = 0\n\nfor i in range(len(ent)):\n  cur += ent[i][1]\n  while ( j< i and (abs(ent[i][0] - ent[j][0]) >= d)):\n    cur -= ent[j][1]\n    j+=1\n  maximo = max(maximo, cur)\n  \nprint maximo"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class B_kefaAndCompany {\n\n\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * Every time you move on, subtract the previous instead of adding them all together\n\t\t * check their solution\n\t\t */\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\tint numFriends = scan.nextInt();\n\t\tlong minMoneyDiff = scan.nextInt();\n\t\t\n\t\tFriend[] friends = new Friend[numFriends];\n\t\tfor (int i = 0; i < numFriends; i++) {\n\t\t\tfriends[i] = new Friend(scan.nextLong(), scan.nextLong());\n\t\t}\n\t\tArrays.sort(friends);\n\t\t\n\t\tlong totalFriendship = 0;\n\t\t/*long tempFriendship = 0;\n\t\tfor (int i = 0; i < numFriends; i++) {\n\t\t\tfor (int j = i; j < numFriends; j++) {\n\t\t\t\tSystem.out.println(i + \" \" + j + \" \" + friends[i].money + \" \" + friends[j].money + \" \" + tempFriendship);\n\t\t\t\tif (friends[i].money + minMoneyDiff > friends[j].money) {\n\t\t\t\t\ttempFriendship += friends[j].friendship;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"temp: \" + tempFriendship);\n\t\t\ttotalFriendship = Math.max(totalFriendship, tempFriendship);\n\t\t\ttempFriendship -= friends[i].friendship;\n\t\t}\n\t\tSystem.out.println(totalFriendship);\n\t\tSystem.out.println();*/\n\t\t\n\t\ttotalFriendship = 0;\n\t\tlong currentFriendship = 0;\n\t\tint currentIndex = 0;\n\t\tfor (int i = 0; i < friends.length; i++) {\n\t\t\t//System.out.println(currentIndex);\n\t\t\twhile (currentIndex < friends.length && friends[i].money + minMoneyDiff > friends[currentIndex].money) {\n\t\t\t\t//System.out.println(i + \" \" + currentIndex + \" \" + friends[i].money + \" \" + friends[currentIndex].money + \" \" + tempFriendship);\n\t\t\t\tcurrentFriendship += friends[currentIndex].friendship;\n\t\t\t\tcurrentIndex++;\n\t\t\t}\n\t\t\t//System.out.println(\"temp: \" + currentFriendship);\n\t\t\ttotalFriendship = Math.max(totalFriendship, currentFriendship);\n\t\t\tcurrentFriendship -= friends[i].friendship;\n\t\t}\n\t\t\n\t\tSystem.out.println(totalFriendship);\n\t}\n}\n\nclass Friend implements Comparable<Friend> {\n\tlong money;\n\tlong friendship;\n\t\n\tpublic Friend(long money, long friendship) {\n\t\tthis.money = money;\n\t\tthis.friendship = friendship;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Friend f) {\n\t\treturn Long.compare(this.money, f.money);\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "\n\n'''\n---------------vishva-mitra----------------\n\n'''\nimport bisect\n\n\nN,D = map(int, raw_input().strip().split(' '))\nA = []\nfor _ in xrange(N) :\n    A += map(int, raw_input().strip().split(' ')),\nA.sort(key = lambda x : x[0])\nM = [x[0] for x in A]\nS = [x[1] for x in A]\ndel A\nfor i in xrange(1,N) :\n    S[i] += S[i-1]\n\nres = 0\nfor i in xrange(N) :\n    j = bisect.bisect(M,M[i]+D-1)\n    tmp = S[j-1]\n    if i > 0 :\n        tmp = tmp - S[i-1]\n    res = max(res, tmp)\n\nprint res"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\n\nfactor_map = {}\nmoney_list = []\n\nfor i in xrange(n):\n    money, factor = map(int, raw_input().split())\n    if money not in factor_map:\n        money_list.append(money)\n        factor_map[money] = factor\n    else:\n        factor_map[money] += factor\n\nmoney_list.sort()\n\nans = atual = 0\nj = 0\n\nfor i in xrange(len(money_list)):\n    while j < len(money_list) and money_list[j] - money_list[i] < d:\n        atual += factor_map[money_list[j]]\n        j += 1\n    ans = max(ans, atual)\n    atual -= factor_map[money_list[i]]\n\nprint ans\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Codechef\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner sc=new Scanner(System.in);\n        PrintWriter pw=new PrintWriter(System.out);\n\t\tint n=sc.nextInt();\n\t\tlong d=sc.nextLong();\n\t\tTreeMap<Long,Long> hs=new TreeMap<>();\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t   long a=sc.nextLong();\n\t\t   long b=sc.nextLong();\n\t\t   if(!hs.containsKey(a))\n\t\t   hs.put(a,b);\n\t\t   else hs.replace(a,hs.get(a)+b);\n\t\t}\n        List<Long> a=new ArrayList<>(hs.keySet());\n        List<Long> b=new ArrayList<>(hs.values());\n         long max=0,sum=0;int j=0;\n        for(int i=0;i<a.size();i++)\n        {\n            if(a.get(i)-a.get(j)<d)\n            {\n                sum+=b.get(i);\n            }\n            else \n            {  sum-=b.get(j);\n               i--;\n               j++;\n            }\n            max=Math.max(max,sum);\n        }\n        pw.println(max);\n        pw.close();\n}\n}"
        },
        {
            "language": 3,
            "solution": "class Guest(object):\n    def __init__(self, money, friendship_factor):\n        self.money = money\n        self.friendship_factor = friendship_factor\n\n    def __repr__(self):\n        return \"Guest\"\n\n    def __str__(self):\n        return \" \".join([\"Guest:\", str(self.money), str(self.friendship_factor)])\n\n\nclass Company(object):\n    def __init__(self, number_of_guests, poorness_threshold):\n        self.number_of_guests = number_of_guests\n        self.poorness_threshold = poorness_threshold\n        self.list_of_guests = list()\n        self.maximum_sum_of_friendship = 0\n\n    def add_guest(self, money, friendship_factor):\n        self.list_of_guests.append(Guest(money, friendship_factor))\n\n    def sort_guest_list(self):\n        self.list_of_guests.sort(key=lambda guest: guest.money)\n\n    def compute_maximal_friendship(self):\n        temporary_friendship = 0\n        trailing_guest_index = 0\n\n        for guest_index in range(self.number_of_guests):\n            temporary_friendship += self.list_of_guests[guest_index].friendship_factor\n            while self.list_of_guests[guest_index].money - self.list_of_guests[trailing_guest_index].money \\\n                    >= self.poorness_threshold:\n                temporary_friendship -= self.list_of_guests[trailing_guest_index].friendship_factor\n                trailing_guest_index += 1\n            if self.maximum_sum_of_friendship < temporary_friendship:\n                self.maximum_sum_of_friendship = temporary_friendship\n\n    # def compute_friendship_starting_from_specified_guest(self, guest_number):\n    #     temporary_friendship = self.list_of_guests[guest_number].friendship_factor\n    #     for index in range(guest_number + 1, len(self.list_of_guests)):\n    #         if abs(self.list_of_guests[index].money -\n    #                        self.list_of_guests[guest_number].money) \\\n    #                 >= self.poorness_threshold:\n    #             break\n    #         else:\n    #             temporary_friendship += self.list_of_guests[index].friendship_factor\n    #     if temporary_friendship > self.maximum_sum_of_friendship:\n    #         self.maximum_sum_of_friendship = temporary_friendship\n\n\nif __name__ == '__main__':\n\n    input_number_of_guests, input_poorness_threshold = map(int, input().split(\" \"))\n\n    company = Company(input_number_of_guests, input_poorness_threshold)\n\n    for counter in range(input_number_of_guests):\n        input_money, input_friendship_factor = map(int, input().split(\" \"))\n        company.add_guest(input_money, input_friendship_factor)\n\n    company.sort_guest_list()\n\n    company.compute_maximal_friendship()\n\n    # for counter in range(len(company.list_of_guests)):\n    #     # if counter > 0:\n    #     #     if company.list_of_guests[counter-1].money == guest.money:\n    #     #         continue\n    #     company.compute_friendship_starting_from_specified_guest(counter)\n\n    print(company.maximum_sum_of_friendship)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\npublic class B580{\n    public static void main(String[]args){\n        Scanner ss=new Scanner(System.in);\n        int n=ss.nextInt(),temp=n,j=0;\n        long d=ss.nextLong(),sum=0,m,s;\n        ArrayList<Pair> li=new ArrayList<Pair>();\n        while(n-->0){\n            m=ss.nextLong();\n            s=ss.nextLong();\n            li.add(new Pair(m,s));\n        }\n\n        Collections.sort(li);\n        long max=-1;\n        int count=0;\n        for(int i=0;i<li.size();i++){\n            while(j<li.size()&&li.get(j).getM()-li.get(i).getM()<d){\n                sum+=li.get(j).getS();\n                j++;\n                max=Math.max(max, sum);\n            }\n            sum-=li.get(i).getS();\n        }\n        System.out.println(max);\n\n    }\n}\n\n\nclass Pair implements Comparable<Pair>{\n    long m;\n    long s;\n    public Pair(long m,long s){\n        this.m=m;\n        this.s=s;\n    }\n    public long getM() {\n        return m;\n    }\n    public long getS() {\n        return s;\n    }\n    public String toString(){\n        return m+\" \"+s;\n    }\n\n    public int compareTo(Pair a){\n        return (this.getM()-a.getM()>0)?1:(this.getM()-a.getM()==0)?0:-1;\n    }\n\n\n\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<int, int> arr[100500];\nint main() {\n  int n, d;\n  cin >> n >> d;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    arr[i] = make_pair(x, y);\n  }\n  sort(arr, arr + n);\n  long long j = 0, i = 0;\n  long long ans = 0, maxi = 0;\n  for (int i = 0; i < n; i++) {\n    ans += arr[i].second;\n    while (arr[i].first - arr[j].first >= d) {\n      ans -= arr[j].second;\n      j++;\n    }\n    maxi = max(ans, maxi);\n  }\n  maxi = max(ans, maxi);\n  cout << maxi;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, d;\n  pair<int, int> friendlist[100001];\n  scanf(\"%d%d\", &n, &d);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d%d\", &((friendlist + i)->first), &((friendlist + i)->second));\n  sort(friendlist, friendlist + n);\n  int it_left = 0;\n  int it_right = 0;\n  long long maxfriendship = 0;\n  long long friendship = 0;\n  while (true) {\n    while (it_right < n &&\n           friendlist[it_right].first - friendlist[it_left].first < d) {\n      friendship += friendlist[it_right].second;\n      maxfriendship = max(maxfriendship, friendship);\n      it_right++;\n    }\n    if (it_right >= n) break;\n    while (friendlist[it_right].first - friendlist[it_left].first >= d) {\n      friendship -= friendlist[it_left].second;\n      it_left++;\n    }\n  }\n  cout << maxfriendship;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > fx;\nint main() {\n  long long i, j, k, l, maxx = 0, n, b, sum = 0, d;\n  cin >> n >> d;\n  for (i = 0; i < n; i++) {\n    cin >> j >> k;\n    fx.push_back(pair<long long, long long>(j, k));\n  }\n  sort(fx.begin(), fx.end());\n  for (i = 0, j = 0; i < n; i++) {\n    while ((abs(fx[i].first - fx[j].first) < d) && (j < n)) {\n      sum += fx[j].second;\n      j++;\n    }\n    maxx = max(maxx, sum);\n    sum -= fx[i].second;\n  }\n  cout << maxx;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst long long int INF = 1e12;\nconst int N = 1e5 + 1;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n, d;\n  cin >> n >> d;\n  pair<int, int> arr[n];\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i].first >> arr[i].second;\n  }\n  sort(arr, arr + n);\n  int i = 0, j = 0;\n  long long int ans = 0, sum = 0;\n  while (i < n) {\n    while (j < n && arr[j].first - arr[i].first < d) sum += arr[j].second, j++;\n    ans = max(ans, sum);\n    sum -= arr[i++].second;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long inf = 1e9 + 7;\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  {\n    long long n, d, fm = 0;\n    cin >> n >> d;\n    pair<long long, long long> a[n];\n    long long f[n];\n    for (long long i = 0; i < n; i++) {\n      cin >> a[i].first >> a[i].second;\n    }\n    sort(a, a + n);\n    f[0] = a[0].second;\n    for (long long i = 1; i < n; i++) {\n      f[i] = f[i - 1] + a[i].second;\n    }\n    long long i = 0, j = 0;\n    while (j < n) {\n      while (a[j].first - a[i].first >= d) {\n        i++;\n      }\n      if (a[j].first - a[i].first < d) {\n        if (i != 0) {\n          fm = max(fm, f[j] - f[i - 1]);\n        } else {\n          fm = max(fm, f[j]);\n        }\n        j++;\n      }\n    }\n    cout << fm << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def main(n, d):\n    p = []\n    for i in range(n):\n        a, b = map(int, input().split())\n        p.append([a, b])\n    p.sort()\n    maxi = 0\n    sum = 0\n    e = []\n    g = 0\n    em = 0\n    while len(p) != 0:\n        while g != n and p[g][0] < p[em][0] + d:\n            sum += p[g][1]\n            g += 1\n        if g == n:\n            maxi = max(maxi, sum)\n            print(max(maxi, sum))\n            break\n        else:\n            maxi = max(maxi, sum)\n            while em != g and p[em][0] + d <= p[g][0]:\n                sum -= p[em][1]\n                em += 1\nn, d = map(int, input().split())\nmain(n, d)\n    \n    \n"
        },
        {
            "language": 1,
            "solution": "# input\nn, d = map(int, raw_input().split())\nfriends = []\nfor i in range(n): friends.append(map(int, raw_input().split()))\nfriends = sorted(friends, key=lambda x: x[0])\n\n# solution\ncurrent_group_sum = friends[0][1]\ncurrent_group_min = friends[0][0]\ncurrent_group_first = 0\nresult = current_group_sum\n\ni = 1\nwhile i < len(friends):\n    while abs(friends[i][0] - friends[current_group_first][0]) >= d:\n        current_group_sum -= friends[current_group_first][1]\n        current_group_first = current_group_first + 1\n\n    current_group_sum = current_group_sum + friends[i][1]\n    result = max(result, current_group_sum)\n    i += 1\n\nprint result\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\n\ns=[0]*n\nfor _ in range(n):\n    m,f=map(int,input().split())\n    s[_]=(m,f)\n\ns.sort()\n\ni=0;j=0\n\nans=0\n\nfr=0\nwhile j<n:\n    if s[j][0]-s[i][0]<d :\n        fr+=s[j][1]\n        j+=1\n    else:\n        ans=max(ans,fr)\n        while s[j][0]-s[i][0]>=d:\n            fr-=s[i][1]\n            i+=1\nans=max(ans,fr)\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "def solve(inp, d):\n    inp = sorted(inp, key=lambda x: x[0])\n    p1 = 0\n    p2 = 0\n    n = len(inp)\n    maxfnd = 0\n    max1 = maxfnd\n    while p2 < n:\n        if inp[p2][0] - inp[p1][0] < d:\n            maxfnd += inp[p2][1]\n            p2 += 1\n\n        else:\n            maxfnd -= inp[p1][1]\n            p1 += 1\n        max1 = max(max1, maxfnd)\n    return max1\n\n\nn, s = map(int, input().split())\nin1 = []\nfor i in range(n):\n    in1.append(list(map(int, input().split())))\nprint(solve(in1, s))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5;\nconst long long mod = 1e9 + 7;\nconst long long INF = 0x7f7f7f7f7f7f7f7f;\nconst int INFi = 0x7f7f7f7f;\nlong long n, d, mx = 0;\nvector<pair<long long, long long> > a;\nvoid solve() {\n  cin >> n >> d;\n  for (int i = 1; i <= n; i++) {\n    int x, y;\n    cin >> x >> y;\n    a.push_back({x, y});\n  }\n  sort(a.begin(), a.end());\n  long long res = 0;\n  for (int i = 0, j = 0; i < n; i++) {\n    res += a[i].second;\n    while (a[i].first - a[j].first >= d) {\n      res -= a[j].second;\n      j++;\n    }\n    mx = max(mx, res);\n  }\n  cout << mx << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout << fixed;\n  cout << setprecision(15);\n  ;\n  int test = 1;\n  for (int i = 1; i <= test; i++) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "#import sys\n#sys.stdin = open(\"python/in\", \"r\")\n#from collections import defaultdict\n#import numpy as np\n#import array as rr\n#arr = rr.array('q')\n#n = int(input())\nfriend = []\nn, d = [int (i) for i in input().split(\" \")]\nfor i in range (n):\n    friend.append([int (i) for i in input().split(\" \")])\nfriend = sorted(friend, key = lambda fr: fr[0])\nans = 0\ncur = 0\nrich = iter(friend)\ni = next(rich)\nfor poor in friend:\n    try:\n        while i[0] < poor[0] + d:\n            cur += i[1]\n            i = next(rich)\n        ans = max(ans, cur)\n        #print(\"debug like a noob\")\n        cur -= poor[1]\n    except StopIteration:\n        #print(\"breaking\")\n        break\n\nans = max(ans, cur)\nprint (ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int N = 1e6 + 7;\nbool comp(const pair<long long, long long> &i,\n          const pair<long long, long long> &j) {\n  return i.second > j.second;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n;\n  long long d, num, c = 0, x, y, res = 0;\n  cin >> n >> d;\n  std::vector<pair<long long, long long> > a;\n  a.push_back(make_pair(0, 0));\n  for (int i = (0); i < n; i++) {\n    cin >> x >> y;\n    a.push_back(make_pair(x, y));\n  }\n  long long temp2, t = 0;\n  sort(a.begin(), a.end());\n  vector<long long> v(n + 2, 0), v1(n + 1, 0);\n  for (int i = (1); i < n + 1; i++) {\n    v[i] += (v[i - 1] + a[i].second);\n    v1[i] = a[i].first;\n  }\n  for (int i = (1); i < n + 1; i++) {\n    num = v1[i] + d;\n    int temp = lower_bound(v1.begin() + i, v1.end(), num) - v1.begin();\n    if (temp == n + 1) temp--;\n    if (v1[temp] >= num) temp--;\n    temp2 = v[temp] - v[i - 1];\n    t = max(temp2, t);\n  }\n  cout << t;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint n;\nlong long d, dp[N];\npair<long long, long long> arr[N];\nbool cmp(pair<long long, long long> a, pair<long long, long long> b) {\n  return a.first < b.first;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> d;\n  for (int i = 1; i <= n; i++) {\n    long long a, b;\n    cin >> a >> b;\n    arr[i] = {a, b};\n  }\n  sort(arr + 1, arr + 1 + n, cmp);\n  dp[1] = arr[1].second;\n  for (int i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] + arr[i].second;\n  }\n  long long answer = -1;\n  for (int i = 1; i <= n; i++) {\n    long long target = arr[i].first + d - 1;\n    int l = 1;\n    int r = n;\n    int ans = -1;\n    while (l <= r) {\n      int mid = l + (r - l) / 2;\n      if (arr[mid].first <= target) {\n        ans = mid;\n        l = mid + 1;\n      } else {\n        r = mid - 1;\n      }\n    }\n    answer = max(answer, dp[ans] - dp[i - 1]);\n  }\n  cout << answer << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef solve(m, d):\n    m.sort()\n    res = 0\n    curr = 0\n    i, j = 0, 0\n    while j < len(m):\n        if m[j][0] - m[i][0] >= d:\n            curr -= m[i][1]\n            i += 1\n        else:\n            curr += m[j][1]\n            res = max(res, curr)\n            j += 1\n    return res\n\n\nn, d = map(int, input().split())\nf = []\nfor i in range(n):\n    mi, fi = map(int, input().split())\n    f.append((mi, fi))\n\nprint(solve(f, d))"
        },
        {
            "language": 3,
            "solution": "n, d = map(int,input().split())\nv = sorted([list(map(int,input().split())) for i in range(n)], key = lambda x: x[0])\nsum = v[0][1]\nsol = v[0][1]\nb = 0\nfor i in range(1,n):\n    while v[i][0] >= d + v[b][0]:\n        sum -= v[b][1]\n        b += 1\n    sum += v[i][1]\n    sol = max(sum,sol)\nprint(sol)"
        },
        {
            "language": 3,
            "solution": "l = input()\nl = l.split()\n# print(l)\nn = int(l[0])\nd = int(l[1])\n\nlst = []\n\nfor i in range(n):\n    l = input()\n    l = l.split()\n    lst.append((int(l[0]), int(l[1])))\n# print(lst, n, d)\n\nlst.sort(key=lambda x: x[0])\n# print(lst)\n\nsum, maxim, start, fin = 0, 0, 0, 0\n\nwhile fin < n:\n    while fin < n and lst[fin][0] - lst[start][0] + 1 <= d:\n        sum += lst[fin][1]\n        fin += 1\n    maxim = max(maxim, sum)\n    sum -= lst[start][1]\n    start += 1\n#print(lst)\nprint(maxim)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class B {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint d = in.nextInt();\n\t\tPair[] a = new Pair[n];\n\t\tfor(int i = 0; i < n; i ++)\n\t\t\ta[i] = new Pair(in.nextInt(), in.nextInt());\n\t\tArrays.sort(a);\n\t\tint ptr1 = 0;\n\t\tlong max = 0;\n\t\tlong cur = 0;\n\t\tfor(int i = 0; i < n; i ++)\n\t\t{\n//\t\t\tSystem.out.println(ptr1 + \" \" + i + \" \" + a[i].c + \" \" + a[ptr1].c + \" \" + d);\n\t\t\twhile(a[ptr1].c - a[i].c >= d)\n\t\t\t{\n\t\t\t\tcur -= a[ptr1].v;\n\t\t\t\tptr1++;\n\t\t\t}\n\t\t\t\n\t\t\tcur+=a[i].v;\n\t\t\tmax = Math.max(cur, max);\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\tstatic class Pair implements Comparable<Pair>\n\t{\n\t\tint v;\n\t\tint c;\n\t\tPair(int cost, int value)\n\t\t{\n\t\t\tv = value;\n\t\t\tc =cost;\n\t\t}\n\t\tpublic int compareTo(Pair p) {\n\t\t\treturn p.c - c;\n\t\t}\n\t\t\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "import random, math\nfrom copy import deepcopy as dc\nfrom bisect import bisect_left, bisect_right\n\n\n# Function to call the actual solution\ndef solution(pairs, d):\n\tpairs.sort(key = lambda x: x[0])\n\ti = 0\n\n\t# Finding Prefix sum\n\tpre = []\n\tprek = []\n\tsk = 0\n\tfor i in range(len(pairs)):\n\t\tsk += pairs[i][1]\n\t\tpre.append(pairs[i][0])\n\t\tprek.append(sk)\n\t# print(pre, prek)\n\tmaxi = float('-inf')\n\tfor i in range(len(pairs)):\n\t\tmid = bisect_right(pre, pre[i] + d - 1, i+1, len(pairs))\n\t\tm = prek[mid-1]\n\t\tif i != 0:\n\t\t\tm -= prek[i-1]\n\t\tif m > maxi:\n\t\t\tmaxi = dc(m)\n\t\t# print(m, mid, maxi)\n\treturn maxi\n\n\n# Function to take input\ndef input_test():\n\tn, d = map(int, input().strip().split(\" \"))\n\tpairs = []\n\tfor i in range(n):\n\t\tli = list(map(int, input().strip().split(\" \")))\n\t\tpairs.append(li)\n\tout = solution(pairs, d)\n\tprint(out)\n\n\ninput_test()\n# test()"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\ndef check(num):\n\ti,j = 0,0\n\tcount = 0\n\twhile j<n:\n\t\twhile j<n and (a[j][0]-a[i][0])<d:\n\t\t\tcount += a[j][1]\n\t\t\tj += 1\n\t\tif count>=num:\n\t\t\treturn True\n\t\tcount -= a[i][1]\n\t\ti += 1\n\treturn False\n\n\nn,d = map(int,input().split())\na = []\nmaxx = 0\nfor i in range(n):\n\ta.append(list(map(int,input().split())))\n\tmaxx += a[-1][1]\na.sort()\nif n==1:\n\tprint (a[0][1])\n\texit()\nlow = 0\nhigh = maxx\nwhile low<high:\n\tmid = (low+high)//2\n\tif check(mid):\n\t\tlow = mid+1\n\telse:\n\t\thigh = mid-1\nif check(low):\n\tprint (low)\nelse:\n\tprint (low-1)"
        },
        {
            "language": 3,
            "solution": "import sys\ninput=sys.stdin.readline\nfrom bisect import bisect_right as bi\n\nn,d=list(map(int,input().split()))\na=[]\nfor i in range(n):\n    a.append(list(map(int,input().split())))\na.sort()\nb=[]\nc=[0]\ns=0\nfor i in range(n):\n    b.append(a[i][0])\n    s+=a[i][1]\n    c.append(s)\nc.append(s)\nf=[]\nfor i in range(n):\n    e=bi(b,b[i]+d-1)\n    g=c[e]-c[i]\n    f.append(g)\nprint(max(f))"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class KefaAndCompany {\n\tprivate static final InputReader in = new InputReader(System.in);\n\t\n\tpublic void solve() throws IOException {\n\t\t\tint n = in.readInt();\n\t\t\tint d = in.readInt();\n\t\t\tFriend[] friends = new Friend[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfriends[i] = new Friend(in.readInt(), in.readInt());\n\t\t\t}\n\t\t\tArrays.sort(friends);\n\t\t\tlong total;\n\t\t\t\n\t\t\tint left = 0, right = 0; // current window\n\t\t\tlong currentF = friends[0].s;\n\t\t\ttotal = currentF;\n\t\t\twhile (left < n) {\n\t\t\t\twhile (right < n - 1 && friends[right + 1].m - friends[left].m < d) {\n\t\t\t\t\tright++;\n\t\t\t\t\tcurrentF += friends[right].s;\n\t\t\t\t}\n\t\t\t\ttotal = Math.max(total,currentF);\n\t\t\t\tcurrentF -= friends[left].s;\n\t\t\t\tleft++;\n\t\t\t}\n\t\t\tSystem.out.println(total);\n\t}\n\t\n\tclass Friend implements Comparable<Friend>{\n\t\tint m, s;\n\t\t\n\t\tpublic Friend(int m, int s) {\n\t\t\tthis.m = m;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Friend f) {\n\t\t\treturn Integer.compare(this.m, f.m);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew KefaAndCompany().solve();\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate static class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic void readIntArray(int[] a) {\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i] = this.readInt();\n\t\t\t}\n\t\t}\n\n\t\tpublic int readInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic final class main\n{\n\tpublic static void main(String[] args) {\n\t\tScanner br=new Scanner(System.in);\n\t\tint n=br.nextInt();\n\t\tint d=br.nextInt();\n\t\tFriend[] a=new Friend[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i]=new Friend(br.nextInt(),br.nextInt());\n\t\tArrays.sort(a);\n\t\tint i=0,j=0;\n\t\tlong sum=0L,ans=-1L;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\t\n\t\t\t\tsum+=a[i].f;\n\t\t\tif(a[i].m-a[j].m>=d)\n\t\t\t{\n\t\t\t\twhile(a[i].m-a[j].m>=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tsum-=a[j].f;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\n\t\t\t}\n\t\t\t\tans=Math.max(sum,ans);\n\n\t\t}\n\t\n\t\tSystem.out.println(ans);\n\t}\n}\nclass Friend implements Comparable<Friend>\n{\n\tint f,m;\n\tpublic Friend(int m,int f)\n\t{\n\t\tthis.f=f;\n\t\tthis.m=m;\n\n\t}\n\tpublic int compareTo(Friend that)\n\t{\n\t\treturn this.m-that.m;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.*;\nimport java.math.*;\n\nimport org.omg.CORBA.Any;\n\npublic class template {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tReader scn=new Reader();\n\t\tint n=scn.nextInt();\n\t\tint d=scn.nextInt();\n\t\tArrayList<pair> p=new ArrayList<>();\n\t\t\n\t\tfor(int i=0; i<n; i+=1){\n\t\t\t p.add(new pair(scn.nextInt(), scn.nextInt()));\n\t\t}\n\t\tCollections.sort(p);\n//\t\tSystem.out.println(p);\n\t\tint j=0;\n\t\tlong ans=0, sum=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\t while(j<n && p.get(j).cost-p.get(i).cost<d){\n\t\t\t\tsum+=p.get(j).factor; \n\t\t\t\tj++;\n\t\t\t }\n\t\t\t \n\t\t\t ans=Math.max(ans, sum);\n\t\t\t sum-=p.get(i).factor;\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n\t\n\t\n\t\n\t\n//_________________________TEMPLATE_____________________________________________________________\n\n\tprivate static class pair implements Comparable<pair>{\n\t\tint cost;\n\t\tint factor;\n\t\t\n\t\tpair(int a, int b){\n\t\t\tcost=a;\n\t\t\tfactor=b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn this.cost-o.cost;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn cost+\"-\"+factor;\n\t\t}\n\t}\n\t\n\n\n\n\n\tprivate static class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[100000 + 1]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nint main() {\n  int n, d;\n  cin >> n >> d;\n  pair<int, int> a[n];\n  long long int b[n + 1], max1 = 0, c[n];\n  b[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i].first >> a[i].second;\n  }\n  sort(a, a + n);\n  for (int i = 0; i < n; ++i) {\n    b[i + 1] = b[i] + a[i].second;\n    c[i] = a[i].first;\n  }\n  for (int i = 0; i < n; ++i) {\n    int index = lower_bound(c, c + n, c[i] + d) - c;\n    max1 = max(max1, b[index] - b[i]);\n  }\n  cout << max1;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from __future__ import division, print_function\n\ndef main():\n    n, d = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    a.sort()\n\n    for i in range(1, n):\n        a[i][1] += a[i - 1][1]\n\n    l, mx = 0, -1\n    for i in range(n):\n        while l < n and a[l][0] < a[i][0] + d:\n            l += 1\n            \n        curr = a[l - 1][1]\n        if i:\n            curr -= a[i - 1][1]\n        mx = max(mx, curr)\n\n    print(mx)\n\n\n# PyPy 2 Fast IO Template\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Importing Modules\nimport math\nimport collections\n\nfrom collections import Counter\nfrom math import fabs\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 3,
            "solution": "n, d = list(map(int, input().split()))\nres = []\nfor i in range(n):\n    res.append(list(map(int, input().split())))\nres.sort()\nres.reverse()\nres.append([0, 0])\nleft = 0\nright = 0\nsumm = 0\nrsumm = 0\nwhile True:\n    while res[left][0] - d < res[right][0]:\n        summ += res[right][1]\n        right += 1\n        if right == n + 1:\n            break        \n    if right == n + 1:\n            break\n    rsumm = max(summ, rsumm)\n    summ -= res[left][1]\n    left += 1\nrsumm = max(summ, rsumm)\nprint(rsumm)"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedOutputStream;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Kattio in = new Kattio(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Task {\n        public void solve(int testNumber, Kattio in, PrintWriter out) {\n            int n = in.nextInt();\n            int d = in.nextInt();\n\n            Pair[] arr = new Pair[n];\n            for (int i = 0; i < n; ++i)\n                arr[i] = new Pair(in.nextInt(), in.nextInt());\n\n            Arrays.sort(arr);\n            int l = 0;\n            long sum = 0;\n            long ans = 0;\n            for (int r = 0; r < n; ++r) {\n                sum += arr[r].s;\n                while (arr[r].f - arr[l].f >= d) {\n                    sum -= arr[l++].s;\n                }\n                ans = Math.max(ans, sum);\n            }\n\n            out.println(ans);\n        }\n\n        private class Pair implements Comparable<Pair> {\n            int f;\n            int s;\n\n            public Pair(int f, int s) {\n                this.f = f;\n                this.s = s;\n            }\n\n\n            public int compareTo(Pair o) {\n                return this.f - o.f;\n            }\n\n\n            public String toString() {\n                return this.f + \", \" + this.s;\n            }\n\n        }\n\n    }\n\n    static class Kattio extends PrintWriter {\n        private BufferedReader r;\n        private String line;\n        private StringTokenizer st;\n        private String token;\n\n        public Kattio(InputStream i) {\n            super(new BufferedOutputStream(System.out));\n            r = new BufferedReader(new InputStreamReader(i));\n        }\n\n        public Kattio(InputStream i, OutputStream o) {\n            super(new BufferedOutputStream(o));\n            r = new BufferedReader(new InputStreamReader(i));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        private String peekToken() {\n            if (token == null)\n                try {\n                    while (st == null || !st.hasMoreTokens()) {\n                        line = r.readLine();\n                        if (line == null) return null;\n                        st = new StringTokenizer(line);\n                    }\n                    token = st.nextToken();\n                } catch (IOException e) {\n                }\n            return token;\n        }\n\n        private String nextToken() {\n            String ans = peekToken();\n            token = null;\n            return ans;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\n\nm = {}\nmoney = []\n\nfor i in xrange(n):\n    ans, atual = map(int, raw_input().split())\n    if ans not in m:\n        money.append(ans)\n        m[ans] = atual\n    else:\n        m[ans] += atual\n\nmoney.sort()\n\nans = atual = 0\nj = 0\n\nfor i in xrange(len(money)):\n    while j < len(money) and money[j] - money[i] < d:\n        atual += m[money[j]]\n        j += 1\n    if atual > ans:\n        ans = atual\n    atual -= m[money[i]]\n\nprint ans\n"
        },
        {
            "language": 3,
            "solution": "n, diff = map(int, input().split())\na = sorted([tuple(map(int, input().split())) for _ in range(n)])\n\nleft = right = 0\nret = 0\ns = 0\nwhile right < n:\n    while right < n and a[right][0] - a[left][0] < diff:\n        s += a[right][1]\n        right += 1\n    ret = max(ret, s)\n    if right == n:\n        break\n    s += a[right][1]\n    while left <= right and a[right][0] - a[left][0] >= diff:\n        s -= a[left][1]\n        left += 1\n    right += 1\n    ret = max(ret, s)\nprint(ret)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool comp(const pair<int, long long>& a, const pair<int, long long>& b) {\n  return a.second < b.second;\n}\nvector<pair<int, long long> > pairs;\nvector<pair<int, long long> > indices;\nint main() {\n  int n;\n  long long d;\n  cin >> n >> d;\n  pairs.resize(n);\n  indices.resize(n);\n  long long m, s;\n  for (int i = 0; i < n; i++) {\n    cin >> m >> s;\n    pairs[i].first = s;\n    pairs[i].second = m;\n    indices[i].first = i + 1;\n    indices[i].second = pairs[i].second;\n  }\n  sort(pairs.begin(), pairs.end(), comp);\n  sort(indices.begin(), indices.end(), comp);\n  long long p[100001] = {0};\n  for (int i = 1; i < n + 1; i++) {\n    p[i] = p[i - 1] + pairs[i - 1].first;\n  }\n  long long maxi = 0;\n  for (int i = 0; i < n; i++) {\n    int first, last, mid;\n    first = 0;\n    last = n;\n    while (first < last) {\n      mid = (first + last) / 2;\n      if (pairs[mid].second >= pairs[i].second + d) {\n        last = mid;\n      } else {\n        first = mid + 1;\n      }\n    }\n    long long f = p[first] - p[i];\n    if (f > maxi) {\n      maxi = f;\n    }\n  }\n  cout << maxi << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "//Some of the methods are copied from GeeksforGeeks Website  \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main\n{ \n  static  Reader sc=new Reader();\n  // static FastReader sc=new FastReader(System.in);\n  static int bs(Pair p[],int l,int r,long x)\n   {\n      int ans=-1;\n      while(l<=r)\n       {\n          int m=l+(r-l)/2;\n          if(p[m].x<=x)\n           {\n              ans=m;\n              l=m+1;\n           }\n          else\n           r=m-1;\n       }\n      return ans;\n   }\n public static void main (String[] args) throws java.lang.Exception\n   {\n//\ttry{\n\t    /*\n\t        int n=sc.nextInt();\n\t        ArrayList<Integer> al=new ArrayList<>();\n\t        ArrayList<Long> al=new ArrayList<>();\n\t        Set<Integer> set=new HashSet<>();\n\t        Collections.sort(al,Collections.reverseOrder());\n\t     \n\t        long n=sc.nextLong();\n\t        for(int i=0;i<n;i++) \n\t        String s=sc.next();\n\t        StringBuilder sb=new StringBuilder();\n\t     */\n\t\t  int t = 1;//sc.nextInt();\n\t\t  while(t-->0)\n\t\t    { \n\t\t       int n=sc.nextInt();\n\t\t       long d=sc.nextLong();\n\t\t       Pair p[]=new Pair[n];\n\t\t       for(int i=0;i<n;i++)\n\t\t         {\n\t\t            long m=sc.nextLong();\n\t\t            long f=sc.nextLong();\n\t\t            p[i]=new Pair(m,f);\n\t\t         }\n\t\t     Arrays.sort(p, new Comparator<Pair>() {\n            @Override\n            public int compare(Pair o1, Pair o2) {\n                if(o1.x>o2.x) return 1;\n                else if(o1.x==o2.x)\n                {\n                   if(o1.y>o2.y) return -1;\n                   else return 1;\n                }\n                else return -1;\n            }});\n            // for(int i=0;i<n;i++)\n            //  {\n            //     out.println(p[i].x+\" \"+p[i].y);\n            //  }\n\t\t       long pre[]=new long[n];\n\t\t       pre[0]=p[0].y;\n\t\t       for(int i=1;i<n;i++)\n\t\t         {\n\t\t            pre[i]=pre[i-1]+p[i].y;\n\t\t         }\n\t\t      //print(pre);\n\t\t      long max=long_min;\n\t\t      for(int i=0;i<n;i++)\n\t\t        {\n\t\t           Pair cur=p[i];\n\t\t           long money=cur.x;\n\t\t           int ind=bs(p,0,n-1,money+d-1);\n\t\t           \n\t\t           if(ind==-1) continue;\n\t\t           int ini=i-1;\n\t\t           long val=0;\n\t\t           if(ini<0)  val=pre[ind];\n\t\t           else val=pre[ind]-pre[ini];\n\t\t           \n\t\t           max=Math.max(max,val);\n\t\t        }\n\t\t      out.println(max);\n\t\t    }\n\t     out.flush();\n\t     out.close();\n// \t   }     \n// \tcatch(Exception e)\n// \t\t {}\n\t}\n \n /*\n   ...SOLUTION ENDS HERE...........SOLUTION ENDS HERE...\n */\n \nstatic void flag(boolean flag)\n   {\n       out.println(flag ? \"YES\" : \"NO\");\n       out.flush();\n   }\n   \n /*                     \n    Map<Long,Long> map=new HashMap<>();\n             for(int i=0;i<n;i++)\n               {\n                  if(!map.containsKey(a[i]))\n                   map.put(a[i],1);\n                 else\n                   map.replace(a[i],map.get(a[i])+1);\n               }\n     \n    Set<Map.Entry<Long,Long>> hmap=map.entrySet();\n             for(Map.Entry<Long,Long> data : hmap)\n               {\n          \n               }\n       \n   Iterator<Integer> it = set.iterator();\n          while(it.hasNext()) \n           { \n            int x=it.next();\n           }\n   */\n\nstatic void print(int a[])\n  {\n     int n=a.length;\n     for(int i=0;i<n;i++)\n       {\n          out.print(a[i]+\" \");\n       }\n     out.println();\n     out.flush();\n  }\nstatic void print(long a[])\n  {\n     int n=a.length;\n     for(int i=0;i<n;i++)\n       {\n          out.print(a[i]+\" \");\n       }\n     out.println();\n     out.flush();\n  } \nstatic void print_int(ArrayList<Integer> al)\n  {\n     int si=al.size();\n     for(int i=0;i<si;i++)\n       {\n          out.print(al.get(i)+\" \");\n       }\n     out.println();\n     out.flush();\n  }\nstatic void print_long(ArrayList<Long> al)\n  {\n     int si=al.size();\n     for(int i=0;i<si;i++)\n       {\n          out.print(al.get(i)+\" \");\n       }\n     out.println();\n     out.flush();\n  }\n\nstatic class Graph\n  {\n        int v;\n        ArrayList<Integer> list[];\n        Graph(int v)\n        {\n            this.v=v;\n            list=new ArrayList[v+1];\n            for(int i=1;i<=v;i++)\n                list[i]=new ArrayList<Integer>();\n        }\n        void addEdge(int a, int b)\n        {\n            this.list[a].add(b);\n        }\n    }\nstatic void DFS(Graph g, boolean[] visited, int u)\n\t{\n        visited[u]=true;\n        int v=0;\n        for(int i=0;i<g.list[u].size();i++)\n        {\n            v=g.list[u].get(i);\n            if(!visited[v])\n               DFS(g,visited,v);\n        }\n  } \n  \nstatic class Pair\n   {\n      long x,y;\n      Pair(long x,long y)\n       {\n          this.x=x;\n          this.y=y;\n       }\n   }\n   \nstatic long sum_array(int a[])\n {\n    int n=a.length;\n    long sum=0;\n    for(int i=0;i<n;i++)\n     sum+=a[i];\n    return sum;\n }\nstatic long sum_array(long a[])\n {\n    int n=a.length;\n    long sum=0;\n    for(int i=0;i<n;i++)\n     sum+=a[i];\n    return sum;\n }\n\n static void sort(int[] a) \n   {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\nstatic void sort(long[] a) \n   {\n\t\tArrayList<Long> l=new ArrayList<>();\n\t\tfor (long i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\nstatic void reverse_array(int a[])\n {\n    int n=a.length;\n    int i,t; \n    for (i = 0; i < n / 2; i++) { \n            t = a[i]; \n            a[i] = a[n - i - 1]; \n            a[n - i - 1] = t; \n        } \n }\nstatic void reverse_array(long a[])\n {\n    int n=a.length;\n    int i; long t; \n    for (i = 0; i < n / 2; i++) { \n            t = a[i]; \n            a[i] = a[n - i - 1]; \n            a[n - i - 1] = t; \n        } \n }\n \nstatic long gcd(long a, long b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \nstatic int gcd(int a, int b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \n\n   static class FastReader{\n \n        byte[] buf = new byte[2048];\n        int index, total;\n        InputStream in;\n \n        FastReader(InputStream is) {\n            in = is;\n        }\n \n        int scan() throws IOException {\n            if (index >= total) {\n                index = 0;\n                total = in.read(buf);\n                if (total <= 0) {\n                    return -1;\n                }\n            }\n            return buf[index++];\n        }\n \n        String next() throws IOException {\n            int c;\n            for (c = scan(); c <= 32; c = scan());\n            StringBuilder sb = new StringBuilder();\n            for (; c > 32; c = scan()) {\n                sb.append((char) c);\n            }\n            return sb.toString();\n        }\n \n        int nextInt() throws IOException {\n            int c, val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n \n        long nextLong() throws IOException {\n            int c;\n            long val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n    }\n   \n    static class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    }\n  static  PrintWriter out=new PrintWriter(System.out);\n  static int int_max=Integer.MAX_VALUE;\n  static int int_min=Integer.MIN_VALUE;\n  static long long_max=Long.MAX_VALUE;\n  static long long_min=Long.MIN_VALUE;\n}\n// Thank You !"
        },
        {
            "language": 1,
            "solution": "r = lambda : map(int,raw_input().split())\nn,a = r()\nb = []\nfor _ in xrange(n):\n\tb.append(r())\nb = sorted(b)\n#print b\ns1 = 0\ne1 = 1\nv = b[s1][1]\nvm = b[s1][1]\nwhile 1:\n\tif e1>n-1:\n\t\tprint vm\n\t\tbreak\n\tif b[e1][0]-b[s1][0]<a:\n\t\tv+=b[e1][1]\n\t\tvm = max(vm,v)\n\t\te1+=1\n\telif b[e1][0]-b[s1][0]>=a:\n\t\tv-=b[s1][1]\n\t\ts1+=1\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class FriendshipFactor {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(br.readLine());\n\t\tint n=Integer.parseInt(st.nextToken());\n\t\tint d=Integer.parseInt(st.nextToken());\n\t\tArrayList<friend> arr=new ArrayList<>();\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\tarr.add(new friend(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())));\n\t\t}\n\t\t\n\t\tCollections.sort(arr,(a,b)->a.money-b.money);\n\t\t\n// \t\tfor (friend friend : arr) {\n// \t\t\tSystem.out.println(friend.money+\" \"+friend.ff);\n// \t\t}\n\t\t\n\t\tlong sum=arr.get(0).ff;\n\t\tlong res=arr.get(0).ff;\n\t\tint beg=0;\n\t\tfor (int i = 1; i < n; ++i) {\n\t        while ((arr.get(i).money - arr.get(beg).money) >= d) {\n\t            sum -= arr.get(beg).ff;\n\t            ++beg;\n\t        }\n\t        sum += arr.get(i).ff;\n\t        res = Math.max(res, sum);\n\t    }\n\t\tSystem.out.println(res);\n\t\t\n\t}\n\t\n\tstatic class friend{\n\t\tint money;\n\t\tint ff;\n\t\t\n\t\tfriend(int money, int ff)\n\t\t{\n\t\t\tthis.money=money;\n\t\t\tthis.ff=ff;\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nm_s = sorted(tuple(map(int, input().split())) for _ in range(n))\ns, max_s, i = 0, 0, 0\nfor j in range(n):\n    s += m_s[j][1]\n    while m_s[j][0] - m_s[i][0] >= d:\n        s -= m_s[i][1]\n        i += 1\n    max_s = max(max_s, s)\nprint(max_s)"
        },
        {
            "language": 1,
            "solution": "#coding: utf-8\n\nxi, yi = map(int, raw_input().split())\n\nfator = 0\npessoas = []\n\nfor i in xrange(xi):\n\tx, y = map(int, raw_input().split())\n\tpessoas.append([x, y])\n\npessoas.sort()\n\nfator = 0\nj = 0\nthisFactor = 0\n\nfor i in xrange(xi):\n\t\n\twhile j < xi and pessoas[j][0]-pessoas[i][0] < yi:\n\t\t#print pessoas[i], pessoas[j]\t\n\t\tthisFactor += pessoas[j][1]\n\t\tj += 1\t\n\t\t\t\t\n\tif thisFactor > fator:\n\t\tfator = thisFactor\n\n\tthisFactor -= pessoas[i][1]\n\t\t\t\n\t\t\t\t\nprint fator\n"
        },
        {
            "language": 3,
            "solution": "#                                               |\n#   _` |  __ \\    _` |   __|   _ \\   __ \\    _` |   _` |\n#  (   |  |   |  (   |  (     (   |  |   |  (   |  (   |\n# \\__,_| _|  _| \\__,_| \\___| \\___/  _|  _| \\__,_| \\__,_|\n\nimport sys\nimport math\nimport operator as op\nfrom functools import reduce\n\ndef read_line():\n    return sys.stdin.readline()[:-1]\n \ndef read_int():\n    return int(sys.stdin.readline())\n    \ndef read_int_line():\n    return [int(v) for v in sys.stdin.readline().split()]\n\ndef read_float_line():\n    return [float(v) for v in sys.stdin.readline().split()]\n\ndef ncr(n, r):\n    r = min(r, n-r)\n    numer = reduce(op.mul, range(n, n-r, -1), 1)\n    denom = reduce(op.mul, range(1, r+1), 1)\n    return numer / denom\n\n# t = read_int()\nt = 1\nfor i in range(t):\n\tn, d = read_int_line()\n\tli = []\n\tfor i in range(n):\n\t\tm,f = read_int_line()\n\t\tli.append([m,f])\n\n\tli = sorted(li,key=lambda x:x[0])\n\n\tl = 0\n\tr = 0\n\tans = -1\n\tcur = 0\n\twhile l<=r and r<n:\n\t\twhile l<=r and abs(li[l][0] - li[r][0])>=d:\n\t\t\tcur-=li[l][1]\n\t\t\tl+=1\n\t\twhile r<n and abs(li[l][0] - li[r][0])<d:\n\t\t\tcur += li[r][1]\n\t\t\tr+=1\n\t\tans = max(ans,cur)\n\n\tprint(ans)\n\t\t\t\n\t\t"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BKefaAndCompany solver = new BKefaAndCompany();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BKefaAndCompany {\n        public void solve(int testNumber, InputReader in, OutputWriter out) throws IOException {\n            int n = in.nextInt();\n            int d = in.nextInt();\n            int ms[][] = in.nextIntMatrix(n, 2);\n            long prefixSumsOfFriendship[] = new long[n + 1];\n            prefixSumsOfFriendship[0] = 0;\n            Arrays.sort(ms, new Comparator<int[]>() {\n\n                public int compare(int[] o1, int[] o2) {\n                    return o1[0] - o2[0];\n                }\n            });\n            for (int i = 0; i < n; i++)\n                prefixSumsOfFriendship[i + 1] = prefixSumsOfFriendship[i] + ms[i][1];\n        /*for(int i=0;i<n;i++)\n            out.printLine(ms[i][0]+\"\\t\"+ms[i][1]);*/\n            int j = 0;\n            long maxFriendShipFactor = 0;\n            for (int i = 0; i < n; i++) {\n                while (j < n && ms[j][0] - ms[i][0] < d) j++;\n                j--;\n                //out.printLine(i+\"\\t\"+j);\n                if (prefixSumsOfFriendship[j + 1] - prefixSumsOfFriendship[i] > maxFriendShipFactor)\n                    maxFriendShipFactor = prefixSumsOfFriendship[j + 1] - prefixSumsOfFriendship[i];\n                //out.printLine(tempFriendshipfactor);\n                if (j == n - 1)\n                    break;\n            }\n            out.printLine(maxFriendShipFactor);\n        }\n\n    }\n\n    static class InputReader {\n        private static final int DEFAULT_BUFFER_SIZE = 1 << 16;\n        private static final InputStream DEFAULT_STREAM = System.in;\n        private int c;\n        private byte[] buf;\n        private int bufferSize;\n        private int bufIndex;\n        private int numBytesRead;\n        private InputStream stream;\n        private static final byte EOF = -1;\n        private static final byte SPACE = 32;\n        private static final byte DASH = 45;\n        private char[] charBuffer;\n        private static byte[] bytes = new byte[58];\n        private static int[] ints = new int[58];\n        private static char[] chars = new char[128];\n\n        static {\n            char ch = ' ';\n            int value = 0;\n            byte _byte = 0;\n            for (int i = 48; i < 58; i++) bytes[i] = _byte++;\n            for (int i = 48; i < 58; i++) ints[i] = value++;\n            for (int i = 32; i < 128; i++) chars[i] = ch++;\n        }\n\n        public InputReader() {\n            this(DEFAULT_STREAM, DEFAULT_BUFFER_SIZE);\n        }\n\n        public InputReader(int bufferSize) {\n            this(DEFAULT_STREAM, bufferSize);\n        }\n\n        public InputReader(InputStream stream) {\n            this(stream, DEFAULT_BUFFER_SIZE);\n        }\n\n        public InputReader(InputStream stream, int bufferSize) {\n            if (stream == null || bufferSize <= 0)\n                throw new IllegalArgumentException();\n            buf = new byte[bufferSize];\n            charBuffer = new char[128];\n            this.bufferSize = bufferSize;\n            this.stream = stream;\n        }\n\n        private int readJunk(int token) throws IOException {\n\n            if (numBytesRead == EOF) return EOF;\n\n            // Seek to the first valid position index\n            do {\n\n                while (bufIndex < numBytesRead) {\n                    if (buf[bufIndex] > token) return 0;\n                    bufIndex++;\n                }\n\n                // reload buffer\n                numBytesRead = stream.read(buf);\n                if (numBytesRead == EOF) return EOF;\n                bufIndex = 0;\n\n            } while (true);\n\n        }\n\n        public int nextInt() throws IOException {\n\n            if (readJunk(DASH - 1) == EOF) throw new IOException();\n            int sgn = 1, res = 0;\n\n            c = buf[bufIndex];\n            if (c == DASH) {\n                sgn = -1;\n                bufIndex++;\n            }\n\n            do {\n\n                while (bufIndex < numBytesRead) {\n                    if (buf[bufIndex] > SPACE) {\n                        res = (res << 3) + (res << 1);\n                        res += ints[buf[bufIndex++]];\n                    } else {\n                        bufIndex++;\n                        return res * sgn;\n                    }\n                }\n\n                // Reload buffer\n                numBytesRead = stream.read(buf);\n                if (numBytesRead == EOF) return res * sgn;\n                bufIndex = 0;\n\n            } while (true);\n\n        }\n\n        public int[][] nextIntMatrix(int rows, int cols) throws IOException {\n            int[][] matrix = new int[rows][cols];\n            for (int i = 0; i < rows; i++)\n                for (int j = 0; j < cols; j++)\n                    matrix[i][j] = nextInt();\n            return matrix;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, d;\n  cin >> n >> d;\n  vector<pair<long long, long long>> v;\n  for (long long i = 0; i < n; i++) {\n    long long a, b;\n    cin >> a >> b;\n    v.push_back({a, b});\n  }\n  sort(v.begin(), v.end());\n  vector<long long> sum(n);\n  sum[0] = v[0].second;\n  for (long long i = 1; i < n; i++) {\n    sum[i] = v[i].second + sum[i - 1];\n  }\n  long long ans = 0;\n  for (long long i = 0; i < n; i++) {\n    pair<long long, long long> it = {v[i].first + d, 0};\n    long long index = lower_bound(v.begin(), v.end(), it) - v.begin();\n    if (i == 0)\n      ans = sum[index - 1];\n    else {\n      ans = max(sum[index - 1] - sum[i - 1], ans);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int m, s;\n} a[100005];\nbool cmp(node a, node b) { return a.m < b.m; }\nlong long sum[100005];\nint main() {\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &a[i].m, &a[i].s);\n  sort(a + 1, a + n + 1, cmp);\n  sum[0] = 0;\n  for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i].s;\n  long long ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int l = i, r = n;\n    int mid;\n    while (l < r) {\n      mid = (l + r) >> 1;\n      if (a[mid].m - a[i].m >= d)\n        r = mid - 1;\n      else\n        l = mid + 1;\n    }\n    if (a[l].m - a[i].m >= d) l--;\n    ans = max(ans, sum[l] - sum[i - 1]);\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\nfirstLineInput = input()\n\nfirstLineInput = firstLineInput.split(' ')\n\nrepetition = int(firstLineInput[0])\ndick = int(firstLineInput[1])\n\n\nfriendship= []\n\ni=0\nwhile i != repetition:\n    friendInput = input()\n    friendInput = friendInput.split(' ')\n    friendship.append([int(friendInput[0]),int(friendInput[1])])\n    i+=1\n\nfriendship.sort()\n\nstart = 0\nend =0\nref =0\nn = len(friendship)\ntotalSum =0\n\n# 1 as money\n# 2 as friendship\nwhile end < n:\n    while end < n and friendship[end][0] - friendship[start][0] < dick:\n        totalSum += friendship[end][1]\n        end +=1\n\n    if totalSum > ref:\n        ref = totalSum\n\n    totalSum -= friendship[start][1]\n\n    start +=1\nprint(ref)\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  unsigned int n, d;\n  while (cin >> n >> d) {\n    vector<pair<unsigned long long, unsigned long long>> ms(n);\n    for (size_t i = 0; i < n; ++i) cin >> ms[i].first >> ms[i].second;\n    sort(ms.begin(), ms.end());\n    unsigned long long factor = ms[0].second;\n    size_t left = 0, right = 1;\n    unsigned long long result = factor;\n    while (right < n) {\n      while (right < n && ms[right].first - ms[left].first < d)\n        factor += ms[right].second, ++right;\n      result = max(result, factor);\n      factor -= ms[left].second;\n      ++left;\n    }\n    cout << result << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100009;\nint n, d;\nlong long b[N] = {};\npair<int, int> a[N];\nint main() {\n  scanf(\"%d%d\", &n, &d);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &a[i].first, &a[i].second);\n  sort(a + 1, a + n + 1);\n  for (int i = 1; i <= n; i++) b[i] = b[i - 1] + a[i].second;\n  long long ans = 0;\n  for (int l = 1, r = 1; r <= n; r++) {\n    while (a[r].first - a[l].first >= d) l += 1;\n    ans = max(ans, b[r] - b[l - 1]);\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# https://vjudge.net/contest/319995#problem/C\n \nn, money = [ int(x) for x in input().split() ]\ndata = []\n \nfor i in range(n):\n    d = [ int(x) for x in input().split() ]\n    data.append(d)\n \ndata.sort(key=lambda x: x[0])\n \ni, j, soma, soma_parcial = 0, 1, data[0][1], data[0][1] \nwhile j < n and i < n:\n    if abs(data[i][0] - data[j][0]) < money:\n        soma_parcial += data[j][1]\n        j += 1\n    else:\n        soma_parcial -= data[i][1]\n        i += 1\n    if soma_parcial > soma:\n            soma = soma_parcial\n \nprint(soma)"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n// CFPS -> CodeForcesProblemSet\npublic final class CFPS {\n\tstatic FastReader fr = new FastReader();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic final int gigamod = 1000000007;\n\tstatic int t = 1;\n\tpublic static void main(String[] args) {\n\t\tOUTER: \n\t\tfor (int tc = 0; tc < t; tc++) {\n\t\t\t\n\t\t\t int n = fr.nextInt();\n\t\t\t long d = fr.nextLong();\n\t\t\t \n\t\t\t Friend[] friends = new Friend[n];\n\t\t\t \n\t\t\t for (int i = 0; i < n; i++) {\n\t\t\t\t friends[i] = new Friend(fr.nextLong(), fr.nextLong());\n\t\t\t }\n\t\t\t \n\t\t\t // What will we do?\n\t\t\t // 1. We will sort by money.\n\t\t\t // 2. We will calculate the prefix sum that will help us\n\t\t\t // instantly determine the total friendship points upto\n\t\t\t // some index.\n\t\t\t // 3. We will binary search the maximum money friend we can\n\t\t\t // take with the current and record the total points we get.\n\t\t\t \n\t\t\t Arrays.sort(friends);\n\t\t\t \n\t\t\t long[] fpUpto = new long[n];\n\t\t\t fpUpto[0] = friends[0].fPoints;\n\t\t\t for (int i = 1; i < n; i++)\n\t\t\t\t fpUpto[i] = fpUpto[i - 1] + friends[i].fPoints;\n\t\t\t \n\t\t\t long[] moneyOf = new long[n];\n\t\t\t for (int i = 0; i < n; i++)\n\t\t\t\t moneyOf[i] = friends[i].money;\n\t\t\t \n\t\t\t long maxFP = -1;\n\t\t\t \n\t\t\t for (int i = 0; i < n; i++) {\n\t\t\t\t // Binary searching the index which will be the last friend\n\t\t\t\t // we can take with the 'i'th one.\n\t\t\t\t int idx = bsearch(moneyOf, moneyOf[i] + (d - 1), i, n - 1, true);\n\t\t\t\t if (idx == -1) continue;\t// The richer friend has at least 'd'\n\t\t\t\t long currSegTotFP;\n\t\t\t\t if (i > 0)\n\t\t\t\t\t currSegTotFP = fpUpto[idx] - fpUpto[i - 1];\n\t\t\t\t else\n\t\t\t\t\t currSegTotFP = fpUpto[idx];\n\t\t\t\t \n\t\t\t\t maxFP = Math.max(maxFP, currSegTotFP);\n\t\t\t }\n\t\t\t \n\t\t\t out.println(maxFP);\n\t\t}\n\t\tout.close();\n\t}\n\t\n\tstatic class Friend implements Comparable<Friend>{\n\t\tlong money;\n\t\tlong fPoints;\n\t\t\n\t\tFriend(long money, long fpoints) {\n\t\t\tthis.money = money;\n\t\t\tfPoints = fpoints;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Friend that) {\n\t\t\tif (this.money > that.money)\n\t\t\t\treturn 1;\n\t\t\tif (this.money < that.money)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t// Returns the binary string of length at least bits.\n\tstatic String toBinaryString(long num, int bits) {\n\t\tStringBuilder sb = new StringBuilder(Long.toBinaryString(num));\n\t\tsb.reverse();\n\t\tfor (int i = sb.length(); i < bits; i++)\n\t\t\tsb.append(0);\n\t\treturn sb.reverse().toString();\n\t}\n\t\n\tstatic class CountMap extends HashMap<Long, Integer>{\n\n\t\tpublic Integer put(Long key) {\n\t\t\tif (super.containsKey(key)) {\n\t\t\t\treturn super.put(key, super.get(key) + 1);\n\t\t\t} else {\n\t\t\t\treturn super.put(key, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Integer put(int key) {\n\t\t\tif (super.containsKey((long) key)) {\n\t\t\t\treturn super.put((long) key, super.get((long) key) + 1);\n\t\t\t} else {\n\t\t\t\treturn super.put((long) key, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Integer remove(Long key) {\n\t\t\tInteger count = super.get(key);\n\t\t\tif (count == null) return -1;\n\t\t\tif (count == 1)\n\t\t\t\treturn super.remove(key);\n\t\t\telse\n\t\t\t\treturn super.put(key, super.get(key) - 1);\n\t\t}\n\t\t\n\t\tpublic Integer remove(int key) {\n\t\t\tInteger count = super.get((long) key);\n\t\t\tif (count == null) return -1;\n\t\t\tif (count == 1)\n\t\t\t\treturn super.remove((long) key);\n\t\t\telse\n\t\t\t\treturn super.put((long) key, super.get((long) key) - 1);\n\t\t}\n\t\t\n\t\tpublic Integer get(int key) {\n\t\t\tInteger count = super.get((long) key);\n\t\t\tif (count == null)\n\t\t\t\treturn 0;\n\t\t\treturn count;\n\t\t}\n\t\t\n\t\tpublic Integer get(long key) {\n\t\t\tInteger count = super.get(key);\n\t\t\tif (count == null)\n\t\t\t\treturn 0;\n\t\t\treturn count;\n\t\t}\n\t}\n\t\n\t// Checks if s has subsequence t.\n\tstatic boolean hasSubsequence(String s, String t) {\n\t\t\n\t\tchar[] schars = s.toCharArray();\n\t\tchar[] tchars = t.toCharArray();\n\t\tint slen = schars.length, tlen = tchars.length;\n\t\tint tctr = 0;\n\t\t\n\t\tif (slen < tlen) return false;\n\t\t\n\t\tfor (int i = 0; i < slen || i < tlen; i++) {\n\t\t\tif (tctr == tlen) break;\n\t\t\tif (schars[i] == tchars[tctr]) {\n\t\t\t\ttctr++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (tctr == tlen) return true;\n\t\t\n\t\treturn false;\n\t}\n\t\n\tstatic class Point implements Comparable<Point> {\n\t\tlong x;\n\t\tlong y;\n\t\tint id;\n\t\t\n\t\tPoint() {\n\t\t\tx = y = id = 0;\n\t\t}\n\t\t\n\t\tPoint(Point p) {\n\t\t\tthis.x = p.x;\n\t\t\tthis.y = p.y;\n\t\t\tthis.id = p.id;\n\t\t}\n\t\t\n\t\tPoint(long a, long b, int id) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t\tthis.id = id;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\tif (this.x > o.x)\n\t\t\t\treturn 1;\n\t\t\tif (this.x < o.x)\n\t\t\t\treturn -1;\n\t\t\tif (this.y > o.y)\n\t\t\t\treturn 1;\n\t\t\tif (this.y < o.y)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tstatic class PointComparator implements Comparator<Point> {\n\t\t@Override\n\t\tpublic int compare(Point o1, Point o2) {\n\t\t\tif (o1.y > o2.y)\n\t\t\t\treturn 1;\n\t\t\tif (o1.y < o2.y)\n\t\t\t\treturn -1;\n\t\t\tif (o1.x > o2.x)\n\t\t\t\treturn 1;\n\t\t\tif (o1.x < o2.x)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t// Returns the largest power of k that fits into n.\n\tstatic int largestFittingPower(long n, long k) {\n\t\tint lo = 0, hi = log2(Long.MAX_VALUE);\n\t\tint largestPower = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\t\n\t\t\tlong val = (long) Math.pow(k, mid);\n\t\t\tif (val <= n) {\n\t\t\t\tlargestPower = mid;\n\t\t\t\tlo = mid + 1;\n\t\t\t} else {\n\t\t\t\thi = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn largestPower;\n\t}\n\t\n\tstatic String bitSetToString(int set) {\n\t\t// We have to print all the elements that are present\n\t\t// in the set.\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tif (((set >> i) & 1) == 1) {\n\t\t\t\t// The 'i'th bit is on meaning that the element 'i' is \n\t\t\t\t// present in the set.\n\t\t\t\tsb.append((i + 1) + \" \");\n\t\t\t}\n\t\t}\n\t\tsb.append(\"\\n\");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String displayBitSet(long set) {\n\t\t// We have to print all the elements that are present\n\t\t// in the set.\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 60; i++) {\n\t\t\tif (((set >> i) & 1) == 1) {\n\t\t\t\t// The 'i'th bit is on meaning that the element 'i' is \n\t\t\t\t// present in the set.\n\t\t\t\tsb.append((i + 1) + \" \");\n\t\t\t}\n\t\t}\n\t\tsb.append(\"\\n\");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic int addToBitSet(int set, int element) {\n\t\tset = (set) | (1 << (element - 1));\n\t\treturn set;\n\t}\n\t\n\tstatic int removeFromBitSet(int set, int element) {\n\t\t// Checking whether the bit is present.\n\t\tif ((set & (1 << (element - 1))) == 0) return set;\n\t\tset = set ^ (1 << (element - 1));\n\t\treturn set;\n\t}\n\t\n\t// Returns map of factor and its power in the number.\n\tstatic TreeMap<Long, Integer> primeFactorization(long num) {\n\t\tTreeMap<Long, Integer> map = new TreeMap<>();\n\t\twhile (num % 2 == 0) {\n\t\t\tnum /= 2;\n\t\t\tInteger pwrCnt = map.get(2L);\n\t\t\tmap.put(2L, pwrCnt != null ? pwrCnt + 1 : 1);\n\t\t}\n\t\t\n\t\tfor (long i = 3; i * i <= num; i += 2) {\n\t\t\twhile (num % i == 0) {\n\t\t\t\tnum /= i;\n\t\t\t\tInteger pwrCnt = map.get(i);\n\t\t\t\tmap.put(i, pwrCnt != null ? pwrCnt + 1 : 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If the number is prime, we have to add it to the \n\t\t// map.\n\t\tif (num != 1)\n\t\t\tmap.put(num, 1);\n\t\t\n\t\treturn map;\n\t}\n\t\n\t// Returns map of factor and its power in the number.\n\tstatic TreeMap<Integer, Integer> primeFactorization(int num) {\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\t\twhile (num % 2 == 0) {\n\t\t\tnum /= 2;\n\t\t\tInteger pwrCnt = map.get(2);\n\t\t\tmap.put(2, pwrCnt != null ? pwrCnt + 1 : 1);\n\t\t}\n\t\t\n\t\tfor (int i = 3; i * i <= num; i += 2) {\n\t\t\twhile (num % i == 0) {\n\t\t\t\tnum /= i;\n\t\t\t\tInteger pwrCnt = map.get(i);\n\t\t\t\tmap.put(i, pwrCnt != null ? pwrCnt + 1 : 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If the number is prime, we have to add it to the \n\t\t// map.\n\t\tif (num != 1)\n\t\t\tmap.put(num, 1);\n\t\t\n\t\treturn map;\n\t}\n\t\n\tstatic Set<Long> divisors(long num) {\n\t\tSet<Long> divisors = new TreeSet<Long>();\n\t\tdivisors.add(1L);\n\t\tdivisors.add(num);\n\t\t\n\t\tfor (long i = 2; i * i <= num; i++) {\n\t\t\tif (num % i == 0) {\n\t\t\t\tdivisors.add(num/i);\n\t\t\t\tdivisors.add(i);\n\t\t\t}\n\t\t}\n\t\treturn divisors;\n\t}\n\t\n\tstatic void dfs(int node, boolean[] marked, ArrayList<Integer>[] adj) {\n\t\tif (marked[node]) return;\n\n\t\tmarked[node] = true;\n\t\tfor (int adjc : adj[node])\n\t\t\tdfs(adjc, marked, adj);\n\t}\n\t\n\t// Returns the index of the first element\n\t// larger than or equal to val.\n\tstatic int bsearch(int[] arr, int val, int lo, int hi) {\n\t\tint idx = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tif (arr[mid] >= val) {\n\t\t\t\tidx = mid;\n\t\t\t\thi = mid - 1;\n\t\t\t} else\n\t\t\t\tlo = mid + 1;\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\tstatic int bsearch(long[] arr, long val, int lo, int hi) {\n\t\tint idx = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tif (arr[mid] >= val) {\n\t\t\t\tidx = mid;\n\t\t\t\thi = mid - 1;\n\t\t\t} else\n\t\t\t\tlo = mid + 1;\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\t// Returns the index of the last element \n\t// smaller than or equal to val.\n\tstatic int bsearch(long[] arr, long val, int lo, int hi, boolean sMode) {\n\t\tint idx = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tif (arr[mid] > val) {\n\t\t\t\thi = mid - 1;\n\t\t\t} else {\n\t\t\t\tidx = mid;\n\t\t\t\tlo = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\tstatic int bsearch(int[] arr, long val, int lo, int hi, boolean sMode) {\n\t\tint idx = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tif (arr[mid] > val) {\n\t\t\t\thi = mid - 1;\n\t\t\t} else {\n\t\t\t\tidx = mid;\n\t\t\t\tlo = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\tstatic int factorial(int n) {\n\t\tif (n <= 1)\n\t\t\treturn 1;\n\t\treturn n * factorial(n - 1);\n\t}\n\t\n\tstatic long factorial(long n) {\n\t\tif (n <= 1)\n\t\t\treturn 1;\n\t\tlong factorial = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfactorial = mod(factorial * i);\n\t\treturn factorial;\n\t}\n\t\n\tstatic long factorialInDivision(long a, long b) {\n\t\tif (a == b)\n\t\t\treturn 1;\n\t\tif (b < a) {\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t}\n\t\t\n\t\tlong factorial = 1;\n\t\tfor (long i = a + 1; i <= b; i++)\n\t\t\tfactorial = mod(factorial * i);\n\t\treturn factorial;\n\t}\n\t\n\tstatic BigInteger factorialInDivision(BigInteger a, BigInteger b) {\n\t\tif (a.equals(b))\n\t\t\treturn BigInteger.ONE;\n\t\treturn a.multiply(factorialInDivision(a.subtract(BigInteger.ONE), b));\n\t}\n\t\n\tstatic long nCr(long n, long r) {\n\t\tlong p = gigamod;\n\t    // Base case\n\t    if (r == 0)\n\t        return 1;\n\t \n\t    // Fill factorial array so that we\n\t    // can find all factorial of r, n\n\t    // and n-r\n\t    long fac[] = new long[(int)n + 1];\n\t    fac[0] = 1;\n\t    for (int i = 1; i <= n; i++)\n\t        fac[i] = fac[i - 1] * i % p;\n\t \n\t    return (fac[(int)n] * modInverse(fac[(int)r], p) % p\n\t                    * modInverse(fac[(int)n - (int)r], p) % p) % p;\n\t}\n\t\n\tstatic long modInverse(long n, long p) {\n\t    return power(n, p - 2, p);\n\t}\n\t\n\tstatic long power(long x, long y, long p) {\n\t    long res = 1; // Initialize result\n\t \n\t    x = x % p; // Update x if it is more than or\n\t    // equal to p\n\t \n\t    while (y > 0) {\n\t        // If y is odd, multiply x with result\n\t        if ((y & 1)==1)\n\t            res = (res * x) % p;\n\t \n\t        // y must be even now\n\t        y = y >> 1; // y = y/2\n\t        x = (x * x) % p;\n\t    }\n\t    return res;\n\t}\n\t\n\tstatic long nPr(long n, long r) {\n\t\treturn factorialInDivision(n, n - r);\n\t}\n\t\n\tstatic int log2(long n) {\n\t\treturn (int)(Math.log(n) / Math.log(2));\n\t}\n\t\n\tstatic int logk(long n, long k) {\n\t\treturn (int)(Math.log(n) / Math.log(k));\n\t}\n\t\n\t// Sieve of Eratosthenes: \n\tstatic boolean[] primeGenerator(int upto) {\n\t\tboolean[] isPrime = new boolean[upto + 1];\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[1] = isPrime[0] = false;\n\n\t\tfor (long i = 2; i * i < upto + 1; i++)\n\t\t\tif (isPrime[(int) i])\n\t\t\t\t// Mark all the multiples greater than or equal\n\t\t\t\t// to the square of i to be false.\n\t\t\t\tfor (long j = i; j * i < upto + 1; j++)\n\t\t\t\t\tisPrime[(int) j * (int) i] = false;\n\t\treturn isPrime;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn gcd(b, a % b);\n\t\t}\n\t}\n\t\n\tstatic long gcd(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn gcd(b, a % b);\n\t\t}\n\t}\n\t\n\tstatic int gcd(int[] arr) {\n\t\tint n = arr.length;\n\t\tint gcd = arr[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tgcd = gcd(gcd, arr[i]);\n\t\t}\n\t\treturn gcd;\n\t}\n\t\n\tstatic long gcd(long[] arr) {\n\t\tint n = arr.length;\n\t\tlong gcd = arr[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tgcd = gcd(gcd, arr[i]);\n\t\t}\n\t\treturn gcd;\n\t}\n\t\n\tstatic long lcm(int[] arr) {\n\t\tint lcm = arr[0];\n\t\tint n = arr.length;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tlcm = (lcm * arr[i]) / gcd(lcm, arr[i]);\n\t\t}\n\t\treturn lcm;\n\t}\n\t\n\tstatic long lcm(long[] arr) {\n\t\tlong lcm = arr[0];\n\t\tint n = arr.length;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tlcm = (lcm * arr[i]) / gcd(lcm, arr[i]);\n\t\t}\n\t\treturn lcm;\n\t}\n\t\n\tstatic long lcm(int a, int b) {\n\t\treturn (a * b)/gcd(a, b);\n\t}\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn (a * b)/gcd(a, b);\n\t}\n\t\n\tstatic boolean less(int a, int b) {\n\t\treturn a < b ? true : false;\n\t}\n\t\n\tstatic boolean isSorted(int[] a) {\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif (less(a[i], a[i - 1]))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic boolean isSorted(long[] a) {\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif (a[i] < a[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic void swap(int a, int b) {\n\t\tint temp = a;\n\t\ta = b;\n\t\tb = temp;\n\t}\n\t\n\tstatic void swap(long a, long b) {\n\t\tlong temp = a;\n\t\ta = b;\n\t\tb = temp;\n\t}\n\t\n\tstatic void swap(double a, double b) {\n\t\tdouble temp = a;\n\t\ta = b;\n\t\tb = temp;\n\t}\n\t\n\tstatic void swap(int[] a, int i, int j) {\n\t\tint temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\t\n\tstatic void swap(long[] a, int i, int j) {\n\t\tlong temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\t\n\tstatic void swap(double[] a, int i, int j) {\n\t\tdouble temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\t\n\tstatic void swap(char[] a, int i, int j) {\n\t\tchar temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\t\n\tstatic void sort(int[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t}\n\t\n\tstatic void sort(char[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t}\n\t\n\tstatic void sort(long[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t}\n\t\n\tstatic void sort(double[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t}\n\t\n\tstatic void reverseSort(int[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n/2; i++)\n\t\t\tswap(arr, i, n - 1 - i);\n\t}\n\t\n\tstatic void reverseSort(char[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n/2; i++)\n\t\t\tswap(arr, i, n - 1 - i);\n\t}\n\t\n\tstatic void reverseSort(long[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n/2; i++)\n\t\t\tswap(arr, i, n - 1 - i);\n\t}\n\t\n\tstatic void reverseSort(double[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n/2; i++)\n\t\t\tswap(arr, i, n - 1 - i);\n\t}\n\t\n\tstatic void shuffleArray(long[] arr, int startPos, int endPos) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = startPos; i < endPos; ++i) {\n\t\t\tlong tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(endPos - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\t\n\tstatic void shuffleArray(int[] arr, int startPos, int endPos) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = startPos; i < endPos; ++i) {\n\t\t\tint tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(endPos - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\t\n\tstatic void shuffleArray(double[] arr, int startPos, int endPos) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = startPos; i < endPos; ++i) {\n\t\t\tdouble tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(endPos - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\t\n\tprivate static void shuffleArray(char[] arr, int startPos, int endPos) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = startPos; i < endPos; ++i) {\n\t\t\tchar tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(endPos - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\t\n\tstatic boolean isPrime(int n) {\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\n\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\treturn false;\n\n\t\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tstatic String toString(int[] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\tsb.append(dp[i] + \" \");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(boolean[] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\tsb.append(dp[i] + \" \");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(long[] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\tsb.append(dp[i] + \" \");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(char[] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\tsb.append(dp[i] + \"\");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(int[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\tsb.append(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(long[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\tsb.append(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(double[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\tsb.append(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(char[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\tsb.append(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic char toChar(int i) {\n\t\treturn (char) (i + 48);\n\t}\n\t\n\tstatic long mod(long a, long m) {\n\t    return (a%m + m) % m;\n\t}\n\t\n\tstatic long mod(long num) {\n\t\treturn (num % gigamod + gigamod) % gigamod;\n\t}\n\t\n\t// Uses weighted quick-union with path compression.\n\tstatic class UnionFind {\n\t    private int[] parent;  // parent[i] = parent of i\n\t    private int[] size;    // size[i] = number of sites in tree rooted at i\n\t                           // Note: not necessarily correct if i is not a root node\n\t    private int count;     // number of components\n\n\t    public UnionFind(int n) {\n\t        count = n;\n\t        parent = new int[n];\n\t        size = new int[n];\n\t        for (int i = 0; i < n; i++) {\n\t            parent[i] = i;\n\t            size[i] = 1;\n\t        }\n\t    }\n\n\t    // Number of connected components.\n\t    public int count() {\n\t        return count;\n\t    }\n\t  \n\t    // Find the root of p.\n\t    public int find(int p) {\n\t        int root = p;\n\t        while (root != parent[root])\n\t            root = parent[root];\n\t        while (p != root) {\n\t            int newp = parent[p];\n\t            parent[p] = root;\n\t            p = newp;\n\t        }\n\t        return root;\n\t    }\n\n\t    public boolean connected(int p, int q) {\n\t        return find(p) == find(q);\n\t    }\n\t    \n\t    public int numConnectedTo(int node) {\n\t    \treturn size[find(node)];\n\t    }\n\t    \n\t    // Weighted union.\n\t    public void union(int p, int q) {\n\t        int rootP = find(p);\n\t        int rootQ = find(q);\n\t        \n\t        if (rootP == rootQ) return;\n\n\t        // make smaller root point to larger one\n\t        if (size[rootP] < size[rootQ]) {\n\t            parent[rootP] = rootQ;\n\t            size[rootQ] += size[rootP];\n\t        }\n\t        else {\n\t            parent[rootQ] = rootP;\n\t            size[rootP] += size[rootQ];\n\t        }\n\t        count--;\n\t    }\n\t}\n\t\n\tstatic class UGraph {\n\t\t// Adjacency list.\n\t\tprivate HashSet<Integer>[] adj;\n\t\tprivate static final String NEWLINE = \"\\n\";\n\t\tprivate int E;\n\t\t\n\t\tpublic UGraph(int V) {\n\t\t\tadj = (HashSet<Integer>[]) new HashSet[V];\n\t\t\tE = 0;\n\t\t\tfor (int i = 0; i < V; i++)\n\t\t\t\tadj[i] = new HashSet<Integer>();\n\t\t}\n\t\t\n\t\tpublic void addEdge(int from, int to) {\n\t\t\tif (adj[from].contains(to)) return;\n\t\t\tE++;\n\t\t\tadj[from].add(to);\n\t\t\tadj[to].add(from);\n\t\t}\n\t\t\n\t\tpublic HashSet<Integer> adj(int from) {\n\t\t\treturn adj[from];\n\t\t}\n\t\t\n\t\tpublic int V() {\n\t\t\treturn adj.length;\n\t\t}\n\t\t\n\t\tpublic int E() {\n\t\t\treturn E;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\ts.append(V() + \" vertices, \" + E() + \" edges \" + NEWLINE);\n\t\t\tfor (int v = 0; v < V(); v++) {\n\t\t\t\ts.append(v + \": \");\n\t\t\t\tfor (int w : adj[v]) {\n\t\t\t\t\ts.append(w + \" \");\n\t\t\t\t}\n\t\t\t\ts.append(NEWLINE);\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\t\n\t\tpublic static void dfsMark(int source, boolean[] marked, UGraph g) {\n\t\t\tif (marked[source]) return;\n\t\t\t\n\t\t\tmarked[source] = true;\n\t\t\tIterable<Integer> adj = g.adj(source);\n\t\t\tfor (int adjc : adj)\n\t\t\t\tdfsMark(adjc, marked, g);\n\t\t}\n\t\t\n\t\tpublic static void bfsOrder(int source, UGraph g) {\n\t\t}\n\t\t\n\t\tprivate static void dfsMark(int source, int[] colorIds, int color, UGraph g) {\n\t\t\tif (colorIds[source] != -1) return;\n\t\t\t\n\t\t\tcolorIds[source] = color;\n\t\t\tIterable<Integer> adj = g.adj(source);\n\t\t\tfor (int adjc : adj)\n\t\t\t\tdfsMark(adjc, colorIds, color, g);\n\t\t}\n\t\t\n\t\tpublic static int[] connectedComponents(UGraph g) {\n\t\t\tint n = g.V();\n\t\t\tint[] componentId = new int[n];\n\t\t\tArrays.fill(componentId, -1);\n\t\t\tint colorCtr = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (componentId[i] != -1) continue;\n\t\t\t\tdfsMark(i, componentId, colorCtr, g);\n\t\t\t\tcolorCtr++;\n\t\t\t}\n\t\t\t\n\t\t\treturn componentId;\n\t\t}\n\t}\n\t\n\tstatic class Digraph {\n\t\t// Adjacency list.\n\t\tprivate HashSet<Integer>[] adj;\n\t\tprivate static final String NEWLINE = \"\\n\";\n\t\tprivate int E;\n\t\t\n\t\tpublic Digraph(int V) {\n\t\t\tadj = (HashSet<Integer>[]) new HashSet[V];\n\t\t\tE = 0;\n\t\t\tfor (int i = 0; i < V; i++)\n\t\t\t\tadj[i] = new HashSet<Integer>();\n\t\t}\n\t\t\n\t\tpublic void addEdge(int from, int to) {\n\t\t\tif (adj[from].contains(to)) return;\n\t\t\tE++;\n\t\t\tadj[from].add(to);\n\t\t}\n\t\t\n\t\tpublic HashSet<Integer> adj(int from) {\n\t\t\treturn adj[from];\n\t\t}\n\t\t\n\t\tpublic int V() {\n\t\t\treturn adj.length;\n\t\t}\n\t\t\n\t\tpublic int E() {\n\t\t\treturn E;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\ts.append(V() + \" vertices, \" + E() + \" edges \" + NEWLINE);\n\t\t\tfor (int v = 0; v < V(); v++) {\n\t\t\t\ts.append(v + \": \");\n\t\t\t\tfor (int w : adj[v]) {\n\t\t\t\t\ts.append(w + \" \");\n\t\t\t\t}\n\t\t\t\ts.append(NEWLINE);\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\t\n\t\tpublic static void dfsMark(int source, boolean[] marked, Digraph g) {\n\t\t\tif (marked[source]) return;\n\t\t\t\n\t\t\tmarked[source] = true;\n\t\t\tIterable<Integer> adj = g.adj(source);\n\t\t\tfor (int adjc : adj)\n\t\t\t\tdfsMark(adjc, marked, g);\n\t\t}\n\t\t\n\t\tpublic static void bfsOrder(int source, Digraph g) {\n\t\t}\n\t\t\n\t\tprivate static void dfsMark(int source, int[] colorIds, int color, Digraph g) {\n\t\t\tif (colorIds[source] != -1) return;\n\t\t\t\n\t\t\tcolorIds[source] = color;\n\t\t\tIterable<Integer> adj = g.adj(source);\n\t\t\tfor (int adjc : adj)\n\t\t\t\tdfsMark(adjc, colorIds, color, g);\n\t\t}\n\t\t\n\t\tpublic static int[] connectedComponents(Digraph g) {\n\t\t\tint n = g.V();\n\t\t\tint[] componentId = new int[n];\n\t\t\tArrays.fill(componentId, -1);\n\t\t\tint colorCtr = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (componentId[i] != -1) continue;\n\t\t\t\tdfsMark(i, componentId, colorCtr, g);\n\t\t\t\tcolorCtr++;\n\t\t\t}\n\t\t\t\n\t\t\treturn componentId;\n\t\t}\n\t\t\n\t\tpublic static Stack<Integer> topologicalSort(Digraph dg)\n\t\t{\n\t\t\t// dg has to be a directed acyclic graph.\n\t\t\t// We'll have to run dfs on the digraph and push the deepest nodes on stack first.\n\t\t\t// We'll need a Stack<Integer> and a int[] marked.\n\t\t\tStack<Integer> topologicalStack = new Stack<Integer>();\n\t\t\tboolean[] marked = new boolean[dg.V()];\n\t\t\t\n\t\t\t// Calling dfs\n\t\t\tfor (int i = 0; i < dg.V(); i++)\n\t\t\t{\n\t\t\t\tif (!marked[i]) runDfs(dg, topologicalStack, marked, i);\n\t\t\t}\n\t\t\t\n\t\t\treturn topologicalStack;\n\t\t}\n\t\t\n\t\tstatic void runDfs(Digraph dg, Stack<Integer> topologicalStack, boolean[] marked, int source)\n\t\t{\n\t\t\tmarked[source] = true;\n\t\t\tfor (Integer adjVertex : dg.adj(source))\n\t\t\t{\n\t\t\t\tif (!marked[adjVertex]) runDfs(dg, topologicalStack, marked, adjVertex);\n\t\t\t}\n\t\t\ttopologicalStack.add(source);\n\t\t}\n\t}\n\t\n\tstatic class FastReader {\n\t\tprivate BufferedReader bfr;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbfr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\tif (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(bfr.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn next().toCharArray()[0];\n\t\t}\n\n\t\tString nextString() {\n\t\t\treturn next();\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarr[i] = nextInt();\n\t\t\treturn arr;\n\t\t}\n\t\t\n\t\tint[] nextOneIntArray(int n) {\n\t\t\tint[] arr = new int[n + 1];\n\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\tarr[i] = nextInt();\n\t\t\treturn arr;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] arr = new double[n];\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tarr[i] = nextDouble();\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarr[i] = nextLong();\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic char[] nextCharArray(int n) {\n\t\t\tchar[] chars = new char[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tchars[i] = fr.nextChar();\n\t\t\treturn chars;\n\t\t}\n\t}\n\t\n\tprivate static class IndexMaxPQ<Key extends Comparable<Key>> implements Iterable<Integer> {\n\t    private int maxN;        // maximum number of elements on PQ\n\t    private int n;           // number of elements on PQ\n\t    private int[] pq;        // binary heap using 1-based indexing\n\t    private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i\n\t    private Key[] keys;      // keys[i] = priority of i\n\n\t    /**\n\t     * Initializes an empty indexed priority queue with indices between {@code 0}\n\t     * and {@code maxN - 1}.\n\t     *\n\t     * @param  maxN the keys on this priority queue are index from {@code 0} to {@code maxN - 1}\n\t     * @throws IllegalArgumentException if {@code maxN < 0}\n\t     */\n\t    public IndexMaxPQ(int maxN) {\n\t        if (maxN < 0) throw new IllegalArgumentException();\n\t        this.maxN = maxN;\n\t        n = 0;\n\t        keys = (Key[]) new Comparable[maxN + 1];    // make this of length maxN??\n\t        pq   = new int[maxN + 1];\n\t        qp   = new int[maxN + 1];                   // make this of length maxN??\n\t        for (int i = 0; i <= maxN; i++)\n\t            qp[i] = -1;\n\t    }\n\n\t    /**\n\t     * Returns true if this priority queue is empty.\n\t     *\n\t     * @return {@code true} if this priority queue is empty;\n\t     *         {@code false} otherwise\n\t     */\n\t    public boolean isEmpty() {\n\t        return n == 0;\n\t    }\n\n\t    /**\n\t     * Is {@code i} an index on this priority queue?\n\t     *\n\t     * @param  i an index\n\t     * @return {@code true} if {@code i} is an index on this priority queue;\n\t     *         {@code false} otherwise\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     */\n\t    public boolean contains(int i) {\n\t        validateIndex(i);\n\t        return qp[i] != -1;\n\t    }\n\n\t    /**\n\t     * Returns the number of keys on this priority queue.\n\t     *\n\t     * @return the number of keys on this priority queue \n\t     */\n\t    public int size() {\n\t        return n;\n\t    }\n\n\t   /**\n\t     * Associate key with index i.\n\t     *\n\t     * @param  i an index\n\t     * @param  key the key to associate with index {@code i}\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if there already is an item\n\t     *         associated with index {@code i}\n\t     */\n\t    public void insert(int i, Key key) {\n\t        validateIndex(i);\n\t        if (contains(i)) throw new IllegalArgumentException(\"index is already in the priority queue\");\n\t        n++;\n\t        qp[i] = n;\n\t        pq[n] = i;\n\t        keys[i] = key;\n\t        swim(n);\n\t    }\n\n\t    /**\n\t     * Returns an index associated with a maximum key.\n\t     *\n\t     * @return an index associated with a maximum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public int maxIndex() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        return pq[1];\n\t    }\n\n\t    /**\n\t     * Returns a maximum key.\n\t     *\n\t     * @return a maximum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public Key maxKey() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        return keys[pq[1]];\n\t    }\n\n\t    /**\n\t     * Removes a maximum key and returns its associated index.\n\t     *\n\t     * @return an index associated with a maximum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public int delMax() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        int max = pq[1];\n\t        exch(1, n--);\n\t        sink(1);\n\n\t        assert pq[n+1] == max;\n\t        qp[max] = -1;        // delete\n\t        keys[max] = null;    // to help with garbage collection\n\t        pq[n+1] = -1;        // not needed\n\t        return max;\n\t    }\n\n\t    /**\n\t     * Returns the key associated with index {@code i}.\n\t     *\n\t     * @param  i the index of the key to return\n\t     * @return the key associated with index {@code i}\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public Key keyOf(int i) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        else return keys[i];\n\t    }\n\n\t    /**\n\t     * Change the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to change\n\t     * @param  key change the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     */\n\t    public void changeKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        keys[i] = key;\n\t        swim(qp[i]);\n\t        sink(qp[i]);\n\t    }\n\n\t   /**\n\t     * Change the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to change\n\t     * @param  key change the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @deprecated Replaced by {@code changeKey(int, Key)}.\n\t     */\n\t    @Deprecated\n\t    public void change(int i, Key key) {\n\t        validateIndex(i);\n\t        changeKey(i, key);\n\t    }\n\n\t    /**\n\t     * Increase the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to increase\n\t     * @param  key increase the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if {@code key <= keyOf(i)}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void increaseKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        if (keys[i].compareTo(key) == 0)\n\t            throw new IllegalArgumentException(\"Calling increaseKey() with a key equal to the key in the priority queue\");\n\t        if (keys[i].compareTo(key) > 0)\n\t            throw new IllegalArgumentException(\"Calling increaseKey() with a key that is strictly less than the key in the priority queue\");\n\n\t        keys[i] = key;\n\t        swim(qp[i]);\n\t    }\n\n\t    /**\n\t     * Decrease the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to decrease\n\t     * @param  key decrease the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if {@code key >= keyOf(i)}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void decreaseKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        if (keys[i].compareTo(key) == 0)\n\t            throw new IllegalArgumentException(\"Calling decreaseKey() with a key equal to the key in the priority queue\");\n\t        if (keys[i].compareTo(key) < 0)\n\t            throw new IllegalArgumentException(\"Calling decreaseKey() with a key that is strictly greater than the key in the priority queue\");\n\t        keys[i] = key;\n\t        sink(qp[i]);\n\t    }\n\n\t    /**\n\t     * Remove the key on the priority queue associated with index {@code i}.\n\t     *\n\t     * @param  i the index of the key to remove\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void delete(int i) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        int index = qp[i];\n\t        exch(index, n--);\n\t        swim(index);\n\t        sink(index);\n\t        keys[i] = null;\n\t        qp[i] = -1;\n\t    }\n\n\t    // throw an IllegalArgumentException if i is an invalid index\n\t    private void validateIndex(int i) {\n\t        if (i < 0) throw new IllegalArgumentException(\"index is negative: \" + i);\n\t        if (i >= maxN) throw new IllegalArgumentException(\"index >= capacity: \" + i);\n\t    }\n\n\t   /***************************************************************************\n\t    * General helper functions.\n\t    ***************************************************************************/\n\t    private boolean less(int i, int j) {\n\t        return keys[pq[i]].compareTo(keys[pq[j]]) < 0;\n\t    }\n\n\t    private void exch(int i, int j) {\n\t        int swap = pq[i];\n\t        pq[i] = pq[j];\n\t        pq[j] = swap;\n\t        qp[pq[i]] = i;\n\t        qp[pq[j]] = j;\n\t    }\n\n\n\t   /***************************************************************************\n\t    * Heap helper functions.\n\t    ***************************************************************************/\n\t    private void swim(int k) {\n\t        while (k > 1 && less(k/2, k)) {\n\t            exch(k, k/2);\n\t            k = k/2;\n\t        }\n\t    }\n\n\t    private void sink(int k) {\n\t        while (2*k <= n) {\n\t            int j = 2*k;\n\t            if (j < n && less(j, j+1)) j++;\n\t            if (!less(k, j)) break;\n\t            exch(k, j);\n\t            k = j;\n\t        }\n\t    }\n\n\n\t    /**\n\t     * Returns an iterator that iterates over the keys on the\n\t     * priority queue in descending order.\n\t     * The iterator doesn't implement {@code remove()} since it's optional.\n\t     *\n\t     * @return an iterator that iterates over the keys in descending order\n\t     */\n\t    public Iterator<Integer> iterator() {\n\t        return new HeapIterator();\n\t    }\n\n\t    private class HeapIterator implements Iterator<Integer> {\n\t        // create a new pq\n\t        private IndexMaxPQ<Key> copy;\n\n\t        // add all elements to copy of heap\n\t        // takes linear time since already in heap order so no keys move\n\t        public HeapIterator() {\n\t            copy = new IndexMaxPQ<Key>(pq.length - 1);\n\t            for (int i = 1; i <= n; i++)\n\t                copy.insert(pq[i], keys[pq[i]]);\n\t        }\n\n\t        public boolean hasNext()  { return !copy.isEmpty();                     }\n\t        public void remove()      { throw new UnsupportedOperationException();  }\n\n\t        public Integer next() {\n\t            if (!hasNext()) throw new NoSuchElementException();\n\t            return copy.delMax();\n\t        }\n\t    }\n\n\t    /*public static void main(String[] args) {\n\t        // insert a bunch of strings\n\t        String[] strings = { \"it\", \"was\", \"the\", \"best\", \"of\", \"times\", \"it\", \"was\", \"the\", \"worst\" };\n\n\t        IndexMaxPQ<String> pq = new IndexMaxPQ<String>(strings.length);\n\t        for (int i = 0; i < strings.length; i++) {\n\t            pq.insert(i, strings[i]);\n\t        }\n\n\t        // print each key using the iterator\n\t        for (int i : pq) {\n\t            StdOut.println(i + \" \" + strings[i]);\n\t        }\n\n\t        StdOut.println();\n\n\t        // increase or decrease the key\n\t        for (int i = 0; i < strings.length; i++) {\n\t            if (StdRandom.uniform() < 0.5)\n\t                pq.increaseKey(i, strings[i] + strings[i]);\n\t            else\n\t                pq.decreaseKey(i, strings[i].substring(0, 1));\n\t        }\n\n\t        // delete and print each key\n\t        while (!pq.isEmpty()) {\n\t            String key = pq.maxKey();\n\t            int i = pq.delMax();\n\t            StdOut.println(i + \" \" + key);\n\t        }\n\t        StdOut.println();\n\n\t        // reinsert the same strings\n\t        for (int i = 0; i < strings.length; i++) {\n\t            pq.insert(i, strings[i]);\n\t        }\n\n\t        // delete them in random order\n\t        int[] perm = new int[strings.length];\n\t        for (int i = 0; i < strings.length; i++)\n\t            perm[i] = i;\n\t        StdRandom.shuffle(perm);\n\t        for (int i = 0; i < perm.length; i++) {\n\t            String key = pq.keyOf(perm[i]);\n\t            pq.delete(perm[i]);\n\t            StdOut.println(perm[i] + \" \" + key);\n\t        }\n\n\t    }*/\n\t}\n\t\n\tpublic static class IndexMinPQ<Key extends Comparable<Key>> implements Iterable<Integer> {\n\t    private int maxN;        // maximum number of elements on PQ\n\t    private int n;           // number of elements on PQ\n\t    private int[] pq;        // binary heap using 1-based indexing\n\t    private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i\n\t    private Key[] keys;      // keys[i] = priority of i\n\n\t    /**\n\t     * Initializes an empty indexed priority queue with indices between {@code 0}\n\t     * and {@code maxN - 1}.\n\t     * @param  maxN the keys on this priority queue are index from {@code 0}\n\t     *         {@code maxN - 1}\n\t     * @throws IllegalArgumentException if {@code maxN < 0}\n\t     */\n\t    public IndexMinPQ(int maxN) {\n\t        if (maxN < 0) throw new IllegalArgumentException();\n\t        this.maxN = maxN;\n\t        n = 0;\n\t        keys = (Key[]) new Comparable[maxN + 1];    // make this of length maxN??\n\t        pq   = new int[maxN + 1];\n\t        qp   = new int[maxN + 1];                   // make this of length maxN??\n\t        for (int i = 0; i <= maxN; i++)\n\t            qp[i] = -1;\n\t    }\n\n\t    /**\n\t     * Returns true if this priority queue is empty.\n\t     *\n\t     * @return {@code true} if this priority queue is empty;\n\t     *         {@code false} otherwise\n\t     */\n\t    public boolean isEmpty() {\n\t        return n == 0;\n\t    }\n\n\t    /**\n\t     * Is {@code i} an index on this priority queue?\n\t     *\n\t     * @param  i an index\n\t     * @return {@code true} if {@code i} is an index on this priority queue;\n\t     *         {@code false} otherwise\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     */\n\t    public boolean contains(int i) {\n\t        validateIndex(i);\n\t        return qp[i] != -1;\n\t    }\n\n\t    /**\n\t     * Returns the number of keys on this priority queue.\n\t     *\n\t     * @return the number of keys on this priority queue\n\t     */\n\t    public int size() {\n\t        return n;\n\t    }\n\n\t    /**\n\t     * Associates key with index {@code i}.\n\t     *\n\t     * @param  i an index\n\t     * @param  key the key to associate with index {@code i}\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if there already is an item associated\n\t     *         with index {@code i}\n\t     */\n\t    public void insert(int i, Key key) {\n\t        validateIndex(i);\n\t        if (contains(i)) throw new IllegalArgumentException(\"index is already in the priority queue\");\n\t        n++;\n\t        qp[i] = n;\n\t        pq[n] = i;\n\t        keys[i] = key;\n\t        swim(n);\n\t    }\n\n\t    /**\n\t     * Returns an index associated with a minimum key.\n\t     *\n\t     * @return an index associated with a minimum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public int minIndex() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        return pq[1];\n\t    }\n\n\t    /**\n\t     * Returns a minimum key.\n\t     *\n\t     * @return a minimum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public Key minKey() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        return keys[pq[1]];\n\t    }\n\n\t    /**\n\t     * Removes a minimum key and returns its associated index.\n\t     * @return an index associated with a minimum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public int delMin() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        int min = pq[1];\n\t        exch(1, n--);\n\t        sink(1);\n\t        assert min == pq[n+1];\n\t        qp[min] = -1;        // delete\n\t        keys[min] = null;    // to help with garbage collection\n\t        pq[n+1] = -1;        // not needed\n\t        return min;\n\t    }\n\n\t    /**\n\t     * Returns the key associated with index {@code i}.\n\t     *\n\t     * @param  i the index of the key to return\n\t     * @return the key associated with index {@code i}\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public Key keyOf(int i) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        else return keys[i];\n\t    }\n\n\t    /**\n\t     * Change the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to change\n\t     * @param  key change the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void changeKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        keys[i] = key;\n\t        swim(qp[i]);\n\t        sink(qp[i]);\n\t    }\n\n\t    /**\n\t     * Change the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to change\n\t     * @param  key change the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @deprecated Replaced by {@code changeKey(int, Key)}.\n\t     */\n\t    @Deprecated\n\t    public void change(int i, Key key) {\n\t        changeKey(i, key);\n\t    }\n\n\t    /**\n\t     * Decrease the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to decrease\n\t     * @param  key decrease the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if {@code key >= keyOf(i)}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void decreaseKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        if (keys[i].compareTo(key) == 0)\n\t            throw new IllegalArgumentException(\"Calling decreaseKey() with a key equal to the key in the priority queue\");\n\t        if (keys[i].compareTo(key) < 0)\n\t            throw new IllegalArgumentException(\"Calling decreaseKey() with a key strictly greater than the key in the priority queue\");\n\t        keys[i] = key;\n\t        swim(qp[i]);\n\t    }\n\n\t    /**\n\t     * Increase the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to increase\n\t     * @param  key increase the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if {@code key <= keyOf(i)}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void increaseKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        if (keys[i].compareTo(key) == 0)\n\t            throw new IllegalArgumentException(\"Calling increaseKey() with a key equal to the key in the priority queue\");\n\t        if (keys[i].compareTo(key) > 0)\n\t            throw new IllegalArgumentException(\"Calling increaseKey() with a key strictly less than the key in the priority queue\");\n\t        keys[i] = key;\n\t        sink(qp[i]);\n\t    }\n\n\t    /**\n\t     * Remove the key associated with index {@code i}.\n\t     *\n\t     * @param  i the index of the key to remove\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void delete(int i) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        int index = qp[i];\n\t        exch(index, n--);\n\t        swim(index);\n\t        sink(index);\n\t        keys[i] = null;\n\t        qp[i] = -1;\n\t    }\n\n\t    // throw an IllegalArgumentException if i is an invalid index\n\t    private void validateIndex(int i) {\n\t        if (i < 0) throw new IllegalArgumentException(\"index is negative: \" + i);\n\t        if (i >= maxN) throw new IllegalArgumentException(\"index >= capacity: \" + i);\n\t    }\n\n\t   /***************************************************************************\n\t    * General helper functions.\n\t    ***************************************************************************/\n\t    private boolean greater(int i, int j) {\n\t        return keys[pq[i]].compareTo(keys[pq[j]]) > 0;\n\t    }\n\n\t    private void exch(int i, int j) {\n\t        int swap = pq[i];\n\t        pq[i] = pq[j];\n\t        pq[j] = swap;\n\t        qp[pq[i]] = i;\n\t        qp[pq[j]] = j;\n\t    }\n\n\n\t   /***************************************************************************\n\t    * Heap helper functions.\n\t    ***************************************************************************/\n\t    private void swim(int k) {\n\t        while (k > 1 && greater(k/2, k)) {\n\t            exch(k, k/2);\n\t            k = k/2;\n\t        }\n\t    }\n\n\t    private void sink(int k) {\n\t        while (2*k <= n) {\n\t            int j = 2*k;\n\t            if (j < n && greater(j, j+1)) j++;\n\t            if (!greater(k, j)) break;\n\t            exch(k, j);\n\t            k = j;\n\t        }\n\t    }\n\n\n\t   /***************************************************************************\n\t    * Iterators.\n\t    ***************************************************************************/\n\n\t    /**\n\t     * Returns an iterator that iterates over the keys on the\n\t     * priority queue in ascending order.\n\t     * The iterator doesn't implement {@code remove()} since it's optional.\n\t     *\n\t     * @return an iterator that iterates over the keys in ascending order\n\t     */\n\t    public Iterator<Integer> iterator() { return new HeapIterator(); }\n\n\t    private class HeapIterator implements Iterator<Integer> {\n\t        // create a new pq\n\t        private IndexMinPQ<Key> copy;\n\n\t        // add all elements to copy of heap\n\t        // takes linear time since already in heap order so no keys move\n\t        public HeapIterator() {\n\t            copy = new IndexMinPQ<Key>(pq.length - 1);\n\t            for (int i = 1; i <= n; i++)\n\t                copy.insert(pq[i], keys[pq[i]]);\n\t        }\n\n\t        public boolean hasNext()  { return !copy.isEmpty();                     }\n\t        public void remove()      { throw new UnsupportedOperationException();  }\n\n\t        public Integer next() {\n\t            if (!hasNext()) throw new NoSuchElementException();\n\t            return copy.delMin();\n\t        }\n\t    }\n\n\n\t    /**\n\t     * Unit tests the {@code IndexMinPQ} data type.\n\t     *\n\t     * @param args the command-line arguments\n\t     */\n\t   /* public static void main(String[] args) {\n\t        // insert a bunch of strings\n\t        String[] strings = { \"it\", \"was\", \"the\", \"best\", \"of\", \"times\", \"it\", \"was\", \"the\", \"worst\" };\n\n\t        IndexMinPQ<String> pq = new IndexMinPQ<String>(strings.length);\n\t        for (int i = 0; i < strings.length; i++) {\n\t            pq.insert(i, strings[i]);\n\t        }\n\n\t        // delete and print each key\n\t        while (!pq.isEmpty()) {\n\t            int i = pq.delMin();\n\t            StdOut.println(i + \" \" + strings[i]);\n\t        }\n\t        StdOut.println();\n\n\t        // reinsert the same strings\n\t        for (int i = 0; i < strings.length; i++) {\n\t            pq.insert(i, strings[i]);\n\t        }\n\n\t        // print each key using the iterator\n\t        for (int i : pq) {\n\t            StdOut.println(i + \" \" + strings[i]);\n\t        }\n\t        while (!pq.isEmpty()) {\n\t            pq.delMin();\n\t        }\n\n\t    }*/\n\t}\n}\n\n// NOTES: \n// ASCII VALUE OF 'A': 65\n// ASCII VALUE OF 'a': 97\n// Range of long: 9 * 10^18\n// ASCII VALUE OF '0': 48"
        },
        {
            "language": 4,
            "solution": "//package com.competitions.year2015.julytoseptember.round321div2;\n\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic final class Second\n{\n\tstatic int n, d;\n\tstatic Friend fr[];\n\tstatic InputReader reader;\n\tstatic OutputWriter writer;\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tSecond second = new Second();\n\t\t\n\t\treader = second.new InputReader(System.in);\n\t\twriter = second.new OutputWriter(System.out);\n\t\t\n\t\tgetAttributes2();\n\t\t\n\t\twriter.flush();\n\t\t\n\t\treader.close();\n\t\twriter.close();\n\t}\n\t\n\tstatic void getAttributes()\n\t{\n\t\tn = reader.nextInt();\n\t\td = reader.nextInt();\n\t\t\n\t\tfr = new Friend[n];\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfr[i] = new Friend(reader.nextInt(), reader.nextInt());\n\t\t\n\t\tFriend.sortMoney(fr);\n\t\t\n\t\tlong currMax, max, currMin, val;\n\t\t\n\t\tcurrMax = max = val = 0;\n\t\tcurrMin = fr[0].money;\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (fr[i].money - currMin < d)\n\t\t\t{\n\t\t\t\tval = currMax + fr[i].fr;\n\t\t\t\t\n\t\t\t\t\tif (currMax == 0)\n\t\t\t\t\t\tcurrMin = fr[i].money;\n\t\t\t\t\t\n\t\t\t\t\tcurrMax = val;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurrMin = fr[i].money;\n\t\t\t\tcurrMax = fr[i].fr;\n\t\t\t}\n\t\t\t\n\t\t\tif (currMax > max)\n\t\t\t{\n\t\t\t\tmax = currMax;\n\t\t\t}\n\t\t}\n\t\t\n\t\twriter.println(max);\n\t}\n\t\n\tstatic void getAttributes2()\n\t{\n\t\tn = reader.nextInt();\n\t\td = reader.nextInt();\n\t\t\n\t\tfr = new Friend[n];\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfr[i] = new Friend(reader.nextInt(), reader.nextInt());\n\t\t\n\t\tFriend.sortMoney(fr);\n\t\t\n\t\tlong max[] = new long[n];\n\t\tlong cum[] = new long[n];\n\t\t\n\t\tmax[n - 1] = fr[n - 1].fr;\n\t\t\n\t\tcum[0] = fr[0].fr;\n\t\t\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tcum[i] = cum[i - 1] + fr[i].fr;\n\t\t\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tint srch = binS(fr[i].money, i + 1, n - 1);\n\t\t\t\n\t\t\tif (srch == -1)\n\t\t\t\tmax[i] = fr[i].fr;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmax[i] = cum[srch] - cum[i] + fr[i].fr;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong fin = max[0];\n\t\t\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tif (max[i] > fin)\n\t\t\t\tfin = max[i];\n\t\t\n\t\twriter.print(fin);\n\t}\n\t\n\tstatic int binS(int left, int from, int to)\n\t{\n\t\tint mid;\n\t\t\n\t\twhile (from <= to)\n\t\t{\n\t\t\tmid = from + (to - from) / 2;\n\t\t\t\n\t\t\tif (fr[mid].money - left < d)\n\t\t\t{\n\t\t\t\tif (mid == n - 1)\n\t\t\t\t\treturn mid;\n\t\t\t\telse if (fr[mid + 1].money - left >= d)\n\t\t\t\t\treturn mid;\n\t\t\t\telse\n\t\t\t\t\tfrom = mid + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tto = mid - 1;\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tstatic class Friend\n\t{\n\t\tint money;\n\t\tint fr;\n\t\t\n\t\tpublic Friend(int money, int fr)\n\t\t{\n\t\t\tsuper();\n\t\t\tthis.money = money;\n\t\t\tthis.fr = fr;\n\t\t}\n\t\t\n\t\tstatic void sortMoney(Friend fr[])\n\t\t{\n\t\t\tArrays.sort(fr, new Comparator<Friend>()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(Friend o1, Friend o2)\n\t\t\t\t{\n\t\t\t\t\treturn o1.money - o2.money;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t}\n\t\t\n\t}\n\t\n\tclass InputReader\n\t{\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt()\n\t\t{\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\n\t\t\tint sgn = 1;\n\n\t\t\tif (c == '-')\n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t\tres *= 10;\n\t\t\t\tres += c & 15;\n\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong()\n\t\t{\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\n\t\t\tint sign = 1;\n\n\t\t\tif (c == '-')\n\t\t\t{\n\t\t\t\tsign = -1;\n\n\t\t\t\tc = read();\n\t\t\t}\n\n\t\t\tlong result = 0;\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t\tresult *= 10;\n\t\t\t\tresult += c & 15;\n\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn result * sign;\n\t\t}\n\n\t\tpublic float nextFloat() // problematic\n\t\t{\n\t\t\tfloat result, div;\n\t\t\tbyte c;\n\n\t\t\tresult = 0;\n\t\t\tdiv = 1;\n\t\t\tc = (byte) read();\n\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = (byte) read();\n\n\t\t\tboolean isNegative = (c == '-');\n\n\t\t\tif (isNegative)\n\t\t\t\tc = (byte) read();\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tresult = result * 10 + c - '0';\n\t\t\t} while ((c = (byte) read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.')\n\t\t\t\twhile ((c = (byte) read()) >= '0' && c <= '9')\n\t\t\t\t\tresult += (c - '0') / (div *= 10);\n\n\t\t\tif (isNegative)\n\t\t\t\treturn -result;\n\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic double nextDouble() // not completely accurate\n\t\t{\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = (byte) read();\n\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = (byte) read();\n\n\t\t\tboolean neg = (c == '-');\n\n\t\t\tif (neg)\n\t\t\t\tc = (byte) read();\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = (byte) read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.')\n\t\t\t\twhile ((c = (byte) read()) >= '0' && c <= '9')\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String next()\n\t\t{\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\n\t\t\tStringBuilder res = new StringBuilder();\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c)\n\t\t{\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic void close()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstream.close();\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass OutputWriter\n\t{\n\t\tprivate PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream stream)\n\t\t{\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n\t\t\t\t\tstream)));\n\t\t}\n\n\t\tpublic OutputWriter(Writer writer)\n\t\t{\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n\n\t\tpublic void println(int x)\n\t\t{\n\t\t\twriter.println(x);\n\t\t}\n\n\t\tpublic void print(int x)\n\t\t{\n\t\t\twriter.print(x);\n\t\t}\n\n\t\tpublic void println(int array[], int size)\n\t\t{\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tprintln(array[i]);\n\t\t}\n\n\t\tpublic void print(int array[], int size)\n\t\t{\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tprint(array[i] + \" \");\n\t\t}\n\n\t\tpublic void println(long x)\n\t\t{\n\t\t\twriter.println(x);\n\t\t}\n\n\t\tpublic void print(long x)\n\t\t{\n\t\t\twriter.print(x);\n\t\t}\n\n\t\tpublic void println(long array[], int size)\n\t\t{\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tprintln(array[i]);\n\t\t}\n\n\t\tpublic void print(long array[], int size)\n\t\t{\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tprint(array[i]);\n\t\t}\n\n\t\tpublic void println(float num)\n\t\t{\n\t\t\twriter.println(num);\n\t\t}\n\n\t\tpublic void print(float num)\n\t\t{\n\t\t\twriter.print(num);\n\t\t}\n\n\t\tpublic void println(double num)\n\t\t{\n\t\t\twriter.println(num);\n\t\t}\n\n\t\tpublic void print(double num)\n\t\t{\n\t\t\twriter.print(num);\n\t\t}\n\n\t\tpublic void println(String s)\n\t\t{\n\t\t\twriter.println(s);\n\t\t}\n\n\t\tpublic void print(String s)\n\t\t{\n\t\t\twriter.print(s);\n\t\t}\n\n\t\tpublic void println()\n\t\t{\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void printSpace()\n\t\t{\n\t\t\twriter.print(\" \");\n\t\t}\n\n\t\tpublic void flush()\n\t\t{\n\t\t\twriter.flush();\n\t\t}\n\n\t\tpublic void close()\n\t\t{\n\t\t\twriter.close();\n\t\t}\n\n\t}\n\n}\n\n/*\n\n3 20\n100 100\n50 50\n60 60\n\n3 20\n100 100\n20 20\n60 60\n\n*/\n"
        },
        {
            "language": 3,
            "solution": "line = input()\nn, d = map(int, line.split())\nms = []\nfor i in range(n):\n    line = input()\n    tmp = list(map(int, line.split()))\n    ms.append(tmp)\n    #print(tmp)\n    #print(ms)\n#print(ms[0])\n\nms = sorted(ms, key = lambda ms: ms[0])\n#print(ms)\n\ni = 0\nj = 0\nans = 0\nwhile j < n and abs(ms[i][0] - ms[j][0]) < d:\n    ans += ms[j][1]\n    j += 1\nmaxx = ans\nwhile j < n:\n    ans += ms[j][1]\n    while abs(ms[i][0] - ms[j][0]) >= d:\n        ans -= ms[i][1]\n        i += 1\n    if maxx < ans:\n        maxx = ans\n    j += 1\nprint(maxx)\n    \n    "
        },
        {
            "language": 3,
            "solution": "# #!/usr/bin/env python\n# import os\n# import sys\n# from io import BytesIO, IOBase\n\n\n# def main():\n#     pass\n\n\n# # region fastio\n\n# BUFSIZE = 8192\n\n\n# class FastIO(IOBase):\n#     newlines = 0\n\n#     def __init__(self, file):\n#         self._fd = file.fileno()\n#         self.buffer = BytesIO()\n#         self.writable = \"x\" in file.mode or \"r\" not in file.mode\n#         self.write = self.buffer.write if self.writable else None\n\n#     def read(self):\n#         while True:\n#             b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n#             if not b:\n#                 break\n#             ptr = self.buffer.tell()\n#             self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n#         self.newlines = 0\n#         return self.buffer.read()\n\n#     def readline(self):\n#         while self.newlines == 0:\n#             b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n#             self.newlines = b.count(b\"\\n\") + (not b)\n#             ptr = self.buffer.tell()\n#             self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n#         self.newlines -= 1\n#         return self.buffer.readline()\n\n#     def flush(self):\n#         if self.writable:\n#             os.write(self._fd, self.buffer.getvalue())\n#             self.buffer.truncate(0), self.buffer.seek(0)\n\n\n# class IOWrapper(IOBase):\n#     def __init__(self, file):\n#         self.buffer = FastIO(file)\n#         self.flush = self.buffer.flush\n#         self.writable = self.buffer.writable\n#         self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n#         self.read = lambda: self.buffer.read().decode(\"ascii\")\n#         self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\n# sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n# input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# # endregion\n\n# if __name__ == \"__main__\":\n#     main()\nn,d = map(int,input().split())\nl = []\nfor _ in range(n):\n    l.append(tuple(map(int,input().split())))\nl.sort()\nans=0\na=[]\ni=0\nj=0\n \nwhile i<n:\n    if l[i][0]-l[j][0]>=d:\n        a.append(ans)\n        ans-=l[j][1]\n        j+=1\n    else:\n        ans+=l[i][1]\n        a.append(ans)\n        i+=1\nprint(max(a))"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nlive = True\nif not live: stdin = open('data.in', 'r')\n\nn, limit = list(map(int, stdin.readline().strip().split()))\nfriends = []\nfor i in range(n):\n\tm, s = list(map(int, stdin.readline().strip().split()))\n\tfriends += [(m, s)]\nfriends = sorted(friends, key = lambda t: t[0])\n\nans = temp = friends[0][1]\nstart = 0\nfor i, j in friends[1:]:\n\tif temp > ans: ans = temp\n\ttemp += j\n\twhile not (i - friends[start][0] < limit):\n\t\ttemp -= friends[start][1]\n\t\tstart += 1\nif temp > ans: ans = temp\nprint(ans)\n\nif not live: stdin.close()"
        },
        {
            "language": 3,
            "solution": "from collections import deque\nn, d = map(int, input().split())\nfriends = sorted(tuple(map(int, input().split())) for _ in range(n))\n\nss = deque()\nmm = deque()\nff = 0\nans = 0\n\nfor m, s in friends:\n    ss.append(s)\n    mm.append(m)\n    ff += s\n    while mm[0]+d <= mm[-1]:\n        ff -= ss.popleft()\n        mm.popleft()\n    ans = max(ans, ff)\n\nprint(ans)"
        },
        {
            "language": 1,
            "solution": "from math import *\nPI = 3.1415926535898\nn, d = map(int, raw_input().strip().split(' '))\nfd = []\nfor x in range(n):\n    m, s = map(int, raw_input().strip().split(' '))\n    fd.append((m, s))\nfd.sort()\ni = 0\nj = 0\nans = 0\nnow = 0\nwhile j < len(fd):\n    now += fd[j][1]\n    while fd[j][0] - fd[i][0] >= d:\n        now -= fd[i][1]\n        i += 1\n    ans = max(ans, now)\n    j += 1\nprint ans\n"
        },
        {
            "language": 3,
            "solution": "n,d= map(int,input().split())\nmoney=[]\ndic={}\nfor _ in range(n):\n    m,s=map(int,input().split())\n    money.append(m)\n    if m in dic:\n        dic[m].append(s)\n    else:\n        dic[m]=[s]\nmoney.sort()\nf=[]\nmoney1= sorted(list(set(money)))\nfor i in money1:\n    for j in dic[i]:\n        f.append(j)\nmoney=[None]+money\nf=[None]+f\npref=[0 for i in range(n+1)]\nfor i in range(1,n+1):\n    pref[i]=f[i]+pref[i-1]\ni=1\nj=1\nfinal=[]\nwhile j<=n and i<=n:\n    if money[j]-money[i]<d:\n        if j==n:\n            final.append(pref[j]-pref[i-1])\n        j+=1\n    else:\n        final.append(pref[j-1]-pref[i-1])\n        i+=1\nprint(max(final))\n        \n    \n\n    "
        },
        {
            "language": 3,
            "solution": "# Author: S Mahesh Raju\n# Username: maheshraju2020\n# Date: 30/04/2020\n\nfrom sys import stdin,stdout\nfrom math import gcd, ceil, sqrt\nii1 = lambda: int(stdin.readline().strip())\nis1 = lambda: stdin.readline().strip()\niia = lambda: list(map(int, stdin.readline().strip().split()))\nisa = lambda: stdin.readline().strip().split()\nmod = 1000000007\n\nn, d = iia()\nfrds = []\nfor _ in range(n):\n    frds.append(iia())\nfrds.sort()\nres = float(\"-inf\")\ntot = frds[0][1]\np = 0\nfor i in range(1, n):\n    while frds[i][0] - frds[p][0] >= d:\n        res = max(res, tot)\n        tot -= frds[p][1]\n        p += 1\n    tot += frds[i][1]\nres = max(res,tot)\nprint(res)\n\n        \n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, d;\npair<int, int> f[N];\nint main() {\n  scanf(\"%d%d\", &n, &d);\n  for (int i = 1; i <= n; ++i) scanf(\"%d%d\", &f[i].first, &f[i].second);\n  sort(f + 1, f + n + 1);\n  int uk = 1;\n  long long mx = 0, cur_sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    while (uk <= n && f[uk].first - f[i].first < d) {\n      cur_sum += f[uk].second;\n      ++uk;\n    }\n    mx = max(mx, cur_sum);\n    cur_sum -= f[i].second;\n  }\n  cout << mx << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "a,b=map(int,input().split())\nc=0\nf=0\nd=0\ne=list()\nfor _ in range(a):\n    g,h=map(int,input().split())\n    e.append([g,h])\ne.sort()\nfor i in range(a):\n    c=c+e[i][1]\n    while e[i][0]-e[d][0]>=b:\n        c=c-e[d][1]\n        d=d+1\n    f=max(f,c)\nprint(f)"
        },
        {
            "language": 3,
            "solution": "# d - money difference\n# l[i][0] - money\n# l[i][1] - friendship factor\nn, d = input().split()\nn, d = int(n), int(d)\nl = []\nfor _ in range(n):\n    x = input().split()\n    l.append((int(x[0]),int(x[1])))\n\ndef key(pair):\n    return pair[0]\n\nl.sort(key = key)\n\n\ni = 0\nj = 0\nsum = 0\nmax = 0\nwhile i < n and j < n:\n    if l[j][0] - l[i][0] >= d:\n        sum -= l[i][1]\n        i-=-1\n    else:\n        sum += l[j][1]\n        j-=-1\n    if sum > max:\n        max = sum\nprint(max)"
        },
        {
            "language": 3,
            "solution": "n, d = [int(i) for i in input().split()]\na = [0] * n\nfor i in range(n):\n    a[i] = [int(j) for j in input().split()]\na.sort()\ni = 0; j = 0; ans = 0\nc = 0\nfor j in range(0, n):\n    if (j > 0):\n        c -= a[j - 1][1]\n    while (i < n):\n        if a[i][0] - a[j][0] < d:\n            c += a[i][1]\n            i += 1\n        else:\n            break\n    ans = max(c, ans)\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long, long long> > A;\nlong long n, d, a, b, ps = 1, ans;\nlong long pre[100001];\nint main() {\n  cin >> n >> d;\n  A.push_back({0, 0});\n  for (int i = 1; i <= n; i++) {\n    cin >> a >> b;\n    A.push_back({a, b});\n  }\n  sort(A.begin(), A.end());\n  for (int i = 1; i <= n; i++) {\n    pre[i] = pre[i - 1] + A[i].second;\n    if (A[i].first - A[ps].first >= d) {\n      while (1) {\n        ps++;\n        if (A[i].first - A[ps].first < d) break;\n      }\n    }\n    ans = max(ans, pre[i] - pre[ps - 1]);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class T {\n\n\t\n\tstatic class Tuple implements Comparable<Tuple>{\n\t\tint m, f;\n\t\t\n\t\tpublic Tuple(int ii, int jj) {\n\t\t\tm = ii;\n\t\t\tf = jj;\n\t\t}\n\n\t\tpublic int compareTo(Tuple o) {\n\t\t\tif(m < o.m) return -1;\n\t\t\tif(o.m < m) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\treturn \"{\"+m + \", \" + f+\"}\";\n\t\t}\n\t}\n\t\n\tstatic Tuple[] friend;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint d = in.nextInt();\n\t\t\n\t\tfriend = new Tuple[n];\n\t\t\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfriend[i] = new Tuple(in.nextInt(), in.nextInt());\n\t\t}\n\t\tArrays.sort(friend);\n\t\t\n\t\tint i, j;\n\t\ti = 0; j = 0;\n\t\tlong sum = 0;\n\t\tlong max = sum;\n\t\twhile( i < n && j < n) {\n\t\t\tif(i == j) {\n\t\t\t\tsum += friend[j++].f;\n\t\t\t\tmax = Math.max(max, sum);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(friend[j].m - friend[i].m >= d) {\n\t\t\t\t\tsum -= friend[i++].f;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsum+= friend[j++].f;\n\t\t\t\t\tmax = Math.max(max, sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\narr = sorted(list(map(int, input().split())) for _ in range(n))\ns, max_s, i = 0, 0, 0\nfor j in range(n):\n    s += arr[j][1]\n    while arr[j][0] - arr[i][0] >= d:\n        s -= arr[i][1]\n        i += 1\n    max_s = max(max_s, s)\nprint(max_s)\n\t\t \t\t\t\t \t\t\t\t\t  \t \t  \t   \t \t\t  \t"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\nimport atexit\nimport io\nimport sys\n\n_I_B = sys.stdin.read().splitlines()\ninput = iter(_I_B).__next__\n_O_B = io.StringIO()\nsys.stdout = _O_B\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_O_B.getvalue())\n\n\ndef main():\n    n,d=map(int,input().split())\n    a=[]\n    for i in range(n):\n        a.append(tuple(map(int,input().split())))\n    a.sort()\n    l=0\n    r=0\n    ff=0\n    mff=0\n    while l<=r and r<n:\n        if a[r][0]-a[l][0]<d:\n            ff+=a[r][1]\n            mff=max(ff,mff)\n            r+=1\n        else:\n            ff-=a[l][1]\n            l+=1\n    print(mff)\n        \n\n\nif __name__=='__main__':\n    main()"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\narr = []\nfor i in range(n):\n    arr.append(list(map(int,input().split())))\narr.sort(key = lambda arr:arr[0])\nmaxx = 0\nleft = 0\nright = 0\ncurr = 0\nwhile right <n and left<n:\n    if abs(arr[left][0]-arr[right][0]) <d:\n        curr += arr[right][1]\n        right+=1\n    else:\n        curr -= arr[left][1]\n        left+=1\n    maxx=max(curr,maxx)\nprint (maxx)\n"
        },
        {
            "language": 3,
            "solution": "n, d = [int(i) for i in input().split()]\nfriends = [[0, 0] for i in range(n)]\nfor i in range(n):\n    a = input().split()\n    friends[i][0] = int(a[0])\n    friends[i][1] = int(a[1])\n\nfriends.sort()\nl = 0\nr = 0\nresult = 0\nadd = 0\n\nwhile (l < n and r < n):\n    while (r < n and ((friends[r][0] - friends[l][0]) < d)):\n        add += friends[r][1]\n        r += 1\n    result = max(result, add)\n    add -= friends[l][1]\n    l += 1\n\nprint(result)"
        },
        {
            "language": 4,
            "solution": "//Number theory -1\n//DSU -1,\n//Div 2C @unsolved-44,45,47,50,53,54,55\n//graph -1,2,3    @unsolved-540C,4D,295B,526B,500B,682C,506D,103B,329B,161D;\n//complete search --NA;\n//binary search -1,2,3 @unsolved-                      \n//DP - 1, 2(ongoing);@unsolved-289B,446A,467C,158D,676C,166E,553A,118D,611C,518D,602B;\n//combinatorics-\n//Two pointer-1,2,3\n\nimport java.util.*;\nimport java.io.*;\npublic class CF580B\n{    //*****************************************    VARIABLE DECLERATION SECTION   ********************************************************************;\n         //Integer ArrayList Math TreeMap TreeSet\n         // System.out.println\n     long a,b;\n     CF580B(long x,long y)\n     {\n        a=x;b=y;\n     }\n\n    //*****************************************    VARIABLE DECLERATION ENDS   ********************************************************************;\n\n    //************************************************   MAIN FUNCTION  *************************************************************************; \n    public static void main(String[] args) \n    {   \n         FastReader scan=new FastReader();\n         int n=scan.nextInt();\n         long d=scan.nextLong();\n         //Point[] arr1=new Point[n+1];\n         CF580B[] arr=new CF580B[n+1];\n         arr[0]=new CF580B(0,0);\n         for(int i=1;i<=n;i++)\n         {\n            long a=scan.nextInt();\n            long b=scan.nextInt();\n            arr[i]=new CF580B(a,b);\n\n         }\n         Arrays.sort(arr,new Comp());\n         for(int i=1;i<=n;i++)\n         {\n           arr[i].b+=arr[i-1].b ; \n         }\n         /*for(int i=1;i<=n;i++)\n            System.out.println(\">>>\"+arr[i].a+\" \"+arr[i].b);*/\n        int l=1,r=1;\n        long sum=0;\n        while(r<=n&&l<=n)\n        {   \n             while(r<=n&&arr[r].a-arr[l].a<d)r++;\n             sum=Math.max(sum,arr[r-1].b-arr[l-1].b);\n             l++;\n        }\n        System.out.println(sum);\n        \n         \n\n     \n\n    }\n    //***********************************************  MAIN FUNCTION ENDS   *********************************************************************;\n\n    //**********************************************   AUXILIARY FUNCTIONS  **********************************************************************;\n    /*static void func()\n    {\n\n    }*/\n    //**********************************************   AUXILIARY FUNCTIONS  ENDS  **********************************************************************;\n\n    //**********************************************   INPUT FUNCTIONS     ******************************************************************************;\n       static class FastReader\n    {   BufferedReader br;   StringTokenizer st;\n        public FastReader()\n        {  br = new BufferedReader(new  InputStreamReader(System.in)); }\n        String next()\n        {    while (st == null || !st.hasMoreElements())\n            {    try\n                {  st = new StringTokenizer(br.readLine()); }\n                catch (IOException  e)\n                {  e.printStackTrace(); }\n            }\n            return st.nextToken();\n        }\n        int nextInt()\n        {   return Integer.parseInt(next()); }\n        long nextLong()\n        {   return Long.parseLong(next()); }\n        double nextDouble()\n        {  return Double.parseDouble(next()); }\n        String nextLine()\n        { String str = \"\";\n            try\n            {     str = br.readLine(); }\n            catch (IOException e)\n            {     e.printStackTrace(); }\n            return str;\n        }\n    }\n    //**********************************************   INPUT FUNCTIONS     ******************************************************************************;\n}\nclass Comp implements Comparator<CF580B>\n{\n    public int compare(CF580B o1,CF580B o2)\n    {\n        if(o1.a<o2.a)return -1;\n        if(o1.a>o2.a)return 1;\n        return 0;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "def find_index(arr, num, low, high, best):\n    mid = (low + high) // 2\n    if low > high:\n        return  best\n    if arr[mid][0] >= num:\n        return find_index(arr, num, low, mid - 1, best)\n    return find_index(arr, num, mid + 1, high, mid)\nn, d = map(int, input().split())\narr = [tuple(map(int, input().split())) for _ in range(n)]\narr.sort(key = lambda x: x[0])\ns = [arr[0][1]]\nans = 0\nfor i in range(1, n):\n    s.append(s[i - 1] + arr[i][1])\ns += [0]\nfor i in range(n):\n    j = find_index(arr, arr[i][0] + d, i, n - 1, i)\n    ans = max(ans, s[j] - s[i - 1])\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\na=[]\nfor i in range(n):\n    a.append([int(i) for i in input().split()])\na.sort()\nmoney = 0 ; f = a[0][1] ; ff=[]\nfor i in range(1,n):\n    if a[i][0]<a[money][0]+d:\n        f+=a[i][1]\n    else:\n        ff.append(f)\n        while a[i][0]>=a[money][0]+d:\n            f-=a[money][1]\n            money+=1\n        f+=a[i][1]\nff.append(f)\nprint(max(ff))\n        \n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct s {\n  long long a, b;\n} v[123456];\nbool cmp(s a, s b) { return a.a < b.a; }\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) cin >> v[i].a >> v[i].b;\n  sort(&v[0], &v[n], cmp);\n  long long mx = 0, p = 0, now = 0;\n  for (int i = 0; i < n; i++) {\n    while (v[i].a - v[p].a >= m) {\n      now -= v[p].b;\n      p++;\n    }\n    now = now + v[i].b;\n    mx = max(mx, now);\n  }\n  cout << mx << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long n = 0;\n  long d = 0;\n  cin >> n;\n  cin >> d;\n  struct fr {\n    long money;\n    long friendship;\n  };\n  vector<fr> friends;\n  friends.reserve(n);\n  auto c = n;\n  while (c--) {\n    fr nf;\n    cin >> nf.money;\n    cin >> nf.friendship;\n    friends.push_back(nf);\n  }\n  sort(begin(friends), end(friends), [](const fr& lhs, const fr& rhs) {\n    if (lhs.money != rhs.money) return (lhs.money < rhs.money);\n    return (lhs.friendship > rhs.friendship);\n  });\n  long long sum = 0;\n  long long maxSum = 0;\n  long long minMoneyIndex = 0;\n  for (size_t i = 0; i < friends.size(); ++i) {\n    while ((friends[i].money - friends[minMoneyIndex].money) >= d) {\n      sum -= friends[minMoneyIndex].friendship;\n      ++minMoneyIndex;\n    }\n    sum += friends[i].friendship;\n    maxSum = max(sum, maxSum);\n    if (sum < 0) sum = 0;\n  }\n  cout << maxSum << \"\\n\";\n};\n"
        },
        {
            "language": 3,
            "solution": "def binarySearch(alist, value):\n    first = 0\n    last = len(alist)-1\n    while first <= last:\n        midpoint = (first + last)//2\n        if value >= alist[midpoint][\"m\"] and value < alist[midpoint + 1][\"m\"]:\n            return midpoint\n        else:\n            if value >= alist[midpoint+1][\"m\"]:\n                first = midpoint+1\n            else:\n                if value < alist[midpoint][\"m\"]:\n                    last = midpoint-1\n    return 10**10\n\n\n[n, d] = list(map(int, input().split(\" \")))\na = []\nfor i in range(n):\n    [m, s] = list(map(int, input().split(\" \")))\n    a.append({\"m\": m, \"s\": s})\na.sort(key=lambda x: x[\"m\"])\na.append({\"m\": 10**10, \"s\": 0})\n\nt = [a[0][\"s\"]]\nfor i in range(1, n+1):\n    t.append(t[i-1] + a[i][\"s\"])\n\nm = 0\nfor i in range(n):\n    v = a[i][\"m\"]+d-1\n    e = binarySearch(a, v)\n    r = t[e] - (0 if i == 0 else t[i-1])\n    m = max(m,r)\nprint(m)\n"
        },
        {
            "language": 1,
            "solution": "R=lambda:map(int,raw_input().split())\nn,k=R()\nfs=sorted([R() for _ in range(n)])+[[2*10**9+1,0]]\nr=s=ans=0\nfor i in range(n):\n    while fs[r][0]<fs[i][0]+k: \n        s+=fs[r][1]\n        r+=1\n    s-=fs[i-1][1]\n    ans=max(ans,s)\n    if r>=n: break\nprint ans"
        },
        {
            "language": 3,
            "solution": "\nimport math\n\ns = input().split()\nn, d = int(s[0]), int(s[1])\nms = []\nfor _ in range(n):\n    st = input().split()\n    if int(st[1]):\n        ms.append((int(st[0]), (int(st[1]))))\n\nms = sorted(ms, key=lambda i: i[0])\nm, s = [], []\nfor i in ms:\n    m.append(i[0])\n    s.append(i[1])\n\nssums = [0]\nfor i in s:\n    ssums.append(ssums[-1] + i)\n# ssums.append(ssums[-1])\nmaxsSum = 0\niOverMaxEl = 1\nfor iMinEl in range(len(m)):\n    if iOverMaxEl <= iMinEl:\n        iOverMaxEl = iMinEl + 1\n    while iOverMaxEl < len(s) and m[iOverMaxEl] - m[iMinEl] < d:\n        iOverMaxEl += 1\n    sSum = ssums[iOverMaxEl] - ssums[iMinEl]\n    # sSum = sum(s[iMinEl: iOverMaxEl])\n    if sSum > maxsSum:\n        maxsSum = sSum\n\nprint(maxsSum)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\n\npublic class Main {\n\t\n\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\n\t\tint n=Integer.parseInt(st.nextToken());\n\t\tint d = Integer.parseInt(st.nextToken());\n\t\tTreeMap<Integer,Long> tm = new TreeMap<Integer,Long>();\n\t\tlong res =0;\n\t\tfor (int i =0; i<n; i++){\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint fri_Mon = Integer.parseInt(st.nextToken());//Money each friend has\n\t\t\tint fri_d= Integer.parseInt(st.nextToken()); // friend factor for each friend\n\t\t\tif (tm.containsKey(fri_Mon)){\n\t\t\t\t//this if-statement assigning the money to the factor, and since the tree\n\t\t\t\t//doesn't have duplication, if the same value was added\n\t\t\t\t//only the factor is updated with the new d\n\t\t\t\tlong temp = fri_d+tm.get(fri_Mon);\n\t\t\t\ttm.put(fri_Mon, temp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttm.put(fri_Mon,(long) fri_d);//if no same value was added\n\t\t\t}\n\t\t}\n\t\tObject[] a;\n\t\ta= tm.keySet().toArray();//this array has the money values in order\n\t\tres = tm.get(a[0]);//result initially has the factor (value) of the first frien's money(key)\n\t\tlong max = res;\n\t\tint leftdx = 0;\n\t\tint left = (int)a[leftdx];\n\t\tfor (int i = 1;i<a.length;i++){\n\t\t\tint right = (int)a[i];\n\t\t\tif ((right-left)<d){\n\t\t\t\tmax+=tm.get(a[i]);\n\t\t\t}\n\t\t\t\n\t\t\telse{\n\t\t\t\tmax+=tm.get(a[i]);\n\t\t\t\twhile(right-(int)a[leftdx]>=d){\n\t\t\t\t\tmax-=tm.get((int)a[leftdx]);\n\t\t\t\t\tleftdx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (max>res)res = max;\n\t\t}\n\t\tSystem.out.print(res);\n\t}\n\t\n}\n"
        },
        {
            "language": 3,
            "solution": "\n\ndef max_friendship_factor(friends, min_money_diff):\n    sorted_friends = sorted(friends, key=lambda t: t[0])\n\n    n = len(friends)\n    _, ff_sum = sorted_friends[0]  # set first elements ff to ff_sum\n    max_ff_sum = ff_sum  # and max_ff_sum\n\n    head_index = 0\n    hm, hff = sorted_friends[0]  # set head money and head ff\n    for i in range(1, n):\n        m, ff = sorted_friends[i]\n        ff_sum += ff\n        while abs(m - hm) >= min_money_diff:\n            # push head forwards\n            ff_sum -= hff\n            head_index += 1\n            hm, hff = sorted_friends[head_index]\n        if max_ff_sum < ff_sum:\n            max_ff_sum = ff_sum\n\n    return max_ff_sum\n\n\ndef run_alg():\n    first_line_data = input().split(' ')\n    num_friends = int(first_line_data[0])\n    min_money_diff = int(first_line_data[1])\n\n    friends = []\n    for _ in range(num_friends):\n        line_data = input().split(' ')\n        money = int(line_data[0])\n        friendship = int(line_data[1])\n        friends.append((money, friendship))\n    print(max_friendship_factor(friends, min_money_diff))\n\n\nif __name__ == '__main__':\n    run_alg()\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int,input().split())\nfriends=[[] for i in range(n)]\nfor i in range(n):\n    m,s=map(int,input().split())\n    friends[i] = [m,s]\nfriends.sort()\nli=[0]*n\ni,j=0,0\ntot = 0\nwhile i < n:\n    currI = friends[i]\n    tot += currI[1]\n    while currI[0] - friends[j][0] >= d:\n        tot -= friends[j][1]\n        j += 1\n    li[i] = tot\n    i += 1\nprint(max(li))\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Mouna Cheikhna\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int d = in.nextInt();\n\n            Friend[] friends = new Friend[n];\n            for (int i = 0; i < n; i++) {\n                friends[i] = new Friend(in.nextLong(), in.nextLong());\n            }\n\n            Arrays.sort(friends);\n            long maxSum = 0;\n            long currSum = 0;\n            int r = 0;\n            int l = 0;\n            while (l < n) {\n                while (r < n && friends[r].m - friends[l].m < d) {\n                    currSum += friends[r].s;\n                    r++;\n                }\n                maxSum = Math.max(maxSum, currSum);\n                currSum -= friends[l].s;\n                l++;\n            }\n            out.println(maxSum);\n        }\n\n        class Friend implements Comparable<Friend> {\n            long m;\n            long s;\n\n            Friend(long m, long s) {\n                this.m = m;\n                this.s = s;\n            }\n\n\n            public int compareTo(Friend o) {\n                if (m == o.m) {\n                    return Long.compare(s, o.s);\n                }\n                return Long.compare(m, o.m);\n            }\n\n\n            public String toString() {\n                return \"Friend{\" +\n                        \"m=\" + m +\n                        \", s=\" + s +\n                        '}';\n            }\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nfrom decimal import *\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [input() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [int(input()) for i in range(n)]\n\n\nclass Math():\n    @staticmethod\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return Math.gcd(b, a % b)\n\n    @staticmethod\n    def lcm(a, b):\n        return (a * b) // Math.gcd(a, b)\n\n    @staticmethod\n    def divisor(n):\n        res = []\n        i = 1\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                res.append(i)\n                if i != n // i:\n                    res.append(n // i)\n        return res\n\n    @staticmethod\n    def round_up(a, b):\n        return -(-a // b)\n\n    @staticmethod\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        d = int(n ** 0.5) + 1\n        for i in range(3, d + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n\nclass PriorityQueue:\n    def __init__(self, l=[]):\n        self.q = l\n        heapq.heapify(self.q)\n        return\n\n    def push(self, n):\n        heapq.heappush(self.q, n)\n        return\n\n    def pop(self):\n        return heapq.heappop(self.q)\n\n\ndef pop_count(x):\n    x = x - ((x >> 1) & 0x5555555555555555)\n    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    x = x + (x >> 32)\n    return x & 0x0000007f\n\n\nMOD = int(1e09) + 7\nINF = int(1e15)\n\n\ndef main():\n    # sys.stdin = open(\"sample.txt\")\n    N, D = Scanner.map_int()\n    M = [(0, 0) for _ in range(N)]\n    for i in range(N):\n        m, s = Scanner.map_int()\n        M[i] = (m, s)\n    M.sort()\n    r = 0\n    tmp = 0\n    ans = 0\n    for l in range(N):\n        while r < N and M[l][0] + D > M[r][0]:\n            tmp += M[r][1]\n            r += 1\n        ans = max(ans, tmp)\n        tmp -= M[l][1]\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct prieten {\n  int first, second;\n};\nprieten a[100002];\nint d;\nint main() {\n  int n, i, j;\n  long long lmax = 0;\n  pair<int, int> a[100002];\n  cin >> n >> d;\n  for (i = 1; i <= n; i++) cin >> a[i].first >> a[i].second;\n  sort(a + 1, a + n + 1);\n  j = 1;\n  long long sc = 0;\n  for (i = 1; i <= n; i++) {\n    sc += a[i].second;\n    while (j <= i && a[i].first - a[j].first >= d) {\n      sc -= a[j].second;\n      j++;\n    }\n    lmax = max(lmax, sc);\n  }\n  cout << lmax;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,d=map(int, input().split())\narr=[]\nfor i in range(n):\n    arr.append(tuple(map(int, input().split())))\narr=sorted(arr)\nprefix=[]\nprefix.append(arr[0][1])\nfor i in range(1,n):\n    prefix.append(prefix[i-1]+arr[i][1])\nans=0\nfor i in range(n):\n    low=0\n    high=n-1\n    while low<high:\n        mid=(low+high+1)//2\n        if arr[mid][0]>=arr[i][0]+d:\n            high=mid-1\n        else:\n            low=mid\n    if i==0:\n        ans=prefix[low]\n    elif prefix[low]-prefix[i-1]>ans:\n        ans=prefix[low]-prefix[i-1]\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.awt.List;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\npublic class B {\n\n\tpublic static void main(String[] args) {\n\t\tLocale.setDefault(Locale.US);\n\t\tInputStream inputstream = System.in;\n\t\tOutputStream outputstream = System.out;\n\t\tFastReader in = new FastReader(inputstream);\n\t\tPrintWriter out = new PrintWriter(outputstream);\n\t\tTaskA solver = new TaskA();\n\t\t// int testcase = in.ni();\n\t\tfor (int i = 0; i < 1; i++)\n\t\t\tsolver.solve(i, in, out);\n\t\tout.close();\n\n\t}\n\n}\n\nclass Pair {\n\tint coin;\n\tint frdship;\n\n\tpublic Pair() {\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n\tpublic Pair(int c, int f) {\n\t\tcoin = c;\n\t\tfrdship = f;\n\t}\n}\n\nclass TaskA {\n\n\tpublic void solve(int testnumber, FastReader in, PrintWriter out) {\n\n\t\tint n = in.ni();\n\t\tint d = in.ni();\n\t\t\n\t\tPair arr[] = new Pair[n];\n\t\tfor(int i =0;i<n;i++){\n\t\t\tarr[i] = new Pair(in.ni(), in.ni());\n\t\t}\n\t\t\n\t\tArrays.sort(arr, new Comparator<Pair>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\treturn o1.coin- o2.coin;\n\t\t\t}\n\t\t});\n\t\t\n\t\tint start = 0, end = 1;\n\t\t\n\t\tlong max = 0;\n\t\t\n\t\tlong current = arr[0].frdship;\n\t\t\n\t\twhile(start < arr.length){\n\t\t\t\n\t\t\twhile(end < arr.length && (arr[start].coin + d) > arr[end].coin){\n\t\t\t\tcurrent += arr[end].frdship;\n\t\t\t\tend++;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(current > max){\n\t\t\t\tmax = current;\n\t\t\t}\n\t\t\tcurrent -= arr[start].frdship;\n\t\t\tstart++;\n\t\t}\n\t\t\n\t\tout.println(max);\n\t}\n}\n\nclass FastReader {\n\tpublic InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic FastReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic FastReader() {\n\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int ni() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9') {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic String ns() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null) {\n\t\t\treturn filter.isSpaceChar(c);\n\t\t}\n\t\treturn isWhitespace(c);\n\t}\n\n\tpublic static boolean isWhitespace(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tpublic int[] iArr(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = ni();\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic String next() {\n\t\treturn ns();\n\t}\n\n\tpublic interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n\n}"
        },
        {
            "language": 3,
            "solution": "import sys\ndef fastio():\n    from io import StringIO\n    from atexit import register\n    global input\n    sys.stdin = StringIO(sys.stdin.read())\n    input = lambda : sys.stdin.readline().rstrip('\\r\\n')\n    sys.stdout = StringIO()\n    register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))\nfastio()\n\ndef debug(*var, sep = ' ', end = '\\n'):\n    print(*var, file=sys.stderr, end = end, sep = sep)\n\nINF = 10**20\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\nfrom math import gcd\nfrom math import ceil\nfrom collections import defaultdict as dd, Counter\nfrom bisect import bisect_left as bl, bisect_right as br\n\nn, d = I()\na = [(0, 0)]\nfor i in range(n):\n    x, y = I()\n    a.append((x, y))\na.sort()\nj = 0\nans = 0\ncur = 0\nfor i in range(1, n + 1):\n    cur += a[i][1]\n    while a[i][0] - a[j][0] >= d:\n        cur -= a[j][1]\n        j += 1\n    ans = max(ans, cur)\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "[n, d] = map(int, input().strip().split())\na = []\nfor i in range(n):\n    [m, f] = map(int, input().strip().split())\n    a.append((m, f))\n\na.sort()\nl, r = 0, 0\nSum = 0\nans = 0\nwhile(l < n):\n    while(r < n and a[r][0] - a[l][0] < d):\n        Sum += a[r][1]\n        r += 1\n    ans = max(ans, Sum)\n    Sum -= a[l][1]\n    l += 1\nprint(ans)\n"
        },
        {
            "language": 1,
            "solution": "n,d = map(int,raw_input().split())\nfr = []\nfor _ in xrange(n):\n    x,y = map(int,raw_input().split())\n    fr += [(x,y)]\nfr.sort()\ntemp  = []\nmx = 0\nmc = 0\ntc = 0\nfor i in fr:\n    temp+=[i]\n    tc+=i[1]\n    while((temp[-1][0]-temp[0][0]) >= d):\n        tc-=temp[0][1]\n        temp.pop(0)\n    mc = max(mc,tc)\nprint mc\n    \n"
        },
        {
            "language": 3,
            "solution": "\"Codeforces Round #260 (Div. 1)\"\n\"A. Boredom\"\n# def Boredom():\n#     y=int(input())\n#     a=list(map(int,input().split()))\n#     d={}\n#     for i in a:\n#         d.setdefault(i,0)\n#         d[i]+=1\n#     # print(d)    \n#     k=list(d.keys())\n#     k.sort()\n#     # print(k)\n#     l=len(k)\n#     k.append(0)\n#     d[0]=0\n#     sum=0\n#     if l==1:\n#         print(k[0]*d[k[0]])\n#         return\n#     z=x=0\n#     za=0    \n#     for i in range(l):\n#         # print(sum,z,x,k[i])\n#         z+=(1-za)*d[k[i]]*k[i]\n#         x+=za*(d[k[i]])*k[i]\n#         za=1-za\n#         if k[i]+1!=k[i+1]: \n#             sum+=max(z,x)\n#             z=x=0\n#     print(sum)\n#     return             \n       \n\n# Boredom()\n\"Codeforces Round #321 (Div. 2)\"\n\"B. Kefa and Company\"\ndef Kefa_and_Company():\n    n,dd=map(int,input().split())\n    d={}\n    for i in range(n):\n        z,x=map(int,input().split())\n        d.setdefault(z,0)\n        d[z]+=x\n    m=list(d.keys())\n    m.sort()\n    f=[0]\n    for i in m:\n        f.append(f[-1]+d[i])\n    f.pop(0)\n    # print(m)\n    # print(f)\n    i=j=0\n    ans=[]\n    l=len(m)\n    while True:\n        # print(i,j,m[i],m[j],ans)   \n        if m[j]-m[i]>=dd:\n            if i==0:\n                ans.append(f[j-1])\n            # elif j==l-1:\n            #     if m[j]-m[i-1]>dd:\n            #         ans.append(f[j]-f[i-1]) \n            #     else           \n            else:\n                ans.append(f[j-1]-f[i-1]) \n            i+=1\n        else:\n            if j==l-1:\n                if i==0:\n                    ans.append(f[j])\n                elif i==l-1:\n                    ans.append(f[j]-f[i-1])\n                else:\n                    ans.append(f[j]-f[i-1])                        \n                break\n            j+=1\n    ws=max(ans)\n    print(ws)\n    return\nKefa_and_Company()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Friend {\n  long long money, factor;\n};\nlong long d;\nvector<Friend> friends;\nbool hasInferiorityFeelings(int i, int k) {\n  if (k == 0) {\n    return false;\n  }\n  return friends[i + k - 1].money - friends[i].money >= d;\n}\nint main() {\n  int n;\n  cin >> n >> d;\n  friends.resize(n);\n  for (Friend &f : friends) {\n    cin >> f.money >> f.factor;\n  }\n  sort(friends.begin(), friends.end(),\n       [](Friend a, Friend b) { return a.money < b.money; });\n  vector<long long> partialSums(n + 1, 0);\n  for (int i = 0; i < n; i++) {\n    partialSums[i + 1] = partialSums[i] + friends[i].factor;\n  }\n  long long maxFriendship = 0;\n  for (int i = 0; i < n; i++) {\n    int l = 0, r = n - i;\n    while (l != r) {\n      int m = (l + r + 1) / 2;\n      if (!hasInferiorityFeelings(i, m)) {\n        l = m;\n      } else {\n        r = m - 1;\n      }\n    }\n    long long totalFriendship = partialSums[i + r] - partialSums[i];\n    maxFriendship = max(maxFriendship, totalFriendship);\n  }\n  cout << maxFriendship << '\\n';\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import namedtuple\nFriend = namedtuple(\"Friend\", \"money value\")\n\nn, d = map(int, input().split())\n\n# At first we sort all friends in money ascending order.\narr = []\nfor i in range(n):\n    money, value = map(int, input().split())\n    arr.append(Friend(money, value))\narr.sort()\n\n\nsss = arr[0].value # the answer is some sub segment sum of the array\nans = sss\n\n# Next, we use the method of two pointers for finding the required subsegment.\ntail = 0\nfor head in range(1, n): # range increases head\n    while (arr[head].money - arr[tail].money >= d): # while drags tail as necessary\n        sss -= arr[tail].value\n        tail += 1\n    sss += arr[head].value\n    ans = max(sss, ans)\nprint(ans)\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\n\ndef solution_oleksii():\n\n    n, d = map(int, next(sys.stdin).split())\n    a = sorted(map(int, l.split()) for l in sys.stdin)\n\n    j = 0\n    ans = 0\n    s = 0\n    for i in xrange(n):\n        s += a[i][1]\n        while j <= i and a[i][0] - a[j][0] >= d:\n            s -= a[j][1]\n            j += 1\n        ans = max(ans, s)\n\n    print ans\n\n\ndef radixsort(aList):\n    RADIX = 10\n    maxLength = False\n    tmp, placement = -1, 1\n\n    while not maxLength:\n        maxLength = True\n        buckets = [list() for _ in range(RADIX)]\n\n        for i in aList:\n            tmp = i[0] / placement\n            buckets[tmp % RADIX].append(i)\n            if maxLength and tmp > 0:\n                maxLength = False\n\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                aList[a] = i\n                a += 1\n\n        placement *= RADIX\n\n\ndef two_pointers(arr, d, n):\n    radixsort(arr)\n    max_ff = 0\n    r = 0\n    curr_ff = 0\n    for l in xrange(n):\n\n        while r < n and arr[r][0] - arr[l][0] < d:\n            curr_ff += arr[r][1]\n            r += 1\n\n        if max_ff < curr_ff:\n            max_ff = curr_ff\n\n        curr_ff -= arr[l][1]\n    return max_ff\n\n\ndef solution():\n    first_line = sys.stdin.readline()\n    n, d = map(int, first_line.split())\n\n    input_ = []\n    for i in range(n):\n        input_.append(tuple(map(int, sys.stdin.readline().split())))\n    if n == 1:\n        return input_[0][1]\n    else:\n        return two_pointers(input_, d, n)\n\nif __name__ == '__main__':\n\n    print solution()"
        },
        {
            "language": 4,
            "solution": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tstatic class pair{\n\t\tlong x,y;\n\t\tpair(long a,long b){\n\t\t\tx=a;\n\t\t\ty=b;\n\t\t}\n\t}\n\tstatic int find(long[] a, int low, int high, long element){\n    while(low < high){\n        int middle = low + (high - low)/2;\n        if(a[middle] > element)\n            high = middle;\n        else \n            low = middle + 1;\n    }\n    return low;\n}\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tlong d=sc.nextLong();\n\t\tlong money[]=new long[n];\n\t\tpair a[]=new pair[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tlong x=sc.nextLong(),y=sc.nextLong();\n\t\t\ta[i]=new pair(x,y);\n\t\t\tmoney[i]=x;\n\t\t}\n\t\tArrays.sort(money);\n\t\tArrays.sort(a,new Comparator<pair>(){\n\t\t\tpublic int compare(pair a,pair b){\n\t\t\t\treturn (int)(a.x-b.x);\n\t\t\t}\n\t\t});\n\t\tlong pre[]=new long[n];\n\t\tpre[0]=a[0].y;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tpre[i]=pre[i-1]+a[i].y;\n\t\t}\n\t\tlong max=pre[0];\n\t\tfor(int i=1;i<n;i++){\n\t\t\tlong m=a[i].x;\n\t\t\tint idx=find(money,0,n-1,m-d);\n\t\t\tlong val=pre[i]-(idx==0?0:pre[idx-1]);\n\t\t\tif(val>max) max=val;\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > v;\nint main() {\n  int n, d, x, y;\n  scanf(\"%d %d\", &n, &d);\n  for (int i = 0, _ = n; i < n; i++) {\n    scanf(\"%d %d\", &x, &y);\n    v.push_back(make_pair(x, y));\n  }\n  sort(v.begin(), v.end());\n  long long maxi = 0, sum = 0;\n  int i = 0, curr = 0;\n  for (int i = 0, _ = n; i < n; i++) {\n    sum += v[i].second;\n    while (v[i].first - v[curr].first >= d) {\n      sum -= v[curr].second;\n      curr++;\n    }\n    maxi = max(sum, maxi);\n  }\n  printf(\"%lld\\n\", maxi);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, d = map(int, raw_input().split())\nli=[]\nfor i in xrange(n):\n    li.append(map(int, raw_input().split()))\nli=sorted(li, key=lambda x:(x[0]))\nans=-1\ntemp=0\nr=0\nfor i in xrange(n):\n    while(r<n and (li[r][0]-li[i][0])<d):\n        temp+=li[r][1]\n        r+=1\n    if temp>ans:\n        ans=temp\n    temp-=li[i][1]\nprint ans\n"
        },
        {
            "language": 3,
            "solution": "class Dupla:\n    def __init__(self, money, factor):\n        self.money = money\n        self.factor = factor\n    def getMoney(self):\n        return self.money\n    def getFactor(self):\n        return self.factor\n    \n    def __repr__(self):\n        return ' - '.join(map(str,(self.money,self.factor)))\n    def __lt__(self, other):\n        return self.money < other.money\n\n\na = []\nn, d = map(int, input().split())\nfor i in range(n):\n    m, f = map(int, input().split())\n    t = Dupla(m, f)\n    a.append(t)\ns = sorted(a)\n\nmaxi1 = s[0].getFactor()\nmaxi2 = s[0].getFactor()\ni = 1\nj = 0\nwhile(i < n):\n    if(abs(s[j].getMoney() - s[i].getMoney()) < d):\n        maxi1 += s[i].getFactor() \n        i += 1 \n        if(maxi1 > maxi2):\n            maxi2 = maxi1\n    else:\n        maxi1 -= s[j].getFactor()\n        j += 1\nprint(maxi2)"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\nf = lambda: map(int, input().split())\nn, d = f()\nfriends = []\nfor i in range(n):\n    friends.append(tuple(f()))\nfriends.sort(key=lambda x: x[0])\nmax_s = 0\ntemp_s = friends[0][1]\nl, r = 0, 0\nwhile l < n and r < n:\n    if temp_s > max_s:\n        max_s = temp_s\n    if r + 1 < n and friends[l][0] + d > friends[r + 1][0]:\n        r += 1\n        temp_s += friends[r][1]\n    elif l == r and r + 1 < n:\n        l += 1\n        r += 1\n        temp_s = friends[l][1]\n    else:\n        l += 1\n        temp_s -= friends[l - 1][1]\nprint(max_s)\n"
        },
        {
            "language": 3,
            "solution": "n, d = map(int, input().split())\nfriends = sorted(tuple(map(int, input().split())) for _ in range(n))\nleft = sub_sum = max_sum = 0\n\nfor right in range(n):\n    sub_sum += friends[right][1]\n    \n    while friends[right][0] - friends[left][0] >= d:\n        sub_sum, left = sub_sum - friends[left][1], left + 1\n    \n    max_sum = max(sub_sum, max_sum)\n\nprint(max_sum)"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\n\npublic class Main {\n\n    static Parser in = new Parser(System.in);\n\n    static class Pair implements Comparable<Pair> {\n\n        final int u;\n        final int v;\n\n        public Pair(int u, int v) {\n            this.u = u;\n            this.v = v;\n        }\n\n        public int compareTo(Pair other) {\n            return u - other.u;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n\n\n\n        int n = in.nextInt(), diff = in.nextInt();\n        Pair arr[] = new Pair[n];\n        long sum = 0, maxi = 0;\n\n        for (int i = 0; i < n; i++) {\n            Pair p = new Pair(in.nextInt(), in.nextInt());\n            arr[i] = p;\n        }\n\n        Arrays.sort(arr);\n\n        for (int i = 0, j = 0; i < n; i++) {\n            while (j < n && arr[j].u - arr[i].u < diff) {\n                sum += arr[j].v;\n                j++;\n            }\n            maxi = Math.max(maxi, sum);\n            sum -= arr[i].v;\n        }\n\n        System.out.println(Math.max(maxi, sum));\n    }\n\n    static class Parser {\n        final private int BUFFER_SIZE = 2048;\n        private InputStream din;\n        private byte[] buffer;\n        private int bufferPointer;\n        private int bytesRead;\n\n        public Parser(InputStream in) {\n            din = in;\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public int nextInt() throws IOException {\n            int result = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            while (c >= '0' && c <= '9') {\n                result = result * 10 + c - '0';\n                c = read();\n            }\n            if (neg)\n                return -result;\n            return result;\n        }\n\n        public String readLine() throws IOException {\n            StringBuilder line = new StringBuilder();\n            char c;\n            while ((c = (char) (read())) != '\\n') {\n                line.append(c);\n            }\n            return line.toString();\n        }\n\n        public byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "l = list(map(int, input().rstrip().split()))\na=[]\nfor i in range(l[0]):\n    k = list(map(int, input().rstrip().split()))\n    a.append(k)\na.sort()\nend=0\nstrat=0\ntrust=0\nsubtrust=0\nk=0\nwhile(end<len(a)):\n    if abs(a[strat][0]-a[end][0])<l[1]:\n        subtrust+=a[end][1]\n        end += 1\n        trust=max(trust,subtrust)\n    else:\n        subtrust -= a[strat][1]\n        strat+=1\nprint(trust)\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin,stdout\nn,d=map(int,input().split())\nl=[]\nfor i in range(n):\n    l.append(list(map(int,stdin.readline().split())))\nl.sort()\nfrom bisect import bisect_left\nans=0\nl1=[0]\nf=0\nfor i in l:\n    f+=i[1]\n    l1.append(f)\nfor i in range(1,n+1):\n    x=bisect_left(l,[l[i-1][0]+d,0])\n    ans=max(ans,l1[x]-l1[i-1])\nprint(ans)\n    \n\n                \n                \n    \n"
        },
        {
            "language": 4,
            "solution": "/*\n * Code Author: Sanket Udgirkar.\n * DA-IICT\n */\nimport java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\n\t\tint n=s.nextInt();\n\t\tint d=s.nextInt();\n\t\t\n\t\tPair p[] = new Pair[n];\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tint m=s.nextInt();\n\t\t\tint f=s.nextInt();\n\t\t\tp[i]=new Pair(m,f);\n\t\t}\n\t\t\n\t\tArrays.sort(p);\n\t\t\n\t\tint curr=0;\n\t\tlong ans=0;\n\t\tlong temp=0;\n\t\t\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\twhile(p[i].f-p[curr].f>=d)\n\t\t\t{\n\t\t\t\ttemp=temp-p[curr].s;\n\t\t\t\tcurr++;\n\t\t\t}\n\t\t\ttemp=temp+p[i].s;\n\t\t\tans=Math.max(ans, temp);\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n\t\n\tstatic int gcd(int a,int b)\n\t{\n\t\tif(b==0)\n\t\t\treturn a;\n\t\ta%=b;\n\t\treturn gcd(b,a);\n\t}\n\t\n\tstatic long exp(long a, long b)\n\t{\n\t\tif(b==1)\n\t\t\treturn a;\n\t\tif(b==2)\n\t\t\treturn a*a;\n\t\t\n\t\tif(b%2==0)\n\t\t\treturn exp(exp(a,b/2),2);\n\t\telse\n\t\t\treturn a*exp(exp(a,(b-1)/2),2);\n\t}\n\t\n\tstatic void quicksort(int arr[],int low, int high)\n\t{\n\t\tint i=low;\n\t\tint j=high;\n\t\tint pivot=arr[(high+low)/2];\n\t\tint temp;\n\t\t\n\t\twhile(i<=j)\n\t\t{\n\t\t\twhile(arr[i]<pivot)\n\t\t\t\ti++;\n\t\t\twhile(arr[j]>pivot)\n\t\t\t\tj--;\n\t\t\n\t\t\tif(i<=j)\n\t\t\t{\n\t\t\t\ttemp=arr[i];\n\t\t\t\tarr[i]=arr[j];\n\t\t\t\tarr[j]=temp;\n\t\t\t\t\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(low<j)\n\t\t\tquicksort(arr, low, j);\n\t\tif(i<high)\n\t\t\tquicksort(arr, i, high);\n\t}\n\n\tstatic class Pair implements Comparable<Pair>\n\t{\n\t\tlong f,s;\n\t\tPair(long ii, long cc)\n\t\t{\n\t\t\tf=ii;\n\t\t\ts=cc;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Pair o) \n\t\t{\n\t\t\treturn Long.compare(this.f, o.f);\n\t\t}\n\t\t\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom bisect import bisect_right\nfrom itertools import accumulate\n\n\ndef main():\n    n, d = map(int, input().split())\n    friends = sorted(tuple(int(c) for c in line.split()) for line in sys.stdin)\n    money = [e[0] for e in friends]\n\n    friendship_sum = [0] + list(accumulate(e for _, e in friends))\n\n    start = 0\n    _min, ans = friends[0]\n\n    for i in range(1, n):\n        cur = friends[i][0]\n        if cur - _min >= d:\n            start = bisect_right(money, cur - d)\n            _min = friends[start][0]\n\n        friendship = friendship_sum[i + 1] - friendship_sum[start]\n        ans = max(ans, friendship)\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 3,
            "solution": "a,b=map(int,input().split())\nx=[[0,0]]\nmx=0\nc1=1\nc2=1\nfor i in range(a):\n    x.append(list(map(int,input().split())))\nx.sort()\n\nfor i in range(1,a+1):\n    x[i][1]=x[i-1][1]+x[i][1]\n\n\nfor c1 in range(0,a+1):\n    c2=max(c1,c2)\n    while c2<a+1 and x[c2][0]<x[c1][0]+b:\n        c2+=1\n    mx=max(mx,x[c2-1][1]-x[c1-1][1])\n    if mx==19:\n        print(c2,c1)\nprint(mx)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  long long int t, n, i, d, x, y, st = 0, e = 0;\n  long long int sum = 0, ans = 0;\n  cin >> n >> d;\n  vector<pair<long long int, long long int> > v;\n  for (i = 0; i < n; i++) {\n    cin >> x >> y;\n    v.push_back({x, y});\n  }\n  sort(v.begin(), v.end());\n  while (e < n) {\n    if (v[e].first - v[st].first < d)\n      sum += v[e].second, e++;\n    else if (st < e)\n      sum -= v[st].second, st++;\n    ans = max(ans, sum);\n  }\n  cout << ans << endl;\n}\n"
        }
    ]
}