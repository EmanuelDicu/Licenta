{
    "name": "1549_D. Integers Have Friends",
    "source": "CODEFORCES",
    "description": "British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that \"every positive integer was one of his personal friends.\"\n\nIt turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. \n\nDefine a subarray a_i, a_{i+1}, \u2026, a_j to be a friend group if and only if there exists an integer m \u2265 2 such that a_i mod m = a_{i+1} mod m = \u2026 = a_j mod m, where x mod y denotes the remainder when x is divided by y.\n\nYour friend Gregor wants to know the size of the largest friend group in a.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c5 10^4). \n\nEach test case begins with a line containing the integer n (1 \u2264 n \u2264 2 \u22c5 10^5), the size of the array a.\n\nThe next line contains n positive integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.\n\nIt is guaranteed that the sum of n over all test cases is less than 2\u22c5 10^5.\n\nOutput\n\nYour output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.\n\nExample\n\nInput\n\n\n4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 2000\n8\n465 55 3 54 234 12 45 78\n\n\nOutput\n\n\n3\n3\n2\n6\n\nNote\n\nIn the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.\n\nIn the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.\n\nIn the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.",
    "difficulty": "D",
    "tags": [
        "binary search",
        "data structures",
        "math",
        "two pointers"
    ],
    "rating": 1800,
    "public_test": [
        {
            "input": "4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 2000\n8\n465 55 3 54 234 12 45 78\n",
            "output": "3\n3\n2\n6\n"
        }
    ],
    "generated_test": [
        {
            "input": "1\n3\n1 137438953474 335417888009\n",
            "output": "2\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 256 262 268 274 280 286 462 298 304 310 316 322 328 334 340 346 352 358 364 370 376 382 388 391 397 403\n",
            "output": "66\n"
        },
        {
            "input": "1\n20\n1 3 5 7 9 11 13 15 17 19 22 25 28 31 66 37 40 43 46 49\n",
            "output": "10\n"
        },
        {
            "input": "1\n20\n16 15 17 8 30 23 20 28 27 6 1 5 24 2 10 5 14 29 12 7\n",
            "output": "3\n"
        },
        {
            "input": "3\n3\n14 4 27\n13\n26 14 6 10 5 3 29 2 24 12 22 11 1\n4\n10 37 29 11\n",
            "output": "2\n4\n3\n"
        },
        {
            "input": "4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 1881\n8\n465 55 3 54 234 12 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "3\n3\n14 4 27\n13\n26 14 6 10 5 3 29 2 24 12 22 11 1\n4\n10 37 29 22\n",
            "output": "2\n4\n2\n"
        },
        {
            "input": "1\n20\n16 15 20 8 30 23 20 28 27 5 1 5 24 2 10 5 14 29 12 7\n",
            "output": "4\n"
        },
        {
            "input": "3\n3\n14 4 36\n13\n26 14 6 10 5 3 13 2 24 12 22 11 1\n4\n10 37 29 22\n",
            "output": "3\n4\n2\n"
        },
        {
            "input": "4\n5\n0 7 2 8 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 234 5 45 78\n",
            "output": "3\n3\n2\n3\n"
        },
        {
            "input": "4\n5\n0 9 2 8 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 215 5 45 59\n",
            "output": "3\n3\n2\n4\n"
        },
        {
            "input": "4\n5\n0 9 2 3 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 215 5 45 59\n",
            "output": "2\n3\n2\n4\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 172 5 45 59\n",
            "output": "2\n3\n2\n3\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 5 8\n2\n1000 2150\n8\n651 55 3 54 172 5 45 59\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "5\n1\n13\n1\n1\n6\n7 19 28 25 6 10\n3\n3 19 10\n9\n26 1 28 8 24 27 12 16 17\n",
            "output": "1\n1\n4\n2\n3\n"
        },
        {
            "input": "1\n69\n2 4 7 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 256 262 268 274 280 286 292 298 304 310 316 322 328 334 340 346 352 358 364 370 376 382 388 391 397 403\n",
            "output": "68\n"
        },
        {
            "input": "1\n20\n1 3 5 7 9 11 13 15 17 19 22 25 28 31 34 37 22 43 46 49\n",
            "output": "11\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 279 232 238 244 250 256 262 268 274 280 286 462 298 304 310 316 322 328 334 340 346 352 358 364 370 376 382 388 391 397 403\n",
            "output": "38\n"
        },
        {
            "input": "1\n20\n1 3 5 7 9 11 2 15 17 19 22 25 28 31 66 37 40 43 46 49\n",
            "output": "6\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 394 256 465 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 358 364 370 376 382 388 391 397 286\n",
            "output": "44\n"
        },
        {
            "input": "3\n3\n14 4 36\n13\n26 14 6 10 5 3 13 2 24 12 22 11 1\n4\n17 37 29 22\n",
            "output": "3\n4\n3\n"
        },
        {
            "input": "4\n5\n0 7 2 8 6\n4\n4 2 5 10\n2\n1000 2150\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n2\n2\n6\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 5 8\n2\n1000 2150\n8\n501 55 3 51 172 5 45 59\n",
            "output": "2\n2\n2\n4\n"
        },
        {
            "input": "1\n69\n2 4 7 16 20 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 256 262 268 274 280 286 292 298 304 310 316 322 328 334 340 346 352 358 364 370 376 382 388 391 397 403\n",
            "output": "64\n"
        },
        {
            "input": "4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 2000\n8\n465 48 3 54 234 0 45 78\n",
            "output": "3\n3\n2\n8\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 54 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 256 262 268 274 280 286 462 298 304 310 316 322 328 334 111 346 352 358 364 370 376 382 388 391 397 286\n",
            "output": "57\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 263 190 196 202 208 214 220 226 232 238 244 394 256 465 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 358 364 370 376 382 388 391 397 286\n",
            "output": "31\n"
        },
        {
            "input": "4\n5\n0 11 2 8 6\n4\n8 0 6 10\n2\n1000 2150\n8\n651 55 3 54 215 5 45 78\n",
            "output": "3\n4\n2\n3\n"
        },
        {
            "input": "4\n5\n0 9 2 8 6\n4\n8 0 7 10\n2\n1000 2150\n8\n862 55 3 54 215 5 45 59\n",
            "output": "3\n2\n2\n4\n"
        },
        {
            "input": "4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 2000\n8\n107 48 3 54 234 0 45 78\n",
            "output": "3\n3\n2\n7\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 92 43 70 76 82 88 94 100 106 112 118 124 130 200 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 256 262 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 358 364 370 376 382 388 391 397 403\n",
            "output": "54\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 25 76 82 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 263 190 196 202 208 214 220 226 232 238 244 394 256 465 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 358 364 370 376 382 388 391 397 286\n",
            "output": "30\n"
        },
        {
            "input": "4\n5\n1 8 2 4 6\n4\n8 2 5 10\n2\n1010 279\n8\n465 55 3 54 234 15 45 78\n",
            "output": "4\n3\n2\n6\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 4 10\n2\n1100 2150\n8\n651 55 3 42 172 5 45 59\n",
            "output": "2\n4\n2\n4\n"
        },
        {
            "input": "4\n5\n1 9 2 4 6\n4\n8 0 5 8\n2\n1000 2150\n8\n501 55 0 51 172 5 45 59\n",
            "output": "3\n2\n2\n3\n"
        },
        {
            "input": "1\n69\n1 4 7 16 20 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 336 262 268 274 280 286 292 298 304 310 316 322 328 334 340 346 352 358 364 370 376 382 388 391 397 403\n",
            "output": "63\n"
        },
        {
            "input": "3\n3\n14 4 27\n13\n26 14 6 10 5 2 10 2 24 6 22 11 1\n4\n10 25 29 11\n",
            "output": "2\n6\n3\n"
        },
        {
            "input": "4\n5\n1 3 2 4 6\n4\n0 2 5 10\n2\n1000 2150\n8\n465 55 1 54 234 15 45 78\n",
            "output": "3\n2\n2\n5\n"
        },
        {
            "input": "4\n5\n0 8 2 4 6\n4\n8 2 5 10\n2\n1010 279\n8\n465 55 3 54 234 15 45 78\n",
            "output": "5\n3\n2\n6\n"
        },
        {
            "input": "4\n5\n1 5 3 4 6\n4\n8 2 5 10\n2\n1000 2000\n8\n107 48 3 54 234 0 56 78\n",
            "output": "3\n3\n2\n5\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 32 154 160 166 172 178 184 190 323 202 208 214 220 5 232 238 244 250 256 262 268 274 280 286 866 298 304 310 316 322 328 334 340 346 352 358 364 370 376 382 388 391 397 403\n",
            "output": "33\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 25 76 82 88 94 110 106 112 118 124 130 136 142 148 154 160 166 172 178 263 190 196 202 208 214 283 226 232 238 244 394 256 465 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 358 364 370 376 382 388 391 397 286\n",
            "output": "21\n"
        },
        {
            "input": "4\n5\n0 8 3 4 6\n4\n8 2 5 10\n2\n1010 279\n8\n465 55 3 54 234 15 45 78\n",
            "output": "2\n3\n2\n6\n"
        },
        {
            "input": "1\n20\n1 3 10 11 9 17 1 15 17 19 22 25 28 56 34 37 22 43 46 49\n",
            "output": "7\n"
        },
        {
            "input": "3\n3\n14 4 27\n13\n26 14 6 10 5 2 10 2 24 6 22 20 1\n4\n10 25 33 11\n",
            "output": "2\n7\n3\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 32 154 257 166 172 178 184 190 323 202 208 214 220 5 232 238 244 250 256 262 268 274 280 286 866 298 304 310 316 322 328 334 340 346 352 358 364 370 376 382 388 391 397 403\n",
            "output": "27\n"
        },
        {
            "input": "4\n5\n0 7 2 4 3\n4\n8 1 2 10\n2\n1010 2150\n8\n465 55 3 96 234 15 45 57\n",
            "output": "2\n2\n2\n6\n"
        },
        {
            "input": "1\n69\n1 4 7 16 20 28 34 40 46 52 58 64 70 76 136 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 336 262 268 274 280 286 292 298 304 310 316 322 401 334 340 346 352 134 364 370 376 382 388 391 397 403\n",
            "output": "52\n"
        },
        {
            "input": "3\n3\n14 7 27\n13\n26 3 4 10 5 3 29 2 24 12 31 15 1\n4\n10 37 29 16\n",
            "output": "2\n3\n2\n"
        },
        {
            "input": "1\n69\n1 4 7 16 20 28 34 40 46 52 58 64 70 76 136 88 94 100 106 112 118 124 130 170 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 336 262 268 274 280 286 292 298 55 310 316 322 401 334 340 346 352 134 364 370 376 382 388 391 397 403\n",
            "output": "48\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 54 132 32 130 11 162 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 256 262 268 274 159 286 462 298 304 310 316 322 328 334 111 334 352 358 364 51 376 382 388 391 397 286\n",
            "output": "23\n"
        },
        {
            "input": "1\n20\n1 2 10 11 9 17 1 15 12 19 22 2 28 56 34 37 8 43 69 37\n",
            "output": "5\n"
        },
        {
            "input": "1\n69\n1 4 7 16 20 28 34 40 46 52 58 64 70 71 136 88 94 100 106 112 118 124 54 170 142 148 154 160 322 172 178 184 190 196 202 14 214 220 226 232 238 244 250 336 262 268 274 280 286 292 298 55 310 316 322 401 334 340 346 352 134 364 370 376 339 388 391 397 403\n",
            "output": "37\n"
        },
        {
            "input": "3\n3\n14 4 20\n13\n34 3 4 10 5 1 31 2 24 12 31 25 1\n2\n10 37 29 16\n",
            "output": "3\n3\n2\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 19 40 37 52 92 43 70 76 118 88 94 100 106 112 118 124 130 200 142 148 154 160 166 324 178 184 190 196 300 208 214 129 226 167 238 244 250 209 262 322 274 280 286 462 298 304 310 316 322 328 169 110 591 352 358 364 370 376 382 388 391 397 403\n",
            "output": "25\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 19 40 37 52 92 43 70 76 118 88 94 100 106 112 118 124 130 200 142 148 154 160 63 324 178 184 190 196 300 208 214 129 226 167 238 244 250 209 262 322 274 280 286 462 298 304 310 316 322 328 169 110 591 352 358 364 142 376 382 388 391 397 403\n",
            "output": "16\n"
        },
        {
            "input": "1\n69\n2 6 10 16 22 28 34 40 64 20 58 64 25 76 82 88 2 110 106 150 118 124 130 136 142 148 154 160 166 172 178 263 190 196 202 404 27 283 226 232 41 90 394 256 465 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 715 364 370 376 558 530 391 397 286\n",
            "output": "18\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 8 70 76 82 88 94 100 106 9 42 89 130 136 142 32 154 257 166 172 178 170 6 323 202 208 214 220 5 338 238 244 250 256 262 268 274 280 286 866 516 304 310 304 322 328 334 213 346 261 358 364 370 376 382 388 391 397 403\n",
            "output": "19\n"
        },
        {
            "input": "1\n69\n2 0 10 16 22 28 19 40 37 52 92 43 70 76 118 88 94 100 106 112 118 124 130 301 142 148 154 160 63 324 178 184 190 196 300 208 214 129 226 167 238 244 250 209 262 322 274 280 286 462 275 304 310 316 322 328 169 110 591 352 358 364 142 376 382 388 391 397 403\n",
            "output": "17\n"
        },
        {
            "input": "1\n69\n2 6 10 16 22 28 34 40 64 20 27 64 25 76 82 88 2 110 106 150 118 124 181 136 142 148 154 160 166 172 178 263 190 196 202 404 27 419 226 232 41 90 394 256 465 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 715 364 370 376 558 530 391 397 286\n",
            "output": "15\n"
        },
        {
            "input": "1\n69\n2 1 10 16 22 28 34 40 46 52 58 64 70 76 82 88 83 100 106 62 132 32 130 11 115 148 154 6 166 172 226 184 190 196 250 208 214 220 226 232 238 244 250 256 262 513 274 159 169 184 298 304 310 316 322 328 334 011 334 352 358 364 9 376 382 388 391 397 940\n",
            "output": "20\n"
        },
        {
            "input": "1\n69\n2 0 10 16 22 28 19 40 8 52 92 43 70 76 199 88 94 100 106 112 118 124 130 108 142 148 154 160 63 324 178 184 190 196 300 18 214 129 226 167 238 244 250 209 262 322 274 280 286 462 275 304 310 316 322 328 221 110 591 352 358 364 142 376 382 388 391 397 403\n",
            "output": "13\n"
        },
        {
            "input": "1\n69\n1 4 7 16 20 28 34 40 46 52 76 50 70 71 136 88 94 100 106 112 216 124 54 170 142 148 262 160 322 172 178 184 190 196 202 14 214 220 226 232 238 244 101 336 262 501 235 280 286 1 316 55 257 316 322 401 334 340 346 285 25 364 370 376 339 388 391 397 403\n",
            "output": "28\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 33 52 58 8 77 76 82 88 94 100 106 9 42 89 130 136 142 32 154 191 166 172 178 170 6 323 202 208 214 220 5 464 238 244 250 441 262 178 274 280 286 1176 516 304 590 541 322 328 334 213 449 261 358 364 370 376 382 388 391 397 403\n",
            "output": "9\n"
        },
        {
            "input": "1\n69\n2 6 10 16 22 28 34 40 64 20 27 57 25 76 82 119 2 110 106 150 118 124 181 136 142 148 65 160 166 172 178 263 190 196 202 404 27 419 226 232 20 90 394 256 465 268 274 125 286 462 298 304 310 316 322 188 334 110 346 352 715 364 370 376 558 530 280 397 48\n",
            "output": "12\n"
        },
        {
            "input": "1\n69\n2 0 10 16 22 28 19 40 8 10 92 43 70 76 47 88 94 100 106 112 58 124 189 108 142 139 154 160 63 21 178 184 190 196 300 18 214 129 226 167 238 244 250 209 262 322 274 280 286 462 275 145 310 316 322 328 221 110 591 352 358 364 142 376 382 388 734 397 403\n",
            "output": "8\n"
        },
        {
            "input": "1\n4\n1 140688977775057788 85453702640803050 281377955925200962\n",
            "output": "3\n"
        },
        {
            "input": "1\n3\n1 37420937351 335417888009\n",
            "output": "3\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 256 262 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 358 364 370 376 382 388 391 397 403\n",
            "output": "66\n"
        },
        {
            "input": "1\n20\n1 3 5 11 9 11 13 15 17 19 22 25 28 31 66 37 40 43 46 49\n",
            "output": "10\n"
        },
        {
            "input": "1\n20\n16 15 20 8 30 23 20 28 27 6 1 5 24 2 10 5 14 29 12 7\n",
            "output": "3\n"
        },
        {
            "input": "1\n4\n1 140688977775057788 63098712947127598 281377955925200962\n",
            "output": "3\n"
        },
        {
            "input": "4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 1881\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n1 74066906511 335417888009\n",
            "output": "3\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 256 262 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 358 364 370 376 382 388 391 397 286\n",
            "output": "66\n"
        },
        {
            "input": "3\n3\n14 4 27\n13\n26 14 6 10 5 3 13 2 24 12 22 11 1\n4\n10 37 29 22\n",
            "output": "2\n4\n2\n"
        },
        {
            "input": "1\n4\n1 140688977775057788 45974782186072584 281377955925200962\n",
            "output": "3\n"
        },
        {
            "input": "4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 2150\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n1 74066906511 276932169986\n",
            "output": "3\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 394 256 262 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 358 364 370 376 382 388 391 397 286\n",
            "output": "66\n"
        },
        {
            "input": "1\n4\n1 156944554664967561 45974782186072584 281377955925200962\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n1 7 2 4 6\n4\n8 2 5 10\n2\n1000 2150\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n1 10618971110 276932169986\n",
            "output": "2\n"
        },
        {
            "input": "3\n3\n14 4 36\n13\n1 14 6 10 5 3 13 2 24 12 22 11 1\n4\n10 37 29 22\n",
            "output": "3\n4\n2\n"
        },
        {
            "input": "1\n2\n1 156944554664967561 45974782186072584 281377955925200962\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n0 7 2 4 6\n4\n8 2 5 10\n2\n1000 2150\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n1 8943586220 276932169986\n",
            "output": "2\n"
        },
        {
            "input": "3\n3\n14 6 36\n13\n1 14 6 10 5 3 13 2 24 12 22 11 1\n4\n10 37 29 22\n",
            "output": "3\n4\n2\n"
        },
        {
            "input": "1\n2\n1 156944554664967561 45974782186072584 168996258663992263\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n0 7 2 8 6\n4\n8 2 5 10\n2\n1000 2150\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n1 8943586220 328707442366\n",
            "output": "2\n"
        },
        {
            "input": "3\n3\n14 6 24\n13\n1 14 6 10 5 3 13 2 24 12 22 11 1\n4\n10 37 29 22\n",
            "output": "3\n4\n2\n"
        },
        {
            "input": "4\n5\n0 7 2 8 6\n4\n8 0 5 10\n2\n1000 2150\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n2 8943586220 328707442366\n",
            "output": "3\n"
        },
        {
            "input": "4\n5\n0 7 2 8 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 234 15 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n2 8943586220 630301212521\n",
            "output": "3\n"
        },
        {
            "input": "1\n3\n2 8943586220 844669376002\n",
            "output": "3\n"
        },
        {
            "input": "4\n5\n0 9 2 8 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 234 5 45 78\n",
            "output": "3\n3\n2\n3\n"
        },
        {
            "input": "1\n3\n2 8943586220 275585903615\n",
            "output": "3\n"
        },
        {
            "input": "4\n5\n0 9 2 8 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 215 5 45 78\n",
            "output": "3\n3\n2\n3\n"
        },
        {
            "input": "1\n3\n2 8943586220 416431968682\n",
            "output": "3\n"
        },
        {
            "input": "1\n3\n2 8943586220 645418046643\n",
            "output": "2\n"
        },
        {
            "input": "1\n3\n2 8943586220 208923630236\n",
            "output": "3\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 215 5 45 59\n",
            "output": "2\n3\n2\n4\n"
        },
        {
            "input": "1\n3\n1 8943586220 208923630236\n",
            "output": "2\n"
        },
        {
            "input": "1\n3\n1 10741575522 208923630236\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 5 8\n2\n1000 2150\n8\n501 55 3 54 172 5 45 59\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 5 2\n2\n1000 2150\n8\n501 55 3 54 172 5 45 59\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 5 2\n2\n1000 2150\n8\n597 55 3 54 172 5 45 59\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 5 2\n2\n1001 2150\n8\n597 55 3 54 172 5 45 59\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 5 2\n2\n1001 2150\n8\n597 55 3 54 172 5 45 112\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n6 0 5 2\n2\n1001 2150\n8\n597 55 3 54 172 5 45 112\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n6 0 5 2\n2\n1001 2150\n8\n597 55 3 54 172 2 45 112\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "1\n3\n0 137438953474 274877906947\n",
            "output": "2\n"
        },
        {
            "input": "1\n20\n16 15 17 8 30 23 20 28 27 6 1 18 24 2 18 5 14 29 12 7\n",
            "output": "4\n"
        },
        {
            "input": "3\n3\n14 4 27\n13\n26 14 6 10 5 1 29 2 24 12 22 11 1\n4\n10 25 29 11\n",
            "output": "2\n4\n3\n"
        },
        {
            "input": "1\n4\n0 140688977775057788 281377955550115575 281377955925200962\n",
            "output": "3\n"
        },
        {
            "input": "4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 2000\n8\n465 55 3 54 234 0 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n1 106132765440 335417888009\n",
            "output": "2\n"
        },
        {
            "input": "1\n20\n16 15 17 8 30 23 20 28 27 6 1 5 47 2 10 5 14 29 12 7\n",
            "output": "3\n"
        },
        {
            "input": "3\n3\n14 7 27\n13\n26 14 6 10 5 3 29 2 24 12 22 11 1\n4\n10 37 29 11\n",
            "output": "2\n4\n3\n"
        },
        {
            "input": "1\n4\n1 140688977775057788 13870468711702273 281377955925200962\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 2004\n8\n465 55 3 54 234 12 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n1 37420937351 138232306652\n",
            "output": "2\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 92 64 70 76 82 88 94 100 106 112 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 256 262 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 358 364 370 376 382 388 391 397 403\n",
            "output": "66\n"
        },
        {
            "input": "1\n20\n1 3 5 11 9 11 13 15 17 19 22 25 28 31 66 37 40 43 46 5\n",
            "output": "10\n"
        },
        {
            "input": "1\n20\n16 15 20 8 30 23 20 28 27 3 1 5 24 2 10 5 14 29 12 7\n",
            "output": "4\n"
        },
        {
            "input": "3\n3\n14 4 27\n13\n26 14 6 10 5 3 33 2 24 12 22 11 1\n4\n10 37 29 22\n",
            "output": "2\n4\n2\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 54 118 124 130 136 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 256 262 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 358 364 370 376 382 388 391 397 286\n",
            "output": "66\n"
        },
        {
            "input": "1\n20\n16 21 20 8 30 23 20 28 27 5 1 5 24 2 10 5 14 29 12 7\n",
            "output": "4\n"
        },
        {
            "input": "3\n3\n14 4 52\n13\n26 14 6 10 5 3 13 2 24 12 22 11 1\n4\n10 37 29 22\n",
            "output": "3\n4\n2\n"
        },
        {
            "input": "1\n4\n1 266829056017429338 45974782186072584 281377955925200962\n",
            "output": "3\n"
        },
        {
            "input": "4\n5\n1 3 2 4 6\n4\n8 2 5 10\n2\n1000 2150\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n1 12788235736 276932169986\n",
            "output": "3\n"
        },
        {
            "input": "1\n4\n1 156944554664967561 45974782186072584 542502824928251936\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n1 7 2 4 6\n4\n8 2 5 10\n2\n1000 279\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n1 8167231997 276932169986\n",
            "output": "2\n"
        },
        {
            "input": "3\n3\n1 4 36\n13\n1 14 6 10 5 3 13 2 24 12 22 11 1\n4\n10 37 29 22\n",
            "output": "2\n4\n2\n"
        },
        {
            "input": "1\n2\n1 156944554664967561 45974782186072584 510283780766247808\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n0 7 2 4 6\n4\n8 2 5 10\n2\n1000 2150\n8\n465 55 3 54 234 15 45 57\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n1 12893591604 276932169986\n",
            "output": "2\n"
        },
        {
            "input": "3\n3\n14 6 36\n13\n1 14 6 10 5 3 13 2 46 12 22 11 1\n4\n10 37 29 22\n",
            "output": "3\n4\n2\n"
        },
        {
            "input": "1\n3\n1 156944554664967561 45974782186072584 168996258663992263\n",
            "output": "2\n"
        },
        {
            "input": "1\n3\n1 16370475012 328707442366\n",
            "output": "2\n"
        },
        {
            "input": "3\n3\n21 6 24\n13\n1 14 6 10 5 3 13 2 24 12 22 11 1\n4\n10 37 29 22\n",
            "output": "3\n4\n2\n"
        },
        {
            "input": "4\n5\n0 7 2 8 6\n4\n8 0 5 10\n2\n1000 2282\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n2 8943586220 627838251582\n",
            "output": "3\n"
        },
        {
            "input": "4\n5\n0 7 2 8 6\n4\n4 0 5 10\n2\n1000 2150\n8\n651 55 3 54 234 15 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n0 8943586220 630301212521\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n0 7 1 8 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 234 5 45 78\n",
            "output": "2\n3\n2\n3\n"
        },
        {
            "input": "4\n5\n0 9 2 8 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 234 5 45 66\n",
            "output": "3\n3\n2\n3\n"
        },
        {
            "input": "1\n3\n2 8943586220 123648696716\n",
            "output": "3\n"
        },
        {
            "input": "4\n5\n0 11 2 8 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 215 5 45 78\n",
            "output": "3\n3\n2\n3\n"
        },
        {
            "input": "1\n3\n2 2553653315 416431968682\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n0 9 2 8 6\n4\n8 0 5 10\n2\n1000 2150\n8\n862 55 3 54 215 5 45 59\n",
            "output": "3\n3\n2\n4\n"
        },
        {
            "input": "1\n3\n2 8943586220 45777194315\n",
            "output": "3\n"
        },
        {
            "input": "1\n3\n2 12755656909 208923630236\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 5 10\n2\n1100 2150\n8\n651 55 3 54 172 5 45 59\n",
            "output": "2\n3\n2\n3\n"
        },
        {
            "input": "1\n2\n1 10741575522 208923630236\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n1 9 2 1 6\n4\n8 0 5 2\n2\n1000 2150\n8\n501 55 3 54 172 5 45 59\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 5 2\n2\n1010 2150\n8\n597 55 3 54 172 5 45 59\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "4\n5\n1 9 2 3 6\n4\n8 0 5 2\n2\n1001 2150\n8\n831 55 3 54 172 5 45 59\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "4\n5\n1 15 2 3 6\n4\n8 0 5 2\n2\n1001 2150\n8\n597 55 3 54 172 5 45 112\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "4\n5\n1 9 4 3 6\n4\n6 0 5 2\n2\n1001 2150\n8\n597 55 3 54 172 5 45 112\n",
            "output": "2\n2\n2\n3\n"
        },
        {
            "input": "1\n3\n0 137438953474 219314891303\n",
            "output": "3\n"
        },
        {
            "input": "1\n20\n1 3 5 11 9 11 13 15 17 19 22 25 28 31 34 37 22 43 46 49\n",
            "output": "11\n"
        },
        {
            "input": "3\n3\n14 4 27\n13\n26 14 6 10 5 2 29 2 24 12 22 11 1\n4\n10 25 29 11\n",
            "output": "2\n4\n3\n"
        },
        {
            "input": "1\n4\n0 140688977775057788 281377955550115575 151626360431654794\n",
            "output": "2\n"
        },
        {
            "input": "1\n3\n1 204216717776 335417888009\n",
            "output": "3\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 58 64 70 76 82 88 94 100 106 112 118 124 130 136 142 32 154 160 166 172 178 184 190 196 202 208 214 220 279 232 238 244 250 256 262 268 274 280 286 462 298 304 310 316 322 328 334 340 346 352 358 364 370 376 382 388 391 397 403\n",
            "output": "38\n"
        },
        {
            "input": "1\n20\n16 15 17 9 30 23 20 28 27 6 1 5 47 2 10 5 14 29 12 7\n",
            "output": "3\n"
        },
        {
            "input": "3\n3\n14 7 27\n13\n26 14 6 10 5 3 29 2 24 12 22 15 1\n4\n10 37 29 11\n",
            "output": "2\n4\n3\n"
        },
        {
            "input": "1\n4\n1 263608031299402537 13870468711702273 281377955925200962\n",
            "output": "4\n"
        },
        {
            "input": "1\n3\n1 28271562941 138232306652\n",
            "output": "2\n"
        },
        {
            "input": "1\n69\n2 4 10 16 22 28 34 40 46 52 92 64 70 76 82 88 94 100 106 112 118 124 130 200 142 148 154 160 166 172 178 184 190 196 202 208 214 220 226 232 238 244 250 256 262 268 274 280 286 462 298 304 310 316 322 328 334 110 346 352 358 364 370 376 382 388 391 397 403\n",
            "output": "66\n"
        },
        {
            "input": "1\n20\n1 3 5 11 9 11 13 15 17 19 22 25 28 31 60 37 40 43 46 5\n",
            "output": "10\n"
        },
        {
            "input": "1\n20\n16 15 20 8 30 23 20 28 27 3 1 5 24 2 6 5 14 29 12 7\n",
            "output": "4\n"
        },
        {
            "input": "1\n4\n2 266829056017429338 45974782186072584 281377955925200962\n",
            "output": "4\n"
        },
        {
            "input": "4\n5\n1 3 2 4 6\n4\n1 2 5 10\n2\n1000 2150\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n2\n2\n6\n"
        },
        {
            "input": "1\n3\n1 9823716801 276932169986\n",
            "output": "3\n"
        },
        {
            "input": "3\n3\n14 4 36\n13\n26 14 6 10 5 3 13 2 24 6 22 11 1\n4\n17 37 29 22\n",
            "output": "3\n4\n3\n"
        },
        {
            "input": "1\n4\n1 156944554664967561 45974782186072584 424619939076198103\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n1 7 2 4 6\n4\n8 2 5 10\n2\n1010 279\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n3\n2\n6\n"
        },
        {
            "input": "1\n3\n0 8167231997 276932169986\n",
            "output": "2\n"
        },
        {
            "input": "3\n3\n1 4 36\n13\n1 14 9 10 5 3 13 2 24 12 22 11 1\n4\n10 37 29 22\n",
            "output": "2\n4\n2\n"
        },
        {
            "input": "4\n5\n0 7 2 4 6\n4\n8 1 5 10\n2\n1000 2150\n8\n465 55 3 54 234 15 45 57\n",
            "output": "3\n2\n2\n6\n"
        },
        {
            "input": "1\n3\n1 12893591604 105902132899\n",
            "output": "2\n"
        },
        {
            "input": "3\n3\n14 6 15\n13\n1 14 6 10 5 3 13 2 46 12 22 11 1\n4\n10 37 29 22\n",
            "output": "2\n4\n2\n"
        },
        {
            "input": "1\n3\n1 215228063154146246 45974782186072584 168996258663992263\n",
            "output": "2\n"
        },
        {
            "input": "4\n5\n-1 7 2 8 6\n4\n4 2 5 10\n2\n1000 2150\n8\n465 55 3 54 234 15 45 78\n",
            "output": "3\n2\n2\n6\n"
        },
        {
            "input": "1\n3\n1 24286833335 328707442366\n",
            "output": "2\n"
        },
        {
            "input": "3\n3\n21 6 24\n13\n1 14 6 20 5 3 13 2 24 12 22 11 1\n4\n10 37 29 22\n",
            "output": "3\n4\n2\n"
        },
        {
            "input": "4\n5\n0 7 2 8 6\n4\n8 0 5 10\n2\n1000 2282\n8\n465 55 3 54 234 15 7 78\n",
            "output": "3\n3\n2\n4\n"
        },
        {
            "input": "4\n5\n0 7 2 8 6\n4\n4 0 5 10\n2\n1000 2150\n8\n651 55 3 31 234 15 45 78\n",
            "output": "3\n3\n2\n4\n"
        },
        {
            "input": "4\n5\n0 5 1 8 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 234 5 45 78\n",
            "output": "2\n3\n2\n3\n"
        },
        {
            "input": "4\n5\n0 9 2 13 6\n4\n8 0 5 10\n2\n1000 2150\n8\n651 55 3 54 234 5 45 66\n",
            "output": "2\n3\n2\n3\n"
        },
        {
            "input": "1\n3\n2 8943586220 128373962352\n",
            "output": "3\n"
        },
        {
            "input": "1\n3\n2 1042758520 416431968682\n",
            "output": "3\n"
        },
        {
            "input": "1\n3\n2 7886764954 45777194315\n",
            "output": "2\n"
        },
        {
            "input": "1\n3\n3 12755656909 208923630236\n",
            "output": "2\n"
        }
    ],
    "solution": [
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n//import java.math.*;\n\npublic class Task{\n//  ..............code begins here..............\n\nstatic long mod=(long)1e9+7,mod1=998244353l,inf=(long)1e18+5;\n// 1111111999999, 311111111111113\n\nstatic void solve1() throws  IOException{\n    int n=int_v(read());\n    long[] a=long_arr();\n    if(n<=1){out.write(1+\"\\n\");return;}\n    List<Long> l=new ArrayList<>();\n    for(int i=0;i+1<n;i++){\n        l.add(Math.abs(a[i]-a[i+1]));\n    }\n    int k=l.size();\n    int[] pow=new int[20+1],log=new int[n+1];\n    pow[0]=1;log[1]=0;\n    for(int i=2;i<=n;i++)log[i]=log[i/2]+1;\n    for(int i=1;i<=20;i++)pow[i]=pow[i-1]*2;\n    long[][] dp=new long[k+1][20];\n    for(int i=0;i<l.size();i++)dp[i][0]=(long)l.get(i);\n    for(int i=1;i<20;i++){\n        for(int j=0;j<k;j++){\n            dp[j][i]=gcd(dp[Math.min(j+pow[i-1],k-1)][i-1],dp[j][i-1]);\n        }\n        //out.write(dp[0][i-1]+\", \");\n    }\n    for(int i=0;i<20;i++){\n        dp[k][i]=dp[k-1][i];\n    }\n    int l1=1,r=k,ans=0;\n    while(l1<=r){\n        int m=(l1+r)/2;\n        boolean ok=false;\n        for(int i=0;i<k&&k-i>=m;i++){\n            int len=log[m];\n            long tmp=gcd(dp[i][len],dp[i+m-pow[len]][len]);\n            if(tmp>=2){ok=true;break;}\n        }\n        if(ok){\n            ans=m;l1=m+1;\n        }\n        else r=m-1;\n    }\n\n    out.write((ans+1)+\"\\n\");\n}\n//\n\npublic static void main(String[] args) throws  IOException{\n    assign();\n    int t=int_v(read()),cn=1;\n    while(t--!=0){\n        //out.write(\"Case #\"+cn+\": \");\n        solve1();\n        //cn++;\n    }\n    out.flush();\n}\n\n// taking inputs\nstatic BufferedReader s1;\nstatic BufferedWriter out;\nstatic String read() throws IOException{String line=\"\";while(line.length()==0){line=s1.readLine();continue;}return line;}\nstatic int int_v (String s1){return Integer.parseInt(s1);}\nstatic long long_v(String s1){return Long.parseLong(s1);}\nstatic void sort(int[] a){List<Integer> l=new ArrayList<>();for(int x:a){l.add(x);}Collections.sort(l);for(int i=0;i<a.length;i++){a[i]=l.get(i);}}\nstatic int[] int_arr() throws IOException{String[] a=read().split(\" \");int[] b=new int[a.length];for(int i=0;i<a.length;i++){b[i]=int_v(a[i]);}return b;}\nstatic long[] long_arr() throws IOException{String[] a=read().split(\" \");long[] b=new long[a.length];for(int i=0;i<a.length;i++){b[i]=long_v(a[i]);}return b;}\nstatic void assign(){s1=new BufferedReader(new InputStreamReader(System.in));out=new BufferedWriter(new OutputStreamWriter(System.out));}\n//static String setpreciosion(double d,int k){BigDecimal d1 = new BigDecimal(Double.toString(d));return d1.setScale(k,RoundingMode.HALF_UP).toString();}//UP DOWN HALF_UP\nstatic int add(int a,int b){int z=a+b;if(z>=mod)z-=mod;return z;}\nstatic long gcd(long a,long b){if(b==0){return a;}return gcd(b,a%b);}\nstatic long Modpow(long a,long p,long m){long res=1;while(p>0){if((p&1)!=0){res=(res*a)%m;}p >>=1;a=(a*a)%m;}return res%m;}\nstatic long Modmul(long a,long b,long m){return ((a%m)*(b%m))%m;}\nstatic long ModInv(long a,long m){return Modpow(a,m-2,m);}\n//static long nck(int n,int r,long m){if(r>n){return 0l;}return Modmul(f[n],ModInv(Modmul(f[n-r],f[r],m),m),m);}\n//static long[] f;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 200005;\nlong long t, n, ans;\nlong long a[N], b[N], v[N], l[N];\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nsigned main() {\n  scanf(\"%lld\", &t);\n  while (t--) {\n    scanf(\"%lld\", &n);\n    ans = 0ll;\n    for (long long i = 1; i <= n; ++i) scanf(\"%lld\", &b[i]);\n    for (long long i = 1; i < n; ++i) a[i] = abs(b[i + 1] - b[i]);\n    --n;\n    for (long long i = 1; i <= n; ++i) {\n      v[i] = a[i];\n      l[i] = i;\n    }\n    for (long long i = 1; i <= n; ++i)\n      for (long long j = i; j; j = l[j] - 1) {\n        v[j] = gcd(v[j], a[i]);\n        while (l[j] > 1 && gcd(a[i], v[l[j] - 1]) == v[j]) l[j] = l[l[j] - 1];\n        if (v[j] > 1) ans = max(ans, i - l[j] + 1);\n      }\n    printf(\"%lld\\n\", ans + 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 5e5 + 5;\nlong long arr[N] = {0};\nlong long pre[N];\nlong long suf[N];\nlong long gcd(long long a, long long b) {\n  while (b) {\n    long long temp = a % b;\n    a = b;\n    b = temp;\n  }\n  return a;\n}\nbool check(long long val, long long n) {\n  for (long long i = 1; i <= n; i += val) {\n    long long l = i;\n    long long r = min(n, i + val - 1);\n    pre[l] = arr[l];\n    for (long long j = l + 1; j <= r; ++j) {\n      pre[j] = gcd(pre[j - 1], arr[j]);\n    }\n    suf[r] = arr[r];\n    for (long long j = r - 1; j >= l; --j) {\n      suf[j] = gcd(suf[j + 1], arr[j]);\n    }\n  }\n  for (long long i = 1; i + val - 1 <= n; ++i) {\n    if (gcd(suf[i], pre[i + val - 1]) >= 2) {\n      return 1;\n    }\n  }\n  return 0;\n}\nlong long solve(long long n) {\n  long long l = 1;\n  long long r = n + 1;\n  while (l < r) {\n    long long mid = l + r >> 1;\n    if (check(mid, n)) {\n      l = mid + 1;\n    } else {\n      r = mid;\n    }\n  }\n  return l - 1;\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long long long t;\n  cin >> t;\n  while (t--) {\n    long long long long n;\n    cin >> n;\n    long long long long a[n];\n    cin >> a[0];\n    for (long long i = 1; i < n; i++) {\n      cin >> a[i];\n      arr[i] = llabs(a[i] - a[i - 1]);\n    }\n    for (long long i = 1; i <= n - 1; i++) {\n    }\n    long long ans = solve(n - 1);\n    cout << ans + 1 << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "def gcd(a, b):\n\twhile b != 0: a, b = b, a%b\n\treturn a\n\nfrom sys import stdin\nraw_input = lambda: stdin.readline().rstrip()\ninput = lambda: int(raw_input())\nI=lambda: map(int, raw_input().split())\nt = input()\nfor _ in xrange(t):\n\tn = input()\n\ta = I()\n\tr = 1\n\td = []\n\tfor i in xrange(n-1):\n\t\tq = abs(a[i]-a[i+1])\n\t\tif q > 1:\n\t\t\tr = 2\n\t\td.append(q)\n\tif r == 1:\n\t\tprint 1\n\t\tcontinue\n\ti = 0\n\tcurLst = [(d[0], 2)]\n\twhile i<n-2:\n\t\tif d[i] > 1:\n\t\t\tfor x in curLst:\n\t\t\t\tg, cur = x\n\t\t\t\tj = i+1\n\t\t\t\twhile j<n-1:\n\t\t\t\t\tg = gcd(g, d[j])\n\t\t\t\t\tif g==1:\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tcur += 1\n\t\t\t\t\t\tj += 1\n\t\t\t\tr = max(r, cur)\n\t\t\tif j<n-1:\n\t\t\t\tcur = 2\n\t\t\t\tg = d[j]\n\t\t\t\tprevG = g\n\t\t\t\tcurLst = []\n\t\t\t\tk = j-1\n\t\t\t\twhile k > i:\n\t\t\t\t\tg = gcd(g, d[k])\n\t\t\t\t\tif g==1:\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tif g != prevG:\n\t\t\t\t\t\t\tcurLst.append((prevG, cur))\n\t\t\t\t\t\t\tprevG = g\n\t\t\t\t\t\tcur += 1\n\t\t\t\t\tk -= 1\n\t\t\t\tcurLst.append((prevG, cur))\n\t\t\t\tcurLst.reverse()\n\t\t\ti = j\n\t\telse:\n\t\t\ti += 1\n\t\t\tcurLst = [(d[i], 2)]\n\tprint r\t\t\t\t\t"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.util.function.Predicate;\n\npublic class D {\n\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n\n\n        int test = scn.nextInt();\n        while (test-- > 0) {\n            int n = scn.nextInt();\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = scn.nextLong();\n            }\n            if (n == 1) {\n                System.out.println(1);\n                continue;\n            }\n            long[] diff = new long[n - 1];\n            for (int i = 0; i < n - 1; i++) {\n                diff[i] = arr[i] - arr[i + 1];\n                if (diff[i] < 0) diff[i] = -diff[i];\n            }\n            SparseTable st = new SparseTable(diff);\n\n            int maxDistance = lastTrue(0, n - 1, (x) -> isPossible(x, st)) + 2;\n            System.out.println(maxDistance);\n\n        }\n\n\n    }\n\n    public static int lastTrue(int lo, int hi, Predicate<Integer> f) {\n        for (--lo; lo < hi; ) {\n            int mid = lo + (hi - lo + 1) / 2;\n            // find the middle of the current range (rounding up)\n            if (f.test(mid)) lo = mid;\n                // if mid works, then all numbers smaller than mid also work\n            else hi = mid - 1;\n            // if mid does not work, greater values would not work too\n            // so we don't care about them\n\n        }\n        return lo;\n    }\n\n    static boolean isPossible(int distance, SparseTable st) {\n\n        for (int i = 0; i + distance < st.ST[0].length; i++) {\n            long gcd = st.query(i, i + distance);\n            if (gcd > 1) return true;\n        }\n        return false;\n    }\n\n    static long gcd(long a, long b) {\n        while (b > 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n\n    }\n\n\n    static class SparseTable {\n        long[][] ST;\n        int n;\n\n        SparseTable(long[] A) {\n            n = A.length;\n\n            int k = 31 - Integer.numberOfLeadingZeros(n);\n\n            ST = new long[k + 1][n];\n            for (int i = 0; i < n; ++i)\n                ST[0][i] = A[i];\n            for (int i = 1; i <= k; ++i)\n                for (int j = 0; j + (1 << i) <= n; ++j)\n                    ST[i][j] = gcd(ST[i - 1][j], ST[i - 1][j + (1 << i - 1)]);\n        }\n\n        long query(int l, int r) {\n            int k = 31 - Integer.numberOfLeadingZeros(r - l + 1);\n            return gcd(ST[k][l], ST[k][r - (1 << k) + 1]);\n        }\n    }\n\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Coder {\n  static int n,m;\n  static long na[];\n  static long pre[];\n  static long suf[];\n  static long a[];\n  static StringBuffer str=new StringBuffer();\n  \n  static boolean isPoss(int m){\n      for(int i=1;i<n;i+=m){\n          int l=i;\n          int r=Math.min(n-1, i+m-1);\n          pre[l]=na[l];\n          for(int j=l+1;j<=r;j++) pre[j]=gcd(pre[j-1], na[j]);\n          suf[r]=na[r];\n          for(int j=r-1;j>=l;j--) suf[j]=gcd(suf[j+1], na[j]);\n      }\n      for(int i=1;(i+m-1)<n;i++){\n          if(gcd(suf[i], pre[i+m-1])>1) return true;\n      }\n      return false;\n  }\n  static long gcd(long a, long b){\n      if(b==0) return a;\n      return gcd(b, a%b);\n  }\n  static void solve(){\n      if(n==1){\n          str.append(n).append(\"\\n\");return;\n      }\n      na=new long[n];\n      for(int i=1;i<n;i++){\n          na[i]=Math.abs(a[i]-a[i-1]);\n      }\n      int l=1, r=n-1;\n      int ans=0;\n      while(l<=r){\n          int mid=l+(r-l)/2;\n          if(isPoss(mid)){\n              ans=mid;\n              l=mid+1;\n          }else r=mid-1;\n      }\n      str.append((ans+1)).append(\"\\n\");\n  }\n\n  public static void main(String[] args) throws java.lang.Exception {\n    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n    int q = Integer.parseInt(bf.readLine().trim());\n    while(q-->0) {\n        n=Integer.parseInt(bf.readLine().trim());\n        a=new long[n];\n        pre=new long[n];\n        suf=new long[n];\n        String s[]=bf.readLine().trim().split(\"\\\\s+\");\n        for(int i=0;i<n;i++) a[i]=Long.parseLong(s[i]);\n        solve();\n    }\n    System.out.print(str);\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\ninline void read(long long &x) {\n  long long s = 0;\n  x = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') x = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9')\n    s = (s << 3) + (s << 1) + ch - '0', ch = getchar();\n  x *= s;\n}\nconst long long N = 6e5 + 5, M = 25;\nlong long w[N], d[N];\nlong long n, logn[N << 2];\nlong long st[N][M];\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nvoid init() {\n  for (long long i = 2; i <= n + 1; i++) logn[i] = logn[i / 2] + 1;\n  for (long long j = 0; j < M; j++)\n    for (long long i = 1; i + (1 << j) - 1 <= n + 1; i++)\n      if (!j)\n        st[i][j] = d[i];\n      else\n        st[i][j] = gcd(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);\n}\nlong long query(long long l, long long r) {\n  long long len = r - l + 1;\n  long long k = logn[len];\n  return gcd(st[l][k], st[r - (1 << k) + 1][k]);\n}\nsigned main() {\n  long long T;\n  cin >> T;\n  while (T--) {\n    read(n);\n    for (long long i = (1); i <= (n); i++) read(w[i]);\n    for (long long i = (1); i <= (n + 1); i++) d[i] = w[i] - w[i - 1];\n    init();\n    long long res = 0;\n    for (long long i = (1); i <= (n); i++) {\n      long long l = i + 1, r = n;\n      while (l <= r) {\n        long long mid = l + r >> 1;\n        if (abs(query(i + 1, mid)) != 1)\n          l = mid + 1;\n        else\n          r = mid - 1;\n      }\n      long long t = abs(query(i + 1, l));\n      if (i != n) {\n        if (w[i] % t == w[i + 1] % t) res = max(res, l - i);\n      } else\n        res = max(res, 1LL);\n    }\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static PrintWriter pw;\n    static Scanner sc;\n    static long ceildiv(long x, long y) { return (x+y-1)/y; }\n    static int mod(long x, int m) { return (int)((x%m+m)%m); }\n    static void put(TreeMap<Long, Integer> map, Long p){if(map.containsKey(p)) map.replace(p, map.get(p)+1); else map.put(p, 1); }\n    static void rem(TreeMap<Long, Integer> map, Long p){ if(map.get(p)==1) map.remove(p);else map.replace(p, map.get(p)-1); }\n    static void printf(double x, int dig){ String s=\"%.\"+dig+\"f\"; pw.printf(s, x); }\n    static int Int(boolean x){ return x?1:0; }\n    static final int inf=(int)1e9, mod= inf + 7;\n    static final long infL=inf*1l*inf;\n    static final double eps=1e-9;\n    public static long gcd(long x, long y) { return y==0? x: gcd(y, x%y); }\n    public static void main(String[] args) throws Exception {\n        sc = new Scanner(System.in);\n        pw = new PrintWriter(System.out);\n        int t = sc.nextInt();\n        while (t-- > 0)\n            testcase();\n        pw.close();\n    }\n\n    static void testcase() throws IOException {\n        int n = sc.nextInt();\n        long[] arr = sc.nextLongArr(n);\n        Solver solver = new Solver(n);\n        solver.add(arr[0]);\n        int ans = 1;\n        for (int i = 0, j=0; j<n;) {\n            if(solver.getGCD() != 1){\n                ans = Math.max(ans, j-i+1);\n                if(j < n-1)\n                    solver.add(arr[++j]);\n                else\n                    break;\n            }else{\n                solver.remove(arr[i++]);\n            }\n        }\n        pw.println(ans);\n    }\n\n    static class Solver{\n        SegmentTree diff;\n        int diffSize;\n        TreeMap<Long, Integer> values;\n        HashMap<Long, Queue<Integer>> diffIdx;\n        Queue<Integer> freeIdx;\n        public Solver(int n){\n            diff = new SegmentTree(new int[n]);\n            values = new TreeMap<>();\n            diffSize = 0;\n            diffIdx = new HashMap<>();\n            freeIdx = new LinkedList<>();\n        }\n\n        public void add(long x){\n            put(values, x);\n            if(values.get(x) == 1){\n                Long more = values.ceilingKey(x+1);\n                Long less = values.floorKey(x-1);\n                if(more != null)\n                    addToDiff(more - x);\n                if(less != null)\n                    addToDiff(x - less);\n                if(more != null && less != null)\n                    removeFromDiff(more - less);\n            }\n        }\n\n        public void remove(long x){\n            rem(values, x);\n            if(!values.containsKey(x)){\n                Long more = values.ceilingKey(x+1);\n                Long less = values.floorKey(x-1);\n                if(more != null)\n                    removeFromDiff(more - x);\n                if(less != null)\n                    removeFromDiff(x - less);\n                if(more != null && less != null)\n                    addToDiff(more - less);\n            }\n        }\n\n        public void addToDiff(long x){\n            if(!freeIdx.isEmpty()){\n                int idx = freeIdx.poll();\n                diff.updateValue(idx, x);\n                if(!diffIdx.containsKey(x))\n                    diffIdx.put(x, new LinkedList<>());\n                diffIdx.get(x).add(idx);\n                return;\n            }\n            diff.updateValue(diffSize, x);\n            if(!diffIdx.containsKey(x))\n                diffIdx.put(x, new LinkedList<>());\n            diffIdx.get(x).add(diffSize);\n            diffSize++;\n        }\n\n        public void removeFromDiff(long x){\n            int idx = diffIdx.get(x).poll();\n            diff.updateValue(idx, 0);\n            freeIdx.add(idx);\n        }\n\n        public long getGCD(){\n            return diff.tree[0];\n        }\n    }\n\n    static class SegmentTree {\n        long[] arr, tree;\n        int n;\n        public SegmentTree(int[] arr){\n            int N = arr.length;\n            n = 1;\n            while(n < N)\n                n <<= 1;\n            this.arr = new long[n];\n            for (int i = 0; i < N; i++)\n                this.arr[i] = arr[i];\n            tree = new long[2*n -1];\n            build(0);\n        }\n\n        public long build(int i){\n            if(i >= n-1)\n                return tree[i] = arr[i-n+1];\n            return tree[i] = gcd(build(2*i +1), build(2*i + 2));\n        }\n\n        public long getGCD(int l, int r){\n            return getGCD(0, 0, n-1, l, r);\n        }\n\n        public long getGCD(int node, int i, int j, int l, int r){\n            if(i>=l && j<=r)\n                return tree[node];\n            if(i>r || j<l)\n                return 0;\n            int mid = (i+j)/2, left = 2*node + 1, right = 2*node + 2;\n            return gcd(getGCD(left, i, mid, l, r), getGCD(right, mid+1, j, l, r));\n        }\n\n        public void updateValue(int idx, long val){\n            int i = n-1 + idx;\n            tree[i] = val;\n            arr[idx] = val;\n            while(i >= 1){\n                i = (i-1)/2;\n                tree[i] = gcd(tree[i*2 + 1], tree[i*2 + 2]);\n            }\n        }\n    }\n\n    static void printArr(int[] arr) {\n        for (int i = 0; i < arr.length; i++)\n            pw.print(arr[i] + \" \");\n        pw.println();\n    }\n    static void printArr(long[] arr) {\n        for (int i = 0; i < arr.length; i++)\n            pw.print(arr[i] + \" \");\n        pw.println();\n    }\n    static void printArr(double[] arr) {\n        for (int i = 0; i < arr.length; i++)\n            pw.print(arr[i] + \" \");\n        pw.println();\n    }\n    static void printArr(Integer[] arr) {\n        for (int i = 0; i < arr.length; i++)\n            pw.print(arr[i] + \" \");\n        pw.println();\n    }\n    static void printArr(List list) {\n        for (int i = 0; i < list.size() - 1; i++)\n            pw.print(list.get(i)+\" \");\n        pw.println(list.get(list.size()-1));\n    }\n    static void printArr(boolean[] arr) {\n        StringBuilder sb=new StringBuilder();\n        for(boolean b: arr)\n            sb.append(Int(b));\n        pw.println(sb);\n    }\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n        public int[] nextDigits() throws IOException{\n            String s=nextLine();\n            int[] arr=new int[s.length()];\n            for(int i=0; i<arr.length; i++)\n                arr[i]=s.charAt(i)-'0';\n            return arr;\n        }\n        public int[] nextArr(int n) throws IOException {\n            int[] arr = new int[n];\n            for (int i = 0; i < arr.length; i++)\n                arr[i] = nextInt();\n            return arr;\n        }\n        public Integer[] nextsort(int n) throws IOException{\n            Integer[] arr=new Integer[n];\n            for(int i=0; i<n; i++)\n                arr[i]=nextInt();\n            return arr;\n        }\n        public Pair nextPair() throws IOException{\n            return new Pair(nextInt(), nextInt());\n        }\n        public long[] nextLongArr(int n) throws IOException{\n            long[] arr=new long[n];\n            for (int i = 0; i < n; i++)\n                arr[i]=sc.nextLong();\n            return arr;\n        }\n        public Pair[] nextPairArr(int n) throws IOException{\n            Pair[] arr=new Pair[n];\n            for(int i=0; i<n; i++)\n                arr[i]=nextPair();\n            return arr;\n        }\n        public boolean hasNext() throws IOException {\n            return (st!=null && st.hasMoreTokens()) || br.ready();\n        }\n    }\n    static class Pair implements Comparable<Pair> {\n        int x;\n        int y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public Pair(Map.Entry<Integer, Integer> a) {\n            x = a.getKey();\n            y = a.getValue();\n        }\n\n        public boolean inRange(int mid){\n            return mid>=x && mid<=y;\n        }\n\n        public boolean contains(int a) {\n            return x == a || y == a;\n        }\n\n        public int hashCode() {\n            return (this.x * 1000000000 + this.y);\n        }\n\n        public int compareTo(Pair p) {\n            return Integer.compare(x, p.x);\n        }\n\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (this.getClass() != obj.getClass()) {\n                return false;\n            }\n            Pair p = (Pair) obj;\n            return this.x == p.x && this.y == p.y;\n        }\n\n        public Pair clone() {\n            return new Pair(x, y);\n        }\n\n        public String toString() {\n            return this.x + \" \" + this.y;\n        }\n\n        public void add(Pair p) {\n            x += p.x;\n            y += p.y;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import math\nfor case in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = [1] + [abs(a[i]-a[i-1]) for i in range(1, n)]\n    cur = {1 : 0}\n    ans = 0\n    for i in range(1, n):\n        g = b[i]\n        d = {}\n        d[g] = i\n        if g != 1:\n            tmp = sorted(list(cur.keys()), reverse = True)\n            for j in tmp:\n                g = math.gcd(g, j)\n                if g not in d:\n                    d[g] = cur[j]\n                if g == 1:\n                    ans = max(ans, i - cur[j])\n                    break\n        cur = d\n    print(ans + 1)"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while y>0:\n            x, y=y, x%y\n        return x\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2                                    \n\n#    total=bmax\n#    c=int(0.5+math.log2(bmax))\n#    k=0\n#    while k+total<n:\n#        if St[k][c]!=1:\n#            start=total+1\n#            end=min(n-k-1, bmax*2-1)\n#            while start<=end:\n#                j=(start+end)//2\n#                if HCF(St[k][c], St[k+j-2**c][c])!=1:\n#                    total=j\n#                    start=j+1\n#                else:\n#                    end=j-1    \n#        k+=1\n\n    def possible_group(x, y):\n        c=b[x]\n        for i in range(x+1, y):\n            c=HCF(c, b[i])\n            if c==1:\n                return False\n        return True        \n\n    total=bmax\n    start=bmax+1\n    end=min(n-1, bmax*2-1)\n    c=int(0.5+math.log2(bmax))\n    while start<=end:\n        j=(start+end)//2\n        for k in range(n-j):            \n            if HCF(St[k][c], St[k+j-2**c][c])!=1:\n                total=j\n                start=j+1\n                break\n        if start<=j:\n            end=j-1\n            \n    \n    print(total+1)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Coder {\n  static int n,m;\n  static long na[];\n  static long a[];\n  static long st[];\n  static StringBuffer str=new StringBuffer();\n  \n  static long gcd(long a, long b){\n      if(b==0) return a;\n      return gcd(b, a%b);\n  }\n  static long constructST(int ss, int se, int si){\n      if(ss==se){\n          return st[si]=na[ss];\n      }\n      int mid=ss+(se-ss)/2;\n      return st[si]=gcd(constructST(ss, mid, 2*si+1), constructST(mid+1, se, 2*si+2));\n  }\n  \n  static long findGcd(int ss, int se, int qs, int qe, int si){\n      if(qs<=ss && qe>=se) return st[si];\n      if(ss>qe || se<qs) return 0;\n      int mid=ss+(se-ss)/2;\n      return gcd(findGcd(ss, mid, qs, qe, 2*si+1), findGcd(mid+1, se, qs, qe, 2*si+2));\n  }\n\n  static void solve(){\n      if(n==1){\n          str.append(n).append(\"\\n\");return;\n      }\n      na=new long[n-1];\n      for(int i=1;i<n;i++){\n          na[i-1]=Math.abs(a[i]-a[i-1]);\n      }\n      int x=(int)Math.ceil(Math.log(n-1)/Math.log(2));\n      int sz=2*(int)Math.pow(2, x)-1;\n      st=new long[sz];\n      constructST(0, n-2, 0);\n      int l=0, r=0, ans=0;\n      long g=0;\n      while(l<=r && r<n-1){\n          g=gcd(na[r], g);\n          if(g>1) r++;\n          else{\n              ans=Math.max(ans, r-l);\n              l++;r++;\n              if(r<n-1){\n                  g=findGcd(0, n-2, l, r, 0);\n              }\n          }\n      }\n      ans=Math.max(ans, r-l);\n      str.append((ans+1)).append(\"\\n\");\n  }\n\n  public static void main(String[] args) throws java.lang.Exception {\n    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n    int q = Integer.parseInt(bf.readLine().trim());\n    while(q-->0) {\n        n=Integer.parseInt(bf.readLine().trim());\n        a=new long[n];\n        String s[]=bf.readLine().trim().split(\"\\\\s+\");\n        for(int i=0;i<n;i++) a[i]=Long.parseLong(s[i]);\n        solve();\n    }\n    System.out.print(str);\n  }\n}"
        },
        {
            "language": 3,
            "solution": "'''\nCreated: 01-08-2021 at 20:07:23\nAuthor : Aaditya Upadhyay\n'''\nimport os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\ndef st(): return list(sys.stdin.readline().strip())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef mp(): return map(int, sys.stdin.readline().split())\ndef inp(): return int(sys.stdin.readline())\ndef pr(n): return sys.stdout.write(str(n)+\"\\n\")\ndef prl(n): return sys.stdout.write(str(n)+\" \")\n\n\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\n\ndef solve():\n    def getGCD(a,b):\n        p=logs[b-a+1]\n        plen = 1<<p\n        return gcd(table[p][a],table[p][b-plen+1])\n    N = inp()\n    ans = 0\n    x = li()\n    l = [abs(x[i]-x[i+1]) for i in range(N-1)]\n    n = N - 1\n    maxlog = 20\n    \n    logs=[0 for i in range(n+1)]\n    for  i in range(2,n+1):\n        logs[i]=logs[i>>1]+1\n    \n    table=[[0 for i in range(n+1)] for j in range(maxlog)]\n    \n    for i in range(logs[n]+1):\n        j=0\n        cur= 1<<i\n        while j+cur <=n:\n            if cur==1:\n                table[i][j]= l[j]\n            else:\n                table[i][j]= gcd(table[i-1][j],table[i-1][j + (cur//2)])\n            j+=1\n    low = 1\n    high = n\n    while low <= high:\n        flag = 0\n        mid = (low+high)//2\n        for i in range(n-mid+1):\n            cur = getGCD(i, i+mid-1)\n            if cur > 1:\n                flag = 1\n                break\n        if flag:\n            ans = mid + 1\n            low = mid + 1\n        else:\n            high = mid - 1\n    pr(max(1, ans))\n\n\nfor _ in range(inp()):\n    solve()\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom math import gcd\n\nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nM = 2*10**5 + 1\nprefix = [0] * M\nsuffix = [0] * M\n\ndef check(D, size):\n#    print(size, len(D))\n    for i in range(0, len(D), size):\n        first, last = i, min(len(D), i + size)\n#        print(first, last)\n\n        prefix[first] = D[first]\n        for j in range(first + 1, last):\n            prefix[j] = gcd(prefix[j - 1], D[j])\n\n        j = last - 1\n        suffix[j] = D[j]\n        while first < j:\n            suffix[j - 1] = gcd(suffix[j], D[j - 1])\n            j -= 1\n\n#    print(D, size)\n#    print(prefix[: len(D)])\n#    print(suffix[: len(D)])\n    for j in range(len(D) - size + 1):\n            if gcd(suffix[j], prefix[j + size - 1]) > 1:\n#                print(j, j + size - 1 < last, suffix[j], prefix[j + size - 1])\n                return True\n            j += 1\n\n    return False\n\ndef solve(D):\n    if len(D) == 0:\n        return 1\n    if len(D) == 1:\n        return 2 if abs(D[0]) != 1 else 1\n\n    l, r = 1, len(D) + 1\n    while l < r:\n        m = (l + r)//2\n        if check(D, m):\n            l = m + 1\n        else:\n            r = m\n\n    return l\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    A = list(map(int, input().split(' ')))\n\n    if n == 1:\n        r = 1\n\n    D = [abs(A[i + 1] - A[i]) for i in range(n - 1)]\n\n    print(solve(D))   "
        },
        {
            "language": 3,
            "solution": "'''\n\n* Author : Ayushman Chahar #\n* About  : IT Junior       #\n* Insti  : VIT, Vellore    #\n\n'''\n\nimport os\nimport sys\n# from collections import *\n# from itertools import *\nfrom math import gcd, log2\n# from queue import *\n# from heapq import *\n# from bisect import *\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nreadint = lambda: int(sys.stdin.readline().rstrip(\"\\r\\n\"))\nreadints = lambda: map(int, sys.stdin.readline().rstrip(\"\\r\\n\").split())\nreadstr = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nreadstrs = lambda: map(str, sys.stdin.readline().rstrip(\"\\r\\n\").split())\nreadarri = lambda: [int(_) for _ in sys.stdin.readline().rstrip(\"\\r\\n\").split()]\nreadarrs = lambda: [str(_) for _ in sys.stdin.readline().rstrip(\"\\r\\n\").split()]\n\nK = 25\nMAXN = int(2e5) + 1\nst = [[0 for _ in range(K + 1)] for _ in range(MAXN)]\nlg = [0, 1]\nfor i in range(2, MAXN + 1):\n    lg.append(lg[i >> 1] + 1)\narr = list()\n\n\ndef sparse(n):\n    global st\n    for j in range(n):\n        st[j][0] = arr[j]\n    for j in range(1, K + 1):\n        for z in range(0, n + 1 - (1 << j)):\n            st[z][j] = gcd(st[z][j - 1], st[z + (1 << (j - 1))][j - 1])\n\n\ndef query(l, r):\n    f = lg[r - l + 1] - 1\n    return gcd(st[l][f], st[r - (1 << f) + 1][f])\n\n\ndef solve():\n    global arr\n    n = readint()\n    a = readarri()\n    if (n == 1):\n        print(1)\n        return\n    arr = [0] * (n - 1)\n    for i in range(n - 1):\n        arr[i] = abs(a[i + 1] - a[i])\n    sparse(n - 1)\n    ans = 1\n    ptr = 0\n    for i in range(n - 1):\n        while (ptr <= i and query(ptr, i) == 1):\n            ptr += 1\n        ans = max(ans, i - ptr + 2)\n    print(ans)\n\n\ndef main():\n    t = 1\n    t = readint()\n    for _ in range(t):\n        # print(\"Case #\" + str(_ + 1) + \": \", end=\"\")\n        solve()\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Akshay Mishra\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        DIntegersHaveFriends solver = new DIntegersHaveFriends();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DIntegersHaveFriends {\n        public static long seg[];\n        public static long arr[];\n\n        public static long gcd(long a, long b) {\n            if (a == 0)\n                return b;\n            return gcd(b % a, a);\n        }\n\n        public static long const_seg(int node, int l, int r) {\n            if (l == r) {\n                return seg[node] = arr[l];\n            } else {\n                int mid = (l + r) / 2;\n                return seg[node] = gcd(const_seg(2 * node, l, mid), const_seg(2 * node + 1, mid + 1, r));\n            }\n        }\n\n        public static long query(int node, int l, int r, int x, int y) {\n            if (x <= l && r <= y) {\n                return seg[node];\n            }\n            else if (r < x || y < l) {\n                return 0l;\n            } else {\n                int mid = (l + r) / 2;\n                return gcd(query(2 * node, l, mid, x, y), query(2 * node + 1, mid + 1, r, x, y));\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int test = in.nextInt();\n            while (test-- > 0) {\n                int n = in.nextInt();\n                long array[] = new long[n];\n                for (int i = 0; i < n; i++) {\n                    array[i] = in.nextLong();\n                }\n                if (n == 1) {\n                    out.println(1);\n                    continue;\n                }\n                long diff[] = new long[n - 1];\n                for (int i = 0; i < n - 1; i++) {\n                    diff[i] = Math.abs(array[i] - array[i + 1]);\n                }\n                arr = diff;\n                seg = new long[4 * n + 1];\n                const_seg(1, 0, n - 2);\n                int ans = 1,i = 0, j = 0;\n                while (i < n - 1) {\n                    long temp_ans = query(1, 0, n - 2, i, j);\n                    if (temp_ans >= 2) {\n                        ans = Math.max(ans, j - i + 2);\n                    }\n                    if (j < n - 2 && temp_ans >= 2) {\n                        j++;\n                    } else {\n                        i++;\n                        if (i == j + 1) {\n                            j++;\n                        }\n                    }\n                }\n                out.println(ans);\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static long gcd(long a, long b) {\n        if(a == 0) {\n            return b;\n        }\n        return gcd(b%a, a);\n    }\n    public static void main(String[] args) throws IOException {\n        //BufferedReader f = new BufferedReader(new FileReader(\"uva.in\"));\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int t = Integer.parseInt(f.readLine());\n        while(t-- > 0) {\n            int n = Integer.parseInt(f.readLine());\n            StringTokenizer st = new StringTokenizer(f.readLine());\n            long[] a = new long[n];\n            for(int i = 0; i < n; i++) {\n                a[i] = Long.parseLong(st.nextToken());\n            }\n            if(n == 1) {\n                out.println(1);\n                continue;\n            }\n            int i = 0;\n            int j = 1;\n            int ans = 1;\n            long gcd = Math.abs(a[0]-a[1]);\n            while(j < n) {\n                if(gcd > 1) {\n                    ans = Math.max(ans, j-i+1);\n                    if(j == n-1) {\n                        break;\n                    }\n                    gcd = gcd(gcd, Math.abs(a[j]-a[++j]));\n                } else {\n                    int k = j-1;\n                    long temp = Math.abs(a[j]-a[k]);\n                    long temp2 = temp;\n                    while(temp > 1) {\n                        temp2 = temp;\n                        temp = gcd(temp, Math.abs(a[k]-a[--k]));\n                    }\n                    i = k+1;\n                    gcd = temp2;\n                    while(j < n-1 && gcd == 1) {\n                        i++;\n                        j++;\n                        gcd = Math.abs(a[i]-a[j]);\n                    }\n                    if(j == n-1 && gcd == 1) {\n                        break;\n                    }\n                }\n            }\n            out.println(ans);\n        }\n        f.close();\n        out.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class D {\n    public static void main(String[] args) throws IOException{\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        int t = Integer.parseInt(f.readLine());\n        while(t-->0){\n            int n = Integer.parseInt(f.readLine());\n            long[] arr = new long[n];\n            StringTokenizer st = new StringTokenizer(f.readLine());\n            for(int i = 0; i < n; i++){\n                arr[i] = Long.parseLong(st.nextToken());\n            }\n            if(n == 1){\n                out.println(1);\n                continue;\n            }\n            long[] diffs = new long[n-1];\n            for(int i = 0; i < n-1; i++){\n                diffs[i] = arr[i+1]-arr[i];\n            }\n            SegmentTree segtree = new SegmentTree(0, n-1);\n            for(int i = 0; i < n-1; i++) segtree.update(i, Math.abs(diffs[i]));\n            int left = 0;\n            int right = 0;\n            int maxL = 0;\n            while(left < n-1 && right < n-1){\n                long ans = segtree.query(left, right);\n                if(ans > 1){\n                    maxL = Math.max(maxL, right-left+1);\n                    right++;\n                }else{\n                    left++;\n                    right++;\n                }\n            }\n            out.println(maxL+1);\n        }\n\n        out.close();\n    }\n    static class SegmentTree\n    {\n        //Tlatoani's segment tree\n        //iterative implementation = low constant runtime factor\n        //range query, non lazy\n        final long[] val;\n        final int treeFrom;\n        final int length;\n\n        public SegmentTree(int treeFrom, int treeTo)\n        {\n            this.treeFrom = treeFrom;\n            int length = treeTo - treeFrom + 1;\n            int l;\n            for (l = 0; (1 << l) < length; l++);\n            val = new long[1 << (l + 1)];\n            this.length = 1 << l;\n        }\n        public void update(int index, long delta)\n        {\n            //replaces value\n            int node = index - treeFrom + length;\n            val[node] = delta;\n            for (node >>= 1; node > 0; node >>= 1)\n                val[node] = comb(val[node << 1], val[(node << 1) + 1]);\n        }\n        public long query(int from, int to)\n        {\n            //inclusive bounds\n            if (to < from)\n                return 0; //0 or 1?\n            from += length - treeFrom;\n            to += length - treeFrom + 1;\n            //0 or 1?\n            long res = 0;\n            for (; from + (from & -from) <= to; from += from & -from)\n                res = comb(res, val[from / (from & -from)]);\n            for (; to - (to & -to) >= from; to -= to & -to)\n                res = comb(res, val[(to - (to & -to)) / (to & -to)]);\n            return res;\n        }\n        public long comb(long a, long b)\n        {\n            //change this\n            return gcd(a,b);\n        }\n        private long gcd(long a, long b)\n        {\n            if(a > b)\n                a = (a+b)-(b=a);\n            if(a == 0L)\n                return b;\n            return gcd(b%a, a);\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom functools import reduce\nfrom math import gcd\n\n \ndef main():\n\n\tdef discrete_binary_search(func, lo, hi):\n\t    \"\"\" Locate the first value x s.t. func(x) = True within [lo, hi] \"\"\"\n\t    while lo < hi:\n\t        mi = lo + (hi - lo) // 2\n\t        if func(mi):\n\t            hi = mi\n\t        else:\n\t            lo = mi + 1\n\n\t    return lo\n\n\tdef check(l):\n\t\tfor i in range(n-l):\n\t\t\tg = spt.query(i, i+l)\n\t\t\tif g > 1:\n\t\t\t\treturn False\n\t\treturn True\n\n\tclass RangeQuery:\n\t    def __init__(self, data, func=min):\n\t        self.func = func\n\t        self._data = _data = [list(data)]\n\t        i, n = 1, len(_data[0])\n\t        while 2 * i <= n:\n\t            prev = _data[-1]\n\t            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n\t            i <<= 1\n \n\t    def query(self, start, stop):\n\t        \"\"\"func of data[start, stop)\"\"\"\n\t        depth = (stop - start).bit_length() - 1\n\t        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n \n\t    def __getitem__(self, idx):\n\t        return self._data[0][idx]\n \n\tinp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n \n\tt = inp[ii]; ii += 1\n\tfor _ in range(t):\n\t\tn = inp[ii]; ii += 1\n\t\tar = inp[ii:ii+n]; ii += n\n\t\t\n\t\tar2 = [ar[i+1] - ar[i] for i in range(n-1)]\n\t\t#print(ar2)\n\n\t\tspt = RangeQuery(ar2, gcd)\n \n\t\tprint(discrete_binary_search(check, 1, n))\n \n \n \n\t\t\n \n \nmain()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class D{\n\t\nstatic long gcd(long a,  long  b) {\n\tif (a==0) return b;\n\treturn gcd(b%a,a);\n}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t// br = new BufferedReader(new FileReader(\".in\"));\n\t\t// out = new PrintWriter(new FileWriter(\".out\"));\n\t\t//new Thread(null, new (), \"peepee\", 1<<28).start();\n\t\tint t= readInt();\n\t\twhile(t-->0) {\n\t\t\tint n =readInt();\n\t\t\tlong[]  a = new long[n];\n\t\t\tint  ans  = 1;\n\t\t\tfor (int i = 0; i  < n; i++)a[i]=readLong();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t//System.out.println(\"Testing index \" + i);\n\t\t\t\tlong gcd = 0;\n\t\t\t\tint new_m = 0;\n\t\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\t\tgcd = gcd(gcd,a[j]-a[i]);\n\t\t\t\t\tif (gcd != 1 && gcd != -1) {\n\t\t\t\t\t\t//System.out.println(\"Works from \" + i + \" to \" + j + \": \" + gcd);\n\t\t\t\t\t\tans = max(j-i+1,ans);\n\t\t\t\t\t\tnew_m = j;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\ti = max(i, new_m-50);\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\t\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tstatic StringTokenizer st = new StringTokenizer(\"\");\n\tstatic String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n\tstatic int readInt() throws IOException{return Integer.parseInt(read());}\n\tstatic long readLong() throws IOException{return Long.parseLong(read());}\n\tstatic double readDouble() throws IOException{return Double.parseDouble(read());}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int gcd(long long int A, long long int B) {\n  if (B == 0)\n    return A;\n  else\n    return gcd(B, A % B);\n}\nvoid build(vector<long long int>& a, int v, int tl, int tr,\n           vector<long long int>& t) {\n  if (tl == tr) {\n    t[v] = a[tl];\n  } else {\n    int tm = (tl + tr) / 2;\n    build(a, v * 2, tl, tm, t);\n    build(a, v * 2 + 1, tm + 1, tr, t);\n    t[v] = gcd(t[v * 2], t[v * 2 + 1]);\n  }\n}\nlong long int g(int v, int tl, int tr, int l, int r, vector<long long int>& t) {\n  if (l > r) return 0;\n  if (l == tl && r == tr) {\n    return t[v];\n  }\n  int tm = (tl + tr) / 2;\n  return gcd(g(v * 2, tl, tm, l, min(r, tm), t),\n             g(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, t));\n}\nbool check(int n, long long int mid, vector<long long int>& t) {\n  for (int i = 0; i <= n - mid; i++) {\n    if (g(1, 0, n - 1, i, i + mid - 1, t) != 1) {\n      return true;\n    }\n  }\n  return false;\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<long long int> v(n);\n  for (int i = 0; i < n; i++) cin >> v[i];\n  ;\n  vector<long long int> t(4 * n);\n  vector<long long int> a(n - 1);\n  if (n == 1) {\n    cout << \"1\\n\";\n    return;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    a[i] = abs(v[i] - v[i + 1]);\n  }\n  build(a, 1, 0, n - 2, t);\n  int l = -1;\n  int r = n;\n  while (r - l > 1) {\n    int mid = (l + r) / 2;\n    if (check(n - 1, mid, t)) {\n      l = mid;\n    } else {\n      r = mid;\n    }\n  }\n  cout << l + 1 << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  cin >> t;\n  for (int i = 1; i <= t; i++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\ntesting = len(sys.argv) == 4 and sys.argv[3] == \"myTest\"\ninteractive = False\nif testing:\n    cmd = sys.stdout\n    from time import time\n    start_time = int(round(time() * 1000)) \n    readAll = open(sys.argv[1], 'r').read\n    sys.stdout = open(sys.argv[2], 'w')\nelse:\n    readAll = sys.stdin.read\n\n# ############ ---- I/O Functions ---- ############\n\nclass InputData:\n    def __init__(self):\n        self.lines = readAll().split('\\n')\n        self.n = len(self.lines)\n        self.ii = -1\n    def input(self):\n        self.ii += 1\n        assert self.ii < self.n\n        return self.lines[self.ii]\n\nflush = sys.stdout.flush\nif interactive and not testing:\n    input = sys.stdin.readline\nelse:\n    inputData = InputData()\n    input = inputData.input\n\ndef intin():\n    return(int(input()))\ndef intlin():\n    return(list(map(int,input().split())))\ndef chrin():\n    return(list(input()))\ndef strin():\n    return input()\ndef lout(l, sep=\"\\n\", toStr=True):\n    print(sep.join(map(str, l) if toStr else l))\ndef dout(*args, **kargs):\n    if not testing: return\n    if args: print(args[0] if len(args)==1 else args)\n    if kargs: print([(k,v) for k,v in kargs.items()])\ndef ask(q):\n    sys.stdout.write(str(q)+'\\n')\n    flush()\n    return intin()\n    \n# ############ ---- I/O Functions ---- ############\n\n# from math import ceil\nfrom collections import defaultdict as ddict, Counter\n# from heapq import *\n# from Queue import Queue\nclass ST:\n    def __init__(self, a, f):\n        self.n = len(a)\n        self.f = f\n        self.tree = [None]*(2*self.n)\n        self.build(a)\n\n    def build(self, a):\n        for i in xrange(self.n):\n            self.tree[self.n+i] = a[i]\n        for i in xrange(self.n-1,0,-1):\n            self.tree[i] = self.f(self.tree[i<<1], self.tree[i<<1 | 1])\n    \n    def update(self, i, v):\n        i += self.n\n        self.tree[i] = v\n        while i > 1:\n            self.tree[i>>1] = self.f(self.tree[i], self.tree[i^1])\n            i >>= 1\n\n    def query(self, l, r):\n        #to find the sum in the range [l,r)\n        v = 0\n        l,r = (l+self.n,self.n+r)\n        while l < r:\n            if (l&1)>0:\n                v = self.f(v, self.tree[l])\n                l += 1\n            if (r&1)>0:\n                r -= 1\n                v = self.f(v, self.tree[r])\n            l >>= 1\n            r >>= 1\n        return v\n \ndef gcd(a, b):\n    while b:\n        a, b = b, a%b\n    return a\n\ndef main():\n    n = intin()\n    a = intlin()\n    if n == 1:\n        return 1\n    b = [abs(a[i] - a[i-1]) for i in xrange(1,n)]\n    ans = 1 + int(max(b)>1)\n    dout(b)\n    st = ST(b, gcd)\n    i = 0\n    j = 1\n    while i < len(b) and j < len(b):\n        if st.query(i,j+1) != 1:\n            ans = max(ans, j-i+2)\n            j += 1\n        else:\n            i += 1\n            if i == j:\n                j = i+1\n    return ans\n\n\n\n\nanss = []\nfor _ in xrange(intin()):\n    anss.append(main())\n    # anss.append(\"YES\" if main() else \"NO\")\nlout(anss)\n\nif testing:\n    sys.stdout = cmd\n    print(int(round(time() * 1000))  - start_time)"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while y!=0:\n            x, y=y, x%y\n        return x\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    c=0\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][c], St[j+upton][c])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2\n        c+=1\n\n #   total=bmax\n #   c=int(0.5+math.log2(bmax))\n #   k=0\n #   while k+total<n:\n #       if St[k][c]!=1:\n #           start=total+1\n #           end=min(n-k-1, bmax*2-1)\n #           while start<=end:\n #               j=(start+end)//2\n #               if HCF(St[k][c], St[k+j-2**c][c])!=1:\n #                   total=j\n #                   start=j+1\n #               else:\n #                   end=j-1    \n #       k+=1\n\n    def possible_group(x, y):\n        c=b[x]\n        for i in range(x+1, y):\n            c=HCF(c, b[i])\n            if c==1:\n                return False\n        return True        \n\n    total=bmax\n    start=bmax+1\n    end=min(n-1, bmax*2-1)\n    c=int(0.5+math.log2(bmax))\n    startk=0\n    while start<=end:\n        j=(start+end)//2\n        for k in range(startk, n-j):            \n            if HCF(St[k][c], St[k+j-2**c][c])!=1:\n                total=j\n                start=j+1\n                startk=k\n                break\n        if start<=j:\n            end=j-1\n            \n    \n    print(total+1)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 3,
            "solution": "# ///////////////////////////////////////////////////////////////////////////\n# //////////////////// PYTHON IS THE BEST ////////////////////////\n# ///////////////////////////////////////////////////////////////////////////\nimport sys,os,io\nfrom sys import stdin\nimport math \nfrom collections import defaultdict\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left , bisect_right\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\n\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\n\n\n#for deep recursion__________________________________________-\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\ndef ncr(n, r, p):  \n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,p - 2, p)) % p\n\ndef primeFactors(n): \n    l = []\n    while n % 2 == 0: \n        l.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i== 0: \n            l.append(int(i))\n            n = n / i \n    if n > 2: \n        l.append(n)\n    # c = dict(Counter(l))\n    return list(set(l))\n    # return c\n\ndef power(x, y, p) : \n\tres = 1\n\tx = x % p \n\tif (x == 0) : \n\t\treturn 0\n\twhile (y > 0) : \n\t\tif ((y & 1) == 1) : \n\t\t\tres = (res * x) % p \n\t\ty = y >> 1\t # y = y/2 \n\t\tx = (x * x) % p \t\t\n\treturn res \n\n#____________________GetPrimeFactors in log(n)________________________________________\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if (spf[i] == i):\n            for j in range(i * i, MAXN, i): \n                if (spf[j] == j):\n                    spf[j] = i\n    return spf\ndef getPrimeFactorizationLOGN(x):\n    spf = sieveForSmallestPrimeFactor()\n    ret = list()\n    while (x != 1):\n        ret.append(spf[x])\n        x = x // spf[x]  \n    return ret\n#____________________________________________________________\n\n\n\ndef SieveOfEratosthenes(n): \n    #time complexity = nlog(log(n))\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef si():\n    return input()\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n//x\n    return n//x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\n\n\n# ///////////////////////////////////////////////////////////////////////////\n# //////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n# ///////////////////////////////////////////////////////////////////////////\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\") \nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n    input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nclass RangeQuery:\n    def __init__(self, data, func=math.gcd):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n\n    def __getitem__(self, idx):\n        return self._data[0][idx]\n\ndef fun(mid,s,n):\n    f = 0\n    for i in range(n-mid+1):\n        if s.query(i,i+mid)>1:\n            f = 1\n    return f\n\n\ndef solve():\n    n = ii()\n    a = li()\n    d = [abs(a[i+1]-a[i]) for i in range(0,n-1)]\n    s = RangeQuery(d)\n    low = 1\n    high = n-1\n    ans = 0\n    # print(d)\n    while low<=high:\n        mid = (low+high)//2\n        if fun(mid,s,n-1)==1:\n            low = mid+1\n            ans = mid\n        else:\n            high = mid-1\n    \n    print(ans+1)\n\n\nt = 1\nt = ii()\nfor _ in range(t):\n    solve()\n"
        },
        {
            "language": 3,
            "solution": "import math\nimport sys\ninput=sys.stdin.readline\ndef range_gcd(l,r):\n    global li\n    que=int(math.log(r-l+1,2))+1\n    return math.gcd(li[que-1][l],li[que-1][r+1-(1<<(que-1))])\n    \ndef binary(ind,l,r):\n    global data,n,br\n    while(True):\n        mid=(l+r)//2\n        if(r-l<=1):\n            if(range_gcd(ind+1, r)>=2):\n                return r\n            elif(range_gcd(ind+1, l)>=2):\n                 return l\n            else:\n                return ind\n        if(range_gcd(ind+1,mid,)>=2):\n            l=mid\n        else:\n            r=mid-1\n            \n\nfor _ in range(int(input())):\n    n=int(input())\n    br=list(map(int,input().split()))\n    ar=[0]\n    for i in range(1,n):\n        ar.append(br[i]-br[i-1])\n    arle=n\n    le=int(math.log(n,2))\n    li=[ar.copy()]\n    st=1\n    for i in range(le):\n        li.append([])\n        for j in range(arle-st):\n            li[-1].append(math.gcd(li[-2][j],li[-2][j+st]))\n        arle-=(st)\n        st<<=1\n    \n    ans=1\n    for i in range(n-1):\n        xx=binary(i, i+1, n-1)\n        ans=max(ans,xx-i+1)\n    print(ans)\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ans;\nlong long n, m, l, r, t, a[200000], b, prevb;\nlong long i, j, k;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nvoid solution() {\n  cin >> n;\n  ;\n  if (n == 1) {\n    cin >> b;\n    ;\n    cout << 1 << \"\\n\";\n    ;\n  } else {\n    n--;\n    ans = 0;\n    cin >> prevb;\n    ;\n    for (i = 0; i < n; i++) {\n      cin >> b;\n      a[i] = abs(prevb - b);\n      prevb = b;\n    }\n    i = 0;\n    while ((a[i] == 1) && (i < n)) {\n      i++;\n    }\n    if (i < n) {\n      t = 2;\n      m = a[i];\n    } else {\n      t = 1;\n    }\n    for (i++; i < n; i++) {\n      m = gcd(m, a[i]);\n      if (m == 1) {\n        if (t > ans) {\n          ans = t;\n        }\n        while ((a[i] == 1) && (i < n)) {\n          i++;\n        }\n        if (i < n) {\n          t = 2;\n          m = a[i];\n        } else {\n          t = 1;\n          break;\n        }\n        l = gcd(m, a[i - 1]);\n        for (j = i - 2; l != 1; j--) {\n          m = l;\n          l = gcd(m, a[j]);\n          t++;\n        }\n      } else {\n        t++;\n      }\n    }\n    if (t > ans) {\n      ans = t;\n    }\n    cout << ans << \"\\n\";\n    ;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  long long ttt;\n  cin >> ttt;\n  ;\n  while (ttt--) {\n    solution();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nt=int(input())\nfor _ in range(t):\n\tn=int(input())\n\ta=[int(x) for x in input().split()]\n\tb=[1]\n\tfor i in range(1,n):\n\t\tb.append(abs(a[i]-a[i-1]))\n\tcur={1:0}\n\tans=0\n\tfor i in range(1,n):\n\t\tg=b[i]\n\t\td={}\n\t\td[g]=i\n\t\tif (g!=1):\n\t\t\ttmp=sorted(list(cur.keys()))\n\t\t\ttmp.reverse()\n\t\t\tfor j in tmp:\n\t\t\t\tg=math.gcd(g,j)\n\t\t\t\tif (g not in d):\n\t\t\t\t\td[g]=cur[j]\n\t\t\t\tif (g==1):\n\t\t\t\t\tans=max(ans,i-cur[j])\n\t\t\t\t\tbreak\n\t\tcur=d.copy()\n\tprint(ans+1)"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class First {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        //int a = 1;\n        int t;\n        t = in.nextInt();\n        //t = 1;\n        while (t > 0) {\n            //out.print(\"Case #\"+(a++)+\": \");\n            solver.call(in,out);\n            t--;\n        }\n        out.close();\n\n    }\n\n    static class TaskA {\n        public void call(InputReader in, PrintWriter out) {\n            int n, a = 0, k = 25;\n            n = in.nextInt();\n            long[] array = new long[n];\n            long[][] st = new long[n][k+1];\n\n            for(int i = 0; i < n; i++){\n                array[i] = in.nextLong();\n            }\n            long[] arr = new long[n];\n\n            for(int i = 1; i <= n-1; i++){\n                arr[i] = Math.abs(array[i-1] - array[i]);\n            }\n\n            for (int i = 1; i <= n- 1; i++)\n                st[i][0] = (arr[i]);\n\n            for (int j = 1; j <= k; j++) {\n                for (int i = 1; i + (1 << j) <= n; i++) {\n                    st[i][j] = gcd(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n                }\n            }\n\n            int[] log = new int[n+10];\n            log[1] = 0;\n            for(int i = 2; i < n+ 10; i++){\n                log[i] = 1 + log[i/2];\n            }\n\n            int l, r, mid, ans = 0;\n            for(int i = 1; i <= n - 1; i++){\n                l = i-1;\n                r = n;\n\n                while(l + 1 < r){\n                    mid = (l+r)/2;\n                    int j = log[mid - i + 1];\n                    long gcd = gcd(st[i][j], st[mid - (1 << j) + 1][j]);\n                    if(gcd!=1){\n                        l = mid;\n                    }\n                    else{\n                        r = mid;\n                    }\n                }\n                ans = Math.max(ans, l - i + 2);\n            }\n            ans = Math.max(ans, 1);\n            out.println(ans);\n\n        }\n    }\n\n    static class answer implements Comparable<answer>{\n        int a, b;\n\n        public answer(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(answer o) {\n            if(this.a == o.a){\n                return this.b - o.b;\n            }\n            return this.a - o.a;\n        }\n    }\n\n    static class answer1 implements Comparable<answer1>{\n        int a, b, c;\n\n        public answer1(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n\n        }\n\n        @Override\n        public int compareTo(answer1 o) {\n            if(o.c==this.c){\n                return this.a - o.a;\n            }\n            return o.c - this.c;\n        }\n    }\n\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    static void sort(long[] a) {\n        ArrayList<Long> l=new ArrayList<>();\n        for (Long i:a) l.add(i);\n        l.sort(Collections.reverseOrder());\n        for (int i=0; i<a.length; i++) a[i]=l.get(i);\n    }\n\n    static final Random random=new Random();\n\n    static void shuffleSort(int[] a) {\n        int n=a.length;\n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n), temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long rd() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n  return x * f;\n}\nlong long t, n;\nlong long a[400010];\nlong long c[400010][20];\nlong long lg[400010];\ninline long long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long ask(long long a, long long b) {\n  long long lo = lg[b - a + 1];\n  long long po = 1 << lo;\n  return gcd(c[a][lo], c[b - po + 1][lo]);\n}\nbool check(long long len) {\n  for (register long long i = 1; i <= n - 1; ++i) {\n    long long x = i, y = (i + len) - 1;\n    if (y >= n) break;\n    if (ask(x, y) > 1) return 1;\n  }\n  return 0;\n}\nint main() {\n  lg[0] = -1;\n  for (register long long i = 1; i <= 400000; ++i) lg[i] = lg[i >> 1] + 1;\n  t = rd();\n  while (t--) {\n    long long res = 0;\n    n = rd();\n    for (register long long i = 1; i <= n; ++i) a[i] = rd();\n    for (register long long i = 1; i <= n - 1; ++i)\n      c[i][0] = abs(a[i + 1] - a[i]);\n    for (long long i = 1; i <= lg[n]; i++)\n      for (long long j = 1; j + (1 << i) - 1 <= n; j++) {\n        long long po = 1 << (i - 1);\n        c[j][i] = gcd(c[j][i - 1], c[j + po][i - 1]);\n      }\n    long long l = 1, r = n;\n    while (l < r) {\n      long long mid = (l + r) / 2;\n      if (check(mid))\n        l = mid + 1, res = mid;\n      else\n        r = mid;\n    }\n    printf(\"%lld\\n\", res + 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nusing ll = long long int;\nusing ld = long double;\nusing pi = pair<int, int>;\nconst double PI = acos(-1.0);\nconst double eps = 1e-9;\nconst ll mod = 1e9 + 7;\nconst int inf = 1e7;\nconst int MAXN = 2e5 + 5;\nll gcd(ll a, ll b) {\n  if (b == 0)\n    return a;\n  else\n    return gcd(b, a % b);\n}\nint lg[MAXN];\nvoid init() {\n  lg[1] = 0;\n  for (int i = 2; i < MAXN; i++) lg[i] = lg[i / 2] + 1;\n}\nusing ftype = ll;\nconst int K = 25;\nftype st[MAXN][K + 1];\nftype combine(ftype L, ftype R) { return gcd(L, R); }\nvoid build(vector<ftype> &arr) {\n  int n = ((int)arr.size());\n  for (int i = 0; i < n; i++) st[i][0] = arr[i];\n  for (int j = 1; j <= K; j++)\n    for (int i = 0; i + (1 << (j - 1)) < n; i++)\n      st[i][j] = combine(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n}\nftype query(int L, int R) {\n  int j = lg[R - L + 1];\n  return combine(st[L][j], st[R - (1 << j) + 1][j]);\n}\nvoid cp() {\n  int n;\n  cin >> n;\n  vector<ll> arr(n);\n  for (ll &x : arr) cin >> x;\n  for (int i = 0; i < n - 1; i++) arr[i] = abs(arr[i] - arr[i + 1]);\n  arr.pop_back();\n  int m = n - 1;\n  build(arr);\n  int ans = 0;\n  for (int i = 0; i < m; i++) {\n    int lo = i, hi = m - 1;\n    while (lo <= hi) {\n      int mid = (lo + hi) >> 1;\n      ll g = query(i, mid);\n      if (g > 1)\n        ans = max(ans, mid - i + 1), lo = mid + 1;\n      else\n        hi = mid - 1;\n    }\n  }\n  cout << ans + 1 << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  int t;\n  t = 1;\n  init();\n  cin >> t;\n  while (t--) {\n    cp();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//Some of the methods are copied from GeeksforGeeks Website  \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main\n{ \n  static  Reader sc=new Reader();\n  // static FastReader sc=new FastReader(System.in);\n  \n  static int max_n=(int)2e5+5;\n  static int max_log=(int)(Math.log(max_n)/Math.log(2));\n  static long st[][]=new long[max_n][max_log+1];\n  static int log[]=new int[max_n];\n  static int n;\n  static long a[];\n  \n \n  static void sparse_table()\n   {\n      for(int i=0;i<n;i++)\n        {\n           st[i][0]=a[i];\n        }\n     for(int j=1;j<=max_log;j++)\n        {\n           for(int i=0;i+(1<<j)<=n;i++)\n             {\n                st[i][j]=gcd(st[i][j-1],st[i+(1<<(j-1))][j-1]);\n             }\n        }\n   }\n\n static long gcd_query(int l,int r)\n  {\n    long gcd= 0;\n    for (int j=max_log;j>=0;j--) \n    {\n      if ((1 << j) <= r - l + 1) \n      {\n        gcd=gcd(gcd,st[l][j]);\n        l += 1 << j;\n       }\n     }\n    return gcd;\n  }\n \n public static void main (String[] args) throws java.lang.Exception\n   {\n\t//try{\n\t  \n\t\t  int t =  sc.nextInt();\n\t\t  while(t-->0)\n\t\t    { \n\t\t       n=sc.nextInt();\n\t\t       long b[]=new long[n];\n\t\t       for(int i=0;i<n;i++)\n\t\t         {\n\t\t           b[i]=sc.nextLong();\n\t\t         }\n\t\t       if(n==1)\n\t\t        {\n\t\t           out.println(n);\n\t\t           continue;\n\t\t        }\n\t\t       n--;\n\t\t       a=new long[n];\n\t\t       for(int i=0;i<n;i++)\n\t\t         a[i]=Math.abs(b[i+1]-b[i]);\n\t\t       \n\t\t       sparse_table();\n\t\t       int longest_seg=0;\n\t\t       for(int right=0;right<n;right++)\n\t\t         {\n\t\t            int l=0;\n\t\t            int r=right;\n\t\t            int left=r;\n\t\t            while(l<=r)\n\t\t              {\n\t\t                 int m=l+(r-l)/2;\n\t\t                 if(gcd_query(m,right)!=1)\n\t\t                   {\n\t\t                      r=m-1;\n\t\t                      left=Math.min(left,r);\n\t\t                   }\n\t\t                else\n\t\t                   {\n\t\t                      l=m+1;\n\t\t                   }\n\t\t              }\n\t\t            longest_seg=Math.max(longest_seg,right-left+1);\n\t\t         }\n\t\t     \n\t\t       out.println(longest_seg);\n\t\t    }\n\t     out.flush();\n\t     out.close();\n// \t   }     \n// \tcatch(Exception e)\n// \t\t {}\n\t}\n \n /*\n   ...SOLUTION ENDS HERE...........SOLUTION ENDS HERE...\n */\n \nstatic void flag(boolean flag)\n   {\n       out.println(flag ? \"YES\" : \"NO\");\n       out.flush();\n   }\n   \n /*                     \n    Map<Long,Long> map=new HashMap<>();\n             for(int i=0;i<n;i++)\n               {\n                  if(!map.containsKey(a[i]))\n                   map.put(a[i],1);\n                 else\n                   map.replace(a[i],map.get(a[i])+1);\n               }\n     \n    Set<Map.Entry<Long,Long>> hmap=map.entrySet();\n             for(Map.Entry<Long,Long> data : hmap)\n               {\n          \n               }\n       \n   Iterator<Integer> it = set.iterator();\n          while(it.hasNext()) \n           { \n            int x=it.next();\n           }\n   */\n\nstatic void print(int a[])\n  {\n     int n=a.length;\n     for(int i=0;i<n;i++)\n       {\n          out.print(a[i]+\" \");\n       }\n     out.println();\n     out.flush();\n  }\nstatic void print(long a[])\n  {\n     int n=a.length;\n     for(int i=0;i<n;i++)\n       {\n          out.print(a[i]+\" \");\n       }\n     out.println();\n     out.flush();\n  } \nstatic void print_int(ArrayList<Integer> al)\n  {\n     int si=al.size();\n     for(int i=0;i<si;i++)\n       {\n          out.print(al.get(i)+\" \");\n       }\n     out.println();\n     out.flush();\n  }\nstatic void print_long(ArrayList<Long> al)\n  {\n     int si=al.size();\n     for(int i=0;i<si;i++)\n       {\n          out.print(al.get(i)+\" \");\n       }\n     out.println();\n     out.flush();\n  }\n  \nstatic int LowerBound(int a[], int x) \n { // x is the target value or key\n  int l=-1,r=a.length;\n  while(l+1<r) {\n    int m=(l+r)>>>1;\n    if(a[m]>=x) r=m;\n    else l=m;\n  }\n  return r;\n}\n\n static int UpperBound(int a[], int x)\n  {// x is the key or target value\n    int l=-1,r=a.length;\n    while(l+1<r) {\n       int m=(l+r)>>>1;\n       if(a[m]<=x) l=m;\n       else r=m;\n    }\n    return l+1;\n }\nstatic class Graph\n  {\n        int v;\n        ArrayList<Integer> list[];\n        Graph(int v)\n        {\n            this.v=v;\n            list=new ArrayList[v+1];\n            for(int i=1;i<=v;i++)\n                list[i]=new ArrayList<Integer>();\n        }\n        void addEdge(int a, int b)\n        {\n            this.list[a].add(b);\n        }\n    }\nstatic void DFS(Graph g, boolean[] visited, int u)\n\t{\n        visited[u]=true;\n        int v=0;\n        for(int i=0;i<g.list[u].size();i++)\n        {\n            v=g.list[u].get(i);\n            if(!visited[v])\n               DFS(g,visited,v);\n        }\n  } \n  \n// static class Pair\n//    {\n//       int x,y;\n//       Pair(int x,int y)\n//        {\n//           this.x=x;\n//           this.y=y;\n//        }\n//    }\n   \nstatic long sum_array(int a[])\n {\n    int n=a.length;\n    long sum=0;\n    for(int i=0;i<n;i++)\n     sum+=a[i];\n    return sum;\n }\nstatic long sum_array(long a[])\n {\n    int n=a.length;\n    long sum=0;\n    for(int i=0;i<n;i++)\n     sum+=a[i];\n    return sum;\n }\n\n static void sort(int[] a) \n   {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\nstatic void sort(long[] a) \n   {\n\t\tArrayList<Long> l=new ArrayList<>();\n\t\tfor (long i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\nstatic void reverse_array(int a[])\n {\n    int n=a.length;\n    int i,t; \n    for (i = 0; i < n / 2; i++) { \n            t = a[i]; \n            a[i] = a[n - i - 1]; \n            a[n - i - 1] = t; \n        } \n }\nstatic void reverse_array(long a[])\n {\n    int n=a.length;\n    int i; long t; \n    for (i = 0; i < n / 2; i++) { \n            t = a[i]; \n            a[i] = a[n - i - 1]; \n            a[n - i - 1] = t; \n        } \n }\n static long modInverse(long a, long m)\n\t    {\n\t        long g = gcd(a, m);\n\t       \n\t          return   power(a, m - 2, m);\n\t        \n\t    }\nstatic long power(long x, long y, long m)\n\t    {\n\t        if (y == 0)\n\t            return 1;\n\t        long p = power(x, y / 2, m) % m;\n\t        p = (int)((p * (long)p) % m);\n\t        if (y % 2 == 0)\n\t            return p;\n\t        else\n\t            return (int)((x * (long)p) % m);\n\t    }\nstatic long gcd(long a, long b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \nstatic int gcd(int a, int b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \n\n   static class FastReader{\n \n        byte[] buf = new byte[2048];\n        int index, total;\n        InputStream in;\n \n        FastReader(InputStream is) {\n            in = is;\n        }\n \n        int scan() throws IOException {\n            if (index >= total) {\n                index = 0;\n                total = in.read(buf);\n                if (total <= 0) {\n                    return -1;\n                }\n            }\n            return buf[index++];\n        }\n \n        String next() throws IOException {\n            int c;\n            for (c = scan(); c <= 32; c = scan());\n            StringBuilder sb = new StringBuilder();\n            for (; c > 32; c = scan()) {\n                sb.append((char) c);\n            }\n            return sb.toString();\n        }\n \n        int nextInt() throws IOException {\n            int c, val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n \n        long nextLong() throws IOException {\n            int c;\n            long val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n    }\n   \n    static class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    }\n  static  PrintWriter out=new PrintWriter(System.out);\n  static int int_max=Integer.MAX_VALUE;\n  static int int_min=Integer.MIN_VALUE;\n  static long long_max=Long.MAX_VALUE;\n  static long long_min=Long.MIN_VALUE;\n}\n// Thank You !"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\nvector<vector<long long>> gcd_sparse_table(vector<long long>& d) {\n  int N = d.size();\n  int K = ceil(log2(N));\n  vector<vector<long long>> sparse_table(N, vector<long long>(K + 1));\n  for (int i = 0; i < N; i++) {\n    sparse_table[i][0] = d[i];\n  }\n  for (int j = 1; j <= K; j++) {\n    for (int i = 0; i + (1 << j) <= N; i++) {\n      sparse_table[i][j] =\n          gcd(sparse_table[i][j - 1], sparse_table[i + (1 << (j - 1))][j - 1]);\n    }\n  }\n  return sparse_table;\n}\nlong long range_gcd(vector<vector<long long>>& sparse_table, int i, int j) {\n  int k = floor(log2(j - i + 1));\n  return gcd(sparse_table[i][k], sparse_table[j - (1 << k) + 1][k]);\n}\nint main() {\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    if (n == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    vector<long long> d(n - 1);\n    for (int i = 0; i < n - 1; i++) {\n      d[i] = a[i + 1] - a[i];\n    }\n    vector<vector<long long>> sparse_table = gcd_sparse_table(d);\n    int largest_friend_group = 1;\n    int l = 0;\n    int r = 0;\n    while (r < n - 1) {\n      if (abs(range_gcd(sparse_table, l, r)) != 1) {\n        largest_friend_group = max(largest_friend_group, r - l + 2);\n      } else {\n        l++;\n      }\n      r++;\n    }\n    cout << largest_friend_group << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class D {\n    public static void main(String[] args) throws IOException {\n        Reader scan = new Reader();\n        PrintWriter pw = new PrintWriter(System.out);\n        StringBuilder sb = new StringBuilder();\n\n        int t = scan.nextInt();\n        while(t-- > 0) {\n            int n = scan.nextInt();\n            long[] a = new long[n];\n            for(int i=0;i<n;i++) {\n                a[i] = scan.nextLong();\n            }\n            if(n == 1) {\n                sb.append(1).append('\\n');\n            }else {\n                int m = n - 1;\n                long[] tree = new long[4 * m];\n                long[] diff = new long[m];\n                for (int i = 0; i < n - 1; i++) {\n                    diff[i] = Math.abs(a[i] - a[i + 1]);\n                }\n                long root = constructTree(0, m - 1, 0, diff, tree);\n                int left = 0;\n                int right = -1;\n                long ans = 0;\n                long temp = 0;\n                while (right < n - 2) {\n                    while (right < n - 2) {\n                        right++;\n                        temp = gcd(temp, diff[right]);\n                        if (temp == 1) break;\n                        ans = Math.max(ans, right - left + 1);\n                    }\n                    while (left <= right) {\n                        left++;\n                        temp = check(left, right, 0, m - 1, 0, tree);\n                        if (temp != 1) break;\n                    }\n                }\n                sb.append(ans+1).append('\\n');\n            }\n        }\n        pw.print(sb);\n        pw.close();\n    }\n//    static boolean possible(long[] a, int len, long[] tree) {\n//        int i=0;\n//        int j = len - 1;\n//        while(j < a.length - 1) {\n//            if(check(i, j, 0, a.length - 2, 0, tree) > 1)\n//                return true;\n//            i++;\n//            j++;\n//        }\n//        return false;\n//    }\n    static long check(int i, int j, int start, int end, int index, long[] tree) {\n        if(end < i || start > j) {\n            return 0;\n        }\n        if(i <= start && j >= end)\n            return tree[index];\n        int mid = start + (end - start)/2;\n        long temp1 = check(i, j, start, mid, (2*index) + 1, tree);\n        long temp2 = check(i, j, mid+1, end, (2*index) + 2, tree);\n        return gcd(temp1, temp2);\n    }\n    static long gcd(long a, long b) {\n        if(b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    static long constructTree(int start, int end, int index, long[] diff, long[] tree) {\n        if(start == end) {\n            tree[index] = diff[start];\n            return tree[index];\n        }\n        int mid = start + ((end - start)/2);\n        tree[index] = gcd(constructTree(start, mid, (2*index) + 1, diff, tree), constructTree(mid + 1, end, (2*index) + 2, diff, tree));\n        return tree[index];\n    }\n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\npublic class d1549 implements Runnable{\n\t\n    public static void main(String[] args) {\n    \ttry{\n            new Thread(null, new d1549(), \"process\", 1<<26).start();\n        }\n        catch(Exception e){\n            System.out.println(e);\n        }\n    }\n\tpublic void run() {\n\t\tFastReader scan = new FastReader();\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t//PrintWriter out = new PrintWriter(\"file.out\");\n\t\tTask solver = new Task();\n\t\tint t = scan.nextInt();\n\t\t//int t = 1;\n\t\tfor(int i = 1; i <= t; i++) solver.solve(i, scan, out);\n\t\tout.close();\n\t}\n\n\tstatic class Task {\n\t\tstatic final int oo = Integer.MAX_VALUE;\n\t\tstatic final long OO = Long.MAX_VALUE;\n\n\t\tpublic void solve(int testNumber, FastReader sc, PrintWriter out) {\n\t\t\tint N = sc.nextInt();\n\t\t\t\n\t\t\tlong[] arr = sc.readLongArray(N);\n\t\t\t\n\t\t\tif(N == 1) {\n\t\t\t\tout.println(1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tlong[] diff = new long[N-1];\n\t\t\tfor(int i = 1; i < N; i++) {\n\t\t\t\tdiff[i-1] = Math.abs(arr[i] - arr[i-1]);\n\t\t\t}\n\n\t\t\tconstructSegmentTree(diff);\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0, j = 0; i < N-1; i++) {\n\t\t\t\t\n\t\t\t\twhile(i != j && findRangeGcd(j, i, diff) < 2) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, i-j+2);\n\t\t\t}\n\t\t\t\n\t\t\tboolean flag=  true;\n\t\t\tfor(long each: diff)\n\t\t\t\tif(each != 1)\n\t\t\t\t\tflag = false;\n\t\t\t\n\t\t\tif(flag) {\n\t\t\t\tout.println(1);\n\t\t\t} else \n\t\t\t\tout.println(max);\n\t\t}\n\t\t\n\t\tprivate static long[] st;\n\t    public static long[] constructSegmentTree(long[] arr)\n\t    {\n\t        int height = (int)Math.ceil(Math.log(arr.length)/Math.log(2));\n\t        int size = 2*(int)Math.pow(2, height)-1;\n\t        st = new long[size];\n\t        constructST(arr, 0, arr.length-1, 0);\n\t        return st;\n\t    }\n\t  \n\t    public static long constructST(long[] arr, int ss,\n\t                                  int se, int si)\n\t    {\n\t        if (ss==se)\n\t        {\n\t            st[si] = arr[ss];\n\t            return st[si];\n\t        }\n\t        int mid = ss+(se-ss)/2;\n\t        st[si] = gcd(constructST(arr, ss, mid, si*2+1),\n\t                     constructST(arr, mid+1, se, si*2+2));\n\t        return st[si];\n\t    }\n\t  \n\t    private static long gcd(long a, long b)\n\t    {\n\t        if (a < b)\n\t        {\n\t            long temp = b;\n\t            b = a;\n\t            a = temp;\n\t        }\n\t  \n\t        if (b==0)\n\t            return a;\n\t        return gcd(b,a%b);\n\t    }\n\t  \n\t    public static long findRangeGcd(int ss, int se, long[] arr)\n\t    {\n\t        int n = arr.length;\n\t  \n\t        if (ss<0 || se > n-1 || ss>se)\n\t            throw new IllegalArgumentException(\"Invalid arguments\");\n\t  \n\t        return findGcd(0, n-1, ss, se, 0);\n\t    }\n\t  \n\t    public static long findGcd(int ss, int se, int qs, int qe, int si)\n\t    {\n\t        if (ss>qe || se < qs)\n\t            return 0;\n\t  \n\t        if (qs<=ss && qe>=se)\n\t            return st[si];\n\t  \n\t        int mid = ss+(se-ss)/2;\n\t  \n\t        return gcd(findGcd(ss, mid, qs, qe, si*2+1),\n\t                   findGcd(mid+1, se, qs, qe, si*2+2));\n\t    }\n\t\t\n\t}\n\tstatic long modInverse(long N, long MOD) {\n\t\treturn binpow(N, MOD - 2, MOD);\n\t}\n\tstatic long modDivide(long a, long b, long MOD) {\n\t\ta %= MOD;\n\t\treturn (binpow(b, MOD-2, MOD) * a) % MOD;\n\t}\n\tstatic long binpow(long a, long b, long m) {\n\t\ta %= m;\n\t\tlong res = 1;\n\t\twhile (b > 0) {\n\t\t\tif ((b & 1) == 1)\n\t\t\t\tres = res * a % m;\n\t\t\ta = a * a % m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int[] reverse(int a[]) \n    { \n        int[] b = new int[a.length]; \n        for (int i = 0, j = a.length; i < a.length; i++, j--) { \n            b[j - 1] = a[i]; \n        } \n        \n        return b;\n    }\n\tstatic long[] reverse(long a[]) \n    { \n        long[] b = new long[a.length]; \n        for (int i = 0, j = a.length; i < a.length; i++, j--) { \n            b[j - 1] = a[i]; \n        } \n        \n        return b;\n    }\n\t\n\tstatic void shuffle(Object[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tObject temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t}\n\tstatic void shuffle(long[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tlong temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t}\n\t\n\tstatic class tup implements Comparable<tup>, Comparator<tup>{\n\t\tint a, b;\n\t\ttup(int a,int b){\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\tpublic tup() {\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(tup o){\n\t\t\treturn Integer.compare(b,o.b);\n\t\t}\n\t\t@Override\n\t\tpublic int compare(tup o1, tup o2) {\n\t\t\treturn Integer.compare(o1.b, o2.b);\n\t\t}\n\t\t\n\t\t@Override\n\t    public int hashCode() {\n\t\t\treturn Objects.hash(a, b);\n\t    }\n \n\t    @Override\n\t    public boolean equals(Object obj) {\n\t    \tif (this == obj)\n                return true;\n\t    \tif (obj == null)\n                return false;\n\t    \tif (getClass() != obj.getClass())\n                return false;\n\t    \ttup other = (tup) obj;\n\t    \treturn a==other.a && b==other.b;\n\t    }\n\t    \n\t    @Override\n\t    public String toString() {\n\t    \treturn a + \" \" + b;\n\t    }\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastReader(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t\t\n\t\tint[] readArray(int size) {\n\t\t\tint[] a = new int[size];\n\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tlong[] readLongArray(int size) {\n\t\t\tlong[] a = new long[size];\n\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\ta[i] = nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\tstatic void dbg(int[] arr) {\n\t\tSystem.out.println(Arrays.toString(arr));\n\t}\n\tstatic void dbg(long[] arr) {\n\t\tSystem.out.println(Arrays.toString(arr));\n\t}\n\tstatic void dbg(boolean[] arr) {\n\t\tSystem.out.println(Arrays.toString(arr));\n\t}\n\n\tstatic void dbg(Object... args) {\n        for (Object arg : args)\n            System.out.print(arg + \" \");\n        System.out.println();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.*;\npublic class student {\n    public static int m, n, k;\n    public static long[] arr, pos, log;\n    public static long[][] st;\n\n    public static Scanner obj = new Scanner(System.in);\n    public static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        int length = obj.nextInt();\n        while (length-- != 0) {\n            solve();\n        }\n        out.flush();\n    }\n\n    public static void solve() {\n        m = obj.nextInt();\n        n = m - 1;\n        arr = new long[m];\n        for (int i = 0; i < m; i++) arr[i] = obj.nextLong();\n        if (m == 1) {\n            out.println(1);\n            return;\n        }\n        pos = new long[n];\n        for (int i = 0; i < n; i++) pos[i] = Math.abs(arr[i + 1] - arr[i]);\n        k = (int) (Math.log(m) / Math.log(2));\n        st = new long[n][k + 1];\n        precompute();\n     \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            int j = bs(i);\n            if (j == 1 && st[i][0] == 1) continue;\n            ans = Math.max(ans, j);\n        }\n        out.println(ans + 1);\n    }\n\n    public static void precompute() {\n        log = new long[n + 1];\n        log[1] = 0;\n        for (int i = 2; i <= n; i++) log[i] = log[i / 2] + 1;\n        for (int i = 0; i < n; i++) st[i][0] = pos[i];\n        for (int j = 1; j <= k; j++) {\n            for (int i = 0; i + (1 << j) <= n; i++) {\n                st[i][j] = gcd(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    public static int bs(int i) {\n        int l = i, r = n - 1;\n        int ans = i;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (query(i, mid)) {\n                l = mid + 1;\n                ans = mid;\n            } else r = mid - 1;\n        }\n        return ans - i + 1;\n    }\n\n    public static boolean query(int l, int r) {\n        int j = (int) log[r - l + 1];\n        return gcd(st[l][j], st[r - (1 << j) + 1][j]) >= 2;\n    }\n\n    public static long gcd(long a, long b) {\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n# from typing import *\n\nimport sys\nimport io\nimport math\nimport collections\nimport decimal\nimport itertools\nimport bisect\nimport heapq\n\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\n\n# sys.setrecursionlimit(1000000)\n\n# _INPUT = \"\"\"4\n# 5\n# 1 2 3 4 5\n# 4\n# 8 2 5 10\n# 2\n# 1000 2000\n# 8\n# 465 55 3 54 234 12 45 78\n\n# \"\"\"\n# sys.stdin = io.StringIO(_INPUT)\n\nINF = 10**10\n\nclass SegTree_GCD:\n    def __init__(self, a):\n        n = len(a)\n        self.n1 = 2 ** (n-1).bit_length()\n        self.dat = [0] * self.n1 + a + [-1] * (self.n1-n)\n        for i in reversed(range(1, self.n1)):\n            self.dat[i] = self.gcd1(self.dat[i*2], self.dat[i*2+1])\n    \n    def gcd1(self, v1, v2) -> int:\n        if v1 == -1:\n            return v2\n        elif v2 == -1:\n            return v1\n        else:\n            return math.gcd(v1, v2)\n\n    def get_rgcd(self, l, r) -> int:\n        l += self.n1\n        r += self.n1\n        v = -1\n        while l < r:\n            if l & 1:\n                v = self.gcd1(v, self.dat[l])\n                l += 1\n            if r & 1:\n                v = self.gcd1(v, self.dat[r-1])\n                r -= 1\n            l //= 2\n            r //= 2\n        return v\n\n    def update(self, i, x) -> None:\n        i += self.n1\n        self.dat[i] = x\n        while i > 1:\n            i //= 2\n            self.dat[i] = self.gcd1(self.dat[i*2], self.dat[i*2+1])\n\n    def get_value(self, i) -> int:\n        return self.dat[i+self.n1]\n\ndef solve(N, A):\n    if N == 1:\n        return 1\n    elif N == 2:\n        if abs(A[0]-A[1]) > 1:\n            return 2\n        else:\n            return 1\n\n    B = [abs(A[i+1] - A[i]) for i in range(N-1)]\n    \n    segt_gcd = SegTree_GCD(B)\n    length = 0\n    r = 1\n    for l in range(N-1):\n        r = l + length\n        while r+1 <= N-1 and segt_gcd.get_rgcd(l, r+1) > 1:\n            r += 1\n        \n        length = max(length, r-l)\n\n    return length + 1\n\nT0 = int(input())\nfor _ in range(T0):\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(solve(N, A))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long x[200010];\nlong long cha[200010];\nlong long gcd(long long a, long long b) {\n  if (b == 0)\n    return a;\n  else\n    return gcd(b, a % b);\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%lld\", &x[i]);\n      if (i > 1) cha[i - 1] = max(x[i] - x[i - 1], x[i - 1] - x[i]);\n    }\n    long long k = cha[1], fl = 1, mx = 1, tot = 1;\n    for (int i = 1; i < n; i++) {\n      k = gcd(k, cha[i]);\n      if (k == 1) {\n        k = cha[i];\n        tot = 2;\n        fl = i;\n        if (k == 1) {\n          k = cha[i + 1];\n          tot = 1;\n          continue;\n        }\n        for (int j = i - 1; j >= 1; j--) {\n          if (gcd(k, cha[j]) != 1)\n            k = gcd(k, cha[j]), tot++, fl = j;\n          else\n            break;\n        }\n      } else {\n        tot++;\n        mx = max(mx, tot);\n      }\n    }\n    printf(\"%d\\n\", mx);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n    Author : Akshat Jindal\n    from NIT Jalandhar , Punjab , India\n    JAI MATA DI\n */\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.sql.Array;\n\n\n\npublic class Main {\n\t  static class FR{\n\t\t  \n\t\t\tBufferedReader br;\n\t\t\tStringTokenizer st;\n\t\t\tpublic FR() {\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t}\n\t\t\tString next() \n\t\t    { \n\t\t        while (st == null || !st.hasMoreElements()) \n\t\t        { \n\t\t            try\n\t\t            { \n\t\t                st = new StringTokenizer(br.readLine()); \n\t\t            } \n\t\t            catch (IOException  e) \n\t\t            { \n\t\t                e.printStackTrace(); \n\t\t            } \n\t\t        } \n\t\t        return st.nextToken(); \n\t\t    } \n\n\t\t    int nextInt() \n\t\t    { \n\t\t        return Integer.parseInt(next()); \n\t\t    } \n\n\t\t    long nextLong() \n\t\t    { \n\t\t        return Long.parseLong(next()); \n\t\t    } \n\n\t\t    double nextDouble() \n\t\t    { \n\t\t        return Double.parseDouble(next()); \n\t\t    } \n\n\t\t    String nextLine() \n\t\t    { \n\t\t        String str = \"\"; \n\t\t        try\n\t\t        { \n\t\t            str = br.readLine(); \n\t\t        } \n\t\t        catch (IOException e) \n\t\t        { \n\t\t            e.printStackTrace(); \n\t\t        } \n\t\t        return str; \n\t\t    } \n\t\t}\n\t \n\t  static long mod = (long)(1e9 + 7);\n\t \n\tstatic void sort(long[] arr ) {\n\t\t ArrayList<Long> al = new ArrayList<>();\n\t\t for(long e:arr) al.add(e);\n\t\t Collections.sort(al);\n\t\t for(int i = 0 ; i<al.size(); i++) arr[i] = al.get(i);\n\t }\n\tstatic void sort(int[] arr ) {\n\t\t ArrayList<Integer> al = new ArrayList<>();\n\t\t for(int e:arr) al.add(e);\n\t\t Collections.sort(al);\n\t\t for(int i = 0 ; i<al.size(); i++) arr[i] = al.get(i);\n\t }\n\tstatic int UB(long[] arr , long find , int l , int r) {\n\t\twhile(l<=r) {\n\t\t\tint m = (l+r)/2;\n\t\t\tif(arr[m]<find) l = m+1;\n\t\t\telse r = m-1;\n\t\t}\n\t\treturn l;\n\t}\n\tstatic int LB(long[] arr , long find,int l ,int r ) {\n\t\twhile(l<=r) {\n\t\t\tint m = (l+r)/2;\n\t\t\tif(arr[m] > find) r = m-1;\n\t\t\telse l = m+1;\n\t\t}\n\t\treturn r;\n\t}\n\tstatic int UB(int[] arr , long find , int l , int r) {\n\t\twhile(l<=r) {\n\t\t\tint m = (l+r)/2;\n\t\t\tif(arr[m]<find) l = m+1;\n\t\t\telse r = m-1;\n\t\t}\n\t\treturn l;\n\t}\n\tstatic int LB(int[] arr , long find,int l ,int r ) {\n\t\twhile(l<=r) {\n\t\t\tint m = (l+r)/2;\n\t\t\tif(arr[m] > find) r = m-1;\n\t\t\telse l = m+1;\n\t\t}\n\t\treturn r;\n\t}\n\t static long gcd(long a, long b)\n\t  {      \n\t     if (b == 0)\n\t        return a;\n\t     return gcd(b, a % b); \n\t  }\n\t static boolean[] prime(int num) {\n\t\t\tboolean[] bool = new boolean[num];\n\t\t     \n\t\t      for (int i = 0; i< bool.length; i++) {\n\t\t         bool[i] = true;\n\t\t      }\n\t\t      for (int i = 2; i< Math.sqrt(num); i++) {\n\t\t         if(bool[i] == true) {\n\t\t            for(int j = (i*i); j<num; j = j+i) {\n\t\t               bool[j] = false;\n\t\t            }\n\t\t         }\n\t\t      }\n\t\t      if(num >= 0) {\n\t\t    \t  bool[0] = false;\n\t\t    \t  bool[1] = false;\n\t\t      }\n\t\t      \n\t\t      return bool;\n\t\t}\n\t static void sort(char[] arr) {\n\t\t ArrayList<Character> al = new ArrayList<Character>();\n\t\t for(char cc:arr) al.add(cc);\n\t\t Collections.sort(al);\n\t\t for(int i = 0 ;i<arr.length ;i++) arr[i] = al.get(i);\n\t\t \n\t }\n\t static long[][] ncr(int n, int k)\n\t    {\n\t        long C[][] = new long[n + 1][k + 1];\n\t        int i, j;\n\t \n\t        // Calculate  value of Binomial\n\t        // Coefficient in bottom up manner\n\t        for (i = 0; i <= n; i++) {\n\t            for (j = 0; j <= Math.min(i, k); j++) {\n\t                // Base Cases\n\t                if (j == 0 || j == i)\n\t                    C[i][j] = 1;\n\t \n\t                // Calculate value using\n\t                // previously stored values\n\t                else\n\t                    C[i][j] = (C[i - 1][j - 1] + C[i - 1][j])%mod;\n\t            }\n\t        }\n\t \n\t        return C;\n\t    }\n\t static long modInverse(long a, long m)\n\t    {\n\t        long g = gcd(a, m);\n\t       \n\t          return   power(a, m - 2, m);\n\t        \n\t    }\n\t   \n\t      static long power(long x, long y, long m)\n\t    {\n\t        if (y == 0)\n\t            return 1;\n\t        long p = power(x, y / 2, m) % m;\n\t        p = (int)((p * (long)p) % m);\n\t        if (y % 2 == 0)\n\t            return p;\n\t        else\n\t            return (int)((x * (long)p) % m);\n\t    }\n\t      static class DisjointUnionSets {\n\t\t\t    int[] rank, parent;\n\t\t\t    int n;\n\t\t\t  \n\t\t\t    public DisjointUnionSets(int n)\n\t\t\t    {\n\t\t\t        rank = new int[n];\n\t\t\t        parent = new int[n];\n\t\t\t        this.n = n;\n\t\t\t        makeSet();\n\t\t\t    }\n\t\t\t  \n\t\t\t    void makeSet()\n\t\t\t    {\n\t\t\t        for (int i = 0; i < n; i++) {\n\t\t\t          \n\t\t\t            parent[i] = i;\n\t\t\t        }\n\t\t\t    }\n\t\t\t  \n\t\t\t    int find(int x)\n\t\t\t    {\n\t\t\t        if (parent[x] != x) {\n\t\t\t        \n\t\t\t            parent[x] = find(parent[x]);\n\t\t\t  \n\t\t\t        }\n\t\t\t  \n\t\t\t        return parent[x];\n\t\t\t    }\n\t\t\t  \n\t\t\t    void union(int x, int y)\n\t\t\t    {\n\t\t\t        int xRoot = find(x), yRoot = find(y);\n\t\t\t  \n\t\t\t        if (xRoot == yRoot)\n\t\t\t            return;\n\t\t\t  \n\t\t\t        if (rank[xRoot] < rank[yRoot])\n\t\t\t  \n\t\t\t            parent[xRoot] = yRoot;\n\t\t\t  \n\t\t\t        else if (rank[yRoot] < rank[xRoot])\n\t\t\t  \n\t\t\t            parent[yRoot] = xRoot;\n\t\t\t  \n\t\t\t        else\n\t\t\t        {\n\t\t\t            parent[yRoot] = xRoot;\n\t\t\t  \n\t\t\t            rank[xRoot] = rank[xRoot] + 1;\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n//\t  \tstatic int query(int[] tree , int ss ,int se ,int qs , int qe,int index) {\n//\t\t\t\n//\t\t\tif(ss>=qs && se<=qe) return tree[index];\n//\t\t\t\n//\t\t\tif(qe<ss || se<qs) return Integer.MAX_VALUE;\n//\t\t\t\n//\t\t\tint mid = (ss + se)/2;\n//\t\t\tint left = query(tree , ss , mid , qs ,qe , 2*index);\n//\t\t\tint right= query(tree ,mid + 1 , se , qs ,qe , 2*index+1);\n//\t\t\treturn Math.min(left, right);\n//\t\t}\n//\t\tstatic void buildTree(int[] a ,int s ,int e ,int[] tree ,int index ) {\n//\t\t\tif(s == e) {\n//\t\t\t\ttree[index] = a[s];\n//\t\t\t\treturn;\n//\t\t\t}\n//\t\t\n//\t\t\tint mid = (s+e)/2;\n//\t\t\t\n//\t\t\tbuildTree(a, s,  mid, tree, 2*index);\n//\t\t\tbuildTree(a, mid+1, e, tree, 2*index+1);\n//\t\t\t\n//\t\t\ttree[index] = tree[2*index] + tree[2*index+1];\n//\t\t}\n/* ***************************************************************************************************************************************************/\t \n\t \n\t      static FR sc = new FR();\n\t static StringBuilder sb = new StringBuilder();\n\t public static void main(String args[]) {\n\t\t\n\t\t int tc = 1;\n\t\t  tc = sc.nextInt();\n\n\t\t while(tc-->0) {\n\t\t\t TEST_CASE();\n\t\t\t \n\t\t }\n\t\t \n\t    System.out.println(sb);\n\t }\n\t \n\t static void TEST_CASE() {\n\t\t int n = sc.nextInt();\n\t\t long[] arr = new long[n];\n\t\t for(int i = 0 ; i<n ; i++)\n\t\t\t arr[i] = sc.nextLong();\n\t\t \n\t\t long[] sub = new long[n-1];\n\t\t \n\t\t for(int i =0 ; i<n-1 ; i++)\n\t\t\t sub[i] = Math.abs(arr[i] - arr[i+1]);\n\t\t \n\t\t SparseTable st = new SparseTable(sub);\n\t\t long ans = 0;\n\t\t for(int i = 0 ; i<sub.length ;i++) {\n\t\t\t int l = i , r = sub.length-1;\n\t\t\t while(l<=r) {\n\t\t\t\t int m = (l+r)/2;\n\t\t\t\t if(st.query(i, m) <=1) r = m-1;\n\t\t\t\t else l = m+1;\n\t\t\t }\n\t\t\t ans = Math.max(ans, r - i+1);\n\t\t }\n\t\t sb.append((ans+1)+\"\\n\");\n\t }\n\t \n\n\t \n\n}\n\n\n\n/*******************************************************************************************************************************************************/\n\n  class SparseTable{\n\t\n\tprivate long[][] st;\n\t\n\tSparseTable(long[] arr){\n\t\tint n = arr.length;\n\t\tst = new long[n][25];\n\t\tlog = new int[n+2];\n\t\tbuild_log(n+1);\n\t\tbuild(arr);\n\t}\n\t\n\tprivate void build(long[] arr) {\n\t\tint n = arr.length;\n\t\t\n\t\tfor(int i = n-1 ; i>=0 ; i--) {\n\t\t\tfor(int j = 0 ; j<25 ; j++) {\n\t\t\t\tint r = i + (1<<j)-1;\n\t\t\t\tif(r>=n) break;\n\t\t\t\tif(j == 0 ) st[i][j] = arr[i];\n\t\t\t\telse st[i][j] = gcd(st[i][j-1] , st[ i + ( 1 << (j-1) ) ][ j-1 ] );\n\t\t\t}\n\t\t}\n\t}\n\tpublic long gcd(long a  ,long b) {\n\t\tif(a == 0) return b;\n\t\treturn gcd(b%a , a);\n\t}\n\tpublic long query(int l ,int r) {\n\t\tint w = r-l+1;\n\t\tint power = log[w];\n\t\treturn gcd(st[l][power],st[r - (1<<power) + 1][power]);\n\t}\n\tprivate int[] log;\n\tvoid build_log(int n) {\n\t\tlog[1] = 0;\n\t\tfor(int i = 2 ; i<=n ; i++) {\n\t\t\tlog[i] = 1 + log[i/2];\n\t\t}\n\t}\n}\n\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "from math import gcd\nimport sys\n\ninput = sys.stdin.readline\n\nfor _ in range(int(input())):\n    n, a = int(input()), map(int, input().split())\n    maxim, last, cua = 1, next(a), []\n    for i, new in enumerate(a):\n        dif, last = abs(last-new), new\n        cua.append((dif, i))\n        nova_cua = []\n        for g, p in cua:\n            g = gcd(dif, g)\n            if g != 1 and (not nova_cua or g > nova_cua[-1][0]):\n                nova_cua.append((g, p))\n                maxim = max(maxim, i - p + 2)\n        cua = nova_cua\n    print(maxim)"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while x>1:\n            x, y=y%x, x\n        if x==1:\n            return 1\n        else:        \n            return y\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2                                    \n\n #   total=bmax\n #   c=int(0.5+math.log2(bmax))\n #   k=0\n #   while k+total<n:\n #       if St[k][c]!=1:\n #           start=total+1\n #           end=min(n-k-1, bmax*2-1)\n #           while start<=end:\n #               j=(start+end)//2\n #               if HCF(St[k][c], St[k+j-2**c][c])!=1:\n #                   total=j\n #                   start=j+1\n #               else:\n #                   end=j-1    \n #       k+=1\n\n    def possible_group(x, y):\n        c=b[x]\n        for i in range(x+1, y):\n            c=HCF(c, b[i])\n            if c==1:\n                return False\n        return True        \n\n    total=bmax\n    start=bmax+1\n    end=min(n-1, bmax*2-1)\n    c=int(0.5+math.log2(bmax))\n    upton=2**c\n    while start<=end:\n        j=(start+end)//2\n        for k in range(n-j):            \n            if HCF(St[k][c], St[k+j-upton][c])!=1:\n                total=j\n                start=j+1\n                break\n        if start<=j:\n            end=j-1\n            \n    \n    print(total+1)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 3,
            "solution": "import sys\nfrom math import gcd\n\ninput = sys.stdin.readline\n\nt = int(input())\n\nwhile(t>0):\n    n = int(input())\n    arr = [*map(int, input().split())]\n    a = [0]+arr\n    \n    g = 0\n    p = 0\n    c = 1\n    \n    for i in range(2, n+1):\n        g = gcd(g, abs(a[i]-a[i-1]))\n        \n        if g>1:\n            c = max(c, i-p)\n        else:\n            g = 0\n            p = i\n            while g!=1:\n                sg = g\n                g = gcd(g, abs(a[p]-a[p-1]))\n                p-=1\n            g = sg\n    \n    print(c)\n    \n    t-=1"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tstatic long[] a; \n\tstatic RMQ table;\n\tstatic class RMQ {\n\t\tlong[] vs;\n\t\tlong[][] lift;\n \n\t\tpublic RMQ(long[] vs) {\n\t\t\tthis.vs = vs;\n\t\t\tint n = vs.length;\n\t\t\tint maxlog = Integer.numberOfTrailingZeros(Integer.highestOneBit(n)) + 2;\n\t\t\tlift = new long[maxlog][n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tlift[0][i] = vs[i];\n\t\t\tint lastRange = 1;\n\t\t\tfor (int lg = 1; lg < maxlog; lg++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tlift[lg][i] = __gcd(lift[lg - 1][i], lift[lg - 1][Math.min(i + lastRange, n - 1)]);\n\t\t\t\t}\n\t\t\t\tlastRange *= 2;\n\t\t\t}\n\t\t}\n \n\t\tpublic long query(int low, int hi) {\n\t\t\tint range = hi - low + 1;\n\t\t\tint exp = Integer.highestOneBit(range);\n\t\t\tint lg = Integer.numberOfTrailingZeros(exp);\n\t\t\treturn __gcd(lift[lg][low], lift[lg][hi - exp + 1]);\n\t\t}\n\t}\n\tstatic long __gcd(long a, long b)\n\t{\n\t    return b == 0 ? a : __gcd(b, a % b);    \n\t}\n    static int func(int start,int end,int ind) {\n    \tif(start>end) {\n    \t\treturn a.length+1;\n    \t}\n    \tint mid=(start+end)/2;\n    \tif(table.query(mid, ind)>1) {\n    \t\treturn Math.min(mid, func(start,mid-1,ind));\n    \t}\n    \treturn func(mid+1,end,ind);\n    }\n    \n\tpublic static void main(String[] args) throws IOException \n\t{ \n\t\tFastScanner f = new FastScanner(); \n\t\tint ttt=1;\n\t\tttt=f.nextInt();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tfor(int tt=0;tt<ttt;tt++) {\n\t\t\tint n=f.nextInt();\n\t\t\tlong[] l=f.readLongArray(n);\n\t\t\ta=new long[n-1];\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\ta[i]=Math.abs(l[i]-l[i+1]);\n\t\t\t}\n\t\t\ttable=new RMQ(a);\n\t\t\tint ans=0;\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\tint ind=func(0,i,i);\n\t\t\t\tans=Math.max(ans,i-ind+1);\n\t\t\t}\n\t\t\tif(ans==1) {\n\t\t\t\tboolean flag=false;\n\t\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\t\tif(l[i]%a[i]==l[i+1]%a[i]) flag=true;\n\t\t\t\t}\n\t\t\t\tif(flag) {\n\t\t\t\t\tout.println(2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout.println(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.println(ans+1);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tout.close();\n\t} \n\tstatic void sort(int[] p) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i: p) q.add( i);\n        Collections.sort(q);\n        for (int i = 0; i < p.length; i++) p[i] = q.get(i);\n    }\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tlong[] readLongArray(int n) {\n\t\t\tlong[] a=new long[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom math import gcd\nfrom collections import deque\n\nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nM = 2*10**5 + 1\n\ndef check(D, size):\n    if len(D) < size:\n        return False\n\n    L = [D[size - 1]]\n    for i in reversed(range(size - 1)):\n        L.append(gcd(L[-1], D[i]))\n\n    if L[-1] > 1:\n        return True\n\n    R = []\n    gcdr = 0\n    for d in D[size:]:\n        if len(L) > 0:\n            L.pop()\n\n        gcdl = L[-1] if len(L) > 0 else 0\n        gcdr = gcd(gcdr, d) if len(R) > 0 else d\n        R.append(d)\n\n        if gcd(gcdl, gcdr) > 1:\n            return True\n\n        if len(L) == 0:\n            L.append(R.pop())\n            while len(R) > 0:\n                L.append(gcd(L[-1], R.pop()))\n                \n\n    return False\n\ndef solve(D):\n    if len(D) == 0:\n        return 1\n    if len(D) == 1:\n        return 2 if abs(D[0]) != 1 else 1\n\n    l, r = 1, len(D) + 1\n    while l < r:\n        m = (l + r)//2\n        if check(D, m):\n            l = m + 1\n        else:\n            r = m\n\n    return l\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    A = list(map(int, input().split(' ')))\n\n    if n == 1:\n        r = 1\n\n    D = [abs(A[i + 1] - A[i]) for i in range(n - 1)]\n\n    print(solve(D))   "
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n//import java.math.*;\n\npublic class Task{\n//  ..............code begins here..............\n\nstatic long mod=(long)1e9+7,mod1=998244353l,inf=(long)1e18+5;\n// 1111111999999, 311111111111113\n\nstatic void solve1() throws  IOException{\n    int n=int_v(read()),k=n-1;\n    long[] a=long_arr();\n    if(n<=1){out.write(1+\"\\n\");return;}\n    long[][] dp=new long[n][20];\n    for(int i=0;i+1<n;i++){\n        dp[i][0]=Math.abs(a[i]-a[i+1]);\n    }\n    int[] log=new int[n+1];\n    log[1]=0;\n    for(int i=2;i<=n;i++)log[i]=log[i/2]+1;\n    for(int i=1;i<20;i++){\n        for(int j=0;j<k;j++){\n            dp[j][i]=gcd(dp[Math.min(j+(1<<(i-1)),k-1)][i-1],dp[j][i-1]);\n        }\n    }\n    int l1=1,r=k,ans=0;\n    while(l1<=r){\n        int m=(l1+r)/2;\n        boolean ok=false;\n        for(int i=0;i<k&&k-i>=m;i++){\n            int len=log[m];\n            long tmp=gcd(dp[i][len],dp[i+m-(1<<len)][len]);\n            if(tmp>=2){ok=true;break;}\n        }\n        if(ok){\n            ans=m;l1=m+1;\n        }\n        else r=m-1;\n    }\n\n    out.write((ans+1)+\"\\n\");\n}\n//\n\npublic static void main(String[] args) throws  IOException{\n    assign();\n    int t=int_v(read()),cn=1;\n    while(t--!=0){\n        //out.write(\"Case #\"+cn+\": \");\n        solve1();\n        //cn++;\n    }\n    out.flush();\n}\n\n// taking inputs\nstatic BufferedReader s1;\nstatic BufferedWriter out;\nstatic String read() throws IOException{String line=\"\";while(line.length()==0){line=s1.readLine();continue;}return line;}\nstatic int int_v (String s1){return Integer.parseInt(s1);}\nstatic long long_v(String s1){return Long.parseLong(s1);}\nstatic void sort(int[] a){List<Integer> l=new ArrayList<>();for(int x:a){l.add(x);}Collections.sort(l);for(int i=0;i<a.length;i++){a[i]=l.get(i);}}\nstatic int[] int_arr() throws IOException{String[] a=read().split(\" \");int[] b=new int[a.length];for(int i=0;i<a.length;i++){b[i]=int_v(a[i]);}return b;}\nstatic long[] long_arr() throws IOException{String[] a=read().split(\" \");long[] b=new long[a.length];for(int i=0;i<a.length;i++){b[i]=long_v(a[i]);}return b;}\nstatic void assign(){s1=new BufferedReader(new InputStreamReader(System.in));out=new BufferedWriter(new OutputStreamWriter(System.out));}\n//static String setpreciosion(double d,int k){BigDecimal d1 = new BigDecimal(Double.toString(d));return d1.setScale(k,RoundingMode.HALF_UP).toString();}//UP DOWN HALF_UP\nstatic int add(int a,int b){int z=a+b;if(z>=mod)z-=mod;return z;}\nstatic long gcd(long a,long b){if(b==0){return a;}return gcd(b,a%b);}\nstatic long Modpow(long a,long p,long m){long res=1;while(p>0){if((p&1)!=0){res=(res*a)%m;}p >>=1;a=(a*a)%m;}return res%m;}\nstatic long Modmul(long a,long b,long m){return ((a%m)*(b%m))%m;}\nstatic long ModInv(long a,long m){return Modpow(a,m-2,m);}\n//static long nck(int n,int r,long m){if(r>n){return 0l;}return Modmul(f[n],ModInv(Modmul(f[n-r],f[r],m),m),m);}\n//static long[] f;\n}"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while y>1:\n            x, y=y, x%y\n        if y==1:\n            return 1\n        else:        \n            return x\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2                                    \n\n #   total=bmax\n #   c=int(0.5+math.log2(bmax))\n #   k=0\n #   while k+total<n:\n #       if St[k][c]!=1:\n #           start=total+1\n #           end=min(n-k-1, bmax*2-1)\n #           while start<=end:\n #               j=(start+end)//2\n #               if HCF(St[k][c], St[k+j-2**c][c])!=1:\n #                   total=j\n #                   start=j+1\n #               else:\n #                   end=j-1    \n #       k+=1\n\n    def possible_group(x, y):\n        c=b[x]\n        for i in range(x+1, y):\n            c=HCF(c, b[i])\n            if c==1:\n                return False\n        return True        \n\n    total=bmax\n    start=bmax+1\n    end=min(n-1, bmax*2-1)\n    c=int(0.5+math.log2(bmax))\n    while start<=end:\n        j=(start+end)//2\n        for k in range(n-j):            \n            if HCF(St[k][c], St[k+j-2**c][c])!=1:\n                total=j\n                start=j+1\n                break\n        if start<=j:\n            end=j-1\n            \n    \n    print(total+1)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nint n;\nlong long t[2 * 200010];\nvoid build() {\n  for (int i = n - 1; i > 0; --i) t[i] = gcd(t[i << 1], t[i << 1 | 1]);\n}\nvoid modify(int p, long long value) {\n  for (t[p += n] = value; p > 1; p >>= 1) t[p >> 1] = gcd(t[p], t[p ^ 1]);\n}\nlong long query(int l, int r) {\n  long long res = 0;\n  r++;\n  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n    if (l & 1) res = gcd(res, t[l++]);\n    if (r & 1) res = gcd(res, t[--r]);\n  }\n  return res;\n}\nint bb(int i) {\n  if (query(i, i) == 1) return 0;\n  int l = i, r = n - 1;\n  while (l < r) {\n    int m = (l + r + 1) / 2;\n    if (query(i, m) > 1) {\n      l = m;\n    } else {\n      r = m - 1;\n    }\n  }\n  return l - i + 1;\n}\nvoid solve() {\n  cin >> n;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  if (n == 1) {\n    cout << \"1\\n\";\n    return;\n  }\n  n--;\n  for (int i = 0; i < n; i++) t[n + i] = abs(a[i + 1] - a[i]);\n  build();\n  int res = 0;\n  for (int i = 0; i < n; i++) {\n    res = max(res, bb(i));\n  }\n  cout << res + 1 << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int tst;\n  cin >> tst;\n  while (tst--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.Scanner; \nimport java.util.StringTokenizer;\nimport java.util.*;\npublic class codeforcesA{\n   static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n   } \n   public static long gcd(long a,long b){\n        if(b==0){return a;}return gcd(b,a%b);\n    }\n   public static long seg_tree[],diff[];\n   public static void main(String args[]){\n     FastReader sc=new FastReader();\n     int t=sc.nextInt();\n     StringBuilder sb=new StringBuilder();\n     while(t-->0){\n          int n=sc.nextInt();\n          long ar[]=new long[n];\n          for(int i=0;i<n;i++){ar[i]=sc.nextLong();}\n           diff=new long[n-1];\n          for(int i=1;i<n;i++){diff[i-1]=Math.abs(ar[i]-ar[i-1]);}\n          //build a segment tree\n           seg_tree=new long[4*n+1];\n           build(0,n-2,1);\n           //for(int i=0;i<4*n+1;i++){System.out.print(seg_tree[i]+\" \");}\n           int ptr1=0,ptr2=0;\n           int len=1;\n           while(ptr1<n-1){\n               //System.out.println(ptr1+\" \"+ptr2);\n               long val=query(0,n-2,ptr2,ptr1,1);\n               //System.out.println(val);\n               if(val>1){len=Math.max(len,ptr1-ptr2+2);ptr1++;}\n               else{\n                   if(ptr1==ptr2){ptr1++;ptr2++;}\n                   else{ptr2++;}\n                }\n            }\n            sb.append(len+\"\\n\");\n        }\n        System.out.print(sb.toString());\n    }\n   public static void build(int s,int e,int i){\n       if(s==e){seg_tree[i]=diff[s];}\n       if(e>s){\n           int mid=(s+e)/2;\n           build(s,mid,2*i);\n           build(mid+1,e,2*i+1);\n         long left=seg_tree[2*i];\n         long right=seg_tree[2*i+1];\n         seg_tree[i]=gcd(left,right);\n         }\n        \n    }\n    public static long query(int ns,int ne,int qs,int qe,int i){\n        if(qs>ne || qe<ns){return 0;}\n        if(qs<=ns && qe>=ne){return seg_tree[i];}\n        \n         int mid=(ns+ne)/2;\n          return gcd(query(ns,mid,qs,qe,i*2),query(mid+1,ne,qs,qe,i*2+1));\n        \n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.buffer.readline \n\ngcd_dict = {}\n\ndef gcd(a, b):\n    if a > b==0:\n        a, b = b, a\n    if (a, b) in gcd_dict:\n        return gcd_dict[(a, b)]\n    if b % a==0:\n        return a\n    answer = gcd(b % a, a)\n    return answer\n\ndef process(A):\n    n = len(A)\n    if n==1:\n        return 1\n    A2 = []\n    for i in range(n-1):\n        A2.append(abs(A[i+1]-A[i]))\n    answer = 0\n    curr = []\n    for i in range(n-1):\n        x = A2[i]\n        new_curr = []\n        if x==1:\n            new_curr = []\n        elif len(curr)==0:\n            new_curr = [[x, 1]]\n            answer = max(answer, 1)\n        elif x==curr[0][0]:\n            for g, y in curr:\n                new_curr.append([g, y+1])\n                answer = max(answer, y+1)\n        else:\n            new_curr = [[x, 1]]\n            for g, y in curr:\n                x2 = new_curr[-1][0]\n                g2 = gcd(g, x2)\n                if g2==x2:\n                    new_curr[-1][1] = y+1\n                    answer = max(answer, new_curr[-1][1])\n                elif g2 > 1:\n                    new_curr.append([g2, y+1])\n                    answer = max(answer, y+1)\n                else:\n                    break\n        curr = new_curr\n    return answer+1\n                \nt = int(input())\nfor i in range(t):\n    n = int(input())\n    A = [int(x) for x in input().split()]\n    sys.stdout.write(str(process(A))+'\\n')\n    "
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict, deque, Counter\nfrom sys import stdin, stdout\nfrom heapq import heappush, heappop\nimport math\nimport io\nimport os\nimport math\nimport bisect\n\n#?############################################################\n\n\ndef isPrime(x):\n    for i in range(2, x):\n        if i*i > x:\n            break\n        if (x % i == 0):\n            return False\n    return True\n\n#?############################################################\n\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, p - 2, p)) % p\n\n\n#?############################################################\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            l.append(int(i))\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\n\n#?############################################################\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n#?############################################################\n\n\ndef sieve(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\n#?############################################################\n\ndef digits(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\n\n#?############################################################\n\n\ndef ceil(n, x):\n    if (n % x == 0):\n        return n//x\n    return (n//x)+1\n\n#?############################################################\n\n\ndef mapin():\n    return [int(i) for i in input().split()]\n\n#?############################################################\n\n\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nclass RangeQuery:\n    def __init__(self, data, func=math.gcd):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n \n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n \n    def __getitem__(self, idx):\n        return self._data[0][idx]\n \ndef fun(mid,s,n):\n    f = 0\n    for i in range(n-mid+1):\n        if s.query(i,i+mid)>1:\n            f = 1\n    return f\n\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l =[int(x) for x in input().split()]\n    d  =[]\n    for i in range(1, n):\n        d.append(l[i]-l[i-1])\n    s = RangeQuery(d)\n    low = 1\n    high = n-1\n    ans = 0\n    while low<=high:\n        mid = (low+high)//2\n        if fun(mid,s,n-1)==1:\n            low = mid+1\n            ans = mid\n        else:\n            high = mid-1\n    \n    print(ans+1)\n    \n    "
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class student {\n    public static int m, n, k;\n    public static long[] arr, pos, log;\n    public static long[][] st;\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(\n                    new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    public static FastReader obj = new FastReader();\n    public static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n\n        int length = obj.nextInt();\n        while (length-- != 0) {\n            solve();\n        }\n        out.flush();\n    }\n\n    public static void solve() {\n        m = obj.nextInt();\n        n = m - 1;\n        arr = new long[m];\n        for (int i = 0; i < m; i++) arr[i] = obj.nextLong();\n        if (m == 1) {\n            out.println(1);\n            return;\n        }\n        pos = new long[n];\n        for (int i = 0; i < n; i++) pos[i] = Math.abs(arr[i + 1] - arr[i]);\n        k = (int) (Math.log(m) / Math.log(2));\n        st = new long[n][k + 1];\n        precompute();\n\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            int j = bs(i);\n            if (j == 1 && st[i][0] == 1) continue;\n            ans = Math.max(ans, j);\n        }\n        out.println(ans + 1);\n    }\n\n    public static void precompute() {\n        log = new long[n + 1];\n        log[1] = 0;\n        for (int i = 2; i <= n; i++) log[i] = log[i / 2] + 1;\n        for (int i = 0; i < n; i++) st[i][0] = pos[i];\n        for (int j = 1; j <= k; j++) {\n            for (int i = 0; i + (1 << j) <= n; i++) {\n                st[i][j] = gcd(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    public static int bs(int i) {\n        int l = i, r = n - 1;\n        int ans = i;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (query(i, mid)) {\n                l = mid + 1;\n                ans = mid;\n            } else r = mid - 1;\n        }\n        return ans - i + 1;\n    }\n\n    public static boolean query(int l, int r) {\n        int j = (int) log[r - l + 1];\n        return gcd(st[l][j], st[r - (1 << j) + 1][j]) >= 2;\n    }\n\n    public static long gcd(long a, long b) {\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\nfrom math import gcd\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\n\nclass segmenttree:\n    def __init__(self, arr, n):\n        self.tree, self.n = [0] * (2 * n), n\n        for i in range(2 * n - 1, 0, -1):\n            if i >= n:\n                self.tree[i] = arr[i - n]\n            else:\n                self.tree[i] = gcd(self.tree[i << 1], self.tree[(i << 1) + 1])\n\n    def query(self, l, r):\n        res = 0\n        l += self.n\n        r += self.n\n        while l < r:\n            if l & 1:\n                res = gcd(self.tree[l], res)\n                l += 1\n            if r & 1:\n                r -= 1\n                res = gcd(self.tree[r], res)\n            l >>= 1\n            r >>= 1\n\n        return res\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\nfor _ in range(int(input())):\n    n, a, ans = int(input()), inp(int), 0\n    a = [abs(a[i] - a[i - 1]) for i in range(1, n)]\n    tree, g, be = segmenttree(a, n - 1), 0, 0\n\n    for i in range(n - 1):\n        g = gcd(a[i], g)\n        while g == 1 and be <= i:\n            be += 1\n            g = tree.query(be, i + 1)\n\n        ans = max(ans, i - be + 1)\n\n    print(ans + 1)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Solution{ \n\t\n\t static void fun(long ST[][],int n,int k,long a[]){\n         for (int i = 0; i <n; i++)\n              ST[i][0] = a[i];\n          \n         for (int j = 1; j <k; j++)\n            for (int i = 0; (i+(1 << j))<=n; i++)\n                    ST[i][j] = gcd(ST[i][j-1], ST[i + (1 << (j - 1))][j - 1]);\n } \n\t static long query(int l,int r) {\n\t\t int j=Log[r-l+1];\n         long g = gcd(ST[l][j],ST[r-(1<<j)+1][j]);\n         return g;\n\t }\n\t static long[][] ST;\n\t static int[] Log;\n\t static boolean ok(int l,int n) {\n\t\t int i1=0,i2=l-1;\n\t\t while(i2<n) {\n\t\t\t long g = query(i1,i2);\n\t\t\t if(g>1)\n\t\t\t\t return true;\n\t\t\t i1++;i2++;\n\t\t }\n\t\t return false;\n\t }\npublic static void main(String[] args)throws Exception\n{  \n\t//System.out.println(\"enter a number\");\n\n\nint t = ni();\nfor(int u=1;u<=t;u++) {\n  \n\tint n = ni();\n    long a[] = al(n);\n    if(n==1)\n    \tout.println(1);\n    else {\n    \tlong d[] = new long[n-1];\n    \tfor(int i=1;i<n;i++)\n    \t\td[i-1]=Math.abs(a[i]-a[i-1]);\n    \t int k = (int)(Math.log(n-1)/Math.log(2))+1;\n          ST = new long[n-1][k];\n         Log = new int[n];\n\n             fun(ST,n-1,k,d);\n             Log[1] = 0;\n            for (int i = 2; i <n; i++)\n                  Log[i] = Log[i/2]+1;\n    \tint l=0,r=n;\n    \twhile((r-l)>1) {\n    \t\tint m=(l+r)/2;\n    \t\tif(ok(m,n-1))\n    \t\t  l=m;\n    \t\telse\n    \t\t  r=m;\n    \t}\n    \tl=l+1;\n    \tout.println(l);\n    }\n}\n     out.flush();\n}\nstatic HashMap<Integer,Integer> gethm(int a[]){\n\t HashMap<Integer,Integer> hm = new HashMap();\n\t for(int i=0;i<a.length;i++)\n\t\t if(hm.containsKey(a[i]))\n\t\t\t hm.put(a[i], hm.get(a[i])+1);\n\t\t else\n\t\t\t hm.put(a[i], 1);\n\t return hm;\n}\n////////////////////////// solution ends ////////////////////////////////////////////////\nstatic class pair\n\t{\n\t\tint l,k;\n\t\tpair(){}\n\t\tpair(int c,int d){l=c;k=d;}\n\t\t/*@Override\n\t\tpublic int hashCode(){return (a+\" \"+b).hashCode();}\n\t\t@Override public boolean equals(Object c){if(a==((pair)c).a&&b==((pair)c).b)return true;return false;} */\n\t}  \nstatic void seive(boolean p[]){\n\n                    p[0]=true; p[1]=true;\n                for(int i=2;i*i<p.length;i++)\n                   if(p[i]==false){\n                    for(int j=i*i;j<p.length;j=j+i)\n                         p[j]=true;\n                  }\n             }\nstatic int get(int index)\n        {\n                return (index&(-index));\n        }\nstatic void add(int bit[],int index,int val)\n        {\n             while(index<bit.length)\n               {\n                    bit[index] = bit[index]+val;\n                    index = index + get(index);\n               }\n        }\nstatic int get(int bit[],int index)\n         {\n               int sum=0;\n               while(index>0)\n                {\n                    sum = sum+bit[index];\n                    index = index-get(index);\n                }\n              return sum;\n         }\nstatic void add(long bit[],int index,long val)\n        {\n             while(index<bit.length)\n               {\n                    bit[index] = bit[index]+val;\n                    index = index + get(index);\n               }\n        }\nstatic long get(long bit[],int index)\n         {\n               long sum=0;\n               while(index>0)\n                {\n                    sum = sum+bit[index];\n                    index = index-get(index);\n                }\n              return sum;\n         } \nstatic void compress(int a[])\n         {      \n                int n = a.length;\n                Integer ar[] = new Integer[n];\n                for(int i=0;i<n;i++)\n                     ar[i] = a[i];\n                Arrays.sort(ar);\n                HashMap<Integer,Integer> hm = new HashMap();\n                int st=1;\n                for(int i=0;i<n;i++)\n                    if(!hm.containsKey(ar[i]))\n                        hm.put(ar[i],st++);\n                for(int i=0;i<n;i++)\n                   a[i] = hm.get(a[i]);\n         }\nstatic int find(int x,int p[]){ if(x==p[x]) return x; return p[x]=find(p[x],p) ;}\nstatic void union(int x,int y,int p[]){ int xr=find(x,p),yr=find(y,p); if(xr!=yr){ p[xr]=yr;} }\n \nstatic int abs(int x){ return x>0 ? x : -x; }\nstatic long abs(long x){ return x>0 ? x : -x; }\nstatic long gcd(long a,long b){ if(a==0)return b; if(b==0) return a;if(b%a==0) return a;return gcd(b%a,a); }\nstatic int gcd(int a,int b){ if(a==0)return b; if(b==0) return a; if(b%a==0) return a;return gcd(b%a,a); }\nstatic long min(long a,long b){ return a<b ? a : b; }\nstatic int min(int a,int b){ return a<b ? a : b; }\nstatic long max(long a,long b){ return a>b ? a : b; }\nstatic int max(int a,int b){ return a>b ? a : b; }\nstatic long pow(long a,long b,long md){ long ans=1;  while(b>0){if(b%2==1) ans = (ans*a)%md; a = (a*a)%md; b = b/2;} return ans; }\nstatic int log2n(long a){ int te=0; while(a>0) {a>>=1; ++te; } return te; }\n\nstatic void reverse(int a[]){int i1=0,i2=a.length-1; while(i1<i2){int t = a[i1];a[i1]=a[i2];a[i2]=t;i1++;i2--;}  } \nstatic void reverse(long a[]){ int i1=0,i2=a.length-1; while(i1<i2){ long t = a[i1]; a[i1]=a[i2];a[i2]=t;i1++;i2--;}  } \n\nstatic void subtract_1(char s[]){if(s[0]=='0') return;int n = s.length,i=n-1;while(s[i]=='0')i--;s[i] =(char)((int)(s[i]-'0') + 47);for(int j=i+1;j<n;j++)s[j]='9';}\nstatic void reverse(char s[]){int i1=0,i2=s.length-1; while(i1<i2){char t=s[i1];s[i1]=s[i2];s[i2]=t; i1++;i2--;} }\nstatic String reverse(String r){String s = \"\";int i= r.length()-1; while(i>=0){ s=s+r.charAt(i);i--;}return s;}\nstatic boolean pal(char s[]){ int i1=0,i2=s.length-1; while(i1<i2){ if(s[i1]!=s[i2]) return false; i1++;i2--;} return true;}\nstatic boolean pal(String s){int n = s.length(),i1=0,i2=n-1;while(i1<i2){if(s.charAt(i1)!=s.charAt(i2))return false;i1++; i2--;}return true;}\n \n// Input OutPut Functions\nstatic PrintWriter out = new PrintWriter(System.out);\nstatic FastReader sc=new FastReader();\nstatic int ni(){ int x = sc.nextInt();return(x); }\nstatic long nl(){ long x = sc.nextLong(); return(x); }\n\nstatic String n(){ String str = sc.next(); return(str); }\nstatic String ns(){ String str = sc.nextLine(); return(str);}\nstatic double nd(){double d = sc.nextDouble(); return(d); }\nstatic int[] ai(int n){ int a[] = new int[n]; for(int i=0;i<n;i++) a[i] = ni(); return a; }\nstatic long[] al(int n) {long a[] = new long[n]; for(int i=0;i<n;i++) a[i] = nl(); return a; }\nstatic double[] ad(int n) { double a[]= new double[n]; for(int i=0;i<n;i++) a[i]=nd(); return a;} \nstatic String[] as(int n){ String a[] = new String[n]; for(int i=0;i<n;i++) a[i] = n(); return a; }\nstatic void p(Object o){ out.print(o); }\nstatic void pn(Object o){ out.println(o); } \n \nstatic class FastReader{ \nBufferedReader br; \nStringTokenizer st;   \npublic FastReader() { br = new BufferedReader(new InputStreamReader(System.in));  }   \nString next(){while(st==null || !st.hasMoreElements()){try{st = new StringTokenizer(br.readLine());}catch (IOException  e){e.printStackTrace();}}return st.nextToken();} \nint nextInt(){ return Integer.parseInt(next()); } \nlong nextLong(){ return Long.parseLong(next()); } \ndouble nextDouble(){return Double.parseDouble(next()); } \nString nextLine(){ String str = \"\"; try{ str = br.readLine();} catch (IOException e){ e.printStackTrace();} return str;} \n  } \n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\npublic class ACMIND\n{\n    static FastReader scan;\n    static PrintWriter pw;\n    static long MOD = 1_000_000_007;\n    static long INF = 2_000_000_000_000_000_000L;\n    static long inf = 2_000_000_000;\n    public static void main(String[] args) {\n        new Thread(null,null,\"_\",1<<27)\n        {\n            public void run()\n            {\n                try\n                {\n                    solve();\n                }\n                catch(Exception e)\n                {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n\n\n    static void solve() throws IOException {\n        scan = new FastReader();\n        pw = new PrintWriter(System.out, true);\n        StringBuilder sb = new StringBuilder();\n\n        int t = ni();\n        while (t-->0) {\n            int n = ni();\n            long arr[] = new long[n-1];\n            long prev = nl();\n            for(int i=0;i<n-1;i++) {\n                arr[i] = nl() - prev;\n                prev = prev + arr[i];\n                arr[i] = abs(arr[i]);\n            }\n\n            if(n==1) {\n                pl(1);\n            }\n            else {\n                pl(findLargestSubarray(arr) + 1);\n            }\n        }\n\n        pw.flush();\n        pw.close();\n    }\n\n    static int findLargestSubarray(long arr[]) {\n        // pa(\"arr\", arr);\n        int n = arr.length;\n        int MAX = (int)(log(n) / log(2));\n        long sp[][] = new long[n][MAX+1];\n        for(int i=0;i<n;i++) {\n            sp[i][0] = arr[i];\n        }\n        for(int r=1;r<=MAX;r++) {\n            for(int i=0;i<n;i++) {\n                if((i+(1<<(r-1))) < n) {\n                    sp[i][r] = gcd(sp[i][r-1], sp[i+(1<<(r-1))][r-1]);\n                }\n                else {\n                    sp[i][r] = sp[i][r-1];\n                }\n            }\n        }\n\n        // pa(\"sp\", sp);\n\n        int max = 0;\n        for(int i=0;i<n;i++) {\n            long curr = 0;\n            int start = i;\n            for(int j=MAX;j>=0 && start<n;--j) {\n                long g = gcd(curr, sp[start][j]);\n                if(g>1) {\n                    curr = g;\n                    start = start + (1<<j);\n                }\n            }\n\n            start = min(start, n);\n            max = max(max, start - i);\n        }\n\n        return max;\n    }\n\n    static long gcd(long a, long b) {\n        if(b==0) {\n            return a;\n        }\n        return gcd(b,a%b);\n    }\n\n    static void assert_in_range(String varName, int n, int l, int r) {\n        if (n >=l && n<=r) return;\n        System.out.println(varName + \" is not in range. Actual: \"+n+\" l : \"+l+\" r: \"+r);\n        System.exit(1);\n    }\n    static void assert_in_range(String varName, long n, long l, long r) {\n        if (n>=l && n<=r) return;\n        System.out.println(varName + \" is not in range. Actual: \"+n+\" l : \"+l+\" r: \"+r);\n        System.exit(1);\n    }\n\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Set<Object> set)\n    {\n        pl(arrayName+\" : \");\n        for(Object o : set)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object arr[])\n    {\n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String listName, List list)\n    {\n        pl(listName+\" : \");\n        for(Object o : list)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(Object o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, int[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(int o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, long[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(long o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, char[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(char o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, double[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(double o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static class FastReader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public FastReader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public FastReader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[1000000];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author sarthakmanna\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DIntegersHaveFriends solver = new DIntegersHaveFriends();\n        int testCount = Integer.parseInt(in.next());\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class DIntegersHaveFriends {\n        final static Helper hp = new Helper();\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int i, j, k;\n            // Theory: if a ~ b (mod m) then m | abs(a - b)\n            // http://www.math.toronto.edu/rosent/Mat246Y/congruencies.htm\n\n            int N = in.nextInt();\n            long[] A = in.getLongArray(N);\n\n            long[] D = new long[N - 1];\n            for (i = 0; i < N - 1; ++i) D[i] = Math.abs(A[i + 1] - A[i]);\n            //System.err.println(Arrays.toString(D));\n\n            SegmentTree segT = new SegmentTree(D, 0, 0) {\n                public long nodeToNode(long a, long b) {\n                    return hp.gcd(a, b);\n                }\n            };\n            //System.err.println(segT);\n\n            int max = 0, p = 0;\n            for (i = 0; i < N - 1; ++i) {\n                while (p < N - 1 && segT.rangeQuery(i, p) != 1) ++p;\n                max = Math.max(max, p - i);\n            }\n            out.println(max + 1);\n        }\n\n    }\n\n    static class FastReader {\n        static final int BUFSIZE = 1 << 20;\n        static byte[] buf;\n        static int index;\n        static int total;\n        static InputStream in;\n\n        public FastReader(InputStream is) {\n            try {\n                in = is;\n                buf = new byte[BUFSIZE];\n            } catch (Exception e) {\n            }\n        }\n\n        private int scan() {\n            try {\n                if (index >= total) {\n                    index = 0;\n                    total = in.read(buf);\n                    if (total <= 0)\n                        return -1;\n                }\n                return buf[index++];\n            } catch (Exception | Error e) {\n                System.err.println(e.getMessage());\n                return 13 / 0;\n            }\n        }\n\n        public String next() {\n            int c;\n            for (c = scan(); c <= 32; c = scan()) ;\n            StringBuilder sb = new StringBuilder();\n            for (; c > 32; c = scan())\n                sb.append((char) c);\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int c, val = 0;\n            for (c = scan(); c <= 32; c = scan()) ;\n            boolean neg = c == '-';\n            if (c == '-' || c == '+')\n                c = scan();\n            for (; c >= '0' && c <= '9'; c = scan())\n                val = (val << 3) + (val << 1) + (c & 15);\n            return neg ? -val : val;\n        }\n\n        public long nextLong() {\n            int c;\n            long val = 0;\n            for (c = scan(); c <= 32; c = scan()) ;\n            boolean neg = c == '-';\n            if (c == '-' || c == '+')\n                c = scan();\n            for (; c >= '0' && c <= '9'; c = scan())\n                val = (val << 3) + (val << 1) + (c & 15);\n            return neg ? -val : val;\n        }\n\n        public long[] getLongArray(int size) {\n            long[] ar = new long[size];\n            for (int i = 0; i < size; ++i) ar[i] = nextLong();\n            return ar;\n        }\n\n    }\n\n    static class Helper {\n        public final long MOD;\n        public final int MAXN;\n        final Random rnd;\n\n        public Helper() {\n            MOD = 1000_000_007;\n            MAXN = 1000_006;\n            rnd = new Random();\n        }\n\n        public Helper(long mod, int maxn) {\n            MOD = mod;\n            MAXN = maxn;\n            rnd = new Random();\n        }\n\n        public long gcd(long a, long b) {\n            return b == 0 ? a : gcd(b, a % b);\n        }\n\n    }\n\n    static class SegmentTree {\n        private int N;\n        private long[] tree;\n        private long[] lazy;\n        public final long DEFAULT_NODE;\n        public final long DEFAULT_LAZY;\n\n        public SegmentTree(long[] ar, long def_node, long def_lazy) {\n            DEFAULT_NODE = def_node;\n            DEFAULT_LAZY = def_lazy;\n            N = 1;\n            while (N < ar.length) N <<= 1;\n            tree = new long[N * 2 - 1];\n            Arrays.fill(tree, DEFAULT_NODE);\n            lazy = new long[N * 2 - 1];\n            Arrays.fill(lazy, DEFAULT_LAZY);\n\n            for (int i = 0; i < ar.length; ++i) tree[i + N - 1] = ar[i];\n            for (int i = N - 2; i >= 0; --i) {\n                tree[i] = nodeToNode(tree[i * 2 + 1], tree[i * 2 + 2]);\n            }\n        }\n\n        public long nodeToNode(long a, long b) {\n            return a + b;\n        }\n\n        public long lazyToLazy(long a, long b) {\n            return a + b;\n        }\n\n        public long lazyToNode(long a, int l, int r) {\n            return a * (r - l + 1);\n        }\n\n        public void pushDown(int i, int l, int r) {\n            tree[i] = nodeToNode(tree[i], lazyToNode(lazy[i], l, r));\n            if (i * 2 + 1 < tree.length) {\n                lazy[i * 2 + 1] = lazyToLazy(lazy[i * 2 + 1], lazy[i]);\n                lazy[i * 2 + 2] = lazyToLazy(lazy[i * 2 + 2], lazy[i]);\n            }\n            lazy[i] = DEFAULT_LAZY;\n        }\n\n        public long rangeQuery(int l, int r) {\n            return query(0, 0, N - 1, l, r);\n        }\n\n        private long query(int i, int l, int r, int ql, int qr) {\n            pushDown(i, l, r);\n            int mid = l + r >> 1, i2 = i << 1;\n            if (l > qr || r < ql) return DEFAULT_NODE;\n            else if (l >= ql && r <= qr) return tree[i];\n            else {\n                return nodeToNode(query(i2 + 1, l, mid, ql, qr),\n                        query(i2 + 2, mid + 1, r, ql, qr));\n            }\n        }\n\n        public String toString() {\n            return \"SegTree = \" + Arrays.toString(tree) + \", \" + Arrays.toString(lazy);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict, deque, Counter\nfrom sys import stdin, stdout\nfrom heapq import heappush, heappop\nimport math\nimport io\nimport os\nimport math\nimport bisect\n\n#?############################################################\n\n\ndef isPrime(x):\n    for i in range(2, x):\n        if i*i > x:\n            break\n        if (x % i == 0):\n            return False\n    return True\n\n#?############################################################\n\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, p - 2, p)) % p\n\n\n#?############################################################\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            l.append(int(i))\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\n\n#?############################################################\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n#?############################################################\n\n\ndef sieve(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\n#?############################################################\n\ndef digits(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\n\n#?############################################################\n\n\ndef ceil(n, x):\n    if (n % x == 0):\n        return n//x\n    return (n//x)+1\n\n#?############################################################\n\n\ndef mapin():\n    return [int(i) for i in input().split()]\n\n#?############################################################\n\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nclass RangeQuery:\n    def __init__(self, data, func=math.gcd):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n \n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n \n    def __getitem__(self, idx):\n        return self._data[0][idx]\n \ndef fun(mid,s,n):\n    f = 0\n    for i in range(n-mid+1):\n        if s.query(i,i+mid)>1:\n            f = 1\n    return f\n\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l =[int(x) for x in input().split()]\n    d  =[]\n    for i in range(1, n):\n        d.append(l[i]-l[i-1])\n    s = RangeQuery(d)\n    low = 1\n    high = n-1\n    ans = 0\n    while low<=high:\n        mid = (low+high)//2\n        if fun(mid,s,n-1)==1:\n            low = mid+1\n            ans = mid\n        else:\n            high = mid-1\n    \n    print(ans+1)\n    \n    "
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom collections import Counter\nfrom collections import defaultdict as dd\nimport random\n\n# sys.setrecursionlimit(100000000)\n\nflush = lambda: stdout.flush()\nstdstr = lambda: stdin.readline()\nstdint = lambda: int(stdin.readline())\nstdpr = lambda x: stdout.write(str(x))\nstdmap = lambda: map(int, stdstr().split())\nstdarr = lambda: list(map(int, stdstr().split()))\n\nmod = 1000000007\nclass RangeQuery:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n\n    def __getitem__(self, idx):\n        return self._data[0][idx]\n\n\ndef check(st, n, k):\n    for i in range(n-k+1):\n        # print(i, i+k)\n        g = st.query(i, i+k)\n        if(g > 1):\n            return True\n\n    return False\n\n\n\nfor _ in range(stdint()):\n    n = stdint()\n\n    arr = stdarr()\n\n\n    diff = []\n\n    for i in range(n-1):\n        diff.append(abs(arr[i]-arr[i+1]))\n\n    st = RangeQuery(diff, func=math.gcd)\n\n    lo,hi = 1,int(math.sqrt(10**18))+1\n\n    last = -1\n\n    while(lo <= hi):\n        mid = (lo+hi)//2\n        if(check(st, len(diff), mid)):\n\n            last = mid\n            lo = mid+1\n        else:\n            hi = mid-1\n\n\n    print(max(last+1, 1))"
        },
        {
            "language": 3,
            "solution": "import sys\ninput =sys.stdin.buffer.readline\nfrom math import gcd\ndef queries(l,r):\n    gd=0\n    while l<=r:\n        if l %2==1:\n            gd =gcd(gd,sgn_tree[l])\n            l+=1\n        if r %2==0:\n            gd =gcd(gd,sgn_tree[r])\n            r-=1\n        l =l>>1\n        r =r>>1\n    return gd\n\nfor _ in range(int(input())):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    brr=[]\n    for i in range(1,n):\n        brr.append(abs(arr[i]-arr[i-1]))\n    n-=1\n    sgn_tree=[0 for i in range(2*n)]\n    sgn_tree[n:] =brr[::]\n    for i in range(n-1,0,-1):\n        sgn_tree[i] =gcd(sgn_tree[2*i] , sgn_tree[2*i +1])\n    maxi =0\n    src,end=0,0\n    gd=0\n    while end <n and src <n:\n        end =max(src,end)\n        gd =gcd(gd,brr[end])\n        if gd >1:\n            maxi =max(maxi ,end-src+2)\n            end +=1\n            continue\n        src +=1\n        gd =queries(n+src ,n+end)\n    print(max(1,maxi))"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n# from typing import *\n\nimport sys\nimport io\nimport math\nimport collections\nimport decimal\nimport itertools\nimport bisect\nimport heapq\n\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\n\n# sys.setrecursionlimit(1000000)\n\n# _INPUT = \"\"\"4\n# 5\n# 5 6 7 6 5\n# 4\n# 8 2 5 10\n# 2\n# 1000 2000\n# 8\n# 465 55 3 54 234 12 45 78\n\n# \"\"\"\n# sys.stdin = io.StringIO(_INPUT)\n\nINF = 10**20\n\nclass SegTree_GCD:\n    def __init__(self, a):\n        n = len(a)\n        self.n1 = 2 ** (n-1).bit_length()\n        self.dat = [0] * self.n1 + a + [INF] * (self.n1-n)\n        for i in reversed(range(1, self.n1)):\n            self.dat[i] = self.gcd1(self.dat[i*2], self.dat[i*2+1])\n    \n    def gcd1(self, v1, v2) -> int:\n        if v1 == INF:\n            return v2\n        elif v2 == INF:\n            return v1\n        else:\n            return math.gcd(v1, v2)\n\n    def get_rgcd(self, l, r) -> int:\n        l += self.n1\n        r += self.n1\n        v = INF\n        while l < r:\n            if l & 1:\n                v = self.gcd1(v, self.dat[l])\n                l += 1\n            if r & 1:\n                v = self.gcd1(v, self.dat[r-1])\n                r -= 1\n            l //= 2\n            r //= 2\n        return v\n\n    def update(self, i, x) -> None:\n        i += self.n1\n        self.dat[i] = x\n        while i > 1:\n            i //= 2\n            self.dat[i] = self.gcd1(self.dat[i*2], self.dat[i*2+1])\n\n    def get_value(self, i) -> int:\n        return self.dat[i+self.n1]\n\ndef solve(N, A):\n    if N == 1:\n        return 1\n    elif N == 2:\n        if abs(A[0]-A[1]) > 1:\n            return 2\n        else:\n            return 1\n\n    B = [A[i+1] - A[i] for i in range(N-1)]\n    \n    segt_gcd = SegTree_GCD(B)\n    length = 0\n    r = 1\n    for l in range(N-1):\n        r = l + length\n        while r+1 <= N-1 and segt_gcd.get_rgcd(l, r+1) not in [1, -1]:\n            r += 1\n        \n        length = max(length, r-l)\n\n    return length + 1\n\nT0 = int(input())\nfor _ in range(T0):\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(solve(N, A))"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while y>0:\n            x, y=y, x%y\n        return x\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2                                    \n\n    total=bmax\n    c=int(0.5+math.log2(bmax))\n    k=0\n    while k+total<n:\n        if St[k][c]!=1:\n            start=total+1\n            end=min(n-k-1, bmax*2-1)\n            while start<=end:\n                j=(start+end)//2\n                if HCF(St[k][c], St[k+j-2**c][c])!=1:\n                    total=j\n                    start=j+1\n                else:\n                    end=j-1    \n        k+=1\n\n    def possible_group(x, y):\n        c=b[x]\n        for i in range(x+1, y):\n            c=HCF(c, b[i])\n            if c==1:\n                return False\n        return True        \n\n#    total=bmax\n#    start=bmax+1\n#    end=min(n-1, bmax*2-1)\n#    c=int(0.5+math.log2(bmax))\n#    while start<=end:\n#        j=(start+end)//2\n#        for k in range(n-j):            \n#            if HCF(St[k][c], St[k+j-2**c][c])!=1:\n#                total=j\n#                start=j+1\n#                break\n#        if start<=j:\n#            end=j-1\n            \n    \n    print(total+1)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while x>1:\n            x, y=y%x, x\n        if x==1:\n            return 1\n        else:        \n            return y\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2                                    \n\n #   total=bmax\n #   c=int(math.log2(bmax))\n #   k=0\n #   while k+total<n:\n #       if St[k][c]!=1:\n #           start=total+1\n #           end=min(n-k-1, bmax*2-1)\n #           while start<=end:\n #               j=(start+end)//2\n #               if HCF(St[k][c], St[k+j-2**c][c])!=1:\n #                   total=j\n #                   start=j+1\n #               else:\n #                   end=j-1    \n #       k+=1\n\n#    def possible_group(x, y):\n#        c=b[x]\n#        for i in range(x+1, y):\n#            c=HCF(c, b[i])\n#            if c==1:\n#                return False\n#        return True        \n\n#    total=bmax\n#    start=bmax+1\n#    end=min(n-1, bmax*2-1)\n#    c=int(math.log2(bmax))\n#    upton=2**c\n#    while start<=end:\n#        j=(start+end)//2\n#        for k in range(n-j):            \n#            if HCF(St[k][c], St[k+j-upton][c])!=1:\n#                total=j\n#                start=j+1\n#                break\n#        if start<=j:\n#            end=j-1\n\n    total=bmax+1\n    l=0\n    r=total\n    c=int(math.log2(bmax))\n    while r<n:\n        while r-l>=total and HCF(St[l][c], St[r-2**c][c])==1:\n            l+=1\n        if r-l>=total:\n            total=r-l+1\n        r+=1 \n\n    \n    print(total)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 3,
            "solution": "from math import gcd\nclass SegTree:\n    def __init__(self, a) -> None:\n        n = len(a)\n        self.size = size = 1<<((n-1).bit_length())\n        self.tree = [0]*(2*size)\n        self.tree[size:size+n] = a\n        for i in range(size-1,0,-1):\n            self.tree[i] = gcd(self.tree[2*i],self.tree[2*i+1])\n    def query(self,l,r):\n        l+=self.size\n        r+=self.size\n        ans = 0\n        while l!=r:\n            if l&1:\n                ans = gcd(ans,self.tree[l])\n                l+=1\n            if r&1:\n                r-=1\n                ans = gcd(ans, self.tree[r])\n            r>>=1\n            l>>=1\n        return ans\nif __name__ == \"__main__\":\n    for t in range(int(input())):\n        n = int(input())\n        b = list(map(int,input().split()))\n        a = []\n        for i in range(1,len(b)):\n            a.append(b[i]-b[i-1])\n        st = SegTree(a)\n        j = 0\n        ans = 1\n        for i in range(n-1):\n            while j<=i and st.query(j,i+1) == 1:\n                j+=1\n            ans = max(ans,i-j+2)\n        print(ans, flush=False)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class Main { \n    static Random random;\n \n    /* public static void main(String[] args){\n        new Thread(null, new Template (), \"Main\", 1<<26).start();\n    } */\n \n    public static void main(String[] args) {\n        FastScanner in = new FastScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        random = new Random();\n         \n        // long timeStamp = System.currentTimeMillis();\n        Solver solver = new Solver();\n        solver.solve(in, out);\n        out.close();\n        // System.err.println(\"TIME: \"+(System.currentTimeMillis()-timeStamp)+\" ms\");\n    }\n     \n    /* ------------------------------------- START -------------------------------------------- */\n    static class Solver {\n        public void solve(FastScanner in, PrintWriter out) {\n            int tests = in.nextInt();\n            for(int cases = 0; cases < tests; ++cases){\n                solveOne(in, out);\n            }\n        }\n\n        private void solveOne(FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            long[] input = new long[n];\n\n            for(int i = 0; i<n; i++){\n                input[i] = in.nextLong();\n            }\n\n            for(int i = n-1; i>=1; i--){\n                input[i] -= input[i-1];\n                if(input[i] < 0)\n                    input[i] = -input[i];\n            }\n\n            // new Debug().d(\"input\", input).d();\n\n            @SuppressWarnings(\"unchecked\")\n            ArrayList<Tuple>[] gcds = new ArrayList[n];\n            gcds[0] = new ArrayList<>();\n\n            int ans = 1;\n\n            for(int i = 1; i<n; i++){\n                gcds[i] = new ArrayList<>();\n                if(i > 1){\n                    Tuple prev = gcds[i-1].get(0);\n                    gcds[i].add(new Tuple(gcd(prev.a, input[i]), 1));\n                }\n\n\n                // new Debug().d(\"i\", i).d();\n                for(int j = 1; j<gcds[i-1].size(); j++){\n                    // new Debug().d(\"j\", j).d();\n                    Tuple prev = gcds[i-1].get(j);\n                    long g = gcd(prev.a, input[i]);\n                    if(g != gcds[i].get(gcds[i].size()-1).a){\n                        gcds[i].add(new Tuple(g, prev.b));\n                    }\n                }\n\n                if(gcds[i].isEmpty() || input[i] != gcds[i].get(gcds[i].size()-1).a){\n                    gcds[i].add(new Tuple(input[i], i));\n                }\n\n                // new Debug().d(\"gcds\", i, gcds[i]).d();\n\n                for(int j = 0; j<gcds[i].size(); j++){\n                    if(gcds[i].get(j).a != 1)\n                        ans = Math.max(ans, i - gcds[i].get(j).b + 2);\n                }\n            }\n\n            // new Debug().d(\"ans\", ans).d();\n\n            out.println(ans);\n        }\n\n        private static long gcd(long a, long b){\n            while(b != 0){\n                a %= b;\n                {long swapTemp = a; a = b; b = swapTemp;}\n            }\n            return a;\n        }\n\n        private static class Tuple {\n            public long a;\n            public int b;\n            public Tuple(long a, int b){\n                this.a = a;\n                this.b = b;\n            }\n            public boolean equals(Object o) {\n                if(o == null || getClass() != o.getClass()) return false;\n                Tuple t = (Tuple) o;\n                return a == t.a && b == t.b;\n            }\n            public String toString(){\n                return \"(\" + a + \", \" + b + ')';\n            }\n        }\n    }\n    /* -------------------------------------- END --------------------------------------------- */\n     \n    /* Shuffle function to shuffle before Arrays.sort */\n    static void shuffle(int[] arr){\n        int swapTemp;\n        for(int i = arr.length-1; i>= 1; i--){\n            int pos = random.nextInt(i+1);\n            if(pos == i) continue;\n            {swapTemp = arr[i]; arr[i] = arr[pos]; arr[pos] = swapTemp;}\n        }\n    }\n     \n    /* Fast Input reader */\n    static class FastScanner {\n        BufferedReader reader;\n        StreamTokenizer tokenizer;\n        public FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = new StreamTokenizer(reader);\n            tokenizer.resetSyntax();\n            tokenizer.whitespaceChars(0, 32);\n            tokenizer.wordChars(33, 126);\n        }\n        private void nextToken(){\n            try{ tokenizer.nextToken(); }\n            catch (Exception e) { e.printStackTrace(); }\n        }\n        String next() {\n            nextToken();\n            return tokenizer.sval;\n        }\n        int nextInt() {\n            nextToken();\n            return Integer.parseInt(tokenizer.sval);\n        }\n        long nextLong() {\n            nextToken();\n            return Long.parseLong(tokenizer.sval);\n        }\n        double nextDouble() {\n            nextToken();\n            return Double.parseDouble(tokenizer.sval);\n        }\n        String nextLine() {\n            try{\n                String string = reader.readLine();\n                return string;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom collections import defaultdict\nfrom  collections import deque\ninput = sys.stdin.readline\n \ndef gcd(a, b):\n    if a < b:\n        a, b = b, a\n    while b > 0:\n        a, b = b, a % b\n    return a\n\nclass StackWithGCD:\n    def __init__(self, s):\n        self._size = 0\n        self._data = [0] * (s + 5)\n        self._gcd = [0] * (s + 5)\n\n    def reset(self):\n        self._size = 0\n\n    def empty(self):\n        return self._size == 0\n\n    def _internal_push(self, v, v_gcd):\n        self._data[self._size] = v\n        self._gcd[self._size] = v_gcd\n        self._size += 1\n\n    def pop(self):\n        self._size -= 1\n        return self._data[self._size]\n\n    def current_gcd(self):\n        return self._gcd[self._size - 1]\n\n    def push(self, v):\n        if self.empty():\n            self._internal_push(v, v)\n        else:\n            self._internal_push(v, gcd(v, self.current_gcd()))\n \nclass Queue:\n    def __init__(self, s):\n        self.stack1 = StackWithGCD(s)\n        self.stack2 = StackWithGCD(s)\n\n    def reset(self):\n        self.stack1.reset()\n        self.stack2.reset()\n\n    def add(self, val):\n        self.stack1.push(val)\n \n    def pop(self):\n        if self.stack2.empty():\n            while not self.stack1.empty():\n                val = self.stack1.pop()\n                self.stack2.push(val)\n        if not self.stack2.empty():\n            return self.stack2.pop()\n        return\n \n    def get_gcd(self):\n        if self.stack1.empty() and self.stack2.empty():\n            return \n        if self.stack1.empty():\n            return self.stack2.current_gcd()\n        if self.stack2.empty():\n            return self.stack1.current_gcd()\n        \n        return gcd(self.stack1.current_gcd(), self.stack2.current_gcd())\n\n\ndef solve(q, vals):\n    max_len = 0\n    r = 1 \n    for i in range(1, len(vals)):\n        q.pop()\n \n        while q.get_gcd()  is None or (r < len(vals) and q.get_gcd()  > 1):\n            if r < len(vals):\n                diff = abs(vals[r] - vals[r-1])\n                q.add(diff)\n                r += 1\n            else:\n                break\n        max_len = max(max_len, r - i)\n        if q.get_gcd() is not None and q.get_gcd() > 1:\n            max_len = max(max_len, r - i+1)\n \n    return max_len\n \nif __name__ == \"__main__\":\n    n = int(input())\n\n    q = Queue(200 * 1000 + 5)\n    \n    for _ in range(n):\n        q.reset()\n        k = int(input())\n        if k == 1:\n            _ = input()\n            print(1)\n        else:\n            vals = list(map(int, input().split()))\n            sys.stdout.write(str(solve(q, vals)) + '\\n')\n\n"
        },
        {
            "language": 3,
            "solution": "#                   __         __                                         __     \n#   _________  ____/ /__  ____/ /_______  ____ _____ ___  ___  _____ ____/ /___ _\n#  / ___/ __ / __  / _ / __  / ___/ _ / __ `/ __ `__ / _ / ___// __  / __ `/\n# / /__/ /_/ / /_/ /  __/ /_/ / /  /  __/ /_/ / / / / / /  __/ /   / /_/ / /_/ / \n# __/___/_,_/__/_,_/_/   __/_,_/_/ /_/ /_/__/_/_____,_/_, /  \n#                                                            /_____/    /____/   \nfrom sys import *\n'''sys.stdin = open('input.txt', 'r')  \nsys.stdout = open('output.txt', 'w') '''\nfrom collections import defaultdict as dd\nfrom math import *\nfrom bisect import *\n#sys.setrecursionlimit(10 ** 8)\ndef sinp():\n    return stdin.readline()\ndef inp():\n    return int(stdin.readline())\ndef minp():\n    return map(int, stdin.readline().split())\ndef linp():\n    return list(map(int, stdin.readline().split()))\ndef strl():\n    return list(sinp())\ndef pr(x):\n    print(x)\nmod = int(1e9+7)\ndef bsearch(low, high):\n    ans = 0\n    while low <= high:\n        flag = False\n        mid = (low + high) // 2\n        for i in range(n - mid + 1):\n            a, b = i, i + mid - 1\n            p = log_[b - a + 1]\n            cur = gcd(t[p][a], t[p][b - (1 << p) + 1])\n            if cur > 1:\n                flag = True\n                break\n        if flag:\n            ans = mid + 1\n            low = mid + 1\n        else:\n            high = mid - 1\n    return ans\nfor _ in range(inp()):\n    n = inp()\n    x = linp()\n    l = [abs(x[i] - x[i + 1]) for i in range(n - 1)]\n    n -= 1\n    log_ = [0 for i in range(n + 1)]\n    for  i in range(2, n + 1):\n        log_[i] = log_[i >> 1] + 1\n    t = [[0 for i in range(n + 1)] for j in range(20)]\n    for i in range(log_[n] + 1):\n        j = 0\n        curr = 1 << i\n        while j + curr <= n:\n            if curr == 1:\n                t[i][j] = l[j]\n            else:\n                t[i][j] = gcd(t[i - 1][j], t[i - 1][j + (curr >> 1)])\n            j += 1\n    pr(max(bsearch(1, n), 1))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> v, d;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nstruct RMQ {\n  vector<vector<long long>> rmq;\n  vector<int> logb2;\n  RMQ() {}\n  RMQ(vector<long long>& v) {\n    int n = (int)v.size();\n    logb2.resize(n + 1, 0);\n    rmq.resize(1, vector<long long>(n));\n    for (int i = 0; i < n; i++) {\n      rmq[0][i] = v[i];\n    }\n    for (int i = 0; (1 << i) <= n; i++) {\n      logb2[1 << i] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n      logb2[i] = max(logb2[i], logb2[i - 1]);\n    }\n    rmq.resize(logb2.back() + 1);\n    for (int t = 1; t < (int)rmq.size(); t++) {\n      rmq[t].resize(n - (1 << t) + 1);\n      for (int i = 0; i <= n - (1 << t); i++)\n        rmq[t][i] = gcd(rmq[t - 1][i], rmq[t - 1][i + (1 << (t - 1))]);\n    }\n  }\n  long long query(int i, int j) {\n    if (i > j) {\n      swap(i, j);\n    }\n    int k = logb2[j - i + 1];\n    return gcd(rmq[k][i], rmq[k][j - (1 << k) + 1]);\n  }\n};\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    v.resize(n);\n    d.resize(n - 1);\n    for (auto& x : v) {\n      cin >> x;\n    }\n    if (n == 1) {\n      cout << \"1\\n\";\n      continue;\n    }\n    if (n == 2) {\n      cout << 1 + (abs(v[0] - v[1]) > 1) << '\\n';\n      continue;\n    }\n    for (int i = 0; i < n - 1; i++) d[i] = abs(v[i] - v[i + 1]);\n    if (count(d.begin(), d.end(), 1) == n - 1) {\n      cout << 1 << '\\n';\n      continue;\n    }\n    int res = 0;\n    RMQ rmq(d);\n    for (int i = 0; i < n - 1; i++) {\n      long long cur = d[i];\n      int j = i;\n      while (j < n - 1) {\n        if (cur == 1) {\n          break;\n        }\n        int l = j + 1, r = n - 1;\n        while (l != r) {\n          int mid = (l + r) >> 1;\n          long long g = rmq.query(i, mid);\n          g == cur ? l = mid + 1 : r = mid;\n        }\n        if (l == n - 1) {\n          j = l;\n          break;\n        }\n        j = l;\n        cur = rmq.query(i, l);\n      }\n      res = max(res, j - i);\n    }\n    cout << res + 1 << '\\n';\n  }\n  cin.ignore(2);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while x>1:\n            x, y=y%x, x\n        if x==1:\n            return 1\n        else:        \n            return y\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2                                    \n\n #   total=bmax\n #   c=int(math.log2(bmax))\n #   k=0\n #   while k+total<n:\n #       if St[k][c]!=1:\n #           start=total+1\n #           end=min(n-k-1, bmax*2-1)\n #           while start<=end:\n #               j=(start+end)//2\n #               if HCF(St[k][c], St[k+j-2**c][c])!=1:\n #                   total=j\n #                   start=j+1\n #               else:\n #                   end=j-1    \n #       k+=1\n\n#    def possible_group(x, y):\n#        c=b[x]\n#        for i in range(x+1, y):\n#            c=HCF(c, b[i])\n#            if c==1:\n#                return False\n#        return True        \n\n#    total=bmax\n#    start=bmax+1\n#    end=min(n-1, bmax*2-1)\n#    c=int(math.log2(bmax))\n#    upton=2**c\n#    while start<=end:\n#        j=(start+end)//2\n#        for k in range(n-j):            \n#            if HCF(St[k][c], St[k+j-upton][c])!=1:\n#                total=j\n#                start=j+1\n#                break\n#        if start<=j:\n#            end=j-1\n\n    total=bmax+1\n    l=0\n    r=total\n    c=int(math.log2(bmax))\n    while r<n:\n        while r-l+1>total and HCF(St[l][c], St[r-2**c][c])==1:\n            l+=1\n        if r-l+1>total:\n            total=r-l+1\n        r+=1 \n\n    \n    print(total)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 3,
            "solution": "from math import log2, gcd, ceil\nfrom pprint import pprint\n# class SparseTable:\n#     def __init__(self, arr, logs) -> None:\n#         self.n = len(arr)\n#         self.logs = logs\n#         l = self.logs[self.n]\n#         self.mat = [arr]\n#         for i in range(1,l+1):\n#             j = 0\n#             self.mat.append([0]*(self.n-(1<<i)+1))\n#             while (j+(1<<i))<=self.n:\n#                 self.mat[i][j] = gcd(self.mat[i-1][j], self.mat[i-1][j+(1<<(i-1))]) \n#                 j+=1\n\n#     def query(self,l,r):\n#         n = r-l+1\n#         l2 = self.logs[n]\n#         return gcd(self.mat[l2][l], self.mat[l2][r-(1<<l2)+1])\nclass RangeQuery:\n    def __init__(self, data, func=gcd):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, begin, end):\n        depth = (end - begin).bit_length() - 1\n        return self.func(self._data[depth][begin], self._data[depth][end - (1 << depth)])\nif __name__ == \"__main__\":\n    for t in range(int(input())):\n        n = int(input())\n        b = list(map(int,input().split()))\n        a = []\n        for i in range(1,len(b)):\n            a.append(b[i]-b[i-1])\n        st = RangeQuery(a)\n        j = 0\n        ans = 1\n        for i in range(n-1):\n            while j<=i and st.query(j,i+1) == 1:\n                j+=1\n            ans = max(ans,i-j+2)\n        print(ans)\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.BigInteger;\n\n/**\n __                  __\n ( _)                ( _)\n / / \\\\              / /\\_\\_\n / /   \\\\            / / | \\ \\\n / /     \\\\          / /  |\\ \\ \\\n /  /   ,  \\ ,       / /   /|  \\ \\\n /  /    |\\_ /|      / /   / \\   \\_\\\n /  /  |\\/ _ '_| \\   / /   /   \\    \\\\\n |  /   |/  0 \\0\\    / |    |    \\    \\\\\n |    |\\|      \\_\\_ /  /    |     \\    \\\\\n |  | |/    \\.\\ o\\o)  /      \\     |    \\\\\n \\    |     /\\\\`v-v  /        |    |     \\\\\n | \\/    /_| \\\\_|  /         |    | \\    \\\\\n | |    /__/_ `-` /   _____  |    |  \\    \\\\\n \\|    [__]  \\_/  |_________  \\   |   \\    ()\n /    [___] (    \\         \\  |\\ |   |   //\n |    [___]                  |\\| \\|   /  |/\n /|    [____]                  \\  |/\\ / / ||\n (  \\   [____ /     ) _\\      \\  \\    \\| | ||\n \\  \\  [_____|    / /     __/    \\   / / //\n |   \\ [_____/   / /        \\    |   \\/ //\n |   /  '----|   /=\\____   _/    |   / //\n __ /  /        |  /   ___/  _/\\    \\  | ||\n (/-(/-\\)       /   \\  (/\\/\\)/  |    /  | /\n (/\\/\\)           /   /   //\n _________/   /    /\n \\____________/    (\n\n\n @author NTUDragons-Reborn\n */\n\npublic class C{\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(in, out);\n        out.close();\n    }\n    // main solver\n    static class Task{\n\n        double eps= 0.00000001;\n        static final int MAXN = 1010;\n        static final int MOD= 1000000007;\n\n        // stores smallest prime factor for every number\n        static int spf[] = new int[MAXN];\n\n        static boolean[] prime;\n\n        Map<Integer,Set<Integer>> dp= new HashMap<>();\n\n        // Calculating SPF (Smallest Prime Factor) for every\n        // number till MAXN.\n        // Time Complexity : O(nloglogn)\n        public void sieve()\n        {\n            spf[1] = 1;\n            for (int i=2; i<MAXN; i++)\n\n                // marking smallest prime factor for every\n                // number to be itself.\n                spf[i] = i;\n\n            // separately marking spf for every even\n            // number as 2\n            for (int i=4; i<MAXN; i+=2)\n                spf[i] = 2;\n\n            for (int i=3; i*i<MAXN; i++)\n            {\n                // checking if i is prime\n                if (spf[i] == i)\n                {\n                    // marking SPF for all numbers divisible by i\n                    for (int j=i*i; j<MAXN; j+=i)\n\n                        // marking spf[j] if it is not\n                        // previously marked\n                        if (spf[j]==j)\n                            spf[j] = i;\n                }\n            }\n        }\n\n        void sieveOfEratosthenes(int n)\n        {\n            // Create a boolean array\n            // \"prime[0..n]\" and\n            // initialize all entries\n            // it as true. A value in\n            // prime[i] will finally be\n            // false if i is Not a\n            // prime, else true.\n            prime= new boolean[n + 1];\n            for (int i = 0; i <= n; i++)\n                prime[i] = true;\n    \n            for (int p = 2; p * p <= n; p++)\n            {\n                // If prime[p] is not changed, then it is a\n                // prime\n                if (prime[p] == true)\n                {\n                    // Update all multiples of p\n                    for (int i = p * p; i <= n; i += p)\n                        prime[i] = false;\n                }\n            }\n        }\n\n        // A O(log n) function returning primefactorization\n        // by dividing by smallest prime factor at every step\n        public Set<Integer> getFactorization(int x)\n        {\n            if(dp.containsKey(x)) return dp.get(x);\n            Set<Integer> ret = new HashSet<>();\n            while (x != 1)\n            {\n                if(spf[x]!=2) ret.add(spf[x]);\n                x = x / spf[x];\n            }\n            dp.put(x,ret);\n            return ret;\n        }\n        // function to find first index >= x\n        public int lowerIndex(List<Integer> arr, int n, int x)\n        {\n            int l = 0, h = n - 1;\n            while (l <= h)\n            {\n                int mid = (l + h) / 2;\n                if (arr.get(mid) >= x)\n                    h = mid - 1;\n                else\n                    l = mid + 1;\n            }\n            return l;\n        }\n        public int lowerIndex(int[] arr, int n, int x)\n        {\n            int l = 0, h = n - 1;\n            while (l <= h)\n            {\n                int mid = (l + h) / 2;\n                if (arr[mid] >= x)\n                    h = mid - 1;\n                else\n                    l = mid + 1;\n            }\n            return l;\n        }\n\n        // function to find last index <= y\n        public int upperIndex(List<Integer> arr, int n, int y)\n        {\n            int l = 0, h = n - 1;\n            while (l <= h)\n            {\n                int mid = (l + h) / 2;\n                if (arr.get(mid) <= y)\n                    l = mid + 1;\n                else\n                    h = mid - 1;\n            }\n            return h;\n        }\n        public int upperIndex(int[] arr, int n, int y)\n        {\n            int l = 0, h = n - 1;\n            while (l <= h)\n            {\n                int mid = (l + h) / 2;\n                if (arr[mid] <= y)\n                    l = mid + 1;\n                else\n                    h = mid - 1;\n            }\n            return h;\n        }\n\n        // function to count elements within given range\n        public int countInRange(List<Integer> arr, int n, int x, int y)\n        {\n            // initialize result\n            int count = 0;\n            count = upperIndex(arr, n, y) -\n                    lowerIndex(arr, n, x) + 1;\n            return count;\n        }\n\n        public int add(int a, int b){\n            a+=b;\n            if(a>=MOD) a-=MOD;\n            else if(a<0) a+=MOD;\n            return a;\n        }\n\n        public int mul(int a, int b){\n            long res= (long)a*(long)b;\n            return (int)(res%MOD);\n        }\n\n        public int power(int a, int b) {\n            int ans=1;\n            while(b>0){\n                if((b&1)!=0) ans= mul(ans,a);\n                b>>=1;\n                a= mul(a,a);\n            }\n            return ans;\n        }\n\n        int[] fact= new int[MAXN];\n        int[] inv= new int[MAXN];\n\n        public int Ckn(int n, int k){\n            if(k<0 || n<0) return 0;\n            return mul(mul(fact[n],inv[k]),inv[n-k]);\n        }\n\n        public int inverse(int a){\n            return power(a,MOD-2);\n        }\n\n        public void preprocess() {\n            fact[0]=1;\n            for(int i=1;i<MAXN;i++) fact[i]= mul(fact[i-1],i);\n            inv[MAXN-1]= inverse(fact[MAXN-1]);\n            for(int i=MAXN-2;i>=0;i--){\n                inv[i]= mul(inv[i+1],i+1);\n            }\n        }\n\n        /**\n         * return VALUE of lower bound for unsorted array\n         */\n        public int lowerBoundNormalArray(int[] arr, int x){\n            TreeSet<Integer> set= new TreeSet<>();\n            for(int num: arr) set.add(num);\n            return set.lower(x);\n        }\n        /**\n         * return VALUE of upper bound for unsorted array\n         */\n        public int upperBoundNormalArray(int[] arr, int x){\n            TreeSet<Integer> set= new TreeSet<>();\n            for(int num: arr) set.add(num);\n            return set.higher(x);\n        }\n\n        public void debugArr(int[] arr){\n            for(int i: arr) out.print(i+\" \");\n            out.println();\n        }\n\n        public int rand(){\n            int min=0, max= MAXN;\n            int random_int = (int)Math.floor(Math.random()*(max-min+1)+min);\n            return random_int;\n        }\n        \n        InputReader in; PrintWriter out;\n        \n        public void solve(InputReader in, PrintWriter out) {\n            this.in=in; this.out=out;\n            int t= in.nextInt();\n            while(t-->0){\n                solveC();\n            }\n        }\n\n        public void solveC(){\n            int n= in.nextInt();\n            long prev= -1;\n            List<Long> d= new ArrayList<>();\n            for (int i =0; i < n; i++){\n                long num = in.nextLong();\n                if (prev!=-1){\n                    long dd = num-prev;\n                    if (dd<0) dd=-dd;\n                    d.add(dd);\n                }\n                prev = num;\n            }\n            if (n==1){\n                out.println(1); return;\n            }\n            SEG tree = new SEG(d);\n            int ans = 1;\n            n = d.size();\n            int hi= 0, lo=0;\n            while(hi<n) {\n                while(hi<n && tree.query(0, 0, n-1, lo, hi)>1) hi++;\n                ans= Math.max(ans,hi-lo+1);\n                lo++;\n                if(hi<lo) hi= lo;\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class SEG {\n        public long _gcd(long a,  long  b)\n        {\n\n            if(b == 0) {\n                return a;\n            }\n            else {\n                return _gcd(b, a % b);\n            }\n        }\n        long[] segs;\n        public SEG(List<Long> a) {\n            int n= a.size();\n            segs= new long[4*n];\n            build(0,a,0,n-1);\n        }\n        void build(int root, List<Long> a, int l, int r){\n            if (l==r){\n                segs[root] = a.get(l); return;\n            }\n            int m = (l+r) >> 1;\n            build(root*2+1, a, l, m);\n            build(root*2+2, a, m+1, r);\n            segs[root] = _gcd(segs[root*2+1], segs[root*2+2]);\n        }\n        long query(int root, int l, int r, int lq, int rq){\n            if (lq > r || rq < l) return 0l;\n            if (l >= lq && rq >= r) return segs[root];\n            int m = (l+r)>>1;\n            return _gcd(query(root*2+1, l, m, lq, rq),\n                         query(root*2+2, m+1, r, lq, rq));\n        }\n    }\n\n    static class Venice{\n        public Map<Long,Long> m= new HashMap<>();\n        public long base=0;\n        public long totalValue=0;\n        private int M= 1000000007;\n\n        private long addMod(long a, long b){\n            a+=b;\n            if(a>=M) a-=M;\n            return a;\n        }\n\n        public void reset(){\n            m= new HashMap<>();\n            base=0;\n            totalValue=0;\n        }\n        public void update(long add){\n            base= base+ add;\n        }\n        public void add(long key, long val){\n            long newKey= key-base;\n            m.put(newKey, addMod(m.getOrDefault(newKey,(long)0),val));\n        }\n    }\n\n\n\n    static class Tuple implements Comparable<Tuple>{\n        int x, y, z;\n        public Tuple(int x, int y, int z){\n            this.x= x;\n            this.y= y;\n            this.z=z;\n        }\n        @Override\n        public int compareTo(Tuple o){\n            return this.x-o.x;\n        }\n    }\n\n    static class Pair implements Comparable<Pair>{\n        public int x;\n        public int y;\n        public Pair(int x, int y){\n            this.x= x;\n            this.y= y;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            return this.x-o.x;\n        }\n    }\n\n    // public static class compareL implements Comparator<Tuple>{\n    //     @Override\n    //     public int compare(Tuple t1, Tuple t2) {\n    //         return t2.l - t1.l;\n    //     }\n    // }\n\n    // fast input reader class;\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (line == null) {\n                    return null;\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(nextToken());\n        }\n        public long nextLong(){\n            return Long.parseLong(nextToken());\n        }\n        public int[] nextIntArr(int n){\n            int[] arr= new int[n];\n            for(int i=0;i<n;i++) arr[i]= nextInt();\n            return arr;\n        }\n        public long[] nextLongArr(int n){\n            long[] arr= new long[n];\n            for(int i=0;i<n;i++) arr[i]= nextLong();\n            return arr;\n        }\n        public List<Integer> nextIntList(int n){\n            List<Integer> arr= new ArrayList<>();\n            for(int i=0;i<n;i++) arr.add(nextInt());\n            return arr;\n        }\n        public int[][] nextIntMatArr(int n, int m){\n            int[][] mat= new int[n][m];\n            for(int i=0;i<n;i++) for(int j=0;j<m;j++) mat[i][j]= nextInt();\n            return mat;\n        }\n        public List<List<Integer>> nextIntMatList(int n, int m){\n            List<List<Integer>> mat= new ArrayList<>();\n            for(int i=0;i<n;i++){\n                List<Integer> temp= new ArrayList<>();\n                for(int j=0;j<m;j++) temp.add(nextInt());\n                mat.add(temp);\n            }\n            return mat;\n        }\n        public char[] nextStringCharArr(){\n            return nextToken().toCharArray();\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct input_data {\n  int n;\n  vector<long long> a;\n};\ninput_data read_input() {\n  input_data in;\n  cin >> in.n;\n  in.a.resize(in.n);\n  for (int i = 0; i < in.n; ++i) {\n    cin >> in.a[i];\n  }\n  return in;\n}\nlong long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\nclass gcd_tree {\n  vector<long long> t;\n  int n;\n  void build(const vector<long long>& a, int v, int l, int r) {\n    if (l == r) {\n      t[v] = a[l];\n    } else {\n      int m = (l + r) / 2;\n      build(a, v * 2, l, m);\n      build(a, v * 2 + 1, m + 1, r);\n      t[v] = gcd(t[v * 2], t[v * 2 + 1]);\n    }\n  }\n  long long get(int v, int l, int r, int L, int R) {\n    if (l == L && r == R) {\n      return t[v];\n    } else {\n      int m = (l + r) / 2;\n      if (R <= m) {\n        return get(v * 2, l, m, L, R);\n      } else if (L > m) {\n        return get(v * 2 + 1, m + 1, r, L, R);\n      } else {\n        return gcd(get(v * 2, l, m, L, m), get(v * 2 + 1, m + 1, r, m + 1, R));\n      }\n    }\n  }\n\n public:\n  gcd_tree(const vector<long long>& a) {\n    n = a.size();\n    t.resize(n * 4);\n    build(a, 1, 0, n - 1);\n  }\n  long long get(int l, int r) { return get(1, 0, n - 1, l, r); }\n};\nvoid solve(const input_data& in) {\n  if (in.n == 1) {\n    printf(\"1\\n\");\n    return;\n  }\n  vector<long long> b;\n  for (int i = 1; i < in.n; ++i) {\n    b.push_back(abs(in.a[i] - in.a[i - 1]));\n  }\n  int n = b.size();\n  gcd_tree g(b);\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    int l = i, r = n - 1;\n    while (l < r) {\n      int m = (l + r + 1) / 2;\n      if (g.get(i, m) > 1) {\n        l = m;\n      } else {\n        r = m - 1;\n      }\n    }\n    if (g.get(i, r) > 1) {\n      int len = r - i + 1;\n      ans = max(ans, len);\n    }\n  }\n  printf(\"%d\\n\", ans + 1);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    auto in = read_input();\n    solve(in);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class hacker49 {\n\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n\tstatic long[] x= {1,1,1,0,0,0,-1,-1,-1};\n\tstatic long[] y= {1,-1,0,-1,0,1,1,-1,0};\n\tpublic static void main(String[] args) {\n\t\tOutputStream outputStream =System.out;\n\t    PrintWriter out =new PrintWriter(outputStream);\n\t\tFastReader s=new FastReader();\n\t  int t=s.nextInt();\n//\t  sieve();\n\t  while(t>0) {\n\t\t  int n=s.nextInt();\n\t\t  long[] a=new long[n];\n\t\t  for(int i=0;i<n;i++) {\n\t\t\t  a[i]=s.nextLong();\n\t\t  }\n\t\t\t  long[] diff=new long[n-1];\n\t\t\t  for(int i=0;i<n-1;i++) {\n\t\t\t\t  diff[i]=Math.abs(a[i+1]-a[i]);\n\t\t\t  }\n\t\t\t  if(n==1) {\n\t\t\t\t  out.println(1);\n\t\t\t  }else {\n\t\t\t  long ans=0;\n\t\t\t  int h=nextPowerOf2(n-1);\n\t\t\t  long[] b=new long[2*h-1];\n\t\t\t  CS(diff,b,0,n-2,0);\n\t\t\t  long f=-1;\n\t\t\t  long c=1;\n\t\t\t int j=0;\n\t\t\t int i=0;\n\t\t\t while(j<n-1) {\n\t\t\t\t long d=RS(b,i,j,0,n-2,0);\n\t\t\t\t if(d!=1) {\n\t\t\t\t\tans=Math.max(j-i+2, ans);\n\t\t\t\t }else {\n\t\t\t\t\t while(RS(b,i,j,0,n-2,0)==1) {\n\t\t\t\t\t\t i++;\n\t\t\t\t\t }\n\t\t\t\t\t ans=Math.max(j-i+2, ans);\n\t\t\t\t }\n\t\t\t\t j++;\n\t\t\t }\n\t\t\t  \n\t\t\tout.println(ans);  \n\n\t\t\t  \n\t\t\t  }\n\t\t  t--;\n\t  }\n\t\t\t\t\n\t\t\tout.close();\n\t}\n\tpublic static int[] KMP( String str) {\n\t\tint[] a=new int[str.length()];\n\t\tint j;\n\t\tint i;\n     for(i=1,j=0;i<str.length();) {\n    \t if(str.charAt(i)==str.charAt(j)) {\n    \t\t a[i]=j+1;\n    \t\t j++;\n    \t\t i++;\n    \t }else {\n    \t\t if(j!=0) {\n    \t\t\t j=a[j-1];\n    \t\t  }else {\n    \t\t\t a[j]=0;\n    \t\t\t i++;\n    \t\t }\n    \t }\n     }\n\t\treturn a;\n\t}\n\tpublic static void CS(long[] arr,long[] segtree,int low,int high,int pos) {\n\t\tif(low==high) {\n\t\t\tsegtree[pos]=arr[low];\n\t\t\treturn;\n\t\t}\n\t\tint mid=(low+high)/2;\n\t\tCS(arr,segtree,low,mid,2*pos+1);\n\t\tCS(arr,segtree,mid+1,high,2*pos+2);\n\t\tsegtree[pos]=GCD(segtree[2*pos+1],segtree[2*pos+2]);\n\t\n\t\t}\n\tpublic static long RS(long[] segtree,int qlow,int qhigh,int low,int high,int pos) {\n\t\tif(low>=qlow && high<=qhigh) {\n\t\t\treturn segtree[pos];\n\t\t}\n\t\tif(qhigh<low || qlow>high) {\n\t\t\treturn 0;\n\t\t}\n\t\tint mid=(low+high)/2;\n\treturn GCD(RS(segtree,qlow,qhigh,low,mid,2*pos+1),RS(segtree,qlow,qhigh,mid+1,high,2*pos+2));\n\t}\n\tpublic static void US(long[] segtree,int low,int high,int pos ,long new_val,int index,long prev_val,int c,int n) {\n//\t\tif(index>high || index<low) {\n//\t\t\treturn ;\n//\t\t}\n\t\tif(low==high) {\n\t\t\tsegtree[pos]=new_val;\n\t\t\treturn;\n\t\t}\n//\t\tsegtree[pos]+=diff;\n//\t\t segtree[pos] = (segtree[pos] ^ prev_val) ^ new_val;\n\t\tif(high!=low) {\n\t\t\tint mid=(high+low)/2;\n\t\t\tif(index<=mid) {\n\t\t\tUS(segtree,low,mid,2*pos+1,new_val,index,prev_val,c+1,n);}else {\n\t\t\tUS(segtree,mid+1,high,2*pos+2,new_val,index,prev_val,c+1,n);}\n\t\t\tif((n-c)%2!=0) {\n\t\t\t\tsegtree[pos]=(segtree[2*pos+1]|segtree[2*pos+2]);\n\t\t\t}else {\n\t\t\t\tsegtree[pos]=(segtree[2*pos+1]^segtree[2*pos+2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int nextPowerOf2(int n) \n\t{ \n\t    n--; \n\t    n |= n >> 1; \n\t    n |= n >> 2; \n\t    n |= n >> 4; \n\t    n |= n >> 8; \n\t    n |= n >> 16; \n\t    n++; \n\t      \n\t    return n; \n\t} \n\n\tpublic static int longest_Repeating_Subsequence(String str,int n) {\n\t\tint[][] dp=new int[n+1][n+1];\n\t\t\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tfor(int j=1;j<=n;j++) {\n\t\t\t\tif(str.charAt(i-1)==str.charAt(j-1) &&  i!=j) {\n\t\t\t\t\tdp[i][j]=1+dp[i-1][j-1];\n\t\t\t\t}else {\n\t\t\t\t\tdp[i][j]=Math.max(dp[i][j-1], dp[i-1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn dp[n][n];\n\t}\n\tpublic static int d1(ArrayList<Integer> e,int n,int i) {\n\t\tint l=-1;\n\t\tint r=n;\n\t\t\t\t;\n\t\twhile(r>l+1) {\n\t\t\tint mid=(l+r)/2;\n//\t\t\tlong h=mid^n;\n//\t\t\tSystem.out.println(e.get(mid)+\" \"+mid);\n\t\t\tif(e.get(mid)>i) {\n\t\t\t\tr=mid;\n\t\t\t}else {\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t\t\t\t\n\t}\n\tpublic static int upper_bound(long[] a ,long x,int n) {\n\t\tint l=-1;\n\t\tint r=n;\n\t\twhile(r>l+1) {\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(a[mid]>x) {\n\t\t\t\tr=mid;\n\t\t\t}else {\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t\t\t\t\n\t}\n\tpublic static int lower_bound(long[] a ,long x,int n) {\n\t\tint l=-1;\n\t\tint r=n;\n\t\twhile(r>l+1) {\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(a[mid]<=x) {\n\t\t\t\tl=mid;\n\t\t\t}else {\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t\t\t\t\n\t}\n\tstatic long get=0;\n\tstatic int[] ans=new int[200001];\n//\tstatic int[] dx= {2,2,-2,-2,-1,-1,1,1};\n//\tstatic int[] dy= {1,-1,-1,1,-2,2,-2,2};\n//\tstatic int[][] vis1=new int[101][101];\n//\tstatic boolean valid(int x,int y,int n) {\n//\t\tif(x>=1 && x<=n && y>=1 && y<=n) {\n//\t\t\treturn true;\n//\t\t}\n//\t\treturn false;\n//\t}\n//\tstatic void dfs(int x,int y,char[][] a,int n,char t) {\n//\t\ta[x][y]=t;\n//\t\tvis1[x][y]=1;\n//\t\tfor(int i=0;i<8;i++) {\n//\t\t\tif(valid(x+dx[i],y+dy[i],n) && vis1[x+dx[i]][y+dy[i]]==0) {\n//\t\t\t\tdfs(x+dx[i],y+dy[i],a,n,(t=='W')?'B':'W');\n//\t\t\t}\n//\t\t}\n//\t}\n\n\tstatic int[] h=new int[200001];\n\tstatic int[] subtree=new int[200001];\n\tstatic int[] vis=new int[200001];\n\tstatic HashMap<Integer,pair> e=new HashMap<>();\n\tstatic ArrayList<Integer>[] f1=new ArrayList[200001];\t\n\tstatic PriorityQueue<pair> q=new PriorityQueue<>();\t\n\tstatic ArrayList<pair>[] f=new ArrayList[200001];   \n//\tstatic void bfs() {\n//\t\tQueue<node> q=new LinkedList<>();\n//\t\tq.add(new node(1,0));\n//\t\th[1]=0;\n//\t\tvis[1]=1;\n//\t\twhile(!q.isEmpty()) {\n//\t\t\tnode p=q.poll();\n////\t\t\th[p.a]=p.b;\n//\t\t\tfor(int i=0;i<f1[p.a].size();i++) {\n//\t\t\t\tif(vis[f1[p.a].get(i)]==0) {\n//\t\t\t\t\tq.add(new node(f1[p.a].get(i),p.b+1));\n//\t\t\t\t\th[f1[p.a].get(i)]=p.b+1;\n//\t\t\t\t\tvis[f1[p.a].get(i)]=1;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t}\n\tstatic int dfs(int node) {\n\t\tint c=1;\n\t\tvis[node]=1;\n\t\tfor(int i=0;i<f1[node].size();i++) {\n\t\t\tif(vis[f1[node].get(i)]==0) {\n\t\t\t\tc+=dfs(f1[node].get(i));\n\t\t\t}\n\t\t}\n\t\tsubtree[node]=c;\n\t\treturn c;\n\t}\n\tstatic void dfs2(int node,int v) {\n\t\tvis[node]=1;\n\t\tif(ans[node]==1) {\n\t\t\tget+=v;\n\t\t}\n\t\tfor(int i=0;i<f1[node].size();i++) {\n\t\t\tif(vis[f1[node].get(i)]==0) {\n\t\t\t\tdfs2(f1[node].get(i),v+((ans[node]==0)?1:0));\n\t\t\t}\n\t\t}\n\t}\nstatic long m=-1;\nstatic void sf(long[] min){\n        int n = min.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i){\n            long tmp = min[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            min[i] = min[randomPos];\n            min[randomPos] = tmp;\n        }   \n}\n\n\tstatic class pair implements Comparable<pair>{\n\t\tprivate long a;\n\t\tprivate long b;\n\t\tprivate long c;\n\t\t\n\t\tpair(long a,long b,long c){\n\t\t\tthis.a=a;\n//\t\t\tthis.f=f;\n\t\t\tthis.b=b;\n\t\t\tthis.c=c;\n//\t\t\tthis.d=d;\n//\t\t\tthis.e=e;\n\t\t}\n\t\tpublic int compareTo(pair o) {\n\t\t\tif(o.c!=this.c) {\n//\t\t\treturn Integer.compare(o.c, this.c);}\n//\t\telse {\n\t\t\t\treturn Long.compare(this.c,o.c);\n\t\t\t}else {\n\t\t\t\treturn Long.compare(this.a*this.b,o.a*o.b);\n\t\t\t}\n\t\t}\n//\t\t\n\t\t\n\t}\n\tstatic class node implements Comparable<node>{\n\t\tprivate long a;\n\t\tprivate long b;\n\t\tprivate long c;\n\t\tnode(long a,long b,long c){\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t\tthis.c=c;\n\t\t}\n\t\tpublic int compareTo(node o) {\n//\t\t\treturn Long.compare(arg0, arg1)\n\t\t\tif(this.c!=o.c) {\n\t\t\t\treturn Long.compare(o.c, this.c);\n\t\t\t}else {\n\t\t\t\treturn Long.compare(this.b, o.b);\n\t\t\t}\n\t\t}\n\t}\n\n//\tpublic static int upper_bound(long[] a ,long x,int n) {\n//\t\tint l=-1;\n//\t\tint r=n;\n//\t\twhile(r>l+1) {\n//\t\t\tint mid=(l+r)/2;\n//\t\t\tif(a[mid]<x) {\n//\t\t\t\tl=mid;\n//\t\t\t}else {\n//\t\t\t\tr=mid;\n//\t\t\t}\n//\t\t}\n//\t\treturn r;\n//\t\t\t\t\n//\t}\n//\tpublic static int lower_bound(long[] a ,long x,int m) {\n//\t\tint l=0;\n//\t\tint r=m+1;\n//\t\twhile(r>l+1) {\n//\t\t\tint mid=(l+r)/2;\n//\t\t\tif(a[mid]>=x) {\n//\t\t\t\tr=mid;\n//\t\t\t}else {\n//\t\t\t\tl=mid;\n//\t\t\t}\n//\t\t}\n//\t\treturn r;\n//\t\t\t\t\n//\t}\n\tpublic static long lb(int n,long[] pre,long k,long a,long b,long x,long y) {\n\t\tlong l=0;\n\t\tlong r=n+1;\n\t\twhile(l<r) {\n\t\t\tlong mid=(l+r)/2;\n\t\t\tlong sum=0;\n\t\t\tlong gcd=GCD(a,b);\n\t\t\tlong g=mid/(a*b/gcd);\n\t\t\tlong a1=mid/a;\n\t\t\tlong b1=mid/b;\n\t\t\tsum+=(pre[(int) g]*(x+y))/100;\n\t\t\tif(x>=y) {\n\t\t\t\tsum+=((pre[(int) a1]-pre[(int) g])*x)/100;\n\t\t\t\tsum+=(((pre[(int)(a1+b1-g)]-pre[(int)(a1)])*y))/100;\n\t\t\t}else {\n\t\t\t\tsum+=((pre[(int) b1]-pre[(int) g])*y)/100;\n\t\t\t\tsum+=(((pre[(int)(a1+b1-g)]-pre[(int)(b1)])*x))/100;\n\t\t\t}\n\t\t\tif(sum>=k) {\n\t\t\t\tr=mid;\n\t\t\t}else {\n\t\t\t\tl=mid+1;\n\t\t\t}\n//\t\t\tSystem.out.println(mid+\" \"+h);\n\t\t}\n\t\t\n\t\treturn r;\n\t\t\t\t\n\t}\n\t\n\t\n\t\n\tpublic static long[] merge_sort(long[] A, int start, int end) {\n\t\tif (end > start) {\n\t\t\tint mid = (end + start) / 2;\n\t\t\tlong[] v = merge_sort(A, start, mid);\n\t\t\tlong[] o = merge_sort(A, mid + 1, end);\n\t\t\treturn (merge(v, o));\n\t\t} else {\n\t\t\tlong[] y = new long[1];\n\t\t\ty[0] = A[start];\n\t\t\treturn y;\n\t\t}\n\t}\n\tpublic static long[] merge(long a[], long b[]) {\n\t\t\n\t\tlong[] temp = new long[a.length + b.length];\n\t\tint m = a.length;\n\t\tint n = b.length;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint c = 0;\n\t\twhile (i < m && j < n) {\n\t\t\tif (a[i] < b[j]) {\n\t\t\t\ttemp[c++] = a[i++];\n\t\t\t\n\t\t\t} else {\n\t\t\t\ttemp[c++] = b[j++];\n\t\t\t}\n\t\t}\n\t\twhile (i < m) {\n\t\t\ttemp[c++] = a[i++];\n\t\t}\n\t\twhile (j < n) {\n\t\t\ttemp[c++] = b[j++];\n\t\t}\n\t\treturn temp;\n\t}\t\n\tpublic static int[] Create(int[] a,int n) {\n\t\tint[] b=new int[n+1];\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint j=i;\n\t\t\tint h=a[i];\n\t\t\twhile(i<=n) {\n\t\t\t\tb[i]+=h;\n\t\t\t\ti=get_next(i);\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\treturn b;\n\t}\npublic static int get_next(int a) {\n\treturn a+(a&-a);\n}\npublic static int get_parent(int a) {\n\treturn a-(a&-a);\n}\npublic static int query_1(int[] b,int index) {\n\tint sum=0;\n\tif(index<=0) {\n\t\treturn 0;\n\t}\n\twhile(index>0) {\n\t\tsum+=b[index];\n\t\tindex=get_parent(index);\n\t}\n\treturn sum;\n}\npublic static int query(int[] b,int n,int l,int r) {\n\tint sum=0;\n\tsum+=query_1(b,r);\n\tsum-=query_1(b,l-1);\n\treturn sum;\n}\npublic static void update(int[] a,int[] b,int n,int index,int val) {\n\tint diff=val-a[index];\n\ta[index]+=diff;\n\twhile(index<=n) {\n\t\tb[index]+=diff;\n\t\tindex=get_next(index);\n\t}\t\n}\n\t\n//\tpublic static void Create(int[] a,pair[] segtree,int low,int high,int pos) {\n//\t\tif(low>high) {\n//\t\t\treturn;\n//\t\t}\n//\t\tif(low==high) {\n//\t\t\tsegtree[pos].b.add(a[low]);\n//\t\t\treturn ;\n//\t\t}\n//\t\tint mid=(low+high)/2;\n//\t\tCreate(a,segtree,low,mid,2*pos);\n//\t\tCreate(a,segtree,mid+1,high,2*pos+1);\n//\t\tsegtree[pos].b.addAll(segtree[2*pos].b);\n//\t\tsegtree[pos].b.addAll(segtree[2*pos+1].b);\n//\t}\n//\tpublic static void update(pair[] segtree,int low,int high,int index,int pos,int val,int prev) {\n//\t\tif(index>high || index<low) {\n//\t\t\treturn ;\n//\t\t}\n//\t\tif(low==high && low==index) {\n//\t\t\tsegtree[pos].b.remove(prev);\n//\t\t\tsegtree[pos].b.add(val);\n//\t\t\treturn;\n//\t\t}\n//\t\t\tint mid=(high+low)/2;\n//\t\t\t update(segtree,low,mid,index,2*pos,val,prev);\n//\t\t\t update(segtree,mid+1,high,index,2*pos+1,val,prev);\n//\t\t\t segtree[pos].b.clear();\n//\t\t\t  segtree[pos].b.addAll(segtree[2*pos].b);\n//\t\t\t  segtree[pos].b.addAll(segtree[2*pos+1].b);\n//\t\t\t  \n//\t}\n//\tpublic static pair query(pair[] segtree,int low,int high,int qlow,int qhigh ,int pos) {\n//\t\tif(low>=qlow && high<=qhigh) {\n//\t\t\treturn segtree[pos];\n//\t\t}\n//\t\tif(qhigh<low || qlow>high) {\n//\t\t\treturn new pair();\n//\t\t}\n//\t\tint mid=(low+high)/2;\n//\t  pair a1=query(segtree,low,mid,qlow,qhigh,2*pos);\n//\t  pair a2=query(segtree,mid+1,high,qlow,qhigh,2*pos+1);\n//\t  pair a3=new pair();\n//\t  a3.b.addAll(a1.b);\n//\t  a3.b.addAll(a2.b);\n//\t  return a3;\n//\t  \n//\t}\n//\t\n//\tpublic static int nextPowerOf2(int n) \n//\t{ \n//\t    n--; \n//\t    n |= n >> 1; \n//\t    n |= n >> 2; \n//\t    n |= n >> 4; \n//\t    n |= n >> 8; \n//\t    n |= n >> 16; \n//\t    n++;     \n//\t    return n; \n//\t} \n//\t\n////\tstatic class pair implements Comparable<pair>{\n////\t\tprivate int a;\n////\t\tprivate long b;\n//////\t\tprivate long c;\n////\t\tpair(int a,long b){\n////\t\t\tthis.a=a;\n////\t\t\tthis.b=b;\n//////\t\t\tthis.c=c;\n////\t\t}\n////\t\tpublic int compareTo(pair o) {\n//////\t\tif(this.a!=o.a) {\n//////\t\t\treturn Long.compare(this.a, o.a);\n//////\t\t}else {\n////\t\t\treturn Long.compare(o.b,this.b);\n//////\t\t}\n////\t\t}\n////\t}\n//\tstatic class pair implements Comparable<pair>{\n//\t\tprivate int a;\n//\t\tprivate int b;\n//\t\tpair(int a,int b){\n////\t\t\tthis.b=new HashSet<>();\n//\t\t\tthis.a=a;\n//\t\t\tthis.b=b;\n//\t\t}\n//\t\tpublic int compareTo(pair o) {\n//\t\t\treturn Integer.compare(this.b, o.b);\n//\t\t}\n//\t}\n\tpublic static int lower_bound(ArrayList<Long> a ,int n,long x) {\n\t\tint l=0;\n\t\tint r=n;\n\t\twhile(r>l+1) {\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(a.get(mid)<=x) {\n\t\t\t\tl=mid;\n\t\t\t}else {\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t\treturn l;\t\t\n\t}\n\tpublic static int[] is_prime=new int[10000001];\n\tpublic static ArrayList<Long> primes=new ArrayList<>();\n \tpublic static void sieve() {\n\t\tlong maxN=100000000;\n\t\tfor(long i=1;i<=maxN;i++) {\n\t\t\tis_prime[(int) i]=1;\n\t\t}\n\t\tis_prime[0]=0;\n\t\tis_prime[1]=0;\n\t\tfor(long i=2;i*i<=maxN;i++) {\n\t\t\tif(is_prime[(int) i]==1) {\n//\t\t\t\tprimes.add((int) i);\n\t\t\t\tfor(long j=i*i;j<=maxN;j+=i) {\n\t\t\t\t\tis_prime[(int) j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(long i=0;i<=maxN;i++) {\n\t\t\tif(is_prime[(int) i]==1) {\n\t\t\t\tprimes.add(i);\n\t\t\t}\n\t\t}\t\t\n\t}\n//\tpublic static pair[] merge_sort(pair[] A, int start, int end) {\n//\t\tif (end > start) {\n//\t\t\tint mid = (end + start) / 2;\n//\t\t\tpair[] v = merge_sort(A, start, mid);\n//\t\t\tpair[] o = merge_sort(A, mid + 1, end);\n//\t\t\treturn (merge(v, o));\n//\t\t} else {\n//\t\t\tpair[] y = new pair[1];\n//\t\t\ty[0] = A[start];\n//\t\t\treturn y;\n//\t\t}\n//\t}\n//\tpublic static pair[] merge(pair a[], pair b[]) {\n//\t\tpair[] temp = new pair[a.length + b.length];\n//\t\tint m = a.length;\n//\t\tint n = b.length;\n//\t\tint i = 0;\n//\t\tint j = 0;\n//\t\tint c = 0;\n//\t\twhile (i < m && j < n) {\n//\t\t\tif (a[i].b >= b[j].b) {\n//\t\t\t\ttemp[c++] = a[i++];\n//\t\t\t\n//\t\t\t} else {\n//\t\t\t\ttemp[c++] = b[j++];\n//\t\t\t}\n//\t\t}\n//\t\twhile (i < m) {\n//\t\t\ttemp[c++] = a[i++];\n//\t\t}\n//\t\twhile (j < n) {\n//\t\t\ttemp[c++] = b[j++];\n//\t\t}\n//\t\treturn temp;\n//\t}\n\tpublic static long im(long a) {\n\t\treturn binary_exponentiation_1(a,mod-2)%mod;\n\t}\n\tpublic static long binary_exponentiation_1(long a,long n) {\n\t\tlong res=1;\n\t\twhile(n>0) {\n\t\t\tif(n%2!=0) {\n\t\t\t\tres=((res)%(mod) * (a)%(mod))%(mod);\n\t\t\t\tn--;\n\t\t\t}else {\n\t\t\t\ta=((a)%(mod) *(a)%(mod))%(mod);\n\t\t\t\tn/=2;\n\t\t\t}\n\t\t}\n\t\treturn (res)%(mod);\n\t\t\n\t}\n\tpublic static long b1(long a,long n) {\n\t\tlong res=1;\n\t\twhile(n>0) {\n\t\t\tif(n%2!=0) {\n\t\t\t\tres=((res)%(mod) * (a)%(mod))%(mod);\n\t\t\t\tn--;\n\t\t\t}else {\n\t\t\t\ta=((a)%(mod) *(a)%(mod))%(mod);\n\t\t\t\tn/=2;\n\t\t\t}\n\t\t}\n\t\treturn (res)%(mod);\n\t\t\n\t}\n\n\tpublic static double bn1(double a,double n) {\n\t\tdouble res=1;\n\t\twhile(n>0) {\n\t\t\tif(n%2!=0) {\n//\t\t\t\tres=((res)%(1000000007) * (a)%(1000000007))%(1000000007);\n\t\t\t\tres=(res*a);\n\t\t\t\tn--;\n\t\t\t}else {\n//\t\t\t\ta=((a)%(1000000007) *(a)%(1000000007))%(1000000007);\n\t\t\t\ta=(a*a);\n\t\t\t\tn/=2;\n\t\t\t}\n\t\t}\n\t\treturn (res);\t\n\t}\n\tpublic static long bn(long a,long n) {\n\t\tlong res=1;\n\t\twhile(n>0) {\n\t\t\tif(n%2!=0) {\n\t\t\t\tres=res*a;\n\t\t\t\tn--;\n\t\t\t}else {\n\t\t\t\ta*=a;\n\t\t\t\tn/=2;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t\t\n\t}\npublic static long[] fac=new long[300001];\npublic static void ff() {\n\t\tfac[0]=(long)1;\n\t\tfac[1]=(long)1;\n\t\tfor(long i=2;i<=300000;i++) {\n\t\t\tfac[(int) i]=(fac[(int) (i-1)]*i)%(m);\n\t\t}\n\t}\t\npublic static long mod=1000000007;\npublic static long GCD(long a,long b) {\n\t\tif(b==(long)0) {\n\t\t\treturn a;\n\t\t}\n\t\treturn GCD(b , a%b);\n\t}\npublic static long c=0;\t\n}"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while y:\n            x, y=y, x%y\n        return x\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2                                    \n\n #   total=bmax\n #   c=int(0.5+math.log2(bmax))\n #   k=0\n #   while k+total<n:\n #       if St[k][c]!=1:\n #           start=total+1\n #           end=min(n-k-1, bmax*2-1)\n #           while start<=end:\n #               j=(start+end)//2\n #               if HCF(St[k][c], St[k+j-2**c][c])!=1:\n #                   total=j\n #                   start=j+1\n #               else:\n #                   end=j-1    \n #       k+=1\n\n    def possible_group(x, y):\n        c=b[x]\n        for i in range(x+1, y):\n            c=HCF(c, b[i])\n            if c==1:\n                return False\n        return True        \n\n    total=bmax\n    start=bmax+1\n    end=min(n-1, bmax*2-1)\n    c=int(0.5+math.log2(bmax))\n    startk=0\n    while start<=end:\n        j=(start+end)//2\n        for k in range(startk, n-j):            \n            if HCF(St[k][c], St[k+j-2**c][c])!=1:\n                total=j\n                start=j+1\n                startk=k\n                break\n        if start<=j:\n            end=j-1\n            \n    \n    print(total+1)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optmize(\"O3,unroll-loops\")\nusing namespace std;\nconst long long mod = 1e9 + 7;\ninline long long inv(long long x, long long MOD = mod) {\n  long long power = MOD - 2, ret = 1;\n  while (power) {\n    if (power & 1) (ret *= x) %= MOD;\n    power >>= 1;\n    (x *= x) %= MOD;\n  }\n  return ret;\n}\ninline long long gcd(long long x, long long y) {\n  if (y == 0) return x;\n  return gcd(y, x % y);\n}\nint n;\nlong long arr[200000 + 5];\nlong long sgt[4 * 200000 + 100];\nvoid build(int left, int right, int x) {\n  if (left == right) {\n    sgt[x] = abs(arr[left] - arr[left + 1]);\n    return;\n  }\n  int mid = ((left + right) >> 1);\n  build(left, mid, 2 * x);\n  build(mid + 1, right, 2 * x + 1);\n  sgt[x] = gcd(sgt[2 * x], sgt[2 * x + 1]);\n}\nlong long query(int left, int right, int l, int r, int x) {\n  if (right < l || left > r) {\n    return -1;\n  }\n  if (left >= l && right <= r) {\n    return sgt[x];\n  }\n  int mid = ((left + right) >> 1);\n  long long r1 = query(left, mid, l, r, 2 * x),\n            r2 = query(mid + 1, right, l, r, 2 * x + 1);\n  if (r1 != -1 && r2 != -1) {\n    return gcd(r1, r2);\n  } else if (r1 == -1) {\n    return r2;\n  } else {\n    return r1;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    if (n == 1) {\n      cout << 1 << '\\n';\n    } else {\n      build(0, n - 1, 1);\n      int left = 0, maxx = 1, acc = 1;\n      for (int i = 1; i < n; i++) {\n        long long now = abs(arr[i] - arr[i - 1]);\n        while (left < i && query(0, n - 1, left, i - 1, 1) == 1) {\n          left++;\n        }\n        maxx = max(maxx, i - left + 1);\n      }\n      cout << maxx << '\\n';\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int t=Integer.parseInt(bu.readLine());\n        while(t-->0)\n        {\n            int n=Integer.parseInt(bu.readLine());\n            String s[]=bu.readLine().split(\" \");\n            long a[]=new long[n];\n            int l=1,i,ans=1;\n            for(i=0;i<n;i++) a[i]=Long.parseLong(s[i]);\n\n            st=new long[4*n];\n            for(i=1;i<n;i++)\n            {\n                update(0,n-1,i,Math.abs(a[i]-a[i-1]),0);\n                while(l<i && query(0,n-1,l,i,0)==1) l++;\n                if(query(0,n-1,l,i,0)!=1) ans=Math.max(ans,i-l+2);\n            }\n            sb.append(ans+\"\\n\");\n        }\n        System.out.print(sb);\n    }\n\n    static long st[];\n    static void update(int ss,int se,int i,long v,int n)\n    {\n        if(ss>se) return;\n        if(ss==se)\n        {\n            st[n]=v;\n            return;\n        }\n        int m=ss+(se-ss)/2;\n        if(i<=m) update(ss,m,i,v,2*n+1);\n        else update(m+1,se,i,v,2*n+2);\n        st[n]=gcd(st[2*n+1],st[2*n+2]);\n    }\n\n    static long query(int ss,int se,int qs,int qe,int n)\n    {\n        if(ss>se || ss>qe || se<qs) return 0;\n        if(ss>=qs && qe<=qe) return st[n];\n        int m=ss+(se-ss)/2;\n        return gcd(query(ss,m,qs,qe,2*n+1),query(m+1,se,qs,qe,2*n+2));\n    }\n\n    static long gcd(long a,long b)\n    {\n        long t;\n        while(b!=0)\n        {\n            t=b;\n            b=a%b;\n            a=t;\n        }\n        return a;\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "def gcd(a, b):\n    if a == -1:\n        return b\n    if b == -1:\n        return a\n    while b: a, b = b, a % b\n    return a\nclass SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func\n        self.num = 2**(n-1).bit_length()\n        self.ide_ele = ide_ele\n        self.seg=[self.ide_ele]*2*self.num\n        for i in range(n):\n            self.seg[i+self.num-1]=init_val[i]    \n        for i in range(self.num-2,-1,-1) :\n            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n        \n    def update(self, k, x):\n        k += self.num-1\n        self.seg[k] = x\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n        \n    def query(self, p, q):\n        if q<=p:\n            return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:\n                res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:\n                res = self.segfunc(res,self.seg[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.segfunc(res,self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\n        return res\n\nimport sys;input=sys.stdin.readline\nT, = map(int, input().split())\nfor _ in range(T):\n    N, = map(int, input().split())\n    X = list(map(int, input().split()))\n    Y = [0]*(N-1)\n    for i in range(N-1):\n        Y[i] = abs(X[i+1]-X[i])\n    Y.append(1)\n    ss = SegTree(Y, N, -1, gcd)\n    mx = 1\n    for i in range(N-1):\n        for j in range(i+mx, N+1):\n            if ss.query(i, j) == 1:\n                mx = max(mx, j-i)\n                break\n    print(mx)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.io.FileWriter;\nimport java.io.PrintWriter;\n/*\n    Solution Created: 23:38:00 01/08/2021\n    Custom Competitive programming helper.\n*/\npublic class Main {\n\tstatic int n;\n\tstatic long[] a;\n\tstatic SegmentTree st;\n\tpublic static void solve() {\n\t\tn = in.nextInt();\n\t\ta = in.nl(n);\n\t\tif(n==1) {\n\t\t\tout.println(1);\n\t\t\treturn;\n\t\t}\n\t\tlong[] diff = new long[n-1];\n\t\tfor(int i = 0; i<n-1; i++) diff[i] = Math.abs(a[i+1]-a[i]);\n\t\tst = new SegmentTree(diff);\n\t\tint ans = 1, j = 0;\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tj = Math.max(i, j);\n\t\t\twhile(j+1<n && st.query(i, j)>=2) j++;\n\t\t\tans = Math.max(ans, j-i+1);\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tstatic boolean can(int sz) {\n\t\tfor(int i = 0; i+sz-1<n; i++) if(st.query(i, i+sz-2)>=2) return true;\n\t\treturn false;\n\t}\n\t\n\tstatic class SegmentTree{\n\t\tint dummyValue = 0;\n\t\tpublic long operation(long a, long b){\n\t\t\treturn Util.gcd(a, b);\n\t\t}\n\t\tprivate long[] tree;\n\t\tint n;\n\t\tpublic SegmentTree(long[] diff) {\n\t\t\tthis.n = diff.length;\n\t\t\tthis.tree = new long[4*n];\n\t\t\tbuild(0, 0, n-1, diff);\n\t\t}\n\t\t\n\t\tpublic SegmentTree(int n) {\n\t\t\tthis.n = n;\n\t\t\tthis.tree = new long[4*n];\n\t\t}\n\t\t\n\t\tprivate void build(int idx, int l, int r, long[] a) {\n\t\t\tif(l==r) tree[idx] = a[l];\n\t\t\telse {\n\t\t\t\tint m = (l+r)/2;\n\t\t\t\tbuild(2*idx+1, l, m, a);\n\t\t\t\tbuild(2*idx+2,m+1,r, a);\n\t\t\t\ttree[idx] = operation(tree[2*idx+1], tree[2*idx+2]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void update(int idx, long weight) {\n\t\t\tupdateUtil(0, 0, n-1, idx, weight);\n\t\t}\n\t\t\n\t\tprivate void updateUtil(int idx ,int l, int r, int i, long weight) {\n\t\t\tif(l==r) tree[idx] = weight;\n\t\t\telse {\n\t\t\t\tint md = (l+r)/2;\n\t\t\t\tif(i<=md) updateUtil(2*idx+1, l, md, i, weight);\n\t\t\t\telse updateUtil(2*idx+2, md+1, r, i, weight);\n\t\t\t\ttree[idx] = operation(tree[2*idx+1], tree[2*idx+2]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long query(int l, int r) {\n\t\t\treturn queryUtil(0, l, r, 0, n-1);\n\t\t}\n\t\t\n\t\tprivate long queryUtil(int idx, int lBound, int rBound, int l, int r) {\n\t\t\tif(rBound < l || r < lBound) return dummyValue;\n\t\t\tif(lBound <= l && r<= rBound) return tree[idx];\n\t\t\tint md = (l+r)/2;\n\t\t\treturn operation(queryUtil(2*idx+1, lBound, rBound, l, md), queryUtil(2*idx+2, lBound, rBound, md+1, r));\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tin = new Reader();\n\t\tout = new Writer();\n\t\tint t = in.nextInt();\n\t\twhile(t-->0) solve();\n\t\tout.exit();\n\t}\n\tstatic Reader in; static Writer out;\n\nstatic class Reader {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer st;\n\t\n\tpublic Reader() {\n\t\tthis.br = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\t\n\tpublic Reader(String f){\n\t\ttry {\n\t\t\tthis.br = new BufferedReader(new FileReader(f));\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic double[] nd(int n) {\n\t\tdouble[] a = new double[n];\n\t\tfor (int i = 0; i < n; i++) a[i] = nextDouble();\n\t\treturn a;\n\t}\n\t\n\tpublic long[] nl(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++) a[i] = nextLong();\n\t\treturn a;\n\t}\n\n\tpublic char[] nca() {\n\t\treturn next().toCharArray();\n\t}\n\n\tpublic String[] ns(int n) {\n\t\tString[] a = new String[n];\n\t\tfor (int i = 0; i < n; i++) a[i] = next();\n\t\treturn a;\n\t}\n\n\tpublic int nextInt() {\n\t\tensureNext();\n\t\treturn Integer.parseInt(st.nextToken());\n\t}\n\n\tpublic double nextDouble() {\n\t\tensureNext();\n\t\treturn Double.parseDouble(st.nextToken());\n\t}\n\n\tpublic Long nextLong() {\n\t\tensureNext();\n\t\treturn Long.parseLong(st.nextToken());\n\t}\n\n\tpublic String next() {\n\t\tensureNext();\n\t\treturn st.nextToken();\n\t}\n\t\n\tpublic String nextLine() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tprivate void ensureNext() {\n\t\tif (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic class Util{\n\t\tprivate static Random random = new Random();\n\t\tstatic long[] fact;\n\t\t\n\t\tpublic static void initFactorial(int n, long mod) {\n\t\t\tfact = new long[n+1];\n\t\t\tfact[0] = 1;\n\t\t\tfor (int i = 1; i < n+1; i++) fact[i] = (fact[i - 1] * i) % mod;\n\t\t}\n\t\t\n\t\tpublic static long modInverse(long a, long MOD) {\n\t\t\tlong[] gcdE = gcdExtended(a, MOD);\n\t\t\tif (gcdE[0] != 1) return -1; // Inverted doesn't exist\n\t\t\tlong x = gcdE[1];\n\t\t\treturn (x % MOD + MOD) % MOD;\n\t\t}\n\t\t\n\t\tpublic static long[] gcdExtended(long p, long q) {\n\t\t\tif (q == 0) return new long[] { p, 1, 0 };\n\t\t\tlong[] vals = gcdExtended(q, p % q);\n\t\t\tlong tmp = vals[2];\n\t\t\tvals[2] = vals[1] - (p / q) * vals[2];\n\t\t\tvals[1] = tmp;\n\t\t\treturn vals;\n\t\t}\n\t\t\n\t\tpublic static long nCr(int n, int r, long MOD) {\n\t\t\tif (r == 0) return 1;\n\t\t\treturn (fact[n] * modInverse(fact[r], MOD) % MOD * modInverse(fact[n - r], MOD) % MOD) % MOD;\n\t\t}\n\t\t\n\t\tpublic static long nCr(int n, int r) {\n\t\t\treturn (fact[n]/fact[r])/fact[n-r];\n\t\t}\n\t\t\n\t\tpublic static long nPr(int n, int r, long MOD) {\n\t\t\tif (r == 0) return 1;\n\t\t\treturn (fact[n] * modInverse(fact[n - r], MOD) % MOD) % MOD;\n\t\t}\n\t\tpublic static long nPr(int n, int r) {\n\t\t\treturn fact[n]/fact[n-r];\n\t\t}\n\t\t\n\t\tpublic static boolean isPrime(int n) { \n\t        if (n <= 1) return false; \n\t        if (n <= 3) return true; \n\t        if (n % 2 == 0 || n % 3 == 0) return false; \n\t        for (int i = 5; i * i <= n; i = i + 6) \n\t            if (n % i == 0 || n % (i + 2) == 0) \n\t            return false; \n\t        return true; \n\t    }\n\t\t\n\t    public static boolean[] getSieve(int n) {\n\t        boolean[] isPrime = new boolean[n+1];\n\t        for (int i = 2; i <= n; i++) isPrime[i] = true;\n\t        for (int i = 2; i*i <= n; i++) if (isPrime[i]) \n\t                for (int j = i; i*j <= n; j++) isPrime[i*j] = false;\n\t        return isPrime;\n\t    }\n\t    \n\t    public static int gcd(int a, int b) { \n\t    \tint tmp = 0;\n\t    \twhile(b != 0) {\n\t    \t\ttmp = b;\n\t    \t\tb = a%b;\n\t    \t\ta = tmp;\n\t    \t}\n\t    \treturn a;\n\t    }\n\t    \n\t    public static long gcd(long a, long b) { \n\t    \tlong tmp = 0;\n\t    \twhile(b != 0) {\n\t    \t\ttmp = b;\n\t    \t\tb = a%b;\n\t    \t\ta = tmp;\n\t    \t}\n\t    \treturn a;\n\t    }\n\t    \n\t    public static int random(int min, int max) {\n\t    \treturn random.nextInt(max-min+1)+min;\n\t    }\n\t    \n\t\tpublic static void dbg(Object... o) { \n\t\t\tSystem.out.println(Arrays.deepToString(o)); \n\t\t}\n\t\t\n\t\tpublic static void reverse(int[] s, int l , int r) {\n\t\t\tfor(int i = l; i<=(l+r)/2; i++) {\n\t\t\t\tint tmp = s[i];\n\t\t\t\ts[i] = s[r+l-i];\n\t\t\t\ts[r+l-i] = tmp;\n\t\t\t}\n\t    }\n\t\t\n\t\tpublic static void reverse(int[] s) {\n\t\t\treverse(s, 0, s.length-1);\n\t    }\n\t\t\n\t\tpublic static void reverse(long[] s, int l , int r) {\n\t\t\tfor(int i = l; i<=(l+r)/2; i++) {\n\t\t\t\tlong tmp = s[i];\n\t\t\t\ts[i] = s[r+l-i];\n\t\t\t\ts[r+l-i] = tmp;\n\t\t\t}\n\t    }\n\t\t\n\t\tpublic static void reverse(long[] s) {\n\t\t\treverse(s, 0, s.length-1);\n\t    }\n\t\t\n\t\tpublic static void reverse(float[] s, int l , int r) {\n\t\t\tfor(int i = l; i<=(l+r)/2; i++) {\n\t\t\t\tfloat tmp = s[i];\n\t\t\t\ts[i] = s[r+l-i];\n\t\t\t\ts[r+l-i] = tmp;\n\t\t\t}\n\t    }\n\t\t\n\t\tpublic static void reverse(float[] s) {\n\t\t\treverse(s, 0, s.length-1);\n\t    }\n\t\t\n\t\tpublic static void reverse(double[] s, int l , int r) {\n\t\t\tfor(int i = l; i<=(l+r)/2; i++) {\n\t\t\t\tdouble tmp = s[i];\n\t\t\t\ts[i] = s[r+l-i];\n\t\t\t\ts[r+l-i] = tmp;\n\t\t\t}\n\t    }\n\t\t\n\t\tpublic static void reverse(double[] s) {\n\t\t\treverse(s, 0, s.length-1);\n\t    }\n\t\t\n\t\tpublic static void reverse(char[] s, int l , int r) {\n\t\t\tfor(int i = l; i<=(l+r)/2; i++) {\n\t\t\t\tchar tmp = s[i];\n\t\t\t\ts[i] = s[r+l-i];\n\t\t\t\ts[r+l-i] = tmp;\n\t\t\t}\n\t    }\n\t\t\n\t\tpublic static void reverse(char[] s) {\n\t\t\treverse(s, 0, s.length-1);\n\t    }\n\t\t\n\t\tpublic static <T> void reverse(T[] s, int l , int r) {\n\t\t\tfor(int i = l; i<=(l+r)/2; i++) {\n\t\t\t\tT tmp = s[i];\n\t\t\t\ts[i] = s[r+l-i];\n\t\t\t\ts[r+l-i] = tmp;\n\t\t\t}\n\t    }\n\t\t\n\t\tpublic static <T> void reverse(T[] s) {\n\t\t\treverse(s, 0, s.length-1);\n\t    }\n\t\t\n\t\tpublic static void shuffle(int[] s) {\n\t        for (int i = 0; i < s.length; ++i) {\n\t            int j = random.nextInt(i + 1);\n\t            int t = s[i];\n\t            s[i] = s[j];\n\t            s[j] = t;\n\t        }\n\t    }\n\t\t\n\t    public static void shuffle(long[] s) {\n\t        for (int i = 0; i < s.length; ++i) {\n\t            int j = random.nextInt(i + 1);\n\t            long t = s[i];\n\t            s[i] = s[j];\n\t            s[j] = t;\n\t        }\n\t    }\n\t    \n\t    public static void shuffle(float[] s) {\n\t        for (int i = 0; i < s.length; ++i) {\n\t            int j = random.nextInt(i + 1);\n\t            float t = s[i];\n\t            s[i] = s[j];\n\t            s[j] = t;\n\t        }\n\t    }\n\t    \n\t    public static void shuffle(double[] s) {\n\t        for (int i = 0; i < s.length; ++i) {\n\t            int j = random.nextInt(i + 1);\n\t            double t = s[i];\n\t            s[i] = s[j];\n\t            s[j] = t;\n\t        }\n\t    }\n\t    \n\t    public static void shuffle(char[] s) {\n\t        for (int i = 0; i < s.length; ++i) {\n\t            int j = random.nextInt(i + 1);\n\t            char t = s[i];\n\t            s[i] = s[j];\n\t            s[j] = t;\n\t        }\n\t    }\n\t    \n\t    public static <T> void shuffle(T[] s) {\n\t        for (int i = 0; i < s.length; ++i) {\n\t            int j = random.nextInt(i + 1);\n\t            T t = s[i];\n\t            s[i] = s[j];\n\t            s[j] = t;\n\t        }\n\t    }\n\t    \n\t\tpublic static void sortArray(int[] a) {\n\t        shuffle(a);\n\t        Arrays.sort(a);\n\t    }\n\t\t\n\t\tpublic static void sortArray(long[] a) {\n\t\t\tshuffle(a);\n\t        Arrays.sort(a);\n\t    }\n\t\t\n\t\tpublic static void sortArray(float[] a) {\n\t\t\tshuffle(a);\n\t        Arrays.sort(a);\n\t    }\n\t\t\n\t\tpublic static void sortArray(double[] a) {\n\t\t\tshuffle(a);\n\t        Arrays.sort(a);\n\t    }\n\t\t\n\t\tpublic static void sortArray(char[] a) {\n\t\t\tshuffle(a);\n\t        Arrays.sort(a);\n\t    }\n\t\t\n\t\tpublic static <T extends Comparable<T>> void sortArray(T[] a) {\n\t        Arrays.sort(a);\n\t    }\n\t}\n\nstatic class Writer {\n\tprivate PrintWriter pw;\n\tpublic Writer(){\n\t\tpw = new PrintWriter(System.out);\n\t}\n\t\n\tpublic Writer(String f){\n\t\ttry {\n\t\t\tpw = new PrintWriter(new FileWriter(f));\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic void yesNo(boolean condition) {\n\t\tprintln(condition?\"YES\":\"NO\");\n\t}\n\t\n\tpublic void printArray(int[] a) {\n\t\tfor(int i = 0; i<a.length; i++) print(a[i]+\" \");\n\t}\n\t\n\tpublic void printlnArray(int[] a) {\n\t\tfor(int i = 0; i<a.length; i++) print(a[i]+\" \");\n\t\tpw.println();\n\t}\n\t\n\tpublic void printArray(long[] a) {\n\t\tfor(int i = 0; i<a.length; i++) print(a[i]+\" \");\n\t}\n\t\n\tpublic void printlnArray(long[] a) {\n\t\tfor(int i = 0; i<a.length; i++) print(a[i]+\" \");\n\t\tpw.println();\n\t}\n\t\n\tpublic void print(Object o) {\n\t\tpw.print(o.toString());\n\t}\n\t\n\tpublic void println(Object o) {\n\t\tpw.println(o.toString());\n\t}\n\t\n\tpublic void println() {\n\t\tpw.println();\n\t}\n\t\n\tpublic void flush() {\n\t\tpw.flush();\n\t}\n\tpublic void exit() {\n\t\tpw.close();\n\t}\n}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nconst int maxm = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 998244353;\nconst double eps = 1e-10;\nint dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\nmt19937 rnd(\n    (unsigned int)chrono::steady_clock::now().time_since_epoch().count());\nint n;\nlong long a[maxn], d[maxn];\nlong long gcd(long long a, long long b) {\n  if (!b)\n    return a;\n  else\n    return gcd(b, a % b);\n}\nstruct node {\n  long long gcd;\n} tree[maxn << 2];\nvoid push_up(int rt) {\n  tree[rt].gcd = abs(gcd(tree[rt << 1].gcd, tree[rt << 1 | 1].gcd));\n}\nvoid build(int rt, int l, int r) {\n  if (l == r) {\n    tree[rt].gcd = d[l];\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(rt << 1, l, mid);\n  build(rt << 1 | 1, mid + 1, r);\n  push_up(rt);\n}\nvoid update(int rt, long long c, int l, int r, int pow) {\n  if (l == r) {\n    tree[rt].gcd += c;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (pow <= mid)\n    update(rt << 1, c, l, mid, pow);\n  else\n    update(rt << 1 | 1, c, mid + 1, r, pow);\n  push_up(rt);\n}\nlong long query(int rt, int l, int r, int L, int R) {\n  if (L <= l && r <= R) return tree[rt].gcd;\n  int mid = (l + r) >> 1;\n  long long g = 0;\n  if (L <= mid) g = abs(gcd(g, query(rt << 1, l, mid, L, R)));\n  if (R > mid) g = abs(gcd(g, query(rt << 1 | 1, mid + 1, r, L, R)));\n  return g;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    if (n == 1)\n      cout << 1 << endl;\n    else {\n      for (int i = 2; i <= n; i++) d[i - 1] = abs(a[i] - a[i - 1]);\n      build(1, 1, n - 1);\n      int miao = 0;\n      for (int i = 1; i <= n - 1; i++) {\n        int l = i, r = n - 1;\n        int ans = 0;\n        while (l <= r) {\n          int mid = (l + r) >> 1;\n          if (query(1, 1, n - 1, i, mid) > 1) {\n            l = mid + 1;\n            ans = mid;\n          } else\n            r = mid - 1;\n        }\n        miao = max(miao, ans - i + 2);\n      }\n      cout << miao << endl;\n    }\n  }\n  return ~~(0 - 0);\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.buffer.readline())\ndef MI(): return map(int, sys.stdin.buffer.readline().split())\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef BI(): return sys.stdin.buffer.readline().rstrip()\ndef SI(): return sys.stdin.buffer.readline().rstrip().decode()\ndef li(): return [int(i) for i in input().split()]\ndef lli(rows): return [li() for _ in range(rows)]\ndef si(): return input()\ndef ii(): return int(input())\ndef ins(): return input().split()\n\ndef gcd(a,b):\n    if b==0:\n        return a\n    return gcd(b,a%b)\n    \ndef possible(k):\n    m=0\n    while((1<<m)<=k):\n        m+=1\n    for i in range(n-k):\n        curr=gcd(dp[i][m-1],dp[i+k-(1<<(m-1))][m-1])\n        if curr>1:\n            return True\n    return False\n        \n\nt=II()\nfor _ in range(t):\n    n=II()\n    nums=LI()\n    arr=[abs(nums[i]-nums[i-1]) for i in range(1,n)]\n    log=0\n    while((1<<log)<=n-1):\n        log+=1\n    dp=[[0 for j in range(log)] for i in range(n-1)]\n    for i in range(n-1):\n        dp[i][0]=arr[i]\n    for j in range(1,log):\n        for i in range(n-(1<<j)):\n            dp[i][j]=gcd(dp[i][j-1],dp[i+(1<<(j-1))][j-1])\n    hi,lo=n-1,1\n    while(lo<=hi):\n        mid=(lo+hi)//2\n        if possible(mid):\n            lo=mid+1\n        else:\n            hi=mid-1\n    print(lo)\n    \n    \n        \n        "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; };\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (auto &ai : a) cin >> ai;\n    int ans = 0;\n    int logn = 0;\n    for (; (1 << logn) < n - 1; logn++)\n      ;\n    vector<vector<long long>> f(n, vector<long long>(logn + 1));\n    for (int j = 1; j < n; j++) {\n      f[j][0] = abs(a[j] - a[j - 1]);\n      if (f[j][0] > 1) ans = max(ans, 2);\n    }\n    for (int i = 1; i <= logn; i++) {\n      for (int j = 1; j < n; j++) {\n        int d = 1 << (i - 1), _j = j - d;\n        if (f[j][i - 1] == 1) {\n          f[j][i] = 1;\n          continue;\n        } else if (_j < 1) {\n          f[j][i] = f[j][i - 1];\n        } else {\n          f[j][i] = gcd(f[j][i - 1], f[_j][i - 1]);\n          if (f[j][i] > 1) {\n            ans = max(ans, (j - (1 << i) > 0 ? 1 << i : j) + 1);\n          } else {\n            int l = max(_j - d + 1, 1), r = _j + 1, mid;\n            while (l + 1 < r) {\n              mid = ceil((l + r) / 2.);\n              long long g = gcd(f[j][i - 1], f[mid + d - 1][i - 1]);\n              if (g > 1) {\n                r = mid;\n              } else {\n                l = mid;\n              }\n            }\n            ans = max(ans, (j - r + 1) + 1);\n          }\n        }\n      }\n    }\n    cout << max(ans, 1) << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\nlong long st[20][200005];\nlong long getset(long long a) {\n  long long temp = -1;\n  while (a) {\n    temp++;\n    a /= 2;\n  }\n  return temp;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    long long arr[n];\n    for (long long i = 0; i < n; i++) {\n      cin >> arr[i];\n    }\n    if (n == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    n--;\n    for (long long i = 0; i < n; i++) {\n      st[0][i] = abs(arr[i + 1] - arr[i]);\n    }\n    for (long long i = 1; i < 20; i++) {\n      for (long long j = 0; j < n - (1 << (i - 1)); j++) {\n        st[i][j] = gcd(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n      }\n    }\n    long long ans = 1;\n    for (long long i = 0; i < n; i++) {\n      long long l = 1, r = n - i;\n      while (l <= r) {\n        long long mid = (l + r) / 2;\n        long long x = getset(mid);\n        if (gcd(st[x][i], st[x][i + mid - (1 << x)]) > 1) {\n          ans = max(ans, mid + 1);\n          l = mid + 1;\n        } else {\n          r = mid - 1;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class D {\n\n\tstatic boolean cheak(int mid, SegmentTree sg, int n) {\n\t\tfor (int i = 1; i + mid <= n; i++) {\n\t\t\tlong gcd = sg.query(i, i + mid - 1);\n\t\t\tif (gcd != 1)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\n//\t\tsieve(1000);\n\n\t\tint t = sc.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tlong[] a = new long[n];\n\t\t\tint N = 1;\n\t\t\twhile (N < n - 1)\n\t\t\t\tN <<= 1;\n\t\t\tlong[] in = new long[N + 1];\n\t\t\tArrays.fill(in, 1);\n\t\t\ta[0] = sc.nextLong();\n\t\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\t\ta[i] = sc.nextLong();\n\t\t\t\tin[i] = Math.abs(a[i] - a[i - 1]);\n\t\t\t}\n\t\t\tSegmentTree sg = new SegmentTree(in);\n\n//\t\t\tSystem.out.println(sg.query(1, 2));\n//\t\t\tint s = 1;\n//\t\t\tint e = n-1;\n//\t\t\tint max = 1;\n//\t\t\twhile (s <= e) {\n//\t\t\t\tint mid = s + e >> 1;\n//\t\t\t\tif (cheak(mid, sg, n)) {\n//\t\t\t\t\tmax = mid+1;\n//\t\t\t\t\ts = mid + 1;\n//\t\t\t\t} else {\n//\t\t\t\t\te = mid - 1;\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tint ans = 1;\n\t\t\tint j = 1;\n\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tj = Math.max(j, i);\n\t\t\t\twhile (j < n && sg.query(i, j) > 1)\n\t\t\t\t\tj++;\n\t\t\t\tans = Math.max(ans, j - i + 1);\n\t\t\t}\n\n\t\t\tpw.println(ans);\n\t\t}\n\n\t\tpw.flush();\n\t}\n\n\tstatic class SegmentTree { // 1-based DS, OOP\n\n\t\tint N; // the number of elements in the array as a power of 2 (i.e. after padding)\n\t\tlong[] array, sTree, lazy;\n\n\t\tSegmentTree(long[] in) {\n\t\t\tarray = in;\n\t\t\tN = in.length - 1;\n\t\t\tsTree = new long[N << 1]; // no. of nodes = 2*N - 1, we add one to cross out index zero\n\t\t\tlazy = new long[N << 1];\n\t\t\tbuild(1, 1, N);\n\t\t}\n\n\t\tvoid build(int node, int b, int e) // O(n)\n\t\t{\n\t\t\tif (b == e)\n\t\t\t\tsTree[node] = array[b];\n\t\t\telse {\n\t\t\t\tint mid = b + e >> 1;\n\t\t\t\tbuild(node << 1, b, mid);\n\t\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\t\tsTree[node] = gcd(sTree[node << 1], sTree[node << 1 | 1]);\n\t\t\t}\n\t\t}\n\n\t\tlong query(int i, int j) {\n\t\t\treturn query(1, 1, N, i, j);\n\t\t}\n\n\t\tlong query(int node, int b, int e, int i, int j) // O(log n)\n\t\t{\n\t\t\tif (i > e || j < b)\n\t\t\t\treturn 0;\n\t\t\tif (b >= i && e <= j)\n\t\t\t\treturn sTree[node];\n\t\t\tint mid = b + e >> 1;\n\t\t\tlong q1 = query(node << 1, b, mid, i, j);\n\t\t\tlong q2 = query(node << 1 | 1, mid + 1, e, i, j);\n\t\t\treturn gcd(q1, q2);\n\n\t\t}\n\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic int[][] a;\n\tstatic int n, m;\n\n\tstatic int fill() {\n\t\tint c = 1;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (check(0, i)) {\n\t\t\t\ta[0][i] = 1;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (check(i, m - 1)) {\n\t\t\t\ta[i][m - 1] = 1;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = m - 1; i > -1; i--) {\n\t\t\tif (check(n - 1, i)) {\n\t\t\t\ta[n - 1][i] = 1;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = n - 1; i > -1; i--) {\n\t\t\tif (check(i, 0)) {\n\t\t\t\ta[i][0] = 1;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\treturn c;\n\n\t}\n\n\tstatic boolean check(int i, int j) {\n\t\tboolean f = (a[i][j] != 1);\n\t\tf &= helper(i - 1, j) && helper(i, j - 1) && helper(i + 1, j) && helper(i, j + 1) && helper(i - 1, j - 1)\n\t\t\t\t&& helper(i - 1, j + 1) && helper(i + 1, j - 1) && helper(i + 1, j + 1);\n\n\t\treturn f;\n\t}\n\n\tstatic boolean helper(int i, int j) {\n\t\tif (i < n && i > -1 && j < m && j > -1)\n\t\t\treturn a[i][j] != 1;\n\t\treturn true;\n\t}\n\n\tstatic ArrayList<Integer>[] g;\n\tstatic int[] tour;\n\tstatic int idx;\n\n\tstatic void query(ArrayList<Integer> arr) {\n\t\tSystem.out.print(\"? \" + (arr.size()));\n\t\tfor (int x : arr)\n\t\t\tSystem.out.print(\" \" + x);\n\t\tSystem.out.println();\n\t}\n\n\tstatic ArrayList<Integer> findSet(int s, int e) {\n\t\tTreeSet<Integer> tr = new TreeSet<Integer>();\n\t\tfor (int i = s; i <= e; i++) {\n\t\t\ttr.add(tour[i]);\n\t\t}\n\t\tArrayList<Integer> ret = new ArrayList<Integer>();\n\t\tfor (int x : tr)\n\t\t\tret.add(x);\n\t\treturn ret;\n\t}\n\n\tstatic void go(int u, int p) {\n\t\ttour[idx++] = u + 1;\n\t\tfor (int v : g[u]) {\n\t\t\tif (v == p)\n\t\t\t\tcontinue;\n\t\t\tgo(v, u);\n\t\t}\n\t\ttour[idx++] = u + 1;\n\t}\n\n\tstatic long[] fac;\n\tstatic int mod = 998244353;\n\n\tstatic void fac() {\n\t\tfac[0] = 1;\n\t\tfor (int j = 1; j < fac.length; j++) {\n\t\t\tfac[j] = fac[j - 1] * j;\n\t\t\tfac[j] %= mod;\n\t\t}\n\t}\n\n\tstatic long inverse(long n) {\n\t\treturn modPow(n, mod - 2, mod);\n\t}\n\n\tstatic long nc(int n, int r) {\n\t\treturn ((fac[n] * inverse(fac[r])) % mod) * inverse(fac[n - r]) % mod;\n\t}\n\n\tstatic long modPow(long a, long e, int mod) // O(log e)\n\t{\n\t\ta %= mod;\n\t\tlong res = 1;\n\t\twhile (e > 0) {\n\t\t\tif ((e & 1) == 1)\n\t\t\t\tres = (res * a) % mod;\n\t\t\ta = (a * a) % mod;\n\t\t\te >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MaxN = 200200;\nlong long a[MaxN];\nlong long gcd(long long a, long long b) {\n  if (a % b == 0) return b;\n  return gcd(b, a % b);\n}\nlong long query(long long h, long long l, long long r,\n                vector<vector<long long> > &arr) {\n  if (l == r) {\n    return arr[h][l];\n  }\n  if (l % 2 == 0 && r % 2 == 1) {\n    return query(h + 1, l / 2, r / 2, arr);\n  }\n  if (l % 2 == 1) {\n    return gcd(arr[h][l], query(h, l + 1, r, arr));\n  }\n  if (r % 2 == 0) {\n    return gcd(query(h, l, r - 1, arr), arr[h][r]);\n  }\n}\nbool func(int M, vector<vector<long long> > &arr) {\n  for (int i = 0; i + M - 1 < arr[0].size(); i++) {\n    if (query(0, i, i + M - 1, arr) > 1) {\n      return true;\n    }\n  }\n  return false;\n}\nvoid solve() {\n  long long N;\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> a[i];\n  }\n  vector<vector<long long> > arr(1);\n  for (int i = 0; i < N - 1; i++) {\n    arr[0].push_back(abs(a[i + 1] - a[i]));\n  }\n  int h = 0;\n  while (arr[h].size() > 1) {\n    vector<long long> newrow;\n    for (int i = 0; i < arr[h].size() / 2; i++) {\n      newrow.push_back(gcd(arr[h][2 * i], arr[h][2 * i + 1]));\n    }\n    arr.push_back(newrow);\n    h++;\n  }\n  if (N == 1)\n    cout << 1 << endl;\n  else if (N == 2) {\n    if (abs(arr[0][0]) == 1)\n      cout << 1 << endl;\n    else\n      cout << 2 << endl;\n  } else {\n    int lower = 0;\n    int upper = arr[0].size();\n    while (upper > lower) {\n      int m = (upper + lower + 1) / 2;\n      if (func(m, arr)) {\n        lower = m;\n      } else {\n        upper = m - 1;\n      }\n    }\n    cout << lower + 1 << endl;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 210000;\nconst int M = 1100000;\nconst int mod = 998244353;\nconst int inf = (int)1e9;\nconst double eps = 1e-9;\nconst long long INF = 1e15;\nint n, ans, cur;\nlong long a[N], b[N], g[M], c[N][25];\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nvoid update(int k) { g[k] = gcd(g[k << 1], g[k << 1 | 1]); }\nvoid build(int k, int l, int r) {\n  if (l == r) {\n    g[k] = a[l];\n    return;\n  }\n  int mid = (l + r) / 2;\n  build(k << 1, l, mid);\n  build(k << 1 | 1, mid + 1, r);\n  update(k);\n}\nlong long ask(int k, int l, int r, int a, int b) {\n  if (l == a && r == b) return g[k];\n  int mid = (l + r) / 2;\n  long long res;\n  if (b <= mid)\n    res = ask(k << 1, l, mid, a, b);\n  else if (a > mid)\n    res = ask(k << 1 | 1, mid + 1, r, a, b);\n  else\n    res = gcd(ask(k << 1, l, mid, a, mid),\n              ask(k << 1 | 1, mid + 1, r, mid + 1, b));\n  return res;\n}\nvoid solve() {\n  scanf(\"%d\", &n);\n  ans = 0;\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &b[i]);\n  if (n == 1) {\n    printf(\"1\\n\");\n    return;\n  }\n  for (int i = 1; i < n; i++) a[i] = abs(b[i + 1] - b[i]);\n  n--;\n  build(1, 1, n);\n  for (int i = 1; i <= n; i++)\n    for (int j = 0; j <= 20; j++) c[i][j] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int now = 0; now <= 20; now++) {\n      if (i + (1 << now) > n) break;\n      c[i][now] = ask(1, 1, n, i, i + (1 << now));\n    }\n  }\n  ans = 0;\n  for (int i = 1; i <= n; i++) {\n    long long r = a[i];\n    if (r == 1) continue;\n    int pos = i;\n    for (int now = 20; now >= 0; now--) {\n      if (pos + (1 << now) > n) continue;\n      long long nr = gcd(r, c[pos][now]);\n      if (nr == 1) continue;\n      r = nr;\n      pos += (1 << now);\n    }\n    ans = max(ans, pos - i + 1);\n  }\n  printf(\"%d\\n\", ans + 1);\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.util.StringTokenizer;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.*;\npublic class D {\n\n\n   \n\n    public static void main(String[] args) {\n        FastReader fr = new FastReader();\n        PrintWriter out = new PrintWriter(System.out, true);\n        int cases = fr.nextInt();\n        for(int c = 0; c < cases; c++) {\n            int size = fr.nextInt();\n            long[] nums = new long[size];\n            for(int i = 0; i < size; i++) {\n                nums[i] = fr.nextLong();\n            }\n\n            long[] subs = new long[size-1];\n            for(int i = 0 ;i < size-1; i++) {\n                subs[i] = Math.abs(nums[i] - nums[i+1]);\n            }\n            \n\n            int max = 1;\n\n            \n            int i = 0;\n            int j = 0;\n            if(nums.length > 1) {\n                segtree tree = new segtree(subs);\n                while(j < size-1) {\n                    if(i == j) {\n                        j++;\n                    }\n                    else if(i != j && tree.getgcd(i, j-1) > 1) {\n                        max = Math.max(max, j-i+1);\n                        j++;\n                    } else {\n                        i++;\n                    }\n                }\n                \n\n                if(tree.getgcd(i, j-1) > 1) {\n                    max = Math.max(max, j-i+1);\n                }\n            }   \n            out.write(max + \"\\n\");\n            \n        }\n        out.close();\n    }\n\n    static class segtree {\n        int n;\n        int[] lo, hi;\n        long[] gcds;\n        long[] needed;\n\n        public segtree(long[] needed) {\n            this.n = needed.length;\n            lo = new int[4*n+1]; // low end of range for node i\n            hi = new int[4*n+1]; // high end of range for node i\n            gcds = new long[4*n+1];\n            this.needed = needed;\n            init(1, 0, n-1);\n            // for(int x: gcds) {\n            //     System.out.print(x + \" \");\n            // }\n            // System.out.println(\"\");\n        }\n\n        public long getgcd(int a, int b) {\n            return getgcd(1, a, b);\n        }\n\n        long getgcd(int i, int a, int b) {\n            if(b < lo[i] || hi[i] < a) {\n                return -1;\n            }\n            if(a <= lo[i] && hi[i] <= b) {\n                return gcds[i];\n            }\n\n            long left = getgcd(2*i, a, b);\n            long right = getgcd(2*i+1, a, b);\n            if(left != -1 && right != -1) {\n                return gcd(left, right);\n            }\n            if(left == -1) {\n                return right;\n            }\n            return left;\n        }\n        \n        void init(int i, int l, int r) {\n            lo[i] = l;\n            hi[i] = r;\n\n            if(l == r) {\n                gcds[i] = needed[l];\n                return;\n            }\n\n            int m = (l+r)/2;\n            init(2*i, l, m);\n            init(2*i+1, m+1, r);\n            update(i);\n        }\n\n        void update(int i) {\n            gcds[i] = gcd(gcds[2*i], gcds[2*i+1]);\n        }\n\n    }\n\n    static long gcd(long a, long b) {\n        if(b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n\n    static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            this.br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() { \n            while (st == null || !st.hasMoreElements()) {\n                try{\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n\n        long nextLong() { return Long.parseLong(next()); }\n\n        double nextDouble() { return Double.parseDouble(next()); }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nimport io\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nimport threading\n\n#sys.setrecursionlimit(300000)\n#threading.stack_size(10**8)\n\nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------game starts now-----------------------------------------------------\n#mod = 9223372036854775807  \nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: math.gcd(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nclass SegmentTree1:\n    def __init__(self, data, default=0, func=lambda a, b: a+b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n \n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n \n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n \n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n \n \nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n \n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n#-------------------------------------------------------------------------\nprime = [True for i in range(11)] \nprime[0]=prime[1]=False\n#pp=[0]*10\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c=0\n    while (p <= n): \n          \n        if (prime[p] == True):\n            c+=1\n            for i in range(p, n+1, p): \n                #pp[i]=1\n                prime[i] = False\n        p += 1\n#-----------------------------------DSU--------------------------------------------------\nclass DSU:\n    def __init__(self, R, C):\n        #R * C is the source, and isn't a grid square\n        self.par = range(R*C + 1)\n        self.rnk = [0] * (R*C + 1)\n        self.sz = [1] * (R*C + 1)\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        if self.rnk[xr] < self.rnk[yr]:\n            xr, yr = yr, xr\n        if self.rnk[xr] == self.rnk[yr]:\n            self.rnk[xr] += 1\n\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\n    def top(self):\n        # Size of component at ephemeral \"source\" node at index R*C,\n        # minus 1 to not count the source itself in the size\n        return self.size(len(self.sz) - 1) - 1\n#---------------------------------Lazy Segment Tree--------------------------------------\n# https://github.com/atcoder/ac-library/blob/master/atcoder/lazysegtree.hpp\nclass LazySegTree:\n    def __init__(self, _op, _e, _mapping, _composition, _id, v):\n        def set(p, x):\n            assert 0 <= p < _n\n            p += _size\n            for i in range(_log, 0, -1):\n                _push(p >> i)\n            _d[p] = x\n            for i in range(1, _log + 1):\n                _update(p >> i)\n \n        def get(p):\n            assert 0 <= p < _n\n            p += _size\n            for i in range(_log, 0, -1):\n                _push(p >> i)\n            return _d[p]\n \n        def prod(l, r):\n            assert 0 <= l <= r <= _n\n \n            if l == r:\n                return _e\n \n            l += _size\n            r += _size\n \n            for i in range(_log, 0, -1):\n                if ((l >> i) << i) != l:\n                    _push(l >> i)\n                if ((r >> i) << i) != r:\n                    _push(r >> i)\n \n            sml = _e\n            smr = _e\n            while l < r:\n                if l & 1:\n                    sml = _op(sml, _d[l])\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    smr = _op(_d[r], smr)\n                l >>= 1\n                r >>= 1\n \n            return _op(sml, smr)\n \n        def apply(l, r, f):\n            assert 0 <= l <= r <= _n\n            if l == r:\n                return\n \n            l += _size\n            r += _size\n \n            for i in range(_log, 0, -1):\n                if ((l >> i) << i) != l:\n                    _push(l >> i)\n                if ((r >> i) << i) != r:\n                    _push((r - 1) >> i)\n \n            l2 = l\n            r2 = r\n            while l < r:\n                if l & 1:\n                    _all_apply(l, f)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    _all_apply(r, f)\n                l >>= 1\n                r >>= 1\n            l = l2\n            r = r2\n \n            for i in range(1, _log + 1):\n                if ((l >> i) << i) != l:\n                    _update(l >> i)\n                if ((r >> i) << i) != r:\n                    _update((r - 1) >> i)\n \n        def _update(k):\n            _d[k] = _op(_d[2 * k], _d[2 * k + 1])\n \n        def _all_apply(k, f):\n            _d[k] = _mapping(f, _d[k])\n            if k < _size:\n                _lz[k] = _composition(f, _lz[k])\n \n        def _push(k):\n            _all_apply(2 * k, _lz[k])\n            _all_apply(2 * k + 1, _lz[k])\n            _lz[k] = _id\n \n        _n = len(v)\n        _log = _n.bit_length()\n        _size = 1 << _log\n        _d = [_e] * (2 * _size)\n        _lz = [_id] * _size\n        for i in range(_n):\n            _d[_size + i] = v[i]\n        for i in range(_size - 1, 0, -1):\n            _update(i)\n \n        self.set = set\n        self.get = get\n        self.prod = prod\n        self.apply = apply\n \n \nMIL = 1 << 20\n \n \ndef makeNode(total, count):\n    # Pack a pair into a float\n    return (total * MIL) + count\n \n \ndef getTotal(node):\n    return math.floor(node / MIL)\n \n \ndef getCount(node):\n    return node - getTotal(node) * MIL\n \n \nnodeIdentity = makeNode(0.0, 0.0)\n \n \ndef nodeOp(node1, node2):\n    return node1 + node2\n    # Equivalent to the following:\n    return makeNode(\n        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)\n    )\n \n \nidentityMapping = -1\n \n \ndef mapping(tag, node):\n    if tag == identityMapping:\n        return node\n    # If assigned, new total is the number assigned times count\n    count = getCount(node)\n    return makeNode(tag * count, count)\n \n \ndef composition(mapping1, mapping2):\n    # If assigned multiple times, take first non-identity assignment\n    return mapping1 if mapping1 != identityMapping else mapping2\n#---------------------------------Pollard rho--------------------------------------------\ndef memodict(f):\n    \"\"\"memoization decorator for a function taking a single argument\"\"\"\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n \n    return memodict().__getitem__\n \n \ndef pollard_rho(n):\n    \"\"\"returns a random factor of n\"\"\"\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n \n    s = ((n - 1) & (1 - n)).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = (p * p) % n\n            if p == 1:\n                return math.gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                x, y = i, (i * i + 1) % n\n                f = math.gcd(abs(x - y), n)\n                while f == 1:\n                    x, y = (x * x + 1) % n, (y * y + 1) % n\n                    y = (y * y + 1) % n\n                    f = math.gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n \n \n@memodict\ndef prime_factors(n):\n    \"\"\"returns a Counter of the prime factorization of n\"\"\"\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n \n \ndef distinct_factors(n):\n    \"\"\"returns a list of all distinct factors of n\"\"\"\n    factors = [1]\n    for p, exp in prime_factors(n).items():\n        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]\n    return factors\n \n \ndef all_factors(n):\n    \"\"\"returns a sorted list of all distinct factors of n\"\"\"\n    small, large = [], []\n    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):\n        if not n % i:\n            small.append(i)\n            large.append(n // i)\n    if small[-1] == large[-1]:\n        large.pop()\n    large.reverse()\n    small.extend(large)\n    return small\n\n#---------------------------------Binary Search------------------------------------------\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res = n\n    while (left <= right):\n        mid = (right + left)//2\n        if (arr[mid] > key):\n            res=mid\n            right = mid-1\n        else:\n            left = mid + 1\n    return res\n\ndef binarySearch1(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=-1\n    while (left <= right):\n        mid = (right + left)//2\n        if (arr[mid] > key):\n            right = mid-1\n        else:\n            res=mid\n            left = mid + 1\n    return res\n#---------------------------------running code------------------------------------------\nfor ik in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    diff=[]\n    for i in range(1,n):\n        diff.append(abs(l[i]-l[i-1]))\n    n-=1\n    ans=1\n    s=SegmentTree(diff)\n    j=0\n    for i in range(n):\n        if i>0 and diff[i]==diff[i-1]:\n            continue\n        j=max(j,i+1)\n        w=s.query(i,j-1)\n        if w>1:\n            ans=max(ans, j-i+1)\n        while(j<n):\n            w=int(math.gcd(w,diff[j]))\n            if w>1:\n                ans=max(ans,j-i+2)\n            else:\n                break\n            j+=1\n    print(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    \n    public static void main(String[] args) {\n    \n        var sc = new FastScanner(System.in);\n        var pw = new PrintWriter(System.out);\n        \n        int T = Integer.parseInt(sc.next());\n        for(int t = 0; t < T; t++){\n            int n = Integer.parseInt(sc.next());\n            var a = new long[n];\n            for(int i = 0; i < n; i++){\n                a[i] = Long.parseLong(sc.next());\n            }\n            \n            int l = 0;\n            int r = 0;\n            if(n >= 100000){\n                var rand = new Random();\n                l = rand.nextInt(100) + 1;\n                r = rand.nextInt(100) + 1;\n            }\n            var b = new long[l+n-1+r];\n            for(int i = l; i < l+n-1; i++){\n                b[i] = Math.abs(a[i-l] - a[i+1-l]);\n            }\n            var st = new SegmentTree(b);\n    \n            int ans = 1;\n            for(int i = l; i < l+n-1; i++){\n                ans = Math.max(st.get(i, l+n-1) - i + 1, ans);\n            }\n            pw.println(ans);\n        }\n        pw.flush();\n    }\n    \n    static long gcd(long a, long b){\n        return b == 0 ? a : gcd(b, a%b);\n    }\n    \n    static class SegmentTree {\n        int n;\n        long[] node;\n        \n        long op(long a, long b){\n            return gcd(a, b);\n        }\n        \n        long e = 0;\n        \n        public SegmentTree(int size){\n            n = 1;\n            while(n < size) n <<= 1;\n            node = new long[2*n-1];\n            Arrays.fill(node, e);\n        }\n        public SegmentTree(long[] ar){\n            n = 1;\n            while(n < ar.length) n <<= 1;\n            node = new long[2*n-1];\n            System.arraycopy(ar, 0, node, n-1, ar.length);\n            Arrays.fill(node, n-1+ar.length, 2*n-1, e);\n            for(int i = n-2; i >= 0; i--){\n                node[i] = op(node[i*2+1], node[i*2+2]);\n            }\n        }\n        void set(int index, long newValue){\n            index += n-1;\n            node[index] = newValue;\n            while(index > 0){\n                index = (index-1)/2;\n                node[index] = op(node[index*2+1], node[index*2+2]);\n            }\n        }\n        \n        ArrayList<Integer> list;\n        \n        int get(int left, int size){\n            list = new ArrayList<>();\n            get(left, size, 0, 0, n);\n            long gcd = get(left);\n            for(Integer i : list){\n                long gcd2 = gcd(node[i], gcd);\n                if(gcd2 == 1){\n                    int k = i;\n                    while(k < n-1){\n                        k = k*2+1;\n                        gcd2 = gcd(node[k], gcd);\n                        if(gcd2 >= 2){\n                            gcd = gcd2;\n                            k++;\n                        }\n                    }\n                    return k-n+1;\n                }else{\n                    gcd = gcd2;\n                }\n            }\n            return size;\n        }\n        void get(int a, int b, int k, int l, int r){\n            if(r <= a || b <= l) return;\n            if(a <= l && r <= b){\n                list.add(k);\n                return;\n            }\n            get(a, b, k*2+1, l, (l+r)/2);\n            get(a, b, k*2+2, (l+r)/2, r);\n        }\n        long get(int index){\n            return node[index+n-1];\n        }\n    }\n    \n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n        String next(){\n            while(st == null || !st.hasMoreTokens()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch(IOException e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Akshay Mishra\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        DIntegersHaveFriends solver = new DIntegersHaveFriends();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DIntegersHaveFriends {\n        public static long seg[];\n        public static long arr[];\n\n        public static long gcd(long a, long b) {\n            if (a == 0)\n                return b;\n            return gcd(b % a, a);\n        }\n\n        public static long const_seg(int node, int l, int r) {\n            if (l == r) {\n                return seg[node] = arr[l];\n            } else {\n                int mid = (l + r) / 2;\n                return seg[node] = gcd(const_seg(2 * node, l, mid), const_seg(2 * node + 1, mid + 1, r));\n            }\n        }\n\n        public static long query(int node, int l, int r, int x, int y) {\n            if (x <= l && r <= y) {\n                return seg[node];\n            }\n            else if (r < x || y < l) {\n                return 0l;\n            } else {\n                int mid = (l + r) / 2;\n                return gcd(query(2 * node, l, mid, x, y), query(2 * node + 1, mid + 1, r, x, y));\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int test = in.nextInt();\n            while (test-- > 0) {\n                int n = in.nextInt();\n                long array[] = new long[n];\n                for (int i = 0; i < n; i++) {\n                    array[i] = in.nextLong();\n                }\n                if (n == 1) {\n                    out.println(1);\n                    continue;\n                }\n                long diff[] = new long[n - 1];\n                for (int i = 0; i < n - 1; i++) {\n                    diff[i] = Math.abs(array[i] - array[i + 1]);\n                }\n                arr = diff;\n                seg = new long[4 * n + 1];\n                const_seg(1, 0, n - 2);\n                int ans = 1, inc = 0;\n                for (int i = 0; i + ans - 1 < n - 1; i++) {\n                    for (int j = Math.max(i, inc); j < n - 1; j++, inc++) {\n                        long temp_ans = query(1, 0, n - 2, i, j);\n                        if (temp_ans > 1) {\n                            ans = Math.max(ans, j - i + 2);\n                        }\n                        if (temp_ans <= 1) {\n                            break;\n                        }\n                    }\n                }\n                out.println(ans);\n            }\n        }\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.*;\n\npublic class IntegersHaveFriends {\n\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tFastScanner f = new FastScanner();\n\t\tPrintWriter p = new PrintWriter(System.out);\n\t\tint t = f.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tint n = f.nextInt();\n\t\t\tlong arr[] = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarr[i] = f.nextLong();\n\t\t\tlong diff[] = new long[n - 1];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tdiff[i - 1] = Math.abs(arr[i] - arr[i - 1]);\n\t\t\t}\n\n\t\t\t// 2^18=262144\n\t\t\t// BUILDING SPARSE TABLE\n\t\t\tlong table[][] = new long[18][n - 1];\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\ttable[0][i] = diff[i];\n\t\t\t}\n\t\t\tfor (int i = 1; i < 18; i++) {\n\t\t\t\tfor (int j = 0; j < n - (1 << i); j++) {\n\t\t\t\t\ttable[i][j] = gcd(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 1;\n\t\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\t\tif (table[0][j] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tint curr = j;\n\t\t\t\tlong g = Long.MAX_VALUE;\n\t\t\t\tfor (int i = 17; i >= 0; i--) {\n\t\t\t\t\tif (curr == n - 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (table[i][curr] >= 2 && (g == Long.MAX_VALUE || gcd(g, table[i][curr]) >= 2)) {\n\t\t\t\t\t\tif (g == Long.MAX_VALUE) {\n\t\t\t\t\t\t\tg = table[i][curr];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tg = gcd(g, table[i][curr]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurr += (1 << i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, curr - j + 1);\n\t\t\t}\n\t\t\tp.println(ans);\n\t\t}\n\t\tp.close();\n\n\t}\n\n\t// will work till array size of 65537---fastest sorting time\n//\tstatic long[] radixSort(long[] f) {\n//\t\treturn radixSort(f, f.length);\n//\t}\n//\n//\tstatic long[] radixSort(long[] f, int n) {\n//\t\tlong[] to = new long[n];\n//\t\t{\n//\t\t\tint[] b = new int[65537];\n//\t\t\tfor (int i = 0; i < n; i++)\n//\t\t\t\tb[1 + (int) (f[i] & 0xffff)]++;\n//\t\t\tfor (int i = 1; i <= 65536; i++)\n//\t\t\t\tb[i] += b[i - 1];\n//\t\t\tfor (int i = 0; i < n; i++)\n//\t\t\t\tto[b[(int) (f[i] & 0xffff)]++] = f[i];\n//\t\t\tlong[] d = f;\n//\t\t\tf = to;\n//\t\t\tto = d;\n//\t\t}\n//\t\t{\n//\t\t\tint[] b = new int[65537];\n//\t\t\tfor (int i = 0; i < n; i++)\n//\t\t\t\tb[1 + (int) (f[i] >>> 16 & 0xffff)]++;\n//\t\t\tfor (int i = 1; i <= 65536; i++)\n//\t\t\t\tb[i] += b[i - 1];\n//\t\t\tfor (int i = 0; i < n; i++)\n//\t\t\t\tto[b[(int) (f[i] >>> 16 & 0xffff)]++] = f[i];\n//\t\t\tlong[] d = f;\n//\t\t\tf = to;\n//\t\t\tto = d;\n//\t\t}\n//\t\t{\n//\t\t\tint[] b = new int[65537];\n//\t\t\tfor (int i = 0; i < n; i++)\n//\t\t\t\tb[1 + (int) (f[i] >>> 32 & 0xffff)]++;\n//\t\t\tfor (int i = 1; i <= 65536; i++)\n//\t\t\t\tb[i] += b[i - 1];\n//\t\t\tfor (int i = 0; i < n; i++)\n//\t\t\t\tto[b[(int) (f[i] >>> 32 & 0xffff)]++] = f[i];\n//\t\t\tlong[] d = f;\n//\t\t\tf = to;\n//\t\t\tto = d;\n//\t\t}\n//\t\t{\n//\t\t\tint[] b = new int[65537];\n//\t\t\tfor (int i = 0; i < n; i++)\n//\t\t\t\tb[1 + (int) (f[i] >>> 48 & 0xffff)]++;\n//\t\t\tfor (int i = 1; i <= 65536; i++)\n//\t\t\t\tb[i] += b[i - 1];\n//\t\t\tfor (int i = 0; i < n; i++)\n//\t\t\t\tto[b[(int) (f[i] >>> 48 & 0xffff)]++] = f[i];\n//\t\t\tlong[] d = f;\n//\t\t\tf = to;\n//\t\t\tto = d;\n//\t\t}\n//\t\treturn f;\n//\t}\n\n\t// Function to sort an array using quick sort algorithm.\n\tstatic void quickSort(long arr[], int low, int high) {\n\t\tif (low < high) {\n\t\t\tint p = partition(arr, low, high);\n\t\t\tquickSort(arr, low, p - 1);\n\t\t\tquickSort(arr, p + 1, high);\n\t\t}\n\t}\n\n\tstatic int partition(long arr[], int low, int high) {\n\t\tlong pivot = arr[high];\n\t\tint i = low - 1;\n\t\tfor (int j = low; j < high; j++) {\n\t\t\tif (arr[j] < pivot) {\n\t\t\t\ti++;\n\t\t\t\tlong temp = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t}\n\t\t}\n\t\tlong temp = arr[i + 1];\n\t\tarr[i + 1] = arr[high];\n\t\tarr[high] = temp;\n\n\t\treturn i + 1;\n\t}\n\n\t/// Ceils\n\tstatic long ceil(long x, long m) {\n\t\tlong res = x / m;\n\t\tif (x % m != 0) {\n\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n\n\t// ------------------------------------------------------------------------------------------------\n\t// makes the prefix sum array\n\tstatic long[] prefixSum(long arr[], int n) {\n\t\tlong psum[] = new long[n];\n\t\tpsum[0] = arr[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tpsum[i] = psum[i - 1] + arr[i];\n\t\t}\n\t\treturn psum;\n\t}\n\t// ------------------------------------------------------------------------------------------------\n\n\t// makes the suffix sum array\n\tstatic long[] suffixSum(long arr[], int n) {\n\t\tlong ssum[] = new long[n];\n\t\tssum[n - 1] = arr[n - 1];\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tssum[i] = ssum[i + 1] + arr[i];\n\t\t}\n\t\treturn ssum;\n\t}\n\n//------------------------------------------------------------------------------------------\n\t// BINARY EXPONENTIATION OF A NUMBER MODULO M FASTER METHOD WITHOUT RECURSIVE\n\t// OVERHEADS\n\tstatic long m = (long) (1e9 + 7);\n\n\tstatic long binPower(long a, long n, long m) {\n\t\tif (n == 0)\n\t\t\treturn 1;\n\t\tlong res = 1;\n\t\twhile (n > 0) {\n\t\t\tif ((n & 1) != 0) {\n\t\t\t\tres *= a;\n\t\t\t}\n\t\t\ta *= a;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n//-------------------------------------------------------------------------------------------\n\n\t// gcd\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\n//------------------------------------------------------------------------------------------\n\n\t// lcm\n\tstatic long lcm(long a, long b) {\n\t\treturn a / gcd(a, b) * b;\n\t}\n\n//------------------------------------------------------------------------------------------\n\t// BRIAN KERNINGHAM TO CHECK NUMBER OF SET BITS\n\t// O(LOGn)\n\tstatic int setBits(int n) {\n\t\tint count = 0;\n\t\twhile (n > 0) {\n\t\t\tn = n & (n - 1);\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n//------------------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------------------\n\t// 0 based indexing\n\tstatic boolean KthBitSet(int n, int k) {\n\t\tint mask = 1;\n\t\tmask = mask <<= k;\n\t\tif ((mask & n) != 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n//------------------------------------------------------------------------------------------\n\n\t// EXTENDED EUCLIDEAN THEOREM\n\t// TO REPRESENT GCD IN TERMS OF A AND B\n\t// gcd(a,b) = a.x + b.y where x and y are integers\n\n\tstatic long x = -1;\n\tstatic long y = -1;\n\n\tstatic long gcdxy(long a, long b) {\n\t\tif (b == 0) {\n\t\t\tx = 1;\n\t\t\ty = 0;\n\t\t\treturn a;\n\t\t} else {\n\t\t\tlong d = gcdxy(b, a % b);\n\t\t\tlong x1 = y;\n\t\t\tlong y1 = x - (a / b) * y;\n\t\t\tx = x1;\n\t\t\ty = y1;\n\n\t\t\treturn d;\n\t\t}\n\t}\n\n//-------------------------------------------------------------------------------------------------F\n}\n"
        },
        {
            "language": 3,
            "solution": "#from itertools import product, permutations, combinations, accumulate, compress\n#from collections import Counter, defaultdict, deque # deque([iterable[, maxlen]]) #appendleft popleft rotate\n#from heapq import heapify, heappop, heappush # func(heapifiedlist, item)\n#from bisect import bisect_left, bisect_right, insort # func(sortedlist, item)\n# TODO: more coping mechanisms...?\n#from sys import setrecursionlimit\n\nimport os, sys\ninput = lambda: sys.stdin.buffer.readline().rstrip(b'\\r\\n')\n\ndef dbp(*args, **kwargs): # calling with dbp(locals()) is perfectly cromulent\n\tprint(*args, file=sys.stderr, **kwargs)\n\na_str = lambda: input().decode('ascii')\nget_int_list = lambda: [int(x) for x in input().split()]\njoin_str = lambda l, ch=' ': ch.join((str(x) for x in l))  # ch is a default, not kwarg\n\nfrom math import gcd\n\nclass segtree():\n\tdef __init__(self, opf, alist):\n\t\tself.merge = opf\n\t\tif opf == gcd:\n\t\t\tself.default = 0\n\t\telse:\n\t\t\traise Exception('woopth')\n\t\tself.n = len(alist) # no kth ele, non power of 2 ok\n\t\tself.st = [0] * (2*self.n)\n\t\tself.st[self.n:] = alist\n\t\tfor i in range(self.n-1, 0, -1):\n\t\t\tself.st[i] = self.merge(self.st[i<<1], self.st[i<<1|1])\n\n\t# uhhh, static...  so just query...\n\tdef query(self, l, r):\n\t\tl += self.n\n\t\tr += self.n\n\t\tans = self.default\n\t\twhile l < r:\n\t\t\tif l&1:\n\t\t\t\tans = self.merge(ans, self.st[l])\n\t\t\t\tl += 1\n\t\t\tif r&1:\n\t\t\t\tr -= 1\n\t\t\t\tans = self.merge(ans, self.st[r])\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\treturn ans\n\ndef do_thing():\n\tn = int(input())\n\talist = get_int_list()\n\t#dbp('case:', alist)\n\n\tif n == 1:\n\t\treturn 1\n\n\tdifflist = [abs(alist[i]-alist[i-1]) for i in range(1, n)] + [1]\n\t#dbp('difflist:', difflist)\n\tgcdst = segtree(gcd, difflist)\n\n\tans = 1\n\tfor l in range(n-1):\n\t\tr = l+ans\n\t\tif r >=n:\n\t\t\tbreak\n\t\tg = gcdst.query(l, r)\n\t\t#dbp('queried:', difflist[l:r], 'got:', g)\n\t\tif g == 1:\n\t\t\tcontinue\n\n\t\twhile r < n and g > 1:\n\t\t\t#dbp('checking:', g, difflist[r])\n\t\t\tg = gcd(g, difflist[r])\n\t\t\tr += 1\n\n\t\tans = max(ans, r-l)\n\t\t\t\n\treturn ans\n\ndef multicase():\n\tmaxcc = int(input().strip())\n\tfor cc in range(maxcc):\n\t\tprint(do_thing())\n\nif __name__ == \"__main__\":\n\tmulticase()\n\t#print(do_thing())"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\ninput = sys.stdin.readline\nINF = 10**20\ndef gcd(a, b):\n    if a == INF:\n        return b\n    if b == INF:\n        return a\n    return math.gcd(a, b)\nclass LazySegmentTree:\n    def __init__(self, data, default=0, func=min):\n        \"\"\"initialize the lazy segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        self._lazy = [0] * (2 * _size)\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __len__(self):\n        return self._len\n\n    def _push(self, idx):\n        \"\"\"push query on idx to its children\"\"\"\n        # Let the children know of the queries\n        q, self._lazy[idx] = self._lazy[idx], 0\n\n        self._lazy[2 * idx] += q\n        self._lazy[2 * idx + 1] += q\n        self.data[2 * idx] += q\n        self.data[2 * idx + 1] += q\n\n    def _update(self, idx):\n        \"\"\"updates the node idx to know of all queries applied to it via its ancestors\"\"\"\n        for i in reversed(range(1, idx.bit_length())):\n            self._push(idx >> i)\n\n    def _build(self, idx):\n        \"\"\"make the changes to idx be known to its ancestors\"\"\"\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]\n            idx >>= 1\n\n    def add(self, start, stop, value):\n        \"\"\"lazily add value to [start, stop)\"\"\"\n        start = start_copy = start + self._size\n        stop = stop_copy = stop + self._size\n        while start < stop:\n            if start & 1:\n                self._lazy[start] += value\n                self.data[start] += value\n                start += 1\n            if stop & 1:\n                stop -= 1\n                self._lazy[stop] += value\n                self.data[stop] += value\n            start >>= 1\n            stop >>= 1\n\n        # Tell all nodes above of the updated area of the updates\n        self._build(start_copy)\n        self._build(stop_copy - 1)\n\n    def query(self, start, stop, default=1e9):\n        \"\"\"func of data[start, stop)\"\"\"\n        start += self._size\n        stop += self._size\n\n        # Apply all the lazily stored queries\n        self._update(start)\n        self._update(stop - 1)\n\n        res = default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"LazySegmentTree({0})\".format(self.data)\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = list(map(int, input().split()))\n    s = [abs(s[i]-s[i+1]) for i in range(n-1)] + [1]\n    N = len(s)\n    T = LazySegmentTree(s, func=gcd)\n    ans = 1\n    for l in range(n - 1):\n        r = l + ans\n        if r >= n:\n            break\n        g = T.query(l, r, default=INF)\n        # dbp('queried:', difflist[l:r], 'got:', g)\n        if g == 1:\n            continue\n\n        while r < n and g > 1:\n            # dbp('checking:', g, difflist[r])\n            g = gcd(g, s[r])\n            r += 1\n\n        ans = max(ans, r - l)\n    print(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.*;\nimport java.io.*;\n\n// Java Template Pramod Hosahalli...\n@SuppressWarnings(\"unused\")\npublic class Solution {\n\n\tstatic FastReader in = new FastReader();\n\t//static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tstatic int mod = 1000000007;\n\n\tprivate static void go() throws Exception{\n\t\tint n = in.ni();\n\t\tlong[] a = new long[n];\n\t\tlong[] b = new long[n-1];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = in.nl();\n\t\t\tif(i > 0) b[i-1] = Math.abs(a[i] - a[i-1]);\n\t\t}\n\t\t\n\t\tif(n == 1){\n\t\t\tprint(1, \"1\");\n\t\t\treturn;\n\t\t}\n\n\t\tlong[][] f = SparseTable.precompute(b);\n\t\tint maxima = 1;\t\t\n\t\tfor(int j = 0; j < b.length; j++){\n\t\t\tif(f[0][j] == 1)continue;\n\t\t\tlong g = -1;\n\t\t\tint curr = j;\n\t\t\tfor(int p = f.length-1; p >= 0; p--){\n\t\t\t\tif(curr == b.length)break;\n\t\t\t\tif(f[p][curr] > 1 && (g == -1 || gcd(g, f[p][curr]) > 1)){\n\t\t\t\t\tif(g == -1) g = f[p][curr];\n\t\t\t\t\telse g = gcd(g, f[p][curr]);\n\t\t\t\t\tcurr = curr + (1 << p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxima = Math.max(maxima, curr - j + 1);\n\t\t}\n\t\tprint(1, maxima+\"\");\n    }\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint t = in.ni();\n        //int t = pi(in.readLine());\n\t\tfor(int _i = 1; _i <= t; _i++){\n\t\t\tgo();\n\t\t}\n\t\tin.close();\n\t}\n\n\tstatic long mul(long a, long b) {\n\t\treturn ((a % mod) * (b % mod)) % mod;\n\t}\n\n\tstatic class FastReader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic FastReader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic FastReader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[64]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n') {\n\t\t\t\t\tif (cnt != 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int ni() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ') {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nl() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nd() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\t}\n\n\tstatic String rl() throws Exception{\n\t\treturn in.readLine();\n\t}\n\n\tstatic int pi(String s) {\n\t\treturn Integer.parseInt(s);\n\t}\n\n\tstatic long pl(String s) {\n\t\treturn Long.parseLong(s);\n\t}\n\n\tstatic void print(int newline, String s) {\n\t\tSystem.out.print(s);\n\t\tif (newline != 0)\n\t\t\tSystem.out.println();\n\t\t// System.out.flush();\n\t}\n\n\tstatic void cprint(int x) {\n\t\tprint(0, \"Case #\" + x + \": \");\n\t}\n\n\t//utility function for gcd\n\tprivate static long gcd(long a, long b)\n\t{\n\t\tif(a == 0 || b == 0)return a + b;\n\t\tif(a > b)return gcd(a % b, b);\n\t\treturn gcd(a, b % a);\n\t}\n\n\n\tstatic class SparseTable {\n\n\t\tstatic long[][] precompute(long[] arr){\n\t\t\tint n = arr.length;\n\t\t\tint p  = (int)((double)Math.log(n) / Math.log(2));\n\t\t\tlong[][] f = new long[p+1][n];\n\t\t\tfor(int i = 0; i < n; i++) f[0][i] = arr[i];\n\t\t\tfor(int j = 1; j <= p; j++){\n\t\t\t\tfor(int i = 0; i + (1 << j) - 1 < n; i++){\n\t\t\t\t\tf[j][i] = gcd(f[j-1][i], f[j-1][i + (1 << (j-1))]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn f;\n\t\t}\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.function.BinaryOperator;\n\npublic class D{\n    static class InputReader {\n        private static final int DEFAULT_BUFFER_SIZE = 1 << 16; // Change this to increase your input size //\n        private static final InputStream DEFAULT_STREAM = System.in;private static final int MAX_DECIMAL_PRECISION = 21;private int c;private byte[] buf;\n        private int bufferSize, bufIndex, numBytesRead;private InputStream stream;private static final byte EOF = -1;private static final byte NEW_LINE = 10;\n        private static final byte CARRIAGE_RETURN = 13;private static final byte SPACE = 32;private static final byte DASH = 45;private static final byte DOT = 46;\n        private char[] charBuffer;private static byte[] bytes = new byte[58];private static int[] ints = new int[58];private static char[] chars = new char[128];\n        static { char ch = ' ';int value = 0;byte _byte = 0;for (int i = 48; i < 58; i++) bytes[i] = _byte++;for (int i = 48; i < 58; i++) ints[i] = value++;for (int i = 32; i < 128; i++) chars[i] = ch++; }\n        public InputReader() { this(DEFAULT_STREAM, DEFAULT_BUFFER_SIZE); }public InputReader(int bufferSize) { this(DEFAULT_STREAM, bufferSize); }public InputReader(InputStream stream) { this(stream, DEFAULT_BUFFER_SIZE); }\n        public InputReader(InputStream stream, int bufferSize) { if (stream == null || bufferSize <= 0) throw new IllegalArgumentException();buf = new byte[bufferSize];charBuffer = new char[128];this.bufferSize = bufferSize;this.stream = stream; }\n        private byte read() throws IOException { if (numBytesRead == EOF) throw new IOException();if (bufIndex >= numBytesRead) { bufIndex = 0;numBytesRead = stream.read(buf);if (numBytesRead == EOF) return EOF; }return buf[bufIndex++]; }\n        private int readJunk(int token) throws IOException { if (numBytesRead == EOF) return EOF;do { while (bufIndex < numBytesRead) { if (buf[bufIndex] > token) return 0;bufIndex++; }numBytesRead = stream.read(buf);if (numBytesRead == EOF) return EOF;bufIndex = 0; } while (true); }\n        public byte nextByte() throws IOException {return (byte) ni(); }\n        public int ni() throws IOException { if (readJunk(DASH - 1) == EOF) throw new IOException();int sgn = 1, res = 0;c = buf[bufIndex];if (c == DASH) { sgn = -1;bufIndex++; } do { while (bufIndex < numBytesRead)\n        { if (buf[bufIndex] > SPACE) { res = (res << 3) + (res << 1);res += ints[buf[bufIndex++]]; } else { bufIndex++;return res * sgn; } }numBytesRead = stream.read(buf);if (numBytesRead == EOF) return res * sgn;bufIndex = 0; } while (true); }\n        public long nl() throws IOException { if (readJunk(DASH - 1) == EOF) throw new IOException();int sgn = 1;long res = 0L;c = buf[bufIndex];if (c == DASH) { sgn = -1;bufIndex++; } do { while (bufIndex < numBytesRead)\n        { if (buf[bufIndex] > SPACE) { res = (res << 3) + (res << 1);res += ints[buf[bufIndex++]]; } else { bufIndex++;return res * sgn; } }numBytesRead = stream.read(buf);if (numBytesRead == EOF) return res * sgn;bufIndex = 0; } while (true); }\n        private void doubleCharBufferSize() { char[] newBuffer = new char[charBuffer.length << 1];for (int i = 0; i < charBuffer.length; i++) newBuffer[i] = charBuffer[i];charBuffer = newBuffer; }\n        public String nli() throws IOException { try { c = read(); } catch (IOException e) { return null; }if (c == NEW_LINE) return \"\";\n            if (c == EOF) return null;int i = 0;charBuffer[i++] = (char) c;do { while (bufIndex < numBytesRead) { if (buf[bufIndex] != NEW_LINE && buf[bufIndex] != CARRIAGE_RETURN)\n            { if (i == charBuffer.length) doubleCharBufferSize();charBuffer[i++] = (char) buf[bufIndex++]; } else { if(buf[bufIndex] == CARRIAGE_RETURN) bufIndex++;bufIndex++;\n                return new String(charBuffer, 0, i); } }numBytesRead = stream.read(buf);if (numBytesRead == EOF) return new String(charBuffer, 0, i);bufIndex = 0; } while (true); }\n        public String ns() throws IOException { if (numBytesRead == EOF) return null;if (readJunk(SPACE) == EOF) return null;for (int i = 0; ; )\n        { while (bufIndex < numBytesRead) { if (buf[bufIndex] > SPACE) { if (i == charBuffer.length) doubleCharBufferSize();charBuffer[i++] = (char) buf[bufIndex++]; }\n        else {bufIndex++;return new String(charBuffer, 0, i); } }numBytesRead = stream.read(buf);if (numBytesRead == EOF) return new String(charBuffer, 0, i);bufIndex = 0; } }\n        public double nd() throws IOException { String doubleVal = ns();if (doubleVal == null) throw new IOException();return Double.valueOf(doubleVal); }\n        public void close() throws IOException {stream.close(); }\n    }\n\n    // region variables\n    static InputReader sc = new InputReader();\n    static OutputStream outputStream = System.out;\n    static PrintWriter w = new PrintWriter(outputStream);\n    // endregion\n\n    private static void initiateIO()\n            throws IOException {if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n        try { w = new PrintWriter(\"output.txt\");\n            sc = new InputReader(new FileInputStream(\"input.txt\"));\n        } catch (Exception e) { throw new IOException(); }} }\n\n    public static void main(String[] args)\n            throws IOException {\n\n        initiateIO();\n//\n\n        int t = sc.ni();\n        while(t-- > 0)\n            solve();\n\n        w.close();\n\n    }\n\n    static void solve() throws IOException {\n        long n = sc.nl();\n        long[] arr = new long[(int)n];\n\n        for(int i = 0; i < n; i++) {\n            arr[i] = sc.nl();\n        }\n        \n        if(n == 1) {\n            w.println(1);\n            return;\n        }\n\n\n        long[] diff = new long[(int)n-1];\n\n        for(int i = 0; i < n-1; i++) {\n            diff[i] = Math.abs(arr[i] - arr[i+1]);\n        }\n\n        SparseTable st = new SparseTable(diff, SparseTable.Operation.GCD);\n\n        int l = 0;\n        int r = 0;\n        long ans = 0;\n\n        for(int i = 0; i < diff.length; i++) {\n            l = i; r = diff.length-1;\n            while (l <= r) {\n                int mid = (l+r)/2;\n                long q = st.query(i, mid);\n                if(q > 1) {\n                    ans = Math.max(ans, mid-i+1);\n                    l = mid+1;\n                } else {\n                    r = mid-1;\n                }\n            }\n        }\n\n        w.println((ans+1));\n\n    }\n\n     /**\n          * Sparse table only supports immutable structures\n          * <p>Specify the operation using \"Operation\" public enum in the constructor</p>\n          * Enter the range on which you want to perform query [l, r] both inclusive\n          * <p>min, max and gcd queries are constant</p>\n          * sum query is logarithmic\n          * <p> query index is used to find the index of the min/max values</p>\n          */\n         // region SparseTable\n         static class SparseTable {\n\n             // The number of elements in the original input array.\n             private int n;\n\n             // The maximum power of 2 needed. This value is floor(log2(n))\n             private int P;\n\n             // Fast log base 2 logarithm lookup table for i, 1 <= i <= n\n             private int[] log2;\n\n             // The sparse table values.\n             private long[][] dp;\n\n             // Index Table (IT) associated with the values in the sparse table.\n             private int[][] it;\n\n             // The various supported query operations on this sparse table.\n             public enum Operation {\n                 MIN,\n                 MAX,\n                 SUM,\n                 MULT,\n                 GCD\n             }\n\n             ;\n\n             private Operation op;\n\n             // All functions must be associative, e.g: a * (b * c) = (a * b) * c for some operation '*'\n             private BinaryOperator<Long> sumFn = (a, b) -> a + b;\n             private BinaryOperator<Long> minFn = (a, b) -> Math.min(a, b);\n             private BinaryOperator<Long> maxFn = (a, b) -> Math.max(a, b);\n             private BinaryOperator<Long> multFn = (a, b) -> a * b;\n             private BinaryOperator<Long> gcdFn =\n                     (a, b) -> {\n                         long gcd = a;\n                         while (b != 0) {\n                             gcd = b;\n                             b = a % b;\n                             a = gcd;\n                         }\n                         return Math.abs(gcd);\n                     };\n\n             public SparseTable(long[] values, Operation op) {\n                 // TODO(william): Lazily call init in query methods instead of initializing in constructor?\n                 this.op = op;\n                 init(values);\n             }\n\n             private void init(long[] v) {\n                 n = v.length;\n\n                 // Tip: to get the floor of the logarithm base 2 in Java you can also do:\n                 // Integer.numberOfTrailingZeros(Integer.highestOneBit(n)).\n                 P = (int) (Math.log(n) / Math.log(2));\n                 dp = new long[P + 1][n];\n                 it = new int[P + 1][n];\n\n                 for (int i = 0; i < n; i++) {\n                     dp[0][i] = v[i];\n                     it[0][i] = i;\n                 }\n\n                 log2 = new int[n + 1];\n                 for (int i = 2; i <= n; i++) {\n                     log2[i] = log2[i / 2] + 1;\n                 }\n\n                 // Build sparse table combining the values of the previous intervals.\n                 for (int i = 1; i <= P; i++) {\n                     for (int j = 0; j + (1 << i) <= n; j++) {\n                         long leftInterval = dp[i - 1][j];\n                         long rightInterval = dp[i - 1][j + (1 << (i - 1))];  // [j+(1<<(i-1))] = j + 2^(i-1) // Watch in insertion slides for more info\n                         if (op == Operation.MIN) {\n                             dp[i][j] = minFn.apply(leftInterval, rightInterval);\n                             // Propagate the index of the best value\n                             if (leftInterval <= rightInterval) {\n                                 it[i][j] = it[i - 1][j];\n                             } else {\n                                 it[i][j] = it[i - 1][j + (1 << (i - 1))];\n                             }\n                         } else if (op == Operation.MAX) {\n                             dp[i][j] = maxFn.apply(leftInterval, rightInterval);\n                             // Propagate the index of the best value\n                             if (leftInterval >= rightInterval) {\n                                 it[i][j] = it[i - 1][j];\n                             } else {\n                                 it[i][j] = it[i - 1][j + (1 << (i - 1))];\n                             }\n                         } else if (op == Operation.SUM) {\n                             dp[i][j] = sumFn.apply(leftInterval, rightInterval);\n                         } else if (op == Operation.MULT) {\n                             dp[i][j] = multFn.apply(leftInterval, rightInterval);\n                         } else if (op == Operation.GCD) {\n                             dp[i][j] = gcdFn.apply(leftInterval, rightInterval);\n                         }\n                     }\n                 }\n                 // Uncomment for debugging\n                 // printTable();\n             }\n\n             // For debugging, testing and slides.\n             private void printTable() {\n                 for (long[] r : dp) {\n                     for (int i = 0; i < r.length; i++) {\n                         System.out.printf(\"%02d, \", r[i]);\n                     }\n                     System.out.println();\n                 }\n             }\n\n             // Queries [l, r] for the operation set on this sparse table.\n             public long query(int l, int r) {\n                 // Fast queries types, O(1)\n                 if (op == Operation.MIN) {\n                     return query(l, r, minFn);\n                 } else if (op == Operation.MAX) {\n                     return query(l, r, maxFn);\n                 } else if (op == Operation.GCD) {\n                     return query(l, r, gcdFn);\n                 }\n\n                 // Slower query types, O(log2(n))\n                 if (op == Operation.SUM) {\n                     return sumQuery(l, r);\n                 } else {\n                     return multQuery(l, r);\n                 }\n             }\n\n             public int queryIndex(int l, int r) {\n                 if (op == Operation.MIN) {\n                     return minQueryIndex(l, r);\n                 } else if (op == Operation.MAX) {\n                     return maxQueryIndex(l, r);\n                 }\n                 throw new UnsupportedOperationException(\n                         \"Operation type: \" + op + \" doesn't support index queries :/\");\n             }\n\n             private int minQueryIndex(int l, int r) {\n                 int len = r - l + 1;\n                 int p = log2[len];\n                 long leftInterval = dp[p][l];\n                 long rightInterval = dp[p][r - (1 << p) + 1];\n                 if (leftInterval <= rightInterval) {\n                     return it[p][l];\n                 } else {\n                     return it[p][r - (1 << p) + 1];\n                 }\n             }\n\n             private int maxQueryIndex(int l, int r) {\n                 int len = r - l + 1;\n                 int p = log2[len];\n                 long leftInterval = dp[p][l];\n                 long rightInterval = dp[p][r - (1 << p) + 1];\n                 if (leftInterval >= rightInterval) {\n                     return it[p][l];\n                 } else {\n                     return it[p][r - (1 << p) + 1];\n                 }\n             }\n\n             // Do sum query [l, r] in O(log2(n)).\n             //\n             // Perform a cascading query which shrinks the left endpoint while summing over all the intervals\n             // which are powers of 2 between [l, r].\n             //\n             // WARNING: This method can easily produces values that overflow.\n             //\n             // NOTE: You can achieve a faster time complexity and use less memory with a simple prefix sum\n             // array. This method is here more as a proof of concept than for its usefulness.\n             private long sumQuery(int l, int r) {\n                 long sum = 0;\n                 for (int p = log2[r - l + 1]; l <= r; p = log2[r - l + 1]) {\n                     sum += dp[p][l];\n                     l += (1 << p);\n                 }\n                 return sum;\n             }\n\n             private long multQuery(int l, int r) {\n                 long result = 1;\n                 for (int p = log2[r - l + 1]; l <= r; p = log2[r - l + 1]) {\n                     result *= dp[p][l];\n                     l += (1 << p);\n                 }\n                 return result;\n             }\n\n             // Do either a min, max or gcd query on the interval [l, r] in O(1).\n             //\n             // We can get O(1) query by finding the smallest power of 2 that fits within the interval length\n             // which we'll call k. Then we can query the intervals [l, l+k] and [r-k+1, r] (which likely\n             // overlap) and apply the function again. Some functions (like min and max) don't care about\n             // overlapping intervals so this trick works, but for a function like sum this would return the\n             // wrong result since it is not an idempotent binary function.\n             private long query(int l, int r, BinaryOperator<Long> fn) {\n                 int len = r - l + 1;\n                 int p = log2[len];\n                 return fn.apply(dp[p][l], dp[p][r - (1 << p) + 1]);\n             }\n         }\n         // endregion\n}"
        },
        {
            "language": 3,
            "solution": "import sys,os,io\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom math import gcd\n\nclass RangeQuery:\n    def __init__(self, data, func=gcd):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n\nfor _ in range (int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    d = [abs(a[i] - a[i-1]) for i in range (1,n)]\n    rq = RangeQuery(d)\n    ans = 1\n    l = 0\n    r = 0\n    while(r<n-1):\n        if rq.query(l, r+1)==1:\n            l+=1\n            r = max(l,r)\n        else:\n            ans = max(ans, r-l+2)\n            r+=1\n    print(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\ninline void read(long long &x) {\n  long long s = 0;\n  x = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') x = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9')\n    s = (s << 3) + (s << 1) + ch - '0', ch = getchar();\n  x *= s;\n}\nconst long long N = 6e5 + 5, M = 25;\nlong long w[N], d[N];\nlong long n, logn[N << 2];\nlong long st[N][M];\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nvoid init() {\n  for (long long i = 2; i <= n; i++) logn[i] = logn[i / 2] + 1;\n  for (long long j = 0; j < M; j++)\n    for (long long i = 2; i + (1 << j) - 1 <= n; i++)\n      if (!j)\n        st[i][j] = d[i];\n      else\n        st[i][j] = gcd(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);\n}\nlong long query(long long l, long long r) {\n  long long len = r - l + 1;\n  long long k = logn[len];\n  return gcd(st[l][k], st[r - (1 << k) + 1][k]);\n}\nsigned main() {\n  long long T;\n  cin >> T;\n  while (T--) {\n    read(n);\n    for (long long i = (1); i <= (n); i++) read(w[i]);\n    for (long long i = (2); i <= (n); i++) d[i] = w[i] - w[i - 1];\n    init();\n    long long res = 1;\n    for (long long i = (2); i <= (n); i++) {\n      long long l = i, r = n;\n      while (l < r) {\n        long long mid = l + r + 1 >> 1;\n        if (abs(query(i, mid)) != 1)\n          l = mid;\n        else\n          r = mid - 1;\n      }\n      if (abs(query(i, i)) == 1)\n        continue;\n      else\n        res = max(res, l - i + 1 + 1);\n    }\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict, Counter,deque\nfrom math import sqrt, log10, log, floor, factorial,gcd\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations,combinations\nimport sys, io, os\ninput = sys.stdin.readline\n# input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n# sys.setrecursionlimit(10000)\ninf = float('inf')\nmod = 10 ** 9 + 7\ndef get_list(): return [int(i) for i in input().split()]\ndef yn(a): print(\"YES\" if a else \"NO\")\nceil = lambda a, b: (a + b - 1) // b\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass RangeQuery:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n\n    def __getitem__(self, idx):\n        return self._data[0][idx]\ndef fun(diff,k):\n    n=len(diff)\n    for i in range(n-k+1):\n        gcda=s.query(i,i+k)\n        # print(i,i+k,gcda)\n        if gcda>1:\n            return 0\n    return 1\ndef discrete_binary_search(func, lo, hi):\n    \"\"\" Locate the first value x s.t. func(x) = True within [lo, hi] \"\"\"\n    while lo < hi:\n        mi = lo + (hi - lo) // 2\n        # print(mi)\n        if func(diff,mi):\n            hi = mi\n        else:\n            lo = mi + 1\n\n    return lo\nt=int(input())\nfor i in range(t):\n    n=int(input())\n    l=[int(i) for i in input().split()]\n    if n==1:\n        print(1)\n        continue\n    diff=[abs(l[i]-l[i-1]) for i in range(1,n)]\n    s=RangeQuery(diff,gcd)\n    maxa=0\n    low=1\n    high=n\n    ans=discrete_binary_search(fun,low,high)\n    print(ans)\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.List;\n import java.util.*;\n public class realfast implements Runnable \n  {\n    private static final int INF = (int) 1e9;\n    long in= 1000000007;\n    long fac[]= new long[1000001];\n    long inv[]=new long[1000001];\n    public  void solve() throws IOException \n    {\n        \n     \n          \n\n       //   out.println(cnt);\n\n        int t = readInt();\n\n        for(int f =0;f<t;f++)\n        {\n             int n = readInt();\n             long arr[]=new long[n+1];\n             for(int i=1;i<=n;i++)\n                arr[i]= readLong();\n            if(n==1)\n                out.println(1);\n             else\n             {\n              int max=1;\n              for(int i=1;i<n;i++)\n              {\n                arr[i]= Math.abs(arr[i]-arr[i+1]);\n              }\n              long seg[]=new long[4*n+4];\n              build(seg,arr,1,n-1,0);\n              int start=1;\n              for(int i=1;i<=n-1;i++)\n              {\n                if(arr[i]==1)\n                    continue;\n                start= Math.max(i,start);\n                long kl = gc(seg,1,n-1,0,i,start);\n                \n                while(start<n&&kl>1)\n                {\n                   kl = gcd(kl,arr[start]);\n                   if(kl!=1)\n                   start++;\n                }\n              \n                max=Math.max(max,start-i+1);\n              }\n              \n              out.println(max);\n            }\n\n        }\n          \n      \n\n    }\n\n    public long gc(long seg[], int left , int right ,int index , int l , int r)\n    {\n        if(left>r||l>right)\n            return 0;\n\n        if(left>=l&&right<=r)\n            return seg[index];\n\n        int mid = left+(right-left)/2;\n\n        long val = gc(seg,left,mid,2*index+1,l,r);\n        long val1 = gc(seg,mid+1,right,2*index+2,l,r);\n\n        return gcd(val,val1);\n\n    }\n\n    public void build(long seg[] , long arr[] , int left , int right,int index)\n    {\n        if(left==right)\n        {\n            seg[index]= arr[left];\n            return;\n        }\n\n        int mid = left+(right-left)/2;\n\n        build(seg,arr,left,mid,2*index+1);\n        build(seg,arr,mid+1,right,2*index+2);\n\n        seg[index]= gcd(seg[2*index+1],seg[2*index+2]);\n        \n    }\n   \n   \n    public long gcd(long a , long b )\n    {\n\n      if(a<b)\n      {\n        long t =a;\n        a=b;\n        b=t;\n      }\n      if(b==0)\n        return a;\n      if(a%b==0)\n        return b ;\n      return gcd(b,a%b);\n    }\n    public long pow(long n , long p,long m)\n    {\n         if(p==0)\n            return 1;\n        long val = pow(n,p/2,m);;\n        val= (val*val)%m;\n        if(p%2==0)\n            return val;\n        else\n            return (val*n)%m;\n    }\n    \n    \n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    public static void main(String[] args) {\n        new Thread(null, new realfast(), \"\", 128 * (1L << 20)).start();\n    }\n \n    private static final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private PrintWriter out;\n \n    @Override\n    public void run() {\n        try {\n            if (ONLINE_JUDGE || !new File(\"input.txt\").exists()) {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                reader = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            solve();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // nothing\n            }\n            out.close();\n        }\n    }\n \n    private String readString() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n \n    @SuppressWarnings(\"unused\")\n    private int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n \n    @SuppressWarnings(\"unused\")\n    private long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n \n    @SuppressWarnings(\"unused\")\n    private double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n}\nclass edge implements Comparable<edge>{\n    int u ;\n    int v;\n    \n    edge(int  u, int v)\n    {\n       this.u=u;\n       this.v=v;\n    }\n    public int compareTo(edge e)\n    {\n        return this.v-e.v;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Practice {\n\tpublic static long mod = (long) Math.pow(10, 9) + 7;\n\tpublic static long mod2 = 998244353;\n\tpublic static int tt = 1;\n\tpublic static ArrayList<Integer> prime;\n\tpublic static long[] fac = new long[200005];\n\tpublic static long[] invfac = new long[200005];\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint t = Integer.parseInt(br.readLine());\n\t\twhile (t-- > 0) {\n\t\t\tString[] s1 = br.readLine().split(\" \");\n\t\t\tint n = Integer.parseInt(s1[0]);\n\t\t\tlong[] arr = new long[n];\n\t\t\tString str = (br.readLine());\n\t\t\tString[] s2 = str.split(\" \");\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Long.parseLong(s2[i]);\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\tpw.println(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint ans = 1;\n\t\t\tlong[] gcd = new long[n - 1];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tgcd[i - 1] = Math.abs(arr[i] - arr[i - 1]);\n\t\t\t}\n\t\t\tlong curr = 0;\n\t\t\tint w = 0;\n\t\t\tlong[] tree = new long[4 * n];\n\n\t\t\tmakeTree(0, gcd, n, tree, 0, n - 2);\n\t\t\tint p = 0;\n\t\t\tfor (int i = 0; i < n - 1;) {\n\t\t\t\tcurr = getGCD(curr, gcd[i]);\n\t\t\t\tif (gcd[i] == 1) {\n\t\t\t\t\tans = Math.max(i - w + 1, ans);\n\t\t\t\t\ti++;\n\t\t\t\t\tw = i;\n\t\t\t\t\tcurr = 0;\n\t\t\t\t}\n\t\t\t\t// System.out.println(curr);\n\t\t\t\telse if (curr > 1) {\n\t\t\t\t\ti++;\n\n\t\t\t\t} else {\n\t\t\t\t\tans = Math.max(i - w + 1, ans);\n\t\t\t\t\tw++;\n\t\t\t\t\tcurr = getAns(0, w, i, tree, 0, n - 2);\n\t\t\t\t}\n\t\t\t\t// System.out.println(ans + \" \" + i + \" \" + curr + \" \" + w);\n\n\t\t\t}\n\t\t\t// System.out.println(w);\n\t\t\tans = Math.max(n - w, ans);\n\t\t\tpw.println(ans);\n\t\t}\n\t\tpw.close();\n\n\t}\n\n\tprivate static long getAns(int curr, int l1, int r1, long[] tree, int l, int r) {\n\t\t// TODO Auto-generated method stub\n\t\tif (l > r) {\n\t\t\treturn 0l;\n\t\t}\n\t\t// if()\n\t\tif (l1 > r || r1 < l) {\n\t\t\treturn 0l;\n\t\t}\n\t\tif (l1 <= l && r1 >= r) {\n\t\t\treturn tree[curr];\n\t\t}\n\t\tint mid = (l + r) / 2;\n\n\t\tlong ans = getAns(2 * curr + 1, l1, r1, tree, l, mid);\n\t\tans = getGCD(getAns(2 * curr + 2, l1, r1, tree, mid + 1, r), ans);\n\t\treturn ans;\n\t}\n\n\tprivate static void makeTree(int curr, long[] gcd, int n, long[] tree, int l, int r) {\n\t\t// TODO Auto-generated method stub\n\t\tif (l == r) {\n\t\t\ttree[curr] = gcd[l];\n\t\t\treturn;\n\t\t}\n\t\tif (l > r) {\n\t\t\treturn;\n\t\t}\n\t\tint mid = (l + r) / 2;\n\t\tmakeTree(2 * curr + 1, gcd, n, tree, l, mid);\n\t\tmakeTree(2 * curr + 2, gcd, n, tree, mid + 1, r);\n\t\ttree[curr] = getGCD(tree[2 * curr + 1], tree[2 * curr + 2]);\n\t\treturn;\n\t}\n\n\tprivate static long getGCD(long l, long m) {\n\n\t\tlong t1 = Math.min(l, m);\n\t\tlong t2 = Math.max(l, m);\n\t\tif (t1 == 0) {\n\t\t\treturn t2;\n\t\t}\n\t\twhile (true) {\n\t\t\tlong temp = t2 % t1;\n\t\t\tif (temp == 0) {\n\t\t\t\treturn t1;\n\t\t\t}\n\t\t\tt2 = t1;\n\t\t\tt1 = temp;\n\t\t}\n\t}\n\n\t// private static int kmp(String str) {\n//\t\t// TODO Auto-generated method stub\n//\t\t// System.out.println(str);\n//\t\tint[] pi = new int[str.length()];\n//\t\tpi[0] = 0;\n//\t\tfor (int i = 1; i < str.length(); i++) {\n//\t\t\tint j = pi[i - 1];\n//\t\t\twhile (j > 0 && str.charAt(i) != str.charAt(j)) {\n//\t\t\t\tj = pi[j - 1];\n//\t\t\t}\n//\t\t\tif (str.charAt(j) == str.charAt(i)) {\n//\t\t\t\tj++;\n//\t\t\t}\n//\t\t\tpi[i] = j;\n//\t\t\tSystem.out.print(pi[i]);\n//\t\t}\n//\t\tSystem.out.println();\n//\t\treturn pi[str.length() - 1];\n//\t}\n\n}\n\n//\tprivate static void getFac(long n, PrintWriter pw) {\n//\t\t// TODO Auto-generated method stub\n//\t\tint a = 0;\n//\t\twhile (n % 2 == 0) {\n//\t\t\ta++;\n//\t\t\tn = n / 2;\n//\t\t}\n//\t\tif (n == 1) {\n//\t\t\ta--;\n//\t\t}\n//\t\tfor (int i = 3; i <= Math.sqrt(n); i += 2) {\n//\t\t\twhile (n % i == 0) {\n//\t\t\t\tn = n / i;\n//\t\t\t\ta++;\n//\t\t\t}\n//\t\t}\n//\t\tif (n > 1) {\n//\t\t\ta++;\n//\t\t}\n//\t\tif (a % 2 == 0) {\n//\t\t\tpw.println(\"Bob\");\n//\t\t} else {\n//\t\t\tpw.println(\"Alice\");\n//\t\t}\n//\t\t//System.out.println(a);\n//\t\treturn;\n//\t}\n\n//\tprivate static long power(long a, long p) {\n//\t\t// TODO Auto-generated method stub\n//\t\tlong res = 1;\n//\t\twhile (p > 0) {\n//\t\t\tif (p % 2 == 1) {\n//\t\t\t\tres = (res * a) % mod;\n//\t\t\t}\n//\t\t\tp = p / 2;\n//\t\t\ta = (a * a) % mod;\n//\t\t}\n//\t\treturn res;\n//\t}\n//\n//\tprivate static void fac() {\n//\t\tfac[0] = 1;\n//\t\t// TODO Auto-generated method stub\n//\t\tfor (int i = 1; i < fac.length; i++) {\n//\t\t\tif (i == 1) {\n//\t\t\t\tfac[i] = 1;\n//\t\t\t} else {\n//\t\t\t\tfac[i] = i * fac[i - 1];\n//\t\t\t}\n//\t\t\tif (fac[i] > mod) {\n//\t\t\t\tfac[i] = fac[i] % mod;\n//\t\t\t}\n//\t\t}\n//\t}\n//\n//\tprivate static int getLower(Long long1, Long[] st) {\n//\t\t// TODO Auto-generated method stub\n//\t\tint left = 0, right = st.length - 1;\n//\t\tint ans = -1;\n//\t\twhile (left <= right) {\n//\t\t\tint mid = (left + right) / 2;\n//\t\t\tif (st[mid] <= long1) {\n//\t\t\t\tans = mid;\n//\t\t\t\tleft = mid + 1;\n//\t\t\t} else {\n//\t\t\t\tright = mid - 1;\n//\t\t\t}\n//\t\t}\n//\t\treturn ans;\n//\t}\n\n//\tprivate static long getGCD(long l, long m) {\n//\n//\t\tlong t1 = Math.min(l, m);\n//\t\tlong t2 = Math.max(l, m);\n//\t\twhile (true) {\n//\t\t\tlong temp = t2 % t1;\n//\t\t\tif (temp == 0) {\n//\t\t\t\treturn t1;\n//\t\t\t}\n//\t\t\tt2 = t1;\n//\t\t\tt1 = temp;\n//\t\t}\n//\t}"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        if x==1:\n            return 1\n        while y>1:\n            x, y=y, x%y\n        if y==1:\n            return 1\n        else:        \n            return x\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2                                    \n\n #   total=bmax\n #   c=int(0.5+math.log2(bmax))\n #   k=0\n #   while k+total<n:\n #       if St[k][c]!=1:\n #           start=total+1\n #           end=min(n-k-1, bmax*2-1)\n #           while start<=end:\n #               j=(start+end)//2\n #               if HCF(St[k][c], St[k+j-2**c][c])!=1:\n #                   total=j\n #                   start=j+1\n #               else:\n #                   end=j-1    \n #       k+=1\n\n    def possible_group(x, y):\n        c=b[x]\n        for i in range(x+1, y):\n            c=HCF(c, b[i])\n            if c==1:\n                return False\n        return True        \n\n    total=bmax\n    start=bmax+1\n    end=min(n-1, bmax*2-1)\n    c=int(0.5+math.log2(bmax))\n    startk=0\n    while start<=end:\n        j=(start+end)//2\n        for k in range(startk, n-j):            \n            if HCF(St[k][c], St[k+j-2**c][c])!=1:\n                total=j\n                start=j+1\n                startk=k\n                break\n        if start<=j:\n            end=j-1\n            \n    \n    print(total+1)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\n\npublic class MainD {\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public boolean hasNext() {\n            try {\n                String string = reader.readLine();\n                if (string == null) {\n                    return false;\n                }\n                tokenizer = new StringTokenizer(string);\n                return tokenizer.hasMoreTokens();\n            } catch (IOException e) {\n                return false;\n            }\n        }\n    }\n    static InputReader in = new InputReader(System.in);\n    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] args) {\n        int t = in.nextInt();\n        while (t -- > 0) {\n            solve();\n        }\n        out.close();\n    }\n    static void solve() {\n        int n = in.nextInt();\n        long[] a = new long[n];\n        long[] diff = new long[n-1];\n        for (int i = 0; i < n; i ++) {\n            a[i] = in.nextLong();\n        }\n        if (n == 1) {\n            out.println(n);\n            return;\n        }\n        for (int i = 0; i < n-1; i++) {\n            diff[i] = abs(a[i+1] - a[i]);\n        }\n        long answer;\n        int temp;\n        long preGcd;\n        long[][] table = new long[18][n-1];\n        for (int i = 0; i < n-1; i++) {\n            table[0][i] = diff[i];\n        }\n        for (int i = 1; i < 18; i++) {\n            for (int j = 0; j < n-(1<<i); j++) {\n                table[i][j] = gcd(table[i-1][j], table[i-1][j+(1<<(i-1))]);\n            }\n        }\n        answer = 1;\n        for (int i = 0; i < n-1; i ++) {\n            if (table[0][i] == 1) continue;\n            temp = i;\n            preGcd = -1;\n            for (int j = 17; j >= 0; j--) {\n                if (temp == n-1) break;\n                if (table[j][temp] >= 2 && (preGcd == -1 || gcd(preGcd, table[j][temp]) >= 2)) {\n                    if (preGcd == -1)\n                        preGcd = table[j][temp];\n                    else\n                        preGcd = gcd(preGcd, table[j][temp]);\n                    temp += (1 << j);\n                }\n            }\n            answer = max(answer, temp - i + 1);\n        }\n//        for (int i = 0; i < n-1; i++) {\n//            if (diff[i] == 1) {\n//                answer = max(temp, answer);\n//                temp = 1;\n//                preGcd = -1;\n//            } else {\n//                if (preGcd == -1) {\n//                    preGcd = diff[i];\n//                    temp ++;\n//                } else {\n//                    preGcd = gcd(preGcd, diff[i]);\n//                    if (preGcd == 1) {\n//                        preGcd = -1;\n//                        answer = max(answer, temp);\n//                        temp = 1;\n//                        i --;\n//                    } else {\n//                        temp ++;\n//                    }\n//                }\n//            }\n//            answer = max(answer, temp);\n//        }\n        out.println(answer);\n    }\n    static long gcd (long a, long b) {\n        long temp;\n        while (true) {\n            temp = a % b;\n            if (temp == 0) return b;\n            a = b;\n            b = temp;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int MOD = 1000000007;\nlong long int modpow(long long int a, long long int b, long long int mod) {\n  long long int res = 1;\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a;\n    res %= mod;\n    a = a * a;\n    a %= mod;\n  }\n  return res;\n}\nlong long int p(long long int a, long long int b) {\n  long long int res = 1;\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a;\n    a = a * a;\n  }\n  return res;\n}\nlong long int gcd(long long int a, long long int b) {\n  return b ? gcd(b, a % b) : a;\n}\nstruct SegTree {\n  vector<long long int> tree;\n  long long int n = 0;\n  long long int def = 0;\n  long long int f(long long int a, long long int b) { return gcd(a, b); }\n  void init(vector<long long int>& a) {\n    n = a.size();\n    tree.clear();\n    tree.resize(2 * n - 1);\n    for (long long int i = (long long int)0; i < (long long int)n; ++i) {\n      tree[n - 1 + i] = a[i];\n    }\n    for (long long int i = (long long int)n - 2; i >= (long long int)0; --i) {\n      tree[i] = f(tree[2 * i + 1], tree[2 * i + 2]);\n    }\n  }\n  long long int query(long long int a, long long int b, long long int l,\n                      long long int r, long long int node) {\n    if (a >= l && b <= r)\n      return tree[node];\n    else if (a > r || b < l || a > b) {\n      return def;\n    } else {\n      return f(query(a, (a + b) / 2, l, r, 2 * node + 1),\n               query((a + b) / 2 + 1, b, l, r, 2 * node + 2));\n    }\n  }\n};\nvoid testcases(long long int test) {\n  long long int n;\n  cin >> n;\n  vector<long long int> a(n);\n  for (long long int i = (long long int)0; i < (long long int)n; ++i)\n    cin >> a[i];\n  vector<long long int> b(n - 1);\n  for (long long int i = (long long int)1; i < (long long int)n; ++i)\n    b[i - 1] = abs(a[i] - a[i - 1]);\n  long long int N = 1;\n  while (N < b.size()) {\n    N <<= 1;\n  }\n  for (long long int i = (long long int)b.size(); i < (long long int)N; ++i)\n    b.push_back(0);\n  SegTree seg;\n  seg.init(b);\n  long long int l = 0, r = 0;\n  long long int cur = b[0];\n  long long int ans = 1;\n  while (l < n - 1) {\n    while (r < n - 1 && cur > 1) {\n      r++;\n      if (r < n) cur = seg.query(0, N - 1, l, r, 0);\n    }\n    ans = ((ans > r - l + 1) ? ans : r - l + 1);\n    l++;\n    if (r < l) r++;\n    cur = seg.query(0, N - 1, l, r, 0);\n  }\n  cout << ans << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t;\n  cin >> t;\n  for (long long int i = (long long int)0; i < (long long int)t; ++i)\n    testcases(i);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Stream;\n\n/**\n * @author madi.sagimbekov\n */\npublic class C1549D {\n\n    private static BufferedReader in;\n    private static BufferedWriter out;\n\n    private static List<Integer>[] list;\n    private static int[] arr;\n    private static int[][] dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    private static boolean[] used;\n\n    public static void solve() throws IOException {\n        int n = readInt();\n        long[] a = readLongs();\n\n\n        long M = 0;\n        for (int i = 0; i < n; i++) {\n            M = Math.max(M, a[i]);\n        }\n\n        int length = (int) (Math.log10(M) + 1);\n\n        long[][] gcd = new long[6 * length][n];\n\n        for (int i = 0; i < n - 1; i++) {\n            gcd[0][i] = Math.abs(a[i] - a[i+1]);\n        }\n\n        int last = gcd.length - 1;\n        for (int i = 1; i < gcd.length; i++) {\n            boolean found = false;\n            for (int j = 0; j < n - 1; j++) {\n                if (gcd[i-1][j] > 1 && gcd[i-1][j+1] > 1) {\n                    gcd[i][j] = gcd(gcd[i-1][j], gcd[i-1][j+1]);\n                    found = true;\n                }\n            }\n            if (!found) {\n                last = i - 1;\n                break;\n            }\n        }\n\n        int max = 0;\n        int cnt = 0;\n        long temp = 0;\n        for (int j = 0; j < n; j++) {\n            if (gcd[last][j] > 1) {\n                if (temp == 0 || temp != gcd[last][j]) {\n                    cnt = 0;\n                    temp = gcd[last][j];\n                }\n                cnt++;\n                if (cnt > max) {\n                    max = cnt;\n                }\n            } else {\n                temp = 0;\n                cnt = 0;\n            }\n        }\n\n        out.write((max + last + 1)+ \"\\n\");\n    }\n\n    private static long gcd(long a, long b) {\n        if (a < b) {\n            return gcd(b, a);\n        }\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static void main(String[] args) throws IOException {\n        open();\n\n        int t = readInt();\n        while (t-- > 0) {\n            solve();\n        }\n\n        close();\n    }\n\n    private static int[] readInts() throws IOException {\n        return Stream.of(in.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n\n    private static int readInt() throws IOException {\n        return Integer.parseInt(in.readLine());\n    }\n\n    private static long[] readLongs() throws IOException {\n        return Stream.of(in.readLine().split(\" \")).mapToLong(Long::parseLong).toArray();\n    }\n\n    private static long readLong() throws IOException {\n        return Long.parseLong(in.readLine());\n    }\n\n    private static double[] readDoubles() throws IOException {\n        return Stream.of(in.readLine().split(\" \")).mapToDouble(Double::parseDouble).toArray();\n    }\n\n    private static double readDouble() throws IOException {\n        return Double.parseDouble(in.readLine());\n    }\n\n    private static String readString() throws IOException {\n        return in.readLine();\n    }\n\n    private static List<Integer>[] buildAdjacencyList(int n, int m) throws IOException {\n        List<Integer>[] list = new ArrayList[n + 1];\n        for (int i = 0; i <= n; i++) {\n            list[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < m; i++) {\n            int[] e = readInts();\n            list[e[0]].add(e[1]);\n            list[e[1]].add(e[0]);\n        }\n\n        return list;\n    }\n\n    private static void open() {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new BufferedWriter(new OutputStreamWriter((System.out)));\n    }\n\n    private static void close() throws IOException {\n        out.flush();\n        out.close();\n        in.close();\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import javax.swing.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class A {\n    static ArrayList<Integer> [] adj;\n    static ArrayList<Integer> temp;\n    static int mod = (int) 1e9+7;\n    static boolean[] vis = new boolean[(int)1e5];\n    static List<Long> l = new ArrayList<>();\n    static int p=0,x=0;\n    static class SparseTable{\n\n        int pow[],log[],type;\n        long[][]table;\n        SparseTable(long[] a,int type) throws IOException//type=-1 for min, 1 for max\n        {\n            log = new int[a.length+1];computeLog(a.length); this.type=type;\n            pow = new int[log[a.length]+1];computePow(log[a.length]);\n            table = new long[log[a.length]+1][a.length];build(a);\n        }\n        void computeLog(int n){log[1]=0;for(int i=2;i<=n;i++)log[i]=log[i>>1]+1;}//log2 or divide ny 2\n        void computePow(int lim){pow[0]=1;for(int i=1;i<=lim;i++)pow[i]=pow[i-1]<<1;}//2^i\n        long func(long a,long b) throws IOException {return gcd(a,b);}\n        void build(long[] a) throws IOException {\n            for(int i=0;i<a.length;i++)table[0][i]=a[i];\n            for(int i=1;i<=log[a.length];i++){\n                for(int j=0;j+pow[i]<=a.length;j++)\n                    table[i][j]=func(table[i-1][j],table[i-1][j+pow[i-1]]);\n            }\n        }\n        long query(int l,int r) throws IOException {\n            int k=log[r-l+1];\n            return func(table[k][l],table[k][r-pow[k]+1]);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastScanner s=new FastScanner();\n        int t = s.nextInt();\n//        int t = 1;\n        StringBuilder se = new StringBuilder(\"\");\n        while(t-->0) {\n            int n = s.nextInt();\n            long[] a = new long[n];\n            long[] d = new long[n-1];\n            for(int i=0;i<n;i++){\n                a[i] = s.nextLong();\n            }\n            if(n==1){\n                se.append(1+\"\\n\");\n                continue;\n            }\n            long ans=0;\n            for(int i=1;i<n;i++){\n                d[i-1] = Math.abs(a[i]-a[i-1]);\n            }\n            SparseTable ST = new SparseTable(d,-1);\n            for(int i=0;i<d.length;i++){\n                int l=i,r=d.length-1;\n                while(l<=r){\n                    int mid=(l+r)/2;\n                    long g = ST.query(i,mid);\n                    if(g>1){\n                        ans=Math.max(ans,mid-i+1);\n                        l=mid+1;\n                    }\n                    else r=mid-1;\n                }\n            }\n            se.append((ans+1)+\"\\n\");\n        }\n        System.out.println(se);\n    }\n\n    //Important\n    //Dont't stick on same approach\n    //Check long\n\n    static int lower_bound(int[] arr, int x) {\n        int low_limit = 0, high_limit = arr.length, mid = -1;\n        while (low_limit < high_limit) {\n            mid = (low_limit + high_limit) / 2;\n            if (arr[mid] >= x) {\n                high_limit = mid;\n            } else  {\n                low_limit = mid + 1;\n            }\n        }\n        return low_limit + 1;\n    }\n\n\n    static void dfs(int i){\n        vis[i]=true;\n        temp.add(i);\n        List<Integer> Y = adj[i];\n        for(int x:Y){\n            if(!vis[x])dfs(x);\n        }\n    }\n\n    static long gcd(long a, long b) throws IOException {\n        return (b == 0) ? a : gcd(b, a % b);\n    }\n\n    static int gcd(int a, int b) throws IOException {\n        return (b == 0) ? a : gcd(b, a % b);\n    }\n\n    static void sortr(int[] a) {\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a)\n            l.add(i);\n        Collections.sort(l, Collections.reverseOrder());\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n\n    static void sort(int[] a) {\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n\n    static void sort(long[] a) {\n        ArrayList<Long> l = new ArrayList<>();\n        for (long i : a)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long r() {\n  long long s = 0, k = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') k = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    s = s * 10 + c - '0';\n    c = getchar();\n  }\n  return s * k;\n}\nlong long n, m, a[4000001], tr[4000001], b[1000001], ans;\nlong long gcd(long long aa, long long bb) {\n  if (!bb) return aa;\n  return gcd(bb, aa % bb);\n}\nvoid build(long long l, long long r, long long bh) {\n  if (l == r) {\n    tr[bh] = a[l];\n    return;\n  }\n  long long mid = (l + r) / 2;\n  build(l, mid, bh * 2);\n  build(mid + 1, r, bh * 2 + 1);\n  tr[bh] = gcd(tr[bh * 2], tr[bh * 2 + 1]);\n}\nlong long sum(long long now_l, long long now_r, long long l, long long r,\n              long long bh) {\n  if (l <= now_l && now_r <= r) return tr[bh];\n  if (now_l > r || now_r < l) return 0;\n  long long mid = (now_l + now_r) / 2;\n  long long x = sum(now_l, mid, l, r, bh * 2),\n            y = sum(mid + 1, now_r, l, r, bh * 2 + 1);\n  return gcd(max(x, y), min(x, y));\n}\nsigned main() {\n  long long t = r();\n  while (t--) {\n    ans = 1;\n    n = r();\n    for (long long i = 1; i <= n; i++) {\n      b[i] = r();\n      a[i - 1] = abs(b[i] - b[i - 1]);\n    }\n    a[n] = 1;\n    for (long long i = 0; i <= 4 * n + 5; i++) tr[i] = 1;\n    build(1, n, 1);\n    long long r = 2;\n    for (long long l = 1; l < n; l++) {\n      r = max(r, l + 1);\n      long long x = sum(1, n, l, r - 1, 1);\n      while (x > 1 && r <= n) {\n        r++;\n        if (r > n) break;\n        x = sum(1, n, l, r - 1, 1);\n      }\n      ans = max(ans, r - l);\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import gcd\n\nfor _ in range(int(input())):\n    n, a = int(input()), map(int, input().split())\n    maxim, last, nova_cua = 1, next(a), []\n    for i, new in enumerate(a):\n        dif, last, cua, nova_cua = abs(last-new), new, nova_cua, []\n        for g, p in [(dif, i)] + cua:\n            g = gcd(dif, g)\n            if g == 1:\n                break\n            if nova_cua and nova_cua[-1][0] == g:\n                nova_cua.pop()\n            nova_cua.append((g, p))\n            maxim = max(maxim, i-p+2)\n    print(maxim)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> v, d;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nstruct RMQ {\n  vector<vector<long long>> rmq;\n  vector<int> logb2;\n  RMQ() {}\n  RMQ(vector<long long>& v) {\n    int n = (int)v.size();\n    logb2.resize(n + 1, 0);\n    rmq.resize(1, vector<long long>(n));\n    for (int i = 0; i < n; i++) {\n      rmq[0][i] = v[i];\n    }\n    for (int i = 0; (1 << i) <= n; i++) {\n      logb2[1 << i] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n      logb2[i] = max(logb2[i], logb2[i - 1]);\n    }\n    rmq.resize(logb2.back() + 1);\n    for (int t = 1; t < (int)rmq.size(); t++) {\n      rmq[t].resize(n - (1 << t) + 1);\n      for (int i = 0; i <= n - (1 << t); i++)\n        rmq[t][i] = gcd(rmq[t - 1][i], rmq[t - 1][i + (1 << (t - 1))]);\n    }\n  }\n  long long query(int i, int j) {\n    if (i > j) {\n      swap(i, j);\n    }\n    int k = logb2[j - i + 1];\n    return gcd(rmq[k][i], rmq[k][j - (1 << k) + 1]);\n  }\n};\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    v.resize(n);\n    d.resize(n - 1);\n    for (auto& x : v) {\n      cin >> x;\n    }\n    for (int i = 0; i < n - 1; i++) d[i] = abs(v[i] - v[i + 1]);\n    int res = 0;\n    RMQ rmq(d);\n    for (int i = 0; i < n - 1; i++) {\n      int l = i, r = n - 1;\n      while (l != r) {\n        int mid = (l + r) >> 1;\n        long long g = rmq.query(i, mid);\n        g == 1 ? r = mid : l = mid + 1;\n      }\n      res = max(res, l - i);\n    }\n    cout << res + 1 << '\\n';\n  }\n  cin.ignore(2);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Solution\n{\n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n    //static final long mod=(long)1e9+7;\n    static final long mod=998244353L;\n    public static long pow(long a,long p)\n    {\n        long res=1;\n        while(p>0)\n        {\n            if(p%2==1)\n            {\n                p--;\n                res*=a;\n                res%=mod;\n            }\n            else\n            {\n                a*=a;\n                a%=mod;\n                p/=2;\n            }\n        }\n        return res;\n    }\n    static class Pair\n    {\n        int u,v;\n        Pair(int u,int v)\n        {\n            this.u=u;\n            this.v=v;\n        }\n    }\n    /*static class Pair implements Comparable<Pair>\n    {\n        int v,l;\n        Pair(int v,int l)\n        {\n            this.v=v;\n            this.l=l;\n        }\n        public int compareTo(Pair p)\n        {\n            return l-p.l; \n        }\n    }*/\n    static long gcd(long a,long b)\n    {\n        if(a==0)\n        return b;\n        if(b%a==0)\n        return a;\n        return gcd(b%a,a);\n    }\n    public static class comp implements Comparator<Pair>\n    {\n        public int compare(Pair p1,Pair p2)\n        {\n            if(p1.v>p2.v)\n            return 1;\n            return -1;\n        }\n    }\n    public static void build(long seg[],long a[],int l,int r,int ind)\n    {\n        if(l==r)\n        {\n            seg[ind]=a[l];\n            return;\n        }\n        int m=(l+r)/2;\n        build(seg,a,l,m,2*ind+1);\n        build(seg,a,m+1,r,2*ind+2);\n        seg[ind]=gcd(Math.min(seg[2*ind+1],seg[2*ind+2]),Math.max(seg[2*ind+1],seg[2*ind+2]));\n    }\n    public static long q(long seg[],int s,int e,int l,int r,int ind)\n    {\n        if(s>r||e<l)\n        return 0L;\n        if(l>=s&&r<=e)\n        return seg[ind];\n        int m=(l+r)/2;\n        long l1=q(seg,s,e,l,m,2*ind+1);\n        long l2=q(seg,s,e,m+1,r,2*ind+2);\n        return gcd(Math.min(l1,l2),Math.max(l1,l2));\n    }\n    public static void main(String args[])throws Exception\n    {\n        FastReader fs=new FastReader();\n        PrintWriter pw=new PrintWriter(System.out);\n        int tc=fs.nextInt();\n        while(tc-->0)\n        {\n            int n=fs.nextInt();\n            long a[]=new long[n];\n            for(int i=0;i<n;i++)\n            a[i]=fs.nextLong();\n            if(n==1)\n            {\n                pw.println(1);\n                continue;\n            }\n            if(n==2)\n            {\n                if((long)Math.abs(a[1]-a[0])==1)\n                pw.println(1);\n                else\n                pw.println(2);\n                continue;\n            }\n            long aa[]=new long[n-1];\n            for(int i=1;i<n;i++)\n            aa[i-1]=(long)Math.abs(a[i]-a[i-1]);\n            long seg[]=new long[4*n];\n            build(seg,aa,0,n-2,0);\n            int l=0,r=0;\n            int mx=0;\n            long g=0;\n            while(r<n-1)\n            {\n                if(l==r)\n                {\n                    if(aa[l]==1)\n                    l++;\n                    else\n                    g=aa[l];\n                    r++;\n                }\n                else\n                {\n                    long gg=q(seg,l,r,0,n-2,0);\n                    if(gg==1)\n                    l++;\n                    else\n                    {\n                        g=gg;\n                        r++;\n                    }\n                }\n                mx=Math.max(mx,r-l);\n            }\n            pw.println(mx+1);\n        }\n        pw.flush();\n        pw.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import com.sun.source.tree.Tree;\n\nimport java.io.*;\nimport java.lang.reflect.Parameter;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\n    static final int MAX_N = 1000010;\n    static final int INF = 0x3f3f3f3f;\n\n    public static void main(String[] args) throws IOException {\n        initReader(System.in);\n\n\n        int T = nextInt();\n        for (int i = 1; i <= T; i++)\n            solve();\n\n\n        pw.flush();\n    }\n\n\n    /*******************************************************************************************************************************/\n\n    static long[] C;\n    static long[] c;\n    static long[] a;\n\n    public static void solve() throws IOException {\n        int n = nextInt();\n\n        C = new long[n << 2];\n\n        a = new long[n + 1];\n        for (int i = 1; i <= n; i++) a[i] = nextLong();\n\n        c = new long[n + 1];\n        for (int i = 1; i <= n; i++) c[i] = Math.abs(a[i] - a[i - 1]);\n\n\n        build(1, n, 1);\n\n\n        int ans = 1;\n        for (int i = 1, j = 1; i <= n; i++, j++) {\n            while (j + 1 <= n && query(i, j + 1, 1, n, 1) > 1) j++;\n            if (j <= n && query(i, j, 1, n, 1) > 1)\n                ans = Math.max(ans, j - (i - 1 >= 1 ? i - 1 : i) + 1);\n        }\n\n        pw.println(ans);\n    }\n\n    public static void pushUp(int root) {\n        C[root] = gcd(C[root << 1], C[root << 1 | 1]);\n    }\n\n    public static void build(int l, int r, int root) {\n        if (l == r) {\n            C[root] = c[l];\n            return;\n        }\n\n        int mid = l + r >> 1;\n        build(l, mid, root << 1);\n        build(mid + 1, r, root << 1 | 1);\n        pushUp(root);\n    }\n\n    public static long query(int L, int R, int l, int r, int root) {\n        if (L <= l && r <= R) return C[root];\n\n        long ans = 0;\n        int mid = l + r >> 1;\n        if (L <= mid) ans = gcd(ans, query(L, R, l, mid, root << 1));\n        if (mid < R) ans = gcd(ans, query(L, R, mid + 1, r, root << 1 | 1));\n\n        return ans;\n    }\n\n    public static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    /*******************************************************************************************************************************/\n\n\n    /*******************************************************************************************************************************/\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n    static PrintWriter pw;\n\n    public static void initReader(InputStream input) throws IOException {\n        reader = new BufferedReader(new InputStreamReader(input));\n        tokenizer = new StringTokenizer(\"\");\n        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n//        reader = new BufferedReader(new FileReader(\"test.in\"));\n//        tokenizer = new StringTokenizer(\"\");\n//        pw = new PrintWriter(new BufferedWriter(new FileWriter(\"test1.out\")));\n    }\n\n    public static boolean hasNext() {\n        try {\n            while (!tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    public static String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    public static char nextChar() throws IOException {\n        return next().charAt(0);\n    }\n\n    public static short nextShort() throws IOException {\n        return Short.parseShort(next());\n    }\n\n}\n\n"
        },
        {
            "language": 1,
            "solution": "import sys\ntesting = len(sys.argv) == 4 and sys.argv[3] == \"myTest\"\ninteractive = False\nif testing:\n    cmd = sys.stdout\n    from time import time\n    start_time = int(round(time() * 1000)) \n    readAll = open(sys.argv[1], 'r').read\n    sys.stdout = open(sys.argv[2], 'w')\nelse:\n    readAll = sys.stdin.read\n\n# ############ ---- I/O Functions ---- ############\n\nclass InputData:\n    def __init__(self):\n        self.lines = readAll().split('\\n')\n        self.n = len(self.lines)\n        self.ii = -1\n    def input(self):\n        self.ii += 1\n        assert self.ii < self.n\n        return self.lines[self.ii]\n\nflush = sys.stdout.flush\nif interactive and not testing:\n    input = sys.stdin.readline\nelse:\n    inputData = InputData()\n    input = inputData.input\n\ndef intin():\n    return(int(input()))\ndef intlin():\n    return(list(map(int,input().split())))\ndef chrin():\n    return(list(input()))\ndef strin():\n    return input()\ndef lout(l, sep=\"\\n\", toStr=True):\n    print(sep.join(map(str, l) if toStr else l))\ndef dout(*args, **kargs):\n    if not testing: return\n    if args: print(args[0] if len(args)==1 else args)\n    if kargs: print([(k,v) for k,v in kargs.items()])\ndef ask(q):\n    sys.stdout.write(str(q)+'\\n')\n    flush()\n    return intin()\n    \n# ############ ---- I/O Functions ---- ############\n\n# from math import ceil\nfrom collections import defaultdict as ddict, Counter\n# from heapq import *\n# from Queue import Queue\nclass ST:\n    def __init__(self, a, f):\n        self.n = len(a)\n        self.f = f\n        self.tree = [None]*(2*self.n)\n        self.build(a)\n\n    def build(self, a):\n        for i in xrange(self.n):\n            self.tree[self.n+i] = a[i]\n        for i in xrange(self.n-1,0,-1):\n            self.tree[i] = self.f(self.tree[i<<1], self.tree[i<<1 | 1])\n    \n    def update(self, i, v):\n        i += self.n\n        self.tree[i] = v\n        while i > 1:\n            self.tree[i>>1] = self.f(self.tree[i], self.tree[i^1])\n            i >>= 1\n\n    def query(self, l, r):\n        #to find the sum in the range [l,r)\n        v = 0\n        l,r = (l+self.n,self.n+r)\n        while l < r:\n            if (l&1)>0:\n                v = self.f(v, self.tree[l])\n                l += 1\n            if (r&1)>0:\n                r -= 1\n                v = self.f(v, self.tree[r])\n            l >>= 1\n            r >>= 1\n        return v\n \nclass SparseTable:\n    def __init__(self, a, f, nv=0):\n        self.f, self.nv = [f, nv]\n        self.k = 0\n        while (1<<self.k) <= len(a):\n            self.k += 1\n        self.table = [[nv]*len(a) for _ in xrange(self.k)]\n        self.build(a)\n\n    def build(self, a):\n        for i in xrange(len(a)):\n            self.table[0][i] = a[i]\n        for j in xrange(1, self.k):\n            i = 0\n            while (i+(1<<j)) <= len(a):\n                self.table[j][i] = self.f(self.table[j-1][i], self.table[j-1][i+(1<<(j-1))])\n                i += 1\n\n    def query(self, l, r):\n        for j in xrange(self.k, -1, -1):\n            if (1<<j) < r-l+1:\n                return self.f(self.table[j][l], self.table[j][r-(1<<j)])\n                l += (1<<j)\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a%b\n    return a\n\ndef main():\n    n = intin()\n    a = intlin()\n    if n == 1:\n        return 1\n    b = [abs(a[i] - a[i-1]) for i in xrange(1,n)]\n    ans = 1 + int(max(b)>1)\n    st = SparseTable(b, gcd, nv=0)\n    i = 0\n    j = 1\n    while i < len(b) and j < len(b):\n        if st.query(i,j+1) != 1:\n            ans = max(ans, j-i+2)\n            j += 1\n        else:\n            i += 1\n            if i == j:\n                j = i+1\n    return ans\n\n\n\n\nanss = []\nfor _ in xrange(intin()):\n    anss.append(main())\n    # anss.append(\"YES\" if main() else \"NO\")\nlout(anss)\n\nif testing:\n    sys.stdout = cmd\n    print(int(round(time() * 1000))  - start_time)"
        },
        {
            "language": 3,
            "solution": "def main():\n    \n    mod=1000000007\n    # mod=998244353\n    # nCr =  make_nCr_mod()\n    \n    tc=ri()\n    for _ in range(tc):\n        n=ri()\n        a=[0]+ria()\n        b=[0]*(n+1)\n        \n        for i in range(1,n+1):\n            b[i]=abs(a[i]-a[i-1])\n        \n        Table=SparseTable(b,gcd)\n        \n        ans=1\n        \n        l,r=2,n\n        \n        while l<=r:\n            mid=(l+r)//2\n            flag=False\n            for i in range(1,n-mid+2):\n                left,right=i+1,i+mid-1\n                val=Table.query(left,right)\n                if val!=1:\n                    flag=True\n                    break\n            if flag:\n                ans=mid\n                l= mid +1\n            else:\n                r= mid -1\n        wi(ans)\n        \n        \n\ndef rant():\n    # RANT BEGINS-\n    # \n    # Did you look at the constraints dummy? Read problem again carefully understand it correctly\n    # Are base cases correct n=0,n=1,n=N or string is all 0 or all 1?\n    # \n    # 1.Greedy? What matters what doesnt? Is my claim correct? \n    #   Does my implementation correctly implements the greedy i thought of? \n    #   Dictionary? keep a count of values if constraint on something is low(like only alphabets(26) count)? \n    # \n    # 2.DP? Think about state's ranges maybe one of the states have lesser possible values than it may look like? \n    #   Obviously think about order of evaluation\n    # \n    # 3.Binary Search?(Monotonic? any one directed order in which we have to perform something?)\n    # \n    # 4.Graph?DSU?Edge property or Vertex property Read carefully? Bipartitenes Property??? Cycle Property??? \n    #   Hidden but dependency ordering of values(in 1d array or 2d Table/Array) is that of a graph???\n    # \n    # 5.Number Theory?(GCD subtraction?)\n    # \n    # 6.Bruteforce?(Redundant part of N which may not give answer?Constraints?)\n    # \n    # 7.Range Queries?\n    # \n    # 8.Any Equivalency?(We have A and B and have to do \n    #   something between them maybe difficult if there was A~C and C~B then A~B\n    #   C could be max or min or some other thing)\n    # \n    # 9.Reverse Engineering?(From Answer to quesn or last step to first step)\n    #\n    # 10.Constructive? Mod? Bruteforce for smaller case and analyze patterns?\n    #\n    # 11.String? Constructive Greedy example- \n    #   Bracket sequence make first part unknown open and second part unknown closed \n    #   Remember always only n//2 open and n//2 closed brackets are there\n    #\n    # 12.Combinatorics?--> (n to i-1 index ways) * (ith index ways) * Ways (for i-1 till 0 index)?\n    #\n    # 13.Look for patterns and dependency of the patterns(maybe only first row or column matters to construct other rows and columns)\n    #   for smaller cases maybe make bruteforce solution and analyze the patterns\n    # \n    # RANT ENDS\n    return \"AAAAAAAAAAAAAAAAARRRGHHHHHHHHHHHHHHHHHHHHHHHH\"\n    \ndef SieveOfEratosthenes(limit):\n    \"\"\"Returns all primes not greater than limit.\"\"\"\n    isPrime = [True]*(limit+1)\n    isPrime[0] = isPrime[1] = False\n    primes = []\n    for i in range(2, limit+1):\n        if not isPrime[i]:continue\n        primes += [i]\n        for j in range(i*i, limit+1, i):\n            isPrime[j] = False\n    return primes\n\ndef gcd(x, y):\n    \"\"\"greatest common divisor of x and y\"\"\"\n    while y:\n        x, y = y, x % y\n    return x\n\ndef memodict(f):\n    \"\"\"memoization decorator for a function taking a single argument\"\"\"\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n\n    return memodict().__getitem__\n\ndef pollard_rho(n):\n    \"\"\"returns a random factor of n\"\"\"\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n\n    s = ((n - 1) & (1 - n)).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = (p * p) % n\n            if p == 1:\n                return gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                x, y = i, (i * i + 1) % n\n                f = gcd(abs(x - y), n)\n                while f == 1:\n                    x, y = (x * x + 1) % n, (y * y + 1) % n\n                    y = (y * y + 1) % n\n                    f = gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n\n@memodict\ndef prime_factors(n):\n    \"\"\"returns a Counter of the prime factorization of n\"\"\"\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n\ndef distinct_factors(n):\n    \"\"\"returns a list of all distinct factors of n\"\"\"\n    factors = [1]\n    for p, exp in prime_factors(n).items():\n        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]\n    return factors\n\ndef all_factors(n):\n    \"\"\"returns a sorted list of all distinct factors of n\"\"\"\n    small, large = [], []\n    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):\n        if not n % i:\n            small.append(i)\n            large.append(n // i)\n    if small[-1] == large[-1]:\n        large.pop()\n    large.reverse()\n    small.extend(large)\n    return small\n\ndef make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):\n    max_n = min(max_n, mod - 1)\n\n    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)\n    fact[0] = 1\n    for i in range(max_n):\n        fact[i + 1] = fact[i] * (i + 1) % mod\n\n    inv_fact[-1] = pow(fact[-1], mod - 2, mod)\n    for i in reversed(range(max_n)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def nCr_mod(n, r):\n        res = 1\n        while n or r:\n            a, b = n % mod, r % mod\n            if a < b:\n                return 0\n            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n            n //= mod\n            r //= mod\n        return res\n\n    return nCr_mod\n\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = [*range(n+1)]\n        self.size = [1]*(n+1)\n        self.min, self.max = [*range(n+1)], [*range(n+1)]\n        self.count = n\n\n    def get(self, a):\n        \"\"\"Returns the identifier (parent) of the set to which a belongs to!\"\"\"\n        if self.parent[a] == a:\n            return a\n        x = a\n        while a != self.parent[a]:\n            a = self.parent[a]\n        while x != self.parent[x]:\n            self.parent[x], x = a, self.parent[x]\n        return a\n\n    def union(self, a, b):\n        \"\"\"Join two sets that contain a and b!\"\"\"\n        a, b = self.get(a), self.get(b)\n        if a != b:\n            if self.size[a] > self.size[b]:\n                a, b = b, a\n            self.parent[a] = b\n            self.size[b] += self.size[a]\n            self.min[b] = min(self.min[a], self.min[b])\n            self.max[b] = max(self.max[a], self.max[b])\n            self.count -= 1\n\n    def count_sets(self):\n        \"\"\"Returns the number of disjoint sets!\"\"\"\n        return self.count\n    \nclass SegTree:\n    \n    def __init__(self, n):\n        self.N = 1 << n.bit_length()\n        self.tree = [0] * (self.N<<1)\n    \n    def update(self, i, j, v):\n        i += self.N\n        j += self.N\n        while i <= j:\n            if i%2==1: self.tree[i] += v\n            if j%2==0: self.tree[j] += v\n            i, j = (i+1) >> 1, (j-1) >> 1\n    \n    def query(self, i):\n        v = 0\n        i += self.N\n        while i > 0:\n            v += self.tree[i]\n            i >>= 1\n        return v\n\nclass SparseTable:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)]\"\"\"\n        depth = (stop + 1 - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop + 1 - (1 << depth)])\n\n    def __getitem__(self, idx):\n        return self._data[0][idx]\n              \nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n \n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n \n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n \n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n \n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n \n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n \n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n \n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n \n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n \n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n \n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n \n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n \n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n \n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n \n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n \n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n \n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n \n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n \n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n \n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n \n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n \n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\nimport sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom math import log2\nfrom bisect import bisect_left,bisect_right\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n# sys.setrecursionlimit(111111) \nINF=999999999999999999999999\nalphabets=\"abcdefghijklmnopqrstuvwxyz\"\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    main()\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    "
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport static java.lang.System.out;\nimport java.util.Stack;\nimport java.util.Queue;\n\npublic class D1549\n{\n\n    static int mod=(int)(1e9+7);\n    static long MOD=(long)(1e9+7);\n    static FastReader in=new FastReader();\n    static PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        \n    public static void main(String args[])\n    {  \n\n        int tc=1;\n     \n        tc=in.nextInt();\n        tcloop: while(tc-->0)\n        {\n            \n            int n=in.nextInt();\n            \n            long arr[]=in.readLongArray(n);\n            \n            \n            int p=18;\n            \n            long spt[][]=new long[n-1][p];\n            \n            for(int i=0;i<n-1;i++)\n            {\n\t\t\t\tspt[i][0]=Math.abs(arr[i+1]-arr[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=1;j<p;j++)\n\t\t\t{\n\t\t\t\tfor(int i=0;i+(1<<j)-1<n-1;i++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tspt[i][j]=gcd(spt[i][j-1],spt[i+(1<<(j-1))][j-1]);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint ans=1;\n\t\t\t\n\t\t\tfor(int i=0;i<n-1;i++)\n\t\t\t{\n\t\t\t\tif(spt[i][0]==1)continue;\n\t\t\t\t\n\t\t\t\tint curr=i;\n\t\t\t\tlong inf=(long)2e18;\n\t\t\t\tlong g=inf;\n\t\t\t\t\n\t\t\t\tfor(int j=p-1;j>=0;j--)\n\t\t\t\t{\n\t\t\t\t\tif(curr==n-1)break;\n\t\t\t\t\t\n\t\t\t\t\tif(spt[curr][j]>=2 && (g==inf|| gcd(g,spt[curr][j])>=2))\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tg=(g==inf)?spt[curr][j]:gcd(g,spt[curr][j]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcurr+=(1<<j);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tans=Math.max(ans,curr-i+1);\n\t\t\t}\n\t\t\t\n\t\t\tpr.println(ans);\n\t\t\t\n\t\n\n        }\n        pr.flush();\n        \n    }\n\n\tstatic long gcd(long a,long b)\n\t{\n\t\tif(a==0)return b;\n\t\treturn gcd(b%a,a);\n\t}\n\n    \n\n    static void sort(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n\t}\n    \n    \n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n    }\n\n    \n    static class FastReader\n    { \n        BufferedReader br; \n        StringTokenizer st; \n\n        public FastReader() \n        { \n            br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n\n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n\n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n\n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n\n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n        \n        int[] readIntArray(int n)\n        {\n\t\tint a[]=new int[n];\n\t\tfor(int i=0;i<n;i++)a[i]=nextInt();\n\t\treturn a;\n\t}\n\t\t\n\tlong[] readLongArray(int n)\n\t{\n\t\tlong a[]=new long[n];\n\t\tfor(int i=0;i<n;i++)a[i]=nextLong();\n\t\treturn a;\n\t}\n\t\n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n}\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class SegTree {\n    long[] a;\n    long[] dp;\n    public SegTree(long[] nums) {\n        long[] diff = new long[nums.length - 1];\n        for (int i = 1; i < nums.length; i++) {\n            diff[i - 1] = Math.abs(nums[i] - nums[i - 1]);\n        }\n        a = diff;\n//        System.out.println(Arrays.toString(a));\n        dp = new long[4 * a.length + 1];\n        build(0, 0, a.length - 1);\n    }\n    public void build(int idx, int low, int high) {\n        if (low == high) {\n            dp[idx] = a[low];\n            return;\n        }\n        int mid = low + (high - low) / 2;\n        build(2 * idx + 1, low, mid);\n        build(2 * idx + 2, mid + 1, high);\n        dp[idx] = gcd(dp[2*idx + 1], dp[2*idx + 2]);\n    }\n    public static long gcd(long a, long b) {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n    public long query(int idx, int low, int high, int left, int right) {\n        if (left > right) return 0;\n        // completely inside\n        if (low >= left && high <= right) {\n            return dp[idx];\n        }\n        // disjoint\n        if (left > high || right < low) {\n            return 0;\n        }\n        // overlap\n        int mid = low + (high - low) / 2;\n        long lChild = query(2 * idx + 1, low, mid, left, right);\n        long rChild = query(2*idx + 2, mid + 1, high, left, right);\n        return gcd(lChild, rChild);\n\n    }\n    public int maxLength() {\n        int start = 0; int end = 0;\n        long last = 0;\n        int max = 0;\n        while (end < a.length) {\n            long temp = gcd(last, a[end]);\n            if (temp > 1) {\n                end++;\n                max = Math.max(max, end - start);\n                last = temp;\n            }\n            else {\n                start++;\n                if (end < start) end = start;\n                last = query(0, 0, a.length - 1, start, end - 1);\n            }\n        }\n        return max + 1;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int t = Integer.parseInt(br.readLine());\n        for (int j = 0; j < t; j++) {\n            int n = Integer.parseInt(br.readLine());\n            long[] a = new long[n];\n            String[] s = br.readLine().split(\"\\\\s\");\n            for (int i = 0; i < a.length; i++) {\n                a[i] = Long.parseLong(s[i]);\n            }\n            if (a.length > 1){\n                SegTree test = new SegTree(a);\n                pw.println(test.maxLength());\n            }\n            else pw.println(a.length);\n        }\n        pw.flush();\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    \n    \n    mod=1000000007\n    # mod=998244353\n    # nCr =  make_nCr_mod()\n    \n    # LOGIC - www.youtube.com/watch?v=z0vqlIEUHjI\n    \n    tc=ri()\n    for _ in range(tc):\n        n=ri()\n        a=[0]+ria()\n        b=[0]*(n+1)\n        \n        for i in range(1,n+1):\n            b[i]=abs(a[i]-a[i-1])\n        \n        Table=SparseTable(b,math.gcd)\n                \n        ans=1\n        \n        l,r=2,n\n        \n        while l<=r:\n            mid=(l+r)//2\n            flag=False\n            for i in range(1,n-mid+2):\n                left,right=i+1,i+mid-1\n                val=Table.query(left,right)\n                if val!=1:\n                    flag=True\n                    break\n            if flag:\n                ans=mid\n                l= mid +1\n            else:\n                r= mid -1\n        wi(ans)\n        \n        \n\ndef rant():\n    # RANT BEGINS-\n    # \n    # Did you look at the constraints dummy? Read problem again carefully understand it correctly\n    # Are base cases correct n=0,n=1,n=N or string is all 0 or all 1?\n    # \n    # 1.Greedy? What matters what doesnt? Is my claim correct? \n    #   Does my implementation correctly implements the greedy i thought of? \n    #   Dictionary? keep a count of values if constraint on something is low(like only alphabets(26) count)? \n    # \n    # 2.DP? Think about state's ranges maybe one of the states have lesser possible values than it may look like? \n    #   Obviously think about order of evaluation\n    # \n    # 3.Binary Search?(Monotonic? any one directed order in which we have to perform something?)\n    # \n    # 4.Graph?DSU?Edge property or Vertex property Read carefully? Bipartitenes Property??? Cycle Property??? \n    #   Hidden but dependency ordering of values(in 1d array or 2d Table/Array) is that of a graph???\n    # \n    # 5.Number Theory?(GCD subtraction?)\n    # \n    # 6.Bruteforce?(Redundant part of N which may not give answer?Constraints?)\n    # \n    # 7.Range Queries?\n    # \n    # 8.Any Equivalency?(We have A and B and have to do \n    #   something between them maybe difficult if there was A~C and C~B then A~B\n    #   C could be max or min or some other thing)\n    # \n    # 9.Reverse Engineering?(From Answer to quesn or last step to first step)\n    #\n    # 10.Constructive? Mod? Bruteforce for smaller case and analyze patterns?\n    #\n    # 11.String? Constructive Greedy example- \n    #   Bracket sequence make first part unknown open and second part unknown closed \n    #   Remember always only n//2 open and n//2 closed brackets are there\n    #\n    # 12.Combinatorics?--> (n to i-1 index ways) * (ith index ways) * Ways (for i-1 till 0 index)?\n    #\n    # 13.Look for patterns and dependency of the patterns(maybe only first row or column matters to construct other rows and columns)\n    #   for smaller cases maybe make bruteforce solution and analyze the patterns\n    # \n    # RANT ENDS\n    return \"AAAAAAAAAAAAAAAAARRRGHHHHHHHHHHHHHHHHHHHHHHHH\"\n    \ndef SieveOfEratosthenes(limit):\n    \"\"\"Returns all primes not greater than limit.\"\"\"\n    isPrime = [True]*(limit+1)\n    isPrime[0] = isPrime[1] = False\n    primes = []\n    for i in range(2, limit+1):\n        if not isPrime[i]:continue\n        primes += [i]\n        for j in range(i*i, limit+1, i):\n            isPrime[j] = False\n    return primes\n\ndef gcd(x, y):\n    \"\"\"greatest common divisor of x and y\"\"\"\n    while y:\n        x, y = y, x % y\n    return x\n\ndef memodict(f):\n    \"\"\"memoization decorator for a function taking a single argument\"\"\"\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n\n    return memodict().__getitem__\n\ndef pollard_rho(n):\n    \"\"\"returns a random factor of n\"\"\"\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n\n    s = ((n - 1) & (1 - n)).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = (p * p) % n\n            if p == 1:\n                return gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                x, y = i, (i * i + 1) % n\n                f = gcd(abs(x - y), n)\n                while f == 1:\n                    x, y = (x * x + 1) % n, (y * y + 1) % n\n                    y = (y * y + 1) % n\n                    f = gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n\n@memodict\ndef prime_factors(n):\n    \"\"\"returns a Counter of the prime factorization of n\"\"\"\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n\ndef distinct_factors(n):\n    \"\"\"returns a list of all distinct factors of n\"\"\"\n    factors = [1]\n    for p, exp in prime_factors(n).items():\n        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]\n    return factors\n\ndef all_factors(n):\n    \"\"\"returns a sorted list of all distinct factors of n\"\"\"\n    small, large = [], []\n    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):\n        if not n % i:\n            small.append(i)\n            large.append(n // i)\n    if small[-1] == large[-1]:\n        large.pop()\n    large.reverse()\n    small.extend(large)\n    return small\n\ndef make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):\n    max_n = min(max_n, mod - 1)\n\n    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)\n    fact[0] = 1\n    for i in range(max_n):\n        fact[i + 1] = fact[i] * (i + 1) % mod\n\n    inv_fact[-1] = pow(fact[-1], mod - 2, mod)\n    for i in reversed(range(max_n)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def nCr_mod(n, r):\n        res = 1\n        while n or r:\n            a, b = n % mod, r % mod\n            if a < b:\n                return 0\n            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n            n //= mod\n            r //= mod\n        return res\n\n    return nCr_mod\n\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = [*range(n+1)]\n        self.size = [1]*(n+1)\n        self.min, self.max = [*range(n+1)], [*range(n+1)]\n        self.count = n\n\n    def get(self, a):\n        \"\"\"Returns the identifier (parent) of the set to which a belongs to!\"\"\"\n        if self.parent[a] == a:\n            return a\n        x = a\n        while a != self.parent[a]:\n            a = self.parent[a]\n        while x != self.parent[x]:\n            self.parent[x], x = a, self.parent[x]\n        return a\n\n    def union(self, a, b):\n        \"\"\"Join two sets that contain a and b!\"\"\"\n        a, b = self.get(a), self.get(b)\n        if a != b:\n            if self.size[a] > self.size[b]:\n                a, b = b, a\n            self.parent[a] = b\n            self.size[b] += self.size[a]\n            self.min[b] = min(self.min[a], self.min[b])\n            self.max[b] = max(self.max[a], self.max[b])\n            self.count -= 1\n\n    def count_sets(self):\n        \"\"\"Returns the number of disjoint sets!\"\"\"\n        return self.count\n    \nclass SegTree:\n    \n    def __init__(self, n):\n        self.N = 1 << n.bit_length()\n        self.tree = [0] * (self.N<<1)\n    \n    def update(self, i, j, v):\n        i += self.N\n        j += self.N\n        while i <= j:\n            if i%2==1: self.tree[i] += v\n            if j%2==0: self.tree[j] += v\n            i, j = (i+1) >> 1, (j-1) >> 1\n    \n    def query(self, i):\n        v = 0\n        i += self.N\n        while i > 0:\n            v += self.tree[i]\n            i >>= 1\n        return v\n\nclass SparseTable:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)]\"\"\"\n        depth = (stop + 1 - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop + 1 - (1 << depth)])\n\n    def __getitem__(self, idx):\n        return self._data[0][idx]\n              \nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n \n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n \n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n \n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n \n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n \n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n \n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n \n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n \n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n \n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n \n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n \n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n \n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n \n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n \n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n \n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n \n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n \n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n \n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n \n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n \n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n \n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\nimport sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom math import log2\nfrom bisect import bisect_left,bisect_right\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n# sys.setrecursionlimit(111111) \nINF=999999999999999999999999\nalphabets=\"abcdefghijklmnopqrstuvwxyz\"\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    main()\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    "
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\nimport java.io.*;\n \npublic class IntegersHaveFriends {\n\t\n\tprivate static class MyScanner {\n\t    BufferedReader br;\n\t    StringTokenizer st;\n\n\t    public MyScanner() {\n\t       br = new BufferedReader(new InputStreamReader(System.in));\n\t    }\n\n\t    String next() {\n\t        while (st == null || !st.hasMoreElements()) {\n\t            try {\n\t                st = new StringTokenizer(br.readLine());\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t        return st.nextToken();\n\t    }\n\n\t    int nextInt() {\n\t        return Integer.parseInt(next());\n\t    }\n\n\t    long nextLong() {\n\t        return Long.parseLong(next());\n\t    }\n\n\t    double nextDouble() {\n\t        return Double.parseDouble(next());\n\t    }\n\n\t    String nextLine(){\n\t        String str = \"\";\n\t\t  try {\n\t\t     str = br.readLine();\n\t\t  } catch (IOException e) {\n\t\t     e.printStackTrace();\n\t\t  }\n\t\t  return str;\n\t    }\n\n\t }\n\t\n\tpublic static interface Operation {\n\t\t\n\t\tpublic long op(long a, long b);\n\t}\n\t\n\tpublic static class SegmentTree {\n\t\t\n\t\tint n;\n\t\tlong base;\n\t\tlong[] tree;\n\t\tOperation o;\n\t\t\n\t\tSegmentTree(long[] arr, Operation o, long base) {\n\t\t\t\n\t\t\tthis.n = arr.length;\n\t\t\tthis.base = base;\n\t\t\tthis.o = o;\n\t\t\tbuild(arr);\n\t\t}\n\t\t\n\t\tpublic void build(long[] arr) {\n\t\t   \ttree = new long[2*n];\n\t\t   \t\n\t\t   \tfor(int i  = 0; i<n; i++)\n\t\t   \t\ttree[n+i] = arr[i];\n\t\t   \t\n\t\t   \tfor(int i = n-1; i>0; i--)\n\t\t   \t\ttree[i] = o.op(tree[2*i],tree[2*i+1]);\n\t\t   \n\t\t}\n\t\t\n\t\tpublic void update(int in, int v) {\n\t\t\t\n\t\t\ttree[n+in] = v;\n\t\t\tint p = v/2;\n\t\t\t\n\t\t\twhile(p>0) {\n\t\t\t\ttree[p] = o.op(tree[2*p], tree[2*p+1]);\n\t\t\t\tp/=2;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic long query(int l, int r) {\n\t\t\t\n\t\t\tl+=n;\n\t\t\tr+=n;\n\t\t\t\n\t\t\tlong res = base;\n\t\t\t\n\t\t\twhile(l<=r) {\n\t\t\t\t\n\t\t\t\tif(l%2==1)\n\t\t\t\t  res = o.op(res, tree[l++]);\n\t\t\t\t\n\t\t\t\tif(r%2==0)\n\t\t\t\t  res = o.op(res, tree[r--]);\n\t\t\t\t\n\t\t\t\tl/=2;\n\t\t\t\tr/=2;\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\t\t\n\t\t}\n\t\t\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\t\n\t\tif(b==0)\n\t\t\treturn a;\n\t\t\n\t\treturn gcd(b,a%b);\n\t}\n\t\n\tpublic static int solution(long[] arr, int n)\n\t\t\t\n\t{\n\t\tlong[] req = new long[n-1];\n\t\t\n\t\tfor(int i = 0; i<n-1; i++)\n\t\t  req[i] = Math.abs(arr[i]-arr[i+1]);\n\t\t\n\t\tint max  = 0;\n\t\tlong prev = 0;\n\t\tint curr = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tSegmentTree st = new SegmentTree(req, (a,b) -> gcd(a,b), 0);\n\t\t\n\t\twhile(j<n-1)\n\t\t{\n\t\t\t\n\t\t\tprev = st.query(i, j);\n\t\t\t\n\t\t\twhile(prev==1)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tprev = st.query(i,j);\n\t\t\t}\n\t\t\t\n\t\t\tcurr = j-i+1;\n\t\t\t\n\t\t\tif(curr>max)\n\t\t\t\tmax = curr;\n\t\t\t\n\t\t\tj++;\n\t\t}\n\t\t\n\t\treturn max+1;\n\t\t\n\t}\n        \nprivate static PrintWriter out = new PrintWriter(System.out);\n\npublic static void main (String[] args)\n{\n\tMyScanner s =  new MyScanner();\n     \n    int t = s.nextInt();\n\n    for(int j = 0; j<t ; j++)\n    {\n    \tint n = s.nextInt();\n    \tlong[] arr = new long[n];\n    \tfor(int i =0; i<n; i++)\n    \t   arr[i] = s.nextLong();\n    \t\t\n        out.println(solution(arr,n));\n    }\n    \n    out.flush();\n    out.close();\n    \n}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class SolutionD {\n    private static FastScanner in = new FastScanner();\n    private static PrintWriter out =\n        new PrintWriter(new BufferedOutputStream(System.out));\n\n    public static void main(String[] args) {\n        \n        tests();\n        // solve();\n        \n        out.close();\n    }\n\n    \n    static void solve() {\n        int n = in.nextInt();\n\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextLong();\n        }\n\n        n--;\n        long[] d = new long[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = abs(a[i] - a[i + 1]);\n        }\n\n        SegmentTree st = new SegmentTree(d);\n        \n        int answer = 1;\n        int l = 0, r = 1;\n        while (l < r && r <= n) {\n            if (d[l] == 1) {\n                l++;\n                if (l == r) r++;\n                continue;\n            }\n            if (st.query(l, r) > 1) {\n                answer = max(answer, r - l + 1);\n                r++;\n            }\n            else {\n                l++;\n            }\n        }\n\n        out.println(answer);\n    }\n\n    static long gcd(long x, long y) {\n        if (y == 0) return x;\n        return gcd(y, x % y);\n    }\n\n    static void tests() {\n        int t = in.nextInt();\n        while (t-- > 0) {\n            solve();\n        }\n    }\n\n    static class SegmentTree {\n    \n        private int size;\n        private Node[] tree;\n    \n        SegmentTree(long[] a) {\n            size = 1;\n            while (size < a.length) size *= 2;\n            tree = new Node[2*size];\n            build(a);\n        }\n    \n        private static class Node {\n            long gcd;\n\n            Node() { gcd = 0; } // neutral \n            Node(long gcd) { this.gcd = gcd; }\n        }\n\n        static Node merge(Node v, Node w) {\n            if (v == null) return w;\n            if (w == null) return v;\n\n            long gcd = gcd(v.gcd, w.gcd);\n            return new Node(gcd);\n        }\n\n        public long query(int from, int to) {\n            return query(from, to, 0, 0, size).gcd;\n        }\n\n        public void build(long[] a) {\n            build(a, 0, 0, size);\n        }\n    \n        public void set(int index, long value) {\n            set(index, value, 0, 0, size);\n        }\n    \n        private void build(long[] a, int node, int lo, int hi) {\n            if (hi - lo == 1) {\n                if (lo < a.length) {\n                    tree[node] = new Node(a[lo]);\n                }\n                return;\n            }\n    \n            int mid = (lo + hi) / 2;\n            build(a, 2*node + 1, lo, mid);\n            build(a, 2*node + 2, mid, hi);\n            \n            tree[node] = merge(tree[2*node + 1], tree[2*node + 2]);\n        }\n        \n        private void set(int index, long value, int node, int lo, int hi) {\n            if (hi - lo == 1) { // leaf node\n                tree[node] = new Node(value);\n                return;\n            }\n    \n            int mid = (lo + hi) / 2;\n            \n            if (index < mid) { // go left\n                set(index, value, 2*node + 1, lo, mid);\n            }\n            else { // go right\n                set(index, value, 2*node + 2, mid, hi);\n            }\n    \n            tree[node] = merge(tree[2*node + 1], tree[2*node + 2]);\n        }\n    \n        private Node query(int from, int to, int node, int lo, int hi) {\n            if (to <= lo || hi <= from) { // don't intersect\n                return new Node();\n            }\n            if (from <= lo && hi <= to) { // fully contains\n                return tree[node];\n            }\n    \n            int mid = (lo + hi) / 2;\n    \n            Node leftResult = query(from, to, 2*node + 1, lo, mid); \n            Node rightResult = query(from, to, 2*node + 2, mid, hi); \n            return merge(leftResult, rightResult);\n        }\n    }\n\n    private static class FastScanner {\n        private BufferedReader br;\n        private StringTokenizer st;\n    \n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n    \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) { e.printStackTrace(); }\n            }\n            return st.nextToken();\n        }\n    \n        int nextInt() { return Integer.parseInt(next()); }\n    \n        long nextLong() { return Long.parseLong(next()); }\n    \n        double nextDouble() { return Double.parseDouble(next()); }\n    \n        String nextLine() {\n            String str = \"\";\n            try { str = br.readLine(); } \n            catch (IOException e) { e.printStackTrace(); }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import io,os\nimport math\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\nclass segment_tree(object):\n\n    def __init__(self,n,nums):\n        self.n = n\n        self.arr = [0]*(2*n)\n        for i in range(2*n-1,0,-1):\n            if i>=n:  self.arr[i] = nums[i-n]\n            else:  self.arr[i] = math.gcd(self.arr[2*i],self.arr[2*i+1])\n\n\n\n\n    def merge(self,num,temp):\n        return math.gcd(num,temp)\n\n\n\n#    def update(self,index,target):\n\n#        self.arr[index] = target\n#        if index & 1:\n#            nexttarget = self.merge( self.arr[index], self.arr[index-1])\n#        else:\n#            nexttarget = self.merge( self.arr[index], self.arr[index+1])\n#        if index>0:  self.update(index>>1,nexttarget )\n\n \n\n\n\n\n#    def addnum(self,index,diff):\n#        self.update(index+self.n, self.arr[index+self.n] + diff)\n\n\n\n    def query(self,left,right):\n        i,j = self.n+left,  self.n+right+1\n        output = self.arr[i]  # initial output should be changed if you want to change the merge function\n\n        while i<j:\n            if i&1:\n                output = self.merge(self.arr[i],output)\n                i += 1\n            if j&1:\n                j -= 1\n                output = self.merge(self.arr[j],output)\n            i = i >> 1\n            j = j >> 1\n        return output\n\n\n\n\n\n\n\n\n\n\n\ndef main(t,T):\n\n\n    n = int(input())\n    arr = list(map(int,input().split()))\n\n\n\n\n\n\n    if n==1: \n        print(1)\n        return \n\n\n    diff = [abs(arr[i+1]-arr[i]) for i in range(n-1)]\n    diff.append(1)\n\n\n    ans = 1\n\n    tree = segment_tree(n,diff)\n\n\n\n\n\n    for i in range(n-1):\n        front = i + ans - 1\n        if front>=n: break\n        num = tree.query(i,front)\n        if num==1: continue \n\n\n        while front<n-1 and num > 1:\n            front += 1\n            num = math.gcd(num,diff[front])\n\n        \n\n        ans = max(ans,  front-i+1)\n\n\n\n\n\n\n\n\n    print(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT = int(input())\nt = 1\nwhile t<=T:\n    main(t,T)\n    t += 1\n"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\nimport string\nimport math\nimport bisect\n#import random\nimport sys\n# sys.setrecursionlimit(10**6) \nfrom fractions import Fraction\ndef array_int():\n    return [int(i) for i in sys.stdin.readline().split()]\ndef vary(arrber_of_variables):\n    if arrber_of_variables==1:\n        return int(sys.stdin.readline())\n    if arrber_of_variables>=2:\n        return map(int,sys.stdin.readline().split()) \ndef makedict(var):\n    return dict(Counter(var))\ndef gcd2(a,b):\n    if min(a,b)==0:\n        return 0\n    else:\n        return math.gcd(a,b)\nclass SegmentTree(object):\n\n\tdef __init__(self, nums):\n\t\tself.l = len(nums)\n\t\tself.tree = [0]*self.l + nums\n\t\tfor i in range(self.l - 1, 0, -1):\n\t\t\tself.tree[i] = gcd2(self.tree[2*i],self.tree[2*i+1])\n\t\n\tdef update(self, i, val):\n\t\tn = self.l + i\n\t\tself.tree[n] = val\n\t\twhile n > 1:\n\t\t\tself.tree[n//2] = gcd2(self.tree[n],self.tree[n^1])\n\t\t\tn//=2\n\n\tdef sumRange(self, i, j):\n\t\tm = self.l + i\n\t\tn = self.l + j\n\t\tres = self.tree[m]\n\t\twhile m <= n:\n\t\t\tif m & 1:\n\t\t\t\tres=gcd2(res,self.tree[m])\n\t\t\t\tm += 1\n\t\t\tm >>= 1\n\t\t\tif n & 1 ==0:\n\t\t\t\tres=gcd2(res,self.tree[n])\n\t\t\t\tn -= 1\n\t\t\tn >>= 1\n\t\treturn res\ntestcases=vary(1)\nfor _ in range(testcases):\n    n=vary(1)\n    num=array_int()\n    if n==1:\n        print(1)\n    else:\n        diff=[]\n        for i in range(n-1):\n            diff.append(abs(num[i]-num[i+1]))\n        pt=SegmentTree(diff)\n        # print(diff)\n        # print(pt.tree)\n        # print(pt.sumRange(0,1))\n        l = 0\n        r = 0\n        ans=1\n        while(r < n-1):\n            if(diff[r] == 1):\n                r+=1\n                l = r\n                continue\n            if(pt.sumRange(l, r) > 1):\n                ans = max(r-l+2,ans)\n                r+=1\n            else:\n                l+=1\n        print(ans)\n"
        },
        {
            "language": 3,
            "solution": "import io\nimport os\n\nfrom math import gcd\nfrom collections import namedtuple\n\nStackEntry = namedtuple(\"StackEntry\", (\"value\", \"gcd\"))\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\nclass GCDQueue:\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n\n    def gcd(self):\n        if self.s1 and self.s2:\n            return gcd(self.s1[-1].gcd, self.s2[-1].gcd)\n        elif self.s1:\n            return self.s1[-1].gcd\n        elif self.s2:\n            return self.s2[-1].gcd\n        else:\n            return 0\n\n    def push(self, val):\n        g = gcd(val, self.s1[-1].gcd) if self.s1 else val\n        self.s1.append(StackEntry(val, g))\n\n    def pop(self):\n        if not self.s2:\n            while self.s1:\n                el = self.s1.pop().value\n                g = gcd(el, self.s2[-1].gcd) if self.s2 else el\n                self.s2.append(StackEntry(el, g))\n\n        return self.s2.pop()\n\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = [abs(x - y) for x, y in zip(a, a[1:])]\n\n    if n == 1:\n        print(1)\n        return\n\n    m = 0\n    q = GCDQueue()\n    l = r = 0\n    while l < n - 1:\n        while r < n - 1 and gcd(q.gcd(), d[r]) != 1:\n            q.push(d[r])\n            r += 1\n            m = max(m, r - l)\n        if r == n - 1:\n            break\n        q.push(d[r])\n        r += 1\n        while q.gcd() == 1:\n            q.pop()\n            l += 1\n\n    print(m + 1)\n\n\nt = int(input())\n\nfor _ in range(t):\n    solve()\n"
        },
        {
            "language": 4,
            "solution": "//created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class D\n{\n    private static long _gcd(long a, long b) {return a==0?b:_gcd(b%a,a);}\n    static class SparseTable\n    {\n        int pow[], log[], type;\n        long[][] table;\n\n        SparseTable(long[] a, int type) //type=-1 for min, 1 for max\n        {\n            log=new int[a.length+1]; computeLog(a.length); this.type=type;\n            pow=new int[log[a.length]+1]; computePow(log[a.length]);\n            table=new long[log[a.length]+1][a.length]; build(a);\n        }\n        void computeLog(int N){log[1]=0;for(int i=2;i<=N;i++) log[i]=log[i>>1]+1;}\n        void computePow(int lim){pow[0]=1;for(int i=1;i<=lim;i++) pow[i]=pow[i-1]<<1;}\n        long func(long a, long b){return _gcd(a,b);}\n        void build(long[] a)\n        {\n            for(int i=0;i<a.length;i++) table[0][i]=a[i];\n            for(int i=1;i<=log[a.length];i++)\n                for(int j=0;j+pow[i]<=a.length;j++)\n                    table[i][j]=func(table[i-1][j],table[i-1][j+pow[i-1]]);\n        }\n        long query(int l, int r)\n        {\n            int k=log[r-l+1];\n            return func(table[k][l],table[k][r-pow[k]+1]);\n        }\n    }\n    public static void main(String[] args) throws Exception\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N;\n\n        int T=Integer.parseInt(br.readLine().trim());\n        StringBuilder sb=new StringBuilder();\n\n        while (T-->0)\n        {\n            N=Integer.parseInt(br.readLine().trim());\n            String[] s=br.readLine().trim().split(\" \");\n            long[] a=new long[N];\n            for(i=0;i<N;i++) a[i]=Long.parseLong(s[i]);\n\n            if(N==1)\n            {\n                sb.append(1).append(\"\\n\");\n                continue;\n            }\n\n            int max=0;\n            long[] b=new long[N-1];\n            for(i=1;i<N;i++) b[i-1]=Math.abs(a[i]-a[i-1]);\n\n            SparseTable ST=new SparseTable(b,-1);\n\n            for(i=0;i<b.length;i++)\n            {\n                int l=i,r=b.length-1,mid;\n                while (l<=r)\n                {\n                    mid=(l+r)/2;\n                    long g=ST.query(i,mid);\n\n                    if(g>1)\n                    {\n                        max=Math.max(max,mid-i+1);\n                        l=mid+1;\n                    }\n                    else r=mid-1;\n                }\n            }\n\n            sb.append(max+1).append(\"\\n\");\n        }\n        System.out.println(sb);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  if (n == 1) {\n    cout << \"1\\n\";\n    return;\n  }\n  vector<long long> difs(n - 1);\n  for (int i = 0; i < n - 1; i++) difs[i] = abs(a[i + 1] - a[i]);\n  vector<long long> cj(n);\n  vector<long long> fj(n);\n  cj[n - 1] = 0;\n  fj[n - 1] = 1;\n  long long res = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (gcd(difs[i], fj[i + 1]) > 1) {\n      cj[i] = cj[i + 1] + 1;\n      fj[i] = gcd(difs[i], fj[i + 1]);\n    } else {\n      cj[i] = int(difs[i] > 1ll);\n      fj[i] = difs[i];\n      for (int k = 1; k < cj[i + 1]; k++) {\n        if (gcd(fj[i], difs[i + k]) > 1) {\n          cj[i]++;\n          fj[i] = gcd(fj[i], difs[i + k]);\n        } else\n          break;\n      }\n    }\n    res = max(res, cj[i]);\n  }\n  cout << res + 1 << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int tst;\n  cin >> tst;\n  while (tst--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Akshay Mishra\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        DIntegersHaveFriends solver = new DIntegersHaveFriends();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DIntegersHaveFriends {\n        public static long seg[];\n        public static long arr[];\n\n        public static long gcd(long a, long b) {\n            if (a == 0)\n                return b;\n            return gcd(b % a, a);\n        }\n\n        public static long const_seg(int node, int l, int r) {\n            if (l == r) {\n                return seg[node] = arr[l];\n            } else {\n                int mid = (l + r) / 2;\n                return seg[node] = gcd(const_seg(2 * node, l, mid), const_seg(2 * node + 1, mid + 1, r));\n            }\n        }\n\n        public static long query(int node, int l, int r, int x, int y) {\n            if (x <= l && r <= y) {\n                return seg[node];\n            }\n            else if (r < x || y < l) {\n                return 0l;\n            } else {\n                int mid = (l + r) / 2;\n                return gcd(query(2 * node, l, mid, x, y), query(2 * node + 1, mid + 1, r, x, y));\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int test = in.nextInt();\n            while (test-- > 0) {\n                int n = in.nextInt();\n                long array[] = new long[n];\n                for (int i = 0; i < n; i++) {\n                    array[i] = in.nextLong();\n                }\n                if (n == 1) {\n                    out.println(1);\n                    continue;\n                }\n                long diff[] = new long[n - 1];\n                for (int i = 0; i < n - 1; i++) {\n                    diff[i] = Math.abs(array[i] - array[i + 1]);\n                }\n                arr = diff;\n                seg = new long[4 * n + 1];\n                const_seg(1, 0, n - 2);\n                int ans = 1,i = 0, j = 0;\n                while (i + ans - 1 < n - 1) {\n                    long temp_ans = query(1, 0, n - 2, i, j);\n                    if (temp_ans >= 2) {\n                        ans = Math.max(ans, j - i + 2);\n                    }\n                    if (j < n - 2 && temp_ans >= 2) {\n                        j++;\n                    } else {\n                        i++;\n                        if (i == j + 1) {\n                            j++;\n                        }\n                    }\n                }\n                out.println(ans);\n            }\n        }\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while y>1:\n            x, y=y, x%y\n        if y==1:\n            return 1\n        else:        \n            return x\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2                                    \n\n #   total=bmax\n #   c=int(0.5+math.log2(bmax))\n #   k=0\n #   while k+total<n:\n #       if St[k][c]!=1:\n #           start=total+1\n #           end=min(n-k-1, bmax*2-1)\n #           while start<=end:\n #               j=(start+end)//2\n #               if HCF(St[k][c], St[k+j-2**c][c])!=1:\n #                   total=j\n #                   start=j+1\n #               else:\n #                   end=j-1    \n #       k+=1\n\n    def possible_group(x, y):\n        c=b[x]\n        for i in range(x+1, y):\n            c=HCF(c, b[i])\n            if c==1:\n                return False\n        return True        \n\n    total=bmax\n    start=bmax+1\n    end=min(n-1, bmax*2-1)\n    c=int(0.5+math.log2(bmax))\n    startk=0\n    while start<=end:\n        j=(start+end)//2\n        for k in range(startk, n-j):            \n            if HCF(St[k][c], St[k+j-2**c][c])!=1:\n                total=j\n                start=j+1\n                startk=k\n                break\n        if start<=j:\n            end=j-1\n            \n    \n    print(total+1)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\ninline long long ab(long long x) { return x < 0 ? -x : x; }\ninline long long gcd(long long a, long long b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nlong long a[N], dt[N];\nlong long g[N][21];\nint lg[N], n;\nvoid init() {\n  for (int i = 2; i < N; ++i) lg[i] = lg[i >> 1] + 1;\n}\nvoid st() {\n  for (int i = 1; i <= n; ++i) g[i][0] = a[i];\n  for (int k = 1; k <= lg[n]; ++k) {\n    for (int i = 1; i + (1 << k) - 1 <= n; ++i) {\n      g[i][k] = gcd(g[i][k - 1], g[i + (1 << k - 1)][k - 1]);\n    }\n  }\n}\nlong long q(int l, int r) {\n  int k = lg[r - l + 1];\n  return gcd(g[l][k], g[r - (1 << k) + 1][k]);\n}\nbool qry(int x) {\n  if (x <= 0) return 1;\n  for (int i = 2; i + x - 1 <= n; ++i)\n    if (q(i, i + x - 1) != 1) return 1;\n  return 0;\n}\nint main() {\n  init();\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int _;\n  cin >> _;\n  while (_--) {\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    for (int i = n; i; --i) a[i] = ab(a[i] - a[i - 1]);\n    st();\n    int l = 0, r = n - 1, mid;\n    while (l != r) {\n      mid = l + r + 1 >> 1;\n      if (qry(mid))\n        l = mid;\n      else\n        r = mid - 1;\n    }\n    cout << l + 1 << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n#######################################\nfrom math import gcd\nclass RangeQuery:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n \n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n \n    def __getitem__(self, idx):\n        return self._data[0][idx]\nfor t in range(int(input())):\n    n=int(input())\n    l1=list(map(int,input().split()))\n    if n==1:\n        print(1)\n        continue\n    l=[]\n    for i in range(n-1):\n        l.append(abs(l1[i+1]-l1[i]))\n    r=RangeQuery(l,gcd)\n    ans=1\n    i=0\n    j=1\n    while i<n-1 and j<n:\n        g=r.query(i,j)\n        if g>1:\n            while g>1:\n                j+=1\n                if j==n:\n                    break\n                g=r.query(i,j)\n            ans=max(ans,j-i)\n            i+=1\n        else:\n            i+=1\n            if j==i:\n                j+=1\n    print(ans)\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    \n    mod=1000000007\n    # mod=998244353\n    # nCr =  make_nCr_mod()\n    \n    tc=ri()\n    for _ in range(tc):\n        n=ri()\n        a=[0]+ria()\n        b=[0]*(n+1)\n        \n        for i in range(1,n+1):\n            b[i]=a[i]-a[i-1]\n        \n        Table=SparseTable(b,gcd)\n        \n        l,r=2,n\n        ans=1\n        \n        while l<=r:\n            mid=(l+r)//2\n            flag=False\n            for i in range(1,n-mid+2):\n                left,right=i+1,i+mid-1\n                val=Table.query(left,right)\n                if abs(val)>1 or val==0:\n                    flag=True\n                    break\n            if flag:\n                ans=mid\n                l= mid +1\n            else:\n                r= mid -1\n        wi(ans)\n        \n        \n\ndef rant():\n    # RANT BEGINS-\n    # \n    # Did you look at the constraints dummy? Read problem again carefully understand it correctly\n    # Are base cases correct n=0,n=1,n=N or string is all 0 or all 1?\n    # \n    # 1.Greedy? What matters what doesnt? Is my claim correct? \n    #   Does my implementation correctly implements the greedy i thought of? \n    #   Dictionary? keep a count of values if constraint on something is low(like only alphabets(26) count)? \n    # \n    # 2.DP? Think about state's ranges maybe one of the states have lesser possible values than it may look like? \n    #   Obviously think about order of evaluation\n    # \n    # 3.Binary Search?(Monotonic? any one directed order in which we have to perform something?)\n    # \n    # 4.Graph?DSU?Edge property or Vertex property Read carefully? Bipartitenes Property??? Cycle Property??? \n    #   Hidden but dependency ordering of values(in 1d array or 2d Table/Array) is that of a graph???\n    # \n    # 5.Number Theory?(GCD subtraction?)\n    # \n    # 6.Bruteforce?(Redundant part of N which may not give answer?Constraints?)\n    # \n    # 7.Range Queries?\n    # \n    # 8.Any Equivalency?(We have A and B and have to do \n    #   something between them maybe difficult if there was A~C and C~B then A~B\n    #   C could be max or min or some other thing)\n    # \n    # 9.Reverse Engineering?(From Answer to quesn or last step to first step)\n    #\n    # 10.Constructive? Mod? Bruteforce for smaller case and analyze patterns?\n    #\n    # 11.String? Constructive Greedy example- \n    #   Bracket sequence make first part unknown open and second part unknown closed \n    #   Remember always only n//2 open and n//2 closed brackets are there\n    #\n    # 12.Combinatorics?--> (n to i-1 index ways) * (ith index ways) * Ways (for i-1 till 0 index)?\n    #\n    # 13.Look for patterns and dependency of the patterns(maybe only first row or column matters to construct other rows and columns)\n    #   for smaller cases maybe make bruteforce solution and analyze the patterns\n    # \n    # RANT ENDS\n    return \"AAAAAAAAAAAAAAAAARRRGHHHHHHHHHHHHHHHHHHHHHHHH\"\n    \ndef SieveOfEratosthenes(limit):\n    \"\"\"Returns all primes not greater than limit.\"\"\"\n    isPrime = [True]*(limit+1)\n    isPrime[0] = isPrime[1] = False\n    primes = []\n    for i in range(2, limit+1):\n        if not isPrime[i]:continue\n        primes += [i]\n        for j in range(i*i, limit+1, i):\n            isPrime[j] = False\n    return primes\n\ndef gcd(x, y):\n    \"\"\"greatest common divisor of x and y\"\"\"\n    while y:\n        x, y = y, x % y\n    return x\n\ndef memodict(f):\n    \"\"\"memoization decorator for a function taking a single argument\"\"\"\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n\n    return memodict().__getitem__\n\ndef pollard_rho(n):\n    \"\"\"returns a random factor of n\"\"\"\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n\n    s = ((n - 1) & (1 - n)).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = (p * p) % n\n            if p == 1:\n                return gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                x, y = i, (i * i + 1) % n\n                f = gcd(abs(x - y), n)\n                while f == 1:\n                    x, y = (x * x + 1) % n, (y * y + 1) % n\n                    y = (y * y + 1) % n\n                    f = gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n\n@memodict\ndef prime_factors(n):\n    \"\"\"returns a Counter of the prime factorization of n\"\"\"\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n\ndef distinct_factors(n):\n    \"\"\"returns a list of all distinct factors of n\"\"\"\n    factors = [1]\n    for p, exp in prime_factors(n).items():\n        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]\n    return factors\n\ndef all_factors(n):\n    \"\"\"returns a sorted list of all distinct factors of n\"\"\"\n    small, large = [], []\n    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):\n        if not n % i:\n            small.append(i)\n            large.append(n // i)\n    if small[-1] == large[-1]:\n        large.pop()\n    large.reverse()\n    small.extend(large)\n    return small\n\ndef make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):\n    max_n = min(max_n, mod - 1)\n\n    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)\n    fact[0] = 1\n    for i in range(max_n):\n        fact[i + 1] = fact[i] * (i + 1) % mod\n\n    inv_fact[-1] = pow(fact[-1], mod - 2, mod)\n    for i in reversed(range(max_n)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def nCr_mod(n, r):\n        res = 1\n        while n or r:\n            a, b = n % mod, r % mod\n            if a < b:\n                return 0\n            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n            n //= mod\n            r //= mod\n        return res\n\n    return nCr_mod\n\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = [*range(n+1)]\n        self.size = [1]*(n+1)\n        self.min, self.max = [*range(n+1)], [*range(n+1)]\n        self.count = n\n\n    def get(self, a):\n        \"\"\"Returns the identifier (parent) of the set to which a belongs to!\"\"\"\n        if self.parent[a] == a:\n            return a\n        x = a\n        while a != self.parent[a]:\n            a = self.parent[a]\n        while x != self.parent[x]:\n            self.parent[x], x = a, self.parent[x]\n        return a\n\n    def union(self, a, b):\n        \"\"\"Join two sets that contain a and b!\"\"\"\n        a, b = self.get(a), self.get(b)\n        if a != b:\n            if self.size[a] > self.size[b]:\n                a, b = b, a\n            self.parent[a] = b\n            self.size[b] += self.size[a]\n            self.min[b] = min(self.min[a], self.min[b])\n            self.max[b] = max(self.max[a], self.max[b])\n            self.count -= 1\n\n    def count_sets(self):\n        \"\"\"Returns the number of disjoint sets!\"\"\"\n        return self.count\n    \nclass SegTree:\n    \n    def __init__(self, n):\n        self.N = 1 << n.bit_length()\n        self.tree = [0] * (self.N<<1)\n    \n    def update(self, i, j, v):\n        i += self.N\n        j += self.N\n        while i <= j:\n            if i%2==1: self.tree[i] += v\n            if j%2==0: self.tree[j] += v\n            i, j = (i+1) >> 1, (j-1) >> 1\n    \n    def query(self, i):\n        v = 0\n        i += self.N\n        while i > 0:\n            v += self.tree[i]\n            i >>= 1\n        return v\n\nclass SparseTable:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)]\"\"\"\n        depth = (stop + 1 - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop + 1 - (1 << depth)])\n\n    def __getitem__(self, idx):\n        return self._data[0][idx]\n              \nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n \n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n \n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n \n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n \n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n \n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n \n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n \n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n \n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n \n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n \n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n \n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n \n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n \n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n \n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n \n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n \n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n \n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n \n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n \n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n \n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n \n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\nimport sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom math import log2\nfrom bisect import bisect_left,bisect_right\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n# sys.setrecursionlimit(111111) \nINF=999999999999999999999999\nalphabets=\"abcdefghijklmnopqrstuvwxyz\"\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    main()\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    "
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Coder {\n  static int n,m;\n  static long na[];\n  static long a[];\n  static long st[];\n  static StringBuffer str=new StringBuffer();\n  \n  static long gcd(long a, long b){\n      if(b==0) return a;\n      return gcd(b, a%b);\n  }\n  static long constructST(int ss, int se, int si){\n      if(ss==se){\n          return st[si]=na[ss];\n      }\n      int mid=ss+(se-ss)/2;\n      return st[si]=gcd(constructST(ss, mid, 2*si+1), constructST(mid+1, se, 2*si+2));\n  }\n  \n  static long findGcd(int ss, int se, int qs, int qe, int si){\n      if(qs<=ss && qe>=se) return st[si];\n      if(ss>qe || se<qs) return 0;\n      int mid=ss+(se-ss)/2;\n      return gcd(findGcd(ss, mid, qs, qe, 2*si+1), findGcd(mid+1, se, qs, qe, 2*si+2));\n  }\n//   static boolean isPoss(int m){\n//       for(int i=0;i+m-1<n-1;i++){\n//           int l=i;\n//           int r=i+m-1;\n//           long p = findGcd(0, n-2, l, r, 0);\n//           if(p>1) {\n//               return true;\n//           }\n//       }\n//       return false;\n//   }\n  static void solve(){\n      if(n==1){\n          str.append(n).append(\"\\n\");return;\n      }\n      na=new long[n-1];\n      for(int i=1;i<n;i++){\n          na[i-1]=Math.abs(a[i]-a[i-1]);\n      }\n      int x=(int)Math.ceil(Math.log(n-1)/Math.log(2));\n      int sz=2*(int)Math.pow(2, x)-1;\n      st=new long[sz];\n      constructST(0, n-2, 0);\n      int l=0,r=0, ans=0;\n      long gc=0;\n      while(l<=r && r<n-1){\n          gc=gcd(na[r], gc);\n          if(gc>1){\n              r++;\n          }else{\n              ans=Math.max(ans, r-l);\n              l++;\n              r++;\n              if(r<n-1){\n                  gc=findGcd(0, n-2, l, r, 0);\n              }\n          }\n      }\n      ans=Math.max(ans, r-l);\n    //   int l=1, r=n-1;\n    //   int ans=0;\n      \n    //   while(l<=r){\n    //       int mid=l+(r-l)/2;\n    //       if(isPoss(mid)){\n              \n    //           ans=mid;\n    //           l=mid+1;\n    //       }else r=mid-1;\n    //   }\n      str.append((ans+1)).append(\"\\n\");\n  }\n\n  public static void main(String[] args) throws java.lang.Exception {\n    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n    int q = Integer.parseInt(bf.readLine().trim());\n    while(q-->0) {\n        n=Integer.parseInt(bf.readLine().trim());\n        a=new long[n];\n        String s[]=bf.readLine().trim().split(\"\\\\s+\");\n        for(int i=0;i<n;i++) a[i]=Long.parseLong(s[i]);\n        solve();\n    }\n    System.out.print(str);\n  }\n}"
        },
        {
            "language": 3,
            "solution": "'''\n................ ::...:... .....................  :. .:...... ........\n...............  ::....: :  ..      .......:::::::  .:......:  .......\n............... .:.....:. =.........           .=  :.......:. ........\n............... ::..::....                    .:  :.......:=  ........\n............... :::::                        .:  ::......:::..  ......\n..............  ::+.           :==.         :.  :::......::    .  ....\n..  .......... ::-:.:=-:.      #%%*        ..  .::::::..::      . ....\n.............  =::-=*****+=-:. .::.             ..::::.::      .. ....\n............. :=-=************+=:.                  .:::       -  ....\n............ --:=*****************+-:                  .      :. .....\n..........  --:=********=*************=:                      =  .....\n........ .:-:::-+*******-***************+-.                  .-  .....\n...  ..:===-:-=++**+=+**:+-==++=+=+****+++++:                .:  .....\n...     .-+-:+**********:=++++++++++**++*****+-              .:  .....\n...... ..--:-*****+*+++--:++++++++++*-+++++*****-             :   ....\n.....  .-:::=***+++*++--=========++++:-=++++=++**+:  .   .....:.  ....\n.... .----=:+++*+++++-  :--=======+==   .-++::+++*==...........:  ....\n..  ...  :::++++++==.    .--=======:-...  .:-  -++=*+:.........-  ....\n        .-:-+++++=--===:::.=--====-.-==++*+++-.  ==+**:........=  ....\n       .-::-++=+=+*=-#%#*+...:----- :.-%##+*+-*-.-=++*=........=  ....\n      :----=-====.:. %####+    .:--   +****## ..--+++*-....... =  ....\n           :.:+===.  :*++=+           .=-=-+: :-==++++....... .-  ....\n       .  ..:-+-=::.. .=-:             .:::. ..:-==+=.......  -.  ....\n........  :.:::=+ .......             ...... .::::::......  ::.   ....\n........  : ::::*-.......     .... .    ...    .::......::::     .....\n ..        :...:::==:.      -.   ...       .-==-...::::.       .......\n             ...-:......::.    .......:-=+*=:....-.        ...........\n     ......... :.         :==-.       :-::.........  .................\n.............  :            .           ::::.......:  ........        \n.........     :                        ..:.........:-                 \n              :                     ..:..........:..::                \n              ..                 .................:..-                \n               -              ....:...............:.. :               \n                - ...:.:..........--....................              \n                 -...   :.......::.   .::............. :                        \n'''\n\n\nimport os,sys,math \nfrom io import BytesIO, IOBase\nfrom collections import defaultdict,deque,OrderedDict\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\ndef I():return (int(input()))\ndef In():return(map(int,input().split()))\ndef ln():return list(map(int,input().split()))\ndef Sn():return input().strip()\nBUFSIZE = 8192\n#complete the main function with number of test cases to complete greater than x\ndef find_gt(a, x):\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:            \n        return len(a)\n\nclass Segmenttreemx():\n    st,n=[],0\n    def __init__(self,n,l):\n        self.st=[0]*(2*n)\n        self.n=n\n        for i in range(n):\n            self.st[i+n]=l[i]\n        for i in range(n-1,0,-1):\n            self.st[i]=math.gcd(self.st[i<<1],self.st[i<<1 | 1])\n\n    def update(self,p,val):\n        self.st[p+self.n]=val\n        p+=self.n\n        while p>1:\n            self.st[p>>1]=max( self.st[p],self.st[p^1])\n            p>>=1\n            \n    def query(self,l,r):\n        l,r=l+self.n,r+self.n\n        res=self.st[l]\n        while l<r:\n            if l&1:\n                res=math.gcd(res,self.st[l])\n                l+=1\n            if r&1:\n                r-=1\n                res=math.gcd(res,self.st[r])\n            l>>=1\n            r>>=1\n        return res\n\ndef solve():\n    n=I()\n    l=list(In())\n    if n==1:\n        print(1)\n        return\n    \n    diff=[abs(l[i+1]-l[i]) for i in range(n-1)]\n    Sg=Segmenttreemx(len(diff),diff)\n    j,ans =0,1\n    for i in range(n-1):\n        while j<=i and Sg.query(j,i+1)==1:\n            j+=1\n        ans=max(ans,i-j+2)\n    print(ans)\n\n    pass\n\n\n\ndef main():\n    T=I()\n    for i in range(T):\n        solve()\n        \nM = 998244353\nP = 1000000007\n \n\n\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> fourDirection = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\nvector<vector<int>> eightDirection = {{-1, 0}, {-1, 1}, {0, 1},  {1, 1},\n                                      {1, 0},  {1, -1}, {0, -1}, {-1, -1}};\nlong long int mod(long long int n, long long int M) { return (n % M + M) % M; }\nlong long int modAdd(long long int a, long long int b, long long int M) {\n  return mod(mod(a, M) + mod(b, M), M);\n}\nlong long int modMul(long long int a, long long int b, long long int M) {\n  return mod(mod(a, M) * mod(b, M), M);\n}\nlong long int modMinus(long long int a, long long int b, long long int M) {\n  return mod(mod(a, M) - mod(b, M), M);\n}\nlong long int modpow(long long int x, long long int n, long long int M) {\n  if (n == 0) return 1 % M;\n  if (n == 1) return x % M;\n  long long int u = modpow(x, n / 2, M);\n  u = modMul(u, u, M);\n  if (n % 2) u = modMul(u, x, M);\n  return u;\n}\nlong long int gcd(long long int a, long long int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long int extendedGcd(long long int a, long long int b, long long int &x,\n                          long long int &y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long int x1, y1;\n  long long int g = extendedGcd(b, a % b, x1, y1);\n  x = y1;\n  y = x1 - y1 * (a / b);\n  return g;\n}\nlong long int modInverse(long long int a, long long int m) {\n  long long int g, x, y;\n  g = extendedGcd(a, m, x, y);\n  if (g == 1) {\n    return (x % m + m) % m;\n  }\n  return -1;\n}\nlong long int crt(vector<long long int> &P, vector<long long int> &R) {\n  int n = P.size();\n  vector<long long int> X(n);\n  long long int productOfAllP = 1;\n  for (int i = 0; i < n; i++) productOfAllP *= P[i];\n  for (int i = 0; i < n; i++) {\n    X[i] = R[i];\n    long long int mulOfInverse = 1;\n    long long int mul = 1;\n    for (int j = 0; j < i; j++) {\n      mulOfInverse = modMul(mulOfInverse, modInverse(P[j], P[i]), P[i]);\n      X[i] = modMinus(X[i], modMul(X[j], mul, P[i]), P[i]);\n      mul = modMul(mul, P[j], P[i]);\n    }\n    X[i] = modMul(X[i], mulOfInverse, P[i]);\n  }\n  long long int finalX = 0;\n  long long int mul = 1;\n  for (int i = 0; i < n; i++) {\n    finalX = modAdd(finalX, modMul(X[i], mul, productOfAllP), productOfAllP);\n    mul = modMul(mul, P[i], productOfAllP);\n  }\n  return finalX;\n}\nbool isPrime(long long int n) {\n  for (int i = 2; i * i <= n; i++)\n    if (n % i == 0) return false;\n  return true;\n}\nint getParent(vector<int> &parent, int s) {\n  if (parent[s] == s) return s;\n  return getParent(parent, parent[s]);\n}\nvector<int> primeNumbers;\nvoid sieve() {\n  int limit = 1e5;\n  vector<bool> prime(limit, true);\n  for (long long int i = 2; i < limit; i++) {\n    if (prime[i]) {\n      primeNumbers.push_back(i);\n      for (long long int j = i * i; j < limit; j = j + i) prime[j] = false;\n    }\n  }\n}\nbool insideGrid(int x, int y, int n, int m) {\n  if (x >= 0 && x < n && y >= 0 && y < m) return true;\n  return false;\n}\nvector<long long int> getMemAllocated(int n) {\n  int ans = 1;\n  while (n > ans) ans *= 2;\n  ans = ans * 2 - 1;\n  vector<long long int> result(ans, 0);\n  return result;\n}\nlong long int buildTree(vector<long long int> &tree,\n                        vector<long long int> &data, int root, int start,\n                        int end) {\n  if (start != end) {\n    int mid = (start + end) / 2;\n    tree[root] = gcd(buildTree(tree, data, root * 2 + 1, start, mid),\n                     buildTree(tree, data, root * 2 + 2, mid + 1, end));\n  } else\n    tree[root] = data[start];\n  return tree[root];\n}\nlong long int rangeQuery(vector<long long int> &tree, int root, int start,\n                         int end, int rS, int rE) {\n  if (start >= rS && end <= rE) return tree[root];\n  if (start > rE || end < rS) return -1;\n  int mid = (start + end) / 2;\n  long long int v1 = rangeQuery(tree, root * 2 + 1, start, mid, rS, rE);\n  long long int v2 = rangeQuery(tree, root * 2 + 2, mid + 1, end, rS, rE);\n  if (v1 == v2) return v1;\n  if (v1 == -1) return v2;\n  if (v2 == -1) return v1;\n  return gcd(v1, v2);\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<long long int> data(n);\n  for (int i = 0; i < n; i++) cin >> data[i];\n  if (n == 1) {\n    cout << 1 << \"\\n\";\n    return;\n  }\n  vector<long long int> dif;\n  for (int i = 1; i < n; i++) dif.push_back(abs(data[i] - data[i - 1]));\n  vector<long long int> T = getMemAllocated(dif.size());\n  buildTree(T, dif, 0, 0, dif.size() - 1);\n  int globalAns = 0;\n  for (int i = 0; i < dif.size(); i++) {\n    int start = i;\n    int end = dif.size() - 1;\n    int qAns = i;\n    bool possible = false;\n    while (start <= end) {\n      int m = (start + end) / 2;\n      long long int g = rangeQuery(T, 0, 0, dif.size() - 1, i, m);\n      if (g == 1) {\n        end = m - 1;\n      } else {\n        possible = true;\n        qAns = m;\n        start = m + 1;\n      }\n    }\n    if (possible) {\n      globalAns = max(globalAns, qAns - i + 1);\n    }\n  }\n  cout << globalAns + 1 << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import log2, gcd, ceil\nfrom pprint import pprint\nclass SparseTable:\n    def __init__(self, arr, logs) -> None:\n        self.n = len(arr)\n        self.logs = logs\n        l = self.logs[self.n]\n        self.mat = [arr]\n        for i in range(1,l+1):\n            j = 0\n            self.mat.append([0]*(self.n-(1<<i)+1))\n            while (j+(1<<i))<=self.n:\n                self.mat[i][j] = gcd(self.mat[i-1][j], self.mat[i-1][j+(1<<(i-1))]) \n                j+=1\n\n    def query(self,l,r):\n        n = r-l+1\n        l2 = self.logs[n]\n        return gcd(self.mat[l2][l], self.mat[l2][r-(1<<l2)+1])\n\nif __name__ == \"__main__\":\n    logs = [-1,0,1]\n    for i in range(3, 2*pow(10,5)+1):\n        logs.append(logs[i//2]+1)\n    for t in range(int(input())):\n        n = int(input())\n        b = list(map(int,input().split()))\n        a = []\n        for i in range(1,len(b)):\n            a.append(b[i]-b[i-1])\n        st = SparseTable(a,logs)\n        j = 0\n        ans = 1\n        for i in range(n-1):\n            while j<=i and st.query(j,i) == 1:\n                j+=1\n            ans = max(ans,i-j+2)\n        print(ans)\n\n\n"
        },
        {
            "language": 1,
            "solution": "import sys\nimport os\nfrom io import BytesIO\nfrom fractions import gcd\n\n# pypy2\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n\nf = sys.stdin\n\nline = lambda: f.readline().strip('\\r\\n').split()\n\ndef write(w):\n    sys.stdout.write(w)\n    sys.stdout.write(\"\\n\")\n\ndef solve():\n    \n    if N == 1:\n        return str(1)\n    \n    c = 1\n    res = 1\n    \n    d = [0] * (N-1)\n    for i in range(N-1):\n        f = A[i]\n        s = A[i+1]\n        d[i] = abs(f-s)\n    \n    g = 0\n    j = -1\n    for i in range(N-1):\n        g = gcd(d[i], g)\n        if g != 1:\n            c = i - j + 1\n        else:\n            nxt = 0\n            j = i\n            while j >= 0:\n                g = nxt\n                nxt = gcd(nxt, d[j])\n                if nxt == 1:\n                    break\n                j -= 1\n            c = i - j + 1\n\n        if c > res:\n            res = c\n            \n    return str(res)\n\nT = int(line()[0])\nfor test in range(1,T+1):\n    N = int(line()[0])\n    A = list(map(int, line()))\n    \n    write(solve())\n    \nf.close()"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class CF1549D extends PrintWriter {\n\tCF1549D() { super(System.out); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1549D o = new CF1549D(); o.main(); o.flush();\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tlong[] st; int n_;\n\tvoid build(long[] aa, int n) {\n\t\tn_ = n;\n\t\tst = new long[n_ * 2];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[n_ + i] = aa[i];\n\t\tfor (int i = n_ - 1; i > 0; i--)\n\t\t\tst[i] = gcd(st[i << 1], st[i << 1 | 1]);\n\t}\n\tlong query(int l, int r) {\n\t\tlong x = 0;\n\t\tfor (l += n_, r += n_; l <= r; l >>= 1, r >>= 1) {\n\t\t\tif ((l & 1) == 1)\n\t\t\t\tx = gcd(x, st[l++]);\n\t\t\tif ((r & 1) == 0)\n\t\t\t\tx = gcd(x, st[r--]);\n\t\t}\n\t\treturn x;\n\t}\n\tvoid main() {\n\t\tint t = sc.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tlong[] aa = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\taa[i] = sc.nextLong();\n\t\t\tn--;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\taa[i] = Math.abs(aa[i + 1] - aa[i]);\n\t\t\tbuild(aa, n);\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0, j = 0; i < n; i++) {\n\t\t\t\tif (j < i)\n\t\t\t\t\tj = i;\n\t\t\t\tlong d = i < j ? query(i, j - 1) : 0, d_;\n\t\t\t\twhile (j < n && (d_ = gcd(d, aa[j])) != 1) {\n\t\t\t\t\td = d_;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, j - i);\n\t\t\t}\n\t\t\tprintln(ans + 1);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.AbstractMap;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.*;\nimport java.io.*;\n\n// Java Template Pramod Hosahalli...\n@SuppressWarnings(\"unused\")\npublic class Solution {\n\n\tstatic FastReader in = new FastReader();\n\t//static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tstatic int mod = 1000000007;\n\n\tprivate static void go() throws Exception{\n\t\tint n = in.ni();\n\t\tlong[] a = new long[n];\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = in.nl();\n\t\t}\n\n\t\tif(n == 1){\n\t\t\tprint(1, \"1\");\n\t\t\treturn;\n\t\t}\n\t\tlong[] b = new long[n-1];\n\t\tfor(int i = 0; i < b.length; i++) b[i] = Math.abs(a[i] - a[i+1]);\n\t\tlong[][] f = SparseTable.precompute(b);\n\n\t\tint maxima = 1;\n\t\tfor(int j = 0; j < b.length; j++){\n\t\t\tif(f[0][j] == 1) continue;\n\t\t\tlong g = -1;\n\t\t\tint curr = j;\n\t\t\tfor(int p = f.length-1; p >= 0; p--){\n\t\t\t\tif(curr == b.length)break;\n\t\t\t\tif(f[p][curr] > 1 && (g == -1 || gcd(g, f[p][curr]) > 1)){\n\t\t\t\t\tif(g == -1) g = f[p][curr];\n\t\t\t\t\telse g = gcd(g, f[p][curr]);\n\t\t\t\t\tcurr = curr + (1 << p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxima = Math.max(maxima, curr - j + 1);\n\t\t}\n\t\tprint(1, maxima + \"\");\n    }\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint t = in.ni();\n        //int t = pi(in.readLine());\n\t\tfor(int _i = 1; _i <= t; _i++){\n\t\t\tgo();\n\t\t}\n\t\tin.close();\n\t}\n\n\tstatic long mul(long a, long b) {\n\t\treturn ((a % mod) * (b % mod)) % mod;\n\t}\n\n\tstatic class FastReader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic FastReader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic FastReader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[64]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n') {\n\t\t\t\t\tif (cnt != 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int ni() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ') {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nl() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nd() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\t}\n\n\tstatic String rl() throws Exception{\n\t\treturn in.readLine();\n\t}\n\n\tstatic int pi(String s) {\n\t\treturn Integer.parseInt(s);\n\t}\n\n\tstatic long pl(String s) {\n\t\treturn Long.parseLong(s);\n\t}\n\n\tstatic void print(int newline, String s) {\n\t\tSystem.out.print(s);\n\t\tif (newline != 0)\n\t\t\tSystem.out.println();\n\t\t// System.out.flush();\n\t}\n\n\tstatic void cprint(int x) {\n\t\tprint(0, \"Case #\" + x + \": \");\n\t}\n\n\t//utility function for gcd\n\tprivate static long gcd(long a, long b)\n\t{\n\t\tif(a == 0 || b == 0)return a + b;\n\t\tif(a > b)return gcd(a % b, b);\n\t\treturn gcd(a, b % a);\n\t}\n\n\t// construct sparse table : for static range queries\n\tstatic class SparseTable{\n\n\t\tstatic long[][] precompute(long[] arr)\n\t\t{\n\t\t\tint n = arr.length;\n\t\t\tint p = (int)((double)Math.log(n) / Math.log(2));\n\t\t\tlong[][] f = new long[p+1][n];\n\n\t\t\tfor(int i = 0; i < n; i++) f[0][i] = arr[i];\n\t\t\tfor(int j = 1; j <= p; j++){\n\t\t\t\tfor(int i = 0; i + (1 << j) - 1 < n; i++){\n\t\t\t\t\tf[j][i] = gcd(f[j-1][i], f[j-1][i + (1 << (j-1))]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn f;\n\t\t}\n\n\t}\n\n}"
        },
        {
            "language": 3,
            "solution": "'''\n\n* Author : Ayushman Chahar #\n* About  : IT Junior       #\n* Insti  : VIT, Vellore    #\n\n'''\n\nimport os\nimport sys\n# from collections import *\n# from itertools import *\nfrom math import gcd, log2\n# from queue import *\n# from heapq import *\n# from bisect import *\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nreadint = lambda: int(sys.stdin.readline().rstrip(\"\\r\\n\"))\nreadints = lambda: map(int, sys.stdin.readline().rstrip(\"\\r\\n\").split())\nreadstr = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nreadstrs = lambda: map(str, sys.stdin.readline().rstrip(\"\\r\\n\").split())\nreadarri = lambda: [int(_) for _ in sys.stdin.readline().rstrip(\"\\r\\n\").split()]\nreadarrs = lambda: [str(_) for _ in sys.stdin.readline().rstrip(\"\\r\\n\").split()]\n\nK = 25\nMAXN = int(2e5) + 1\nst = [[0 for _ in range(K + 1)] for _ in range(MAXN)]\n# lg = [0, 1]\n# for i in range(2, MAXN + 1):\n#     lg.append(lg[i >> 1] + 1)\narr = list()\n\n\ndef sparse(n):\n    global st\n    for j in range(n):\n        st[j][0] = arr[j]\n    for j in range(1, K + 1):\n        for z in range(0, n + 1 - (1 << j)):\n            st[z][j] = gcd(st[z][j - 1], st[z + (1 << (j - 1))][j - 1])\n\n\ndef query(l, r):\n    f = int(log2(r - l + 1))\n    return gcd(st[l][f], st[r - (1 << f) + 1][f])\n\n\ndef solve():\n    global arr\n    n = readint()\n    a = readarri()\n    if (n == 1):\n        print(1)\n        return\n    arr = [0] * (n - 1)\n    for i in range(n - 1):\n        arr[i] = abs(a[i + 1] - a[i])\n    sparse(n - 1)\n    ans = 1\n    ptr = 0\n    for i in range(n - 1):\n        while (ptr <= i and query(ptr, i) == 1):\n            ptr += 1\n        ans = max(ans, i - ptr + 2)\n    print(ans)\n\n\ndef main():\n    t = 1\n    t = readint()\n    for _ in range(t):\n        # print(\"Case #\" + str(_ + 1) + \": \", end=\"\")\n        solve()\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class D\n{\n    static InputReader in=new InputReader(System.in);\n    static OutputWriter out=new OutputWriter(System.out);\n    static StringBuilder sb=new StringBuilder();\n    static int MAX = 4 * 1000000 + 2;\n    static int n;\n    // Main Class Starts Here\n    public static void main(String[] args)throws IOException\n    {\n        // Write your code.\n\n        int t = in();\n        while(t-- > 0){\n            int n = in();\n            long ar[] = lan(n);\n\n            int s = n-1;\n            long a[] = new long[s];\n            for(int i = 0 ;i < s; i++)\n                a[i] = Math.abs(ar[i+1] - ar[i]);\n\n            // sparse table.\n            long sp[][] = new long[s][18];\n            // sp[i][j] = gcd of range a[i, i + (1 << j)]\n\n            // initialize sparse table\n            for(int i =0 ; i < s; i++)\n                sp[i][0] = a[i];\n\n            // construct sparse table\n            for(int j = 1; j <= 17; j++){\n                for(int i = 0; i + (1 << j) < s; i++){\n                    sp[i][j] = gcd(sp[i][j-1], sp[i + (1 << (j-1))][j-1]);\n                }\n            }\n\n            // two pointer.\n            int l = 0;\n            int r = 0;\n            int max = 0;\n            while(r < s){\n                long gcd = sparseQuery(l, r, sp);\n                if(gcd > 1){\n                    max = Math.max(max, (r - l + 1));\n                    r++;\n                }\n                else if(gcd == 1){\n                    if(r == l)\n                        r++;\n                    l++;\n                }\n            }\n            max++;\n            app(max+\"\\n\");\n        }\n        out.printLine(sb);\n        out.close();\n    }\n\n    public static long sparseQuery(int l, int r, long sp[][]){\n        long res = 0L;\n        while(l <= r){\n            if(l == r){\n                res = gcd(res, sp[l][0]);\n                break;\n            }\n            for(int i = 17; i >= 0; i--){\n                int length = l + (1 << i);\n                if(length > r) continue;\n                res = gcd(res, sp[l][i]);\n                l += 1 << i;\n                break;\n            }\n        }\n        return res;\n    }\n\n    static class Query{\n        int l;\n        int r;\n        int index;\n        int answer;\n        public Query(int l, int r, int index){\n            this.l = l;\n            this.r = r;\n            this.index = index;\n        }\n\n        public void setAnswer(int answer){\n            this.answer = answer;\n        }\n\n        @Override\n        public String toString(){\n            return \"(\"+(l+1)+\",\"+(r+1)+\")\";\n        }\n    }\n\n    static class Pair{\n        int x, y;\n        public Pair(int x, int y){\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString(){\n            return \"(\"+x+\",\"+y+\")\";\n        }\n    }\n\n    static class DisjointSet{\n        int parent[];\n        int rank[];\n        int size;\n\n        public DisjointSet(int n){\n            this.parent = new int[n];\n            this.rank = new int[n];\n            this.size = n;\n            for(int i = 0; i < n; i++)\n                parent[i] = i;\n        }\n\n        public int findParent(int x){\n            if(parent[x] != x){\n                return parent[x] = findParent(parent[x]);\n            }\n            return parent[x];\n        }\n\n        public boolean inSameComponents(int x, int y){\n            int parentX = findParent(x);\n            int parentY = findParent(y);\n            return parentX == parentY;\n        }\n\n        public int mergeComponents(int x, int y){\n            int parentX = findParent(x);\n            int parentY = findParent(y);\n            if(parentX == parentY) {\n                return 0; // merge failed as in the same components hence no change in components\n            }\n            if(rank[parentX] < rank[parentY]){\n                parent[parentX] = parentY;\n            }\n            else if(rank[parentX] > rank[parentY]){\n                parent[parentY] = parentX;\n            }\n            else{\n                // merge component of y to x.\n                parent[parentY] = parentX;\n                rank[parentX]++;\n            }\n            return 1; // merge successful - decrease in merge components\n        }\n\n        public int countComponents(){\n            int count = 0;\n            for(int i = 0; i < size; i++)\n                if(parent[i] == i) count++;\n            return count;\n        }\n\n        public TreeMap<Integer, List<Integer>> getComponents(){\n            TreeMap<Integer, List<Integer>> componentMap = new TreeMap<>();\n\n            for(int i = 0; i < size; i++){\n                List<Integer> componentElements = componentMap.getOrDefault(parent[i], new ArrayList<>());\n                componentElements.add(i);\n                componentMap.put(parent[i], componentElements);\n            }\n\n            return componentMap;\n        }\n\n        public Set<Integer> getComponentsWithNode(int x){\n            HashSet<Integer> set = new HashSet<>();\n            int parentX = findParent(x);\n            for(int i = 0; i < n; i++){\n                if(parent[i] == parentX){\n                    set.add(i);\n                }\n            }\n            return set;\n        }\n    }\n\n    // segment tree.\n    static class SegmentTree{\n        int size;\n        List<Integer> st[];\n        int n;\n        public SegmentTree(int a[], int n){\n            int x = (int)Math.ceil((Math.log(n) / Math.log(2)));\n            this.size = (int)Math.pow(2, 2 * x) - 1;\n            st = new ArrayList[size];\n            buildTree(0, n-1, 0, a);\n            this.n = n;\n        }\n\n        public List<Integer> buildTree(int l, int r, int curIndex, int a[]){\n            if(l == r){\n                st[curIndex] =  new ArrayList<>();\n                st[curIndex].add(a[l]);\n                return st[curIndex];\n            }\n            int mid = (l + r) / 2;\n            List<Integer> leftList = buildTree(l, mid, 2 * curIndex + 1, a);\n            List<Integer> rightList = buildTree(mid + 1, r, 2 * curIndex + 2, a);\n            int lastLeftProduct = leftList.get(leftList.size() - 1);\n            int firstRightProduct = rightList.get(0);\n            int gcd = gcd(lastLeftProduct, firstRightProduct);\n            if(gcd > 1){\n                st[curIndex] = new ArrayList<>(leftList);\n                st[curIndex].addAll(rightList);\n            }\n            else{\n                st[curIndex] = new ArrayList<>();\n                for(int i = 0; i < leftList.size() - 1; i++)\n                    st[curIndex].add(leftList.get(i));\n                st[curIndex].add(lastLeftProduct * firstRightProduct);\n                for(int i = 1 ; i < rightList.size(); i++)\n                    st[curIndex].add((rightList.get(i)));\n            }\n            return st[curIndex];\n        }\n\n        public int resolveQuery(int ql, int qr){\n            List<Integer> ans = mergeRanges(0, n-1, ql, qr, 0);\n            return ans.size();\n        }\n\n        public List<Integer> mergeRanges(int l, int r, int ql, int qr, int curIndex){\n            if(l > qr || r < ql) return null;\n            if(ql <= l && qr >= r){\n                return st[curIndex];\n            }\n            int mid = (l + r) / 2;\n            List<Integer> leftList = mergeRanges(l, mid, ql, qr, 2 * curIndex + 1);\n            List<Integer> rightList = mergeRanges(mid + 1, r, ql, qr, 2 * curIndex + 2);\n            if(leftList != null && rightList != null){\n                int lastLeftProduct = leftList.get(leftList.size() - 1);\n                int firstRightProduct = rightList.get(0);\n                int gcd = gcd(lastLeftProduct, firstRightProduct);\n                List<Integer> mergedList = new ArrayList<>();\n                if(gcd > 1){\n                    mergedList.addAll(leftList);\n                    mergedList.addAll(rightList);\n                }\n                else{\n                    for(int i = 0; i < leftList.size() - 1; i++)\n                        mergedList.add(leftList.get(i));\n                    mergedList.add(lastLeftProduct * firstRightProduct);\n                    for(int i = 1 ; i < rightList.size(); i++)\n                        mergedList.add((rightList.get(i)));\n                }\n                return mergedList;\n            }\n            else if(leftList != null) return leftList;\n            else return rightList;\n        }\n\n        public void printTree(){\n            for(int i = 0; i < st.length; i++)\n                prln(i+\" , \"+st[i]);\n        }\n    }\n\n    public static String atsi(int a[]){\n        return Arrays.toString(a);\n    }\n\n    public static String atsl(long a[]){\n        return Arrays.toString(a);\n    }\n\n    public static long gcd(long a, long b){\n        if(b == 0) return a;\n        return gcd(b, a % b);\n    }\n\n    public static int gcd(int a, int b){\n        if(b == 0) return a;\n        return gcd(b, a % b);\n    }\n\n    public static int[] an(int n) {\n        int ar[]=new int[n];\n        for(int i=0;i<n;i++)\n            ar[i]=in();\n        return ar;\n    }\n\n    public static long[] lan(int n) {\n        long ar[]=new long[n];\n        for(int i=0;i<n;i++)\n            ar[i]=lin();\n        return ar;\n    }\n\n    public static String atos(Object ar[]) {\n        return Arrays.toString(ar);\n    }\n\n    public static int in() {\n        return in.readInt();\n    }\n\n    public static long lin() {\n        return in.readLong();\n    }\n\n    public static String sn() {\n        return in.readString();\n    }\n\n    public static void prln(Object o) {\n        out.printLine(o);\n    }\n\n    public static void prn(Object o) {\n        out.print(o);\n    }\n\n    public static void app(Object o) {\n        sb.append(o);\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object...objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object...objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Sol{\n\n/*   \n->n=1 important test case\n->Dont get stuck on one approach try all possibilities\n->check int overflow,array bounds,etc\n->Dont think just idea think of its (correct) implementation completely (then only code)\n*/\n\npublic static void main(String []args){\n//precomp();\nint times=ni();while(times-->0){solve();}out.close();}\n\nstatic void solve(){  \n     int n=ni();int ans=1;\n     long A[]=new long[n];\n     for(int i=0;i<n;i++)A[i]=nl();\n     if(n==1){out.println(1);return;}\n     n--;\n     long a[]=new long[n];\n     for(int i=0;i<n;i++){a[i]=A[i+1]-A[i];if(a[i]<0){a[i]*=-1;}}\n     \n     \n    \n     long m[][]=new long[n][20];\n     for(int i=0;i<n;i++){m[i][0]=a[i];}\n     \n     for(int j=1;j<20;j++){\n        for(int i=0;i+(1<<j)-1<n;i++){\n         m[i][j]=gcd(m[i][j-1],m[i+(1<<j-1)][j-1]);\n        \n        }\n     }\n     int l=0;int r=n+1;\n     while(l+1<r){\n        int mid=(l+r)/2;\n        if(good(mid,m,n))l=mid;\n        else r=mid;\n    } \n \n      out.println(l+1);\n      return;\n }\n\n//-----------------Utility--------------------------------------------\n\n//error 3 4\nstatic boolean good(int len,long m[][],int n){\n      int j=log2(len); \n   for(int i=0;i+len-1<n;i++){\n      long g1=m[i][j];\n      int k=i+len-(1<<j);\n      if(k>=n)break;\n      long g2=m[k][j];\n    \n      if(gcd(g1,g2)>1)return true;\n   }\n   return false;       \n }\n \nstatic int log2(int n){int j=-1;while(n>0){j++;n/=2;}return j;}\n\nstatic long gcd(long a,long b){if(b==0)return a; return gcd(b,a%b);}\n \nstatic int Max=Integer.MAX_VALUE; static long mod=1000000007;\n \nstatic int v(char c){return (int)(c-'a');}\n\npublic static long power(long x, long y )\n    {\n        //0^0 = 1\n        long res = 1L;\n        x = x%mod;\n        while(y > 0)\n        {\n            if((y&1)==1)\n                res = (res*x)%mod;\n            y >>= 1;\n            x = (x*x)%mod;\n        }\n        return res;\n    }\n \nstatic class Pair implements Comparable<Pair>{\n        int id;int value;Pair next;\n        public Pair(int id,int value) {\n         \n          this.id=id;this.value=value;next=null;\n        }\n        @Override\n        public int compareTo(Pair p){return Long.compare(value,p.value);}\n    }\n\n//----------------------I/O---------------------------------------------\n \nstatic InputStream inputStream = System.in;\nstatic OutputStream outputStream = System.out;\nstatic FastReader in=new FastReader(inputStream);\nstatic PrintWriter out=new PrintWriter(outputStream);\n \nstatic class FastReader \n{ \n  BufferedReader br; \n  StringTokenizer st; \n \n        FastReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n \n  public String next() \n  { \n      while (st == null || !st.hasMoreElements()) \n      { \n          try\n          { \n              st = new StringTokenizer(br.readLine()); \n          } \n          catch (IOException  e) \n          { \n              e.printStackTrace(); \n          } \n      } \n      return st.nextToken(); \n  } \n \n  public int nextInt() \n  { \n      return Integer.parseInt(next()); \n  } \n \n  public long nextLong() \n  { \n      return Long.parseLong(next()); \n  } \n \n public  double nextDouble() \n  { \n      return Double.parseDouble(next()); \n  } \n \n \n  String nextLine() \n  { \n      String str = \"\"; \n      try\n      { \n          str = br.readLine(); \n      } \n      catch (IOException e) \n      { \n          e.printStackTrace(); \n      } \n      return str; \n  } \n}\nstatic int ni() {\n        return in.nextInt();\n    }\nstatic long nl(){return in.nextLong();}\nstatic String ns(){return in.nextLine();}\n//---------------------I/O------------------------------------------------- \n}"
        },
        {
            "language": 3,
            "solution": "import math\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = [int(x) for x in input().split()]\n\tb = [1]\n\tfor i in range(1, n):\n\t\tb.append(abs(a[i] - a[i - 1]))\n\tcur = {1:0}\n\tans = 0\n\tfor i in range(1, n):\n\t\tg = b[i]\n\t\td = {}\n\t\td[g] = i\n\t\tif (g != 1):\n\t\t\ttmp = sorted(list(cur.keys()))\n\t\t\ttmp.reverse()\n\t\t\tfor j in tmp:\n\t\t\t\tg = math.gcd(g, j)\n\t\t\t\tif (g not in d):\n\t\t\t\t\td[g] = cur[j]\n\t\t\t\tif (g == 1):\n\t\t\t\t\tans = max(ans, i - cur[j])\n\t\t\t\t\tbreak\n\t\tcur = d.copy()\n\tprint(ans + 1)"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        DIntegersHaveFriends solver = new DIntegersHaveFriends();\n        int testCount = Integer.parseInt(in.next());\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class DIntegersHaveFriends {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            long[] arr = in.nextLongArray(n);\n            long[] diff = new long[n - 1];\n            for (int i = 0; i < n - 1; i++) {\n                diff[i] = Math.abs(arr[i] - arr[i + 1]);\n            }\n\n            DIntegersHaveFriends.CompactSegmentTree st = new DIntegersHaveFriends.CompactSegmentTree(diff);\n            n--;\n            long ans = 0;\n            int head = -1;\n            int tail = 0;\n\n            while (tail < n) {\n                // condition\n                if (head == n - 1) break;\n                while (head + 1 < n && (st.query(tail, head + 2) > 1)) {\n                    head++;\n                }\n                ans = Math.max(ans, head - tail + 1);\n                if (head == n - 1) break;\n                if (head < tail) {\n                    tail++;\n                    head = tail - 1;\n                } else {\n                    while (tail <= head && st.query(tail, head + 2) == 1) {\n                        tail++;\n                    }\n                }\n            }\n\n            out.println(ans + 1);\n        }\n\n        public static class CompactSegmentTree {\n            private int N;\n            private long UNIQUE = 8123572096793136074L;\n            private long[] tree;\n\n            public CompactSegmentTree(int size) {\n                tree = new long[2 * (N = size)];\n                Arrays.fill(tree, UNIQUE);\n            }\n\n            public CompactSegmentTree(long[] values) {\n                this(values.length);\n                // TODO(william): Implement smarter construction.\n                for (int i = 0; i < N; i++) modify(i, values[i]);\n            }\n\n            private long function(long a, long b) {\n                if (a == UNIQUE) return b;\n                else if (b == UNIQUE) return a;\n\n                return gcd(a, b); // sum over a range\n                // return (a > b) ? a : b; // maximum value over a range\n                // return (a < b) ? a : b; // minimum value over a range\n                // return a * b; // product over a range (watch out for overflow!)\n            }\n\n            public long gcd(long a, long b) {\n                return b == 0 ? (a < 0 ? -a : a) : gcd(b, a % b);\n            }\n\n            public void modify(int i, long value) {\n                tree[i + N] = function(tree[i + N], value);\n                for (i += N; i > 1; i >>= 1) {\n                    tree[i >> 1] = function(tree[i], tree[i ^ 1]);\n                }\n            }\n\n            public long query(int l, int r) {\n                long res = UNIQUE;\n                for (l += N, r += N; l < r; l >>= 1, r >>= 1) {\n                    if ((l & 1) != 0) res = function(res, tree[l++]);\n                    if ((r & 1) != 0) res = function(res, tree[--r]);\n                }\n                if (res == UNIQUE) {\n                    throw new IllegalStateException(\"UNIQUE should not be the return value.\");\n                }\n                return res;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] array = new long[n];\n            for (int i = 0; i < n; ++i) array[i] = nextLong();\n            return array;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.lang.*;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n    static void deal(int n,long[] arr) { \n        if(n==1) {\n            out.println(1);\n            return;\n        }\n        int d = 20;\n        int max =1;\n        long[][] dp = new long[n-1][d];\n        for(int i=0;i<n-1;i++) {\n            dp[i][0] = Math.abs(arr[i]-arr[i+1]);\n        }\n        int q = 1;\n        for(int i=1;i<d;i++) {\n            for(int j=0;j<n-1;j++) {\n                if(j+q>=n-1) {\n                    dp[j][i] = 1;\n                    continue;\n                }\n                dp[j][i] = gcd(dp[j][i-1],dp[j+q][i-1]);\n            }\n            q = q<<1;\n        }\n//        for(int i=0;i<n-1;i++) System.out.println(Arrays.toString(dp[i]));\n        for(int i=0;i<n-1;i++) {\n            long res = dp[i][0];\n            int now = i;\n            while(true) {\n                int index = 0;\n                q=1;\n                while(index<d && gcd(res,dp[now][index])>1) {\n                    index++;\n                    q = q<<1;\n                }\n                index --;\n                q = q>>1;\n                if(index>=0) res = gcd(res,dp[now][index]);\n                \n//                System.out.println(String.format(\"%d %d %d %d %d\",i,now,index,q,res));\n                if(index <= 0) {\n                    if(index==0) {\n                        now++;\n                    }\n                    max = Math.max(max,now-i+1);\n                    break;\n                }\n                now = now +q;\n                if(now == n-1) {\n                    max = Math.max(max,n-i);\n                    break;\n                    \n                }\n            }\n        }\n        out.println(max);\n    }\n\n    static long gcd(long a,long b) {\n        while(b>0) {\n            long c = a % b;\n            a = b;\n            b = c;\n        }\n        return a;\n    }\n    \n\tpublic static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int t = sc.nextInt();\n        for(int i=0;i<t;i++) {\n            int n = sc.nextInt();\n            long[] arr = new long[n];\n            for(int j=0;j<n;j++) arr[j] = sc.nextLong();\n            deal(n,arr);\n        }\n        out.close();\n    }\n    \n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n    \n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public MyScanner() {\n                br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n                while (st == null || !st.hasMoreElements()) {\n                        try {\n                                st = new StringTokenizer(br.readLine());\n                        } catch (IOException e) {\n                                e.printStackTrace();\n                        }\n                }\n                return st.nextToken();\n        }\n        \n        int nextInt() {\n                return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n                return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n                return Double.parseDouble(next());\n        }\n        \n        String nextLine(){\n                String str = \"\";\n    try {\n            str = br.readLine();\n    } catch (IOException e) {\n            e.printStackTrace();\n    }\n    return str;\n        }\n        \n    }\n}"
        },
        {
            "language": 4,
            "solution": "/*Everything is Hard \n * Before Easy \n * Jai Mata Dii \n */ \n \nimport java.util.*;\nimport java.io.*; \n  \npublic class Main { \n\tstatic class FastReader{ BufferedReader br;StringTokenizer st;public FastReader(){br = new BufferedReader(new InputStreamReader(System.in));}String next(){while (st == null || !st.hasMoreElements()){try{st = new StringTokenizer(br.readLine());}catch (IOException  e){e.printStackTrace();}}return st.nextToken();}int nextInt(){ return Integer.parseInt(next());}long nextLong(){return Long.parseLong(next());}double nextDouble(){return Double.parseDouble(next());}String nextLine(){String str = \"\"; try{str = br.readLine(); } catch (IOException e) {e.printStackTrace();} return str; }} \n\tstatic long mod = (long)(1e9+7); \n\t// static long mod = 998244353; \n//\t static Scanner sc = new Scanner(System.in); \n\tstatic FastReader sc = new FastReader(); \n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic TreeSet<Integer> g[];\n\tpublic static void main (String[] args) { \n\t\tint ttt = 1;\n\t\tttt = sc.nextInt();\n\t\tz :for(int tc=1;tc<=ttt;tc++){\n\t\t\tint n = sc.nextInt();\n\t\t\tlong a[] = new long[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i] = sc.nextLong();\n\t\t\t}\n\t\t\tlong dif[] = new long[n];\n\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\tdif[i-1] = Math.abs(a[i]-a[i-1]);\n\t\t\t}\n\t\t\tSegTree tre = new SegTree(dif);\n\t\t\tint ans = 0, l = 0, r = 0;\n\t\t\twhile(r<n-1) {\n\t\t\t\tlong cgcd = tre.query(l, r);\n\t\t\t\twhile(cgcd==1 && l<=r) {\n\t\t\t\t\tl++;\n\t\t\t\t\tcgcd = tre.query(l, r);\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, r-l+1);\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tans = ans + 1;\n\t\t\tout.write(ans+\"\\n\");\n\t\t}\n\t\tout.close();\n\t\t//410 52 51 180 222 33 33\n\t}\n\tstatic long pow(long a, long b){long ret = 1;while(b>0){if(b%2 == 0){a = (a*a)%mod;b /= 2;}else{ret = (ret*a)%mod;b--;}}return ret%mod;}\n\tstatic long gcd(long a,long b){if(b==0) return  a; return gcd(b,a%b); } \n\tprivate static void sort(int[] a) {List<Integer> k = new ArrayList<>();for(int val : a) k.add(val);Collections.sort(k);for(int i=0;i<a.length;i++) a[i] = k.get(i);} \n\tprivate static void ini(List<Integer>[] tre2){for(int i=0;i<tre2.length;i++){tre2[i] = new ArrayList<>();}} \n\tprivate static void init(List<int[]>[] tre2){for(int i=0;i<tre2.length;i++){tre2[i] = new ArrayList<>();}} \n\tprivate static void sort(long[] a) {List<Long> k = new ArrayList<>();for(long val : a) k.add(val);Collections.sort(k);for(int i=0;i<a.length;i++) a[i] = k.get(i);} \n}\nclass SegTree {\n\tstatic int n;\n\tstatic long segTree[];\n\tstatic long a[];\n\tpublic SegTree(int n) {\n\t\tsegTree = new long[4*n];\n\t\ta = new long[n];\n\t}\n\tstatic long gcd(long a,long b){if(b==0) return  a; return gcd(b,a%b); } \n\tpublic SegTree(long b[]) {\n\t\tsegTree = new long[4*b.length+10];\n\t\ta = b;\n\t\tbuild(0,0,a.length-1);\n\t}\n\tprivate static void build(int idx, int low, int high) {\n\t\tif(low == high) {\n\t\t\tsegTree[idx] = a[low];\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint mid = (low+high)/2;\n\t\t\n\t\tbuild(2*idx+1,low,mid);\n\t\tbuild(2*idx+2,mid+1,high);\n\t\t\n\t\tsegTree[idx] = gcd(segTree[2*idx+1], segTree[2*idx+2]);\n\t}\n\tpublic static long query(int l , int r) {\n\t\treturn Query(0,0,a.length-1,l,r);\n\t}\n\tstatic long Query(int idx,int low,int high,int l,int r) {\n\t\t\n\t\tif(r<low || l>high) return 0;\n\t\t\n\t\tif(l<=low && r>=high)\n\t\t\treturn segTree[idx];\n\t\t\n\t\tint mid = (low+high)>>1;\n\t\t\n\t\tlong left = Query(2*idx+1,low,mid,l,r);\n\t\tlong right = Query(2*idx+2,mid+1,high,l,r);\n\t\t\n\t\treturn gcd(left, right);\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nimport time\nimport math as mt\nimport pprint\nimport itertools as it\nimport operator as op\nimport bisect as bs\nimport functools as fn\nfrom collections import deque, defaultdict , OrderedDict, Counter, ChainMap\nmaxx, localsys, mod = 1 << 60, 0, int(1e9 + 7)\ndef nCr(n, r): return reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)\n\n\ndef ceil(n, x): return (n + x - 1) // x\n\n\nosi, oso = '/home/priyanshu/Documents/cp/input.txt', '/home/priyanshu/Documents/cp/output.txt'\nif os.path.exists(osi):\n    sys.stdin = open(osi, 'r')\n    sys.stdout = open(oso, 'w')\n\ninput = sys.stdin.readline\n\ndef maps(): return map(int, input().split())\n\n#   THINK ABOUT THE EDGE CASES ..........\n\n#   DON'T SUBMIT UNLESS YOU ARE ABSOLUTELY SURE !!!!!\ngcd = mt.gcd\ndef query(l,r):\n    j = log[r-l+1]\n    return gcd(st[l][j] , st[r - (1 << j) + 1][j])\n\nfor _ in range(*maps()):\n    n, = maps()\n    a, k = [*maps()] , mt.floor(mt.log2(n))\n    st = [[0 for _ in range(k+1)] for __ in range(n)]\n\n    for i in range(1,n):\n        st[i][0] = abs(a[i] - a[i-1])\n\n    log = [0]*n + [0]; log[0] = 1\n    for i in range(2 , n+1):\n        log[i] = log[i//2] + 1\n\n    for j in range(1,k+1):\n        i = 1\n        while i + (1<<j)<=n:\n            st[i][j] = gcd(st[i][j-1] , st[i+(1 <<(j-1))][j-1])\n            i+=1\n\n    ans = j = 1\n    for i in range(1,n):\n        while j <=i and query(j,i) ==1:\n            j+=1\n        ans = max(ans , i-j+2)\n\n    print(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\ninline long long ab(long long x) { return x < 0 ? -x : x; }\ninline long long gcd(long long a, long long b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nlong long a[N], dt[N];\nlong long g[N][21];\nint lg[N], n;\nvoid init() {\n  for (int i = 2; i < N; ++i) lg[i] = lg[i >> 1] + 1;\n}\nvoid st() {\n  for (int i = 1; i <= n; ++i) g[i][0] = a[i];\n  for (int k = 1; k <= lg[n]; ++k) {\n    for (int i = 1; i + (1 << k) - 1 <= n; ++i) {\n      g[i][k] = gcd(g[i][k - 1], g[i + (1 << k - 1)][k - 1]);\n    }\n  }\n}\nlong long q(int l, int r) {\n  int k = lg[r - l + 1];\n  return gcd(g[l][k], g[r - (1 << k) + 1][k]);\n}\nbool qry(int x) {\n  if (x <= 0) return 1;\n  for (int i = 2; i + x - 1 <= n; ++i)\n    if (q(i, i + x - 1) != 1) return 1;\n  return 0;\n}\nint main() {\n  init();\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int _;\n  cin >> _;\n  while (_--) {\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    for (int i = n; i; --i) a[i] = ab(a[i] - a[i - 1]);\n    st();\n    int ans = 0;\n    for (int r = 2, l = 2; r <= n; r++) {\n      while (l < r && q(l, r) == 1) l++;\n      if (q(l, r) != 1) ans = max(ans, r - l + 1);\n    }\n    ans++;\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nimport math\n\nclass RMQ:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.logn = int(math.log2(self.n)) + 1\n        self.arr = [0] + arr\n        self.Log = [0] * (self.n + 1)\n        if self.n >= 2: self.Log[2] = 1\n        for i in range(3, self.n + 1):\n            self.Log[i] = self.Log[i // 2] + 1\n        self.gcd = [[0] * (self.logn + 1) for _ in range(self.n + 1)]\n        for i in range(1, self.n + 1):\n            self.gcd[i][0] = self.arr[i]\n\n    def pre(self):\n        for j in range(1, self.logn + 1):\n            for i in range(1, self.n + 1):\n                if i + (1 << j) - 1 > self.n: break\n                self.gcd[i][j] = math.gcd(self.gcd[i][j - 1], self.gcd[i + (1 << (j - 1))][j - 1])\n\n    def queryGcd(self, l, r):\n        s = self.Log[r - l + 1]\n        return math.gcd(self.gcd[l][s], self.gcd[r - (1 << s) + 1][s])\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    if n == 1:\n        print(1)\n        continue\n    D = [abs(a - b) for a, b in zip(A, A[1:])]\n    rmq = RMQ(D)\n    rmq.pre()\n    ans = 0\n    j = 1\n    for i in range(1, n):\n        while j < n and rmq.queryGcd(i, j) > 1: j += 1\n        ans = max(ans, j - i)\n        j = max(j, i + 1)\n    print(ans + 1)"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while x>1:\n            x, y=y%x, x\n        if x==1:\n            return 1\n        else:        \n            return y\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2                                    \n\n #   total=bmax\n #   c=int(0.5+math.log2(bmax))\n #   k=0\n #   while k+total<n:\n #       if St[k][c]!=1:\n #           start=total+1\n #           end=min(n-k-1, bmax*2-1)\n #           while start<=end:\n #               j=(start+end)//2\n #               if HCF(St[k][c], St[k+j-2**c][c])!=1:\n #                   total=j\n #                   start=j+1\n #               else:\n #                   end=j-1    \n #       k+=1\n\n    def possible_group(x, y):\n        c=b[x]\n        for i in range(x+1, y):\n            c=HCF(c, b[i])\n            if c==1:\n                return False\n        return True        \n\n    total=bmax\n    start=bmax+1\n    end=min(n-1, bmax*2-1)\n    c=int(0.5+math.log2(bmax))\n    while start<=end:\n        j=(start+end)//2\n        for k in range(n-j):            \n            if HCF(St[k][c], St[k+j-2**c][c])!=1:\n                total=j\n                start=j+1\n                break\n        if start<=j:\n            end=j-1\n            \n    \n    print(total+1)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\t\n\tpublic static void main(String[] args)throws IOException {\n\t\t\n\t\tFastScanner scan = new FastScanner();\n\t\tBufferedWriter output = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tint t = scan.nextInt();\n\t\tfor(int tt = 0;tt<t;tt++) {\n\t\t\t\n\t\t\tint n = scan.nextInt();\n\t\t\tlong arr[] = new long[n];\n\t\t\tfor(int i = 0;i<n;i++) arr[i] = scan.nextLong();\n\t\t\t\n\t\t\tlong diff[] = new long[n-1];\n\t\t\tfor(int i = 0;i<n-1;i++) diff[i] = Math.abs(arr[i+1] - arr[i]);\n\t\t\t\n\t\t\tif(n == 1 ) {\n\t\t\t\toutput.write(1 + \"\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSegTree st = new SegTree(0, n-2, diff);\n\t\t\t\n\t\t\tint i = 0, j = 0;\n\t\t\tint max = 0;\n\t\t\twhile(j<n-1) {\n\t\t\t\tlong gcd = st.getQuery(i, j);\n\t\t\t\tif(gcd > 1) {\n\t\t\t\t\tmax = Math.max(max, j-i);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti++;\n\t\t\t\t\tj = Math.max(j, i);\n\t\t\t\t}\n\t\t\t\tif(gcd != 1) max = Math.max(max, j-i);\n\t\t\t}\n\t\t\toutput.write(max+1 + \"\\n\");\n\t\t}\n\t\toutput.flush();\n\t}\n\t\n\tstatic class SegTree{\n\t\tint leftmost, rightmost;\n\t\tSegTree lChild, rChild;\n\t\tlong sum;\n\t\t\n\t\tpublic SegTree(int leftmost, int rightmost, long arr[]) {\n\t\t\tthis.leftmost = leftmost;\n\t\t\tthis.rightmost = rightmost;\n\t\t\tif(leftmost == rightmost) {\n\t\t\t\t//leaf\n\t\t\t\tsum = arr[leftmost];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//have two children\n\t\t\t\tint mid = (leftmost + rightmost)/2;\n\t\t\t\t\n\t\t\t\t//[l, mid], [mid+1, r]\n\t\t\t\tlChild = new SegTree(leftmost, mid, arr);\n\t\t\t\trChild = new SegTree(mid+1, rightmost, arr);\n\t\t\t\trecalc();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void recalc() {\n\t\t\tif(leftmost == rightmost) return;\n\t\t\t\n\t\t\t//change depending on problem\n\t\t\tsum = gcd(lChild.sum , rChild.sum);\n\t\t}\n\t\t\n\t\tpublic void pointUpdate(int index, long newVal) {\n\t\t\tif(leftmost == rightmost) {\n\t\t\t\t//leaf\n\t\t\t\tsum = newVal;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//2 kids\n\t\t\t\tif(index <= lChild.rightmost) lChild.pointUpdate(index, newVal);\n\t\t\t\telse rChild.pointUpdate(index, newVal);\n\t\t\t\trecalc();\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic long getQuery(int l, int r) {\n\t\t\t//case 1: entirely disjoint\n\t\t\tif(l > rightmost || r < leftmost) return 0;\n\t\t\t\n\t\t\t//case 2: range covers\n\t\t\tif(l <= leftmost && r >= rightmost) return sum;\n\t\t\t\n\t\t\t//case 3: we dont know\n\t\t\t//change depending on question\n\t\t\treturn gcd(lChild.getQuery(l, r), rChild.getQuery(l, r));\n\t\t}\n\t\t\n\t\tpublic static long gcd(long a, long b) {\n\t\t\tif(a == 0) return b;\n\t\t\treturn gcd(b%a, a);\n\t\t}\n\t}\n\t\n\tpublic static int[] sort(int arr[]) {\n\n\t\tList<Integer> list = new ArrayList<>();\n\t\tfor(int i:arr)\n\t\t\tlist.add(i);\n\t\tCollections.sort(list);\n\t\tfor(int i = 0;i<list.size();i++) {\n\t\t\tarr[i] = list.get(i);\n\t\t}\n\t\treturn arr;\n\n\t}\n\t\n\tpublic static int gcd(int a, int b) {\n\t\tif(a == 0) return b;\n\t\treturn gcd(b%a, a);\n\t}\n\t\n\tpublic static void printArray(int arr[]) {\n\t\tfor(int i:arr) System.out.print(i+\" \");\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import com.sun.source.tree.Tree;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.TreeSet;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Solution {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Main solver = new Main();\n        boolean multipleTC = true;\n        int testCount = multipleTC ? Integer.parseInt(in.next()) : 1;\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(in, out, i);\n        out.close();\n    }\n    static class Main {\n        PrintWriter out;\n        InputReader in;\n\n        long[] segtree;\n        long merge(long x, long y){\n            return gcd(x, y);\n        }\n        void build_segtree(int n){\n            int i = 0;\n            for(i = n - 1; i > 0; i--)\n                segtree[i] = merge(segtree[i << 1], segtree[i << 1 | 1]);\n        }\n        long segtree_query(int l, int r, int n){\n            long res = 0;\n            for(l += n, r += n; l < r; l >>= 1, r >>= 1){\n                if((l & 1) == 1)\n                    res = merge(res, segtree[l++]);\n                if((r & 1) == 1)\n                    res = merge(res, segtree[--r]);\n            }\n            return res;\n        }\n\n\n        public void solve(InputReader in, PrintWriter out, int test) {\n            this.out = out;\n            this.in = in;\n            int n = ni();\n            long[] arr = new long[n];\n            segtree = new long[2 * n];\n            for(int i = 0; i < n; i++)\n                arr[i] = nl();\n            for(int i = 0; i < n - 1; i++)\n                segtree[n - 1 + i] = Math.abs(arr[i] - arr[i + 1]);\n            build_segtree(n - 1);\n            int ans = 1;\n            for(int i = 0; i < n - 1; i++){\n                int lo = i, hi = n - 2, ind = -1;\n                while(lo <= hi) {\n                    int mid = (lo + hi) >> 1;\n                    if(segtree_query(i, mid + 1, n - 1) > 1) {\n                        lo = mid + 1;\n                        ind = mid;\n                    } else {\n                        hi = mid - 1;\n                    }\n                }\n                ans = Math.max(ind - i + 2, ans);\n            }\n            pn(ans);\n        }\n\n        long gcd(long a, long b)\n        {\n            if (a == 0)\n                return b;\n\n            return gcd(b%a, a);\n        }\n\n\n        String n(){\n            return in.next();\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n        void pn(String sz) {\n            out.println(sz);\n        }\n\n        void pn(double dx){\n            out.println(dx);\n        }\n\n        class Tuple {\n            long x;\n            long y;\n\n            Tuple(long a, long b) {\n                x = a;\n                y = b;\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import math\nimport sys\ninput = iter(sys.stdin.read().splitlines()).__next__\n\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    # differences between contiguous friends in friend group have common divisor\n    differences = [abs(a[i+1]-a[i]) for i in range(n-1)]\n    gcd_till_here = {0: 1}  # {gcd_of_friend_group_ending_at_i : size_of_friend_group}\n    largest_friend_group = 1\n    for i in range(n-1):\n        new_gcd_till_here = {}\n        for gcd, friend_group_size in gcd_till_here.items():\n            new_gcd = math.gcd(gcd, differences[i])\n            if new_gcd == 1:\n                continue\n            new_gcd_till_here[new_gcd] = max(new_gcd_till_here.get(new_gcd, 0), friend_group_size + 1)\n        if differences[i] > 1 and differences[i] not in new_gcd_till_here:\n            new_gcd_till_here[differences[i]] = 2\n        if new_gcd_till_here:\n            largest_friend_group = max(largest_friend_group, max(new_gcd_till_here.values()))\n        gcd_till_here = new_gcd_till_here\n    return largest_friend_group\n\nt = int(input())\noutput = []\nfor _ in range(t):\n    output.append(solve())\nprint(*output, sep=\"\\n\")\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    static long gcdArr[][];\n    public static void main(String args[])\n    {\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=input.nextInt();\n        while(T-->0)\n        {\n            int n=input.nextInt();\n            long a[]=new long[n];\n            for(int i=0;i<n;i++)\n            {\n                a[i]=input.nextLong();\n            }\n            if(n==1)\n            {\n                out.println(1);\n            }\n            else\n            {\n                long arr[]=new long[n];\n                for(int i=1;i<n;i++)\n                {\n                    arr[i]=Math.abs(a[i]-a[i-1]);\n                }\n                int n1=n-1;\n                gcdArr=new long[n1+1][30];\n                createArrayMax(arr,n1);\n                int i=0,j=0;\n                int max=1;\n                while(i<n && j<n)\n                {\n                    if(i==j)\n                    {\n                        j++;\n                    }\n                    else\n                    {\n                        long g=getGCD(i+1,j);\n                        if(g>1)\n                        {\n                            max=Math.max(max,j-i+1);\n                            j++;\n                        }\n                        else\n                        {\n                            i++;\n                        }\n                    }\n                }\n                max=Math.max(max,n-i);\n                out.println(max);\n            }\n        }\n        out.close();\n    }\n    public static void createArrayMax(long a[],int n)\n    {\n        for(int i=0;i<=n;i++)\n        {\n            gcdArr[i][0]=a[i];\n        }\n        for(int j=1;j<30;j++)\n        {\n            for(int i=0;i<=n;i++)\n            {\n                int s=(int)Math.pow(2,j);\n                int last=i+s-1;\n                if(last<=n)\n                {\n                    int p1=i;\n                    int p2=i+(s/2);\n                    long val=gcd(gcdArr[p1][j-1],gcdArr[p2][j-1]);\n                    gcdArr[i][j]=val;\n                }\n            }\n        }\n    }\n    public static long getGCD(int x,int y)\n    {\n        int len=y-x+1;\n        long g=0;\n        while(len>0)\n        {\n            int q=(int)(Math.log(len)/Math.log(2));\n            g=gcd(g,gcdArr[x][q]);\n            q=(int)Math.pow(2,q);\n            x+=q;\n            len-=q;\n        }\n        return g;\n    }\n    public static long gcd(long a, long b)\n    {\n        if(a==0)\n        {\n            return b;\n        }\n        else\n        {\n            return gcd(b%a,a);\n        }\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n        String nextLine()\n        {\n            String str=\"\";\n            try\n            {\n                str=br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 1,
            "solution": "import sys\ntesting = len(sys.argv) == 4 and sys.argv[3] == \"myTest\"\ninteractive = False\nif testing:\n    cmd = sys.stdout\n    from time import time\n    start_time = int(round(time() * 1000)) \n    readAll = open(sys.argv[1], 'r').read\n    sys.stdout = open(sys.argv[2], 'w')\nelse:\n    readAll = sys.stdin.read\n\n# ############ ---- I/O Functions ---- ############\n\nclass InputData:\n    def __init__(self):\n        self.lines = readAll().split('\\n')\n        self.n = len(self.lines)\n        self.ii = -1\n    def input(self):\n        self.ii += 1\n        assert self.ii < self.n\n        return self.lines[self.ii]\n\nflush = sys.stdout.flush\nif interactive and not testing:\n    input = sys.stdin.readline\nelse:\n    inputData = InputData()\n    input = inputData.input\n\ndef intin():\n    return(int(input()))\ndef intlin():\n    return(list(map(int,input().split())))\ndef chrin():\n    return(list(input()))\ndef strin():\n    return input()\ndef lout(l, sep=\"\\n\", toStr=True):\n    print(sep.join(map(str, l) if toStr else l))\ndef dout(*args, **kargs):\n    if not testing: return\n    if args: print(args[0] if len(args)==1 else args)\n    if kargs: print([(k,v) for k,v in kargs.items()])\ndef ask(q):\n    sys.stdout.write(str(q)+'\\n')\n    flush()\n    return intin()\n    \n# ############ ---- I/O Functions ---- ############\n\n# from math import ceil\nfrom collections import defaultdict as ddict, Counter\n# from heapq import *\n# from Queue import Queue\nclass ST:\n    def __init__(self, a, f):\n        self.n = len(a)\n        self.f = f\n        self.tree = [None]*(2*self.n)\n        self.build(a)\n\n    def build(self, a):\n        for i in xrange(self.n):\n            self.tree[self.n+i] = a[i]\n        for i in xrange(self.n-1,0,-1):\n            self.tree[i] = self.f(self.tree[i<<1], self.tree[i<<1 | 1])\n    \n    def update(self, i, v):\n        i += self.n\n        self.tree[i] = v\n        while i > 1:\n            self.tree[i>>1] = self.f(self.tree[i], self.tree[i^1])\n            i >>= 1\n\n    def query(self, l, r):\n        #to find the sum in the range [l,r)\n        v = 0\n        l,r = (l+self.n,self.n+r)\n        while l < r:\n            if (l&1)>0:\n                v = self.f(v, self.tree[l])\n                l += 1\n            if (r&1)>0:\n                r -= 1\n                v = self.f(v, self.tree[r])\n            l >>= 1\n            r >>= 1\n        return v\n\nfrom math import log\nclass SparseTable:\n    def __init__(self, a, f):\n        self.f = f\n        self.k = int(log(len(a),2))+1\n        self.table = [[0]*len(a) for _ in xrange(self.k)]\n        self.build(a)\n\n    def build(self, a):\n        for i in xrange(len(a)):\n            self.table[0][i] = a[i]\n        for j in xrange(1, self.k):\n            i = 0\n            while (i+(1<<j)) <= len(a):\n                self.table[j][i] = self.f(self.table[j-1][i], self.table[j-1][i+(1<<(j-1))])\n                i += 1\n\n    def query(self, l, r):\n        j = int(log(r-l,2))\n        return self.f(self.table[j][l], self.table[j][r-(1<<j)])\n \n\ndef gcd(a, b):\n    while b:\n        a, b = b, a%b\n    return a\n\ndef main():\n    n = intin()\n    a = intlin()\n    if n == 1:\n        return 1\n    b = [abs(a[i] - a[i-1]) for i in xrange(1,n)]\n    ans = 1 + int(max(b)>1)\n    st = SparseTable(b, gcd)\n    i = 0\n    j = 1\n    while i < len(b) and j < len(b):\n        if st.query(i,j+1) != 1:\n            ans = max(ans, j-i+2)\n            j += 1\n        else:\n            i += 1\n            if i == j:\n                j = i+1\n    return ans\n\n\n\n\nanss = []\nfor _ in xrange(intin()):\n    anss.append(main())\n    # anss.append(\"YES\" if main() else \"NO\")\nlout(anss)\n\nif testing:\n    sys.stdout = cmd\n    print(int(round(time() * 1000))  - start_time)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\nint t, n, ans;\nlong long a[200005], st[200005][20], b[200005];\nlong long ask(int l, int r) {\n  int now = l;\n  long long tmp = 0;\n  for (int j = 19; ~j; --j) {\n    if (now > r) break;\n    if (now + (1 << j) - 1 <= r) {\n      tmp = gcd(st[now][j], tmp);\n      now += (1 << j);\n    }\n  }\n  return tmp;\n}\nint main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n), ans = 1;\n    for (int i = 1; i <= n; ++i) scanf(\"%lld\", &a[i]);\n    if (n == 1) {\n      puts(\"1\");\n      continue;\n    }\n    for (int i = 1; i < n; ++i) b[i] = abs(a[i] - a[i + 1]);\n    for (int i = 1; i < n; ++i) st[i][0] = b[i];\n    for (int k = 1; k <= 19; ++k)\n      for (int i = 1; i + (1 << k) - 1 < n; ++i)\n        st[i][k] = gcd(st[i][k - 1], st[i + (1 << (k - 1))][k - 1]);\n    for (int i = 1; i <= n; ++i) {\n      int l = i + 1, r = n, pos = -1;\n      while (l <= r) {\n        int mid = l + r >> 1;\n        if (ask(i, mid - 1) > 1)\n          l = mid + 1, pos = mid;\n        else\n          r = mid - 1;\n      }\n      if (pos != -1) ans = max(ans, pos - i + 1);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while x>1:\n            x, y=y%x, x\n        if x==1:\n            return 1\n        else:        \n            return y\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2\n        if bmax<upton:\n            break\n\n #   total=bmax\n #   c=int(math.log2(bmax))\n #   k=0\n #   while k+total<n:\n #       if St[k][c]!=1:\n #           start=total+1\n #           end=min(n-k-1, bmax*2-1)\n #           while start<=end:\n #               j=(start+end)//2\n #               if HCF(St[k][c], St[k+j-2**c][c])!=1:\n #                   total=j\n #                   start=j+1\n #               else:\n #                   end=j-1    \n #       k+=1\n\n#    def possible_group(x, y):\n#        c=b[x]\n#        for i in range(x+1, y):\n#            c=HCF(c, b[i])\n#            if c==1:\n#                return False\n#        return True        \n\n#    total=bmax\n#    start=bmax+1\n#    end=min(n-1, bmax*2-1)\n#    c=int(math.log2(bmax))\n#    upton=2**c\n#    while start<=end:\n#        j=(start+end)//2\n#        for k in range(n-j):            \n#            if HCF(St[k][c], St[k+j-upton][c])!=1:\n#                total=j\n#                start=j+1\n#                break\n#        if start<=j:\n#            end=j-1\n\n    total=bmax+1\n    l=0\n    r=total\n    c=int(math.log2(bmax))\n    while r<n:\n        while r-l>=total and HCF(St[l][c], St[r-2**c][c])==1:\n            l+=1\n        if r-l>=total:\n            total=r-l+1\n        r+=1 \n\n    \n    print(total)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nstruct SparseTable {\n  int N, sz;\n  vector<vector<long long>> table;\n  SparseTable(vector<long long> v) {\n    int sz = v.size();\n    N = 0;\n    while ((1 << N) <= sz) N++;\n    table = vector<vector<long long>>(N, vector<long long>(sz));\n    for (int i = 0; i < sz; i++) table[0][i] = v[i];\n    for (int i = 1; i < N; i++) {\n      for (int j = 0; j + (1 << i) - 1 < sz; j++) {\n        table[i][j] = gcd(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);\n      }\n    }\n  }\n  long long range_calc(int l, int r) {\n    int h = floor(log2(r - l + 1));\n    return gcd(table[h][l], table[h][r - (1 << h) + 1]);\n  }\n};\nint n;\nvector<long long> a, d;\nvoid solve() {\n  cin >> n;\n  a = vector<long long>(n);\n  d = vector<long long>(n - 1);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n - 1; i++) d[i] = abs(a[i + 1] - a[i]);\n  SparseTable spt(d);\n  int ans = 1;\n  for (int i = 0; i < n - 1; i++) {\n    if (d[i] == 1) continue;\n    int ok = i, ng = n - 1;\n    while (ng - ok > 1) {\n      int mid = (ok + ng) / 2;\n      if (spt.range_calc(i, mid) > 1)\n        ok = mid;\n      else\n        ng = mid;\n    }\n    ans = max(ans, ok - i + 2);\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Coder {\n  static int n,m;\n  static long na[];\n  static long a[];\n  static long table[][];\n  static StringBuffer str=new StringBuffer();\n  \n  static long gcd(long a, long b){\n      if(b==0) return a;\n      return gcd(b, a%b);\n  }\n  static void constructST(int sz){\n      int p=(int)(Math.log(sz)/Math.log(2));\n      table=new long[sz][p+1];\n      for(int i=0;i<sz;i++) table[i][0]=na[i];\n      for(int j=1;j<=p;j++){\n          for(int i=0;i<=(sz-(1<<j));i++){\n              table[i][j]=gcd(table[i][j-1], table[i+(1<<(j-1))][j-1]);\n          }\n      }\n  }\n  \n  static long findGcd(int l, int r){\n      int d=(int)(Math.log(r-l+1)/Math.log(2));\n      int p=r-(1<<d)+1;\n      return gcd(table[l][d], table[p][d]);\n  }\n  static boolean isPoss(int m){\n      for(int i=0;i+m-1<n-1;i++){\n          int l=i;\n          int r=i+m-1;\n          long p = findGcd(l, r);\n          if(p>1) {\n              return true;\n          }\n      }\n      return false;\n  }\n  static void solve(){\n      if(n==1){\n          str.append(n).append(\"\\n\");return;\n      }\n      na=new long[n-1];\n      for(int i=1;i<n;i++){\n          na[i-1]=Math.abs(a[i]-a[i-1]);\n      }\n      constructST(n-1);\n      int l=1, r=n-1;\n      int ans=0;\n      while(l<=r){\n          int mid=l+(r-l)/2;\n          if(isPoss(mid)){\n              ans=mid;\n              l=mid+1;\n          }else r=mid-1;\n      }\n      str.append((ans+1)).append(\"\\n\");\n  }\n\n  public static void main(String[] args) throws java.lang.Exception {\n    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n    int q = Integer.parseInt(bf.readLine().trim());\n    while(q-->0) {\n        n=Integer.parseInt(bf.readLine().trim());\n        a=new long[n];\n        String s[]=bf.readLine().trim().split(\"\\\\s+\");\n        for(int i=0;i<n;i++) a[i]=Long.parseLong(s[i]);\n        solve();\n    }\n    System.out.print(str);\n  }\n}"
        },
        {
            "language": 3,
            "solution": "from math import gcd\n\nfor _ in range(int(input())):\n    n, a = int(input()), map(int, input().split())\n    maxim, last, cua = 1, next(a), []\n    for i, new in enumerate(a):\n        dif, last, nova_cua = abs(last-new), new, []\n        for g, p in cua + [(dif, i)]:\n            g = gcd(dif, g)\n            if g != 1 and (not nova_cua or g > nova_cua[-1][0]):\n                nova_cua.append((g, p))\n                maxim = max(maxim, i-p+2)\n        cua = nova_cua\n    print(maxim)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200050, P = 20;\nlong long gcd(long long x, long long y) {\n  if (y == 0) return x;\n  return gcd(y, x % y);\n}\nlong long ln[N];\nlong long st[P][N];\nlong long qry(long long x, long long y) {\n  int z = ln[y - x + 1];\n  return gcd(st[z][x], st[z][y - (1 << z) + 1]);\n}\nint main() {\n  int t;\n  cin >> t;\n  ln[0] = -1;\n  for (int i = 1; i < N; i++) ln[i] = ln[i >> 1] + 1;\n  while (t--) {\n    long long n;\n    cin >> n;\n    long long a[n + 1], b[n];\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1; i <= n - 1; i++) {\n      b[i] = abs(a[i + 1] - a[i]);\n      st[0][i] = b[i];\n    }\n    n--;\n    for (int i = 1; i < P; i++)\n      for (int j = 1; j <= n - (1 << i) + 1; j++)\n        st[i][j] = gcd(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);\n    long long rez = 0;\n    for (int i = 1; i <= n; i++)\n      while (i + rez <= n && qry(i, i + rez) != 1) rez++;\n    cout << rez + 1 << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class Main extends PrintWriter {\n    \n    void solve() {\n        int t = sc.nextInt();\n        for(int i = 0; i < t; i++) {\n            test_case();\n        }\n                \n    }\n    \n    void test_case() {\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for(int i = 0; i < n; i++) a[i] = sc.nextLong();\n        long[] d = new long[n-1];\n        for(int i = 0; i+1 < n; i++) {\n            d[i] = Math.abs(a[i+1] - a[i]);\n        }\n\n        GCDQueue gcd_queue = new GCDQueue();\n        int ans = 0;\n        for(int r = 0, l = 0; r < n-1; r++) {\n            gcd_queue.add(d[r]); \n            while(gcd_queue.gcd() == 1) {\n                gcd_queue.remove();\n                l++;\n            }\n            ans = Math.max(ans, r-l+1);\n        }\n        println(ans+1);\n    }\n    static long gcd(long a, long b) {\n        while(b > 0) {\n            long t = b;\n            b = a%b;\n            a = t;\n        }\n        return a;\n    }\n        \n    class GCDQueue{\n        GCDStack st1 = new GCDStack();\n        GCDStack st2 = new GCDStack();\n        \n        \n        void add(long x) {\n            st1.push(x);\n        }\n        \n        long remove() {\n            if(st2.isEmpty()) {\n                while(!st1.isEmpty()) {\n                    st2.push(st1.pop());\n                }\n            }\n            return st2.pop();\n        }\n        \n        long gcd() {\n            return Main.gcd(st1.gcd(), st2.gcd());\n        }\n    }\n    \n    \n    class GCDStack {\n        \n        ArrayDeque<Long> gcd = new ArrayDeque<>();\n        ArrayDeque<Long> stack = new ArrayDeque<>();\n        \n        boolean isEmpty() {\n            return stack.isEmpty();\n        }\n        \n        void push(long x) {\n            stack.addFirst(x);\n            if(gcd.isEmpty()) gcd.add(x);\n            else gcd.addFirst(Main.gcd(x, gcd.getFirst()));\n        }\n        \n        long pop() {\n            gcd.removeFirst();\n            return stack.removeFirst();\n        }\n        \n        long gcd() {\n            if(gcd.isEmpty()) return 0L;\n            return gcd.getFirst();\n        }\n \n    }\n    \n//  Main() throws FileNotFoundException { super(new File(\"output.txt\")); }\n//  InputReader sc = new InputReader(new FileInputStream(\"1_08\"));\n  Main() { super(System.out); }\n  InputReader sc = new InputReader(System.in);\n  static class InputReader {\n      InputReader(InputStream in) { this.in = in; } InputStream in;\n      \n      private byte[] buf = new byte[16384];\n      private int    curChar;\n      private int    numChars;\n      \n \n      public int read() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = in.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n \n      private String nextLine() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isEndOfLine(c));\n          return res.toString();\n      }\n \n      public String nextString() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isSpaceChar(c));\n          return res.toString();\n      }\n \n      public long nextLong() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          long res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public int nextInt() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      private boolean isSpaceChar(int c) {\n          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n \n      private boolean isEndOfLine(int c) {\n          return c == '\\n' || c == '\\r' || c == -1;\n      }\n  }\n \n    public static void main(String[] $) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                long start = System.nanoTime();\n                try {Main solution = new Main(); solution.solve(); solution.flush();} \n                catch (Exception e) {e.printStackTrace(); System.exit(1);}\n                System.err.println((System.nanoTime()-start)/1E9);\n            }\n        }, \"1\", 1 << 27).start();\n \n    }\n}"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n                      \n            \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n        \nclass RangeQuery:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n \n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n \n    def __getitem__(self, idx):\n        return self._data[0][idx]\n \n \ndef check(st, n, k):\n    for i in range(n-k+1):\n        g = st.query(i, i+k)\n        if(g > 1):\n            return True \n    return False\n \n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nfrom collections import defaultdict,deque\nfrom math import ceil,floor,sqrt,log2,gcd,pi\nfrom heapq import heappush,heappop\nfrom fractions import Fraction\nfrom bisect import bisect_left,bisect\nimport sys\nabc='abcdefghijklmnopqrstuvwxyz'\nABC=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    diff=[]\n    for i in range(1,n):\n        diff.append(abs(arr[i]-arr[i-1]))\n    st=RangeQuery(diff,func=gcd)\n    lo=1\n    hi=10**18\n    last=-1\n    while hi>=lo:\n        mid=(lo+hi)//2\n        if check(st,len(diff),mid):\n            last=mid\n            lo=mid+1\n        else:\n            hi=mid-1\n    print(max(last+1,1))\n        \n"
        },
        {
            "language": 4,
            "solution": "//------------------>>>>>>>>>>>>>>>> HI . HOW ARE YOU? <<<<<<<<<<<<<<<<<<<<<<<<<<<<<------------------------------\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n//---------------------------->>>>>>>>>>>>>>>>>>>>>> FK OFF <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<-------------------\n\n//--------------------------->>>>>>>>>>>>>>>>>>>>>>>> HACKER MF <<<<<<<<<<<<-------------------------------------\n\npublic class practice{\n\n    static int[] count,count1,count2;\n    static boolean[] prime;\n    static boolean flag;\n    static int[] spf;\n    static Node[] nodes,nodes1,nodes2;\n    static long[] arr;\n    static long[][] cost;\n    static int[] arrInt,darrInt,farrInt;\n    static int[][] dp;\n    static char[] ch,ch1,ch2;\n    static long[] darr,farr;\n    static long[][] mat,mat1;\n    static boolean[] vis;\n    static long x,h;\n    static long maxl,sum,total;\n    static double dec;\n    static long mx = (long)1e7;\n    static long inf = (long)1e17;\n    static String s,s1,s2,s3,s4;\n    static long minl;\n    static long mod = (long)(1e9)+7;\n    // static int minl = -1;\n    // static long n;\n    static int n,n1,n2,q,r1,c1,r2,c2;\n    static int arr_size = (int)2e5+10;\n    static long a;\n    static long b;\n    static long c;\n    static long d;\n    static long y,z;\n    static int m,m1;\n    static long ans;\n    static long k;\n    static FastScanner sc;\n    static String[] str,str1;\n    static Set<Long> set,set1,set2;\n    static SortedSet<Long> ss;\n    static List<StringBuilder> list,list1,list2,list3;\n    static PriorityQueue<Node> pq,pq1;\n    static LinkedList<Node> ll,ll1,ll2;\n    static Map<Integer,List<Integer>> map;\n    static Map<Integer,Integer> map2;\n    static Map<Integer,Long> mapL,mapR;\n    static Map<Integer,Node> map1;\n    static StringBuilder sb,sb1,sb2;\n    static int index;\n    static int[] dx = {0,-1,0,1,-1,1,-1,1};\n    static int[] dy = {-1,0,1,0,-1,-1,1,1};\n\n    static class Node{\n        long first;\n        int second;\n        Node(long f,int s){\n            this.first = f;\n            this.second = s;\n        }\n    }\n\n    static LNode head = null;\n    static LNode tail = null;\n\n    static class LNode{\n        long key;\n        long val;\n        LNode next;\n        LNode prev;\n        LNode(long key,long val){\n            this.key = key;\n            this.val = val;\n            this.next = null;\n            this.prev = null;\n        }\n        LNode(long val){\n            this.key = -1;\n            this.val = val;\n            this.next = null;\n            this.prev = null;\n        }\n    }\n\n\n//     public static void solve(){\n//\n//        FastScanner sc = new FastScanner();\n//        int t = sc.nextInt();\n//        // int t = 1;\n//        for(int tt = 1 ; tt <= t ; tt++){\n//\n//            System.out.println(\"Case #\"+tt+\": \"+ ans);\n//\n//        }\n//\n//     }\n\n    //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------------------\n\n    public static void solve(){\n\n        //dont forget to change array to its difference and take abs\n        n -= 1;\n        arr = new long[n];\n        for(int i = 1 ; i <= n ; i++){\n            arr[i-1] = abs(darr[i] - darr[i-1]);\n        }\n\n        int l = 0;\n        int h = n+1;\n        long[] suffix;\n        long[] prefix;\n\n        while(h - l > 1){\n\n            int mid = (h + l)/2;\n\n            suffix = new long[n];\n            prefix = new long[n];\n            boolean flag = false;\n\n            for(int j = 0; j < n; j++)\n                if (j%mid == 0)\n                    prefix[j] = arr[j];\n                else\n                    prefix[j] = gcd(prefix[j - 1], arr[j]);\n\n            for(int j = n - 2; j >= 0; j--)\n                if (j%mid == mid-1)\n                    suffix[j] = arr[j];\n                else\n                    suffix[j] = gcd(suffix[j + 1], arr[j]);\n\n\n            for(int j = 0; j < n - mid + 1 ; j++) {\n                if (gcd(suffix[j], prefix[j + mid - 1]) >= 2L) {\n                    flag = true;\n                    break;\n                }\n                if (((j % mid) == (mid - 1)) && prefix[j] >= 2L) {\n                    flag = true;\n                    break;\n                }\n            }\n\n            if (flag)\n                l = mid;\n            else\n                h = mid;\n\n        }\n\n        sb.append(l+1).append(\"\\n\");\n\n    }\n\n    //----------->>>>>>> SPEED UP SPEED UP . THIS IS SPEEDFORCES . SPEED UP SPEEEEEEEEEEEEEEEEEEEEEEEEEEDDDDDD <<<<<<<------------------\n\n    public static void main(String[] args) {\n\n        sc = new FastScanner();\n        // Scanner sc = new Scanner(System.in);\n        sb = new StringBuilder();\n        int t = sc.nextInt();\n//        int t = 1;\n        while(t > 0){\n\n//             k = sc.nextLong();\n            // x = sc.nextLong();\n            // y = sc.nextLong();\n            // z = sc.nextLong();\n\n//            a = sc.nextLong();\n//             b = sc.nextLong();\n//             c = sc.nextLong();\n//             d = sc.nextLong();\n//\n//             x = sc.nextLong();\n//             y = sc.nextLong();\n//             z = sc.nextLong();\n            // d = sc.nextLong();\n\n            n = sc.nextInt();\n\n            // n1 = sc.nextInt();\n\n//            m = sc.nextInt();\n//             q = sc.nextInt();\n\n//             a = sc.nextLong();\n//             b = sc.nextLong();\n\n//             k = sc.nextLong();\n\n//            x = sc.nextLong();\n            // d = sc.nextLong();\n\n//            s = sc.next();\n\n//            ch = sc.next().toCharArray();\n//            ch1 = sc.next().toCharArray();\n\n//             m = sc.nextInt();\n            // n = 6;\n\n//            arr = new long[n];\n//            for(int i = 0 ; i < n ; i++){\n//                arr[i] = sc.nextLong();\n//            }\n\n//            arrInt = new int[n];\n//            for(int i = 0 ; i < n ; i++){\n//                arrInt[i] = sc.nextInt();\n//            }\n\n            // x = sc.nextLong();\n            // y = sc.nextLong();\n//             ch = sc.next().toCharArray();\n//            m = n;\n////             m = sc.nextInt();\n            darr = new long[n];\n            for(int i = 0 ; i < n ; i++){\n                darr[i] = sc.nextLong();\n            }\n            // k = sc.nextLong();\n            // m = n;\n//             darrInt = new int[n];\n//             for(int i = 0 ; i < n ; i++){\n//                 darrInt[i] = sc.nextInt();\n//             }\n\n//             farr = new long[n];\n//             for(int i = 0 ; i < n ; i++){\n//                 farr[i] = sc.nextLong();\n//             }\n\n            // farrInt = new int[m];\n            // for(int i = 0; i < m ; i++){\n            //     farrInt[i] = sc.nextInt();\n            // }\n\n            // m = n;\n//            mat = new long[n][m];\n//            for(int i = 0 ; i < n ; i++){\n//                for(int j = 0 ; j < m ; j++){\n//                    mat[i][j] = sc.nextLong();\n//                }\n//            }\n\n//             m = n;\n//             mat = new char[n][m];\n//             for(int i = 0 ; i < n ; i++){\n//                 String s = sc.next();\n//                 for(int j = 0 ; j < m ; j++){\n//                     mat[i][j] = s.charAt(j);\n//                 }\n//             }\n//\n//             str = new String[n];\n//             for(int i = 0 ; i < n ; i++)\n//                 str[i] = sc.next();\n\n//             nodes = new Node[n];\n//             for(int i = 0 ; i < n ;i++)\n//                 nodes[i] = new Node(sc.nextLong(),(i));\n\n            solve();\n            t -= 1;\n        }\n        System.out.print(sb);\n\n    }\n\n    public static int log(double n,double base){\n\n        if(n == 0 || n == 1)\n            return 0;\n\n        if(n == base)\n            return 1;\n\n        double num = Math.log(n);\n        double den = Math.log(base);\n\n        if(den == 0)\n            return 0;\n\n        return (int)(num/den);\n    }\n\n    public static boolean isPrime(long n) {\n        // Corner cases\n        if (n <= 1)\n            return false;\n\n        if (n <= 3)\n            return true;\n\n        // This is checked so that we can skip\n        // middle five numbers in below loop\n        if (n%2 == 0 || n%3 == 0)\n            return false;\n\n        for (int i=5; i*i<=n; i=i+6)\n            if (n%i == 0 || n%(i+2) == 0)\n                return false;\n\n        return true;\n    }\n\n    public static void SpecialSieve(int MAXN)\n    {\n        spf = new int[MAXN];\n        spf[1] = 1;\n        for (int i=2; i<MAXN; i++)\n\n            // marking smallest prime factor for every\n            // number to be itself.\n            spf[i] = i;\n\n        // separately marking spf for every even\n        // number as 2\n        for (int i=4; i<MAXN; i+=2)\n            spf[i] = 2;\n\n        for (int i=3; i*i<MAXN; i++)\n        {\n            // checking if i is prime\n            if (spf[i] == i)\n            {\n                // marking SPF for all numbers divisible by i\n                for (int j=i*i; j<MAXN; j+=i)\n\n                    // marking spf[j] if it is not\n                    // previously marked\n                    if (spf[j]==j)\n                        spf[j] = i;\n            }\n        }\n    }\n\n    public static ArrayList<Integer> getFactorization(int x)\n    {\n        ArrayList<Integer> ret = new ArrayList<Integer>();\n        while (x != 1)\n        {\n            ret.add(spf[x]);\n            x = x / spf[x];\n        }\n        return ret;\n    }\n\n    public static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    public static long lcm(long a, long b)\n    {\n        return (b/gcd(b, a % b)) * a;\n    }\n\n    public static long mod_inverse(long a,long mod){\n        long x1=1,x2=0;\n        long p=mod,q,t;\n        while(a%p!=0){\n            q = a/p;\n            t = x1-q*x2;\n            x1=x2; x2=t;\n            t=a%p;\n            a=p; p=t;\n        }\n        return x2<0 ? x2+mod : x2;\n    }\n\n    public static void swap(double[] curr,int i,int j){\n        double temp = curr[j];\n        curr[j] = curr[i];\n        curr[i] = temp;\n    }\n\n    static final Random random=new Random();\n\n    static void ruffleSortLong(long[] a) {\n        int n=a.length;//shuffle, then sort\n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            long temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void ruffleSortInt(int[] a) {\n        int n=a.length;//shuffle, then sort\n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            int temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void ruffleSortChar(char[] a) {\n        int n=a.length;//shuffle, then sort\n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            char temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static long binomialCoeff(long n, long k){\n\n        long res = 1;\n\n        // Since C(n, k) = C(n, n-k)\n        if (k > n - k)\n            k = n - k;\n\n        // Calculate value of\n        // [n * (n-1) *---* (n-k+1)] / [k * (k-1) *----* 1]\n        for (long i = 0; i < k; ++i) {\n            res = (res*(n - i));\n            res = (res/(i + 1));\n        }\n\n        return res;\n    }\n\n    static long mod(long x)\n    {\n        long y = mod;\n        long result = x % y;\n        while (result < 0)\n        {\n            result += y;\n        }\n        return result;\n    }\n\n    static long[] fact;\n\n    public static long inv(long n){\n        return power(n, mod-2);\n    }\n\n    public static void fact(int n){\n        fact = new long[n+1];\n        fact[0] = 1;\n        for(int j = 1;j<=n;j++)\n            fact[j] = (fact[j-1]*(long)j)%mod;\n    }\n\n    public static long binom(int n, int k){\n\n        long prod = fact[n];\n        prod*=inv(fact[n-k]);\n        prod%=mod;\n        prod*=inv(fact[k]);\n        prod%=mod;\n        return prod;\n    }\n\n    static long power(long x, long y){\n        if (y == 0)\n            return 1;\n        if (y%2 == 1)\n            return (x*power(x, y-1))%mod;\n        return power((x*x)%mod, y/2)%mod;\n    }\n\n    static void sieve(int n){\n\n        prime = new boolean[n+1];\n        for(int i=2;i<n;i++)\n            prime[i] = true;\n\n        for(int p = 2; p*p <=n; p++)\n        {\n            if(prime[p])\n            {\n                for(int i = p*p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n\n    }\n\n    static long abs(long a){\n        return Math.abs(a);\n    }\n\n    static int abs(int a){\n        return Math.abs(a);\n    }\n\n    static int max(int a,int b){\n        if(a>b)\n            return a;\n        else\n            return b;\n    }\n    static double max(double a,double b){\n        if(a>b)\n            return a;\n        else\n            return b;\n    }\n    static double min(double a,double b){\n        if(a>b)\n            return b;\n        else\n            return a;\n    }\n\n    static int min(int a,int b){\n        if(a>b)\n            return b;\n        else\n            return a;\n    }\n\n    static long max(long a,long b){\n        if(a>b)\n            return a;\n        else\n            return b;\n    }\n\n    static long min(long a,long b){\n        if(a>b)\n            return b;\n        else\n            return a;\n    }\n\n    static long sq(long num){\n        return num*num;\n    }\n\n    static double sq(double num){\n        return num*num;\n    }\n\n    static long sqrt(long num){\n        return (long)Math.sqrt(num);\n    }\n\n    static double sqrt(double num){\n        return Math.sqrt(num);\n    }\n\n    static private void removeNode(LNode n){\n        if(n.prev!=null){\n            n.prev.next = n.next;\n        }else{\n            head = n.next;\n        }\n\n        if(n.next!=null){\n            n.next.prev = n.prev;\n        }else{\n            tail = n.prev;\n        }\n    }\n\n    static private void offerNode(LNode n){\n\n        if(tail!=null){\n            tail.next = n;\n        }\n\n        n.prev = tail;\n        n.next = null;\n        tail = n;\n\n        if(head == null){\n            head = tail;\n        }\n    }\n\n    static class FastScanner {\n\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        //        void readArray(int n) {\n//            arr = new long[n];\n//            for (int i = 0; i < n; i++)\n//                arr[i] = nextLong();\n//        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n\npublic class b{ \n\n     static FastScanner sc;\n     static TreeSet<Integer> ans;\n     static long[] arr,a,dp;\n     static char[][] board;\n     static long mul,mul1;\n     static int[] spf;\n     static char[] ch;\n     static int n,q,m;\n     static long k,x;\n     static StringBuilder sb;\n     static long b,sum;\n     static Map<Integer,List<Integer>> map;\n    static Map<Long,List<Integer>> map2;\n    static Map<Long,List<Integer>> map3;\n    static Map<Integer,Integer> shortest;\n    static Map<Integer,List<Integer>> map1;\n    static List<Integer> list,list1;\n    static int[] count;\n\n    // static class Node{\n    //     long dist;\n    //     Set<Integer> set;\n    //     Node(){\n    //         this.set = new HashSet<>();\n    //     }\n    //     Node(int f){\n    //         this.dist = f;\n    //         this.set = new HashSet<>();\n    //     }\n    // }\n\n    // public static class Lca {\n\n    //     int[] depth;\n    //     int[] dfs_order;\n    //     int cnt;\n    //     int[] first;\n    //     int[] minPos;\n    //     int n;\n\n    //     void dfs(List<Integer>[] tree, int u, int d) {\n    //         depth[u] = d;\n    //         dfs_order[cnt++] = u;\n    //         for (int v : tree[u])\n    //             if (depth[v] == -1) {\n    //                 dfs(tree, v, d + 1);\n    //                 dfs_order[cnt++] = u;\n    //             }\n    //     }\n\n    //     void buildTree(int node, int left, int right) {\n    //         if (left == right) {\n    //             minPos[node] = dfs_order[left];\n    //             return;\n    //         }\n    //         int mid = (left + right) >> 1;\n    //         buildTree(2 * node + 1, left, mid);\n    //         buildTree(2 * node + 2, mid + 1, right);\n    //         minPos[node] = depth[minPos[2 * node + 1]] < depth[minPos[2 * node + 2]] ? minPos[2 * node + 1] : minPos[2 * node + 2];\n    //     }\n\n    //     public Lca(List<Integer>[] tree, int root) {\n    //         int nodes = tree.length;\n    //         depth = new int[nodes];\n    //         Arrays.fill(depth, -1);\n\n    //         n = 2 * nodes - 1;\n    //         dfs_order = new int[n];\n    //         cnt = 0;\n    //         dfs(tree, root, 0);\n\n    //         minPos = new int[4 * n];\n    //         buildTree(0, 0, n - 1);\n\n    //         first = new int[nodes];\n    //         Arrays.fill(first, -1);\n    //         for (int i = 0; i < dfs_order.length; i++)\n    //             if (first[dfs_order[i]] == -1)\n    //                 first[dfs_order[i]] = i;\n    //     }\n\n    //     public int lca(int a, int b) {\n    //         return minPos(Math.min(first[a], first[b]), Math.max(first[a], first[b]), 0, 0, n - 1);\n    //     }\n\n    //     int minPos(int a, int b, int node, int left, int right) {\n    //         if (a == left && right == b)\n    //             return minPos[node];\n    //         int mid = (left + right) >> 1;\n    //         if (a <= mid && b > mid) {\n    //             int p1 = minPos(a, Math.min(b, mid), 2 * node + 1, left, mid);\n    //             int p2 = minPos(Math.max(a, mid + 1), b, 2 * node + 2, mid + 1, right);\n    //             return depth[p1] < depth[p2] ? p1 : p2;\n    //         } else if (a <= mid) {\n    //             return minPos(a, Math.min(b, mid), 2 * node + 1, left, mid);\n    //         } else if (b > mid) {\n    //             return minPos(Math.max(a, mid + 1), b, 2 * node + 2, mid + 1, right);\n    //         } else {\n    //             throw new RuntimeException();\n    //         }\n    //     }\n    // }\n\n    // private static long dfs(int v, int parent,long ht) {\n\n    //     List<Integer> list = map.get(v);\n    //     hyt[v] = ht;\n\n    //     if(list.size() == 1){\n    //         if(!map3.containsKey(ht))\n    //             map3.put(ht,new ArrayList<>());\n\n    //         map3.get(ht).add(v);\n    //         return ht;\n\n    //     }\n\n    //     long maxl = -1;\n    //     for(Integer i : list){\n    //         if(i == parent)\n    //             continue;\n    //         maxl = Math.max(maxl,dfs(i,v,ht+1));\n    //     }\n\n    //     return maxl;\n\n    // }\n    // public static int N = 100005;\n\n    // long a[N];\n    // long sfx[N];\n    // long pfx[N];\n\n    public static boolean f(int width){\n\n        // long[] a = new long[n];\n        long[] sfx = new long[n];\n        long[] pfx = new long[n];\n\n        for (int j = 0; j < n; j++){\n            if (j % width == 0){\n                pfx[j] = a[j];\n            }\n            else pfx[j] = gcd(pfx[j - 1], a[j]);\n        }\n        for (int j = n - 2; j >= 0; j--){\n            if (j % width == width - 1){\n                sfx[j] = a[j];\n            }\n            else sfx[j] = gcd(sfx[j + 1], a[j]);\n        }\n\n        for(int j = 0; j < n - width + 1 ; j++){\n            if (gcd(sfx[j], pfx[j + width - 1]) >= k) return true;\n            if (((j % width) == width - 1) && pfx[j] >= k){\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    public static int solve(){\n\n        int lo = 0;\n        int hi = n+1;\n        while (hi - lo > 1){\n            int mid = (hi + lo) / 2;\n            if (f(mid)){\n                lo = mid;\n            }\n            else{\n                hi = mid;\n            }\n        }\n\n        return lo+1;\n\n    }\n        \n     public static void main(String[] args) {\n\n            sc = new FastScanner();\n            // Scanner sc = new Scanner(System.in);\n            // SpecialSieve(5000000+5);\n            int t = sc.nextInt();\n            // sb = new StringBuilder();\n            // int t = 1;\n            while(t > 0){\n\n                // a = sc.nextLong();\n                n = sc.nextInt();\n                k = 2;\n                // x = sc.nextLong();\n                // m = sc.nextInt();\n                // mat = new int[2][m];\n\n                // for(int i = 0 ; i < 2 ; i++)\n                //     for(int j = 0 ; j < m ; j++)\n                //         mat[i][j] = sc.nextLong();\n\n                // for(int i = 1 ; i <= 15 ; i++){\n                //     m = i;\n                //     solve();\n                // // }\n                // board = new char[3][3];\n                // for(int i = 0 ; i < 3 ; i++){\n                //     String s = sc.next();\n                //     for(int j = 0 ; j < 3 ; j++){\n                //         board[i][j] = s.charAt(j);\n                //     }\n                // }\n                // x = sc.nextInt();\n                // ch = sc.next().toCharArray();\n                // q = sc.nextInt();\n                // ch = sc.next().toCharArray();\n                arr = new long[n];\n                for(int i = 0 ; i < n ; i++)\n                    arr[i] = sc.nextLong();\n\n                a = new long[n-1];\n                for(int i = 1 ; i < n ; i++)\n                    a[i-1] = Math.abs(arr[i] - arr[i-1]);\n\n                n -= 1;\n\n                System.out.println(solve());\n                t -= 1;\n            }\n            // System.out.print(sb);\n\n     }\n\n    // Use this instead of Arrays.sort() on an array of ints. Arrays.sort() is n^2\n    // worst case since it uses a version of quicksort. Although this would never\n    // actually show up in the real world, in codeforces, people can hack, so\n    // this is needed.\n    static void ruffleSort(long[] a) {\n        //ruffle\n        int n=a.length;\n        Random r=new Random();\n        for (int i=0; i<a.length; i++) {\n            int oi=r.nextInt(n);long temp=a[i];\n            a[i]=a[oi];\n            a[oi]=temp;\n        }\n        \n        //then sort\n        Arrays.sort(a);\n    }\n    public static long gcd(long a, long b)\n    {\n      if (b == 0)\n        return a;\n\n      return gcd(b, a % b); \n      \n    }\n     public static int log(double n,double base){\n\n        if(n == 0 || n == 1)\n            return 0;\n\n        if(n == base)\n            return 1;\n\n        double num = Math.log(n);\n        double den = Math.log(base);\n\n        if(den == 0)\n            return 0;\n\n        return (int)(num/den);\n    }\n    public static long mod(long x, long mod)\n{\n    long result = x % mod;\n    if (result < 0)\n    {\n        result += mod;\n    }\n    return result;\n}\n    \n    // Use this to input code since it is faster than a Scanner\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        int[] readArray(int n) {\n            int[] a=new int[n];\n            for (int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\nfrom math import gcd\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\n\nclass segmenttree:\n    def __init__(self, arr, n):\n        self.tree, self.n = [0] * (2 * n), n\n        for i in range(2 * n - 1, 0, -1):\n            if i >= n:\n                self.tree[i] = arr[i - n]\n            else:\n                self.tree[i] = gcd(self.tree[i << 1], self.tree[(i << 1) + 1])\n\n    def query(self, l, r):\n        res = 0\n        l += self.n\n        r += self.n\n        while l < r:\n            if l & 1:\n                res = gcd(self.tree[l], res)\n                l += 1\n            if r & 1:\n                r -= 1\n                res = gcd(self.tree[r], res)\n            l >>= 1\n            r >>= 1\n\n        return res\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\nfor _ in range(int(input())):\n    n, a, ans = int(input()), inp(int), 0\n    a = [a[i] - a[i - 1] for i in range(1, n)]\n    tree, g, be = segmenttree(a, n - 1), 0, 0\n\n    for i in range(n - 1):\n        g = gcd(a[i], g)\n        while g == 1 and be <= i:\n            be += 1\n            g = tree.query(be, i + 1)\n\n        ans = max(ans, i - be + 1)\n\n    print(ans + 1)\n"
        },
        {
            "language": 3,
            "solution": "'''\nCreated: 02-08-2021 at 01:51:42\nAuthor : Aaditya Upadhyay\n'''\nimport os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\ndef st(): return list(sys.stdin.readline().strip())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef mp(): return map(int, sys.stdin.readline().split())\ndef inp(): return int(sys.stdin.readline())\ndef pr(n): return sys.stdout.write(str(n)+\"\\n\")\ndef prl(n): return sys.stdout.write(str(n)+\" \")\n\n\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\n\ndef solve():\n    def getGCD(a, b):\n        p = logs[b-a+1]\n        plen = 1 << p\n        return gcd(table[p][a], table[p][b-plen+1])\n    N = inp()\n    ans = 0\n    x = li()\n    l = [abs(x[i]-x[i+1]) for i in range(N-1)]\n    n = N - 1\n    maxlog = 20\n\n    logs = [0 for i in range(n+1)]\n    for i in range(2, n+1):\n        logs[i] = logs[i >> 1]+1\n\n    table = [[0 for i in range(n+1)] for j in range(maxlog)]\n\n    for i in range(logs[n]+1):\n        j = 0\n        cur = 1 << i\n        while j+cur <= n:\n            if cur == 1:\n                table[i][j] = l[j]\n            else:\n                table[i][j] = gcd(table[i-1][j], table[i-1][j + (cur//2)])\n            j += 1\n    low = 1\n    high = n\n    while low <= high:\n        flag = 0\n        mid = (low+high)//2\n        for i in range(n-mid+1):\n            cur = getGCD(i, i+mid-1)\n            if cur > 1:\n                flag = 1\n                break\n        if flag:\n            ans = mid + 1\n            low = mid + 1\n        else:\n            high = mid - 1\n    pr(max(1, ans))\n\n\nfor _ in range(inp()):\n    solve()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 200005;\nconst long long K = 24;\nlong long st[MAXN][K + 1];\nlong long LOG[MAXN];\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long query(long long L, long long R) {\n  long long j = LOG[R - L + 1];\n  return gcd(st[L][j], st[R - (1 << j) + 1][j]);\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> v(n);\n  for (auto &i : v) cin >> i;\n  if (n == 1) {\n    cout << 1 << \"\\n\";\n    return;\n  }\n  long long m = n - 1;\n  vector<long long> diff(m);\n  for (long long i = 0; i < m; i++) diff[i] = abs(v[i + 1] - v[i]);\n  for (long long i = 0; i < m; i++) st[i][0] = diff[i];\n  for (long long j = 1; j <= K; j++) {\n    for (long long i = 0; i + (1 << j) <= m; i++) {\n      st[i][j] = gcd(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n    }\n  }\n  long long j = 0;\n  long long ans = 1;\n  for (long long i = 0; i < m; i++) {\n    while (j <= i && query(j, i) == 1) j++;\n    ans = max(ans, i - j + 2);\n  }\n  cout << ans << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  LOG[1] = 0;\n  for (long long i = 2; i < MAXN; i++) LOG[i] = LOG[i / 2] + 1;\n  long long tc;\n  tc = 1;\n  cin >> tc;\n  while (tc--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\ntesting = len(sys.argv) == 4 and sys.argv[3] == \"myTest\"\ninteractive = False\nif testing:\n    cmd = sys.stdout\n    from time import time\n    start_time = int(round(time() * 1000)) \n    readAll = open(sys.argv[1], 'r').read\n    sys.stdout = open(sys.argv[2], 'w')\nelse:\n    readAll = sys.stdin.read\n\n# ############ ---- I/O Functions ---- ############\n\nclass InputData:\n    def __init__(self):\n        self.lines = readAll().split('\\n')\n        self.n = len(self.lines)\n        self.ii = -1\n    def input(self):\n        self.ii += 1\n        assert self.ii < self.n\n        return self.lines[self.ii]\n\nflush = sys.stdout.flush\nif interactive and not testing:\n    input = sys.stdin.readline\nelse:\n    inputData = InputData()\n    input = inputData.input\n\ndef intin():\n    return(int(input()))\ndef intlin():\n    return(list(map(int,input().split())))\ndef chrin():\n    return(list(input()))\ndef strin():\n    return input()\ndef lout(l, sep=\"\\n\", toStr=True):\n    print(sep.join(map(str, l) if toStr else l))\ndef dout(*args, **kargs):\n    if not testing: return\n    if args: print(args[0] if len(args)==1 else args)\n    if kargs: print([(k,v) for k,v in kargs.items()])\ndef ask(q):\n    sys.stdout.write(str(q)+'\\n')\n    flush()\n    return intin()\n    \n# ############ ---- I/O Functions ---- ############\n\n# from math import ceil\nfrom collections import defaultdict as ddict, Counter\n# from heapq import *\n# from Queue import Queue\nclass ST:\n    def __init__(self, a, f):\n        self.n = len(a)\n        self.f = f\n        self.tree = [None]*(2*self.n)\n        self.build(a)\n\n    def build(self, a):\n        for i in xrange(self.n):\n            self.tree[self.n+i] = a[i]\n        for i in xrange(self.n-1,0,-1):\n            self.tree[i] = self.f(self.tree[i<<1], self.tree[i<<1 | 1])\n    \n    def update(self, i, v):\n        i += self.n\n        self.tree[i] = v\n        while i > 1:\n            self.tree[i>>1] = self.f(self.tree[i], self.tree[i^1])\n            i >>= 1\n\n    def query(self, l, r):\n        #to find the sum in the range [l,r)\n        v = 0\n        l,r = (l+self.n,self.n+r)\n        while l < r:\n            if (l&1)>0:\n                v = self.f(v, self.tree[l])\n                l += 1\n            if (r&1)>0:\n                r -= 1\n                v = self.f(v, self.tree[r])\n            l >>= 1\n            r >>= 1\n        return v\n \nclass SparseTable:\n    def __init__(self, a, f, nv=0):\n        self.f, self.nv = [f, nv]\n        self.k = 0\n        while (1<<self.k) <= len(a):\n            self.k += 1\n        self.table = [[nv]*len(a) for _ in xrange(self.k)]\n        self.build(a)\n\n    def build(self, a):\n        for i in xrange(len(a)):\n            self.table[0][i] = a[i]\n        for j in xrange(1, self.k):\n            i = 0\n            while (i+(1<<j)) <= len(a):\n                self.table[j][i] = self.f(self.table[j-1][i], self.table[j-1][i+(1<<(j-1))])\n                i += 1\n\n    def query(self, l, r):\n        ans = self.nv\n        for j in xrange(self.k, -1, -1):\n            if (1<<j) < r-l+1:\n                ans = self.f(ans, self.table[j][l])\n                l += (1<<j)\n        return ans\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a%b\n    return a\n\ndef main():\n    n = intin()\n    a = intlin()\n    if n == 1:\n        return 1\n    b = [abs(a[i] - a[i-1]) for i in xrange(1,n)]\n    ans = 1 + int(max(b)>1)\n    st = SparseTable(b, gcd, nv=0)\n    i = 0\n    j = 1\n    while i < len(b) and j < len(b):\n        if st.query(i,j+1) != 1:\n            ans = max(ans, j-i+2)\n            j += 1\n        else:\n            i += 1\n            if i == j:\n                j = i+1\n    return ans\n\n\n\n\nanss = []\nfor _ in xrange(intin()):\n    anss.append(main())\n    # anss.append(\"YES\" if main() else \"NO\")\nlout(anss)\n\nif testing:\n    sys.stdout = cmd\n    print(int(round(time() * 1000))  - start_time)"
        },
        {
            "language": 3,
            "solution": "# not my soln\nfrom math import gcd\nclass RangeQuery:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n\n    def __getitem__(self, idx):\n        return self._data[0][idx]\n\ndef func(k, d):\n    for i in range(k, len(d) + 1):\n        temp = obj.query(i - k, i)\n        if temp > 1 or temp == 0:\n            return 0\n    return 1\n\nt = int(input())\nwhile(t):\n    t -= 1\n    n = int(input())\n    l = [int(i) for i in input().split()]\n    d = []\n    for i in range(n - 1):\n        d.append(abs(l[i+1] - l[i]))\n    \n    l = 1\n    r = n\n    # print(*d)\n    obj = RangeQuery(d, gcd)\n    \n    while(l < r):\n        mid = l + (r - l)//2\n        if(func(mid, d)):\n            r = mid\n        else:\n            l = mid + 1\n    print(l)\n    \n    \n    \n    \n    \n    "
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while x>1:\n            x, y=y%x, x\n        if x==1:\n            return 1\n        else:        \n            return y\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2                                    \n\n #   total=bmax\n #   c=int(math.log2(bmax))\n #   k=0\n #   while k+total<n:\n #       if St[k][c]!=1:\n #           start=total+1\n #           end=min(n-k-1, bmax*2-1)\n #           while start<=end:\n #               j=(start+end)//2\n #               if HCF(St[k][c], St[k+j-2**c][c])!=1:\n #                   total=j\n #                   start=j+1\n #               else:\n #                   end=j-1    \n #       k+=1\n\n#    def possible_group(x, y):\n#        c=b[x]\n#        for i in range(x+1, y):\n#            c=HCF(c, b[i])\n#            if c==1:\n#                return False\n#        return True        \n\n#    total=bmax\n#    start=bmax+1\n#    end=min(n-1, bmax*2-1)\n#    c=int(math.log2(bmax))\n#    upton=2**c\n#    while start<=end:\n#        j=(start+end)//2\n#        for k in range(n-j):            \n#            if HCF(St[k][c], St[k+j-upton][c])!=1:\n#                total=j\n#                start=j+1\n#                break\n#        if start<=j:\n#            end=j-1\n\n    def possible_group(l, r):\n        c=int(math.log2(r-l))\n        return HCF(St[l][c], St[r-2**c][c])!=1\n\n    total=bmax+1\n    l=0\n    r=total\n    while r<n:\n        while r-l+1>total and not possible_group(l,r):\n            l+=1\n        if r-l+1>total:\n            total=r-l+1\n        r+=1 \n\n    \n    print(total)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n# from typing import *\n\nimport sys\nimport io\nimport math\nimport collections\nimport decimal\nimport itertools\nimport bisect\nimport heapq\n\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\n\n# sys.setrecursionlimit(1000000)\n\n# _INPUT = \"\"\"4\n# 2\n# 5 8\n# 4\n# 8 2 5 10\n# 2\n# 1000 2000\n# 8\n# 465 55 3 54 234 12 45 78\n\n# \"\"\"\n# sys.stdin = io.StringIO(_INPUT)\n\nINF = 10**20\n\nclass SegTree_GCD:\n    def __init__(self, a):\n        n = len(a)\n        self.n1 = 2 ** (n-1).bit_length()\n        self.dat = [0] * self.n1 + a + [INF] * (self.n1-n)\n        for i in reversed(range(1, self.n1)):\n            self.dat[i] = self.gcd1(self.dat[i*2], self.dat[i*2+1])\n    \n    def gcd1(self, v1, v2) -> int:\n        if v1 == INF:\n            return v2\n        elif v2 == INF:\n            return v1\n        else:\n            return math.gcd(v1, v2)\n\n    def get_rgcd(self, l, r) -> int:\n        l += self.n1\n        r += self.n1\n        v = INF\n        while l < r:\n            if l & 1:\n                v = self.gcd1(v, self.dat[l])\n                l += 1\n            if r & 1:\n                v = self.gcd1(v, self.dat[r-1])\n                r -= 1\n            l //= 2\n            r //= 2\n        return v\n\n\ndef solve(N, A):\n    if N == 1:\n        return 1\n\n    B = [A[i+1] - A[i] for i in range(N-1)]\n    \n    segt_gcd = SegTree_GCD(B)\n    length = 0\n    r = 1\n    for l in range(N-1):\n        r = l + length\n        while r+1 <= N-1 and segt_gcd.get_rgcd(l, r+1) not in [1, -1]:\n            r += 1\n        length = max(length, r-l)\n\n    return length + 1\n\nT0 = int(input())\nfor _ in range(T0):\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(solve(N, A))"
        },
        {
            "language": 4,
            "solution": "// Integers have friends\n// This question requires knowledge of Sparse Table OR Segment Tree, which I don't have currently.\n\n// Trying to solve this question, again on 07-08-2021 after learning sparse table..\n\nimport java.io.*;\nimport java.util.*;\npublic class D {\n    public static void main(String[] args)throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(br.readLine());\n\n        String input[];\n        StringBuilder sb = new StringBuilder(\"\");\n        int max_size = 200000;\n        long arr[] = new long[max_size];\n        long diff[] = new long[max_size];\n        \n        int ans = 0;\n        int n;\n        int i, j;\n        int main_size;\n        \n        while(t-->0){\n            n = Integer.parseInt(br.readLine());\n            input = br.readLine().trim().split(\" \");\n\n            // ans = Math.min(n, 2);\n            ans = 0;\n\n            for(i=0; i<n; i++){\n                arr[i] = Long.parseLong(input[i]);\n            }\n\n            if(n==1){\n                sb.append(\"1\\n\");\n                continue;\n            }\n\n            for(i=1; i<n; i++){\n                diff[i-1] = Math.abs(arr[i] - arr[i-1]);\n            }\n            main_size = n-1;\n\n            // int sp_size = (int)(Math.log(main_size)/Math.log(2)) + 1;\n            int sp_size = (int)(logbase2(main_size))+1;\n            // System.out.println(\"size: \"+sp_size+\" \"+Math.log(main_size)+\" \"+main_size);\n            long sparse_table[][] = new long[sp_size][main_size];\n            for(j=0; j<main_size; j++){\n                sparse_table[0][j] = diff[j];\n            }\n            int tmp = 1;\n            for(i=1; i<sp_size; i++){\n                for(j=0; j<main_size; j++){\n                    long other = (j+tmp<main_size)?sparse_table[i-1][j+tmp]:sparse_table[i-1][j];\n                    sparse_table[i][j] = gcd(sparse_table[i-1][j], other);\n                    // System.out.print(sparse_table[i][j]+\": \"+sparse_table[i-1][j]+\"+\"+other+\"  \");\n                }\n                tmp = tmp<<1;\n                // System.out.println();\n            }\n            \n            // for(i=0; i<sp_size; i++){\n            //     for(j=0; j<main_size; j++){\n            //         System.out.print(sparse_table[i][j]+\" \");\n            //     }\n            //     System.out.println();\n            // }\n\n\n            for(i=0; i<main_size; i++){\n                int low = i;\n                int high = main_size-1;\n                int mid;\n                while(low<=high){\n                    mid = low + (high-low)/2;\n                    // int len = (int)(Math.log(mid-i+1)/Math.log(2));\n                    // int len = logbase2(mid-i+1);\n\n                    // int gd = sparse_table[len][i];\n                    // if(Math.pow(2, len)!=mid-i+1)\n                    //     gd = gcd(sparse_table[len][i], sparse_table[len][main_size-(int)(Math.pow(2, len))]);\n\n                    int len = (int)(logbase2(mid-i+1));\n                    long gd = gcd(sparse_table[len][i], sparse_table[len][mid-(1<<len)+1]);\n                    if(gd==1){\n                        high = mid-1;\n                    }else{\n                        low = mid+1;\n                    }\n                }\n                // System.out.println(i+\" \"+high+\" \"+(high-i+2));\n                ans = Math.max(ans, high-i+2);\n            }\n\n            sb.append(ans+\"\\n\");\n            // System.out.println(ans);\n\n        }\n        \n        System.out.println(sb);\n    }\n\n    public static long gcd(long a, long b){\n        if(b==0){\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n    public static long logbase2(long a){\n        if(a==1){\n            return 0;\n        }\n        long tmp = 1;\n        long pow = 0;\n        while(true){\n            if(tmp==a){\n                return pow;\n            }\n            if(tmp>a){\n                return pow-1;\n            }\n            tmp = tmp<<1;\n            pow++;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import math\n#####segfunc#####\ndef segfunc(x, y):\n    return math.gcd(x,y)\n#################\n\n#####ide_ele#####\nide_ele = 0\n#################\n\nclass SegTree:\n    \"\"\"\n    init(init_val, ide_ele): \u914d\u5217init_val\u3067\u521d\u671f\u5316 O(N)\n    update(k, x): k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0 O(logN)\n    query(l, r): \u533a\u9593[l, r)\u3092segfunc\u3057\u305f\u3082\u306e\u3092\u8fd4\u3059 O(logN)\n    \"\"\"\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        # \u914d\u5217\u306e\u5024\u3092\u8449\u306b\u30bb\u30c3\u30c8\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        # \u69cb\u7bc9\u3057\u3066\u3044\u304f\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        \"\"\"\n        k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0\n        k: index(0-index)\n        x: update value\n        \"\"\"\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        \"\"\"\n        [l, r)\u306esegfunc\u3057\u305f\u3082\u306e\u3092\u5f97\u308b\n        l: index(0-index)\n        r: index(0-index)\n        \"\"\"\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\nimport sys\nimport math\nfrom collections import deque,Counter\nfrom sys import stdin\n\n#sys.setrecursionlimit(10**7)\nint1=lambda x: int(x)-1\n\ninp=lambda :int(input())\nmi=lambda :map(int,input().split())\nli=lambda :list(mi())\nmi1=lambda :map(int1,input().split())\nli1=lambda :list(mi1())\nmis=lambda :map(str,input().split())\nlis=lambda :list(mis())\n\nstinput=lambda :stdin.readline()[:-1]\nstinp=lambda :int(stinput())\nstmi=lambda :map(int, stdin.readline().split())\nstli=lambda :list(stmi())\nstmi1=lambda :map(int1, stdin.readline().split())\nstli1=lambda :list(stmi1())\nstmis=lambda :stdin.readline()[:-1]\n\npr=print\n\nfrom collections import defaultdict\n\"\"\"\n#\u521d\u671f\u5024 0\nd=defaultdict(int)\n\n#\u521d\u671f\u5024 1\nd=defaultdict(lambda:1)\n\"\"\"\n\nmod=10**9+7\nMod=998244353\nINF=10**18\nans=0\n\nt=inp()\nfor _ in range(t):\n  n=inp()\n  a=stli()\n  b=[0]*(n-1)\n  for i in range(n-1):\n    b[i]=abs(a[i]-a[i+1])\n  seg = SegTree(b, segfunc, ide_ele)\n  ans=0\n  i=0\n  j=0\n  while i<n-1:\n    if i==j:\n      i+=1\n    else:\n      g=seg.query(j,i+1)\n      #print(i,j,g)\n      if g!=1:\n        ans=max(ans,i-j+2)\n        i+=1\n      else:\n        j+=1\n  if b and max(b)!=1:\n    ans=max(ans,2)\n  print(max(ans,1))"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nimport heapq\nimport bisect\nfrom collections import Counter\nfrom collections import defaultdict\nfrom io import BytesIO, IOBase\nimport string\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n        self.BUFSIZE = 8192\n\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef get_int():\n    return int(input())\n\n\ndef get_ints():\n    return list(map(int, input().split(' ')))\n\n\ndef get_int_grid(n):\n    return [get_ints() for _ in range(n)]\n\n\ndef get_str():\n    return input().strip()\n\n\ndef get_strs():\n    return get_str().split(' ')\n\n\ndef flat_list(arr):\n    return [item for subarr in arr for item in subarr]\n\n\ndef yes_no(b):\n    if b:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ndef binary_search(good, left, right, delta=1, right_true=False):\n    \"\"\"\n    Performs binary search\n    ----------\n    Parameters\n    ----------\n    :param good: Function used to perform the binary search\n    :param left: Starting value of left limit\n    :param right: Starting value of the right limit\n    :param delta: Margin of error, defaults value of 1 for integer binary search\n    :param right_true: Boolean, for whether the right limit is the true invariant\n    :return: Returns the most extremal value interval [left, right] which is good function evaluates to True,\n            alternatively returns False if no such value found\n    \"\"\"\n\n    limits = [left, right]\n    while limits[1] - limits[0] > delta:\n        if delta == 1:\n            mid = sum(limits) // 2\n        else:\n            mid = sum(limits) / 2\n        if good(mid):\n            limits[int(right_true)] = mid\n        else:\n            limits[int(~right_true)] = mid\n    if good(limits[int(right_true)]):\n        return limits[int(right_true)]\n    else:\n        return False\n\n\ndef prefix_sums(a):\n    p = [0]\n    for x in a:\n        p.append(p[-1] + x)\n    return p\n\n\ndef solve_a():\n    p = get_int()\n    if p == 5:\n        return 2, 4\n    else:\n        return 2, (p - 1) // 2\n\n\ndef solve_b():\n    n = get_int()\n    enemy = list(get_str())\n    me = list(get_str())\n    cnt = 0\n\n    for i in range(n):\n        if me[i] == '1' and enemy[i] == '0':\n            cnt += 1\n        elif i > 0 and me[i] == '1' and enemy[i - 1] == '1':\n            enemy[i - 1] = 'x'\n            cnt += 1\n        elif i < n - 1 and me[i] == '1' and enemy[i + 1] == '1':\n            enemy[i + 1] = 'x'\n            cnt += 1\n    return cnt\n\n\ndef solve_c():\n    n, m = get_ints()\n    num_big = [0] * n\n    inv_cnt = n\n\n    def add_edge(u, v):\n        if u > v:\n            u, v = v, u\n        u, v = u - 1, v - 1\n        num_big[u] += 1\n        if num_big[u] == 1:\n            return - 1\n        return 0\n\n    def rem_edge(u, v):\n        if u > v:\n            u, v = v, u\n        u, v = u - 1, v - 1\n        num_big[u] -= 1\n        if num_big[u] == 0:\n            return 1\n        return 0\n\n    for edge in range(m):\n        u, v = get_ints()\n        inv_cnt += add_edge(u, v)\n\n    q = get_int()\n\n    for _ in range(q):\n        dat = get_ints()\n        if dat[0] == 3:\n            print(inv_cnt)\n        if dat[0] == 1:\n            inv_cnt += add_edge(dat[1], dat[2])\n        if dat[0] == 2:\n            inv_cnt += rem_edge(dat[1], dat[2])\n\n\nclass GCDStack:\n    def __init__(self):\n        self.s = []\n        self.s_gcd = [0]\n\n    def push(self, x):\n        self.s.append(x)\n        self.s_gcd.append(math.gcd(self.s_gcd[-1], x))\n\n    def pop(self):\n        res = self.s[-1]\n        self.s.pop()\n        self.s_gcd.pop()\n        return res\n\n    def gcd(self):\n        return self.s_gcd[-1]\n\n\nclass GCDQueue:\n    def __init__(self):\n        self.s1 = GCDStack()\n        self.s2 = GCDStack()\n\n    def add(self, x):\n        self.s1.push(x)\n\n    def remove(self):\n        if not self.s2.s:\n            while self.s1.s:\n                self.s2.push(self.s1.pop())\n        return self.s2.pop()\n\n    def gcd(self):\n        return math.gcd(self.s1.gcd(), self.s2.gcd())\n\n    def good(self):\n        return self.gcd() != 1\n\n\n\ndef solve_d():\n    n = get_int()\n    a = get_ints()\n    d = [a[i] - a[i - 1] for i in range(1, n)]\n    Q = GCDQueue()\n    M = 0\n    l = 0\n    for r in range(n - 1):\n        Q.add(d[r])\n        while not Q.good():\n            Q.remove()\n            l += 1\n        M = max(M, r - l + 1)\n    return M + 1\n\n\nt = get_int()\nfor _ in range(t):\n    print(solve_d())\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\n\nimport java.math.*;\nimport java.math.BigInteger;\n\n\npublic final class B\n{    \n\tstatic PrintWriter out = new PrintWriter(System.out); \n\tstatic StringBuilder ans=new StringBuilder();\n\tstatic FastReader in=new FastReader();\n//\tstatic ArrayList<Pair> g[];\n\tstatic long mod=(long)998244353,INF=Long.MAX_VALUE;\n\tstatic boolean set[],col[]; \n\tstatic int par[],tot[],partial[];\n\tstatic int D[],P[][];\n\tstatic int dp[][],sum=0,size[];\n\tstatic long seg[];\n\t//\tstatic node1 seg[];\n\t//static pair moves[]= {new pair(-1,0),new pair(1,0), new pair(0,-1), new pair(0,1)};\n\tpublic static void main(String args[])throws IOException\n\t{\t\t\t\t\n\t\tint T=i();\n\t\twhile(T-->0)\n\t\t{\n\t\t\tint N=i();\n\t\t\t\n\t\t\tlong lt=l();\n\t\t\tif(N==1)\n\t\t\t{\n\t\t\t\tans.append(\"1\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlong A[]=new long[N-1];\n\t\t\tfor(int i=0; i<N-1; i++)\n\t\t\t{\n\t\t\t\tlong a=l();\n\t\t\t\tA[i]=Math.abs(a-lt);\n\t\t\t\tlt=a;\n\t\t\t}\n\t\t\tseg=new long[4*N+5];\n\t\t\tbuild(1,0,N-2,A);\n//\t\t\tprint(seg);\n\t\t\tint max=1;\n\t\t\tint l=0;\n\t\t\t//print(A);\n//\t\t\tSystem.out.println(ask(1,0,N-2,1,1)+\" \"+GCD(0,5));\n\t\t\tfor(int i=1; i<N; i++)\n\t\t\t{\n\t\t\t\tlong g=ask(1,0,N-2,l,i-1);\n\t\t\t\t//System.out.println(\"GCD--> \"+g);\n\t\t\t\twhile(g==1 && l<i)\n\t\t\t\t{\n\t\t\t\t\tl++;\n\t\t\t\t\tg=ask(1,0,N-2,l,i-1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax=Math.max(i-l+1, max);\n\t\t\t\t//System.out.println(\"l--> \"+l+\" r--> \"+i+\" g--> \"+g+\" \"+max);\n\t\t\t}\n\t\t\tans.append(max+\"\\n\");\n\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n\tstatic int f(int i,int l,int r,int N)\n\t{\n\t\twhile(r-l>1)\n\t\t{\n\t\t\tint m=(l+r)/2;\n\t\t\tlong g=ask(1,0,N-2,i,m);\n\t\t\tif(g>1)l=m;\n\t\t\telse r=m;\n\t\t}\n\t\treturn l;\n\t}\n\tstatic void build(int v,int tl,int tr,long A[])\n\t{\n\t\tif(tl==tr)\n\t\t{\n\t\t\tseg[v]=A[tl];\n\t\t\treturn;\n\t\t}\n\t\tint tm=(tl+tr)/2;\n\t\tbuild(v*2,tl,tm,A);\n\t\tbuild(v*2+1,tm+1,tr,A);\n\t\tseg[v]=GCD(seg[v*2],seg[v*2+1]);\n\n\t}\n\tstatic long ask(int v,int tl,int tr,int l,int r)\n\t{\n\t\tif(l>r)return 0;\n\t\tif(tl==l && tr==r)\n\t\t{\n\t\t\treturn seg[v];\n\t\t}\n\t\tint tm=(tl+tr)/2;\t\t\n\t\tlong a=ask(v*2,tl,tm,l,Math.min(tm, r));\n\t\tlong b=ask(v*2+1,tm+1,tr,Math.max(l,tm+1),r);\n//\t\tSystem.out.print(tl+\" \"+tm+\" \"+tr+\" \");\n//\t\tSystem.out.println(a+\" \"+b);\n\t\treturn GCD(a,b);\n\t}\n\tstatic int cost(int s,int A[],int B[],int K)\n\t{\n\t\tint c=0;\n\t\tint N=A.length;\n\t\tfor(int i=0; i<N/2; i++)\n\t\t{\n\t\t\tif(B[i]==s)continue;\n\t\t\tif(s>B[i])\n\t\t\t{\n\t\t\t\t//we need to add\n\t\t\t\tint max=Math.max(K-A[i], K-A[N-i-1]);\n\t\t\t\tif(s-B[i]<=max)c++;\n\t\t\t\telse c+=2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint max=Math.max(A[i]-1, (K-A[N-i-1])-1);\n\t\t\t\tif(s-B[i]<=max)c++;\n\t\t\t\telse c+=2;\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\n\n\tstatic int [] sub(int A[],int B[])\n\t{\n\t\tint N=A.length;\n\t\tint f[]=new int[N];\n\t\tfor(int i=N-1; i>=0; i--)\n\t\t{\n\t\t\tif(B[i]<A[i])\n\t\t\t{\n\t\t\t\tB[i]+=26;\n\t\t\t\tB[i-1]-=1;\n\t\t\t}\n\t\t\tf[i]=B[i]-A[i];\n\t\t}\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tif(f[i]%2!=0)f[i+1]+=26;\n\t\t\tf[i]/=2;\n\t\t}\n\t\treturn f;\n\t}\n\tstatic int[] f(int  N)\n\t{\n\t\tchar X[]=in.next().toCharArray();\n\t\tint A[]=new int[N];\n\t\tfor(int i=0; i<N; i++)A[i]=X[i]-'a';\n\t\treturn A;\n\t}\n\n\n\n\n\tstatic int max(int a ,int b,int c,int d)\n\t{\n\t\ta=Math.max(a, b);\n\t\tc=Math.max(c,d);\n\t\treturn Math.max(a, c);\n\t}\n\tstatic int min(int a ,int b,int c,int d)\n\t{\n\t\ta=Math.min(a, b);\n\t\tc=Math.min(c,d);\n\t\treturn Math.min(a, c);\n\t}\n\n\n\n\tstatic HashMap<Integer,Integer> Hash(int A[])\n\t{\n\t\tHashMap<Integer,Integer> mp=new HashMap<>();\n\t\tfor(int a:A)\n\t\t{\n\t\t\tint f=mp.getOrDefault(a,0)+1;\n\t\t\tmp.put(a, f);\n\t\t}\n\t\treturn mp;\n\t}\n\tstatic long mul(long a, long b)\n\t{\n\t\treturn ( a %mod * 1L * b%mod )%mod;\n\t}\n\tstatic void swap(int A[],int a,int b)\n\t{\n\t\tint t=A[a];\n\t\tA[a]=A[b];\n\t\tA[b]=t;\n\t}\n\n\n\tstatic int find(int a)\n\t{\n\t\tif(par[a]<0)return a;\n\t\treturn par[a]=find(par[a]);\n\t}\n\tstatic void union(int a,int b)\n\t{\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a!=b)\n\t\t{\n\t\t\tpar[a]+=par[b];\n\t\t\tpar[b]=a;\n\t\t}\n\t}\n\tstatic boolean isSorted(int A[])\n\t{\n\t\tfor(int i=1; i<A.length; i++)\n\t\t{\n\t\t\tif(A[i]<A[i-1])return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic boolean isDivisible(StringBuilder X,int i,long num)\n\t{\n\t\tlong r=0;\n\t\tfor(; i<X.length(); i++)\n\t\t{\n\t\t\tr=r*10+(X.charAt(i)-'0');\n\t\t\tr=r%num;\n\t\t}\n\t\treturn r==0;\n\t}    \n\n\n\n\tstatic int lower_Bound(int A[],int low,int high, int x) \n\t{ \n\t\tif (low > high) \n\t\t\tif (x >= A[high]) \n\t\t\t\treturn A[high]; \n\n\t\tint mid = (low + high) / 2; \n\n\t\tif (A[mid] == x) \n\t\t\treturn A[mid]; \n\n\t\tif (mid > 0 && A[mid - 1] <= x && x < A[mid]) \n\t\t\treturn A[mid - 1]; \n\n\t\tif (x < A[mid]) \n\t\t\treturn lower_Bound( A, low, mid - 1, x); \n\n\t\treturn lower_Bound(A, mid + 1, high, x); \n\t} \n\n\tstatic String f(String A)\n\t{\n\t\tString X=\"\";\n\t\tfor(int i=A.length()-1; i>=0; i--)\n\t\t{\n\t\t\tint c=A.charAt(i)-'0';\n\t\t\tX+=(c+1)%2;\n\t\t}\n\t\treturn X;\n\t}\n\n\tstatic void sort(long[] a) //check for long\n\t{\n\t\tArrayList<Long> l=new ArrayList<>();\n\t\tfor (long i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\n\tstatic String swap(String X,int i,int j)\n\t{\n\t\tchar ch[]=X.toCharArray();\n\t\tchar a=ch[i];\n\t\tch[i]=ch[j];\n\t\tch[j]=a;\n\t\treturn new String(ch);\n\t}\n\n\tstatic int sD(long n)  \n\t{  \n\n\t\tif (n % 2 == 0 )  \n\t\t\treturn 2;  \n\n\t\tfor (int i = 3; i * i <= n; i += 2) {  \n\t\t\tif (n % i == 0 )  \n\t\t\t\treturn i;  \n\t\t}  \n\n\t\treturn (int)n;  \n\t}  \n\n\tstatic void setGraph(int N)\n\t{\n\t\ttot=new int[N+1];\n\t\tpartial=new int[N+1];\n\t\tD=new int[N+1];\n\t\tP=new int[N+1][(int)(Math.log(N)+10)];\n\t\tset=new boolean[N+1];\n//\t\tg=new ArrayList[N+1];\n\t\tfor(int i=0; i<=N; i++)\n\t\t{\n\n//\t\t\tg[i]=new ArrayList<>();\t\t\n\t\t\tD[i]=Integer.MAX_VALUE;\n\t\t\t//D2[i]=INF;\n\t\t}\n\t}\n\n\n\n\tstatic  long pow(long a,long b)\n\t{\n\t\t//long mod=1000000007;\n\t\tlong pow=1;\n\t\tlong x=a;\n\t\twhile(b!=0)\n\t\t{\n\t\t\tif((b&1)!=0)pow=(pow*x)%mod;\n\t\t\tx=(x*x)%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn pow;\n\t}\n\n\tstatic long toggleBits(long x)//one's complement || Toggle bits\n\t{\n\t\tint n=(int)(Math.floor(Math.log(x)/Math.log(2)))+1;\n\n\t\treturn ((1<<n)-1)^x;\n\t}\n\n\tstatic int countBits(long a)\n\t{\n\t\treturn (int)(Math.log(a)/Math.log(2)+1);\n\t}\n\n\tstatic long fact(long N)\n\t{ \n\t\tlong n=2; \n\t\tif(N<=1)return 1;\n\t\telse\n\t\t{\n\t\t\tfor(int i=3; i<=N; i++)n=(n*i)%mod;\n\t\t}\n\t\treturn n;\n\t}\n\n\tstatic int kadane(int A[])\n\t{\n\t\tint lsum=A[0],gsum=A[0];\n\t\tfor(int i=1; i<A.length; i++)\n\t\t{\n\t\t\tlsum=Math.max(lsum+A[i],A[i]);\n\t\t\tgsum=Math.max(gsum,lsum);\n\t\t}\n\t\treturn gsum;\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\n\tstatic boolean isPrime(long N)\n\t{\n\t\tif (N<=1)  return false; \n\t\tif (N<=3)  return true; \n\t\tif (N%2 == 0 || N%3 == 0) return false; \n\t\tfor (int i=5; i*i<=N; i=i+6) \n\t\t\tif (N%i == 0 || N%(i+2) == 0) \n\t\t\t\treturn false; \n\t\treturn true; \n\t}\n\tstatic void print(char A[])\n\t{\n\t\tfor(char c:A)System.out.print(c+\" \");\n\t\tSystem.out.println();\n\t}\n\tstatic void print(boolean A[])\n\t{\n\t\tfor(boolean c:A)System.out.print(c+\" \");\n\t\tSystem.out.println();\n\t}\n\tstatic void print(int A[])\n\t{\n\t\tfor(int a:A)System.out.print(a+\" \");\n\t\tSystem.out.println();\t\n\t}\n\tstatic void print(long A[])\n\t{\n\t\tfor(long i:A)System.out.print(i+ \" \");\n\t\tSystem.out.println();\n\n\t}\n\tstatic void print(boolean A[][])\n\t{\n\t\tfor(boolean a[]:A)print(a);\n\t}\n\tstatic void print(long A[][])\n\t{\n\t\tfor(long a[]:A)print(a);\n\t}\n\tstatic void print(int A[][])\n\t{\n\t\tfor(int a[]:A)print(a);\n\t}\n\tstatic void print(ArrayList<Integer> A)\n\t{\n\t\tfor(int a:A)System.out.print(a+\" \");\n\t\tSystem.out.println();\n\t}\n\n\tstatic int i()\n\t{\n\t\treturn in.nextInt();\n\t}\n\n\tstatic long l()\n\t{\n\t\treturn in.nextLong();\n\t}\n\n\tstatic int[] input(int N){\n\t\tint A[]=new int[N];\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tA[i]=in.nextInt();\n\t\t}\n\t\treturn A;\n\t}\n\n\tstatic long[] inputLong(int N)     {\n\t\tlong A[]=new long[N];\n\t\tfor(int i=0; i<A.length; i++)A[i]=in.nextLong();\n\t\treturn A;\n\t}\n\n\tstatic long GCD(long a,long b) \n\t{\n\t\tif(b==0)\n\t\t{\n\t\t\treturn a;\n\t\t}\n\t\telse return GCD(b,a%b );\n\t}\n\n}\n\n\n//Code For FastReader\n//Code For FastReader\n//Code For FastReader\n//Code For FastReader\nclass FastReader\n{\n\tBufferedReader br;\n\tStringTokenizer st;\n\tpublic FastReader()\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tString next()\n\t{\n\t\twhile(st==null || !st.hasMoreElements())\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\tcatch(IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt()\n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong()\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble()\n\t{\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tString nextLine()\n\t{\n\t\tString str=\"\";\n\t\ttry\n\t\t{\n\t\t\tstr=br.readLine();\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn str;\n\t}\n\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\ninput = sys.stdin.readline\nINF = 10**20\ndef gcd(a, b):\n    if a == INF:\n        return b\n    if b == INF:\n        return a\n    return math.gcd(a, b)\nclass LazySegmentTree:\n    def __init__(self, data, default=0, func=min):\n        \"\"\"initialize the lazy segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        self._lazy = [0] * (2 * _size)\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __len__(self):\n        return self._len\n\n    def _push(self, idx):\n        \"\"\"push query on idx to its children\"\"\"\n        # Let the children know of the queries\n        q, self._lazy[idx] = self._lazy[idx], 0\n\n        self._lazy[2 * idx] += q\n        self._lazy[2 * idx + 1] += q\n        self.data[2 * idx] += q\n        self.data[2 * idx + 1] += q\n\n    def _update(self, idx):\n        \"\"\"updates the node idx to know of all queries applied to it via its ancestors\"\"\"\n        for i in reversed(range(1, idx.bit_length())):\n            self._push(idx >> i)\n\n    def _build(self, idx):\n        \"\"\"make the changes to idx be known to its ancestors\"\"\"\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]\n            idx >>= 1\n\n    def add(self, start, stop, value):\n        \"\"\"lazily add value to [start, stop)\"\"\"\n        start = start_copy = start + self._size\n        stop = stop_copy = stop + self._size\n        while start < stop:\n            if start & 1:\n                self._lazy[start] += value\n                self.data[start] += value\n                start += 1\n            if stop & 1:\n                stop -= 1\n                self._lazy[stop] += value\n                self.data[stop] += value\n            start >>= 1\n            stop >>= 1\n\n        # Tell all nodes above of the updated area of the updates\n        self._build(start_copy)\n        self._build(stop_copy - 1)\n\n    def query(self, start, stop, default=1e9):\n        \"\"\"func of data[start, stop)\"\"\"\n        start += self._size\n        stop += self._size\n\n        # Apply all the lazily stored queries\n        self._update(start)\n        self._update(stop - 1)\n\n        res = default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"LazySegmentTree({0})\".format(self.data)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        s = list(map(int, input().split()))\n        s = [abs(s[i]-s[i+1]) for i in range(n-1)] + [1]\n        N = len(s)\n        T = LazySegmentTree(s, func=gcd)\n        ans = 1\n        for l in range(n - 1):\n            r = l + ans\n            if r >= n:\n                break\n            g = T.query(l, r, default=INF)\n            # dbp('queried:', difflist[l:r], 'got:', g)\n            if g == 1:\n                continue\n\n            while r < n and g > 1:\n                # dbp('checking:', g, difflist[r])\n                g = gcd(g, s[r])\n                r += 1\n\n            ans = max(ans, r - l)\n\n        # res = 0\n        # for left in range(N):\n        #     left_search = left\n        #     right_search = N\n        #     gcd_temp = INF\n        #     while right_search - left_search > 1:\n        #         mid = left_search + (right_search - left_search)//2\n        #         gcd_val = T.query(left_search, mid+1, default=INF)\n        #         if gcd(gcd_val, gcd_temp) > 1:\n        #             left_search = mid\n        #             gcd_temp = gcd(gcd_val, gcd_temp)\n        #         else:\n        #             right_search = mid\n        #     res = max(res, right_search - left)\n        print(ans)\nmain()\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\ninput = sys.stdin.readline\n\nclass SegTree(object):\n\t\"\"\"docstring for SegTree\"\"\"\n\tdef __init__(self, n, arr):\n\t\tself.n = n\n\t\tself.arr = arr\n\t\tself.tree = [0 for i in range(2*n)]\n\t\tself.construct()\n\n\tdef construct(self): # Construction\n\t\tfor i in range(self.n):\n\t\t\tself.tree[self.n+i] = self.arr[i]\n\t\tfor i in range(self.n-1,0,-1):\n\t\t\tself.tree[i] = self.function(self.tree[2*i],self.tree[2*i+1])\n\n\tdef update(self,index,value):\n\t\tstart = index+self.n\n\t\tself.tree[start] = value\n\t\tstart = start//2\n\t\twhile start>0:\n\t\t\tself.tree[start] = self.function(self.tree[2*start],self.tree[2*start+1])\n\t\t\tstart = start//2\n\n\tdef calc(self,low,high): # 0-indexed\n\t\tlow+=self.n\n\t\thigh+=self.n\n\t\tans = self.tree[low] # Needs to initialised\n\t\twhile low<high:\n\t\t\tif low%2:\n\t\t\t\tans = self.function(ans, self.tree[low])\n\t\t\t\tlow += 1\n\t\t\tif high%2:\n\t\t\t\thigh -= 1\n\t\t\t\tans = self.function(ans, self.tree[high])\n\t\t\tlow = low//2\n\t\t\thigh = high//2\n\t\treturn ans\n\t\n\tdef function(self,a,b): # Function used to construct Segment Tree\n\t\treturn math.gcd(a, b)\n\n\nfor nt in range(int(input())):\n\tn = int(input())\n\ta = list(map(int,input().split()))\n\tif n==1:\n\t\tprint (1)\n\t\tcontinue\n\td = []\n\tfor i in range(1, n):\n\t\td.append(abs(a[i]-a[i-1]))\n\n\t# print (d)\n\ttree = SegTree(len(d), d)\n\tl, r = 0, 0\n\tans = 0\n\twhile r<n-1:\n\t\thcf = tree.calc(l, r+1)\n\t\t# print (l, r, hcf)\n\t\tif hcf>1:\n\t\t\tans = max(r - l + 1, ans)\n\t\t\tr += 1\n\t\telse:\n\t\t\tl += 1\n\t\t\tr += 1\n\tprint (ans+1)\n\n\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    \n    public static void main(String[] args) {\n    \n        var sc = new FastScanner(System.in);\n        var pw = new PrintWriter(System.out);\n        \n        int T = Integer.parseInt(sc.next());\n        for(int t = 0; t < T; t++){\n            int n = Integer.parseInt(sc.next());\n            var a = new long[n];\n            for(int i = 0; i < n; i++){\n                a[i] = Long.parseLong(sc.next());\n            }\n            \n            var b = new long[n-1];\n            for(int i = 0; i < n-1; i++){\n                b[i] = Math.abs(a[i] - a[i+1]);\n            }\n            var st = new SegmentTree(b);\n    \n            int ans = 1;\n            int l = 0;\n            for(int r = 0; r < n-1; r++){\n                if(b[r] == 1){\n                    l = r+1;\n                    continue;\n                }\n                if(r-l+2 <= ans){\n                    continue;\n                }\n                while(st.get(l, r+1) == 1){\n                    l++;\n                }\n                ans = Math.max(r-l+2, ans);\n            }\n            pw.println(ans);\n        }\n        pw.flush();\n    }\n    \n    static long gcd(long a, long b){\n        return b == 0 ? a : gcd(b, a%b);\n    }\n    \n    static class SegmentTree {\n        int n;\n        long[] node;\n        \n        long op(long a, long b){\n            return gcd(a, b);\n        }\n        \n        long e = 0;\n        \n        public SegmentTree(int size){\n            n = 1;\n            while(n < size) n <<= 1;\n            node = new long[2*n-1];\n            Arrays.fill(node, e);\n        }\n        public SegmentTree(long[] ar){\n            n = 1;\n            while(n < ar.length) n <<= 1;\n            node = new long[2*n-1];\n            System.arraycopy(ar, 0, node, n-1, ar.length);\n            Arrays.fill(node, n-1+ar.length, 2*n-1, e);\n            for(int i = n-2; i >= 0; i--){\n                node[i] = op(node[i*2+1], node[i*2+2]);\n            }\n        }\n        void set(int index, long newValue){\n            index += n-1;\n            node[index] = newValue;\n            while(index > 0){\n                index = (index-1)/2;\n                node[index] = op(node[index*2+1], node[index*2+2]);\n            }\n        }\n        long get(int left, int right){\n            return get(left, right, 0, 0, n);\n        }\n        long get(int a, int b, int k, int l, int r){\n            if(r <= a || b <= l) return e;\n            if(a <= l && r <= b) return node[k];\n            long vl = get(a, b, k*2+1, l, (l+r)/2);\n            long vr = get(a, b, k*2+2, (l+r)/2, r);\n            return op(vl, vr);\n        }\n        long get(int index){\n            return node[index+n-1];\n        }\n    }\n    \n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n        String next(){\n            while(st == null || !st.hasMoreTokens()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch(IOException e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout, setrecursionlimit as srl\nfrom threading import stack_size\nfrom collections import deque, defaultdict as dd\nfrom math import gcd, ceil, sqrt\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\n\n#srl(int(1e6))\ninput = stdin.readline\nflush = stdout.flush\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=gcd):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        start += self._size\n        stop += self._size\n\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n\n        return self._func(res_left, res_right)\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\ntc = 1\ntc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    a = list(map(int, input().split()))\n    x = []\n    for i in range(n-1):\n        x.append(abs(a[i+1]-a[i]))\n    \n    ans = 0\n    s = SegmentTree(x)\n\n    left = 0\n    right = 0\n    while (right < n-2):\n        if (s.query(left, right+2) != 1):\n            right += 1\n        else:\n            if (s.query(left, right+1) != 1): ans = max(ans, right - left + 1)\n            left += 1\n    if (s.query(left, right+1) != 1): ans = max(ans, right - left + 1)\n    if (len(x) == 0): ans = 0\n    print(ans+1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 400005;\nint T, n;\nlong long a[N], z[100], b[100];\nint f[N][100], top, t2, id[100];\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nint main() {\n  cin >> T;\n  while (T--) {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%lld\", &a[i]);\n      a[i - 1] = abs(a[i] - a[i - 1]);\n      for (int j = 0; j <= 80; j++) f[i][j] = 0;\n    }\n    int ans = 1;\n    top = 0;\n    for (int i = 1; i <= n - 1; i++) {\n      t2 = 0;\n      memset(id, 0, sizeof(id));\n      z[top + 1] = a[i];\n      for (int j = 1; j <= top; j++) {\n        id[j] = t2 + 1;\n        if (gcd(z[j], a[i]) != gcd(z[j + 1], a[i])) b[++t2] = gcd(z[j], a[i]);\n      }\n      id[top + 1] = t2 + 1;\n      b[++t2] = gcd(z[top + 1], a[i]);\n      for (int j = 1; j <= top; j++)\n        f[i][id[j]] = max(f[i][id[j]], f[i - 1][j] + 1);\n      if (!f[i][t2]) f[i][t2] = 1;\n      for (int j = 1; j <= t2; j++) z[j] = b[j];\n      top = t2;\n      for (int j = 1; j <= top; j++)\n        if (z[j] > 1) ans = max(ans, f[i][j] + 1);\n    }\n    printf(\"%d\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class D\n{\n    static InputReader in=new InputReader(System.in);\n    static OutputWriter out=new OutputWriter(System.out);\n    static StringBuilder sb=new StringBuilder();\n    static int MAX = 4 * 1000000 + 2;\n    static int n;\n    // Main Class Starts Here\n    public static void main(String[] args)throws IOException\n    {\n        // Write your code.\n\n        int t = in();\n        while(t-- > 0){\n            int n = in();\n            long ar[] = lan(n);\n\n            int s = n-1;\n            long a[] = new long[s];\n            for(int i = 0 ;i < s; i++)\n                a[i] = Math.abs(ar[i+1] - ar[i]);\n\n            // prln(atsl(ar)+\"\\n\"+atsl(a));\n\n            // sparse table.\n            long sp[][] = new long[s][18];\n            // sp[i][j] = gcd of range a[i, i + (1 << j)]\n\n            // initialize sparse table\n            for(int i =0 ; i < s; i++)\n                sp[i][0] = a[i];\n\n            // construct sparse table\n            for(int j = 1; j <= 17; j++){\n                for(int i = 0; i + (1 << j) < s; i++){\n                    sp[i][j] = gcd(sp[i][j-1], sp[i + (1 << (j-1))][j-1]);\n                }\n            }\n\n            /*for(int i = 0; i < s; i++)\n                prln(a[i]+\" -> \"+atsl(sp[i]));\n\n            prln(\"\\n\");*/\n\n            // two pointer.\n            int l = 0;\n            int r = 0;\n            int max = 0;\n            while(r < s){\n                long gcd = sparseQuery(l, r, sp);\n                if(gcd > 1){\n                    max = Math.max(max, (r - l + 1));\n                    r++;\n                }\n                else if(gcd == 1){\n                    if(r == l)\n                        r++;\n                    l++;\n                }\n            }\n            max++;\n            app(max+\"\\n\");\n        }\n        out.printLine(sb);\n        out.close();\n    }\n\n    public static long sparseQuery(int l, int r, long sp[][]){\n        long res = 0L;\n        while(l <= r){\n            if(l == r){\n                res = gcd(res, sp[l][0]);\n                break;\n            }\n            for(int i = 17; i >= 0; i--){\n                int length = l + (1 << i);\n                if(length > r) continue;\n                res = gcd(res, sp[l][i]);\n                l += 1 << i;\n                break;\n            }\n        }\n        return res;\n    }\n\n    static class Query{\n        int l;\n        int r;\n        int index;\n        int answer;\n        public Query(int l, int r, int index){\n            this.l = l;\n            this.r = r;\n            this.index = index;\n        }\n\n        public void setAnswer(int answer){\n            this.answer = answer;\n        }\n\n        @Override\n        public String toString(){\n            return \"(\"+(l+1)+\",\"+(r+1)+\")\";\n        }\n    }\n\n    static class Pair{\n        int x, y;\n        public Pair(int x, int y){\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString(){\n            return \"(\"+x+\",\"+y+\")\";\n        }\n    }\n\n    static class DisjointSet{\n        int parent[];\n        int rank[];\n        int size;\n\n        public DisjointSet(int n){\n            this.parent = new int[n];\n            this.rank = new int[n];\n            this.size = n;\n            for(int i = 0; i < n; i++)\n                parent[i] = i;\n        }\n\n        public int findParent(int x){\n            if(parent[x] != x){\n                return parent[x] = findParent(parent[x]);\n            }\n            return parent[x];\n        }\n\n        public boolean inSameComponents(int x, int y){\n            int parentX = findParent(x);\n            int parentY = findParent(y);\n            return parentX == parentY;\n        }\n\n        public int mergeComponents(int x, int y){\n            int parentX = findParent(x);\n            int parentY = findParent(y);\n            if(parentX == parentY) {\n                return 0; // merge failed as in the same components hence no change in components\n            }\n            if(rank[parentX] < rank[parentY]){\n                parent[parentX] = parentY;\n            }\n            else if(rank[parentX] > rank[parentY]){\n                parent[parentY] = parentX;\n            }\n            else{\n                // merge component of y to x.\n                parent[parentY] = parentX;\n                rank[parentX]++;\n            }\n            return 1; // merge successful - decrease in merge components\n        }\n\n        public int countComponents(){\n            int count = 0;\n            for(int i = 0; i < size; i++)\n                if(parent[i] == i) count++;\n            return count;\n        }\n\n        public TreeMap<Integer, List<Integer>> getComponents(){\n            TreeMap<Integer, List<Integer>> componentMap = new TreeMap<>();\n\n            for(int i = 0; i < size; i++){\n                List<Integer> componentElements = componentMap.getOrDefault(parent[i], new ArrayList<>());\n                componentElements.add(i);\n                componentMap.put(parent[i], componentElements);\n            }\n\n            return componentMap;\n        }\n\n        public Set<Integer> getComponentsWithNode(int x){\n            HashSet<Integer> set = new HashSet<>();\n            int parentX = findParent(x);\n            for(int i = 0; i < n; i++){\n                if(parent[i] == parentX){\n                    set.add(i);\n                }\n            }\n            return set;\n        }\n    }\n\n    // segment tree.\n    static class SegmentTree{\n        int size;\n        List<Integer> st[];\n        int n;\n        public SegmentTree(int a[], int n){\n            int x = (int)Math.ceil((Math.log(n) / Math.log(2)));\n            this.size = (int)Math.pow(2, 2 * x) - 1;\n            st = new ArrayList[size];\n            buildTree(0, n-1, 0, a);\n            this.n = n;\n        }\n\n        public List<Integer> buildTree(int l, int r, int curIndex, int a[]){\n            if(l == r){\n                st[curIndex] =  new ArrayList<>();\n                st[curIndex].add(a[l]);\n                return st[curIndex];\n            }\n            int mid = (l + r) / 2;\n            List<Integer> leftList = buildTree(l, mid, 2 * curIndex + 1, a);\n            List<Integer> rightList = buildTree(mid + 1, r, 2 * curIndex + 2, a);\n            int lastLeftProduct = leftList.get(leftList.size() - 1);\n            int firstRightProduct = rightList.get(0);\n            int gcd = gcd(lastLeftProduct, firstRightProduct);\n            if(gcd > 1){\n                st[curIndex] = new ArrayList<>(leftList);\n                st[curIndex].addAll(rightList);\n            }\n            else{\n                st[curIndex] = new ArrayList<>();\n                for(int i = 0; i < leftList.size() - 1; i++)\n                    st[curIndex].add(leftList.get(i));\n                st[curIndex].add(lastLeftProduct * firstRightProduct);\n                for(int i = 1 ; i < rightList.size(); i++)\n                    st[curIndex].add((rightList.get(i)));\n            }\n            return st[curIndex];\n        }\n\n        public int resolveQuery(int ql, int qr){\n            List<Integer> ans = mergeRanges(0, n-1, ql, qr, 0);\n            return ans.size();\n        }\n\n        public List<Integer> mergeRanges(int l, int r, int ql, int qr, int curIndex){\n            if(l > qr || r < ql) return null;\n            if(ql <= l && qr >= r){\n                return st[curIndex];\n            }\n            int mid = (l + r) / 2;\n            List<Integer> leftList = mergeRanges(l, mid, ql, qr, 2 * curIndex + 1);\n            List<Integer> rightList = mergeRanges(mid + 1, r, ql, qr, 2 * curIndex + 2);\n            if(leftList != null && rightList != null){\n                int lastLeftProduct = leftList.get(leftList.size() - 1);\n                int firstRightProduct = rightList.get(0);\n                int gcd = gcd(lastLeftProduct, firstRightProduct);\n                List<Integer> mergedList = new ArrayList<>();\n                if(gcd > 1){\n                    mergedList.addAll(leftList);\n                    mergedList.addAll(rightList);\n                }\n                else{\n                    for(int i = 0; i < leftList.size() - 1; i++)\n                        mergedList.add(leftList.get(i));\n                    mergedList.add(lastLeftProduct * firstRightProduct);\n                    for(int i = 1 ; i < rightList.size(); i++)\n                        mergedList.add((rightList.get(i)));\n                }\n                return mergedList;\n            }\n            else if(leftList != null) return leftList;\n            else return rightList;\n        }\n\n        public void printTree(){\n            for(int i = 0; i < st.length; i++)\n                prln(i+\" , \"+st[i]);\n        }\n    }\n\n    public static String atsi(int a[]){\n        return Arrays.toString(a);\n    }\n\n    public static String atsl(long a[]){\n        return Arrays.toString(a);\n    }\n\n    public static long gcd(long a, long b){\n        if(b == 0) return a;\n        return gcd(b, a % b);\n    }\n\n    public static int gcd(int a, int b){\n        if(b == 0) return a;\n        return gcd(b, a % b);\n    }\n\n    public static int[] an(int n) {\n        int ar[]=new int[n];\n        for(int i=0;i<n;i++)\n            ar[i]=in();\n        return ar;\n    }\n\n    public static long[] lan(int n) {\n        long ar[]=new long[n];\n        for(int i=0;i<n;i++)\n            ar[i]=lin();\n        return ar;\n    }\n\n    public static String atos(Object ar[]) {\n        return Arrays.toString(ar);\n    }\n\n    public static int in() {\n        return in.readInt();\n    }\n\n    public static long lin() {\n        return in.readLong();\n    }\n\n    public static String sn() {\n        return in.readString();\n    }\n\n    public static void prln(Object o) {\n        out.printLine(o);\n    }\n\n    public static void prn(Object o) {\n        out.print(o);\n    }\n\n    public static void app(Object o) {\n        sb.append(o);\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object...objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object...objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from itertools import chain\nfrom math import gcd\n\nfor _ in range(int(input())):\n    n, a = int(input()), map(int, input().split())\n    maxim, last, nova_cua = 1, next(a), []\n    for i, new in enumerate(a):\n        dif, last, cua, nova_cua = abs(last-new), new, nova_cua, []\n        for g, p in chain([(dif, i)], cua):\n            g = gcd(dif, g)\n            if g == 1: break\n            if nova_cua and nova_cua[-1][0] == g: nova_cua.pop()\n            nova_cua.append((g, p))\n            maxim = max(maxim, i-p+2)\n    print(maxim)"
        },
        {
            "language": 3,
            "solution": "from typing import Counter\nimport sys\nfrom collections import defaultdict as dd\nfrom math import *\n\ndef vinp():\n    return map(int,input().split())\ndef linp():\n    return list(map(int,input().split()))\ndef sinp():\n    return input()\ndef inp():\n    return int(input())\ndef mod(f):\n    return f % 1000000007\ndef pr(*x):\n    print(*x)\ndef finp():\n    f=open(\"input.txt\",\"r\")\n    f=f.read().split(\"\\n\")\n    return f\ndef finp():\n    f=open(\"input.txt\",\"r\")\n    f=f.read().split(\"\\n\")\n    return f\ndef fout():\n    return open(\"output.txt\",\"w\")\ndef fpr(f,x):\n    f.write(x+\"\\n\")\ndef csort(c):\n    sorted(c.items(), key=lambda pair: pair[1], reverse=True)\ndef indc(l,n):\n    c={}\n    for i in range(n):\n        c[l[i]]=c.get(l[i],[])+[i+1]\n    return c\ndef ok(a,b):\n    p=lo[b-a+1]\n    return gcd(t[p][a],t[p][b-(1<<p)+1])\nif __name__ ==\"__main__\":\n    cou=inp()\n    for i in range(cou):\n        n,l=inp(),linp()\n        l=[abs(l[i]-l[i+1]) for i in range(n-1)]\n        n,f=n-1,0\n        lo=[0 for i in range(n+1)]\n        for i in range(2,n+1):\n            lo[i]=lo[i>>1]+1\n        t=[[0 for i in range(n+1)] for j in range(20)]\n        for i in range(lo[n]+1):\n            j,cc=0,1<<i\n            while j+cc<=n:\n                if cc!=1:\n                    t[i][j]= gcd(t[i-1][j],t[i-1][j+(cc//2)])\n                else:\n                    t[i][j]=l[j]\n                j+=1\n        ll=1\n        hh=n\n        fa=0\n        while ll<=hh:\n            f=False\n            mm=(ll+hh)//2\n            for i in range(n-mm+1):\n                cc = ok(i,i+mm-1)\n                if cc>1:\n                    f=True\n                    break\n            if not f:\n                hh=mm-1 \n            else:\n                fa=mm+1\n                ll=mm+1\n        if fa>1:\n            pr(fa)\n        else:\n            pr(1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nlong long lcm(long long a, long long b) { return (a / gcd(a, b)) * b; }\nlong long seg[4 * N], a[N];\nvoid build(int p, int s, int e) {\n  if (s == e) {\n    seg[p] = a[s];\n    return;\n  }\n  int m = (s + e) / 2;\n  build(2 * p, s, m);\n  build(2 * p + 1, m + 1, e);\n  seg[p] = gcd(seg[2 * p], seg[2 * p + 1]);\n}\nlong long query(int p, int s, int e, int l, int r) {\n  if (s > r || e < l) return 0;\n  if (l <= s && e <= r) return seg[p];\n  int m = (s + e) / 2;\n  return gcd(query(2 * p, s, m, l, r), query(2 * p + 1, m + 1, e, l, r));\n}\nvoid solve() {\n  int n;\n  scanf(\"%d\", &n);\n  long long a[n];\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%lld\", a + i);\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    ::a[i] = abs(a[i] - a[i + 1]);\n  }\n  build(1, 0, n - 1);\n  long long l = 0, ans = 1;\n  for (int r = 0; r < n - 1; ++r) {\n    while (r >= l && query(1, 0, n - 1, l, r) == 1) {\n      ++l;\n    }\n    ans = max(ans, r - l + 2);\n  }\n  printf(\"%lld\\n\", ans);\n}\nint main() {\n  int t = 1;\n  scanf(\"%d\", &t);\n  while (t--) solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/** Built using CHelper plug-in Actual solution is at the top */\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    FastReader in = new FastReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    DIntegersHaveFriends solver = new DIntegersHaveFriends();\n    int testCount = Integer.parseInt(in.next());\n    for (int i = 1; i <= testCount; i++) solver.solve(i, in, out);\n    out.close();\n  }\n\n  static class DIntegersHaveFriends {\n    public void solve(int testNumber, FastReader in, PrintWriter out) {\n      int n = in.nextInt();\n      long[] a = in.nextLongArray(n);\n      if (n == 1) {\n        out.println(1);\n        return;\n      }\n      long[] b = new long[n - 1];\n      for (int i = 1; i < n; ++i) {\n        b[i - 1] = Math.abs(a[i] - a[i - 1]);\n      }\n      final SegmentTreeL segmentTree =\n          new SegmentTreeL(b) {\n\n            public long merge(long c1, long c2) {\n              return NT.gcd(c1, c2);\n            }\n\n            public long incorrectCondition() {\n              return 0;\n            }\n          };\n      int ans = 0;\n      for (int i = 0, j = 0; i < n; ++i) {\n        if (j < i) {\n          j = i;\n        }\n        long cur = i < j ? segmentTree.getRangeOp(i, j - 1) : 0;\n        long _gcd;\n        while (j < n - 1 && (_gcd = NT.gcd(cur, b[j])) != 1) {\n          ++j;\n          cur = _gcd;\n        }\n        ans = Math.max(ans, j - i);\n      }\n      out.println(ans + 1);\n    }\n  }\n\n  static interface PReader {}\n\n  abstract static class SegmentTreeL {\n    long[] seg;\n    long[] a;\n    int size;\n    int N;\n    int MIN = Integer.MIN_VALUE;\n\n    public SegmentTreeL(long[] a) {\n      this.N = a.length;\n      size = 4 * N;\n      seg = new long[size];\n      Arrays.fill(seg, MIN);\n      this.a = a;\n      build(0, N - 1, 0);\n    }\n\n    public SegmentTreeL(int n) {\n      N = n;\n      size = 4 * N;\n      seg = new long[size];\n      a = new long[n];\n      build(0, N - 1, 0);\n    }\n\n    private void build(int s, int e, int c) {\n      if (s == e) {\n        seg[c] = a[s];\n        return;\n      }\n      int m = (s + e) >>> 1;\n      build(s, m, 2 * c + 1);\n      build(m + 1, e, 2 * c + 2);\n      seg[c] = merge(seg[2 * c + 1], seg[2 * c + 2]);\n    }\n\n    public abstract long merge(long c1, long c2);\n\n    public abstract long incorrectCondition();\n\n    public long getRangeOp(int l, int r) {\n      return getRangeOp(0, N - 1, 0, l, r);\n    }\n\n    private long getRangeOp(int s, int e, int c, int l, int r) {\n      if (s > e || l > r || l > e || r < s) return incorrectCondition();\n      if (s == e) {\n        return seg[c];\n      }\n      if (s >= l && e <= r) {\n        return seg[c];\n      }\n      int m = (s + e) >>> 1;\n      return merge(getRangeOp(s, m, 2 * c + 1, l, r), getRangeOp(m + 1, e, 2 * c + 2, l, r));\n    }\n  }\n\n  static class NT {\n    public static long gcd(long a, long b) {\n      a = Math.abs(a);\n      b = Math.abs(b);\n      while (b > 0) {\n        long c = a;\n        a = b;\n        b = c % b;\n      }\n      return a;\n    }\n  }\n\n  static class FastReader implements PReader {\n    private final InputStream stream;\n    private final byte[] buf = new byte[8192];\n    private int curChar;\n    private int pnumChars;\n\n    public FastReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public String next() {\n      return nextString();\n    }\n\n    public String nextString() {\n      int c = pread();\n      while (isSpaceChar(c)) c = pread();\n      StringBuilder res = new StringBuilder();\n      do {\n        res.appendCodePoint(c);\n        c = pread();\n      } while (!isSpaceChar(c));\n      return res.toString();\n    }\n\n    private int pread() {\n      if (pnumChars == -1) {\n        throw new InputMismatchException();\n      }\n      if (curChar >= pnumChars) {\n        curChar = 0;\n        try {\n          pnumChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (pnumChars <= 0) {\n          return -1;\n        }\n      }\n      return buf[curChar++];\n    }\n\n    private boolean isSpaceChar(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int nextInt() {\n      int c = pread();\n      while (isSpaceChar(c)) c = pread();\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = pread();\n      }\n      int res = 0;\n      do {\n        if (c == ',') {\n          c = pread();\n        }\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res *= 10;\n        res += c - '0';\n        c = pread();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextLong();\n      }\n      return array;\n    }\n\n    public long nextLong() {\n      int c = pread();\n      while (isSpaceChar(c)) c = pread();\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = pread();\n      }\n      long res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res *= 10;\n        res += c - '0';\n        c = pread();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.*;\nimport java.io.*;\n\npublic class D {\n\tstatic StringBuilder sb;\n\tstatic dsu dsu;\n\tstatic long fact[];\n\tstatic int mod = (int) (1e9 + 7);\n\tstatic int si;\n\tstatic int ei;\n\n\tstatic void solve() {\n\t\tint n = i();\n\t\tlong[] arr = readArray(n);\n\t\tlong[] diff = new long[n - 1];\n\t\tif (n == 1) {\n\t\t\tsb.append(\"1\\n\");\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\tdiff[i - 1] = Math.abs(arr[i] - arr[i - 1]);\n\t\t}\n\n\t\tlong[][] sparse = sparsetable(diff);\n\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tlong ans = 0;\n\t\twhile (j < diff.length) {\n\t\t\tint log = (int) (Math.log(j - i + 1) / Math.log(2));\n\t\t\tlong left = sparse[i][log];\n\t\t\tlong right = sparse[j - (1 << log) + 1][log];\n\n\t\t\tlong gcd = (gcd(left, right));\n\t\t\tif (gcd > 1) {\n\t\t\t\tans = Math.max(ans, j - i + 1);\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tif (i < j) {\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsb.append(ans + 1 + \"\\n\");\n\n\t}\n\n\tstatic long[][] sparsetable(long[] arr) {\n\t\tint n = arr.length;\n\t\tint log = (int) (Math.log(n) / Math.log(2));\n\t\tlong[][] sparse = new long[arr.length][log + 1];\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tsparse[i][0] = arr[i];\n\t\t}\n\n\t\tfor (int j = 1; j <= log; j++) {\n\t\t\tfor (int i = 0; i <= n - (1 << (j)); i++) {\n\t\t\t\tsparse[i][j] = gcd(sparse[i][j - 1], sparse[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\n\t\treturn sparse;\n\t}\n\n\tstatic ArrayList<Integer> sieveOfEratosthenes(int n) {\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\tif (prime[p] == true) {\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\tArrayList<Integer> primes = new ArrayList<>();\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tif (prime[i] == true) {\n\t\t\t\tprimes.add(i);\n\t\t\t}\n\t\t}\n\n\t\treturn primes;\n\t}\n\n\tstatic ArrayList<Integer> primes;\n\n\tpublic static void main(String[] args) {\n\t\tsb = new StringBuilder();\n\t\tint test = i();\n\t\tprimes = sieveOfEratosthenes(3020);\n\t\twhile (test-- > 0) {\n\t\t\tsolve();\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\tstatic long ncr(int n, int r) {\n\t\tif (r > n)\n\t\t\treturn (long) 0;\n\n\t\tlong res = fact[n] % mod;\n\t\tres = ((long) (res % mod) * (long) (p(fact[r], mod - 2) % mod)) % mod;\n\t\tres = ((long) (res % mod) * (long) (p(fact[n - r], mod - 2) % mod)) % mod;\n\t\treturn res;\n\n\t}\n\n\tstatic long p(long x, long y) {\n\t\tif (y == 0)\n\t\t\treturn 1;\n\n\t\tlong res = 1;\n\t\twhile (y > 0) {\n\t\t\tif (y % 2 == 1) {\n\t\t\t\tres = (res * x) % mod;\n\t\t\t\ty--;\n\t\t\t}\n\n\t\t\tx = (x * x) % mod;\n\t\t\ty = y / 2;\n\n\t\t}\n\t\treturn res;\n\t}\n\n//**************END******************\n\n\t// *************Disjoint set\n\t// union*********//\n\tstatic class dsu {\n\t\tint parent[];\n\n\t\tdsu(int n) {\n\t\t\tparent = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tparent[i] = -1;\n\t\t}\n\n\t\tint find(int a) {\n\t\t\tif (parent[a] < 0)\n\t\t\t\treturn a;\n\t\t\telse {\n\t\t\t\tint x = find(parent[a]);\n\t\t\t\tparent[a] = x;\n\t\t\t\treturn x;\n\t\t\t}\n\t\t}\n\n\t\tvoid merge(int a, int b) {\n\t\t\ta = find(a);\n\t\t\tb = find(b);\n\t\t\tif (a == b)\n\t\t\t\treturn;\n\t\t\tparent[b] = a;\n\t\t}\n\t}\n\n//**************PRIME FACTORIZE **********************************//\n\tstatic TreeMap<Integer, Integer> prime(long n) {\n\t\tTreeMap<Integer, Integer> h = new TreeMap<>();\n\t\tlong num = n;\n\t\tfor (int i = 2; i <= Math.sqrt(num); i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tint nt = 0;\n\t\t\t\twhile (n % i == 0) {\n\t\t\t\t\tn = n / i;\n\t\t\t\t\tnt++;\n\t\t\t\t}\n\t\t\t\th.put(i, nt);\n\t\t\t}\n\t\t}\n\t\tif (n != 1)\n\t\t\th.put((int) n, 1);\n\t\treturn h;\n\n\t}\n\n//****CLASS PAIR ************************************************\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint x;\n\t\tint y;\n\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn (int) (this.y - o.y);\n\n\t\t}\n\n\t}\n//****CLASS PAIR **************************************************\n\n\tstatic class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int Int() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String String() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\treturn String();\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n\n\tstatic class OutputWriter {\n\t\tprivate final PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream outputStream) {\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t}\n\n\t\tpublic OutputWriter(Writer writer) {\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n\n\t\tpublic void print(Object... objects) {\n\t\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\twriter.print(' ');\n\t\t\t\twriter.print(objects[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void printLine(Object... objects) {\n\t\t\tprint(objects);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void close() {\n\t\t\twriter.close();\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\twriter.flush();\n\t\t}\n\t}\n\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic OutputWriter out = new OutputWriter(System.out);\n\n\tpublic static long[] sort(long[] a2) {\n\t\tint n = a2.length;\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a2)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < l.size(); i++)\n\t\t\ta2[i] = l.get(i);\n\t\treturn a2;\n\t}\n\n\tpublic static int[] sort(int[] a2) {\n\t\tint n = a2.length;\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a2)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < l.size(); i++)\n\t\t\ta2[i] = l.get(i);\n\t\treturn a2;\n\t}\n\n\tpublic static long pow(long x, long y) {\n\t\tlong res = 1;\n\t\twhile (y > 0) {\n\t\t\tif (y % 2 != 0) {\n\t\t\t\tres = (res * x);// % modulus;\n\t\t\t\ty--;\n\n\t\t\t}\n\t\t\tx = (x * x);// % modulus;\n\t\t\ty = y / 2;\n\t\t}\n\t\treturn res;\n\t}\n\n//GCD___+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\tpublic static long gcd(long x, long y) {\n\t\tif (x == 0)\n\t\t\treturn y;\n\t\telse\n\t\t\treturn gcd(y % x, x);\n\t}\n\t// ******LOWEST COMMON MULTIPLE\n\t// *********************************************\n\n\tpublic static long lcm(long x, long y) {\n\t\treturn (x * (y / gcd(x, y)));\n\t}\n\n//INPUT PATTERN********************************************************\n\tpublic static int i() {\n\t\treturn in.Int();\n\t}\n\n\tpublic static long l() {\n\t\tString s = in.String();\n\t\treturn Long.parseLong(s);\n\t}\n\n\tpublic static String s() {\n\t\treturn in.String();\n\t}\n\n\tpublic static int[] readArrayi(int n) {\n\t\tint A[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tA[i] = i();\n\t\t}\n\t\treturn A;\n\t}\n\n\tpublic static long[] readArray(long n) {\n\t\tlong A[] = new long[(int) n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tA[i] = l();\n\t\t}\n\t\treturn A;\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main\n{\n    static long gcd(long a,long b){\n        if(b==0)return a;\n       return gcd(b,a%b);\n    }\n    static long st[];\n    static long segTree(long arr[],int s,int e,int i){\n        if(s==e){\n            st[i]=arr[s];\n            return arr[s];\n        }\n        int m=(s+e)/2;\n        st[i]=gcd(segTree(arr,s,m,i*2+1),segTree(arr,m+1,e,i*2+2));\n        return st[i];\n        \n    }\n    static long gcdQuery(int s,int e,int qs,int qe,int i){\n        if (qs <= s && qe >= e)\n            return st[i];\n        if (e < qs || s > qe)\n            return 0;\n        int m=(s+e)/2;\n        return gcd(gcdQuery(s,m,qs,qe,2*i+1),gcdQuery(m+1,e,qs,qe,2*i+2));\n    }\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    Scanner sc=new Scanner(System.in);\n\t   // BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t    int t=1;\n\t    t=sc.nextInt();\n\t    //int t=Integer.parseInt(br.readLine());\n\t    while(--t>=0){\n\t        int n=sc.nextInt();\n\t        long a[]=new long[n];\n\t        for(int i=0;i<n;i++)a[i]=sc.nextLong();\n\t        if(n==1){\n\t            System.out.println(1);\n\t            continue;\n\t        }\n\t        long b[]=new long[n-1];\n\t        for(int i=1;i<n;i++){\n\t            b[i-1]=Math.abs(a[i]-a[i-1]);\n\t        }\n\t        long max=1;\n\t        int i=0,j=0;\n\t        st=new long[n*4];\n\t        segTree(b,0,n-2,0);\n\t        while(true){\n\t            if(i>=(n-1)||j>=(n-1))break;\n\t           // System.out.println(i+\" \"+j);\n\t           if(i<j){\n\t               break;\n\t           }\n\t            if(gcdQuery(0,n-2,j,i,0)>1l){\n\t                max=Math.max(max,(i-j+2));\n\t                i++;\n\t            }\n\t            else{\n\t                if(i<=j){\n\t                    i++;\n\t                    j++;\n\t                }\n\t                else{\n\t                    j++;\n\t                }\n\t                \n\t            }\n\t        }\n\t     System.out.println(max);\n\t        \n\t    }\n\t    \n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n \n \npublic class Codeforces {\n\t\n\tstatic int mod=1000000007;\n\tstatic long mat[][];\n\tstatic int log[];\n\tstatic int max;\n\tstatic int k;\n\tpublic static void main(String[] args) throws Exception {\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t    FastScanner fs=new FastScanner();\n\t    int t=fs.nextInt();\n\t    callog();\n\t    while(t-->0) {\n\t    \tint n=fs.nextInt();\n\t    \tmax=n-1;\n\t    \tk=log[max];\n\t    \tlong arr[]=new long[n];\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\tarr[i]=fs.nextLong();\n\t    \t}\n\t    \tif(n==1) {\n\t    \t\tout.println(n);\n\t    \t\tcontinue;\n\t    \t}\n\t    \tlong diff[]=new long[n-1];\n\t    \tfor(int i=0;i<n-1;i++) {\n\t    \t\tdiff[i]=Math.abs(arr[i+1]-arr[i]);\n\t    \t}\n\t    \tbuild(diff);\n\t    \tint l=1,r=n;\n\t    \twhile(l<r) {\n\t    \t\tint mid=(l+r+1)/2;\n\t    \t\tif(check(mid-1)) {\n\t    \t\t\tl=mid;\n\t    \t\t}\n\t    \t\telse r=mid-1;\n\t    \t}\n//\t    \tSystem.out.println(query(0,3));\n\t    \tout.println(l);\n\t    }\n\t    out.close();\n\t    \n\t}\n\tstatic boolean check(int len) {\n\t\tif(len==0) return true;\n\t\tfor(int i=0;i+len<=max;i++) {\n\t\t\tlong rem= query(i,i+len-1);\n\t\t\tif(rem>1) {\n//\t\t\t\tSystem.out.println(len);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tstatic void build(long arr[]) {\n\t\tmat=new long[max][k+1];\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tmat[i][0]=arr[i];\n\t\t}\n\t\tfor(int j=1;j<=k;j++) {\n\t\t\tfor(int i=0;i+(1<<j)<=max;i++) {\n\t\t\t\tmat[i][j]=gcd(mat[i][j-1], mat[i+(1<<(j-1))][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void callog() {\n\t\tlog=new int[200000+1];\n\t\tlog[1]=0;\n\t\tfor(int i=2;i<=200000;i++) {\n\t\t\tlog[i]=log[i/2]+1;\n\t\t}\n\t}\n\tstatic long query(int l,int r) {\n\t\tint j=log[r-l+1];\n\t\treturn gcd(mat[l][j], mat[r-(1<<j)+1][j]);\n\t}\n\t\n\tstatic long gcd(long  a,long  b) {\n\t\tif(b==0) return a;\n\t\treturn gcd(b,a%b);\n\t}\n\tstatic long nck(int n,int k) {\n\t\tif(k>n) return 0;\n\t\tlong res=1;\n\t\tres*=fact(n);\n\t\tres%=mod;\n\t\tres*=modInv(fact(k));\n\t\tres%=mod;\n\t\tres*=modInv(fact(n-k)); \n\t\tres%=mod;\n\t\treturn res;\n\t}\n\tstatic long fact(long n) {\n\t\tlong res=1;\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\tres*=i;\n\t\t\tres%=mod;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic long pow(long a,long b) {\n\t\tlong res=1;\n\t\twhile(b!=0) {\n\t\t\tif((b&1)!=0) {\n\t\t\t\tres*=a;\n\t\t\t\tres%=mod;\n\t\t\t}\n\t\t\ta*=a;\n\t\t\ta%=mod;\n\t\t\tb=b>>1;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic long modInv(long n) {\n\t\treturn pow(n,mod-2);\n\t}\n\t\n\tstatic void sort(int[] a) {\n\t\t//suffle\n\t\tint n=a.length;\n\t\tRandom r=new Random();\n\t\tfor (int i=0; i<a.length; i++) {\n\t\t\tint oi=r.nextInt(n);\n\t\t\tint temp=a[i];\n\t\t\ta[i]=a[oi];\n\t\t\ta[oi]=temp;\n\t\t}\n\t\t\n\t\t//then sort\n\t\tArrays.sort(a);\n\t}\n\t\n\t// Use this to input code since it is faster than a Scanner\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n \n}"
        },
        {
            "language": 3,
            "solution": "from math import gcd\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dif = [abs(a[i] - a[i+1]) for i in range(n-1)]\n    maxim, cua = 1, []\n    for i, d in enumerate(dif):\n        cua.append((d, i))\n        nova_cua = []\n        for c, p in cua:\n            c = gcd(d, c)\n            if c != 1 and (not nova_cua or c > nova_cua[-1][0]):\n                nova_cua.append((c, p))\n                maxim = max(maxim, i - p + 2)\n        cua = nova_cua\n    print(maxim)"
        },
        {
            "language": 3,
            "solution": "import sys\ninput=sys.stdin.readline\n \nfrom math import gcd\ndef lcm(a,b):\n  return a*b//gcd(a,b)\n \nclass SparseTable:\n    def func(self,a,b):\n        return gcd(a,b)\n    def __init__(self,arr):\n        n=len(arr)\n        max_k=(n-1).bit_length()-1\n        val=1 #set by func /ex. min->INF\n        table=[[val]*(max_k+1) for i in range(n)]\n        for i in range(n):\n            table[i][0]=arr[i]\n        for k in range(1,max_k+1):\n            k2=1<<(k-1)\n            k3=1<<k-1\n            for i in range(n-k3):\n                table[i][k]=self.func(table[i][k-1],table[k2+i][k-1])\n        self.table=table\n    def query(self,l,r):#[l,r)->[l,r]\n        d=r-l\n        if d==1:\n            return self.table[l][0]\n        k=(d-1).bit_length()-1\n        k2=1<<k\n        return self.func(self.table[l][k],self.table[r-k2][k])\nt=int(input())\nfor _ in range(t):\n  n=int(input())\n  a=list(map(int,input().split()))\n  if n==1:\n    print(1)\n    continue\n  if n==2:\n    if abs(a[1]-a[0])>=2:\n      print(2)\n    else:\n      print(1)\n    continue\n  d=[abs(a[i+1]-a[i]) for i in range(n-1)]\n  if all(d[i]==0 for i in range(n-1)):\n    print(n)\n    continue\n  for i in range(1,n-1):\n    if d[i]==0:\n      d[i]=d[i-1]\n  for i in range(1,n-1)[::-1]:\n    if d[i-1]==0:\n      d[i-1]=d[i]\n  sp=SparseTable(d)\n  l=0\n  r=n+1\n  while r-l>1:\n    mid=(l+r)//2\n    for i in range(len(d)-mid+1):\n      g=sp.query(i,i+mid)\n      if g!=1:\n        l=mid\n        break\n    else:\n      r=mid\n  print(l+1)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    \n    public static void main(String[] args) {\n    \n        var sc = new FastScanner(System.in);\n        var pw = new PrintWriter(System.out);\n        \n        int T = Integer.parseInt(sc.next());\n        for(int t = 0; t < T; t++){\n            int n = Integer.parseInt(sc.next());\n            var a = new long[n];\n            for(int i = 0; i < n; i++){\n                a[i] = Long.parseLong(sc.next());\n            }\n            \n            var b = new long[n-1];\n            for(int i = 0; i < n-1; i++){\n                b[i] = Math.abs(a[i] - a[i+1]);\n            }\n            var st = new SparseTable(b);\n    \n            int ans = 1;\n            int l = 0;\n            for(int r = 0; r < n-1; r++){\n                if(b[r] == 1){\n                    l = r+1;\n                    continue;\n                }\n                if(r-l+2 <= ans){\n                    continue;\n                }\n                while(st.get(l, r+1) == 1){\n                    l++;\n                }\n                ans = Math.max(r-l+2, ans);\n            }\n            pw.println(ans);\n        }\n        pw.flush();\n    }\n    \n    static long gcd(long a, long b){\n        return b == 0 ? a : gcd(b, a%b);\n    }\n    \n    static class SparseTable {\n        long[][] table;\n        \n        public SparseTable(long[] a){\n            int n = a.length;\n            int k = 1;\n            while((1 << k) < n){\n                k++;\n            }\n            table = new long[k][n];\n            System.arraycopy(a, 0, table[0], 0, n);\n            for(int i = 1; i < k; i++){\n                for(int j = 0; j <= n - (1 << i); j++){\n                    table[i][j] = gcd(table[i-1][j], table[i-1][j + (1 << (i-1))]);\n                }\n            }\n        }\n        \n        long get(int l, int r){\n            int k = 1;\n            while((1 << k) < (r-l)){\n                k++;\n            }\n            k--;\n            return gcd(table[k][l], table[k][r - (1 << k)]);\n        }\n    }\n    \n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n        String next(){\n            while(st == null || !st.hasMoreTokens()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch(IOException e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from math import gcd\nfrom operator import sub\nfrom sys import stdin, gettrace\n\nif gettrace():\n    def inputi():\n        return input()\nelse:\n    def input():\n        return next(stdin)[:-1]\n\n\n    def inputi():\n        return stdin.buffer.readline()\n\nclass IdempotentSparseTable:\n    ''' Answer range queries for an idempotent function\n    '''\n    def __init__(self, data, f):\n        '''\n        :param data: The data, a list\n        :param f: An idempotent function. MUST BE IDEMPOTENT\n        '''\n        self.f = f\n        self.n = len(data)\n        self.st = [[d] for d in data]\n        k = self.n.bit_length()\n        for j in range(1, k):\n            for i in range(self.n-(1<<j) + 1):\n                self.st[i].append(self.f(self.st[i][j-1], self.st[i + (1 << (j-1))][j-1]))\n        self.logs = [0, 0]\n        for i in range(2, self.n+1):\n            self.logs.append(self.logs[i//2] + 1)\n\n    def range_query(self, l, r):\n        j = self.logs[r - l]\n        return self.f(self.st[l][j], self.st[r-(1<<j)][j])\n\n\ndef solve():\n    n = int(input())\n    aa = [int(a) for a in input().split()]\n    if n == 1:\n        print(1)\n        return\n    aad = list(map(lambda a, b: abs(a -b), aa, aa[1:]))\n    st = IdempotentSparseTable(aad, gcd)\n    i = 0\n    j = 1\n    best = 1\n    while j < n:\n        if st.range_query(i, j) == 1:\n            i += 1\n            if j == i:\n                j += 1\n        else:\n            j += 1\n            best = max(best, j-i)\n    print(best)\n\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nint T, n;\nlong long a[N], b[N], f[N][21], lg[N];\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nbool check(int l, int r) {\n  int len = lg[r - l + 1];\n  return gcd(f[l][len], f[r - (1 << len) + 1][len]) > 1;\n}\nnamespace bl {\nint solve(int n) {\n  int ans = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = n; j >= i + ans; j--) {\n      int mx = 0;\n      for (int k = i; k <= j; k++) mx = max(mx, (int)a[k]);\n      bool ok = false;\n      for (int k = 2; k <= mx; k++) {\n        bool now = true;\n        for (int p = i + 1; p <= j; p++)\n          if (a[p] % k != a[p - 1] % k) {\n            now = false;\n            break;\n          }\n        if (now) {\n          ok = true;\n          break;\n        }\n      }\n      if (ok) {\n        ans = max(ans, j - i + 1);\n      }\n    }\n  return ans;\n}\n}  // namespace bl\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n    for (int i = 1; i <= n - 1; i++) b[i] = abs(a[i] - a[i + 1]);\n    n--;\n    lg[0] = -1;\n    for (int i = 1; i <= n; i++) {\n      f[i][0] = b[i];\n      lg[i] = lg[i >> 1] + 1;\n    }\n    for (int j = 1; j <= lg[n]; j++)\n      for (int i = 1; i + (1 << j) - 1 <= n; i++)\n        f[i][j] = gcd(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      int l = i, r = n, j = i;\n      while (l <= r) {\n        int mid = l + r >> 1;\n        if (check(i, mid))\n          j = mid, l = mid + 1;\n        else\n          r = mid - 1;\n      }\n      if (i == j && b[i] == 1) continue;\n      ans = max(ans, j - i + 1);\n    }\n    printf(\"%d\\n\", max(1, ans + 1));\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n    static final int INF = 50000000;\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n        \n        int Q = sc.ni();\n        int P = 18;\n        for (int q = 0; q < Q; q++) {\n            int N = sc.ni();\n            long[] a = new long[N];\n            for (int i = 0; i < N; i++)\n                a[i] = sc.nl();\n            \n            long[][] table = new long[P][N-1];\n            for (int i = 0; i < N-1; i++)\n                table[0][i] = Math.abs(a[i+1]-a[i]);\n            for (int i = 1; i < P; i++) {\n                for (int j = 0; j < N-(1<<i); j++) {\n                    table[i][j] = gcd(table[i-1][j],table[i-1][j+(1<<(i-1))]);\n                }\n            }\n            int ans = 1;\n            for (int j = 0; j < N-1; j++) {\n                if (table[0][j]==1) continue;\n                int cur = j;\n                long g = INF;\n                for (int i = P-1; i >= 0; i--) {\n                    if (cur==N-1) break;\n                    if (table[i][cur] >= 2 && (g==INF||gcd(g,table[i][cur])>=2)) {\n                        if (g==INF)\n                            g = table[i][cur];\n                        else\n                            g = gcd(g,table[i][cur]);\n                        cur += (1<<i);\n                    }\n                }\n                ans = Math.max(ans,cur-j+1);\n            }\n            pw.println(ans);\n        }\n        pw.close();\n    }\n    \n    //Find the GCD of two numbers\n    public static long gcd(long a, long b) {\n        if (a < b)\n            return gcd(b,a);\n        if (b == 0)\n            return a;\n        else\n            return gcd(b,a%b);\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int ni() {\n            return Integer.parseInt(next());\n        }\n \n        long nl() {\n            return Long.parseLong(next());\n        }\n \n        double nd() {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport math\n#import random\ninput=sys.stdin\noutput=sys.stdout\n\nt=int(input.readline().strip())\nfor i in range(t):\n    n=int(input.readline().strip())\n    a=[int(x) for x in input.readline().strip().split()]\n#    n=random.randrange(1,100)\n#    a=[random.randrange(1,100000000) for x in range(n)]\n\n    bmax=0\n    b=[0]*(n-1)\n    for j in range(n-1):\n        b[j]=a[j]-a[j+1]\n        if b[j]<0:\n            b[j]=-b[j]\n        if b[j]!=1:\n            bmax=1    \n\n    if bmax==0:\n        print(1)\n        continue        \n\n#    def HCF(a, b):\n#        if a==0:\n#            return b\n#        elif b==0:\n#            return a\n#        elif a>b:\n#            return HCF(a%b, b)\n#        else:\n#            return HCF(b%a, a)\n\n#    def HCF(x, y):\n#        while True:\n#            if x==0:\n#                return y\n#            elif y==0:\n#                return x\n#            elif x>y:\n#                x=x%y\n#            else:\n#                y=y%x\n\n    def HCF(x, y):\n        while y:\n            x, y=y, x%y\n        return x\n        \n    St=[[b[x]] for x in range(n-1)]\n    upton=1\n    while upton<n:\n        for j in range(n-upton*2):\n            a=HCF(St[j][-1], St[j+upton][-1])\n            St[j].append(a)\n            if a!=1:\n                bmax=upton*2\n        upton*=2                                    \n\n    total=bmax\n    c=int(0.5+math.log2(bmax))\n    k=0\n    while k+total<n:\n        if St[k][c]!=1:\n            start=total+1\n            end=min(n-k-1, bmax*2-1)\n            while start<=end:\n                j=(start+end)//2\n                if HCF(St[k][c], St[k+j-2**c][c])!=1:\n                    total=j\n                    start=j+1\n                else:\n                    end=j-1    \n        k+=1\n\n    def possible_group(x, y):\n        c=b[x]\n        for i in range(x+1, y):\n            c=HCF(c, b[i])\n            if c==1:\n                return False\n        return True        \n\n#    total=bmax\n#    start=bmax+1\n#    end=min(n-1, bmax*2-1)\n#    c=int(0.5+math.log2(bmax))\n#    while start<=end:\n#        j=(start+end)//2\n#        for k in range(n-j):            \n#            if HCF(St[k][c], St[k+j-2**c][c])!=1:\n#                total=j\n#                start=j+1\n#                break\n#        if start<=j:\n#            end=j-1\n            \n    \n    print(total+1)\n\n#    test=0\n#    for j in range(1,n):\n#        for k in range(n-j):\n#            if possible_group(k,k+j):\n#                test=j\n#                break\n#        if test<j:\n#            break    \n\n#    if test!=total:\n#        print(test,total)        \n\n    \n\n    "
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict, deque, Counter\nfrom heapq import heapify, heappop, heappush\nimport math\nfrom copy import deepcopy\nfrom itertools import combinations, permutations, product, combinations_with_replacement\nfrom bisect import bisect_left, bisect_right\n\nimport sys\ndef input():\n    return sys.stdin.readline().rstrip()\ndef getN():\n    return int(input())\ndef getNM():\n    return map(int, input().split())\ndef getList():\n    return list(map(int, input().split()))\ndef getListGraph():\n    return list(map(lambda x:int(x) - 1, input().split()))\ndef getArray(intn):\n    return [int(input()) for i in range(intn)]\n\nmod = 10 ** 9 + 7\nMOD = 998244353\n# sys.setrecursionlimit(10000000)\ninf = float('inf')\neps = 10 ** (-10)\ndy = [0, 1, 0, -1]\ndx = [1, 0, -1, 0]\n\n#############\n# Main Code #\n#############\n\n#####segfunc#####\ndef segfunc(x, y):\n    return math.gcd(x, y)\n#################\n\n# gcd\u306e\u9006\u5143\u306f0\n#####ide_ele#####\nide_ele = 0\n#################\n\nclass SegTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        # \u914d\u5217\u306e\u5024\u3092\u8449\u306b\u30bb\u30c3\u30c8\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        # \u69cb\u7bc9\u3057\u3066\u3044\u304f\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\nT = getN()\nfor _ in range(T):\n    N = getN()\n    psu = getList()\n    A = [abs(psu[i] - psu[i + 1]) for i in range(N - 1)]\n    seg = SegTree(A, segfunc, ide_ele)\n    if N == 1:\n        print(1)\n        continue\n\n    l, ans = 0, 0\n    for r in range(N - 1):\n        while seg.query(l, r + 1) == 1:\n            l += 1\n        ans = max(ans, r - l + 2)\n    print(ans)"
        },
        {
            "language": 4,
            "solution": "//package codechef;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.StringTokenizer;\npublic class codeforces {\n\t\n\t\n\t\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n    private static void shuffleArray(int[] array)\n    {\n        int index, temp;\n        Random random = new Random();\n        for (int i = array.length - 1; i > 0; i--)\n        {\n            index = random.nextInt(i + 1);\n            temp = array[index];\n            array[index] = array[i];\n            array[i] = temp;\n        }\n    }\n    \n    static long power(long n,long m)\n    {\n    \tlong res=1;\n    \t\n    \twhile(m>0)\n    \t{\n    \t\tif((m&1)==1)\n    \t\t\tres=res*n;\n    \t\tn=n*n;\n    \t\tm=m/2;\n    \t}\n    \t\n    \treturn res;\n    }\n\tstatic boolean[] res;\n\tstatic ArrayList<Integer> prime;\n    static void preCompute(int n)\n    {\n    \tres=new boolean[n+1];\n    \tArrays.fill(res, true);\n    \t\n    \tfor(int i=2;i*i<=n;i++)\n    \t{\n    \t\tif(res[i])\n    \t\t{\n    \t\t\tfor(int j=i*i;j<=n;j+=i)\n    \t\t\t{\n    \t\t\t\tres[j]=false;\n    \t\t\t}\n    \t\t}\n    \t}\n    \tprime=new ArrayList<>();\n    \tfor(int i=2;i<=n;i++)\n    \t{\n    \t\tif(res[i])\n    \t\t\tprime.add(i);\n    \t}\n    \t\n    \t\n    \t\n    }\n    \n    static long gcd(long a, long b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b);\n    }\n    \n    static boolean check(int k,long arr[])\n    {\n    \tint n=arr.length;\n    \tlong[] pre=new long[n];\n    \tlong[] suff=new long[n];\n    \tfor(int i=0;i<arr.length;i+=k)\n    \t{\n    \t\tint l=i;\n    \t\tint r=Math.min(n-1, l+k-1);\n    \t\tpre[l]=arr[l];\n    \t\tfor(int j=l+1;j<=r;j++)\n    \t\t{\n    \t\t\tpre[j]=gcd(pre[j-1], arr[j]);\n    \t\t}\n    \t\t\n    \t\tsuff[r]=arr[r];\n    \t\tfor(int j=r-1;j>=l;j--)\n    \t\t{\n    \t\t\tsuff[j]=gcd(suff[j+1], arr[j]);\n    \t\t}\n    \t}\n    \t\n    \tfor(int i=0;i+k-1<n;i++)\n    \t{\n    \t\tif(gcd(suff[i], pre[i+k-1])>1)\n    \t\t{\n    \t\t\treturn true;\n    \t\t}\n    \t}\n    \t\n    \treturn false;\n    }\n    \n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tFastReader sc=new FastReader();\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0)\n\t\t{\n\t\t\tint n=sc.nextInt();\n\t\t\t//int k=sc.nextInt();\n\t\t\tlong arr[]=new long[n];\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i]=sc.nextLong();\n\t\t\t}\n\t\t\t\n\t\t\tlong[] b=new long[n-1];\n\t\t\tfor(int i=0;i<n-1;i++)\n\t\t\t{\n\t\t\t\tb[i]=Math.abs(arr[i+1]-arr[i]);\n\t\t\t}\n\t\t\t\n\t\t\tint l=1,r=n;\n\t\t\twhile(l<r)\n\t\t\t{\n\t\t\t\tint mid=(r+l)/2;\n\t\t\t\tif(check(mid, b))\n\t\t\t\t{\n\t\t\t\t\tl=mid+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tr=mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(l);\n\t\t}\n\t\t\n\t\t\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys,os,io\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom math import gcd\n\nclass RangeQuery:\n    def __init__(self, data, func=gcd):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n\nfor _ in range (int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    d = [abs(a[i] - a[i-1]) for i in range (1,n)]\n    rq = RangeQuery(d)\n    ans = 1\n    for i in range (n):\n        l = i\n        r = n-2\n        while(l<=r):\n            mid = (l+r)//2\n            q = rq.query(i, mid+1)\n            if q==1:\n                r = mid-1\n            else:\n                ans = max(ans, mid-i+2)\n                l = mid+1\n    print(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Ishu\n{\n    static Scanner scan = new Scanner(System.in);\n    static BufferedWriter output = new BufferedWriter(new OutputStreamWriter(System.out)); \n    static long gcd(long a, long b)\n    {\n    if(b == 0l)\n        return a;\n        \n    return gcd(b, a % b);\n    }\n    \n    static void tc() throws Exception\n    {\n    int n = scan.nextInt();\n    long[] a = new long[n];\n    int i, j;\n    \n    for(i=0;i<n;++i)\n        a[i] = scan.nextLong();\n    \n    long[] b = new long[n - 1];\n    for(i=1;i<n;++i)\n        b[i - 1] = Math.abs(a[i] - a[i - 1]); \n        \n    if(n == 1)\n        {\n        output.write(\"1\\n\");\n        output.flush();\n        return;\n        }  \n        \n    int LOG = 0;    \n    while((1 << (LOG + 1)) <= n - 1)    \n        LOG++;\n        \n    long[][] dp = new long[LOG + 1][n - 1];\n    for(j=0;j<n-1;++j)    \n        dp[0][j] = b[j];\n        \n    for(i=1;i<=LOG;++i)    \n        for(j=0;j + (1 << i) - 1 < n-1;++j)\n            dp[i][j] = gcd(dp[i - 1][j], dp[i - 1][j + (1 << i) / 2]);\n        \n    int ans = 1;\n    for(i=0;i<n-1;++i)\n        {\n        long cur = b[i];\n        \n        int idx = -1;\n        int beg = i;\n        int end = n - 2;\n        int mid = (beg + end) / 2;\n        \n        while(beg <= end)\n            {\n            mid = (beg + end) / 2;\n            int len = mid - i + 1;\n            int l = 0;\n            while(1 << (l + 1) <= len)\n                l++;\n                \n            long ca = gcd(dp[l][i], dp[l][mid - (1 << l) + 1]); \n            \n            if(ca > 1l)\n                {\n                idx = mid;\n                beg = mid + 1;\n                }   \n            else\n                end = mid - 1;\n            }\n        \n        if(idx != -1)\n            ans = Math.max(ans, idx - i + 2);\n        }\n         \n        \n    output.write(ans + \"\\n\");\n    output.flush();      \n    output.flush();\n    }\n    public static void main(String[] args) throws Exception\n    {\n    int t = 1;\n    t = scan.nextInt();\n    while(t-- > 0)\n        tc();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> fourDirection = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\nvector<vector<int>> eightDirection = {{-1, 0}, {-1, 1}, {0, 1},  {1, 1},\n                                      {1, 0},  {1, -1}, {0, -1}, {-1, -1}};\nlong long int mod(long long int n, long long int M) { return (n % M + M) % M; }\nlong long int modAdd(long long int a, long long int b, long long int M) {\n  return mod(mod(a, M) + mod(b, M), M);\n}\nlong long int modMul(long long int a, long long int b, long long int M) {\n  return mod(mod(a, M) * mod(b, M), M);\n}\nlong long int modMinus(long long int a, long long int b, long long int M) {\n  return mod(mod(a, M) - mod(b, M), M);\n}\nlong long int modpow(long long int x, long long int n, long long int M) {\n  if (n == 0) return 1 % M;\n  if (n == 1) return x % M;\n  long long int u = modpow(x, n / 2, M);\n  u = modMul(u, u, M);\n  if (n % 2) u = modMul(u, x, M);\n  return u;\n}\nlong long int gcd(long long int a, long long int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long int extendedGcd(long long int a, long long int b, long long int &x,\n                          long long int &y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long int x1, y1;\n  long long int g = extendedGcd(b, a % b, x1, y1);\n  x = y1;\n  y = x1 - y1 * (a / b);\n  return g;\n}\nlong long int modInverse(long long int a, long long int m) {\n  long long int g, x, y;\n  g = extendedGcd(a, m, x, y);\n  if (g == 1) {\n    return (x % m + m) % m;\n  }\n  return -1;\n}\nlong long int crt(vector<long long int> &P, vector<long long int> &R) {\n  int n = P.size();\n  vector<long long int> X(n);\n  long long int productOfAllP = 1;\n  for (int i = 0; i < n; i++) productOfAllP *= P[i];\n  for (int i = 0; i < n; i++) {\n    X[i] = R[i];\n    long long int mulOfInverse = 1;\n    long long int mul = 1;\n    for (int j = 0; j < i; j++) {\n      mulOfInverse = modMul(mulOfInverse, modInverse(P[j], P[i]), P[i]);\n      X[i] = modMinus(X[i], modMul(X[j], mul, P[i]), P[i]);\n      mul = modMul(mul, P[j], P[i]);\n    }\n    X[i] = modMul(X[i], mulOfInverse, P[i]);\n  }\n  long long int finalX = 0;\n  long long int mul = 1;\n  for (int i = 0; i < n; i++) {\n    finalX = modAdd(finalX, modMul(X[i], mul, productOfAllP), productOfAllP);\n    mul = modMul(mul, P[i], productOfAllP);\n  }\n  return finalX;\n}\nbool isPrime(long long int n) {\n  for (int i = 2; i * i <= n; i++)\n    if (n % i == 0) return false;\n  return true;\n}\nint getParent(vector<int> &parent, int s) {\n  if (parent[s] == s) return s;\n  return getParent(parent, parent[s]);\n}\nvector<int> primeNumbers;\nvoid sieve() {\n  int limit = 1e5;\n  vector<bool> prime(limit, true);\n  for (long long int i = 2; i < limit; i++) {\n    if (prime[i]) {\n      primeNumbers.push_back(i);\n      for (long long int j = i * i; j < limit; j = j + i) prime[j] = false;\n    }\n  }\n}\nbool insideGrid(int x, int y, int n, int m) {\n  if (x >= 0 && x < n && y >= 0 && y < m) return true;\n  return false;\n}\nvector<long long int> getMemAllocated(int n) {\n  int ans = 1;\n  while (n > ans) ans *= 2;\n  ans = ans * 2 - 1;\n  vector<long long int> result(ans, 0);\n  return result;\n}\nlong long int buildTree(vector<long long int> &tree,\n                        vector<long long int> &data, int root, int start,\n                        int end) {\n  if (start != end) {\n    int mid = (start + end) / 2;\n    tree[root] = gcd(buildTree(tree, data, root * 2 + 1, start, mid),\n                     buildTree(tree, data, root * 2 + 2, mid + 1, end));\n  } else\n    tree[root] = data[start];\n  return tree[root];\n}\nlong long int rangeQuery(vector<long long int> &tree, int root, int start,\n                         int end, int rS, int rE) {\n  if (start >= rS && end <= rE) return tree[root];\n  if (start > rE || end < rS) return -1;\n  int mid = (start + end) / 2;\n  long long int v1 = rangeQuery(tree, root * 2 + 1, start, mid, rS, rE);\n  long long int v2 = rangeQuery(tree, root * 2 + 2, mid + 1, end, rS, rE);\n  if (v1 == v2) return v1;\n  if (v1 == -1) return v2;\n  if (v2 == -1) return v1;\n  return gcd(v1, v2);\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<long long int> data(n);\n  for (int i = 0; i < n; i++) cin >> data[i];\n  if (n == 1) {\n    cout << 1 << \"\\n\";\n    return;\n  }\n  vector<long long int> dif;\n  for (int i = 1; i < n; i++) dif.push_back(abs(data[i] - data[i - 1]));\n  vector<long long int> T = getMemAllocated(dif.size());\n  buildTree(T, dif, 0, 0, dif.size() - 1);\n  int globalAns = 0;\n  for (int i = 0; i < dif.size(); i++) {\n    int start = i;\n    int end = dif.size() - 1;\n    int qAns = i;\n    bool possible = false;\n    while (start <= end) {\n      int m = (start + end) / 2;\n      long long int g = rangeQuery(T, 0, 0, dif.size() - 1, i, m);\n      assert(g != -1);\n      if (g == 1) {\n        end = m - 1;\n      } else {\n        possible = true;\n        qAns = m;\n        start = m + 1;\n      }\n    }\n    if (possible) {\n      globalAns = max(globalAns, qAns - i + 1);\n    }\n  }\n  cout << globalAns + 1 << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.BitSet;\nimport java.util.function.BinaryOperator;\n\npublic class D {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static FastReader s = new FastReader();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    private static int[] rai(int n) {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextInt();\n        }\n        return arr;\n    }\n\n    private static int[][] rai(int n, int m) {\n        int[][] arr = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                arr[i][j] = s.nextInt();\n            }\n        }\n        return arr;\n    }\n\n    private static long[] ral(int n) {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextLong();\n        }\n        return arr;\n    }\n\n    private static long[][] ral(int n, int m) {\n        long[][] arr = new long[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                arr[i][j] = s.nextLong();\n            }\n        }\n        return arr;\n    }\n\n    private static int ri() {\n        return s.nextInt();\n    }\n\n    private static long rl() {\n        return s.nextLong();\n    }\n\n    private static String rs() {\n        return s.next();\n    }\n\n\n    static long gcd(long a,long b)\n    {\n        if(b==0)\n        {\n            return a;\n        }\n        return gcd(b,a%b);\n    }\n\n    static int MOD=(int)1e9+7;\n\n    public static int primeFactors(long n)\n    {\n        // Print the number of 2s that divide n\n        int count=0;\n        while (n % 2 == 0) {\n            count++;\n            n /= 2;\n        }\n\n        // n must be odd at this point.  So we can\n        // skip one element (Note i = i +2)\n        for (long i = 3; i * i<=n; i += 2) {\n            // While i divides n, print i and divide n\n            while (n % i == 0) {\n                count++;\n                n /= i;\n            }\n        }\n\n        // This condition is to handle the case whien\n        // n is a prime number greater than 2\n        if (n > 2)\n            count++;\n\n        return count;\n    }\n    static int factors(int n)\n    {\n        HashSet<Integer> set=new HashSet<>();\n        for(int i=1;i*i<=n;i++)\n        {\n            if(n%i==0)\n            {\n                set.add(i);\n                set.add(n/i);\n            }\n        }\n        return set.size()-1;\n    }\n\n    static List<Integer> primes = new ArrayList<>();\n    static int countPF(int x) {\n        int count=0;\n        for (int i:primes) {\n            while (x%i==0) {\n                count++;\n                x/=i;\n            }\n        }\n        if (x>1) count++;\n        return count;\n    }\n\n    static List<Integer> sieveOfEratosthenes(int n)\n    {\n\n        boolean[] prime = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n            prime[i] = true;\n\n        for (int p = 2; p * p <= n; p++)\n        {\n            // If prime[p] is not changed, then it is a\n            // prime\n            if (prime[p])\n            {\n                // Update all multiples of p\n                for (int i = p * p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n\n        List<Integer> list = new ArrayList<>();\n        for(int i=2;i<=n;i++)\n        {\n            if(prime[i])\n            {\n                list.add(i);\n            }\n\n        }\n\n        return list;\n    }\n\n    static int bsearch(SparseMatrix sp, int i ,int len)\n    {\n        int l=i,r=len-1;\n        int ind = -1;\n        while(l<=r)\n        {\n            int mid = (l+r)/2;\n            long gcd = sp.getGCD(i,mid);\n            if(gcd>1)\n            {\n                ind=mid;\n                l=mid+1;\n            }\n            else\n            {\n                r=mid-1;\n            }\n        }\n        return ind;\n    }\n    public static void main(String[] args) {\n        StringBuilder ans = new StringBuilder();\n\n        int t = ri();\n//        int t=1;\n        while(t-- >0)\n        {\n            int n=ri();\n            long[] arr=ral(n);\n            if(n==1)\n            {\n                ans.append(\"1\\n\");\n                continue;\n            }\n\n            long[] diff = new long[n-1];\n            int len = n-1;\n            for(int i=0;i<len;i++)\n            {\n                diff[i] = Math.abs(arr[i+1]-arr[i]);\n            }\n\n            SparseMatrix sp = new SparseMatrix(diff);\n//            System.out.println(Arrays.toString(diff));\n            int max = 0;\n            for(int i=0;i<len;i++)\n            {\n                int ind = bsearch(sp,i,len);\n//                System.out.println(i+\" \"+ind);\n                max=Math.max(ind-i+1,max);\n            }\n            ans.append(max+1).append(\"\\n\");\n\n\n        }\n        out.print(ans.toString());\n        out.flush();\n    }\n    public static class SparseMatrix {\n        private long[] arr;\n        private int m;\n        private long[][] minSparse;\n\n\n        private int n;\n        public SparseMatrix(long[] arr) {\n            this.arr = arr;\n            this.m=arr.length;\n            this.n=Integer.toBinaryString(m).length();\n            minSparse=new long[n][m];\n\n            createMinSparse();\n        }\n        private long gcd(long a,long b)\n        {\n            if(b==0)\n            {\n                return a;\n            }\n            return gcd(b,a%b);\n        }\n        private void createMinSparse()\n        {\n            //filling the first row of sparse matrix with the values of the input array\n            for(int j=0;j<m;j++)\n            {\n                minSparse[0][j]=arr[j];\n            }\n            //filling other rows of the sparse matrix\n            for(int i=1;i<n;i++)\n            {\n                for(int j=0;j+(1<<(i-1))<m;j++)\n                {\n\n                    long left=minSparse[i-1][j];\n                    long right=minSparse[i-1][j+(1<<(i-1))];\n\n                    //change to min-> max to create MaxSparseMatrix\n                    minSparse[i][j]=gcd(left,right);\n\n\n                }\n            }\n        }\n\n        //get minimum value in range l->r inclusive\n    /*\n        for any range [l, r] we can find the two values and\n        find their minimum. These values are defined below:\n\n        len: length of the required range, i.e., r-l+1\n\n        p: maximum power of 2 that can fit in len. E.g, [1,11] , len=11, thus p=3\n\n        k: 2^p\n\n        find the minimum between sparse[p][l] and sparse[p][r-k+1]\n    */\n        public long getGCD(int l,int r)\n        {\n            int len=r-l+1;\n            int p=Integer.toBinaryString(len).length()-1;\n            int k=1<<p;\n\n            long left=minSparse[p][l];\n            long right=minSparse[p][r-k+1];\n            return gcd(right,left);\n        }\n\n\n\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\nconst int inf = 0x3f3f3f3f;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst int N = 2e5 + 5, M = 20;\nint n, m, lg[N];\nlong long f[N][M];\nlong long a[N], b[N];\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nvoid init() {\n  for (int i = 1; i <= n; ++i) f[i][0] = a[i];\n  for (int i = 1; (1 << i) <= n; ++i)\n    for (int j = 1; j + (1 << i) - 1 <= n; ++j) {\n      f[j][i] = gcd(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n    }\n}\nlong long query(int l, int r) {\n  int k = lg[r - l + 1] - 1;\n  return gcd(f[l][k], f[r - (1 << k) + 1][k]);\n}\nvoid show() {\n  for (int i = 1; i <= n; ++i) {\n    cout << a[i] << ' ';\n  }\n  puts(\"\");\n}\nvoid solve() {\n  scanf(\"%d\", &n);\n  long long g = 0;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", &b[i]);\n  }\n  for (int i = 1; i < n; ++i) {\n    a[i] = abs(b[i] - b[i + 1]);\n  }\n  --n;\n  int res = 0;\n  init();\n  for (int i = 1; i <= n; ++i) {\n    int l = i, r = n;\n    while (l < r) {\n      int mid = l + r + 1 >> 1;\n      if (query(i, mid) > 1)\n        l = mid;\n      else\n        r = mid - 1;\n    }\n    if (query(i, r) > 1) res = max(res, r - i + 1);\n  }\n  printf(\"%d\\n\", res + 1);\n}\nint main() {\n  for (int i = 1; i < N; ++i) lg[i] = lg[i >> 1] + 1;\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//Utilities\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n\tstatic int t;\n\tstatic int n;\n\tstatic long[] a, d, gcd;\n\tstatic int res;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tt = in.iscan();\n\t\twhile (t-- > 0) {\n\t\t\tn = in.iscan(); a = new long[n]; d = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = in.lscan();\n\t\t\t\tif (i > 0) {\n\t\t\t\t\td[i] = Math.abs(a[i] - a[i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 1;\n\t\t\tif (n > 1) {\n\t\t\t\tgcd = new long[4*n+5];\n\t\t\t\tinit(1, 1, n-1);\n\t\t\t\tint l = 1, r = 1;\n\t\t\t\twhile (l < n) {\n\t\t\t\t\tif (r < l) {\n\t\t\t\t\t\tr = l;\n\t\t\t\t\t}\n\t\t\t\t\twhile (r < n-1 && getGcd(1, 1, n-1, l, r+1) != 1) {\n\t\t\t\t\t\tr++;\n\t\t\t\t\t}\n\t\t\t\t\tif (getGcd(1, 1, n-1, l, r) != 1) {\n\t\t\t\t\t\tres = Math.max(res, r - l + 2);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res);\n\t\t}\n\t\tout.close();\n\t} \n\t\n\tstatic void init(int i, int l, int r){\n\t    if (l == r){  \n\t      gcd[i] = d[l];\n\t      return; \n\t    }\n\t    int mid = (l+r) / 2;\n\t    init(2*i, l, mid);\n\t    init(2*i + 1, mid + 1, r);\n\t    gcd[i] = UTILITIES.gcd(gcd[2*i], gcd[2*i+1]);\n\t  }\n\n\t  static long getGcd(int i, int l, int r, int ql, int qr){\n\t    if (qr < l || ql > r) return -1;\n\t    else if (ql <= l && qr >= r) return gcd[i];\n\t    else {\n\t      int mid = (l+r) / 2;\n\t      long a = getGcd(2*i, l, mid, ql, qr);\n\t      long b = getGcd(2*i+1, mid + 1, r, ql, qr);\n\t      if (a != -1 && b != -1) return UTILITIES.gcd(a, b);\n\t      if (a != -1) return a;\n\t      return b;\n\t    }\n\t  }\n\t\n\tstatic INPUT in = new INPUT(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tprivate static class INPUT {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar, numChars;\n\n\t\tpublic INPUT (InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic INPUT (String file) throws IOException {\n\t\t\tthis.stream = new FileInputStream (file);\n\t\t}\n\n\t\tpublic int cscan () throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read (buf);\n\t\t\t}\n\t\t\t\n\t\t\tif (numChars == -1)\n\t\t\t\treturn numChars;\n\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int iscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo {\n\t\t\t\tres = (res << 1) + (res << 3);\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String sscan () throws IOException {\n\t\t\tint c = cscan ();\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tStringBuilder res = new StringBuilder ();\n\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint (c);\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res.toString ();\n\t\t}\n\n\t\tpublic double dscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tdouble res = 0;\n\n\t\t\twhile (!space (c) && c != '.') {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * UTILITIES.fast_pow (10, iscan ());\n\t\t\t\t\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tif (c == '.') {\n\t\t\t\tc = cscan ();\n\t\t\t\tdouble m = 1;\n\n\t\t\t\twhile (!space (c)) {\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * UTILITIES.fast_pow (10, iscan ());\n\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = cscan ();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long lscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tlong res = 0;\n\n\t\t\tdo {\n\t\t\t\tres = (res << 1) + (res << 3);\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean space (int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n\tpublic static class UTILITIES {\n\n\t\tstatic final double EPS = 10e-6;\n\t\t\n\t\tpublic static void sort(int[] a, boolean increasing) {\n\t\t\tArrayList<Integer> arr = new ArrayList<Integer>();\n\t\t\tint n = a.length;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr.add(a[i]);\n\t\t\t}\n\t\t\tCollections.sort(arr);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (increasing) {\n\t\t\t\t\ta[i] = arr.get(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[i] = arr.get(n-1-i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static void sort(long[] a, boolean increasing) {\n\t\t\tArrayList<Long> arr = new ArrayList<Long>();\n\t\t\tint n = a.length;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr.add(a[i]);\n\t\t\t}\n\t\t\tCollections.sort(arr);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (increasing) {\n\t\t\t\t\ta[i] = arr.get(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[i] = arr.get(n-1-i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static void sort(double[] a, boolean increasing) {\n\t\t\tArrayList<Double> arr = new ArrayList<Double>();\n\t\t\tint n = a.length;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr.add(a[i]);\n\t\t\t}\n\t\t\tCollections.sort(arr);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (increasing) {\n\t\t\t\t\ta[i] = arr.get(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[i] = arr.get(n-1-i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic static int lower_bound (int[] arr, int x) {\n\t\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\n\t\t\t\tif (arr[mid] >= x)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse\n\t\t\t\t\tlow = mid + 1;\n\t\t\t}\n\n\t\t\treturn low;\n\t\t}\n\n\t\tpublic static int upper_bound (int[] arr, int x) {\n\t\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\n\t\t\t\tif (arr[mid] > x)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse\n\t\t\t\t\tlow = mid + 1;\n\t\t\t}\n\n\t\t\treturn low;\n\t\t}\n\n\t\tpublic static long gcd (long a, long b) {\n\t\t\treturn b == 0 ? a : gcd (b, a % b);\n\t\t}\n\n\t\tpublic static long lcm (long a, long b) {\n\t\t\treturn a * b / gcd (a, b);\n\t\t}\n\n\t\tpublic static long fast_pow_mod (long b, long x, int mod) {\n\t\t\tif (x == 0) return 1;\n\t\t\tif (x == 1) return b;\n\t\t\tif (x % 2 == 0) return fast_pow_mod (b * b % mod, x / 2, mod) % mod;\n\n\t\t\treturn b * fast_pow_mod (b * b % mod, x / 2, mod) % mod;\n\t\t}\n\n\t\tpublic static int fast_pow (int b, int x) {\n\t\t\tif (x == 0) return 1;\n\t\t\tif (x == 1) return b;\n\t\t\tif (x % 2 == 0) return fast_pow (b * b, x / 2);\n\n\t\t\treturn b * fast_pow (b * b, x / 2);\n\t\t}\n\n\t\tpublic static long choose (long n, long k) {\n\t\t\tk = Math.min (k, n - k);\n\t\t\tlong val = 1;\n\n\t\t\tfor (int i = 0; i < k; ++i)\n\t\t\t\tval = val * (n - i) / (i + 1);\n\n\t\t\treturn val;\n\t\t}\n\n\t\tpublic static long permute (int n, int k) {\n\t\t\tif (n < k) return 0;\n\t\t\tlong val = 1;\n\n\t\t\tfor (int i = 0; i < k; ++i)\n\t\t\t\tval = (val * (n - i));\n\n\t\t\treturn val;\n\t\t}\n\t\t\n\t\t// start of permutation and lower/upper bound template\n\t\tpublic static void nextPermutation(int[] nums) {\n\t\t    //find first decreasing digit\n\t\t    int mark = -1;\n\t\t    for (int i = nums.length - 1; i > 0; i--) {\n\t\t        if (nums[i] > nums[i - 1]) {\n\t\t            mark = i - 1;\n\t\t            break;\n\t\t        }\n\t\t    }\n\t\t \n\t\t    if (mark == -1) {\n\t\t        reverse(nums, 0, nums.length - 1);\n\t\t        return;\n\t\t    }\n\t\t \n\t\t    int idx = nums.length-1;\n\t\t    for (int i = nums.length-1; i >= mark+1; i--) {\n\t\t        if (nums[i] > nums[mark]) {\n\t\t            idx = i;\n\t\t            break;\n\t\t        }\n\t\t    }\n\t\t \n\t\t    swap(nums, mark, idx);\n\t\t \n\t\t    reverse(nums, mark + 1, nums.length - 1);\n\t\t}\n\t\t \n\t\tpublic static void swap(int[] nums, int i, int j) {\n\t\t    int t = nums[i];\n\t\t    nums[i] = nums[j];\n\t\t    nums[j] = t;\n\t\t}\n\t\t \n\t\tpublic static void reverse(int[] nums, int i, int j) {\n\t\t    while (i < j) {\n\t\t        swap(nums, i, j);\n\t\t        i++;\n\t\t        j--;\n\t\t    }\n\t\t}\n\t\t\n\t\tstatic int lower_bound (int[] arr, int hi, int cmp) {\n\t\t\tint low = 0, high = hi, mid = -1;\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\t\t\t\tif (arr[mid] >= cmp) high = mid;\n\t\t\t\telse low = mid + 1;\n\t\t\t}\n\t\t\treturn low;\n\t\t}\n\t \n\t\tstatic int upper_bound (int[] arr, int hi, int cmp) {\n\t\t\tint low = 0, high = hi, mid = -1;\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\t\t\t\tif (arr[mid] > cmp) high = mid;\n\t\t\t\telse low = mid + 1;\n\t\t\t}\n\t\t\treturn low;\n\t\t}\n\t\t// end of permutation and lower/upper bound template\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class D {\n\t\n\tstatic int K, N;\n\tstatic long[][] st;\n\tstatic int[] log;\n\t\n\t\n\tpublic static void main(String args[]) throws NumberFormatException, IOException {\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\t\n\t\tint t = Integer.parseInt(br.readLine());\n\t\t\n\t\twhile(t --> 0) {\n\t\t\t\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tStringTokenizer stn = new StringTokenizer(br.readLine());\n\t\t\t\n\t\t\tlong[] subs = new long[n-1];\n\t\t\tlong[] ar = new long[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\n\t\t\t\tar[i] = Long.parseLong(stn.nextToken());\n\t\t\t\t\n\t\t\t\tif(i > 0)\n\t\t\t\t\tsubs[i-1] = Math.abs(ar[i] - ar[i-1]);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tar = subs;\n\t\t\t\n\t\t\tif(n == 1) {\n\t\t\t\t\n\t\t\t\tpw.println(1);\n\t\t\t\tpw.flush();\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tK = 25;\n\t\t\tN = n-1;\n\t\t\tst = new long[N][K+1];\n\t\t\tlog = new int[N+1];\n\t\t\t\n\t\t\tlog[1] = 0;\n\t\t\tfor (int i = 2; i <= N; i++)\n\t\t\t    log[i] = log[i/2] + 1;\n\t\t\t\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t    st[i][0] = ar[i];\n\n\t\t\tfor (int j = 1; j <= K; j++)\n\t\t\t    for (int i = 0; i + (1 << j) <= N; i++)\n\t\t\t        st[i][j] = gcd(st[i][j-1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t\t\t\t\n\t\t\tint i = 0; \n\t\t\tint j = 0;\n\t\t\tint mx = 1;\n\t\t\t\t\t\t\n\t\t\twhile(j < N) {\n\t\t\t\t\n\t\t\t\twhile(j < N && gcd(st[i][log[j - i + 1]], st[j - (1 << log[j - i + 1]) + 1][log[j - i + 1]]) > 1) {\n\t\t\t\t\t\n\t\t\t\t\tj++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\tmx = Math.max(mx, 1+j-i);\n\t\t\t\t\n\t\t\t\tif(j == N)\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\twhile(i < N && i <= j && gcd(st[i][log[j - i + 1]], st[j - (1 << log[j - i + 1]) + 1][log[j - i + 1]]) == 1) {\n\t\t\t\t\t\n\t\t\t\t\ti++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tj = Math.max(j, i);\n\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tpw.println(mx);\n\t\t\tpw.flush();\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tpw.close();\n\t\t\n\t}\n\t\n\tstatic long gcd (long a, long b) {\n\t    if (b == 0)\n\t        return a;\n\t    else\n\t        return gcd (b, a % b);\n\t}\n\t\n}"
        },
        {
            "language": 1,
            "solution": "import sys\nimport os\nfrom io import BytesIO\nfrom fractions import gcd\n\n# pypy2\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n\nf = sys.stdin\n\nline = lambda: f.readline().strip('\\r\\n').split()\n\ndef write(w):\n    sys.stdout.write(w)\n    sys.stdout.write(\"\\n\")\n\nclass RangeQuery:\n    def __init__(self,array,func,func_eq):\n        n = len(array)\n        self.array = array\n        self.func = func\n        self.func_eq = func_eq\n        self.row = n.bit_length()\n        self.tab = [[0 for _ in range(n)] for _ in range(self.row)]\n\n        self.tab[0] = list(self.array)\n        for e in range(1, self.row):\n            for j in range(n - 2**e + 1):\n                self.tab[e][j] = self.func(self.tab[e-1][j], self.tab[e-1][j + 2**(e-1)])\n    \n    ''' l,r inclusive '''\n    def query(self,l,r):\n        e = 0 if r-l == 0 else (r-l+1).bit_length() - 1\n        return self.func(self.tab[e][l], self.tab[e][r - 2**e + 1])\n    \n\ndef bs_pred_r(predicate, start_l, start_r):\n    l = start_l\n    r = start_r\n    while l <= r:\n        mid = (l&r+1) + ((l^r+1)>>1)\n        if predicate(mid):\n            r = mid-1\n        else:\n            l = mid+1\n    return l\n\ndef solve():\n    \n    if N == 1:\n        return str(1)\n    \n    res = 1\n    \n    d = [0] * (N-1)\n    for i in range(N-1):\n        f = A[i]\n        s = A[i+1]\n        d[i] = abs(f-s)\n        \n    rq = RangeQuery(d, gcd, min)\n    \n    for i in range(N-1):\n        if rq.query(i, i) == 1:\n            continue\n        \n        idx = bs_pred_r(lambda n: rq.query(i, n) == 1, i, N-2)\n        idx -= 1\n        \n        l = idx - i + 2\n                \n        if l > res:\n            res = l\n            \n    return str(res)\n\nT = int(line()[0])\nfor test in range(1,T+1):\n    N = int(line()[0])\n    A = list(map(int, line()))\n    \n    write(solve())\n    \nf.close()"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom collections import defaultdict\nfrom  collections import deque\ninput = sys.stdin.readline\n \ndef gcd(a, b):\n    a, b = max(a, b), min(a, b)\n    while True:\n        if a % b == 0:\n            return b\n        else:\n            a, b = b, a % b\n \nclass Queue:\n    stack1, stack2 = [], []\n    gcd_stack1, gcd_stack2 = [], []\n    \n    def add_to_stack(self, val, stack, gcd_stack):\n        stack.append(val)\n        if gcd_stack:\n            max_val, min_val = max(gcd_stack[-1], val), min(gcd_stack[-1], val)\n            gcd_stack.append(gcd(max_val, min_val))\n        else:\n            gcd_stack.append(val)\n        \n    def pop_from_stack(self, stack, gcd_stack):\n        if stack:\n            gcd_stack.pop()\n            return stack.pop()\n        return\n    \n    def add(self, val):\n        self.add_to_stack(val, self.stack1, self.gcd_stack1)\n \n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                val = self.pop_from_stack(self.stack1, self.gcd_stack1)\n                self.add_to_stack(val, self.stack2, self.gcd_stack2)\n        if self.stack2:\n            return self.pop_from_stack(self.stack2, self.gcd_stack2)\n        return\n            \n \n    def get_gcd(self):\n        if not self.stack1 and not self.stack2:\n            return \n        elif not self.stack1:\n            return self.gcd_stack2[-1]\n        elif not self.stack2:\n            return self.gcd_stack1[-1]\n        else:\n            max_val, min_val = max(self.gcd_stack1[-1], self.gcd_stack2[-1]), min(self.gcd_stack1[-1], self.gcd_stack2[-1])\n            return gcd(max_val, min_val)\ndef solve(vals):\n    q = Queue()\n    max_len = 0\n    r = 1 \n    for i in range(1, len(vals)):\n        q.pop()\n \n        while q.get_gcd()  is None or (r < len(vals) and q.get_gcd()  > 1):\n            if r < len(vals):\n                diff = abs(vals[r] - vals[r-1])\n                q.add(diff)\n                r += 1\n            else:\n                break\n        max_len = max(max_len, r - i)\n        if q.get_gcd() is not None and q.get_gcd() > 1:\n            max_len = max(max_len, r - i+1)\n \n    return max_len\n \nif __name__ == \"__main__\":\n    n = int(input())\n    \n    for _ in range(n):\n        k = int(input())\n        if k == 1:\n            _ = input()\n            print(1)\n        else:\n            vals = list(map(int, input().split()))\n            sys.stdout.write(str(solve(vals)) + '\\n')\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom collections import defaultdict\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\nimport math\n\n\n\n# lookup[i][j] is going to store minimum\n# value in arr[i..j]. Ideally lookup table\n# size should not be fixed and should be\n# determined using n Log n. It is kept\n# constant to keep code simple.\n\n\n\ndef buildSparseTable(arr, n):\n    # GCD of single element is element itself\n    for i in range(0, n):\n        table[i][0] = arr[i]\n\n    # Build sparse table\n    j = 1\n    while (1 << j) <= n:\n        i = 0\n        while i <= n - (1 << j):\n            table[i][j] = math.gcd(table[i][j - 1],\n                                   table[i + (1 << (j - 1))][j - 1])\n\n            i += 1\n        j += 1\n\n\n# Returns minimum of arr[L..R]\ndef query(L, R):\n    # Find highest power of 2 that is smaller\n    # than or equal to count of elements in\n    # given range. For [2, 10], j = 3\n    j = int(math.log2(R - L + 1))\n\n    # Compute GCD of last 2^j elements with\n    # first 2^j elements in range.\n    # For [2, 10], we find GCD of arr[lookup[0][3]]\n    # and arr[lookup[3][3]],\n    return math.gcd(table[L][j],\n                    table[R - (1 << j) + 1][j])\n\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    #n,m=map(int,input().split())\n    b = list(map(int, input().split()))\n    if (n==1):\n        print(1)\n    else:\n\n        diff=[]\n        i=1\n        while(i<n):\n\n            diff.append(abs(b[i]-b[i-1]))\n            i+=1\n        table = [[0 for i in range(25)]\n                 for j in range(n)]\n        buildSparseTable(diff,n-1)\n        ans=0\n        i=0\n        j=0\n        f=n-1\n        while(j<f):\n\n            curr=query(i,j)\n            if (curr==1):\n                i+=1\n            else:\n                ans = max(ans, j - i + 1)\n                j+=1\n            if i>j:\n                j=i\n        print(ans+1)\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic final class D {\n\n    private static class SegTree {\n        int leftMost, rightMost;\n        SegTree left, right;\n        long gcd;\n\n        SegTree(int leftMost, int rightMost, long[] arr) {\n            this.leftMost = leftMost;\n            this.rightMost = rightMost;\n            if (leftMost == rightMost) {\n                gcd = arr[leftMost];\n            } else {\n                final int mid = leftMost + rightMost >>> 1;\n                left = new SegTree(leftMost, mid, arr);\n                right = new SegTree(mid + 1, rightMost, arr);\n                recalc();\n            }\n        }\n\n        private void recalc() {\n            gcd = gcd(left.gcd, right.gcd);\n        }\n\n        private long query(int l, int r) {\n            if (r < leftMost || l > rightMost) {\n                return 0;\n            }\n            if (l <= leftMost && rightMost <= r) {\n                return gcd;\n            }\n            return gcd(left.query(l, r), right.query(l, r));\n        }\n\n        private void update(int idx, long val) {\n            if (leftMost == rightMost) {\n                gcd = val;\n            } else {\n                final int mid = leftMost + rightMost >>> 1;\n                if (idx <= mid) {\n                    left.update(idx, val);\n                } else {\n                    right.update(idx, val);\n                }\n                recalc();\n            }\n        }\n\n        private static long gcd(long a, long b) {\n            return b == 0 ? a : gcd(b, a % b);\n        }\n    }\n\n    public static void main(String[] args) {\n        final FastScanner fs = new FastScanner();\n        final StringBuilder sb = new StringBuilder();\n        final int t = fs.nextInt();\n        for (int test = 0; test < t; test++) {\n            int n = fs.nextInt();\n            final long[] arr = fs.nextLongArray(n);\n            if (n == 1) {\n                sb.append(1).append('\\n');\n                continue;\n            }\n            n--;\n            final long[] diff = new long[n];\n            for (int i = 0; i < n; i++) {\n                diff[i] = Math.abs(arr[i] - arr[i + 1]);\n            }\n            final SegTree st = new SegTree(0, n - 1, diff);\n            int res = 0;\n            int j = 0;\n            long gcd = 0;\n            for (int i = 0; i < n; i++) {\n                gcd = SegTree.gcd(gcd, diff[i]);\n                while (gcd == 1) {\n                    gcd = st.query(++j, i);\n                }\n                if (gcd > 1) {\n                    res = Math.max(res, i - j + 1);\n                }\n            }\n            sb.append(res + 1).append('\\n');\n        }\n        System.out.println(sb);\n    }\n\n    static final class Utils {\n        private static class Shuffler {\n            private static void shuffle(int[] x) {\n                final Random r = new Random();\n\n                for (int i = 0; i <= x.length - 2; i++) {\n                    final int j = i + r.nextInt(x.length - i);\n                    swap(x, i, j);\n                }\n            }\n\n            private static void shuffle(long[] x) {\n                final Random r = new Random();\n\n                for (int i = 0; i <= x.length - 2; i++) {\n                    final int j = i + r.nextInt(x.length - i);\n                    swap(x, i, j);\n                }\n            }\n\n            private static void swap(int[] x, int i, int j) {\n                final int t = x[i];\n                x[i] = x[j];\n                x[j] = t;\n            }\n\n            private static void swap(long[] x, int i, int j) {\n                final long t = x[i];\n                x[i] = x[j];\n                x[j] = t;\n            }\n        }\n\n        public static void shuffleSort(int[] arr) {\n            Shuffler.shuffle(arr);\n            Arrays.sort(arr);\n        }\n\n        public static void shuffleSort(long[] arr) {\n            Shuffler.shuffle(arr);\n            Arrays.sort(arr);\n        }\n\n        private Utils() {}\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        private String next() {\n            while (!st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    //noinspection CallToPrintStackTrace\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int[] nextIntArray(int n) {\n            final int[] a = new int[n];\n            for (int i = 0; i < n; i++) { a[i] = nextInt(); }\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            final long[] a = new long[n];\n            for (int i = 0; i < n; i++) { a[i] = nextLong(); }\n            return a;\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.util.function.Function;\n\npublic class D {\n\n\tprivate static FastScanner fs = new FastScanner();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tint cases = fs.nextInt();\n\t\twhile (cases-- > 0)\n\t\t\tsolve();\n\t}\n\tstatic void solve() throws IOException {\n\t\tint n = fs.nextInt();\n\t\tlong[] a = fs.nextLongs(n);\n\t\tif (n == 1) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}\n\t\tlong[] b = new long[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tb[i] = Math.abs(a[i+1] - a[i]);\n\t\t}\n\t\tSparseTable st = new SparseTable(b);\n//\t\tSystem.out.println(st);\n\t\tint l = 0;\n\t\tint h = n-1;\n\t\twhile (l<h) {\n\t\t\tint mid = (l + h)/2;\n//\t\t\tSystem.out.println(\"low: \" + l + \" \" + \"high: \" + h + \" \" + mid);\n\t\t\tboolean found = false;\n\t\t\tfor (int i = 0; i < n-mid-1; i++) {\n\t\t\t\tif (st.query(i,i+mid) > 1) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) l = mid+1;\n\t\t\telse h = mid;\n\t\t}\n\t\tSystem.out.println(l+1);\n\t}\n\n\n\tstatic class SparseTable {\n\t\tint n;\n\t\tlong[][] mat;\n\n\t\tSparseTable(int[] a) {\n\t\t\tthis(Arrays.stream(a).asLongStream().toArray());\n\t\t}\n\t\tSparseTable(long[] a) {\n\t\t\tn = a.length;\n\t\t\tint max_log = 32 - Integer.numberOfLeadingZeros(n);\n\t\t\tmat = new long[max_log][n];\n\t\t\tmat[0] = a;\n\t\t\tfor (int j = 1; j < max_log; j++) {\n\t\t\t\tfor (int i = 0; i <= n - (1 << j); i++) {\n\t\t\t\t\tmat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate long func(long l1, long l2) {\n\t\t\treturn gcd(l1,l2);\n\t\t}\n\n\t\tlong query(int from, int to) {\n\t\t\tassert(0 <= from && from <= to && to <= n - 1);\n\t\t\tint lg = 32 - Integer.numberOfLeadingZeros(to - from + 1) - 1;\n\t\t\treturn func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(\"SparseTable{\\n\");\n\t\t\tfor (long[] longs : mat) {\n\t\t\t\tsb.append(Arrays.toString(longs)).append(\"\\n\");\n\t\t\t}\n\t\t\tsb.append('}');\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n\tstatic long lcm(long a,long b) {\n\t    \treturn (a/gcd(a,b))*b;\n\t    }\n\n\tstatic long gcd(long a, long b) {\n\t    if (b == 0)\n\t        return a;\n\t    return gcd(b, a % b);\n\t}\n\n\tstatic class FastScanner\n\t{\n\t\t//I don't understand how this works lmao\n\t\tprivate int BS = 1 << 16;\n\t\tprivate char NC = (char) 0;\n\t\tprivate byte[] buf = new byte[BS];\n\t\tprivate int bId = 0, size = 0;\n\t\tprivate char c = NC;\n\t\tprivate double cnt = 1;\n\t\tprivate BufferedInputStream in;\n\n\t\tpublic FastScanner() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t\t} catch (Exception e) {\n\t\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t\t}\n\t\t}\n\n\t\tprivate char getChar() {\n\t\t\twhile (bId == size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}\n\t\t\t\tif (size == -1) return NC;\n\t\t\t\tbId = 0;\n\t\t\t}\n\t\t\treturn (char) buf[bId++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int) nextLong();\n\t\t}\n\n\t\tpublic int[] nextInts(int N) {\n\t\t\tint[] res = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres[i] = (int) nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic ArrayList<Integer> nextIntsArrayList(int N) {\n\t\t\tArrayList<Integer> res = new ArrayList<>(N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres.add((int) nextLong());\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongs(int N) {\n\t\t\tlong[] res = new long[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tcnt = 1;\n\t\t\tboolean neg = false;\n\t\t\tif (c == NC) c = getChar();\n\t\t\tfor (; (c < '0' || c > '9'); c = getChar()) {\n\t\t\t\tif (c == '-') neg = true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor (; c >= '0' && c <= '9'; c = getChar()) {\n\t\t\t\tres = (res << 3) + (res << 1) + c - '0';\n\t\t\t\tcnt *= 10;\n\t\t\t}\n\t\t\treturn neg ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c != '.' ? cur : cur + nextLong() / cnt;\n\t\t}\n\n\t\tpublic double[] nextDoubles(int N) {\n\t\t\tdouble[] res = new double[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile (c <= 32) c = getChar();\n\t\t\twhile (c > 32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc = getChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile (c <= 32) c = getChar();\n\t\t\twhile (c != '\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc = getChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif (c > 32) return true;\n\t\t\twhile (true) {\n\t\t\t\tc = getChar();\n\t\t\t\tif (c == NC) return false;\n\t\t\t\telse if (c > 32) return true;\n\t\t\t}\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e9 + 7;\nlong long gcd(long long a, long long b) {\n  while (b > 0) {\n    long long p = a % b;\n    a = b;\n    b = p;\n  }\n  return a;\n}\nlong long bexp(long long a, int b) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a;\n    a = a * a;\n    b >>= 1;\n  }\n  return res;\n}\nlong long bexpM(long long a, int b) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % M;\n    a = (a * a) % M;\n    b >>= 1;\n  }\n  return res;\n}\nlong long nCk(int n, int k) {\n  long long res = 1;\n  for (int i = k + 1; i < n + 1; i++) res = res * i;\n  long long p = 1;\n  for (int i = 2; i < n - k + 1; i++) p = p * i;\n  res = res / p;\n  return res;\n}\nlong long nCkM(int n, int k) {\n  long long res = 1;\n  for (int i = k + 1; i < n + 1; i++) res = (res * i) % M;\n  long long p = 1;\n  for (int i = 2; i < n - k + 1; i++) p = (p * i) % M;\n  res = (res * bexpM(p, M - 2)) % M;\n  return res;\n}\nconst int N = 2e5;\nlong long st[N][18];\nlong long q(int l, int s, int n) {\n  int i = 0;\n  while ((1 << (i + 1)) < s) i++;\n  return gcd(st[l][i], st[l - (1 << i) + s][i]);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int u;\n  cin >> u;\n  for (int g = 0; g < u; g++) {\n    int n;\n    cin >> n;\n    long long a[n];\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    n--;\n    for (int i = 0; i < n; i++) {\n      st[i][0] = abs(a[i + 1] - a[i]);\n    }\n    for (int i = 1; i < log2(n); i++) {\n      for (int j = 0; j < n - (1 << (i - 1)); j++) {\n        st[j][i] = gcd(st[j][i - 1], st[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n    int l = 1;\n    int r = n;\n    while (l < r) {\n      int m = (l + r + 1) / 2;\n      long long b[n - m + 1];\n      for (int i = 0; i < n - m + 1; i++) {\n        b[i] = q(i, m, n);\n      }\n      bool bo = 1;\n      for (int i = 0; i < n - m + 1; i++) {\n        if (b[i] != 1) bo = 0;\n      }\n      if (bo)\n        r = m - 1;\n      else\n        l = m;\n    }\n    bool bo = 1;\n    for (int i = 0; i < n; i++) {\n      if (st[i][0] > 1) bo = 0;\n    }\n    if (bo)\n      cout << \"1\\n\";\n    else\n      cout << l + 1 << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom math import gcd\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef discrete_binary_search(func, lo, hi):\n    \"\"\" Locate the first value x s.t. func(x) = True within [lo, hi] \"\"\"\n    while lo < hi:\n        mi = lo + (hi - lo) // 2\n        if func(mi):\n            hi = mi\n        else:\n            lo = mi + 1\n\n    return lo\n\n\nclass RangeQuery:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n\n    def __getitem__(self, idx):\n        return self._data[0][idx]\n\n\ndef main():\n    t = int(input())\n\n    for _ in range(t):\n        n = int(input())\n        a = [int(ai) for ai in input().split()]\n\n        b = [0] * (n - 1)\n        for i in range(n - 1):\n            b[i] = abs(a[i] - a[i + 1])\n\n        rgq = RangeQuery(b, gcd)\n\n        sol = 1\n        for start in range(n - 1):\n            end = discrete_binary_search(lambda x: rgq.query(start, x) == 1, start + 1, len(b))\n            end = min(end, len(b))\n            end -= 1 if rgq.query(start, end) == 1 else 0\n            sol = max(sol, (end - start) + 1)\n\n        print(sol)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 3,
            "solution": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom math import gcd\ndef lcm(a,b):\n  return a*b//gcd(a,b)\n\nclass SparseTable:\n    def func(self,a,b):\n        return gcd(a,b)\n    def __init__(self,arr):\n        n=len(arr)\n        max_k=(n-1).bit_length()-1\n        val=1 #set by func /ex. min->INF\n        table=[[val]*(max_k+1) for i in range(n)]\n        for i in range(n):\n            table[i][0]=arr[i]\n        for k in range(1,max_k+1):\n            k2=1<<(k-1)\n            k3=1<<k-1\n            for i in range(n-k3):\n                table[i][k]=self.func(table[i][k-1],table[k2+i][k-1])\n        self.table=table\n    def query(self,l,r):#[l,r)->[l,r]\n        d=r-l\n        if d==1:\n            return self.table[l][0]\n        k=(d-1).bit_length()-1\n        k2=1<<k\n        return self.func(self.table[l][k],self.table[r-k2][k])\nt=int(input())\nfor _ in range(t):\n  n=int(input())\n  a=list(map(int,input().split()))\n  if n==1:\n    print(1)\n    continue\n  if n==2:\n    if abs(a[1]-a[0])>=2:\n      print(2)\n    else:\n      print(1)\n    continue\n  d=[abs(a[i+1]-a[i]) for i in range(n-1)]\n  if all(d[i]==0 for i in range(n-1)):\n    print(n)\n    continue\n  for i in range(1,n-1):\n    if d[i]==0:\n      d[i]=d[i-1]\n  for i in range(1,n-1)[::-1]:\n    if d[i-1]==0:\n      d[i-1]=d[i]\n  sp=SparseTable(d)\n  l=0\n  r=n+1\n  while r-l>1:\n    mid=(l+r)//2\n    for i in range(len(d)-mid+1):\n      g=sp.query(i,i+mid)\n      if g!=1:\n        l=mid\n        break\n    else:\n      r=mid\n  print(l+1)"
        },
        {
            "language": 3,
            "solution": "from math import gcd\n\nfor _ in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    l=[abs(l[i]-l[i+1]) for i in range(n-1)]\n    n-=1\n    f=0\n    new=[0]*(n+1)\n    for i in range(2,n+1):\n        new[i]=new[i>>1]+1\n    temp=[]\n    for i in range(20):\n        temp.append([0]*(n+1))\n        \n    for i in range(new[n]+1):\n        j=0\n        keke=2**i\n        while j+keke<=n:\n            if keke==1:\n                lmao=l[j]\n                temp[i][j]=lmao\n            else:\n                hoho=j+(keke//2)\n                lmao=gcd(temp[i-1][hoho],temp[i-1][j])\n                temp[i][j]= lmao\n            j+=1\n    last,high,ans=1,n,0\n    while last<=high:\n        dekhle=0\n        m=(last+high)//2\n        for i in range(0,n-m+1):\n            a=i\n            b=i+m-1\n            p=new[b-a+1]\n            check=gcd(temp[p][b-(2**p)+1],temp[p][a])\n            if check>1:\n                dekhle=1\n                break\n        if dekhle:\n            last=m+1\n            ans=m+1\n        else:\n            high=m-1\n            \n    if ans<=1:\n        print(1)\n    else:\n        print(ans)"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nimport time\nimport math as mt\nimport pprint\nimport itertools as it\nimport operator as op\nimport bisect as bs\nimport functools as fn\nfrom collections import deque, defaultdict , OrderedDict, Counter, ChainMap\nmaxx, localsys, mod = 1 << 60, 0, int(1e9 + 7)\ndef nCr(n, r): return reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)\n\n\ndef ceil(n, x): return (n + x - 1) // x\n\n\nosi, oso = '/home/priyanshu/Documents/cp/input.txt', '/home/priyanshu/Documents/cp/output.txt'\nif os.path.exists(osi):\n    sys.stdin = open(osi, 'r')\n    sys.stdout = open(oso, 'w')\n\ninput = sys.stdin.readline\n\ndef maps(): return map(int, input().split())\n\n#   THINK ABOUT THE EDGE CASES ..........\n\n#   DON'T SUBMIT UNLESS YOU ARE ABSOLUTELY SURE !!!!!\nlog = [0]*200005\nlog[0] = 1\nfor i in range(2 , 200005):\n    log[i] = log[i//2] + 1\ngcd = mt.gcd\ndef query(l,r):\n    j = log[r-l+1]\n    return gcd(st[l][j] , st[r - (1 << j) + 1][j])\nfor _ in range(*maps()):\n    n, = maps()\n    a = [*maps()]\n    if n == 1 :\n        print(1)\n        continue\n    a = [abs(a[i] - a[i-1]) for i in range(1,n)]\n    k = mt.floor(mt.log2(n))\n    st = [[0 for _ in range(k+1)] for __ in range(n)]\n    for i in range(1,n):\n        st[i][0] = a[i-1]\n    for j in range(1,k+1):\n        i = 1\n        while i + (1<<j)<=n:\n            st[i][j] = gcd(st[i][j-1] , st[i+(1 <<(j-1))][j-1])\n            i+=1\n    ans =1\n    j = 1\n    for i in range(1,n):\n        while j <=i and query(j,i) ==1:\n            j+=1\n        ans = max(ans , i-j+2)\n    print(ans)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.io.*;\nimport java.math.*;\n\npublic class sparseTable {\n    static StringBuilder sb;\n    static dsu dsu;\n    static long fact[];\n    static int mod = (int) (1e9 + 7);\n\n    static void solve() {\n        int n = i();\n        long[] arr = readArrayL(n);\n        long[] diff = new long[n - 1];\n        if (n == 1) {\n            sb.append(\"1\\n\");\n            return;\n        }\n        for (int i = 1; i < arr.length; i++) {\n            diff[i - 1] = Math.abs(arr[i] - arr[i - 1]);\n        }\n\n        long[][] sparse = sparsetable(diff);\n\n        int i = 0;\n        int j = 0;\n        long ans = 0;\n        while (j < diff.length) {\n            int log = (int) (Math.log(j - i + 1) / Math.log(2));\n            long left = sparse[i][log];\n            long right = sparse[j - (1 << log) + 1][log];\n\n            long gcd = (gcd(left, right));\n            if (gcd > 1) {\n                ans = Math.max(ans, j - i + 1);\n                j++;\n            } else {\n                if (i < j) {\n                    i++;\n                } else {\n                    i++;\n                    j++;\n                }\n            }\n        }\n\n        sb.append(ans + 1 + \"\\n\");\n\n    }\n\n    static long[][] sparsetable(long[] arr) {\n        int n = arr.length;\n        int log = (int) (Math.log(n) / Math.log(2));\n        long[][] sparse = new long[arr.length][log + 1];\n        for (int i = 0; i < arr.length; i++) {\n            sparse[i][0] = arr[i];\n        }\n\n        for (int j = 1; j <= log; j++) {\n            for (int i = 0; i <= n - (1 << (j)); i++) {\n                sparse[i][j] = gcd(sparse[i][j - 1], sparse[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n\n        return sparse;\n    }\n\n    public static void main(String[] args) {\n        sb = new StringBuilder();\n        int test = i();\n        while (test-- > 0) {\n            solve();\n        }\n        System.out.println(sb);\n    }\n\n    /*\n     * fact=new long[(int)1e6+10]; fact[0]=fact[1]=1; for(int i=2;i<fact.length;i++)\n     * { fact[i]=((long)(i%mod)1L(long)(fact[i-1]%mod))%mod; }\n     */\n    // **************NCR%P******************\n    static long ncr(int n, int r) {\n        if (r > n)\n            return (long) 0;\n\n        long res = fact[n] % mod;\n        // System.out.println(res);\n        res = ((long) (res % mod) * (long) (p(fact[r], mod - 2) % mod)) % mod;\n        res = ((long) (res % mod) * (long) (p(fact[n - r], mod - 2) % mod)) % mod;\n        // System.out.println(res);\n        return res;\n\n    }\n\n    static long p(long x, long y)// POWER FXN //\n    {\n        if (y == 0)\n            return 1;\n\n        long res = 1;\n        while (y > 0) {\n            if (y % 2 == 1) {\n                res = (res * x) % mod;\n                y--;\n            }\n\n            x = (x * x) % mod;\n            y = y / 2;\n\n        }\n        return res;\n    }\n\n    // **************END******************\n\n    // *************Disjoint set\n    // union*********//\n    static class dsu {\n        int parent[];\n\n        dsu(int n) {\n            parent = new int[n];\n            for (int i = 0; i < n; i++)\n                parent[i] = -1;\n        }\n\n        int find(int a) {\n            if (parent[a] < 0)\n                return a;\n            else {\n                int x = find(parent[a]);\n                parent[a] = x;\n                return x;\n            }\n        }\n\n        void merge(int a, int b) {\n            a = find(a);\n            b = find(b);\n            if (a == b)\n                return;\n            parent[b] = a;\n        }\n    }\n\n    // **************PRIME FACTORIZE **********************************//\n    static TreeMap<Integer, Integer> prime(long n) {\n        TreeMap<Integer, Integer> h = new TreeMap<>();\n        long num = n;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (n % i == 0) {\n                int nt = 0;\n                while (n % i == 0) {\n                    n = n / i;\n                    nt++;\n                }\n                h.put(i, nt);\n            }\n        }\n        if (n != 1)\n            h.put((int) n, 1);\n        return h;\n\n    }\n\n    // ****CLASS PAIR ************************************************\n    static class Pair implements Comparable<Pair> {\n        int x;\n        long y;\n\n        Pair(int x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Pair o) {\n            return (int) (this.y - o.y);\n\n        }\n\n    }\n    // ****CLASS PAIR **************************************************\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int Int() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String String() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return String();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n    }\n\n    static InputReader in = new InputReader(System.in);\n    static OutputWriter out = new OutputWriter(System.out);\n\n    public static long[] sort(long[] a2) {\n        int n = a2.length;\n        ArrayList<Long> l = new ArrayList<>();\n        for (long i : a2)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < l.size(); i++)\n            a2[i] = l.get(i);\n        return a2;\n    }\n\n    public static long pow(long x, long y) {\n        long res = 1;\n        while (y > 0) {\n            if (y % 2 != 0) {\n                res = (res * x);// % modulus;\n                y--;\n\n            }\n            x = (x * x);// % modulus;\n            y = y / 2;\n        }\n        return res;\n    }\n\n    // GCD___+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n    public static long gcd(long x, long y) {\n        if (x == 0)\n            return y;\n        else\n            return gcd(y % x, x);\n    }\n    // ******LOWEST COMMON MULTIPLE\n    // *********************************************\n\n    public static long lcm(long x, long y) {\n        return (x * (y / gcd(x, y)));\n    }\n\n    // INPUT PATTERN********************************************************\n    public static int i() {\n        return in.Int();\n    }\n\n    public static long l() {\n        String s = in.String();\n        return Long.parseLong(s);\n    }\n\n    public static String s() {\n        return in.String();\n    }\n\n    public static int[] readArray(int n) {\n        int A[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            A[i] = i();\n        }\n        return A;\n    }\n\n    public static long[] readArrayL(int n) {\n        long A[] = new long[n];\n        for (int i = 0; i < n; i++) {\n            A[i] = l();\n        }\n        return A;\n    }\n\n}"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\n\nsys.setrecursionlimit(2*10**5+10)\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\ndebug = lambda x: sys.stderr.write(x+\"\\n\")\nwritef = lambda x: print(\"{:.12f}\".format(x))\n\nclass SG:\n    def __init__(self, n, v=None):\n        self._n = n\n        self.geta = 0\n        x = 0\n        while (1 << x) < n:\n            x += 1\n        self._log = x\n        self._size = 1 << self._log\n        self._d = [ninf] * (2 * self._size)\n        if v is not None:\n            for i in range(self._n):\n                self._d[self._size + i] = v[i]\n        for i in range(self._size - 1, 0, -1):\n            self._update(i)\n    def _update(self, k):\n        self._d[k] = op(self._d[2 * k], self._d[2 * k + 1])\n    def update(self, p, x):\n        assert 0 <= p < self._n\n#         x -= self.geta\n        p += self._size\n        self._d[p] = x\n        for i in range(1, self._log + 1):\n#             self._update(p >> i)\n            k = p>>i\n            self._d[k] = op(self._d[2 * k], self._d[2 * k + 1])\n    def get(self, p):\n        assert 0 <= p < self._n\n        return self._d[p + self._size] # + self.geta\n    def check(self):\n        return [self.get(p) for p in range(self._n)]\n    def query(self, left, right):\n        # [l,r)\u306e\u7dcf\u548c\n#         assert 0 <= left <= right <= self._n\n        sml = ninf\n        smr = ninf\n        left += self._size\n        right += self._size\n        while left < right:\n            if left & 1:\n                sml = op(sml, self._d[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                smr = op(self._d[right], smr)\n            left >>= 1\n            right >>= 1\n        return op(sml, smr) # + self.geta\n    def query_all(self):\n        return self._d[1] # + self.geta\n    def max_right(self, left, f):\n#         assert 0 <= left <= self._n\n#         assert f(ninf)\n        if left == self._n:\n            return self._n\n        left += self._size\n        sm = ninf\n        first = True\n        while first or (left & -left) != left:\n            first = False\n            while left % 2 == 0:\n                left >>= 1\n            if not f(op(sm, self._d[left])):\n                while left < self._size:\n                    left *= 2\n                    if f(op(sm, self._d[left])):\n                        sm = op(sm, self._d[left])\n                        left += 1\n                return left - self._size\n            sm = op(sm, self._d[left])\n            left += 1\n        return self._n\n    def min_left(self, right, f):\n#         assert 0 <= right <= self._n\n#         assert f(ninf)\n        if right == 0:\n            return 0\n        right += self._size\n        sm = ninf\n        first = True\n        while first or (right & -right) != right:\n            first = False\n            right -= 1\n            while right > 1 and right % 2:\n                right >>= 1\n            if not f(op(self._d[right], sm)):\n                while right < self._size:\n                    right = 2 * right + 1\n                    if f(op(self._d[right], sm)):\n                        sm = op(self._d[right], sm)\n                        right -= 1\n                return right + 1 - self._size\n            sm = op(self._d[right], sm)\n        return 0\n    \nfrom math import gcd\nop = gcd\nninf = 0\n\nt = int(input())\nans = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = [a[i]-a[i-1] for i in range(1,n)]\n    sg = SG(n-1, d)\n    j = 0\n    g = 0\n    res = 0\n    for i in range(n-1):\n        if j<i:\n            j = i\n            g = 0\n        else:\n            g = sg.query(i,j)\n        while j<n-1 and gcd(g, d[j])>1:\n            g = gcd(g, d[j])\n            j += 1\n        if g>1:\n            res = max(res, j-i)\n    ans.append(res+1)\nwrite(\"\\n\".join(map(str, ans)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pai = acos(-1.0);\nconst long long maxn = 1e6 + 10;\nconst long long mod = 998244353;\nconst double eps = 1e-9;\nconst long long N = 5e3 + 10;\ninline long long read() {\n  long long k = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) k = (k << 1) + (k << 3) + c - 48, c = getchar();\n  return k * f;\n}\nlong long k, n, m, a[maxn], dis[maxn];\nlong long gcd(long long a, long long b) {\n  if (!b)\n    return a;\n  else\n    return gcd(b, a % b);\n}\nstruct node {\n  long long l;\n  long long r;\n  long long data;\n} t[maxn << 2];\nvoid pushup(long long p) {\n  t[p].data = gcd(t[p << 1].data, t[p << 1 | 1].data);\n}\nvoid build(long long p, long long l, long long r) {\n  t[p].l = l, t[p].r = r;\n  if (l == r) {\n    t[p].data = dis[l];\n    return;\n  }\n  long long mid = l + r >> 1;\n  build(p << 1, l, mid);\n  build(p << 1 | 1, mid + 1, r);\n  pushup(p);\n}\nlong long ask(long long p, long long l, long long r) {\n  if (l <= t[p].l && t[p].r <= r) {\n    return t[p].data;\n  }\n  long long mid = t[p].l + t[p].r >> 1;\n  if (l > mid) return ask(p << 1 | 1, l, r);\n  if (r <= mid) return ask(p << 1, l, r);\n  return gcd(ask(p << 1, l, r), ask(p << 1 | 1, l, r));\n}\nsigned main() {\n  k = read();\n  while (k--) {\n    n = read();\n    for (long long i = 1; i <= n; i++) a[i] = read();\n    for (long long i = 1; i <= n - 1; i++) dis[i] = abs(a[i + 1] - a[i]);\n    if (n == 1)\n      puts(\"1\");\n    else {\n      build(1, 1, n - 1);\n      long long l = 1, ans = 0;\n      for (long long r = 1; r < n; r++) {\n        while (l <= r && ask(1, l, r) == 1) l++;\n        ans = max(ans, 1LL * (r - l + 2));\n      }\n      printf(\"%lld\\n\", ans);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict, Counter,deque\nfrom math import sqrt, log10, log, floor, factorial,gcd\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations,combinations\nimport sys, io, os\ninput = sys.stdin.readline\n# input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n# sys.setrecursionlimit(10000)\ninf = float('inf')\nmod = 10 ** 9 + 7\ndef get_list(): return [int(i) for i in input().split()]\ndef yn(a): print(\"YES\" if a else \"NO\")\nceil = lambda a, b: (a + b - 1) // b\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\nclass RangeQuery:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n\n    def __getitem__(self, idx):\n        return self._data[0][idx]\ndef fun(diff,k):\n    n=len(diff)\n    for i in range(n-k+1):\n        gcda=s.query(i,i+k)\n        if gcda==0:\n            return 0\n        if gcda>1:\n            return 0\n    return 1\ndef discrete_binary_search(func, lo, hi):\n    \"\"\" Locate the first value x s.t. func(x) = True within [lo, hi] \"\"\"\n    while lo < hi:\n        mi = lo + (hi - lo) // 2\n        # print(mi)\n        if func(diff,mi):\n            hi = mi\n        else:\n            lo = mi + 1\n\n    return lo\nt=int(input())\nfor i in range(t):\n    n=int(input())\n    l=[int(i) for i in input().split()]\n    if n==1:\n        print(1)\n        continue\n    diff=[abs(l[i]-l[i-1]) for i in range(1,n)]\n    s=RangeQuery(diff,gcd)\n    maxa=0\n    low=1\n    high=n\n    ans=discrete_binary_search(fun,low,high)\n    print(ans)\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\nimport static java.lang.System.*;\n\npublic class Round736D {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(in);\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            long[] a = new long[n];\n            long[] b = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextLong();\n            }\n            for (int i = 1; i < n; i++) {\n                b[i] = Math.abs(a[i] - a[i - 1]);\n            }\n            long ans = 1;\n            long cur = 1;\n            long gcd = 0;\n            for (int i = 1; i < n; i++) {\n                gcd = gcd(gcd, b[i]);\n                if (gcd == 1) {\n                    gcd = 0;\n                    cur = 1;\n                    for (int j = i; j >= 1; j--) {\n                        long tmp = gcd(gcd, b[j]);\n                        if (tmp == 1) {\n                            break;\n                        } else {\n                            gcd = tmp;\n                            cur++;\n                        }\n                    }\n                } else {\n                    cur++;\n                    ans = Math.max(ans, cur);\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n\n    private static long gcd(long a, long b) {\n        while (b != 0) {\n            long tmp = a % b;\n            a = b;\n            b = tmp;\n        }\n        return a;\n    }\n}"
        }
    ]
}