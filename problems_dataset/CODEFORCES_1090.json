{
    "name": "1090_C. New Year Presents",
    "source": "CODEFORCES",
    "description": "Santa has prepared boxes with presents for n kids, one box for each kid. There are m kinds of presents: balloons, sweets, chocolate bars, toy cars... A child would be disappointed to receive two presents of the same kind, so all kinds of presents in one box are distinct.\n\nHaving packed all the presents, Santa realized that different boxes can contain different number of presents. It would be unfair to the children, so he decided to move some presents between boxes, and make their sizes similar. After all movements, the difference between the maximal and the minimal number of presents in a box must be as small as possible. All presents in each box should still be distinct. Santa wants to finish the job as fast as possible, so he wants to minimize the number of movements required to complete the task.\n\nGiven the sets of presents in each box, find the shortest sequence of movements of presents between boxes that minimizes the difference of sizes of the smallest and the largest box, and keeps all presents in each box distinct.\n\nInput\n\nThe first line of input contains two integers n, m (1 \u2264 n, m \u2264 100\\ 000), the number of boxes and the number of kinds of the presents. Denote presents with integers from 1 to m.\n\nEach of the following n lines contains the description of one box. It begins with an integer s_i (s_i \u2265 0), the number of presents in the box, s_i distinct integers between 1 and m follow, denoting the kinds of presents in that box.\n\nThe total number of presents in all boxes does not exceed 500 000.\n\nOutput\n\nPrint one integer k at the first line of output, the number of movements in the shortest sequence that makes the sizes of the boxes differ by at most one. Then print k lines that describe movements in the same order in which they should be performed. Each movement is described by three integers from_i, to_i, kind_i. It means that the present of kind kind_i is moved from the box with number from_i to the box with number to_i. Boxes are numbered from one in the order they are given in the input.\n\nAt the moment when the movement is performed the present with kind kind_i must be present in the box with number from_i. After performing all moves each box must not contain two presents of the same kind.\n\nIf there are several optimal solutions, output any of them.\n\nExample\n\nInput\n\n\n3 5\n5 1 2 3 4 5\n2 1 2\n2 3 4\n\n\nOutput\n\n\n2\n1 3 5\n1 2 3",
    "difficulty": "C",
    "tags": [
        "constructive algorithms",
        "data structures"
    ],
    "rating": 2400,
    "public_test": [
        {
            "input": "3 5\n5 1 2 3 4 5\n2 1 2\n2 3 4\n",
            "output": "2\n1 2 3\n1 3 1\n"
        }
    ],
    "generated_test": [
        {
            "input": "1 2\n0\n",
            "output": "0\n"
        },
        {
            "input": "3 7\n6 3 5 1 7 6 4\n0 1\n3 1 2 6\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 4\n"
        },
        {
            "input": "3 7\n4 4 10 7 2\n0\n16 12 14 8 10 15 13 17 7 4 6 16 19 18 11 2 5\n",
            "output": "9\n3 2 2\n3 2 4\n3 2 5\n3 2 6\n3 2 7\n3 2 8\n3 1 11\n3 1 12\n3 1 13\n"
        },
        {
            "input": "3 7\n6 3 5 1 7 6 4\n0 1\n4 1 2 6\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 5\n"
        },
        {
            "input": "3 7\n6 3 5 1 7 6 4\n1 1\n1 1 2 6\n",
            "output": "3\n1 2 3\n1 3 4\n1 3 5\n"
        },
        {
            "input": "3 7\n6 3 5 1 7 6 4\n0 0\n3 1 0 12\n",
            "output": "4\n1 2 1\n1 2 3\n1 3 4\n1 3 5\n"
        },
        {
            "input": "3 7\n6 3 8 1 14 6 4\n0 1\n4 1 1 12\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 6\n"
        },
        {
            "input": "3 7\n6 3 8 1 14 6 4\n0 0\n4 1 1 12\n",
            "output": "4\n1 2 1\n1 2 3\n1 3 4\n1 3 6\n"
        },
        {
            "input": "4 50\n9 26 13 12 16 39 37 42 11 18\n42 4 39 19 29 44 30 5 43 28 38 22 2 33 9 50 13 25 37 45 32 27 1 48 35 11 36 42 26 91 40 8 34 7 12 23 31 10 6 18 46 41 17\n28 22 30 48 7 23 42 37 47 41 50 14 33 13 27 18 2 15 12 16 21 32 6 25 28 4 49 45 1\n21 44 40 32 21 19 10 35 36 7 29 27 46 38 2 9 41 24 34 26 15 37\n",
            "output": "20\n2 1 1\n2 1 2\n2 1 4\n2 1 5\n2 1 6\n2 1 7\n2 1 8\n2 1 9\n2 1 10\n2 1 17\n2 1 19\n2 1 22\n2 1 23\n2 1 25\n2 1 27\n2 1 28\n2 4 11\n3 4 1\n3 4 4\n3 4 6\n"
        },
        {
            "input": "3 0\n0\n0\n5 2 1 5 3 4\n",
            "output": "3\n3 1 1\n3 2 2\n3 2 3\n"
        },
        {
            "input": "3 5\n5 1 2 3 4 5\n2 1 2\n2 2 4\n",
            "output": "2\n1 2 3\n1 3 1\n"
        },
        {
            "input": "3 7\n6 3 5 1 7 6 4\n1 1\n0 1 2 6\n",
            "output": "3\n1 3 1\n1 3 3\n1 2 4\n"
        },
        {
            "input": "2 2\n0\n1 1\n",
            "output": "0\n"
        },
        {
            "input": "3 7\n6 3 5 1 7 6 4\n0 2\n4 1 2 6\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 5\n"
        },
        {
            "input": "1 1\n0 1\n",
            "output": "0\n"
        },
        {
            "input": "2 2\n0\n1 2\n",
            "output": "0\n"
        },
        {
            "input": "100 1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1 1\n0\n0\n1 1\n1 1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1 1\n0\n0\n0\n0\n0\n0\n0\n1 1\n0\n0\n0\n1 1\n0\n0\n0\n0\n1 1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1 1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1 1\n0 1\n",
            "output": "0\n"
        },
        {
            "input": "2 0\n0\n1 1\n",
            "output": "0\n"
        },
        {
            "input": "3 7\n6 3 5 1 7 6 4\n0 1\n3 1 2 12\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 4\n"
        },
        {
            "input": "3 7\n6 3 5 1 7 6 4\n0 1\n4 1 1 6\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 5\n"
        },
        {
            "input": "3 7\n6 3 5 1 9 6 4\n0 2\n4 1 2 6\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 5\n"
        },
        {
            "input": "1 1\n0 2\n",
            "output": "0\n"
        },
        {
            "input": "2 4\n0\n1 1\n",
            "output": "0\n"
        },
        {
            "input": "3 7\n6 3 5 1 7 6 4\n0 1\n3 1 0 12\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 4\n"
        },
        {
            "input": "3 7\n6 3 5 1 7 6 4\n0 1\n4 1 1 12\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 5\n"
        },
        {
            "input": "3 7\n6 3 5 1 9 6 4\n0 2\n3 1 2 6\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 4\n"
        },
        {
            "input": "3 7\n6 3 5 1 7 6 4\n0 2\n3 1 0 12\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 4\n"
        },
        {
            "input": "3 7\n6 3 5 1 14 6 4\n0 1\n4 1 1 12\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 5\n"
        },
        {
            "input": "3 7\n6 3 5 1 9 6 4\n0 2\n3 1 1 6\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 4\n"
        },
        {
            "input": "1 1\n1 2\n",
            "output": "0\n"
        },
        {
            "input": "1 11\n10 6 15 11 5 8 2 1 3 4 7\n",
            "output": "0\n"
        },
        {
            "input": "2 3\n0\n1 1\n",
            "output": "0\n"
        },
        {
            "input": "3 7\n6 3 10 1 7 6 4\n0 1\n4 1 2 6\n",
            "output": "3\n1 2 1\n1 2 3\n1 3 6\n"
        },
        {
            "input": "1 2\n0 1\n",
            "output": "0\n"
        },
        {
            "input": "2 2\n0\n1 4\n",
            "output": "0\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\npair<int, int> qq[maxn];\nint q[maxn], s, o[maxn];\nset<int> w[maxn], z;\nvector<pair<pair<int, int>, int> > r;\nint main() {\n  int n, m, a, b, qa, qb;\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> q[i];\n    s += q[i];\n    qq[i] = make_pair(q[i], i);\n    for (int j = 0; j < q[i]; j++) {\n      int t;\n      cin >> t;\n      t--;\n      w[t].insert(i);\n    }\n  }\n  a = s / n;\n  b = a + 1;\n  qb = s % n;\n  qa = n - qb;\n  sort(qq, qq + n);\n  for (int i = 0; i < qa; i++) o[qq[i].second] = a;\n  for (int i = qa; i < n; i++) o[qq[i].second] = b;\n  for (int i = 0; i < n; i++)\n    if (q[i] < o[i]) z.insert(i);\n  for (int i = 0; i < m; i++) {\n    int k = 0;\n    for (int t : w[i]) {\n      if (q[t] > o[t]) {\n        bool flag = false;\n        while (1) {\n          auto it = z.lower_bound(k);\n          if (it == z.end()) {\n            flag = true;\n            break;\n          }\n          k = *it;\n          assert(q[k] < o[k]);\n          if (w[i].count(k)) {\n            k++;\n            continue;\n          }\n          r.push_back(make_pair(make_pair(t, k), i));\n          q[t]--;\n          q[k]++;\n          if (q[k] == o[k]) z.erase(k);\n          k++;\n          break;\n        }\n        if (flag) break;\n      }\n    }\n  }\n  cout << r.size() << endl;\n  for (int i = 0; i < r.size(); i++) {\n    cout << r[i].first.first + 1 << \" \" << r[i].first.second + 1 << \" \"\n         << r[i].second + 1 << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class t>\ninline void read(t &s) {\n  s = 0;\n  register int f = 1;\n  register char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) s = (s << 3) + (s << 1) + (c ^ 48), c = getchar();\n  s *= f;\n  return;\n}\ntemplate <class t, class... A>\ninline void read(t &x, A &...a) {\n  read(x);\n  read(a...);\n}\ntemplate <class t>\ninline void write(t x) {\n  if (x < 0) putchar('-'), x = -x;\n  int buf[21], top = 0;\n  while (x) buf[++top] = x % 10, x /= 10;\n  if (!top) buf[++top] = 0;\n  while (top) putchar(buf[top--] ^ '0');\n  return;\n}\ninline void setIn(std::string s) {\n  freopen(s.c_str(), \"r\", stdin);\n  return;\n}\ninline void setOut(std::string s) {\n  freopen(s.c_str(), \"w\", stdout);\n  return;\n}\ninline void setIO(std::string s = \"\") {\n  setIn(s + \".in\");\n  setOut(s + \".out\");\n  return;\n}\ntemplate <class t>\ninline bool checkmin(t &x, t y) {\n  if (x > y) {\n    x = y;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class t>\ninline bool checkmax(t &x, t y) {\n  if (x < y) {\n    x = y;\n    return 1;\n  }\n  return 0;\n}\ninline int lowbit(int x) { return x & (-x); }\nconst int MaxN = 1e5 + 50;\nstd::unordered_set<int> S[MaxN], d;\nint p[MaxN], to[MaxN], n, K;\nstruct Answer {\n  int x, y, z;\n  Answer() { x = y = z = 0; }\n  Answer(int a, int b, int c) { x = a, y = b, z = c; }\n};\nstd::vector<Answer> ans;\ninline void go(int x, int y, int z) {\n  assert(S[p[x]].count(z)), assert(!S[p[y]].count(z));\n  S[p[x]].erase(z), S[p[y]].insert(z);\n  ans.push_back(Answer(p[x], p[y], z));\n}\nsigned main(void) {\n  read(n, K);\n  register int all = 0;\n  for (int i = 1; i <= n; ++i) {\n    int x, y;\n    read(x);\n    all += x, p[i] = i;\n    while (x--) read(y), S[i].insert(y);\n  }\n  std::sort(p + 1, p + n + 1,\n            [&](int a, int b) { return S[a].size() > S[b].size(); });\n  for (int i = 1; i <= all; ++i) ++to[(i - 1) % n + 1];\n  register int L = 1, R = n;\n  if (L < R) {\n    d = S[p[L]];\n    for (auto i : S[p[R]])\n      if (d.count(i)) d.erase(i);\n  }\n  while (L < R) {\n    while ((int)S[p[L]].size() == to[L]) {\n      if (++L == R) break;\n      d = S[p[L]];\n      for (auto i : S[p[R]])\n        if (d.count(i)) d.erase(i);\n    }\n    while ((int)S[p[R]].size() == to[R]) {\n      for (auto i : S[p[R]])\n        if (S[p[L]].count(i) && !d.count(i)) d.insert(i);\n      if (--R == L) break;\n      for (auto i : S[p[R]])\n        if (d.count(i)) d.erase(i);\n    }\n    if (L >= R) break;\n    register int x = *d.begin();\n    go(L, R, x);\n    d.erase(d.begin());\n  }\n  write((int)ans.size()), std::puts(\"\");\n  for (auto i : ans)\n    write(i.x), std::putchar(32), write(i.y), std::putchar(32), write(i.z),\n        std::puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100100;\nint n, pos[N], f[N], m, sz[N];\nset<int> mp1[N];\nbool cmp(int fi, int se) { return sz[fi] > sz[se]; }\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> sz[i];\n    sum += sz[i];\n    for (int j = 1; j <= sz[i]; j++) {\n      int x;\n      cin >> x;\n      mp1[i].insert(x);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    pos[i] = i;\n    f[i] = sum / n;\n    if (i <= sum % n) ++f[i];\n  }\n  sort(pos + 1, pos + n + 1, cmp);\n  int l = 1, r = n;\n  vector<pair<pair<int, int>, int> > ansvec;\n  while (l < r) {\n    while (1) {\n      if (sz[pos[l]] == f[l]) {\n        ++l;\n        break;\n      }\n      if (sz[pos[r]] == f[r]) {\n        --r;\n        break;\n      }\n      for (auto it = mp1[pos[l]].begin(); it != mp1[pos[l]].end(); it++) {\n        int x = *it;\n        if (mp1[pos[r]].find(x) != mp1[pos[r]].end()) continue;\n        ++it;\n        --sz[pos[l]];\n        ++sz[pos[r]];\n        mp1[pos[l]].erase(x);\n        mp1[pos[r]].insert(x);\n        ansvec.push_back({{pos[l], pos[r]}, x});\n        if (sz[pos[l]] == f[l] || sz[pos[r]] == f[r]) break;\n      }\n    }\n  }\n  cout << ansvec.size() << \"\\n\";\n  for (auto it : ansvec)\n    cout << it.first.first << ' ' << it.first.second << ' ' << it.second\n         << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m, s = 0;\n  cin >> n >> m;\n  vector<pair<pair<int, map<int, bool>>, int>> v(n);\n  vector<map<int, bool>::iterator> pr;\n  vector<vector<int>> ans;\n  for (int i = 0; i < n; ++i) {\n    int s1;\n    cin >> s1;\n    v[i].first.first = s1;\n    v[i].second = i;\n    s += s1;\n    for (int j = 0; j < s1; ++j) {\n      int a;\n      cin >> a;\n      v[i].first.second[a] = true;\n    }\n  }\n  sort(v.begin(), v.end(),\n       [](const pair<pair<int, map<int, bool>>, int> p1,\n          const pair<pair<int, map<int, bool>>, int> p2) {\n         return p1.first.first > p2.first.first;\n       });\n  int l = 0, r = n - 1;\n  while (r != l) {\n    if (v[l].first.first == s / n + (l < s % n)) {\n      ++l;\n      continue;\n    }\n    if (v[r].first.first == s / n + (r < s % n)) {\n      --r;\n      continue;\n    }\n    for (auto p = v[l].first.second.begin(); p != v[l].first.second.end();\n         ++p) {\n      int i = p->first;\n      if (v[l].first.first == s / n + (l < s % n)) {\n        for (auto p : pr) v[l].first.second.erase(p);\n        pr.clear();\n        ++l;\n        break;\n      }\n      if (v[r].first.first == s / n + (r < s % n)) {\n        for (auto p : pr) v[l].first.second.erase(p);\n        pr.clear();\n        --r;\n        break;\n      }\n      if (v[r].first.second[i] == false) {\n        --v[l].first.first;\n        ++v[r].first.first;\n        pr.push_back(p);\n        v[r].first.second[i] = true;\n        ans.push_back({v[l].second + 1, v[r].second + 1, i});\n      }\n    }\n  }\n  cout << ans.size() << '\\n';\n  for (auto i : ans) {\n    for (int j : i) cout << j << ' ';\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC diagnostic ignored \"-Wmissing-declarations\"\ninline int safe_mul(const int x, const int y)\n    __attribute__((warn_unused_result));\nint const maxn = 100003;\nvector<int> used[maxn];\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<int, int>> nums;\n  for (int i = 0; i < n; ++i) {\n    int s;\n    cin >> s;\n    for (int j = 0; j < s; ++j) {\n      int x;\n      cin >> x;\n      used[i].push_back(x);\n    }\n    nums.emplace_back(s, i);\n  }\n  sort(nums.begin(), nums.end());\n  long long acnt = 0;\n  for (const auto& p : nums) acnt += p.first;\n  vector<int> need(n);\n  for (int i = 0; i < n; ++i) {\n    need[i] = acnt / n + (n - i <= acnt % n);\n  }\n  int l = 0;\n  int r = n - 1;\n  vector<tuple<int, int, int>> result;\n  bitset<maxn + 100> lb;\n  for (const int x : used[nums[l].second]) lb.set(x);\n  bitset<maxn + 100> rb;\n  for (const int x : used[nums[r].second]) rb.set(x);\n  for (;;) {\n    bool lsh = false;\n    while (l < r && nums[l].first == need[l]) {\n      ++l;\n      lsh = true;\n    }\n    bool rsh = false;\n    while (r > l && nums[r].first == need[r]) {\n      --r;\n      rsh = true;\n    }\n    if (l >= r) break;\n    if (lsh) {\n      lb.reset();\n      for (const int x : used[nums[l].second]) lb.set(x);\n    }\n    if (rsh) {\n      rb.reset();\n      for (const int x : used[nums[r].second]) rb.set(x);\n    }\n    auto uni = rb & ~lb;\n    uint64_t* ptr = reinterpret_cast<uint64_t*>(&uni);\n    bool ex = false;\n    for (int i = 0; i <= maxn / 64 && !ex; ++i) {\n      if (*ptr) {\n        for (int j = 0; j < 64; ++j)\n          if ((*ptr) & (1uLL << j)) {\n            int idx = i * 64 + j;\n            result.emplace_back(nums[r].second + 1, nums[l].second + 1, idx);\n            lb[idx] = 1;\n            rb[idx] = 0;\n            --nums[r].first;\n            ++nums[l].first;\n            if (nums[l].first == need[l] || nums[r].first == need[r]) {\n              ex = true;\n              break;\n            }\n          }\n      }\n      ++ptr;\n    }\n  }\n  cout << result.size() << endl;\n  for (const auto& t : result)\n    cout << get<0>(t) << ' ' << get<1>(t) << ' ' << get<2>(t) << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool comp(pair<set<int>, int> &a, pair<set<int>, int> &b) {\n  return a.first.size() < b.first.size();\n}\nint a, cnta;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<set<int>, int> > v(n);\n  int tot = 0;\n  for (int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    tot += k;\n    v[i].second = i;\n    for (int j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      v[i].first.insert(c);\n    }\n  }\n  a = tot / n;\n  cnta = n - tot % n;\n  sort(v.begin(), v.end(), comp);\n  vector<pair<set<int>, int> > gives, takes;\n  vector<int> sh(n, a);\n  for (int i = cnta; i < n; ++i) {\n    sh[v[i].second] = a + 1;\n  }\n  int mvs = 0;\n  set<int> still_take;\n  for (int i = 0; i < n; ++i) {\n    if (v[i].first.size() < sh[v[i].second]) {\n      mvs += sh[v[i].second] - v[i].first.size();\n      takes.push_back(v[i]);\n      still_take.insert(takes.size() - 1);\n    } else if (v[i].first.size() > sh[v[i].second]) {\n      gives.push_back(v[i]);\n    }\n  }\n  map<int, int> dic;\n  cout << mvs << endl;\n  for (pair<set<int>, int> x : gives) {\n    int cnt = 0;\n    for (auto v : x.first) {\n      if (x.first.size() - cnt == sh[x.second]) break;\n      while (dic[v] < takes.size()) {\n        if (still_take.lower_bound(dic[v]) == still_take.end())\n          ++dic[v];\n        else {\n          int tmp = *(still_take.lower_bound(dic[v]));\n          dic[v] = tmp;\n          if (takes[dic[v]].first.count(v))\n            ++dic[v];\n          else\n            break;\n        }\n      }\n      if (dic[v] != takes.size()) {\n        ++cnt;\n        cout << x.second + 1 << \" \" << takes[dic[v]].second + 1 << \" \" << v\n             << \"\\n\";\n        takes[dic[v]].first.insert(v);\n        if (takes[dic[v]].first.size() == sh[takes[dic[v]].second]) {\n          still_take.erase(dic[v]);\n        }\n        dic[v]++;\n      }\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class c>\nstruct rge {\n  c b, e;\n};\ntemplate <class c>\nrge<c> range(c i, c j) {\n  return rge<c>{i, j};\n}\ntemplate <class c>\nauto dud(c *x) -> decltype(cerr << *x, 0);\ntemplate <class c>\nchar dud(...);\nstruct debug {\n  ~debug() { cerr << endl; }\n  template <class c>\n  typename enable_if<sizeof dud<c>(0) != 1, debug &>::type operator<<(c i) {\n    cerr << boolalpha << i;\n    return *this;\n  }\n  template <class c>\n  typename enable_if<sizeof dud<c>(0) == 1, debug &>::type operator<<(c i) {\n    return *this << range(begin(i), end(i));\n  }\n  template <class c, class b>\n  debug &operator<<(pair<b, c> d) {\n    return *this << \"(\" << d.first << \", \" << d.second << \")\";\n  }\n  template <class c>\n  debug &operator<<(rge<c> d) {\n    *this << \"[\";\n    for (auto it = d.b; it != d.e; ++it) *this << \", \" + 2 * (it == d.b) << *it;\n    return *this << \"]\";\n  }\n};\nconst long double eps = 1e-9;\nconst long long inf = 1e18;\nauto rnd = bind(uniform_int_distribution<int>(0, 63), mt19937(time(0)));\nauto rndd = bind(uniform_int_distribution<int>(55, 55), mt19937(time(0)));\nconst int N = 1e5 + 1;\nset<long long> have_lower[N];\nset<long long> have_greater[N];\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  ;\n  long long n, m;\n  cin >> n >> m;\n  long long l, r;\n  vector<long long> second(n);\n  vector<vector<long long>> a(n, vector<long long>());\n  long long sm = 0;\n  for (long long i = 0; i < n; i++) {\n    cin >> second[i];\n    a[i].resize(second[i]);\n    for (long long j = 0; j < second[i]; j++) {\n      cin >> a[i][j];\n      --a[i][j];\n    }\n    sm += second[i];\n  }\n  l = sm / n, r = ceil((long double)sm / n);\n  long long cll = n - (sm % n);\n  long long clr = sm % n;\n  set<long long> blya_upd;\n  for (long long i = 0; i < n; i++) {\n    if (second[i] == l) {\n      if (cll != 0) {\n        cll--;\n        continue;\n      }\n    }\n    if (second[i] == r) {\n      if (clr != 0) {\n        clr--;\n        continue;\n      }\n    }\n    if (second[i] >= r) {\n      for (auto &z : a[i]) have_greater[z].insert(i);\n    } else {\n      for (auto &z : a[i]) {\n        have_lower[z].insert(i);\n      }\n      blya_upd.insert(i);\n    }\n  }\n  vector<pair<long long, pair<long long, long long>>> ans;\n  set<long long> pob;\n  for (long long i = 0; i < m; i++) {\n    pob.clear();\n    for (auto &z : have_lower[i]) {\n      blya_upd.erase(z);\n    }\n    while ((long long)blya_upd.size() && (long long)have_greater[i].size()) {\n      long long from = *have_greater[i].rbegin();\n      long long to = *blya_upd.begin();\n      second[from]--;\n      second[to]++;\n      if (second[to] == l && cll) {\n        for (auto &z : a[to]) {\n          have_lower[z].erase(to);\n        }\n        cll--;\n      } else if (second[to] == r) {\n        assert(clr);\n        clr--;\n        for (auto &z : a[to]) {\n          have_lower[z].erase(to);\n        }\n      } else {\n        pob.insert(to);\n      }\n      if (second[from] == r && clr) {\n        for (auto &z : a[from]) {\n          have_greater[z].erase(from);\n        }\n        clr--;\n      } else if (second[from] == l) {\n        assert(cll);\n        cll--;\n        for (auto &z : a[from]) {\n          have_greater[z].erase(from);\n        }\n      }\n      ans.push_back({i, {from, to}});\n      have_greater[i].erase(from);\n      blya_upd.erase(to);\n    }\n    for (auto &z : pob) blya_upd.insert(z);\n    for (auto &z : have_lower[i]) {\n      blya_upd.insert(z);\n    }\n  }\n  cout << (long long)ans.size() << '\\n';\n  for (auto &z : ans) {\n    cout << z.second.first + 1 << ' ' << z.second.second + 1 << ' '\n         << z.first + 1 << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n  int num, tar, id;\n};\nstruct Node2 {\n  int from, to, val;\n};\nconst int N = 1e5 + 10;\nset<int> s[N];\nNode a[N];\nNode2 ans[500010];\nint main() {\n  int n, m, sum, p1, p2, tot;\n  scanf(\"%d %d\", &n, &m);\n  sum = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i].num);\n    for (int j = 1, x; j <= a[i].num; j++) {\n      scanf(\"%d\", &x);\n      s[i].insert(x);\n    }\n    a[i].id = i;\n    sum += a[i].num;\n  }\n  sort(a + 1, a + n + 1, [&](Node x, Node y) { return x.num < y.num; });\n  for (int i = 1; i <= n; i++) a[i].tar = (sum + i - 1) / n;\n  p1 = 1;\n  p2 = n;\n  tot = 0;\n  while (true) {\n    while (p1 < p2 && a[p1].num == a[p1].tar) p1++;\n    if (p1 >= p2) break;\n    while (p2 > p1 && a[p2].num == a[p2].tar) p2--;\n    if (p1 >= p2) break;\n    auto it2 = s[a[p2].id].begin();\n    while (a[p1].num < a[p1].tar && a[p2].num > a[p2].tar) {\n      auto it = s[a[p1].id].lower_bound(*it2);\n      if (it == s[a[p1].id].end() || (*it2) != (*it)) {\n        ans[++tot] = (Node2){a[p2].id, a[p1].id, *it2};\n        s[a[p1].id].insert(*it2);\n        it2 = s[a[p2].id].erase(it2);\n        a[p1].num++;\n        a[p2].num--;\n      } else\n        it2++;\n    }\n  }\n  printf(\"%d\\n\", tot);\n  for (int i = 1; i <= tot; i++)\n    printf(\"%d %d %d\\n\", ans[i].from, ans[i].to, ans[i].val);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nconst int N = (int)3e5;\nint sz[N];\nset<int> pr[N];\nvector<int> lst[N];\nstruct shit {\n  int from, to, kind;\n  shit(int from, int to, int kind) : from(from), to(to), kind(kind) {}\n};\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> n >> m;\n  int s = 0;\n  for (int i = 1; i <= n; i++) {\n    int k, x;\n    cin >> k;\n    s += k;\n    for (int j = 1; j <= k; j++) {\n      cin >> x;\n      sz[i]++;\n      pr[i].insert(x);\n      lst[x].push_back(i);\n    }\n  }\n  int x = s / n;\n  int y = s / n;\n  if (s % n != 0) y++;\n  vector<shit> ans;\n  set<int> st, eq;\n  for (int i = 1; i <= n; i++) {\n    if (sz[i] < x) {\n      st.insert(i);\n    }\n    if (sz[i] == x) {\n      eq.insert(i);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    vector<int> bs, be;\n    for (auto cur : lst[i]) {\n      if (st.find(cur) != st.end()) {\n        st.erase(cur);\n        bs.push_back(cur);\n      }\n    }\n    for (auto cur : lst[i]) {\n      if (sz[cur] > y) {\n        if (!st.empty()) {\n          auto it = st.begin();\n          ans.emplace_back(shit(cur, *it, i));\n          sz[*it]++;\n          sz[cur]--;\n          if (sz[*it] == x) {\n            eq.insert(*it);\n            st.erase(it);\n          } else {\n            bs.push_back(*it);\n            st.erase(it);\n          }\n        }\n      }\n    }\n    for (auto cur : bs) {\n      st.insert(cur);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    lst[i].clear();\n  }\n  for (auto tmp : ans) {\n    pr[tmp.from].erase(tmp.kind);\n    pr[tmp.to].insert(tmp.kind);\n  }\n  int l = ans.size();\n  for (int i = 1; i <= n; i++) {\n    for (auto j : pr[i]) {\n      lst[j].push_back(i);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    vector<int> bs, be;\n    for (auto cur : lst[i]) {\n      if (eq.find(cur) != eq.end()) {\n        eq.erase(cur);\n        be.push_back(cur);\n      }\n    }\n    for (auto cur : lst[i]) {\n      if (sz[cur] > y) {\n        if (!eq.empty() && x + 1 < sz[cur]) {\n          auto it = eq.begin();\n          ans.emplace_back(shit(cur, *it, i));\n          sz[cur]--;\n          sz[*it]++;\n          eq.erase(it);\n        }\n      }\n    }\n    for (auto cur : be) {\n      eq.insert(cur);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    lst[i].clear();\n  }\n  for (int i = l; i < ans.size(); i++) {\n    auto tmp = ans[i];\n    pr[tmp.from].erase(tmp.kind);\n    pr[tmp.to].insert(tmp.kind);\n  }\n  for (int i = 1; i <= n; i++) {\n    for (auto j : pr[i]) {\n      lst[j].push_back(i);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    vector<int> bs, be;\n    for (auto cur : lst[i]) {\n      if (st.find(cur) != st.end()) {\n        st.erase(cur);\n        bs.push_back(cur);\n      }\n    }\n    for (auto cur : lst[i]) {\n      if (sz[cur] == y) {\n        if (!st.empty()) {\n          auto it = st.begin();\n          ans.emplace_back(shit(cur, *it, i));\n          sz[*it]++;\n          sz[cur]--;\n          if (sz[*it] == x) {\n            st.erase(it);\n          } else {\n            bs.push_back(*it);\n            st.erase(it);\n          }\n        }\n      }\n    }\n    for (auto cur : bs) {\n      st.insert(cur);\n    }\n  }\n  cout << ans.size() << \"\\n\";\n  for (auto tmp : ans) {\n    cout << tmp.from << \" \" << tmp.to << \" \" << tmp.kind << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 1;\nstruct segTree {\n  segTree *left = nullptr, *right = nullptr;\n  long long val = 0;\n};\nlong long v(segTree* cur) { return (cur == nullptr) ? 0 : cur->val; }\nsegTree* righ(segTree* cur) { return (cur == nullptr) ? nullptr : cur->right; }\nsegTree* lef(segTree* cur) { return (cur == nullptr) ? nullptr : cur->left; }\nlong long m;\nvoid update(long long p, long long val, segTree* cur, long long ll = 1,\n            long long rr = m) {\n  if (ll == rr) {\n    cur->val = val;\n    return;\n  }\n  long long mid = (ll + rr) / 2;\n  if (p <= mid) {\n    if (cur->left == nullptr) cur->left = new segTree();\n    update(p, val, cur->left, ll, mid);\n  } else {\n    if (cur->right == nullptr) cur->right = new segTree();\n    update(p, val, cur->right, mid + 1, rr);\n  }\n  cur->val = v(cur->left) + v(cur->right);\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  srand(time(0));\n  long long n;\n  cin >> n >> m;\n  segTree* s[n];\n  for (long long i = 0; i < n; i++) s[i] = new segTree();\n  long long sum = 0;\n  priority_queue<pair<long long, long long>> mx, mn;\n  for (long long i = 0; i < n; i++) {\n    long long q;\n    cin >> q;\n    sum += q;\n    mx.push({q, i});\n    mn.push({-q, i});\n    for (long long j = 0; j < q; j++) {\n      long long k;\n      cin >> k;\n      update(k, 1, s[i]);\n    }\n  }\n  long long lim = sum % n != 0;\n  vector<vector<long long>> ans;\n  while (mx.top().first + mn.top().first > lim) {\n    long long sf = mx.top().first, ss = -mn.top().first;\n    long long f = mx.top().second, u = mn.top().second;\n    mx.pop();\n    mn.pop();\n    long long l = 1, r = m;\n    segTree *c1 = s[f], *c2 = s[u];\n    while (l != r) {\n      long long mid = (l + r) / 2;\n      if (v(righ(c1)) > v(righ(c2))) {\n        c1 = righ(c1);\n        c2 = righ(c2);\n        l = mid + 1;\n      } else {\n        c1 = lef(c1);\n        c2 = lef(c2);\n        r = mid;\n      }\n    }\n    ans.push_back({f, u, l});\n    update(l, 0, s[f]);\n    update(l, 1, s[u]);\n    mx.push({sf - 1, f});\n    mn.push({-(sf - 1), f});\n    mx.push({ss + 1, u});\n    mn.push({-(ss + 1), u});\n  }\n  cout << ans.size() << endl;\n  for (vector<long long> i : ans)\n    cout << i[0] + 1 << \" \" << i[1] + 1 << \" \" << i[2] << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid OUT_TST(string s, istream_iterator<string> it) { cerr << s; }\ntemplate <typename T, typename... Args>\nvoid OUT_TST(string s, istream_iterator<string> it, T a, Args... args) {\n  cerr << *it << \"=\" << a << \" \";\n  OUT_TST(s, ++it, args...);\n}\ntemplate <class T>\nvoid rd(T& ret) {\n  ret = 0;\n  bool ok = 0, u = 0;\n  for (;;) {\n    int c = getchar();\n    if (c >= '0' && c <= '9')\n      ret = (ret << 3) + (ret << 1) + c - '0', ok = 1;\n    else if (c == '-')\n      u = 1;\n    else if (ok) {\n      if (u) ret *= -1;\n      return;\n    }\n  }\n}\nlong long powmod(long long p, long long n, long long mod) {\n  long long ret = 1;\n  for (; n; n >>= 1) {\n    if (n & 1) ret = ret * p % mod;\n    p = p * p % mod;\n  }\n  return ret;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n  return b > a ? a = b, 1 : 0;\n}\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(nullptr);\n  int cas;\n  cas = 1;\n  for (int i = 0; i < cas; ++i) {\n    auto solve = []() {\n      int n, m;\n      cin >> n >> m;\n      vector<set<int>> an(n);\n      vector<int> cnt(n), target_num(n, 0), idx(n);\n      int total_cnt = 0;\n      for (int i = 0; i < n; ++i) {\n        an[i].clear();\n        cin >> cnt[i];\n        for (int j = 0; j < cnt[i]; ++j) {\n          int first;\n          cin >> first;\n          an[i].insert(first);\n        }\n        total_cnt += cnt[i];\n        idx[i] = i;\n      }\n      for (int i = 0, j = 0; i < total_cnt; ++i, j = (j + 1) % n) {\n        target_num[j]++;\n      }\n      sort(idx.begin(), idx.end(), [&](int first, int second) {\n        return an[first].size() > an[second].size();\n      });\n      if (n == 1) {\n        cout << \"0\" << endl;\n        return;\n      }\n      auto get_intersection = [](const set<int>& a, const set<int>& b,\n                                 set<int>& res) {\n        res.clear();\n        for (int i : a) {\n          if (!b.count(i)) {\n            res.insert(i);\n          }\n        }\n      };\n      set<int> now;\n      get_intersection(an[idx[0]], an[idx[n - 1]], now);\n      using tp3 = tuple<int, int, int>;\n      vector<tp3> ans;\n      for (int i = 0, j = n - 1; i < j;) {\n        if (target_num[i] == (int)an[idx[i]].size()) {\n          if (++i == j) break;\n          get_intersection(an[idx[i]], an[idx[j]], now);\n        } else if (target_num[j] == (int)an[idx[j]].size()) {\n          if (i == j - 1) break;\n          for (int first : an[idx[j]]) {\n            if (an[idx[i]].count(first)) {\n              now.insert(first);\n            }\n          }\n          --j;\n          for (int first : an[idx[j]]) {\n            auto it = now.find(first);\n            if (it != now.end()) {\n              now.erase(it);\n            }\n          }\n        } else {\n          int first = *now.begin();\n          an[idx[i]].erase(first);\n          an[idx[j]].insert(first);\n          now.erase(now.begin());\n          ans.emplace_back(idx[i], idx[j], first);\n        }\n      }\n      cout << ans.size() << endl;\n      for (auto& i : ans) {\n        cout << get<0>(i) + 1 << \" \" << get<1>(i) + 1 << \" \" << get<2>(i)\n             << endl;\n      }\n    };\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct oper {\n  int f, t, k;\n  oper(int _f, int _t, int _k) : f(_f), t(_t), k(_k) {}\n};\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  int n, m, all = 0;\n  cin >> n >> m;\n  vector<int> pos[m], sz(n), pf(n);\n  vector<pair<int, int> > v;\n  vector<oper> ops;\n  set<int> sl;\n  for (int i = 0; i < n; ++i) {\n    cin >> sz[i];\n    v.emplace_back(sz[i], i);\n    all += sz[i];\n    for (int j = 0; j < sz[i]; ++j) {\n      int x;\n      cin >> x;\n      --x;\n      pos[x].push_back(i);\n    }\n  }\n  sort(v.begin(), v.end());\n  int k = all / n, cntl = n - all % n;\n  for (int i = 0; i < n; ++i) {\n    pf[v[i].second] = k + (i >= cntl);\n    if (sz[v[i].second] < pf[v[i].second]) sl.insert(v[i].second);\n  }\n  for (int i = 0; i < m; ++i) {\n    int l = 0, r = 0;\n    vector<int> oks;\n    auto it = sl.begin();\n    while (r < pos[i].size()) {\n      if (it == sl.end()) break;\n      if (sz[pos[i][r]] <= pf[pos[i][r]]) {\n        ++r;\n        continue;\n      }\n      while (l < pos[i].size() && it != sl.end()) {\n        if (pos[i][l] == *it)\n          ++l, ++it;\n        else if (pos[i][l] < *it)\n          ++l;\n        else\n          break;\n      }\n      if (it != sl.end()) {\n        ++sz[*it], --sz[pos[i][r]];\n        ops.emplace_back(pos[i][r] + 1, *it + 1, i + 1);\n        if (sz[*it] == pf[*it]) oks.push_back(*it);\n        ++it;\n      }\n      ++r;\n    }\n    for (int j : oks) sl.erase(j);\n  }\n  cout << ops.size() << '\\n';\n  for (oper i : ops) cout << i.f << ' ' << i.t << ' ' << i.k << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct box {\n  int id, to;\n  set<int> items;\n};\nstruct offert {\n  int type, where;\n  bool operator<(const offert &x) const {\n    return (type == x.type) ? (where < x.where) : (type < x.type);\n  }\n};\nstruct moves {\n  int x, y, z;\n};\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  int s = 0;\n  vector<box> a(n);\n  for (auto &i : a) {\n    i.id = &i - &a[0];\n    int k, x;\n    cin >> k;\n    s += k;\n    while (k--) {\n      cin >> x;\n      i.items.insert(x);\n    }\n  }\n  vector<int> ord(n);\n  iota(ord.begin(), ord.end(), 0);\n  sort(ord.begin(), ord.end(), [&](const int &x, const int &y) {\n    return a[x].items.size() < a[y].items.size();\n  });\n  int l = s / n, r = (s + n - 1) / n, cnt = s - l * n;\n  set<offert> q, can;\n  for (auto &x : ord) {\n    auto &i = a[x];\n    i.to = l + (n - (&x - &ord[0]) <= cnt);\n    if (i.items.size() > i.to)\n      for (auto j : i.items) q.insert({j, i.id});\n  }\n  auto try_add = [&](set<int> &t, int j) {\n    auto nxt = q.upper_bound({j, 1 << 30});\n    auto prv = q.lower_bound({j, -1});\n    if (prv == q.begin())\n      prv = q.end();\n    else\n      prv = prev(prv);\n    if (prv != q.end() && t.find(prv->type) == t.end()) {\n      can.insert(*prv);\n      q.erase(prv);\n    }\n    if (nxt != q.end() && t.find(nxt->type) == t.end()) {\n      can.insert(*nxt);\n      q.erase(nxt);\n    }\n  };\n  vector<moves> op;\n  for (auto &i : a)\n    if (i.items.size() < i.to) {\n      can.clear();\n      for (auto j : i.items) try_add(i.items, j);\n      if (i.items.empty()) {\n        can.insert(*q.begin());\n        q.erase(q.begin());\n      }\n      for (; i.items.size() < i.to;) {\n        auto it = can.begin();\n        while (i.items.find(it->type) != i.items.end()) {\n          q.insert(*it);\n          can.erase(it);\n          it = can.begin();\n        }\n        op.push_back({it->where, i.id, it->type});\n        i.items.insert(it->type);\n        auto val = *it;\n        can.erase(it);\n        a[val.where].items.erase(val.type);\n        if (a[val.where].items.size() == a[val.where].to) {\n          for (auto z : a[val.where].items) {\n            q.erase({z, val.where});\n            can.erase({z, val.where});\n          }\n          for (auto z : a[val.where].items) try_add(i.items, z);\n        }\n        try_add(i.items, val.type);\n      }\n      for (auto o : can) q.insert(o);\n    }\n  cout << op.size() << \"\\n\";\n  for (auto &i : op) cout << i.x + 1 << \" \" << i.y + 1 << \" \" << i.z << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nset<int> S[N];\npair<int, int> sz[N];\nint req[N];\nvector<pair<pair<int, int>, int> > ANS;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  int tot = 0;\n  for (int i = 1; i <= n; i++) {\n    int s;\n    cin >> s;\n    tot += s;\n    sz[i] = make_pair(s, i);\n    while (s--) {\n      int p;\n      cin >> p;\n      S[i].insert(p);\n    }\n  }\n  sort(sz + 1, sz + n + 1);\n  for (int i = 1; i <= n; i++) {\n    req[i] = tot / n;\n    if (n - i + 1 <= tot % n) req[i]++;\n  }\n  int lo = 1, hi = n;\n  while (1) {\n    while (lo < hi and req[lo] == sz[lo].first) lo++;\n    while (lo < hi and req[hi] == sz[hi].first) hi--;\n    if (lo >= hi) break;\n    int la = sz[lo].second, ra = sz[hi].second;\n    int last = 0;\n    auto it = S[la].begin();\n    vector<int> toAdd;\n    while (sz[lo].first < req[lo] and sz[hi].first > req[hi]) {\n      while (sz[lo].first < req[lo] and sz[hi].first > req[hi] and\n             (it == S[la].end() or *S[ra].upper_bound(last) < *it)) {\n        ANS.push_back(make_pair(make_pair(ra, la), *S[ra].upper_bound(last)));\n        sz[lo].first++;\n        sz[hi].first--;\n        S[ra].erase(S[ra].upper_bound(last));\n        toAdd.push_back(ANS.back().second);\n      }\n      if (it != S[la].end()) last = *(it++);\n    }\n    for (auto it : toAdd) {\n      S[la].insert(it);\n    }\n  }\n  cout << ANS.size() << \"\\n\";\n  for (auto it : ANS) {\n    cout << it.first.first << \" \" << it.first.second << \" \" << it.second\n         << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1e5 + 5;\nint solve();\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n  return 0;\n}\nint n;\nint m;\nint sum = 0;\nint f[MAX_N];\nint len[MAX_N];\nunordered_set<int> s[MAX_N];\nbool cmp(int a, int b) { return (int)s[a].size() < (int)s[b].size(); }\nvector<pair<pair<int, int>, int> > ans;\nint solve() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    int k;\n    cin >> k;\n    len[i] = k;\n    sum += k;\n    for (int j = 1; j <= k; ++j) {\n      int x;\n      cin >> x;\n      s[i].insert(x);\n    }\n  }\n  int need = sum / n;\n  for (int i = 1; i <= sum % n; ++i) {\n    f[i] = need + 1;\n  }\n  for (int i = sum % n + 1; i <= n; ++i) {\n    f[i] = need;\n  }\n  vector<int> vec;\n  for (int i = 1; i <= n; ++i) {\n    vec.push_back(i);\n  }\n  sort(vec.begin(), vec.end(), cmp);\n  reverse(vec.begin(), vec.end());\n  int l = 0;\n  int r = n - 1;\n  while (true) {\n    if (r <= l) {\n      break;\n    }\n    if (len[vec[l]] == f[l + 1]) {\n      l++;\n      continue;\n    }\n    if (len[vec[r]] == f[r + 1]) {\n      r--;\n      continue;\n    }\n    vector<int> erased;\n    for (int it : s[vec[r]]) {\n      if (s[vec[l]].find(it) != s[vec[l]].end()) {\n        erased.push_back(it);\n        s[vec[l]].erase(it);\n      }\n    }\n    bool t = false;\n    bool tl = false;\n    vector<int> added;\n    for (int it : s[vec[l]]) {\n      ans.push_back(make_pair(make_pair(vec[l], vec[r]), it));\n      added.push_back(it);\n      s[vec[r]].insert(it);\n      len[vec[l]]--;\n      len[vec[r]]++;\n      if (len[vec[l]] == f[l + 1]) {\n        l++;\n        t = true;\n        tl = true;\n      }\n      if (len[vec[r]] == f[r + 1]) {\n        r--;\n        t = true;\n      }\n      if (t) {\n        break;\n      }\n    }\n    if (!tl) {\n      for (int it : added) {\n        s[vec[l]].erase(it);\n      }\n      for (int it : erased) {\n        s[vec[l]].insert(it);\n      }\n    }\n  }\n  cout << (int)ans.size() << endl;\n  for (auto it : ans) {\n    cout << it.first.first << ' ' << it.first.second << ' ' << it.second\n         << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX = (1 << 17);\nset<int> S[MX];\nint n;\nint bitgiver[MX];\nset<int> av;\nint cnt[MX];\nset<int> who[MX];\nint bittaker[MX];\nvoid addtogiver(int x, int V) {\n  while (x < MX) {\n    bitgiver[x] += V;\n    x += x & (-x);\n  }\n}\nint tar[MX];\nvoid init() {\n  for (int j = 1; j <= n; j++) {\n    if (S[j].size() <= tar[j]) continue;\n    for (auto pp : S[j]) {\n      if (!av.count(pp)) {\n        av.insert(pp);\n        addtogiver(pp, 1);\n      }\n      who[pp].insert(j);\n      ++cnt[pp];\n    }\n  }\n}\nvoid addtotaker(int x, int V) {\n  while (x < MX) {\n    bittaker[x] += V;\n    x += x & (-x);\n  }\n}\nint find_mismatch() {\n  int ret = 0, a = 0, b = 0;\n  for (int j = 16; j >= 0; j--) {\n    if (a + bitgiver[ret + (1 << j)] == b + bittaker[ret + (1 << j)])\n      ret += (1 << j);\n  }\n  return ++ret;\n}\nvoid inittaker(int idx) {\n  for (auto pp : S[idx]) {\n    if (av.count(pp)) addtotaker(pp, 1);\n  }\n}\nvoid clrtaker(int idx) {\n  for (auto pp : S[idx]) {\n    if (av.count(pp)) addtotaker(pp, -1);\n  }\n}\nvector<pair<pair<int, int>, int> > sol;\nvoid transfer(int which, int to) {\n  S[to].insert(which);\n  int from = *who[which].begin();\n  sol.push_back({{from, to}, which});\n  who[which].erase(from);\n  addtotaker(which, 1);\n  --cnt[which];\n  if (cnt[which] == 0) {\n    av.erase(which);\n    addtogiver(which, -1);\n    addtotaker(which, -1);\n  }\n  S[from].erase(which);\n  if (S[from].size() == tar[from]) {\n    for (auto pp : S[from]) {\n      --cnt[pp];\n      who[pp].erase(from);\n      if (cnt[pp] == 0) {\n        addtogiver(pp, -1);\n        av.erase(pp);\n        if (S[to].count(pp)) addtotaker(pp, -1);\n      }\n    }\n  }\n}\nvector<pair<int, int> > sorted;\nint main() {\n  int K;\n  scanf(\"%d %d\", &n, &K);\n  int sum = 0;\n  for (int j = 1; j <= n; j++) {\n    int K;\n    scanf(\"%d\", &K);\n    sum += K;\n    while (K--) {\n      int x;\n      scanf(\"%d\", &x);\n      S[j].insert(x);\n    }\n  }\n  for (int j = 1; j <= n; j++) {\n    sorted.push_back({S[j].size(), j});\n  }\n  sort(sorted.rbegin(), sorted.rend());\n  for (int j = 1; j <= n; j++) {\n    int who = sorted[j - 1].second;\n    tar[who] = sum / n;\n    if (j <= sum % n) ++tar[who];\n  }\n  init();\n  for (int j = 1; j <= n; j++) {\n    if (S[j].size() >= tar[j]) continue;\n    inittaker(j);\n    int taker = j;\n    while (S[taker].size() < tar[taker]) {\n      int which = find_mismatch();\n      transfer(which, taker);\n    }\n    clrtaker(taker);\n  }\n  cout << sol.size() << endl;\n  for (auto pp : sol)\n    cout << pp.first.first << ' ' << pp.first.second << ' ' << pp.second\n         << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 111111;\nint n, m, s[N], a[N], e[N];\nvector<int> v[N], t;\npair<int, int> p[N];\nvoid solve(int x, int y, int z) {\n  int i, o;\n  for (i = 0; i < s[y]; i = i + 1) e[v[y][i]] = 1;\n  for (i = s[x] - 1; z; i = i - 1) {\n    o = v[x][i];\n    if (e[o])\n      t.push_back(o);\n    else\n      v[y].push_back(o), s[y]++, z--, printf(\"%d %d %d\\n\", x, y, o);\n    v[x][i] = 0;\n    s[x]--;\n  }\n  for (i = 0; i < s[y]; i = i + 1) e[v[y][i]] = 0;\n  for (o = t.size(); o--;) v[x][s[x]++] = t[o];\n  t.clear();\n}\nint main() {\n  int i, j, x, y, z;\n  scanf(\"%d%d\", &n, &m);\n  m = 0;\n  for (i = 1; i <= n; i = i + 1) {\n    scanf(\"%d\", s + i);\n    for (j = 0; j < s[i]; j = j + 1) scanf(\"%d\", &x), v[i].push_back(x);\n    p[i] = make_pair(-s[i], i);\n    m += s[i];\n  }\n  for (i = 1; i <= n; i = i + 1) a[i] = m / n;\n  for (i = 1; i <= m % n; i = i + 1) a[i]++;\n  sort(p + 1, p + n + 1);\n  x = 0;\n  for (i = 1; i <= n; i = i + 1)\n    if (s[p[i].second] > a[i]) x += s[p[i].second] - a[i];\n  printf(\"%d\\n\", x);\n  i = 1, j = n;\n  while (i < j) {\n    x = p[i].second;\n    y = p[j].second;\n    if (s[x] == a[i]) {\n      i++;\n      continue;\n    }\n    if (s[y] == a[j]) {\n      j--;\n      continue;\n    }\n    z = min(s[x] - a[i], a[j] - s[y]);\n    solve(x, y, z);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint n, m, mex[N], a, s, tmp = 0;\nset<pair<int, int> > arr[N];\nset<pair<int, int> > st;\nset<pair<int, int> >::iterator it, it2;\nint sum = 0;\ninline bool In(int idx, int val) {\n  it2 = arr[idx].lower_bound(make_pair(val, 0));\n  if (it2 != arr[idx].end() && it2->first == val) return true;\n  return false;\n}\nvoid make(int i, int j) {\n  st.erase(st.find(make_pair((int)arr[i].size(), i)));\n  st.erase(st.find(make_pair((int)arr[j].size(), j)));\n  int last = 0;\n  while ((int)arr[j].size() < sum && (int)arr[i].size() > tmp) {\n    it = arr[i].lower_bound(make_pair(last, 1000000010));\n    if (it == arr[i].end()) break;\n    last = it->first;\n    if (!In(j, last)) {\n      arr[j].insert(make_pair(it->first, it->second));\n      arr[i].erase(it);\n    }\n  }\n  st.insert(make_pair((int)arr[i].size(), i));\n  st.insert(make_pair((int)arr[j].size(), j));\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &s);\n    sum += s;\n    for (int j = 0; j < s; j++) {\n      scanf(\"%d\", &a);\n      arr[i].insert(make_pair(a, i));\n    }\n    st.insert(make_pair(s, i));\n  }\n  vector<pair<int, pair<int, int> > > ans;\n  tmp = (sum + n - 1) / n;\n  sum /= n;\n  while (true) {\n    if (st.begin()->first >= sum) break;\n    it = st.end();\n    it--;\n    if (it->first <= tmp) break;\n    make(it->second, st.begin()->second);\n  }\n  tmp--;\n  while (true) {\n    if (st.begin()->first >= sum) break;\n    it = st.end();\n    it--;\n    if (it->first <= tmp) break;\n    make(it->second, st.begin()->second);\n  }\n  tmp++;\n  sum++;\n  while (true) {\n    if (st.begin()->first >= sum) break;\n    it = st.end();\n    it--;\n    if (it->first <= tmp) break;\n    make(it->second, st.begin()->second);\n  }\n  for (int i = 0; i < n; i++) {\n    for (it = arr[i].begin(); it != arr[i].end(); it++) {\n      if (it->second != i) {\n        ans.push_back(make_pair(it->second, make_pair(i, it->first)));\n      }\n    }\n  }\n  printf(\"%d\\n\", (int)ans.size());\n  for (int i = 0; i < (int)ans.size(); i++) {\n    printf(\"%d %d %d\\n\", ans[i].first + 1, ans[i].second.first + 1,\n           ans[i].second.second);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 100005;\nint n, m;\nset<int> S[Maxn];\nint need[Maxn];\nint seq[Maxn];\nvector<pair<pair<int, int>, int> > res;\nint tot;\nbool Less(const int &a, const int &b) { return S[a].size() < S[b].size(); }\nvoid Move(int a, int b, int c) {\n  res.push_back(pair<pair<int, int>, int>(pair<int, int>(a, b), c));\n  S[a].erase(c);\n  S[b].insert(c);\n}\nvoid Move(int a, int b) {\n  set<int>::iterator itl = S[b].begin(), itr = S[a].begin();\n  vector<int> add;\n  while ((itl != S[b].end() || itr != S[a].end()) &&\n         S[b].size() + add.size() < need[b] &&\n         S[a].size() > need[a] + add.size())\n    if (itl != S[b].end() && (itr == S[a].end() || *itl < *itr))\n      itl++;\n    else if (itr != S[a].end() && (itl == S[b].end() || *itr < *itl)) {\n      add.push_back(*itr);\n      itr++;\n    } else {\n      itl++;\n      itr++;\n    }\n  for (int i = 0; i < add.size(); i++) Move(a, b, add[i]);\n}\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  tot = 0;\n  for (int i = 1; i <= n; i++) {\n    seq[i - 1] = i;\n    int s;\n    scanf(\"%d\", &s);\n    for (int j = 0; j < s; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      S[i].insert(x);\n    }\n    tot += s;\n  }\n  sort(seq, seq + n, Less);\n  for (int i = 0; i < n; i++) need[seq[i]] = tot / n;\n  for (int i = 1; i <= tot % n; i++) need[seq[n - i]]++;\n  int l = 0, r = n - 1;\n  while (l < r)\n    if (S[seq[r]].size() == need[seq[r]])\n      r--;\n    else if (S[seq[l]].size() == need[seq[l]])\n      l++;\n    else\n      Move(seq[r], seq[l]);\n  printf(\"%d\\n\", int(res.size()));\n  for (int i = 0; i < res.size(); i++)\n    printf(\"%d %d %d\\n\", res[i].first.first, res[i].first.second,\n           res[i].second);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long modx(long long Base, long long exponent) {\n  long long ans = 1;\n  if (Base == 1) return Base;\n  while (exponent) {\n    if (exponent & 1) ans = (ans * Base) % 1000000007LL;\n    Base = (Base * Base) % 1000000007LL;\n    exponent = exponent >> 1;\n  }\n  return ans;\n}\nlong long inmodx(long long num) { return (modx(num, 1000000007LL - 2LL)); }\nbool cmp(pair<int, int> a, pair<int, int> b) {\n  if (a.second < b.second) return 1;\n  if (a.second > b.second) return 0;\n  if (a.first <= b.first) return 1;\n  return 0;\n}\nconst int N = (1e5) + 9;\nconst int M = (N << 2) + 9;\nconst int LOGN = ((int)log2(N)) + 3;\nconst int LOGM = ((int)log2(M)) + 3;\nconst int BUCK = 450;\nset<int> a[N];\npair<int, int> st[M];\nvector<pair<pair<int, int>, int> > ans;\nvector<int> brr, arr[N], crr;\nvoid update_ans(int from, int to, int val) {\n  ans.push_back(make_pair(make_pair(from, to), val));\n  return;\n}\nvoid build(int node, int l, int r) {\n  if (l > r) return;\n  if (l == r) {\n    st[node] = {(int)((a[l]).size()), l};\n    return;\n  }\n  int mid = (l + r) >> 1;\n  int left = node << 1;\n  int right = left | 1;\n  build(left, l, mid);\n  build(right, mid + 1, r);\n  st[node] = min(st[left], st[right]);\n  return;\n}\nvoid update(int node, int l, int r, int ind, pair<int, int> val) {\n  if (l > r || ind < l || ind > r) return;\n  if (l == r) {\n    st[node] = val;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  int left = node << 1;\n  int right = left | 1;\n  update(left, l, mid, ind, val);\n  update(right, mid + 1, r, ind, val);\n  st[node] = min(st[left], st[right]);\n  return;\n}\nvoid solve() {\n  int n, m, i, j, d, x, sum = 0;\n  pair<int, int> X, val;\n  cin >> n >> m;\n  sum = 0;\n  for (i = (1); i < (n + 1); i++) {\n    cin >> d;\n    sum += d;\n    while (d--) {\n      cin >> x;\n      a[i].insert(x);\n    }\n  }\n  X = {sum / n, (sum + n - 1) / n};\n  for (i = (1); i < (n + 1); i++)\n    for (auto x : a[i]) arr[x].push_back(i);\n  build(1, 1, n);\n  for (i = (1); i < (m + 1); i++) {\n    brr.clear();\n    for (auto x : arr[i]) update(1, 1, n, x, make_pair(1000000011, x));\n    for (auto x : arr[i]) {\n      if ((int)((a[x]).size()) <= X.second) continue;\n      val = st[1];\n      if (val.first >= X.first) break;\n      a[val.second].insert(i);\n      update(1, 1, n, val.second, make_pair(1000000011, val.second));\n      brr.push_back(val.second);\n      a[x].erase(i);\n      update_ans(x, val.second, i);\n    }\n    for (auto x : arr[i])\n      update(1, 1, n, x, make_pair((int)((a[x]).size()), x));\n    for (auto x : brr) update(1, 1, n, x, make_pair((int)((a[x]).size()), x));\n  }\n  int fuck = 0;\n  d = 0;\n  for (i = (1); i < (n + 1); i++)\n    if ((int)((a[i]).size()) < X.first) {\n      fuck++;\n      d = 1;\n      break;\n    }\n  if (d == 1) {\n    for (i = (1); i < (m + 1); i++) arr[i].clear();\n    for (i = (1); i < (n + 1); i++)\n      for (auto x : a[i]) arr[x].push_back(i);\n    for (i = (1); i < (m + 1); i++) {\n      brr.clear();\n      for (auto x : arr[i]) update(1, 1, n, x, make_pair(1000000011, x));\n      for (auto x : arr[i]) {\n        if ((int)((a[x]).size()) < X.second) continue;\n        val = st[1];\n        if (val.first >= X.first) break;\n        a[val.second].insert(i);\n        update(1, 1, n, val.second, make_pair(1000000011, val.second));\n        brr.push_back(val.second);\n        a[x].erase(i);\n        update_ans(x, val.second, i);\n      }\n      for (auto x : arr[i])\n        update(1, 1, n, x, make_pair((int)((a[x]).size()), x));\n      for (auto x : brr) update(1, 1, n, x, make_pair((int)((a[x]).size()), x));\n    }\n  }\n  d = 0;\n  for (i = (1); i < (n + 1); i++)\n    if ((int)((a[i]).size()) > X.second) {\n      fuck++;\n      d = 1;\n      break;\n    }\n  if (d == 1) {\n    for (i = (1); i < (m + 1); i++) arr[i].clear();\n    for (i = (1); i < (n + 1); i++)\n      for (auto x : a[i]) arr[x].push_back(i);\n    for (i = (1); i < (m + 1); i++) {\n      brr.clear();\n      for (auto x : arr[i]) update(1, 1, n, x, make_pair(1000000011, x));\n      for (auto x : arr[i]) {\n        if ((int)((a[x]).size()) <= X.second) continue;\n        val = st[1];\n        if (val.first > X.first) break;\n        a[val.second].insert(i);\n        update(1, 1, n, val.second, make_pair(1000000011, val.second));\n        brr.push_back(val.second);\n        a[x].erase(i);\n        update_ans(x, val.second, i);\n      }\n      for (auto x : arr[i])\n        update(1, 1, n, x, make_pair((int)((a[x]).size()), x));\n      for (auto x : brr) update(1, 1, n, x, make_pair((int)((a[x]).size()), x));\n    }\n  }\n  assert(fuck < 2);\n  cout << (int)((ans).size()) << '\\n';\n  for (auto x : ans)\n    cout << x.first.first << \" \" << x.first.second << \" \" << x.second << '\\n';\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  clock_t clk;\n  clk = clock();\n  int t = 1, cs;\n  cout << fixed << setprecision(3);\n  for (cs = (1); cs < (t + 1); cs++) {\n    solve();\n  }\n  clk = clock() - clk;\n  cerr << fixed << setprecision(6) << \"Time: \" << ((double)clk) / CLOCKS_PER_SEC\n       << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k[100005], p[100005], cnt, outf[250005], outt[250005], outk[250005],\n    ans, l, r;\nset<int> s[100005], S;\nvector<int> v;\nbool cmp(int x, int y) { return k[x] > k[y]; }\nvoid del() {\n  for (set<int>::iterator it = s[p[r]].begin(); it != s[p[r]].end(); ++it)\n    if (S.count(*it)) S.erase(*it), v.push_back(*it);\n}\nvoid rec() {\n  for (int i = 0; i < v.size(); ++i) S.insert(v[i]);\n  v.clear();\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    int x;\n    scanf(\"%d\", k + i);\n    cnt += k[i], p[i] = i;\n    for (int j = 1; j <= k[i]; ++j) {\n      scanf(\"%d\", &x);\n      s[i].insert(x);\n    }\n  }\n  sort(p + 1, p + n + 1, cmp);\n  for (int i = 1; i <= n; ++i) k[i] -= cnt / n;\n  for (int i = 1; i <= cnt % n; ++i) --k[p[i]];\n  l = 1, r = n;\n  S = s[p[1]];\n  del();\n  while (l < r) {\n    if (!k[p[l]]) {\n      ++l;\n      if (l == r) break;\n      v.clear(), S = s[p[l]];\n      del();\n      continue;\n    }\n    if (!k[p[r]]) {\n      rec();\n      --r;\n      if (l == r) break;\n      del();\n      continue;\n    }\n    int x = *S.begin();\n    S.erase(x), s[p[r]].insert(x), --k[p[l]], ++k[p[r]];\n    ++ans, outf[ans] = p[l], outt[ans] = p[r], outk[ans] = x;\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = 1; i <= ans; ++i)\n    printf(\"%d %d %d\\n\", outf[i], outt[i], outk[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nstruct child {\n  int ctr, idx;\n  bool operator<(const child &o) const { return ctr < o.ctr; }\n};\nstruct S {\n  int from, to, type;\n};\nchild c[N];\nset<int> a[N];\nvector<S> ans;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m;\n  cin >> n >> m;\n  int total = 0;\n  for (int i = 1; i <= n; ++i) {\n    cin >> c[i].ctr;\n    c[i].idx = i;\n    total += c[i].ctr;\n    for (int j = 0; j < c[i].ctr; ++j) {\n      int x;\n      cin >> x;\n      a[i].insert(x);\n    }\n  }\n  sort(c + 1, c + 1 + n);\n  int hi_ctr = total % n;\n  int i = 1, j = n;\n  while (i < j) {\n    int lo, hi;\n    if (i >= n - hi_ctr + 1) {\n      lo = total / n + 1;\n    } else {\n      lo = total / n;\n    }\n    if (j >= n - hi_ctr + 1) {\n      hi = total / n + 1;\n    } else {\n      hi = total / n;\n    }\n    int transfer = min(lo - c[i].ctr, c[j].ctr - hi);\n    int idx1 = c[i].idx, idx2 = c[j].idx;\n    vector<int> found;\n    auto it1 = a[idx1].begin(), it2 = a[idx2].begin();\n    while (transfer) {\n      if (it1 == a[idx1].end()) {\n        found.push_back(*it2);\n        ++it2;\n        --transfer;\n      } else if (*it1 == *it2) {\n        ++it1;\n        ++it2;\n      } else if (*it1 < *it2) {\n        ++it1;\n      } else {\n        found.push_back(*it2);\n        ++it2;\n        --transfer;\n      }\n    }\n    for (auto &f : found) {\n      ans.push_back({idx2, idx1, f});\n      a[idx2].erase(f);\n      a[idx1].insert(f);\n    }\n    c[i].ctr += found.size();\n    c[j].ctr -= found.size();\n    if (c[i].ctr >= lo) {\n      ++i;\n    }\n    if (c[j].ctr == hi) {\n      --j;\n    }\n  }\n  cout << ans.size() << '\\n';\n  for (auto &f : ans) {\n    cout << f.from << ' ' << f.to << ' ' << f.type << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, cnt, tp, q[100009], sz[100009], ta[100009], e[1000009][3];\nbool bo[100009];\nvector<int> a[100009], b[1000009];\nset<int> S;\nset<int>::iterator it;\nvoid ins(int x, int y, int z) {\n  e[++cnt][0] = x;\n  e[cnt][1] = y;\n  e[cnt][2] = z;\n}\nbool cmp(int x, int y) { return sz[x] < sz[y]; }\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  int i, sum = 0;\n  for (i = 1; i <= n; i++) {\n    int t;\n    scanf(\"%d\", &t);\n    sz[i] = t;\n    sum += t;\n    while (t--) {\n      int x;\n      scanf(\"%d\", &x);\n      a[i].push_back(x);\n    }\n    if (a[i].size() != sz[i])\n      while (1)\n        ;\n  }\n  for (i = 1; i <= n; i++) q[i] = i;\n  sort(q + 1, q + n + 1, cmp);\n  for (i = 1; i <= n; i++) ta[q[i]] = sum / n + (n - i + 1 <= sum % n);\n  for (i = 1; i <= n; i++)\n    if (sz[i] < ta[i]) S.insert(i);\n  for (i = 1; i <= n; i++)\n    for (int p : a[i]) b[p].push_back(i);\n  for (i = 1; i <= m; i++) {\n    for (int p : b[i]) bo[p] = 1;\n    it = S.begin();\n    for (int p : b[i]) {\n      if (sz[p] > ta[p]) {\n        for (; it != S.end(); it++) {\n          int x = *it;\n          if (!bo[x] && sz[x] < ta[x]) {\n            ins(p, x, i);\n            sz[p]--;\n            sz[x]++;\n            if (sz[x] == ta[x]) q[++tp] = x;\n            it++;\n            break;\n          }\n        }\n      }\n    }\n    while (tp) S.erase(q[tp--]);\n    for (int p : b[i]) bo[p] = 0;\n  }\n  printf(\"%d\\n\", cnt);\n  for (i = 1; i <= cnt; i++) printf(\"%d %d %d\\n\", e[i][0], e[i][1], e[i][2]);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.TreeSet;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ISTU: Ne nado dumat'\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            int totalGifts = 0;\n            Bucket[] buckets = new Bucket[n];\n            for (int i = 0; i < n; i++) {\n                buckets[i] = new Bucket(i);\n            }\n            for (int i = 0; i < n; i++) {\n                int k = in.readInt();\n                totalGifts += k;\n                for (int j = 0; j < k; j++) {\n                    buckets[i].a.add(in.readInt());\n                }\n            }\n            Arrays.sort(buckets);\n            List<Move> moves = new ArrayList<>();\n            for (int l = 0, r = n - 1; ; ) {\n                while (l < n && buckets[l].a.size() == getNeedSize(l, n, totalGifts)) {\n                    l++;\n                }\n                while (r >= 0 && buckets[r].a.size() == getNeedSize(r, n, totalGifts)) {\n                    r--;\n                }\n                if (l > r) {\n                    break;\n                }\n                int cnt = Math.min(\n                        getNeedSize(l, n, totalGifts) - buckets[l].a.size(),\n                        buckets[r].a.size() - getNeedSize(r, n, totalGifts)\n                );\n                List<Integer> kinds = get(buckets[l].a, buckets[r].a, cnt);\n                for (int x : kinds) {\n                    moves.add(new Move(buckets[r].index, buckets[l].index, x));\n                    buckets[r].a.remove(x);\n                    buckets[l].a.add(x);\n                }\n            }\n            out.printLine(moves.size());\n            for (int i = 0; i < moves.size(); i++) {\n                Move move = moves.get(i);\n                out.printFormat(\"%d %d %d\\n\", move.from + 1, move.to + 1, move.kind);\n            }\n        }\n\n        int getNeedSize(int at, int n, int m) {\n            if (m % n == 0) {\n                return m / n;\n            }\n            int bigger = m % n;\n            int prefix = n - bigger;\n            if (at < prefix) {\n                return m / n;\n            }\n            return m / n + 1;\n        }\n\n        List<Integer> get(TreeSet<Integer> s1, TreeSet<Integer> s2, int need) {\n            if (need == 0) {\n                return Collections.emptyList();\n            }\n            List<Integer> res = new ArrayList<>();\n            Iterator<Integer> it1 = s1.iterator();\n            Iterator<Integer> it2 = s2.iterator();\n            int x = -1;\n            while (it2.hasNext() && res.size() < need) {\n                int y = it2.next();\n                while (x < y) {\n                    if (it1.hasNext()) {\n                        x = it1.next();\n                    } else {\n                        x = Integer.MAX_VALUE;\n                    }\n                }\n                if (x > y) {\n                    res.add(y);\n                }\n            }\n            return res;\n        }\n\n        class Move {\n            int from;\n            int to;\n            int kind;\n\n            Move(int from, int to, int kind) {\n                this.from = from;\n                this.to = to;\n                this.kind = kind;\n            }\n\n        }\n\n        class Bucket implements Comparable<Bucket> {\n            int index;\n            TreeSet<Integer> a = new TreeSet<>();\n\n            Bucket(int index) {\n                this.index = index;\n            }\n\n            public int compareTo(Bucket o) {\n                return Integer.compare(a.size(), o.a.size());\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void printFormat(String format, Object... objects) {\n            writer.printf(format, objects);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\nconst double eps = 1e-11;\ntemplate <class T>\ninline void ckmin(T &a, T b) {\n  if (b < a) a = b;\n}\ntemplate <class T>\ninline void ckmax(T &a, T b) {\n  if (b > a) a = b;\n}\ntemplate <class T>\ninline T sqr(T x) {\n  return x * x;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  vector<pair<pair<int, int>, int>> ret;\n  int n, m;\n  cin >> n >> m;\n  vector<unordered_set<int>> a(n);\n  vector<vector<int>> g(m);\n  int total = 0;\n  for (int i = 0; i < (n); ++i) {\n    int c;\n    cin >> c;\n    for (int j = 0; j < (c); ++j) {\n      int p;\n      cin >> p;\n      --p;\n      a[i].insert(p);\n    }\n    total += c;\n  }\n  int c1 = total / n;\n  int c2 = (total + n - 1) / n;\n  for (int step = 0; step < (3); ++step) {\n    int bound, limit;\n    if (step == 0)\n      bound = c1 - 1, limit = c2 + 1;\n    else if (step == 1)\n      bound = c1 - 1, limit = c2;\n    else\n      bound = c1, limit = c2 + 1;\n    for (int i = 0; i < (m); ++i) g[i].clear();\n    for (int i = 0; i < (n); ++i)\n      if (((int)a[i].size()) >= limit)\n        for (int x : a[i]) g[x].push_back(i);\n    set<int> skey;\n    skey.clear();\n    for (int i = 0; i < (m); ++i)\n      if (((int)g[i].size()) > 0) skey.insert(i);\n    for (int i = 0; i < (n); ++i)\n      for (int key = 0; ((int)a[i].size()) <= bound; key++) {\n        auto it = skey.lower_bound(key);\n        if (it == skey.end()) break;\n        key = *it;\n        if (a[i].count(key)) continue;\n        if (((int)g[key].size()) == 0) {\n          skey.erase(key);\n          continue;\n        }\n        int idx = g[key].back();\n        g[key].pop_back();\n        if (a[idx].count(key) && ((int)a[idx].size()) >= limit) {\n          assert(a[idx].count(key));\n          assert(!a[i].count(key));\n          a[idx].erase(key);\n          a[i].insert(key);\n          ret.push_back(make_pair(make_pair(idx, i), key));\n        } else\n          --key;\n      }\n  }\n  for (int i = 0; i < (n); ++i)\n    assert(((int)a[i].size()) == c1 || ((int)a[i].size()) == c2);\n  printf(\"%d\\n\", ((int)ret.size()));\n  for (auto w : ret)\n    printf(\"%d %d %d\\n\", w.first.first + 1, w.first.second + 1, w.second + 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 110000;\nset<int> S[N];\nint cnt[N], id[N], to[N];\nint main() {\n  int n, m;\n  cin >> n >> m;\n  set<int> G, L;\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    cnt[i] = x;\n    sum += x;\n    for (int j = 1; j <= x; j++) {\n      int y;\n      cin >> y;\n      S[i].insert(y);\n    }\n  }\n  for (int i = 1; i <= n; i++) id[i] = i;\n  sort(id + 1, id + n + 1, [](int i, int j) { return cnt[i] < cnt[j]; });\n  for (int i = 1; i <= n; i++) to[id[n - i + 1]] = sum / n + (i <= sum % n);\n  for (int i = 1; i <= n; i++) {\n    if (to[i] > cnt[i]) L.insert(i);\n    if (to[i] < cnt[i]) G.insert(i);\n  }\n  vector<tuple<int, int, int>> V;\n  while (G.size()) {\n    if (L.empty()) break;\n    int x = *G.begin();\n    G.erase(x);\n    while (cnt[x] > to[x]) {\n      int y = *L.begin();\n      vector<int> era;\n      assert(cnt[y] < to[y]);\n      assert(cnt[x] > to[x]);\n      int flg = 0;\n      for (int t : S[x]) {\n        if (S[y].count(t)) continue;\n        S[y].insert(t);\n        V.emplace_back(x, y, t);\n        cnt[y]++;\n        cnt[x]--;\n        era.push_back(t);\n        if (cnt[x] == to[x]) {\n          flg = 1;\n          break;\n        }\n        if (cnt[y] == to[y]) {\n          flg = 1;\n          break;\n        }\n      }\n      assert(flg);\n      for (int t : era) S[x].erase(t);\n      if (cnt[y] == to[y]) L.erase(y);\n    }\n  }\n  assert(!L.size());\n  cout << V.size() << endl;\n  for (auto t : V) {\n    int a, b, c;\n    tie(a, b, c) = t;\n    cout << a << ' ' << b << ' ' << c << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint tot, pos[100001], ans[500001][3], xi, yi, tp, s[100001], n, m, fir[100001],\n    nex[1200001], sto[1200001], cnt, sum, si, pre[100001], c[500001], l[400001],\n    r[400001], sz[400001];\nvoid built(int num, int x, int y) {\n  l[num] = x;\n  r[num] = y;\n  sz[num] = 0;\n  if (x == y) return;\n  int mid = (x + y) / 2;\n  built(num * 2, x, mid);\n  built(num * 2 + 1, mid + 1, y);\n}\nvoid gai(int num, int x) {\n  if (l[num] == r[num]) {\n    sz[num] = sz[num] ^ 1;\n    return;\n  }\n  int mid = (l[num] + r[num]) / 2;\n  if (x <= mid)\n    gai(num * 2, x);\n  else\n    gai(num * 2 + 1, x);\n  sz[num] = sz[num * 2] + sz[num * 2 + 1];\n}\nint ask(int num, int x, int y) {\n  if (sz[num] == 0) return (-1);\n  if (l[num] == r[num]) return (l[num]);\n  if ((l[num] == x) && (r[num] == y)) {\n    int answ = ask(num * 2, x, r[num * 2]);\n    if (answ > 0)\n      return (answ);\n    else\n      return (ask(num * 2 + 1, l[num * 2 + 1], y));\n  }\n  int mid = (l[num] + r[num]) / 2;\n  if (y <= mid)\n    return (ask(num * 2, x, y));\n  else {\n    if (x > mid)\n      return (ask(num * 2 + 1, x, y));\n    else {\n      int answ = ask(num * 2, x, mid);\n      if (answ > 0)\n        return (answ);\n      else\n        return (ask(num * 2 + 1, mid + 1, y));\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= m; i++) {\n    cnt++;\n    nex[cnt] = fir[i];\n    fir[i] = cnt;\n    sto[cnt] = 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &s[i]);\n    pre[i] = pre[i - 1] + s[i];\n    sum = sum + s[i];\n    for (int j = pre[i - 1] + 1; j <= pre[i]; j++) {\n      cnt++;\n      scanf(\"%d\", &c[j]);\n      nex[cnt] = fir[c[j]];\n      fir[c[j]] = cnt;\n      sto[cnt] = i;\n    }\n  }\n  tp = sum / n;\n  xi = sum % n;\n  yi = tp + 1;\n  if (xi == 0) {\n    yi--;\n    xi = n + 1;\n  }\n  for (int i = 1; i <= m; i++) {\n    cnt++;\n    nex[cnt] = fir[i];\n    fir[i] = cnt;\n    sto[cnt] = n + 1;\n  }\n  built(1, 1, n);\n  for (int i = 1; i <= n; i++)\n    if (s[i] >= yi) {\n      xi--;\n      pos[i] = yi;\n      if (xi == 0) {\n        yi--;\n        xi = n + 1;\n        break;\n      }\n    }\n  for (int i = 1; i <= n; i++)\n    if (pos[i] == 0) {\n      pos[i] = yi;\n      xi--;\n      if (xi == 0) {\n        yi--;\n        xi = n + 1;\n      }\n    }\n  for (int i = 1; i <= n; i++)\n    if (pos[i] > s[i]) gai(1, i);\n  tot = 0;\n  for (int i = 1; i <= n; i++)\n    if (s[i] > pos[i]) {\n      for (int j = pre[i - 1] + 1; j <= pre[i]; j++) {\n        if (s[i] == pos[i]) break;\n        while (sto[fir[c[j]]] != 0) {\n          int li = sto[fir[c[j]]], ri = sto[nex[fir[c[j]]]], aa = fir[c[j]],\n              bb = nex[aa];\n          if (li != (ri + 1)) {\n            int hh = ask(1, ri + 1, li - 1);\n            if (hh > 0) {\n              tot++;\n              ans[tot][0] = i;\n              ans[tot][1] = hh;\n              ans[tot][2] = c[j];\n              s[hh]++;\n              cnt++;\n              sto[cnt] = hh;\n              nex[aa] = cnt;\n              nex[cnt] = bb;\n              if ((s[hh] == pos[hh])) gai(1, hh);\n              s[i]--;\n              break;\n            }\n          }\n          fir[c[j]] = nex[fir[c[j]]];\n        }\n      }\n    }\n  printf(\"%d\\n\", tot);\n  for (int i = 1; i <= tot; i++)\n    printf(\"%d %d %d\\n\", ans[i][0], ans[i][1], ans[i][2]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC diagnostic ignored \"-Wmissing-declarations\"\ninline int safe_mul(const int x, const int y)\n    __attribute__((warn_unused_result));\nint const maxn = 100003;\nset<int> used[maxn];\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<int, int>> nums;\n  for (int i = 0; i < n; ++i) {\n    int s;\n    cin >> s;\n    for (int j = 0; j < s; ++j) {\n      int x;\n      cin >> x;\n      used[i].insert(x);\n    }\n    nums.emplace_back(s, i);\n  }\n  sort(nums.begin(), nums.end());\n  long long acnt = 0;\n  for (const auto& p : nums) acnt += p.first;\n  vector<int> need(n);\n  for (int i = 0; i < n; ++i) {\n    need[i] = acnt / n + (n - i <= acnt % n);\n  }\n  int l = 0;\n  int r = n - 1;\n  vector<tuple<int, int, int>> result;\n  for (;;) {\n    while (l < r && nums[l].first == need[l]) ++l;\n    while (r > l && nums[r].first == need[r]) --r;\n    if (l >= r) break;\n    vector<int> add;\n    int can = min(need[l] - nums[l].first, nums[r].first - need[r]);\n    for (int x : used[nums[r].second]) {\n      if (used[nums[l].second].find(x) == used[nums[l].second].end()) {\n        add.push_back(x);\n        if (add.size() > can) break;\n      }\n    }\n    for (int idx : add) {\n      result.emplace_back(nums[r].second + 1, nums[l].second + 1, idx);\n      used[nums[l].second].insert(idx);\n      used[nums[r].second].erase(idx);\n      --nums[r].first;\n      ++nums[l].first;\n      if (nums[l].first == need[l] || nums[r].first == need[r]) {\n        break;\n      }\n    }\n  }\n  cout << result.size() << endl;\n  for (const auto& t : result)\n    cout << get<0>(t) << ' ' << get<1>(t) << ' ' << get<2>(t) << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Box {\n  struct Node {\n    Node *l, *r;\n    int cnt;\n    Node() : l(0), r(0), cnt(0) {}\n  };\n  Node *root;\n  Box *prev, *next;\n  int id;\n  Box(int _id = -1) : id(_id), root(0), prev(this), next(this) {}\n};\nvector<Box::Node *> freeNodes;\nBox::Node *new_node() {\n  Box::Node *n;\n  if (!freeNodes.empty()) {\n    n = freeNodes.back();\n    freeNodes.pop_back();\n    new (n) Box::Node();\n  } else {\n    n = new Box::Node;\n  }\n  return n;\n}\nvoid delete_node(Box::Node *n) { freeNodes.push_back(n); }\nvoid print_node(Box::Node *n, int mn, int mx) {\n  int mid = (mn + mx) / 2;\n  if (n && n->cnt) {\n    if (mn + 1 == mx) {\n      printf(\"%d \", mn + 1);\n      return;\n    }\n    print_node(n->l, mn, mid);\n    print_node(n->r, mid, mx);\n  }\n}\nvoid insert_item(Box::Node *wh, int mn, int mx, int it) {\n  wh->cnt++;\n  if (mn + 1 == mx) {\n    return;\n  }\n  Box::Node **nwh;\n  int nmn, nmx;\n  int mid = (mn + mx) / 2;\n  if (it < mid) {\n    nmn = mn;\n    nmx = mid;\n    nwh = &wh->l;\n  } else {\n    nmn = mid;\n    nmx = mx;\n    nwh = &wh->r;\n  }\n  if (!*nwh) {\n    *nwh = new Box::Node;\n  }\n  insert_item(*nwh, nmn, nmx, it);\n}\nint move_item(Box::Node *from, Box::Node *to, int mn, int mx) {\n  if (mn + 1 == mx) {\n    to->cnt++;\n    from->cnt--;\n    return mn;\n  }\n  int item;\n  int nmn, nmx;\n  Box::Node **nfrom, **nto;\n  if (from->l && (!to->l || from->l->cnt > to->l->cnt)) {\n    nmn = mn;\n    nmx = (mn + mx) / 2;\n    nfrom = &from->l;\n    nto = &to->l;\n  } else {\n    nmn = (mn + mx) / 2;\n    nmx = mx;\n    nfrom = &from->r;\n    nto = &to->r;\n  }\n  if (!*nto) {\n    *nto = new_node();\n  }\n  item = move_item(*nfrom, *nto, nmn, nmx);\n  if (!(*nfrom)->cnt) {\n    delete_node(*nfrom);\n    *nfrom = 0;\n  }\n  to->cnt++;\n  from->cnt--;\n  return item;\n}\nint n, m;\nBox boxes[100005];\nint minBox = INT_MAX, maxBox = INT_MIN;\nint move_item(Box *from, Box *to) {\n  if (!to->root) {\n    to->root = new_node();\n  }\n  auto it = move_item(from->root, to->root, 0, m);\n  if (!from->root->cnt) {\n    delete_node(from->root);\n  }\n  return it;\n}\nvoid insert_item(Box *bx, int it) {\n  if (!bx->root) {\n    bx->root = new_node();\n  }\n  insert_item(bx->root, 0, m, it);\n}\nvoid remove_box(Box *nbox) {\n  nbox->prev->next = nbox->next;\n  nbox->next->prev = nbox->prev;\n}\nvoid move_box(Box *nbox, Box *head) {\n  nbox->prev->next = nbox->next;\n  nbox->next->prev = nbox->prev;\n  nbox->next = head->next;\n  nbox->prev = head;\n  head->next = nbox;\n  nbox->next->prev = nbox;\n}\nvoid print_box(Box *b) { print_node(b->root, 0, m); }\nBox *create_box(int s, int i) {\n  auto head = &boxes[s];\n  auto nbox = new Box(i);\n  move_box(nbox, head);\n  return nbox;\n}\nstruct Move {\n  int f, t, k;\n};\nvector<Move> moves;\nint main() {\n  int n;\n  FILE *f = stdin;\n  fscanf(f, \" %d %d\", &n, &m);\n  for (int i = (0); i < (n); ++i) {\n    int s;\n    fscanf(f, \" %d\", &s);\n    Box *b = create_box(s, i);\n    minBox = min(minBox, s);\n    maxBox = max(maxBox, s);\n    for (int j = (0); j < (s); ++j) {\n      int p;\n      fscanf(f, \" %d\", &p);\n      --p;\n      insert_item(b, p);\n    }\n  }\n  while (minBox + 1 < maxBox) {\n    auto from = boxes[maxBox].next;\n    auto to = boxes[minBox].next;\n    int it = move_item(from, to);\n    Move mm;\n    mm.f = from->id + 1;\n    mm.t = to->id + 1;\n    mm.k = it + 1;\n    moves.push_back(mm);\n    move_box(from, &boxes[maxBox - 1]);\n    move_box(to, &boxes[minBox + 1]);\n    while (boxes[maxBox].prev == &boxes[maxBox]) {\n      --maxBox;\n    }\n    while (boxes[minBox].prev == &boxes[minBox]) {\n      ++minBox;\n    }\n  }\n  printf(\"%d\\n\", (int)moves.size());\n  for (auto &m : moves) {\n    printf(\"%d %d %d\\n\", m.f, m.t, m.k);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nstruct Node {\n  Node *l = 0, *r = 0;\n  int s = 0;\n};\ninline Node *get_ch(Node *v) {\n  if (v == 0)\n    return new Node;\n  else\n    return v;\n}\ninline void get(Node *&v) {\n  v->l = get_ch(v->l);\n  v->r = get_ch(v->r);\n}\nvoid update(Node *v, int l, int r, int pos, int x) {\n  if (r - l == 1)\n    v->s = x;\n  else {\n    int m = (r + l) >> 1;\n    get(v);\n    if (pos < m)\n      update(v->l, l, m, pos, x);\n    else\n      update(v->r, m, r, pos, x);\n    v->s = v->l->s + v->r->s;\n  }\n}\nint find(Node *a, Node *b, int l, int r) {\n  if (r - l == 1)\n    return l;\n  else {\n    int m = (r + l) >> 1;\n    get(a);\n    get(b);\n    if (a->l->s > b->l->s)\n      return find(a->l, b->l, l, m);\n    else\n      return find(a->r, b->r, m, r);\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<Node *> t(n);\n  for (int i = 0; i < n; i++) t[i] = new Node;\n  set<pair<int, int>> sz;\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    for (int j = 0; j < x; j++) {\n      int pos;\n      cin >> pos;\n      pos--;\n      update(t[i], 0, m, pos, 1);\n    }\n    sz.insert({x, i});\n    sum += x;\n  }\n  vector<vector<int>> ans;\n  int need = sum / n;\n  while (sz.begin()->first < need || sz.rbegin()->first > need + 1) {\n    int v = sz.begin()->second, u = sz.rbegin()->second;\n    int x = sz.begin()->first, y = sz.rbegin()->first;\n    sz.erase(sz.begin());\n    sz.erase(prev(sz.end()));\n    sz.insert({x + 1, v});\n    sz.insert({y - 1, u});\n    int pos = find(t[u], t[v], 0, m);\n    update(t[u], 0, m, pos, 0);\n    update(t[v], 0, m, pos, 1);\n    ans.push_back({u + 1, v + 1, pos + 1});\n  }\n  cout << ans.size() << '\\n';\n  for (int i = 0; i < ans.size(); i++) {\n    for (int &x : ans[i]) cout << x << ' ';\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst long long llinf = (1LL << 62);\nconst int inf = (1 << 30);\nconst int nmax = 5e5 + 50;\nconst int mod = 1e9 + 7;\nusing namespace std;\nint n, m, i, k, tot, t, j, l, r, b, f[nmax], x, nr;\nset<int> s[nmax];\nset<int>::iterator it, it1, it2, it3;\nvector<pair<int, int> > sz;\nvector<pair<pair<int, int>, int> > ans;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cerr.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (i = 1; i <= n; i++) {\n    cin >> k;\n    tot += k;\n    for (j = 1; j <= k; j++) {\n      cin >> x;\n      s[i].insert(x);\n    }\n    s[i].insert(0), s[i].insert(nmax);\n    sz.push_back({k, i});\n  }\n  sort(sz.begin(), sz.end());\n  reverse(sz.begin(), sz.end());\n  for (i = 0; i < tot % n; i++) f[i] = (tot / n) + 1;\n  for (; i < n; i++) f[i] = tot / n;\n  l = 0, r = n - 1;\n  while (1) {\n    while (l < n && (int)s[sz[l].second].size() - 2 == f[l]) l++;\n    while (r >= 0 && (int)s[sz[r].second].size() - 2 == f[r]) r--;\n    if (l == n || r == -1) break;\n    i = sz[l].second;\n    j = sz[r].second;\n    vector<int> v;\n    nr = b = 0;\n    for (it = s[j].begin(); it != s[j].end(); it++) {\n      it1 = it;\n      it1++;\n      it2 = s[i].upper_bound((*it));\n      it3 = s[i].lower_bound((*it1));\n      if (it2 != it3)\n        for (; it2 != it3; it2++) {\n          v.push_back((*it2));\n          ans.push_back({{i, j}, (*it2)});\n          nr++;\n          if ((int)s[i].size() - 2 - nr == f[l] ||\n              (int)s[j].size() - 2 + nr == f[r]) {\n            b = 1;\n            break;\n          }\n        }\n      if (b) break;\n    }\n    for (t = 0; t < v.size(); t++) {\n      if (s[i].find(v[t]) != s[i].end()) s[i].erase(s[i].find(v[t]));\n      s[j].insert(v[t]);\n    }\n  }\n  cout << (int)ans.size() << endl;\n  for (i = 0; i < ans.size(); i++)\n    cout << ans[i].first.first << \" \" << ans[i].first.second << \" \"\n         << ans[i].second << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, s, t;\nvector<vector<int> > gift(100005);\nunordered_set<int> les;\nint sum[100005], req[100005], all, res;\nint main() {\n  vector<pair<int, int> > ord;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> s;\n    all += s;\n    sum[i] = s;\n    ord.push_back({s, i});\n    for (int j = 1; j <= s; j++) {\n      cin >> t;\n      gift[t].push_back(i);\n    }\n  }\n  sort(ord.begin(), ord.end());\n  for (int i = 0; i < n; i++) req[ord[i].second] = (all + i) / n;\n  for (int i = 1; i <= n; i++)\n    if (sum[i] < req[i]) les.insert(i);\n  for (int i = 1; i <= n; i++) res += abs(sum[i] - req[i]);\n  cout << res / 2 << endl;\n  for (int i = 1; i <= m; i++) {\n    vector<int> mor, del;\n    unordered_set<int> used;\n    for (auto j : gift[i])\n      if (sum[j] > req[j]) mor.push_back(j);\n    for (auto j : gift[i])\n      if (sum[j] < req[j]) used.insert(j);\n    for (auto it = les.begin(); it != les.end(); it++) {\n      if (!mor.size()) break;\n      int u = mor.back(), v = *it;\n      if (used.find(v) != used.end()) continue;\n      cout << u << \" \" << v << \" \" << i << endl;\n      mor.pop_back();\n      sum[u]--;\n      sum[v]++;\n      if (sum[v] == req[v]) del.push_back(v);\n    }\n    for (auto j : del) les.erase(j);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10, M = 5e5 + 10;\nint n, m, sm, goal[N];\nset<int> st[N];\nqueue<int> S, B;\nint tot, px[M], py[M], pz[M];\ninline void Ck(int x) {\n  if ((int)st[x].size() < goal[x]) S.push(x);\n  if ((int)st[x].size() > goal[x]) B.push(x);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1, k, x; i <= n; ++i) {\n    scanf(\"%d\", &k);\n    for (int j = 1; j <= k; ++j) {\n      scanf(\"%d\", &x);\n      st[i].insert(x);\n    }\n    sm += k;\n  }\n  int small = sm / n, big = small + 1, big_num = sm % n,\n      small_num = n - big_num;\n  for (int i = 1; i <= n; ++i) {\n    if (!big_num || (small_num && (int)st[i].size() <= small)) {\n      --small_num;\n      goal[i] = small;\n    } else {\n      --big_num;\n      goal[i] = big;\n    }\n  }\n  for (int i = 1; i <= n; ++i) Ck(i);\n  while (!S.empty()) {\n    int u = S.front(), v = B.front();\n    S.pop();\n    B.pop();\n    vector<int> del;\n    for (set<int>::iterator it = st[u].begin(); it != st[u].end(); ++it) {\n      set<int>::iterator nit = st[v].find(*it);\n      if (nit != st[v].end()) {\n        del.push_back(*nit);\n        st[v].erase(nit);\n      }\n    }\n    while ((int)st[u].size() < goal[u] &&\n           (int)st[v].size() + (int)del.size() > goal[v]) {\n      ++tot;\n      px[tot] = v;\n      py[tot] = u;\n      pz[tot] = *st[v].begin();\n      st[u].insert(pz[tot]);\n      st[v].erase(st[v].begin());\n    }\n    for (vector<int>::iterator it = del.begin(); it != del.end(); ++it)\n      st[v].insert(*it);\n    Ck(u);\n    Ck(v);\n  }\n  assert(B.empty());\n  printf(\"%d\\n\", tot);\n  for (int i = 1; i <= tot; ++i) printf(\"%d %d %d\\n\", px[i], py[i], pz[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nconst int INF = 2e9 + 9;\nconst long long INF1 = 1e18 + 9;\nconst long long MAXN = 4e5 + 7;\nconst long long MAXN1 = 1 << 11;\nconst long long MAXN2 = 4e6 + 9;\nconst long long MOD = 1e9 + 7;\nconst long long MOD1 = 1e9 + 9;\nconst long long ALPH = 50;\nconst long long PW1 = 239;\nconst long long PW2 = 199;\nconst long long PW3 = 193;\nconst long long PW4 = 117;\nconst long double EPS = 1e-9;\nconst long long BLOCK = 3684;\nconst long long BLOCK1 = 1 << 9;\nvoid solve();\nsigned main() {\n  srand('a' + 'l' + 'e' + 'x' + 'X' + '5' + '1' + '2');\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int q = 1;\n  if (0) cin >> q;\n  while (q--) solve();\n}\nbool cmp(pair<set<int>, int> &a, pair<set<int>, int> &b) {\n  return a.first.size() < b.first.size();\n}\nvoid solve() {\n  int n, m, cnt = 0;\n  cin >> n >> m;\n  vector<pair<set<int>, int>> v(n), ans(n);\n  for (int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    cnt += k;\n    for (int j = 0; j < k; ++j) {\n      int a;\n      cin >> a;\n      v[i].first.emplace(a);\n    }\n    v[i].second = i;\n  }\n  sort(v.begin(), v.end(), cmp);\n  int l = 0, r = n - 1;\n  vector<pair<pair<int, int>, int>> ans1;\n  while (l != r) {\n    if (ans[l].first.size() == cnt / n + (l >= n - cnt % n ? 1 : 0)) {\n      ++l;\n      continue;\n    }\n    if (v[r].first.size() + ans[r].first.size() ==\n        cnt / n + (r >= n - cnt % n ? 1 : 0)) {\n      --r;\n      continue;\n    }\n    for (auto &j : v[l].first) ans[l].first.emplace(j);\n    v[l].first.clear();\n    while (ans[l].first.size() < cnt / n + (l >= n - cnt % n ? 1 : 0) &&\n           v[r].first.size() + ans[r].first.size() >\n               cnt / n + (r >= n - cnt % n ? 1 : 0)) {\n      auto p = *v[r].first.begin();\n      v[r].first.erase(p);\n      if (ans[l].first.find(p) == ans[l].first.end()) {\n        ans1.emplace_back(make_pair(v[r].second, v[l].second), p);\n        ans[l].first.emplace(p);\n      } else {\n        ans[r].first.emplace(p);\n      }\n    }\n  }\n  cout << ans1.size() << \"\\n\";\n  for (auto &i : ans1) {\n    cout << i.first.first + 1 << \" \" << i.first.second + 1 << \" \" << i.second\n         << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> l[100009];\nint cur[100009];\nmap<int, int> m1[100009];\nvector<pair<int, pair<int, int> > > final;\nvector<int> remover;\nset<pair<int, int> > lol, lefter;\npair<int, int> temp1, temp2;\nint main() {\n  int i, j, t1, t2, t3, t4, n, m, ind1, ind2, val;\n  bool rekt, founde;\n  scanf(\"%d %d\", &n, &m);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &t1);\n    for (j = 0; j < t1; j++) {\n      scanf(\"%d\", &t2);\n      l[i].push_back(t2);\n      m1[i][t2]++;\n      lefter.insert(make_pair(i, t2));\n    }\n    sort(l[i].begin(), l[i].end());\n    cur[i] = 0;\n    lol.insert(make_pair((int)l[i].size(), i));\n  }\n  if (n == 1) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  while (1) {\n    auto it = lol.begin();\n    auto it2 = lol.end();\n    it2--;\n    t1 = abs(it->first - it2->first);\n    if (t1 <= 1) {\n      break;\n    }\n    remover.clear();\n    ind1 = it2->second;\n    ind2 = it->second;\n    auto it3 = lefter.lower_bound(make_pair(ind1, -1));\n    while (1) {\n      t1 = it3->second;\n      if (m1[ind2].find(t1) == m1[ind2].end()) {\n        m1[ind1].erase(t1);\n        m1[ind2][t1]++;\n        final.push_back(make_pair(ind1, make_pair(ind2, t1)));\n        lefter.erase(make_pair(ind1, t1));\n        temp1 = *it;\n        temp2 = *it2;\n        lol.erase(it);\n        lol.erase(it2);\n        lol.insert(make_pair(temp1.first + 1, temp1.second));\n        lol.insert(make_pair(temp2.first - 1, temp2.second));\n        break;\n      } else {\n        remover.push_back(t1);\n        it3++;\n      }\n    }\n    for (auto it : remover) {\n      lefter.erase(make_pair(ind1, it));\n      lefter.erase(make_pair(ind2, it));\n    }\n  }\n  printf(\"%d\\n\", (int) final.size());\n  for (auto it : final) {\n    printf(\"%d %d %d\\n\", it.first, it.second.first, it.second.second);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nset<int> a[N];\nint n, m;\npair<int, int> b[N], c[N];\nvoid solve(int to, int from, int k) {\n  int x = -1;\n  while (k > 0) {\n    auto itL = a[from].upper_bound(x);\n    if (itL == a[from].end()) throw;\n    int y = *itL;\n    auto itS = a[to].upper_bound(x);\n    while (itS != a[to].end() && *itS < y) itS++;\n    if (itS == a[to].end() || *itS > y) {\n      k--;\n      cout << from + 1 << \" \" << to + 1 << \" \" << y << \"\\n\";\n      a[to].insert(y);\n      a[from].erase(y);\n    }\n    x = y;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  m = 0;\n  for (int i = (0); i < (n); i++) {\n    int k;\n    cin >> k;\n    b[i] = {k, i};\n    m += k;\n    while (k--) {\n      int x;\n      cin >> x;\n      a[i].insert(x);\n    }\n  }\n  sort(b, b + n);\n  reverse(b, b + n);\n  for (int i = (0); i < (n); i++) {\n    int z = m / n;\n    z += (i < (m % n));\n    c[i] = {b[i].first - z, b[i].second};\n  }\n  sort(c, c + n);\n  int res = 0;\n  for (int i = (0); i < (n); i++)\n    if (c[i].first > 0) res += c[i].first;\n  cout << res << \"\\n\";\n  int L = 0, R = n - 1;\n  while (L < R) {\n    while (L < R && c[L].first == 0) L++;\n    while (L < R && c[R].first == 0) R--;\n    if (L >= R) break;\n    int z = min(-c[L].first, c[R].first);\n    c[L].first += z;\n    c[R].first -= z;\n    solve(c[L].second, c[R].second, z);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, s;\npair<int, int> qq[100005];\nset<int> w[100005];\nint o[100005], q[100005];\nint a, b, qa, qb;\nset<int> z;\nvector<pair<pair<int, int>, int> > r;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0, ThxDem = n; i < ThxDem; ++i) {\n    scanf(\"%d\", q + i);\n    s += q[i];\n    qq[i] = make_pair(q[i], i);\n    for (int _ = 0, ThxDem = q[i]; _ < ThxDem; ++_) {\n      int t;\n      scanf(\"%d\", &t);\n      t--;\n      w[t].insert(i);\n    }\n  }\n  sort(qq, qq + n);\n  a = s / n;\n  b = a + 1;\n  qb = s % n;\n  qa = n - qb;\n  for (int i = 0, ThxDem = qa; i < ThxDem; ++i) o[qq[i].second] = a;\n  for (int i = qa, ThxDem = n; i < ThxDem; ++i) o[qq[i].second] = b;\n  for (int i = 0, ThxDem = n; i < ThxDem; ++i)\n    if (q[i] < o[i]) z.insert(i);\n  for (int i = 0, ThxDem = m; i < ThxDem; ++i) {\n    int k = 0;\n    for (int t : w[i])\n      if (q[t] > o[t]) {\n        bool asd = false;\n        while (1) {\n          auto it = z.lower_bound(k);\n          if (it == z.end()) {\n            asd = true;\n            break;\n          }\n          k = *it;\n          assert(q[k] < o[k]);\n          if (w[i].count(k)) {\n            k++;\n            continue;\n          }\n          r.push_back(make_pair(make_pair(t, k), i));\n          q[t]--;\n          q[k]++;\n          if (q[k] == o[k]) z.erase(k);\n          k++;\n          break;\n        }\n        if (asd) break;\n      }\n  }\n  for (int i = 0, ThxDem = n; i < ThxDem; ++i) {\n    assert(q[i] == o[i]);\n  }\n  printf(\"%d\\n\", ((int)(r).size()));\n  for (auto p : r)\n    printf(\"%d %d %d\\n\", p.first.first + 1, p.first.second + 1, p.second + 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int l, r, x;\n  node() {}\n  node(int l, int r, int x) : l(l), r(r), x(x) {}\n};\nvector<int> vec[100010];\nint n, m;\nint vis[100010];\nvector<node> res;\nint a[100010 * 100], now[100010], nx[100010 * 100], last;\nint sze[100010];\nqueue<int> q;\nvoid add(int x, int id) {\n  a[++last] = x;\n  nx[last] = now[id];\n  now[id] = last;\n}\nint main() {\n  while (scanf(\"%d%d\", &n, &m) != EOF) {\n    int tot = 0;\n    res.clear();\n    memset(now, 0, sizeof now);\n    for (int i = 1, x, y; i <= n; ++i) {\n      scanf(\"%d\", &x);\n      tot += x;\n      vec[i].clear();\n      for (int j = 1; j <= x; ++j) {\n        scanf(\"%d\", &y);\n        vec[i].push_back(y);\n      }\n      sze[i] = vec[i].size();\n    }\n    if (tot % n == 0) {\n      int x = tot / n;\n      for (int i = 1; i <= n; ++i)\n        if (sze[i] > x)\n          for (auto it : vec[i]) add(i, it);\n      for (int i = 1; i <= m; ++i)\n        if (now[i]) q.push(i);\n      for (int i = 1, front; i <= n; ++i)\n        if (sze[i] < x) {\n          for (auto it : vec[i]) vis[it] = 1;\n          while (sze[i] < x) {\n            front = q.front();\n            q.pop();\n            if (vis[front]) {\n              q.push(front);\n              continue;\n            }\n            int id = now[front];\n            for (; id; id = nx[id]) {\n              if (sze[a[id]] <= x) continue;\n              res.push_back(node(a[id], i, front));\n              vec[i].push_back(front);\n              vis[front] = 1;\n              --sze[a[id]];\n              ++sze[i];\n              id = nx[id];\n              break;\n            }\n            if (id) q.push(front);\n            now[front] = id;\n          }\n          for (auto it : vec[i]) vis[it] = 0;\n        }\n    } else {\n      int x = tot / n + 1;\n      int need = n - tot % n;\n      for (int i = 1; i <= n; ++i)\n        if (sze[i] > x)\n          for (auto it : vec[i]) add(i, it);\n      for (int i = 1; i <= m; ++i)\n        if (now[i]) q.push(i);\n      for (int i = 1, front; i <= n; ++i)\n        if (sze[i] < x) {\n          if (sze[i] == x - 1 && need) {\n            --need;\n            continue;\n          }\n          for (auto it : vec[i]) vis[it] = 1;\n          while (sze[i] < x) {\n            if (sze[i] == x - 1 && need) {\n              --need;\n              break;\n            }\n            front = q.front();\n            q.pop();\n            if (vis[front]) {\n              q.push(front);\n              continue;\n            }\n            int id = now[front];\n            for (; id; id = nx[id]) {\n              if (sze[a[id]] <= x) continue;\n              res.push_back(node(a[id], i, front));\n              vec[i].push_back(front);\n              vis[front] = 1;\n              --sze[a[id]];\n              ++sze[i];\n              id = nx[id];\n              break;\n            }\n            if (id) q.push(front);\n            now[front] = id;\n          }\n          for (auto it : vec[i]) vis[it] = 0;\n        }\n    }\n    int len = res.size();\n    printf(\"%d\\n\", len);\n    for (int i = 0; i < len; ++i)\n      printf(\"%d %d %d\\n\", res[i].l, res[i].r, res[i].x);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntemplate <typename T1, typename T2>\ninline void mine(T1 &x, const T2 &y) {\n  if (y < x) x = y;\n}\ntemplate <typename T1, typename T2>\ninline void maxe(T1 &x, const T2 &y) {\n  if (x < y) x = y;\n}\nostream &operator<<(ostream &out, const vector<int> &b) {\n  for (auto k : b) out << k << ' ';\n  return out;\n}\nconst int MOD = 1000000007;\nconst int INF = 1000000050;\nconst long long BIG = (long long)2e18 + 50;\nconst int MX = 100010;\nconst double EPS = 1e-9;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nset<int> have[MX];\nvector<int> ids[MX];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  int s = 0;\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    s += k;\n    ids[k].push_back(i);\n    while (k--) {\n      int x;\n      cin >> x;\n      have[i].insert(x);\n    }\n  }\n  int L = s / n;\n  int R = (s + n - 1) / n;\n  int l = 0;\n  int r = m;\n  vector<vector<int> > ans;\n  while (r > R) {\n    while (ids[r].size()) {\n      int from = ids[r].back();\n      while (!ids[l].size()) ++l;\n      int to = ids[l].back();\n      int delta = min(r - R, R - l);\n      ids[r].pop_back();\n      ids[l].pop_back();\n      ids[r - delta].push_back(from);\n      ids[l + delta].push_back(to);\n      auto it = have[from].begin();\n      while (delta > 0 && it != have[from].end()) {\n        int x = *it;\n        if (have[to].find(x) == have[to].end()) {\n          it = have[from].erase(it);\n          have[to].insert(x);\n          ans.push_back({from + 1, to + 1, x});\n          --delta;\n        } else {\n          ++it;\n        }\n      }\n    }\n    --r;\n  }\n  cout << ans.size() << '\\n';\n  for (auto &x : ans) cout << x << '\\n';\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\n\npublic class A {\n\tFastScanner in;\n\tPrintWriter out;\n\tboolean systemIO = true;\n\n\tpublic int gcd(int a, int b) {\n\t\tif (a == 0) {\n\t\t\treturn b;\n\t\t}\n\t\treturn gcd(b % a, a);\n\t}\n\n\tpublic class Pair {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t}\n\n\tpublic class Str implements Comparable<Str> {\n\t\tint[] l;\n\t\tlong hash;\n\t\tint number;\n\n\t\tpublic Str(int[] l, long hash, int number) {\n\t\t\tthis.l = l;\n\t\t\tthis.hash = hash;\n\t\t\tthis.number = number;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Str o) {\n\t\t\tif (hash > o.hash) {\n\t\t\t\treturn 1;\n\t\t\t} else if (hash < o.hash) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int i = 0; i < l.length; i++) {\n\t\t\t\tif (l[i] != o.l[i]) {\n\t\t\t\t\treturn l[i] - o.l[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic class Ans {\n\t\tint from;\n\t\tint to;\n\t\tint type;\n\n\t\tpublic Ans(int from, int to, int type) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.type = type;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn from + \" \" + to + \" \" + type;\n\t\t}\n\t}\n\n\tpublic class Child implements Comparable<Child> {\n\t\tint s;\n\t\tint[] set;\n\t\tint number;\n\n\t\tpublic Child(int s, int[] set, int number) {\n\t\t\tthis.s = s;\n\t\t\tthis.set = set;\n\t\t\tthis.number = number;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Child o) {\n\t\t\treturn o.s - s;\n\t\t}\n\n\t}\n\n\tpublic void solve() {\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint sum = 0;\n\t\tArrayList<Ans> ans = new ArrayList<>();\n\t\tChild[] children = new Child[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint s = in.nextInt();\n\t\t\tint[] set = new int[s];\n\t\t\tfor (int j = 0; j < s; j++) {\n\t\t\t\tset[j] = in.nextInt();\n\t\t\t}\n\t\t\tchildren[i] = new Child(s, set, i + 1);\n\t\t\tsum += s;\n\t\t}\n\t\tint[] size = new int[n];\n\t\tfor (int i = 0; i < size.length; i++) {\n\t\t\tsize[i] = sum / n;\n\t\t}\n\t\tsum -= sum / n * n;\n\t\tfor (int i = 0; i < size.length; i++) {\n\t\t\tif (sum > 0) {\n\t\t\t\tsum--;\n\t\t\t\tsize[i]++;\n\t\t\t}\n\t\t}\n\t\tArrays.sort(children);\n\t\tint l = 0;\n\t\tint r = n - 1;\n\t\tBitSet[] set = new BitSet[n];\n\t\tfor (int i = 0; i < set.length; i++) {\n\t\t\tset[i] = null;\n\t\t}\n\t\tint[] number = new int[n];\n\t\tfor (int i = 0; i < number.length; i++) {\n\t\t\tnumber[i] = children[i].number;\n\t\t}\n\t\tint[] s = new int[n];\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\ts[i] = children[i].s;\n\t\t}\n\t\twhile (l < r) {\n\t\t\tboolean flag = false;\n\t\t\tif (size[l] == s[l]) {\n\t\t\t\tset[l] = null;\n\t\t\t\tl++;\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tif (size[r] == s[r]) {\n\t\t\t\tset[r] = null;\n\t\t\t\tr--;\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (set[l] == null) {\n\t\t\t\tset[l] = new BitSet(m + 1);\n\t\t\t\tfor (int i : children[l].set) {\n\t\t\t\t\tset[l].set(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (set[r] == null) {\n\t\t\t\tset[r] = new BitSet(m + 1);\n\t\t\t\tfor (int i : children[r].set) {\n\t\t\t\t\tset[r].set(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBitSet s1 = (BitSet) set[l].clone();\n\t\t\ts1.andNot(set[r]);\n\t\t\tint iter = Math.min(s[l] - size[l], size[r] - s[r]);\n\t\t\tint iter0 = iter;\n\t\t\tif (s[l] - size[l] == iter) {\n\t\t\t\tfor (int i = s1.nextSetBit(0); i != -1; i = s1.nextSetBit(i + 1)) {\n\t\t\t\t\tset[r].set(i);\n\t\t\t\t\tans.add(new Ans(number[l], number[r], i));\n\t\t\t\t\titer--;\n\t\t\t\t\tif (iter == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = s1.nextSetBit(0); i != -1; i = s1.nextSetBit(i + 1)) {\n\t\t\t\t\tset[l].set(i, false);\n\t\t\t\t\tans.add(new Ans(number[l], number[r], i));\n\t\t\t\t\titer--;\n\t\t\t\t\tif (iter == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts[l] -= iter0;\n\t\t\ts[r] += iter0;\n\t\t}\n\t\tout.println(ans.size());\n\t\tfor (Ans a : ans) {\n\t\t\tout.println(a.toString());\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tif (systemIO) {\n\t\t\t\tin = new FastScanner(System.in);\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t} else {\n\t\t\t\tin = new FastScanner(new File(\"input.txt\"));\n\t\t\t\tout = new PrintWriter(new File(\"output.txt\"));\n\t\t\t}\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tFastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\treturn br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\t// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\tpublic static void main(String[] arg) {\n\t\tnew A().run();\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        TreeSet<Integer> set[] = new TreeSet[n];\n        for(int i = 0; i < n; ++i)\n            set[i] = new TreeSet<>();\n\n        int size[] = new int[n];\n        int sum = 0;\n        for(int i = 0; i < n; ++i) {\n            size[i] = sc.nextInt();\n\n            sum += size[i];\n\n            for(int j = 0; j < size[i]; ++j)\n                set[i].add(sc.nextInt());\n        }\n\n        int minReq = sum / n, maxReq = minReq + 1, maxPoss = sum % n;\n\n        ArrayList<Integer> greaterIndices = new ArrayList<>();\n        ArrayList<Integer> smallerIndices = new ArrayList<>();\n\n        for(int i = 0; i < n; ++i) {\n            if(size[i] <= minReq)\n                smallerIndices.add(i);\n            else\n                greaterIndices.add(i);\n        }\n\n        int greaterPoss = min(maxPoss, greaterIndices.size()), lesserPoss = 0;\n        if(greaterPoss < maxPoss)\n            lesserPoss = maxPoss - greaterPoss;\n\n        greaterPoss = greaterIndices.size() - greaterPoss;\n\n        ArrayList<Move> moves = new ArrayList<>();\n\n        int ptr = 0;\n        ArrayList<Integer> removeList = new ArrayList<>();\n        for(int i : smallerIndices) {\n            while(size[i] < minReq || (size[i] == minReq && lesserPoss > 0)) {\n                removeList.clear();\n                int curInd = greaterIndices.get(ptr);\n\n                int j = -1;\n\n                while(set[curInd].higher(j) != null) {\n                    j = set[curInd].higher(j);\n\n                    if(!(size[i] < minReq || (size[i] == minReq && lesserPoss > 0)) || !(size[curInd] > maxReq || (size[curInd] == maxReq && greaterPoss > 0)))\n                        break;\n\n                    if(!set[i].contains(j)) {\n                        removeList.add(j);\n\n                        if(size[i] == minReq)\n                            lesserPoss--;\n                        if(size[curInd] == maxReq)\n                            greaterPoss--;\n\n                        size[i]++;\n                        size[curInd]--;\n                    }\n                }\n\n                for(int k : removeList) {\n                    set[curInd].remove(k);\n                    set[i].add(k);\n                    moves.add(new Move(curInd, i, k));\n                }\n\n                if(size[i] < minReq || (size[i] == minReq && lesserPoss > 0)) \n                    ptr++;\n            }\n        }\n\n        w.println(moves.size());\n        for(Move curMove : moves)\n            w.println(curMove);\n\n        w.close();\n    }\n}\nclass Move {\n    int from, to, kind;\n    Move(int a, int b, int c) {\n        from = a + 1;\n        to = b + 1;\n        kind = c;\n    }\n    public String toString() {\n        return from + \" \" + to + \" \" + kind;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 500005;\nint n, m, s, p, q, l, k;\nstruct node {\n  int x, y, z;\n} a[N];\nset<int> v[N];\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) f ^= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n  return f ? x : -x;\n}\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++) {\n    int x = read();\n    s += x;\n    while (x--) v[i].insert(read());\n  }\n  l = s / n, p = s % n, q = n - p;\n  for (int i = 1, j = 1;;) {\n    while (i <= n && v[i].size() >= l + !q) {\n      if (v[i].size() == l) q--;\n      i++;\n    }\n    while (j <= n && v[j].size() <= l + (bool)p) {\n      if (v[j].size() == l + 1) p--;\n      j++;\n    }\n    if (i > n || j > n) break;\n    set<int>::iterator it = v[j].begin();\n    int t = min(l - v[i].size() + !q, v[j].size() - l - (bool)p);\n    while (t) {\n      int x = *it;\n      if (*v[i].lower_bound(x) != x)\n        t--, v[i].insert(x), v[j].erase(it), a[++k] = (node){j, i, x},\n                                             it = v[j].lower_bound(x);\n      else\n        it++;\n    }\n  }\n  printf(\"%d\", k);\n  for (int i = 1; i <= k; i++) printf(\"\\n%d %d %d\", a[i].x, a[i].y, a[i].z);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint n, m, vis[maxn];\nstruct out {\n  int f, t, k;\n  out() {}\n  out(int f, int t, int k) : f(f), t(t), k(k) {}\n};\nset<pair<int, int> > S;\nset<pair<int, int> >::iterator it;\nset<int> G[maxn];\nint nu[maxn], a[maxn], sum;\nvector<out> ans;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = (int)1; i <= (int)n; i++) {\n    scanf(\"%d\", &nu[i]);\n    for (int j = (int)1; j <= (int)nu[i]; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      G[i].insert(x);\n    }\n    S.insert({nu[i], i});\n    sum += nu[i];\n  }\n  int cha, ma, mi;\n  if (sum % n == 0) {\n    ma = mi = sum / n;\n    cha = 0;\n  } else {\n    mi = sum / n, ma = mi + 1;\n    cha = 1;\n  }\n  if (n == 1) {\n    return 0 * printf(\"0\\n\");\n  }\n  pair<int, int> bi, sm;\n  it = S.begin();\n  sm = *it;\n  S.erase(it);\n  it = S.end();\n  it--;\n  bi = *it;\n  S.erase(it);\n  int br = 0;\n  while (1 && !br) {\n    vector<int> tmp, tmp1;\n    if (bi.first - sm.first <= cha) break;\n    int szb = G[bi.second].size(), szs = G[sm.second].size();\n    int tb = szb, ts = szs, f1 = 0, f2 = 0;\n    for (set<int>::iterator is = G[sm.second].begin(); is != G[sm.second].end();\n         is++) {\n      int th = *is;\n      a[th]--;\n    }\n    for (set<int>::iterator is = G[bi.second].begin(); is != G[bi.second].end();\n         is++) {\n      int th = *is;\n      a[th]++;\n      tmp1.push_back(th);\n      if (a[th] == 1) {\n        ans.push_back({bi.second, sm.second, th});\n        tb--, ts++;\n        tmp.push_back(th);\n        if (tb <= mi + cha) f1 = 1;\n        if (ts >= ma - cha) f2 = 1;\n        if (f1 && f2 || tb == mi || ts == ma) break;\n      }\n    }\n    for (int i = 0; i < tmp.size(); i++) {\n      int th = tmp[i];\n      G[sm.second].insert(th);\n      G[bi.second].erase(th);\n    }\n    if (f1 && f2) {\n      for (int i = 0; i < tmp1.size(); i++) {\n        a[tmp1[i]]--;\n      }\n      for (set<int>::iterator is = G[sm.second].begin();\n           is != G[sm.second].end(); is++) {\n        int th = *is;\n        a[th] = 0;\n      }\n      if (S.size()) {\n        it = S.begin();\n        sm = *it;\n        S.erase(it);\n      } else\n        br = 1;\n      if (S.size()) {\n        it = S.end();\n        it--;\n        bi = *it;\n        S.erase(it);\n      } else\n        br = 1;\n    } else if (tb == mi) {\n      for (int i = 0; i < tmp1.size(); i++) {\n        a[tmp1[i]]--;\n      }\n      if (S.size()) {\n        it = S.end();\n        it--;\n        bi = *it;\n        S.erase(it);\n      } else\n        br = 1;\n    } else {\n      for (int i = 0; i < tmp1.size(); i++) {\n        a[tmp1[i]]--;\n      }\n      for (set<int>::iterator is = G[sm.second].begin();\n           is != G[sm.second].end(); is++) {\n        int th = *is;\n        a[th] = 0;\n      }\n      if (S.size()) {\n        it = S.begin();\n        sm = *it;\n        S.erase(it);\n      } else\n        br = 1;\n    }\n  }\n  printf(\"%d\\n\", ans.size());\n  for (int i = 0; i < ans.size(); i++) {\n    out x = ans[i];\n    printf(\"%d %d %d\\n\", x.f, x.t, x.k);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e5 + 7;\nint n, m, sum, min_cnt, tar[N], num[N], vis[N];\nbool ban[N], gg[N];\nvector<int> V[N], P[N], T[N];\nset<int> S;\nvector<pair<pair<int, int>, int>> ans;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int s;\n    scanf(\"%d\", &s);\n    num[i] = s;\n    sum += s;\n    while (s--) {\n      int x;\n      scanf(\"%d\", &x);\n      V[i].push_back(x);\n    }\n  }\n  min_cnt = sum / n;\n  int need = sum % n;\n  for (int i = 1; i <= n && need; i++) {\n    if (num[i] >= min_cnt + 1) {\n      gg[i] = true;\n      need--;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (num[i] > min_cnt) {\n      tar[i] = gg[i] ? min_cnt + 1 : min_cnt;\n      if (num[i] > tar[i]) {\n        for (auto &t : V[i]) {\n          P[t].push_back(i);\n        }\n      }\n    } else if (num[i] < min_cnt || need && num[i] == min_cnt) {\n      if (need)\n        tar[i] = min_cnt + 1, need--;\n      else\n        tar[i] = min_cnt;\n      for (auto &t : V[i]) {\n        T[t].push_back(i);\n      }\n      S.insert(i);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    for (auto &id : T[i]) {\n      vis[id] = i;\n    }\n    int pt = 0;\n    while (pt < P[i].size() && ban[P[i][pt]]) pt++;\n    vector<int> del;\n    for (auto &id : S) {\n      if (pt >= P[i].size()) break;\n      if (vis[id] == i) continue;\n      ans.push_back(make_pair(make_pair(P[i][pt], id), i));\n      num[P[i][pt]]--;\n      if (num[P[i][pt]] == tar[P[i][pt]]) {\n        ban[P[i][pt]] = true;\n      }\n      num[id]++;\n      if (num[id] == tar[id]) {\n        del.push_back(id);\n      }\n      pt++;\n      while (pt < P[i].size() && ban[P[i][pt]]) pt++;\n    }\n    for (auto &id : del) S.erase(id);\n  }\n  printf(\"%d\\n\", (int)ans.size());\n  for (auto &t : ans) {\n    printf(\"%d %d %d\\n\", t.first.first, t.first.second, t.second);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct box {\n  int id, to;\n  set<int> items;\n};\nstruct offert {\n  int type, where;\n  bool operator<(const offert &x) const {\n    return (type == x.type) ? (where < x.where) : (type < x.type);\n  }\n};\nstruct moves {\n  int x, y, z;\n};\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  int s = 0;\n  vector<box> a(n);\n  for (auto &i : a) {\n    i.id = &i - &a[0];\n    int k, x;\n    cin >> k;\n    s += k;\n    while (k--) {\n      cin >> x;\n      i.items.insert(x);\n    }\n  }\n  vector<int> ord(n);\n  iota(ord.begin(), ord.end(), 0);\n  sort(ord.begin(), ord.end(), [&](const int &x, const int &y) {\n    return a[x].items.size() < a[y].items.size();\n  });\n  int l = s / n, r = (s + n - 1) / n, cnt = s - l * n;\n  set<offert> q, can;\n  for (auto &x : ord) {\n    auto &i = a[x];\n    i.to = l + (n - (&x - &ord[0]) <= cnt);\n    if (i.items.size() > i.to)\n      for (auto j : i.items) q.insert({j, i.id});\n  }\n  auto try_add = [&](set<int> &t, int j) {\n    auto nxt = q.upper_bound({j, 1 << 30});\n    auto prv = q.lower_bound({j, -1});\n    if (prv == q.begin())\n      prv = q.end();\n    else\n      prv = prev(prv);\n    if (prv != q.end() && t.find(prv->type) == t.end()) {\n      can.insert(*prv);\n      q.erase(prv);\n    }\n    if (nxt != q.end() && t.find(nxt->type) == t.end()) {\n      can.insert(*nxt);\n      q.erase(nxt);\n    }\n  };\n  vector<moves> op;\n  for (auto &i : a)\n    if (i.items.size() < i.to) {\n      can.clear();\n      for (auto j : i.items) try_add(i.items, j);\n      if (i.items.empty()) {\n        can.insert(*q.begin());\n        q.erase(q.begin());\n      }\n      for (; i.items.size() < i.to;) {\n        auto it = can.begin();\n        while (i.items.find(it->type) != i.items.end()) {\n          q.insert(*it);\n          can.erase(it);\n          it = can.begin();\n        }\n        op.push_back({it->where, i.id, it->type});\n        i.items.insert(it->type);\n        auto val = *it;\n        can.erase(it);\n        a[val.where].items.erase(val.type);\n        if (a[val.where].items.size() == a[val.where].to) {\n          for (auto z : a[val.where].items) {\n            q.erase({z, val.where});\n            can.erase({z, val.where});\n          }\n          for (auto z : a[val.where].items) try_add(i.items, z);\n        }\n        try_add(i.items, val.type);\n      }\n      for (auto o : can) q.insert(o);\n    }\n  cout << op.size() << \"\\n\";\n  for (auto &i : op) cout << i.x + 1 << \" \" << i.y + 1 << \" \" << i.z << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\", \"unroll-loops\")\nusing namespace std;\ntemplate <class T>\ninline void sort(T &a) {\n  sort((a).begin(), (a).end());\n}\ntemplate <class T>\ninline void rsort(T &a) {\n  sort((a).rbegin(), (a).rend());\n}\ntemplate <class T>\ninline void reverse(T &a) {\n  reverse((a).begin(), (a).end());\n}\ntemplate <class T, class U>\ninline void checkmin(T &x, U y) {\n  if (x > y) x = y;\n}\ntemplate <class T, class U>\ninline void checkmax(T &x, U y) {\n  if (x < y) x = y;\n}\nstruct bag : public set<int> {\n  int ind;\n};\nbool cmp(const bag &a, const bag &b) { return int(a.size()) > int(b.size()); }\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout << fixed << setprecision(20);\n  srand(time(nullptr));\n  int n, m;\n  cin >> n >> m;\n  vector<bag> arr(n);\n  int sumb = 0;\n  for (int i = 0; i < n; ++i) {\n    int c;\n    cin >> c;\n    sumb += c;\n    for (int j = 0; j < c; ++j) {\n      int k;\n      cin >> k;\n      arr[i].insert(k);\n    }\n    arr[i].ind = i;\n  }\n  sort((arr).begin(), (arr).end(), cmp);\n  vector<int> first(n);\n  for (int i = 0; i < n; ++i) first[i] = sumb / n + (sumb % n > i);\n  int ptra = 0, ptrb = n - 1;\n  vector<vector<int>> ans;\n  while (ptra<ptrb &&int(arr[ptra].size())> first[ptra]) {\n    int x = *(arr[ptra].begin());\n    while (int(arr[ptra].size()) > first[ptra] &&\n           int(arr[ptrb].size()) < first[ptrb]) {\n      if (!arr[ptrb].count(x)) {\n        arr[ptra].erase(x);\n        arr[ptrb].insert(x);\n        ans.push_back({arr[ptra].ind, arr[ptrb].ind, x});\n      }\n      auto it = arr[ptra].upper_bound(x);\n      if (it == arr[ptra].end()) break;\n      x = *it;\n    }\n    if (int(arr[ptra].size()) == first[ptra]) ++ptra;\n    if (int(arr[ptrb].size()) == first[ptrb]) --ptrb;\n  }\n  cout << int(ans.size()) << '\\n';\n  for (auto i : ans) cout << i[0] + 1 << ' ' << i[1] + 1 << ' ' << i[2] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> se[100500];\nvector<int> a[100500], nxt[100500], lst[100500];\nvector<bool> tp[100500];\nint mns[100500], ps[100500];\nbool cmp(int x, int y) { return int(se[x].size()) > int(se[y].size()); }\nint main() {\n  ios_base::sync_with_stdio(0);\n  iostream::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  int sum = 0;\n  int f[n];\n  vector<int> vr(n);\n  for (int i = 0; i < n; i++) {\n    vr[i] = i;\n    int len;\n    cin >> len;\n    sum += len;\n    nxt[i].resize(len);\n    lst[i].resize(len);\n    tp[i].resize(len, 0);\n    for (int j = 0; j < len; j++) {\n      nxt[i][j] = j + 1;\n      lst[i][j] = j - 1;\n      int x;\n      cin >> x;\n      se[i].insert(x);\n      a[i].push_back(x);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    f[i] = sum / n;\n    if (sum % n != 0) {\n      f[i]++;\n      sum--;\n    }\n  }\n  sort(vr.begin(), vr.end(), cmp);\n  int l = 0, r = n - 1;\n  vector<array<int, 3> > ans;\n  ans.clear();\n  while (l < r) {\n    int nm = vr[l], id = vr[r];\n    if (f[l] == int(se[nm].size()) - mns[nm]) {\n      l++;\n      continue;\n    }\n    if (f[r] == int(se[id].size())) {\n      r--;\n      continue;\n    }\n    int i = ps[nm];\n    while (i < int(a[nm].size()) && f[l] != int(se[nm].size()) - mns[nm] &&\n           f[r] != int(se[id].size())) {\n      int val = a[nm][i];\n      if (!tp[nm][i] && se[id].find(val) == se[id].end()) {\n        ans.push_back({nm + 1, id + 1, val});\n        se[id].insert(val);\n        mns[nm]++;\n        int j = lst[nm][i];\n        int nx = nxt[nm][i];\n        if (nx != n) lst[nm][nx] = j;\n        if (j != -1) nxt[nm][j] = nx;\n        tp[nm][i] = 1;\n        while (ps[nm] < int(a[nm].size()) && tp[nm][ps[nm]]) ps[nm]++;\n      }\n      i = nxt[nm][i];\n    }\n  }\n  cout << int(ans.size()) << '\\n';\n  ;\n  for (auto it : ans) cout << it[0] << \" \" << it[1] << \" \" << it[2] << '\\n';\n  ;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long powmod(long long a, long long b) {\n  long long res = 1;\n  a %= mod;\n  assert(b >= 0);\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a % mod;\n    a = a * a % mod;\n  }\n  return res;\n}\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nconst int N = 110007;\nint n, m;\nstruct node {\n  int num;\n  int id;\n} a[N];\nint f[N];\nvector<int> pv[N], t;\nint tot;\nint ans;\nint s[N];\nint b[N];\nint l, r;\nbool cmp(node p, node q) { return p.num > q.num; }\nvoid gao(node &x, node &y, int z) {\n  int i, o;\n  for (i = 0; i < y.num; i++) {\n    b[pv[y.id][i]] = 1;\n  }\n  for (i = x.num - 1; z; i--) {\n    int tmp = pv[x.id][i];\n    if (b[tmp] == 0) {\n      pv[y.id].push_back(tmp);\n      y.num++;\n      z--;\n      printf(\"%d %d %d\\n\", x.id, y.id, tmp);\n    } else {\n      t.push_back(tmp);\n    }\n    pv[x.id][i] = 0;\n    x.num--;\n  }\n  for (i = 0; i < y.num; i++) b[pv[y.id][i]] = 0;\n  for (o = t.size(); o--;) {\n    pv[x.id][x.num++] = t[o];\n  }\n  t.clear();\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int o;\n    scanf(\"%d\", &o);\n    a[i].num = o;\n    a[i].id = i;\n    for (int j = 1; j <= o; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      pv[i].push_back(x);\n    }\n    tot += a[i].num;\n  }\n  sort(a + 1, a + n + 1, cmp);\n  for (int i = 1; i <= n; i++) {\n    f[i] = tot / n;\n    if (i <= (tot % n)) f[i] += 1;\n    if (a[i].num > f[i]) ans += a[i].num - f[i];\n  }\n  printf(\"%d\\n\", ans);\n  l = 1;\n  r = n;\n  while (l < r) {\n    int x = a[l].id;\n    int y = a[r].id;\n    if (a[l].num == f[l]) {\n      l++;\n      continue;\n    }\n    if (a[r].num == f[r]) {\n      r--;\n      continue;\n    }\n    int z = min(a[l].num - f[l], f[r] - a[r].num);\n    gao(a[l], a[r], z);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nset<int> S[100001];\nint need[100001];\nint nC[100001];\nint oC[100001];\nint nSeg[1 << 18];\nvoid update(int i, int s, int e, int x, int v) {\n  nSeg[i] += v;\n  if (s == e) return;\n  int m = (s + e) / 2;\n  if (x <= m)\n    update(i << 1, s, m, x, v);\n  else\n    update(i << 1 | 1, m + 1, e, x, v);\n}\nstruct segtree {\n  struct node {\n    node *l, *r;\n    int cnt;\n    node() : l(0), r(0), cnt(0) {}\n  } * rt;\n  segtree() : rt(0) {}\n  void update(node *&p, int s, int e, int x, int v) {\n    if (p == 0) p = new node();\n    p->cnt += v;\n    if (s == e) return;\n    int m = (s + e) / 2;\n    if (x <= m)\n      update(p->l, s, m, x, v);\n    else\n      update(p->r, m + 1, e, x, v);\n  }\n  void insert(int x) { update(rt, 1, n, x, 1); }\n  void erase(int x) { update(rt, 1, n, x, -1); }\n  int get(node *&p, int i, int s, int e) {\n    if (p == 0) p = new node();\n    if (p->cnt == nSeg[i]) return -1;\n    p->cnt += 1;\n    if (s == e) return s;\n    int m = (s + e) / 2;\n    int ret = get(p->l, i << 1, s, m);\n    if (ret != -1) return ret;\n    return get(p->r, i << 1 | 1, m + 1, e);\n  }\n  int get() { return get(rt, 1, 1, n); }\n} ncontain[100001];\nset<int> contain[100001];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> m;\n  int C = 0;\n  for (int i = 1; i <= n; ++i) {\n    int s;\n    cin >> s;\n    C += s;\n    while (s--) {\n      int x;\n      cin >> x;\n      S[i].insert(x);\n    }\n  }\n  int D = (C + n - 1) / n;\n  int R = D * n - C;\n  vector<int> ord;\n  for (int i = 1; i <= n; ++i) ord.push_back(i);\n  sort(ord.begin(), ord.end(),\n       [&](int i, int j) { return S[i].size() < S[j].size(); });\n  for (int i = 0; i < n; ++i) {\n    if (i < R)\n      need[ord[i]] = D - 1;\n    else\n      need[ord[i]] = D;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (S[i].size() < need[i]) update(1, 1, n, i, 1);\n    for (int j : S[i]) {\n      if (S[i].size() < need[i]) ++nC[j], ncontain[j].insert(i);\n      if (S[i].size() > need[i]) ++oC[j], contain[j].insert(i);\n    }\n  }\n  vector<int> can;\n  for (int i = 1; i <= m; ++i)\n    if (nC[i] < nSeg[1] && oC[i] > 0) can.push_back(i);\n  vector<pair<pair<int, int>, int>> ans;\n  while (!can.empty()) {\n    int x = can.back();\n    can.pop_back();\n    if (nC[x] == nSeg[1] || oC[x] == 0) continue;\n    int from = *contain[x].begin();\n    contain[x].erase(contain[x].begin());\n    int to = ncontain[x].get();\n    ans.emplace_back(pair<int, int>(from, to), x);\n    S[from].erase(x);\n    S[to].insert(x);\n    ++nC[x];\n    --oC[x];\n    if (S[from].size() == need[from]) {\n      for (int i : S[from]) {\n        --oC[i];\n        contain[i].erase(from);\n      }\n    }\n    if (S[to].size() == need[to]) {\n      update(1, 1, n, to, -1);\n      for (int i : S[to]) {\n        --nC[i];\n        ncontain[i].erase(to);\n      }\n    }\n    if (nC[x] < nSeg[1] && oC[x] > 0) can.push_back(x);\n  }\n  printf(\"%u\\n\", ans.size());\n  for (auto i : ans) {\n    printf(\"%d %d %d\\n\", i.first.first, i.first.second, i.second);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint h[2][100005], n, m, tot = 0, ans[5 * 100005][3], fin = 0;\nset<int> trans;\nset<int> hv[100005];\nvoid transR(int id, int val) {\n  if (!h[0][id] && h[1][id]) trans.erase(id);\n  h[1][id] += val;\n  if (!h[0][id] && h[1][id]) trans.insert(id);\n}\nvoid transL(int id, int val) {\n  if (!h[0][id] && h[1][id]) trans.erase(id);\n  h[0][id] += val;\n  if (!h[0][id] && h[1][id]) trans.insert(id);\n}\nvoid give(int from, int to, int g) {\n  hv[from].erase(g);\n  hv[to].insert(g);\n  transR(g, -1);\n  transL(g, 1);\n  ans[fin][0] = from, ans[fin][1] = to, ans[fin][2] = g;\n  fin++;\n}\nint main() {\n  memset(h, 0, sizeof(h));\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    int a;\n    cin >> a;\n    tot += a;\n    for (int j = 0; j < a; j++) {\n      int b;\n      cin >> b;\n      hv[i].insert(b);\n    }\n  }\n  vector<int> v(n + 5);\n  for (int i = 1; i <= n; i++) v[i] = i;\n  sort(v.begin() + 1, v.begin() + n + 1, [&](int &a, int &b) {\n    return (int)(hv[a].size()) < (int)(hv[b].size());\n  });\n  for (auto &i : hv[v[n]]) transR(i, 1);\n  for (auto &i : hv[v[1]]) transL(i, 1);\n  int tgt = tot / n, rem = tot % n;\n  for (int i = 1, j = n; i < j;) {\n    int tr = tgt;\n    if (n - j + 1 <= rem) tr++;\n    if (hv[v[j]].size() == tr) {\n      for (auto &k : hv[v[j]]) transR(k, -1);\n      j--;\n      for (auto &k : hv[v[j]]) transR(k, 1);\n      continue;\n    }\n    int tl = tgt;\n    if (n - i + 1 <= rem) tl++;\n    if (hv[v[i]].size() == tl) {\n      for (auto &k : hv[v[i]]) transL(k, -1);\n      i++;\n      for (auto &k : hv[v[i]]) transL(k, 1);\n      continue;\n    }\n    give(v[j], v[i], (*trans.begin()));\n  }\n  cout << fin << '\\n';\n  for (int i = 0; i < fin; i++)\n    cout << ans[i][0] << ' ' << ans[i][1] << ' ' << ans[i][2] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nlong long gcd(long long a, long long b) { return (a == 0) ? b : gcd(b % a, a); }\nlong long cnt1(long long x) {\n  long long cnt = 0;\n  while (x > 0) x &= x - 1, cnt++;\n  return cnt;\n}\nlong long fact(long long n) { return n == 0 ? 1LL : n * fact(n - 1); }\nlong long fact(long long n, long long p) {\n  return n == 0 ? 1LL : n * fact(n - 1) % p;\n}\nlong long cnk(long long n, long long k) {\n  return n == 1 || k == 1 ? 1 : cnk(n - 1, k) + cnk(n - 1, k - 1);\n}\nlong long pow(long long a, long long n, long long p) {\n  if (n == 0) return 1;\n  long long t = pow(a, n / 2, p);\n  return t * t % p * (n % 2 ? a : 1) % p;\n}\nlong long back(long long x, long long p) { return pow(x, p - 2, p); }\nlong long cnk(long long n, long long k, long long p) {\n  return fact(n, p) * back(fact(k, p), p) % p * back(fact(n - k, p), p) % p;\n}\ntemplate <class T>\nistream &operator>>(istream &stream, vector<T> &v) {\n  for (long long i = 0; i < (long long)v.size(); i++) stream >> v[i];\n  return stream;\n}\ntemplate <class T>\nostream &operator<<(ostream &stream, vector<T> v) {\n  for (long long i = 0; i < (long long)v.size(); i++) stream << v[i] << ' ';\n  stream << '\\n';\n  return stream;\n}\ntemplate <class A, class B>\nistream &operator>>(istream &stream, pair<A, B> &p) {\n  return stream >> p.first >> p.second;\n}\nstruct Node {\n  Node *l = 0, *r = 0;\n  long long s = 0;\n};\ninline Node *get_ch(Node *v) {\n  if (v == 0)\n    return new Node;\n  else\n    return v;\n}\ninline void get(Node *&v) {\n  v->l = get_ch(v->l);\n  v->r = get_ch(v->r);\n}\nvoid update(Node *v, long long l, long long r, long long pos, long long x) {\n  if (r - l == 1)\n    v->s = x;\n  else {\n    long long m = (r + l) >> 1;\n    get(v);\n    if (pos < m)\n      update(v->l, l, m, pos, x);\n    else\n      update(v->r, m, r, pos, x);\n    v->s = v->l->s + v->r->s;\n  }\n}\nlong long find(Node *a, Node *b, long long l, long long r) {\n  if (r - l == 1)\n    return l;\n  else {\n    long long m = (r + l) >> 1;\n    get(a);\n    get(b);\n    if (a->l->s > b->l->s)\n      return find(a->l, b->l, l, m);\n    else\n      return find(a->r, b->r, m, r);\n  }\n}\nsigned main() {\n  srand(time(0));\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  vector<Node *> t(n);\n  for (long long i = 0; i < n; i++) t[i] = new Node;\n  set<pair<long long, long long>> sz;\n  long long sum = 0;\n  for (long long i = 0; i < n; i++) {\n    long long x;\n    cin >> x;\n    for (long long j = 0; j < x; j++) {\n      long long pos;\n      cin >> pos;\n      pos--;\n      update(t[i], 0, m, pos, 1);\n    }\n    sz.insert({x, i});\n    sum += x;\n  }\n  vector<vector<long long>> ans;\n  long long need = sum / n;\n  while (sz.begin()->first < need || sz.rbegin()->first > need + 1) {\n    long long v = sz.begin()->second, u = sz.rbegin()->second;\n    long long x = sz.begin()->first, y = sz.rbegin()->first;\n    sz.erase(sz.begin());\n    sz.erase(prev(sz.end()));\n    sz.insert({x + 1, v});\n    sz.insert({y - 1, u});\n    long long pos = find(t[u], t[v], 0, m);\n    update(t[u], 0, m, pos, 0);\n    update(t[v], 0, m, pos, 1);\n    ans.push_back({u + 1, v + 1, pos + 1});\n  }\n  cout << ans.size() << '\\n';\n  for (long long i = 0; i < ans.size(); i++) cout << ans[i];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntemplate <typename T1, typename T2>\ninline bool upmax(T1& a, T2 b) {\n  return (a < b ? (a = b, true) : false);\n}\ntemplate <typename T1, typename T2>\ninline bool upmin(T1& a, T2 b) {\n  return (b < a ? (a = b, true) : false);\n}\nconst int maxn = (int)1e5 + 5;\nconst int maxlog = 21;\nconst int base = (int)1e9 + 7;\nconst long double eps = (long double)1e-9;\nconst long double PI = acos(-1.);\nconst long long llinf = 1e18;\nconst int inf = 2e9;\nstruct node {\n  int cnt;\n  node *l, *r;\n  node() {\n    cnt = 0;\n    l = 0;\n    r = 0;\n  }\n};\nint getcnt(node* v) {\n  if (!v) return 0;\n  return v->cnt;\n}\nvoid upd(node* v) { v->cnt = getcnt(v->l) + getcnt(v->r); }\nvoid add(node* v, int tl, int tr, int pos, int x) {\n  if (tl == tr) {\n    v->cnt += x;\n    assert(v->cnt == 0 || v->cnt == 1);\n    return;\n  }\n  int tm = (tl + tr) >> 1;\n  if (pos <= tm) {\n    if ((v->l) == 0) {\n      v->l = new node();\n    }\n    add(v->l, tl, tm, pos, x);\n  } else {\n    if ((v->r) == 0) {\n      v->r = new node();\n    }\n    add(v->r, tm + 1, tr, pos, x);\n  }\n  upd(v);\n}\nnode* getleft(node* v) {\n  if (!v) return 0;\n  return v->l;\n}\nnode* getright(node* v) {\n  if (!v) return 0;\n  return v->r;\n}\nint diff(node* v1, node* v2, int tl, int tr) {\n  assert(getcnt(v1) != getcnt(v2));\n  if (tl == tr) {\n    assert(getcnt(v2) != 0);\n    return tl;\n  }\n  int tm = (tl + tr) >> 1;\n  if (getcnt(getleft(v1)) < getcnt(getleft(v2))) {\n    return diff(getleft(v1), getleft(v2), tl, tm);\n  } else {\n    return diff(getright(v1), getright(v2), tm + 1, tr);\n  }\n}\nnode* root[maxn];\nvoid gen() {\n  ofstream cout(\"input.txt\");\n  int n = rand() % 10 + 1, m = rand() % 10 + 1;\n  cout << n << ' ' << m << endl;\n  for (int i = 0; i < n; i++) {\n    int x = rand() % (m + 1);\n    set<int> second;\n    for (int j = 0; j < x; j++) second.insert(rand() % m + 1);\n    cout << second.size() << ' ';\n    for (int x : second) cout << x << ' ';\n    cout << endl;\n  }\n}\nint main() {\n  srand(time(0));\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) root[i] = new node();\n  if (n == 1) {\n    cout << 0 << endl;\n    return 0;\n  }\n  set<pair<int, int> > q;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    q.insert(make_pair(x, i));\n    while (x--) {\n      int y;\n      cin >> y;\n      y--;\n      add(root[i], 0, m - 1, y, +1);\n    }\n  }\n  vector<tuple<int, int, int> > ans;\n  while (1) {\n    auto i = q.begin()->second;\n    auto j = (--q.end())->second;\n    int s1 = q.begin()->first;\n    int s2 = (--q.end())->first;\n    q.erase(q.begin());\n    q.erase(--q.end());\n    if (s2 - s1 <= 1) {\n      break;\n    }\n    int pos = diff(root[i], root[j], 0, m - 1);\n    ans.push_back(make_tuple(j + 1, i + 1, pos + 1));\n    add(root[i], 0, m - 1, pos, +1);\n    add(root[j], 0, m - 1, pos, -1);\n    q.insert(make_pair(s1 + 1, i));\n    q.insert(make_pair(s2 - 1, j));\n  }\n  cout << ans.size() << \"\\n\";\n  for (int i = 0; i < ans.size(); i++) {\n    int a, b, c;\n    tie(a, b, c) = ans[i];\n    cout << a << ' ' << b << ' ' << c << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int INF = 2000000005;\nconst long long BIG_INF = 2000000000000000005;\nconst int mod = 1000000007;\nconst int P = 31;\nconst long double PI = 3.141592653589793238462643;\nconst double eps = 1e-9;\nusing namespace std;\nvector<pair<int, int>> dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\nbool valid(int x, int y, int n, int m) {\n  return x >= 0 && y >= 0 && x < n && y < m;\n}\nmt19937 rng(1999999973);\nconst int N = 100000 + 50;\nint sum = 0, n, m, order[N], need[N];\nunordered_set<int> box[N];\nbool comp(int x, int y) { return box[x].size() > box[y].size(); }\nvector<vector<int>> ans;\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    int t;\n    cin >> t;\n    sum += t;\n    for (int j = 0; j < t; j++) {\n      int cur;\n      cin >> cur;\n      box[i].insert(cur);\n    }\n    order[i] = i;\n  }\n  sort(order, order + n, comp);\n  for (int i = 0; i < sum; i++) need[i % n]++;\n  vector<int> to_erase;\n  int l = 0, r = n - 1;\n  while (l < r) {\n    while (l < r && box[order[r]].size() == need[r]) r--;\n    while (l < r && box[order[l]].size() == need[l]) l++;\n    for (auto it = box[order[l]].begin(); it != box[order[l]].end(); it++) {\n      if (box[order[r]].find(*it) == box[order[r]].end()) {\n        to_erase.push_back(*it);\n        box[order[r]].insert(*it);\n        ans.push_back({order[l] + 1, order[r] + 1, *it});\n        if (box[order[l]].size() - to_erase.size() == need[l] ||\n            box[order[r]].size() == need[r])\n          break;\n      }\n    }\n    while (!to_erase.empty()) {\n      box[order[l]].erase(to_erase.back());\n      to_erase.pop_back();\n    }\n  }\n  cout << ans.size() << '\\n';\n  for (int i = 0; i < ans.size(); i++) {\n    cout << ans[i][0] << \" \" << ans[i][1] << \" \" << ans[i][2] << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\nusing ld = long double;\nusing ll = long long;\nconst int inf = 1e9, mod = 1e9 + 7;\nconst ll INF = 9e18;\nconst ld EPS = 1e-9, PI = acosl(-1.0);\nconst int N = 1e5 + 5;\nint n, m, tot = 0;\nV<V<int>> b(N);\nV<V<int>> toy(N);\nunordered_set<int> toyset[N];\nV<int> ind(N);\nV<int> gt(N, -1), a(N);\nint main() {\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> m;\n  for (int i = 0, _i = (n); i < _i; ++i) {\n    int s;\n    cin >> s;\n    for (int j = 0, _j = (s); j < _j; ++j) {\n      int x;\n      cin >> x;\n      b[i].push_back(x);\n      tot++;\n    }\n  }\n  V<int> v;\n  for (int i = 0, _i = (n); i < _i; ++i) v.push_back(i);\n  sort(v.begin(), v.end(),\n       [&](int l, int r) { return b[l].size() > b[r].size(); });\n  for (int i = 0, _i = (n); i < _i; ++i) ind[v[i]] = i;\n  priority_queue<P<int, int>, V<P<int, int>>, greater<P<int, int>>> minh;\n  priority_queue<P<int, int>> maxh;\n  for (int i = 0, _i = (n); i < _i; ++i) minh.push({b[ind[i]].size(), -i});\n  for (int i = 0, _i = (n); i < _i; ++i) maxh.push({b[ind[i]].size(), -i});\n  int k = inf, k2 = -1;\n  for (int i = 0, _i = (n); i < _i; ++i) a[i] = b[ind[i]].size();\n  while ((!maxh.empty() && !minh.empty()) &&\n         maxh.top().first - minh.top().first > 1) {\n    auto mx = maxh.top();\n    if (gt[-mx.second] == 0) {\n      maxh.pop();\n      continue;\n    }\n    auto mn = minh.top();\n    if (gt[-mn.second] == 1) {\n      minh.pop();\n      continue;\n    }\n    minh.pop();\n    maxh.pop();\n    gt[-mx.second] = 1;\n    gt[-mn.second] = 0;\n    mx.first--;\n    mn.first++;\n    maxh.push(mx);\n    minh.push(mn);\n  }\n  V<int> final(N);\n  while (!maxh.empty()) {\n    auto cur = maxh.top();\n    maxh.pop();\n    if (gt[-cur.second] == 1) final[-cur.second] = cur.first;\n  }\n  while (!minh.empty()) {\n    auto cur = minh.top();\n    minh.pop();\n    if (!gt[-cur.second]) final[-cur.second] = cur.first;\n  }\n  unordered_set<int> takers;\n  for (int i = 0, _i = (n); i < _i; ++i) {\n    if (!gt[i] && a[i] != final[i]) takers.insert(i);\n    for (int t : b[ind[i]]) {\n      if (gt[i] == 1) toy[t].push_back(i);\n      toyset[t].insert(i);\n    }\n  }\n  V<P<P<int, int>, int>> output;\n  for (int i = (1), _i = (m + 1); i < _i; ++i) {\n    int l = 0;\n    V<int> rem;\n    for (int t : takers) {\n      int box;\n      while (l < toy[i].size()) {\n        box = toy[i][l];\n        if (a[box] != final[box]) break;\n        l++;\n      }\n      if (l == toy[i].size()) break;\n      if (toyset[i].find(t) != toyset[i].end()) continue;\n      a[t]++;\n      a[box]--;\n      if (a[t] == final[t]) rem.push_back(t);\n      output.push_back({{box, t}, i});\n      l++;\n    }\n    for (int x : rem) takers.erase(x);\n  }\n  cout << output.size() << '\\n';\n  for (auto cur : output) {\n    cout << ind[cur.first.first] + 1 << \" \" << ind[cur.first.second] + 1 << \" \"\n         << cur.second << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 1, SN = 320;\nset<int> st[N];\nint cntLight[N];\nset<int> heavy[N];\nint sqCntLight[N][SN], sqTotalLight[SN];\nint totalLight, totalHeavy;\nvoid addLight(int i) {\n  totalLight++;\n  sqTotalLight[i / SN]++;\n  for (auto x : st[i]) {\n    cntLight[x]++;\n    sqCntLight[x][i / SN]++;\n  }\n}\nvoid addHeavy(int i) {\n  totalHeavy++;\n  for (auto x : st[i]) {\n    heavy[x].insert(i);\n  }\n}\nvoid removeLight(int i) {\n  totalLight--;\n  sqTotalLight[i / SN]--;\n  for (auto x : st[i]) {\n    cntLight[x]--;\n    sqCntLight[x][i / SN]--;\n  }\n}\nvoid removeHeavy(int i) {\n  totalHeavy--;\n  for (auto x : st[i]) {\n    heavy[x].erase(i);\n  }\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  int total = 0;\n  for (int i = 0; i < n; i++) {\n    int s;\n    cin >> s;\n    total += s;\n    for (int j = 0; j < s; j++) {\n      int val;\n      cin >> val;\n      st[i].insert(val);\n    }\n  }\n  int goodL, goodR;\n  if (total % n == 0) {\n    goodL = goodR = total / n;\n  } else {\n    goodL = total / n;\n    goodR = goodL + 1;\n  }\n  for (int i = 0; i < n; i++) {\n    if (st[i].size() < goodL) {\n      addLight(i);\n    }\n    if (st[i].size() > goodR) {\n      addHeavy(i);\n    }\n  }\n  vector<int> from, to, kind;\n  for (int iter = 0; iter < 2; iter++) {\n    for (int i = 1; i <= m; i++) {\n      while (cntLight[i] < totalLight && !heavy[i].empty()) {\n        int hi = *heavy[i].begin();\n        heavy[i].erase(heavy[i].begin());\n        st[hi].erase(i);\n        if (st[hi].size() <= goodR) {\n          removeHeavy(hi);\n        }\n        int li = -1;\n        for (int bl = 0; bl <= (n - 1) / SN; bl++) {\n          if (sqCntLight[i][bl] < sqTotalLight[bl]) {\n            for (int k = bl * SN; k < (bl + 1) * SN; k++) {\n              if (st[k].size() < goodL && !st[k].count(i)) {\n                li = k;\n                break;\n              }\n            }\n            break;\n          }\n        }\n        cntLight[i]++;\n        sqCntLight[i][li / SN]++;\n        st[li].insert(i);\n        if (st[li].size() >= goodL) {\n          removeLight(li);\n        }\n        from.push_back(hi + 1);\n        to.push_back(li + 1);\n        kind.push_back(i);\n      }\n    }\n    if (totalHeavy) {\n      for (int i = 0; i < n; i++) {\n        if (st[i].size() == goodL) {\n          addLight(i);\n        }\n      }\n      goodL++;\n    } else if (totalLight) {\n      for (int i = 0; i < n; i++) {\n        if (st[i].size() == goodR) {\n          addHeavy(i);\n        }\n      }\n    }\n  }\n  cout << from.size() << endl;\n  for (int i = 0; i < from.size(); i++) {\n    cout << from[i] << \" \" << to[i] << \" \" << kind[i] << endl;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int)1e9 + 23111992;\nconst long long LINF = (long long)1e18 + 23111992;\nconst long double PI = acos((long double)-1);\nconst long double EPS = 1e-9;\ninline long long gcd(long long a, long long b) {\n  long long r;\n  while (b) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\ninline long long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\ninline long long fpow(long long n, long long k, int p = MOD) {\n  long long r = 1;\n  for (; k; k >>= 1) {\n    if (k & 1) r = r * n % p;\n    n = n * n % p;\n  }\n  return r;\n}\ntemplate <class T>\ninline int chkmin(T& a, const T& val) {\n  return val < a ? a = val, 1 : 0;\n}\ntemplate <class T>\ninline int chkmax(T& a, const T& val) {\n  return a < val ? a = val, 1 : 0;\n}\ninline unsigned long long isqrt(unsigned long long k) {\n  unsigned long long r = sqrt(k) + 1;\n  while (r * r > k) r--;\n  return r;\n}\ninline long long icbrt(long long k) {\n  long long r = cbrt(k) + 1;\n  while (r * r * r > k) r--;\n  return r;\n}\ninline void addmod(int& a, int val, int p = MOD) {\n  if ((a = (a + val)) >= p) a -= p;\n}\ninline void submod(int& a, int val, int p = MOD) {\n  if ((a = (a - val)) < 0) a += p;\n}\ninline int mult(int a, int b, int p = MOD) { return (long long)a * b % p; }\ninline int inv(int a, int p = MOD) { return fpow(a, p - 2, p); }\ninline int sign(long double x) { return x < -EPS ? -1 : x > +EPS; }\ninline int sign(long double x, long double y) { return sign(x - y); }\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int myrand() { return abs((int)mt()); }\nstruct node_t {\n  node_t *l, *r;\n  int cnt;\n  node_t(node_t* l = 0, node_t* r = 0, int cnt = 0) : l(l), r(r), cnt(cnt) {}\n};\nnode_t* upd(node_t* p, int i, int L, int R, int val) {\n  if (!p) p = new node_t();\n  if (i < L || R < i) return p;\n  if (L == R) {\n    return new node_t(p->l, p->r, p->cnt + val);\n  }\n  node_t* res = new node_t(p->l, p->r);\n  res->l = upd(res->l, i, L, L + R >> 1, val);\n  res->r = upd(res->r, i, (L + R >> 1) + 1, R, val);\n  res->cnt = res->l->cnt + res->r->cnt;\n  return res;\n}\nint cnt(node_t* p) { return p ? p->cnt : 0; }\nint query(node_t* p, node_t* q, int L, int R) {\n  if (!p) p = new node_t();\n  if (!q) q = new node_t();\n  if (L == R) {\n    return L;\n  }\n  if (cnt(p->l) > cnt(q->l)) {\n    return query(p->l, q->l, L, L + R >> 1);\n  } else {\n    return query(p->r, q->r, (L + R >> 1) + 1, R);\n  }\n}\nconst int maxn = 1e5 + 5;\nint n, m;\nnode_t* f[maxn];\nvoid chemthan() {\n  cin >> n >> m;\n  vector<vector<int> > a(n);\n  for (int i = (0); i < (n); ++i) {\n    int k;\n    cin >> k;\n    a[i].resize(k);\n    f[i] = new node_t();\n    for (int& x : a[i]) {\n      cin >> x, x--;\n      f[i] = upd(f[i], x, 0, m - 1, 1);\n    }\n  }\n  set<pair<int, int> > heap;\n  for (int i = (0); i < (n); ++i) {\n    heap.insert(make_pair(f[i]->cnt, i));\n  }\n  vector<pair<pair<int, int>, int> > res;\n  while (1) {\n    int u = heap.begin()->second;\n    int v = heap.rbegin()->second;\n    if (f[u]->cnt < f[v]->cnt - 1) {\n      heap.erase(make_pair(f[u]->cnt, u));\n      heap.erase(make_pair(f[v]->cnt, v));\n      int x = query(f[v], f[u], 0, m - 1);\n      f[v] = upd(f[v], x, 0, m - 1, -1);\n      f[u] = upd(f[u], x, 0, m - 1, +1);\n      heap.insert(make_pair(f[u]->cnt, u));\n      heap.insert(make_pair(f[v]->cnt, v));\n      res.push_back(make_pair(make_pair(v, u), x));\n    } else {\n      break;\n    }\n  }\n  cout << int((res).size()) << \"\\n\";\n  for (auto e : res) {\n    cout << e.first.first + 1 << \" \" << e.first.second + 1 << \" \"\n         << e.second + 1 << \"\\n\";\n  }\n}\nint main(int argc, char* argv[]) {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  if (argc > 1) {\n    assert(freopen(argv[1], \"r\", stdin));\n  }\n  if (argc > 2) {\n    assert(freopen(argv[2], \"wb\", stdout));\n  }\n  chemthan();\n  cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, m;\nconst int bign = 100033;\nlist<int> itemlist[bign];\nvector<int> vecoi[2];\nint mlist[2][bign];\nint mtotal = 0;\nint cnt[bign];\nint mtop[bign];\nint p[bign];\nint mtarget[bign];\nset<int> mset[bign];\nbool cmp(const int& x1, const int& y1) {\n  return itemlist[x1].size() > itemlist[y1].size();\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int si;\n    p[i] = i;\n    scanf(\"%d\", &si);\n    mtotal += si;\n    for (int j = 0; j < si; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      itemlist[i].push_back(x);\n      mset[i].insert(x);\n    }\n  }\n  sort(p + 1, p + n + 1, cmp);\n  int tsum = mtotal % n;\n  int nsum = mtotal / n;\n  int ansm = 0;\n  for (int i = 1; i <= n; i++) {\n    if (i <= tsum) {\n      mtarget[p[i]] = nsum + 1;\n    } else {\n      mtarget[p[i]] = nsum;\n    }\n    if (itemlist[p[i]].size() > mtarget[p[i]]) {\n      ansm += (int)itemlist[p[i]].size() - mtarget[p[i]];\n      vecoi[0].push_back(p[i]);\n    } else {\n      vecoi[1].push_back(p[i]);\n    }\n  }\n  printf(\"%d\\n\", ansm);\n  int mtop[2] = {0, 0};\n  while (mtop[0] < vecoi[0].size() && mtop[1] < vecoi[1].size()) {\n    int u = vecoi[0][mtop[0]];\n    int v = vecoi[1][mtop[1]];\n    for (list<int>::iterator it = itemlist[u].begin();\n         it != itemlist[u].end();) {\n      if (mset[u].size() == mtarget[u] || mset[v].size() == mtarget[v]) break;\n      list<int>::iterator x = it;\n      it++;\n      if (mset[v].count(*x) == 0) {\n        mset[u].erase(*x);\n        mset[v].insert(*x);\n        printf(\"%d %d %d\\n\", u, v, *x);\n        itemlist[u].erase(x);\n      }\n    }\n    if (mset[u].size() == mtarget[u]) {\n      mtop[0]++;\n    }\n    if (mset[v].size() == mtarget[v]) {\n      mtop[1]++;\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nstruct Node {\n  set<int> st;\n  int id;\n  Node() {}\n  Node(const set<int>& st, int id) : st(st), id(id) {}\n  bool operator<(const Node& tmp) const { return st.size() < tmp.st.size(); }\n} dat[N];\nstruct Ans {\n  int from, to, kind;\n  Ans() {}\n  Ans(int from, int to, int kind) : from(from), to(to), kind(kind) {}\n};\nvector<Ans> ans;\nvoid solve() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  int tot = 0;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    tot += x;\n    set<int> st;\n    while (x--) {\n      int u;\n      scanf(\"%d\", &u);\n      st.insert(u);\n    }\n    dat[i] = Node(st, i);\n  }\n  sort(dat + 1, dat + n + 1);\n  int x = tot / n, y = (tot + n - 1) / n;\n  int l = 1, r = n;\n  while (l < r) {\n    vector<int> tmp;\n    int ma = min((int)dat[r].st.size() - y, x - (int)dat[l].st.size());\n    for (auto i : dat[l].st) {\n      if (dat[r].st.count(i)) {\n        tmp.push_back(i);\n        dat[r].st.erase(i);\n      }\n    }\n    vector<int> t2;\n    for (auto i : dat[r].st) {\n      if (ma <= 0) break;\n      ma--;\n      ans.push_back(Ans(dat[r].id, dat[l].id, i));\n      t2.push_back(i);\n    }\n    for (auto i : t2) dat[r].st.erase(i), dat[l].st.insert(i);\n    for (auto i : tmp) dat[r].st.insert(i);\n    if (dat[r].st.size() <= y) r--;\n    if (dat[l].st.size() >= x) l++;\n  }\n  l = 1, r = n;\n  while (l < r) {\n    vector<int> tmp;\n    int ma = min((int)dat[r].st.size() - x, x - (int)dat[l].st.size());\n    for (auto i : dat[l].st) {\n      if (dat[r].st.count(i)) {\n        tmp.push_back(i);\n        dat[r].st.erase(i);\n      }\n    }\n    vector<int> t2;\n    for (auto i : dat[r].st) {\n      if (ma <= 0) break;\n      ma--;\n      ans.push_back(Ans(dat[r].id, dat[l].id, i));\n      t2.push_back(i);\n    }\n    for (auto i : t2) dat[r].st.erase(i), dat[l].st.insert(i);\n    for (auto i : tmp) dat[r].st.insert(i);\n    if (dat[r].st.size() <= x) r--;\n    if (dat[l].st.size() >= x) l++;\n  }\n  l = 1, r = n;\n  while (l < r) {\n    vector<int> tmp;\n    int ma = min((int)dat[r].st.size() - y, y - (int)dat[l].st.size());\n    for (auto i : dat[l].st) {\n      if (dat[r].st.count(i)) {\n        tmp.push_back(i);\n        dat[r].st.erase(i);\n      }\n    }\n    vector<int> t2;\n    for (auto i : dat[r].st) {\n      if (ma <= 0) break;\n      ma--;\n      ans.push_back(Ans(dat[r].id, dat[l].id, i));\n      t2.push_back(i);\n    }\n    for (auto i : t2) dat[r].st.erase(i), dat[l].st.insert(i);\n    for (auto i : tmp) dat[r].st.insert(i);\n    if (dat[r].st.size() <= y) r--;\n    if (dat[l].st.size() >= y) l++;\n  }\n  for (int i = 1; i <= n; i++) {\n    assert(dat[i].st.size() >= x && dat[i].st.size() <= y);\n  }\n  printf(\"%d\\n\", (int)ans.size());\n  for (auto i : ans) {\n    printf(\"%d %d %d\\n\", i.from, i.to, i.kind);\n  }\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int l, r, siz;\n  node *ls, *rs;\n  node(int _l = 0, int _r = 0, int _s = 0) {\n    l = _l;\n    r = _r;\n    siz = _s;\n    ls = rs = NULL;\n  }\n};\nvoid add(node *nd, int val) {\n  nd->siz++;\n  if (nd->l == nd->r) return;\n  int m = (nd->l + nd->r) / 2;\n  if (val <= m) {\n    if (!(nd->ls)) nd->ls = new node(nd->l, m);\n    add(nd->ls, val);\n  } else {\n    if (!(nd->rs)) nd->rs = new node(m + 1, nd->r);\n    add(nd->rs, val);\n  }\n}\nvoid del(node *nd, int val) {\n  nd->siz--;\n  if (nd->l == nd->r) return;\n  int m = (nd->l + nd->r) / 2;\n  if (val <= m)\n    del(nd->ls, val);\n  else\n    del(nd->rs, val);\n}\nint sear(node *a, node *b) {\n  if (a->l == a->r) {\n    return a->l;\n  }\n  if (!b) {\n    if (a->ls && a->ls->siz)\n      return sear(a->ls, NULL);\n    else\n      return sear(a->rs, NULL);\n  }\n  int val = 0;\n  if (a->ls) val += a->ls->siz;\n  if (b && b->ls) val -= b->ls->siz;\n  if (val > 0)\n    return sear(a->ls, b ? b->ls : NULL);\n  else\n    return sear(a->rs, b ? b->rs : NULL);\n}\nstruct box {\n  int id, size;\n  node *root;\n  box(int _i = 0) {\n    id = _i;\n    size = 0;\n    root = new node(1, 100000);\n  }\n  void insert(int val) {\n    add(root, val);\n    size++;\n  }\n  void erase(int val) {\n    del(root, val);\n    size--;\n  }\n  void clear() {\n    size = 0;\n    root = new node(1, 100000);\n  }\n};\nint find(box a, box b) { return sear(a.root, b.root); }\nbool operator<(box a, box b) { return a.size < b.size; }\nmultiset<box> st;\nbox bx;\nconst int maxn = 5e5 + 5;\nint ope[maxn][3], siz;\nint main() {\n  int i, j, n, m;\n  int k, t;\n  int ans;\n  multiset<box>::iterator it1, it2;\n  box u, v;\n  scanf(\"%d%d\", &n, &m);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &k);\n    bx.clear();\n    bx.id = i + 1;\n    for (j = 0; j < k; j++) {\n      scanf(\"%d\", &t);\n      bx.insert(t);\n    }\n    st.insert(bx);\n  }\n  ans = 0;\n  siz = 0;\n  while (true) {\n    it1 = st.begin();\n    it2 = st.end();\n    it2--;\n    if (it2->size - it1->size <= 1) break;\n    u = *it1;\n    v = *it2;\n    st.erase(it1);\n    st.erase(it2);\n    t = find(v, u);\n    v.erase(t);\n    u.insert(t);\n    ans++;\n    ope[siz][0] = v.id;\n    ope[siz][1] = u.id;\n    ope[siz][2] = t;\n    siz++;\n    st.insert(u);\n    st.insert(v);\n  }\n  printf(\"%d\\n\", ans);\n  for (i = 0; i < siz; i++)\n    printf(\"%d %d %d\\n\", ope[i][0], ope[i][1], ope[i][2]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nconst long long mod = (1LL << 32), inf = 3e9, mxn = 1e5 + 10;\nset<int> co[mxn];\nint ile[mxn];\nvector<pair<int, pair<int, int> > > ans;\nvoid tran(int sk, int dok, int ile) {\n  set<int>::iterator it1, it2;\n  vector<int> vec;\n  it2 = co[dok].begin();\n  for (it1 = co[sk].begin(); it1 != co[sk].end(); it1++) {\n    while (it2 != co[dok].end() && (*it2) < (*it1)) {\n      it2++;\n    }\n    if ((it2 == co[dok].end()) || (*it1) != (*it2)) {\n      vec.push_back((*it1));\n      if (vec.size() == ile) {\n        break;\n      }\n    }\n  }\n  for (int i = 0; i < vec.size(); i++) {\n    ans.push_back(make_pair(sk, make_pair(dok, vec[i])));\n    co[sk].erase(vec[i]);\n    co[dok].insert(vec[i]);\n  }\n}\nint main() {\n  int n, m, i, a, j, su = 0;\n  cin >> n >> m;\n  for (i = 1; i <= n; i++) {\n    cin >> ile[i];\n    su += ile[i];\n    for (j = 0; j < ile[i]; j++) {\n      cin >> a;\n      co[i].insert(a);\n    }\n  }\n  if (su % n == 0) {\n    int cel = su / n;\n    deque<int> dod, odj;\n    for (i = 1; i <= n; i++) {\n      if (co[i].size() > cel) {\n        dod.push_back(i);\n      } else if (co[i].size() < cel) {\n        odj.push_back(i);\n      }\n    }\n    while (dod.size()) {\n      tran(dod[0], odj[0],\n           min(-cel + co[dod[0]].size(), -co[odj[0]].size() + cel));\n      if (cel == co[dod[0]].size()) {\n        dod.pop_front();\n      }\n      if (cel == co[odj[0]].size()) {\n        odj.pop_front();\n      }\n    }\n    cout << ans.size() << \"\\n\";\n    for (i = 0; i < ans.size(); i++) {\n      cout << ans[i].first << \" \" << ans[i].second.first << \" \"\n           << ans[i].second.second << \"\\n\";\n    }\n    return 0;\n  }\n  int dol = su / n;\n  int gu = dol + 1;\n  deque<int> dod, odj;\n  for (i = 1; i <= n; i++) {\n    if (co[i].size() > gu) {\n      dod.push_back(i);\n    } else if (co[i].size() < dol) {\n      odj.push_back(i);\n    }\n  }\n  while (dod.size() > 0 && odj.size() > 0) {\n    tran(dod[0], odj[0],\n         min(-gu + co[dod[0]].size(), -co[odj[0]].size() + dol));\n    if (gu == co[dod[0]].size()) {\n      dod.pop_front();\n    }\n    if (dol == co[odj[0]].size()) {\n      odj.pop_front();\n    }\n  }\n  if (dod.size()) {\n    for (int i = 1; dod.size() && i <= n; i++) {\n      if (co[i].size() == dol) {\n        tran(dod[0], i, 1);\n      }\n      if (gu == co[dod[0]].size()) {\n        dod.pop_front();\n      }\n    }\n  }\n  if (odj.size()) {\n    for (int i = 1; odj.size() && i <= n; i++) {\n      if (co[i].size() == gu) {\n        tran(i, odj[0], 1);\n      }\n      if (dol == co[odj[0]].size()) {\n        odj.pop_front();\n      }\n    }\n  }\n  cout << ans.size() << \"\\n\";\n  for (i = 0; i < ans.size(); i++) {\n    cout << ans[i].first << \" \" << ans[i].second.first << \" \"\n         << ans[i].second.second << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, m;\nvector<long long int> vals[100005];\nvector<long long int> has[100005];\nvector<long long int> cur[100005];\nvector<pair<pair<long long int, long long int>, long long int> > ans;\nlong long int sz[100005], fin[100005];\nlong long int ml[100005], rem[100005];\nvector<long long int> sim[100005];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  long long int mi = m + 5, mx = 0;\n  for (long long int i = 1; i <= n; ++i) {\n    long long int si;\n    cin >> si;\n    mx = max(mx, si);\n    mi = min(mi, si);\n    cur[si].push_back(i);\n    fin[i] = sz[i] = si;\n    while (si--) {\n      long long int v;\n      cin >> v;\n      has[v].push_back(i);\n      vals[i].push_back(v);\n    }\n  }\n  while (mi < mx - 1) {\n    long long int v = cur[mi].back();\n    cur[mi].pop_back();\n    long long int vm = cur[mx].back();\n    cur[mx].pop_back();\n    fin[v] = mi + 1;\n    fin[vm] = mx - 1;\n    cur[mi + 1].push_back(v);\n    cur[mx - 1].push_back(vm);\n    if (cur[mi].empty()) mi++;\n    if (cur[mx].empty()) mx--;\n  }\n  set<long long int> pres;\n  for (long long int i = 1; i <= n; ++i) {\n    if (sz[i] < fin[i]) {\n      ml[i] = fin[i] - sz[i];\n      pres.insert(i);\n    }\n    if (sz[i] > fin[i]) {\n      rem[i] = sz[i] - fin[i];\n      for (long long int v : vals[i]) sim[v].push_back(i);\n    }\n  }\n  for (long long int i = 1; i <= m; ++i) {\n    vector<long long int> er;\n    for (long long int v : has[i])\n      if (pres.find(v) != pres.end()) {\n        pres.erase(v);\n        er.push_back(v);\n      }\n    for (long long int v : sim[i]) {\n      if (!rem[v]) continue;\n      if (pres.empty()) break;\n      long long int vg = *pres.begin();\n      ans.push_back(make_pair(make_pair(v, vg), i));\n      rem[v]--;\n      ml[vg]--;\n      pres.erase(vg);\n      er.push_back(vg);\n    }\n    for (long long int v : er)\n      if (ml[v]) pres.insert(v);\n  }\n  cout << ans.size() << '\\n';\n  for (auto xp : ans)\n    cout << xp.first.first << \" \" << xp.first.second << \" \" << xp.second\n         << '\\n';\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class C {\n\n    private static class FastReader {\n        private static BufferedReader br;\n        private static StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            String s = \"\";\n            try {\n                s = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return s;\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n    }\n\n    public static class Box {\n        TreeSet<Integer> ts;\n        int i;\n\n        public Box(TreeSet<Integer> ts, int i) {\n            this.ts = ts;\n            this.i = i;\n        }\n    }\n\n    public static class Move {\n        int f, t, k;\n\n        public Move(int f, int t, int k) {\n            this.f = f;\n            this.t = t;\n            this.k = k;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader in = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        Box[] bxs = new Box[n];\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            bxs[i] = new Box(new TreeSet<>(), i + 1);\n            int s = in.nextInt();\n            for (int j = 0; j < s; j++) {\n                bxs[i].ts.add(in.nextInt());\n            }\n            cnt += s;\n        }\n        Arrays.sort(bxs, (o1, o2) -> o2.ts.size() - o1.ts.size());\n\n        int[] szs = new int[n];\n        for (int i = 0; i < n; i++) {\n            szs[i] = cnt / n + (i < cnt % n ? 1 : 0);\n        }\n\n        ArrayList<Move> mvs = new ArrayList<>();\n        int l = 0, r = n - 1;\n        while (l < r) {\n            for (Iterator it = bxs[l].ts.iterator(); bxs[l].ts.size() > szs[l] && bxs[r].ts.size() < szs[r];) {\n                int k = (int) it.next();\n                if (!bxs[r].ts.contains(k)) {\n                    it.remove();\n                    bxs[r].ts.add(k);\n                    mvs.add(new Move(bxs[l].i, bxs[r].i, k));\n                }\n            }\n            if (bxs[l].ts.size() == szs[l]) l++;\n            if (bxs[r].ts.size() == szs[r]) r--;\n        }\n\n        out.println(mvs.size());\n        for (Move mv : mvs) {\n            out.println(mv.f + \" \" + mv.t + \" \" + mv.k);\n        }\n        out.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int mod = 1e9 + 7;\ndouble eps = 1e-7;\nlong long int exp(long long int x, long long int y) {\n  if (y < 0) return 0;\n  long long int ret = 1;\n  for (; y; y >>= 1, x = (x * x) % mod) {\n    if (y & 1) ret = (ret * x) % mod;\n  }\n  return ret;\n}\nunsigned long long int pexp(unsigned long long int x,\n                            unsigned long long int y) {\n  if (y < 0) return 0;\n  unsigned long long int ret = 1;\n  for (; y; y >>= 1, x = (x * x)) {\n    if (y & 1) ret = (ret * x);\n  }\n  return ret;\n}\nlong long int gcd(long long int x, long long int y) {\n  if (!x || !y) return x + y;\n  return x % y == 0 ? y : gcd(y, x % y);\n}\nlong long int lcm(long long int x, long long int y) {\n  return x * (y / gcd(x, y));\n}\nlong long int bsum(long long int u, long long int b) {\n  long long int ret = 0;\n  if (u < b) return u;\n  while (u) {\n    ret += u % b;\n    u /= b;\n  }\n  return ret;\n}\nlong long int prival(long long int u, long long int p) {\n  long long int cn = 0;\n  while (u % p == 0) {\n    cn++;\n    u = u / p;\n  }\n  return cn;\n}\nlong long int minv(long long int a, long long int b) {\n  return 1 < a ? b - minv(b % a, a) * b / a : 1;\n}\nlong long int extm(long long int a, long long int b) {\n  long long int ret = 0;\n  while (a != 0) {\n    if (a % 2 == 1) {\n      ret += b;\n      ret %= mod;\n    }\n    a >>= 1;\n    b = (2 * b) % mod;\n  }\n  return ret;\n}\nlong long int eaphi(long long int x) {\n  long long int t = x, ret = x, i;\n  for (i = 2; i * i <= x; i++) {\n    if (t % i == 0) {\n      ret -= ret / i;\n      while (t % i == 0) t /= i;\n    }\n  }\n  if (t != 1) ret -= ret / t;\n  return ret;\n}\nlong long int eadivc(long long int x) {\n  long long int ret = 0;\n  long long int i;\n  for (i = 1; i * i <= x; i++) {\n    if (x % i == 0 && i * i != x) ret += 2;\n    if (x % i == 0 && i * i == x) ret += 1;\n  }\n  return ret;\n}\nlong long int eadivs(long long int x) {\n  long long int ret = 0;\n  long long int i;\n  for (i = 1; i * i <= x; i++) {\n    if (x % i == 0 && i * i != x) ret += i + x / i;\n    if (x % i == 0 && i * i == x) ret += i;\n  }\n  return ret;\n}\nlong long int ndig(long long int x, long long int b) {\n  long long int ret = 0;\n  while (x) {\n    x /= b;\n    ret++;\n  }\n  return ret;\n}\nlong long int rev(long long int n, long long int b) {\n  long long int ret = 0;\n  while (n) {\n    ret = b * ret + n % b;\n    n /= b;\n  }\n  return ret;\n}\nlong long int sq(long long int x) {\n  long long int t = (long long int)sqrt(x);\n  for (long long int i = t - 2; i <= t + 2; i++)\n    if (i * i == x) return abs(i);\n  return -1;\n}\nlong long int extexp(long long int x, long long int y) {\n  if (y < 0) return 0;\n  long long int ret = 1;\n  for (; y; y >>= 1, x = extm(x, x)) {\n    if (y & 1) ret = extm(ret, x);\n  }\n  return ret;\n}\nbool isprime(long long int x) {\n  if (x <= 1) return false;\n  for (long long int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nint n, m, tot, pivot_1, pivot_2, goal[111111];\nstruct BOX {\n  set<int> world;\n  int index;\n} stf[111111];\nvector<pair<int, pair<int, int> > > FIN;\nset<int>::iterator it;\nbool cmp(const BOX &A, const BOX &B) { return A.world.size() > B.world.size(); }\nvoid work(int u, int v) {\n  vector<int> SX;\n  SX.clear();\n  int i;\n  int sz_cut =\n      min(stf[u].world.size() - goal[u], goal[v] - stf[v].world.size());\n  for (it = stf[u].world.begin(); it != stf[u].world.end(); it++) {\n    if (stf[v].world.find((*it)) == stf[v].world.end()) SX.push_back((*it));\n    if (SX.size() >= sz_cut) break;\n  }\n  for (i = 0; i < SX.size(); i++) {\n    FIN.push_back(make_pair(stf[u].index, make_pair(stf[v].index, SX[i])));\n    stf[u].world.erase(SX[i]);\n    stf[v].world.insert(SX[i]);\n  }\n}\nint main(void) {\n  int i, j, x, xx;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (i = 1; i <= n; i++) {\n    cin >> x;\n    tot += x;\n    for (j = 1; j <= x; j++) {\n      cin >> xx;\n      stf[i].world.insert(xx);\n    }\n    stf[i].index = i;\n  }\n  sort(stf + 1, stf + n + 1, cmp);\n  for (i = 1; i <= tot % n; i++) goal[i] = tot / n + 1;\n  for (i = tot % n + 1; i <= n; i++) goal[i] = tot / n;\n  pivot_2 = n + 1;\n  for (i = 1; i <= n; i++) {\n    if (stf[i].world.size() < goal[i]) pivot_2 = i;\n    if (stf[i].world.size() < goal[i]) break;\n  }\n  pivot_1 = 1;\n  while (pivot_2 <= n) {\n    while (stf[pivot_1].world.size() != goal[pivot_1] &&\n           stf[pivot_2].world.size() != goal[pivot_2])\n      work(pivot_1, pivot_2);\n    if (stf[pivot_1].world.size() == goal[pivot_1]) pivot_1++;\n    if (stf[pivot_2].world.size() == goal[pivot_2]) pivot_2++;\n    if (pivot_2 > n) break;\n  }\n  cout << FIN.size() << endl;\n  for (i = 0; i < FIN.size(); i++)\n    cout << FIN[i].first << \" \" << FIN[i].second.first << \" \"\n         << FIN[i].second.second << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nset<int> g[N];\nvector<vector<int> > ans;\nvector<pair<int, int> > B;\nint n, m, total = 0, mn, need[N];\nvoid mer(int a, int b, int v0, int v1) {\n  vector<int> rem;\n  auto it0 = g[a].begin(), it1 = g[b].begin();\n  while (int((rem).size()) + int((g[a]).size()) < v0 &&\n         int((g[b]).size()) - int((rem).size()) > v1) {\n    if (it0 == g[a].end())\n      rem.push_back(*it1), it1 = next(it1);\n    else {\n      if (*it0 == *it1)\n        it0 = next(it0), it1 = next(it1);\n      else if (*it0 < *it1)\n        it0 = next(it0);\n      else\n        rem.push_back(*it1), it1 = next(it1);\n    }\n  }\n  for (int v : rem) g[a].insert(v), g[b].erase(v), ans.push_back({b, a, v});\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  set<pair<int, int> > vs;\n  for (int x = (0), qwerty = (n); x < qwerty; x++) {\n    int s;\n    cin >> s;\n    total += s;\n    for (int _ = (0), qwerty = (s); _ < qwerty; _++) {\n      int v;\n      cin >> v;\n      g[x].insert(v);\n    }\n    vs.insert({s, x});\n    B.push_back({s, x});\n  }\n  sort((B).begin(), (B).end());\n  reverse((B).begin(), (B).end());\n  mn = total / n;\n  fill(need, need + n, mn);\n  for (int x = (0), qwerty = (total % n); x < qwerty; x++) need[B[x].second]++;\n  while (int((vs).size())) {\n    int u = vs.begin()->second, v = vs.rbegin()->second;\n    vs.erase({int((g[u]).size()), u});\n    vs.erase({int((g[v]).size()), v});\n    mer(u, v, need[u], need[v]);\n    if (int((g[u]).size()) != need[u]) vs.insert({int((g[u]).size()), u});\n    if (int((g[v]).size()) != need[v]) vs.insert({int((g[v]).size()), v});\n  }\n  cout << int((ans).size()) << \"\\n\";\n  for (auto v : ans) cout << v[0] + 1 << \" \" << v[1] + 1 << \" \" << v[2] << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans, n, m, tot, order[200005], ex[200005];\nset<int> ord[500005], box[200005];\npriority_queue<pair<int, int>, vector<pair<int, int> >,\n               greater<pair<int, int> > >\n    pq;\nbool cmp(int a, int b) {\n  return (int)box[a].size() - ex[a] > (int)box[b].size() - ex[b];\n}\nvoid pq_add(int x) {\n  if (box[x].size() < ex[x]) pq.push({(int)box[x].size() - ex[x], x});\n}\nvoid move(int x, int y, int w) {\n  cout << x << ' ' << pq.top().second << ' ' << w << \"\\n\";\n  box[x].erase(w);\n  box[y].insert(w);\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    order[i] = i;\n    int s;\n    cin >> s;\n    tot += s;\n    for (int j = 1; j <= s; j++) {\n      int w;\n      cin >> w;\n      box[i].insert(w);\n      ord[w].insert(i);\n    }\n  }\n  sort(order + 1, order + n + 1, cmp);\n  int left = tot % n;\n  for (int i = 1; i <= n; i++) {\n    if (left)\n      ex[order[i]] = tot / n + 1, left--;\n    else\n      ex[order[i]] = tot / n;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (box[i].size() >= ex[i])\n      ans += (int)box[i].size() - ex[i];\n    else\n      pq.push({(int)box[i].size() - ex[i], i});\n  }\n  cout << ans << \"\\n\";\n  for (int w = 1; w <= m; w++) {\n    vector<int> t_ord, des;\n    for (auto x : ord[w]) t_ord.emplace_back(x);\n    sort(begin(t_ord), end(t_ord), cmp);\n    for (auto x : t_ord) {\n      if (box[x].size() <= ex[x]) break;\n      while (!pq.empty() and\n             (ord[w].count(pq.top().second) or\n              pq.top().first !=\n                  (int)box[pq.top().second].size() - ex[pq.top().second])) {\n        pq.pop();\n      }\n      if (pq.empty())\n        break;\n      else {\n        move(x, pq.top().second, w);\n        des.emplace_back(pq.top().second);\n        pq.pop();\n      }\n    }\n    for (auto x : t_ord) pq_add(x);\n    for (auto x : des) pq_add(x);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N = 100100;\nset<int> a[N];\nint n, m;\npair<int, int> b[N];\npair<int, int> c[N];\nvoid solve(int S, int L, int k) {\n  int x = -1;\n  while (k > 0) {\n    auto itL = a[L].upper_bound(x);\n    if (itL == a[L].end()) throw;\n    int y = *itL;\n    auto itS = a[S].upper_bound(x);\n    while (itS != a[S].end() && *itS < y) {\n      itS++;\n    }\n    if (itS == a[S].end() || *itS > y) {\n      k--;\n      printf(\"%d %d %d\\n\", L + 1, S + 1, y);\n      a[S].insert(y);\n      a[L].erase(y);\n      x = y;\n    } else\n      x = y;\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  m = 0;\n  for (int i = 0; i < n; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    b[i] = make_pair(k, i);\n    m += k;\n    while (k--) {\n      int x;\n      scanf(\"%d\", &x);\n      a[i].insert(x);\n    }\n  }\n  sort(b, b + n);\n  reverse(b, b + n);\n  for (int i = 0; i < n; i++) {\n    int z = m / n;\n    if (i < m % n) z++;\n    c[i] = make_pair(b[i].first - z, b[i].second);\n  }\n  sort(c, c + n);\n  int res = 0;\n  for (int i = 0; i < n; i++)\n    if (c[i].first > 0) res += c[i].first;\n  printf(\"%d\\n\", res);\n  int L = 0, R = n - 1;\n  while (L < R) {\n    while (L < R && c[L].first == 0) L++;\n    while (L < R && c[R].first == 0) R--;\n    if (L >= R) break;\n    int z = min(-c[L].first, c[R].first);\n    c[L].first += z;\n    c[R].first -= z;\n    solve(c[L].second, c[R].second, z);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid maxtt(T& t1, T t2) {\n  t1 = max(t1, t2);\n}\ntemplate <typename T>\nvoid mintt(T& t1, T t2) {\n  t1 = min(t1, t2);\n}\nbool debug = 0;\nint n, m, k;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nstring direc = \"URDL\";\nlong long ln, lk, lm;\nvoid etp(bool f = 0) {\n  puts(f ? \"YES\" : \"NO\");\n  exit(0);\n}\nvoid addmod(int& x, int y, int mod = 998244353) {\n  assert(y >= 0);\n  x += y;\n  if (x >= mod) x -= mod;\n  assert(x >= 0 && x < mod);\n}\nvoid et(int x = -1) {\n  printf(\"%d\\n\", x);\n  exit(0);\n}\nlong long fastPow(long long x, long long y, int mod = 998244353) {\n  long long ans = 1;\n  while (y > 0) {\n    if (y & 1) ans = (x * ans) % mod;\n    x = x * x % mod;\n    y >>= 1;\n  }\n  return ans;\n}\nlong long gcd1(long long x, long long y) { return y ? gcd1(y, x % y) : x; }\nint a[100035], b[100035], fr[100035], to[100035], S;\npair<int, int> sp[100035];\nvector<int> seq[100035];\nbool vis[100035];\nvoid mov(int x, int y, int s) {\n  vector<int> tmp;\n  for (int z : seq[y]) vis[z] = 1;\n  while (s) {\n    int t = seq[x].back();\n    seq[x].pop_back();\n    if (vis[t]) {\n      tmp.push_back(t);\n      continue;\n    }\n    vis[t] = 1;\n    seq[y].push_back(t);\n    s--;\n    printf(\"%d %d %d\\n\", x, y, t);\n  }\n  for (int z : seq[y]) vis[z] = 0;\n  for (int z : tmp) seq[x].push_back(z);\n}\nvoid fmain(int tid) {\n  scanf(\"%d%d\", &n, &m);\n  for (int(i) = 1; (i) <= (int)(n); (i)++) {\n    sp[i].second = i;\n    scanf(\"%d\", &fr[i]);\n    sp[i].first = -fr[i];\n    seq[i].resize(fr[i]);\n    S += fr[i];\n    for (int(j) = 1; (j) <= (int)(fr[i]); (j)++) {\n      scanf(\"%d\", &seq[i][j - 1]);\n    }\n  }\n  sort(sp + 1, sp + 1 + n);\n  for (int(i) = 1; (i) <= (int)(n); (i)++) to[i] = S / n + (S % n >= i);\n  int ans = 0;\n  for (int(i) = 1; (i) <= (int)(n); (i)++)\n    ans += max(0, to[i] - fr[sp[i].second]);\n  printf(\"%d\\n\", ans);\n  for (int i = 1, j = n; i < j;) {\n    int x = sp[i].second, y = sp[j].second;\n    if (fr[x] == to[i]) {\n      i++;\n      continue;\n    }\n    if (fr[y] == to[j]) {\n      j--;\n      continue;\n    }\n    int s = min(abs(fr[x] - to[i]), abs(fr[y] - to[j]));\n    fr[x] -= s;\n    fr[y] += s;\n    mov(x, y, s);\n  }\n}\nint main() {\n  int t = 1;\n  for (int(i) = 1; (i) <= (int)(t); (i)++) {\n    fmain(i);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int sz = 5e5 + 10;\nint an[sz][3], anq = 0;\nint main() {\n  int n, m, q = 0;\n  cin >> n >> m;\n  int si[n];\n  set<int> se[n];\n  map<int, vector<int> > ma;\n  for (int a = 0; a < n; a++) {\n    scanf(\"%d\", &si[a]);\n    q += si[a];\n    for (int b = 0; b < si[a]; b++) {\n      int x;\n      scanf(\"%d\", &x);\n      x--;\n      se[a].insert(x);\n      ma[x].push_back(a);\n    }\n  }\n  int mi = q / n, os = (q % n > 0);\n  for (int a = 0; a < n; a++) {\n    if (si[a] < mi) {\n      vector<map<int, vector<int> >::iterator> del;\n      for (auto it = ma.begin(); it != ma.end(); it++) {\n        int x = (*it).first;\n        vector<int> &ve = (*it).second;\n        if (se[a].find(x) == se[a].end()) {\n          while (ve.size()) {\n            int nu = ve.back();\n            if (si[nu] > mi + os) {\n              an[anq][0] = nu, an[anq][1] = a, an[anq][2] = x, anq++;\n              si[nu]--, si[a]++;\n              ve.pop_back();\n              break;\n            } else\n              ve.pop_back();\n          }\n        }\n        if (ve.size() == 0) del.push_back(it);\n        if (si[a] == mi) break;\n      }\n      while (del.size()) {\n        ma.erase(del.back()), del.pop_back();\n      }\n    }\n  }\n  int badq = 0;\n  for (int a = 0; a < n; a++)\n    if (si[a] > mi + os) badq++;\n  for (int a = 0; a < n; a++) {\n    if (si[a] == mi and badq) {\n      vector<map<int, vector<int> >::iterator> del;\n      for (auto it = ma.begin(); it != ma.end(); it++) {\n        int x = (*it).first;\n        vector<int> &ve = (*it).second;\n        if (se[a].find(x) == se[a].end()) {\n          while (ve.size()) {\n            int nu = ve.back();\n            if (si[nu] > mi + os) {\n              an[anq][0] = nu, an[anq][1] = a, an[anq][2] = x, anq++;\n              si[nu]--, si[a]++;\n              if (si[nu] < mi + os) badq--;\n              ve.pop_back();\n              break;\n            } else\n              ve.pop_back();\n          }\n        }\n        if (ve.size() == 0) del.push_back(it);\n        if (si[a] == mi + 1) break;\n      }\n      while (del.size()) {\n        ma.erase(del.back()), del.pop_back();\n      }\n    }\n  }\n  cout << anq << \"\\n\";\n  for (int a = 0; a < anq; a++)\n    printf(\"%d %d %d\\n\", an[a][0] + 1, an[a][1] + 1, an[a][2] + 1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::vector;\nvector<int> box[100005];\nint order[100005];\nint need[100005];\nint cur[100005];\nint used[100005];\nstruct Result {\n  int from, to, kind;\n  Result() {}\n  Result(int from, int to, int kind) : from(from), to(to), kind(kind) {}\n};\nResult answer[500005];\nint min(int a, int b) { return a > b ? b : a; }\nstruct SegmentT {\n  int l, r;\n  int d;\n  int fst;\n};\nSegmentT t[400005];\nSegmentT merge(SegmentT& u, SegmentT& v) {\n  SegmentT res;\n  res.l = u.l, res.r = v.r;\n  res.d = res.fst = -1;\n  if (u.fst != -1)\n    res.fst = u.fst;\n  else\n    res.fst = v.fst;\n  return res;\n}\nvoid build(int p, int l, int r) {\n  t[p].l = l, t[p].r = r;\n  if (l == r) {\n    t[p].d = 0;\n    t[p].fst = -1;\n  } else {\n    int m = (l + r) / 2;\n    build(2 * p, l, m);\n    build(2 * p + 1, m + 1, r);\n    t[p] = merge(t[2 * p], t[2 * p + 1]);\n  }\n}\nvoid change(int p, int x, int v) {\n  if (t[p].l == t[p].r) {\n    t[p].d += v;\n    if (t[p].d == 1)\n      t[p].fst = t[p].l;\n    else\n      t[p].fst = -1;\n  } else {\n    int m = (t[p].l + t[p].r) / 2;\n    if (x <= m)\n      change(2 * p, x, v);\n    else\n      change(2 * p + 1, x, v);\n    t[p] = merge(t[2 * p], t[2 * p + 1]);\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  int all = 0;\n  for (int i = 1; i <= n; i++) {\n    order[i] = i;\n    int k;\n    scanf(\"%d\", &k);\n    all += k;\n    cur[i] = k;\n    while (k--) {\n      int u;\n      scanf(\"%d\", &u);\n      box[i].push_back(u);\n    }\n  }\n  std::sort(order + 1, order + 1 + n,\n            [&](int& u, int& v) { return box[u].size() < box[v].size(); });\n  int left = all % n;\n  int base = all / n;\n  for (int i = 1; i <= n; i++) {\n    int p = order[n - i + 1];\n    if (i <= left)\n      need[p] = base + 1;\n    else\n      need[p] = base;\n  }\n  build(1, 1, m);\n  int total = 0;\n  int l = 1, r = n;\n  for (int u : box[order[l]]) {\n    change(1, u, -1);\n  }\n  for (int u : box[order[r]]) {\n    used[u] = 0;\n    change(1, u, 1);\n  }\n  while (l < r) {\n    while (l <= n && cur[order[l]] == need[order[l]]) {\n      for (int u : box[order[l]]) change(1, u, 1);\n      l++;\n      if (l != n + 1) {\n        for (int u : box[order[l]]) change(1, u, -1);\n      }\n    }\n    while (r >= 1 && cur[order[r]] == need[order[r]]) {\n      for (int u : box[order[r]]) {\n        if (!used[u]) change(1, u, -1);\n      }\n      r--;\n      if (r != 0) {\n        for (int u : box[order[r]]) {\n          used[u] = 0;\n          change(1, u, 1);\n        }\n      }\n    }\n    if (l >= r) break;\n    int give =\n        min(cur[order[r]] - need[order[r]], need[order[l]] - cur[order[l]]);\n    for (int rnd = 0; rnd < give; rnd++) {\n      int kind = t[1].fst;\n      change(1, kind, -2);\n      box[order[l]].push_back(kind);\n      used[kind] = 1;\n      answer[++total] = Result(order[r], order[l], kind);\n      cur[order[l]]++;\n      cur[order[r]]--;\n    }\n  }\n  printf(\"%d\\n\", total);\n  for (int i = 1; i <= total; i++)\n    printf(\"%d %d %d\\n\", answer[i].from, answer[i].to, answer[i].kind);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, need[100005], tot, extra[100005];\nvector<pair<int, set<int> > > ord;\nset<int>::iterator it;\nvector<pair<pair<int, int>, int> > ans;\nbool cmp(pair<int, set<int> > a, pair<int, set<int> > b) {\n  if ((int)a.second.size() > (int)b.second.size()) return true;\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  int precision = numeric_limits<long double>::digits10;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    pair<int, set<int> > temp;\n    temp.first = i;\n    int s;\n    cin >> s;\n    for (int j = 1; j <= s; j++) {\n      int u;\n      cin >> u;\n      temp.second.insert(u);\n      tot++;\n    }\n    ord.push_back(temp);\n  }\n  sort(ord.begin(), ord.end(), cmp);\n  for (int i = 0; i <= n - 1; i++) {\n    need[i] = tot / n;\n    if (i < tot % n) need[i]++;\n    extra[i] = (int)ord[i].second.size() - need[i];\n  }\n  int fw = 0, bw = n - 1;\n  while (fw < bw) {\n    if (extra[bw] == 0) {\n      bw--;\n      continue;\n    }\n    if (extra[fw] == 0) {\n      fw++;\n      continue;\n    }\n    vector<int> rem;\n    for (it = ord[fw].second.begin(); it != ord[fw].second.end(); it++) {\n      if (extra[fw] == 0 || extra[bw] == 0) break;\n      if (ord[bw].second.find(*it) == ord[bw].second.end()) {\n        extra[fw]--;\n        extra[bw]++;\n        rem.push_back(*it);\n        ord[bw].second.insert(*it);\n        ans.push_back(make_pair(make_pair(ord[fw].first, ord[bw].first), *it));\n      }\n    }\n    for (int i = 0; i < (int)rem.size(); i++) ord[fw].second.erase(rem[i]);\n  }\n  cout << (int)ans.size() << endl;\n  for (int i = 0; i < (int)ans.size(); i++)\n    cout << ans[i].first.first << \" \" << ans[i].first.second << \" \"\n         << ans[i].second << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> s[100010];\nset<int>::iterator it1, k;\nset<int>::iterator it2;\npair<int, int> a[100010];\nint ned[100010];\nint tec[100010];\nstruct P {\n  int x1, x2, x3;\n};\nvector<P> ans;\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, m, sum = 0;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    int k;\n    cin >> k;\n    for (int j = 0; j < k; j++) {\n      int l;\n      cin >> l;\n      s[i].insert(l);\n    }\n    tec[i] = s[i].size();\n    sum += k;\n    a[i] = make_pair(k, i);\n  }\n  sort(a + 1, a + n + 1);\n  for (int i = n; i >= 1; i--) {\n    int k = (sum) / n;\n    if (sum % n != 0) {\n      sum--;\n      k++;\n    }\n    ned[a[i].second] = k;\n  }\n  int l = 1, r = n;\n  while (1) {\n    while (r >= 1 && ned[a[r].second] == tec[a[r].second]) r--;\n    while (l <= n && ned[a[l].second] == tec[a[l].second]) l++;\n    if (r - l < 1) break;\n    it1 = s[a[l].second].begin();\n    it2 = s[a[r].second].begin();\n    for (;; it1 != s[a[l].second].end() && it2 != s[a[r].second].end()) {\n      int fl = 0;\n      while (it1 != s[a[l].second].end() && (*it1) < (*it2)) it1++;\n      if (it1 == s[a[l].second].end() || (*it1) > (*it2)) {\n        ans.push_back({a[r].second, a[l].second, *it2});\n        s[a[l].second].insert(*it2);\n        k = it2;\n        it2++;\n        s[a[r].second].erase(k);\n        tec[a[r].second]--;\n        tec[a[l].second]++;\n        fl = 1;\n      } else {\n        it2++;\n      }\n      if (ned[a[r].second] == tec[a[r].second] ||\n          ned[a[l].second] == tec[a[l].second])\n        break;\n    }\n  }\n  cout << ans.size() << endl;\n  for (int i = 0; i < ans.size(); i++) {\n    cout << ans[i].x1 << ' ' << ans[i].x2 << ' ' << ans[i].x3 << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nvoid err() { cout << endl; }\ntemplate <template <typename...> class T, typename t, typename... Args>\nvoid err(T<t> a, Args... args) {\n  for (auto x : a) cout << x << ' ';\n  err(args...);\n}\ntemplate <typename T, typename... Args>\nvoid err(T a, Args... args) {\n  cout << a << ' ';\n  err(args...);\n}\nstruct P {\n  int a, b, item;\n};\nconst int N = 1E5 + 100;\nint n, m, dm[N];\nset<int> S[N];\nint orders[N];\nint main() {\n  cin >> n >> m;\n  int tot = 0;\n  for (decay<decltype(n + 1)>::type i = (1), _i = (n + 1); i < _i; ++i) {\n    int sz;\n    scanf(\"%d\", &sz);\n    for (decay<decltype(sz)>::type j = (0), _j = (sz); j < _j; ++j) {\n      int x;\n      scanf(\"%d\", &x);\n      S[i].insert(x);\n    }\n    tot += sz;\n  }\n  for (decay<decltype(n + 1)>::type i = (1), _i = (n + 1); i < _i; ++i)\n    orders[i] = i;\n  sort(orders + 1, orders + n + 1,\n       [](const int& x, const int& y) { return S[x].size() > S[y].size(); });\n  int ll = 1, rr = n;\n  int at_least = tot / n;\n  for (decay<decltype(n + 1)>::type i = (1), _i = (n + 1); i < _i; ++i) {\n    if (i <= tot % n)\n      dm[orders[i]] = at_least + 1;\n    else\n      dm[orders[i]] = at_least;\n  }\n  vector<P> gather;\n  while (ll < rr) {\n    vector<P> adds;\n    int rrrrrrrrr = orders[rr], lllllllll = orders[ll];\n    ;\n    if (int((S[rrrrrrrrr]).size()) >= dm[rrrrrrrrr] &&\n        int((S[lllllllll]).size()) <= dm[lllllllll])\n      break;\n    vector<set<int>::iterator> vs;\n    vs.push_back(S[lllllllll].begin());\n    for (int v : S[rrrrrrrrr]) {\n      auto it = S[lllllllll].upper_bound(v);\n      if (it != S[lllllllll].end()) vs.push_back(it);\n    }\n    vector<int> dec;\n    for (auto it : vs)\n      while (int((S[lllllllll]).size()) - int((dec).size()) > dm[lllllllll] &&\n             int((S[rrrrrrrrr]).size()) < dm[rrrrrrrrr] &&\n             S[rrrrrrrrr].find(*it) == S[rrrrrrrrr].end()) {\n        S[rrrrrrrrr].insert(*it);\n        dec.push_back(*it++);\n      }\n    for (int v : dec) {\n      S[lllllllll].erase(v);\n      gather.push_back({lllllllll, rrrrrrrrr, v});\n    };\n    if (int((S[lllllllll]).size()) == dm[lllllllll]) ll++;\n    if (int((S[rrrrrrrrr]).size()) == dm[rrrrrrrrr]) rr--;\n  }\n  cout << gather.size() << endl;\n  for (decay<decltype(gather.size())>::type i = (0), _i = (gather.size());\n       i < _i; ++i)\n    printf(\"%d %d %d\\n\", gather[i].a, gather[i].b, gather[i].item);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10, mod = 1e9 + 7;\nconst long long inf = 1e18;\nvector<pair<pair<int, int>, int> > ans;\nset<int> s[maxn];\nvector<int> st;\nset<pair<int, int> > ssz;\nint main() {\n  int n, m, sm = 0;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    int cnt;\n    scanf(\"%d\", &cnt);\n    sm += cnt;\n    while (cnt--) {\n      int x;\n      scanf(\"%d\", &x);\n      s[i].insert(x);\n    }\n    ssz.insert({int((s[i]).size()), i});\n  }\n  int N1 = sm / n, N2 = (sm + n - 1) / n;\n  while (abs((ssz.begin()->first) - (ssz.rbegin()->first)) > 1) {\n    int id1 = ssz.begin()->second, id2 = ssz.rbegin()->second,\n        S1 = int((s[id1]).size()), S2 = int((s[id2]).size());\n    ssz.erase(ssz.begin());\n    ssz.erase(--ssz.end());\n    st.clear();\n    for (int x : s[id1]) {\n      if (s[id2].count(x)) st.push_back(x);\n      s[id2].erase(x);\n    }\n    if (S1 == N1 || S2 == N2) {\n      ans.push_back({{id2, id1}, *s[id2].begin()});\n      s[id1].insert(*s[id2].begin());\n      s[id2].erase(s[id2].begin());\n    }\n    while (S1 < N1 && S2 > N2) {\n      ans.push_back({{id2, id1}, *s[id2].begin()});\n      s[id1].insert(*s[id2].begin());\n      s[id2].erase(s[id2].begin());\n      S1++;\n      S2--;\n    }\n    for (int x : st) s[id2].insert(x);\n    ssz.insert({int((s[id1]).size()), id1});\n    ssz.insert({int((s[id2]).size()), id2});\n  }\n  printf(\"%d\\n\", int((ans).size()));\n  for (auto it : ans)\n    printf(\"%d %d %d\\n\", it.first.first + 1, it.first.second + 1, it.second);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100100;\nint n, pos[N], f[N], m, sz[N];\nset<int> mp1[N];\nbool cmp(int fi, int se) { return sz[fi] > sz[se]; }\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> sz[i];\n    sum += sz[i];\n    for (int j = 1; j <= sz[i]; j++) {\n      int x;\n      cin >> x;\n      mp1[i].insert(x);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    pos[i] = i;\n    f[i] = sum / n;\n    if (i <= sum % n) ++f[i];\n  }\n  sort(pos + 1, pos + n + 1, cmp);\n  int l = 1, r = n;\n  vector<pair<pair<int, int>, int> > ansvec;\n  while (l < r) {\n    while (1) {\n      if (sz[pos[l]] == f[l]) {\n        ++l;\n        break;\n      }\n      if (sz[pos[r]] == f[r]) {\n        --r;\n        break;\n      }\n      for (auto it = mp1[pos[l]].begin(); it != mp1[pos[l]].end(); it++) {\n        int x = *it;\n        if (mp1[pos[r]].find(x) != mp1[pos[r]].end()) continue;\n        ++it;\n        --sz[pos[l]];\n        ++sz[pos[r]];\n        mp1[pos[l]].erase(x);\n        mp1[pos[r]].insert(x);\n        if (it != mp1[pos[l]].begin()) it--;\n        ansvec.push_back({{pos[l], pos[r]}, x});\n        if (sz[pos[l]] == f[l] || sz[pos[r]] == f[r]) break;\n      }\n    }\n  }\n  cout << ansvec.size() << \"\\n\";\n  for (auto it : ansvec)\n    cout << it.first.first << ' ' << it.first.second << ' ' << it.second\n         << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nint n, m;\nunordered_set<int> ada[100005];\npriority_queue<pair<int, int> > pqmi, pqma;\nvector<pair<pair<int, int>, int> > ans;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    pqmi.push(make_pair(-x, i));\n    pqma.push(make_pair(x, i));\n    for (int j = 1; j <= x; j++) {\n      int y;\n      scanf(\"%d\", &y);\n      ada[i].insert(y);\n    }\n  }\n  while (pqma.top().first + pqmi.top().first > 1) {\n    pair<int, int> ma = pqma.top();\n    pqma.pop();\n    pair<int, int> mi = pqmi.top();\n    pqmi.pop();\n    for (auto x : ada[ma.second]) {\n      if (ada[mi.second].count(x) == 0) {\n        ans.push_back({make_pair(ma.second, mi.second), x});\n        ada[ma.second].erase(x);\n        ada[mi.second].insert(x);\n        break;\n      }\n    }\n    ma.first--;\n    mi.first--;\n    pqma.push(ma);\n    pqmi.push(mi);\n  }\n  printf(\"%d\\n\", ans.size());\n  for (int i = 0; i < ans.size(); i++) {\n    printf(\"%d %d %d\\n\", ans[i].first.first, ans[i].first.second,\n           ans[i].second);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M;\nset<int> A[100100];\nint B[100100];\nint need[100100];\nint total = 0;\nint ans[200005][3];\nbool cmp(int a, int b) { return A[a].size() < A[b].size(); }\nvoid go(int a, int b, int rem) {\n  int prv = 0;\n  while (rem > 0) {\n    int cur = *A[b].upper_bound(prv);\n    auto it = A[a].upper_bound(prv);\n    while (it != A[a].end() && *it < cur) it++;\n    if (it == A[a].end() || *it > cur) {\n      A[a].insert(cur);\n      A[b].erase(cur);\n      ans[total][0] = b + 1;\n      ans[total][1] = a + 1;\n      ans[total][2] = cur;\n      total++;\n      rem--;\n    }\n    prv = cur;\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> N >> M;\n  int cnt = 0;\n  for (int i = 0, sz; i < N; i++) {\n    cin >> sz;\n    cnt += sz;\n    for (int j = 0, x; j < sz; j++) {\n      cin >> x;\n      A[i].insert(x);\n    }\n    B[i] = i;\n  }\n  sort(B, B + N, cmp);\n  for (int i = 0; i < N; i++) {\n    if (i < N - cnt % N)\n      need[B[i]] = abs(cnt / N - (int)A[B[i]].size());\n    else\n      need[B[i]] = abs((cnt + N - 1) / N - (int)A[B[i]].size());\n  }\n  int left = 0, right = N - 1;\n  while (true) {\n    while (left < N && need[B[left]] == 0) left++;\n    while (right >= 0 && need[B[right]] == 0) right--;\n    if (left >= right) break;\n    int rem = min(need[B[left]], need[B[right]]);\n    go(B[left], B[right], rem);\n    need[B[left]] -= rem;\n    need[B[right]] -= rem;\n  }\n  cout << total << \"\\n\";\n  for (int i = 0; i < total; i++)\n    cout << ans[i][0] << \" \" << ans[i][1] << \" \" << ans[i][2] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint S[200010], Sz[200010], Nx[200010], Pr[200010], col[200010];\nvector<int> Ans1, Ans2, Ans3;\nvector<int> V[200010];\nvoid Do(int x, int y, int z) {\n  Ans1.push_back(x);\n  Ans2.push_back(y);\n  Ans3.push_back(z);\n}\nint main() {\n  int tot = 0;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    tot += x;\n    Sz[i] = x;\n    for (int j = 1; j <= x; j++) {\n      int k;\n      scanf(\"%d\", &k);\n      V[k].push_back(i);\n    }\n  }\n  int a = tot / n, b = tot % n;\n  int t1 = 1, t2 = 1;\n  for (int i = 1; i <= n; i++)\n    if (Sz[i] > a && b) {\n      b--;\n      S[i] = a + 1;\n    } else\n      S[i] = a;\n  if (b) {\n    for (int i = 1; i <= n && b; i++)\n      if (S[i] != a + 1) S[i] = a + 1, b--;\n  }\n  int lst = 0;\n  for (int i = 1; i <= n + 1; i++)\n    if (Sz[i] < S[i] || i == n + 1) {\n      Nx[lst] = i;\n      Pr[i] = lst;\n      lst = i;\n    }\n  for (int i = 1; i <= m; i++) {\n    for (int j = 0; j < V[i].size(); j++) col[V[i][j]] = i;\n    int t = Nx[0];\n    for (int j = 0; j < V[i].size(); j++)\n      if (Sz[V[i][j]] > S[V[i][j]]) {\n        while (t != n + 1) {\n          if (col[t] != i) {\n            Do(V[i][j], t, i);\n            Sz[V[i][j]]--;\n            Sz[t]++;\n            if (Sz[t] == S[t]) {\n              Pr[Nx[t]] = Pr[t];\n              Nx[Pr[t]] = Nx[t];\n            }\n            t = Nx[t];\n            break;\n          }\n          t = Nx[t];\n        }\n      }\n  }\n  printf(\"%d\\n\", Ans1.size());\n  for (int i = 0; i < Ans1.size(); i++)\n    printf(\"%d %d %d\\n\", Ans1[i], Ans2[i], Ans3[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 1e6 + 10;\nconst long long INF = 1e9 + 10;\nconst int MOD = 998244353;\nint n, m, sum;\nvector<set<int> > a;\nset<pair<int, int> > st;\nvector<pair<pair<int, int>, int> > ans;\nvoid move(int from, int to, int cnt) {\n  st.erase({a[from].size(), from});\n  st.erase({a[to].size(), to});\n  vector<int> ers;\n  for (auto cur : a[from]) {\n    if (a[to].find(cur) == a[to].end()) {\n      cnt--;\n      ers.push_back(cur);\n      if (cnt == 0) break;\n    }\n  }\n  for (auto cur : ers) {\n    ans.push_back({{from + 1, to + 1}, cur});\n    a[from].erase(cur);\n    a[to].insert(cur);\n  }\n  st.insert({a[from].size(), from});\n  st.insert({a[to].size(), to});\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  a.resize(n);\n  for (int i = 0; i < n; i++) {\n    int sz;\n    cin >> sz;\n    sum += sz;\n    st.insert({sz, i});\n    while (sz--) {\n      int x;\n      cin >> x;\n      a[i].insert(x);\n    }\n  }\n  while (true) {\n    pair<int, int> fi = *st.begin(), se = *st.rbegin();\n    if (se.first - fi.first < 2) break;\n    if (sum % n != 0) {\n      int cnt = min(sum / n - fi.first, se.first - sum / n - 1);\n      cnt = max(cnt, 1);\n      move(se.second, fi.second, cnt);\n    } else {\n      int cnt = min(sum / n - fi.first, se.first - sum / n);\n      move(se.second, fi.second, cnt);\n    }\n  }\n  cout << ans.size() << endl;\n  for (auto cur : ans)\n    cout << cur.first.first << ' ' << cur.first.second << ' ' << cur.second\n         << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n  int l, r;\n  int s;\n  Node() {\n    l = r = -1;\n    s = 0;\n  }\n};\nvector<Node> t;\nint n, m;\nvoid inc(int v, int l, int r, int p, int c) {\n  t[v].s += c;\n  if (l == r) return;\n  if (t[v].l == -1) {\n    t[v].l = t.size();\n    t.push_back(Node());\n  }\n  if (t[v].r == -1) {\n    t[v].r = t.size();\n    t.push_back(Node());\n  }\n  int mid = (l + r) / 2;\n  if (p <= mid) {\n    inc(t[v].l, l, mid, p, c);\n  } else {\n    inc(t[v].r, mid + 1, r, p, c);\n  }\n}\nvoid inc(int v, int p, int c) { inc(v, 1, m, p, c); }\nint get(int v, int v2, int l, int r) {\n  if (l == r) return l;\n  if (t[v].l == -1) {\n    t[v].l = t.size();\n    t.push_back(Node());\n  }\n  if (t[v].r == -1) {\n    t[v].r = t.size();\n    t.push_back(Node());\n  }\n  if (t[v2].l == -1) {\n    t[v2].l = t.size();\n    t.push_back(Node());\n  }\n  if (t[v2].r == -1) {\n    t[v2].r = t.size();\n    t.push_back(Node());\n  }\n  int mid = (l + r) / 2;\n  if (t[t[v].l].s < t[t[v2].l].s)\n    return get(t[v].l, t[v2].l, l, mid);\n  else\n    return get(t[v].r, t[v2].r, mid + 1, r);\n}\nint get(int v, int v2) { return get(v, v2, 1, m); }\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> m;\n  vector<int> root;\n  set<pair<int, int> > q;\n  for (int i = 0; i < n; ++i) {\n    int nn;\n    cin >> nn;\n    root.push_back(t.size());\n    t.push_back(Node());\n    for (int j = 0; j < nn; ++j) {\n      int p;\n      cin >> p;\n      inc(root.back(), p, 1);\n    }\n    q.insert({nn, i});\n  }\n  vector<pair<pair<int, int>, int> > ans;\n  while (q.size() > 1) {\n    auto f = (*q.begin());\n    auto s = (*--q.end());\n    if (s.first - f.first < 2) break;\n    int temp = get(root[f.second], root[s.second]);\n    inc(root[f.second], temp, 1);\n    inc(root[s.second], temp, -1);\n    ans.push_back({{s.second + 1, f.second + 1}, temp});\n    q.erase(q.begin());\n    q.erase(--q.end());\n    ++f.first;\n    --s.first;\n    q.insert(f);\n    q.insert(s);\n  }\n  cout << ans.size() << \"\\n\";\n  for (auto i : ans)\n    cout << i.first.first << \" \" << i.first.second << \" \" << i.second << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 10;\nint n, m, size[maxn], sum, avg, ted;\nvector<int> v[maxn];\nvector<pair<pair<int, int>, int> > ans;\nset<int> S;\nunordered_map<long long, bool> have;\nbool cmp(int a, int b) { return size[a] < size[b]; }\nint32_t main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", size + i);\n    sum += size[i];\n    for (int j = 0; j < size[i]; j++) {\n      int a;\n      scanf(\"%d\", &a);\n      a--;\n      have[1ll * i * maxn + 1ll * a] = 1;\n      v[a].push_back(i);\n    }\n  }\n  avg = (sum / n);\n  for (int i = 0; i < n; i++) {\n    if (size[i] < avg) {\n      S.insert(i);\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    sort(v[i].begin(), v[i].end(), cmp);\n    if (S.size()) {\n      for (auto it = S.begin(); it != S.end();) {\n        int pos = (*it);\n        it++;\n        if (v[i].empty() || size[v[i].back()] <= avg + 1) break;\n        if (!have[1ll * pos * maxn + 1ll * i]) {\n          size[pos]++;\n          have[1ll * pos * maxn + 1ll * i] = 1;\n          size[v[i].back()]--;\n          ans.push_back({{v[i].back(), pos}, i});\n          if (size[pos] == avg) {\n            S.erase(pos);\n          }\n          v[i].pop_back();\n        }\n      }\n    }\n  }\n  if (S.size()) {\n    for (int i = 0; i < m; i++) {\n      sort(v[i].begin(), v[i].end(), cmp);\n      if (S.size()) {\n        for (auto it = S.begin(); it != S.end();) {\n          int pos = (*it);\n          it++;\n          if (v[i].empty() || size[v[i].back()] <= avg) break;\n          if (!have[1ll * pos * maxn + 1ll * i]) {\n            have[1ll * pos * maxn + 1ll * i] = 1;\n            size[pos]++;\n            size[v[i].back()]--;\n            ans.push_back({{v[i].back(), pos}, i});\n            if (size[pos] >= avg) {\n              S.erase(pos);\n            }\n            v[i].pop_back();\n          }\n        }\n      }\n    }\n  } else {\n    for (int i = 0; i < n; i++) {\n      if (size[i] <= avg) {\n        S.insert(i);\n      }\n    }\n    for (int i = 0; i < m; i++) {\n      sort(v[i].begin(), v[i].end(), cmp);\n      if (S.size()) {\n        for (auto it = S.begin(); it != S.end();) {\n          int pos = (*it);\n          it++;\n          if (v[i].empty() || size[v[i].back()] <= avg + 1) break;\n          if (!have[1ll * pos * maxn + 1ll * i]) {\n            have[1ll * pos * maxn + 1ll * i] = 1;\n            size[pos]++;\n            size[v[i].back()]--;\n            ans.push_back({{v[i].back(), pos}, i});\n            if (size[pos] >= avg + 1) {\n              S.erase(pos);\n            }\n            v[i].pop_back();\n          }\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\", int(ans.size()));\n  for (pair<pair<int, int>, int> x : ans) {\n    printf(\"%d %d %d\\n\", x.first.first + 1, x.first.second + 1, x.second + 1);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nvector<int> V[N];\nvector<int> tmp;\nint s[N], to[N], sum;\npair<int, int> pa[N];\nbool vis[N];\nvoid _move(int x, int y, int z) {\n  for (auto it : V[y]) vis[it] = true;\n  while (z) {\n    int t = V[x].back();\n    V[x].pop_back();\n    if (vis[t]) {\n      tmp.push_back(t);\n      continue;\n    }\n    printf(\"%d %d %d\\n\", x, y, t);\n    V[y].push_back(t);\n    z--;\n  }\n  for (auto it : V[y]) vis[it] = false;\n  while (!tmp.empty()) {\n    V[x].push_back(tmp.back());\n    tmp.pop_back();\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &s[i]);\n    pa[i] = make_pair(s[i], i);\n    sum += s[i];\n    for (int j = 1; j <= s[i]; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      V[i].push_back(x);\n    }\n  }\n  sort(pa + 1, pa + n + 1);\n  reverse(pa + 1, pa + n + 1);\n  for (int i = 1; i <= n; i++) to[pa[i].second] = sum / n + (sum % n >= i);\n  int siz = 0;\n  for (int i = 1; i <= n; i++) siz += abs(to[i] - s[i]);\n  printf(\"%d\\n\", siz / 2);\n  for (int i = 1, j = n; i < j;) {\n    int x = pa[i].second, y = pa[j].second;\n    if (to[x] == s[x]) {\n      i++;\n      continue;\n    }\n    if (to[y] == s[y]) {\n      j--;\n      continue;\n    }\n    int ss = min(s[x] - to[x], to[y] - s[y]);\n    s[x] -= ss;\n    s[y] += ss;\n    _move(x, y, ss);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 111111;\nint n, m, s[N], a[N], e[N];\nvector<int> v[N], t;\npair<int, int> p[N];\nvoid solve(int x, int y, int z) {\n  int i, o;\n  for (i = 0; i < s[y]; i = i + 1) e[v[y][i]] = 1;\n  for (i = s[x] - 1; z; i = i - 1) {\n    o = v[x][i];\n    if (e[o])\n      t.push_back(o);\n    else\n      v[y].push_back(o), s[y]++, z--, printf(\"%d %d %d\\n\", x, y, o);\n    v[x][i] = 0;\n    s[x]--;\n  }\n  for (i = 0; i < s[y]; i = i + 1) e[v[y][i]] = 0;\n  for (o = t.size(); o--;) v[x][s[x]++] = t[o];\n  t.clear();\n}\nint main() {\n  int i, j, x, y, z;\n  scanf(\"%d%d\", &n, &m);\n  m = 0;\n  for (i = 1; i <= n; i = i + 1) {\n    scanf(\"%d\", s + i);\n    for (j = 0; j < s[i]; j = j + 1) scanf(\"%d\", &x), v[i].push_back(x);\n    p[i] = make_pair(-s[i], i);\n    m += s[i];\n  }\n  for (i = 1; i <= n; i = i + 1) a[i] = m / n;\n  for (i = 1; i <= m % n; i = i + 1) a[i]++;\n  sort(p + 1, p + n + 1);\n  x = 0;\n  for (i = 1; i <= n; i = i + 1)\n    if (s[p[i].second] > a[i]) x += s[p[i].second] - a[i];\n  printf(\"%d\\n\", x);\n  i = 1, j = n;\n  while (i < j) {\n    x = p[i].second;\n    y = p[j].second;\n    if (s[x] == a[i]) {\n      i++;\n      continue;\n    }\n    if (s[y] == a[j]) {\n      j--;\n      continue;\n    }\n    z = min(s[x] - a[i], a[j] - s[y]);\n    solve(x, y, z);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package rohspc2018;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class C2 {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n//\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint[][] a = new int[n][];\n\t\tint[][] ai = new int[n][];\n\t\tint all = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\ta[i] = na(ni());\n\t\t\tai[i] = new int[]{a[i].length, i};\n\t\t\tall += a[i].length;\n\t\t}\n\t\tArrays.sort(ai, new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn (a[0] - b[0]);\n\t\t\t}\n\t\t});\n\t\tint[] ideal = new int[n];\n\t\tfor(int i = 0;i < n;i++)ideal[i] = (all+i)/n;\n\t\tint l = 0, r = n-1;\n\t\tList<String> ret = new ArrayList<>();\n\t\t\n\t\tIntHashSetLST[] sets = new IntHashSetLST[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tIntHashSetLST set = new IntHashSetLST();\n\t\t\tfor(int s : a[i]){\n\t\t\t\tset.add(s);\n\t\t\t}\n\t\t\tsets[i] = set;\n\t\t}\n\t\t\n\t\tint step = 0;\n\t\twhile(l < r){\n\t\t\twhile(l < n && ai[l][0] >= ideal[l])l++;\n\t\t\twhile(r >= 0 && ai[r][0] <= ideal[r])r--;\n\t\t\tif(l >= r)break;\n\t\t\t\n\t\t\tint ir = ai[r][1], il = ai[l][1];\n\t\t\t\n\t\t\t// r->l\n\t\t\tsets[ir].itrreset();\n\t\t\tsets[ir].next();\n\t\t\twhile(ai[l][0] < ideal[l] && ai[r][0] > ideal[r]){\n\t\t\t\tai[r][0]--;\n\t\t\t\tai[l][0]++;\n\t\t\t\twhile(true){\n\t\t\t\t\tint v = sets[ir].keys[sets[ir].itr];\n\t\t\t\t\tif(!sets[il].contains(v)){\n\t\t\t\t\t\tret.add((ir+1) + \" \" + (il+1) + \" \" + v);\n\t\t\t\t\t\tsets[ir].remove(v);\n\t\t\t\t\t\tsets[il].add(v);\n\t\t\t\t\t\tsets[ir].next();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsets[ir].next();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(ret.size());\n\t\tfor(String line : ret){\n\t\t\tout.println(line);\n\t\t}\n\t}\n\t\n\tpublic static class IntHashSetLST {\n\t\tpublic int[] keys;\n\t\tprivate int scale = 1<<2;\n\t\tprivate int rscale = 1<<1;\n\t\tprivate int mask = scale-1;\n\t\tpublic int size = 0;\n\t\tpublic LST lst;\n\t\t\n\t\tpublic IntHashSetLST(){\n\t\t\tlst = new LST(scale);\n\t\t\tkeys = new int[scale];\n\t\t}\n\t\t\n\t\tpublic boolean contains(int x)\n\t\t{\n\t\t\tint pos = h(x)&mask;\n\t\t\twhile(lst.get(pos)){\n\t\t\t\tif(x == keys[pos])return true;\n\t\t\t\tpos = pos+1&mask;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tpublic boolean add(int x)\n\t\t{\n\t\t\tint pos = h(x)&mask;\n\t\t\twhile(lst.get(pos)){\n\t\t\t\tif(x == keys[pos])return false;\n\t\t\t\tpos = pos+1&mask;\n\t\t\t}\n\t\t\tif(size == rscale){\n\t\t\t\tresizeAndAdd(x);\n\t\t\t}else{\n\t\t\t\tkeys[pos] = x;\n\t\t\t\tlst.set(pos);\n\t\t\t}\n\t\t\tsize++;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tpublic boolean remove(int x)\n\t\t{\n\t\t\tint pos = h(x)&mask;\n\t\t\twhile(lst.get(pos)){\n\t\t\t\tif(x == keys[pos]){\n\t\t\t\t\tsize--;\n\t\t\t\t\tint rmpos = pos;\n\t\t\t\t\t\n\t\t\t\t\t// take last and fill rmpos\n\t\t\t\t\tpos = pos+1&mask;\n\t\t\t\t\tint last = rmpos;\n\t\t\t\t\twhile(lst.get(pos)){\n\t\t\t\t\t\tint lh = h(keys[pos])&mask;\n\t\t\t\t\t\t// lh <= last < pos\n\t\t\t\t\t\tif(\n\t\t\t\t\t\t\t\tlh <= last && last < pos ||\n\t\t\t\t\t\t\t\tpos < lh && lh <= last ||\n\t\t\t\t\t\t\t\tlast < pos && pos < lh\n\t\t\t\t\t\t\t\t){\n\t\t\t\t\t\t\tkeys[last] = keys[pos];\n\t\t\t\t\t\t\tlast = pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = pos+1&mask;\n\t\t\t\t\t}\n\t\t\t\t\tkeys[last] = 0;\n\t\t\t\t\tlst.unset(last);\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tpos = pos+1&mask;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tprivate void resizeAndAdd(int x)\n\t\t{\n\t\t\tint nscale = scale<<1;\n\t\t\tint nrscale = rscale<<1;\n\t\t\tint nmask = nscale-1;\n\t\t\tLST nlst = new LST(nscale);\n\t\t\tint[] nkeys = new int[nscale];\n\t\t\titrreset();\n\t\t\twhile(true){\n\t\t\t\tint y = next();\n\t\t\t\tif(end())break;\n\t\t\t\tint pos = h(y)&nmask;\n\t\t\t\twhile(nlst.get(pos))pos = pos+1&nmask; // inefficient\n\t\t\t\tnkeys[pos] = y;\n\t\t\t\tnlst.set(pos);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint pos = h(x)&nmask;\n\t\t\t\twhile(nlst.get(pos))pos = pos+1&nmask; // inefficient\n\t\t\t\tnkeys[pos] = x;\n\t\t\t\tnlst.set(pos);\n\t\t\t}\n\t\t\tlst = nlst;\n\t\t\tkeys = nkeys;\n\t\t\tscale = nscale;\n\t\t\trscale = nrscale;\n\t\t\tmask = nmask;\n\t\t}\n\t\t\n\t\tpublic int itr = -1;\n\t\t\n\t\tpublic void itrreset() { itr = -1; }\n\t\tpublic boolean end() { return itr == -1; }\n\t\t\n\t\tprivate static int NG = Integer.MIN_VALUE;\n\t\tpublic int next() {\n\t\t\titr = lst.next(itr+1);\n\t\t\tif(itr == -1)return NG;\n\t\t\treturn keys[itr];\n\t\t}\n\t\t\n\t\tpublic int h(int x)\n\t\t{\n\t\t\tx ^= x>>>16;\n\t\t\tx *= 0x85ebca6b;\n\t\t\tx ^= x>>>13;\n\t\t\tx *= 0xc2b2ae35;\n\t\t\tx ^= x>>>16;\n\t\t\treturn x;\n\t\t}\n\t\t\n//\t\tprivate long h(long x)\n//\t\t{\n//\t\t\tx ^= x>>>33;\n//\t\t\tx *= 0xff51afd7ed558ccdL;\n//\t\t\tx ^= x>>>33;\n//\t\t\tx *= 0xc4ceb9fe1a85ec53L;\n//\t\t\tx ^= x>>>33;\n//\t\t\treturn x;\n//\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\titrreset();\n\t\t\tint[] vals = new int[size];\n\t\t\tint p = 0;\n\t\t\twhile(true){\n\t\t\t\tint y = next();\n\t\t\t\tif(end())break;\n\t\t\t\tvals[p++] = y;\n\t\t\t}\n\t\t\treturn Arrays.toString(vals);\n\t\t}\n\t}\n\t\n\tpublic static class LST {\n\t\tpublic long[][] set;\n\t\tpublic int n;\n//\t\tpublic int size;\n\t\t\n\t\tpublic LST(int n) {\n\t\t\tthis.n = n;\n\t\t\tint d = 1;\n\t\t\tfor(int m = n;m > 1;m>>>=6, d++);\n\t\t\t\n\t\t\tset = new long[d][];\n\t\t\tfor(int i = 0, m = n>>>6;i < d;i++, m>>>=6){\n\t\t\t\tset[i] = new long[m+1];\n\t\t\t}\n//\t\t\tsize = 0;\n\t\t}\n\t\t\n\t\t// [0,r)\n\t\tpublic LST setRange(int r)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\tfor(int j = 0;j < r>>>6;j++){\n\t\t\t\t\tset[i][j] = -1L;\n\t\t\t\t}\n\t\t\t\tif((r&63) != 0)set[i][r>>>6] |= (1L<<r)-1;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\t// [0,r)\n\t\tpublic LST unsetRange(int r)\n\t\t{\n\t\t\tif(r >= 0){\n\t\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\t\tfor(int j = 0;j < r+63>>>6;j++){\n\t\t\t\t\t\tset[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif((r&63) != 0)set[i][r>>>6] &= ~((1L<<r)-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic LST set(int pos)\n\t\t{\n\t\t\tif(pos >= 0 && pos < n){\n//\t\t\t\tif(!get(pos))size++;\n\t\t\t\tfor(int i = 0;i < set.length;i++, pos>>>=6){\n\t\t\t\t\tset[i][pos>>>6] |= 1L<<pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic LST unset(int pos)\n\t\t{\n\t\t\tif(pos >= 0 && pos < n){\n//\t\t\t\tif(get(pos))size--;\n\t\t\t\tfor(int i = 0;i < set.length && (i == 0 || set[i-1][pos] == 0L);i++, pos>>>=6){\n\t\t\t\t\tset[i][pos>>>6] &= ~(1L<<pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic boolean get(int pos)\n\t\t{\n\t\t\treturn pos >= 0 && pos < n && set[0][pos>>>6]<<~pos<0;\n\t\t}\n\t\t\n\t\tpublic LST toggle(int pos)\n\t\t{\n\t\t\treturn get(pos) ? unset(pos) : set(pos);\n\t\t}\n\t\t\n\t\tpublic int prev(int pos)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length && pos >= 0;i++, pos>>>=6, pos--){\n\t\t\t\tint pre = prev(set[i][pos>>>6], pos&63);\n\t\t\t\tif(pre != -1){\n\t\t\t\t\tpos = pos>>>6<<6|pre;\n\t\t\t\t\twhile(i > 0)pos = pos<<6|63-Long.numberOfLeadingZeros(set[--i][pos]);\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpublic int next(int pos)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length && pos>>>6 < set[i].length;i++, pos>>>=6, pos++){\n\t\t\t\tint nex = next(set[i][pos>>>6], pos&63);\n\t\t\t\tif(nex != -1){\n\t\t\t\t\tpos = pos>>>6<<6|nex;\n\t\t\t\t\twhile(i > 0)pos = pos<<6|Long.numberOfTrailingZeros(set[--i][pos]);\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tprivate static int prev(long set, int n)\n\t\t{\n\t\t\tlong h = set<<~n;\n\t\t\tif(h == 0L)return -1;\n\t\t\treturn -Long.numberOfLeadingZeros(h)+n;\n\t\t}\n\t\t\n\t\tprivate static int next(long set, int n)\n\t\t{\n\t\t\tlong h = set>>>n;\n\t\t\tif(h == 0L)return -1;\n\t\t\treturn Long.numberOfTrailingZeros(h)+n;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int pos = next(0);pos != -1;pos = next(pos+1)){\n\t\t\t\tlist.add(pos);\n\t\t\t}\n\t\t\treturn list.toString();\n\t\t}\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n//\t\tint n = 100000, m = 99999;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tsb.append(100000 + \" \");\n//\t\tfor (int i = 0; i < n-5; i++) {\n//\t\t\tsb.append(0 + \" \");\n//\t\t}\n//\t\tfor(int k = 0;k < 5;k++){\n//\t\t\tsb.append(100000 + \" \");\n//\t\t\tfor(int j = 0;j < 100000;j++){\n//\t\t\t\tsb.append(j+1 + \" \");\n//\t\t\t}\n//\t\t}\n//\t\tsb.append(0 + \" \");\n//\t\tfor (int i = 0; i < n-1; i++) {\n//\t\t\tsb.append(50000 + \" \");\n//\t\t\tfor(int j = 0;j < 50000;j++){\n//\t\t\t\tsb.append(j+1 + \" \");\n//\t\t\t}\n//\t\t}\n//\t\tINPUT = sb.toString();\n\n\t\t\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new C2().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, lint>;\nconst int MAXN = 100005;\nint n, m, sum;\nint cnt[MAXN];\nset<int> s[MAXN];\nint p[MAXN];\nvector<tuple<int, int, int>> dap;\nvoid MOVE(int dst, int src, int v) {\n  vector<int> mutation;\n  for (auto &i : s[dst]) {\n    if (s[src].find(i) == s[src].end()) {\n      continue;\n    }\n    s[src].erase(i);\n    mutation.push_back(i);\n  }\n  while (v--) {\n    auto x = *s[src].begin();\n    s[src].erase(x);\n    s[dst].insert(x);\n    dap.emplace_back(src + 1, dst + 1, x);\n  }\n  for (auto &i : mutation) s[src].insert(i);\n}\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    sum += x;\n    p[i] = i;\n    for (int j = 0; j < x; j++) {\n      int v;\n      scanf(\"%d\", &v);\n      s[i].insert(v);\n    }\n  }\n  for (int i = 0; i < sum; i++) {\n    cnt[n - 1 - i % n]++;\n  }\n  sort(p, p + n,\n       [&](const int &a, const int &b) { return s[a].size() < s[b].size(); });\n  int lx = -1, ly = 1e9;\n  for (int i = 0; i < n; i++) {\n    if (s[p[i]].size() < cnt[i]) {\n      lx = i;\n    }\n    if (s[p[i]].size() > cnt[i]) ly = min(ly, i);\n  }\n  if (lx == -1) {\n    puts(\"0\");\n    return 0;\n  }\n  while (true) {\n    while (lx >= 0 && s[p[lx]].size() == cnt[lx]) lx--;\n    while (ly < n && s[p[ly]].size() == cnt[ly]) ly++;\n    if (lx == -1) break;\n    int thres0 = cnt[lx] - s[p[lx]].size();\n    int thres1 = s[p[ly]].size() - cnt[ly];\n    MOVE(p[lx], p[ly], min(thres0, thres1));\n  }\n  printf(\"%d\\n\", dap.size());\n  for (auto &i : dap) {\n    int x, y, z;\n    tie(x, y, z) = i;\n    printf(\"%d %d %d\\n\", x, y, z);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int MAX = 100000;\nvector<long long int> great[MAX + 1];\nvector<long long int> small[MAX + 1];\nvector<long long int> v[MAX + 1];\nbool gactive[MAX + 1] = {false};\nset<long long int> sactive;\nlong long int sz[MAX + 1] = {0};\nstruct moves {\n  long long int from, to, kind;\n};\nbool in(long long int x, vector<long long int>& p) {\n  if (lower_bound(p.begin(), p.end(), x) != p.end()) {\n    return (*lower_bound(p.begin(), p.end(), x) == x);\n  }\n  return false;\n}\nvoid solve() {\n  long long int n, m;\n  cin >> n >> m;\n  long long int tot = 0;\n  vector<pair<long long int, long long int>> szv(n + 1);\n  szv[0] = {0, 0};\n  for (long long int j = 1; j <= n; j++) {\n    long long int s;\n    cin >> s;\n    tot += s;\n    sz[j] = s;\n    szv[j] = {s, j};\n    for (long long int i = 0; i < s; i++) {\n      long long int c;\n      cin >> c;\n      v[j].push_back(c);\n    }\n  }\n  sort(szv.begin(), szv.end());\n  vector<long long int> gf(n + 1);\n  long long int sum = 0;\n  for (long long int j = 1; j <= n; j++) {\n    if ((tot / n) * (n - j + 1) == tot - sum) {\n      gf[j] = tot / n;\n    } else {\n      gf[j] = (tot + n - 1) / n;\n    }\n    sum += gf[j];\n  }\n  vector<long long int> should(n + 1);\n  for (long long int j = 1; j <= n; j++) {\n    should[szv[j].second] = gf[n - j + 1];\n  }\n  for (long long int j = 1; j <= n; j++) {\n    if (sz[j] > should[j]) {\n      gactive[j] = true;\n      for (auto i : v[j]) {\n        great[i].push_back(j);\n      }\n    } else if (sz[j] < should[j]) {\n      sactive.insert(j);\n      for (auto i : v[j]) {\n        small[i].push_back(j);\n      }\n    }\n  }\n  vector<moves> out;\n  for (long long int j = 1; j <= m; j++) {\n    if (((long long int)great[j].size()) == 0) continue;\n    long long int m1 = great[j].size(), m2 = small[j].size();\n    long long int ptr1 = 0, ptr2 = 0;\n    while (true) {\n      if (ptr1 == m1) break;\n      if (gactive[great[j][ptr1]]) break;\n      ptr1++;\n    }\n    if (ptr1 == m1) continue;\n    set<long long int> todel;\n    for (auto it : sactive) {\n      if (in(it, small[j]))\n        continue;\n      else {\n        sz[great[j][ptr1]]--;\n        sz[it]++;\n        {\n          struct moves q;\n          q.from = great[j][ptr1];\n          q.to = it;\n          q.kind = j;\n          out.push_back(q);\n        }\n        if (sz[great[j][ptr1]] <= should[great[j][ptr1]])\n          gactive[great[j][ptr1]] = false;\n        if (sz[it] >= should[it]) todel.insert(it);\n        ptr1++;\n        while (true) {\n          if (ptr1 == m1) break;\n          if (gactive[great[j][ptr1]]) break;\n          ptr1++;\n        }\n        if (ptr1 == m1) break;\n      }\n    }\n    for (auto it : todel) sactive.erase(it);\n  }\n  cout << (long long int)out.size() << '\\n';\n  for (auto q : out) {\n    cout << q.from << \" \" << q.to << \" \" << q.kind << '\\n';\n  }\n  return;\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int t;\n  t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nconst int MAXN = 100000;\nstruct Move {\n  int from, to, kind;\n  Move() {}\n  Move(int from, int to, int kind) : from(from), to(to), kind(kind) {}\n};\nint n, nkind;\nvector<int> have[MAXN];\nvector<Move> ans;\npair<int, int> o[MAXN];\nint want[MAXN];\nvector<int> calccanmove(vector<int> &a, vector<int> &b, int need) {\n  vector<int> ret;\n  int at = ((int)(b).size()) - 1;\n  for (int i = ((int)(a).size()) - 1; i >= 0 && ((int)(ret).size()) < need;\n       --i) {\n    while (at >= 0 && b[at] > a[i]) --at;\n    if (at >= 0 && b[at] == a[i]) continue;\n    ret.push_back(a[i]);\n  }\n  reverse(ret.begin(), ret.end());\n  return ret;\n}\nvoid remove(vector<int> &a, vector<int> &b) {\n  if (((int)(b).size()) == 0) return;\n  int idx = ((int)(a).size()) - 1;\n  while (idx > 0 && a[idx] >= b[0]) --idx;\n  int n = idx;\n  for (int i = (0); i < (((int)(b).size())); ++i) {\n    while (idx < ((int)(a).size()) && a[idx] < b[i]) a[n++] = a[idx++];\n    assert(idx < ((int)(a).size()) && a[idx] == b[i]);\n    ++idx;\n  }\n  while (idx < ((int)(a).size())) a[n++] = a[idx++];\n  a.resize(n);\n}\nvector<int> merge(vector<int> &a, vector<int> &b) {\n  vector<int> ret;\n  int ai = 0, bi = 0;\n  while (ai < ((int)(a).size()) || bi < ((int)(b).size())) {\n    if (ai < ((int)(a).size()) && (bi >= ((int)(b).size()) || a[ai] <= b[bi]))\n      ret.push_back(a[ai++]);\n    else\n      ret.push_back(b[bi++]);\n  }\n  return ret;\n}\nvoid solve() {\n  for (int i = (0); i < (n); ++i) sort(have[i].begin(), have[i].end());\n  for (int i = (0); i < (n); ++i) o[i] = make_pair(((int)(have[i]).size()), i);\n  sort(o, o + n);\n  int tothave = 0;\n  for (int i = (0); i < (n); ++i) tothave += ((int)(have[i]).size());\n  int each = tothave / n, extra = tothave % n;\n  for (int i = (0); i < (n); ++i) want[i] = each;\n  for (int i = 0; i < extra; ++i) ++want[n - i - 1];\n  ans.clear();\n  int lidx = 0, ridx = n - 1;\n  while (lidx < ridx) {\n    int l = o[lidx].second, r = o[ridx].second;\n    if (((int)(have[l]).size()) >= want[lidx]) {\n      ++lidx;\n      continue;\n    }\n    if (((int)(have[r]).size()) <= want[ridx]) {\n      --ridx;\n      continue;\n    }\n    int nmove = min(want[lidx] - ((int)(have[l]).size()),\n                    ((int)(have[r]).size()) - want[ridx]);\n    vector<int> tomove = calccanmove(have[r], have[l], nmove);\n    for (int i = (0); i < (((int)(tomove).size())); ++i)\n      ans.push_back(Move(r, l, tomove[i]));\n    remove(have[r], tomove);\n    have[l] = merge(have[l], tomove);\n  }\n}\nvoid run() {\n  scanf(\"%d%d\", &n, &nkind);\n  for (int i = (0); i < (n); ++i) {\n    int cnt;\n    scanf(\"%d\", &cnt);\n    have[i] = vector<int>(cnt);\n    for (int j = (0); j < (cnt); ++j) scanf(\"%d\", &have[i][j]), --have[i][j];\n  }\n  solve();\n  printf(\"%d\\n\", ((int)(ans).size()));\n  for (int i = (0); i < (((int)(ans).size())); ++i)\n    printf(\"%d %d %d\\n\", ans[i].from + 1, ans[i].to + 1, ans[i].kind + 1);\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::bitset;\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::make_pair;\nusing std::map;\nusing std::pair;\nusing std::priority_queue;\nusing std::queue;\nusing std::set;\nusing std::string;\nusing std::stringstream;\nusing std::vector;\nclass MyTimer {\n public:\n  void reset() {}\n  void report() {}\n} myTimer;\ntemplate <typename A, typename B>\nstd::ostream &operator<<(std::ostream &cout, const pair<A, B> &x) {\n  return cout << \"(\" << x.first << \", \" << x.second << \")\";\n}\ntemplate <typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) {\n  return a > b ? a = b, true : false;\n}\ntemplate <typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) {\n  return a < b ? a = b, true : false;\n}\ninline int readint() {\n  int a = 0;\n  char c = getchar(), p = 0;\n  while (isspace(c)) c = getchar();\n  if (c == '-') p = 1, c = getchar();\n  while (isdigit(c)) a = a * 10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\nconst int maxN = 100000 + 233;\nint n, m;\nint size[maxN];\nset<pair<int, int> > S;\nconst int NODE = 500000 * 20 * 2;\nint cnt = 0;\nint root[maxN];\nint sum[NODE], lson[NODE], rson[NODE];\nvoid add(int &o, int L, int R, int val) {\n  if (o == 0) o = ++cnt, sum[o] = lson[o] = rson[o] = 0;\n  sum[o]++;\n  if (L == R) {\n  } else {\n    int M = (L + R) >> 1;\n    if (val <= M)\n      add(lson[o], L, M, val);\n    else\n      add(rson[o], M + 1, R, val);\n  }\n}\nint pos = -1;\nvoid move(int &x, int &y, int L, int R) {\n  if (x == 0) x = ++cnt;\n  assert(y);\n  if (y == 0) y = ++cnt;\n  sum[x]++;\n  sum[y]--;\n  if (L == R) {\n    pos = L;\n  } else {\n    int M = (L + R) >> 1;\n    if (sum[lson[x]] < sum[lson[y]])\n      move(lson[x], lson[y], L, M);\n    else\n      move(rson[x], rson[y], M + 1, R);\n  }\n}\nint len, optx[500000 + 233], opty[500000 + 233], optv[500000 + 233];\nint main() {\n  n = readint();\n  m = readint();\n  memset(root, 0, sizeof(root));\n  for (int i = 1; i <= n; ++i) {\n    int c = readint();\n    S.emplace(c, i);\n    size[i] = c;\n    while (c--) add(root[i], 1, m, readint());\n  }\n  len = 0;\n  while (S.begin()->first + 2 <= S.rbegin()->first) {\n    int x = S.begin()->second;\n    S.erase(S.begin());\n    int y = S.rbegin()->second;\n    S.erase(*S.rbegin());\n    size[x]++;\n    size[y]--;\n    pos = -1;\n    move(root[x], root[y], 1, m);\n    assert(pos != -1);\n    ++len;\n    optx[len] = y;\n    opty[len] = x;\n    optv[len] = pos;\n    S.insert(pair<int, int>(size[x], x));\n    S.insert(pair<int, int>(size[y], y));\n  }\n  printf(\"%d\\n\", len);\n  for (int i = 1; i <= len; ++i)\n    printf(\"%d %d %d\\n\", optx[i], opty[i], optv[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXINT = 2147483640;\nconst long long MAXLL = 9223372036854775800LL;\nconst long long MAXN = 1e6;\nconst double eps = 1e-9;\nconst long long mod = 1e9 + 7;\nusing namespace std;\nstruct kek {\n  long long a, b, c;\n};\nstruct node {\n  long long l, r, val;\n};\nvector<kek> vans;\nvector<node> p[100001];\nlong long all;\nvoid modify(long long now, long long v, long long ls, long long rs,\n            long long pos, long long val) {\n  if (ls == rs) {\n    p[now][v].val = val;\n    return;\n  }\n  node cur;\n  cur.l = cur.r = cur.val = 0;\n  long long mid = (ls + rs) / 2;\n  if (pos <= mid) {\n    if (!p[now][v].l) p[now][v].l = p[now].size(), p[now].push_back(cur);\n    modify(now, p[now][v].l, ls, mid, pos, val);\n  } else {\n    if (!p[now][v].r) p[now][v].r = p[now].size(), p[now].push_back(cur);\n    modify(now, p[now][v].r, mid + 1, rs, pos, val);\n  }\n  p[now][v].val = p[now][p[now][v].l].val + p[now][p[now][v].r].val;\n}\nlong long dfs(long long now1, long long now2, long long v1, long long v2,\n              long long ls, long long rs) {\n  if (ls == rs)\n    return ls;\n  else {\n    long long mid = (ls + rs) / 2;\n    if (p[now2][p[now2][v2].l].val > p[now1][p[now1][v1].l].val)\n      return dfs(now1, now2, p[now1][v1].l, p[now2][v2].l, ls, mid);\n    else\n      return dfs(now1, now2, p[now1][v1].r, p[now2][v2].r, mid + 1, rs);\n  }\n}\nint main() {\n  srand(time(0));\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  ;\n  set<pair<long long, long long> > s;\n  long long n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    long long x;\n    cin >> x;\n    node cur;\n    cur.l = cur.r = cur.val = 0;\n    p[i].push_back(cur);\n    p[i].push_back(cur);\n    for (int j = 1; j <= x; ++j) {\n      long long val;\n      cin >> val;\n      modify(i, 1, 1, m, val, 1);\n    }\n    s.insert(make_pair(p[i][1].val, i));\n  }\n  long long stn = 0;\n  while (1) {\n    long long ans1 = s.begin()->first;\n    long long ans2 = (--s.end())->first;\n    long long pos1 = s.begin()->second;\n    long long pos2 = (--s.end())->second;\n    if (abs(ans1 - ans2) <= 1)\n      break;\n    else {\n      long long ans = dfs(pos1, pos2, 1, 1, 1, m);\n      vans.push_back({pos2, pos1, ans});\n      modify(pos1, 1, 1, m, ans, 1);\n      modify(pos2, 1, 1, m, ans, 0);\n      ans1++, ans2--;\n      s.erase(--s.end());\n      s.erase(s.begin());\n      s.insert(make_pair(ans1, pos1));\n      s.insert(make_pair(ans2, pos2));\n    }\n  }\n  cout << vans.size() << endl;\n  for (auto i : vans) cout << i.a << \" \" << i.b << \" \" << i.c << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MN = 1e5 + 5;\nstruct qry {\n  int t;\n  unordered_set<int> s;\n} inp[MN];\nstruct cmp {\n  bool operator()(const qry *lhs, const qry *rhs) {\n    return pair<int, int>(lhs->s.size(), lhs->t) <\n           pair<int, int>(rhs->s.size(), rhs->t);\n  }\n};\nint N, M, lav, hav, tot = 0;\nset<qry *, cmp> presents;\nvector<pair<pair<int, int>, int> > ops;\nbool ins(qry *x) {\n  presents.insert(x);\n  return x->s.size() < lav || x->s.size() > hav;\n}\nvoid exchange(qry *l, qry *h) {\n  auto &ls = l->s, &hs = h->s;\n  int mops = max(1, (int)min(lav - ls.size(), hs.size() - hav));\n  for (auto it = hs.begin(); mops > 0;) {\n    assert(it != hs.end());\n    int x = *it;\n    if (ls.insert(x).second) {\n      it = hs.erase(it);\n      mops--;\n      ops.push_back({{h->t, l->t}, x});\n    } else {\n      it++;\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> N >> M;\n  for (int i = 0, v, x; i < N; i++) {\n    inp[i].t = i + 1;\n    cin >> v;\n    tot += v;\n    while (v--) {\n      cin >> x;\n      inp[i].s.insert(x);\n    }\n  }\n  lav = tot / N;\n  hav = lav + (tot % N > 0);\n  for (int i = 0; i < N; i++) {\n    ins(&inp[i]);\n  }\n  while (!presents.empty()) {\n    qry *l = *presents.begin(), *h = *presents.rbegin();\n    if ((l->s.size() >= lav) && (h->s.size() <= hav)) break;\n    presents.erase(l);\n    presents.erase(h);\n    exchange(l, h);\n    assert(!ins(l) | !ins(h));\n  }\n  printf(\"%d\\n\", ops.size());\n  for (auto p : ops) {\n    printf(\"%d %d %d\\n\", p.first.first, p.first.second, p.second);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \" : \" << arg1 << \" | \";\n  __f(comma + 1, args...);\n}\nconst int N = 100005;\nint target[N];\nset<int> now[N];\nint perm[N];\nset<pair<int, int> > st;\nvector<pair<int, pair<int, int> > > transfers;\nint main() {\n  int n, m, t = 0;\n  scanf(\"%d\", &(n));\n  scanf(\"%d\", &(m));\n  for (int i = 1; i <= n; i++) {\n    int sz;\n    scanf(\"%d\", &(sz));\n    perm[i] = i;\n    for (int j = 1; j <= sz; j++) {\n      int z;\n      scanf(\"%d\", &(z));\n      now[i].insert(z);\n    }\n    t += sz;\n    st.insert({sz, i});\n  }\n  int diff = 0;\n  int x = t / n, y = t % n;\n  for (int i = y + 1; i <= n; i++) {\n    target[perm[i]] = x;\n  }\n  while (1) {\n    auto it1 = *st.begin(), it2 = *st.rbegin();\n    int i = it1.second, j = it2.second;\n    int curr_i = it1.first, curr_j = it2.first;\n    int max_transfer = (curr_j - curr_i) >> 1;\n    max_transfer = min(max_transfer, max(1, curr_j - x - 1));\n    max_transfer = min(max_transfer, max(1, x - curr_i));\n    if (max_transfer == 0) break;\n    int done = 0;\n    vector<int> removed;\n    for (auto it : now[j]) {\n      if (done >= max_transfer) break;\n      if (!now[i].count(it)) {\n        removed.push_back(it);\n        transfers.push_back({j, {i, it}});\n        ++done;\n      }\n    }\n    for (auto it : removed) {\n      now[i].insert(it);\n      now[j].erase(it);\n    }\n    st.erase(it1);\n    st.erase(it2);\n    st.insert({now[i].size(), i});\n    st.insert({now[j].size(), j});\n  }\n  printf(\"%d\\n\", (int)transfers.size());\n  for (auto it : transfers)\n    printf(\"%d %d %d\\n\", it.first, it.second.first, it.second.second);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> bags[101000];\nset<int> lower_bags_for_type[101000];\nset<int> lower_bags_for_type_reserve[101000];\nint line;\nint line2;\nint upper_real_size[101000];\nset<int> upper_bags_for_type[101000];\nset<int> lower_indices;\nqueue<int> erase_indices;\nvoid move_p(int type, int j) {\n  bags[j].push_back(type);\n  if (bags[j].size() >= (line) || bags[j].size() >= (line2)) {\n    erase_indices.push(j);\n    for (int x : bags[j]) lower_bags_for_type[x].erase(j);\n  }\n}\nstruct ans {\n  int from, to, kind;\n  ans(int f, int t, int k) : from(f), to(t), kind(k) {}\n};\nvoid do_loop(int m, vector<ans> &vv) {\n  for (int t = 1; t <= m; t++) {\n    if (upper_bags_for_type[t].size() == 0 || lower_indices.size() == 0)\n      continue;\n    vector<int> erased;\n    for (int x : lower_bags_for_type[t]) {\n      erased.push_back(x);\n      lower_indices.erase(x);\n    }\n    if (lower_indices.size() > 0) {\n      auto it = lower_indices.begin();\n      vector<int> lp;\n      for (auto it = upper_bags_for_type[t].begin();\n           it != upper_bags_for_type[t].end(); it++)\n        lp.push_back(*it);\n      for (int u_id : lp) {\n        if (upper_real_size[u_id] <= line) {\n          continue;\n        }\n        vv.push_back(ans(u_id + 1, *it + 1, t));\n        upper_real_size[u_id]--;\n        move_p(t, *it);\n        upper_bags_for_type[t].erase(u_id);\n        it++;\n        if (it == lower_indices.end()) break;\n      }\n    }\n    for (int x : erased) {\n      lower_indices.insert(x);\n    }\n    while (erase_indices.size() > 0) {\n      lower_indices.erase(erase_indices.front());\n      erase_indices.pop();\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int tot_cnt = 0;\n  int n, m;\n  cin >> n >> m;\n  for (int(i) = (0); (i) < (n); (i)++) {\n    int sz;\n    cin >> sz;\n    tot_cnt += sz;\n    upper_real_size[i] = sz;\n    bags[i].resize(sz);\n    for (int(j) = (0); (j) < (sz); (j)++) {\n      cin >> bags[i][j];\n      m = max(m, bags[i][j]);\n    }\n  }\n  line = (tot_cnt + n - 1) / n;\n  line2 = tot_cnt / n;\n  for (int(i) = (0); (i) < (n); (i)++) {\n    if (bags[i].size() < min(line2, line)) {\n      lower_indices.insert(i);\n      for (int x : bags[i]) {\n        lower_bags_for_type[x].insert(i);\n      }\n    }\n  }\n  for (int(i) = (0); (i) < (n); (i)++) {\n    if (bags[i].size() <= line) continue;\n    for (int x : bags[i]) {\n      upper_bags_for_type[x].insert(i);\n    }\n  }\n  vector<ans> vv;\n  do_loop(m, vv);\n  if (line != line2) {\n    lower_indices.clear();\n    for (int(i) = (0); (i) < (n); (i)++) {\n      if (bags[i].size() == line2) {\n        lower_indices.insert(i);\n        for (int x : bags[i]) {\n          lower_bags_for_type[x].insert(i);\n        }\n      }\n    }\n    do_loop(m, vv);\n  }\n  cout << vv.size() << \"\\n\";\n  for (auto x : vv) {\n    cout << x.from << \" \" << x.to << \" \" << x.kind << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC diagnostic ignored \"-Wmissing-declarations\"\ninline int safe_mul(const int x, const int y)\n    __attribute__((warn_unused_result));\nint const maxn = 100003;\nvector<int> used[maxn];\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<int, int>> nums;\n  for (int i = 0; i < n; ++i) {\n    int s;\n    cin >> s;\n    for (int j = 0; j < s; ++j) {\n      int x;\n      cin >> x;\n      used[i].push_back(x);\n    }\n    nums.emplace_back(s, i);\n  }\n  sort(nums.begin(), nums.end());\n  long long acnt = 0;\n  for (const auto& p : nums) acnt += p.first;\n  vector<int> need(n);\n  for (int i = 0; i < n; ++i) {\n    need[i] = acnt / n + (n - i <= acnt % n);\n  }\n  int l = 0;\n  int r = n - 1;\n  vector<tuple<int, int, int>> result;\n  bitset<maxn + 100> lb;\n  for (const int x : used[nums[l].second]) lb.set(x);\n  bitset<maxn + 100> rb;\n  for (const int x : used[nums[r].second]) rb.set(x);\n  for (;;) {\n    bool lsh = false;\n    while (l < r && nums[l].first == need[l]) {\n      ++l;\n      lsh = true;\n    }\n    bool rsh = false;\n    while (r > l && nums[r].first == need[r]) {\n      --r;\n      rsh = true;\n    }\n    if (l >= r) break;\n    if (lsh) {\n      lb.reset();\n      for (const int x : used[nums[l].second]) lb.set(x);\n    }\n    if (rsh) {\n      rb.reset();\n      for (const int x : used[nums[r].second]) rb.set(x);\n    }\n    auto uni = rb & ~lb;\n    uint64_t* ptr = reinterpret_cast<uint64_t*>(&uni);\n    bool ex = false;\n    for (int i = 0; i <= maxn / 64 && !ex; ++i) {\n      if (*ptr) {\n        for (int j = 0; j < 64; ++j)\n          if ((*ptr) & (1uLL << j)) {\n            int idx = i * 64 + j;\n            result.emplace_back(nums[r].second + 1, nums[l].second + 1, idx);\n            lb[idx] = 1;\n            rb[idx] = 0;\n            --nums[r].first;\n            ++nums[l].first;\n            if (nums[l].first == need[l] || nums[r].first == need[r]) {\n              ex = true;\n              break;\n            }\n          }\n      }\n      ++ptr;\n    }\n  }\n  cout << result.size() << endl;\n  for (const auto& t : result)\n    cout << get<0>(t) << ' ' << get<1>(t) << ' ' << get<2>(t) << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007LL;\nlong long large = 2000000000000000000LL;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int> > a(n, vector<int>());\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    a[i].assign(x, 0);\n    for (int j = 0; j < x; j++) {\n      scanf(\"%d\", &a[i][j]);\n      a[i][j]--;\n    }\n  }\n  int s = 0;\n  for (int i = 0; i < n; i++) s += (int)a[i].size();\n  int ub = (s - 1) / n + 1;\n  int lb = s / n;\n  vector<set<int> > adj;\n  adj.assign(n, set<int>());\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < (int)a[i].size(); j++) adj[i].insert(a[i][j]);\n  }\n  vector<pair<pair<int, int>, int> > e;\n  vector<int> u, l;\n  for (int i = 0; i < n; i++) {\n    if ((int)a[i].size() >= ub) u.push_back(i);\n    if ((int)a[i].size() <= lb) l.push_back(i);\n  }\n  int q = (int)u.size() - (s % n);\n  int lp = 0;\n  int rp = 0;\n  while (lp < (int)l.size() && rp < (int)u.size()) {\n    set<int>::iterator it = adj[u[rp]].begin();\n    vector<int> toe;\n    while ((int)adj[u[rp]].size() - (int)toe.size() > (q > 0 ? lb : ub) &&\n           (int)adj[l[lp]].size() < (q < 0 ? ub : lb)) {\n      int x = *it;\n      if (adj[l[lp]].find(x) == adj[l[lp]].end()) {\n        toe.push_back(x);\n        adj[l[lp]].insert(x);\n        e.push_back(pair<pair<int, int>, int>(pair<int, int>(u[rp], l[lp]), x));\n      }\n      it++;\n    }\n    while (!toe.empty()) {\n      adj[u[rp]].erase(toe.back());\n      toe.pop_back();\n    }\n    if ((int)adj[u[rp]].size() == (q > 0 ? lb : ub)) {\n      if ((int)adj[u[rp]].size() == lb) q--;\n      rp++;\n    }\n    if ((int)adj[l[lp]].size() == (q < 0 ? ub : lb)) {\n      if ((int)adj[l[lp]].size() == ub) q++;\n      lp++;\n    }\n  }\n  cout << e.size() << endl;\n  for (int i = 0; i < (int)e.size(); i++) {\n    printf(\"%d %d %d\\n\", e[i].first.first + 1, e[i].first.second + 1,\n           e[i].second + 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma optimization_level 3\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nstruct Node {\n  Node *l = 0, *r = 0;\n  int sz = 0, num = -1;\n  Node(Node *a, Node *b) {\n    l = a;\n    r = b;\n    sz = l->sz + r->sz;\n  }\n  Node(Node *a, Node *b, int c) {\n    l = a;\n    r = b;\n    sz = c;\n  }\n};\nint gs(Node *n) { return n ? n->sz : 0; }\nvoid upd(Node *n) {\n  if (!n->l && !n->r) return;\n  n->sz = gs(n->l) + gs(n->r);\n}\nNode *add(int l, int r, int pos, Node *n) {\n  if (!n) n = new Node(0, 0, 1);\n  if (l == r) return n;\n  int md = (l + r) / 2;\n  if (pos <= md)\n    n->l = add(l, md, pos, n->l);\n  else\n    n->r = add(md + 1, r, pos, n->r);\n  upd(n);\n  return n;\n}\nNode *rem(int l, int r, int pos, Node *n) {\n  if (l == r) return new Node(0, 0, 0);\n  int md = (l + r) / 2;\n  if (pos <= md)\n    n->l = rem(l, md, pos, n->l);\n  else\n    n->r = rem(md + 1, r, pos, n->r);\n  upd(n);\n  return n;\n}\nint finddiff(int l, int r, Node *x, Node *y) {\n  if (l == r) return r;\n  int md = (l + r) / 2;\n  if (y == 0)\n    return gs(x->l) ? finddiff(l, md, x->l, 0) : finddiff(md + 1, r, x->r, 0);\n  assert(x && y);\n  if (gs(x->l) > gs(y->l))\n    return finddiff(l, md, x->l, y->l);\n  else\n    return finddiff(md + 1, r, x->r, y->r);\n}\nint a, KK, sumsz = 0, SZ = 1e5 + 5;\nmultiset<int> m;\nvector<Node *> v;\nint main() {\n  cin.tie(0);\n  cout.tie(0);\n  cin.sync_with_stdio(0);\n  cout.sync_with_stdio(0);\n  ;\n  cin >> a >> KK;\n  v = vector<Node *>(a);\n  for (int q = 0; q < a; q++) {\n    v[q] = new Node(0, 0, 0);\n    v[q]->num = q;\n    int t;\n    cin >> t;\n    sumsz += t;\n    for (; t; t--) {\n      int x;\n      cin >> x;\n      v[q] = add(1, SZ, x, v[q]);\n    }\n  }\n  sort(v.begin(), v.end(), [](Node *n1, Node *n2) { return n1->sz > n2->sz; });\n  int divsz = sumsz / a;\n  for (int q = 0; q < a; q++) m.insert(divsz);\n  for (int q = 0; q < sumsz % a; q++)\n    m.erase(m.find(divsz)), m.insert(divsz + 1);\n  int l = 0, r = a - 1;\n  vector<int> ans;\n  for (; l < r;) {\n    for (; l < r && m.count(v[l]->sz);) m.erase(m.find(v[l++]->sz));\n    for (; l < r && m.count(v[r]->sz);) m.erase(m.find(v[r--]->sz));\n    if (l >= r) break;\n    assert(v[l]->sz > v[r]->sz);\n    int n = finddiff(1, SZ, v[l], v[r]);\n    v[l] = rem(1, SZ, n, v[l]);\n    v[r] = add(1, SZ, n, v[r]);\n    ans.push_back(v[l]->num + 1);\n    ans.push_back(v[r]->num + 1);\n    ans.push_back(n);\n  }\n  cout << ans.size() / 3 << \"\\n\";\n  ;\n  for (int q = 0; q < ans.size(); q += 3) {\n    cout << ans[q] << \" \" << ans[q + 1] << \" \" << ans[q + 2] << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nunordered_set<int> ada[100005];\npriority_queue<pair<int, int> > pqmi, pqma;\nvector<pair<pair<int, int>, int> > ans;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    pqmi.push(make_pair(-x, i));\n    pqma.push(make_pair(x, i));\n    for (int j = 1; j <= x; j++) {\n      int y;\n      scanf(\"%d\", &y);\n      ada[i].insert(y);\n    }\n  }\n  while (pqma.top().first + pqmi.top().first > 1) {\n    pair<int, int> ma = pqma.top();\n    pqma.pop();\n    pair<int, int> mi = pqmi.top();\n    pqmi.pop();\n    for (auto x : ada[ma.second]) {\n      if (ada[mi.second].count(x) == 0) {\n        ans.push_back({make_pair(ma.second, mi.second), x});\n        ada[ma.second].erase(x);\n        ada[mi.second].insert(x);\n        break;\n      }\n    }\n    ma.first--;\n    mi.first--;\n    pqma.push(ma);\n    pqmi.push(mi);\n  }\n  printf(\"%d\\n\", ans.size());\n  for (int i = 0; i < ans.size(); i++) {\n    printf(\"%d %d %d\\n\", ans[i].first.first, ans[i].first.second,\n           ans[i].second);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nstruct Operation {\n  int from, to, kind;\n  Operation() {}\n  Operation(int from, int to, int kind) {\n    this->to = to;\n    this->from = from;\n    this->kind = kind;\n  }\n};\nint n, m;\nset<int> s[MAXN];\npair<int, int> getBorders(int &bigCnt) {\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    sum += s[i].size();\n  }\n  pair<int, int> out = {sum / n, sum / n};\n  if (sum % n != 0) out.second++;\n  bigCnt = sum % n;\n  return out;\n}\nint main() {\n  vector<Operation> answer;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    int sz;\n    cin >> sz;\n    for (int j = 0; j < sz; j++) {\n      int x;\n      cin >> x;\n      s[i].insert(x);\n    }\n  }\n  int bigCnt;\n  vector<int> v1, v2;\n  pair<int, int> border = getBorders(bigCnt);\n  for (int i = 1; i <= n; i++) {\n    if (s[i].size() <= border.first)\n      v1.push_back(i);\n    else if (s[i].size() >= border.second)\n      v2.push_back(i);\n  }\n  int ind = 0;\n  for (int x : v2) {\n    if (bigCnt == 0) border.second = border.first;\n    while (s[x].size() > border.second) {\n      while (ind < v1.size() && s[v1[ind]].size() >= border.first) ind++;\n      if (ind == v1.size()) break;\n      for (auto it = s[x].begin(); it != s[x].end();) {\n        if (s[v1[ind]].count(*it) == true) {\n          it++;\n          continue;\n        }\n        auto itNext = it;\n        itNext++;\n        answer.push_back(Operation(x, v1[ind], *it));\n        s[v1[ind]].insert(*it);\n        s[x].erase(it);\n        it = itNext;\n        if (s[v1[ind]].size() >= border.first || s[x].size() == border.second)\n          break;\n      }\n    }\n    bigCnt--;\n  }\n  ind = 0;\n  for (int x : v2) {\n    if (bigCnt <= 0) break;\n    if (s[x].size() <= border.second) continue;\n    while (s[x].size() > border.second) {\n      while (ind < v1.size() && s[v1[ind]].size() >= border.second) ind++;\n      if (ind == v1.size()) break;\n      for (auto it = s[x].begin(); it != s[x].end();) {\n        if (s[v1[ind]].count(*it) == true) {\n          it++;\n          continue;\n        }\n        auto itNext = it;\n        itNext++;\n        answer.push_back(Operation(x, v1[ind], *it));\n        s[v1[ind]].insert(*it);\n        s[x].erase(it);\n        it = itNext;\n        if (s[v1[ind]].size() >= border.second ||\n            s[x].size() == border.second) {\n          bigCnt--;\n          break;\n        }\n      }\n      if (bigCnt <= 0) break;\n    }\n    if (bigCnt <= 0) break;\n  }\n  cout << answer.size() << '\\n';\n  for (Operation item : answer)\n    cout << item.from << \" \" << item.to << \" \" << item.kind << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstd::vector<std::pair<std::unordered_set<int>, int>> v;\nbool cmp(std::pair<std::unordered_set<int>, int> v1,\n         std::pair<std::unordered_set<int>, int> v2) {\n  return v1.first.size() < v2.first.size();\n}\nstruct req {\n  int l, r, x;\n};\nsigned main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(0);\n  int n, m;\n  std::cin >> n >> m;\n  v.resize(n);\n  int sz = 0;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    std::cin >> x;\n    sz += x;\n    v[i].second = i;\n    for (int j = 0; j < x; ++j) {\n      int x1;\n      std::cin >> x1;\n      v[i].first.insert(x1);\n    }\n  }\n  std::vector<int> sizes;\n  for (int i = 0; i < n; ++i) {\n    sizes.push_back(sz / n + ((sz % n) > i));\n  }\n  std::sort(sizes.begin(), sizes.end());\n  std::sort(v.begin(), v.end(), cmp);\n  std::vector<req> answ;\n  int l = 0, r = n - 1;\n  while (l < r) {\n    std::vector<int> toErase;\n    for (auto d : v[r].first) {\n      if (sizes[l] - v[l].first.size() == 0) {\n        break;\n      }\n      if (v[r].first.size() - sizes[r] - toErase.size() == 0) {\n        break;\n      }\n      if (v[l].first.find(d) != v[l].first.end()) {\n        continue;\n      } else {\n        answ.push_back({v[r].second, v[l].second, d});\n        v[l].first.insert(d);\n        toErase.push_back(d);\n      }\n    }\n    for (auto q : toErase) {\n      v[r].first.erase(q);\n    }\n    int f1 = sizes[l] - v[l].first.size();\n    int f2 = v[r].first.size() - sizes[r];\n    assert(f1 == 0 || f2 == 0);\n    if (f1 == 0) {\n      l++;\n    }\n    if (f2 == 0) {\n      r--;\n    }\n  }\n  std::cout << answ.size() << '\\n';\n  for (auto d : answ) {\n    std::cout << d.l + 1 << ' ' << d.r + 1 << ' ' << d.x << '\\n';\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "n, m = map(int, raw_input().split())\n\na = []\nu = [{} for i in xrange(n)]\nk = 0\nfor i in xrange(n):\n    s = map(int, raw_input().split())\n    a.append([s[0], i])\n    for x in s[1:]: u[i][x] = 1\n    k += s[0]\na = sorted(a)\nh = n - (k % n)\nk = k / n\n\nwi = 0\nw = [() for i in xrange(10 ** 6)]\nfor i in xrange(n):\n    if a[i][0] > (k if i < h else k + 1):\n        for x in u[a[i][1]]:\n            w[wi] = (x, i)\n            wi += 1\nwn = wi\nwi = 0\n\nz = []\nfor i in xrange(n):\n    if a[i][0] < (k if i < h else k + 1):\n        while True:\n            x = w[wi][0]\n            j = w[wi][1]\n\n            if x not in u[a[i][1]] and a[j][0] > (k if j < h else k + 1):\n                u[a[i][1]][x] = 1\n                a[i][0] += 1\n                a[j][0] -= 1\n                z.append('%d %d %d' % (a[j][1] + 1, a[i][1] + 1, x))\n            else:\n                w[wn] = w[wi]\n                wn += 1\n\n            wi += 1\n            if a[i][0] == (k if i < h else k + 1): break\n\nprint len(z)\nif len(z) > 0: print '\\n'.join(z)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, m, s[N], p[N];\nvector<int> vet[N], nvet[N];\nint k;\nvector<pair<int, int>> all;\nvector<tuple<int, int, int>> ans;\nint pr[5 * N];\nint fn(int i) { return i == pr[i] ? i : pr[i] = fn(pr[i]); }\nint find(int id, int val) {\n  if (binary_search(vet[id].begin(), vet[id].end(), val)) return true;\n  if (binary_search(nvet[id].begin(), nvet[id].end(), val)) return true;\n  return false;\n}\nvector<int> qn[N];\nint id[N], sz;\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", s + i);\n    k += s[i];\n    vet[i].resize(s[i]);\n    for (int j = 0; j < s[i]; j++) scanf(\"%d\", &vet[i][j]);\n    sort(vet[i].begin(), vet[i].end());\n  }\n  k = (k + n - 1) / n;\n  for (int i = 1; i <= n; i++)\n    if (s[i] > k) {\n      for (int x : vet[i]) all.emplace_back(x, i);\n    }\n  sort(all.begin(), all.end());\n  for (int i = 0; i <= (int)all.size(); i++) {\n    pr[i] = i;\n  }\n  for (int i = 1; i <= n; i++)\n    if (s[i] < k) {\n      qn[s[i]].push_back(i);\n    }\n  for (int j = 0; j < k; j++) {\n    for (int x : qn[j]) id[sz++] = x;\n    for (int w = 0, u; w < sz; w++) {\n      u = id[w];\n      int &i = p[u];\n      i = fn(i);\n      while (i < (int)all.size()) {\n        if (s[all[i].second] <= k) {\n          pr[i] = i + 1;\n          i = fn(i + 1);\n        } else if (find(u, all[i].first))\n          i = fn(i + 1);\n        else\n          break;\n      }\n      if (i == (int)all.size()) continue;\n      ans.emplace_back(all[i].second, u, all[i].first);\n      nvet[u].push_back(all[i].first);\n      pr[i] = i + 1;\n      s[all[i].second]--;\n      s[u]++;\n    }\n  }\n  printf(\"%d\\n\", (int)ans.size());\n  int a, b, c;\n  for (auto &e : ans) {\n    tie(a, b, c) = e;\n    printf(\"%d %d %d\\n\", a, b, c);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nconst int N = 5e5 + 10;\nint h[2][N];\nset<int> trans;\nset<int> mse[N];\nint ansn = 0;\nint ans[N][3];\nvoid modifiedL(int x, int val) {\n  if (h[0][x] == 0 && h[1][x]) trans.erase(x);\n  h[0][x] += val;\n  if (h[0][x] == 0 && h[1][x]) trans.insert(x);\n}\nvoid modifiedR(int x, int val) {\n  if (h[0][x] == 0 && h[1][x]) trans.erase(x);\n  h[1][x] += val;\n  if (h[0][x] == 0 && h[1][x]) trans.insert(x);\n}\nvoid give(int x, int y, int pos) {\n  mse[y].insert(pos);\n  mse[x].erase(pos);\n  modifiedR(pos, -1);\n  modifiedL(pos, 1);\n  ++ansn;\n  ans[ansn][0] = x, ans[ansn][1] = y, ans[ansn][2] = pos;\n}\nint per[N];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> m;\n  int sumg = 0;\n  for (int i = 1; i <= n; i++) {\n    int n1;\n    cin >> n1;\n    sumg += n1;\n    while (n1--) {\n      int x;\n      cin >> x;\n      mse[i].insert(x);\n    }\n  }\n  int modn = sumg % n;\n  for (int i = 1; i <= n; i++) per[i] = i;\n  sort(per + 1, per + n + 1,\n       [](int x, int y) { return mse[x].size() < mse[y].size(); });\n  for (auto use : mse[per[n]]) modifiedR(use, 1);\n  for (auto use : mse[per[1]]) modifiedL(use, 1);\n  for (int i = 1, j = n; i < j;) {\n    int tarj = sumg / n;\n    if (n - j + 1 <= modn) tarj++;\n    if (mse[per[j]].size() == tarj) {\n      for (auto use : mse[per[j]]) modifiedR(use, -1);\n      j--;\n      for (auto use : mse[per[j]]) modifiedR(use, 1);\n      continue;\n    }\n    int tari = sumg / n;\n    if (n - i + 1 <= modn) tari++;\n    if (mse[per[i]].size() == tari) {\n      for (auto use : mse[per[i]]) modifiedL(use, -1);\n      i++;\n      for (auto use : mse[per[i]]) modifiedL(use, 1);\n      continue;\n    }\n    give(per[j], per[i], (*trans.begin()));\n  }\n  cout << ansn << '\\n';\n  for (int i = 1; i <= ansn; i++) {\n    for (int j = 0; j < 3; j++) cout << ans[i][j] << \" \";\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int oo = 0x3f3f3f3f;\nconst long long ooo = 9223372036854775807ll;\nconst int _cnt = 1000 * 1000 + 7;\nconst int _p = 1000 * 1000 * 1000 + 7;\nconst int N = 100005;\nconst double PI = acos(-1.0);\nconst double eps = 1e-9;\nint o(int x) { return x % _p; }\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nvoid file_put() {\n  string s = \"/home/jslijin/jslijin/code/\";\n  freopen((s + \"code.in\").c_str(), \"r\", stdin);\n  freopen((s + \"code.out\").c_str(), \"w\", stdout);\n}\nint n, m = 0, t, K, ans = 0, x, y, k, id[N], X[N], Y[N];\nvector<int> B[N], tmp;\nbool v[N];\nbool cmp(int x, int y) { return B[x].size() > B[y].size(); }\nvoid solve(int x, int y, int k) {\n  for (auto t : B[y]) v[t] = 1;\n  while (k) {\n    t = B[x].back(), B[x].pop_back();\n    if (v[t]) {\n      tmp.push_back(t);\n      continue;\n    }\n    B[y].push_back(t), k--, printf(\"%d %d %d\\n\", x, y, t);\n  }\n  for (auto t : tmp) B[x].push_back(t);\n  tmp.clear();\n  for (auto t : B[y]) v[t] = 0;\n}\nint main() {\n  scanf(\"%d%d\", &n, &K);\n  for (int i = (1); i <= (n); ++i) {\n    scanf(\"%d\", &k), id[i] = i, m += k;\n    while (k--) scanf(\"%d\", &x), B[i].push_back(x);\n  }\n  sort(id + 1, id + n + 1, cmp);\n  for (int i = (1); i <= (n); ++i)\n    X[i] = B[id[i]].size(), Y[i] = m / n + (i <= (m % n));\n  for (int i = (1); i <= (n); ++i)\n    if (X[i] > Y[i]) ans += X[i] - Y[i];\n  printf(\"%d\\n\", ans);\n  for (int l = 1, r = n; l < r;) {\n    x = l, y = r;\n    if (X[x] == Y[x]) {\n      ++l;\n      continue;\n    }\n    if (X[y] == Y[y]) {\n      --r;\n      continue;\n    }\n    k = ((abs(X[x] - Y[x])) < (abs(X[y] - Y[y])) ? (abs(X[x] - Y[x]))\n                                                 : (abs(X[y] - Y[y])));\n    X[x] -= k, X[y] += k, solve(id[x], id[y], k);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int SZ = 1000;\nconst int N = 1e6;\nint n, m, tot = 0, tar[N + 10];\nstruct data {\n  int loc, va;\n} a[N + 10];\nvector<int> vec[N + 10];\nvector<int> vc;\nint vis[N + 10], vp[N + 10];\nbool cmp(data p, data q) { return p.va < q.va; }\nvoid Solve1() {\n  for (;;) {\n    int vx = 0, vy = 0;\n    for (int i = 1; i <= n; i++) {\n      if ((int)vec[i].size() > tar[i]) vx = i;\n      if ((int)vec[i].size() < tar[i]) vy = i;\n    }\n    if (vx == 0 || vy == 0) break;\n    int cnt1 = vec[vx].size(), cnt2 = vec[vy].size();\n    for (int i = 0; i < (int)vec[vy].size(); i++) vis[vec[vy][i]] = 1;\n    for (int i = 0; i < (int)vec[vx].size(); i++) vp[i] = 0;\n    for (int i = 0; i < (int)vec[vx].size(); i++)\n      if (!vis[vec[vx][i]]) {\n        vp[i] = 1;\n        vec[vy].push_back(vec[vx][i]);\n        printf(\"%d %d %d\\n\", vx, vy, vec[vx][i]);\n        cnt1--;\n        cnt2++;\n        if (cnt1 == tar[vx]) break;\n        if (cnt2 == tar[vy]) break;\n      }\n    vc.clear();\n    for (int i = 0; i < (int)vec[vx].size(); i++)\n      if (!vp[i]) vc.push_back(vec[vx][i]);\n    vec[vx] = vc;\n    for (int i = 0; i < (int)vec[vy].size(); i++) vis[vec[vy][i]] = 0;\n  }\n}\nset<pair<int, int> > s;\nvoid Solve2() {\n  for (int i = 1; i <= n; i++) s.insert(make_pair(vec[i].size(), i));\n  while (1) {\n    set<pair<int, int> >::iterator it1 = s.begin(), it2 = s.end();\n    it2--;\n    pair<int, int> pii1 = *it1, pii2 = *it2;\n    if (pii2.first - pii1.first <= 1) break;\n    int kx = pii2.second, px = pii1.second;\n    for (int i = 0; i < (int)vec[px].size(); i++) vis[vec[px][i]] = 1;\n    for (int i = vec[kx].size() - 1; i >= 0; i--)\n      if (!vis[vec[kx][i]]) {\n        printf(\"%d %d %d\\n\", kx, px, vec[kx][i]);\n        vec[px].push_back(vec[kx][i]);\n        for (int j = i; j < (int)vec[kx].size() - 1; j++)\n          vec[kx][j] = vec[kx][j + 1];\n        vec[kx].pop_back();\n        break;\n      }\n    for (int i = 0; i < (int)vec[px].size(); i++) vis[vec[px][i]] = 0;\n    s.erase(it1);\n    s.erase(it2);\n    s.insert(make_pair(vec[kx].size(), kx));\n    s.insert(make_pair(vec[px].size(), px));\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    a[i].loc = i;\n    a[i].va = k;\n    for (int j = 1; j <= k; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      vec[i].push_back(x);\n    }\n    tot += vec[i].size();\n  }\n  sort(a + 1, a + n + 1, cmp);\n  for (int i = 1; i <= n; i++) tar[i] = tot / n;\n  for (int i = 1; i <= tot % n; i++) tar[a[n + 1 - i].loc]++;\n  int ans = 0;\n  for (int i = 1; i <= n; i++)\n    if ((int)vec[i].size() > tar[i]) ans += vec[i].size() - tar[i];\n  printf(\"%d\\n\", ans);\n  if (n <= SZ)\n    Solve1();\n  else\n    Solve2();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct el {\n  int ind;\n  set<int> a;\n} a[100002];\nstruct ans {\n  int from, to, kind;\n};\nbool operator<(const el& a, const el& b) { return a.a.size() < b.a.size(); }\nvector<ans> res;\nint main() {\n  int n, m;\n  int q = 0;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    int s;\n    cin >> s;\n    while (s--) {\n      int x;\n      cin >> x;\n      a[i].a.insert(x);\n    }\n    q += a[i].a.size();\n    a[i].ind = i;\n  }\n  sort(a, a + n);\n  int l = 0, r = n - 1;\n  int k = q / n;\n  q = q % n;\n  while (l < r) {\n    set<int>& L = a[l].a;\n    set<int>& R = a[r].a;\n    int ls = k + (l + q >= n), rs = k + (r + q >= n);\n    if (L.size() == ls && R.size() == rs) break;\n    for (auto it = R.begin(); it != R.end();) {\n      if (L.size() == ls) break;\n      if (R.size() == rs) break;\n      if (L.insert(*it).second) {\n        res.push_back({a[r].ind + 1, a[l].ind + 1, *it});\n        it = R.erase(it);\n      } else\n        it++;\n    }\n    if (L.size() == ls) l++;\n    if (R.size() == rs) r--;\n  }\n  cout << res.size() << '\\n';\n  for (auto i : res) {\n    cout << i.from << ' ' << i.to << ' ' << i.kind << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 222;\nset<int> ori[maxn];\nvector<int> ids[maxn];\nint top, bot;\nint dest[maxn];\nint have[maxn];\nint occ[maxn];\nint ans[maxn][3];\nint arr = 0;\nint flag[maxn];\nvector<pair<int, int> > pp;\nvoid solve() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  int tot = 0;\n  for (int i = 1; i <= n; i++) {\n    int s;\n    scanf(\"%d\", &s);\n    tot += s;\n    int a;\n    for (int j = 1; j <= s; j++) {\n      scanf(\"%d\", &a);\n      ori[i].insert(a);\n    }\n    pp.push_back(make_pair(s, i));\n  }\n  sort(pp.begin(), pp.end());\n  reverse(pp.begin(), pp.end());\n  bot = tot / n;\n  top = bot;\n  if (tot % n) top++;\n  int topcnt = tot % n;\n  for (int i = 0; i < pp.size(); i++) {\n    if (i < topcnt)\n      dest[pp[i].second] = top;\n    else\n      dest[pp[i].second] = bot;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (ori[i].size() < dest[i]) flag[i] = 1;\n  }\n  set<int> se;\n  for (int i = 1; i <= n; i++) {\n    if (ori[i].size() > dest[i]) {\n      for (int a : ori[i]) {\n        occ[a]++;\n        se.insert(a);\n        ids[a].push_back(i);\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (flag[i]) {\n      int needcnt = dest[i] - ori[i].size();\n      for (int a : ori[i]) have[a] = 1;\n      vector<int> needdel;\n      for (int id : se) {\n        if (!have[id] && occ[id] > 0) {\n          while (ori[ids[id].back()].size() == dest[ids[id].back()]) {\n            ids[id].pop_back();\n          }\n          int fid = ids[id].back();\n          ids[id].pop_back();\n          arr++;\n          ans[arr][0] = fid;\n          ans[arr][1] = i;\n          ans[arr][2] = id;\n          ori[fid].erase(id);\n          occ[id]--;\n          if (occ[id] == 0) needdel.push_back(id);\n          if (ori[fid].size() == dest[fid]) {\n            for (int a : ori[fid]) {\n              occ[a]--;\n              if (occ[a] == 0) needdel.push_back(a);\n            }\n          }\n          needcnt--;\n        }\n        if (needcnt == 0) break;\n      }\n      for (int a : ori[i]) have[a] = 0;\n      for (int a : needdel) se.erase(a);\n    }\n  }\n  cout << arr << endl;\n  for (int i = 1; i <= arr; i++) {\n    printf(\"%d %d %d\\n\", ans[i][0], ans[i][1], ans[i][2]);\n  }\n}\nsigned main() { solve(); }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nconst long long mod = 1000000007;\nconst int N = 1e5 + 5;\nset<int> boxs[N];\nint main(int argc, char** argv) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  int total = 0;\n  for (int i = 0, a; i < n; i++) {\n    cin >> a;\n    total += a;\n    for (int j = 0, x; j < a; j++) {\n      cin >> x;\n      boxs[i + 1].insert(x);\n    }\n  }\n  int target = (total + n - 1) / n;\n  int gr = 0;\n  set<pair<int, int>> st;\n  for (int i = 1; i <= n; i++)\n    st.insert({boxs[i].size(), i}), gr += (boxs[i].size() >= target);\n  vector<pair<int, pair<int, int>>> moves;\n  while (st.size() > 1) {\n    int sm = st.begin()->first;\n    int ma = st.rbegin()->first;\n    if (ma - sm <= 1) break;\n    int small_index = st.begin()->second;\n    int big_index = st.rbegin()->second;\n    st.erase(st.begin());\n    st.erase(*st.rbegin());\n    int Need = 0;\n    if (gr < total % n)\n      Need = target;\n    else\n      Need = total / n;\n    for (set<int>::iterator it = boxs[big_index].begin();\n         it != boxs[big_index].end() && ma - sm > 1 && sm < Need &&\n         ma > Need;) {\n      if (boxs[small_index].find(*it) != boxs[small_index].end()) {\n        it++;\n        continue;\n      }\n      auto temp = it;\n      temp++;\n      boxs[small_index].insert(*it);\n      moves.push_back({big_index, {small_index, *it}});\n      boxs[big_index].erase(*it);\n      it = temp;\n      sm++;\n      ma--;\n    }\n    st.insert({ma, big_index});\n    st.insert({sm, small_index});\n    if (sm >= target) gr--;\n  }\n  cout << moves.size() << '\\n';\n  for (int i = 0; i < moves.size(); i++) {\n    cout << moves[i].first << \" \" << moves[i].second.first << \" \"\n         << moves[i].second.second << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = (1ll << 32);\nconst int LOGN = 14;\nconst long long INF = (1ll << 62);\nlong long __gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return __gcd(b, a % b);\n}\nbool comp(pair<int, unordered_set<int> >& a,\n          pair<int, unordered_set<int> >& b) {\n  return a.second.size() > b.second.size();\n}\nint main() {\n  std ::ios_base ::sync_with_stdio(false);\n  cin.tie(NULL), cout.tie(NULL);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<int, unordered_set<int> > > a(n);\n  int sz;\n  int ct = 0;\n  int ct_p1 = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> sz;\n    ct += sz;\n    a[i].first = i;\n    int x;\n    for (int j = 0; j < sz; ++j) {\n      cin >> x;\n      a[i].second.insert(x);\n    }\n  }\n  ct_p1 = ct % n;\n  ct /= n;\n  sort(a.begin(), a.end(), comp);\n  int l = 0;\n  int r = n - 1;\n  vector<vector<int> > ans;\n  while (l < r) {\n    int req_l_size = ct;\n    int req_r_size = ct;\n    if (l < ct_p1) req_l_size++;\n    if (r < ct_p1) req_r_size++;\n    vector<int> temp;\n    for (auto it : a[l].second) {\n      if ((int)a[l].second.size() - (int)temp.size() == req_l_size) break;\n      if (a[r].second.size() == req_r_size) break;\n      if (a[r].second.find(it) == a[r].second.end()) {\n        temp.push_back(it);\n        a[r].second.insert(it);\n        vector<int> x;\n        x.push_back(a[l].first);\n        x.push_back(a[r].first);\n        x.push_back(it);\n        ans.push_back(x);\n      }\n    }\n    for (int i = 0; i < temp.size(); ++i) a[l].second.erase(temp[i]);\n    if (a[r].second.size() == req_r_size) r--;\n    if (a[l].second.size() == req_l_size) l++;\n  }\n  cout << ans.size() << endl;\n  for (int i = 0; i < ans.size(); ++i)\n    cout << ans[i][0] + 1 << \" \" << ans[i][1] + 1 << \" \" << ans[i][2] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nconst int MAXN = 1e5 + 5;\nint s[MAXN];\nvector<int> h, d;\nset<int> st[MAXN];\nint main() {\n  int n = read(), m = read();\n  int Sum = 0;\n  for (int i = 1; i <= n; i++) {\n    s[i] = read();\n    Sum += s[i];\n    for (int j = 1; j <= s[i]; j++) {\n      st[i].insert(read());\n    }\n  }\n  int Div = Sum / n;\n  int mo = Sum % n;\n  int tmp = mo, tmp2 = mo;\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (s[i] > Div) tmp--;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (tmp2 > 0) {\n      if (s[i] > Div + 1) {\n        h.push_back(i);\n        ans += s[i] - (Div + 1);\n        tmp2--;\n      } else if (s[i] == Div + 1) {\n        tmp2--;\n      } else if (s[i] == Div) {\n        if (tmp > 0) d.push_back(i);\n      } else {\n        d.push_back(i);\n      }\n    } else {\n      if (s[i] > Div) {\n        ans += s[i] - Div;\n        h.push_back(i);\n      } else if (s[i] < Div) {\n        d.push_back(i);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  auto l = d.begin();\n  for (auto i : h) {\n    for (; l != d.end(); l++) {\n      bool flag = 0;\n      for (auto x = st[i].begin(), x2 = x; x != st[i].end(); x = x2) {\n        x2++;\n        if (s[i] == Div + (mo > 0)) {\n          flag = 1;\n          break;\n        }\n        if (!st[*l].count(*x)) {\n          printf(\"%d %d %d\\n\", i, *l, *x);\n          s[*l]++;\n          st[*l].insert(*x);\n          st[i].erase(x);\n          s[i]--;\n        }\n        if (tmp2 > 0) {\n          if (s[*l] == Div + 1) {\n            tmp2--;\n            break;\n          }\n        } else {\n          if (s[*l] == Div) break;\n        }\n      }\n      if (flag) break;\n    }\n    mo--;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nstruct ans_s {\n  int from;\n  int to;\n  int kind;\n};\npair<int, int> a[N];\nset<int> s[N];\nint f[N];\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, m;\n  cin >> n >> m;\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i].first;\n    a[i].second = i;\n    sum += a[i].first;\n    for (int j = 1; j <= a[i].first; j++) {\n      int c;\n      cin >> c;\n      s[i].insert(c);\n    }\n  }\n  sort(a + 1, a + n + 1);\n  reverse(a + 1, a + n + 1);\n  for (int i = 1; i <= n; i++) {\n    if (i <= sum % n) {\n      f[i] = sum / n + 1;\n    } else {\n      f[i] = sum / n;\n    }\n  }\n  int l = 1, r = n;\n  vector<ans_s> ans;\n  while (1) {\n    while (l <= n && a[l].first == f[l]) {\n      l++;\n    }\n    while (r > 0 && a[r].first == f[r]) {\n      r--;\n    }\n    if (l > n || r < 1) {\n      break;\n    }\n    vector<int> todel;\n    while (a[l].first != f[l] && a[r].first != f[r]) {\n      for (auto x : s[a[l].second]) {\n        set<int>::iterator it;\n        it = s[a[r].second].find(x);\n        if (it != s[a[r].second].end()) {\n          continue;\n        }\n        s[a[r].second].insert(x);\n        ans_s g;\n        g.from = a[l].second;\n        g.to = a[r].second;\n        g.kind = x;\n        ans.push_back(g);\n        todel.push_back(x);\n        a[l].first--;\n        a[r].first++;\n        if (a[l].first == f[l] || a[r].first == f[r]) {\n          break;\n        }\n      }\n    }\n    for (auto x : todel) {\n      s[a[l].second].erase(x);\n    }\n  }\n  cout << ans.size() << \"\\n\";\n  for (auto x : ans) {\n    cout << x.from << \" \" << x.to << \" \" << x.kind << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 179;\nint n, m, ind[MAXN], buf[MAXN], sizes[MAXN], bufsz;\nset<int> g[MAXN];\nvector<tuple<int, int, int> > ans;\nvoid insert(int i1, int i2, int cnt) {\n  bufsz = 0;\n  for (int col : g[i1]) {\n    if (!cnt) {\n      break;\n    }\n    if (!g[i2].count(col)) {\n      --cnt;\n      buf[bufsz++] = col;\n      ans.push_back({i1 + 1, i2 + 1, col});\n    }\n  }\n  assert(cnt == 0);\n  for (int i = 0; i < bufsz; ++i) {\n    g[i2].insert(buf[i]);\n    g[i1].erase(buf[i]);\n  }\n}\nvoid solve() {\n  cin >> n >> m;\n  int total = 0, sz, x;\n  for (int i = 0; i < n; ++i) {\n    cin >> sz;\n    total += sz;\n    for (int j = 0; j < sz; ++j) {\n      cin >> x;\n      g[i].insert(x);\n    }\n  }\n  int k = total / n, ptr = 0;\n  x = total % n;\n  iota(ind, ind + n, 0);\n  fill_n(sizes, n, k);\n  fill_n(sizes, x, k + 1);\n  sort(ind, ind + n, [](int x, int y) { return g[x].size() > g[y].size(); });\n  for (int i = 0; i < n; ++i) {\n    int i1 = ind[i];\n    while ((int)g[i1].size() > sizes[i]) {\n      for (; ptr < n && (int)g[ind[ptr]].size() >= sizes[ptr]; ++ptr)\n        ;\n      if (ptr == n) {\n        break;\n      }\n      int c1 = (int)g[i1].size() - sizes[i];\n      int c2 = sizes[ptr] - (int)g[ind[ptr]].size();\n      insert(i1, ind[ptr], min(c1, c2));\n    }\n  }\n  cout << ans.size() << endl;\n  for (const auto& x : ans) {\n    cout << (get<0>(x)) << \" \" << (get<1>(x)) << \" \" << (get<2>(x)) << '\\n';\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cout.tie(0);\n  cin.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MN = 1e5 + 5;\nstruct qry {\n  int t;\n  set<int> s;\n} inp[MN];\nstruct cmp {\n  bool operator()(const qry *lhs, const qry *rhs) {\n    return pair<int, int>(lhs->s.size(), lhs->t) <\n           pair<int, int>(rhs->s.size(), rhs->t);\n  }\n};\nint N, M, lav, hav, tot = 0;\nset<qry *, cmp> presents;\nvector<pair<pair<int, int>, int> > ops;\nbool ins(qry *x) {\n  presents.insert(x);\n  return x->s.size() < lav || x->s.size() > hav;\n}\nvoid exchange(qry *l, qry *h) {\n  set<int> &ls = l->s, &hs = h->s;\n  int mops = max(1, (int)min(lav - ls.size(), hs.size() - hav));\n  for (auto it = hs.begin(); mops > 0;) {\n    assert(it != hs.end());\n    int x = *it;\n    if (ls.insert(x).second) {\n      it = hs.erase(it);\n      mops--;\n      ops.push_back({{h->t, l->t}, x});\n    } else {\n      it++;\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> N >> M;\n  for (int i = 0, v, x; i < N; i++) {\n    inp[i].t = i + 1;\n    cin >> v;\n    tot += v;\n    while (v--) {\n      cin >> x;\n      inp[i].s.insert(x);\n    }\n  }\n  lav = tot / N;\n  hav = lav + (tot % N > 0);\n  for (int i = 0; i < N; i++) {\n    ins(&inp[i]);\n  }\n  while (!presents.empty()) {\n    qry *l = *presents.begin(), *h = *presents.rbegin();\n    if ((l->s.size() >= lav) && (h->s.size() <= hav)) {\n      break;\n    }\n    presents.erase(l);\n    presents.erase(h);\n    exchange(l, h);\n    assert(!ins(l) | !ins(h));\n  }\n  printf(\"%d\\n\", ops.size());\n  for (auto p : ops) {\n    printf(\"%d %d %d\\n\", p.first.first, p.first.second, p.second);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, r, m, an, ans[1000001][3], sz, x, siz, A, B, t[100001], tn, oN, o[21];\nset<int> v[100001];\nset<pair<int, int> > s;\nset<int>::iterator nw, it;\nset<pair<int, int> >::iterator itt;\nnamespace io {\nconst int SIZE = (1 << 21) + 1;\nchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c,\n                                       qu[55];\nint f, qr;\ninline void flush() {\n  fwrite(obuf, 1, oS - obuf, stdout);\n  oS = obuf;\n}\ninline void putc(char x) {\n  *oS++ = x;\n  if (oS == oT) flush();\n}\ninline char gch() {\n  char c = (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),\n                        (iS == iT ? EOF : *iS++))\n                     : *iS++);\n  for (; isspace(c);\n       c = (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),\n                       (iS == iT ? EOF : *iS++))\n                     : *iS++))\n    ;\n  return c;\n}\ninline void gs(char *c) {\n  char x = (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),\n                        (iS == iT ? EOF : *iS++))\n                     : *iS++);\n  for (; isspace(x);\n       x = (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),\n                       (iS == iT ? EOF : *iS++))\n                     : *iS++))\n    ;\n  for (; !isspace(x);\n       x = (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),\n                       (iS == iT ? EOF : *iS++))\n                     : *iS++))\n    *c++ = x;\n  *c = 0;\n}\ntemplate <class I>\ninline void gi(I &x) {\n  for (f = 1, c = (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),\n                              (iS == iT ? EOF : *iS++))\n                            : *iS++);\n       c < '0' || c > '9';\n       c = (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),\n                       (iS == iT ? EOF : *iS++))\n                     : *iS++))\n    if (c == '-') f = -1;\n  for (x = 0; c <= '9' && c >= '0';\n       c = (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),\n                       (iS == iT ? EOF : *iS++))\n                     : *iS++))\n    x = x * 10 + (c & 15);\n  x *= f;\n}\ntemplate <class I>\ninline void print(I x) {\n  if (!x) putc('0');\n  if (x < 0) putc('-'), x = -x;\n  while (x) qu[++qr] = x % 10 + '0', x /= 10;\n  while (qr) putc(qu[qr--]);\n}\nstruct Flusher_ {\n  ~Flusher_() { flush(); }\n} io_flusher_;\n}  // namespace io\nusing io ::gch;\nusing io ::gi;\nusing io ::gs;\nusing io ::print;\nusing io ::putc;\nvoid pri() {\n  print(an);\n  putc('\\n');\n  for (int i = 1; i <= an; i++)\n    print(ans[i][0]), putc(' '), print(ans[i][1]), putc(' '), print(ans[i][2]),\n        putc('\\n');\n}\nvoid ins(int x, int y, int z) {\n  ans[++an][0] = x, ans[an][1] = y, ans[an][2] = z;\n}\nint main() {\n  gi(n), gi(m);\n  s.clear();\n  siz = 0;\n  for (int i = 1; i <= n; i++) {\n    gi(sz);\n    v[i].clear();\n    siz += sz;\n    v[i].insert(-1);\n    for (int j = 0; j < sz; j++) gi(x), v[i].insert(x);\n    s.insert(make_pair(sz + 1, i));\n  }\n  l = siz / n;\n  if (siz % n != 0)\n    r = l + 1;\n  else\n    r = l;\n  l++;\n  r++;\n  while (1) {\n    itt = s.end();\n    itt--;\n    if ((*(s.begin())).first >= l || (*itt).first <= r) break;\n    A = (*(s.begin())).second;\n    B = (*itt).second;\n    s.erase(make_pair(v[A].size(), A));\n    s.erase(make_pair(v[B].size(), B));\n    nw = v[A].begin();\n    tn = 0;\n    while (v[A].size() + tn < l && v[B].size() > r) {\n      it = v[B].upper_bound(*nw);\n      while (nw != v[A].end() && (*nw) < (*it)) nw++;\n      if (nw == v[A].end() || (*it) != (*nw)) {\n        ins(B, A, *it);\n        t[++tn] = (*it);\n        v[B].erase(it);\n        nw--;\n      }\n    }\n    for (int i = 1; i <= tn; i++) v[A].insert(t[i]);\n    s.insert(make_pair(v[A].size(), A));\n    s.insert(make_pair(v[B].size(), B));\n  }\n  while ((*(s.begin())).first < l) {\n    itt = s.end();\n    itt--;\n    A = (*(s.begin())).second;\n    B = (*itt).second;\n    s.erase(make_pair(v[A].size(), A));\n    s.erase(make_pair(v[B].size(), B));\n    nw = v[A].begin();\n    tn = 0;\n    while (v[A].size() + tn < l && v[B].size() > l) {\n      it = v[B].upper_bound(*nw);\n      while (nw != v[A].end() && (*nw) < (*it)) nw++;\n      if (nw == v[A].end() || (*it) != (*nw)) {\n        ins(B, A, *it);\n        t[++tn] = (*it);\n        v[B].erase(it);\n        nw--;\n      }\n    }\n    for (int i = 1; i <= tn; i++) v[A].insert(t[i]);\n    s.insert(make_pair(v[A].size(), A));\n    s.insert(make_pair(v[B].size(), B));\n  }\n  while (1) {\n    itt = s.end();\n    itt--;\n    if ((*itt).first <= r) break;\n    A = (*(s.begin())).second;\n    B = (*itt).second;\n    s.erase(make_pair(v[A].size(), A));\n    s.erase(make_pair(v[B].size(), B));\n    nw = v[A].begin();\n    tn = 0;\n    while (v[A].size() + tn < r && v[B].size() > r) {\n      it = v[B].upper_bound(*nw);\n      while (nw != v[A].end() && (*nw) < (*it)) nw++;\n      if (nw == v[A].end() || (*it) != (*nw)) {\n        ins(B, A, *it);\n        t[++tn] = (*it);\n        v[B].erase(it);\n        nw--;\n      }\n    }\n    for (int i = 1; i <= tn; i++) v[A].insert(t[i]);\n    s.insert(make_pair(v[A].size(), A));\n    s.insert(make_pair(v[B].size(), B));\n  }\n  pri();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pci = pair<char, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nconst ll infll = 1e18 + 3;\nconst int maxn = 1e6 + 77;\nconst int nmax = 1e6 + 577;\nconst ll basell = 1e18 + 3;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-7;\nconst int inf = 1009000999;\nconst int nv = 100505;\nconst int baseint = 1000200013;\nconst ld PI = acos(-1.0);\ninline bool EQ(ld a, ld b) { return fabs(a - b) < 1e-9; }\ninline bool IF(int a, int b, int c) { return (a >= b && a <= c); }\ninline bool IFS(int a, int b, int c) { return (a > b && a < c); }\ntemplate <typename T>\ninline istream &operator>>(istream &_in, vector<T> &_v) {\n  for (auto &_i : _v) {\n    _in >> _i;\n  }\n  return _in;\n}\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\nvi g[nv];\nint siz[nv];\npii indx[nv];\nmap<int, vpii> pred;\nint inline solve() {\n  ios::sync_with_stdio(NULL), cin.tie(NULL), cout.tie(NULL);\n  ;\n  int n, m;\n  cin >> n >> m;\n  int sum = 0;\n  for (int i = 0; i < n; ++i) {\n    int s;\n    cin >> s;\n    sum += s;\n    indx[i] = {s, i};\n    siz[i] = s;\n    for (int j = 0; j < s; ++j) {\n      int a;\n      cin >> a;\n      g[a - 1].push_back(i);\n    }\n  }\n  sort(indx, indx + n);\n  vector<pair<pii, int>> ans;\n  vector<int> d(n);\n  for (int i = 0; i < n; i++) {\n    d[indx[i].second] = sum / (n - i);\n    sum -= d[indx[i].second];\n  }\n  vi small;\n  for (int i = 0; i < n; ++i) {\n    if (siz[i] < d[i]) {\n      small.push_back(i);\n    }\n  }\n  vi z(n, -1);\n  for (int i = 0; i < m; ++i) {\n    vi big;\n    for (int x : g[i]) {\n      z[x] = i;\n      if (siz[x] > d[x]) {\n        big.push_back(x);\n      }\n    }\n    int j = 0;\n    for (int x : big) {\n      while (j < ((int)(small).size()) && z[small[j]] == i) j++;\n      if (j >= ((int)(small).size())) break;\n      int &y = small[j];\n      ans.push_back({{x, y}, i});\n      siz[x]--;\n      siz[y]++;\n      if (siz[y] == d[y]) {\n        swap(y, small.back());\n        small.pop_back();\n      } else {\n        j++;\n      }\n    }\n  }\n  cout << ((int)(ans).size()) << '\\n';\n  for (auto i : ans) {\n    cout << i.first.first + 1 << \" \" << i.first.second + 1 << \" \"\n         << i.second + 1 << '\\n';\n  }\n  return 0;\n}\nint32_t main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nvector<int> v[100005];\nint need[100005], sz[100005], mk[100005];\nint sum = 0;\npair<int, int> pp[100005];\nset<int> ss;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &sz[i]);\n    for (int j = 0; j < sz[i]; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      v[x].push_back(i);\n    }\n    sum += sz[i];\n    pp[i] = {-sz[i], i};\n  }\n  sort(pp, pp + n);\n  for (int i = 0; i < n; i++) {\n    need[pp[i].second] = sum / n;\n    if (i < sum % n) need[pp[i].second]++;\n  }\n  int ret = 0;\n  for (int i = 0; i < n; i++) {\n    ret += abs(sz[i] - need[i]);\n    if (sz[i] < need[i]) {\n      ss.insert(i);\n    }\n  }\n  printf(\"%d\\n\", ret / 2);\n  memset(mk, 0, sizeof(mk));\n  for (int i = 1; i <= m; i++) {\n    int big = 0;\n    for (int j = 0; j < v[i].size(); j++) {\n      if (sz[v[i][j]] < need[v[i][j]]) {\n        mk[v[i][j]] = 1;\n      }\n    }\n    auto it = ss.begin();\n    vector<int> del;\n    for (int j = 0; j < v[i].size(); j++) {\n      if (sz[v[i][j]] > need[v[i][j]]) {\n        while (it != ss.end() && mk[(*it)] == 1) it++;\n        if (it != ss.end()) {\n          printf(\"%d %d %d\\n\", v[i][j] + 1, (*it) + 1, i);\n          sz[v[i][j]]--;\n          sz[(*it)]++;\n          if (sz[(*it)] == need[(*it)]) {\n            del.push_back((*it));\n          }\n          it++;\n        }\n      }\n    }\n    for (int j = 0; j < del.size(); j++) {\n      ss.erase(del[j]);\n    }\n    for (int j = 0; j < v[i].size(); j++) {\n      if (sz[v[i][j]] < need[v[i][j]]) {\n        mk[v[i][j]] = 0;\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  cout.precision(30);\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  long long sum = 0;\n  vector<vector<long long>> a(n);\n  for (int i = 0; i < n; i++) {\n    int s;\n    cin >> s;\n    sum += s;\n    while (s--) {\n      int b;\n      cin >> b;\n      b--;\n      a[i].push_back(b);\n    }\n  }\n  vector<pair<vector<long long>, int>> cc(n);\n  for (int i = 0; i < n; i++) {\n    cc[i] = {a[i], i};\n  }\n  sort(cc.begin(), cc.end(),\n       [&](pair<vector<long long>, int> a, pair<vector<long long>, int> b) {\n         return a.first.size() > b.first.size();\n       });\n  vector<long long> num(n);\n  for (int i = 0; i < n; i++) a[i] = cc[i].first, num[i] = cc[i].second;\n  vector<set<long long>> b(n);\n  for (int i = 0; i < n; i++) {\n    for (auto &j : a[i]) b[i].insert(j);\n  }\n  vector<long long> need(n);\n  for (int i = 0; i < n; i++) {\n    if (i < sum % n)\n      need[i] = sum / n + 1 - b[i].size();\n    else\n      need[i] = sum / n - b[i].size();\n  }\n  sort(need.begin(), need.end());\n  int l = 0, r = n;\n  for (int i = 0; i < n; i++)\n    if (need[i] > 0) {\n      r = i;\n      break;\n    }\n  long long rr = r;\n  if (r == n) {\n    cout << 0;\n    exit(0);\n  }\n  vector<vector<long long>> ans;\n  while (l < rr && r < n) {\n    vector<long long> to_add;\n    for (auto &i : b[r]) {\n      if (b[l].count(i)) b[l].erase(i), to_add.push_back(i);\n    }\n    if (abs(need[l]) > abs(need[r])) {\n      vector<long long> to_del;\n      for (auto &i : b[l]) {\n        if (need[r] == 0) break;\n        need[l]++;\n        auto x = i;\n        to_del.push_back(x);\n        b[r].insert(x);\n        ans.push_back({num[l], num[r], x});\n        need[r]--;\n      }\n      if (need[r] != 0) cout << l << ' ' << r << \"AAAAAAAA\\n\";\n      for (auto &i : to_del) b[l].erase(i);\n      for (auto &i : to_add) b[l].insert(i);\n      r++;\n    } else {\n      for (auto &i : b[l]) {\n        if (need[l] == 0) break;\n        need[l]++;\n        auto x = i;\n        b[r].insert(x);\n        ans.push_back({num[l], num[r], x});\n        need[r]--;\n      }\n      l++;\n    }\n  }\n  cout << ans.size() << endl;\n  for (auto &i : ans)\n    cout << i[0] + 1 << ' ' << i[1] + 1 << ' ' << i[2] + 1 << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint vis[100005], fr[100005], to[100005];\nvector<int> seq[100005];\nstruct f {\n  int id, sz;\n} a[100005];\nbool cmp(f x, f y) { return x.sz > y.sz; }\nvoid move(int x, int y, int z) {\n  int i, j;\n  vector<int> tmp;\n  for (i = 0; i < seq[y].size(); i++) vis[seq[y][i]] = 1;\n  while (z) {\n    int t = seq[x].back();\n    seq[x].pop_back();\n    if (vis[t]) {\n      tmp.push_back(t);\n      continue;\n    }\n    printf(\"%d %d %d\\n\", x, y, t);\n    seq[y].push_back(t);\n    z--;\n  }\n  for (i = 0; i < seq[y].size(); i++) vis[seq[y][i]] = 0;\n  while (!tmp.empty()) {\n    seq[x].push_back(tmp.back());\n    tmp.pop_back();\n  }\n}\nint main() {\n  int i, j, _;\n  scanf(\"%d%d\", &n, &_);\n  for (i = 1; i <= n; i++) {\n    a[i].id = i;\n    scanf(\"%d\", &a[i].sz);\n    m += (fr[i] = a[i].sz);\n    for (j = 1; j <= a[i].sz; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      seq[i].push_back(x);\n    }\n  }\n  sort(a + 1, a + n + 1, cmp);\n  for (i = 1; i <= n; i++) to[i] = m / n + ((m % n) >= i);\n  int ans = 0;\n  for (i = 1; i <= n; i++) {\n    ans += max(0, to[i] - fr[a[i].id]);\n  }\n  printf(\"%d\\n\", ans);\n  for (i = 1, j = n; i < j;) {\n    int x = a[i].id, y = a[j].id;\n    if (fr[x] == to[i]) {\n      i++;\n      continue;\n    }\n    if (fr[y] == to[j]) {\n      j--;\n      continue;\n    }\n    int s = min(abs(fr[x] - to[i]), abs(fr[y] - to[j]));\n    fr[x] -= s;\n    fr[y] += s;\n    move(x, y, s);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst long long llinf = (1LL << 62);\nconst int inf = (1 << 30);\nconst int nmax = 5e5 + 50;\nconst int mod = 1e9 + 7;\nusing namespace std;\nstruct fastio {\n  char s[100000];\n  int it, len;\n  fastio() { it = len = 0; }\n  inline char get() {\n    if (it < len) return s[it++];\n    it = 0;\n    len = fread(s, 1, 100000, stdin);\n    if (len == 0)\n      return EOF;\n    else\n      return s[it++];\n  }\n  bool notend() {\n    char c = get();\n    while (c == ' ' || c == '\\n') c = get();\n    if (it > 0) it--;\n    return c != EOF;\n  }\n} _buff;\ninline long long getnum() {\n  long long r = 0;\n  bool ng = 0;\n  char c;\n  c = _buff.get();\n  while (c != '-' && (c < '0' || c > '9')) c = _buff.get();\n  if (c == '-') ng = 1, c = _buff.get();\n  while (c >= '0' && c <= '9') r = r * 10 + c - '0', c = _buff.get();\n  return ng ? -r : r;\n}\ntemplate <class T>\ninline void putnum(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  register short a[20] = {}, sz = 0;\n  while (x) a[sz++] = x % 10, x /= 10;\n  if (sz == 0) putchar('0');\n  for (int i = sz - 1; i >= 0; i--) putchar('0' + a[i]);\n}\ninline char getreal() {\n  char c = _buff.get();\n  while (c <= 32) c = _buff.get();\n  return c;\n}\nint n, m, i, k, tot, t, j, l, r, b, f[nmax], x, nr;\nset<int> s[nmax];\nset<int>::iterator it, it1, it2, it3;\nvector<pair<int, int> > sz;\nvector<pair<pair<int, int>, int> > ans;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cerr.tie(0);\n  cout.tie(0);\n  n = getnum(), m = getnum();\n  for (i = 1; i <= n; i++) {\n    k = getnum();\n    tot += k;\n    for (j = 1; j <= k; j++) {\n      x = getnum();\n      s[i].insert(x);\n    }\n    s[i].insert(0), s[i].insert(nmax);\n    sz.push_back({k, i});\n  }\n  sort(sz.begin(), sz.end());\n  reverse(sz.begin(), sz.end());\n  for (i = 0; i < tot % n; i++) f[i] = (tot / n) + 1;\n  for (; i < n; i++) f[i] = tot / n;\n  l = 0, r = n - 1;\n  while (1) {\n    while (l < n && (int)s[sz[l].second].size() - 2 == f[l]) l++;\n    while (r >= 0 && (int)s[sz[r].second].size() - 2 == f[r]) r--;\n    if (l == n || r == -1) break;\n    i = sz[l].second;\n    j = sz[r].second;\n    vector<int> v;\n    nr = b = 0;\n    for (it = s[j].begin(); it != s[j].end(); it++) {\n      it1 = it;\n      it1++;\n      it2 = s[i].upper_bound((*it));\n      it3 = s[i].lower_bound((*it1));\n      if (it2 != it3)\n        for (; it2 != it3; it2++) {\n          v.push_back((*it2));\n          ans.push_back({{i, j}, (*it2)});\n          nr++;\n          if ((int)s[i].size() - 2 - nr == f[l] ||\n              (int)s[j].size() - 2 + nr == f[r]) {\n            b = 1;\n            break;\n          }\n        }\n      if (b) break;\n    }\n    for (t = 0; t < v.size(); t++) {\n      if (s[i].find(v[t]) != s[i].end()) s[i].erase(s[i].find(v[t]));\n      s[j].insert(v[t]);\n    }\n  }\n  cout << (int)ans.size() << endl;\n  for (i = 0; i < ans.size(); i++)\n    putnum(ans[i].first.first), putchar(' '), putnum(ans[i].first.second),\n        putchar(' '), putnum(ans[i].second), putchar('\\n');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nstruct tree {\n  int l = -1, r = -1, sum = 0;\n};\ntree tt;\nvector<tree> t[N];\nset<pair<int, int> > s;\nvector<pair<pair<int, int>, int> > ans;\nint n, m, k, x, sum, pisos, mi, mx, kol1, kol2;\nvoid upd(int cnt, int v, int tl, int tr, int pos) {\n  if (tl == tr) {\n    t[cnt][v].sum++;\n    return;\n  }\n  int tm = (tl + tr) / 2;\n  if (pos <= tm) {\n    if (t[cnt][v].l < 0) {\n      t[cnt][v].l = t[cnt].size();\n      t[cnt].push_back(tt);\n    }\n    upd(cnt, t[cnt][v].l, tl, tm, pos);\n  } else {\n    if (t[cnt][v].r < 0) {\n      t[cnt][v].r = t[cnt].size();\n      t[cnt].push_back(tt);\n    }\n    upd(cnt, t[cnt][v].r, tm + 1, tr, pos);\n  }\n  t[cnt][v].sum = 0;\n  if (t[cnt][v].l >= 0) t[cnt][v].sum += t[cnt][t[cnt][v].l].sum;\n  if (t[cnt][v].r >= 0) t[cnt][v].sum += t[cnt][t[cnt][v].r].sum;\n}\nvoid dfs(int mx, int mi, int vx, int vi, int tl, int tr) {\n  if (tl == tr) {\n    ans.push_back({{mx, mi}, tl});\n    t[mx][vx].sum = 0;\n    t[mi][vi].sum = 1;\n    return;\n  }\n  int tm = (tl + tr) / 2;\n  bool edd = 1;\n  if (t[mx][vx].l >= 0) {\n    if (t[mi][vi].l < 0) {\n      t[mi][vi].l = t[mi].size();\n      t[mi].push_back(tt);\n    }\n    if (t[mx][t[mx][vx].l].sum > t[mi][t[mi][vi].l].sum) {\n      dfs(mx, mi, t[mx][vx].l, t[mi][vi].l, tl, tm);\n      edd = 0;\n    }\n  }\n  if (edd && t[mx][vx].r >= 0) {\n    if (t[mi][vi].r < 0) {\n      t[mi][vi].r = t[mi].size();\n      t[mi].push_back(tt);\n    }\n    if (t[mx][t[mx][vx].r].sum > t[mi][t[mi][vi].r].sum) {\n      dfs(mx, mi, t[mx][vx].r, t[mi][vi].r, tm + 1, tr);\n    }\n  }\n  t[mx][vx].sum = 0;\n  if (t[mx][vx].l >= 0) t[mx][vx].sum += t[mx][t[mx][vx].l].sum;\n  if (t[mx][vx].r >= 0) t[mx][vx].sum += t[mx][t[mx][vx].r].sum;\n  t[mi][vi].sum = 0;\n  if (t[mi][vi].l >= 0) t[mi][vi].sum += t[mi][t[mi][vi].l].sum;\n  if (t[mi][vi].r >= 0) t[mi][vi].sum += t[mi][t[mi][vi].r].sum;\n}\nvoid out(int cnt, int v, int tl, int tr) {\n  if (tl == tr) {\n    if (t[cnt][v].sum) cout << tl << \" \";\n    return;\n  }\n  int tm = (tl + tr) / 2;\n  if (t[cnt][v].l >= 0) out(cnt, t[cnt][v].l, tl, tm);\n  if (t[cnt][v].r >= 0) out(cnt, t[cnt][v].r, tm + 1, tr);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> k;\n    t[i].push_back(tt);\n    sum += k;\n    for (int j = 1; j <= k; j++) {\n      cin >> x;\n      upd(i, 0, 1, m, x);\n    }\n    s.insert({t[i][0].sum, i});\n  }\n  pisos = sum / n;\n  if (n == 1) return cout << 0, 0;\n  while (1) {\n    mi = (*s.begin()).second;\n    mx = (*--s.end()).second;\n    s.erase(s.begin());\n    s.erase(--s.end());\n    kol1 = t[mi][0].sum;\n    kol2 = t[mx][0].sum;\n    if (kol1 == kol2 || (kol1 == pisos && kol2 - kol1 < 2)) break;\n    dfs(mx, mi, 0, 0, 1, m);\n    s.insert({t[mi][0].sum, mi});\n    s.insert({t[mx][0].sum, mx});\n  }\n  cout << ans.size() << endl;\n  for (auto x : ans) {\n    cout << x.first.first << \" \" << x.first.second << \" \" << x.second << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100100;\nint n, pos[N], f[N], m, sz[N];\nunordered_set<int> mp1[N];\nbool cmp(int fi, int se) { return sz[fi] > sz[se]; }\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> sz[i];\n    sum += sz[i];\n    for (int j = 1; j <= sz[i]; j++) {\n      int x;\n      cin >> x;\n      mp1[i].insert(x);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    pos[i] = i;\n    f[i] = sum / n;\n    if (i <= sum % n) ++f[i];\n  }\n  sort(pos + 1, pos + n + 1, cmp);\n  int l = 1, r = n;\n  vector<pair<pair<int, int>, int> > ansvec;\n  while (l < r) {\n    while (1) {\n      if (sz[pos[l]] == f[l]) {\n        ++l;\n        break;\n      }\n      if (sz[pos[r]] == f[r]) {\n        --r;\n        break;\n      }\n      for (auto it = mp1[pos[l]].begin(); it != mp1[pos[l]].end(); it++) {\n        int x = *it;\n        if (mp1[pos[r]].find(x) != mp1[pos[r]].end()) continue;\n        ++it;\n        --sz[pos[l]];\n        ++sz[pos[r]];\n        mp1[pos[l]].erase(x);\n        mp1[pos[r]].insert(x);\n        ansvec.push_back({{pos[l], pos[r]}, x});\n        if (sz[pos[l]] == f[l] || sz[pos[r]] == f[r]) break;\n      }\n    }\n  }\n  cout << ansvec.size() << \"\\n\";\n  for (auto it : ansvec)\n    cout << it.first.first << ' ' << it.first.second << ' ' << it.second\n         << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int UB = 500000;\nvector<tuple<int, int, int>> res;\nvoid func(int n, int m, vector<set<int>> &kss, int lb, int ub) {\n  vector<int> cnt(n);\n  for (int i = 0; i < n; i++) cnt[i] = kss[i].size();\n  vector<vector<int>> pats(m);\n  for (int i = 0; i < n; i++)\n    if (cnt[i] > ub)\n      for (auto k : kss[i]) pats[k].push_back(i);\n  set<int> ls;\n  for (int i = 0; i < n; i++)\n    if (cnt[i] < lb) ls.insert(i);\n  for (int i = 0; i < m; i++) {\n    int idx = 0;\n    auto it = ls.begin();\n    vector<int> added;\n    while (idx < pats[i].size() && it != ls.end()) {\n      if (cnt[pats[i][idx]] == ub) {\n        idx++;\n        continue;\n      }\n      if (kss[*it].count(i)) {\n        it++;\n        continue;\n      }\n      res.emplace_back(pats[i][idx] + 1, (*it) + 1, i + 1);\n      kss[pats[i][idx]].erase(i);\n      kss[*it].insert(i);\n      cnt[pats[i][idx]]--;\n      cnt[*it]++;\n      added.push_back(*it);\n      it++, idx++;\n    }\n    for (auto a : added)\n      if (cnt[a] == lb) ls.erase(a);\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<set<int>> kss(n);\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    int s;\n    cin >> s;\n    sum += s;\n    while (s--) {\n      int kind;\n      cin >> kind;\n      kind--;\n      kss[i].insert(kind);\n    }\n  }\n  int lb = sum / n;\n  int ub = sum / n + (int)(sum % n != 0);\n  func(n, m, kss, lb, ub);\n  func(n, m, kss, ub, ub);\n  cout << res.size() << endl;\n  for (auto &e : res) {\n    cout << get<0>(e) << \" \" << get<1>(e) << \" \" << get<2>(e) << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int)1e9 + 23111992;\nconst long long LINF = (long long)1e18 + 23111992;\nconst long double PI = acos((long double)-1);\nconst long double EPS = 1e-9;\ninline long long gcd(long long a, long long b) {\n  long long r;\n  while (b) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\ninline long long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\ninline long long fpow(long long n, long long k, int p = MOD) {\n  long long r = 1;\n  for (; k; k >>= 1) {\n    if (k & 1) r = r * n % p;\n    n = n * n % p;\n  }\n  return r;\n}\ntemplate <class T>\ninline int chkmin(T& a, const T& val) {\n  return val < a ? a = val, 1 : 0;\n}\ntemplate <class T>\ninline int chkmax(T& a, const T& val) {\n  return a < val ? a = val, 1 : 0;\n}\ninline unsigned long long isqrt(unsigned long long k) {\n  unsigned long long r = sqrt(k) + 1;\n  while (r * r > k) r--;\n  return r;\n}\ninline long long icbrt(long long k) {\n  long long r = cbrt(k) + 1;\n  while (r * r * r > k) r--;\n  return r;\n}\ninline void addmod(int& a, int val, int p = MOD) {\n  if ((a = (a + val)) >= p) a -= p;\n}\ninline void submod(int& a, int val, int p = MOD) {\n  if ((a = (a - val)) < 0) a += p;\n}\ninline int mult(int a, int b, int p = MOD) { return (long long)a * b % p; }\ninline int inv(int a, int p = MOD) { return fpow(a, p - 2, p); }\ninline int sign(long double x) { return x < -EPS ? -1 : x > +EPS; }\ninline int sign(long double x, long double y) { return sign(x - y); }\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int myrand() { return abs((int)mt()); }\nstruct node_t {\n  node_t *l, *r;\n  int cnt;\n  node_t(node_t* l = 0, node_t* r = 0, int cnt = 0) : l(l), r(r), cnt(cnt) {}\n};\nint cnt(node_t* p) { return p ? p->cnt : 0; }\nnode_t* upd(node_t* p, int i, int L, int R, int val) {\n  if (i < L || R < i) return p;\n  if (L == R) {\n    return new node_t(0, 0, cnt(p) + val);\n  }\n  node_t* res = new node_t(p ? p->l : 0, p ? p->r : 0);\n  res->l = upd(res->l, i, L, L + R >> 1, val);\n  res->r = upd(res->r, i, (L + R >> 1) + 1, R, val);\n  res->cnt = cnt(res->l) + cnt(res->r);\n  return res;\n}\nint query(node_t* p, node_t* q, int L, int R) {\n  if (L == R) {\n    return L;\n  }\n  if (cnt(p ? p->l : 0) > cnt(q ? q->l : 0)) {\n    return query(p->l, q ? q->l : 0, L, L + R >> 1);\n  } else {\n    return query(p->r, q ? q->r : 0, (L + R >> 1) + 1, R);\n  }\n}\nconst int maxn = 1e5 + 5;\nint n, m;\nnode_t* f[maxn];\nvoid chemthan() {\n  cin >> n >> m;\n  vector<vector<int> > a(n);\n  for (int i = (0); i < (n); ++i) {\n    int k;\n    cin >> k;\n    a[i].resize(k);\n    for (int& x : a[i]) {\n      cin >> x, x--;\n      f[i] = upd(f[i], x, 0, m - 1, 1);\n    }\n  }\n  set<pair<int, int> > heap;\n  for (int i = (0); i < (n); ++i) {\n    heap.insert(make_pair(cnt(f[i]), i));\n  }\n  vector<pair<pair<int, int>, int> > res;\n  while (1) {\n    int u = heap.begin()->second;\n    int v = heap.rbegin()->second;\n    if (cnt(f[u]) < cnt(f[v]) - 1) {\n      heap.erase(make_pair(cnt(f[u]), u));\n      heap.erase(make_pair(cnt(f[v]), v));\n      int x = query(f[v], f[u], 0, m - 1);\n      f[v] = upd(f[v], x, 0, m - 1, -1);\n      f[u] = upd(f[u], x, 0, m - 1, +1);\n      heap.insert(make_pair(cnt(f[u]), u));\n      heap.insert(make_pair(cnt(f[v]), v));\n      res.push_back(make_pair(make_pair(v, u), x));\n    } else {\n      break;\n    }\n  }\n  cout << int((res).size()) << \"\\n\";\n  for (auto e : res) {\n    cout << e.first.first + 1 << \" \" << e.first.second + 1 << \" \"\n         << e.second + 1 << \"\\n\";\n  }\n}\nint main(int argc, char* argv[]) {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  if (argc > 1) {\n    assert(freopen(argv[1], \"r\", stdin));\n  }\n  if (argc > 2) {\n    assert(freopen(argv[2], \"wb\", stdout));\n  }\n  chemthan();\n  cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nsigned main() {\n#pragma warning(disable : 4996)\n  int n, m;\n  cin >> n >> m;\n  vector<pair<pair<int, int>, vector<int> > > v(n);\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    sum += k;\n    v[i].first.first = k;\n    v[i].first.second = i;\n    v[i].second.resize(k);\n    for (int j = 0; j < k; j++) {\n      cin >> v[i].second[j];\n    }\n  }\n  vector<int> f(n);\n  for (int i = 0; i < n; i++) {\n    if (i < sum % n) {\n      f[i] = sum / n + 1;\n    } else {\n      f[i] = sum / n;\n    }\n  }\n  sort(v.rbegin(), v.rend());\n  vector<unordered_set<int> > st(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < v[i].second.size(); j++) {\n      st[i].insert(v[i].second[j]);\n    }\n  }\n  int l = 0, r = n - 1;\n  vector<pair<pair<int, int>, int> > ans;\n  while (l < r) {\n    if (v[l].first.first == f[l]) {\n      l++;\n      continue;\n    }\n    if (v[r].first.first == f[r]) {\n      r--;\n      continue;\n    }\n    vector<int> del;\n    for (int it : st[l]) {\n      if (!st[r].count(it)) {\n        ans.push_back(make_pair(\n            make_pair(v[l].first.second + 1, v[r].first.second + 1), it));\n        del.push_back(it);\n        st[r].insert(it);\n        v[l].first.first--;\n        v[r].first.first++;\n        if (v[l].first.first == f[l]) {\n          l++;\n          break;\n          ;\n        } else if (v[r].first.first == f[r]) {\n          r--;\n          break;\n        }\n      }\n    }\n    for (int i : del) {\n      st[l].erase(i);\n    }\n  }\n  cout << ans.size() << \"\\n\";\n  for (int i = 0; i < ans.size(); i++) {\n    cout << ans[i].first.first << \" \" << ans[i].first.second << \" \"\n         << ans[i].second << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> in[100005];\npair<int, int> id[100005];\nint bit[100005];\nint lastNum[100005];\nint color[100005];\nvoid solve() {\n  int n, m;\n  scanf(\"%d %d \", &n, &m);\n  long long sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    int num;\n    scanf(\"%d \", &num);\n    sum += num;\n    while (num--) {\n      int x;\n      scanf(\"%d \", &x);\n      in[i].insert(x);\n    }\n    id[i] = {in[i].size(), i};\n  }\n  int x = sum / n;\n  int lim = (n - sum % n);\n  int t = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (i <= lim) {\n      lastNum[i] = x;\n    } else {\n      lastNum[i] = x + 1;\n    }\n    t += lastNum[i];\n  }\n  assert(t == sum);\n  sort(id + 1, id + n + 1);\n  int l = 1, r = n;\n  vector<pair<pair<int, int>, int> > out;\n  bool lin = false, rin = false;\n  set<int> swapNums;\n  while (l < r) {\n    int lid = id[l].second;\n    int rid = id[r].second;\n    if (in[lid].size() == lastNum[l]) {\n      if (lin) {\n        for (int x : in[lid]) {\n          assert(color[x] & 1);\n          color[x] ^= 1;\n          if (color[x] == 2) {\n            assert(!swapNums.count(x));\n            swapNums.insert(x);\n          }\n        }\n      }\n      ++l;\n      lin = false;\n      continue;\n    }\n    if (in[rid].size() == lastNum[r]) {\n      if (rin) {\n        for (int x : in[rid]) {\n          assert(color[x] & 2);\n          if (color[x] == 2) {\n            assert(swapNums.count(x));\n            swapNums.erase(x);\n          }\n          color[x] ^= 2;\n        }\n      }\n      --r;\n      rin = false;\n      continue;\n    }\n    if (!lin) {\n      for (int x : in[lid]) {\n        color[x] |= 1;\n        if (color[x] == 3) {\n          assert(swapNums.count(x));\n          swapNums.erase(x);\n        }\n      }\n      lin = true;\n    }\n    if (!rin) {\n      for (int x : in[rid]) {\n        color[x] |= 2;\n        if (color[x] == 2) {\n          assert(!swapNums.count(x));\n          swapNums.insert(x);\n        }\n      }\n      rin = true;\n    }\n    assert(in[lid].size() < lastNum[l]);\n    assert(in[rid].size() > lastNum[r]);\n    while (in[lid].size() != lastNum[l] && in[rid].size() != lastNum[r]) {\n      assert(swapNums.size() > 0);\n      int g = *swapNums.begin();\n      swapNums.erase(g);\n      in[lid].insert(g);\n      in[rid].erase(g);\n      out.push_back({{rid, lid}, g});\n      color[g] = 1;\n    }\n  }\n  printf(\"%d\\n\", out.size());\n  for (pair<pair<int, int>, int> tmp : out) {\n    printf(\"%d %d %d\\n\", tmp.first.first, tmp.first.second, tmp.second);\n  }\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double eps = 1e-5;\nconst long double PI = acos(-1);\nconst int INF = (int)1e9;\nconst long long INFF = (long long)1e18;\nconst int mod = (int)1e9 + 7;\nconst int MXN = (int)1e5 + 7;\nint hv[MXN];\nint need[MXN];\nint per[MXN];\nstruct Seg {\n  int ll[MXN << 2], rr[MXN << 2];\n  int a[MXN << 2], fr[MXN << 2];\n  inline void pushup(int p) {\n    if (a[p << 1] > a[p << 1 | 1]) {\n      a[p] = a[p << 1];\n      fr[p] = fr[p << 1];\n    } else {\n      a[p] = a[p << 1 | 1];\n      fr[p] = fr[p << 1 | 1];\n    }\n  }\n  void bd(int l, int r, int p = 1) {\n    ll[p] = l, rr[p] = r;\n    if (l == r) {\n      a[p] = need[l] - hv[per[l]];\n      fr[p] = l;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    bd(l, mid, p << 1);\n    bd(mid + 1, r, p << 1 | 1);\n    pushup(p);\n    return;\n  }\n  pair<int, int> qy(int l, int r, int p = 1) {\n    if (l > rr[p] || r < ll[p]) return make_pair(-INF, 0);\n    if (l <= ll[p] && rr[p] <= r) return make_pair(a[p], fr[p]);\n    return max(qy(l, r, p << 1), qy(l, r, p << 1 | 1));\n  }\n  void md(int pp, int p = 1) {\n    if (ll[p] == rr[p]) {\n      a[p]--;\n      return;\n    }\n    int mid = (ll[p] + rr[p]) >> 1;\n    if (pp <= mid)\n      md(pp, p << 1);\n    else\n      md(pp, p << 1 | 1);\n    pushup(p);\n  }\n} seg;\nset<int> al[MXN];\nvector<int> st[MXN];\nvector<int> al2[MXN];\nbool cmp(const int &u, const int &v) { return hv[u] < hv[v]; }\nvector<pair<pair<int, int>, int>> ans;\nint main(void) {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  int sum = 0;\n  for (int i = 1; i < n + 1; ++i) per[i] = i;\n  for (int i = 1; i < n + 1; ++i) {\n    int num;\n    scanf(\"%d\", &num);\n    hv[i] = num;\n    sum += num;\n    while (num--) {\n      int v;\n      scanf(\"%d\", &v);\n      st[i].push_back(v);\n    }\n  }\n  sort(per + 1, per + n + 1, cmp);\n  for (int i = 1; i < n + 1; ++i) need[i] = sum / n;\n  for (int i = n + 1 - sum % n; i < n + 1; ++i) need[i]++;\n  seg.bd(1, n);\n  for (int i = 1; i < n + 1; ++i) {\n    int id = per[i];\n    if (need[i] > hv[id]) {\n      for (int v : st[id]) al[v].insert(i);\n    } else if (need[i] < hv[id]) {\n      for (int v : st[id]) al2[v].push_back(i);\n    }\n  }\n  for (int i = 1; i < m + 1; ++i) {\n    al[i].insert(0);\n    al[i].insert(n + 1);\n  }\n  for (int i = 1; i < m + 1; ++i) {\n    auto ll = al[i].begin();\n    auto rr = ll;\n    rr++;\n    for (int u : al2[i]) {\n      if (need[u] == hv[per[u]]) continue;\n      while (rr != al[i].end()) {\n        int l = *ll, r = *rr;\n        if (l + 1 > r - 1) {\n          ll++, rr++;\n        } else {\n          pair<int, int> res = seg.qy(l + 1, r - 1);\n          if (res.first > 0) {\n            int p = res.second;\n            seg.md(p);\n            ans.push_back(make_pair(make_pair(per[u], per[p]), i));\n            hv[per[u]]--;\n            al[i].insert(p);\n            ll = al[i].lower_bound(l);\n            rr = al[i].lower_bound(p);\n            break;\n          } else {\n            ll++;\n            rr++;\n          }\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\", (int)(ans).size());\n  for (auto x : ans)\n    printf(\"%d %d %d\\n\", x.first.first, x.first.second, x.second);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1e5 + 5, M = 500005 * 25;\nint n, m, a[N], b[N], c[N];\nstd::unordered_set<int> g[N], d, f;\nbool cmp(int x, int y) { return g[x].size() > g[y].size(); }\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  int tot = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n    tot += a[i];\n    c[i] = i;\n    for (int j = 0, x; j < a[i]; j++) scanf(\"%d\", &x), g[i].insert(x);\n  }\n  for (int i = 0; i < tot; i++) b[i % n]++;\n  int l = 0, r = n - 1, ans = 0;\n  std::sort(c, c + n, cmp);\n  for (int i = 0; i < n; i++)\n    if (a[c[i]] > b[i]) ans += a[c[i]] - b[i];\n  printf(\"%d\\n\", ans);\n  d = g[c[l]];\n  for (int v : g[c[r]])\n    if (d.count(v)) d.erase(v), f.insert(v);\n  while (l < r) {\n    if (g[c[l]].size() == b[l]) {\n      l++;\n      if (l >= r) break;\n      f.clear();\n      d = g[c[l]];\n      for (int v : d)\n        if (g[c[r]].count(v)) f.insert(v);\n      for (int v : f) d.erase(v);\n      continue;\n    }\n    if (g[c[r]].size() == b[r]) {\n      r--;\n      if (l >= r) break;\n      for (int v : f) d.insert(v);\n      f.clear();\n      for (int v : g[c[r]])\n        if (d.count(v)) d.erase(v), f.insert(v);\n      continue;\n    }\n    int v = *d.begin();\n    d.erase(v);\n    g[c[l]].erase(v);\n    g[c[r]].insert(v);\n    printf(\"%d %d %d\\n\", c[l] + 1, c[r] + 1, v);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int C = 340;\nset<int> e[100010];\nint c[100010][C];\nint aa[500010][3], ans;\nset<pair<int, int> > a;\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    int l;\n    scanf(\"%d\", &l);\n    for (int j = 0; j < l; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      e[i].insert(x);\n      c[i][x / C]++;\n    }\n    e[i].insert(1001001001 + i);\n    a.insert(make_pair(l, i));\n  }\n  int M = (m + C - 1) / C;\n  while (1) {\n    set<pair<int, int> >::iterator it = a.end();\n    --it;\n    int xc = it->first, yc = a.begin()->first;\n    if (xc - yc < 2) break;\n    int x = it->second, y = a.begin()->second, z;\n    a.erase(it);\n    a.erase(a.begin());\n    a.insert(make_pair(xc - 1, x));\n    a.insert(make_pair(yc + 1, y));\n    for (int i = 0; i < M; i++) {\n      if (c[x][i] > c[y][i]) {\n        z = i * C;\n        --c[x][i];\n        ++c[y][i];\n        break;\n      }\n    }\n    set<int>::iterator ix = e[x].lower_bound(z);\n    set<int>::iterator iy = e[y].lower_bound(z);\n    while (*iy < z + C && *ix >= *iy) {\n      while (*iy<z + C&& * ix> * iy) {\n        ++iy;\n      }\n      while (*ix == *iy) {\n        ++ix;\n        ++iy;\n      }\n    }\n    aa[ans][2] = *ix;\n    e[x].erase(ix);\n    e[y].insert(aa[ans][2]);\n    aa[ans][0] = x;\n    aa[ans][1] = y;\n    ans++;\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = 0; i < ans; i++) {\n    printf(\"%d %d %d\\n\", aa[i][0] + 1, aa[i][1] + 1, aa[i][2] + 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint vis[maxn], bid[maxn], sid[maxn], n, m;\nvector<int> vec[maxn], big[maxn], small[maxn];\nstruct Sol {\n  int a, b, c;\n};\nvector<Sol> ans;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  int tot = 0;\n  for (int i = 1; i <= n; i++) {\n    int c, t;\n    scanf(\"%d\", &c);\n    tot += c;\n    while (c--) {\n      scanf(\"%d\", &t);\n      vec[i].push_back(t);\n    }\n  }\n  int bound = (tot + n - 1) / n, all = tot % n, cb = 0, cs = 0;\n  for (int i = 1; i <= n; i++) {\n    if (vec[i].size() >= bound)\n      ++cb, big[cb] = vec[i], bid[cb] = i;\n    else\n      ++cs, small[cs] = vec[i], sid[cs] = i;\n  }\n  all = !all ? n - cb : all - cb;\n  for (int i = 1; i <= cs; i++) {\n    int l = small[i].size(), d = all ? bound : bound - 1;\n    for (int j : small[i]) vis[j] = i;\n    while (cb > 0 && l < d) {\n      vector<int> temp;\n      for (int j = big[cb].size() - 1; j >= bound - temp.size() && l < d; j--) {\n        if (vis[big[cb][j]] == i)\n          temp.push_back(big[cb][j]);\n        else\n          ans.push_back((Sol){bid[cb], sid[i], big[cb][j]}), ++l,\n              vis[big[cb][j]] = i;\n        big[cb].pop_back();\n      }\n      for (int j : temp) big[cb].push_back(j);\n      assert(big[cb].size() >= bound);\n      if (big[cb].size() == bound) --cb;\n    }\n  }\n  printf(\"%d\\n\", ans.size());\n  for (Sol s : ans) printf(\"%d %d %d\\n\", s.a, s.b, s.c);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18 + 10;\nconst int inf = 1e9 + 10;\nconst int N = 1e7 + 10;\nstruct osu {\n  int l, r, sum;\n};\nosu _new = {-1, -1, 0};\nvector<osu> t;\nvoid add(int v) {\n  if (t[v].l == -1) {\n    t[v].l = t.size();\n    t.push_back(_new);\n  }\n  if (t[v].r == -1) {\n    t[v].r = t.size();\n    t.push_back(_new);\n  }\n}\nvoid modify(int v, int tl, int tr, int val, int pos) {\n  t[v].sum += val;\n  if (tl == tr) return;\n  add(v);\n  int tm = (tl + tr) / 2;\n  if (pos <= tm)\n    modify(t[v].l, tl, tm, val, pos);\n  else\n    modify(t[v].r, tm + 1, tr, val, pos);\n}\nint get(int v, int v1, int tl, int tr) {\n  if (tl == tr) return tl;\n  add(v), add(v1);\n  int tm = (tl + tr) / 2;\n  if (t[t[v].l].sum < t[t[v1].l].sum)\n    return get(t[v].l, t[v1].l, tl, tm);\n  else\n    return get(t[v].r, t[v1].r, tm + 1, tr);\n}\nstruct osu1 {\n  int a, b, c;\n};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> root(n);\n  set<pair<int, int> > que;\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    root[i] = t.size();\n    t.push_back(_new);\n    for (int q = 0; q < k; q++) {\n      int x;\n      cin >> x;\n      modify(root[i], 1, m, 1, x);\n    }\n    que.insert(make_pair(t[root[i]].sum, i));\n  }\n  vector<osu1> ans;\n  while (que.size() > 1) {\n    auto i = que.begin();\n    auto q = --que.end();\n    if (q->first - i->first <= 1) break;\n    auto it = *i;\n    auto it1 = *q;\n    int what = get(root[it.second], root[it1.second], 1, m);\n    ans.push_back({it1.second + 1, it.second + 1, what});\n    modify(root[it1.second], 1, m, -1, what);\n    modify(root[it.second], 1, m, 1, what);\n    que.erase(q);\n    que.erase(que.begin());\n    que.insert(make_pair(it1.first - 1, it1.second));\n    que.insert(make_pair(it.first + 1, it.second));\n  }\n  cout << ans.size() << \"\\n\";\n  for (auto i : ans) cout << i.a << \" \" << i.b << \" \" << i.c << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> s[100010];\nset<int>::iterator it1, k;\nset<int>::iterator it2;\npair<int, int> a[100010];\nint ned[100010];\nint tec[100010];\nstruct P {\n  int x1, x2, x3;\n};\nvector<P> ans;\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, m, sum = 0;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    int k;\n    cin >> k;\n    for (int j = 0; j < k; j++) {\n      int l;\n      cin >> l;\n      s[i].insert(l);\n    }\n    tec[i] = s[i].size();\n    sum += k;\n    a[i] = make_pair(k, i);\n  }\n  sort(a + 1, a + n + 1);\n  for (int i = n; i >= 1; i--) {\n    int k = (sum) / n;\n    if (sum % n != 0) {\n      sum--;\n      k++;\n    }\n    ned[a[i].second] = k;\n  }\n  int l = 1, r = n;\n  while (1) {\n    while (r >= 1 && ned[a[r].second] == tec[a[r].second]) r--;\n    while (l <= n && ned[a[l].second] == tec[a[l].second]) l++;\n    if (r - l < 1) break;\n    it1 = s[a[l].second].begin();\n    it2 = s[a[r].second].begin();\n    while (1) {\n      if (it1 == s[a[l].second].end() && it2 == s[a[r].second].end()) break;\n      int fl = 0;\n      while (it1 != s[a[l].second].end() && (*it1) < (*it2)) it1++;\n      if (it1 == s[a[l].second].end() || (*it1) > (*it2)) {\n        ans.push_back({a[r].second, a[l].second, *it2});\n        s[a[l].second].insert(*it2);\n        k = it2;\n        it2++;\n        s[a[r].second].erase(k);\n        tec[a[r].second]--;\n        tec[a[l].second]++;\n        fl = 1;\n      } else {\n        it2++;\n      }\n      if (ned[a[r].second] == tec[a[r].second] ||\n          ned[a[l].second] == tec[a[l].second])\n        break;\n    }\n  }\n  cout << ans.size() << endl;\n  for (int i = 0; i < ans.size(); i++) {\n    cout << ans[i].x1 << ' ' << ans[i].x2 << ' ' << ans[i].x3 << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"-O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nset<int> se[100500];\nvector<int> a[100500], nxt[100500], lst[100500];\nvector<bool> tp[100500];\nint mns[100500], ps[100500];\nbool cmp(int x, int y) { return int(se[x].size()) > int(se[y].size()); }\nint main() {\n  ios_base::sync_with_stdio(0);\n  iostream::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  int sum = 0;\n  int f[n];\n  vector<int> vr(n);\n  for (int i = 0; i < n; i++) {\n    vr[i] = i;\n    int len;\n    cin >> len;\n    sum += len;\n    nxt[i].resize(len);\n    lst[i].resize(len);\n    tp[i].resize(len, 0);\n    for (int j = 0; j < len; j++) {\n      nxt[i][j] = j + 1;\n      lst[i][j] = j - 1;\n      int x;\n      cin >> x;\n      se[i].insert(x);\n      a[i].push_back(x);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    f[i] = sum / n;\n    if (sum % n != 0) {\n      f[i]++;\n      sum--;\n    }\n  }\n  sort(vr.begin(), vr.end(), cmp);\n  int l = 0, r = n - 1;\n  vector<array<int, 3> > ans;\n  ans.clear();\n  while (l < r) {\n    int nm = vr[l], id = vr[r];\n    if (f[l] == int(se[nm].size()) - mns[nm]) {\n      l++;\n      continue;\n    }\n    if (f[r] == int(se[id].size())) {\n      r--;\n      continue;\n    }\n    int i = ps[nm];\n    while (i < int(a[nm].size()) && f[l] != int(se[nm].size()) - mns[nm] &&\n           f[r] != int(se[id].size())) {\n      int val = a[nm][i];\n      if (!tp[nm][i] && se[id].find(val) == se[id].end()) {\n        ans.push_back({nm + 1, id + 1, val});\n        se[id].insert(val);\n        mns[nm]++;\n        int j = lst[nm][i];\n        int nx = nxt[nm][i];\n        if (nx != n) lst[nm][nx] = j;\n        if (j != -1) nxt[nm][j] = nx;\n        tp[nm][i] = 1;\n        while (ps[nm] < int(a[nm].size()) && tp[nm][ps[nm]]) ps[nm]++;\n      }\n      i = nxt[nm][i];\n    }\n  }\n  cout << int(ans.size()) << '\\n';\n  ;\n  for (auto it : ans) cout << it[0] << \" \" << it[1] << \" \" << it[2] << '\\n';\n  ;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mn = 200005;\nconst int mod = 1e9 + 7;\nint n, m;\nunordered_set<int> h[mn];\npriority_queue<pair<int, int> > q;\nint sum = 0;\nint maxi, mini;\nvector<tuple<int, int, int> > ans;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int u;\n    scanf(\"%d\", &u);\n    for (int j = 1; j <= u; j++) {\n      int v;\n      scanf(\"%d\", &v);\n      h[i].insert(v);\n    }\n    sum += u;\n  }\n  mini = sum / n;\n  maxi = mini + (sum % n != 0);\n  for (int i = 1; i <= n; i++) {\n    if ((int)h[i].size() >= maxi) {\n      q.push({(int)h[i].size(), i});\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    while ((int)h[i].size() < mini) {\n      pair<int, int> u = q.top();\n      q.pop();\n      for (auto it = h[u.second].begin(); it != h[u.second].end(); it++) {\n        if (!h[i].count(*it)) {\n          h[i].insert(*it);\n          ans.push_back({u.second, i, *it});\n          h[u.second].erase(it++);\n          if ((int)h[i].size() == mini || (int)h[u.second].size() <= maxi)\n            break;\n        }\n      }\n      if ((int)h[u.second].size() >= maxi)\n        q.push({(int)h[u.second].size(), u.second});\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (q.top().first == maxi) break;\n    while ((int)h[i].size() == mini) {\n      pair<int, int> u = q.top();\n      q.pop();\n      for (auto it = h[u.second].begin(); it != h[u.second].end(); it++) {\n        if (!h[i].count(*it)) {\n          h[i].insert(*it);\n          ans.push_back({u.second, i, *it});\n          h[u.second].erase(it++);\n          break;\n        }\n      }\n      if ((int)h[u.second].size() >= maxi)\n        q.push({(int)h[u.second].size(), u.second});\n    }\n  }\n  printf(\"%d\\n\", (int)ans.size());\n  for (auto &i : ans) {\n    printf(\"%d %d %d\\n\", get<0>(i), get<1>(i), get<2>(i));\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void read(long long &x) {\n  char ch;\n  bool flag = false;\n  for (ch = getchar(); !isdigit(ch); ch = getchar())\n    if (ch == '-') flag = true;\n  for (x = 0; isdigit(ch); x = x * 10 + ch - '0', ch = getchar())\n    ;\n  x = flag ? -x : x;\n}\ninline void write(long long x) {\n  static const long long maxlen = 100;\n  static char s[maxlen];\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  if (!x) {\n    putchar('0');\n    return;\n  }\n  long long len = 0;\n  for (; x; x /= 10) s[len++] = x % 10 + '0';\n  for (long long i = len - 1; i >= 0; --i) putchar(s[i]);\n}\ninline void read(int &x) {\n  char ch;\n  bool flag = false;\n  for (ch = getchar(); !isdigit(ch); ch = getchar())\n    if (ch == '-') flag = true;\n  for (x = 0; isdigit(ch); x = x * 10 + ch - '0', ch = getchar())\n    ;\n  x = flag ? -x : x;\n}\ninline void write(int x) {\n  static const long long maxlen = 100;\n  static char s[maxlen];\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  if (!x) {\n    putchar('0');\n    return;\n  }\n  long long len = 0;\n  for (; x; x /= 10) s[len++] = x % 10 + '0';\n  for (long long i = len - 1; i >= 0; --i) putchar(s[i]);\n}\nconst int MAXN = 101000;\nvector<int> full[MAXN];\nset<int> l;\nvector<int> lack[MAXN];\nint lim[MAXN];\nint sum[MAXN];\nvector<int> a[MAXN];\nint n, m;\npair<int, int> id[MAXN];\nint main() {\n  read(n);\n  read(m);\n  int cnt = 0;\n  for (int i = 1; i <= n; i++) {\n    read(sum[i]);\n    for (int j = 1; j <= sum[i]; j++) {\n      int x;\n      read(x);\n      a[i].push_back(x);\n    }\n    id[i].first = -sum[i];\n    id[i].second = i;\n    cnt += sum[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    lim[i] = cnt / n + ((i <= cnt % n) ? 1 : 0);\n  }\n  sort(id + 1, id + n + 1);\n  int cnt_ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int x = id[i].second;\n    if (sum[x] > lim[i]) {\n      for (int j = 0; j < sum[x]; j++) full[a[x][j]].push_back(x);\n    }\n    if (sum[x] < lim[i]) {\n      l.insert(x);\n      for (int j = 0; j < sum[x]; j++) lack[a[x][j]].push_back(x);\n    }\n    sum[x] = sum[x] - lim[i];\n    cnt_ans += abs(sum[x]);\n  }\n  printf(\"%d\\n\", cnt_ans / 2);\n  for (int i = 1; i <= m; i++) {\n    lack[i].push_back(n + 1);\n    sort(lack[i].begin(), lack[i].end());\n  }\n  for (int i = 1; i <= m; i++) {\n    int now = 0;\n    auto pos = l.begin();\n    for (int j = 0; j < full[i].size(); j++) {\n      int x = full[i][j];\n      if (sum[x] <= 0) continue;\n      if (pos == l.end()) break;\n      while (lack[i][now] < (*pos)) now++;\n      while ((pos != l.end()) && ((*pos) == lack[i][now])) {\n        pos++;\n        if (pos == l.end()) break;\n        while (lack[i][now] < (*pos)) now++;\n      }\n      if (pos == l.end()) break;\n      int val = *pos;\n      sum[val]++;\n      sum[x]--;\n      printf(\"%d %d %d\\n\", x, val, i);\n      pos++;\n      if (sum[val] >= 0) l.erase(val);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nusing namespace std;\nlong long n, m;\nset<long long> v[((long long)(1e6 + 600))];\nint main() {\n  ios::sync_with_stdio(0);\n  long long t, k;\n  cin >> n >> m;\n  long long s = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> t;\n    while (t--) {\n      cin >> k;\n      v[i].insert(k);\n    }\n    s += v[i].size();\n  }\n  long long l = s / n, r = s / n + ((s % n) > 0);\n  stack<long long> g;\n  for (int i = 0; i < n; i++)\n    if (v[i].size() < l) g.push(i);\n  vector<pair<pair<long long, long long>, long long> > pas;\n  for (int i = 0; i < n; i++) {\n    while (v[i].size() > r && g.size()) {\n      auto w = g.top();\n      for (auto it = v[i].begin(); it != v[i].end();) {\n        if (v[w].find(*it) != v[w].end()) {\n          it++;\n          continue;\n        }\n        pas.push_back({{i, w}, *it});\n        v[w].insert((*it));\n        auto k = it;\n        k++;\n        v[i].erase(it);\n        it = k;\n        if (v[i].size() <= r) break;\n        if (v[w].size() >= l) break;\n      }\n      if (v[w].size() >= l) g.pop();\n    }\n  }\n  if (g.size()) {\n    for (int i = 0; i < n; i++) {\n      while (v[i].size() > l && g.size()) {\n        auto w = g.top();\n        for (auto it = v[i].begin(); it != v[i].end();) {\n          if (v[w].find(*it) != v[w].end()) {\n            it++;\n            continue;\n          }\n          pas.push_back({{i, w}, *it});\n          v[w].insert((*it));\n          auto k = it;\n          k++;\n          v[i].erase(it);\n          it = k;\n          if (v[i].size() == l) break;\n          if (v[w].size() >= l) break;\n        }\n        if (v[w].size() >= l) g.pop();\n      }\n    }\n  } else {\n    for (int i = 0; i < n; i++)\n      if (v[i].size() < r) g.push(i);\n    for (int i = 0; i < n; i++) {\n      while (v[i].size() > r && g.size()) {\n        auto w = g.top();\n        for (auto it = v[i].begin(); it != v[i].end();) {\n          if (v[w].find(*it) != v[w].end()) {\n            it++;\n            continue;\n          }\n          pas.push_back({{i, w}, *it});\n          v[w].insert((*it));\n          auto k = it;\n          k++;\n          v[i].erase(it);\n          it = k;\n          if (v[i].size() <= r) break;\n          if (v[w].size() == r) break;\n        }\n        if (v[w].size() == r) g.pop();\n      }\n    }\n  }\n  cout << pas.size() << endl;\n  for (auto x : pas) {\n    cout << x.first.first + 1 << \" \" << x.first.second + 1 << \" \" << x.second\n         << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  int N, M;\n  cin >> N >> M;\n  int totalSize = 0;\n  vi sz(N);\n  vi ord(N);\n  vvi have(M);\n  for (int i = 0; i < N; i++) {\n    cin >> sz[i];\n    totalSize += sz[i];\n    for (int j = 0, v; j < sz[i]; j++) {\n      cin >> v;\n      have[v - 1].push_back(i);\n    }\n    ord[i] = i;\n  }\n  sort((ord).begin(), (ord).end(),\n       [&sz](int i, int j) { return sz[i] < sz[j]; });\n  vi rank(N);\n  for (int i = 0; i < N; i++) rank[ord[i]] = i;\n  vi targ(N);\n  set<int> smalls;\n  for (int i = 0; i < N; i++) {\n    targ[i] = (totalSize + rank[i]) / N;\n    if (sz[i] < targ[i]) smalls.insert(i);\n  }\n  vector<array<int, 3>> moves;\n  for (int t = 0; t < M; t++) {\n    vi tmp;\n    for (int i : have[t]) {\n      if (sz[i] < targ[i]) {\n        smalls.erase(i);\n        tmp.push_back(i);\n      }\n    }\n    for (int i : have[t]) {\n      if (sz[i] > targ[i] && smalls.size() > 0) {\n        int to = *smalls.begin();\n        smalls.erase(smalls.begin());\n        moves.push_back({i, to, t});\n        sz[i]--;\n        sz[to]++;\n        if (sz[to] < targ[to]) tmp.push_back(to);\n      }\n    }\n    smalls.insert((tmp).begin(), (tmp).end());\n  }\n  cout << moves.size() << \"\\n\";\n  for (auto [f, t, k] : moves) {\n    cout << f + 1 << \" \" << t + 1 << \" \" << k + 1 << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nstruct triple {\n  int x, y, z;\n};\nstruct box {\n  int id, diff;\n  unordered_set<int> pres;\n  void input(int x) {\n    int s;\n    scanf(\"%d\", &s);\n    while (s--) {\n      int curr;\n      scanf(\"%d\", &curr);\n      pres.insert(curr);\n    }\n    id = x;\n  }\n  bool operator<(const box &rhs) const { return pres.size() > rhs.pres.size(); }\n};\nint N, M;\nbox b[MAXN];\nunordered_set<int> all, where[MAXN];\nvector<triple> ans;\nint tot;\nvoid load() {\n  scanf(\"%d%d\", &N, &M);\n  for (int i = 0; i < N; i++) {\n    b[i].input(i + 1);\n    tot += b[i].pres.size();\n  }\n}\nbool cmp(const box &lhs, const box &rhs) { return lhs.diff < rhs.diff; }\nvoid solve() {\n  sort(b, b + N);\n  for (int i = 0; i < N; i++)\n    b[i].diff = (int)b[i].pres.size() - (tot / N + (i < tot % N));\n  sort(b, b + N, cmp);\n  for (int i = 0; i < N; i++)\n    if (b[i].diff > 0)\n      for (auto it : b[i].pres) {\n        all.insert(it);\n        where[it].insert(i);\n      }\n  for (int i = 0; i < N && b[i].diff < 0; i++) {\n    vector<int> todo;\n    for (auto it : b[i].pres) {\n      all.erase(it);\n      todo.push_back(it);\n    }\n    for (int j = 0; j < -b[i].diff; j++) {\n      int kind = *all.begin();\n      int from = *where[kind].begin();\n      ans.push_back({b[from].id, b[i].id, kind});\n      where[kind].erase(from);\n      b[from].pres.erase(kind);\n      b[from].diff--;\n      all.erase(kind);\n      todo.push_back(kind);\n      if (!b[from].diff)\n        for (auto it : b[from].pres) {\n          where[it].erase(from);\n          if (where[it].empty()) all.erase(it);\n        }\n    }\n    for (auto it : todo)\n      if (!where[it].empty()) all.insert(it);\n  }\n  printf(\"%d\\n\", ans.size());\n  for (auto it : ans) printf(\"%d %d %d\\n\", it.x, it.y, it.z);\n}\nint main() {\n  load();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 ran(time(0));\nint mod = 1e9 + 7;\nint gcd(int a, int b) {\n  if (!b) return a;\n  return gcd(b, a % b);\n}\nlong long Bpow(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) {\n      ans *= a;\n      ans %= mod;\n    }\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return ans;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> k(n);\n  set<pair<int, int>> st;\n  vector<vector<int>> nums(m + 1);\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> k[i];\n    sum += k[i];\n    st.insert({k[i], i});\n    for (int j = 0; j < k[i]; j++) {\n      int a;\n      cin >> a;\n      nums[a].push_back(i);\n    }\n  }\n  int mi = sum / n;\n  int cnt = sum - mi * n;\n  int now = 0;\n  for (int i = 0; i < n; i++) {\n    if (k[i] > mi) now++;\n  }\n  vector<vector<int>> ans;\n  for (int i = 1; i < m + 1; i++) {\n    for (auto& nm : nums[i]) {\n      st.erase({k[nm], nm});\n    }\n    vector<pair<int, int>> in;\n    for (auto& nm : nums[i]) {\n      if (!st.empty() &&\n          (now > cnt && k[nm] >= mi + 1 && st.begin()->first < mi ||\n           now < cnt && k[nm] > mi + 1 && st.begin()->first <= mi ||\n           now == cnt && k[nm] > mi + 1 && st.begin()->first < mi)) {\n        k[nm]--;\n        if (mi == k[nm]) --now;\n        pair<int, int> v = *st.begin();\n        v.first++;\n        if (v.first == mi + 1) now++;\n        st.erase({v.first - 1, v.second});\n        in.push_back(v);\n        k[v.second]++;\n        ans.push_back({nm + 1, v.second + 1, i});\n      }\n    }\n    for (auto& t : in) st.insert(t);\n    for (auto& nm : nums[i]) {\n      st.insert({k[nm], nm});\n    }\n  }\n  cout << ans.size() << \"\\n\";\n  for (auto& v : ans) {\n    for (auto& viv : v) cout << viv << \" \";\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100007;\nset<int> st[MAXN];\npair<int, int> pr[MAXN];\nint target[MAXN];\nint rmap[MAXN];\nstruct nd {\n  int from, to, item;\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  int tot = 0;\n  for (int i = 1; i <= n; i++) {\n    int s;\n    cin >> s;\n    pr[i].first = s;\n    pr[i].second = i;\n    tot += s;\n    while (s--) {\n      int x;\n      cin >> x;\n      st[i].insert(x);\n    }\n  }\n  sort(pr + 1, pr + n + 1);\n  for (int i = 1; i <= n; i++) {\n    rmap[pr[i].second] = i;\n  }\n  set<pair<int, int> > fcuk;\n  int x = 0;\n  for (int i = 1; i <= n; i++) {\n    target[i] = tot / (n + 1 - i);\n    tot -= target[i];\n    int id = pr[i].second;\n    if (st[id].size() < target[i])\n      x = i;\n    else if (st[id].size() > target[i]) {\n      for (int x : st[id]) {\n        fcuk.emplace(x, id);\n      }\n    }\n  }\n  vector<nd> vnd;\n  for (int i = 1; i <= x; i++) {\n    int id = pr[i].second;\n    auto it = fcuk.begin();\n    while (it != fcuk.end() && st[id].size() < target[i]) {\n      pair<int, int> p = *it;\n      if (st[id].find(p.first) != st[id].end())\n        ;\n      else {\n        fcuk.erase(it);\n        st[id].insert(p.first);\n        vnd.push_back(nd{p.second, id, p.first});\n        st[p.second].erase(p.first);\n        int jd = rmap[p.second];\n        if (st[p.second].size() == target[jd]) {\n          for (int x : st[p.second]) {\n            fcuk.erase(pair<int, int>(x, p.second));\n          }\n        }\n      }\n      it = fcuk.lower_bound(pair<int, int>(p.first + 1, 0));\n    }\n    assert(st[id].size() == target[i]);\n  }\n  cout << vnd.size() << endl;\n  for (nd _ : vnd) {\n    cout << _.from << \" \" << _.to << \" \" << _.item << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 1;\nstruct segTree {\n  segTree *left = nullptr, *right = nullptr;\n  long long val = 0;\n};\nlong long v(segTree* cur) { return (cur == nullptr) ? 0 : cur->val; }\nsegTree* righ(segTree* cur) { return (cur == nullptr) ? nullptr : cur->right; }\nsegTree* lef(segTree* cur) { return (cur == nullptr) ? nullptr : cur->left; }\nlong long m;\nvoid update(long long p, long long val, segTree* cur, long long ll = 1,\n            long long rr = m) {\n  if (ll == rr) {\n    cur->val = val;\n    return;\n  }\n  long long mid = (ll + rr) / 2;\n  if (p <= mid) {\n    if (cur->left == nullptr) cur->left = new segTree();\n    update(p, val, cur->left, ll, mid);\n  } else {\n    if (cur->right == nullptr) cur->right = new segTree();\n    update(p, val, cur->right, mid + 1, rr);\n  }\n  cur->val = v(cur->left) + v(cur->right);\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  srand(time(0));\n  long long n;\n  cin >> n >> m;\n  segTree* s[n];\n  for (long long i = 0; i < n; i++) s[i] = new segTree();\n  long long sum = 0;\n  priority_queue<pair<long long, long long>> mx, mn;\n  for (long long i = 0; i < n; i++) {\n    long long q;\n    cin >> q;\n    sum += q;\n    mx.push({q, i});\n    mn.push({-q, i});\n    for (long long j = 0; j < q; j++) {\n      long long k;\n      cin >> k;\n      update(k, 1, s[i]);\n    }\n  }\n  long long lim = sum % n != 0;\n  vector<vector<long long>> ans;\n  while (mx.top().first + mn.top().first > lim) {\n    long long sf = mx.top().first, ss = -mn.top().first;\n    long long f = mx.top().second, u = mn.top().second;\n    mx.pop();\n    mn.pop();\n    long long l = 1, r = m;\n    segTree *c1 = s[f], *c2 = s[u];\n    while (l != r) {\n      long long mid = (l + r) / 2;\n      if (v(lef(c1)) <= v(lef(c2))) {\n        c1 = righ(c1);\n        c2 = righ(c2);\n        l = mid + 1;\n      } else {\n        c1 = lef(c1);\n        c2 = lef(c2);\n        r = mid;\n      }\n    }\n    ans.push_back({f, u, l});\n    update(l, 0, s[f]);\n    update(l, 1, s[u]);\n    mx.push({sf - 1, f});\n    mn.push({-(sf - 1), f});\n    mx.push({ss + 1, u});\n    mn.push({-(ss + 1), u});\n  }\n  cout << ans.size() << endl;\n  for (vector<long long> i : ans)\n    cout << i[0] + 1 << \" \" << i[1] + 1 << \" \" << i[2] << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint h[2][100005], n, m, tot = 0, ans[5 * 100005][3], fin = 0;\nset<int> trans;\nset<int> hv[100005];\nvoid transR(int id, int val) {\n  if (!h[0][id] && h[1][id]) trans.erase(id);\n  h[1][id] += val;\n  if (!h[0][id] && h[1][id]) trans.insert(id);\n}\nvoid transL(int id, int val) {\n  if (!h[0][id] && h[1][id]) trans.erase(id);\n  h[0][id] += val;\n  if (!h[0][id] && h[1][id]) trans.insert(id);\n}\nvoid give(int from, int to, int g) {\n  hv[from].erase(g);\n  hv[to].insert(g);\n  transR(g, -1);\n  transL(g, 1);\n  ans[fin][0] = from, ans[fin][1] = to, ans[fin][2] = g;\n  fin++;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  memset(h, 0, sizeof(h));\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    int a;\n    cin >> a;\n    tot += a;\n    for (int j = 0; j < a; j++) {\n      int b;\n      cin >> b;\n      hv[i].insert(b);\n    }\n  }\n  vector<int> v(n + 5);\n  for (int i = 1; i <= n; i++) v[i] = i;\n  sort(v.begin() + 1, v.begin() + n + 1, [&](int &a, int &b) {\n    return (int)(hv[a].size()) < (int)(hv[b].size());\n  });\n  for (auto &i : hv[v[n]]) transR(i, 1);\n  for (auto &i : hv[v[1]]) transL(i, 1);\n  int tgt = tot / n, rem = tot % n;\n  for (int i = 1, j = n; i < j;) {\n    int tr = tgt;\n    if (n - j + 1 <= rem) tr++;\n    if (hv[v[j]].size() == tr) {\n      for (auto &k : hv[v[j]]) transR(k, -1);\n      j--;\n      for (auto &k : hv[v[j]]) transR(k, 1);\n      continue;\n    }\n    int tl = tgt;\n    if (n - i + 1 <= rem) tl++;\n    if (hv[v[i]].size() == tl) {\n      for (auto &k : hv[v[i]]) transL(k, -1);\n      i++;\n      for (auto &k : hv[v[i]]) transL(k, 1);\n      continue;\n    }\n    give(v[j], v[i], (*trans.begin()));\n  }\n  cout << fin << '\\n';\n  for (int i = 0; i < fin; i++)\n    cout << ans[i][0] << ' ' << ans[i][1] << ' ' << ans[i][2] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 2e5 + 5;\nint n, m;\nint a[N], sum;\nint take[N], want[N];\nset<int> s[N];\nvector<pair<pair<int, int>, int> > ans;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    int sz;\n    cin >> sz;\n    for (int j = 1; j <= sz; j++) {\n      int x;\n      cin >> x;\n      s[i].insert(x);\n    }\n    a[i] = i;\n    sum += sz;\n  }\n  sort(a + 1, a + 1 + n,\n       [](int x, int y) { return s[x].size() < s[y].size(); });\n  for (int i = 1; i <= n; i++) {\n    if (i < n - (sum % n) + 1) {\n      want[i] = sum / n;\n    } else {\n      want[i] = sum / n + 1;\n    }\n  }\n  int L = 1, R = n;\n  while (L < R) {\n    if (want[L] == (int)s[a[L]].size()) {\n      L++;\n      continue;\n    }\n    if (want[R] == (int)s[a[R]].size()) {\n      R--;\n      continue;\n    }\n    if (take[L] == 0) {\n      int need =\n          min(want[L] - (int)s[a[L]].size(), (int)s[a[R]].size() - want[R]);\n      vector<int> give;\n      if (s[a[L]].size() == 0) {\n        while ((int)give.size() < need) {\n          auto it = s[a[R]].begin();\n          give.push_back(*it);\n          s[a[R]].erase(it);\n        }\n      } else {\n        while ((int)give.size() < need && *s[a[R]].begin() < *s[a[L]].begin()) {\n          give.push_back(*s[a[R]].begin());\n          s[a[R]].erase(s[a[R]].begin());\n        }\n        for (int i : s[a[L]]) {\n          if ((int)give.size() == need) break;\n          auto it = s[a[L]].find(i);\n          it++;\n          int val = (it != s[a[L]].end() ? *it : 1e9);\n          while (1) {\n            if ((int)give.size() == need) break;\n            auto it1 = s[a[R]].upper_bound(i);\n            if (it1 == s[a[R]].end()) break;\n            if (*it1 >= val) break;\n            give.push_back(*it1);\n            s[a[R]].erase(it1);\n          }\n        }\n      }\n      for (int i : give) {\n        ans.push_back({{a[R], a[L]}, i});\n        s[a[L]].insert(i);\n      }\n      take[L] = 1;\n    } else {\n      int need =\n          min(want[L] - (int)s[a[L]].size(), (int)s[a[R]].size() - want[R]);\n      vector<int> give;\n      for (int i : s[a[R]]) {\n        if ((int)give.size() == need) break;\n        if (s[a[L]].find(i) == s[a[L]].end()) {\n          give.push_back(i);\n        }\n      }\n      for (int i : give) {\n        ans.push_back({{a[R], a[L]}, i});\n        s[a[R]].erase(i);\n        s[a[L]].insert(i);\n      }\n      take[R] = 1;\n    }\n  }\n  cout << (int)ans.size() << \"\\n\";\n  for (auto i : ans) {\n    cout << i.first.first << \" \" << i.first.second << \" \" << i.second << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int N = 1e5 + 10;\nstruct kek {\n  long long l, r, sum;\n};\nstruct lol {\n  long long x, y, z;\n};\nvector<kek> t[N];\nlong long ans;\nvoid add(long long now) { t[now].push_back({-1, -1, 0}); }\nvoid modify(long long now, long long w, long long tl, long long tr,\n            long long pos, long long val) {\n  if (tl == tr)\n    t[now][w].sum = val;\n  else {\n    if (t[now][w].r == -1) {\n      t[now][w].r = t[now].size();\n      add(now);\n    }\n    if (t[now][w].l == -1) {\n      t[now][w].l = t[now].size();\n      add(now);\n    }\n    long long c = (tl + tr) / 2;\n    if (pos <= c)\n      modify(now, t[now][w].l, tl, c, pos, val);\n    else\n      modify(now, t[now][w].r, c + 1, tr, pos, val);\n    t[now][w].sum = t[now][t[now][w].l].sum + t[now][t[now][w].r].sum;\n  }\n}\nvoid dfs(long long big, long long small, long long W, long long w, long long tl,\n         long long tr) {\n  if (ans != INF) return;\n  if (tl == tr)\n    ans = tl;\n  else {\n    long long TOL = t[big][W].l, TOR = t[big][W].r, tol = t[small][w].l,\n              tor = t[small][w].r;\n    if (TOL == -1) {\n      t[big][W].l = t[big].size();\n      TOL = t[big].size();\n      add(big);\n    }\n    if (TOR == -1) {\n      t[big][W].r = t[big].size();\n      TOR = t[big].size();\n      add(big);\n    }\n    if (tol == -1) {\n      t[small][w].l = t[small].size();\n      tol = t[small].size();\n      add(small);\n    }\n    if (tor == -1) {\n      t[small][w].r = t[small].size();\n      tor = t[small].size();\n      add(small);\n    }\n    long long c = (tl + tr) / 2;\n    if (t[big][TOL].sum > t[small][tol].sum)\n      dfs(big, small, TOL, tol, tl, c);\n    else\n      dfs(big, small, TOR, tor, c + 1, tr);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, m, k, i, j, x;\n  set<pair<long long, long long> > st;\n  cin >> n >> m;\n  for (i = 1; i <= n; ++i) {\n    add(i);\n    cin >> k;\n    st.insert({k, i});\n    while (k--) {\n      cin >> x;\n      modify(i, 0, 1, m, x, 1);\n    }\n  }\n  vector<lol> way;\n  while (st.size() > 1) {\n    auto it = st.begin();\n    long long x = (*it).first;\n    long long y = (*it).second;\n    it = st.end();\n    --it;\n    long long a = (*it).first;\n    long long b = (*it).second;\n    if (a - x > 1) {\n      ans = INF;\n      dfs(b, y, 0, 0, 1, m);\n      modify(b, 0, 1, m, ans, 0);\n      modify(y, 0, 1, m, ans, 1);\n      way.push_back({b, y, ans});\n      st.erase({x, y});\n      st.insert({x + 1, y});\n      st.erase({a, b});\n      st.insert({a - 1, b});\n    } else\n      break;\n  }\n  cout << way.size() << endl;\n  for (auto it : way) cout << it.x << \" \" << it.y << \" \" << it.z << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, s, t;\nvector<vector<int> > gift(100005);\nunordered_set<int> les;\nint sum[100005], req[100005], all, res;\nint main() {\n  vector<pair<int, int> > ord;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &s);\n    all += s;\n    sum[i] = s;\n    ord.push_back({s, i});\n    for (int j = 1; j <= s; j++) {\n      scanf(\"%d\", &t);\n      gift[t].push_back(i);\n    }\n  }\n  sort(ord.begin(), ord.end());\n  for (int i = 0; i < n; i++) req[ord[i].second] = (all + i) / n;\n  for (int i = 1; i <= n; i++)\n    if (sum[i] < req[i]) les.insert(i);\n  for (int i = 1; i <= n; i++) res += abs(sum[i] - req[i]);\n  printf(\"%d\\n\", res / 2);\n  for (int i = 1; i <= m; i++) {\n    vector<int> mor, del;\n    unordered_set<int> used;\n    for (auto j : gift[i])\n      if (sum[j] > req[j]) mor.push_back(j);\n    for (auto j : gift[i])\n      if (sum[j] < req[j]) used.insert(j);\n    for (auto it = les.begin(); it != les.end(); it++) {\n      if (!mor.size()) break;\n      int u = mor.back(), v = *it;\n      if (used.find(v) != used.end()) continue;\n      printf(\"%d %d %d\\n\", u, v, i);\n      mor.pop_back();\n      sum[u]--;\n      sum[v]++;\n      if (sum[v] == req[v]) del.push_back(v);\n    }\n    for (auto j : del) les.erase(j);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  int N, M;\n  cin >> N >> M;\n  int totalSize = 0;\n  vi sz(N);\n  vector<set<int>> boxes(N);\n  vvi have(M);\n  for (int i = 0; i < N; i++) {\n    cin >> sz[i];\n    totalSize += sz[i];\n    for (int j = 0, v; j < sz[i]; j++) {\n      cin >> v;\n      have[v - 1].push_back(i);\n      boxes[i].insert(v - 1);\n    }\n  }\n  int small = totalSize / N;\n  int big = small + !!(totalSize % N);\n  int needUp = 0;\n  int needDown = 0;\n  for (int v : sz) {\n    if (v < small) needUp += small - v;\n    if (v > big) needDown += v - big;\n  }\n  int extrDown = max(0, needUp - needDown);\n  int extrUp = max(0, needDown - needUp);\n  set<int> smalls;\n  for (int i = 0; i < N; i++) {\n    if (sz[i] < small || (sz[i] < big && extrUp > 0)) {\n      if (sz[i] == small) extrUp--;\n      smalls.insert(i);\n    }\n  }\n  vector<array<int, 3>> moves;\n  for (int t = 0; t < M; t++) {\n    auto it = smalls.begin();\n    for (int b : have[t]) {\n      if (sz[b] > big || (sz[b] > small && extrDown > 0)) {\n        if (sz[b] == big) extrDown--;\n        while (it != smalls.end() && boxes[*it].count(t)) it++;\n        if (it != smalls.end()) {\n          moves.push_back({b, *it, t});\n          sz[b]--;\n          ++sz[*it];\n          if (sz[*it] < small || (sz[*it] < big && extrUp > 0)) {\n            if (sz[*it] == small) extrUp--;\n            it++;\n          } else {\n            it = smalls.erase(it);\n          }\n        }\n      }\n    }\n  }\n  cout << moves.size() << \"\\n\";\n  for (auto [f, t, k] : moves) {\n    cout << f + 1 << \" \" << t + 1 << \" \" << k + 1 << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, last[100005], need[100005], ss[100005];\nvector<pair<pair<long long, long long>, long long> > ans;\npair<long long, long long> size_[100005];\nset<long long> ls;\nvector<long long> vr[100005];\nint main() {\n  long long tot = 0;\n  scanf(\"%lld %lld\", &n, &m);\n  for (int i = 1; i < n + 1; i++) {\n    long long x, y;\n    scanf(\"%lld\", &x);\n    for (int j = 0; j < x; j++) {\n      scanf(\"%lld\", &y);\n      vr[y].push_back(i);\n    }\n    ss[i] = x;\n    size_[i] = make_pair(x, i);\n    tot += x;\n  }\n  long long ones = tot % n;\n  sort(size_ + 1, size_ + 1 + n, greater<pair<long long, long long> >());\n  for (int i = 1; i < n + 1; i++) {\n    long long idx = size_[i].second, val = size_[i].first;\n    need[idx] = tot / n + (i <= ones);\n  }\n  for (int i = 1; i < n + 1; i++)\n    if (ss[i] < need[i]) ls.insert(i);\n  for (int i = 1; i < m + 1; i++) {\n    vector<long long> temp, ers;\n    for (auto itr = vr[i].begin(); itr != vr[i].end(); itr++) {\n      long long idx = *itr;\n      if (ss[idx] > need[idx]) {\n        temp.push_back(idx);\n      }\n      last[idx] = i;\n    }\n    for (auto itr = ls.begin(); (itr != ls.end()) && temp.size(); itr++) {\n      long long idx = *itr;\n      if (last[idx] != i) {\n        ss[idx]++;\n        ss[*temp.rbegin()]--;\n        if (ss[idx] == need[idx]) ers.push_back(idx);\n        ans.push_back(make_pair(make_pair(*temp.rbegin(), idx), i));\n        temp.pop_back();\n      }\n    }\n    while (ers.size()) {\n      ls.erase(*ers.rbegin());\n      ers.pop_back();\n    }\n  }\n  printf(\"%d\\n\", ans.size());\n  for (int i = 0; i < ans.size(); i++)\n    cout << ans[i].first.first << \" \" << ans[i].first.second << \" \"\n         << ans[i].second << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int readChar();\ntemplate <class T = int>\ninline T readInt();\ntemplate <class T>\ninline void writeInt(T x, char end = 0);\ninline void writeChar(int x);\ninline void writeWord(const char *s);\nstatic const int buf_size = 4096;\ninline int getChar() {\n  static char buf[buf_size];\n  static int len = 0, pos = 0;\n  if (pos == len) pos = 0, len = fread(buf, 1, buf_size, stdin);\n  if (pos == len) return -1;\n  return buf[pos++];\n}\ninline int readChar() {\n  int c = getChar();\n  while (c <= 32) c = getChar();\n  return c;\n}\ntemplate <class T>\ninline T readInt() {\n  int s = 1, c = readChar();\n  T x = 0;\n  if (c == '-') s = -1, c = getChar();\n  while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getChar();\n  return s == 1 ? x : -x;\n}\nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\ninline void writeChar(int x) {\n  if (write_pos == buf_size)\n    fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n  write_buf[write_pos++] = x;\n}\ntemplate <class T>\ninline void writeInt(T x, char end) {\n  if (x < 0) writeChar('-'), x = -x;\n  char s[24];\n  int n = 0;\n  while (x || !n) s[n++] = '0' + x % 10, x /= 10;\n  while (n--) writeChar(s[n]);\n  if (end) writeChar(end);\n}\ninline void writeWord(const char *s) {\n  while (*s) writeChar(*s++);\n}\nstruct Flusher {\n  ~Flusher() {\n    if (write_pos) fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n  }\n} flusher;\ninline void readWord(char *s) {\n  int c = readChar();\n  while (c > 32) *s++ = c, c = getChar();\n  *s = 0;\n}\ninline void writeDouble(double x, int output_len) {\n  if (x < 0) writeChar('-'), x = -x;\n  int t = (int)x;\n  writeInt(t), x -= t;\n  writeChar('.');\n  for (int i = output_len - 1; i > 0; i--) {\n    x *= 10;\n    t = min(9, (int)x);\n    writeChar('0' + t), x -= t;\n  }\n  x *= 10;\n  t = min(9, (int)(x + 0.5));\n  writeChar('0' + t);\n}\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing ull = unsigned long long;\nusing pnt = complex<ld>;\nistream &operator>>(istream &in, pnt &p) {\n  ld a, b;\n  in >> a >> b;\n  p = {a, b};\n  return in;\n}\nld crs(pnt a, pnt b) { return a.real() * b.imag() - a.imag() * b.real(); }\nld dot(pnt a, pnt b) { return a.real() * b.real() + a.imag() * b.imag(); }\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 100;\nconst ll inf64 = 1e18L;\nconst ld pi = acos(-1.0L);\nconst ld eps = 1e-9L;\nconst int di[] = {1, 1, -1, -1, 2, 2, -2, -2};\nconst int dj[] = {2, -2, 2, -2, 1, -1, 1, -1};\nconst int dii[] = {0, 1, -1, 0};\nconst int djj[] = {1, 0, 0, -1};\nconst int dx[] = {1, 1, -1, -1};\nconst int dy[] = {1, -1, 1, -1};\nconst int SQ = 1000;\nconst int LG = 19;\nconst int nax = 5e5;\nint n, m;\nint s[nax];\nset<pii> setik;\nint tot;\nvi fromi, toi, kindi;\nvi cb[nax];\nbitset<nax> tok;\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cout.precision(8);\n  cout << fixed;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    tot += s[i];\n    for (int j = 0; j < s[i]; j++) {\n      int c;\n      cin >> c;\n      c--;\n      cb[c].push_back(i);\n    }\n    setik.insert(make_pair(s[i], i));\n  }\n  int lo = tot / n, hi = (tot + n - 1) / n;\n  for (int i = 0; i < m; i++) {\n    if (cb[i].empty()) continue;\n    sort(cb[i].begin(), cb[i].end(),\n         [&](int i1, int i2) { return s[i1] < s[i2]; });\n    int S = (int)((cb[i]).size());\n    if (s[cb[i][S - 1]] <= hi) continue;\n    for (int id : cb[i]) tok[id] = 1;\n    int pt = S - 1;\n    while (pt != 0 && s[cb[i][pt - 1]] > hi) pt--;\n    auto it = setik.begin();\n    vi cl;\n    while (it != setik.end() && it->first <= lo - 1 &&\n           (int)((cl).size()) != S - pt) {\n      if (!tok[it->second]) cl.push_back(it->second);\n      it++;\n    }\n    if (cl.empty()) {\n      for (int id : cb[i]) tok[id] = 0;\n      continue;\n    }\n    while (S - pt > (int)((cl).size())) pt++;\n    for (int j = 0; j < (int)((cl).size()); j++) {\n      int f = cb[i][pt + j];\n      fromi.push_back(f);\n      int t = cl[j];\n      toi.push_back(t);\n      kindi.push_back(i);\n      setik.erase(make_pair(s[f], f));\n      s[f]--;\n      setik.insert(make_pair(s[f], f));\n      setik.erase(make_pair(s[t], t));\n      s[t]++;\n      setik.insert(make_pair(s[t], t));\n      cb[i][pt + j] = t;\n    }\n    for (int id : cb[i]) tok[id] = 0;\n  }\n  for (int i = 0; i < m && (setik.rbegin()->first != hi); i++) {\n    if (cb[i].empty()) continue;\n    sort(cb[i].begin(), cb[i].end(),\n         [&](int i1, int i2) { return s[i1] < s[i2]; });\n    int S = (int)((cb[i]).size());\n    if (s[cb[i][S - 1]] <= hi) continue;\n    for (int id : cb[i]) tok[id] = 1;\n    int pt = S - 1;\n    while (pt != 0 && s[cb[i][pt - 1]] > hi) pt--;\n    auto it = setik.begin();\n    vi cl;\n    while (it != setik.end() && it->first <= lo &&\n           (int)((cl).size()) != S - pt) {\n      if (!tok[it->second]) cl.push_back(it->second);\n      it++;\n    }\n    if (cl.empty()) {\n      for (int id : cb[i]) tok[id] = 0;\n      continue;\n    }\n    while (S - pt > (int)((cl).size())) pt++;\n    for (int j = 0; j < (int)((cl).size()); j++) {\n      int f = cb[i][pt + j];\n      fromi.push_back(f);\n      int t = cl[j];\n      toi.push_back(t);\n      kindi.push_back(i);\n      setik.erase(make_pair(s[f], f));\n      s[f]--;\n      setik.insert(make_pair(s[f], f));\n      setik.erase(make_pair(s[t], t));\n      s[t]++;\n      setik.insert(make_pair(s[t], t));\n      cb[i][pt + j] = t;\n    }\n    for (int id : cb[i]) tok[id] = 0;\n  }\n  for (int i = 0; i < m && (setik.begin()->first != lo); i++) {\n    if (cb[i].empty()) continue;\n    sort(cb[i].begin(), cb[i].end(),\n         [&](int i1, int i2) { return s[i1] < s[i2]; });\n    int S = (int)((cb[i]).size());\n    if (s[cb[i][S - 1]] < hi) continue;\n    for (int id : cb[i]) tok[id] = 1;\n    int pt = S - 1;\n    while (pt != 0 && s[cb[i][pt - 1]] >= hi) pt--;\n    auto it = setik.begin();\n    vi cl;\n    while (it != setik.end() && it->first <= lo - 1 &&\n           (int)((cl).size()) != S - pt) {\n      if (!tok[it->second]) cl.push_back(it->second);\n      it++;\n    }\n    if (cl.empty()) {\n      for (int id : cb[i]) tok[id] = 0;\n      continue;\n    }\n    while (S - pt > (int)((cl).size())) pt++;\n    for (int j = 0; j < (int)((cl).size()); j++) {\n      int f = cb[i][pt + j];\n      fromi.push_back(f);\n      int t = cl[j];\n      toi.push_back(t);\n      kindi.push_back(i);\n      setik.erase(make_pair(s[f], f));\n      s[f]--;\n      setik.insert(make_pair(s[f], f));\n      setik.erase(make_pair(s[t], t));\n      s[t]++;\n      setik.insert(make_pair(s[t], t));\n      cb[i][pt + j] = t;\n    }\n    for (int id : cb[i]) tok[id] = 0;\n  }\n  set<pii> was;\n  cout << (int)((fromi).size()) << '\\n';\n  for (int i = 0; i < (int)((fromi).size()); i++) {\n    if (was.count(make_pair(fromi[i], kindi[i]))) assert(false);\n    was.insert(make_pair(fromi[i], kindi[i]));\n    if (was.count(make_pair(toi[i], kindi[i]))) assert(false);\n    was.insert(make_pair(toi[i], kindi[i]));\n    cout << fromi[i] + 1 << ' ' << toi[i] + 1 << ' ' << kindi[i] + 1 << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, sum;\nint Need[100005], Order[100005];\nset<int> Presents[100005], Have[100005];\nvector<pair<pair<int, int>, int> > Op;\npriority_queue<pair<int, int> > pq;\nbool Compare(int x, int y) { return Presents[x].size() < Presents[y].size(); }\nvoid Add(int id) {\n  if ((int)Presents[id].size() < Need[id])\n    pq.push(make_pair(Need[id] - Presents[id].size(), id));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    Order[i] = i;\n    int sz;\n    cin >> sz;\n    sum += sz;\n    while (sz--) {\n      int tmp;\n      cin >> tmp;\n      Presents[i].insert(tmp);\n      Have[tmp].insert(i);\n    }\n  }\n  sort(Order + 1, Order + n + 1, Compare);\n  for (int i = 0; i < sum; i++) {\n    ++Need[Order[n - i % n]];\n  }\n  for (int i = 1; i <= n; i++) {\n    Add(i);\n  }\n  for (int i = 1; i <= m; i++) {\n    vector<int> Move;\n    for (auto x : Have[i]) {\n      if (Presents[x].size() <= Need[x]) {\n        continue;\n      }\n      while (pq.empty() == false) {\n        if (Have[i].count(pq.top().second) or\n            pq.top().first !=\n                Need[pq.top().second] - Presents[pq.top().second].size()) {\n          pq.pop();\n          continue;\n        }\n        Op.emplace_back(make_pair(x, pq.top().second), i);\n        Presents[x].erase(i);\n        Presents[pq.top().second].insert(i);\n        Move.emplace_back(pq.top().second);\n        pq.pop();\n        break;\n      }\n    }\n    for (auto x : Have[i]) {\n      Add(x);\n    }\n    for (auto x : Move) {\n      Add(x);\n    }\n  }\n  cout << Op.size() << '\\n';\n  for (auto x : Op) {\n    cout << x.first.first << ' ' << x.first.second << ' ' << x.second << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int x, y, z;\n} ans[500005];\nset<int> a[500005];\nset<int>::iterator ut, vt, tt;\npair<int, int> c[500005];\nint n, k, res, r[500005], b[500005], cnt, p, q, sum, id[500005], u, v;\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &b[i]);\n    for (int j = 0; j < b[i]; j++) {\n      scanf(\"%d\", &p);\n      a[i].insert(p);\n    }\n    sum += b[i];\n    c[i] = (pair<int, int>){b[i], i};\n  }\n  sort(c + 1, c + n + 1);\n  for (int i = 1; i <= n; i++) id[c[i].second] = i, r[i] = sum / n;\n  for (int i = 1; i <= n; i++)\n    if (id[i] > n - sum % n) r[i]++;\n  u = v = 1;\n  while (1) {\n    while (u <= n && b[u] >= r[u]) u++;\n    while (v <= n && b[v] <= r[v]) v++;\n    if (u > n || v > n) break;\n    for (ut = a[u].begin(), vt = a[v].begin();;\n         ut != a[u].end() && vt != a[v].end()) {\n      while (ut != a[u].end() && (*ut) < (*vt)) ut++;\n      if (ut == a[u].end() || (*ut) > (*vt)) {\n        ans[cnt++] = (node){v, u, (*vt)};\n        tt = vt;\n        vt++;\n        a[u].insert(*tt);\n        a[v].erase(tt);\n        b[u]++;\n        b[v]--;\n      } else\n        vt++;\n      if (b[u] == r[u] || b[v] == r[v]) break;\n    }\n  }\n  cout << cnt << endl;\n  for (int i = 0; i < cnt; i++)\n    printf(\"%d %d %d\\n\", ans[i].x, ans[i].y, ans[i].z);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  vector<vector<int>> a(n);\n  int total = 0;\n  for (int i = 0; i < n; ++i) {\n    int s;\n    scanf(\"%d\", &s);\n    for (int j = 0; j < s; ++j) {\n      int x;\n      scanf(\"%d\", &x);\n      a[i].push_back(x - 1);\n    }\n    total += s;\n  }\n  vector<int> p(n);\n  for (int i = 0; i < n; ++i) {\n    p[i] = i;\n  }\n  sort(p.begin(), p.end(),\n       [&](int x, int y) { return a[x].size() > a[y].size(); });\n  vector<int> need(n);\n  for (int i = 0; i < n; ++i) {\n    need[i] = total / n + (i < total % n);\n  }\n  int answer = 0;\n  for (int i = 0; i < n; ++i) {\n    if (a[p[i]].size() > need[i]) {\n      answer += a[p[i]].size() - need[i];\n    }\n  }\n  printf(\"%d\\n\", answer);\n  vector<bool> ban(m);\n  for (int i = 0, j = n - 1; i < j;) {\n    while (i < j && a[p[i]].size() == need[i]) {\n      ++i;\n    }\n    while (i < j && a[p[j]].size() == need[j]) {\n      --j;\n    }\n    if (i >= j) {\n      break;\n    }\n    int c = min(a[p[i]].size() - need[i], need[j] - a[p[j]].size());\n    for (auto x : a[p[j]]) {\n      ban[x] = true;\n    }\n    vector<int> temp;\n    while (c--) {\n      while (ban[a[p[i]].back()]) {\n        temp.push_back(a[p[i]].back());\n        a[p[i]].pop_back();\n      }\n      printf(\"%d %d %d\\n\", p[i] + 1, p[j] + 1, a[p[i]].back() + 1);\n      a[p[j]].push_back(a[p[i]].back());\n      a[p[i]].pop_back();\n    }\n    for (auto x : temp) {\n      a[p[i]].push_back(x);\n    }\n    for (auto x : a[p[j]]) {\n      ban[x] = false;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int nxt() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\nint main() {\n  int n = nxt(), m = nxt();\n  vector<set<int>> a(n);\n  for (int i = 0; i < n; ++i) {\n    int k = nxt();\n    for (int j = 0; j < k; ++j) {\n      a[i].insert(nxt() - 1);\n    }\n  }\n  int total = 0;\n  for (int i = 0; i < n; ++i) {\n    total += a[i].size();\n  }\n  vector<int> cnt(n);\n  for (int i = 0; i < n; ++i) {\n    cnt[i] = a[i].size();\n  }\n  vector<array<int, 3>> ans;\n  int mn = total / n;\n  int mx = (total + n - 1) / n;\n  {\n    set<int> mn_ids, mx_ids;\n    for (int i = 0; i < n; ++i) {\n      if (cnt[i] < mn) {\n        mn_ids.insert(i);\n      } else if (cnt[i] > mx) {\n        mx_ids.insert(i);\n      }\n    }\n    vector<vector<int>> avail(m);\n    for (int i : mx_ids) {\n      for (int j : a[i]) {\n        avail[j].push_back(i);\n      }\n    }\n    for (int i = 0; i < m; ++i) {\n      set<int>::iterator it = mn_ids.begin();\n      while (it != mn_ids.end() && a[*it].count(i)) {\n        ++it;\n      }\n      vector<int> to_del;\n      for (int j : avail[i]) {\n        if (it == mn_ids.end()) {\n          break;\n        }\n        if (cnt[j] <= mx) {\n          continue;\n        }\n        ans.push_back({j, *it, i});\n        --cnt[j];\n        ++cnt[*it];\n        a[j].erase(i);\n        a[*it].insert(i);\n        if (cnt[*it] >= mn) {\n          to_del.push_back(*it);\n        }\n        do {\n          ++it;\n        } while (it != mn_ids.end() && a[*it].count(i));\n      }\n      for (int x : to_del) {\n        mn_ids.erase(x);\n      }\n    }\n  }\n  mn = total / n;\n  mx = mn;\n  {\n    set<int> mn_ids, mx_ids;\n    for (int i = 0; i < n; ++i) {\n      if (cnt[i] < mn) {\n        mn_ids.insert(i);\n      } else if (cnt[i] > mx) {\n        mx_ids.insert(i);\n      }\n    }\n    vector<vector<int>> avail(m);\n    for (int i : mx_ids) {\n      for (int j : a[i]) {\n        avail[j].push_back(i);\n      }\n    }\n    for (int i = 0; i < m; ++i) {\n      set<int>::iterator it = mn_ids.begin();\n      while (it != mn_ids.end() && a[*it].count(i)) {\n        ++it;\n      }\n      vector<int> to_del;\n      for (int j : avail[i]) {\n        if (it == mn_ids.end()) {\n          break;\n        }\n        if (cnt[j] <= mx) {\n          continue;\n        }\n        ans.push_back({j, *it, i});\n        --cnt[j];\n        ++cnt[*it];\n        a[j].erase(i);\n        a[*it].insert(i);\n        if (cnt[*it] >= mn) {\n          to_del.push_back(*it);\n        }\n        do {\n          ++it;\n        } while (it != mn_ids.end() && a[*it].count(i));\n      }\n      for (int x : to_del) {\n        mn_ids.erase(x);\n      }\n    }\n  }\n  mn = (total + n - 1) / n;\n  mx = mn;\n  {\n    set<int> mn_ids, mx_ids;\n    for (int i = 0; i < n; ++i) {\n      if (cnt[i] < mn) {\n        mn_ids.insert(i);\n      } else if (cnt[i] > mx) {\n        mx_ids.insert(i);\n      }\n    }\n    vector<vector<int>> avail(m);\n    for (int i : mx_ids) {\n      for (int j : a[i]) {\n        avail[j].push_back(i);\n      }\n    }\n    for (int i = 0; i < m; ++i) {\n      set<int>::iterator it = mn_ids.begin();\n      while (it != mn_ids.end() && a[*it].count(i)) {\n        ++it;\n      }\n      vector<int> to_del;\n      for (int j : avail[i]) {\n        if (it == mn_ids.end()) {\n          break;\n        }\n        if (cnt[j] <= mx) {\n          continue;\n        }\n        ans.push_back({j, *it, i});\n        --cnt[j];\n        ++cnt[*it];\n        a[j].erase(i);\n        a[*it].insert(i);\n        if (cnt[*it] >= mn) {\n          to_del.push_back(*it);\n        }\n        do {\n          ++it;\n        } while (it != mn_ids.end() && a[*it].count(i));\n      }\n      for (int x : to_del) {\n        mn_ids.erase(x);\n      }\n    }\n  }\n  printf(\"%d\\n\", (int)ans.size());\n  for (auto& v : ans) {\n    for (int& x : v) {\n      printf(\"%d \", x + 1);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct tri {\n  int x, y, z;\n};\nint n, m;\npair<int, set<int>> a[100005];\nint t[100005];\nbool cmp(pair<int, set<int>> a, pair<int, set<int>> b) {\n  return a.second.size() < b.second.size();\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  cerr.tie(nullptr);\n  cin >> n >> m;\n  int z = 0;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    while (x--) {\n      int y;\n      cin >> y;\n      a[i].second.insert(y);\n      z++;\n    }\n    a[i].first = i;\n  }\n  sort(a + 1, a + n + 1, cmp);\n  for (int i = 1; i <= n; i++) {\n    t[i] = z / n;\n  }\n  for (int i = 1; i <= z % n; i++) t[n + 1 - i]++;\n  basic_string<int> poz, neg;\n  for (int i = 1; i <= n; i++) {\n    int raz = (int)a[i].second.size() - t[i];\n    if (raz > 0) {\n      poz += i;\n    } else if (raz < 0) {\n      neg += i;\n    }\n  }\n  basic_string<tri> sol;\n  int i = 0, j = 0;\n  while (i < (int)poz.size() && j < (int)neg.size()) {\n    int ii = neg[j];\n    int jj = poz[i];\n    int rupa = t[ii] - (int)a[ii].second.size();\n    int visak = (int)a[jj].second.size() - t[jj];\n    int selim = min(rupa, visak);\n    if (rupa < visak) {\n      basic_string<int> vrati;\n      for (int x : a[ii].second) {\n        if (a[jj].second.count(x)) {\n          a[jj].second.erase(x);\n          vrati += x;\n        }\n      }\n      while (selim) {\n        int x = *a[jj].second.begin();\n        a[jj].second.erase(x);\n        a[ii].second.insert(x);\n        selim--;\n        sol += {a[jj].first, a[ii].first, x};\n      }\n      for (int x : vrati) {\n        a[jj].second.insert(x);\n      }\n      j++;\n    } else {\n      vector<int> tmp(a[jj].second.begin(), a[jj].second.end());\n      for (int x : tmp) {\n        if (!a[ii].second.count(x) && selim > 0) {\n          selim--;\n          a[jj].second.erase(x);\n          a[ii].second.insert(x);\n          sol += {a[jj].first, a[ii].first, x};\n        }\n      }\n      i++;\n    }\n  }\n  cout << sol.size() << '\\n';\n  for (auto p : sol) {\n    cout << p.x << ' ' << p.y << ' ' << p.z << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, s;\nint cnt[20000005], nnode;\nint root[100005];\nint nxt[20000005][2];\nset<pair<int, int>> kids;\nvector<pair<pair<int, int>, int>> prints;\nvoid add(int id, int v, int ch) {\n  int cur = root[id];\n  cnt[cur] += ch;\n  for (int i = 16; i >= 0; --i) {\n    int bit = v >> i & 1;\n    if (!nxt[cur][bit]) nxt[cur][bit] = ++nnode;\n    cur = nxt[cur][bit];\n    cnt[cur] += ch;\n  }\n}\nvoid move(int fr, int to) {\n  int item = 0;\n  int u = root[fr], v = root[to];\n  for (int i = 16; i >= 0; --i) {\n    if (cnt[nxt[u][0]] > cnt[nxt[v][0]]) {\n      u = nxt[u][0];\n      v = nxt[v][0];\n    } else {\n      u = nxt[u][1];\n      v = nxt[v][1];\n      item += (1 << i);\n    }\n  }\n  prints.push_back({{fr, to}, item});\n  add(fr, item, -1);\n  add(to, item, 1);\n}\nint main(void) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) root[i] = i;\n  nnode = n;\n  for (int i = 1; i <= n; ++i) {\n    int sz;\n    cin >> sz;\n    s += sz;\n    kids.insert({sz, i});\n    while (sz--) {\n      int x;\n      cin >> x;\n      add(i, x, 1);\n    }\n  }\n  while (true) {\n    auto fr = *(--kids.end());\n    auto to = *(kids.begin());\n    if (fr.first - to.first <= 1) {\n      break;\n    }\n    move(fr.second, to.second);\n    kids.erase(fr);\n    kids.erase(to);\n    --fr.first;\n    ++to.first;\n    kids.insert(fr);\n    kids.insert(to);\n  }\n  cout << prints.size() << endl;\n  for (auto z : prints)\n    cout << z.first.first << ' ' << z.first.second << ' ' << z.second << '\\n';\n  return 0;\n}\n"
        }
    ]
}