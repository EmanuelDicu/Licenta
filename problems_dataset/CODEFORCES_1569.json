{
    "name": "1569_F. Palindromic Hamiltonian Path",
    "source": "CODEFORCES",
    "description": "You are given a simple undirected graph with n vertices, n is even. You are going to write a letter on each vertex. Each letter should be one of the first k letters of the Latin alphabet.\n\nA path in the graph is called Hamiltonian if it visits each vertex exactly once. A string is called palindromic if it reads the same from left to right and from right to left. A path in the graph is called palindromic if the letters on the vertices in it spell a palindromic string without changing the order.\n\nA string of length n is good if: \n\n  * each letter is one of the first k lowercase Latin letters; \n  * if you write the i-th letter of the string on the i-th vertex of the graph, there will exist a palindromic Hamiltonian path in the graph. \n\n\n\nNote that the path doesn't necesserily go through the vertices in order 1, 2, ..., n.\n\nCount the number of good strings.\n\nInput\n\nThe first line contains three integers n, m and k (2 \u2264 n \u2264 12; n is even; 0 \u2264 m \u2264 (n \u22c5 (n-1))/(2); 1 \u2264 k \u2264 12) \u2014 the number of vertices in the graph, the number of edges in the graph and the number of first letters of the Latin alphabet that can be used.\n\nEach of the next m lines contains two integers v and u (1 \u2264 v, u \u2264 n; v \u2260 u) \u2014 the edges of the graph. The graph doesn't contain multiple edges and self-loops.\n\nOutput\n\nPrint a single integer \u2014 number of good strings.\n\nExamples\n\nInput\n\n\n4 3 3\n1 2\n2 3\n3 4\n\n\nOutput\n\n\n9\n\n\nInput\n\n\n4 6 3\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n\n\nOutput\n\n\n21\n\n\nInput\n\n\n12 19 12\n1 3\n2 6\n3 6\n3 7\n4 8\n8 5\n8 7\n9 4\n5 9\n10 1\n10 4\n10 6\n9 10\n11 1\n5 11\n7 11\n12 2\n12 5\n12 11\n\n\nOutput\n\n\n456165084",
    "difficulty": "F",
    "tags": [
        "brute force",
        "dfs and similar",
        "dp",
        "graphs",
        "hashing"
    ],
    "rating": 3000,
    "public_test": [
        {
            "input": "4 6 3\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n",
            "output": "21\n"
        },
        {
            "input": "4 3 3\n1 2\n2 3\n3 4\n",
            "output": "9\n"
        },
        {
            "input": "12 19 12\n1 3\n2 6\n3 6\n3 7\n4 8\n8 5\n8 7\n9 4\n5 9\n10 1\n10 4\n10 6\n9 10\n11 1\n5 11\n7 11\n12 2\n12 5\n12 11\n",
            "output": "                                                       456165084"
        }
    ],
    "generated_test": [
        {
            "input": "8 6 3\n5 1\n5 4\n6 7\n4 3\n5 5\n3 2\n",
            "output": "0\n"
        },
        {
            "input": "8 26 3\n6 4\n2 8\n8 4\n4 4\n5 6\n5 2\n1 7\n8 1\n3 7\n4 1\n6 1\n5 4\n7 2\n4 7\n6 2\n7 8\n2 1\n5 3\n6 3\n1 3\n5 7\n7 6\n8 5\n2 3\n8 6\n4 2\n",
            "output": "1641\n"
        },
        {
            "input": "12 45 12\n1 2\n7 5\n5 4\n4 9\n1 12\n2 11\n6 11\n12 8\n10 5\n7 6\n6 3\n11 7\n9 8\n2 6\n12 5\n2 8\n4 3\n1 10\n7 3\n12 11\n3 10\n8 5\n9 6\n1 4\n10 12\n12 7\n1 7\n1 5\n5 3\n8 4\n11 1\n3 12\n10 11\n1 3\n10 4\n12 4\n10 2\n3 11\n6 12\n9 2\n2 5\n3 2\n6 1\n8 7\n8 1\n",
            "output": "12600272928\n"
        },
        {
            "input": "12 50 2\n3 7\n12 11\n12 1\n1 6\n10 5\n5 9\n4 11\n5 7\n3 1\n9 4\n6 9\n5 12\n8 4\n1 11\n12 6\n9 2\n6 2\n5 2\n4 7\n4 10\n11 9\n10 11\n7 12\n4 5\n9 10\n9 8\n11 7\n12 8\n2 8\n7 9\n8 1\n12 4\n2 11\n11 3\n6 7\n8 10\n2 7\n1 9\n3 4\n1 5\n10 2\n3 8\n6 3\n2 12\n10 1\n10 7\n8 6\n5 1\n2 4\n9 12\n",
            "output": "2048\n"
        },
        {
            "input": "6 10 2\n4 1\n4 5\n2 4\n2 1\n6 3\n2 3\n5 1\n5 2\n6 1\n6 2\n",
            "output": "32\n"
        },
        {
            "input": "8 28 12\n3 7\n3 8\n3 2\n2 6\n1 3\n7 6\n7 1\n2 8\n8 5\n5 3\n5 1\n4 1\n4 3\n8 4\n6 3\n2 1\n7 8\n6 5\n7 5\n2 4\n1 8\n4 7\n6 8\n2 4\n2 7\n5 2\n4 6\n1 6\n",
            "output": "1532928\n"
        },
        {
            "input": "12 63 12\n9 10\n3 12\n8 4\n5 2\n12 9\n8 3\n9 11\n11 3\n11 5\n1 10\n6 8\n12 4\n5 4\n6 4\n6 3\n1 8\n3 2\n8 2\n7 6\n9 1\n4 7\n1 6\n6 9\n10 3\n11 10\n5 8\n12 10\n9 8\n12 2\n5 1\n10 6\n8 7\n9 3\n7 10\n11 12\n1 2\n2 11\n2 6\n2 4\n9 5\n10 5\n2 4\n1 3\n12 6\n12 8\n7 11\n12 5\n2 7\n11 4\n2 10\n1 7\n7 3\n5 3\n9 7\n12 7\n1 4\n4 3\n4 10\n8 10\n12 1\n9 4\n8 11\n11 6\n",
            "output": "12665422848\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n2 4\n5 3\n4 5\n1 6\n6 4\n6 5\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n2 8\n3 8\n5 8\n8 6\n1 9\n3 9\n4 9\n9 5\n9 6\n8 9\n1 10\n10 2\n10 3\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n4 11\n3 11\n11 4\n5 11\n6 11\n9 11\n12 1\n2 12\n12 4\n5 12\n6 12\n7 12\n12 8\n9 12\n12 11\n",
            "output": "12662096448\n"
        },
        {
            "input": "6 14 4\n5 2\n6 5\n1 2\n4 1\n5 4\n4 3\n2 4\n1 5\n5 3\n1 6\n6 1\n1 3\n6 4\n3 2\n",
            "output": "544\n"
        },
        {
            "input": "10 36 2\n1 9\n3 5\n7 1\n10 1\n9 5\n10 2\n8 7\n9 3\n7 6\n10 4\n9 6\n8 4\n5 8\n2 8\n3 6\n1 5\n8 6\n6 2\n7 3\n2 4\n7 5\n1 2\n1 3\n10 5\n9 8\n5 6\n2 7\n4 9\n8 7\n8 10\n1 6\n7 10\n6 4\n1 4\n2 9\n7 9\n",
            "output": "512\n"
        },
        {
            "input": "12 59 5\n1 10\n9 4\n9 8\n9 1\n4 2\n8 10\n8 6\n3 8\n3 6\n10 6\n5 1\n9 3\n10 7\n4 1\n8 4\n6 11\n8 7\n4 11\n1 8\n8 5\n5 10\n9 6\n4 6\n1 2\n5 11\n9 11\n7 11\n7 12\n11 8\n5 3\n11 3\n12 4\n1 11\n11 12\n7 5\n1 6\n6 5\n2 7\n9 5\n12 8\n4 3\n4 5\n7 2\n12 6\n10 4\n9 7\n12 2\n2 9\n3 10\n6 7\n7 4\n12 1\n2 3\n12 3\n2 10\n2 5\n9 12\n10 9\n6 2\n",
            "output": "15424865\n"
        },
        {
            "input": "8 7 12\n4 1\n4 3\n2 5\n1 6\n7 2\n7 3\n8 6\n",
            "output": "20736\n"
        },
        {
            "input": "12 47 12\n1 10\n5 3\n3 6\n1 12\n5 11\n1 3\n9 12\n12 7\n12 3\n1 8\n9 7\n10 6\n10 12\n5 1\n8 6\n3 9\n5 9\n12 6\n11 8\n3 10\n7 1\n11 6\n8 7\n1 9\n8 6\n7 11\n9 10\n7 2\n9 11\n11 3\n11 1\n12 5\n6 7\n3 7\n8 3\n5 6\n1 6\n7 10\n9 8\n12 11\n6 9\n10 5\n4 1\n8 12\n10 8\n10 11\n7 5\n",
            "output": "220741632\n"
        },
        {
            "input": "12 35 12\n2 9\n2 10\n2 11\n3 12\n8 10\n5 4\n2 4\n8 3\n11 10\n10 5\n11 5\n4 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n2 8\n3 10\n7 3\n6 7\n2 5\n10 4\n8 11\n9 7\n4 11\n2 7\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "138246912\n"
        },
        {
            "input": "12 34 12\n3 2\n2 4\n5 3\n5 3\n4 5\n6 2\n3 6\n5 6\n7 1\n4 7\n5 7\n8 1\n8 4\n8 5\n9 1\n2 9\n4 9\n9 5\n2 10\n3 10\n4 10\n10 6\n10 7\n10 8\n11 3\n6 11\n11 7\n8 11\n9 11\n12 1\n4 12\n6 12\n10 12\n12 11\n",
            "output": "9935910876\n"
        },
        {
            "input": "12 40 12\n3 2\n4 1\n4 2\n3 4\n5 1\n3 5\n6 1\n3 6\n6 4\n7 3\n4 7\n5 7\n6 7\n8 3\n3 8\n4 8\n8 5\n8 7\n1 9\n9 2\n5 9\n7 9\n9 8\n1 10\n10 4\n7 10\n10 9\n11 1\n11 2\n6 11\n11 7\n11 8\n9 11\n10 11\n1 12\n3 12\n5 12\n12 6\n12 8\n12 10\n",
            "output": "12438633648\n"
        },
        {
            "input": "12 35 12\n7 4\n8 11\n8 4\n8 6\n5 12\n9 10\n5 10\n2 8\n8 7\n8 9\n7 5\n5 8\n11 1\n3 7\n3 11\n3 5\n9 7\n10 8\n3 6\n7 10\n1 8\n11 4\n3 1\n6 10\n10 11\n10 1\n11 9\n9 7\n5 4\n8 3\n6 11\n6 5\n6 4\n5 1\n9 3\n",
            "output": "187287552\n"
        },
        {
            "input": "12 39 12\n6 11\n10 6\n3 5\n4 11\n8 10\n7 9\n10 2\n7 11\n9 4\n7 4\n9 10\n8 12\n10 11\n5 12\n11 9\n2 1\n6 9\n3 4\n3 1\n2 11\n4 1\n7 5\n8 2\n12 4\n11 5\n6 4\n1 7\n5 9\n9 1\n6 1\n3 9\n2 12\n1 10\n4 2\n3 2\n6 5\n6 12\n8 5\n6 8\n",
            "output": "12334160928\n"
        },
        {
            "input": "12 26 12\n1 2\n1 8\n3 4\n5 1\n6 3\n6 5\n3 7\n5 7\n8 2\n8 4\n9 2\n3 9\n9 6\n9 7\n10 4\n5 10\n10 8\n10 9\n3 11\n11 5\n7 11\n10 11\n1 12\n12 2\n12 6\n12 8\n",
            "output": "3850238448\n"
        },
        {
            "input": "12 38 12\n2 1\n3 2\n4 2\n5 2\n5 3\n6 1\n2 6\n6 3\n6 4\n6 5\n1 7\n3 7\n1 8\n3 8\n4 8\n8 6\n7 8\n3 9\n9 4\n9 5\n7 9\n1 10\n4 10\n5 10\n10 7\n9 10\n11 1\n11 2\n2 4\n11 7\n9 11\n11 10\n12 2\n12 4\n5 12\n7 12\n8 12\n10 12\n",
            "output": "12309866328\n"
        },
        {
            "input": "12 20 12\n3 2\n4 3\n4 5\n6 2\n6 5\n1 7\n8 1\n8 6\n9 1\n3 9\n2 4\n5 10\n9 10\n11 4\n11 6\n11 7\n8 11\n1 12\n12 8\n10 12\n",
            "output": "543168264\n"
        },
        {
            "input": "12 37 12\n1 2\n3 1\n4 1\n2 4\n3 4\n5 3\n6 1\n6 2\n6 3\n6 5\n1 7\n7 4\n7 5\n2 8\n3 8\n8 6\n1 9\n3 9\n7 9\n8 9\n1 10\n10 2\n4 10\n5 10\n10 7\n9 10\n3 11\n11 4\n5 11\n8 11\n1 11\n12 3\n12 4\n5 12\n7 12\n12 10\n12 11\n",
            "output": "12000796248\n"
        },
        {
            "input": "12 34 12\n1 3\n3 2\n1 5\n4 2\n2 5\n4 5\n6 1\n6 3\n6 5\n1 7\n7 2\n7 5\n1 8\n8 2\n3 8\n8 4\n8 5\n7 8\n9 2\n9 4\n9 6\n10 1\n10 4\n6 10\n7 10\n11 2\n11 3\n5 11\n9 11\n12 3\n6 12\n7 12\n12 9\n11 12\n",
            "output": "11098251528\n"
        },
        {
            "input": "12 21 12\n4 3\n5 2\n5 3\n5 6\n1 7\n6 7\n5 8\n6 8\n7 8\n4 9\n1 10\n10 2\n10 4\n9 10\n11 1\n11 8\n11 9\n12 2\n12 3\n12 5\n6 12\n",
            "output": "841149552\n"
        },
        {
            "input": "12 42 12\n2 1\n1 3\n2 4\n4 3\n5 1\n3 5\n1 6\n6 2\n6 3\n5 6\n2 11\n7 3\n4 7\n7 6\n8 4\n5 8\n7 8\n2 9\n5 9\n6 9\n9 7\n9 8\n10 1\n10 2\n3 10\n4 10\n10 5\n10 7\n10 8\n11 2\n11 4\n5 11\n6 11\n11 9\n12 1\n12 2\n5 12\n6 12\n12 7\n12 8\n10 12\n12 11\n",
            "output": "12601734168\n"
        },
        {
            "input": "12 33 12\n4 1\n2 4\n4 3\n1 5\n5 3\n4 5\n1 6\n5 6\n7 1\n3 7\n7 4\n8 4\n6 8\n7 8\n9 1\n2 9\n9 3\n9 5\n10 1\n10 2\n8 10\n11 1\n2 11\n11 5\n6 11\n7 11\n9 11\n11 10\n12 2\n12 3\n12 4\n12 6\n12 10\n",
            "output": "10425535968\n"
        },
        {
            "input": "12 34 12\n1 3\n2 3\n1 4\n3 4\n5 3\n5 4\n6 2\n3 6\n7 5\n7 6\n3 8\n4 8\n7 8\n1 9\n9 4\n9 5\n6 9\n7 9\n9 8\n4 10\n10 6\n7 10\n8 10\n11 1\n11 2\n11 5\n11 6\n11 8\n12 1\n9 2\n12 7\n12 8\n12 9\n10 12\n",
            "output": "10589548608\n"
        },
        {
            "input": "12 34 12\n2 1\n3 1\n3 2\n4 1\n4 2\n5 4\n6 1\n6 4\n6 5\n7 2\n3 7\n1 8\n2 8\n8 4\n8 5\n1 9\n4 9\n9 6\n7 9\n3 10\n10 6\n7 10\n8 10\n10 9\n5 11\n6 11\n11 8\n2 12\n3 12\n12 5\n12 7\n12 9\n12 10\n12 11\n",
            "output": "10847414568\n"
        },
        {
            "input": "4 6 3\n1 2\n1 3\n1 4\n2 3\n1 4\n3 4\n",
            "output": "21\n"
        },
        {
            "input": "6 10 2\n4 1\n4 5\n2 4\n2 1\n6 3\n2 3\n5 1\n5 4\n6 1\n6 2\n",
            "output": "28\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n2 4\n5 3\n4 5\n1 6\n6 4\n6 5\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n2 8\n3 8\n5 8\n8 6\n1 9\n3 9\n4 9\n9 5\n9 6\n8 9\n1 10\n10 2\n10 4\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n4 11\n3 11\n11 4\n5 11\n6 11\n9 11\n12 1\n2 12\n12 4\n5 12\n6 12\n7 12\n12 8\n9 12\n12 11\n",
            "output": "12662761728\n"
        },
        {
            "input": "12 50 12\n2 1\n3 1\n3 2\n4 1\n4 2\n1 5\n5 3\n1 6\n2 6\n6 3\n6 5\n2 7\n3 7\n7 4\n7 5\n1 8\n2 8\n5 8\n8 6\n7 8\n9 1\n2 9\n3 9\n4 9\n9 5\n9 7\n3 9\n1 10\n2 10\n10 3\n4 10\n5 10\n7 10\n10 8\n10 9\n11 1\n2 11\n11 3\n11 4\n11 6\n9 11\n10 11\n1 12\n12 2\n12 4\n12 5\n6 12\n7 12\n12 10\n11 12\n",
            "output": "12664757568\n"
        },
        {
            "input": "12 48 12\n4 1\n4 3\n1 5\n5 3\n4 5\n6 1\n2 6\n6 3\n6 4\n5 6\n7 1\n7 2\n3 7\n7 4\n6 7\n1 8\n8 2\n4 8\n8 5\n8 6\n1 9\n9 2\n4 9\n9 6\n9 8\n10 1\n2 10\n3 10\n4 10\n10 5\n10 7\n10 8\n1 11\n11 3\n11 4\n11 9\n7 11\n11 9\n10 11\n12 2\n12 3\n4 12\n12 5\n12 6\n6 12\n12 8\n9 12\n11 12\n",
            "output": "12660100608\n"
        },
        {
            "input": "12 40 12\n3 2\n4 1\n4 2\n3 4\n5 1\n3 5\n6 1\n3 6\n6 4\n7 3\n4 7\n5 7\n6 7\n8 3\n3 8\n4 8\n8 5\n8 7\n1 9\n9 2\n5 9\n7 9\n9 8\n1 10\n10 4\n7 10\n10 9\n11 1\n11 2\n6 11\n11 7\n11 8\n9 11\n10 11\n1 3\n3 12\n5 12\n12 6\n12 8\n12 10\n",
            "output": "12370904448\n"
        },
        {
            "input": "12 35 12\n7 4\n8 11\n8 4\n8 6\n5 12\n9 10\n5 10\n2 8\n8 7\n8 9\n7 5\n5 8\n11 1\n3 7\n3 11\n3 5\n9 7\n10 8\n3 6\n6 10\n1 8\n11 4\n3 1\n6 10\n10 11\n10 1\n11 9\n9 7\n5 4\n8 3\n6 11\n6 5\n6 4\n5 1\n9 3\n",
            "output": "168279552\n"
        },
        {
            "input": "12 26 12\n1 2\n1 8\n3 4\n5 1\n2 3\n6 5\n3 7\n5 7\n8 2\n8 4\n9 2\n3 9\n9 6\n9 7\n10 4\n5 10\n10 8\n10 9\n3 11\n11 5\n7 11\n10 11\n1 12\n12 2\n12 6\n12 8\n",
            "output": "3576773916\n"
        },
        {
            "input": "12 38 12\n2 1\n3 2\n4 2\n5 2\n5 3\n6 1\n2 6\n6 3\n6 4\n6 5\n1 7\n3 10\n1 8\n3 8\n4 8\n8 6\n7 8\n3 9\n9 4\n9 5\n7 9\n1 10\n4 10\n5 10\n10 7\n9 10\n11 1\n11 2\n2 4\n11 7\n9 11\n11 10\n12 2\n12 4\n5 12\n7 12\n8 12\n10 12\n",
            "output": "12224128368\n"
        },
        {
            "input": "12 37 12\n1 2\n3 1\n4 1\n2 4\n3 4\n5 3\n6 1\n6 2\n6 3\n6 5\n1 7\n7 4\n7 5\n2 8\n3 8\n8 6\n1 9\n3 9\n7 9\n8 9\n1 10\n10 2\n4 10\n5 10\n10 7\n9 10\n3 11\n11 4\n5 11\n8 11\n1 10\n12 3\n12 4\n5 12\n7 12\n12 10\n12 11\n",
            "output": "11720689608\n"
        },
        {
            "input": "12 42 12\n2 1\n1 3\n2 4\n4 3\n5 1\n3 5\n1 6\n6 2\n6 3\n5 6\n2 11\n7 3\n4 7\n7 6\n8 4\n5 8\n7 8\n2 9\n5 9\n6 9\n9 7\n9 8\n10 1\n10 2\n3 10\n4 10\n10 5\n10 7\n10 8\n11 2\n11 4\n5 11\n6 11\n11 9\n12 1\n12 2\n5 12\n7 12\n12 7\n12 8\n10 12\n12 11\n",
            "output": "12563623128\n"
        },
        {
            "input": "12 34 12\n2 1\n3 1\n3 2\n4 1\n4 2\n5 4\n6 1\n6 4\n6 5\n7 2\n3 7\n1 8\n2 8\n8 4\n8 5\n1 9\n4 9\n9 6\n7 9\n3 10\n10 6\n7 10\n8 10\n10 9\n5 3\n6 11\n11 8\n2 12\n3 12\n12 5\n12 7\n12 9\n12 10\n12 11\n",
            "output": "10413745596\n"
        },
        {
            "input": "6 10 2\n4 1\n4 5\n2 4\n2 1\n6 4\n2 3\n5 1\n5 4\n6 1\n6 2\n",
            "output": "24\n"
        },
        {
            "input": "12 40 12\n3 2\n4 1\n4 2\n3 4\n5 1\n3 5\n6 1\n3 5\n6 4\n7 3\n4 7\n5 7\n6 7\n8 3\n3 8\n4 8\n8 5\n8 7\n1 9\n9 2\n5 9\n7 9\n9 8\n1 10\n10 4\n7 10\n10 9\n11 1\n11 2\n6 11\n11 7\n11 8\n9 11\n10 11\n1 3\n3 12\n5 12\n12 6\n12 8\n12 10\n",
            "output": "12171187128\n"
        },
        {
            "input": "12 35 12\n7 4\n8 11\n8 4\n8 6\n5 12\n9 10\n5 10\n2 8\n8 7\n8 9\n7 5\n5 8\n11 1\n6 7\n3 11\n3 5\n9 7\n10 8\n3 6\n6 10\n1 8\n11 4\n3 1\n6 10\n10 11\n10 1\n11 9\n9 7\n5 4\n8 3\n6 11\n6 5\n6 4\n5 1\n9 3\n",
            "output": "163907712\n"
        },
        {
            "input": "12 26 12\n1 2\n1 8\n2 4\n5 1\n2 3\n6 5\n3 7\n5 7\n8 2\n8 4\n9 2\n3 9\n9 6\n9 7\n10 4\n5 10\n10 8\n10 9\n3 11\n11 5\n7 11\n10 11\n1 12\n12 2\n12 6\n12 8\n",
            "output": "3353633196\n"
        },
        {
            "input": "12 38 12\n2 1\n3 2\n4 2\n5 2\n5 3\n6 1\n2 6\n6 3\n6 4\n6 5\n1 7\n3 10\n1 8\n3 8\n4 8\n2 6\n7 8\n3 9\n9 4\n9 5\n7 9\n1 10\n4 10\n5 10\n10 7\n9 10\n11 1\n11 2\n2 4\n11 7\n9 11\n11 10\n12 2\n12 4\n5 12\n7 12\n8 12\n10 12\n",
            "output": "11880688128\n"
        },
        {
            "input": "12 37 12\n1 2\n3 1\n4 1\n2 4\n3 4\n5 3\n6 1\n6 2\n6 3\n6 5\n1 7\n7 4\n7 5\n2 8\n3 8\n8 6\n1 9\n3 9\n7 9\n8 10\n1 10\n10 2\n4 10\n5 10\n10 7\n9 10\n3 11\n11 4\n5 11\n8 11\n1 10\n12 3\n12 4\n5 12\n7 12\n12 10\n12 11\n",
            "output": "11380897848\n"
        },
        {
            "input": "12 34 12\n2 1\n3 1\n3 2\n4 1\n4 2\n5 4\n6 1\n6 4\n6 5\n7 2\n3 7\n1 8\n2 8\n8 4\n8 5\n1 9\n4 9\n9 6\n7 9\n3 10\n10 6\n7 10\n8 10\n10 9\n5 3\n6 11\n11 8\n2 12\n3 12\n12 5\n12 7\n12 9\n12 10\n4 11\n",
            "output": "10355631408\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n3 4\n5 3\n4 5\n1 6\n6 4\n6 5\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n2 8\n3 8\n5 8\n8 6\n1 9\n4 9\n4 9\n9 5\n9 6\n8 9\n1 10\n10 2\n10 4\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n4 11\n3 11\n11 4\n5 11\n6 11\n9 11\n12 1\n2 12\n12 4\n5 12\n6 12\n7 12\n12 8\n9 12\n12 11\n",
            "output": "12657914688\n"
        },
        {
            "input": "12 48 12\n4 1\n4 3\n1 5\n5 3\n4 5\n6 1\n2 6\n6 3\n6 4\n5 6\n7 1\n7 2\n3 7\n7 4\n6 7\n1 8\n8 2\n4 8\n8 5\n8 6\n1 9\n9 2\n4 9\n9 6\n9 8\n10 1\n2 10\n3 10\n4 10\n10 5\n10 7\n10 8\n1 11\n11 1\n11 5\n11 9\n7 11\n11 9\n10 11\n12 2\n12 3\n4 12\n12 5\n12 6\n6 12\n12 8\n9 12\n11 12\n",
            "output": "12659435328\n"
        },
        {
            "input": "12 35 7\n2 9\n2 10\n2 11\n3 12\n2 10\n5 4\n2 4\n8 3\n11 10\n10 5\n11 5\n4 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n2 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n9 7\n4 11\n2 7\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "4513537\n"
        },
        {
            "input": "12 26 12\n1 2\n1 8\n2 4\n5 1\n2 3\n6 5\n3 7\n5 7\n8 2\n8 4\n9 2\n3 9\n9 11\n9 7\n10 4\n5 10\n10 8\n10 9\n3 11\n11 5\n7 11\n10 11\n1 12\n12 2\n12 6\n12 8\n",
            "output": "2520531828\n"
        },
        {
            "input": "12 37 12\n1 2\n3 1\n4 1\n2 4\n3 4\n5 3\n6 1\n6 2\n6 3\n6 5\n1 7\n7 4\n7 5\n2 8\n3 8\n8 6\n1 9\n3 9\n7 9\n8 10\n1 10\n10 2\n4 10\n5 10\n10 7\n9 10\n3 11\n11 4\n5 11\n8 11\n1 10\n12 3\n12 4\n4 12\n7 12\n12 10\n12 11\n",
            "output": "10707396888\n"
        },
        {
            "input": "12 34 12\n2 1\n3 1\n3 2\n4 1\n4 2\n5 4\n6 1\n6 4\n6 5\n7 2\n3 7\n1 8\n2 8\n8 4\n8 5\n1 9\n4 9\n9 6\n7 9\n3 10\n10 6\n7 10\n8 10\n10 9\n5 3\n6 11\n11 8\n2 12\n3 12\n12 5\n12 11\n12 9\n12 10\n4 11\n",
            "output": "10857387168\n"
        },
        {
            "input": "12 30 2\n6 4\n1 2\n5 2\n2 9\n5 3\n8 11\n10 3\n3 1\n12 2\n8 9\n5 3\n1 12\n10 4\n1 9\n8 2\n2 6\n8 11\n5 6\n7 2\n1 4\n10 3\n6 1\n11 4\n9 12\n1 11\n1 7\n7 9\n3 12\n4 2\n5 4\n",
            "output": "2038\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n3 4\n5 3\n4 5\n1 6\n6 4\n6 10\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n2 8\n3 8\n5 8\n8 6\n1 9\n4 9\n4 9\n9 5\n9 6\n8 9\n1 10\n10 2\n10 4\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n4 11\n3 11\n11 4\n5 11\n6 11\n9 11\n12 1\n2 12\n12 4\n5 12\n6 12\n7 12\n12 8\n9 12\n12 11\n",
            "output": "12655253568\n"
        },
        {
            "input": "12 35 7\n2 9\n2 10\n2 11\n3 12\n2 10\n5 4\n2 4\n8 3\n11 10\n10 5\n11 5\n4 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n2 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n9 7\n4 11\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "3778831\n"
        },
        {
            "input": "12 26 12\n1 2\n1 8\n2 4\n5 1\n2 3\n6 5\n3 7\n5 8\n8 2\n8 4\n9 2\n3 9\n9 11\n9 7\n10 4\n5 10\n10 8\n10 9\n3 11\n11 5\n7 11\n10 11\n1 12\n12 2\n12 6\n12 8\n",
            "output": "2046033804\n"
        },
        {
            "input": "12 37 12\n1 2\n3 1\n4 1\n2 4\n3 4\n5 3\n6 1\n6 2\n6 3\n6 5\n1 7\n7 4\n7 5\n2 8\n3 8\n8 6\n1 9\n3 9\n7 9\n8 10\n1 10\n3 2\n4 10\n5 10\n10 7\n9 10\n3 11\n11 4\n5 11\n8 11\n1 10\n12 3\n12 4\n4 12\n7 12\n12 10\n12 11\n",
            "output": "10460979288\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n3 4\n5 3\n4 5\n1 6\n6 4\n6 10\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n2 8\n3 8\n5 8\n8 6\n1 9\n4 9\n4 9\n9 5\n12 6\n8 9\n1 10\n10 2\n10 4\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n4 11\n3 11\n11 4\n5 11\n6 11\n9 11\n12 1\n2 12\n12 4\n5 12\n6 12\n7 12\n12 8\n9 12\n12 11\n",
            "output": "12654588288\n"
        },
        {
            "input": "12 35 7\n2 9\n2 10\n2 11\n3 12\n2 10\n5 4\n2 4\n8 3\n11 10\n10 5\n11 5\n4 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n2 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n9 7\n4 7\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "4511479\n"
        },
        {
            "input": "12 26 12\n1 2\n1 8\n2 4\n5 1\n1 3\n6 5\n3 7\n5 8\n8 2\n8 4\n9 2\n3 9\n9 11\n9 7\n10 4\n5 10\n10 8\n10 9\n3 11\n11 5\n7 11\n10 11\n1 12\n12 2\n12 6\n12 8\n",
            "output": "2584436988\n"
        },
        {
            "input": "12 37 12\n1 2\n3 1\n4 1\n2 4\n3 4\n5 3\n6 1\n6 2\n6 3\n7 5\n1 7\n7 4\n7 5\n2 8\n3 8\n8 6\n1 9\n3 9\n7 9\n8 10\n1 10\n3 2\n4 10\n5 10\n10 7\n9 10\n3 11\n11 4\n5 11\n8 11\n1 10\n12 3\n12 4\n4 12\n7 12\n12 10\n12 11\n",
            "output": "8972926128\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n3 4\n5 3\n4 5\n1 6\n6 4\n6 10\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n2 8\n3 8\n5 8\n8 6\n1 9\n4 9\n4 9\n9 5\n12 6\n8 9\n1 10\n10 2\n10 4\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n4 11\n3 11\n11 4\n5 11\n6 11\n9 11\n12 1\n2 12\n12 8\n5 12\n6 12\n7 12\n12 8\n9 12\n12 11\n",
            "output": "12647935488\n"
        },
        {
            "input": "12 26 12\n1 2\n1 8\n2 4\n5 1\n1 3\n6 5\n3 7\n5 8\n8 2\n8 4\n9 2\n3 9\n9 11\n9 7\n10 4\n5 10\n10 8\n10 9\n2 11\n11 5\n7 11\n10 11\n1 12\n12 2\n12 6\n12 8\n",
            "output": "2523859416\n"
        },
        {
            "input": "12 37 12\n1 2\n3 1\n4 1\n2 4\n3 4\n5 3\n12 1\n6 2\n6 3\n7 5\n1 7\n7 4\n7 5\n2 8\n3 8\n8 6\n1 9\n3 9\n7 9\n8 10\n1 10\n3 2\n4 10\n5 10\n10 7\n9 10\n3 11\n11 4\n5 11\n8 11\n1 10\n12 3\n12 4\n4 12\n7 12\n12 10\n12 11\n",
            "output": "8485060728\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n3 7\n5 3\n4 5\n1 6\n6 4\n6 10\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n2 8\n3 8\n5 8\n8 6\n1 9\n4 9\n4 9\n9 5\n12 6\n8 9\n1 10\n10 2\n10 4\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n4 11\n3 11\n11 4\n5 11\n6 11\n9 11\n12 1\n2 12\n12 8\n5 12\n6 12\n7 12\n12 8\n9 12\n12 11\n",
            "output": "12634915008\n"
        },
        {
            "input": "12 35 7\n2 9\n2 10\n2 11\n3 12\n2 5\n5 4\n2 4\n8 3\n11 10\n10 5\n11 5\n4 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n2 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n5 7\n4 7\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "4287157\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n3 7\n5 3\n4 5\n1 6\n6 4\n6 10\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n2 8\n3 8\n5 8\n8 6\n1 9\n4 9\n4 9\n9 5\n12 6\n8 9\n1 10\n10 2\n10 4\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n4 11\n3 11\n11 4\n5 11\n6 11\n9 5\n12 1\n2 12\n12 8\n5 12\n6 12\n7 12\n12 8\n9 12\n12 11\n",
            "output": "12621799488\n"
        },
        {
            "input": "12 35 7\n2 9\n2 10\n2 11\n3 12\n2 5\n5 4\n2 4\n8 3\n11 10\n10 5\n11 5\n4 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n5 7\n4 7\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "3317839\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n3 7\n5 3\n4 5\n1 6\n6 4\n6 10\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n2 8\n3 8\n5 8\n8 6\n1 9\n4 9\n4 9\n9 5\n12 6\n8 9\n1 10\n10 2\n10 4\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n4 11\n1 11\n11 4\n5 11\n6 11\n9 5\n12 1\n2 12\n12 8\n5 12\n6 12\n7 12\n12 1\n9 12\n12 11\n",
            "output": "12547086168\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n3 7\n5 3\n4 5\n1 6\n6 4\n6 10\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n4 8\n3 8\n5 8\n8 6\n1 9\n4 9\n4 9\n9 5\n12 6\n8 9\n1 10\n10 2\n10 4\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n4 11\n1 11\n11 4\n5 11\n6 11\n9 5\n12 1\n2 12\n12 8\n5 12\n6 12\n7 12\n12 1\n9 12\n12 11\n",
            "output": "12429901848\n"
        },
        {
            "input": "10 45 12\n3 4\n3 2\n10 6\n1 9\n9 5\n1 5\n3 6\n4 10\n2 7\n7 9\n2 2\n8 7\n1 10\n8 1\n3 1\n3 8\n10 2\n4 7\n10 5\n6 1\n2 4\n3 5\n6 8\n6 5\n6 4\n4 8\n2 1\n4 1\n5 7\n5 4\n6 2\n7 1\n9 3\n7 6\n2 5\n9 6\n7 3\n9 2\n9 8\n7 10\n4 9\n10 9\n8 10\n8 5\n10 3\n",
            "output": "130179072\n"
        },
        {
            "input": "6 5 6\n2 6\n2 1\n4 5\n3 1\n5 3\n",
            "output": "216\n"
        },
        {
            "input": "8 9 3\n2 3\n5 1\n6 1\n8 4\n4 7\n2 7\n5 8\n4 6\n2 1\n",
            "output": "153\n"
        },
        {
            "input": "10 28 3\n6 2\n7 6\n10 2\n3 9\n7 1\n8 2\n6 9\n5 1\n4 9\n2 7\n3 10\n10 9\n7 9\n5 10\n4 3\n8 3\n1 9\n9 5\n2 4\n8 10\n7 8\n7 5\n10 4\n6 4\n1 4\n4 7\n2 9\n2 1\n",
            "output": "14751\n"
        },
        {
            "input": "6 9 4\n2 6\n3 6\n3 4\n1 3\n5 3\n4 5\n1 4\n1 4\n3 2\n",
            "output": "196\n"
        },
        {
            "input": "6 13 3\n3 2\n6 1\n5 3\n4 3\n1 2\n1 4\n3 2\n5 6\n3 6\n5 4\n1 3\n4 6\n1 5\n",
            "output": "183\n"
        },
        {
            "input": "6 15 12\n5 1\n1 3\n1 6\n1 2\n6 2\n3 4\n4 6\n4 1\n5 3\n2 6\n6 5\n4 5\n3 6\n5 2\n3 2\n",
            "output": "21792\n"
        },
        {
            "input": "12 35 3\n8 12\n10 4\n7 11\n1 5\n6 1\n9 7\n3 6\n9 4\n12 2\n10 4\n9 8\n2 3\n8 4\n1 7\n3 9\n11 5\n6 11\n4 12\n2 9\n3 8\n2 1\n11 1\n7 2\n11 10\n2 11\n3 7\n6 12\n4 3\n6 10\n8 11\n6 2\n7 4\n2 8\n12 11\n8 10\n",
            "output": "131079\n"
        },
        {
            "input": "12 35 12\n2 9\n2 10\n2 11\n3 12\n8 10\n5 4\n2 4\n8 3\n11 10\n10 5\n11 5\n4 8\n4 3\n6 11\n11 9\n10 12\n9 8\n9 3\n7 10\n2 8\n3 10\n7 3\n6 7\n2 5\n10 4\n8 11\n9 7\n4 11\n2 7\n9 10\n6 10\n3 11\n10 1\n2 3\n6 3\n",
            "output": "587158716\n"
        },
        {
            "input": "12 46 12\n10 2\n10 5\n6 1\n1 4\n2 11\n12 9\n10 11\n2 7\n12 6\n2 6\n8 9\n3 11\n4 2\n9 1\n6 5\n4 12\n7 11\n7 6\n4 5\n6 11\n2 9\n12 7\n1 12\n1 5\n11 1\n6 10\n7 8\n4 6\n7 1\n12 11\n1 2\n2 12\n7 4\n9 6\n10 12\n7 9\n9 5\n4 9\n11 4\n7 5\n5 2\n5 12\n11 5\n9 10\n11 9\n1 10\n",
            "output": "6969619680\n"
        },
        {
            "input": "12 11 12\n3 4\n5 2\n4 6\n1 7\n7 8\n9 8\n6 10\n11 1\n2 11\n12 3\n5 12\n",
            "output": "2985984\n"
        },
        {
            "input": "12 39 12\n6 11\n10 6\n3 5\n4 11\n8 10\n7 9\n10 2\n7 11\n9 4\n7 4\n9 10\n8 12\n10 11\n5 12\n11 9\n2 1\n6 9\n3 4\n3 1\n2 11\n4 1\n7 5\n8 2\n12 4\n11 5\n6 4\n1 7\n5 9\n9 1\n6 1\n3 9\n1 12\n1 10\n4 2\n3 2\n6 5\n6 12\n8 5\n6 8\n",
            "output": "12300124728\n"
        },
        {
            "input": "12 26 12\n1 2\n1 4\n3 4\n5 1\n6 3\n6 5\n3 7\n5 7\n8 2\n8 4\n9 2\n3 9\n9 6\n9 7\n10 6\n5 10\n10 8\n10 9\n3 11\n11 5\n7 11\n10 11\n1 12\n12 2\n12 6\n12 8\n",
            "output": "4300866516\n"
        },
        {
            "input": "12 0 3\n",
            "output": "0\n"
        },
        {
            "input": "12 62 2\n1 5\n8 10\n9 10\n7 6\n9 12\n3 1\n12 1\n2 10\n9 9\n2 11\n2 5\n10 4\n4 2\n12 11\n7 8\n4 12\n12 3\n7 11\n10 3\n8 3\n2 8\n1 4\n3 2\n7 12\n10 1\n4 8\n1 6\n10 12\n3 5\n1 2\n6 11\n5 12\n5 9\n2 6\n5 4\n12 2\n3 7\n1 8\n11 5\n2 9\n11 10\n7 4\n8 5\n7 2\n9 1\n8 9\n9 4\n6 4\n6 12\n3 11\n11 4\n6 8\n9 11\n3 6\n8 11\n12 8\n6 5\n10 5\n5 7\n7 10\n7 1\n3 4\n",
            "output": "2048\n"
        },
        {
            "input": "6 5 3\n2 6\n2 2\n4 5\n3 1\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 56 12\n1 2\n3 1\n3 2\n2 4\n4 3\n5 1\n5 2\n3 5\n1 6\n3 6\n4 6\n6 5\n7 1\n2 7\n7 3\n4 7\n7 5\n7 6\n1 8\n2 8\n8 3\n4 8\n5 8\n6 8\n9 1\n9 2\n3 9\n5 9\n6 9\n7 9\n9 8\n10 1\n2 10\n3 10\n10 4\n10 5\n10 7\n8 10\n10 9\n1 12\n11 2\n3 11\n11 4\n5 11\n7 11\n8 11\n9 11\n12 1\n12 4\n12 5\n6 12\n7 12\n8 12\n12 9\n10 12\n11 12\n",
            "output": "12665422848\n"
        },
        {
            "input": "8 24 3\n6 4\n5 1\n8 5\n7 6\n5 8\n7 3\n8 2\n2 3\n2 7\n6 2\n6 3\n8 3\n1 2\n8 7\n3 1\n1 6\n3 5\n1 7\n2 4\n4 8\n8 1\n2 5\n4 1\n4 3\n",
            "output": "1641\n"
        },
        {
            "input": "12 58 2\n11 6\n10 1\n2 12\n5 1\n11 1\n11 9\n1 4\n6 7\n8 11\n6 12\n11 10\n8 2\n3 11\n10 7\n8 12\n11 7\n10 5\n3 1\n12 9\n3 6\n10 12\n1 12\n2 4\n10 4\n3 9\n3 2\n2 6\n7 2\n7 9\n12 10\n3 8\n5 9\n9 2\n8 9\n1 2\n11 12\n1 9\n4 8\n3 10\n12 4\n5 11\n9 6\n10 2\n3 5\n6 1\n6 8\n5 4\n10 8\n3 7\n4 3\n7 8\n2 11\n12 7\n7 4\n12 5\n5 2\n6 5\n9 10\n",
            "output": "2048\n"
        },
        {
            "input": "12 55 12\n1 3\n2 3\n4 1\n2 4\n4 3\n1 5\n2 5\n5 3\n6 1\n6 2\n6 3\n4 6\n7 1\n2 7\n7 4\n5 7\n1 8\n8 2\n8 3\n8 5\n8 6\n8 7\n9 1\n2 9\n9 3\n4 9\n5 9\n7 9\n9 8\n1 10\n10 2\n3 10\n4 10\n10 6\n10 7\n10 8\n11 1\n11 2\n11 3\n11 4\n11 6\n7 11\n8 11\n11 9\n10 2\n1 12\n12 3\n12 4\n12 5\n6 12\n7 12\n12 8\n9 12\n10 12\n11 12\n",
            "output": "12665422848\n"
        },
        {
            "input": "10 9 12\n4 1\n4 3\n6 2\n6 3\n7 1\n1 8\n5 9\n7 9\n10 5\n",
            "output": "0\n"
        },
        {
            "input": "12 57 12\n1 2\n1 3\n3 2\n1 4\n4 3\n1 5\n2 5\n5 3\n4 3\n6 1\n2 6\n3 6\n4 6\n7 1\n7 2\n7 5\n7 6\n3 8\n8 4\n8 5\n6 8\n8 7\n2 9\n3 9\n4 9\n9 5\n7 9\n8 9\n10 1\n2 10\n3 10\n4 10\n5 10\n6 10\n10 7\n8 10\n9 10\n11 1\n2 11\n11 3\n11 4\n11 6\n7 11\n8 11\n9 11\n11 10\n1 12\n12 2\n3 12\n4 12\n5 12\n6 12\n12 7\n12 8\n12 9\n12 10\n11 12\n",
            "output": "12665422848\n"
        },
        {
            "input": "4 1 2\n3 2\n4 2\n1 4\n",
            "output": "0\n"
        },
        {
            "input": "12 50 12\n2 1\n3 1\n3 2\n4 1\n4 2\n1 5\n5 3\n1 6\n2 6\n6 3\n6 5\n1 7\n3 7\n7 4\n7 5\n1 8\n2 8\n5 8\n8 6\n7 8\n9 1\n2 9\n3 9\n4 9\n9 5\n9 7\n3 9\n1 10\n2 10\n10 3\n4 10\n5 10\n7 10\n10 8\n10 9\n11 1\n2 11\n11 3\n11 4\n11 6\n9 11\n10 11\n1 12\n12 2\n12 4\n12 5\n6 12\n7 12\n12 10\n11 12\n",
            "output": "12665422848\n"
        },
        {
            "input": "12 48 12\n4 1\n4 3\n1 5\n5 3\n4 5\n6 1\n2 6\n6 3\n6 4\n5 6\n7 1\n7 2\n3 7\n7 4\n6 7\n1 8\n8 2\n4 8\n8 5\n8 6\n1 9\n9 2\n4 9\n9 6\n9 8\n10 1\n2 10\n3 10\n4 10\n10 5\n10 7\n10 8\n1 11\n11 3\n11 4\n11 9\n7 11\n11 9\n10 11\n12 2\n12 3\n4 12\n12 5\n12 6\n7 12\n12 8\n9 12\n11 12\n",
            "output": "12662096448\n"
        },
        {
            "input": "12 0 2\n",
            "output": "0\n"
        },
        {
            "input": "12 11 12\n3 4\n3 4\n6 1\n8 6\n2 9\n9 7\n7 10\n11 2\n8 11\n12 1\n12 5\n",
            "output": "0\n"
        },
        {
            "input": "12 5 12\n3 4\n5 2\n4 6\n1 7\n7 9\n9 8\n6 10\n11 1\n2 11\n12 3\n5 12\n",
            "output": "0\n"
        },
        {
            "input": "12 37 12\n1 8\n1 5\n5 3\n8 7\n5 8\n2 3\n6 4\n8 3\n10 1\n10 5\n3 1\n9 10\n4 5\n9 4\n3 6\n8 9\n8 2\n9 3\n9 6\n6 10\n4 3\n7 5\n11 4\n5 1\n8 6\n4 2\n2 9\n8 10\n9 7\n5 9\n4 12\n6 1\n10 7\n6 7\n10 3\n2 1\n7 4\n",
            "output": "0\n"
        },
        {
            "input": "12 4 12\n5 3\n1 2\n6 8\n9 3\n",
            "output": "0\n"
        },
        {
            "input": "12 38 2\n4 11\n11 2\n5 1\n6 7\n9 1\n4 1\n12 2\n10 4\n8 1\n9 10\n1 2\n3 1\n11 12\n10 3\n12 9\n3 12\n4 5\n1 6\n3 9\n11 8\n4 12\n5 3\n9 7\n3 8\n7 5\n12 7\n11 10\n4 9\n2 10\n6 12\n9 2\n3 7\n6 2\n5 8\n10 12\n8 7\n4 2\n4 3\n",
            "output": "2048\n"
        },
        {
            "input": "12 39 2\n2 1\n11 4\n9 11\n1 5\n4 1\n11 7\n9 12\n9 3\n4 5\n12 4\n1 11\n8 1\n6 8\n6 11\n4 3\n1 10\n5 10\n3 7\n10 2\n3 11\n12 7\n10 6\n3 12\n12 11\n5 8\n8 2\n7 9\n9 8\n7 2\n11 8\n12 6\n4 6\n12 1\n11 5\n9 5\n7 9\n12 2\n9 4\n6 7\n",
            "output": "2048\n"
        },
        {
            "input": "12 30 2\n6 4\n1 2\n5 8\n2 9\n5 3\n8 11\n10 5\n3 1\n12 2\n8 9\n4 3\n1 12\n10 4\n1 9\n8 2\n2 6\n8 11\n5 6\n7 2\n1 4\n10 3\n6 1\n11 4\n9 12\n1 11\n1 7\n7 9\n3 12\n4 2\n5 4\n",
            "output": "2048\n"
        },
        {
            "input": "8 26 3\n6 4\n1 8\n8 4\n4 4\n5 6\n5 2\n1 7\n8 1\n3 7\n4 1\n6 1\n5 4\n7 2\n4 7\n6 2\n7 8\n2 1\n5 3\n6 3\n1 3\n5 7\n7 6\n8 5\n2 3\n8 6\n4 2\n",
            "output": "1641\n"
        },
        {
            "input": "12 0 0\n",
            "output": "0\n"
        },
        {
            "input": "12 50 2\n3 7\n12 11\n12 1\n1 6\n10 5\n5 9\n4 11\n5 7\n3 1\n9 4\n6 9\n5 12\n8 4\n1 11\n12 9\n9 2\n6 2\n5 2\n4 7\n4 10\n11 9\n10 11\n7 12\n4 5\n9 10\n9 8\n11 7\n12 8\n2 8\n7 9\n8 1\n12 4\n2 11\n11 3\n6 7\n8 10\n2 7\n1 9\n3 4\n1 5\n10 2\n3 8\n6 3\n2 12\n10 1\n10 7\n8 6\n5 1\n2 4\n9 12\n",
            "output": "2048\n"
        },
        {
            "input": "6 5 3\n2 6\n2 2\n4 5\n3 1\n5 4\n",
            "output": "0\n"
        },
        {
            "input": "8 24 3\n6 4\n5 1\n8 5\n7 6\n5 8\n7 3\n8 2\n2 3\n2 7\n6 2\n6 3\n8 3\n1 2\n8 7\n3 1\n1 6\n3 5\n1 7\n2 4\n6 8\n8 1\n2 5\n4 1\n4 3\n",
            "output": "1641\n"
        },
        {
            "input": "6 14 4\n5 2\n6 5\n1 2\n4 1\n5 4\n4 3\n4 4\n1 5\n5 3\n1 6\n6 1\n1 3\n6 4\n3 2\n",
            "output": "544\n"
        },
        {
            "input": "4 1 2\n3 2\n4 2\n1 2\n",
            "output": "0\n"
        },
        {
            "input": "12 59 5\n1 10\n9 4\n9 8\n9 1\n4 2\n8 10\n8 6\n3 8\n3 6\n10 6\n5 1\n9 3\n10 7\n4 1\n8 4\n6 11\n8 7\n4 11\n1 8\n8 5\n5 10\n9 6\n4 6\n1 2\n5 11\n9 11\n7 11\n7 12\n11 8\n5 3\n11 3\n12 4\n1 11\n11 12\n7 5\n1 6\n6 5\n2 7\n9 5\n12 8\n4 3\n4 5\n7 2\n12 6\n10 4\n9 7\n12 2\n2 9\n3 10\n6 7\n7 4\n12 1\n2 3\n12 3\n2 10\n2 5\n9 12\n2 9\n6 2\n",
            "output": "15424865\n"
        },
        {
            "input": "8 7 12\n4 1\n4 3\n2 5\n1 6\n7 2\n7 3\n2 6\n",
            "output": "0\n"
        },
        {
            "input": "12 35 12\n2 9\n2 10\n2 11\n3 12\n8 10\n5 4\n2 4\n8 3\n11 10\n10 5\n11 5\n4 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n2 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n9 7\n4 11\n2 7\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "138246912\n"
        },
        {
            "input": "12 11 12\n3 4\n3 4\n6 2\n8 6\n2 9\n9 7\n7 10\n11 2\n8 11\n12 1\n12 5\n",
            "output": "0\n"
        },
        {
            "input": "12 5 12\n3 4\n5 4\n4 6\n1 7\n7 9\n9 8\n6 10\n11 1\n2 11\n12 3\n5 12\n",
            "output": "0\n"
        },
        {
            "input": "12 4 12\n5 3\n1 2\n6 8\n9 5\n",
            "output": "0\n"
        },
        {
            "input": "12 30 2\n6 4\n1 2\n5 8\n2 9\n5 3\n8 11\n10 5\n3 1\n12 2\n8 9\n5 3\n1 12\n10 4\n1 9\n8 2\n2 6\n8 11\n5 6\n7 2\n1 4\n10 3\n6 1\n11 4\n9 12\n1 11\n1 7\n7 9\n3 12\n4 2\n5 4\n",
            "output": "2048\n"
        },
        {
            "input": "12 50 2\n3 7\n12 11\n12 1\n1 6\n10 5\n5 9\n4 11\n5 7\n3 1\n9 4\n6 9\n4 12\n8 4\n1 11\n12 9\n9 2\n6 2\n5 2\n4 7\n4 10\n11 9\n10 11\n7 12\n4 5\n9 10\n9 8\n11 7\n12 8\n2 8\n7 9\n8 1\n12 4\n2 11\n11 3\n6 7\n8 10\n2 7\n1 9\n3 4\n1 5\n10 2\n3 8\n6 3\n2 12\n10 1\n10 7\n8 6\n5 1\n2 4\n9 12\n",
            "output": "2048\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n2 4\n5 3\n4 5\n1 6\n6 4\n6 5\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n2 8\n3 8\n5 8\n8 6\n1 9\n4 9\n4 9\n9 5\n9 6\n8 9\n1 10\n10 2\n10 4\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n4 11\n3 11\n11 4\n5 11\n6 11\n9 11\n12 1\n2 12\n12 4\n5 12\n6 12\n7 12\n12 8\n9 12\n12 11\n",
            "output": "12662096448\n"
        },
        {
            "input": "8 24 3\n6 4\n5 1\n8 5\n7 6\n5 8\n7 3\n8 2\n2 3\n2 7\n6 2\n6 3\n8 3\n1 2\n8 7\n3 2\n1 6\n3 5\n1 7\n2 4\n6 8\n8 1\n2 5\n4 1\n4 3\n",
            "output": "1641\n"
        },
        {
            "input": "12 50 12\n2 1\n3 1\n3 2\n4 1\n4 2\n1 5\n5 3\n1 6\n2 6\n6 3\n6 5\n2 7\n5 7\n7 4\n7 5\n1 8\n2 8\n5 8\n8 6\n7 8\n9 1\n2 9\n3 9\n4 9\n9 5\n9 7\n3 9\n1 10\n2 10\n10 3\n4 10\n5 10\n7 10\n10 8\n10 9\n11 1\n2 11\n11 3\n11 4\n11 6\n9 11\n10 11\n1 12\n12 2\n12 4\n12 5\n6 12\n7 12\n12 10\n11 12\n",
            "output": "12664757568\n"
        },
        {
            "input": "12 48 12\n4 1\n4 3\n1 5\n5 3\n4 5\n6 1\n2 6\n6 3\n6 4\n5 6\n7 1\n7 2\n3 7\n7 4\n6 7\n1 8\n8 2\n4 8\n8 5\n8 6\n1 9\n9 2\n4 9\n9 6\n9 8\n10 1\n2 10\n3 10\n4 10\n10 5\n10 7\n10 8\n1 11\n11 3\n11 5\n11 9\n7 11\n11 9\n10 11\n12 2\n12 3\n4 12\n12 5\n12 6\n6 12\n12 8\n9 12\n11 12\n",
            "output": "12660100608\n"
        },
        {
            "input": "8 7 3\n4 1\n4 3\n2 5\n1 6\n7 2\n7 3\n2 6\n",
            "output": "0\n"
        },
        {
            "input": "12 35 12\n2 9\n2 10\n2 11\n3 12\n2 10\n5 4\n2 4\n8 3\n11 10\n10 5\n11 5\n4 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n2 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n9 7\n4 11\n2 7\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "138246912\n"
        },
        {
            "input": "12 11 12\n3 4\n3 4\n6 2\n12 6\n2 9\n9 7\n7 10\n11 2\n8 11\n12 1\n12 5\n",
            "output": "0\n"
        },
        {
            "input": "12 5 12\n3 4\n5 4\n4 6\n1 7\n7 9\n9 8\n6 10\n15 1\n2 11\n12 3\n5 12\n",
            "output": "0\n"
        },
        {
            "input": "12 4 2\n5 3\n1 2\n6 8\n9 5\n",
            "output": "0\n"
        },
        {
            "input": "12 30 2\n6 4\n1 2\n5 2\n2 9\n5 3\n8 11\n10 5\n3 1\n12 2\n8 9\n5 3\n1 12\n10 4\n1 9\n8 2\n2 6\n8 11\n5 6\n7 2\n1 4\n10 3\n6 1\n11 4\n9 12\n1 11\n1 7\n7 9\n3 12\n4 2\n5 4\n",
            "output": "2048\n"
        },
        {
            "input": "12 50 0\n3 7\n12 11\n12 1\n1 6\n10 5\n5 9\n4 11\n5 7\n3 1\n9 4\n6 9\n4 12\n8 4\n1 11\n12 9\n9 2\n6 2\n5 2\n4 7\n4 10\n11 9\n10 11\n7 12\n4 5\n9 10\n9 8\n11 7\n12 8\n2 8\n7 9\n8 1\n12 4\n2 11\n11 3\n6 7\n8 10\n2 7\n1 9\n3 4\n1 5\n10 2\n3 8\n6 3\n2 12\n10 1\n10 7\n8 6\n5 1\n2 4\n9 12\n",
            "output": "0\n"
        },
        {
            "input": "8 7 3\n4 1\n4 2\n2 5\n1 6\n7 2\n7 3\n2 6\n",
            "output": "0\n"
        },
        {
            "input": "12 11 12\n3 4\n3 4\n6 2\n12 12\n2 9\n9 7\n7 10\n11 2\n8 11\n12 1\n12 5\n",
            "output": "0\n"
        },
        {
            "input": "12 5 12\n3 4\n5 4\n4 6\n1 7\n7 9\n9 10\n6 10\n15 1\n2 11\n12 3\n5 12\n",
            "output": "0\n"
        },
        {
            "input": "12 5 12\n3 4\n5 4\n4 6\n1 7\n7 9\n9 10\n6 10\n15 1\n2 11\n16 3\n5 12\n",
            "output": "0\n"
        },
        {
            "input": "12 5 12\n3 4\n4 4\n4 6\n1 7\n7 9\n9 10\n6 10\n15 1\n2 11\n16 3\n5 12\n",
            "output": "0\n"
        },
        {
            "input": "12 35 7\n2 9\n2 10\n2 11\n3 12\n2 5\n5 4\n2 4\n8 3\n11 10\n10 5\n11 5\n4 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n2 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n9 7\n4 7\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "4511479\n"
        },
        {
            "input": "12 5 12\n3 4\n7 4\n4 6\n1 7\n7 9\n9 10\n6 10\n15 1\n2 11\n16 3\n5 12\n",
            "output": "0\n"
        },
        {
            "input": "12 5 12\n3 4\n7 4\n4 6\n1 7\n7 9\n9 10\n6 10\n15 1\n1 11\n16 3\n5 12\n",
            "output": "0\n"
        },
        {
            "input": "12 5 12\n3 4\n7 4\n4 6\n1 7\n7 9\n9 10\n6 10\n15 1\n1 11\n16 3\n5 14\n",
            "output": "0\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n3 7\n5 3\n4 5\n1 6\n6 4\n6 10\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n2 8\n3 8\n5 8\n8 6\n1 9\n4 9\n4 9\n9 5\n12 6\n8 9\n1 10\n10 2\n10 4\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n4 11\n3 11\n11 4\n5 11\n6 11\n9 5\n12 1\n2 12\n12 8\n5 12\n6 12\n7 12\n12 1\n9 12\n12 11\n",
            "output": "12621799488\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 11\n3 12\n2 5\n5 4\n2 4\n8 3\n11 10\n10 5\n11 5\n4 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n5 7\n4 7\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 11\n3 12\n2 5\n5 4\n2 4\n8 3\n11 10\n10 5\n11 5\n5 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n5 7\n4 7\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 11\n3 12\n2 5\n5 6\n2 4\n8 3\n11 10\n10 5\n11 5\n5 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n5 7\n4 7\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 11\n3 12\n2 5\n5 6\n2 4\n8 3\n11 10\n10 5\n11 5\n5 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 11\n3 12\n4 5\n5 6\n2 4\n8 3\n11 10\n10 5\n11 5\n5 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 5\n10 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 11\n3 12\n4 5\n5 6\n2 4\n8 3\n11 10\n10 5\n11 5\n5 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n10 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 11\n3 12\n4 5\n5 6\n2 4\n8 3\n5 10\n10 5\n11 5\n5 8\n4 3\n6 11\n11 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n10 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 11\n3 12\n4 5\n5 6\n2 4\n8 3\n5 10\n10 5\n11 5\n5 8\n4 3\n6 11\n10 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n10 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 11\n3 12\n4 5\n5 6\n2 4\n8 3\n5 10\n10 5\n11 5\n5 8\n4 1\n6 11\n10 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n10 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 2\n3 12\n4 5\n5 6\n2 4\n8 3\n5 10\n10 5\n11 5\n5 8\n4 1\n6 11\n10 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n10 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 2\n3 12\n4 5\n5 6\n1 4\n8 3\n5 10\n10 5\n11 5\n5 8\n4 1\n6 11\n10 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n10 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 2\n3 12\n4 5\n5 6\n1 4\n8 3\n5 10\n10 5\n11 5\n5 8\n4 1\n6 11\n10 9\n10 3\n9 8\n9 3\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n10 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 0\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 2\n3 12\n4 5\n5 6\n1 4\n8 3\n5 10\n10 5\n11 5\n5 8\n4 1\n6 11\n10 9\n10 3\n9 8\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n10 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 0\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 2\n3 12\n4 5\n5 6\n1 4\n8 3\n5 10\n10 5\n11 5\n5 8\n4 1\n9 11\n10 9\n10 3\n9 8\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n10 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 0\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 2\n3 12\n4 5\n5 6\n1 4\n8 5\n5 10\n10 5\n11 5\n5 8\n4 1\n9 11\n10 9\n10 3\n9 8\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n10 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 0\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 2\n3 12\n4 5\n5 6\n1 4\n8 5\n5 10\n10 5\n11 5\n5 8\n4 1\n9 11\n10 9\n10 3\n9 8\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n11 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 0\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 2\n3 12\n4 5\n5 6\n1 4\n8 5\n5 10\n10 5\n11 5\n5 8\n4 1\n9 11\n10 9\n10 3\n9 6\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n11 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 0\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n2 9\n2 10\n2 2\n3 12\n4 5\n5 6\n1 4\n8 5\n5 10\n10 5\n11 5\n5 8\n4 1\n9 11\n10 9\n10 3\n9 6\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n11 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n1 9\n2 10\n2 2\n3 12\n4 5\n5 6\n1 4\n8 5\n5 10\n10 5\n11 5\n5 8\n4 1\n9 11\n10 9\n10 3\n9 6\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n11 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n1 9\n2 10\n2 2\n3 12\n4 5\n5 6\n1 4\n8 5\n5 10\n10 5\n11 1\n5 8\n4 1\n9 11\n10 9\n10 3\n9 6\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n11 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n1 9\n2 10\n2 2\n3 12\n4 5\n5 1\n1 4\n8 5\n5 10\n10 5\n11 1\n5 8\n4 1\n9 11\n10 9\n10 3\n9 6\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n11 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n1 9\n2 10\n2 2\n3 12\n4 5\n5 1\n1 4\n8 5\n5 10\n10 5\n11 1\n5 8\n7 1\n9 11\n10 9\n10 3\n9 6\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n11 4\n8 11\n5 7\n4 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n1 9\n2 10\n2 2\n3 12\n4 5\n5 1\n1 4\n8 5\n5 10\n10 5\n11 1\n5 8\n7 1\n9 11\n10 9\n10 3\n9 6\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n11 4\n8 11\n5 7\n8 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n1 9\n2 10\n2 4\n3 12\n4 5\n5 1\n1 4\n8 5\n5 10\n10 5\n11 1\n5 8\n7 1\n9 11\n10 9\n10 3\n9 6\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n11 4\n8 11\n5 7\n8 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "12 9 7\n1 9\n2 10\n2 4\n3 12\n4 5\n5 1\n1 5\n8 5\n5 10\n10 5\n11 1\n5 8\n7 1\n9 11\n10 9\n10 3\n9 6\n9 6\n7 10\n4 8\n3 9\n7 3\n6 7\n2 2\n11 4\n8 11\n5 7\n8 14\n2 9\n9 10\n6 10\n3 11\n10 1\n2 3\n5 3\n",
            "output": "0\n"
        },
        {
            "input": "6 14 4\n2 5\n1 5\n2 3\n6 2\n2 1\n6 1\n6 1\n6 3\n6 4\n4 3\n3 5\n2 4\n5 4\n5 6\n",
            "output": "544\n"
        },
        {
            "input": "8 6 0\n5 1\n5 4\n6 7\n4 3\n3 5\n3 2\n",
            "output": "0\n"
        },
        {
            "input": "8 26 3\n6 4\n2 8\n8 4\n3 4\n5 6\n5 2\n1 7\n8 1\n3 7\n4 1\n6 1\n5 4\n7 2\n4 7\n6 2\n7 8\n2 1\n5 3\n6 3\n1 3\n5 7\n7 6\n8 5\n2 4\n8 6\n4 2\n",
            "output": "1641\n"
        },
        {
            "input": "6 0 1\n",
            "output": "0\n"
        },
        {
            "input": "12 50 2\n3 7\n12 11\n12 1\n1 6\n10 5\n5 9\n4 11\n5 7\n3 1\n9 4\n6 9\n6 12\n8 4\n1 11\n12 6\n9 2\n6 2\n5 2\n4 7\n4 10\n11 9\n10 11\n7 12\n4 5\n9 10\n9 8\n11 7\n12 8\n2 8\n7 9\n8 1\n12 4\n2 11\n11 3\n6 7\n8 10\n2 7\n1 9\n3 4\n1 5\n10 2\n3 8\n6 3\n2 12\n10 1\n10 7\n8 6\n5 11\n2 4\n9 12\n",
            "output": "2048\n"
        },
        {
            "input": "12 63 5\n2 9\n7 11\n4 10\n5 1\n6 2\n6 4\n3 4\n5 11\n7 1\n11 12\n3 5\n3 12\n11 4\n9 12\n2 7\n1 8\n7 5\n2 3\n2 5\n1 9\n3 7\n10 9\n10 3\n10 5\n1 12\n8 2\n12 5\n8 7\n5 4\n9 8\n4 8\n4 9\n10 2\n7 12\n1 10\n9 5\n8 12\n3 9\n8 5\n7 6\n1 11\n3 6\n8 6\n4 12\n6 12\n4 7\n12 10\n3 11\n11 9\n2 1\n10 6\n11 10\n11 6\n2 4\n6 1\n11 2\n8 11\n10 8\n9 6\n7 9\n7 10\n5 6\n1 4\n",
            "output": "15424865\n"
        },
        {
            "input": "8 28 12\n3 7\n3 8\n3 3\n2 6\n1 3\n7 6\n7 1\n2 8\n8 5\n5 3\n5 1\n4 1\n4 3\n8 4\n6 3\n2 1\n7 8\n6 5\n7 5\n5 4\n1 8\n4 7\n6 8\n2 4\n2 7\n5 2\n4 6\n1 6\n",
            "output": "1532928\n"
        },
        {
            "input": "12 51 12\n3 1\n3 2\n4 1\n4 3\n5 1\n5 2\n6 1\n6 3\n6 4\n4 1\n2 7\n3 7\n6 7\n8 1\n8 2\n8 3\n4 8\n8 5\n6 8\n8 7\n2 9\n9 3\n4 9\n5 9\n9 6\n7 9\n9 8\n1 10\n10 2\n3 10\n4 10\n5 10\n10 9\n11 1\n2 11\n3 11\n5 11\n11 6\n11 8\n9 11\n10 11\n1 12\n12 2\n3 12\n4 12\n12 5\n6 12\n12 7\n12 8\n9 12\n12 10\n",
            "output": "12664757568\n"
        },
        {
            "input": "12 62 2\n1 5\n8 10\n9 10\n7 6\n9 12\n3 1\n12 1\n2 10\n6 9\n2 11\n2 5\n10 4\n4 2\n12 11\n7 8\n4 12\n12 3\n7 11\n10 3\n8 3\n2 8\n1 4\n3 2\n7 12\n10 1\n4 8\n1 6\n10 12\n3 5\n1 2\n6 11\n5 12\n5 9\n2 6\n5 4\n12 2\n3 7\n1 8\n11 5\n2 9\n2 10\n7 4\n8 5\n7 2\n9 1\n8 9\n9 4\n6 4\n6 12\n3 11\n11 4\n6 8\n9 11\n3 6\n8 11\n12 8\n6 5\n10 5\n5 7\n7 10\n7 1\n3 4\n",
            "output": "2048\n"
        },
        {
            "input": "12 49 12\n3 1\n2 3\n4 1\n2 4\n5 3\n4 5\n1 6\n6 4\n6 5\n7 1\n7 2\n3 7\n4 7\n7 5\n7 6\n2 8\n3 8\n5 8\n8 6\n1 9\n3 9\n4 9\n9 5\n9 6\n8 9\n1 10\n10 2\n10 3\n10 5\n6 10\n7 10\n10 8\n10 9\n11 1\n2 11\n3 11\n10 4\n5 11\n6 11\n9 11\n12 1\n2 12\n12 4\n5 12\n6 12\n7 12\n12 8\n9 12\n12 11\n",
            "output": "12662096448\n"
        },
        {
            "input": "12 64 12\n6 12\n4 6\n8 6\n5 9\n11 6\n12 11\n7 8\n11 10\n5 1\n5 3\n4 9\n9 1\n6 10\n10 9\n10 1\n5 11\n8 3\n3 2\n1 6\n2 6\n1 11\n3 7\n9 8\n5 10\n10 12\n12 1\n11 2\n6 9\n8 5\n5 12\n8 10\n8 4\n6 5\n1 8\n2 1\n11 7\n3 6\n3 10\n7 2\n7 6\n12 8\n2 9\n7 1\n12 2\n9 3\n4 5\n1 3\n1 4\n11 3\n9 12\n4 2\n3 12\n7 10\n10 4\n11 4\n7 4\n7 12\n2 5\n10 2\n9 7\n4 12\n9 11\n7 5\n4 3\n",
            "output": "12665422848\n"
        },
        {
            "input": "8 24 3\n6 4\n5 1\n8 5\n7 6\n5 4\n7 3\n8 2\n4 3\n2 7\n6 2\n6 3\n8 3\n1 2\n8 7\n3 1\n1 6\n3 5\n1 7\n2 4\n4 8\n8 1\n2 5\n4 1\n4 3\n",
            "output": "1641\n"
        },
        {
            "input": "12 58 2\n11 6\n10 1\n2 12\n5 1\n11 1\n11 9\n1 4\n6 7\n8 11\n6 12\n11 10\n8 2\n3 11\n10 7\n8 12\n11 7\n10 5\n3 1\n12 9\n3 6\n10 12\n1 12\n2 4\n10 4\n3 9\n3 2\n2 6\n2 2\n7 9\n6 10\n3 8\n5 9\n9 2\n8 9\n1 2\n11 12\n1 9\n4 8\n3 10\n12 4\n5 11\n9 6\n10 2\n3 5\n6 1\n6 8\n5 4\n10 8\n3 7\n4 3\n7 8\n2 11\n12 7\n7 4\n12 5\n5 2\n6 5\n9 10\n",
            "output": "2048\n"
        },
        {
            "input": "12 64 2\n10 9\n3 12\n6 4\n9 4\n12 8\n4 3\n2 8\n8 5\n10 4\n11 7\n12 2\n8 4\n3 5\n2 11\n4 2\n4 5\n12 6\n3 2\n2 5\n9 12\n7 5\n12 5\n9 2\n11 1\n6 1\n7 1\n12 7\n8 6\n7 3\n8 7\n5 10\n1 8\n9 7\n11 9\n10 11\n9 5\n8 11\n11 5\n2 7\n7 3\n1 2\n9 1\n6 5\n10 7\n7 4\n1 3\n1 10\n2 10\n9 8\n3 10\n5 1\n3 6\n6 10\n3 11\n9 3\n11 12\n1 4\n9 6\n6 11\n11 4\n3 8\n8 10\n10 12\n4 12\n",
            "output": "2048\n"
        },
        {
            "input": "12 62 5\n12 5\n5 10\n6 5\n2 5\n8 4\n8 2\n1 3\n7 10\n2 3\n11 12\n5 4\n1 3\n5 8\n12 7\n3 9\n9 2\n11 4\n6 9\n1 5\n4 12\n8 7\n11 8\n10 4\n10 11\n1 10\n12 6\n11 1\n11 9\n3 12\n2 1\n1 12\n9 5\n12 9\n12 8\n10 6\n7 6\n8 6\n1 7\n3 6\n8 10\n4 2\n9 10\n4 3\n7 2\n6 1\n8 1\n11 3\n3 10\n2 11\n2 6\n10 12\n8 9\n9 1\n5 7\n5 3\n6 11\n7 9\n5 11\n1 4\n12 2\n8 3\n4 7\n",
            "output": "15424865\n"
        },
        {
            "input": "12 55 12\n1 3\n2 3\n4 1\n2 4\n4 3\n1 5\n2 5\n5 3\n6 1\n6 2\n6 3\n4 6\n7 1\n2 7\n7 4\n5 7\n1 8\n8 2\n8 3\n8 5\n8 6\n8 7\n9 1\n2 9\n9 3\n4 9\n5 9\n7 9\n9 8\n1 10\n10 2\n3 10\n4 10\n10 12\n10 7\n10 8\n11 1\n11 2\n11 3\n11 4\n11 6\n7 11\n8 11\n11 9\n10 11\n1 12\n12 3\n12 4\n12 5\n6 12\n7 12\n12 8\n9 12\n10 12\n11 12\n",
            "output": "12665422848\n"
        },
        {
            "input": "8 14 4\n5 2\n6 5\n1 2\n4 1\n5 4\n4 3\n2 4\n1 5\n5 3\n1 6\n6 3\n1 3\n6 4\n3 2\n",
            "output": "0\n"
        },
        {
            "input": "12 66 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n4 5\n4 6\n4 7\n4 8\n4 9\n4 10\n4 11\n4 12\n5 6\n5 7\n5 8\n5 9\n5 10\n5 11\n5 12\n6 2\n6 8\n6 9\n6 10\n6 11\n6 12\n7 8\n7 9\n7 10\n7 11\n7 12\n8 9\n8 10\n8 11\n8 12\n9 10\n9 11\n9 12\n10 11\n10 12\n11 12\n",
            "output": "12665422848\n"
        },
        {
            "input": "6 13 2\n1 3\n4 2\n6 3\n3 5\n1 6\n4 1\n3 2\n1 5\n4 3\n6 2\n2 5\n6 4\n1 2\n",
            "output": "32\n"
        },
        {
            "input": "12 57 12\n1 2\n1 3\n3 2\n1 4\n4 3\n1 5\n2 5\n5 3\n4 5\n6 1\n2 6\n3 2\n4 6\n7 1\n7 2\n7 5\n7 6\n3 8\n8 4\n8 5\n6 8\n8 7\n2 9\n3 9\n4 9\n9 5\n7 9\n8 9\n10 1\n2 10\n3 10\n4 10\n5 10\n6 10\n10 7\n8 10\n9 10\n11 1\n2 11\n11 3\n11 4\n11 6\n7 11\n8 11\n9 11\n11 10\n1 12\n12 2\n3 12\n4 12\n5 12\n6 12\n12 7\n12 8\n12 9\n12 10\n11 12\n",
            "output": "12665422848\n"
        },
        {
            "input": "12 51 5\n5 4\n9 1\n8 1\n3 8\n7 10\n5 10\n5 2\n7 9\n5 7\n10 4\n6 7\n3 9\n1 7\n6 12\n10 1\n9 11\n4 3\n8 12\n6 8\n1 12\n7 8\n2 12\n3 8\n11 12\n11 6\n9 12\n3 5\n1 2\n11 10\n12 7\n3 2\n4 9\n8 10\n11 7\n4 12\n7 2\n6 4\n1 4\n10 2\n9 8\n12 3\n2 6\n3 1\n5 12\n7 3\n5 1\n9 2\n6 3\n8 4\n10 6\n3 11\n",
            "output": "15424865\n"
        },
        {
            "input": "6 6 3\n3 5\n2 5\n6 1\n2 3\n6 6\n5 4\n",
            "output": "0\n"
        },
        {
            "input": "4 2 0\n1 4\n1 2\n",
            "output": "0\n"
        },
        {
            "input": "12 66 5\n1 2\n9 6\n1 4\n8 6\n1 6\n5 6\n10 9\n12 1\n6 7\n3 1\n12 3\n11 1\n4 5\n12 2\n10 2\n4 10\n2 11\n9 1\n10 5\n6 3\n4 7\n6 10\n4 8\n2 3\n12 5\n10 8\n9 7\n12 9\n9 3\n12 7\n2 5\n9 2\n10 3\n11 5\n1 5\n7 1\n8 1\n6 12\n8 12\n2 4\n9 8\n6 4\n4 12\n8 7\n9 11\n7 3\n3 5\n10 12\n10 11\n5 9\n3 8\n2 8\n7 10\n4 11\n3 4\n8 11\n7 2\n11 3\n7 5\n11 7\n12 11\n1 10\n6 11\n4 4\n5 8\n6 2\n",
            "output": "15424865\n"
        },
        {
            "input": "8 6 2\n3 8\n2 3\n4 8\n3 4\n4 1\n1 2\n",
            "output": "0\n"
        },
        {
            "input": "12 65 5\n1 10\n10 6\n2 10\n8 10\n2 11\n1 5\n12 10\n5 2\n8 2\n6 8\n12 11\n10 11\n1 9\n3 12\n4 2\n4 11\n9 11\n9 4\n1 6\n6 3\n11 6\n12 2\n1 7\n4 1\n12 1\n6 7\n7 12\n9 8\n9 6\n12 9\n3 1\n7 8\n5 12\n11 5\n1 8\n9 10\n3 4\n3 5\n5 7\n4 5\n3 7\n6 12\n1 2\n4 12\n5 10\n8 11\n10 7\n6 2\n5 6\n6 4\n3 9\n3 2\n11 1\n4 7\n10 7\n8 12\n8 3\n5 9\n7 2\n7 11\n9 7\n5 8\n3 11\n9 2\n10 3\n",
            "output": "15424865\n"
        },
        {
            "input": "10 36 2\n1 9\n3 5\n7 1\n10 1\n9 5\n10 2\n8 7\n9 3\n7 6\n10 4\n9 6\n8 4\n5 8\n2 8\n3 6\n1 5\n1 6\n6 2\n7 3\n2 4\n7 5\n1 2\n1 3\n10 5\n9 8\n5 6\n2 7\n4 9\n4 7\n8 10\n1 6\n7 10\n6 4\n1 4\n2 9\n7 9\n",
            "output": "512\n"
        },
        {
            "input": "12 59 5\n1 10\n9 4\n9 8\n9 1\n4 2\n8 10\n8 2\n3 8\n3 6\n10 6\n5 1\n9 3\n10 7\n4 1\n8 4\n6 11\n8 7\n4 11\n1 8\n8 5\n5 10\n9 6\n4 6\n1 2\n5 11\n9 11\n7 11\n7 12\n11 8\n5 3\n11 3\n12 4\n1 11\n11 12\n7 5\n1 6\n6 5\n3 7\n9 5\n12 8\n4 3\n4 5\n7 2\n12 6\n10 4\n9 7\n12 2\n2 9\n3 10\n6 7\n7 4\n12 1\n2 3\n12 3\n2 10\n2 5\n9 12\n10 9\n6 2\n",
            "output": "15424865\n"
        },
        {
            "input": "8 28 3\n3 5\n1 6\n4 6\n8 2\n7 3\n5 8\n6 3\n8 3\n7 4\n1 3\n7 6\n2 5\n5 7\n6 8\n3 2\n4 3\n5 6\n5 4\n4 1\n4 2\n7 1\n6 2\n1 8\n2 1\n4 8\n8 7\n5 1\n3 7\n",
            "output": "1641\n"
        },
        {
            "input": "12 65 2\n4 1\n5 3\n8 7\n11 2\n2 9\n6 3\n3 4\n4 12\n2 8\n4 10\n10 11\n5 1\n10 8\n6 4\n4 5\n11 3\n3 10\n12 2\n12 1\n11 6\n1 8\n9 7\n3 8\n5 8\n2 10\n5 2\n10 6\n8 12\n11 1\n7 12\n11 5\n7 11\n11 8\n8 6\n11 7\n3 9\n1 7\n10 9\n5 12\n12 10\n12 9\n2 1\n7 10\n6 5\n4 7\n6 9\n2 6\n5 9\n6 7\n11 4\n11 9\n7 2\n7 5\n6 1\n3 12\n3 1\n1 9\n4 8\n1 10\n9 8\n2 4\n9 4\n3 7\n2 3\n12 6\n",
            "output": "2048\n"
        },
        {
            "input": "12 50 12\n2 1\n3 1\n3 2\n4 1\n4 2\n1 5\n5 3\n1 6\n2 6\n6 3\n6 5\n1 7\n3 7\n7 4\n7 5\n1 8\n2 8\n5 8\n8 6\n7 8\n9 1\n2 9\n3 9\n4 9\n9 5\n9 7\n8 9\n1 10\n2 10\n10 3\n4 10\n5 10\n7 10\n10 8\n10 9\n11 1\n2 11\n11 3\n11 4\n11 6\n9 11\n10 11\n1 12\n12 2\n12 4\n12 5\n6 12\n10 12\n12 10\n11 12\n",
            "output": "12665422848\n"
        },
        {
            "input": "12 48 12\n4 1\n4 3\n1 5\n5 3\n4 5\n6 1\n2 6\n6 3\n9 4\n5 6\n7 1\n7 2\n3 7\n7 4\n6 7\n1 8\n8 2\n4 8\n8 5\n8 6\n1 9\n9 2\n4 9\n9 6\n9 8\n10 1\n2 10\n3 10\n4 10\n10 5\n10 7\n10 8\n1 11\n11 3\n11 4\n11 5\n7 11\n11 9\n10 11\n12 2\n12 3\n4 12\n12 5\n12 6\n7 12\n12 8\n9 12\n11 12\n",
            "output": "12660100608\n"
        },
        {
            "input": "12 64 5\n8 1\n6 4\n8 11\n8 4\n11 9\n8 3\n7 11\n12 3\n11 5\n11 2\n2 10\n3 7\n6 8\n4 3\n9 12\n7 6\n11 3\n7 8\n1 12\n10 3\n12 8\n1 2\n12 10\n2 12\n11 4\n5 12\n6 7\n7 2\n9 2\n5 4\n3 6\n1 6\n12 7\n1 5\n8 10\n1 4\n10 1\n4 10\n7 9\n1 3\n5 7\n2 5\n3 5\n6 12\n2 3\n12 11\n8 2\n10 11\n9 5\n3 9\n6 2\n9 6\n11 1\n8 5\n4 7\n1 7\n10 7\n4 12\n4 2\n10 5\n10 9\n9 1\n6 10\n11 6\n",
            "output": "15424865\n"
        },
        {
            "input": "2 0 2\n2 1\n",
            "output": "0\n"
        },
        {
            "input": "12 2 5\n4 4\n11 1\n",
            "output": "0\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint rev[1 << 20];\nint dp[1 << 13][13][13];\nint visit[1 << 13][13][13];\nbool visit2[1 << 20];\nint maps[13], c[13];\nint a[13][13];\nint n, m, r;\nlong long ans = 0;\nint stage;\nvector<pair<int, int> > v[1 << 13][13][13];\nvector<int> edges[1 << 20];\nlong long A(int r, int g) {\n  int ans = 1;\n  for (int i = 1; i <= g; i++) ans *= (r - i + 1);\n  return ans;\n}\nbool vis[1 << 20];\nbool dfs2(int x, int y, int state) {\n  if (state == (1 << n) - 1) {\n    visit[state][x][y] = stage;\n    return dp[state][x][y] = true;\n  }\n  if (visit[state][x][y] == stage) return false;\n  for (int i = 0; i < v[state][x][y].size(); i++) {\n    int p = v[state][x][y][i].first;\n    int q = v[state][x][y][i].second;\n    if (maps[p] == maps[q] && dfs2(p, q, state | (1 << p) | (1 << q))) {\n      visit[state][x][y] = stage;\n      return dp[state][x][y] = true;\n    }\n  }\n  visit[state][x][y] = stage;\n  return dp[state][x][y] = false;\n}\nbool check() {\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++)\n      if (a[i][j] && maps[i] == maps[j] && dfs2(i, j, (1 << i) | (1 << j)))\n        return true;\n  return false;\n}\nint flag;\nunordered_map<int, int> mp;\nint get_state(int a[]) {\n  int state = 0;\n  for (int i = 0; i < n; i++) state = 6 * state + a[i] - 1;\n  return state;\n}\nvoid decode_state(int maps[], int state) {\n  for (int i = n - 1; i >= 0; i--) {\n    maps[i] = state % 6 + 1;\n    state /= 6;\n  }\n}\nvoid dfs(int pos, int group) {\n  stage++;\n  if (group > min(6, r) || pos + flag > n) return;\n  if (pos == n) {\n    int id = get_state(maps);\n    int sz = mp.size();\n    mp[id] = sz;\n    rev[sz] = id;\n    if ((group == r || group * 2 == n) && check()) {\n      vis[sz] = true;\n    }\n    return;\n  }\n  c[group + 1]++;\n  flag++;\n  maps[pos] = group + 1;\n  dfs(pos + 1, group + 1);\n  flag--;\n  c[group + 1]--;\n  for (int i = 1; i <= group; i++) {\n    c[i]++;\n    if (c[i] & 1)\n      flag++;\n    else\n      flag--;\n    maps[pos] = i;\n    dfs(pos + 1, group);\n    if (c[i] & 1)\n      flag--;\n    else\n      flag++;\n    c[i]--;\n  }\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &r);\n  while (m--) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    x--, y--;\n    a[x][y] = a[y][x] = 1;\n  }\n  for (int i = 0; i < (1 << n); i++) {\n    int cnt = 0;\n    for (int j = 0; j < n; j++)\n      if (i & (1 << j)) cnt++;\n    if (cnt & 1) continue;\n    for (int j = 0; j < n; j++)\n      for (int k = 0; k < n; k++)\n        if ((i & (1 << j)) && (i & (1 << k)))\n          for (int p = 0; p < n; p++)\n            for (int q = 0; q < n; q++)\n              if (a[j][p] && a[k][q] && p != q && !(i & (1 << p)) &&\n                  !(i & (1 << q)))\n                v[i][j][k].push_back(make_pair(p, q));\n  }\n  dfs(0, 0);\n  for (unordered_map<int, int>::iterator it = mp.begin(); it != mp.end();\n       it++) {\n    decode_state(maps, it->first);\n    int maps2[13];\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++)\n        if (maps[i] != maps[j]) {\n          for (int k = 0; k < n; k++) maps2[k] = maps[k];\n          int id = min(maps[i], maps[j]);\n          int id2 = max(maps[i], maps[j]);\n          for (int k = 0; k < n; k++)\n            if (maps[j] == maps[k]) maps2[k] = id;\n          for (int k = 0; k < n; k++)\n            if (maps2[k] > id2) maps2[k]--;\n          int x = get_state(maps2);\n          edges[it->second].push_back(mp[x]);\n        }\n    }\n  }\n  queue<int> q;\n  for (int i = 0; i < mp.size(); i++) {\n    if (vis[i]) q.push(i), visit2[i] = true;\n  }\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    decode_state(maps, rev[u]);\n    int mx = 0;\n    for (int i = 0; i < n; i++) mx = max(mx, maps[i]);\n    ans += A(r, mx);\n    for (int i = 0; i < edges[u].size(); i++) {\n      int x = edges[u][i];\n      if (visit2[x]) continue;\n      q.push(x);\n      visit2[x] = true;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 13, MAXM = MAXN * MAXN / 2;\nlong long c[MAXN][MAXN], fact[MAXN], ans;\nint n, m, k, cnt, tot, e[MAXN][MAXN], way[MAXN][MAXN], bucket[MAXN], vis[MAXN];\nset<int> s;\npair<int, int> g[MAXN];\nstruct Solution {\n  int id[MAXN];\n  bool operator<(const Solution& s2) const {\n    for (int i = (1); i <= (n); i++)\n      if (id[i] != s2.id[i]) return id[i] < s2.id[i];\n    return 0;\n  }\n} sol;\nset<Solution> ret;\nlong long P(long long n, long long m) {\n  if (n < 0 || m < 0 || n < m) return 0;\n  return c[n][m] * fact[m];\n}\nint check() {\n  static int dp[(1 << 6)][MAXN][MAXN];\n  memset(dp, 0, sizeof dp);\n  for (int i = (0); i <= (n / 2 - 1); i++) {\n    if (e[g[i].first][g[i].second]) {\n      dp[1 << i][g[i].first][g[i].second] =\n          dp[1 << i][g[i].second][g[i].first] = 1;\n    }\n  }\n  for (int i = (1); i <= ((1 << (n / 2)) - 1); i++) {\n    for (int u = (1); u <= (n); u++) {\n      for (int v = (1); v <= (n); v++) {\n        if (!dp[i][u][v]) continue;\n        for (int j = (0); j <= (n / 2 - 1); j++) {\n          if (i & (1 << j)) continue;\n          int x = g[j].first, y = g[j].second;\n          if ((e[u][x] && e[v][y]) || (e[u][y] && e[v][x])) {\n            dp[i | (1 << j)][x][y] = dp[i | (1 << j)][y][x] = 1;\n          }\n        }\n      }\n    }\n  }\n  for (int i = (1); i <= (n); i++)\n    for (int j = (1); j <= (n); j++)\n      if (dp[(1 << (n / 2)) - 1][i][j]) return 1;\n  return 0;\n}\nvoid dfs2(int r) {\n  if (r == n / 2) {\n    for (int i = (1); i <= (cnt); i++) {\n      for (int j = (1); j <= (way[i][0]); j++) {\n        int u = g[way[i][j]].first, v = g[way[i][j]].second;\n        sol.id[u] = sol.id[v] = i;\n      }\n    }\n    ret.insert(sol);\n    return;\n  }\n  for (int i = (1); i <= (cnt); i++) {\n    way[i][++way[i][0]] = r;\n    dfs2(r + 1);\n    way[i][0]--;\n  }\n  cnt++;\n  way[cnt][++way[cnt][0]] = r;\n  dfs2(r + 1);\n  way[cnt][0]--;\n  cnt--;\n}\nvoid dfs() {\n  int u = 0;\n  for (int i = (1); i <= (n); i++)\n    if (!vis[i]) {\n      u = i;\n      break;\n    }\n  if (!u) {\n    if (!check()) return;\n    cnt = 0;\n    for (int i = (1); i <= (n); i++) way[i][0] = 0;\n    dfs2(0);\n    return;\n  }\n  vis[u] = 1;\n  for (int v = (u + 1); v <= (n); v++) {\n    if (vis[v]) continue;\n    vis[v] = 1;\n    g[tot++] = make_pair(u, v);\n    dfs();\n    tot--;\n    vis[v] = 0;\n  }\n  vis[u] = 0;\n}\nvoid solve() {\n  for (int i = (1); i <= (m); i++) {\n    int u, v;\n    cin >> u >> v;\n    e[u][v] = e[v][u] = 1;\n  }\n  dfs();\n  for (auto it : ret) {\n    int cnt = 0;\n    memset(bucket, 0, sizeof bucket);\n    for (int i = (1); i <= (n); i++) {\n      if (bucket[it.id[i]]) continue;\n      cnt++;\n      bucket[it.id[i]] = 1;\n    }\n    ans += P(k, cnt);\n  }\n}\nint main() {\n  c[0][0] = 1;\n  for (int i = (1); i <= (12); i++) {\n    c[i][0] = 1;\n    for (int j = (1); j <= (i); j++) c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n  }\n  fact[0] = 1;\n  for (int i = (1); i <= (12); i++) fact[i] = fact[i - 1] * i;\n  cin >> n >> m >> k;\n  solve();\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint max(int a, int b) { return a > b ? a : b; }\nunsigned int X;\nint rand_() { return (X *= 3) >> 1; }\nvoid srand_() {\n  struct timeval tv;\n  gettimeofday(&tv, NULL);\n  X = tv.tv_sec ^ tv.tv_usec | 1;\n}\nchar adj[12][12];\nint aa[12], n, m, a1;\nvoid decode(long long x) {\n  int i;\n  for (i = n - 1; i >= 0; i--) aa[i] = x % 12, x /= 12;\n}\nlong long encode() {\n  int i;\n  long long x;\n  x = 0;\n  for (i = 0; i < n; i++) x = x * 12 + aa[i];\n  return x;\n}\nint mate[12], uu[12], vv[12], n_;\nint feasible() {\n  static char can[1 << 12 / 2][12 / 2];\n  int b, i, j;\n  n_ = 0;\n  for (i = 0; i < n; i++)\n    if (i < mate[i]) uu[n_] = i, vv[n_] = mate[i], n_++;\n  memset(can, 0, (1 << n_) * sizeof *can);\n  for (i = 0; i < n_; i++) can[1 << i][i] = 1;\n  for (b = 0; b < 1 << n_; b++)\n    for (i = 0; i < n_; i++)\n      if (can[b][i])\n        for (j = 0; j < n_; j++)\n          if ((b & 1 << j) == 0 && (adj[uu[i]][uu[j]] && adj[vv[i]][vv[j]] ||\n                                    adj[uu[i]][vv[j]] && adj[vv[i]][uu[j]]))\n            can[b | 1 << j][j] = 1;\n  for (i = 0; i < n_; i++)\n    if (adj[uu[i]][vv[i]] && can[(1 << n_) - 1][i]) return 1;\n  return 0;\n}\nlong long solutions[3000000];\nint c;\nvoid brute2(int i, int a_) {\n  int a;\n  if (i == n_) {\n    solutions[c++] = encode();\n    return;\n  }\n  for (a = 0; a < a_; a++) aa[uu[i]] = aa[vv[i]] = a, brute2(i + 1, a_);\n  aa[uu[i]] = aa[vv[i]] = a_, brute2(i + 1, a_ + 1);\n}\nvoid brute1(int i) {\n  if (i == n) {\n    if (feasible()) brute2(0, 0);\n    return;\n  }\n  if (mate[i] != -1)\n    brute1(i + 1);\n  else {\n    for (mate[i] = i + 1; mate[i] < n; mate[i]++)\n      if (mate[mate[i]] == -1)\n        mate[mate[i]] = i, brute1(i + 1), mate[mate[i]] = -1;\n    mate[i] = -1;\n  }\n}\nvoid sort(long long *aa, int l, int r) {\n  while (l < r) {\n    int i = l, j = l, k = r;\n    long long a = aa[l + rand_() % (r - l)], tmp;\n    while (j < k)\n      if (aa[j] == a)\n        j++;\n      else if (aa[j] < a) {\n        tmp = aa[i], aa[i] = aa[j], aa[j] = tmp;\n        i++, j++;\n      } else {\n        k--;\n        tmp = aa[j], aa[j] = aa[k], aa[k] = tmp;\n      }\n    sort(aa, l, i);\n    l = k;\n  }\n}\nint main() {\n  int h, i, j;\n  long long ans;\n  srand_();\n  scanf(\"%d%d%d\", &n, &m, &a1);\n  while (m--) {\n    scanf(\"%d%d\", &i, &j), i--, j--;\n    adj[i][j] = adj[j][i] = 1;\n  }\n  memset(mate, -1, n * sizeof *mate);\n  brute1(0);\n  sort(solutions, 0, c);\n  ans = 0;\n  for (h = 0; h < c; h++)\n    if (h == 0 || solutions[h] != solutions[h - 1]) {\n      long long x;\n      int a_, a;\n      decode(solutions[h]);\n      a_ = 0;\n      for (i = 0; i < n; i++) a_ = max(a_, aa[i]);\n      a_++;\n      x = 1;\n      for (a = 0; a < a_; a++) x *= (a1 - a);\n      ans += x;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization(\"unroll-loops, no-stack-protector\")\n#pragma GCC target(\"avx,avx2,fma\")\nusing namespace std;\nmt19937_64 rnd;\nconst long long maxn = 20;\nconst long long mod = 1e9 + 7;\nconst long long base = 3e18;\nconst long double eps = 1e-7;\nmap<long long, long long> dp;\nlong long a[maxn];\nlong long n, m, k;\nbool dd[maxn][maxn];\npair<long long, long long> adj[10];\nbool dp1[(1ll << 6)][6];\nbool chk(pair<long long, long long> a, pair<long long, long long> b) {\n  if (dd[a.first][b.first] && dd[a.second][b.second]) return true;\n  if (dd[a.first][b.second] && dd[a.second][b.first]) return true;\n  return false;\n}\nvoid dosth(long long id) {\n  if (id == n / 2 + 1) {\n    long long msk = 0;\n    memset(dp1, 0, sizeof(dp1));\n    for (int i = 1; i <= n; i++) {\n      msk = msk * 7 + a[i];\n      if (!adj[a[i] - 1].first)\n        adj[a[i] - 1].first = i;\n      else\n        adj[a[i] - 1].second = i;\n    }\n    long long len = n / 2;\n    for (int t = 0; t < len; t++) dp1[(1ll << t)][t] = 1;\n    for (int i = 1; i < (1ll << len); i++) {\n      for (int j = 0; j < len; j++) {\n        if (!dp1[i][j]) continue;\n        for (int t = 0; t < len; t++) {\n          if (i & (1ll << t)) continue;\n          dp1[i + (1ll << t)][t] |= chk(adj[t], adj[j]);\n        }\n      }\n    }\n    bool kt = false;\n    for (int t = 0; t < len; t++) {\n      if (dp1[(1ll << len) - 1][t] && dd[adj[t].first][adj[t].second]) {\n        kt = true;\n        break;\n      }\n    }\n    if (kt) {\n      dp[msk] = 2;\n    } else\n      dp[msk] = 1;\n    for (int i = 0; i < len; i++) adj[i] = make_pair(0ll, 0ll);\n    return;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!a[i]) {\n      a[i] = id;\n      for (int j = i + 1; j <= n; j++) {\n        if (!a[j]) {\n          a[j] = id;\n          dosth(id + 1);\n          a[j] = 0;\n        }\n      }\n      a[i] = 0;\n      return;\n    }\n  }\n}\nlong long f(long long msk) {\n  if (dp.count(msk)) return dp[msk];\n  vector<long long> vt;\n  long long nw = msk;\n  vector<long long> cnt(11, 0ll);\n  for (int i = 0; i < n; i++) {\n    vt.push_back(msk % 7);\n    cnt[msk % 7]++;\n    msk /= 7;\n  }\n  reverse(vt.begin(), vt.end());\n  long long ans = 1;\n  for (int i = 0; i < vt.size(); i++) {\n    if (cnt[vt[i]] >= 4) {\n      for (int j = i + 1; j < vt.size(); j++) {\n        if (vt[j] == vt[i]) {\n          long long pre = vt[i];\n          vt[i] = n / 2 + 1;\n          vt[j] = n / 2 + 1;\n          vector<long long> kt(8, 0ll);\n          long long nxt = 0;\n          long long cnt = 1;\n          for (int t = 0; t < vt.size(); t++) {\n            if (!kt[vt[t]]) {\n              kt[vt[t]] = cnt;\n              cnt++;\n            }\n            nxt = nxt * 7 + kt[vt[t]];\n          }\n          if (f(nxt) == 2) {\n            ans = 2;\n            break;\n          }\n          vt[i] = pre;\n          vt[j] = pre;\n        }\n      }\n      break;\n    }\n  }\n  return dp[msk] = ans;\n}\nlong long ans = 0;\nvoid dosth1(long long id, long long cnt) {\n  if (id == n + 1) {\n    vector<long long> dem(13, 0ll);\n    long long msk = 0;\n    for (int i = 1; i <= n; i++) {\n      dem[a[i]]++;\n      msk = msk * 7 + a[i];\n    }\n    for (int i = 1; i <= n; i++) {\n      if (dem[a[i]] % 2 == 1) return;\n    }\n    if (f(msk) == 2) {\n      long long res = 1;\n      for (long long t = k; t >= k - cnt + 1; t--) res = res * t;\n      ans = (ans + res);\n    }\n    return;\n  }\n  for (int t = 1; t <= cnt; t++) {\n    a[id] = t;\n    dosth1(id + 1, cnt);\n    a[id] = 0;\n  }\n  a[id] = cnt + 1;\n  dosth1(id + 1, cnt + 1);\n  a[id] = 0;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  if (fopen(\"t.inp\", \"r\")) {\n    freopen(\"test.inp\", \"r\", stdin);\n    freopen(\"test.out\", \"w\", stdout);\n  }\n  cin >> n >> m >> k;\n  for (int i = 1; i <= m; i++) {\n    long long x, y;\n    cin >> x >> y;\n    dd[x][y] = 1;\n    dd[y][x] = 1;\n  }\n  dosth(1);\n  dosth1(1, 0);\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble START_TIME;\nvoid exit() { exit(0); }\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, pair<A, B> p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n  for (int i = 0; i <= (int)v.size() - 1; i++) {\n    os << v[i] << \" \";\n  }\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T> t) {\n  for (auto z : t) {\n    os << z << \" \";\n  }\n  return os;\n}\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& os, map<T1, T2> t) {\n  cerr << endl;\n  for (auto z : t) {\n    os << \"\\t\" << z.first << \" -> \" << z.second << endl;\n  }\n  return os;\n}\nconst int MAX = 12;\nint n, m, k;\nint e[MAX][MAX];\nint who[MAX];\nint d[(1 << 6)][6];\nbool bit(int m, int i) { return ((m >> i) & 1); }\nbool canplace(int x0, int y0, int x1, int y1) {\n  return ((e[x0][x1] && e[y0][y1]) || (e[x0][y1] && e[y0][x1]));\n}\nvector<vector<int>> norm(vector<vector<int>> v) {\n  for (int i = 0; i <= (int)v.size() - 1; i++) {\n    sort(v[i].begin(), v[i].end());\n  }\n  sort(v.begin(), v.end());\n  return v;\n}\nset<vector<vector<int>>> t;\nlong long ans;\nlong long dp[MAX][MAX];\nvoid rec2(vector<vector<int>> state) {\n  if (t.find(state) != t.end()) {\n    return;\n  }\n  t.insert(state);\n  long long ways = dp[(int)state.size()][(int)state.size()];\n  ans += ways;\n  for (int i = 0; i <= (int)state.size() - 1; i++) {\n    for (int j = i + 1; j <= (int)state.size() - 1; j++) {\n      vector<vector<int>> newstate;\n      for (int o = 0; o <= (int)state.size() - 1; o++) {\n        if (o == i || o == j) continue;\n        newstate.push_back(state[o]);\n      }\n      vector<int> vv = state[i];\n      vv.insert(vv.end(), state[j].begin(), state[j].end());\n      newstate.push_back(vv);\n      newstate = norm(newstate);\n      rec2(newstate);\n    }\n  }\n}\nvoid check() {\n  vector<pair<int, int>> vp;\n  for (int i = 0; i <= n - 1; i++) {\n    if (who[i] < i) {\n      vp.push_back(make_pair(who[i], i));\n    }\n  }\n  memset(d, 0, sizeof(d));\n  for (int i = 0; i <= n / 2 - 1; i++) {\n    int x = vp[i].first;\n    int y = vp[i].second;\n    if (e[x][y]) {\n      d[(1 << i)][i] = 1;\n    }\n  }\n  for (int o = 1; o <= (1 << (n / 2)) - 1; o++) {\n    for (int i = 0; i <= n / 2 - 1; i++) {\n      if (d[o][i]) {\n        int x0 = vp[i].first;\n        int y0 = vp[i].second;\n        for (int j = 0; j <= n / 2 - 1; j++) {\n          if (bit(o, j)) continue;\n          int x1 = vp[j].first;\n          int y1 = vp[j].second;\n          if (canplace(x0, y0, x1, y1)) {\n            int o2 = o | (1 << j);\n            int i2 = j;\n            d[o2][i2] = 1;\n          }\n        }\n      }\n    }\n  }\n  bool any = false;\n  for (int i = 0; i <= n / 2 - 1; i++)\n    if (d[(1 << (n / 2)) - 1][i]) any = true;\n  if (any) {\n    vector<vector<int>> state;\n    for (int i = 0; i <= (int)vp.size() - 1; i++) {\n      vector<int> v;\n      v.push_back(vp[i].first);\n      v.push_back(vp[i].second);\n      state.push_back(v);\n    }\n    state = norm(state);\n    rec2(state);\n  }\n}\nvoid rec0(int x) {\n  if (x == n) {\n    check();\n    return;\n  }\n  if (who[x] != -1) {\n    rec0(x + 1);\n    return;\n  }\n  for (int i = 0; i <= n - 1; i++) {\n    if (who[i] == -1 && x != i) {\n      who[i] = x;\n      who[x] = i;\n      rec0(x + 1);\n      who[i] = -1;\n      who[x] = -1;\n    }\n  }\n}\nvoid precalc() {\n  dp[0][0] = 1;\n  for (int i = 0; i <= MAX - 2; i++) {\n    for (int j = 0; j <= MAX - 2; j++) {\n      if (dp[i][j] == 0) continue;\n      dp[i + 1][j] += dp[i][j] * j;\n      dp[i + 1][j + 1] += dp[i][j] * (k - j);\n    }\n  }\n  memset(who, -1, sizeof(who));\n  rec0(0);\n  printf(\"%lld\\n\", ans);\n}\nvoid solve() { precalc(); }\nint main() {\n  scanf(\"%d %d %d\", &n, &m, &k);\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    x--, y--;\n    e[x][y] = e[y][x] = 1;\n  }\n  solve();\n  exit();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int p = 1e9 + 7;\nconst int N = 2e5 + 5;\nint n, m, k, vis[13], e[13][13];\nint rig[11000][13], cnt, tot, pp[7], cho[13];\ninline void check() {\n  memset(cho, 0, sizeof(cho));\n  cnt = 0;\n  for (int i = (1); i <= (n); i++)\n    if (!cho[i]) pp[++cnt] = i, cho[i] = 1, cho[vis[i]] = 1;\n  do {\n    int tag = 1;\n    for (int All = (0); All <= ((1 << (n / 2)) - 1); All++) {\n      if (All == (1 << ((n / 2) - 1))) break;\n      int p1 = pp[1], p2 = vis[pp[1]];\n      tag = 1;\n      if (!e[p1][p2]) {\n        tag = 0;\n        break;\n      }\n      if (All & 1) swap(p1, p2);\n      for (int i = (2); i <= (cnt); i++) {\n        if ((All >> (i - 1)) & 1) {\n          if (e[p1][pp[i]] && e[p2][vis[pp[i]]])\n            p1 = pp[i], p2 = vis[pp[i]];\n          else {\n            tag = 0;\n            break;\n          }\n        } else {\n          if (e[p1][vis[pp[i]]] && e[p2][pp[i]])\n            p2 = pp[i], p1 = vis[pp[i]];\n          else {\n            tag = 0;\n            break;\n          }\n        }\n      }\n      if (tag) {\n        tot++;\n        for (int i = (1); i <= (n); i++) rig[tot][i] = vis[i];\n        break;\n      }\n    }\n    if (tag) break;\n  } while (next_permutation(pp + 1, pp + cnt + 1));\n}\ninline void dfs(int x) {\n  if (x > n) return check();\n  if (vis[x]) return dfs(x + 1);\n  for (int i = (x + 1); i <= (n); i++)\n    if (!vis[i]) vis[x] = i, vis[i] = x, dfs(x + 1), vis[i] = 0, vis[x] = 0;\n}\nset<vector<vector<int> > > s;\nvector<vector<int> > vvec;\nvector<int> vec;\nint S[13], idi, mn[13];\nlong long ans, xj[13];\nvector<int> pos[13];\ninline void Dfs(int x, int mx) {\n  if (x > cnt) {\n    vvec.clear();\n    for (int i = (1); i <= (mx); i++) {\n      vec.clear();\n      for (int Pos : pos[i])\n        vec.emplace_back(Pos), vec.emplace_back(rig[idi][Pos]);\n      sort(vec.begin(), vec.end());\n      vvec.emplace_back(vec);\n    }\n    s.insert(vvec);\n    return;\n  }\n  for (int i = (1); i <= (mx + 1); i++) {\n    pos[i].emplace_back(S[x]);\n    Dfs(x + 1, max(mx, i));\n    pos[i].pop_back();\n  }\n}\ninline void solve() {\n  scanf(\"%d %d %d\", &n, &m, &k);\n  for (int i = (1); i <= (m); i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    e[a][b] = e[b][a] = 1;\n  }\n  xj[0] = 1;\n  for (int i = (1); i <= (k); i++) xj[i] = 1ll * xj[i - 1] * (k - i + 1);\n  dfs(1);\n  for (int i = (1); i <= (tot); i++) {\n    cnt = 0;\n    idi = i;\n    for (int j = (1); j <= (n); j++)\n      if (rig[i][j] > j) S[++cnt] = j;\n    Dfs(1, 0);\n  }\n  for (auto v : s) ans += xj[v.size()];\n  printf(\"%lld\\n\", ans);\n}\nint main() { solve(); }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 15;\nconst int M = 11005;\nconst int mo1 = 317503;\nconst int mo2 = 1000000007;\nconst int BAS = 2333;\nconst int P = 3000005;\nint n, m, k, Hash[N], bel[N], tot, matching[M][N][2], temp_matching[N][2],\n    bin[N];\nlong long ans, jc[N];\nvector<int> e[N];\nint ls[mo1], nx[P], key[P], tot_hash;\nbool vis[N], trans[N][N][N][N], f[5005][N];\nvoid add_hash(int *Hash) {\n  int h1 = 0, h2 = 0;\n  for (int i = 1; i <= n; i++) {\n    h1 = ((long long)h1 * BAS + Hash[i]) % mo1;\n    h2 = ((long long)h2 * BAS + Hash[i]) % mo2;\n  }\n  for (int i = ls[h1]; i; i = nx[i])\n    if (key[i] == h2) return;\n  key[++tot_hash] = h2;\n  nx[tot_hash] = ls[h1];\n  ls[h1] = tot_hash;\n}\nbool find_hash(int *Hash) {\n  int h1 = 0, h2 = 0;\n  for (int i = 1; i <= n; i++) {\n    h1 = ((long long)h1 * BAS + Hash[i]) % mo1;\n    h2 = ((long long)h2 * BAS + Hash[i]) % mo2;\n  }\n  for (int i = ls[h1]; i; i = nx[i])\n    if (key[i] == h2) return 1;\n  return 0;\n}\nvoid dfs_matching(int x) {\n  if (x > n / 2) {\n    tot++;\n    for (int i = 1; i <= n / 2; i++) {\n      matching[tot][i][0] = temp_matching[i][0];\n      matching[tot][i][1] = temp_matching[i][1];\n    }\n    return;\n  }\n  int u;\n  for (int i = 1; i <= n; i++)\n    if (!vis[i]) {\n      u = i;\n      vis[i] = 1;\n      break;\n    }\n  temp_matching[x][0] = u;\n  for (int j = u + 1; j <= n; j++)\n    if (!vis[j]) {\n      temp_matching[x][1] = j;\n      vis[j] = 1;\n      dfs_matching(x + 1);\n      vis[j] = 0;\n    }\n  vis[u] = 0;\n}\nvoid dfs_half_divide(int x, int y, int id) {\n  if (x > n / 2) {\n    for (int i = 1; i <= n / 2; i++)\n      Hash[matching[id][i][0]] = Hash[matching[id][i][1]] = bel[i];\n    add_hash(Hash);\n    return;\n  }\n  for (int i = 1; i <= y; i++) {\n    bel[x] = i;\n    dfs_half_divide(x + 1, y, id);\n  }\n  bel[x] = y + 1;\n  dfs_half_divide(x + 1, y + 1, id);\n}\nvoid dfs_divide(int x, int y) {\n  if (x > n) {\n    for (int i = 1; i <= n; i++) Hash[i] = bel[i];\n    if (find_hash(Hash) && y <= k) ans += jc[k] / jc[k - y];\n    return;\n  }\n  for (int i = 1; i <= y; i++) {\n    bel[x] = i;\n    dfs_divide(x + 1, y);\n  }\n  bel[x] = y + 1;\n  dfs_divide(x + 1, y + 1);\n}\nvoid pre_matching() {\n  bin[0] = 1;\n  for (int i = 1; i <= n; i++) bin[i] = bin[i - 1] * 2;\n  for (int u = 1; u <= n; u++)\n    for (int v = 1; v <= n; v++)\n      for (int i : e[u])\n        for (int j : e[v]) trans[u][v][i][j] = 1;\n  for (int i = 1; i <= tot; i++) {\n    memset(f, 0, sizeof(f));\n    for (int j = 1; j <= n / 2; j++) f[bin[j - 1]][j] = 1;\n    for (int j = 1; j < bin[n / 2] - 1; j++)\n      for (int k = 1; k <= n / 2; k++) {\n        int u = matching[i][k][0], v = matching[i][k][1];\n        if (f[j][k]) {\n          for (int l = 1; l <= n / 2; l++)\n            if (!(j & bin[l - 1])) {\n              int p = matching[i][l][0], q = matching[i][l][1];\n              f[j + bin[l - 1]][l] |= trans[u][v][p][q] | trans[u][v][q][p];\n            }\n        }\n      }\n    bool tag = 0;\n    for (int j = 1; j <= n / 2; j++) {\n      int u = matching[i][j][0], v = matching[i][j][1];\n      tag |= f[bin[n / 2] - 1][j] & trans[u][v][v][u];\n    }\n    if (tag) dfs_half_divide(1, 0, i);\n  }\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    e[x].push_back(y);\n    e[y].push_back(x);\n  }\n  jc[0] = 1;\n  for (int i = 1; i <= k; i++) jc[i] = jc[i - 1] * i;\n  dfs_matching(1);\n  pre_matching();\n  dfs_divide(1, 0);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint mp[13][13];\nvector<pair<int, int> > save;\nint vis[13];\nstruct _ {\n  int a[7];\n} null;\nvector<_> v[7];\nint n, m, k;\nvector<pair<int, int> > check[105];\nvector<pair<int, int> > sorts[105];\nint cl[105];\nint sv[105], nn;\nset<long long> st[105];\nint cg[1005][6], nown, lastn;\nint stute[105][1005];\nbool flag;\nvoid add() {\n  int cnt = 0;\n  long long hnum;\n  if (flag == 0) {\n    for (auto a : v[n / 2]) {\n      for (int k = 0; k < nown; k++) {\n        nn = 0;\n        for (int p = 0; p < (n >> 1); p++) {\n          sv[nn++] = save[cg[k][p] - 1].first;\n          sv[nn++] = save[cg[k][p] - 1].second;\n        }\n        for (auto pr : sorts[cnt]) {\n          for (int l = pr.first; l < pr.second; l += 2)\n            for (int r = l + 2; r < pr.second; r += 2)\n              if (sv[l] > sv[r]) {\n                stute[cnt][k] = 1;\n                goto nexts;\n              }\n          sort(sv + pr.first, sv + pr.second);\n        }\n        for (auto pr : check[cnt]) {\n          if (sv[pr.first] > sv[pr.second]) {\n            stute[cnt][k] = 1;\n            goto nexts;\n          }\n        }\n        hnum = 0;\n        for (int i = 0; i < nn; i++) hnum += (((long long)sv[i]) << (i << 2));\n        st[cnt].insert(hnum);\n      nexts:;\n      }\n      cnt++;\n    }\n    flag = 1;\n  }\n  for (auto a : v[n / 2]) {\n    for (int k = 0; k < nown; k++)\n      if (stute[cnt][k] == 0) {\n        nn = 0;\n        for (int p = 0; p < (n >> 1); p++) {\n          sv[nn++] = save[cg[k][p] - 1].first;\n          sv[nn++] = save[cg[k][p] - 1].second;\n        }\n        for (auto pr : sorts[cnt]) {\n          sort(sv + pr.first, sv + pr.second);\n        }\n        for (auto pr : check[cnt]) {\n          if (sv[pr.first] > sv[pr.second]) goto ne;\n        }\n        hnum = 0;\n        for (int i = 0; i < nn; i++) hnum += (((long long)sv[i]) << (i << 2));\n        st[cnt].insert(hnum);\n      ne:;\n      }\n    cnt++;\n  }\n}\nint dp[6][6][64];\nvoid dfs(int bg, int j, int k) {\n  dp[bg][j][k] = 1;\n  for (int i = 0; i < (n >> 1); i++)\n    if ((k & (1 << i)) == 0 && ((mp[save[i].first][save[j].first] == 1 &&\n                                 mp[save[i].second][save[j].second] == 1) ||\n                                (mp[save[i].first][save[j].second] == 1 &&\n                                 mp[save[i].second][save[j].first] == 1))) {\n      dfs(bg, i, k ^ (1 << i));\n    }\n}\nvoid solve() {\n  for (int i = 0; i < 6; i++)\n    for (int j = 0; j < 6; j++)\n      for (int k = 0; k < 64; k++) dp[i][j][k] = 0;\n  for (int i = 0; i < n / 2; i++)\n    if (mp[save[i].first][save[i].second]) {\n      dfs(i, i, 1 << i);\n    }\n  for (int i = 0; i < 6; i++)\n    for (int j = 0; j < 6; j++) {\n      if (dp[i][j][(1 << (n / 2)) - 1]) {\n        add();\n        return;\n      }\n    }\n}\nint main() {\n  v[0].push_back(null);\n  for (int i = 1; i <= 6; i++) {\n    for (int j = 6; j >= 0; j--) {\n      for (int num = 1; i * num <= 6; num++) {\n        if (j + i * num > 6) continue;\n        for (auto a : v[j]) {\n          a.a[i] = num;\n          v[j + i * num].push_back(a);\n        }\n      }\n    }\n  }\n  cin >> n >> m >> k;\n  for (int i = 1; i <= 6; i++) {\n    cg[0][i - 1] = i;\n  }\n  nown++;\n  for (int i = 0; i < n / 2; i++) {\n    lastn = nown;\n    for (int num = 0; num < lastn; num++)\n      for (int j = i + 1; j < n / 2; j++) {\n        for (int k = 0; k < 6; k++) {\n          cg[nown][k] = cg[num][k];\n        }\n        swap(cg[nown][i], cg[nown][j]);\n        nown++;\n      }\n  }\n  int cnt = 0;\n  for (auto a : v[n / 2]) {\n    int now = 0;\n    for (int k = 1; k <= 6; k++)\n      if (a.a[k]) {\n        for (int i = 0; i < a.a[k]; i++)\n          for (int j = i + 1; j < a.a[k]; j++) {\n            check[cnt].push_back(make_pair(now + i * k * 2, now + j * k * 2));\n          }\n        for (int i = 0; i < a.a[k]; i++) {\n          sorts[cnt].push_back(make_pair(now, now + k * 2));\n          now += k * 2;\n          cl[cnt]++;\n        }\n      }\n    cnt++;\n  }\n  while (m--) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    mp[a][b] = mp[b][a] = 1;\n  }\n  int cs[6], now = n - 1, nn = 0;\n  while (now != -1) {\n    cs[nn++] = now;\n    now -= 2;\n  }\n  for (int p[6] = {0};; p[0]++) {\n    now = 0;\n    while (now < nn && p[now] >= cs[now]) {\n      p[now] -= cs[now];\n      p[++now]++;\n    }\n    if (now == nn) break;\n    int l = 1, r;\n    now = 0;\n    while (1) {\n      if (now == nn) break;\n      while (1) {\n        if (vis[l] == 0) break;\n        l++;\n      }\n      r = l + 1;\n      int num = p[now];\n      while (1) {\n        if (vis[r] == 0) {\n          if (num == 0)\n            break;\n          else\n            num--;\n        }\n        r++;\n      }\n      now++;\n      vis[l] = vis[r] = 1;\n      save.push_back(make_pair(l, r));\n    }\n    solve();\n    for (int i = 0; i <= n; i++) vis[i] = 0;\n    save.clear();\n  }\n  long long sans[15] = {0};\n  sans[1] = k;\n  for (int i = 2; i <= k; i++) {\n    sans[i] = sans[i - 1] * (k - i + 1);\n  }\n  long long ans = 0;\n  cnt = 0;\n  for (auto a : v[n / 2]) {\n    ans += sans[cl[cnt]] * st[cnt].size();\n    cnt++;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 15, M = 1e5 + 5;\nint n, m, p[N];\nbool mt[N][N], fg[N], pd[M];\nbool mp[N][N], f[1 << 6][N];\nint a[N], b[N];\nbool dp() {\n  memset(f, 0, sizeof(f));\n  for (int i = 1; i <= n; i++)\n    if (mt[a[i]][b[i]]) f[1 << (i - 1)][i] = 1;\n  for (int i = 0; i < (1 << n); i++)\n    for (int j = 1; j <= n; j++)\n      if (f[i][j]) {\n        for (int k = 1; k <= n; k++)\n          if (!(i & (1 << (k - 1))) && mp[j][k]) f[i + (1 << (k - 1))][k] = 1;\n      }\n  for (int i = 1; i <= n; i++)\n    if (f[(1 << n) - 1][i]) return 1;\n  return 0;\n}\nvoid d1(int d, int s) {\n  if (d > n) {\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= n; j++) {\n        mp[i][j] = ((mt[a[i]][a[j]] && mt[b[i]][b[j]]) ||\n                    (mt[a[i]][b[j]] && mt[b[i]][a[j]]));\n      }\n    }\n    pd[s] = dp();\n    return;\n  }\n  int t = -1, tp[N];\n  for (int i = 1; i <= n + n; i++)\n    if (!fg[i]) tp[++t] = i;\n  fg[tp[0]] = 1;\n  a[d] = tp[0];\n  for (int i = 1; i <= t; i++)\n    fg[tp[i]] = 1, b[d] = tp[i], d1(d + 1, s * p[d] + i - 1), fg[tp[i]] = 0;\n  fg[tp[0]] = 0;\n}\nint c[N];\nbool d3(int d, int s) {\n  if (d > 1) {\n  }\n  if (d > n) {\n    return pd[s];\n  }\n  int t = -1, tp[N];\n  for (int i = 1; i <= n + n; i++)\n    if (!fg[i]) tp[++t] = i;\n  fg[tp[0]] = 1;\n  a[d] = tp[0];\n  for (int i = 1; i <= t; i++)\n    if (c[tp[i]] == c[tp[0]]) {\n      fg[tp[i]] = 1, b[d] = tp[i];\n      if (d3(d + 1, s * p[d] + i - 1)) {\n        fg[tp[i]] = fg[tp[0]] = 0;\n        return 1;\n      }\n      fg[tp[i]] = 0;\n    }\n  fg[tp[0]] = 0;\n  return 0;\n}\nlong long A[N][N], ans;\nvoid d2(int d, int mx) {\n  if (d > n + n) {\n    memset(fg, 0, sizeof(fg));\n    if (d3(1, 0)) {\n      ans += A[m][mx];\n    }\n    return;\n  }\n  for (int i = 1; i <= mx; i++) c[d] = i, d2(d + 1, mx);\n  if (mx < m) c[d] = mx + 1, d2(d + 1, mx + 1);\n}\nint main() {\n  int T;\n  cin >> n >> T >> m;\n  A[0][0] = 1;\n  for (int i = 1; i <= m; i++) {\n    A[i][0] = 1;\n    for (int j = 1; j <= i; j++) A[i][j] = A[i - 1][j - 1] * j + A[i - 1][j];\n  }\n  n >>= 1;\n  for (int u, v, i = 1; i <= T; i++)\n    scanf(\"%d%d\", &u, &v), mt[u][v] = mt[v][u] = 1;\n  for (int i = 1; i <= n; i++) p[i] = (n - i) * 2 + 1;\n  d1(1, 0);\n  d2(1, 0);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, m, K;\nbool adj[15][15];\nstd::set<std::vector<int> > ans;\nint p2[15][2];\nint col[15];\nvoid dfs1(int id, int max) {\n  if (id == n / 2) {\n    static int last[15];\n    for (int i = 0; i < (int)(n); ++i) last[i] = -1;\n    int cnt = 0;\n    for (int i = 0; i < (int)(n); ++i)\n      if (last[col[i]] == -1) last[col[i]] = cnt++;\n    std::vector<int> ovo(n);\n    for (int i = 0; i < (int)(n); ++i) ovo[i] = last[col[i]];\n    ans.insert(ovo);\n    return;\n  }\n  for (int c = 0; c < (int)(max + 1); ++c) {\n    col[p2[id][0]] = col[p2[id][1]] = c;\n    dfs1(id + 1, std::max(c + 1, max));\n  }\n}\nbool check() {\n  static bool dp[1 << 6][10];\n  memset(dp, 0, sizeof(dp));\n  for (int i = 0; i < (int)(n / 2); ++i)\n    if (adj[p2[i][0]][p2[i][1]]) dp[1 << i][i] = true;\n  for (int mask = 0; mask < (int)(1 << (n / 2)); ++mask)\n    for (int cur = 0; cur < (int)(n / 2); ++cur)\n      if (mask >> cur & 1) {\n        int nmask = mask ^ 1 << cur;\n        if (nmask) {\n          for (int last = 0; last < (int)(n / 2); ++last)\n            if (nmask >> last & 1) {\n              if ((adj[p2[cur][0]][p2[last][0]] &&\n                   adj[p2[last][1]][p2[cur][1]]) ||\n                  (adj[p2[cur][0]][p2[last][1]] &&\n                   adj[p2[last][0]][p2[cur][1]])) {\n                dp[mask][cur] |= dp[nmask][last];\n              }\n            }\n        }\n      }\n  for (int i = 0; i < (int)(n / 2); ++i)\n    if (dp[(1 << (n / 2)) - 1][i]) return true;\n  return false;\n}\nvoid dfs0(int mask, int id) {\n  if (!mask) {\n    for (int i = 0; i < (int)(n / 2); ++i) col[p2[i][0]] = col[p2[i][1]] = i;\n    if (check()) dfs1(0, 0);\n    return;\n  }\n  int u = __builtin_ctz(mask);\n  int nmask = mask ^ 1 << u;\n  for (int v = 0; v < (int)(n); ++v)\n    if (nmask >> v & 1) {\n      p2[id][0] = u, p2[id][1] = v;\n      dfs0(nmask ^ 1 << v, id + 1);\n    }\n}\nint main() {\n  scanf(\"%d %d %d\", &n, &m, &K);\n  for (int i = 0; i < (int)(m); ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    --u, --v;\n    adj[u][v] = adj[v][u] = true;\n  }\n  dfs0((1 << n) - 1, 0);\n  static int f[15];\n  for (int i = 0; i < (int)(n + 1); ++i) f[i] = 0;\n  for (auto s : ans) {\n    int mx = 0;\n    for (int i = 0; i < (int)(s.size()); ++i) mx = std::max(mx, s[i] + 1);\n    ++f[mx];\n  }\n  long long ans = 0;\n  for (int i = 0; i < (int)(n + 1); ++i)\n    if (f[i]) {\n      long long cur = 1;\n      for (int x = K; x > K - i; --x) cur = 1LL * cur * x;\n      ans += cur * f[i];\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 15;\nlong long ans;\nint n, m, K, adj[N][N], a[N], b[N], cnt;\nbool vis[N], f[1 << 6][7];\nmap<long long, int> mp;\nqueue<long long> q;\nvector<int> id;\nvoid solve_() {\n  if (n == 2) {\n    if (adj[1][2]) {\n      long long s = 0;\n      for (int j = 0; j < n; j++) s |= (min(a[j + 1], b[j + 1])) << 4 * j;\n      mp[s] = 1, q.push(s);\n    }\n    return;\n  }\n  memset(f, 0, sizeof(f));\n  for (int i = 1; i <= cnt; i++) f[1 << i - 1][i] = 1;\n  for (int i = 0; i < (1 << cnt); i++)\n    for (int j = 1; j <= cnt; j++)\n      if (f[i][j]) {\n        for (int k = 1; k <= cnt; k++)\n          if (!(i & (1 << k - 1))) {\n            if ((i | (1 << k - 1)) != (1 << cnt) - 1 || adj[a[k]][b[k]]) {\n              if (adj[a[k]][a[j]] && adj[b[k]][b[j]])\n                f[i | (1 << k - 1)][k] = 1;\n              if (adj[a[k]][b[j]] && adj[b[k]][a[j]])\n                f[i | (1 << k - 1)][k] = 1;\n            }\n          }\n      }\n  for (int i = 1; i <= cnt; i++)\n    if (f[(1 << cnt) - 1][i]) {\n      long long s = 0;\n      for (int j = 1; j <= cnt; j++)\n        s |= min(a[j], b[j]) *\n             ((1ll << 4 * (a[j] - 1)) + (1ll << 4 * (b[j] - 1)));\n      mp[s] = 1, q.push(s);\n      return;\n    }\n}\nvoid dfs_() {\n  if (cnt == n / 2) {\n    solve_();\n    return;\n  }\n  for (int i = 1; i <= n; i++)\n    if (!vis[i]) {\n      vis[i] = 1, cnt++, a[cnt] = i;\n      for (int j = i + 1; j <= n; j++)\n        if (!vis[j]) {\n          vis[j] = 1;\n          b[cnt] = j;\n          dfs_();\n          vis[j] = 0;\n        }\n      cnt--, vis[i] = 0;\n      return;\n    }\n}\nlong long merge_(long long s, int x, int y) {\n  if (x > y) swap(x, y);\n  for (int i = 0; i < n; i++)\n    if (((s >> i * 4) & 15) == y) s += (x - y) * (1ll << 4 * i);\n  return s;\n}\nvoid init_(long long s) {\n  id.clear();\n  for (int i = 0; i < n; i++)\n    if (((s >> 4 * i) & 15) == i + 1) id.push_back(i + 1);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &K);\n  for (int u, v, i = 1; i <= m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    adj[u][v] = adj[v][u] = 1;\n  }\n  dfs_();\n  while (!q.empty()) {\n    long long u = q.front();\n    q.pop();\n    init_(u);\n    if (id.size() <= K) {\n      long long res = 1;\n      for (int i = K - id.size() + 1; i <= K; i++) res *= i;\n      ans += res;\n    }\n    for (int i = 1; i < (int)id.size(); i++)\n      for (int j = 0; j < i; j++) {\n        long long v = merge_(u, id[j], id[i]);\n        if (!mp.count(v)) mp[v] = 1, q.push(v);\n      }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng((int)chrono::steady_clock::now().time_since_epoch().count());\nint qtd[12];\nbool adj[15][15];\nbool check(string &s) {\n  vector<int> ord(s.size());\n  for (int i = 0; i < (int)s.size(); i++) {\n    ord[i] = i;\n  }\n  sort(ord.begin(), ord.end(), [&](int a, int b) { return s[a] < s[b]; });\n  for (int i = 0; i < (int)s.size(); i += 2) {\n    if (i + 2 == (int)s.size()) {\n      if (!adj[ord[i]][ord[i + 1]]) return false;\n    } else {\n      int a = ord[i];\n      int b = ord[i + 1];\n      int c = ord[i + 2];\n      int d = ord[i + 3];\n      if (!((adj[a][c] && adj[b][d]) || (adj[a][d] && adj[b][c]))) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nstring normalize(string s) {\n  vector<int> ord(7, 0);\n  for (int i = 0, cnt = 0; i < (int)s.size(); i++) {\n    if (!ord[s[i] - '0']) ord[s[i] - '0'] = ++cnt;\n    s[i] = char('0' + ord[s[i] - '0']);\n  }\n  return s;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a - 1][b - 1] = adj[b - 1][a - 1] = true;\n  }\n  string s;\n  for (int i = 1; i <= n / 2; i++) {\n    s.push_back(char('0' + i));\n    s.push_back(char('0' + i));\n  }\n  set<string> vis;\n  queue<string> q;\n  do {\n    if (check(s)) {\n      string ns = normalize(s);\n      if (!vis.count(ns)) {\n        q.push(ns);\n        vis.insert(ns);\n      }\n    }\n  } while (next_permutation(s.begin(), s.end()));\n  while (!q.empty()) {\n    s = q.front();\n    q.pop();\n    char mx = '0';\n    for (int i = 0; i < (int)s.size(); i++) {\n      mx = max(mx, s[i]);\n    }\n    qtd[mx - '0']++;\n    string aux = s;\n    for (char i = '1'; i <= mx; i++) {\n      for (char j = char(i + 1); j <= mx; j++) {\n        for (int l = 0; l < (int)s.size(); l++) {\n          aux[l] = (s[l] == j ? i : (s[l] > j ? char(s[l] - 1) : s[l]));\n        }\n        if (!vis.count(aux)) {\n          q.push(aux);\n          vis.insert(aux);\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n / 2; i++) {\n    long long cost = 1;\n    for (int j = k; j >= k - i + 1; j--) {\n      cost *= j;\n    }\n    ans += qtd[i] * cost;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 12;\nbitset<maxn> g[maxn];\nmap<long long, bool> vis;\nint n, m, k, n2;\nvoid dfs(int cur, vector<int>& a) {\n  int id = find(a.begin(), a.end(), -1) - a.begin();\n  if (id == n) {\n    vector<int> pos1(n2, 0), pos2(n2, 0);\n    vector<bitset<6>> dp(1 << n2);\n    for (int i = 0; i < n; ++i) {\n      pos1[a[i]] = pos2[a[i]];\n      pos2[a[i]] = i;\n    }\n    for (int i = 0; i < n2; ++i)\n      if (g[pos1[i]][pos2[i]]) dp[1 << i][i] = true;\n    for (int i = 0; i < (1 << n2); ++i) {\n      for (int j = 0; j < n2; ++j) {\n        if (!dp[i][j]) continue;\n        for (int k = 0; k < n2; ++k) {\n          if ((i >> k) & 1) continue;\n          dp[i | (1 << k)][k] =\n              dp[i | (1 << k)][k] |\n              (g[pos1[j]][pos1[k]] > 0 && g[pos2[j]][pos2[k]] > 0 ||\n               g[pos1[j]][pos2[k]] > 0 && g[pos2[j]][pos1[k]] > 0);\n          ;\n        }\n      }\n    }\n    for (int i = 0; i < n2; ++i) {\n      if (dp[(1 << n2) - 1][i]) {\n        long long num = 0;\n        for (int j = 0; j < n; ++j) {\n          num = num * 6 + a[j];\n        }\n        vis[num] = true;\n        break;\n      }\n    }\n    return;\n  }\n  for (int i = id + 1; i < n; ++i) {\n    if (a[i] != -1) continue;\n    a[i] = a[id] = cur;\n    dfs(cur + 1, a);\n    a[i] = a[id] = -1;\n  }\n}\nbool dfs3(vector<int>& a) {\n  vector<int> mp(n2, -1), cnt(n2, 0);\n  int tot = 0;\n  long long num = 0;\n  for (int i = 0; i < n; ++i) {\n    if (mp[a[i]] == -1) mp[a[i]] = tot++;\n    num = num * 6 + mp[a[i]];\n    cnt[a[i]]++;\n  }\n  if (vis.count(num)) return vis[num];\n  for (int i = 0; i < n; ++i) {\n    if (cnt[a[i]] < 4) continue;\n    int x = a[i];\n    for (int j = i + 1; j < n; ++j) {\n      if (a[j] == a[i]) {\n        a[i] = a[j] = tot;\n        if (dfs3(a)) {\n          a[i] = a[j] = x;\n          return vis[num] = true;\n        }\n        a[i] = a[j] = x;\n      }\n    }\n    break;\n  }\n  return vis[num] = false;\n}\nvoid dfs2(int cur, vector<int>& a) {\n  int id = find(a.begin(), a.end(), -1) - a.begin();\n  if (id == n) {\n    dfs3(a);\n    return;\n  }\n  for (int i = 0; i <= cur; ++i) {\n    for (int j = id + 1; j < n; ++j) {\n      if (a[j] != -1) continue;\n      a[id] = a[j] = i;\n      dfs2(max(cur, i + 1), a);\n      a[id] = a[j] = -1;\n    }\n  }\n}\nlong long fact[maxn + 2];\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  n2 = n >> 1;\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u--, v--;\n    g[u][v] = g[v][u] = 1;\n  }\n  vector<int> a(n, -1);\n  dfs(0, a);\n  dfs2(0, a);\n  long long ans = 0;\n  fact[0] = 1;\n  for (int i = 1; i <= maxn; ++i) fact[i] = fact[i - 1] * i;\n  for (map<long long, bool>::iterator it = vis.begin(); it != vis.end(); ++it) {\n    if (it->second == false) continue;\n    int mx = 0;\n    long long num = it->first;\n    while (num) {\n      mx = max(1ll * mx, num % 6);\n      num /= 6;\n    }\n    if (mx < k) {\n      ans += fact[k] / fact[k - mx - 1];\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 12;\nlong long read() {\n  long long x = 0, f = 1;\n  char c;\n  while ((c = getchar()) < '0' || c > '9') {\n    if (c == '-') f = -1;\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 3) + (x << 1) + (c ^ 48);\n    c = getchar();\n  }\n  return x * f;\n}\nlong long n, m, k, ans, g[M][M], a[M], p[M], fac[M];\nmap<long long, bool> dp;\nvoid init(long long nc) {\n  long long x = n;\n  for (long long i = 0; i < n; i++)\n    if (p[i] == -1) {\n      x = i;\n      break;\n    }\n  if (x == n) {\n    long long f[1 << 6][M] = {}, p1[M] = {}, p2[M] = {};\n    for (long long i = 0; i < n; i++) {\n      p2[p[i]] = p1[p[i]];\n      p1[p[i]] = i;\n    }\n    for (long long i = 0; i < nc; i++)\n      if (g[p1[i]][p2[i]]) f[1 << i][i] = 1;\n    for (long long i = 0; i < (1 << nc); i++)\n      for (long long j = 0; j < nc; j++)\n        if (f[i][j])\n          for (long long k = 0; k < nc; k++) {\n            if (i & (1 << k)) continue;\n            f[i | (1 << k)][k] |= (g[p1[k]][p1[j]] && g[p2[k]][p2[j]]);\n            f[i | (1 << k)][k] |= (g[p1[k]][p2[j]] && g[p2[k]][p1[j]]);\n          }\n    for (long long i = 0; i < nc; i++)\n      if (f[(1 << nc) - 1][i]) {\n        long long num = 0;\n        for (long long j = 0; j < n; j++) num = num * 6 + p[j];\n        dp[num] = 1;\n        break;\n      }\n    return;\n  }\n  for (long long i = x + 1; i < n; i++)\n    if (p[i] == -1) {\n      p[x] = p[i] = nc;\n      init(nc + 1);\n      p[x] = p[i] = -1;\n    }\n}\nlong long dfs(long long p[]) {\n  long long rn[M], cur[M] = {}, t[M] = {}, cnt = 0, num = 0;\n  memset(rn, -1, sizeof rn);\n  for (long long i = 0; i < n; i++)\n    if (rn[p[i]] == -1) rn[p[i]] = cnt++;\n  for (long long i = 0; i < n; i++) {\n    t[i] = rn[p[i]];\n    cur[t[i]]++;\n    num = num * 6 + t[i];\n  }\n  if (dp.count(num)) return dp[num];\n  long long res = 0;\n  for (long long i = 0; i < n && !res; i++)\n    if (cur[t[i]] > 2)\n      for (long long j = i + 1; j < n; j++)\n        if (t[i] == t[j]) {\n          long long tmp = t[i];\n          t[i] = t[j] = cnt;\n          res |= dfs(t);\n          t[i] = t[j] = tmp;\n          if (res) break;\n        }\n  return dp[num] = res;\n}\nvoid zxy(long long nc) {\n  long long x = n;\n  for (long long i = 0; i < n; i++)\n    if (p[i] == -1) {\n      x = i;\n      break;\n    }\n  if (x == n) {\n    dfs(p);\n    return;\n  }\n  for (long long c = 0; c <= nc; c++)\n    for (long long i = x + 1; i < n; i++)\n      if (p[i] == -1) {\n        p[x] = p[i] = c;\n        zxy(max(c + 1, nc));\n        p[x] = p[i] = -1;\n      }\n}\nsigned main() {\n  n = read();\n  m = read();\n  k = read();\n  for (long long i = 1; i <= m; i++) {\n    long long u = read() - 1, v = read() - 1;\n    g[u][v] = g[v][u] = 1;\n  }\n  memset(p, -1, sizeof p);\n  init(0);\n  zxy(0);\n  fac[0] = 1;\n  for (long long i = 1; i <= k; i++) fac[i] = fac[i - 1] * i;\n  for (auto x : dp)\n    if (x.second) {\n      long long num = x.first, mx = 1;\n      while (num) {\n        mx = max(mx, num % 6 + 1);\n        num /= 6;\n      }\n      if (mx <= k) ans += fac[k] / fac[k - mx];\n    }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nvoid sc(int &x) { scanf(\"%d\", &x); }\nvoid sc(int &x, int &y) { scanf(\"%d%d\", &x, &y); }\nvoid sc(int &x, int &y, int &z) { scanf(\"%d%d%d\", &x, &y, &z); }\nvoid sc(long long &x) { scanf(\"%lld\", &x); }\nvoid sc(long long &x, long long &y) { scanf(\"%lld%lld\", &x, &y); }\nvoid sc(long long &x, long long &y, long long &z) {\n  scanf(\"%lld%lld%lld\", &x, &y, &z);\n}\nvoid sc(char *x) { scanf(\"%s\", x); }\nvoid sc(char *x, char *y) { scanf(\"%s%s\", x, y); }\nvoid sc(char *x, char *y, char *z) { scanf(\"%s%s%s\", x, y, z); }\nvoid out(int x) { printf(\"%d\\n\", x); }\nvoid out(long long x) { printf(\"%lld\\n\", x); }\nvoid out(int x, int y) { printf(\"%d %d\\n\", x, y); }\nvoid out(long long x, long long y) { printf(\"%lld %lld\\n\", x, y); }\nvoid out(int x, int y, int z) { printf(\"%d %d %d\\n\", x, y, z); }\nvoid out(long long x, long long y, long long z) {\n  printf(\"%lld %lld %lld\\n\", x, y, z);\n}\nvoid ast(long long x, long long l, long long r) { assert(x >= l && x <= r); }\nusing namespace std;\nconst int N = 5e5 + 5, mod = 998244353;\nint n, m, k;\nlong long f[15], c[15][15];\nbool e[15][15];\nlong long g[15];\nlong long ans;\nlong long st1, st2;\nlong long C(int n, int m) {\n  if (m == 0 || m == n) return 1;\n  if (m == 1) return n;\n  if (c[n][m]) return c[n][m];\n  return c[n][m] = C(n - 1, m - 1) + C(n - 1, m);\n}\nvector<pair<int, int>> vc;\nmap<long long, bool> vis;\nbool judge(vector<pair<int, int>> &vc) {\n  if (vis.count(st1)) return vis[st1];\n  int up = (1 << (vc.size())) - 1;\n  bool dp[up + 1][vc.size()];\n  memset(dp, false, sizeof(dp));\n  for (int i = 0; i < vc.size(); i++) dp[1 << i][i] = true;\n  for (int i = 0; i < up; i++)\n    for (int j = 0; j < vc.size(); j++)\n      if (dp[i][j]) {\n        for (int k = 0; k < vc.size(); k++)\n          if (!(i >> k & 1)) {\n            if (e[vc[k].first][vc[j].first] && e[vc[k].second][vc[j].second] ||\n                e[vc[k].first][vc[j].second] && e[vc[k].second][vc[j].first])\n              dp[i | (1 << k)][k] = true;\n          }\n      }\n  bool ans = false;\n  for (int i = 0; i < vc.size(); i++)\n    if (e[vc[i].first][vc[i].second]) ans |= dp[up][i];\n  return vis[st1] = ans;\n}\nset<long long> ok;\nvoid cal(vector<pair<int, int>> &vc, int mx) {\n  if (judge(vc)) {\n    if (!ok.count(st2)) {\n      ans += C(k, mx + 1) * f[mx + 1];\n      ok.insert(st2);\n    }\n  }\n}\nvoid dfs(int up, int mx) {\n  if (up == 0) {\n    cal(vc, mx);\n    return;\n  }\n  for (int i = 0; i < n; i++)\n    if (up >> i & 1) {\n      for (int j = i + 1; j < n; j++)\n        if (up >> j & 1) {\n          st1 += (i + 1) * g[vc.size() << 1];\n          st1 += (j + 1) * g[vc.size() << 1 | 1];\n          vc.push_back({i + 1, j + 1});\n          int nst = up ^ (1 << i) ^ (1 << j);\n          for (int s = 0; s <= mx + 1 && s < k; s++) {\n            st2 += (s + 1) * g[i];\n            st2 += (s + 1) * g[j];\n            dfs(nst, max(s, mx));\n            st2 -= (s + 1) * g[i];\n            st2 -= (s + 1) * g[j];\n          }\n          vc.pop_back();\n          st1 -= (i + 1) * g[vc.size() << 1];\n          st1 -= (j + 1) * g[vc.size() << 1 | 1];\n        }\n      break;\n    }\n}\nvoid sol(int cas) {\n  f[0] = g[0] = 1;\n  for (int i = 1; i < 15; i++) f[i] = f[i - 1] * i, g[i] = g[i - 1] * 13;\n  sc(n, m, k);\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    sc(x, y);\n    e[x][y] = e[y][x] = true;\n  }\n  int up = (1 << n) - 1;\n  dfs(up, -1);\n  out(ans);\n}\nint main() {\n  srand(time(0));\n  int t = 1, cas = 0;\n  while (t--) {\n    sol(++cas);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconst int N = 13;\nstruct ts {\n  int mask, l, r;\n};\nint n, m, k, step = 0;\nll ans;\nint comp[N], comp_mask[N];\nint cnk[N][N], f[N];\nint g[N];\nbool can_move[N][N];\nint sz[(1 << N)];\nint lst[(1 << N)][N];\nint can[(1 << N)][N][N];\nts q[(1 << N) * N * N];\nvoid init() {\n  f[0] = cnk[0][0] = 1;\n  for (int i = 1; i < N; ++i) {\n    f[i] = f[i - 1] * i;\n    cnk[i][0] = 1;\n    for (int j = 1; j <= i; ++j) {\n      cnk[i][j] = cnk[i - 1][j - 1] + cnk[i - 1][j];\n    }\n  }\n  for (int i = 0; i < (1 << N); ++i) {\n    for (int j = 0; j < N; ++j) {\n      if ((i & (1 << j)) != 0) {\n        lst[i][sz[i]++] = j;\n      }\n    }\n  }\n}\nbool check(int y) {\n  for (int i = 0; i < y; ++i) {\n    comp_mask[i] = 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    comp_mask[comp[i]] |= (1 << i);\n  }\n  for (int i = 0; i < y; ++i) {\n    assert(sz[comp_mask[i]] > 0);\n    if (sz[comp_mask[i]] % 2 != 0) {\n      return false;\n    }\n  }\n  for (int i = 0; i < y; ++i) {\n    bool found = false;\n    for (int ll = 0; ll < sz[comp_mask[i]]; ++ll) {\n      for (int rr = ll + 1; rr < sz[comp_mask[i]]; ++rr) {\n        if (can_move[lst[comp_mask[i]][ll]][lst[comp_mask[i]][rr]]) {\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n  ++step;\n  int qr = 0;\n  for (int i = 0; i < n; ++i) {\n    int msk = ((1 << n) - 1) ^ (1 << i);\n    msk &= comp_mask[comp[i]];\n    msk &= g[i];\n    for (int jj = 0; jj < sz[msk]; ++jj) {\n      if (n == 2) {\n        return true;\n      }\n      int j = lst[msk][jj];\n      if (can[(1 << i) | (1 << j)][i][j] != step) {\n        can[(1 << i) | (1 << j)][i][j] = step;\n        q[qr++] = {((1 << i) | (1 << j)), i, j};\n      }\n    }\n  }\n  while (qr > 0) {\n    ts s = q[--qr];\n    int left_neigs = (((1 << n) - 1) ^ s.mask) & g[s.l];\n    for (int ii = 0; ii < sz[left_neigs]; ++ii) {\n      int i = lst[left_neigs][ii];\n      int right_neigs = (((1 << n) - 1) ^ s.mask ^ (1 << i)) & g[s.r];\n      right_neigs &= comp_mask[comp[i]];\n      for (int jj = 0; jj < sz[right_neigs]; ++jj) {\n        int j = lst[right_neigs][jj];\n        if (can[s.mask | (1 << i) | (1 << j)][i][j] != step) {\n          can[s.mask | (1 << i) | (1 << j)][i][j] = step;\n          q[qr++] = {(s.mask | (1 << i) | (1 << j)), i, j};\n          if (q[qr - 1].mask == ((1 << n) - 1)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nvoid gen(int x, int y) {\n  if (x >= n) {\n    if (check(y)) {\n      ans += cnk[k][y] * f[y];\n    }\n    return;\n  }\n  for (int i = 0; i < y; ++i) {\n    comp[x] = i;\n    gen(x + 1, y);\n  }\n  if (y + 1 <= min(n / 2, k)) {\n    comp[x] = y;\n    gen(x + 1, y + 1);\n  }\n}\nvoid solve() {\n  scanf(\"%d %d %d\", &n, &m, &k);\n  for (int i = 0; i < n; ++i) {\n    g[i] = 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      can_move[i][j] = false;\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a;\n    --b;\n    g[a] |= (1 << b);\n    g[b] |= (1 << a);\n    can_move[a][b] = can_move[b][a] = true;\n  }\n  for (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        can_move[i][j] |= (can_move[i][k] & can_move[k][j]);\n      }\n    }\n  }\n  ans = 0;\n  gen(0, 0);\n  cout << ans << endl;\n}\nint main() {\n  init();\n  int t = 1;\n  for (int i = 0; i < t; ++i) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconst int N = 13;\nstruct ts {\n  int mask, l, r;\n};\nint n, m, k, step = 0;\nll ans;\nint comp[N], comp_mask[N];\nint cnk[N][N], f[N];\nint g[N];\nbool can_move[N][N];\nint sz[(1 << N)];\nint lst[(1 << N)][N];\nint used[(1 << N)][N][N];\nbool can[(1 << N)][N][N];\nts q[(1 << N) * N * N];\nvoid init() {\n  f[0] = cnk[0][0] = 1;\n  for (int i = 1; i < N; ++i) {\n    f[i] = f[i - 1] * i;\n    cnk[i][0] = 1;\n    for (int j = 1; j <= i; ++j) {\n      cnk[i][j] = cnk[i - 1][j - 1] + cnk[i - 1][j];\n    }\n  }\n  for (int i = 0; i < (1 << N); ++i) {\n    for (int j = 0; j < N; ++j) {\n      if ((i & (1 << j)) != 0) {\n        lst[i][sz[i]++] = j;\n      }\n    }\n  }\n}\nbool check(int msk, int l, int r) {\n  if (msk == 0) {\n    return (g[l] & (1 << r)) != 0;\n  }\n  if (used[msk][l][r] == step) {\n    return can[msk][l][r];\n  }\n  used[msk][l][r] = step;\n  can[msk][l][r] = false;\n  int left_neigs = msk & g[l];\n  for (int ll = 0; ll < sz[left_neigs]; ++ll) {\n    int nl = lst[left_neigs][ll];\n    int right_neigs = (msk ^ (1 << nl)) & g[r];\n    right_neigs &= comp_mask[comp[nl]];\n    for (int rr = 0; rr < sz[right_neigs]; ++rr) {\n      int nr = lst[right_neigs][rr];\n      if (check((msk ^ (1 << nl) ^ (1 << nr)), nl, nr)) {\n        can[msk][l][r] = true;\n        return true;\n      }\n    }\n  }\n  return false;\n}\nbool check(int y) {\n  for (int i = 0; i < y; ++i) {\n    comp_mask[i] = 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    comp_mask[comp[i]] |= (1 << i);\n  }\n  for (int i = 0; i < y; ++i) {\n    assert(sz[comp_mask[i]] > 0);\n    if (sz[comp_mask[i]] % 2 != 0) {\n      return false;\n    }\n  }\n  for (int i = 0; i < y; ++i) {\n    bool found = false;\n    for (int ll = 0; ll < sz[comp_mask[i]]; ++ll) {\n      for (int rr = ll + 1; rr < sz[comp_mask[i]]; ++rr) {\n        if (can_move[lst[comp_mask[i]][ll]][lst[comp_mask[i]][rr]]) {\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n  ++step;\n  for (int i = 0; i < y; ++i) {\n    for (int ll = 0; ll < sz[comp_mask[i]]; ++ll) {\n      for (int rr = ll + 1; rr < sz[comp_mask[i]]; ++rr) {\n        int l = lst[comp_mask[i]][ll];\n        int r = lst[comp_mask[i]][rr];\n        if (check((((1 << n) - 1) ^ (1 << l) ^ (1 << r)), l, r)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nvoid gen(int x, int y) {\n  if (x >= n) {\n    if (check(y)) {\n      ans += cnk[k][y] * f[y];\n    }\n    return;\n  }\n  for (int i = 0; i < y; ++i) {\n    comp[x] = i;\n    gen(x + 1, y);\n  }\n  if (y + 1 <= min(n / 2, k)) {\n    comp[x] = y;\n    gen(x + 1, y + 1);\n  }\n}\nvoid solve() {\n  scanf(\"%d %d %d\", &n, &m, &k);\n  for (int i = 0; i < n; ++i) {\n    g[i] = 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      can_move[i][j] = false;\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a;\n    --b;\n    g[a] |= (1 << b);\n    g[b] |= (1 << a);\n    can_move[a][b] = can_move[b][a] = true;\n  }\n  for (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        can_move[i][j] |= (can_move[i][k] & can_move[k][j]);\n      }\n    }\n  }\n  ans = 0;\n  gen(0, 0);\n  cout << ans << endl;\n}\nint main() {\n  init();\n  int t = 1;\n  for (int i = 0; i < t; ++i) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, bl[12];\nbool vis[12], E[12][12];\nlong long ans;\nvector<vector<int> > V, part;\nunordered_set<long long> se;\nvector<int> cur;\nlong long H(vector<int> p) {\n  long long s = 0;\n  for (int i = (0), iend = (n - 1); i <= iend; ++i) s = s * n + p[i];\n  return s;\n}\nvoid dfs0(int now) {\n  if (now == n)\n    part.push_back(cur);\n  else\n    for (int i = (0), iend = (n - 1); i <= iend; ++i)\n      if (!vis[i] && bl[now] == bl[i] && i != now && (i > now || cur[i] == now))\n        cur.push_back(i), vis[i] = 1, dfs0(now + 1), vis[i] = 0, cur.pop_back();\n}\nvoid dfs(int now) {\n  if (now == n) {\n    bool zzh = 1;\n    for (const auto& v : V) zzh &= v.size() % 2 == 0;\n    if (!zzh) return;\n    for (const auto& v : V)\n      for (const auto& x : v) bl[x] = v[0];\n    bool asf = 0;\n    part.clear(), dfs0(0);\n    for (const auto& p : part) {\n      if (se.count(H(p))) {\n        asf = 1;\n        break;\n      }\n    }\n    if (asf) {\n      long long res = 1;\n      for (int i = (1), iend = (V.size()); i <= iend; ++i) res *= k - i + 1;\n      ans += res;\n    }\n    return;\n  }\n  for (int i = (0), iend = (V.size() - 1); i <= iend; ++i)\n    V[i].push_back(now), dfs(now + 1), V[i].pop_back();\n  V.push_back({now}), dfs(now + 1), V.pop_back();\n}\nint main() {\n  cin >> n >> m >> k;\n  while (m--) {\n    int u, v;\n    cin >> u >> v, u--, v--, E[u][v] = E[v][u] = 1;\n  }\n  dfs0(0);\n  for (const auto& p : part) {\n    bool asf = 0;\n    int U[6], V[6], ct = 0;\n    for (int i = (0), iend = (n - 1); i <= iend; ++i)\n      if (i < p[i]) U[ct] = i, V[ct] = p[i], ct++;\n    int q[6];\n    for (int i = (0), iend = (ct - 1); i <= iend; ++i) q[i] = i;\n    do {\n      int x = U[q[0]], y = V[q[0]];\n      bool flg = E[x][y];\n      for (int i = (1), iend = (ct - 1); i <= iend; ++i) {\n        int u = U[q[i]], v = V[q[i]];\n        flg &= (E[x][u] && E[y][v]) || (E[x][v] && E[y][u]);\n        x = u, y = v;\n      }\n      if (flg) {\n        asf = 1;\n        break;\n      }\n    } while (next_permutation(q, q + ct));\n    if (asf) se.insert(H(p));\n  }\n  dfs(0);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, K, C[15][15], fc[8], cnt[15], a[15], tot;\nbool g[15][15];\nint px[10], py[10], N;\nunordered_set<long long> dp;\nvector<pair<int, long long> > all;\nvoid divset(int x) {\n  if (x == n) {\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 0; i < n; i++) cnt[a[i]]++;\n    bool tmp = 1;\n    for (int i = 0; i < tot && tmp; i++) tmp &= (cnt[i] % 2 == 0);\n    if (tmp) {\n      long long state = 0;\n      for (int i = 0; i < n; i++) state = state * 6 + a[i];\n      all.push_back(make_pair(tot, state));\n    }\n    return;\n  }\n  a[x] = tot++;\n  divset(x + 1);\n  --tot;\n  for (int i = 0; i < tot; i++) {\n    a[x] = i;\n    divset(x + 1);\n  }\n}\nbool f[70][7];\nbool check() {\n  memset(f, 0, sizeof(f));\n  for (int i = 0; i < n / 2; i++)\n    if (g[px[i]][py[i]]) f[(1 << i)][i] = 1;\n  for (int i = 1; i < (1 << (n / 2)); i++)\n    for (int j = 0; j < n / 2; j++)\n      if (f[i][j])\n        for (int k = 0; k < n / 2; k++)\n          if (!((1 << k) & i))\n            if ((g[px[j]][px[k]] && g[py[j]][py[k]]) ||\n                (g[px[j]][py[k]] && g[py[j]][px[k]]))\n              f[i | (1 << k)][k] = 1;\n  bool ans = 0;\n  for (int i = 0; i < n / 2 && !ans; i++) ans |= f[(1 << (n / 2)) - 1][i];\n  return ans;\n}\nvoid dfsinit(int mask) {\n  if (mask == 0) {\n    if (check()) {\n      for (int i = 0; i < n / 2; i++) a[px[i]] = a[py[i]] = i;\n      long long state = 0;\n      for (int i = 0; i < n; i++) state = state * 6 + a[i];\n      dp.insert(state);\n    }\n    return;\n  }\n  int x = __builtin_ffs(mask) - 1;\n  px[N] = x, mask ^= (1 << x);\n  for (int y = 0; y < n; y++)\n    if ((1 << y) & mask) {\n      py[N++] = y;\n      dfsinit(mask ^ (1 << y));\n      N--;\n    }\n}\nlong long ans;\nint b[15];\nvoid trans(long long mask, int x, int y) {\n  for (int i = n - 1; ~i; i--) {\n    a[i] = mask % 6, mask /= 6;\n    if (a[i] == y) a[i] = x;\n  }\n  memset(b, -1, sizeof(b)), N = 0;\n  long long state = 0;\n  for (int i = 0; i < n; i++) {\n    if (b[a[i]] < 0) b[a[i]] = N++;\n    state = state * 6 + b[a[i]];\n  }\n  dp.insert(state);\n}\nint main() {\n  for (int i = 0; i < 15; C[i][0] = 1, i++)\n    for (int j = 1; j <= i; j++) C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n  fc[0] = 1;\n  for (int i = 1; i < 8; i++) fc[i] = fc[i - 1] * i;\n  scanf(\"%d%d%d\", &n, &m, &K);\n  divset(0), sort(all.begin(), all.end(), greater<pair<int, long long> >());\n  while (m--) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u--, v--, g[u][v] = g[v][u] = 1;\n  }\n  dfsinit((1 << n) - 1);\n  for (auto x : all) {\n    long long msk = x.second;\n    int v = x.first;\n    if (dp.find(msk) == dp.end()) continue;\n    if (v <= K) ans += (long long)C[K][v] * fc[v];\n    for (int i = 0; i < v; i++)\n      for (int j = i + 1; j < v; j++) trans(msk, i, j);\n  }\n  printf(\"%I64d\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, n_, m, K, e[15], u[15], v[15], s;\nlong long pw[15], ans;\nvector<long long> st;\nvoid dfs2(int k1, int k2, long long k3) {\n  if (k1 >= n_) {\n    st.push_back(k3);\n    return;\n  }\n  for (int i = (0); i <= (k2 + 1); ++i) {\n    k3 += pw[u[k1]] * i;\n    k3 += pw[v[k1]] * i;\n    dfs2(k1 + 1, k2 + (i > k2), k3);\n    k3 -= pw[u[k1]] * i;\n    k3 -= pw[v[k1]] * i;\n  }\n}\nvoid dfs1(int k1, int k2, int k3) {\n  if (k1 >= n) {\n    vector<vector<int> > dp((1 << n_), vector<int>(n_));\n    for (int i = (0); i <= (n_ - 1); ++i)\n      if (e[u[i]] >> v[i] & 1) dp[1 << i][i] = 1;\n    for (int i = (0); i <= ((1 << n_) - 1); ++i) {\n      for (int j = (0); j <= (n_ - 1); ++j)\n        if (i >> j & 1)\n          if (dp[i][j]) {\n            for (int k = (0); k <= (n_ - 1); ++k)\n              if ((~i >> k & 1) &&\n                  (((e[u[j]] >> u[k] & 1) && (e[v[j]] >> v[k] & 1)) ||\n                   ((e[v[j]] >> u[k] & 1) && (e[u[j]] >> v[k] & 1)))) {\n                dp[i ^ (1 << k)][k] = 1;\n              }\n          }\n    }\n    bool flg = 0;\n    for (int i = (0); i <= (n_ - 1); ++i)\n      if (dp[(1 << n_) - 1][i]) flg = 1;\n    if (flg) {\n      dfs2(1, 0, 0);\n    }\n    return;\n  }\n  if (k2 >> k1 & 1) {\n    dfs1(k1 + 1, k2, k3);\n  } else {\n    for (int i = (k1 + 1); i <= (n - 1); ++i)\n      if (~k2 >> i & 1) {\n        u[k3] = k1, v[k3] = i;\n        dfs1(k1 + 1, k2 ^ (1 << k1) ^ (1 << i), k3 + 1);\n        u[k3] = v[k3] = 0;\n      }\n  }\n}\nint main() {\n  pw[0] = 1;\n  for (int i = (1); i <= (14); ++i) pw[i] = pw[i - 1] * 6;\n  scanf(\"%d%d%d\", &n, &m, &K), n_ = n >> 1;\n  for (int i = (1); i <= (m); ++i) {\n    int k1, k2;\n    scanf(\"%d%d\", &k1, &k2);\n    --k1, --k2;\n    e[k1] |= 1 << k2;\n    e[k2] |= 1 << k1;\n  }\n  dfs1(0, 0, 0);\n  sort(st.begin(), st.end());\n  st.erase(unique(st.begin(), st.end()), st.end());\n  auto debug_out = [&](long long x) {\n    ((void)0);\n    for (int i = (0); i <= (n - 1); ++i) {\n      ((void)0);\n      x /= 6;\n    }\n    ((void)0);\n  };\n  vector<int> f(n_);\n  for (auto x : st) {\n    int mx = 0;\n    long long now = x;\n    while (now) {\n      mx = max(mx, (int)(now % 6));\n      now /= 6;\n    }\n    ++f[mx];\n  }\n  auto calc = [&](int t) {\n    long long res = 1;\n    for (int i = (1); i <= (t); ++i) res *= K - i + 1;\n    return res;\n  };\n  for (int i = (0); i <= (n_ - 1); ++i) {\n    ans += f[i] * calc(i + 1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAX_N = 12;\nbool M[MAX_N + 3][MAX_N + 3];\nint n, m, k;\nbool is_bit(int mask, int pos) { return (mask & (1 << pos)) != 0; }\nstd::vector<long long> states;\nstd::unordered_map<long long, int> longest;\nstd::unordered_map<long long, int> longest_cnt;\nstd::unordered_map<long long, int> buckets_cnt;\nstd::unordered_map<long long, bool> dp;\nlong long pot[20];\nlong long potK[20];\nint cnt[6];\nlong long choose[15][15];\nlong long f[15];\nvoid gen_states(long long state, int next, int buckets) {\n  if (next == n) {\n    for (int i = 0; i < 6; i++) cnt[i] = 0;\n    for (int i = 0; i < n; i++) {\n      cnt[(state % pot[i + 1]) / pot[i]]++;\n    }\n    for (int i = 0; i < n; i++)\n      if (cnt[i] % 2 == 1) return;\n    states.push_back(state);\n    int x = -1;\n    int y = 0;\n    for (int i = 5; i >= 0; i--) {\n      if (cnt[i] > x) {\n        x = cnt[i];\n        y = 1;\n      } else if (cnt[i] == x)\n        y++;\n    }\n    longest[state] = x;\n    longest_cnt[state] = y;\n    buckets_cnt[state] = buckets + 1;\n    return;\n  }\n  for (long long i = 0; i <= std::min(5, buckets + 1); i++)\n    gen_states(state + (pot[next] * i), next + 1,\n               std::max((long long)(buckets), i));\n}\nbool cmp_states(const long long &A, const long long &B) {\n  if (longest[A] < longest[B])\n    return true;\n  else if (longest[A] == longest[B])\n    return longest_cnt[A] < longest_cnt[B];\n  return false;\n}\nvoid input() {\n  std::cin >> n >> m >> k;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    std::cin >> x >> y;\n    x--;\n    y--;\n    M[x][y] = M[y][x] = true;\n  }\n}\nconst int MAX_MASK = (1 << 6);\nbool dpI[MAX_MASK + 3][6];\nstd::pair<int, int> v[6];\nbool base_dp(long long state) {\n  for (int i = 0; i < 6; i++) v[i] = std::make_pair(-1, -1);\n  for (int i = 0; i < n; i++) {\n    int c = (state % pot[i + 1]) / pot[i];\n    if (v[c].first == -1)\n      v[c].first = i;\n    else\n      v[c].second = i;\n  }\n  int colors = n / 2;\n  for (int i = 0; i < colors; i++) {\n    dpI[(1 << i)][i] = M[v[i].first][v[i].second];\n  }\n  for (int mask = 1; mask < (1 << colors); mask++) {\n    if (__builtin_popcount(mask) <= 1) continue;\n    for (int i = 0; i < colors; i++) {\n      dpI[mask][i] = false;\n      if (is_bit(mask, i)) {\n        int mask1 = mask ^ (1 << i);\n        for (int j = 0; j < colors && !dpI[mask][i]; j++) {\n          if (is_bit(mask1, j) && dpI[mask1][j]) {\n            if ((M[v[j].first][v[i].first] && M[v[j].second][v[i].second]) ||\n                (M[v[j].first][v[i].second] && M[v[j].second][v[i].first]))\n              dpI[mask][i] = true;\n          }\n        }\n      }\n    }\n  }\n  for (int i = 0; i < colors; i++)\n    if (dpI[(1 << colors) - 1][i]) return true;\n  return false;\n}\nstd::vector<int> w[10];\nlong long sum[10];\nlong long sum_bigger[10];\nlong long max[20];\nbool calc_dp(long long state) {\n  for (int i = 0; i < (n / 2); i++) {\n    w[i].clear();\n    sum_bigger[i] = 0;\n    sum[i] = 0;\n  }\n  long long max_found = -1;\n  for (int i = 0; i < n; i++) {\n    max[i] = max_found;\n    long long x = (state % pot[i + 1]) / pot[i];\n    max_found = std::max(max_found, x);\n    sum[x] += pot[i];\n    w[x].push_back(i);\n  }\n  sum_bigger[5] = sum_bigger[6] = 0;\n  for (int i = 4; i >= 0; i--) sum_bigger[i] = sum_bigger[i + 1] + sum[i + 1];\n  for (int i = 0; i < (n / 2); i++) {\n    if (w[i].size() >= 4) {\n      int x = w[i][0];\n      for (int j = 1; j < w[i].size(); j++) {\n        int y = w[i][j];\n        int u = max[w[i][1]];\n        if (j == 1) u = max[w[i][2]];\n        long long statep =\n            state + sum_bigger[u] + (sum[i] - pot[x] - pot[y]) * ((u + 1) - i);\n        if (dp[statep]) return true;\n      }\n    }\n  }\n  return false;\n}\nvoid solve() {\n  input();\n  pot[0] = 1;\n  for (int i = 1; i <= 19; i++) pot[i] = (pot[i - 1] * (long long)(6));\n  f[0] = 1;\n  for (long long i = 1; i <= 13; i++) f[i] = f[i - 1] * i;\n  choose[0][0] = 1;\n  for (int i = 1; i <= 13; i++) {\n    choose[i][0] = 1;\n    for (int j = 1; j <= i; j++)\n      choose[i][j] = choose[i - 1][j] + choose[i - 1][j - 1];\n  }\n  gen_states(0, 0, -1);\n  std::sort(states.begin(), states.end(), cmp_states);\n  for (auto s : states) {\n    if (longest[s] == 2)\n      dp[s] = base_dp(s);\n    else\n      dp[s] = calc_dp(s);\n  }\n  long long res = 0;\n  for (auto s : states)\n    if (dp[s]) res += choose[k][buckets_cnt[s]] * f[buckets_cnt[s]];\n  std::cout << res << \"\\n\";\n}\nint main() {\n  std::ios_base::sync_with_stdio(0);\n  std::cin.tie(NULL);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nnamespace ywy {\ninline int get() {\n  int n = 0;\n  char c;\n  while ((c = getchar()) || 23333) {\n    if (c >= '0' && c <= '9') break;\n    if (c == '-') goto s;\n  }\n  n = c - '0';\n  while ((c = getchar()) || 23333) {\n    if (c >= '0' && c <= '9')\n      n = n * 10 + c - '0';\n    else\n      return (n);\n  }\ns:\n  while ((c = getchar()) || 23333) {\n    if (c >= '0' && c <= '9')\n      n = n * 10 - c + '0';\n    else\n      return (n);\n  }\n}\nint G[13][13], id[13], pa[13], pb[13], head = 0, tail = 0, n;\nunsigned char dp[64][6];\nunordered_set<long long> st;\ntypedef struct _n {\n  unsigned char col[12];\n} node;\nnode que[2000100];\nlong long c[20][20], jc[20];\nvoid dfs(int pt, int cnt) {\n  if (pt == n) {\n    memset(pa, -1, sizeof(pa));\n    memset(pb, -1, sizeof(pb));\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < n; i++) {\n      if (pa[id[i]] == -1)\n        pa[id[i]] = i;\n      else\n        pb[id[i]] = i;\n    }\n    for (int i = 0; i < n / 2; i++) {\n      if (n == 2 && G[pa[i]][pb[i]]) dp[1 << i][i] = 1;\n      if (n > 2) dp[1 << i][i] = 1;\n    }\n    for (int i = 1; i < (1 << (n >> 1)); i++) {\n      for (int j = 0; j < (n >> 1); j++) {\n        if (!dp[i][j]) continue;\n        for (int k = 0; k < (n >> 1); k++) {\n          if (i & (1 << k)) continue;\n          if ((G[pa[j]][pa[k]] && G[pb[j]][pb[k]]) ||\n              (G[pa[j]][pb[k]] && G[pb[j]][pa[k]])) {\n            if (G[pa[k]][pb[k]] || (i | (1 << k)) != (1 << (n >> 1)) - 1)\n              dp[i | (1 << k)][k] = 1;\n          }\n        }\n      }\n    }\n    for (int i = 0; i < (n >> 1); i++) {\n      if (dp[(1 << (n >> 1)) - 1][i]) {\n        long long hsh = 0;\n        for (int j = 0; j < n; j++)\n          hsh = hsh * 6 + id[j], que[tail].col[j] = id[j];\n        st.insert(hsh);\n        tail++;\n        return;\n      }\n    }\n    return;\n  }\n  if (id[pt] != -1)\n    dfs(pt + 1, cnt);\n  else {\n    id[pt] = cnt;\n    for (int i = pt + 1; i < n; i++) {\n      if (id[i] != -1) continue;\n      id[i] = cnt;\n      dfs(pt + 1, cnt + 1);\n      id[i] = -1;\n    }\n    id[pt] = -1;\n  }\n}\nvoid ywymain() {\n  memset(id, -1, sizeof(id));\n  n = get();\n  int m = get(), k = get();\n  for (int i = 1; i <= m; i++) {\n    int s = get() - 1, t = get() - 1;\n    G[s][t] = G[t][s] = 1;\n  }\n  dfs(0, 0);\n  jc[0] = 1;\n  for (int i = 1; i <= k; i++) jc[i] = jc[i - 1] * i;\n  long long ans = 0;\n  while (head < tail) {\n    node me = que[head++];\n    int mx = 0;\n    for (int i = 0; i < n; i++) mx = max(mx, me.col[i] + 1);\n    if (mx <= k) ans += jc[k] / jc[k - mx];\n    for (int i = 0; i < mx; i++) {\n      for (int j = i + 1; j < mx; j++) {\n        long long ha = 0;\n        node nd;\n        for (int a = 0; a < n; a++) {\n          if (me.col[a] == j)\n            nd.col[a] = i;\n          else {\n            nd.col[a] = me.col[a] - (me.col[a] > j);\n          }\n          ha = ha * 6 + nd.col[a];\n        }\n        if (!st.count(ha)) st.insert(ha), que[tail] = nd, tail++;\n      }\n    }\n  }\n  cout << ans << endl;\n}\n}  // namespace ywy\nint main() { ywy::ywymain(); }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng((int)chrono::steady_clock::now().time_since_epoch().count());\nint qtd[12];\nbool adj[15][15];\nbool check(string &s) {\n  vector<int> ord(s.size());\n  for (int i = 0; i < (int)s.size(); i++) {\n    ord[i] = i;\n  }\n  sort(ord.begin(), ord.end(), [&](int a, int b) { return s[a] < s[b]; });\n  for (int i = 0; i < (int)s.size(); i += 2) {\n    if (i + 2 == (int)s.size()) {\n      if (!adj[ord[i]][ord[i + 1]]) return false;\n    } else {\n      int a = ord[i];\n      int b = ord[i + 1];\n      int c = ord[i + 2];\n      int d = ord[i + 3];\n      if (!((adj[a][c] && adj[b][d]) || (adj[a][d] && adj[b][c]))) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\narray<char, 12> normalize(string s) {\n  vector<int> ord(7, 0);\n  array<char, 12> ss;\n  for (int i = 0, cnt = 0; i < (int)s.size(); i++) {\n    if (!ord[s[i] - '0']) ord[s[i] - '0'] = ++cnt;\n    ss[i] = char('0' + ord[s[i] - '0']);\n  }\n  return ss;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a - 1][b - 1] = adj[b - 1][a - 1] = true;\n  }\n  string s;\n  for (int i = 1; i <= n / 2; i++) {\n    s.push_back(char('0' + i));\n    s.push_back(char('0' + i));\n  }\n  set<array<char, 12>> vis;\n  queue<array<char, 12>> q;\n  do {\n    if (check(s)) {\n      array<char, 12> ns = normalize(s);\n      if (!vis.count(ns)) {\n        q.push(ns);\n        vis.insert(ns);\n      }\n    }\n  } while (next_permutation(s.begin(), s.end()));\n  while (!q.empty()) {\n    auto ss = q.front();\n    q.pop();\n    char mx = '0';\n    for (int i = 0; i < n; i++) {\n      mx = max(mx, ss[i]);\n    }\n    qtd[mx - '0']++;\n    array<char, 12> aux;\n    for (char i = '1'; i <= mx; i++) {\n      for (char j = char(i + 1); j <= mx; j++) {\n        for (int l = 0; l < n; l++) {\n          aux[l] = (ss[l] == j ? i : (ss[l] > j ? char(ss[l] - 1) : ss[l]));\n        }\n        if (!vis.count(aux)) {\n          q.push(aux);\n          vis.insert(aux);\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n / 2; i++) {\n    long long cost = 1;\n    for (int j = k; j >= k - i + 1; j--) {\n      cost *= j;\n    }\n    ans += qtd[i] * cost;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 15;\nconst char inf = 'z';\nbool g[N][N];\nvector<string> gen_cand_strings(int n);\nvoid rec_gen(vector<string>& ans, string& cur, char c, int n);\nvector<string> get_good_strings(vector<string>& cand, int n);\nvector<string> gen_cand2_strings(int n);\nvoid rec_gen2(vector<string>& ans, string& cur, char c, int n);\nbool is_ok(string s, vector<string>& good, int n);\nbool is_ok_rec(string& s, vector<string>& good, vector<bool>& done, int c,\n               int n);\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m, k;\n  cin >> n >> m >> k;\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    --u;\n    --v;\n    g[u][v] = g[v][u] = 1;\n  }\n  vector<string> cand = gen_cand_strings(n);\n  vector<string> good = get_good_strings(cand, n);\n  sort(good.begin(), good.end());\n  vector<string> cand2 = gen_cand2_strings(n);\n  sort(cand2.begin(), cand2.end());\n  cand2.erase(unique(cand2.begin(), cand2.end()), cand2.end());\n  long long ans = 0;\n  for (auto& s : cand2) {\n    if (is_ok(s, good, n)) {\n      long long tmp = 1;\n      int cnt = *max_element(s.begin(), s.end()) + 1;\n      for (int i = 0; i < cnt; ++i) {\n        tmp *= (k - i);\n      }\n      ans += tmp;\n    } else {\n    }\n  }\n  cout << ans << '\\n';\n}\nvector<string> gen_cand_strings(int n) {\n  vector<string> ans;\n  string base(n, inf);\n  rec_gen(ans, base, 0, n);\n  return ans;\n}\nvoid rec_gen(vector<string>& ans, string& cur, char c, int n) {\n  for (int i = 0; i < n; ++i) {\n    if (cur[i] == inf) {\n      cur[i] = c;\n      for (int j = i + 1; j < n; ++j) {\n        if (cur[j] == inf) {\n          cur[j] = c;\n          rec_gen(ans, cur, c + 1, n);\n          cur[j] = inf;\n        }\n      }\n      cur[i] = inf;\n      return;\n    }\n  }\n  ans.push_back(cur);\n}\nvector<string> get_good_strings(vector<string>& cand, int n) {\n  vector<string> good;\n  for (auto& s : cand) {\n    vector<vector<int>> pos(n / 2);\n    for (int i = 0; i < n; ++i) {\n      pos[s[i]].push_back(i);\n    }\n    int tot = (1 << (n / 2));\n    vector<vector<int>> dp(tot, vector<int>(n / 2, 0));\n    for (int i = 0; i < n / 2; ++i) {\n      dp[(1 << i)][i] = g[pos[i][0]][pos[i][1]];\n    }\n    for (int mask = 0; mask < tot; ++mask) {\n      if (__builtin_popcount(mask) < 2) {\n        continue;\n      }\n      for (int i = 0; i < n / 2; ++i) {\n        if (!((mask >> i) & 1)) {\n          continue;\n        }\n        int u0 = pos[i][0], u1 = pos[i][1];\n        int submask = mask - (1 << i);\n        for (int j = 0; j < n / 2; ++j) {\n          if (dp[submask][j]) {\n            int v0 = pos[j][0], v1 = pos[j][1];\n            if ((g[u0][v0] and g[u1][v1]) or (g[u0][v1] and g[u1][v0])) {\n              dp[mask][i] = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (int i = 0; i < n / 2; ++i) {\n      if (dp[tot - 1][i]) {\n        good.push_back(s);\n        break;\n      }\n    }\n  }\n  return good;\n}\nvector<string> gen_cand2_strings(int n) {\n  vector<string> ans;\n  string base(n, inf);\n  rec_gen2(ans, base, 0, n);\n  return ans;\n}\nvoid rec_gen2(vector<string>& ans, string& cur, char c, int n) {\n  for (int i = 0; i < n; ++i) {\n    if (cur[i] == inf) {\n      for (int j = i + 1; j < n; ++j) {\n        if (cur[j] == inf) {\n          for (int nc = 0; nc <= c; ++nc) {\n            cur[i] = cur[j] = nc;\n            rec_gen2(ans, cur, max(int(c), nc + 1), n);\n            cur[i] = cur[j] = inf;\n          }\n        }\n      }\n      return;\n    }\n  }\n  ans.push_back(cur);\n}\nbool is_ok(string s, vector<string>& good, int n) {\n  vector<bool> done(n, 0);\n  return is_ok_rec(s, good, done, 0, n);\n}\nbool is_ok_rec(string& s, vector<string>& good, vector<bool>& done, int c,\n               int n) {\n  if (c == n / 2) {\n    auto it = lower_bound(good.begin(), good.end(), s);\n    if (it != good.end() and *it == s) {\n      return true;\n    }\n  } else {\n    for (int i = 0; i < n; ++i) {\n      if (!done[i]) {\n        for (int j = i + 1; j < n; ++j) {\n          if (!done[j] and s[i] == s[j]) {\n            char tmp = s[i];\n            s[i] = s[j] = c;\n            done[i] = done[j] = true;\n            if (is_ok_rec(s, good, done, c + 1, n)) {\n              return true;\n            }\n            s[i] = s[j] = tmp;\n            done[i] = done[j] = false;\n          }\n        }\n        break;\n      }\n    }\n  }\n  return false;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, K, C[15][15], fc[8], cnt[15], a[15], tot;\nbool g[15][15];\nint px[10], py[10], N;\nmap<long long, bool> dp;\nvector<pair<int, long long> > all;\nvoid divset(int x) {\n  if (x == n) {\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 0; i < n; i++) cnt[a[i]]++;\n    bool tmp = 1;\n    for (int i = 0; i < tot && tmp; i++) tmp &= (cnt[i] % 2 == 0);\n    if (tmp) {\n      long long state = 0;\n      for (int i = 0; i < n; i++) state = state * 6 + a[i];\n      all.push_back(make_pair(tot, state));\n    }\n    return;\n  }\n  a[x] = tot++;\n  divset(x + 1);\n  --tot;\n  for (int i = 0; i < tot; i++) {\n    a[x] = i;\n    divset(x + 1);\n  }\n}\nbool f[70][7];\nbool check() {\n  memset(f, 0, sizeof(f));\n  for (int i = 0; i < n / 2; i++)\n    if (g[px[i]][py[i]]) f[(1 << i)][i] = 1;\n  for (int i = 1; i < (1 << (n / 2)); i++)\n    for (int j = 0; j < n / 2; j++)\n      if (f[i][j])\n        for (int k = 0; k < n / 2; k++)\n          if (!((1 << k) & i))\n            if ((g[px[j]][px[k]] && g[py[j]][py[k]]) ||\n                (g[px[j]][py[k]] && g[py[j]][px[k]]))\n              f[i | (1 << k)][k] = 1;\n  bool ans = 0;\n  for (int i = 0; i < n / 2 && !ans; i++) ans |= f[(1 << (n / 2)) - 1][i];\n  return ans;\n}\nvoid dfsinit(int mask) {\n  if (mask == 0) {\n    if (check()) {\n      for (int i = 0; i < n / 2; i++) a[px[i]] = a[py[i]] = i;\n      long long state = 0;\n      for (int i = 0; i < n; i++) state = state * 6 + a[i];\n      dp[state] = 1;\n    }\n    return;\n  }\n  int x = __builtin_ffs(mask) - 1;\n  px[N] = x, mask ^= (1 << x);\n  for (int y = 0; y < n; y++)\n    if ((1 << y) & mask) {\n      py[N++] = y;\n      dfsinit(mask ^ (1 << y));\n      N--;\n    }\n}\nlong long ans;\nint b[15];\nvoid trans(long long mask, int x, int y) {\n  for (int i = n - 1; ~i; i--) {\n    a[i] = mask % 6, mask /= 6;\n    if (a[i] == y) a[i] = x;\n  }\n  memset(b, -1, sizeof(b)), N = 0;\n  long long state = 0;\n  for (int i = 0; i < n; i++) {\n    if (b[a[i]] < 0) b[a[i]] = N++;\n    state = state * 6 + b[a[i]];\n  }\n  dp[state] = 1;\n}\nint main() {\n  for (int i = 0; i < 15; C[i][0] = 1, i++)\n    for (int j = 1; j <= i; j++) C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n  fc[0] = 1;\n  for (int i = 1; i < 8; i++) fc[i] = fc[i - 1] * i;\n  scanf(\"%d%d%d\", &n, &m, &K);\n  divset(0), sort(all.begin(), all.end(), greater<pair<int, long long> >());\n  while (m--) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u--, v--, g[u][v] = g[v][u] = 1;\n  }\n  dfsinit((1 << n) - 1);\n  for (auto x : all) {\n    long long msk = x.second;\n    int v = x.first;\n    if (dp.find(msk) == dp.end()) continue;\n    if (v <= K) ans += (long long)C[K][v] * fc[v];\n    for (int i = 0; i < v; i++)\n      for (int j = i + 1; j < v; j++) trans(msk, i, j);\n  }\n  printf(\"%I64d\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 13;\nint n, m, k, g[N][N], p[N], L[N], R[N];\nlong long fac[N];\nbool dp[1 << 6][6];\nunordered_map<long long, int> mp;\ninline void dfs1(int x) {\n  if ((x << 1) == n) {\n    memset(dp, false, sizeof(dp));\n    for (int i = 0; i < x; ++i)\n      if (g[L[i]][R[i]]) dp[1 << i][i] = 1;\n    for (int i = 0; i < (1 << x); ++i)\n      for (int j = 0; j < x; ++j) {\n        if (!dp[i][j]) continue;\n        for (int k = 0; k < x; ++k)\n          if (!(i & (1 << k)))\n            dp[i | (1 << k)][k] |= (g[L[j]][L[k]] && g[R[j]][R[k]]) ||\n                                   (g[L[j]][R[k]] && g[R[j]][L[k]]);\n      }\n    int tot = (1 << x) - 1;\n    long long now = 0;\n    bool ret = 0;\n    for (int i = 1; i <= n; ++i) now = now * 6 + p[i];\n    for (int i = 0; i < x; ++i)\n      if (dp[tot][i]) {\n        ret = true;\n        break;\n      }\n    mp[now] = ret;\n    return;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (p[i] == -1) {\n      for (int j = i + 1; j <= n; ++j)\n        if (p[j] == -1) {\n          p[i] = p[j] = x;\n          L[x] = i;\n          R[x] = j;\n          dfs1(x + 1);\n          p[i] = p[j] = -1;\n        }\n      break;\n    }\n  }\n}\ninline bool check(vector<int> p) {\n  vector<int> ct(n >> 1), lst(n >> 1);\n  long long now = 0;\n  int tot = 0;\n  for (int i = 0; i < (n >> 1); ++i) lst[i] = -1;\n  for (int i = 1; i <= n; ++i) {\n    if (lst[p[i]] == -1) lst[p[i]] = tot++;\n    p[i] = lst[p[i]];\n    now = now * 6 + p[i], ct[p[i]]++;\n  }\n  if (mp.count(now)) return mp[now];\n  for (int i = 1; i <= n; ++i) {\n    if (ct[p[i]] > 2) {\n      for (int j = i + 1; j <= n; ++j) {\n        if (p[i] == p[j]) {\n          int rec = p[i];\n          p[i] = p[j] = tot;\n          bool ret = check(p);\n          p[i] = p[j] = rec;\n          if (ret) return mp[now] = true;\n        }\n      }\n      break;\n    }\n  }\n  return mp[now] = false;\n}\ninline void dfs2(int x) {\n  int pos = -1;\n  for (int i = 1; i <= n; ++i)\n    if (p[i] == -1) {\n      pos = i;\n      break;\n    }\n  if (pos == -1) {\n    vector<int> ve(n + 1);\n    for (int i = 1; i <= n; ++i) ve[i] = p[i];\n    check(ve);\n    return;\n  }\n  for (int k = 0; k <= x; ++k) {\n    for (int y = pos + 1; y <= n; ++y) {\n      if (p[y] == -1) {\n        p[pos] = p[y] = k;\n        dfs2(max(k + 1, x));\n        p[pos] = p[y] = -1;\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 1, u, v; i <= m; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    g[u][v] = g[v][u] = 1;\n  }\n  for (int i = 1; i <= n; ++i) p[i] = -1;\n  fac[0] = 1;\n  for (int i = 1; i <= k; ++i) fac[i] = fac[i - 1] * i;\n  dfs1(0);\n  dfs2(0);\n  long long ans = 0;\n  for (auto p : mp) {\n    if (!p.second) continue;\n    long long mx = 0;\n    long long now = p.first;\n    for (int i = 1; i <= n; ++i) {\n      mx = max(mx, now % 6);\n      now /= 6;\n    }\n    mx++;\n    if (mx <= k) ans = ans + fac[k] / fac[k - mx];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 14;\nint n, m, K, lnk[maxn], f[1 << maxn][maxn], G[maxn][maxn], cnt[maxn], p[maxn];\nlong long ans, coef[maxn];\nmap<int, bool> mp;\nint main() {\n  scanf(\"%d %d %d\", &n, &m, &K);\n  for (int i = 1; i <= K; i++) {\n    coef[i] = 1;\n    for (int j = K; j >= K - i + 1; j--) coef[i] *= j;\n  }\n  while (m--) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    G[u][v] = G[v][u] = 1;\n  }\n  auto chk = [&]() {\n    int h = 0;\n    vector<pair<int, int>> V;\n    for (int i = 1; i <= n; i++)\n      if (lnk[i] > i) {\n        V.emplace_back(i, lnk[i]);\n        h = h * 12 + lnk[i] - 1;\n      }\n    if (mp.count(h)) return mp[h];\n    for (int i = 0; i < 1 << V.size(); i++) {\n      for (int j = 0; j < V.size(); j++) f[i][j] = 0;\n    }\n    for (int i = 0; i < V.size(); i++) {\n      if (G[V[i].first][V[i].second]) f[1 << i][i] = 1;\n    }\n    for (int i = 0; i < 1 << V.size(); i++) {\n      for (int j = 0; j < V.size(); j++)\n        if (f[i][j]) {\n          int u = V[j].first, v = V[j].second;\n          for (int k = 0; k < V.size(); k++)\n            if (!(i >> k & 1)) {\n              if (G[u][V[k].first] && G[v][V[k].second]) f[i | (1 << k)][k] = 1;\n              if (G[u][V[k].second] && G[v][V[k].first]) f[i | (1 << k)][k] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < V.size(); i++) {\n      if (f[(1 << V.size()) - 1][i]) return mp[h] = true;\n    }\n    return mp[h] = false;\n  };\n  function<bool(int)> dfs = [&](int v) {\n    if (v >= n) return chk();\n    if (lnk[v]) return dfs(v + 1);\n    for (int i = v + 1; i <= n; i++)\n      if (!lnk[i] && p[i] == p[v]) {\n        lnk[i] = v, lnk[v] = i;\n        if (dfs(v + 1)) return true;\n        lnk[i] = lnk[v] = 0;\n      }\n    return false;\n  };\n  function<void()> solve = [&]() {\n    fill(cnt + 1, cnt + K + 1, 0);\n    for (int i = 1; i <= n; i++) cnt[p[i]]++, lnk[i] = 0;\n    for (int i = 1; i <= K; i++)\n      if (cnt[i] & 1) return;\n    if (dfs(1)) ans += coef[*max_element(p + 1, p + n + 1)];\n  };\n  function<void(int)> _enum = [&](int pos) {\n    if (pos > n) {\n      solve();\n      return;\n    }\n    int mx = pos == 1 ? 0 : *max_element(p + 1, p + pos);\n    for (int i = 1; i <= min(K, mx + 1); i++) {\n      p[pos] = i, _enum(pos + 1);\n    }\n  };\n  _enum(1), printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,abm,mmx,tune=native\")\nusing namespace std;\nlong long gcd(long long i, long long j) {\n  if (j == 0)\n    return i;\n  else\n    return gcd(j, i % j);\n}\ntemplate <typename T>\ninline T getint() {\n  T val = 0;\n  char c;\n  bool neg = false;\n  while ((c = getchar()) && !(c >= '0' && c <= '9')) {\n    neg |= c == '-';\n  }\n  do {\n    val = (val * 10) + c - '0';\n  } while ((c = getchar()) && (c >= '0' && c <= '9'));\n  return val * (neg ? -1 : 1);\n}\nconst long long INF = 1e9 + 100;\nconst int mod = 998244353;\nconst double eps = 1e-11, pi = acos(-1);\nconst long long maxN = 13, maxT = 600100, A = 179, K = 170;\nmt19937 mt_rand(time(0));\nlong long bp(long long et, long long b) {\n  b %= mod - 1;\n  et %= mod;\n  long long res = 1;\n  for (int i = 30; i >= 0; --i) {\n    res = (res * res) % mod;\n    if ((b & (1 << i)) != 0) res = (res * et) % mod;\n  }\n  return res;\n}\nvoid panic() {\n  cout << \"-1\\n\";\n  exit(0);\n}\nlong long c[maxN][maxN];\nlong long f[maxN];\nvoid build() {\n  f[0] = 1;\n  for (int i = 1; i < maxN; ++i) f[i] = f[i - 1] * i;\n  for (int i = 0; i < maxN; ++i) {\n    c[i][0] = c[0][i] = 1;\n  }\n  for (int i = 1; i < maxN; ++i) {\n    for (int j = 1; j < maxN; ++j) {\n      c[i][j] = c[i - 1][j] + c[i][j - 1];\n    }\n  }\n}\nlong long C(int n, int k) { return c[n - k][k]; }\nlong long AA(int n, int k) { return f[n] / f[n - k]; }\nint g[maxN][maxN];\nint n;\nint used[maxN];\nset<vector<int>> clr[maxN];\nvector<pair<int, int>> pr;\nvector<int> col;\nvoid rec1(int lvl, int clrr = 1) {\n  if (lvl == n / 2) {\n    clr[clrr - 1].insert(col);\n    return;\n  }\n  for (int i = 1; i <= clrr; ++i) {\n    col[pr[lvl].first - 1] = col[pr[lvl].second - 1] = i;\n    rec1(lvl + 1, clrr + (i == clrr));\n  }\n}\nvoid rec(int lvl) {\n  if (lvl == n / 2) {\n    vector<int> tmp(n / 2);\n    for (int i = 0; i < n / 2; ++i) tmp[i] = i;\n    bool gg = 0;\n    do {\n      bool gd = 1;\n      for (int i = 1; i < n / 2; ++i) {\n        if (!g[pr[tmp[i - 1]].first][pr[tmp[i]].first] ||\n            !g[pr[tmp[i - 1]].second][pr[tmp[i]].second]) {\n          if (!g[pr[tmp[i - 1]].first][pr[tmp[i]].second] ||\n              !g[pr[tmp[i - 1]].second][pr[tmp[i]].first]) {\n            gd = 0;\n            break;\n          }\n        }\n      }\n      gd &= g[pr[tmp.back()].first][pr[tmp.back()].second];\n      if (gd) {\n        gg = 1;\n        break;\n      }\n    } while (next_permutation(tmp.begin(), tmp.end()));\n    if (!gg) return;\n    col.assign(n, 0);\n    rec1(0);\n    return;\n  }\n  int st = 1;\n  while (used[st]) ++st;\n  for (int to = st + 1; to <= n; ++to) {\n    if (used[to]) continue;\n    used[st] = used[to] = 1;\n    pr.push_back({st, to});\n    rec(lvl + 1);\n    pr.pop_back();\n    used[st] = used[to] = 0;\n  }\n}\nvoid solve() {\n  build();\n  int m, k;\n  cin >> n >> m >> k;\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    cin >> a >> b;\n    g[a][b] = g[b][a] = 1;\n  }\n  rec(0);\n  long long ans = 0;\n  for (int i = 1; i <= k; ++i) {\n    long long tmp = AA(k, i);\n    ans += (long long)clr[i].size() * tmp;\n  }\n  cout << ans << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout.precision(20);\n  srand(time(0));\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k;\nlong long dp[1 << 12][12];\nint G[12][12];\nlong long pw[20];\nvector<pair<int, int> > match;\nint single, lowest, used[20];\nset<long long> all[20];\nvector<vector<int> > trans;\nvector<int> smalltrans;\nvoid GetTrans(int n, int M) {\n  if (n == 0) {\n    trans.push_back(smalltrans);\n    return;\n  }\n  for (int i = 0; i <= M; i++) {\n    smalltrans.push_back(i);\n    GetTrans(n - 1, M + (i == M));\n    smalltrans.pop_back();\n  }\n}\nint GetM(long long id) {\n  int maxj = 0;\n  for (int i = 0; i < n; i++) {\n    maxj = max((long long)maxj, id / pw[i] % 12);\n  }\n  return maxj + 1;\n}\nlong long f[1 << 6][6][2];\nvoid dfs(int now, long long id, int one) {\n  if (now * 2 + one == n) {\n    memset(f, 0, sizeof(f));\n    for (int i = 0; i < now; i++) {\n      f[1 << i][i][0] = f[1 << i][i][1] = G[match[i].first][match[i].second];\n    }\n    for (int mask = 0; mask < (1 << now); mask++) {\n      for (int i = 0; i < now; i++)\n        if ((mask >> i & 1)) {\n          int x = match[i].first, y = match[i].second;\n          for (int p = 0; p < 2; p++)\n            if (f[mask][i][p]) {\n              for (int j = 0; j < now; j++)\n                if (!(mask >> j & 1)) {\n                  int xx = match[j].first, yy = match[j].second;\n                  for (int q = 0; q < 2; q++) {\n                    if (G[x][xx] && G[y][yy])\n                      f[mask | 1 << j][j][q] += f[mask][i][p];\n                    swap(xx, yy);\n                  }\n                }\n              swap(x, y);\n            }\n        }\n    }\n    long long ans = 0;\n    for (int i = 0; i < now; i++) {\n      for (int p = 0; p < 2; p++) {\n        ans += f[(1 << now) - 1][i][p];\n      }\n    }\n    if (ans) all[GetM(id)].insert(id);\n    return;\n  }\n  int oldlowest = lowest, rnk = now + one;\n  while (used[lowest]) lowest++;\n  if ((n & 1) && !one)\n    used[lowest] = 1, dfs(now + 1, id + rnk * pw[lowest], 1), used[lowest] = 0;\n  for (int i = lowest + 1; i < n; i++)\n    if (!used[i]) {\n      used[lowest] = used[i] = 1, match.push_back(make_pair(lowest, i));\n      dfs(now + 1, id + rnk * pw[lowest] + rnk * pw[i], one);\n      used[lowest] = used[i] = 0, match.pop_back();\n    }\n  lowest = oldlowest;\n}\nint main() {\n  pw[0] = 1;\n  for (int i = 1; i <= 12; i++) pw[i] = pw[i - 1] * 12;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y), x--, y--;\n    G[x][y] = G[y][x] = 1;\n  }\n  for (int i = 0; i < n; i++) {\n    dp[1 << i][i] = 1;\n  }\n  for (int mask = 0; mask < (1 << n); mask++) {\n    for (int i = 0; i < n; i++)\n      if (dp[mask][i]) {\n        for (int j = 0; j < n; j++)\n          if (!(mask >> j & 1) && G[i][j]) {\n            dp[mask | 1 << j][j] += dp[mask][i];\n          }\n      }\n  }\n  dfs(0, 0, 0);\n  for (int i = 1; i <= n; i++) {\n    if (!all[i].size()) continue;\n    trans.clear(), GetTrans(i, 0);\n    for (auto id : all[i]) {\n      for (auto tr : trans) {\n        long long nid = 0;\n        for (int i = 0; i < n; i++) {\n          nid += tr[id / pw[i] % 12] * pw[i];\n        }\n        if (id != nid) all[GetM(nid)].insert(nid);\n      }\n    }\n  }\n  long long ans = 0, pw = 1;\n  for (int i = 1; i <= n; i++) {\n    pw = pw * (k - i + 1);\n    ans += pw * all[i].size();\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst long long LINF = 1e18;\nint n, m, k;\nbool noted[13];\nbool connected[13][13];\nint cnt = 0;\nset<long long> st;\nset<set<int>> sets;\nvector<int> vec[13];\nlong long pw[13];\nbool visitedd[13];\nmap<long long, bool> visiteddd[13][13];\nvoid bruteforce_string(int u, int v, int d, long long code) {\n  if (d == n / 2) {\n    if (!connected[u][v]) return;\n    cnt++;\n    st.insert(code);\n    return;\n  }\n  for (int x : vec[u])\n    for (int y : vec[v]) {\n      if (x == y) continue;\n      if (visitedd[x] || visitedd[y]) continue;\n      long long nx = min(x, y);\n      long long ny = max(x, y);\n      long long ncode = code + (ny << (4LL * nx));\n      if (!visiteddd[nx][ny][ncode]) {\n        visiteddd[nx][ny][ncode] = 1;\n        visitedd[x] = 1;\n        visitedd[y] = 1;\n        bruteforce_string(nx, ny, d + 1, ncode);\n        visitedd[x] = 0;\n        visitedd[y] = 0;\n      }\n    }\n}\nint cnt2 = 0;\nmap<set<int>, bool> visited;\nvoid bruteforce_striling(set<int> st) {\n  visited[st] = 1;\n  if (st.size() == 1) return;\n  for (auto it = st.begin(); it != st.end(); it++) {\n    auto jt = it;\n    ++jt;\n    for (; jt != st.end(); jt++) {\n      set<int> nt = st;\n      nt.erase(*it);\n      nt.erase(*jt);\n      nt.insert(*it + *jt);\n      if (!visited[nt]) bruteforce_striling(nt);\n    }\n  }\n}\nlong long P(int n, int k) {\n  long long res = 1;\n  for (int i = 0; i < k; i++) res = (res * (n - i));\n  return res;\n}\nint main() {\n  pw[0] = 1;\n  for (int i = 1; i <= 12; i++) pw[i] = pw[i - 1] * 13;\n  scanf(\"%d %d %d\\n\", &n, &m, &k);\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    vec[u].push_back(v);\n    vec[v].push_back(u);\n    connected[u][v] = connected[v][u] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = i + 1; j <= n; j++) {\n      visitedd[i] = 1;\n      visitedd[j] = 1;\n      bruteforce_string(i, j, 1, ((1LL * j) << (4 * i)));\n      visitedd[i] = 0;\n      visitedd[j] = 0;\n    }\n  }\n  for (auto it : st) {\n    set<int> temp;\n    for (int i = 1; i <= 12; i++) {\n      int u = i;\n      int v = ((it >> (4LL * i)) & 15);\n      if (v) temp.insert((1 << u) + (1 << v));\n    }\n    sets.insert(temp);\n  }\n  for (auto it : sets) {\n    if (!visited[it]) bruteforce_striling(it);\n  }\n  long long res = 0;\n  for (auto it : visited) {\n    res += P(k, it.first.size());\n  }\n  printf(\"%lld\\n\", res);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<char>> g;\nmap<long long, bool> dp;\nvoid brute(int n, vector<int> &p) {\n  int x = find(p.begin(), p.end(), -1) - p.begin();\n  if (x == int(p.size())) {\n    vector<vector<char>> dp2(1 << n, vector<char>(n));\n    vector<int> pos1(n), pos2(n);\n    for (int i = 0; i < int(p.size()); i++) {\n      pos1[p[i]] = pos2[p[i]];\n      pos2[p[i]] = i;\n    }\n    for (int i = 0; i < int(n); i++)\n      if (g[pos1[i]][pos2[i]]) dp2[1 << i][i] = true;\n    for (int mask = 0; mask < int(1 << n); mask++)\n      for (int i = 0; i < int(n); i++)\n        if (dp2[mask][i]) {\n          for (int j = 0; j < int(n); j++)\n            if (!((mask >> j) & 1)) {\n              dp2[mask | (1 << j)][j] |=\n                  (g[pos1[i]][pos1[j]] && g[pos2[i]][pos2[j]]);\n              dp2[mask | (1 << j)][j] |=\n                  (g[pos1[i]][pos2[j]] && g[pos2[i]][pos1[j]]);\n            }\n        }\n    for (int i = 0; i < int(n); i++)\n      if (dp2[(1 << n) - 1][i]) {\n        long long num = 0;\n        for (int x : p) num = num * 6 + x;\n        dp[num] = true;\n        break;\n      }\n    return;\n  }\n  for (int y = x + 1; y < int(p.size()); ++y)\n    if (p[y] == -1) {\n      p[x] = p[y] = n;\n      brute(n + 1, p);\n      p[x] = p[y] = -1;\n    }\n}\nbool dfs(vector<int> p) {\n  vector<int> used(int(p.size()), -1);\n  int cnt = 0;\n  for (int i = 0; i < int(p.size()); i++)\n    if (used[p[i]] == -1) used[p[i]] = cnt++;\n  long long num = 0;\n  for (int &x : p) {\n    x = used[x];\n    num = num * 6 + x;\n  }\n  if (dp.count(num)) return dp[num];\n  bool res = false;\n  vector<int> cur(cnt);\n  for (int i = 0; i < int(p.size()); i++) ++cur[p[i]];\n  for (int i = 0; i < int(p.size()); i++)\n    if (cur[p[i]] > 2) {\n      int x = p[i];\n      for (int j = i + 1; j < int(p.size()); ++j)\n        if (p[j] == p[i]) {\n          p[i] = p[j] = cnt;\n          if (dfs(p)) {\n            res = true;\n            break;\n          }\n          p[i] = p[j] = x;\n        }\n      break;\n    }\n  return dp[num] = res;\n}\nvoid brute2(int n, vector<int> &p) {\n  int x = find(p.begin(), p.end(), -1) - p.begin();\n  if (x == int(p.size())) {\n    dfs(p);\n    return;\n  }\n  for (int i = 0; i < int(n + 1); i++) {\n    for (int y = x + 1; y < int(p.size()); ++y)\n      if (p[y] == -1) {\n        p[x] = p[y] = i;\n        brute2(max(n, i + 1), p);\n        p[x] = p[y] = -1;\n      }\n  }\n}\nint main() {\n  int n, m, k;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  g.resize(n, vector<char>(n));\n  for (int _ = 0; _ < int(m); _++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    --v, --u;\n    g[v][u] = g[u][v] = 1;\n  }\n  vector<int> cur(n, -1);\n  brute(0, cur);\n  brute2(0, cur);\n  vector<long long> fact(k + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= k; ++i) fact[i] = fact[i - 1] * i;\n  long long ans = 0;\n  for (auto it : dp)\n    if (it.second) {\n      long long num = it.first;\n      long long mx = 1;\n      while (num) {\n        mx = max(mx, num % 6 + 1);\n        num /= 6;\n      }\n      if (mx <= k) {\n        ans += fact[k] / fact[k - mx];\n      }\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, K, fac[12];\nlong long res;\nint blk[12], num, BLK[12], mun;\nint Hsh() {\n  mun = 0;\n  for (int i = 0; i < n; i++)\n    if (!BLK[blk[i]]) BLK[blk[i]] = mun++;\n  int ret = 0;\n  for (int i = 0; i < n; i++) ret = 6 * ret + BLK[blk[i]];\n  for (int i = 0; i < n; i++) BLK[blk[i]] = 0;\n  return ret;\n}\nunordered_map<int, bool> mp;\nbool f[6][1 << 6], g[12][12];\nvector<int> v[6];\nbool che() {\n  memset(f, false, sizeof(f));\n  for (int i = 0; i < num; i++)\n    if (g[v[i][0]][v[i][1]]) f[i][1 << i] = true;\n  for (int i = 1; i < (1 << num); i++)\n    for (int j = 0; j < num; j++) {\n      if (!(i & (1 << j)) || !f[j][i]) continue;\n      for (int k = 0; k < num; k++) {\n        if (i & (1 << k)) continue;\n        if (g[v[j][0]][v[k][0]] && g[v[j][1]][v[k][1]])\n          f[k][i | (1 << k)] = true;\n        if (g[v[j][0]][v[k][1]] && g[v[j][1]][v[k][0]])\n          f[k][i | (1 << k)] = true;\n      }\n    }\n  for (int i = 0; i < num; i++)\n    if (f[i][(1 << num) - 1]) return true;\n  return false;\n}\nvoid dfs(int pos) {\n  if (num > (n >> 1)) return;\n  if (pos == n) {\n    for (int i = 0; i < num; i++) v[i].clear();\n    for (int i = 0; i < n; i++) v[blk[i]].push_back(i);\n    for (int i = 0; i < num; i++)\n      if (v[i].size() & 1) return;\n    int x = Hsh();\n    if (num == (n >> 1)) {\n      if (che()) mp[x] = true;\n    } else {\n      int id = num - 1;\n      while (v[id].size() == 2) id--;\n      for (int i = 1; i + 1 < v[id].size(); i++) {\n        blk[v[id][i]] = blk[v[id].back()] = num;\n        int y = Hsh();\n        blk[v[id][i]] = blk[v[id].back()] = id;\n        if (mp.find(y) != mp.end()) {\n          mp[x] = true;\n          break;\n        }\n      }\n      for (int i = 1; i + 1 < v[id].size(); i++) blk[v[id][i]] = num;\n      int y = Hsh();\n      for (int i = 1; i + 1 < v[id].size(); i++) blk[v[id][i]] = id;\n      if (mp.find(y) != mp.end()) mp[x] = true;\n    }\n    if (mp.find(x) != mp.end()) res += fac[num];\n    return;\n  }\n  blk[pos] = num++;\n  dfs(pos + 1), num--;\n  for (int i = num - 1; i >= 0; i--) blk[pos] = i, dfs(pos + 1);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &K);\n  fac[1] = K;\n  for (int i = 2; i <= (n >> 1); i++) fac[i] = fac[i - 1] * (K - i + 1);\n  for (int i = 1, x, y; i <= m; i++)\n    scanf(\"%d%d\", &x, &y), g[x - 1][y - 1] = g[y - 1][x - 1] = true;\n  dfs(0);\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 6;\nint n, m, k;\nlong long ans;\nbool conn[13][13];\nint pr[7][2], fact[13], A[13][13];\nbool vis[13];\nint ind[7];\nbool check() {\n  for (int i = 0; i < (n >> 1); ++i) ind[i] = i + 1;\n  for (int _ = 0; _ < fact[n >> 1]; ++_) {\n    next_permutation(ind, ind + (n >> 1));\n    if (!conn[pr[ind[0]][0]][pr[ind[0]][1]]) continue;\n    bool ok = true;\n    for (int i = 1; i < (n >> 1) && ok; ++i) {\n      int a1 = pr[ind[i]][0], b1 = pr[ind[i]][1], a2 = pr[ind[i - 1]][0],\n          b2 = pr[ind[i - 1]][1];\n      if ((!conn[a1][a2] || !conn[b1][b2]) &&\n          (!conn[a1][b2] || !conn[b1][a2])) {\n        ok = false;\n      }\n    }\n    if (ok) return true;\n  }\n  return false;\n}\nmap<int, int> mp;\nint color[13];\nvoid gen(int bound, int flg) {\n  if (!flg) {\n    int tmp = 0;\n    for (int i = 1; i <= n; ++i) tmp = tmp * mod + color[i];\n    mp[tmp] = bound;\n    return;\n  }\n  if (flg == (n >> 1)) {\n    color[pr[flg][0]] = color[pr[flg][1]] = 0;\n    gen(0, flg - 1);\n  } else {\n    for (int i = 0; i <= bound; ++i) {\n      color[pr[flg][0]] = color[pr[flg][1]] = i;\n      gen(bound, flg - 1);\n    }\n    color[pr[flg][0]] = color[pr[flg][1]] = bound + 1;\n    gen(bound + 1, flg - 1);\n  }\n}\nvoid dfs(int b, int flg) {\n  if (!flg) {\n    if (check()) {\n      gen(0, n >> 1);\n    }\n    return;\n  }\n  while (vis[b]) ++b;\n  for (int i = b + 1; i <= n; ++i) {\n    if (!vis[i]) {\n      vis[i] = vis[b] = true;\n      pr[flg][0] = b;\n      pr[flg][1] = i;\n      dfs(b + 1, flg - 1);\n      vis[i] = vis[b] = false;\n    }\n  }\n}\nint main() {\n  fact[0] = 1;\n  for (int i = 1; i <= 12; ++i) fact[i] = fact[i - 1] * i;\n  for (int i = 0; i <= 12; ++i)\n    for (int j = 0; j <= i; ++j) A[i][j] = fact[i] / fact[i - j];\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    conn[u][v] = conn[v][u] = true;\n  }\n  ans = 0;\n  dfs(1, n >> 1);\n  for (auto nd : mp) {\n    ans += A[k][nd.second + 1];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, hf;\nbool g[50][50];\ninline void addedge(long long from, long long to) {\n  g[from][to] = g[to][from] = true;\n}\nlong long makepair[50];\nlong long chains[50][2], belong[50];\nlong long p[50];\nbool check() {\n  for (long long i = 1; i <= hf; i++) p[i] = i;\n  do {\n    for (long long i = 1; i < hf; i++) {\n      if (g[chains[p[i]][0]][chains[p[i + 1]][0]] &&\n          g[chains[p[i]][1]][chains[p[i + 1]][1]])\n        ;\n      else if (g[chains[p[i]][0]][chains[p[i + 1]][1]] &&\n               g[chains[p[i]][1]][chains[p[i + 1]][0]])\n        ;\n      else\n        goto no;\n    }\n    if (!g[chains[p[hf]][0]][chains[p[hf]][1]]) continue;\n    return true;\n  no:;\n  } while (next_permutation(p + 1, p + hf + 1));\n  return false;\n}\nvector<vector<long long> > colors;\nvector<long long> nowcolor;\nvoid color(long long u, long long now) {\n  if (u == hf + 1) {\n    nowcolor[0] = now - 1;\n    colors.push_back(nowcolor);\n    return;\n  }\n  for (long long i = 1; i <= now; i++) {\n    nowcolor[u] = i;\n    color(u + 1, max(now, i + 1));\n  }\n}\nset<pair<long long, long long> > anss;\nvoid dfs(long long u, long long now) {\n  while (u <= n && makepair[u]) u++;\n  if (u == n + 1) {\n    bool ok = check();\n    if (!ok) return;\n    for (auto vec : colors) {\n      long long Hash = 0;\n      for (long long i = 1; i <= n; i++) Hash = Hash * 6 + (vec[belong[i]] - 1);\n      anss.insert({Hash, vec[0]});\n    }\n    return;\n  }\n  for (long long i = u + 1; i <= n; i++)\n    if (!makepair[i]) {\n      makepair[u] = i, makepair[i] = u;\n      chains[now][0] = u, chains[now][1] = i;\n      belong[u] = belong[i] = now;\n      dfs(u + 1, now + 1);\n      makepair[u] = makepair[i] = 0;\n    }\n}\nlong long fac[50];\ninline void InitFac(long long n) {\n  fac[0] = 1;\n  for (long long i = 1; i <= n; i++) fac[i] = fac[i - 1] * i;\n}\ninline long long A(long long n, long long m) {\n  return n < m ? 0 : fac[n] / fac[n - m];\n}\nsigned main() {\n  memset(g, false, sizeof(g));\n  InitFac(15);\n  long long m, k;\n  scanf(\"%lld %lld %lld\", &n, &m, &k);\n  hf = n >> 1;\n  while (m--) {\n    long long u, v;\n    scanf(\"%lld %lld\", &u, &v);\n    addedge(u, v);\n  }\n  memset(makepair, 0, sizeof(makepair));\n  nowcolor.resize(50);\n  color(1, 1);\n  dfs(1, 1);\n  long long ans = 0;\n  for (auto x : anss) {\n    long long cnt = x.second;\n    ans += A(k, cnt);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, hf;\nbool g[50][50];\ninline void addedge(long long from, long long to) {\n  g[from][to] = g[to][from] = true;\n}\nlong long makepair[50];\nlong long chains[50][2], belong[50];\nlong long p[50], vis[50];\nbool check(long long u) {\n  if (u == hf + 1) {\n    for (long long i = 1; i <= hf; i++) vis[i] = 0;\n    return true;\n  }\n  for (long long i = 1; i <= hf; i++) {\n    if (vis[i]) continue;\n    if (u == 1) {\n      if (!g[chains[i][0]][chains[i][1]]) continue;\n    } else {\n      if (g[chains[p[u - 1]][0]][chains[i][0]] &&\n          g[chains[p[u - 1]][1]][chains[i][1]])\n        ;\n      else if (g[chains[p[u - 1]][0]][chains[i][1]] &&\n               g[chains[p[u - 1]][1]][chains[i][0]])\n        ;\n      else\n        continue;\n    }\n    p[u] = i, vis[i] = 1;\n    if (check(u + 1)) return true;\n    p[u] = 0, vis[i] = 0;\n  }\n  return false;\n}\nvector<vector<long long> > colors;\nvector<long long> nowcolor;\nvoid color(long long u, long long now) {\n  if (u == hf + 1) {\n    nowcolor[0] = now - 1;\n    colors.push_back(nowcolor);\n    return;\n  }\n  for (long long i = 1; i <= now; i++) {\n    nowcolor[u] = i;\n    color(u + 1, max(now, i + 1));\n  }\n}\nset<pair<long long, long long> > anss;\nvoid dfs(long long u, long long now) {\n  while (u <= n && makepair[u]) u++;\n  if (u == n + 1) {\n    bool ok = check(1);\n    if (!ok) return;\n    for (auto vec : colors) {\n      long long Hash = 0;\n      for (long long i = 1; i <= n; i++) Hash = Hash * 6 + (vec[belong[i]] - 1);\n      anss.insert({Hash, vec[0]});\n    }\n    return;\n  }\n  for (long long i = u + 1; i <= n; i++)\n    if (!makepair[i]) {\n      makepair[u] = i, makepair[i] = u;\n      chains[now][0] = u, chains[now][1] = i;\n      belong[u] = belong[i] = now;\n      dfs(u + 1, now + 1);\n      makepair[u] = makepair[i] = 0;\n    }\n}\nlong long fac[50];\ninline void InitFac(long long n) {\n  fac[0] = 1;\n  for (long long i = 1; i <= n; i++) fac[i] = fac[i - 1] * i;\n}\ninline long long A(long long n, long long m) {\n  return n < m ? 0 : fac[n] / fac[n - m];\n}\nsigned main() {\n  InitFac(15);\n  long long m, k;\n  scanf(\"%lld %lld %lld\", &n, &m, &k);\n  hf = n >> 1;\n  while (m--) {\n    long long u, v;\n    scanf(\"%lld %lld\", &u, &v);\n    addedge(u, v);\n  }\n  memset(makepair, 0, sizeof(makepair));\n  nowcolor.resize(50);\n  color(1, 1);\n  dfs(1, 1);\n  long long ans = 0;\n  for (auto x : anss) {\n    long long cnt = x.second;\n    ans += A(k, cnt);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T>\nvoid dout(string name, int idx, T arg) {\n  cerr << name << \" = \" << to_string(arg);\n}\ntemplate <typename T1, typename... T2>\nvoid dout(string names, int idx, T1 arg, T2... args) {\n  cerr << names.substr(0, names.find(',')) << \" = \" << to_string(arg) << \", \";\n  dout(names.substr(names.find(',') + 2), idx + 1, args...);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, z;\n  cin >> n >> m >> z;\n  vector<vector<int>> g(n, vector<int>(n));\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    --y;\n    g[x][y] = 1;\n    g[y][x] = 1;\n  }\n  vector<int> match(n, -1);\n  long long ans = 0;\n  set<vector<int>> matches;\n  function<void()> DP = [&]() {\n    assert(*min_element(match.begin(), match.end()) > -1);\n    vector<pair<int, int>> pairs;\n    for (int i = 0; i < n; i++) {\n      if (i < match[i]) {\n        pairs.emplace_back(i, match[i]);\n      }\n    }\n    assert((int)2 * pairs.size() == n);\n    vector<vector<vector<int>>> dp(\n        1 << (n / 2), vector<vector<int>>(n / 2, vector<int>(2, 0)));\n    for (int i = 0; i < (int)pairs.size(); i++) {\n      int x = pairs[i].first, y = pairs[i].second;\n      if (g[x][y]) {\n        assert(g[y][x]);\n        dp[1 << i][i][0] = dp[1 << i][i][1] = 1;\n      }\n    }\n    for (int mask = 1; mask < (1 << (int)pairs.size()); mask++) {\n      for (int i = 0; i < (int)pairs.size(); i++) {\n        int xi = pairs[i].first, yi = pairs[i].second;\n        if (mask & (1 << i)) {\n          for (int j = 0; j < (int)pairs.size(); j++) {\n            if (mask & (1 << j)) {\n              int xj = pairs[j].first, yj = pairs[j].second;\n              if (g[xi][xj] && g[yi][yj]) {\n                dp[mask][i][0] |= dp[mask ^ (1 << i)][j][0];\n              }\n              if (g[xi][yj] && g[xj][yi]) {\n                dp[mask][i][0] |= dp[mask ^ (1 << i)][j][1];\n              }\n              if (g[yi][xj] && g[yj][xi]) {\n                dp[mask][i][1] |= dp[mask ^ (1 << i)][j][0];\n              }\n              if (g[yi][yj] && g[xi][xj]) {\n                dp[mask][i][1] |= dp[mask ^ (1 << i)][j][1];\n              }\n            }\n          }\n        }\n      }\n    }\n    int p = 1;\n    for (int i = 0; i < n / 2; i++) {\n      p *= z;\n    }\n    int any = 0;\n    for (int i = 0; i < (int)pairs.size(); i++) {\n      for (int j = 0; j < 2; j++) {\n        any |= dp[(1 << ((int)pairs.size())) - 1][i][j];\n      }\n    }\n    if (any) {\n      matches.insert(match);\n    }\n  };\n  function<void(int)> DoMatch = [&](int i) {\n    if (i == n) {\n      DP();\n      return;\n    }\n    if (match[i] != -1) {\n      DoMatch(i + 1);\n    } else {\n      for (int j = i + 1; j < n; j++) {\n        if (match[j] == -1) {\n          match[i] = j;\n          match[j] = i;\n          DoMatch(i + 1);\n          match[i] = -1;\n          match[j] = -1;\n        }\n      }\n    }\n  };\n  vector<int> color(n, -1);\n  vector<vector<int>> comp(6);\n  set<vector<int>> cached;\n  vector<int> new_match(n);\n  vector<int> f(n + 1);\n  f[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    f[i] = f[i - 1] * (z - i + 1);\n  }\n  function<bool(int)> Calculate = [&](int i) {\n    if (i == n) {\n      if (matches.count(new_match)) {\n        int size = 1 + *max_element(color.begin(), color.end());\n        ans += f[size];\n        return true;\n      }\n      return false;\n    }\n    if (new_match[i] != -1) {\n      return Calculate(i + 1);\n    }\n    for (int j : comp[color[i]]) {\n      if (i == j || new_match[j] != -1) {\n        continue;\n      }\n      new_match[i] = j;\n      new_match[j] = i;\n      if (Calculate(i + 1)) {\n        return true;\n      }\n      new_match[i] = -1;\n      new_match[j] = -1;\n    }\n    return false;\n  };\n  function<void(int, int)> DoColoring = [&](int i, int size) {\n    if (i == n) {\n      bool ok = true;\n      for (int j = 0; j < 6; j++) {\n        if ((int)comp[j].size() % 2) {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) {\n        new_match = vector<int>(n, -1);\n        Calculate(0);\n      }\n      return;\n    }\n    for (int j = 0; j < size; j++) {\n      color[i] = j;\n      comp[j].push_back(i);\n      DoColoring(i + 1, min(6, max(size, color[i] + 2)));\n      comp[j].pop_back();\n      color[i] = -1;\n    }\n  };\n  DoMatch(0);\n  DoColoring(0, 1);\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\nusing namespace std;\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>\nbool ckmin(T& a, const T& b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char* x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string& x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V>& x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << \", \";\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T& x) {\n  int first = 0;\n  cerr << '{';\n  for (auto& i : x) cerr << (first++ ? \", \" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 13;\nint N, M, K;\nlong long ans = 0;\nvector<int> color, match;\nvector<int> cc[MX];\nint nc = 0;\nset<vector<int>> okMatches;\nlong long numWays[MX];\nbool graph[MX][MX];\nbool goMatch(int p) {\n  if (p == N) {\n    if (okMatches.count(match)) {\n      ans += numWays[nc];\n      return true;\n    }\n    return false;\n  }\n  if (match[p] != -1) {\n    return goMatch(p + 1);\n  }\n  for (auto& a : cc[color[p]]) {\n    if (a == p || match[a] != -1) continue;\n    match[a] = p;\n    match[p] = a;\n    if (goMatch(p + 1)) return true;\n    match[p] = -1;\n    match[a] = -1;\n  }\n  return false;\n}\nvoid goColor(int p) {\n  if (p == N) {\n    for (int i = 0; i < (nc); i++)\n      if ((int)(cc[i]).size() % 2) return;\n    match = vector<int>(N, -1);\n    goMatch(0);\n    return;\n  }\n  int onc = nc;\n  for (int i = 0; i < (onc + 1); i++) {\n    ckmax(nc, i + 1);\n    color[p] = i;\n    cc[i].push_back(p);\n    goColor(p + 1);\n    cc[i].pop_back();\n  }\n  nc = onc;\n}\nvoid initMatch(int p) {\n  if (p == N) {\n    vector<vector<int>> pairs;\n    for (int i = 0; i < (N); i++) {\n      if (i < match[i]) {\n        pairs.push_back({i, match[i]});\n      }\n    }\n    bool ok[N / 2][N / 2];\n    for (int i = 0; i < (N / 2); i++)\n      for (int j = 0; j < (N / 2); j++) ok[i][j] = false;\n    for (int i = 0; i < (N / 2); i++) {\n      for (int j = 0; j < (N / 2); j++) {\n        for (int a = 0; a < (2); a++) {\n          for (int b = 0; b < (2); b++) {\n            if (graph[pairs[i][a]][pairs[j][b]] &&\n                graph[pairs[i][1 - a]][pairs[j][1 - b]]) {\n              ok[i][j] = true;\n            }\n            if (i == j && graph[pairs[i][a]][pairs[j][b]]) {\n              ok[i][j] = true;\n            }\n          }\n        }\n      }\n    }\n    vector<int> perm;\n    for (int i = 0; i < ((int)(pairs).size()); i++) perm.push_back(i);\n    do {\n      bool val = true;\n      for (int i = 0; i < (N / 2 - 1); i++)\n        if (!ok[perm[i]][perm[i + 1]]) val = false;\n      if (!ok[perm[0]][perm[0]]) val = false;\n      if (val) {\n        okMatches.insert(match);\n        return;\n      }\n    } while (next_permutation(perm.begin(), perm.end()));\n    return;\n  }\n  if (match[p] != -1) {\n    initMatch(p + 1);\n    return;\n  }\n  for (int a = p + 1; a < (N); a++) {\n    if (a == p || match[a] != -1) continue;\n    match[a] = p;\n    match[p] = a;\n    initMatch(p + 1);\n    match[p] = -1;\n    match[a] = -1;\n  }\n}\nvoid solve() {\n  cin >> N >> M >> K;\n  numWays[0] = 1;\n  for (int i = 1; i < (MX); i++) numWays[i] = numWays[i - 1] * (K - i + 1);\n  for (int i = 0; i < (M); i++) {\n    int X, Y;\n    cin >> X >> Y;\n    X--;\n    Y--;\n    graph[X][Y] = true;\n    graph[Y][X] = true;\n  }\n  match = vector<int>(N, -1);\n  color = vector<int>(N);\n  initMatch(0);\n  goColor(0);\n  cout << ans << nl;\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin.exceptions(cin.failbit);\n  int T = 1;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, k, g[15][15], vis[15], ss[15], ans, fac[15];\nlong long path[20000][15], cnt, tot, co[15], p[10];\nset<vector<vector<long long>>> s;\nvector<vector<long long>> cev;\nvector<long long> vec, pos[15];\nlong long read() {\n  long long res = 0, f = 1;\n  char ch;\n  do {\n    ch = getchar();\n    if (ch == '-') f = -1;\n  } while (!isdigit(ch));\n  do {\n    res = res * 10 + ch - '0';\n    ch = getchar();\n  } while (isdigit(ch));\n  return res * f;\n}\nvoid check() {\n  memset(co, 0, sizeof(co));\n  cnt = 0;\n  for (long long i = (1); i <= (n); ++i)\n    if (!co[i]) p[++cnt] = i, co[i] = 1, co[vis[i]] = 1;\n  do {\n    long long fl = 1;\n    for (long long S = (0); S <= (1 << ((n / 2) - 1)); ++S) {\n      long long p1 = p[1], p2 = vis[p[1]];\n      fl = 1;\n      if (!g[p1][p2]) {\n        fl = 0;\n        break;\n      }\n      if (S & 1) swap(p1, p2);\n      for (long long i = (2); i <= (cnt); ++i)\n        if ((1 << (i - 1)) & S) {\n          if (g[p1][p[i]] && g[p2][vis[p[i]]])\n            p1 = p[i], p2 = vis[p[i]];\n          else {\n            fl = 0;\n            break;\n          }\n        } else {\n          if (g[p1][vis[p[i]]] && g[p2][p[i]])\n            p1 = vis[p[i]], p2 = p[i];\n          else {\n            fl = 0;\n            break;\n          }\n        }\n      if (fl) {\n        tot++;\n        for (long long i = (1); i <= (n); ++i) path[tot][i] = vis[i];\n        break;\n      }\n    }\n    if (fl) break;\n  } while (next_permutation(p + 1, p + cnt + 1));\n}\nvoid dfs(long long x) {\n  if (x > n) return check();\n  if (vis[x]) return dfs(x + 1);\n  for (long long i = (x + 1); i <= (n); ++i)\n    if (!vis[i]) {\n      vis[x] = i;\n      vis[i] = x;\n      dfs(x + 1);\n      vis[i] = vis[x] = 0;\n    }\n}\nvoid dfs2(long long id, long long x, long long mx) {\n  if (x > cnt) {\n    cev.clear();\n    for (long long i = (1); i <= (mx); ++i) {\n      vec.clear();\n      for (long long ps : pos[i])\n        vec.push_back(ps), vec.push_back(path[id][ps]);\n      sort(vec.begin(), vec.end());\n      cev.push_back(vec);\n    }\n    s.insert(cev);\n    return;\n  }\n  for (long long i = (1); i <= (mx + 1); ++i)\n    pos[i].push_back(ss[x]), dfs2(id, x + 1, max(mx, i)), pos[i].pop_back();\n}\nsigned main() {\n  n = read();\n  m = read();\n  k = read();\n  for (long long i = (1); i <= (m); ++i) {\n    long long u = read(), v = read();\n    g[u][v] = g[v][u] = 1;\n  }\n  fac[0] = 1;\n  for (long long i = (1); i <= (k); ++i) fac[i] = fac[i - 1] * (k - i + 1);\n  dfs(1);\n  for (long long i = (1); i <= (tot); ++i) {\n    cnt = 0;\n    for (long long j = (1); j <= (n); ++j)\n      if (path[i][j] > j) ss[++cnt] = j;\n    dfs2(i, 1, 0);\n  }\n  for (auto x : s) ans += fac[x.size()];\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \" \";\n  return os;\n}\nconst int mxN = 12, oo = 1e9;\nbool g[12][12], used[13];\nlong long ans = 0;\nint n = 12, k;\nint a[12];\nbool pused[6];\nbool goodr(int i = 0, int d = 0) {\n  if (d == n - 2) return g[a[i]][a[i + 1]];\n  for (int to = 0; to < n; to += 2)\n    if (!pused[to]) {\n      if ((g[a[i]][a[to]] and g[a[i + 1]][a[to + 1]]) or\n          (g[a[i]][a[to + 1]] and g[a[i + 1]][a[to]])) {\n        pused[to] = true;\n        if (goodr(to, d + 2)) {\n          pused[to] = false;\n          return true;\n        }\n        pused[to] = false;\n      }\n    }\n  return false;\n}\nbool good() {\n  for (int i = 0; i < n; i += 2) {\n    pused[i] = true;\n    if (goodr(i)) {\n      pused[i] = false;\n      return true;\n    }\n    pused[i] = false;\n  }\n  return false;\n}\nset<array<char, 12>> s;\nint eq = 0;\narray<char, 12> equiv, mp, reale;\nvoid normalize() {\n  fill(begin(mp), end(mp), -1);\n  int t = 0;\n  for (int i = 0; i < n; ++i) {\n    if (mp[equiv[i]] == -1) mp[equiv[i]] = t++;\n    reale[i] = mp[equiv[i]];\n  }\n}\nvoid rec2(int i = 0) {\n  if (i == n) {\n    normalize();\n    if (eq > k) return;\n    if (!s.count(reale)) {\n      int cur = 1;\n      for (int j = k - eq + 1; j <= k; ++j) {\n        cur *= j;\n      }\n      ans += cur;\n      s.insert(reale);\n    }\n    return;\n  }\n  equiv[a[i]] = eq;\n  equiv[a[i + 1]] = eq;\n  eq++;\n  rec2(i + 2);\n  eq--;\n  for (int j = 0; j < eq; ++j) {\n    equiv[a[i]] = j;\n    equiv[a[i + 1]] = j;\n    rec2(i + 2);\n  }\n}\nvoid rec(int i, int d = 0) {\n  while (used[i]) ++i;\n  if (i == n) {\n    if (good()) {\n      rec2();\n    }\n    return;\n  }\n  used[i] = true;\n  for (int j = i + 1; j < n; ++j)\n    if (!used[j]) {\n      used[j] = true;\n      a[d] = i;\n      a[d + 1] = j;\n      rec(i + 1, d + 2);\n      used[j] = false;\n    }\n  used[i] = false;\n}\nint main() {\n  int m;\n  cin >> n >> m >> k;\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v, --u, --v;\n    g[u][v] = true;\n    g[v][u] = true;\n  }\n  rec(0);\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\nusing namespace std;\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>\nbool ckmin(T& a, const T& b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char* x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string& x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V>& x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << \", \";\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T& x) {\n  int first = 0;\n  cerr << '{';\n  for (auto& i : x) cerr << (first++ ? \", \" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 13;\nint N, M, K;\nlong long ans = 0;\nvector<int> color, match;\nvector<int> cc[MX];\nint nc = 0;\nset<vector<int>> okMatches;\nlong long numWays[MX];\nbool graph[MX][MX];\nbool goMatch(int p) {\n  if (p == N) {\n    if (okMatches.count(match)) {\n      ans += numWays[nc];\n      return true;\n    }\n    return false;\n  }\n  if (match[p] != -1) {\n    return goMatch(p + 1);\n  }\n  for (auto& a : cc[color[p]]) {\n    if (a == p || match[a] != -1) continue;\n    match[a] = p;\n    match[p] = a;\n    if (goMatch(p + 1)) return true;\n    match[p] = -1;\n    match[a] = -1;\n  }\n  return false;\n}\nvoid goColor(int p) {\n  if (p == N) {\n    for (int i = 0; i < (nc); i++)\n      if ((int)(cc[i]).size() % 2) return;\n    match = vector<int>(N, -1);\n    goMatch(0);\n    return;\n  }\n  int onc = nc;\n  for (int i = 0; i < (onc + 1); i++) {\n    ckmax(nc, i + 1);\n    color[p] = i;\n    cc[i].push_back(p);\n    goColor(p + 1);\n    cc[i].pop_back();\n  }\n  nc = onc;\n}\nvoid initMatch(int p) {\n  if (p == N) {\n    vector<vector<int>> pairs;\n    for (int i = 0; i < (N); i++) {\n      if (i < match[i]) {\n        pairs.push_back({i, match[i]});\n      }\n    }\n    bool ok[N / 2][N / 2];\n    for (int i = 0; i < (N / 2); i++)\n      for (int j = 0; j < (N / 2); j++) ok[i][j] = false;\n    for (int i = 0; i < (N / 2); i++) {\n      for (int j = 0; j < (N / 2); j++) {\n        for (int a = 0; a < (2); a++) {\n          for (int b = 0; b < (2); b++) {\n            if (graph[pairs[i][a]][pairs[j][b]] &&\n                graph[pairs[i][1 - a]][pairs[j][1 - b]]) {\n              ok[i][j] = true;\n            }\n            if (i == j && graph[pairs[i][a]][pairs[j][b]]) {\n              ok[i][j] = true;\n            }\n          }\n        }\n      }\n    }\n    vector<int> perm;\n    for (int i = 0; i < ((int)(pairs).size()); i++) perm.push_back(i);\n    do {\n      bool val = true;\n      for (int i = 0; i < (N / 2 - 1); i++)\n        if (!ok[perm[i]][perm[i + 1]]) val = false;\n      if (!ok[perm[0]][perm[0]]) val = false;\n      if (val) {\n        okMatches.insert(match);\n        return;\n      }\n    } while (next_permutation(perm.begin(), perm.end()));\n    return;\n  }\n  if (match[p] != -1) {\n    initMatch(p + 1);\n    return;\n  }\n  for (int a = p + 1; a < (N); a++) {\n    if (a == p || match[a] != -1) continue;\n    match[a] = p;\n    match[p] = a;\n    initMatch(p + 1);\n    match[p] = -1;\n    match[a] = -1;\n  }\n}\nvoid solve() {\n  cin >> N >> M >> K;\n  numWays[0] = 1;\n  for (int i = 1; i < (MX); i++) numWays[i] = numWays[i - 1] * (K - i + 1);\n  for (int i = 0; i < (M); i++) {\n    int X, Y;\n    cin >> X >> Y;\n    X--;\n    Y--;\n    graph[X][Y] = true;\n    graph[Y][X] = true;\n  }\n  match = vector<int>(N, -1);\n  color = vector<int>(N);\n  initMatch(0);\n  goColor(0);\n  cout << ans << endl;\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin.exceptions(cin.failbit);\n  int T = 1;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target( \\\n    \"fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconst double eps = 1e-6;\nstruct inout {\n  static const int ibufl = 1 << 25;\n  char in_buf[ibufl + 5], out_buf[ibufl + 5], *inf, *ouf;\n  void init() {\n    fread(in_buf, 1, ibufl, stdin);\n    inf = in_buf;\n    ouf = out_buf;\n  }\n  inout& operator>>(int& a) {\n    int fh = 1;\n    while (!(isdigit(*inf) || *inf == '-')) ++inf;\n    if (*inf == '-') fh = -1, ++inf;\n    a = 0;\n    while (isdigit(*inf)) {\n      a = a * 10 + *inf - '0';\n      ++inf;\n    }\n    a *= fh;\n    return *this;\n  }\n  inout& operator>>(char& a) {\n    while (*inf == ' ' || *inf == '\\n') ++inf;\n    a = *inf;\n    ++inf;\n    return *this;\n  }\n  inout& operator>>(char* a) {\n    while (*inf == ' ' || *inf == '\\n') ++inf;\n    while (!(*inf == ' ' || *inf == '\\n')) {\n      *a = *inf;\n      ++inf;\n      ++a;\n    }\n    *a = '\\0';\n    return *this;\n  }\n  inout& operator>>(double& a) {\n    int fh = 1;\n    double s;\n    while (!(isdigit(*inf) || *inf == '-')) ++inf;\n    if (*inf == '-') fh = -1, ++inf;\n    a = 0;\n    while (isdigit(*inf)) {\n      a = a * 10 + *inf - '0';\n      ++inf;\n    }\n    if (*inf == '.') {\n      s = 0.1;\n      ++inf;\n      while (isdigit(*inf)) {\n        a += s * (*inf - '0');\n        ++inf;\n        s *= 0.1;\n      }\n    }\n    a *= fh;\n    return *this;\n  }\n  void writeint(int x) {\n    if (x / 10) writeint(x / 10);\n    *ouf = x % 10 + '0';\n    ++ouf;\n  }\n  inout& operator<<(int a) {\n    if (a < 0) {\n      *ouf = '-';\n      ++ouf;\n      a = -a;\n    }\n    writeint(a);\n    return *this;\n  }\n  static const int sz = 2;\n  inout& operator<<(char a) {\n    *ouf = a;\n    ++ouf;\n    return *this;\n  }\n  inout& operator<<(char* a) {\n    while (*a) {\n      *ouf = *a;\n      ++ouf;\n      ++a;\n    }\n    return *this;\n  }\n  inout& operator<<(double a) {\n    if (a < -eps) {\n      *ouf = '-';\n      ++ouf;\n      a = -a;\n    }\n    writeint((int)a);\n    a -= (int)a;\n    *ouf = '.';\n    ++ouf;\n    for (int i = 1; i <= sz; i++) {\n      a = a * 10;\n      *ouf = (int)a + '0';\n      ++ouf;\n      a -= (int)a;\n    }\n    return *this;\n  }\n  void out() { fwrite(out_buf, 1, ouf - out_buf, stdout); }\n};\ninout io;\nint num[15], n;\nbool f[15][15];\nint C[15], p[15][15], len[15];\npair<int, pair<int, int> > q[600000];\nint t;\nbool vis[1 << 12][14][15];\nint tot;\ninline bool dfs2(int mask, int x, int y) {\n  q[++t] = make_pair(mask, make_pair(x, y));\n  if (mask == (1 << n) - 1) return 1;\n  for (int i = 1; i <= tot; i++) {\n    for (int j = 1; j <= len[i]; j++)\n      if (!(mask & (1 << p[i][j]))) {\n        for (int K = j + 1; K <= len[i]; K++)\n          if (!(mask & (1 << p[i][K]))) {\n            if (f[p[i][j]][x] && f[p[i][K]][y] ||\n                f[p[i][j]][y] && f[p[i][K]][x]) {\n              if (!vis[mask | (1 << p[i][j]) | (1 << p[i][K])][p[i][j]]\n                      [p[i][K]]) {\n                vis[mask | (1 << p[i][j]) | (1 << p[i][K])][p[i][j]][p[i][K]] =\n                    1;\n                if (dfs2(mask | (1 << p[i][j]) | (1 << p[i][K]), p[i][j],\n                         p[i][K]))\n                  return 1;\n              }\n            }\n          }\n      }\n  }\n  return 0;\n}\nvoid dfs(int x, int used, int cnt) {\n  if (x + cnt > n) return;\n  if (x == n) {\n    t = 0;\n    tot = used;\n    for (int i = 1; i <= used; i++) {\n      for (int j = 1; j <= len[i]; j++) {\n        for (int K = j + 1; K <= len[i]; K++)\n          if (f[p[i][j]][p[i][K]]) {\n            vis[(1 << p[i][j]) + (1 << p[i][K])][p[i][j]][p[i][K]] = 1;\n            if (dfs2((1 << p[i][j]) + (1 << p[i][K]), p[i][j], p[i][K])) {\n              for (int i = 1; i <= t; i++)\n                vis[q[i].first][q[i].second.first][q[i].second.second] = 0;\n              C[used]++;\n              return;\n            }\n          }\n      }\n    }\n    for (int i = 1; i <= t; i++)\n      vis[q[i].first][q[i].second.first][q[i].second.second] = 0;\n    return;\n  }\n  for (int i = 1; i <= used + 1; i++) {\n    num[i]++;\n    p[i][++len[i]] = x;\n    dfs(x + 1, max(used, i), cnt + ((num[i] & 1) ? 1 : (-1)));\n    num[i]--;\n    --len[i];\n  }\n}\nsigned main() {\n  io.init();\n  int m, k;\n  io >> n >> m >> k;\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    io >> x >> y;\n    x--;\n    y--;\n    f[x][y] = f[y][x] = 1;\n  }\n  dfs(0, 0, 0);\n  long long ans = 0;\n  for (int i = 1; i <= k; i++) {\n    long long p = 1;\n    for (int j = k; j >= k - i + 1; j--) p *= j;\n    ans += C[i] * p;\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\nusing namespace std;\nlong long n, hf;\nbool g[50][50];\ninline void addedge(long long from, long long to) {\n  g[from][to] = g[to][from] = true;\n}\nlong long makepair[50];\nlong long chains[50][2], belong[50];\nlong long p[50];\nbool check() {\n  for (long long i = 1; i <= hf; i++) p[i] = i;\n  do {\n    for (long long i = 1; i < hf; i++) {\n      if (g[chains[p[i]][0]][chains[p[i + 1]][0]] &&\n          g[chains[p[i]][1]][chains[p[i + 1]][1]])\n        ;\n      else if (g[chains[p[i]][0]][chains[p[i + 1]][1]] &&\n               g[chains[p[i]][1]][chains[p[i + 1]][0]])\n        ;\n      else\n        goto no;\n    }\n    if (!g[chains[p[hf]][0]][chains[p[hf]][1]]) continue;\n    return true;\n  no:;\n  } while (next_permutation(p + 1, p + hf + 1));\n  return false;\n}\nvector<vector<long long> > colors;\nvector<long long> nowcolor;\nvoid color(long long u, long long now) {\n  if (u == hf + 1) {\n    nowcolor[0] = now - 1;\n    colors.push_back(nowcolor);\n    return;\n  }\n  for (long long i = 1; i <= now; i++) {\n    nowcolor[u] = i;\n    color(u + 1, max(now, i + 1));\n  }\n}\nset<pair<long long, long long> > anss;\nvoid dfs(long long u, long long now) {\n  while (u <= n && makepair[u]) u++;\n  if (u == n + 1) {\n    bool ok = check();\n    if (!ok) return;\n    for (auto vec : colors) {\n      long long Hash = 0;\n      for (long long i = 1; i <= n; i++) Hash = Hash * 6 + (vec[belong[i]] - 1);\n      anss.insert({Hash, vec[0]});\n    }\n    return;\n  }\n  for (long long i = u + 1; i <= n; i++)\n    if (!makepair[i]) {\n      makepair[u] = i, makepair[i] = u;\n      chains[now][0] = u, chains[now][1] = i;\n      belong[u] = belong[i] = now;\n      dfs(u + 1, now + 1);\n      makepair[u] = makepair[i] = 0;\n    }\n}\nlong long fac[50];\ninline void InitFac(long long n) {\n  fac[0] = 1;\n  for (long long i = 1; i <= n; i++) fac[i] = fac[i - 1] * i;\n}\ninline long long A(long long n, long long m) {\n  return n < m ? 0 : fac[n] / fac[n - m];\n}\nsigned main() {\n  memset(g, false, sizeof(g));\n  InitFac(15);\n  long long m, k;\n  scanf(\"%lld %lld %lld\", &n, &m, &k);\n  hf = n >> 1;\n  while (m--) {\n    long long u, v;\n    scanf(\"%lld %lld\", &u, &v);\n    addedge(u, v);\n  }\n  memset(makepair, 0, sizeof(makepair));\n  nowcolor.resize(50);\n  color(1, 1);\n  dfs(1, 1);\n  long long ans = 0;\n  for (auto x : anss) {\n    long long cnt = x.second;\n    ans += A(k, cnt);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng((int)chrono::steady_clock::now().time_since_epoch().count());\nint ord[12], qtd[12];\nbool adj[15][15];\nbool check(string &s) {\n  for (int i = 0; i < (int)s.size(); i++) {\n    ord[i] = i;\n  }\n  sort(ord, ord + (int)s.size(), [&](int a, int b) { return s[a] < s[b]; });\n  for (int i = 0; i < (int)s.size(); i += 2) {\n    if (i + 2 == (int)s.size()) {\n      if (!adj[ord[i]][ord[i + 1]]) return false;\n    } else {\n      int a = ord[i];\n      int b = ord[i + 1];\n      int c = ord[i + 2];\n      int d = ord[i + 3];\n      if (!((adj[a][c] && adj[b][d]) || (adj[a][d] && adj[b][c]))) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nstring normalize(string s) {\n  for (int i = 0; i <= 6; i++) {\n    ord[i] = 0;\n  }\n  for (int i = 0, cnt = 0; i < (int)s.size(); i++) {\n    if (!ord[s[i] - '0']) ord[s[i] - '0'] = ++cnt;\n    s[i] = char('0' + ord[s[i] - '0']);\n  }\n  return s;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a - 1][b - 1] = adj[b - 1][a - 1] = true;\n  }\n  string s;\n  for (int i = 1; i <= n / 2; i++) {\n    s.push_back(char('0' + i));\n    s.push_back(char('0' + i));\n  }\n  set<string> vis;\n  queue<string> q;\n  do {\n    if (check(s)) {\n      string ns = normalize(s);\n      if (!vis.count(ns)) {\n        q.push(ns);\n        vis.insert(ns);\n      }\n    }\n  } while (next_permutation(s.begin(), s.end()));\n  while (!q.empty()) {\n    s = q.front();\n    q.pop();\n    char mx = '0';\n    for (int i = 0; i < (int)s.size(); i++) {\n      mx = max(mx, s[i]);\n    }\n    qtd[mx - '0']++;\n    string aux = s;\n    for (char i = '1'; i <= mx; i++) {\n      for (char j = char(i + 1); j <= mx; j++) {\n        for (int l = 0; l < (int)s.size(); l++) {\n          aux[l] = (s[l] == j ? i : (s[l] > j ? char(s[l] - 1) : s[l]));\n        }\n        if (!vis.count(aux)) {\n          q.push(aux);\n          vis.insert(aux);\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n / 2; i++) {\n    long long cost = 1;\n    for (int j = k; j >= k - i + 1; j--) {\n      cost *= j;\n    }\n    ans += qtd[i] * cost;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nint N, M, K;\nint E[12][12];\nstatic const int N_ = 1020;\nstatic signed long long P_[N_][N_];\nint V[12];\nsigned long long ret;\nmap<vector<pair<int, int>>, int> memo;\nint valid(vector<pair<int, int>> P) {\n  sort((P.begin()), (P.end()));\n  if (memo.count(P)) return memo[P];\n  int ret = 0;\n  do {\n    int i;\n    int ok = 1;\n    if (E[P[0].first][P[0].second] == 0) ok = 0;\n    for (i = 1; i < P.size(); i++) {\n      int can =\n          (E[P[i].first][P[i - 1].first] && E[P[i].second][P[i - 1].second]) |\n          (E[P[i].first][P[i - 1].second] && E[P[i].second][P[i - 1].first]);\n      ok &= can;\n    }\n    if (ok) return memo[P] = 1;\n  } while (next_permutation((P.begin()), (P.end())));\n  return memo[P] = 0;\n}\nint ok(int mask, vector<pair<int, int>>& P) {\n  if (mask == 0) return valid(P);\n  int i, j;\n  for (i = 0; i < (N); i++)\n    if (mask & (1 << i)) break;\n  mask ^= 1 << i;\n  for (j = 0; j < (N); j++)\n    if ((mask & (1 << j)) && V[i] == V[j]) {\n      P.push_back({i, j});\n      int v = ok(mask ^ (1 << j), P);\n      P.pop_back();\n      if (v) return 1;\n    }\n  return 0;\n}\nvoid dfs(int cur, int ma, int mask) {\n  int i;\n  if (cur == N) {\n    if (mask == 0) {\n      vector<pair<int, int>> P;\n      if (ok((1 << N) - 1, P)) ret += P_[K][ma];\n    }\n    return;\n  }\n  for (i = 0; i < min(ma + 1, N / 2); i++) {\n    V[cur] = i;\n    dfs(cur + 1, max(ma, i + 1), mask ^ (1 << i));\n  }\n}\nvoid solve() {\n  int i, j, k, l, r, x, y;\n  string s;\n  for (i = 0; i < (15); i++) {\n    P_[i][0] = 1;\n    for (j = 1; j <= i; j++) P_[i][j] = P_[i][j - 1] * (i + 1 - j);\n  }\n  cin >> N >> M >> K;\n  for (i = 0; i < (M); i++) {\n    cin >> x >> y;\n    E[x - 1][y - 1] = E[y - 1][x - 1] = 1;\n  }\n  dfs(0, 0, 0);\n  cout << ret << endl;\n}\nint main(int argc, char** argv) {\n  string s;\n  int i;\n  if (argc == 1) ios::sync_with_stdio(false), cin.tie(0);\n  for (i = 0; i < (argc - 1); i++) s += argv[i + 1], s += '\\n';\n  for (i = 0; i < (s.size()); i++) ungetc(s[s.size() - 1 - i], stdin);\n  cout.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng((int)chrono::steady_clock::now().time_since_epoch().count());\nint ord[12], qtd[12];\nbool adj[15][15];\nbool check(string &s) {\n  for (int i = 0; i < (int)s.size(); i++) {\n    ord[i] = i;\n  }\n  sort(ord, ord + (int)s.size(), [&](int a, int b) { return s[a] < s[b]; });\n  for (int i = 0; i < (int)s.size(); i += 2) {\n    if (i + 2 == (int)s.size()) {\n      if (!adj[ord[i]][ord[i + 1]]) return false;\n    } else {\n      int a = ord[i];\n      int b = ord[i + 1];\n      int c = ord[i + 2];\n      int d = ord[i + 3];\n      if (!((adj[a][c] && adj[b][d]) || (adj[a][d] && adj[b][c]))) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\narray<char, 12> normalize(string &s) {\n  for (int i = 0; i <= 6; i++) {\n    ord[i] = 0;\n  }\n  array<char, 12> ss;\n  for (int i = 0, cnt = 0; i < (int)s.size(); i++) {\n    if (!ord[s[i] - '0']) ord[s[i] - '0'] = ++cnt;\n    ss[i] = char('0' + ord[s[i] - '0']);\n  }\n  return ss;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a - 1][b - 1] = adj[b - 1][a - 1] = true;\n  }\n  string s;\n  for (int i = 1; i <= n / 2; i++) {\n    s.push_back(char('0' + i));\n    s.push_back(char('0' + i));\n  }\n  set<array<char, 12>> vis;\n  queue<array<char, 12>> q;\n  do {\n    if (check(s)) {\n      array<char, 12> ns = normalize(s);\n      if (!vis.count(ns)) {\n        q.push(ns);\n        vis.insert(ns);\n      }\n    }\n  } while (next_permutation(s.begin(), s.end()));\n  while (!q.empty()) {\n    auto ss = q.front();\n    q.pop();\n    char mx = '0';\n    for (int i = 0; i < n; i++) {\n      mx = max(mx, ss[i]);\n    }\n    qtd[mx - '0']++;\n    array<char, 12> aux;\n    for (char i = '1'; i <= mx; i++) {\n      for (char j = char(i + 1); j <= mx; j++) {\n        for (int l = 0; l < n; l++) {\n          aux[l] = (ss[l] == j ? i : (ss[l] > j ? char(ss[l] - 1) : ss[l]));\n        }\n        if (!vis.count(aux)) {\n          q.push(aux);\n          vis.insert(aux);\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n / 2; i++) {\n    long long cost = 1;\n    for (int j = k; j >= k - i + 1; j--) {\n      cost *= j;\n    }\n    ans += qtd[i] * cost;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx2\")\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\ntemplate <typename T>\nT abs(T x) {\n  return x < 0 ? -x : x;\n}\ntemplate <typename T>\nT sgn(T x) {\n  return x < 0 ? -1 : (x > 0 ? 1 : 0);\n}\ntemplate <typename T>\nT sqr(T x) {\n  return x * x;\n}\ntemplate <typename T>\nT gcd(T a, T b) {\n  return a ? gcd(b % a, a) : b;\n}\nint n;\nint m;\nint k;\nint cnt[12];\nvi v[12];\nint was[1 << 12][12][12];\npair<int, ii> q[(1 << 12) * 12 * 12];\nint col[12];\nint ct;\nint g[12][12];\nint ct2;\nint was2[12];\nvoid go2(int x) {\n  was2[x] = ct2;\n  for (int i = 0; i < n; i++)\n    if (g[x][i] && was2[i] != ct2) go2(i);\n}\nint check(int mask, int x, int y) {\n  ct2++;\n  for (int i = 0; i < n; i++)\n    if ((mask >> i) & 1) was2[i] = ct2;\n  go2(x);\n  go2(y);\n  for (int i = 0; i < n; i++)\n    if (was2[i] != ct2) return 0;\n  return 1;\n}\nint pre[1 << 12][12][12];\nint vv[1 << 12][12][12];\nint cv[1 << 12][12];\nint go2(int mask, int x, int y) {\n  if ((mask + 1) == (1 << n)) return 1;\n  if (!pre[mask][x][y]) return 0;\n  was[mask][x][y] = ct;\n  for (int ia = 0; ia < cv[mask][x]; ia++)\n    for (int ib = 0; ib < cv[mask][y]; ib++) {\n      int a = vv[mask][x][ia];\n      int b = vv[mask][y][ib];\n      if (a != b && col[a] == col[b] &&\n          was[mask | (1 << a) | (1 << b)][a][b] != ct)\n        if (go2(mask | (1 << a) | (1 << b), a, b)) return 1;\n    }\n  return 0;\n}\nll go(int i, int j, ll tot) {\n  if (!tot) return 0;\n  if (i == n) {\n    for (int k = 0; k < j; k++)\n      if (cnt[k] & 1) return 0;\n    ct++;\n    for (int i = 0; i < n; i++)\n      for (int j = i + 1; j < n; j++)\n        if (g[i][j] && col[i] == col[j])\n          if (go2((1 << i) | (1 << j), i, j)) return tot;\n    return 0;\n  }\n  ll ans = 0;\n  for (int k = 0; k <= j; k++) {\n    col[i] = k;\n    cnt[k]++;\n    ans += go(i + 1, j + int(k == j), j == k ? tot * (::k - j) : tot);\n    cnt[k]--;\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    a--;\n    b--;\n    v[a].push_back(b);\n    v[b].push_back(a);\n    g[a][b] = g[b][a] = 1;\n  }\n  for (int i = 0; i < (1 << n); i++)\n    for (int j = 0; j < n; j++)\n      for (int k = 0; k < n; k++) {\n        pre[i][j][k] = check(i, j, k);\n        if (((i >> k) & 1) == 0 && g[j][k]) vv[i][j][cv[i][j]++] = k;\n      }\n  printf(\"%lld\\n\", go(0, 0, 1));\n  cerr << clock() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 12;\nconst int M = N + 7;\nconst double EPS = 1e-10;\nconst int MOD = 1e9 + 7;\nconst long long INF = 2e18;\nbool edge[M][M];\nmap<long long, bool> dp;\nvoid calcDP(int n, vector<int>& col) {\n  auto i = find(col.begin(), col.end(), -1) - col.begin();\n  if (i == (int)col.size()) {\n    int pos[n][2];\n    for (int i = 0; i < (int)col.size(); i++) {\n      pos[col[i]][0] = pos[col[i]][1];\n      pos[col[i]][1] = i;\n    }\n    vector<vector<int>> d(1 << n, vector<int>(n));\n    for (int i = 0; i < n; i++)\n      if (edge[pos[i][0]][pos[i][1]]) d[1 << i][i] = true;\n    for (int mask = 0; mask < (1 << n); mask++) {\n      for (int i = 0; i < n; i++) {\n        if (!d[mask][i]) continue;\n        for (int j = 0; j < n; j++) {\n          if (!((mask >> j) & 1)) {\n            d[mask | (1 << j)][j] |=\n                edge[pos[j][0]][pos[i][0]] && edge[pos[j][1]][pos[i][1]];\n            d[mask | (1 << j)][j] |=\n                edge[pos[j][0]][pos[i][1]] && edge[pos[j][1]][pos[i][0]];\n          }\n        }\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      if (d[(1 << n) - 1][i]) {\n        long long hash = 0;\n        for (int c : col) hash = hash * 6 + c;\n        dp[hash] = true;\n        break;\n      }\n    }\n    return;\n  }\n  for (int j = i + 1; j < (int)col.size(); j++) {\n    if (col[j] == -1) {\n      col[i] = col[j] = n;\n      calcDP(n + 1, col);\n      col[i] = col[j] = -1;\n    }\n  }\n}\nbool calcAdvancedDP(vector<int> col) {\n  vector<int> p((int)col.size(), -1);\n  int cnt = 0;\n  for (int i = 0; i < (int)col.size(); i++)\n    if (p[col[i]] == -1) p[col[i]] = cnt++;\n  vector<int> count(cnt, 0);\n  long long hash = 0;\n  for (int i = 0; i < (int)col.size(); i++) {\n    col[i] = p[col[i]];\n    count[col[i]]++;\n    hash = hash * 6 + col[i];\n  }\n  if (dp.count(hash)) return dp[hash];\n  bool res = false;\n  for (int i = 0; i < (int)col.size(); i++) {\n    if (count[col[i]] <= 2) continue;\n    for (int j = i + 1; j < (int)col.size() && !res; j++) {\n      if (col[i] != col[j]) continue;\n      int old = col[i];\n      col[i] = col[j] = cnt;\n      res |= calcAdvancedDP(col);\n      col[i] = col[j] = old;\n    }\n    break;\n  }\n  return dp[hash] = res;\n}\nvoid calcAdvancedDP(int n, vector<int>& col) {\n  int i = find(col.begin(), col.end(), -1) - col.begin();\n  if (i == (int)col.size()) {\n    calcAdvancedDP(col);\n    return;\n  }\n  for (int x = 0; x <= n; x++) {\n    for (int j = i + 1; j < (int)col.size(); j++) {\n      if (col[j] == -1) {\n        col[i] = col[j] = x;\n        calcAdvancedDP(x == n ? x + 1 : n, col);\n        col[i] = col[j] = -1;\n      }\n    }\n  }\n}\nvoid solve() {\n  int n, m, k;\n  scanf(\"%d %d %d\", &n, &m, &k);\n  for (int i = 1; i <= m; i++) {\n    int v, u;\n    scanf(\"%d %d\", &v, &u);\n    v--;\n    u--;\n    edge[v][u] = edge[u][v] = true;\n  }\n  vector<int> col(n, -1);\n  calcDP(0, col);\n  calcAdvancedDP(0, col);\n  vector<long long> fact(k + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= k; i++) fact[i] = fact[i - 1] * i;\n  long long ans = 0;\n  for (auto cur : dp) {\n    if (!cur.second) continue;\n    long long hash = cur.first;\n    int colors = 0;\n    while (hash) {\n      colors = max(colors, (int)(hash % 6));\n      hash /= 6;\n    }\n    if (colors + 1 <= k) ans += fact[k] / fact[k - colors - 1];\n  }\n  printf(\"%lld\\n\", ans);\n}\nint main() {\n  int tt = 1;\n  while (tt--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 12 + 5;\nconst int ALL = (1 << 12) + 5;\nconst int ALLP = (1 << 6) + 5;\nconst int inf = 0x3f3f3f3f;\nint num1[ALL];\nint n, m, d;\nbool hase[MAXN][MAXN];\nint pcnt;\npair<int, int> p[MAXN];\nunordered_set<long long> hsh[MAXN];\nint clr[MAXN], ccnt = 0;\nvoid dfs_clr(int dep) {\n  if (dep > pcnt) {\n    long long h = 0;\n    for (int i = 1; i <= n; ++i) h = h * 7 + clr[i];\n    hsh[ccnt].insert(h);\n    return;\n  }\n  int u = p[dep].first, v = p[dep].second;\n  for (int i = 1; i <= ccnt; ++i) {\n    clr[u] = clr[v] = i;\n    dfs_clr(dep + 1);\n  }\n  if (ccnt < d) {\n    clr[u] = clr[v] = ++ccnt;\n    dfs_clr(dep + 1);\n    --ccnt;\n  }\n}\nint dp[ALLP][MAXN];\nbool cango[MAXN][MAXN];\ninline void upd_hsh(void) {\n  for (int i = 1; i <= pcnt; ++i)\n    for (int j = 1; j < i; ++j)\n      cango[i][j] = cango[j][i] =\n          (hase[p[i].first][p[j].first] && hase[p[i].second][p[j].second]) ||\n          (hase[p[i].first][p[j].second] && hase[p[i].second][p[j].first]);\n  int all = (1 << pcnt) - 1;\n  for (int mask = 0; mask <= all; ++mask) memset(dp[mask], 0, (pcnt + 1) << 2);\n  for (int i = 1; i <= pcnt; ++i)\n    if (hase[p[i].first][p[i].second]) dp[(1 << (i - 1))][i] = 1;\n  for (int mask = 1; mask <= all; ++mask)\n    for (int i = 1; i <= pcnt; ++i)\n      if (dp[mask][i])\n        for (int j = 1; j <= pcnt; ++j)\n          if (!(((mask) >> (j - 1)) & 1) && cango[i][j])\n            dp[mask | (1 << (j - 1))][j] = 1;\n  if (*max_element(dp[all] + 1, dp[all] + pcnt + 1) == 0) return;\n  dfs_clr(1);\n}\nint main(void) {\n  for (int i = 1; i < ALL; ++i) num1[i] = num1[i ^ ((i) & -(i))] + 1;\n  scanf(\"%d%d%d\", &n, &m, &d);\n  for (int i = 1; i <= m; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    hase[u][v] = hase[v][u] = 1;\n  }\n  int all = (1 << n) - 1;\n  pcnt = n / 2;\n  for (int mask = 0; mask <= all; ++mask)\n    if (num1[mask] == n / 2) {\n      vector<int> a, b;\n      for (int i = 1; i <= n; ++i) {\n        if ((((mask) >> (i - 1)) & 1))\n          a.push_back(i);\n        else\n          b.push_back(i);\n      }\n      do {\n        bool ok = 1;\n        for (int i = 0; i < (int)a.size(); ++i)\n          if (a[i] > b[i]) {\n            ok = 0;\n            break;\n          }\n        if (!ok) continue;\n        for (int i = 1; i <= pcnt; ++i) p[i] = make_pair(a[i - 1], b[i - 1]);\n        upd_hsh();\n      } while (next_permutation(b.begin(), b.end()));\n    }\n  long long ans = 0;\n  for (int i = 1; i <= d; ++i)\n    if (hsh[i].size()) {\n      long long cur = 1;\n      for (int j = d - i + 1; j <= d; ++j) cur *= j;\n      ans += cur * (int)hsh[i].size();\n    }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 12;\nconst int K = 15;\nint n, m, k;\nbool c[N][N];\nlong long po[N];\nvector<int> v;\nvector<int> odd;\nint counter = 0;\nvector<pair<int, long long> > arr;\nvoid rec(int i, long long cur) {\n  if (i == n) {\n    if (counter == 0) arr.push_back(make_pair((int)v.size(), cur));\n    return;\n  }\n  v.push_back(i);\n  odd.push_back(1);\n  counter++;\n  rec(i + 1, cur + po[i] * i);\n  v.pop_back();\n  odd.pop_back();\n  counter--;\n  for (int j = 0; j < (int)v.size(); j++) {\n    odd[j] ^= 1;\n    if (odd[j])\n      counter++;\n    else\n      counter--;\n    rec(i + 1, cur + po[i] * v[j]);\n    odd[j] ^= 1;\n    if (odd[j])\n      counter++;\n    else\n      counter--;\n  }\n}\nvoid NumToVec(long long num, vector<int> &v) {\n  v.clear();\n  v.resize(n);\n  for (int i = 0; i < n; i++) {\n    v[i] = num % N;\n    num /= N;\n  }\n}\nvector<pair<int, int> > parr;\nbool dp[(1 << (N / 2))][N / 2];\nbool check() {\n  int sz = (int)parr.size();\n  for (int i = 0; i < sz; i++) {\n    dp[(1 << sz) - 1][i] = c[parr[i].first][parr[i].second];\n  }\n  for (int mask = (1 << sz) - 2; mask > 0; mask--) {\n    for (int last = 0; last < sz; last++) {\n      if (((mask >> last) & 1) == 0) continue;\n      dp[mask][last] = false;\n      for (int i = 0; i < sz; i++) {\n        if (((mask >> i) & 1) == 1) continue;\n        if (c[parr[i].first][parr[last].first] &&\n            c[parr[i].second][parr[last].second] && dp[mask ^ (1 << i)][i])\n          dp[mask][last] = true;\n        if (c[parr[i].second][parr[last].first] &&\n            c[parr[i].first][parr[last].second] && dp[mask ^ (1 << i)][i])\n          dp[mask][last] = true;\n      }\n    }\n  }\n  for (int i = 0; i < sz; i++) {\n    if (dp[(1 << i)][i]) return true;\n  }\n  return false;\n}\nmap<long long, bool> good;\nlong long ans = 0;\nint frq[N];\nlong long nck[K][K], fact[K];\nint main() {\n  po[0] = 1;\n  for (int i = 1; i < N; i++) po[i] = N * po[i - 1];\n  fact[0] = 1;\n  for (int i = 1; i < K; i++) fact[i] = (long long)i * fact[i - 1];\n  for (int i = 0; i < K; i++) {\n    nck[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      nck[i][j] = nck[i - 1][j] + nck[i - 1][j - 1];\n    }\n  }\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int a, b, i = 0; i < m; i++) {\n    scanf(\"%d%d\", &a, &b);\n    a--, b--;\n    c[a][b] = c[b][a] = true;\n  }\n  rec(0, 0);\n  sort(arr.begin(), arr.end());\n  reverse(arr.begin(), arr.end());\n  long long tmp = 0;\n  for (int i = 0; i < (int)arr.size(); i++) {\n    if (arr[i].first == n / 2) {\n      parr.clear();\n      NumToVec(arr[i].second, v);\n      for (int j = 0; j < (int)v.size(); j++) {\n        if (v[j] != j) parr.push_back(make_pair(j, v[j]));\n      }\n      good[arr[i].second] = check();\n    }\n    if (good[arr[i].second]) {\n      ans += nck[k][arr[i].first] * fact[arr[i].first];\n      if (arr[i].first != n / 2) NumToVec(arr[i].second, v);\n      memset(frq, 0, sizeof(frq));\n      for (int j = 0; j < (int)v.size(); j++) {\n        frq[v[j]]++;\n      }\n      for (int l = 0; l < n; l++) {\n        if (frq[l] == 0) continue;\n        for (int j = l + 1; j < n; j++) {\n          if (frq[j] == 0 || (frq[l] != 2 && frq[j] != 2)) continue;\n          tmp = arr[i].second;\n          for (int k = 0; k < (int)v.size(); k++) {\n            if (v[k] == j) {\n              tmp -= po[k] * j;\n              tmp += po[k] * l;\n            }\n          }\n          good[tmp] = true;\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<char>> g;\nmap<long long, bool> dp;\nvoid brute(int n, vector<int> &p) {\n  int x = find(p.begin(), p.end(), -1) - p.begin();\n  if (x == int(p.size())) {\n    vector<vector<char>> dp2(1 << n, vector<char>(n));\n    vector<int> pos1(n), pos2(n);\n    for (int i = 0; i < int(p.size()); i++) {\n      pos1[p[i]] = pos2[p[i]];\n      pos2[p[i]] = i;\n    }\n    for (int i = 0; i < int(n); i++)\n      if (g[pos1[i]][pos2[i]]) dp2[1 << i][i] = true;\n    for (int mask = 0; mask < int(1 << n); mask++)\n      for (int i = 0; i < int(n); i++)\n        if (dp2[mask][i]) {\n          for (int j = 0; j < int(n); j++)\n            if (!((mask >> j) & 1)) {\n              dp2[mask | (1 << j)][j] |=\n                  (g[pos1[i]][pos1[j]] && g[pos2[i]][pos2[j]]);\n              dp2[mask | (1 << j)][j] |=\n                  (g[pos1[i]][pos2[j]] && g[pos2[i]][pos1[j]]);\n            }\n        }\n    bool flag = 0;\n    for (int i = 0; i < int(n); i++)\n      if (dp2[(1 << n) - 1][i]) {\n        flag = 1;\n        break;\n      }\n    long long num = 0;\n    for (int x : p) num = num * 6 + x;\n    dp[num] = flag;\n    return;\n  }\n  for (int y = x + 1; y < int(p.size()); ++y)\n    if (p[y] == -1) {\n      p[x] = p[y] = n;\n      brute(n + 1, p);\n      p[x] = p[y] = -1;\n    }\n}\nbool dfs(vector<int> p) {\n  vector<int> used(int(p.size()), -1);\n  int cnt = 0;\n  for (int i = 0; i < int(p.size()); i++)\n    if (used[p[i]] == -1) used[p[i]] = cnt++;\n  long long num = 0;\n  for (int &x : p) {\n    x = used[x];\n    num = num * 6 + x;\n  }\n  if (dp.count(num)) return dp[num];\n  bool res = false;\n  vector<int> cur(cnt);\n  for (int i = 0; i < int(p.size()); i++) ++cur[p[i]];\n  for (int i = 0; i < int(p.size()); i++)\n    if (cur[p[i]] > 2) {\n      int x = p[i];\n      for (int j = i + 1; j < int(p.size()); ++j)\n        if (p[j] == p[i]) {\n          p[i] = p[j] = cnt;\n          if (dfs(p)) {\n            res = true;\n            break;\n          }\n          p[i] = p[j] = x;\n        }\n      break;\n    }\n  return dp[num] = res;\n}\nvoid brute2(int n, vector<int> &p) {\n  int x = find(p.begin(), p.end(), -1) - p.begin();\n  if (x == int(p.size())) {\n    dfs(p);\n    return;\n  }\n  for (int i = 0; i < int(n + 1); i++) {\n    for (int y = x + 1; y < int(p.size()); ++y)\n      if (p[y] == -1) {\n        p[x] = p[y] = i;\n        brute2(max(n, i + 1), p);\n        p[x] = p[y] = -1;\n      }\n  }\n}\nint main() {\n  int n, m, k;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  g.resize(n, vector<char>(n));\n  for (int _ = 0; _ < int(m); _++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    --v, --u;\n    g[v][u] = g[u][v] = 1;\n  }\n  vector<int> cur(n, -1);\n  brute(0, cur);\n  brute2(0, cur);\n  vector<long long> fact(k + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= k; ++i) fact[i] = fact[i - 1] * i;\n  long long ans = 0;\n  for (auto it : dp)\n    if (it.second) {\n      long long num = it.first;\n      long long mx = 1;\n      while (num) {\n        mx = max(mx, num % 6 + 1);\n        num /= 6;\n      }\n      if (mx <= k) {\n        ans += fact[k] / fact[k - mx];\n      }\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nvoid sc(int &x) { scanf(\"%d\", &x); }\nvoid sc(int &x, int &y) { scanf(\"%d%d\", &x, &y); }\nvoid sc(int &x, int &y, int &z) { scanf(\"%d%d%d\", &x, &y, &z); }\nvoid sc(long long &x) { scanf(\"%lld\", &x); }\nvoid sc(long long &x, long long &y) { scanf(\"%lld%lld\", &x, &y); }\nvoid sc(long long &x, long long &y, long long &z) {\n  scanf(\"%lld%lld%lld\", &x, &y, &z);\n}\nvoid sc(char *x) { scanf(\"%s\", x); }\nvoid sc(char *x, char *y) { scanf(\"%s%s\", x, y); }\nvoid sc(char *x, char *y, char *z) { scanf(\"%s%s%s\", x, y, z); }\nvoid out(int x) { printf(\"%d\\n\", x); }\nvoid out(long long x) { printf(\"%lld\\n\", x); }\nvoid out(int x, int y) { printf(\"%d %d\\n\", x, y); }\nvoid out(long long x, long long y) { printf(\"%lld %lld\\n\", x, y); }\nvoid out(int x, int y, int z) { printf(\"%d %d %d\\n\", x, y, z); }\nvoid out(long long x, long long y, long long z) {\n  printf(\"%lld %lld %lld\\n\", x, y, z);\n}\nvoid ast(long long x, long long l, long long r) { assert(x >= l && x <= r); }\nusing namespace std;\nconst int N = 5e5 + 5, mod = 998244353;\nint n, m, k;\nlong long f[15], c[15][15];\nbool e[15][15];\nlong long g[15];\nlong long ans;\nlong long st1, st2;\nlong long C(int n, int m) {\n  if (m == 0 || m == n) return 1;\n  if (m == 1) return n;\n  if (c[n][m]) return c[n][m];\n  return c[n][m] = C(n - 1, m - 1) + C(n - 1, m);\n}\nvector<pair<int, int>> vc;\nmap<long long, bool> vis;\nbool judge(vector<pair<int, int>> &vc) {\n  if (vis.count(st1)) return vis[st1];\n  int up = (1 << (vc.size())) - 1;\n  bool dp[up + 1][vc.size()];\n  memset(dp, false, sizeof(dp));\n  for (int i = 0; i < vc.size(); i++) dp[1 << i][i] = true;\n  for (int i = 0; i < up; i++)\n    for (int j = 0; j < vc.size(); j++)\n      if (dp[i][j]) {\n        for (int k = 0; k < vc.size(); k++)\n          if (!(i >> k & 1)) {\n            if (e[vc[k].first][vc[j].first] && e[vc[k].second][vc[j].second] ||\n                e[vc[k].first][vc[j].second] && e[vc[k].second][vc[j].first])\n              dp[i | (1 << k)][k] = true;\n          }\n      }\n  bool ans = false;\n  for (int i = 0; i < vc.size(); i++)\n    if (e[vc[i].first][vc[i].second]) ans |= dp[up][i];\n  return vis[st1] = ans;\n}\nset<long long> ok;\nvoid cal(vector<pair<int, int>> &vc, int mx) {\n  if (judge(vc)) {\n    if (!ok.count(st2)) {\n      ans += C(k, mx + 1) * f[mx + 1];\n      ok.insert(st2);\n    }\n  }\n}\nvoid dfs(int up, int mx) {\n  if (up == 0) {\n    cal(vc, mx);\n    return;\n  }\n  for (int i = 0; i < n; i++)\n    if (up >> i & 1) {\n      for (int j = i + 1; j < n; j++)\n        if (up >> j & 1) {\n          st1 += (i + 1) * g[vc.size() << 1];\n          st1 += (j + 1) * g[vc.size() << 1 | 1];\n          vc.push_back({i + 1, j + 1});\n          int nst = up ^ (1 << i) ^ (1 << j);\n          for (int s = 0; s <= mx + 1 && s < k; s++) {\n            st2 += (s + 1) * g[i];\n            st2 += (s + 1) * g[j];\n            dfs(nst, max(s, mx));\n            st2 -= (s + 1) * g[i];\n            st2 -= (s + 1) * g[j];\n          }\n          vc.pop_back();\n          st1 -= (i + 1) * g[vc.size() << 1];\n          st1 -= (j + 1) * g[vc.size() << 1 | 1];\n        }\n      break;\n    }\n}\nvoid ways() {\n  long long dp[13][13];\n  memset(dp, 0, sizeof(dp));\n  dp[1][0] = 1;\n  for (int i = 1; i < 12; i++)\n    for (int j = 0; j < 12; j++)\n      for (int k = 0; k <= j + 1 && k < 12; k++)\n        dp[i + 1][max(j, k)] += dp[i][j];\n  long long ans = 0;\n  for (int k = 0; k < 12; k++) ans += dp[12][k];\n  out(ans);\n}\nvoid sol(int cas) {\n  f[0] = g[0] = 1;\n  for (int i = 1; i < 15; i++) f[i] = f[i - 1] * i, g[i] = g[i - 1] * 13;\n  sc(n, m, k);\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    sc(x, y);\n    e[x][y] = e[y][x] = true;\n  }\n  int up = (1 << n) - 1;\n  dfs(up, -1);\n  out(ans);\n}\nint main() {\n  srand(time(0));\n  int t = 1, cas = 0;\n  while (t--) {\n    sol(++cas);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<char>> g;\nmap<long long, bool> dp;\nvoid brute(int n, vector<int> &p) {\n  int x = find(p.begin(), p.end(), -1) - p.begin();\n  if (x == int(p.size())) {\n    vector<vector<char>> dp2(1 << n, vector<char>(n));\n    vector<int> pos1(n), pos2(n);\n    for (int i = 0; i < int(p.size()); i++) {\n      pos1[p[i]] = pos2[p[i]];\n      pos2[p[i]] = i;\n    }\n    for (int i = 0; i < int(n); i++)\n      if (g[pos1[i]][pos2[i]]) dp2[1 << i][i] = true;\n    for (int mask = 0; mask < int(1 << n); mask++)\n      for (int i = 0; i < int(n); i++)\n        if (dp2[mask][i]) {\n          for (int j = 0; j < int(n); j++)\n            if (!((mask >> j) & 1)) {\n              dp2[mask | (1 << j)][j] |=\n                  (g[pos1[i]][pos1[j]] && g[pos2[i]][pos2[j]]);\n              dp2[mask | (1 << j)][j] |=\n                  (g[pos1[i]][pos2[j]] && g[pos2[i]][pos1[j]]);\n            }\n        }\n    for (int i = 0; i < int(n); i++)\n      if (dp2[(1 << n) - 1][i]) {\n        long long num = 0;\n        for (int x : p) num = num * 6 + x;\n        dp[num] = true;\n        break;\n      }\n    return;\n  }\n  for (int y = x + 1; y < int(p.size()); ++y)\n    if (p[y] == -1) {\n      p[x] = p[y] = n;\n      brute(n + 1, p);\n      p[x] = p[y] = -1;\n    }\n}\nbool dfs(vector<int> p) {\n  vector<int> used(int(p.size()), -1);\n  int cnt = 0;\n  for (int i = 0; i < int(p.size()); i++)\n    if (used[p[i]] == -1) used[p[i]] = cnt++;\n  long long num = 0;\n  for (int &x : p) {\n    x = used[x];\n    num = num * 6 + x;\n  }\n  if (dp.count(num)) return dp[num];\n  bool res = false;\n  vector<int> cur(cnt);\n  for (int i = 0; i < int(p.size()); i++) ++cur[p[i]];\n  for (int i = 0; i < int(p.size()); i++)\n    if (cur[p[i]] > 2) {\n      int x = p[i];\n      for (int j = i + 1; j < int(p.size()); ++j)\n        if (p[j] == p[i]) {\n          p[i] = p[j] = cnt;\n          if (dfs(p)) {\n            res = true;\n            break;\n          }\n          p[i] = p[j] = x;\n        }\n      break;\n    }\n  return dp[num] = res;\n}\nvoid brute2(int n, vector<int> &p) {\n  int x = find(p.begin(), p.end(), -1) - p.begin();\n  if (x == int(p.size())) {\n    dfs(p);\n    return;\n  }\n  for (int i = 0; i < int(n + 1); i++) {\n    for (int y = x + 1; y < int(p.size()); ++y)\n      if (p[y] == -1) {\n        p[x] = p[y] = i;\n        brute2(max(n, i + 1), p);\n        p[x] = p[y] = -1;\n      }\n  }\n}\nint main() {\n  int n, m, k;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  g.resize(n, vector<char>(n));\n  for (int _ = 0; _ < int(m); _++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    --v, --u;\n    g[v][u] = g[u][v] = 1;\n  }\n  vector<int> cur(n, -1);\n  brute(0, cur);\n  brute2(0, cur);\n  vector<long long> fact(k + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= k; ++i) fact[i] = fact[i - 1] * i;\n  long long ans = 0;\n  for (auto it : dp)\n    if (it.second) {\n      long long num = it.first;\n      long long mx = 1;\n      while (num) {\n        mx = max(mx, num % 6 + 1);\n        num /= 6;\n      }\n      if (mx <= k) {\n        ans += fact[k] / fact[k - mx];\n      }\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class t>\ninline void read(t &s) {\n  s = 0;\n  signed f = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) s = (s << 3) + (s << 1) + (c ^ 48), c = getchar();\n  ;\n  s *= f;\n}\ntemplate <class t, class... A>\ninline void read(t &x, A &...a) {\n  read(x);\n  read(a...);\n}\ntemplate <class t>\ninline void write(t x) {\n  if (x < 0) putchar('-'), x = -x;\n  static int buf[50], top = 0;\n  while (x) buf[++top] = x % 10, x /= 10;\n  if (!top) buf[++top] = 0;\n  while (top) putchar(buf[top--] ^ '0');\n}\ninline void setIn(std::string s) {\n  freopen(s.c_str(), \"r\", stdin);\n  return;\n}\ninline void setOut(std::string s) {\n  freopen(s.c_str(), \"w\", stdout);\n  return;\n}\ninline void setIO(std::string s = \"\") {\n  setIn(s + \".in\");\n  setOut(s + \".out\");\n  return;\n}\ntemplate <class t>\ninline bool ckmin(t &x, t y) {\n  if (x > y) {\n    x = y;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class t>\ninline bool ckmax(t &x, t y) {\n  if (x < y) {\n    x = y;\n    return 1;\n  }\n  return 0;\n}\ninline int lowbit(int x) { return x & (-x); }\nconst int MaxN = 15;\nstd::vector<int> E[MaxN];\nint g[MaxN][MaxN], n, m, K;\nstruct CC {\n  long long f[MaxN];\n  CC() {\n    f[0] = 1;\n    for (int i = 1; i < MaxN; ++i) f[i] = f[i - 1] * i;\n  }\n  inline long long operator()(int n, int m) const {\n    if (n < m || m < 0) return 0;\n    return f[n] / f[n - m];\n  }\n} C;\nint vis[MaxN];\nstd::pair<int, int> b[MaxN], d[MaxN];\nint p[MaxN], c[MaxN], e[MaxN];\n__int128 pw30;\nstd::vector<__int128> dr;\nstd::vector<std::vector<int> > Bell[MaxN];\ninline void work2() {\n  for (int ct = 1; ct <= std::min(K, n / 2); ++ct)\n    for (auto &ar : Bell[ct]) {\n      for (int i = 1; i <= n / 2; ++i)\n        e[d[i].first] = e[d[i].second] = ar[i - 1];\n      __int128 msk = 0;\n      for (int i = 1; i <= n; ++i) msk = msk * 100 + e[i];\n      msk += pw30 * ct;\n      dr.emplace_back(msk);\n    }\n}\ninline void dfs2(int dep, int cnt) {\n  if (dep > n / 2) {\n    std::vector<int> ret;\n    for (int i = 1; i <= n / 2; ++i) ret.push_back(c[i]);\n    Bell[cnt].push_back(ret);\n    return;\n  }\n  for (int i = 1; i <= cnt; ++i) c[dep] = i, dfs2(dep + 1, cnt);\n  if (cnt < K) c[dep] = cnt + 1, dfs2(dep + 1, cnt + 1);\n}\ninline void work() {\n  for (int i = 1; i <= n / 2; ++i) p[i] = i;\n  int flg = 0;\n  do {\n    for (int msk = 0; msk < (1 << (n / 2 - 1)); ++msk) {\n      for (int j = 1; j <= n / 2; ++j) d[j] = b[p[j]];\n      for (int j = 0; j < n / 2 - 1; ++j)\n        if (msk & (1 << j)) std::swap(d[j + 2].first, d[j + 2].second);\n      int now = 1;\n      for (int j = 1; now && j < n / 2; ++j)\n        now &= g[d[j].first][d[j + 1].first];\n      for (int j = 1; now && j < n / 2; ++j)\n        now &= g[d[j].second][d[j + 1].second];\n      now &= ((g[d[1].first][d[1].second]) ||\n              (g[d[n / 2].first][d[n / 2].second]));\n      if (now) {\n        flg = 1;\n        break;\n      }\n    }\n    if (flg) break;\n  } while (std::next_permutation(p + 1, p + n / 2 + 1));\n  if (!flg) return;\n  for (int i = 1; i <= n / 2; ++i) d[i] = b[i];\n  std::sort(d + 1, d + n / 2 + 1,\n            [&](std::pair<int, int> a, std::pair<int, int> b) {\n              return std::min(a.first, a.second) < std::min(b.first, b.second);\n            });\n  work2();\n}\ninline void dfs(int dep) {\n  if (dep > n / 2) return work();\n  int s = 0;\n  for (int i = 1; !s && i <= n; ++i)\n    if (!vis[i]) s = i;\n  vis[s] = 1;\n  for (int i = s + 1; i <= n; ++i)\n    if (!vis[i])\n      vis[i] = 1, b[dep] = std::make_pair(s, i), dfs(dep + 1), vis[i] = 0;\n  vis[s] = 0;\n}\nlong long f[MaxN];\nsigned main(void) {\n  pw30 = 1;\n  for (int i = 0; i < 30; ++i) pw30 *= 10;\n  read(n, m, K);\n  dfs2(1, 0);\n  int u, v;\n  for (int i = 1; i <= m; ++i)\n    read(u, v), E[u].push_back(v), E[v].push_back(u), g[u][v] = g[v][u] = 1;\n  dfs(1);\n  for (int i = 1; i <= K; ++i) f[i] = C(K, i);\n  std::sort((dr).begin(), (dr).end()),\n      dr.erase(std::unique((dr).begin(), (dr).end()), dr.end());\n  long long ans = 0;\n  for (auto i : dr) ans += f[i / pw30];\n  write(ans), putchar('\\n');\n  42;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<tuple<array<int8_t, 13>, int, int>> p;\nset<array<int8_t, 13>> s2, s1;\nint n, m, k, e[15][15];\nlong long as, ct[15], tt = 1;\nvoid dfs(array<int8_t, 13> a, int x, int y) {\n  if (x < y) swap(x, y);\n  a[x] = y;\n  if (p.count(make_tuple(a, x, y))) return;\n  p.insert(make_tuple(a, x, y));\n  bool v[13] = {};\n  for (int i = (1); i <= (n); i++)\n    if (a[i]) v[i] = v[a[i]] = 1;\n  if (*min_element(v + 1, v + n + 1)) {\n    if (e[x][y]) s1.insert(a);\n    return;\n  }\n  for (int i = (1); i <= (n); i++)\n    if (e[x][i] && !v[i])\n      for (int j = (1); j <= (n); j++)\n        if (i != j && e[y][j] && !v[j]) dfs(a, i, j);\n}\nvoid sol(array<int8_t, 13> a, int x) {\n  while (x <= n && a[x]) x++;\n  if (x > n) {\n    for (int i = (1); i <= (n); i++)\n      if (a[a[i]]) a[i] = a[a[i]];\n    s2.insert(a);\n    return;\n  }\n  vector<int> v;\n  for (int i = (x + 1); i <= (n); i++)\n    if (!a[i]) v.push_back(i);\n  int l = v.size();\n  for (int s = (0); s <= ((1 << l) - 1); s++) {\n    array<int8_t, 13> nw = a;\n    for (int i = (0); i <= (l - 1); i++)\n      if (s >> i & 1) nw[v[i]] = x;\n    sol(nw, x + 1);\n  }\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  int x, y;\n  for (int i = (1); i <= (n); i++) e[0][i] = e[i][0] = 1;\n  for (int i = (1); i <= (m); i++) scanf(\"%d%d\", &x, &y), e[x][y] = e[y][x] = 1;\n  dfs(array<int8_t, 13>(), 0, 0);\n  for (array<int8_t, 13> y : s1) sol(y, 1);\n  for (array<int8_t, 13> a : s2) {\n    int tt = 0;\n    for (int i = (1); i <= (n); i++)\n      if (!a[i]) tt++;\n    ct[tt]++;\n  }\n  for (int i = (1); i <= (n / 2); i++) {\n    tt = tt * (k - i + 1);\n    as += tt * ct[i];\n  }\n  printf(\"%lld\\n\", as);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, x, y, a[15], b[15], cnt[15], vis[15], p1[15], p2[15], g[15][15],\n    f[100][10];\nlong long ans, fac[15];\nunordered_map<long long, bool> mp;\nint read() {\n  int x = 0;\n  char c = getchar();\n  while (c < '0' || c > '9') c = getchar();\n  while (c >= '0' && c <= '9') x = x * 10 + (c ^ 48), c = getchar();\n  return x;\n}\nvoid dfs1(int x) {\n  int p = 1;\n  while (a[p]) p++;\n  if (p == n + 1) {\n    for (int i = 0; i < x; i++) p1[i] = p2[i] = 0;\n    for (int i = 1; i <= n; i++) {\n      if (!p1[a[i] - 1])\n        p1[a[i] - 1] = i;\n      else\n        p2[a[i] - 1] = i;\n    }\n    int M = 1 << x;\n    for (int S = 0; S < M; S++)\n      for (int i = 0; i < x; i++) f[S][i] = 0;\n    for (int i = 0; i < x; i++)\n      if (g[p1[i]][p2[i]]) f[1 << i][i] = 1;\n    for (int S = 0; S < M; S++) {\n      for (int i = 0; i < x; i++) {\n        if ((S >> i & 1) && f[S][i]) {\n          for (int j = 0; j < x; j++) {\n            if (!(S >> j & 1) && !f[S ^ (1 << j)][j] &&\n                (g[p1[j]][p1[i]] && g[p2[j]][p2[i]] ||\n                 g[p1[j]][p2[i]] && g[p2[j]][p1[i]])) {\n              f[S ^ (1 << j)][j] = 1;\n            }\n          }\n        }\n      }\n    }\n    for (int i = 0; i < x; i++) {\n      if (f[M - 1][i]) {\n        long long s = 0;\n        for (int j = 1; j <= n; j++) s = s * 6 + a[j] - 1;\n        mp[s] = 1;\n        break;\n      }\n    }\n    return;\n  }\n  for (int i = p + 1; i <= n; i++) {\n    if (!a[i]) {\n      a[p] = a[i] = x + 1;\n      dfs1(x + 1);\n      a[p] = a[i] = 0;\n    }\n  }\n}\nbool calc() {\n  int cur = 0;\n  for (int i = 1; i <= n; i++) vis[b[i]] = 0, cnt[b[i]] = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!vis[b[i]]) vis[b[i]] = ++cur;\n    cnt[b[i]]++;\n  }\n  long long s = 0;\n  for (int i = 1; i <= n; i++) s = s * 6 + vis[b[i]] - 1;\n  if (mp.count(s)) return mp[s];\n  for (int i = 1; i <= n; i++) {\n    if (cnt[b[i]] > 2) {\n      int t = b[i];\n      for (int j = i + 1; j <= n; j++) {\n        if (b[i] == b[j]) {\n          b[i] = b[j] = cur + 1;\n          if (calc()) {\n            mp[s] = 1;\n            return 1;\n          }\n          b[i] = b[j] = t;\n        }\n      }\n      break;\n    }\n  }\n  mp[s] = 0;\n  return 0;\n}\nvoid dfs2(int x) {\n  int p = 1;\n  while (a[p]) p++;\n  if (p == n + 1) {\n    for (int i = 1; i <= n; i++) b[i] = a[i];\n    calc();\n    return;\n  }\n  for (int i = 1; i <= x + 1; i++) {\n    for (int j = p + 1; j <= n; j++) {\n      if (!a[j]) {\n        a[p] = a[j] = i;\n        dfs2(max(x, i));\n        a[p] = a[j] = 0;\n      }\n    }\n  }\n}\nint main() {\n  n = read(), m = read(), k = read();\n  for (int i = 1; i <= m; i++) {\n    x = read(), y = read();\n    g[x][y] = g[y][x] = 1;\n  }\n  dfs1(0);\n  dfs2(0);\n  fac[0] = 1;\n  for (int i = 1; i <= k; i++) fac[i] = fac[i - 1] * i;\n  for (unordered_map<long long, bool>::iterator it = mp.begin(); it != mp.end();\n       ++it) {\n    if (it->second == 1) {\n      int mx = 1;\n      long long t = it->first;\n      while (t) mx = max((long long)mx, t % 6 + 1), t /= 6;\n      if (mx <= k) ans += fac[k] / fac[k - mx];\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 15;\nint n, m, k, p[N], ct[N], mt[N], fk;\nbool G[N][N];\nlong long A[N], ans;\npair<int, int> d[N];\nbool f[1 << N][N];\nunordered_map<int, bool> ok;\ninline bool solve() {\n  int hsh = 0, tot = 0;\n  for (int i = 1; i <= n; ++i)\n    if (mt[i] > i) d[++tot] = make_pair(i, mt[i]), hsh = hsh * 12 + mt[i] - 1;\n  if (ok.count(hsh)) return ok[hsh];\n  int st = 1 << tot;\n  for (int i = 0; i < st; ++i)\n    for (int j = 1; j <= tot; ++j) f[i][j] = 0;\n  for (int i = 1; i <= tot; ++i)\n    if (G[d[i].first][d[i].second]) f[1 << (i - 1)][i] = 1;\n  for (int i = 0; i < st; ++i)\n    for (int j = 1; j <= tot; ++j)\n      if (f[i][j]) {\n        int u = d[j].first, v = d[j].second;\n        for (int t = 0; t < tot; ++t)\n          if (!(i & (1 << t)))\n            if ((G[u][d[t + 1].first] & G[v][d[t + 1].second]) ||\n                (G[u][d[t + 1].second] & G[v][d[t + 1].first]))\n              f[i | (1 << t)][t + 1] = 1;\n      }\n  for (int i = 1; i <= tot; ++i)\n    if (f[st - 1][i]) return ok[hsh] = true;\n  return ok[hsh] = false;\n}\nbool dfs2(int u) {\n  if (u >= n) return solve();\n  if (mt[u]) return dfs2(u + 1);\n  for (int i = u + 1; i <= n; ++i)\n    if (!mt[i] && p[u] == p[i]) {\n      mt[i] = u, mt[u] = i;\n      if (dfs2(u + 1)) return true;\n      mt[i] = 0, mt[u] = 0;\n    }\n  return false;\n}\ninline void work() {\n  for (int i = 1; i <= k; ++i) ct[i] = 0;\n  for (int i = 1; i <= n; ++i) ++ct[p[i]], mt[i] = 0;\n  for (int i = 1; i <= k; ++i)\n    if (ct[i] & 1) return;\n  if (dfs2(1)) ans += A[*max_element(p + 1, p + n + 1)];\n}\nvoid dfs1(int pos) {\n  if (pos > n) return work();\n  int mx = 0;\n  for (int i = 1; i < pos; ++i) mx = max(mx, p[i]);\n  for (int i = 1; i <= min(k, mx + 1); ++i) p[pos] = i, dfs1(pos + 1);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 1; i <= k; ++i) {\n    A[i] = 1;\n    for (int j = k; j >= k - i + 1; --j) A[i] *= j;\n  }\n  for (int i = 1, u, v; i <= m; ++i)\n    scanf(\"%d%d\", &u, &v), G[u][v] = G[v][u] = 1;\n  dfs1(1);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<char> > g;\nmap<long long, bool> dp;\nvoid brute(int n, vector<int> &p) {\n  int x = find(p.begin(), p.end(), -1) - p.begin();\n  if (x == int(p.size())) {\n    vector<vector<char> > dp2(1 << n, vector<char>(n));\n    vector<int> pos1(n), pos2(n);\n    for (int i = 0; i < p.size(); i++) pos1[p[i]] = pos2[p[i]], pos2[p[i]] = i;\n    for (int i = 0; i < int(n); i++)\n      if (g[pos1[i]][pos2[i]]) dp2[1 << i][i] = true;\n    for (int mask = 0; mask < 1 << n; mask++)\n      for (int i = 0; i < n; i++)\n        if (dp2[mask][i])\n          for (int j = 0; j < n; j++)\n            if (!((mask >> j) & 1))\n              dp2[mask | (1 << j)][j] |=\n                  (g[pos1[i]][pos1[j]] && g[pos2[i]][pos2[j]]),\n                  dp2[mask | (1 << j)][j] |=\n                  (g[pos1[i]][pos2[j]] && g[pos2[i]][pos1[j]]);\n    for (int i = 0; i < int(n); i++)\n      if (dp2[(1 << n) - 1][i]) {\n        long long num = 0;\n        for (int x : p) num = num * 6 + x;\n        dp[num] = true;\n        break;\n      }\n    return;\n  }\n  for (int y = x + 1; y < int(p.size()); ++y)\n    if (p[y] == -1) p[x] = p[y] = n, brute(n + 1, p), p[x] = p[y] = -1;\n}\nbool dfs(vector<int> p) {\n  vector<int> used(int(p.size()), -1);\n  int cnt = 0;\n  for (int i = 0; i < int(p.size()); i++)\n    if (used[p[i]] == -1) used[p[i]] = cnt++;\n  long long num = 0;\n  for (int &x : p) x = used[x], num = num * 6 + x;\n  if (dp.count(num)) return dp[num];\n  bool res = false;\n  vector<int> cur(cnt);\n  for (int i = 0; i < int(p.size()); i++) ++cur[p[i]];\n  for (int i = 0; i < int(p.size()); i++)\n    if (cur[p[i]] > 2) {\n      int x = p[i];\n      for (int j = i + 1; j < int(p.size()); ++j)\n        if (p[j] == p[i]) {\n          p[i] = p[j] = cnt;\n          if (dfs(p)) {\n            res = true;\n            break;\n          }\n          p[i] = p[j] = x;\n        }\n      break;\n    }\n  return dp[num] = res;\n}\nvoid brute2(int n, vector<int> &p) {\n  int x = find(p.begin(), p.end(), -1) - p.begin();\n  if (x == int(p.size())) {\n    dfs(p);\n    return;\n  }\n  for (int i = 0; i < int(n + 1); i++)\n    for (int y = x + 1; y < int(p.size()); y++)\n      if (p[y] == -1)\n        p[x] = p[y] = i, brute2(max(n, i + 1), p), p[x] = p[y] = -1;\n}\nint main() {\n  int n, m, k;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  g.resize(n, vector<char>(n));\n  for (int i = 0, u, v; i < m; i++)\n    scanf(\"%d%d\", &v, &u), v--, u--, g[v][u] = g[u][v] = 1;\n  vector<int> cur(n, -1);\n  brute(0, cur), brute2(0, cur);\n  vector<long long> fact(k + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= k; ++i) fact[i] = fact[i - 1] * i;\n  long long ans = 0;\n  for (auto it : dp)\n    if (it.second) {\n      long long num = it.first, mx = 1;\n      while (num) mx = max(mx, num % 6 + 1), num /= 6;\n      if (mx <= k) ans += fact[k] / fact[k - mx];\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 12;\nconst int M = 1 << 12;\nconst long long P = 998244353LL;\nint n, m, k, cnt[M];\nlong long fac[N << 1], ans = 0, bin[N];\nbool e[N][N], f[M][N];\nmap<long long, bool> ok;\nvector<int> g, bel;\nnamespace Fread {\nconst int L = 1 << 15;\nchar buffer[L], *S, *T;\ninline char Getchar() {\n  if (S == T) {\n    T = (S = buffer) + fread(buffer, 1, L, stdin);\n    if (S == T) return EOF;\n  }\n  return *S++;\n}\ntemplate <class T>\ninline void read(T &X) {\n  char ch;\n  T op = 1;\n  for (ch = Getchar(); ch > '9' || ch < '0'; ch = Getchar())\n    if (ch == '-') op = -1;\n  for (X = 0; ch >= '0' && ch <= '9'; ch = Getchar())\n    X = (X << 1) + (X << 3) + ch - '0';\n  X *= op;\n}\n}  // namespace Fread\nusing Fread::read;\ninline int lowbit(int s) { return s & (-s); }\ninline long long getDivHash() {\n  vector<int> tmp(n);\n  long long res = 0;\n  for (int i = 0; i < g.size(); i++) {\n    for (int j = 0; j < n; j++) {\n      if (!(g[i] & (1 << j))) continue;\n      tmp[j] = i;\n    }\n  }\n  for (int i = 0; i < n; i++) res += bin[i] * tmp[i];\n  return res;\n}\ninline long long getPairHash(vector<int> &v) {\n  long long res = 0;\n  for (int i = 0; i < n; i++) {\n    assert(v[i] != -1);\n    res += bin[i] * v[i];\n  }\n  return res;\n}\ninline long long maintain(vector<int> cur) {\n  int p = 0;\n  vector<int> flag(n, -1);\n  for (int i = 0; i < cur.size(); i++) {\n    if (flag[cur[i]] == -1) flag[cur[i]] = p++;\n    cur[i] = flag[cur[i]];\n  }\n  return getPairHash(cur);\n}\nbool dp(long long cur) {\n  if (ok.find(cur) != ok.end()) return ok[cur];\n  long long res = false;\n  vector<int> tmp(n);\n  long long t = cur;\n  for (int i = 0; i < n; i++) {\n    tmp[i] = t % 6;\n    t /= 6;\n  }\n  int tot = n / 2;\n  vector<int> valCnt(tot);\n  for (int i = 0; i < n; i++) ++valCnt[tmp[i]];\n  for (int i = 0; i < n; i++) {\n    if (valCnt[tmp[i]] <= 2) continue;\n    int oldVal = tmp[i];\n    for (int j = i + 1; j < n; j++) {\n      if (tmp[j] != tmp[i]) continue;\n      tmp[i] = tmp[j] = tot;\n      if (dp(maintain(tmp))) {\n        res = true;\n        break;\n      }\n      tmp[i] = tmp[j] = oldVal;\n    }\n    break;\n  }\n  ok[cur] = res;\n  return res;\n}\ninline bool chkDiv() {\n  long long cur = getDivHash();\n  return dp(cur);\n}\ninline void chkPair() {\n  int tot = n / 2;\n  vector<int> p1(tot, -1), p2(tot, -1);\n  for (int i = 0; i < n; i++) {\n    if (p1[bel[i]] == -1) {\n      p1[bel[i]] = i;\n    } else {\n      assert(p2[bel[i]] == -1);\n      p2[bel[i]] = i;\n    }\n  }\n  for (int s = 0; s < (1 << tot); s++)\n    for (int i = 0; i < tot; i++) f[s][i] = 0;\n  for (int i = 0; i < tot; i++) f[1 << i][i] = 1;\n  for (int s = 1; s < (1 << tot); s++) {\n    for (int i = 0; i < tot; i++) {\n      if (!(s & (1 << i))) continue;\n      if (!f[s][i]) continue;\n      int x1 = p1[i], y1 = p2[i];\n      for (int j = 0; j < tot; j++) {\n        if (s & (1 << j)) continue;\n        int x2 = p1[j], y2 = p2[j];\n        if ((e[x1][x2] && e[y1][y2]) || (e[x1][y2] && e[x2][y1])) {\n          f[s ^ (1 << j)][j] = 1;\n        }\n      }\n    }\n  }\n  long long cur = getPairHash(bel);\n  bool res = false;\n  for (int i = 0; i < tot; i++) {\n    if (!f[(1 << tot) - 1][i]) continue;\n    if (e[p1[i]][p2[i]]) {\n      res = true;\n      break;\n    }\n  }\n  ok[cur] = res;\n}\nvoid dfsPair(int s, int cur) {\n  if (s == (1 << n) - 1) {\n    chkPair();\n    return;\n  }\n  int p = 0;\n  for (int i = 0; i < n; i++) {\n    if (!(s & (1 << i))) {\n      p = i;\n      break;\n    }\n  }\n  for (int i = p + 1; i < n; i++) {\n    if (s & (1 << i)) continue;\n    bel[p] = bel[i] = cur;\n    int tos = s ^ (1 << p) ^ (1 << i);\n    dfsPair(tos, cur + 1);\n    bel[p] = bel[i] = -1;\n  }\n}\nvoid dfsDiv(int s) {\n  if (s == (1 << n) - 1) {\n    if (chkDiv()) {\n      if (g.size() <= k) {\n        long long res = fac[k] / fac[k - g.size()];\n        ans += res;\n      }\n    }\n    return;\n  }\n  int r = ((1 << n) - 1) ^ s, x = lowbit(r);\n  for (int sub = r; sub; sub = (sub - 1) & r) {\n    if (!(sub & x)) continue;\n    if (cnt[sub] & 1) continue;\n    g.emplace_back(sub);\n    dfsDiv(s ^ sub);\n    g.pop_back();\n  }\n}\nint main() {\n  read(n), read(m), read(k);\n  fac[0] = 1;\n  for (int i = 1; i <= k; i++) fac[i] = fac[i - 1] * i;\n  for (int s = 0; s < (1 << n); s++) cnt[s] = __builtin_popcount(s);\n  bin[0] = 1;\n  for (int i = 1; i < n; i++) bin[i] = bin[i - 1] * 6;\n  for (int x, y, i = 1; i <= m; i++) {\n    read(x), read(y);\n    x--, y--;\n    e[x][y] = e[y][x] = 1;\n  }\n  bel.resize(n, -1);\n  dfsPair(0, 0);\n  dfsDiv(0);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2, 3, \"Ofast\")\n#pragma GCC target(\"avx\", \"avx2\")\nusing namespace std;\ntemplate <typename T1, typename T2>\nvoid ckmin(T1 &a, T2 b) {\n  if (a > b) a = b;\n}\ntemplate <typename T1, typename T2>\nvoid ckmax(T1 &a, T2 b) {\n  if (a < b) a = b;\n}\nint read() {\n  int x = 0, f = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate <typename T>\nvoid print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <typename T>\nvoid print(T x, char let) {\n  print(x), putchar(let);\n}\nconst int N = 12;\nbool mp[N][N];\nint n, m, K;\nint be[N], num[7];\nint vis[1 << N][N][N], ok[1 << N][N][N], tag;\nbool dfs(int mask, int u, int v) {\n  if (!mask) return 1;\n  if (vis[mask][u][v] == tag) return ok[mask][u][v];\n  vis[mask][u][v] = tag;\n  for (int i = 0; i <= n - 1; i++)\n    if ((mask >> i & 1)) {\n      for (int j = i + 1; j <= n - 1; j++)\n        if (i != j && (mask >> j & 1) && be[i] == be[j]) {\n          if (!(mp[u][i] && mp[v][j]) && !(mp[u][j] && mp[v][i])) continue;\n          if (dfs(mask ^ (1 << i) ^ (1 << j), i, j)) return ok[mask][u][v] = 1;\n        }\n    }\n  return ok[mask][u][v] = 0;\n}\nbool chk(int k) {\n  int mask = (1 << n) - 1;\n  for (int i = 0; i <= n - 1; i++) {\n    for (int j = i + 1; j <= n - 1; j++) {\n      ++tag;\n      if (mp[i][j] && be[i] == be[j] && dfs(mask ^ (1 << i) ^ (1 << j), i, j)) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\nlong long ans = 0;\nvoid dfs(int u, int k) {\n  if (u == n) {\n    bool ok = 1;\n    for (int i = 1; i <= k; i++) ok &= ~num[i] & 1;\n    if (!ok) return;\n    if (chk(k)) {\n      long long cf = 1;\n      for (int i = K; i >= K - k + 1; i--) cf *= i;\n      ans += cf;\n    }\n    return;\n  }\n  for (int i = 1; i <= min(6, k + 1); i++) {\n    be[u] = i, num[i]++;\n    dfs(u + 1, max(k, i));\n    be[u] = 0, num[i]--;\n  }\n}\nbool _[N];\nint ah = 0;\nvoid d(int u) {\n  _[u] = 1, ah++;\n  for (int i = 0; i < n; i++)\n    if (!_[i] && mp[u][i]) {\n      d(i);\n    }\n}\nint main() {\n  n = read(), m = read(), K = read();\n  for (int i = 1; i <= m; i++) {\n    int u = read() - 1, v = read() - 1;\n    mp[u][v] = mp[v][u] = 1;\n  }\n  d(0);\n  if (ah != n) return puts(\"0\"), 0;\n  dfs(0, 0);\n  print(ans, '\\n');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k;\nbool g[15][15];\nmap<long long, bool> dp;\nvoid parse(vector<int> &v) {\n  static int f[1 << 6][6], p1[6], p2[6];\n  memset(f, 0, sizeof(f));\n  memset(p1, -1, sizeof(p1));\n  memset(p2, -1, sizeof(p2));\n  for (int i = 0; i < v.size(); i++) {\n    if (p1[v[i]] == -1)\n      p1[v[i]] = i;\n    else\n      p2[v[i]] = i;\n  }\n  int c = n / 2;\n  for (int i = 0; i < c; i++) f[1 << i][i] = g[p1[i]][p2[i]];\n  for (int s = 0; s < 1 << c; s++)\n    for (int i = 0; i < c; i++)\n      if (f[s][i]) {\n        for (int j = 0; j < c; j++)\n          if (s >> j & 1 ^ 1) {\n            f[s | 1 << j][j] |= g[p1[i]][p1[j]] && g[p2[i]][p2[j]];\n            f[s | 1 << j][j] |= g[p1[i]][p2[j]] && g[p2[i]][p1[j]];\n          }\n      }\n  if (*max_element(f[(1 << c) - 1], f[(1 << c) - 1] + c)) {\n    long long h = 0;\n    for (int x : v) h = h * 6 + x;\n    dp[h] = 1;\n  }\n}\nvoid prec(int c, vector<int> &v) {\n  int x = 0;\n  while (x < n && v[x] != -1) x++;\n  if (x == n) {\n    parse(v);\n    return;\n  }\n  for (int y = x + 1; y < n; y++)\n    if (v[y] == -1) {\n      v[x] = v[y] = c;\n      prec(c + 1, v);\n      v[x] = v[y] = -1;\n    }\n}\nbool dfs(vector<int> &v) {\n  vector<int> u(n, -1);\n  int tot = 0;\n  for (int i = 0; i < n; i++)\n    if (u[v[i]] == -1) u[v[i]] = tot++;\n  long long h = 0;\n  for (int c : v) h = h * 6 + u[c];\n  if (dp.count(h)) return dp[h];\n  bool res = 0;\n  vector<int> cnt(tot);\n  for (int c : v) cnt[c]++;\n  for (int i = 0; i < v.size(); i++)\n    if (cnt[v[i]] > 2) {\n      int tmp = v[i];\n      for (int j = i + 1; j < v.size(); j++)\n        if (v[i] == v[j]) {\n          v[i] = v[j] = tot;\n          res = dfs(v);\n          v[i] = v[j] = tmp;\n          if (res) break;\n        }\n      break;\n    }\n  return dp[h] = res;\n}\nvoid gen(int c, vector<int> &v) {\n  int x = 0;\n  while (x < n && v[x] != -1) x++;\n  if (x == n) {\n    dfs(v);\n    return;\n  }\n  for (int i = 0; i <= c; i++) {\n    for (int y = x + 1; y < n; y++)\n      if (v[y] == -1) {\n        v[x] = v[y] = i;\n        gen(c + (c == i), v);\n        v[x] = v[y] = -1;\n      }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m >> k;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    g[a][b] = g[b][a] = 1;\n  }\n  vector<int> v(n, -1);\n  prec(0, v);\n  gen(0, v);\n  long long ans = 0;\n  vector<int> fact(1, 1);\n  for (int i = 1; i <= k; i++) fact.emplace_back(fact.back() * i);\n  for (auto [x, y] : dp)\n    if (y) {\n      int c = 0;\n      long long t = x;\n      while (t) {\n        c = max(c, int(t % 6));\n        t /= 6;\n      }\n      if (c < k) ans += fact[k] / fact[k - c - 1];\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, K;\nlong long ans;\nbool G[15][15];\nvector<pair<int, int> > vec;\nbool used[15], g[(1 << 6)][6];\nint bel[15];\nmap<long long, bool> f;\nlong long gao(int *bel) {\n  int mp[8] = {0}, now = 0;\n  for (int i = 1; i <= n; i++)\n    if (!mp[bel[i]]) mp[bel[i]] = now++;\n  long long ret = 0;\n  for (int i = 1; i <= n; i++) ret = ret * 6 + mp[bel[i]];\n  return ret;\n}\nlong long gao(vector<pair<int, int> > &vec) {\n  int bel[15];\n  for (int i = 0; i < vec.size(); i++)\n    bel[vec[i].first] = bel[vec[i].second] = i;\n  return gao(bel);\n}\nvoid calc() {\n  int N = n / 2;\n  memset(g, 0, sizeof(g));\n  for (int i = 0; i < N; i++) g[1 << i][i] = G[vec[i].first][vec[i].second];\n  for (int i = 1; i + 1 < (1 << N); i++)\n    for (int j = 0; j < N; j++)\n      if (g[i][j]) {\n        int a = vec[j].first, b = vec[j].second;\n        for (int k = 0; k < N; k++)\n          if (!(i >> k & 1)) {\n            int c = vec[k].first, d = vec[k].second;\n            if ((G[a][c] && G[b][d]) || (G[a][d] && G[b][c]))\n              g[i | (1 << k)][k] |= true;\n          }\n      }\n  for (int i = 0; i < N; i++)\n    if (g[(1 << N) - 1][i]) {\n      f[gao(vec)] = true;\n      return;\n    }\n  f[gao(vec)] = false;\n}\nvoid dfs1(int now) {\n  if (now > n) {\n    calc();\n    return;\n  }\n  used[now] = true;\n  for (int i = now + 1; i <= n; i++)\n    if (!used[i]) {\n      used[i] = true;\n      vec.push_back(pair<int, int>(now, i));\n      for (int j = 1;; j++)\n        if (!used[j]) {\n          dfs1(j);\n          break;\n        }\n      used[i] = false;\n      vec.pop_back();\n    }\n  used[now] = false;\n}\nbool dp(long long msk) {\n  if (f.count(msk)) return f[msk];\n  int bel[15], cnt[8] = {0}, mx = 0;\n  long long mm = msk;\n  for (int i = 0; i < n; i++, mm /= 6) {\n    int x = mm % 6;\n    bel[n - i] = x;\n    cnt[x]++;\n    mx = max(mx, x);\n  }\n  for (int i = 1; i <= n; i++)\n    if (cnt[bel[i]] > 2) {\n      int old = bel[i];\n      for (int j = i + 1; j <= n; j++)\n        if (bel[i] == bel[j]) {\n          bel[i] = bel[j] = mx + 1;\n          if (dp(gao(bel))) return f[msk] = true;\n          bel[i] = bel[j] = old;\n        }\n      break;\n    }\n  return f[msk] = false;\n}\nvoid dfs2(int now, int a, int b) {\n  if (now > n) {\n    long long x = 1;\n    for (int i = 0; i + 1 < a; i++) x *= K - i;\n    if (dp(gao(bel))) ans += x;\n    return;\n  }\n  bel[now] = a;\n  for (int i = now + 1; i <= n; i++)\n    if (!bel[i]) dfs2(i, a, b + 1);\n  if (b % 2 == 0)\n    for (int i = 1;; i++)\n      if (!bel[i]) {\n        dfs2(i, a + 1, 1);\n        break;\n      }\n  bel[now] = 0;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &K);\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    G[x][y] = G[y][x] = true;\n  }\n  dfs1(1);\n  dfs2(1, 1, 1);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, to[105], edge[105][105];\nbool dp[10][(1 << 6) + 11];\nmap<pair<long long, long long>, bool> M;\nvector<vector<pair<int, int>>> vec;\nvector<vector<vector<int>>> group;\nlong long ans, fac[105];\nvoid dfs0(int lvl) {\n  if (to[lvl]) return dfs0(lvl + 1);\n  if (lvl == n + 1) {\n    vector<pair<int, int>> cur;\n    for (int i = (1); i <= (n); i++)\n      if (i < to[i]) cur.push_back(make_pair(i, to[i]));\n    vec.push_back(cur);\n    return;\n  }\n  for (int i = (lvl + 1); i <= (n); i++) {\n    if (to[i]) continue;\n    to[lvl] = i;\n    to[i] = lvl;\n    dfs0(lvl + 1);\n    to[lvl] = to[i] = 0;\n  }\n}\nvoid dfs1(int lvl, int dep) {\n  if (lvl == n / 2 + 1) {\n    vector<vector<int>> cur;\n    cur.resize(dep);\n    for (int i = (1); i <= (n / 2); i++) cur[to[i] - 1].push_back(i - 1);\n    group.push_back(cur);\n    return;\n  }\n  for (int i = (1); i <= (dep + 1); i++) {\n    to[lvl] = i;\n    dfs1(lvl + 1, max(dep, i));\n  }\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  fac[0] = 1;\n  for (int i = (1); i <= (k); i++) fac[i] = fac[i - 1] * i;\n  for (int i = (1); i <= (m); i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    edge[u][v] = edge[v][u] = 1;\n  }\n  dfs0(1);\n  dfs1(1, 0);\n  for (auto x : vec) {\n    memset(dp, 0, sizeof dp);\n    for (int i = (0); i <= (n / 2 - 1); i++) {\n      if (edge[x[i].first][x[i].second]) dp[i][(1 << i)] = 1;\n    }\n    for (int s = (1); s <= ((1 << (n / 2)) - 1); s++) {\n      for (int i = (0); i <= (n / 2 - 1); i++) {\n        if (!dp[i][s]) continue;\n        for (int j = (0); j <= (n / 2 - 1); j++) {\n          if (s >> j & 1) continue;\n          if ((edge[x[i].first][x[j].first] &&\n               edge[x[i].second][x[j].second]) ||\n              (edge[x[i].first][x[j].second] &&\n               edge[x[i].second][x[j].first])) {\n            dp[j][s | (1 << j)] = 1;\n          }\n        }\n      }\n    }\n    bool flag = 0;\n    for (int i = (0); i <= (n / 2 - 1); i++) flag |= dp[i][(1 << (n / 2)) - 1];\n    if (!flag) continue;\n    for (auto y : group) {\n      int cnt = 0;\n      long long u = 0, v = 0;\n      for (auto z : y) {\n        cnt++;\n        if (cnt <= 3)\n          u <<= 12;\n        else\n          v <<= 12;\n        for (auto w : z) {\n          if (cnt <= 3) {\n            u |= (1 << (x[w].first - 1));\n            u |= (1 << (x[w].second - 1));\n          } else {\n            v |= (1 << (x[w].first - 1));\n            v |= (1 << (x[w].second - 1));\n          }\n        }\n      }\n      if (M[make_pair(u, v)]) continue;\n      M[make_pair(u, v)] = 1;\n      if (cnt <= k) ans += fac[k] / fac[k - cnt];\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng((int)chrono::steady_clock::now().time_since_epoch().count());\nint qtd[12];\nbool adj[15][15];\nbool check(string &s) {\n  vector<int> ord;\n  for (int i = 0; i < (int)s.size(); i++) {\n    ord.push_back(i);\n  }\n  sort(ord.begin(), ord.end(), [&](int a, int b) { return s[a] < s[b]; });\n  for (int i = 0; i < (int)s.size(); i += 2) {\n    if (i + 2 == (int)s.size()) {\n      if (!adj[ord[i]][ord[i + 1]]) return false;\n    } else {\n      int a = ord[i];\n      int b = ord[i + 1];\n      int c = ord[i + 2];\n      int d = ord[i + 3];\n      if (!((adj[a][c] && adj[b][d]) || (adj[a][d] && adj[b][c]))) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nstring normalize(string s) {\n  vector<int> ord;\n  for (int i = 0; i <= 6; i++) {\n    ord.push_back(0);\n  }\n  for (int i = 0, cnt = 0; i < (int)s.size(); i++) {\n    if (!ord[s[i] - '0']) ord[s[i] - '0'] = ++cnt;\n    s[i] = char('0' + ord[s[i] - '0']);\n  }\n  return s;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a - 1][b - 1] = adj[b - 1][a - 1] = true;\n  }\n  string s;\n  for (int i = 1; i <= n / 2; i++) {\n    s.push_back(char('0' + i));\n    s.push_back(char('0' + i));\n  }\n  set<string> vis;\n  queue<string> q;\n  do {\n    if (check(s)) {\n      string ns = normalize(s);\n      if (!vis.count(ns)) {\n        q.push(ns);\n        vis.insert(ns);\n      }\n    }\n  } while (next_permutation(s.begin(), s.end()));\n  while (!q.empty()) {\n    s = q.front();\n    q.pop();\n    char mx = '0';\n    for (int i = 0; i < (int)s.size(); i++) {\n      mx = max(mx, s[i]);\n    }\n    qtd[mx - '0']++;\n    string aux = s;\n    for (char i = '1'; i <= mx; i++) {\n      for (char j = char(i + 1); j <= mx; j++) {\n        for (int l = 0; l < (int)s.size(); l++) {\n          aux[l] = (s[l] == j ? i : (s[l] > j ? char(s[l] - 1) : s[l]));\n        }\n        if (!vis.count(aux)) {\n          q.push(aux);\n          vis.insert(aux);\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n / 2; i++) {\n    long long cost = 1;\n    for (int j = k; j >= k - i + 1; j--) {\n      cost *= j;\n    }\n    ans += qtd[i] * cost;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, bl[12];\nbool vis[12], E[12][12];\nlong long ans;\nvector<vector<int> > V, part;\nunordered_set<long long> se;\nvector<int> cur;\nlong long H(vector<int> p) {\n  long long s = 0;\n  for (int i = (0), iend = (n - 1); i <= iend; ++i) s = s * n + p[i];\n  return s;\n}\nvoid dfs0(int now) {\n  if (now == n)\n    part.push_back(cur);\n  else\n    for (int i = (0), iend = (n - 1); i <= iend; ++i)\n      if (!vis[i] && bl[now] == bl[i] && i != now && (i > now || cur[i] == now))\n        cur.push_back(i), vis[i] = 1, dfs0(now + 1), vis[i] = 0, cur.pop_back();\n}\nvoid dfs(int now) {\n  if (now == n) {\n    bool zzh = 1, asf = 0;\n    for (const auto& v : V) zzh &= v.size() % 2 == 0;\n    if (!zzh) return;\n    for (const auto& v : V)\n      for (const auto& x : v) bl[x] = v[0];\n    part.clear(), dfs0(0);\n    for (const auto& p : part)\n      if (se.count(H(p))) {\n        asf = 1;\n        break;\n      }\n    if (asf) {\n      long long res = 1;\n      for (int i = (1), iend = (V.size()); i <= iend; ++i) res *= k - i + 1;\n      ans += res;\n    }\n    return;\n  }\n  for (int i = (0), iend = (V.size() - 1); i <= iend; ++i)\n    V[i].push_back(now), dfs(now + 1), V[i].pop_back();\n  V.push_back({now}), dfs(now + 1), V.pop_back();\n}\nint main() {\n  cin >> n >> m >> k;\n  while (m--) {\n    int u, v;\n    cin >> u >> v, u--, v--, E[u][v] = E[v][u] = 1;\n  }\n  dfs0(0);\n  for (const auto& p : part) {\n    bool asf = 0;\n    int U[6], V[6], ct = 0;\n    for (int i = (0), iend = (n - 1); i <= iend; ++i)\n      if (i < p[i]) U[ct] = i, V[ct] = p[i], ct++;\n    int q[6];\n    for (int i = (0), iend = (ct - 1); i <= iend; ++i) q[i] = i;\n    do {\n      int x = U[q[0]], y = V[q[0]];\n      bool flg = E[x][y];\n      for (int i = (1), iend = (ct - 1); i <= iend; ++i) {\n        int u = U[q[i]], v = V[q[i]];\n        flg &= (E[x][u] && E[y][v]) || (E[x][v] && E[y][u]), x = u, y = v;\n      }\n      if (flg) {\n        asf = 1;\n        break;\n      }\n    } while (next_permutation(q, q + ct));\n    if (asf) se.insert(H(p));\n  }\n  return dfs(0), cout << ans << endl, 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, bl[12];\nbool vis[12], E[12][12];\nlong long ans, s;\nvector<vector<int> > V, part;\nunordered_set<long long> se;\nvector<int> cur;\nlong long H(vector<int> p) {\n  s = 0;\n  for (int i = (0), iend = (n - 1); i <= iend; ++i) s = s * n + p[i];\n  return s;\n}\nvoid dfs0(int now) {\n  if (now == n)\n    part.push_back(cur);\n  else\n    for (int i = (0), iend = (n - 1); i <= iend; ++i)\n      if (!vis[i] && bl[now] == bl[i] && i != now && (i > now || cur[i] == now))\n        cur.push_back(i), vis[i] = 1, dfs0(now + 1), vis[i] = 0, cur.pop_back();\n}\nvoid dfs(int now) {\n  if (now == n) {\n    bool asf = 0;\n    for (const auto& v : V)\n      if (v.size() % 2) return;\n    for (const auto& v : V)\n      for (const auto& x : v) bl[x] = v[0];\n    part.clear(), dfs0(0);\n    for (const auto& p : part)\n      if (se.count(H(p))) {\n        asf = 1;\n        break;\n      }\n    if (asf) {\n      long long res = 1;\n      for (int i = (1), iend = (V.size()); i <= iend; ++i) res *= k - i + 1;\n      ans += res;\n    }\n    return;\n  }\n  for (int i = (0), iend = (V.size() - 1); i <= iend; ++i)\n    V[i].push_back(now), dfs(now + 1), V[i].pop_back();\n  V.push_back({now}), dfs(now + 1), V.pop_back();\n}\nint main() {\n  cin >> n >> m >> k;\n  while (m--) {\n    int u, v;\n    cin >> u >> v, u--, v--, E[u][v] = E[v][u] = 1;\n  }\n  dfs0(0);\n  for (const auto& p : part) {\n    bool asf = 0;\n    int U[6], V[6], ct = 0;\n    for (int i = (0), iend = (n - 1); i <= iend; ++i)\n      if (i < p[i]) U[ct] = i, V[ct] = p[i], ct++;\n    int q[6];\n    for (int i = (0), iend = (ct - 1); i <= iend; ++i) q[i] = i;\n    do {\n      int x = U[q[0]], y = V[q[0]];\n      bool flg = E[x][y];\n      for (int i = (1), iend = (ct - 1); i <= iend; ++i) {\n        int u = U[q[i]], v = V[q[i]];\n        flg &= (E[x][u] && E[y][v]) || (E[x][v] && E[y][u]), x = u, y = v;\n      }\n      if (flg) {\n        asf = 1;\n        break;\n      }\n    } while (next_permutation(q, q + ct));\n    if (asf) se.insert(H(p));\n  }\n  return dfs(0), cout << ans, 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nint n, m, k, e[20][20], v[200000][14], vv[200000],\n    cc = 0, tmp[20], H[20], pw[20][20], cc2 = 0, dp[70][10], dist[200000];\nlong long ans = 0;\nvector<pair<int, int> > ddd;\nbool vis[20];\nmap<int, int> hsh;\nvoid dfs(int pos, int cur) {\n  if (pos == n) {\n    int ok[20];\n    for (int i = 0; i < n + 3; ++i) ok[i] = 0;\n    for (int i = 0; i < n; ++i) ok[tmp[i]] ^= 1;\n    bool okk = true;\n    for (int i = 1; i <= cur; ++i)\n      if (ok[i] == 1) okk = false;\n    if (okk) {\n      int val = 0;\n      for (int i = 0; i < n; ++i) v[cc][i] = tmp[i], val ^= pw[tmp[i]][i + 1];\n      hsh[val] = cc;\n      vv[cc++] = val;\n    }\n    return;\n  }\n  for (int i = 1; i <= cur; ++i) {\n    tmp[pos] = i;\n    dfs(pos + 1, cur);\n  }\n  tmp[pos] = cur + 1;\n  dfs(pos + 1, cur + 1);\n}\nbool check(vector<pair<int, int> > x) {\n  for (int i = 0; i < 65; ++i)\n    for (int j = 0; j < n + 2; ++j) dp[i][j] = 0;\n  for (int i = 0; i < x.size(); ++i)\n    if (e[x[i].first][x[i].second] == 1) dp[1 << i][i] = 1;\n  for (int i = 0; i < 1 << x.size(); ++i)\n    for (int j = 0; j < x.size(); ++j)\n      if (dp[i][j] == 1) {\n        for (int p = 0; p < x.size(); ++p)\n          if ((i & (1 << p)) == 0 && ((e[x[j].first][x[p].first] == 1 &&\n                                       e[x[j].second][x[p].second] == 1) ||\n                                      (e[x[j].first][x[p].second] == 1 &&\n                                       e[x[j].second][x[p].first] == 1)))\n            dp[i | (1 << p)][p] = 1;\n      }\n  bool ok = false;\n  for (int i = 0; i < x.size(); ++i) ok |= (dp[(1 << x.size()) - 1][i]);\n  return ok;\n}\nvoid trans(int *from, int *to) {\n  int mp[10], c = 0;\n  for (int i = 0; i < 8; ++i) mp[i] = -1;\n  for (int i = 0; i < n; ++i) {\n    if (mp[from[i]] == -1) mp[from[i]] = ++c;\n    to[i] = mp[from[i]];\n  }\n}\nvoid dfs2(int pos) {\n  if (pos == n) {\n    if (!check(ddd)) return;\n    for (int i = 0; i < ddd.size(); ++i) H[ddd[i].first] = H[ddd[i].second] = i;\n    trans(H, tmp);\n    int val = 0;\n    for (int i = 0; i < n; ++i) val ^= pw[tmp[i]][i + 1];\n    dist[hsh[val]] = 1;\n    return;\n  }\n  if (vis[pos]) {\n    dfs2(pos + 1);\n    return;\n  }\n  for (int i = pos + 1; i < n; ++i)\n    if (!vis[i]) {\n      ddd.push_back(make_pair(pos, i));\n      vis[pos] = vis[i] = true;\n      dfs2(pos + 1);\n      ddd.pop_back();\n      vis[pos] = vis[i] = false;\n    }\n}\nint dfs3(int pos) {\n  if (dist[pos] != 0) return dist[pos];\n  int cnt[10], mx = 0;\n  for (int i = 0; i < 8; ++i) cnt[i] = 0;\n  for (int i = 0; i < n; ++i) ++cnt[v[pos][i]], mx = max(mx, v[pos][i]);\n  int id = -1;\n  vector<int> s;\n  s.clear();\n  for (int i = 0; i < n; ++i)\n    if (cnt[i] >= 4) {\n      id = i;\n      for (int j = 0; j < n; ++j)\n        if (v[pos][j] == i) s.push_back(j);\n      break;\n    }\n  for (int i = 0; i < n; ++i) cnt[i] = v[pos][i];\n  for (int j = 0; j < s.size(); ++j)\n    for (int p = j + 1; p < s.size(); ++p) {\n      cnt[s[j]] = cnt[s[p]] = mx + 1;\n      trans(cnt, tmp);\n      int val = 0;\n      for (int r = 0; r < n; ++r) val ^= pw[tmp[r]][r + 1];\n      if (dfs3(hsh[val]) == 1) return dist[pos] = 1;\n      cnt[s[j]] = cnt[s[p]] = id;\n    }\n  return dist[pos] = -1;\n}\nint main() {\n  for (int i = 0; i < 18; ++i) {\n    H[i] = (long long)rand() * (long long)rand() % MOD;\n    pw[i][0] = 1;\n    for (int j = 1; j <= 17; ++j)\n      pw[i][j] = (long long)pw[i][j - 1] * (long long)H[i] % MOD;\n  }\n  cin >> n >> m >> k;\n  int x, y;\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    --x;\n    --y;\n    e[x][y] = e[y][x] = 1;\n  }\n  dfs(0, 0);\n  dfs2(0);\n  for (int i = 0; i < cc; ++i) {\n    map<int, int> tmpp;\n    tmpp.clear();\n    for (int j = 0; j < n; ++j) tmpp[v[i][j]] = 1;\n    if (tmpp.size() > k) continue;\n    long long mul = 1;\n    for (long long j = k; j > k - tmpp.size(); --j) mul *= j;\n    if (dfs3(i) == 1) ans += mul;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<tuple<array<int8_t, 13>, int, int>> p;\nset<array<int8_t, 13>> s2, s1;\nint n, m, k, e[15][15];\nlong long as, ct[15], tt = 1;\nvoid dfs(array<int8_t, 13> a, int x, int y) {\n  if (x < y) swap(x, y);\n  a[x] = y;\n  if (p.count(make_tuple(a, x, y))) return;\n  p.insert(make_tuple(a, x, y));\n  bool v[13] = {};\n  for (int i = (1); i <= (n); i++)\n    if (a[i]) v[i] = v[a[i]] = 1;\n  if (*min_element(v + 1, v + n + 1)) {\n    if (e[x][y]) s1.insert(a);\n    return;\n  }\n  for (int i = (1); i <= (n); i++)\n    if (e[x][i] && !v[i])\n      for (int j = (1); j <= (n); j++)\n        if (i != j && e[y][j] && !v[j]) dfs(a, i, j);\n}\nvoid sol(array<int8_t, 13> a, int x) {\n  while (x <= n && a[x]) x++;\n  if (x > n) {\n    for (int i = (1); i <= (n); i++)\n      if (a[a[i]]) a[i] = a[a[i]];\n    s2.insert(a);\n    return;\n  }\n  vector<int> v;\n  for (int i = (x + 1); i <= (n); i++)\n    if (!a[i]) v.push_back(i);\n  int l = v.size();\n  for (int s = (0); s <= ((1 << l) - 1); s++) {\n    array<int8_t, 13> nw = a;\n    for (int i = (0); i <= (l - 1); i++)\n      if (s >> i & 1) nw[v[i]] = x;\n    sol(nw, x + 1);\n  }\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  int x, y;\n  for (int i = (1); i <= (n); i++) e[0][i] = e[i][0] = 1;\n  for (int i = (1); i <= (m); i++) scanf(\"%d%d\", &x, &y), e[x][y] = e[y][x] = 1;\n  dfs(array<int8_t, 13>(), 0, 0);\n  for (array<int8_t, 13> y : s1) sol(y, 1);\n  for (array<int8_t, 13> a : s2) {\n    int tt = 0;\n    for (int i = (1); i <= (n); i++)\n      if (!a[i]) tt++;\n    ct[tt]++;\n  }\n  for (int i = (1); i <= (n / 2); i++) {\n    tt = tt * (k - i + 1);\n    as += tt * ct[i];\n  }\n  printf(\"%lld\\n\", as);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int mod = 1000000007;\nconst int gmod = 3;\nconst int inf = 1039074182;\nconst double eps = 1e-9;\nconst double pi = 3.141592653589793238462643383279;\nconst long long llinf = 2LL * inf * inf;\ntemplate <typename T1, typename T2>\ninline void chmin(T1 &x, T2 b) {\n  if (b < x) x = b;\n}\ntemplate <typename T1, typename T2>\ninline void chmax(T1 &x, T2 b) {\n  if (b > x) x = b;\n}\ninline void chadd(int &x, int b) {\n  x += b - mod;\n  x += (x >> 31 & mod);\n}\ntemplate <typename T1, typename T2>\ninline void chadd(T1 &x, T2 b) {\n  x += b;\n  if (x >= mod) x -= mod;\n}\ntemplate <typename T1, typename T2>\ninline void chmul(T1 &x, T2 b) {\n  x = 1LL * x * b % mod;\n}\ntemplate <typename T1, typename T2>\ninline void chmod(T1 &x, T2 b) {\n  x %= b, x += b;\n  if (x >= b) x -= b;\n}\ntemplate <typename T>\ninline T mabs(T x) {\n  return (x < 0 ? -x : x);\n}\nusing namespace std;\nusing namespace std;\ntemplate <typename T>\nostream &operator<<(ostream &cout, const vector<T> &vec) {\n  cout << \"{\";\n  for (int i = 0; i < (int)vec.size(); i++) {\n    cout << vec[i];\n    if (i != (int)vec.size() - 1) cout << ',';\n  }\n  cout << \"}\";\n  return cout;\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &cout, pair<T1, T2> p) {\n  cout << \"(\" << p.first << ',' << p.second << \")\";\n  return cout;\n}\ntemplate <typename T, typename T2>\nostream &operator<<(ostream &cout, set<T, T2> s) {\n  vector<T> t;\n  for (auto x : s) t.push_back(x);\n  cout << t;\n  return cout;\n}\ntemplate <typename T, typename T2>\nostream &operator<<(ostream &cout, multiset<T, T2> s) {\n  vector<T> t;\n  for (auto x : s) t.push_back(x);\n  cout << t;\n  return cout;\n}\ntemplate <typename T>\nostream &operator<<(ostream &cout, queue<T> q) {\n  vector<T> t;\n  while (q.size()) {\n    t.push_back(q.front());\n    q.pop();\n  }\n  cout << t;\n  return cout;\n}\ntemplate <typename T1, typename T2, typename T3>\nostream &operator<<(ostream &cout, map<T1, T2, T3> m) {\n  for (auto &x : m) {\n    cout << \"Key: \" << x.first << ' ' << \"Value: \" << x.second << endl;\n  }\n  return cout;\n}\ntemplate <typename T1, typename T2>\nvoid operator+=(pair<T1, T2> &x, const pair<T1, T2> y) {\n  x.first += y.first;\n  x.second += y.second;\n}\ntemplate <typename T1, typename T2>\npair<T1, T2> operator+(const pair<T1, T2> &x, const pair<T1, T2> &y) {\n  return make_pair(x.first + y.first, x.second + y.second);\n}\ntemplate <typename T1, typename T2>\npair<T1, T2> operator-(const pair<T1, T2> &x, const pair<T1, T2> &y) {\n  return make_pair(x.first - y.first, x.second - y.second);\n}\ntemplate <typename T1, typename T2>\npair<T1, T2> operator-(pair<T1, T2> x) {\n  return make_pair(-x.first, -x.second);\n}\ntemplate <typename T>\nvector<vector<T>> operator~(vector<vector<T>> vec) {\n  vector<vector<T>> v;\n  int n = vec.size(), m = vec[0].size();\n  v.resize(m);\n  for (int i = 0; i < m; i++) {\n    v[i].resize(n);\n  }\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      v[i][j] = vec[j][i];\n    }\n  }\n  return v;\n}\nvoid print0x(int x) {\n  std::vector<int> vec;\n  while (x) {\n    vec.push_back(x & 1);\n    x >>= 1;\n  }\n  std::reverse(vec.begin(), vec.end());\n  for (int i = 0; i < (int)vec.size(); i++) {\n    std::cout << vec[i];\n  }\n  std::cout << ' ';\n}\ntemplate <typename T>\nvoid print0x(T x, int len) {\n  std::vector<int> vec;\n  while (x) {\n    std::cout << (x & 1);\n    x >>= 1;\n    len--;\n  }\n  while (len--) cout << 0;\n}\nvector<string> vec_splitter(string s) {\n  s += ',';\n  vector<string> res;\n  while (!s.empty()) {\n    res.push_back(s.substr(0, s.find(',')));\n    s = s.substr(s.find(',') + 1);\n  }\n  return res;\n}\nvoid debug_out(vector<string> __attribute__((unused)) args,\n               __attribute__((unused)) int idx,\n               __attribute__((unused)) int LINE_NUM) {\n  cerr << endl;\n}\ntemplate <typename Head, typename... Tail>\nvoid debug_out(vector<string> args, int idx, int LINE_NUM, Head H, Tail... T) {\n  if (idx > 0)\n    cerr << \", \";\n  else\n    cerr << \"Line(\" << LINE_NUM << \") \";\n  stringstream ss;\n  ss << H;\n  cerr << args[idx] << \" = \" << ss.str();\n  debug_out(args, idx + 1, LINE_NUM, T...);\n}\nnamespace HASHTABLE {\nstruct HashInt {\n  int operator()(int x) {\n    x ^= (x >> 13);\n    return x;\n  }\n};\n}  // namespace HASHTABLE\ntemplate <typename Key, typename Value, typename Hash, int N, int mod>\nstruct HashTable {\n  int head[mod + 5];\n  int nxt[N + 5];\n  Value val[N + 5];\n  Key key[N + 5];\n  Hash hash;\n  int cnt;\n  HashTable() : cnt(1) {}\n  inline bool exist(const Key &k) {\n    int t = hash(k) % mod;\n    for (int i = head[t]; i; i = nxt[i]) {\n      if (key[i] == k) return true;\n    }\n    return false;\n  }\n  inline Value &at(const Key &k) {\n    int t = hash(k) % mod;\n    for (int i = head[t]; i; i = nxt[i]) {\n      if (key[i] == k) return val[i];\n    }\n    key[cnt] = k;\n    nxt[cnt] = head[t];\n    head[t] = cnt;\n    assert(cnt <= N);\n    return val[cnt++];\n  }\n  inline Value &operator[](const Key &k) { return at(k); }\n  inline void clear() {\n    cnt = 1;\n    memset(head, 0, sizeof(head));\n  }\n};\nnamespace combinatorics {\nint *fac;\nint *ifac;\nint __Tmod;\ninline int add(int a, int b) { return (a + b) % __Tmod; }\ninline int sub(int a, int b) { return (a - b + __Tmod) % __Tmod; }\ninline int mult(int a, int b) { return (1LL * a * b) % __Tmod; }\ninline int fastpow(int basic, int x) {\n  chmod(x, __Tmod - 1);\n  if (x == 0) return 1;\n  int res = 1;\n  while (x) {\n    if (x & 1) res = mult(res, basic);\n    basic = mult(basic, basic);\n    x >>= 1;\n  }\n  return res;\n}\ninline int inv(int x) { return fastpow(x, __Tmod - 2); }\ninline int div(int a, int b) { return mult(a, inv(b)); }\nvoid init(int n, int tmod) {\n  __Tmod = tmod;\n  fac = new int[n + 5];\n  ifac = new int[n + 5];\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fac[i] = mult(fac[i - 1], i);\n  }\n  ifac[n] = inv(fac[n]);\n  for (int i = n - 1; i >= 0; i--) {\n    ifac[i] = mult(ifac[i + 1], i + 1);\n  }\n}\ninline int C(int n, int m) {\n  if (n < m || n < 0 || m < 0) return 0;\n  return mult(mult(fac[n], ifac[m]), ifac[n - m]);\n}\ninline int Cat(int x) { return mult(C(x * 2, x), inv(x + 1)); }\n}  // namespace combinatorics\nusing combinatorics::fac;\nusing combinatorics::ifac;\nconst int prime = 1000000;\nusing namespace std;\nint n, k;\nint go[12][12];\nstruct State {\n  int a[12];\n};\nint tmp[12];\nvoid lsh(State &x) {\n  memset(tmp, -1, sizeof(tmp));\n  int cnt = 1;\n  for (int i = 0; i < n; i++) {\n    if (x.a[i] == 0) continue;\n    if (tmp[x.a[i]] == -1) tmp[x.a[i]] = cnt++;\n    x.a[i] = tmp[x.a[i]];\n  }\n}\nostream &operator<<(ostream &cout, const State &s) {\n  vector<int> v;\n  for (int i = 0; i < n; i++) v.push_back(s.a[i]);\n  cout << v;\n  return cout;\n}\nint to[12];\nstruct HashState {\n  inline int operator()(const State &s) const {\n    int res = 0;\n    memset(to, -1, sizeof(to));\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n      if (to[s.a[i]] == -1) to[s.a[i]] = ++cnt;\n      res = (1LL * res * prime + to[s.a[i]]) % mod;\n    }\n    return res;\n  }\n};\nstruct HashPiiState {\n  inline int operator()(const pair<pair<int, int>, State> &s) const {\n    int x = s.first.first, y = s.first.second;\n    if (x > y) swap(x, y);\n    int res = x * n + y;\n    memset(to, -1, sizeof(to));\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n      if (to[s.second.a[i]] == -1) to[s.second.a[i]] = ++cnt;\n      res = (1LL * res * prime + to[s.second.a[i]]) % mod;\n    }\n    return res;\n  }\n};\nHashState hs;\nbool operator==(State a, State b) {\n  lsh(a);\n  lsh(b);\n  for (int i = 0; i < n; i++) {\n    if (a.a[i] != b.a[i]) return false;\n  }\n  return true;\n}\nHashTable<State, bool, HashState, 1000000, 2000003> ht;\nHashTable<pair<pair<int, int>, State>, bool, HashPiiState, 2000000, 2000003>\n    ht2;\nHashTable<State, bool, HashState, 1000000, 2000003> hfuck;\nvoid dfs(State now) {\n  if (ht.exist(now)) return;\n  ht[now] = 1;\n  int cols[12];\n  for (int i = 0; i < n; i++) {\n    cols[i] = now.a[i];\n  }\n  sort(cols, cols + n);\n  int k = unique(cols, cols + n) - cols;\n  for (int i = 0; i < k; i++) {\n    for (int j = i + 1; j < k; j++) {\n      State nxt = now;\n      for (int t = 0; t < n; t++) {\n        if (nxt.a[t] == cols[j]) nxt.a[t] = cols[i];\n      }\n      dfs(nxt);\n    }\n  }\n}\nvector<State> vs;\nvoid bfs(State now, int x, int y, int p) {\n  if (p == n / 2 + 1) {\n    if (hfuck.exist(now)) return;\n    hfuck[now] = 1;\n    vs.emplace_back(now);\n    return;\n  }\n  if (ht2.exist(make_pair(make_pair(x, y), now))) return;\n  ht2[make_pair(make_pair(x, y), now)] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      if (now.a[i] || now.a[j] || !go[x][i] || !go[y][j]) continue;\n      now.a[i] = now.a[j] = p;\n      bfs(now, i, j, p + 1);\n      now.a[i] = now.a[j] = 0;\n    }\n  }\n}\nvoid read() {\n  int m;\n  cin >> n >> m >> k;\n  while (m--) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    x--;\n    y--;\n    go[x][y] = go[y][x] = 1;\n  }\n}\nint main() {\n  combinatorics::init(12, mod);\n  read();\n  State st;\n  memset(st.a, 0, sizeof(st.a));\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (!go[i][j]) continue;\n      st.a[i] = st.a[j] = 1;\n      bfs(st, i, j, 2);\n      st.a[i] = st.a[j] = 0;\n    }\n  }\n  for (auto x : vs) {\n    dfs(x);\n  }\n  long long res = 0;\n  for (int i = 1; i < ht.cnt; i++) {\n    st = ht.key[i];\n    map<int, int> m;\n    for (int j = 0; j < n; j++) {\n      m[st.a[j]]++;\n    }\n    if ((int)m.size() > k) continue;\n    res += 1LL * fac[k] * ifac[k - m.size()] % mod;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class t>\ninline void read(t &s) {\n  s = 0;\n  signed f = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) s = (s << 3) + (s << 1) + (c ^ 48), c = getchar();\n  ;\n  s *= f;\n}\ntemplate <class t, class... A>\ninline void read(t &x, A &...a) {\n  read(x);\n  read(a...);\n}\ntemplate <class t>\ninline void write(t x) {\n  if (x < 0) putchar('-'), x = -x;\n  static int buf[50], top = 0;\n  while (x) buf[++top] = x % 10, x /= 10;\n  if (!top) buf[++top] = 0;\n  while (top) putchar(buf[top--] ^ '0');\n}\ninline void setIn(std::string s) {\n  freopen(s.c_str(), \"r\", stdin);\n  return;\n}\ninline void setOut(std::string s) {\n  freopen(s.c_str(), \"w\", stdout);\n  return;\n}\ninline void setIO(std::string s = \"\") {\n  setIn(s + \".in\");\n  setOut(s + \".out\");\n  return;\n}\ntemplate <class t>\ninline bool ckmin(t &x, t y) {\n  if (x > y) {\n    x = y;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class t>\ninline bool ckmax(t &x, t y) {\n  if (x < y) {\n    x = y;\n    return 1;\n  }\n  return 0;\n}\ninline int lowbit(int x) { return x & (-x); }\nconst int MaxN = 15;\nstd::vector<int> E[MaxN];\nint g[MaxN][MaxN], n, m, K;\nstruct CC {\n  long long f[MaxN];\n  CC() {\n    f[0] = 1;\n    for (int i = 1; i < MaxN; ++i) f[i] = f[i - 1] * i;\n  }\n  inline long long operator()(int n, int m) const {\n    if (n < m || m < 0) return 0;\n    return f[n] / f[n - m];\n  }\n} C;\nint vis[MaxN];\nstd::pair<int, int> b[MaxN], d[MaxN];\nint p[MaxN], c[MaxN], e[MaxN];\n__int128 pw30;\nstd::vector<__int128> dr;\nstd::vector<std::vector<int> > Bell[MaxN];\ninline void work2() {\n  for (int ct = 1; ct <= std::min(K, n / 2); ++ct)\n    for (auto &ar : Bell[ct]) {\n      for (int i = 1; i <= n / 2; ++i)\n        e[d[i].first] = e[d[i].second] = ar[i - 1];\n      __int128 msk = 0;\n      for (int i = 1; i <= n; ++i) msk = msk * 100 + e[i];\n      msk += pw30 * ct;\n      dr.emplace_back(msk);\n    }\n}\ninline void dfs2(int dep, int cnt) {\n  if (dep > n / 2) {\n    std::vector<int> ret;\n    for (int i = 1; i <= n / 2; ++i) ret.push_back(c[i]);\n    Bell[cnt].push_back(ret);\n    return;\n  }\n  for (int i = 1; i <= cnt; ++i) c[dep] = i, dfs2(dep + 1, cnt);\n  if (cnt < K) c[dep] = cnt + 1, dfs2(dep + 1, cnt + 1);\n}\ninline void work() {\n  for (int i = 1; i <= n / 2; ++i) p[i] = i;\n  int flg = 0;\n  do {\n    for (int j = 1; j <= n / 2; ++j) d[j] = b[p[j]];\n    int now = 1;\n    for (int j = 1; now && j < n / 2; ++j)\n      now &=\n          (g[d[j].first][d[j + 1].first] && g[d[j].second][d[j + 1].second]) ||\n          (g[d[j].first][d[j + 1].second] && g[d[j].second][d[j + 1].first]);\n    now &=\n        ((g[d[1].first][d[1].second]) || (g[d[n / 2].first][d[n / 2].second]));\n    if (now) {\n      flg = 1;\n      break;\n    }\n  } while (std::next_permutation(p + 1, p + n / 2 + 1));\n  if (!flg) return;\n  for (int i = 1; i <= n / 2; ++i) d[i] = b[i];\n  std::sort(d + 1, d + n / 2 + 1,\n            [&](std::pair<int, int> a, std::pair<int, int> b) {\n              return std::min(a.first, a.second) < std::min(b.first, b.second);\n            });\n  work2();\n}\ninline void dfs(int dep) {\n  if (dep > n / 2) return work();\n  int s = 0;\n  for (int i = 1; !s && i <= n; ++i)\n    if (!vis[i]) s = i;\n  vis[s] = 1;\n  for (int i = s + 1; i <= n; ++i)\n    if (!vis[i])\n      vis[i] = 1, b[dep] = std::make_pair(s, i), dfs(dep + 1), vis[i] = 0;\n  vis[s] = 0;\n}\nlong long f[MaxN];\nsigned main(void) {\n  pw30 = 1;\n  for (int i = 0; i < 30; ++i) pw30 *= 10;\n  read(n, m, K);\n  dfs2(1, 0);\n  int u, v;\n  for (int i = 1; i <= m; ++i)\n    read(u, v), E[u].push_back(v), E[v].push_back(u), g[u][v] = g[v][u] = 1;\n  dfs(1);\n  for (int i = 1; i <= K; ++i) f[i] = C(K, i);\n  std::sort((dr).begin(), (dr).end()),\n      dr.erase(std::unique((dr).begin(), (dr).end()), dr.end());\n  long long ans = 0;\n  for (auto i : dr) ans += f[i / pw30];\n  write(ans), putchar('\\n');\n  42;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconst int N = 13;\nstruct ts {\n  int mask, l, r;\n};\nint n, m, k, step = 0;\nll ans;\nint comp[N], comp_mask[N];\nint cnk[N][N], f[N];\nint g[N];\nbool can_move[N][N];\nvector<int> lst[(1 << N)];\nint can[(1 << N)][N][N];\nts q[(1 << N) * N * N];\nvoid init() {\n  f[0] = cnk[0][0] = 1;\n  for (int i = 1; i < N; ++i) {\n    f[i] = f[i - 1] * i;\n    cnk[i][0] = 1;\n    for (int j = 1; j <= i; ++j) {\n      cnk[i][j] = cnk[i - 1][j - 1] + cnk[i - 1][j];\n    }\n  }\n  for (int i = 0; i < (1 << N); ++i) {\n    for (int j = 0; j < N; ++j) {\n      if ((i & (1 << j)) != 0) {\n        lst[i].push_back(j);\n      }\n    }\n  }\n}\nbool check(int y) {\n  for (int i = 0; i < y; ++i) {\n    comp_mask[i] = 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    comp_mask[comp[i]] |= (1 << i);\n  }\n  int cnt = 0;\n  for (int i = 0; i < y; ++i) {\n    assert(((int)(lst[comp_mask[i]]).size()) > 0);\n    if (((int)(lst[comp_mask[i]]).size()) % 2 != 0) {\n      ++cnt;\n    }\n  }\n  if (n % 2 == 0 && cnt > 0) {\n    return false;\n  }\n  if (n % 2 != 0 && cnt > 1) {\n    return false;\n  }\n  for (int i = 0; i < y; ++i) {\n    if (((int)(lst[comp_mask[i]]).size()) >= 2) {\n      bool found = false;\n      for (int l : lst[comp_mask[i]]) {\n        for (int r : lst[comp_mask[i]]) {\n          if (l != r && can_move[l][r]) {\n            found = true;\n            break;\n          }\n        }\n        if (found) {\n          break;\n        }\n      }\n      if (!found) {\n        return false;\n      }\n    }\n  }\n  ++step;\n  int qr = 0;\n  if (n % 2 == 0) {\n    for (int i = 0; i < n; ++i) {\n      int msk = ((1 << n) - 1) ^ (1 << i);\n      msk &= comp_mask[comp[i]];\n      msk &= g[i];\n      for (int j : lst[msk]) {\n        if (n == 2) {\n          return true;\n        }\n        if (can[(1 << i) | (1 << j)][i][j] != step) {\n          can[(1 << i) | (1 << j)][i][j] = step;\n          q[qr++] = {((1 << i) | (1 << j)), i, j};\n        }\n      }\n    }\n  } else {\n    for (int i = 0; i < n; ++i) {\n      can[(1 << i)][i][i] = step;\n      q[qr++] = {(1 << i), i, i};\n    }\n  }\n  while (qr > 0) {\n    ts s = q[--qr];\n    int left_neigs = (((1 << n) - 1) ^ s.mask) & g[s.l];\n    for (int i : lst[left_neigs]) {\n      int right_neigs = (((1 << n) - 1) ^ s.mask ^ (1 << i)) & g[s.r];\n      right_neigs &= comp_mask[comp[i]];\n      for (int j : lst[right_neigs]) {\n        if (can[s.mask | (1 << i) | (1 << j)][i][j] != step) {\n          can[s.mask | (1 << i) | (1 << j)][i][j] = step;\n          q[qr++] = {(s.mask | (1 << i) | (1 << j)), i, j};\n          if (q[qr - 1].mask == ((1 << n) - 1)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nvoid gen(int x, int y) {\n  if (x >= n) {\n    if (check(y)) {\n      ans += cnk[k][y] * f[y];\n    }\n    return;\n  }\n  for (int i = 0; i < y; ++i) {\n    comp[x] = i;\n    gen(x + 1, y);\n  }\n  if (y + 1 <= min((n + 1) / 2, k)) {\n    comp[x] = y;\n    gen(x + 1, y + 1);\n  }\n}\nvoid solve() {\n  scanf(\"%d %d %d\", &n, &m, &k);\n  for (int i = 0; i < n; ++i) {\n    g[i] = 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      can_move[i][j] = false;\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a;\n    --b;\n    g[a] |= (1 << b);\n    g[b] |= (1 << a);\n    can_move[a][b] = can_move[b][a] = true;\n  }\n  for (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        can_move[i][j] |= (can_move[i][k] & can_move[k][j]);\n      }\n    }\n  }\n  ans = 0;\n  gen(0, 0);\n  cout << ans << endl;\n}\nint main() {\n  init();\n  int t = 1;\n  for (int i = 0; i < t; ++i) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, k, hf;\nbool g[50][50];\ninline void addedge(long long from, long long to) {\n  g[from][to] = g[to][from] = true;\n}\nlong long makepair[50], ans;\nlong long chains[50][2], belong[50];\nlong long p[50], vis[50];\nbool check(long long u) {\n  if (u == hf + 1) {\n    for (long long i = 1; i <= hf; i++) vis[i] = 0;\n    return true;\n  }\n  for (long long i = 1; i <= hf; i++) {\n    if (vis[i]) continue;\n    if (u == 1) {\n      if (!g[chains[i][0]][chains[i][1]]) continue;\n    } else {\n      if (g[chains[p[u - 1]][0]][chains[i][0]] &&\n          g[chains[p[u - 1]][1]][chains[i][1]])\n        ;\n      else if (g[chains[p[u - 1]][0]][chains[i][1]] &&\n               g[chains[p[u - 1]][1]][chains[i][0]])\n        ;\n      else\n        continue;\n    }\n    p[u] = i, vis[i] = 1;\n    if (check(u + 1)) return true;\n    p[u] = 0, vis[i] = 0;\n  }\n  return false;\n}\nvector<vector<long long> > colors;\nvector<long long> nowcolor;\nvoid color(long long u, long long now) {\n  if (u == hf + 1) {\n    nowcolor[0] = now - 1;\n    colors.push_back(nowcolor);\n    return;\n  }\n  for (long long i = 1; i <= now; i++) {\n    nowcolor[u] = i;\n    color(u + 1, max(now, i + 1));\n  }\n}\nunordered_map<long long, bool> mp;\nlong long fac[50];\ninline void InitFac(long long n) {\n  fac[0] = 1;\n  for (long long i = 1; i <= n; i++) fac[i] = fac[i - 1] * i;\n}\ninline long long A(long long n, long long m) {\n  return n < m ? 0 : fac[n] / fac[n - m];\n}\nvoid dfs(long long u, long long now) {\n  while (u <= n && makepair[u]) u++;\n  if (u == n + 1) {\n    bool ok = check(1);\n    if (!ok) return;\n    for (auto vec : colors) {\n      long long Hash = 0;\n      for (long long i = 1; i <= n; i++)\n        Hash = Hash * hf + (vec[belong[i]] - 1);\n      if (!mp[Hash]) {\n        mp[Hash] = 1;\n        ans += A(k, vec[0]);\n      }\n    }\n    return;\n  }\n  for (long long i = u + 1; i <= n; i++)\n    if (!makepair[i]) {\n      makepair[u] = i, makepair[i] = u;\n      chains[now][0] = u, chains[now][1] = i;\n      belong[u] = belong[i] = now;\n      dfs(u + 1, now + 1);\n      makepair[u] = makepair[i] = 0;\n    }\n}\nsigned main() {\n  InitFac(15);\n  scanf(\"%lld %lld %lld\", &n, &m, &k);\n  hf = n >> 1;\n  while (m--) {\n    long long u, v;\n    scanf(\"%lld %lld\", &u, &v);\n    addedge(u, v);\n  }\n  memset(makepair, 0, sizeof(makepair));\n  nowcolor.resize(50);\n  color(1, 1);\n  dfs(1, 1);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int Max(int a, int b) { return a > b ? a : b; }\nconst int o = 100;\nint n, m, k, q[o], p[o], u[o], v[o];\nbool g[o][o], vis[o][o];\nlong long ans, c[o];\nmap<long long, bool> mp, usd;\ninline bool chk1() {\n  for (int i = 0; i < (n >> 1); ++i) u[i] = v[i] = 0;\n  for (int i = 1; i <= n; ++i)\n    if (u[p[i] - 1])\n      v[p[i] - 1] = i;\n    else\n      u[p[i] - 1] = i;\n  for (int i = 0; i < (1 << (n >> 1)); ++i)\n    for (int j = 0; j < (n >> 1); ++j) vis[i][j] = 0;\n  for (int i = 0; i < (n >> 1); ++i)\n    if (g[u[i]][v[i]]) vis[1 << i][i] = 1;\n  for (int i = 1; i < (1 << (n >> 1)); ++i)\n    for (int j = 0; j < (n >> 1); ++j)\n      if (vis[i][j])\n        for (int $ = 0; $ < (n >> 1); ++$)\n          if (!(i & (1 << $)))\n            vis[i | (1 << $)][$] |= ((g[u[j]][u[$]] && g[v[j]][v[$]]) ||\n                                     (g[u[j]][v[$]] && g[v[j]][u[$]]));\n  for (int i = 0; i < (n >> 1); ++i)\n    if (vis[(1 << (n >> 1)) - 1][i]) return true;\n  return false;\n}\nbool chk2() {\n  long long hsh = 0;\n  int mxc = 0;\n  for (int i = 1; i <= n; ++i) hsh = hsh * 7 + p[i], mxc = Max(mxc, p[i]);\n  if (mp.count(hsh)) return mp[hsh];\n  if (mxc == (n >> 1)) return mp[hsh] = chk1();\n  int cnt[7];\n  for (int i = 1; i <= (n >> 1); ++i) cnt[i] = 0;\n  for (int i = 1; i <= n; ++i) ++cnt[p[i]];\n  for (int i = 1; i <= n; ++i)\n    if (cnt[p[i]] > 2) {\n      for (int j = i + 1, $ = p[i]; j <= n; ++j)\n        if ($ == p[j]) {\n          p[i] = p[j] = mxc + 1;\n          if (chk2()) {\n            p[i] = p[j] = $;\n            return mp[hsh] = true;\n          }\n          p[i] = p[j] = $;\n        }\n      break;\n    }\n  return mp[hsh] = false;\n}\nvoid dfs(int col) {\n  int beg = 1;\n  for (; q[beg]; ++beg)\n    ;\n  if (beg > n) {\n    long long hsh = 0;\n    for (int i = 1; i <= n; ++i) hsh = hsh * 7 + (p[i] = q[i]);\n    if (usd[hsh]) return;\n    usd[hsh] = 1;\n    if (chk2()) ans += c[col - 1];\n    return;\n  }\n  for (int i = 1; i <= col; ++i)\n    for (int j = beg + 1; j <= n; ++j)\n      if (!q[j]) q[beg] = q[j] = i, dfs(Max(col, i + 1)), q[beg] = q[j] = 0;\n}\nint main() {\n  cin >> n >> m >> k;\n  for (int i = c[0] = 1; i <= k; ++i) c[i] = c[i - 1] * (k - i + 1);\n  for (int i = 1, $, _; i <= m; ++i) cin >> $ >> _, g[$][_] = g[_][$] = 1;\n  dfs(1);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid cmax(T& x, T y) {\n  if (x < y) x = y;\n}\ntemplate <typename T>\nvoid cmin(T& x, T y) {\n  if (y < x) x = y;\n}\ninline int read() {\n  int f = 1, x = 0;\n  char ch = getchar();\n  while (ch > '9' || ch < '0') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return f * x;\n}\nconst int N = 13;\nint n, m, k, E[N][N], cnt[N];\nstruct T {\n  int a[N];\n  T() { memset(a, 0, sizeof(a)); }\n  bool operator<(const T& o) const {\n    for (int i = (1); i <= (12); i++)\n      if (a[i] != o.a[i]) return a[i] < o.a[i];\n    return 0;\n  }\n};\nstruct TT {\n  T a;\n  int x, y;\n  bool operator<(const TT& o) const {\n    if (a < o.a || o.a < a) return a < o.a;\n    if (x != o.x) return x < o.x;\n    return y < o.y;\n  }\n};\nset<T> S1, S2;\nset<TT> S;\ninline void dfs(T arr, int x, int y) {\n  if (x > y) swap(x, y);\n  arr.a[y] = x;\n  if (S.count(TT{arr, x, y})) return;\n  S.insert(TT{arr, x, y});\n  bool vis[15] = {};\n  for (int i = (1); i <= (n); i++)\n    if (arr.a[i]) vis[i] = vis[arr.a[i]] = 1;\n  if (*min_element(vis + 1, vis + n + 1)) {\n    if (E[x][y]) S1.insert(arr);\n    return;\n  }\n  for (int i = (1); i <= (n); i++)\n    if (E[x][i] && !vis[i])\n      for (int j = (1); j <= (n); j++)\n        if (E[y][j] && !vis[j] && i ^ j) dfs(arr, i, j);\n}\ninline void work(T arr, int i) {\n  while (i <= n && arr.a[i]) i++;\n  if (i > n) {\n    for (int i = (1); i <= (n); i++)\n      if (arr.a[arr.a[i]]) arr.a[i] = arr.a[arr.a[i]];\n    return S2.insert(arr), void();\n  }\n  vector<int> v;\n  for (int j = (i + 1); j <= (n); j++)\n    if (!arr.a[j]) v.push_back(j);\n  for (int j = (0); j <= ((1 << ((int)v.size())) - 1); j++) {\n    T tmp = arr;\n    for (int k = (0); k <= (((int)v.size()) - 1); k++)\n      if ((j >> k) & 1) tmp.a[v[k]] = i;\n    work(tmp, i + 1);\n  }\n}\nint main() {\n  n = read(), m = read(), k = read();\n  for (int i = (1); i <= (m); i++) {\n    int x = read(), y = read();\n    E[x][y] = E[y][x] = 1;\n  }\n  for (int i = (1); i <= (n); i++)\n    for (int j = (1); j <= (n); j++)\n      if (i ^ j) dfs(T(), i, j);\n  for (auto x : S1) work(x, 1);\n  for (auto x : S2) {\n    int c = 0;\n    for (int i = (1); i <= (n); i++)\n      if (!x.a[i]) c++;\n    cnt[c]++;\n  }\n  long long t = 1, ans = 0;\n  for (int i = (1); i <= (n / 2); i++) {\n    t *= (k--);\n    ans += cnt[i] * t;\n  }\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nconst int SET_SIZE = 50349;\nusing Line = bitset<SET_SIZE>;\nvector<vector<int>> gen(int N) {\n  vector<vector<int>> res;\n  vector<int> cur(N);\n  function<void(int, int)> fill = [&](int nxt, int now) {\n    if (now == 0) {\n      res.push_back(cur);\n      return;\n    }\n    int mi = 31 - __builtin_clz(now);\n    now ^= (1 << mi);\n    cur[mi] = nxt;\n    for (int i = 0; i = (i - now) & now;)\n      if (__builtin_popcount(i) & 1) {\n        for (int j = 0; j < N; ++j)\n          if (i & (1 << j)) cur[j] = nxt;\n        fill(nxt + 1, now - i);\n        for (int j = 0; j < N; ++j)\n          if (i & (1 << j)) cur[j] = 0;\n      }\n    cur[mi] = 0;\n  };\n  fill(1, (1 << N) - 1);\n  return res;\n}\nLine ok(vector<vector<bool>> adj, vector<vector<int>> V) {\n  int N = adj.size();\n  map<tuple<int, int, int>, Line> DP;\n  for (int i = 0; i < N; ++i)\n    for (int j = 0; j < i; ++j)\n      if (adj[i][j])\n        for (int k = 0; k < (int)V.size(); ++k)\n          if (V[k][i] == V[k][j]) DP[{i, j, (1 << i) | (1 << j)}][k] = true;\n  vector<vector<Line>> eq(N, vector<Line>(N));\n  for (int i = 0; i < N; ++i)\n    for (int j = 0; j < i; ++j)\n      for (int k = 0; k < (int)V.size(); ++k)\n        if (V[k][i] == V[k][j]) eq[i][j][k] = true;\n  vector<vector<int>> VV(N + 1);\n  for (int b = 0; b < (1 << N); ++b) {\n    int p = __builtin_popcount(b);\n    VV[p].push_back(b);\n  }\n  for (int i = 4; i <= N; i += 2) {\n    map<tuple<int, int, int>, Line> NDP;\n    for (auto b : VV[i]) {\n      int p = __builtin_popcount(b);\n      if (p <= 2 || (p & 1)) continue;\n      for (int i = 0; i < N; ++i)\n        if ((1 << i) & b)\n          for (int j = 0; j < i; ++j)\n            if ((1 << j) & b) {\n              int rem = b ^ (1 << i) ^ (1 << j);\n              set<pair<int, int>> KS;\n              for (int k = 0; k < N; ++k)\n                if ((1 << k) & rem && adj[i][k])\n                  for (int s = 0; s < N; ++s)\n                    if (k != s && ((1 << s) & rem) && adj[s][j]) {\n                      KS.emplace(max(k, s), min(k, s));\n                    }\n              for (auto [k, s] : KS) {\n                if (DP.count({k, s, rem}))\n                  NDP[{i, j, b}] |= DP[{k, s, rem}] & eq[i][j] & eq[k][s];\n              }\n            }\n    }\n    DP.swap(NDP);\n    NDP.clear();\n  }\n  Line ret;\n  for (int i = 0; i < N; ++i)\n    for (int j = 0; j < i; ++j)\n      if (DP.count({i, j, (1 << N) - 1})) ret |= DP[{i, j, (1 << N) - 1}];\n  return ret;\n}\nlong long calc(int K, vector<int> x) {\n  long long ans = 1;\n  int mv = *max_element(x.begin(), x.end());\n  for (int i = 0; i < mv; ++i) ans *= K - i;\n  return ans;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int N, M, K;\n  cin >> N >> M >> K;\n  vector<vector<bool>> adj(N, vector<bool>(N));\n  for (int i = 0; i < M; ++i) {\n    int u, v;\n    cin >> u >> v;\n    --u;\n    --v;\n    adj[u][v] = adj[v][u] = 1;\n  }\n  vector<vector<int>> G = gen(N);\n  vector<vector<int>> G1(G.begin(), G.begin() + G.size() / 3);\n  vector<vector<int>> G2(G.begin() + G.size() / 3,\n                         G.begin() + G.size() * 2 / 3);\n  vector<vector<int>> G3(G.begin() + G.size() * 2 / 3, G.begin() + G.size());\n  auto res1 = ok(adj, G1);\n  auto res2 = ok(adj, G2);\n  auto res3 = ok(adj, G3);\n  long long ans = 0;\n  for (int i = 0; i < (int)G1.size(); ++i)\n    if (res1[i]) ans += calc(K, G1[i]);\n  for (int i = 0; i < (int)G2.size(); ++i)\n    if (res2[i]) ans += calc(K, G2[i]);\n  for (int i = 0; i < (int)G3.size(); ++i)\n    if (res3[i]) ans += calc(K, G3[i]);\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 13;\nint n, m, k;\nbool e[MAXN][MAXN];\nlong long comb[MAXN][MAXN];\nvector<vector<int> > R;\nint p[13];\nvoid dfs(int now, int mx) {\n  if (now == n / 2 + 1) {\n    vector<int> z;\n    for (int i = 1; i <= n / 2; ++i) z.push_back(p[i] - 1);\n    R.push_back(z);\n    return;\n  }\n  for (int z = 1; z <= mx + 1; ++z) {\n    p[now] = z;\n    dfs(now + 1, max(z, mx));\n  }\n}\nvector<vector<pair<int, int> > > R2;\nbool used[MAXN];\nvoid dfs2(int now) {\n  if (now == n + 1) {\n    vector<pair<int, int> > tmp;\n    for (int i = 1; i <= n / 2; ++i) {\n      tmp.push_back(make_pair(p[i] - 1, p[i + n / 2] - 1));\n    }\n    R2.push_back(tmp);\n    return;\n  }\n  if (now <= n / 2) {\n    for (int j = p[now - 1] + 1; j <= n; ++j) {\n      p[now] = j;\n      used[j] = 1;\n      dfs2(now + 1);\n      used[j] = 0;\n    }\n  } else {\n    for (int j = p[now - n / 2] + 1; j <= n; ++j) {\n      if (!used[j]) {\n        p[now] = j;\n        used[j] = 1;\n        dfs2(now + 1);\n        used[j] = 0;\n      }\n    }\n  }\n}\nconst int MOD = (1 << 22) - 1;\nconst unsigned int A = 10719;\nstruct Hashtable {\n  vector<vector<int> > tmp;\n  vector<int> nex;\n  int fir[MOD + 1];\n  Hashtable() { fill(fir, fir + MOD + 1, -1); }\n  unsigned int ky(vector<int>& v) {\n    unsigned int rest = 0;\n    unsigned int AA = 1;\n    for (auto it : v) {\n      rest += AA * it;\n      rest %= MOD;\n      AA *= A;\n    }\n    return rest;\n  }\n  void insert(vector<int>& v) {\n    int _ = ky(v);\n    for (int now = fir[_]; now != -1; now = nex[now])\n      if (tmp[now] == v) return;\n    nex.push_back(fir[_]);\n    fir[_] = tmp.size();\n    tmp.push_back(v);\n  }\n} table;\nint fa[MAXN], cnt[MAXN];\nlong long fact[MAXN];\nint root(int x) { return fa[x] = (fa[x] == x ? x : root(fa[x])); }\nvoid merge(int u, int v) {\n  u = root(u);\n  v = root(v);\n  fa[min(u, v)] = max(u, v);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  fact[0] = 1;\n  for (int i = 1; i <= 6; ++i) fact[i] = 1ll * i * fact[i - 1];\n  dfs(1, 0);\n  dfs2(1);\n  for (int i = 1; i <= m; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u--;\n    v--;\n    e[u][v] = e[v][u] = 1;\n  }\n  for (int i = 0; i <= k; ++i) comb[i][0] = 1;\n  for (int i = 1; i <= k; ++i)\n    for (int j = 1; j <= k; ++j)\n      comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n  bool dp[6][1 << 6];\n  int pre[6];\n  for (auto it : R2) {\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < it.size(); ++i)\n      if (e[it[i].first][it[i].second]) dp[i][1 << i] = 1;\n    for (int mask = 0; mask < 1 << it.size(); ++mask)\n      for (int i = 0; i < it.size(); ++i)\n        if (dp[i][mask]) {\n          for (int j = 0; j < it.size(); ++j) {\n            if ((mask >> j) & 1)\n              ;\n            else {\n              int u1, v1, u2, v2;\n              u1 = it[i].first, v1 = it[i].second;\n              u2 = it[j].first, v2 = it[j].second;\n              if ((e[u1][u2] && e[v1][v2]) || (e[u1][v2] && e[v1][u2]))\n                dp[j][mask | (1 << j)] = 1;\n            }\n          }\n        }\n    bool ok = false;\n    for (int i = 0; i < it.size(); ++i)\n      if (dp[i][(1 << it.size()) - 1]) ok = 1;\n    if (ok) {\n      for (auto it2 : R) {\n        fill(pre, pre + 6, -1);\n        for (int i = 0; i < n; ++i) fa[i] = i;\n        for (auto it3 : it) merge(it3.first, it3.second);\n        for (int i = 0; i < it2.size(); ++i) {\n          if (pre[it2[i]] == -1) {\n            pre[it2[i]] = i;\n            continue;\n          }\n          merge(it[pre[it2[i]]].first, it[i].first);\n        }\n        vector<int> Tmp;\n        for (int i = 0; i < n; ++i) Tmp.push_back(root(i));\n        table.insert(Tmp);\n      }\n    }\n  }\n  vector<vector<int> > H = table.tmp;\n  long long answer = 0;\n  for (auto ve : H) {\n    memset(cnt, 0, sizeof(cnt));\n    int nonz = 0;\n    for (auto it : ve) {\n      nonz += !cnt[it];\n      cnt[it] = 1;\n    }\n    answer += fact[nonz] * comb[k][nonz];\n  }\n  cout << answer << endl;\n  return 0;\n}\n"
        }
    ]
}