{
    "name": "878_B. Teams Formation",
    "source": "CODEFORCES",
    "description": "This time the Berland Team Olympiad in Informatics is held in a remote city that can only be reached by one small bus. Bus has n passenger seats, seat i can be occupied only by a participant from the city ai.\n\nToday the bus has completed m trips, each time bringing n participants. The participants were then aligned in one line in the order they arrived, with people from the same bus standing in the order of their seats (i. e. if we write down the cities where the participants came from, we get the sequence a1, a2, ..., an repeated m times).\n\nAfter that some teams were formed, each consisting of k participants form the same city standing next to each other in the line. Once formed, teams left the line. The teams were formed until there were no k neighboring participants from the same city.\n\nHelp the organizers determine how many participants have left in the line after that process ended. We can prove that answer doesn't depend on the order in which teams were selected.\n\nInput\n\nThe first line contains three integers n, k and m (1 \u2264 n \u2264 105, 2 \u2264 k \u2264 109, 1 \u2264 m \u2264 109).\n\nThe second line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 105), where ai is the number of city, person from which must take seat i in the bus. \n\nOutput\n\nOutput the number of remaining participants in the line.\n\nExamples\n\nInput\n\n4 2 5\n1 2 3 1\n\n\nOutput\n\n12\n\n\nInput\n\n1 9 10\n1\n\n\nOutput\n\n1\n\n\nInput\n\n3 2 10\n1 2 1\n\n\nOutput\n\n0\n\nNote\n\nIn the second example, the line consists of ten participants from the same city. Nine of them will form a team. At the end, only one participant will stay in the line.",
    "difficulty": "B",
    "tags": [
        "data structures",
        "implementation"
    ],
    "rating": 2300,
    "public_test": [
        {
            "input": "4 2 5\n1 2 3 1\n",
            "output": "12\n"
        },
        {
            "input": "1 9 10\n1\n",
            "output": "1\n"
        },
        {
            "input": "3 2 10\n1 2 1\n",
            "output": "0\n"
        }
    ],
    "generated_test": [
        {
            "input": "2 4 1\n1 0\n",
            "output": "2\n"
        },
        {
            "input": "5 3 2\n1 1 3 1 1\n",
            "output": "7\n"
        },
        {
            "input": "1 7 10\n1\n",
            "output": "3\n"
        },
        {
            "input": "4 2 5\n1 2 4 1\n",
            "output": "12\n"
        },
        {
            "input": "1 18 10\n1\n",
            "output": "10\n"
        },
        {
            "input": "3 2 10\n1 3 1\n",
            "output": "0\n"
        },
        {
            "input": "4 3 5\n1 2 4 1\n",
            "output": "20\n"
        },
        {
            "input": "5 3 3\n1 2 3 1 1\n",
            "output": "9\n"
        },
        {
            "input": "5 2 3\n1 3 3 1 1\n",
            "output": "1\n"
        },
        {
            "input": "4 5 1\n2 2 4 1\n",
            "output": "4\n"
        },
        {
            "input": "10 5 1000000000\n1 1 1 2 2 1 2 2 3 2\n",
            "output": "10000000000\n"
        },
        {
            "input": "4 2 2\n1 2 3 1\n",
            "output": "6\n"
        },
        {
            "input": "5 2 5\n1 2 3 1 1\n",
            "output": "15\n"
        },
        {
            "input": "4 5 2\n4 0 4 1\n",
            "output": "8\n"
        },
        {
            "input": "2 3 1\n1 0\n",
            "output": "2\n"
        },
        {
            "input": "5 3 2\n1 2 3 1 1\n",
            "output": "7\n"
        },
        {
            "input": "3 2 14\n1 3 1\n",
            "output": "0\n"
        },
        {
            "input": "4 5 5\n1 2 4 1\n",
            "output": "20\n"
        },
        {
            "input": "5 2 3\n1 2 3 1 1\n",
            "output": "9\n"
        },
        {
            "input": "4 5 5\n2 2 4 1\n",
            "output": "20\n"
        },
        {
            "input": "4 5 1\n2 4 4 1\n",
            "output": "4\n"
        },
        {
            "input": "4 5 1\n2 0 4 1\n",
            "output": "4\n"
        },
        {
            "input": "4 5 1\n4 0 4 1\n",
            "output": "4\n"
        },
        {
            "input": "4 5 1\n4 0 4 2\n",
            "output": "4\n"
        },
        {
            "input": "5 3 3\n1 2 2 2 1\n",
            "output": "0\n"
        },
        {
            "input": "2 4 1\n1 2\n",
            "output": "2\n"
        },
        {
            "input": "1 1000000000 1000000000\n110000\n",
            "output": "0\n"
        },
        {
            "input": "5 2 4\n1 2 1 2 1\n",
            "output": "0\n"
        },
        {
            "input": "1 10 2\n1\n",
            "output": "2\n"
        },
        {
            "input": "3 2 11\n1 2 1\n",
            "output": "3\n"
        },
        {
            "input": "4 2 5\n1 2 4 2\n",
            "output": "20\n"
        },
        {
            "input": "5 3 2\n1 2 3 0 1\n",
            "output": "10\n"
        },
        {
            "input": "3 2 22\n1 3 1\n",
            "output": "0\n"
        },
        {
            "input": "4 10 5\n1 2 4 1\n",
            "output": "20\n"
        },
        {
            "input": "4 5 5\n2 2 4 0\n",
            "output": "20\n"
        },
        {
            "input": "5 2 3\n1 0 3 1 1\n",
            "output": "9\n"
        },
        {
            "input": "4 5 1\n2 0 6 1\n",
            "output": "4\n"
        },
        {
            "input": "10 5 1000000000\n1 1 1 2 0 1 2 2 3 2\n",
            "output": "10000000000\n"
        },
        {
            "input": "2 4 1\n1 4\n",
            "output": "2\n"
        },
        {
            "input": "1 1000000000 1000000000\n110100\n",
            "output": "0\n"
        },
        {
            "input": "1 3 2\n1\n",
            "output": "2\n"
        },
        {
            "input": "4 2 2\n1 2 3 0\n",
            "output": "8\n"
        },
        {
            "input": "3 2 11\n2 2 1\n",
            "output": "1\n"
        },
        {
            "input": "4 2 5\n1 2 5 2\n",
            "output": "20\n"
        },
        {
            "input": "5 3 2\n1 2 3 -1 1\n",
            "output": "10\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k, b;\n  scanf(\"%d%d%d\", &n, &k, &b);\n  stack<pair<int, int> > st;\n  long long ans = (long long)n * b;\n  for (int i = 0, a; i < n; i++) {\n    scanf(\"%d\", &a);\n    if (st.size() && st.top().first == a) {\n      st.top().second++;\n      if (st.top().second == k) ans -= (long long)k * b, st.pop();\n    } else\n      st.push({a, 1});\n  }\n  deque<int> q;\n  while (st.size()) {\n    while (st.top().second) q.push_front(st.top().first), st.top().second--;\n    st.pop();\n  }\n  while (q.size()) {\n    int c = 0, x = q.front();\n    while (q.size() && q.front() == x) c++, q.pop_front();\n    while (q.size() && q.back() == x) c++, q.pop_back();\n    if (!q.size()) {\n      long long am = (long long)b * c;\n      if (am % k == 0) return puts(\"0\"), 0;\n      ans -= (am / k) * k;\n    } else if (c % k == 0) {\n      ans -= (long long)c * (b - 1);\n    } else {\n      ans -= (c / k) * k * (long long)(b - 1);\n      break;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 50;\nint zhan[N], arr[N], top, cnt[N];\nlong long n, m, K;\nint main() {\n  int i, j;\n  top = 0;\n  scanf(\"%I64d%I64d%I64d\", &n, &K, &m);\n  bool flag = 1;\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &arr[i]);\n    if (arr[i] != arr[1]) flag = 0;\n  }\n  if (flag) {\n    printf(\"%I64d\\n\", (m * n) % K);\n    return 0;\n  }\n  for (i = 1; i <= n; i++) {\n    if (top == 0 || zhan[top] != arr[i])\n      zhan[++top] = arr[i], cnt[top] = 1;\n    else\n      cnt[top]++;\n    if (cnt[top] == K) cnt[top] = 0, top--;\n  }\n  int tot = 0;\n  for (i = 1; i <= top; i++) {\n    for (j = 1; j <= cnt[i]; j++) arr[++tot] = zhan[i];\n  }\n  int L = 1, R = tot;\n  long long tmp = 0;\n  while (L < R && arr[L] == arr[R]) {\n    int l = L, r = R;\n    int num = 0;\n    while (num < K && l && r > l && arr[l] == arr[R]) l++, num++;\n    while (num < K && l && r > l && arr[r] == arr[R]) r--, num++;\n    if (num == K)\n      L = l, R = r, tmp += K;\n    else\n      break;\n  }\n  flag = 1;\n  for (i = L; i <= R; i++)\n    if (arr[i] != arr[L]) flag = 0;\n  long long len = (R - L + 1) * m;\n  if (flag) {\n    if (len % K == 0)\n      printf(\"0\\n\");\n    else\n      printf(\"%I64d\\n\", len % K + tmp);\n  } else\n    printf(\"%I64d\\n\", len + tmp);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class c>\nstruct rge {\n  c b, e;\n};\ntemplate <class c>\nrge<c> range(c i, c j) {\n  return rge<c>{i, j};\n}\ntemplate <class c>\nauto dud(c* x) -> decltype(cerr << *x, 0);\ntemplate <class c>\nchar dud(...);\nstruct debug {\n  template <class c>\n  debug& operator<<(const c&) {\n    return *this;\n  }\n};\nint main() {\n  int n, k, m;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  int interior = 0;\n  vector<pair<int, int>> t;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    if (t.empty() || t.back().first != x)\n      t.push_back({x, 1});\n    else {\n      t.back().second++;\n      if (t.back().second == k) {\n        t.pop_back();\n        ++interior;\n      }\n    }\n  }\n  vector<pair<int, int>> memo = t;\n  int border = 0;\n  int start = 0;\n  while ((int)t.size() - start >= 2 && t[start].first == t.back().first &&\n         t[start].second + t.back().second >= k) {\n    int tmp = t[start].second + t.back().second;\n    border += tmp / k;\n    tmp -= tmp / k * k;\n    if (tmp == 0) {\n      ++start;\n      t.pop_back();\n    } else {\n      t.pop_back();\n      t[start].second = tmp;\n    }\n  }\n  debug() << \" [\"\n          << \"interior\"\n             \": \"\n          << (interior)\n          << \"] \"\n             \" [\"\n          << \"border\"\n             \": \"\n          << (border) << \"] \";\n  long long answer =\n      (long long)interior * m * k + (long long)border * (m - 1) * k;\n  if ((int)t.size() == start + 1) {\n    long long a = (long long)m * t[start].second;\n    answer += a / k * k;\n    a -= a / k * k;\n    if (a == 0) {\n      debug() << \"spec case\";\n      vector<pair<int, int>> nowy;\n      for (int i = 0; i < start; ++i) nowy.push_back(memo[i]);\n      for (int i = (int)t.size(); i < (int)memo.size(); ++i)\n        nowy.push_back(memo[i]);\n      debug() << \" [\"\n              << \"nowy\"\n                 \": \"\n              << (nowy) << \"] \";\n      vector<pair<int, int>> dwa;\n      for (pair<int, int> p : nowy) {\n        if (dwa.empty() || dwa.back().first != p.first)\n          dwa.push_back(p);\n        else {\n          dwa.back().second += p.second;\n          answer += dwa.back().second / k * k;\n          dwa.back().second %= k;\n          if (dwa.back().second == 0) dwa.pop_back();\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", (long long)n * m - answer);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dim = 500005;\nint n, m, k;\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cin >> n >> k >> m;\n  long long total = 1LL * n * m;\n  list<pair<int, int> > v;\n  for (int i = 1; i <= n; ++i) {\n    int x;\n    cin >> x;\n    if (v.empty() || v.back().first != x)\n      v.push_back({x, 1});\n    else\n      v.back().second++;\n  }\n  list<pair<int, int> > w;\n  for (auto it : v) {\n    if (w.empty()) {\n      if (it.second % k == 0) {\n        total -= 1LL * it.second * m;\n      } else {\n        w.push_back({it.first, it.second % k});\n        total -= 1LL * (it.second - it.second % k) * m;\n      }\n      continue;\n    }\n    if (w.back().first != it.first) {\n      if (it.second % k == 0) {\n        total -= 1LL * it.second * m;\n      } else {\n        w.push_back({it.first, it.second % k});\n        total -= 1LL * (it.second - it.second % k) * m;\n      }\n      continue;\n    }\n    w.back().second += it.second;\n    if (w.back().second % k == 0) {\n      total -= 1LL * w.back().second * m;\n      w.pop_back();\n    } else {\n      total -= 1LL * (w.back().second - w.back().second % k) * m;\n      w.back().second %= k;\n    }\n  }\n  v = w;\n  w.clear();\n  while (!v.empty()) {\n    if (v.size() == 1) {\n      total -= (1LL * m * v.back().second - 1LL * m * v.back().second % k);\n      if (1LL * m * v.back().second % k == 0) v.pop_back();\n      break;\n    }\n    if (v.front().first != v.back().first) break;\n    int s = v.front().second + v.back().second;\n    if (s % k != 0) {\n      total -= 1LL * (m - 1) * (s - s % k);\n      break;\n    }\n    total -= 1LL * (m - 1) * s;\n    w.push_back(v.back());\n    w.push_front(v.front());\n    v.pop_back();\n    v.pop_front();\n  }\n  if (v.empty()) {\n    v = w;\n    if (!v.empty()) {\n      auto it2 = v.begin();\n      auto it1 = it2++;\n      while (it1->first != it2->first) it1++, it2++;\n      while (true) {\n        int s = it1->second + it2->second;\n        if (s % k) {\n          total -= s - s % k;\n          break;\n        } else {\n          total -= s;\n          it2++;\n          if (it2 == v.end()) break;\n          it1--;\n        }\n      }\n    }\n  }\n  cout << total << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 1;\nlong long n, m, k, a[N], c;\nlong long res;\npair<long long, long long> q[N], st[N], ed[N];\nint main() {\n  scanf(\"%I64d%I64d%I64d\", &n, &k, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%I64d\", &a[i]);\n  for (int i = 1, t = 1; i <= n; i = t + 1) {\n    t = i;\n    while (a[t + 1] == a[t]) t++;\n    if ((t - i + 1) % k) q[++c] = make_pair(a[i], (t - i + 1) % k);\n    while (q[c].first == q[c - 1].first && c > 1) {\n      c--;\n      q[c].second += q[c + 1].second;\n      q[c].second %= k;\n      if (!q[c].second) c--;\n    }\n  }\n  for (int i = 1; i <= c; ++i) st[i] = ed[i] = q[i], res += q[i].second;\n  res *= m;\n  int l = 1, r = c;\n  int stl = 1, edl = 1, str = c, edr = c;\n  while (l <= r) {\n    if (l == r) {\n      if (q[l].second * m >= k) {\n        long long t = q[l].second * m % k;\n        res -= (q[l].second * m - t);\n        if (t) return 0 * printf(\"%I64d\", res);\n        int c1 = c;\n        c = 0;\n        str--;\n        edl++;\n        for (int i = 1; i <= str; ++i) {\n          q[++c] = st[i];\n          while (q[c].first == q[c - 1].first) {\n            c--;\n            q[c].second += q[c + 1].second;\n            res -= (q[c].second / k) * k;\n            q[c].second %= k;\n            if (!q[c].second) c--;\n          }\n        }\n        for (int i = edl; i <= c1; ++i) {\n          q[++c] = ed[i];\n          while (q[c].first == q[c - 1].first && c > 1) {\n            c--;\n            q[c].second += q[c + 1].second;\n            res -= (q[c].second / k) * k;\n            q[c].second %= k;\n            if (!q[c].second) c--;\n          }\n        }\n        break;\n      } else\n        break;\n    } else if (q[r].first == q[l].first && q[r].second + q[l].second >= k) {\n      long long t = (q[r].second + q[l].second) % k;\n      res -= (q[r].second + q[l].second - t) * (m - 1);\n      q[r].second = t;\n      q[str].second = t;\n      if (!q[r].second) r--, str--;\n      l++;\n      edl++;\n    } else\n      break;\n  }\n  return 0 * printf(\"%I64d\", res);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid morir(long long int s) {\n  cout << s << endl;\n  exit(0);\n}\nint suma(vector<pair<int, int> > &v, int i1, int i2) {\n  int s = 0;\n  for (int i = i1; i <= i2; i++) s += v[i].second;\n  return s;\n}\nlong long int n, k, m;\nvector<pair<int, int> > reduce(vector<pair<int, int> > v) {\n  vector<pair<int, int> > nextv;\n  for (int i = 0; i < int(v.size()); i++) {\n    if (int(nextv.size()) == 0 or v[i].first != nextv.back().first)\n      nextv.push_back(v[i]);\n    else\n      nextv.back().second += v[i].second;\n    if (nextv.back().second % k == 0) nextv.pop_back();\n  }\n  return nextv;\n}\nvoid termina(vector<pair<int, int> > v) {\n  v = reduce(v);\n  morir(suma(v, 0, int(v.size()) - 1));\n}\nvector<pair<int, int> > v;\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    v.push_back(pair<int, int>(x, 1));\n  }\n  v = reduce(v);\n  if (m == 1) termina(v);\n  int ind = 0;\n  n = int(v.size());\n  for (;;) {\n    if (n < 2 * (ind + 1)) {\n      if (n % 2 == 0) termina(v);\n      vector<pair<int, int> > w;\n      for (int i = 0; i < n; i++) {\n        if (2 * i + 1 == n)\n          w.push_back(pair<int, int>(v[i].first, m * v[i].second % k));\n        else\n          w.push_back(v[i]);\n      }\n      termina(w);\n    }\n    if (v[ind].first == v[n - 1 - ind].first and\n        (v[ind].second + v[n - 1 - ind].second) % k == 0) {\n      ind++;\n      continue;\n    }\n    if (v[ind].first == v[n - 1 - ind].first)\n      morir(suma(v, 0, n - 1 - ind - 1) + suma(v, ind + 1, n - 1) +\n            (v[ind].second + v[n - 1 - ind].second) % k * (m - 1) +\n            suma(v, ind + 1, n - 1 - ind - 1) * (m - 2));\n    morir(suma(v, 0, n - 1 - ind) + suma(v, ind, n - 1) +\n          suma(v, ind, n - 1 - ind) * (m - 2));\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e5 + 10;\nlong long Stack[M][2];\nint main() {\n  int n, k, m, x, top = 0;\n  long long ans = 0;\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> x;\n    if (!top || Stack[top][0] != x) {\n      Stack[++top][0] = x;\n      Stack[top][1] = 1;\n    } else {\n      Stack[top][1]++;\n    }\n    if (Stack[top][1] == k) {\n      Stack[top--][1] -= k;\n    }\n  }\n  long long sum = 0;\n  for (int i = 1; i <= top; i++) {\n    sum += Stack[i][1];\n  }\n  int sta = 1, ed = top;\n  while (sta < ed && Stack[sta][0] == Stack[ed][0]) {\n    if ((Stack[sta][1] + Stack[ed][1]) % k == 0) {\n      sta++, ed--;\n    } else {\n      Stack[sta][1] = (Stack[sta][1] + Stack[ed][1]) % k;\n      Stack[ed][1] = 0;\n      break;\n    }\n  }\n  if (sta < ed) {\n    for (int i = sta; i <= ed; i++) ans += Stack[i][1];\n    ans *= (m - 1);\n    ans += sum;\n  } else if (sta == ed) {\n    if (Stack[sta][1] * m % k == 0)\n      ans = 0;\n    else {\n      ans = sum + Stack[sta][1] * (m - 1);\n      ans -= Stack[sta][1] * m - Stack[sta][1] * m % k;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx,tune=native\")\nusing namespace std;\nint n, k, m;\ndeque<pair<int, int> > q;\nint main() {\n  if (fopen(\"FILENAME.in\", \"r\")) {\n    freopen(\"FILENAME.in\", \"r\", stdin);\n    freopen(\"FILENAME.out\", \"w\", stdout);\n  }\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    if (q.size() && q.back().first == x) {\n      q.back().second++;\n      if (q.back().second >= k) q.pop_back();\n    } else {\n      q.push_back(make_pair(x, 1));\n    }\n  }\n  long long ans = 0;\n  while (q.size() > 1) {\n    if (q.front().first != q.back().first) break;\n    int sum = q.front().second + q.back().second;\n    if (sum >= k) {\n      ans += k;\n      int color = q.front().first;\n      q.pop_front();\n      q.pop_back();\n      if (sum > k) {\n        q.push_front(make_pair(0, sum - k));\n        break;\n      }\n    } else\n      break;\n  }\n  if (q.size() == 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (q.size() == 1) {\n    long long remainder = ((1LL * m * q.front().second) % k);\n    if (remainder == 0) {\n      cout << 0 << endl;\n      return 0;\n    }\n    cout << ans + remainder << endl;\n    return 0;\n  }\n  int total = 0;\n  for (pair<int, int> a : q) {\n    total += a.second;\n  }\n  cout << ans + 1LL * m * total << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  char c = getchar();\n  long long x = 0;\n  bool f = 0;\n  for (; !isdigit(c); c = getchar()) f ^= !(c ^ 45);\n  for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);\n  if (f) x = -x;\n  return x;\n}\nlong long n, m, k, top, a[100005];\npair<long long, long long> s[100005];\nsigned main() {\n  n = read(), k = read(), m = read();\n  for (register long long i = (1); i <= (n); ++i) {\n    a[i] = read();\n    if (s[top].first != a[i])\n      s[++top] = make_pair(a[i], 1);\n    else {\n      s[top].second++;\n      if (s[top].second == k) --top;\n    }\n  }\n  long long r1 = 0, r2 = 0, res = 0;\n  for (register long long i = (1); i <= (top); ++i) r1 += s[i].second;\n  long long l = 1, r = top;\n  while (l < r && s[l].first == s[r].first &&\n         (s[l].second + s[r].second) % k == 0)\n    r2 += s[l].second + s[r].second, ++l, --r;\n  if (l == r) {\n    if (s[l].second * m % k == 0) res -= r2;\n    res += m * r1 - (m - 1) * r2 - (s[l].second * m / k * k);\n    cout << res;\n  } else {\n    if (s[l].first == s[r].first) r2 += (s[l].second + s[r].second) / k * k;\n    cout << m * r1 - (m - 1) * r2;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid out(T x) {\n  cout << x << endl;\n  exit(0);\n}\nconst long long mod = 1e9 + 7;\nconst int maxn = 1e6 + 5;\nlong long n, k, m;\nint siz;\nint a[maxn], b[maxn];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k >> m;\n  long long res = n * m;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    if (siz > 0 && a[siz - 1] == x) {\n      b[siz - 1]++;\n      if (b[siz - 1] == k) {\n        res -= k * m;\n        siz--;\n      }\n    } else {\n      a[siz] = x;\n      b[siz] = 1;\n      siz++;\n    }\n  }\n  if (siz <= 1) {\n    res = res % k;\n    out(res);\n  }\n  for (int i = 0; i < siz / 2; i++) {\n    if (a[i] != a[siz - 1 - i]) {\n      out(res);\n    }\n    long long count = b[i] + b[siz - 1 - i];\n    if (count < k) {\n      out(res);\n    }\n    res -= k * (m - 1);\n    if (count > k) {\n      out(res);\n    }\n  }\n  assert(siz % 2 == 1);\n  long long mid = b[siz / 2] * m;\n  res -= mid / k * k;\n  if (mid % k == 0) {\n    res = 0;\n  }\n  out(res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, k, m, a[100010], b[100010], c[100010], cnt;\nlong long ans;\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) scanf(\"%d\", a + i);\n  for (int i = 0, j = 0; i < n; i = j) {\n    for (; j < n && a[i] == a[j]; j++)\n      ;\n    if ((j - i) % k) {\n      b[cnt] = a[i], c[cnt++] = (j - i) % k;\n      if (cnt > 1 && b[cnt - 1] == b[cnt - 2]) {\n        cnt--;\n        (c[cnt - 1] += c[cnt]) %= k;\n        if (!c[cnt - 1]) --cnt;\n      }\n    }\n  }\n  int l = 0, r = cnt - 1, el = 0;\n  while (l <= r && b[l] == b[r] && (c[l] + c[r]) % k == 0)\n    el += c[l++] + c[r--];\n  if (l < r) {\n    if (b[l] == b[r]) el += c[l] + c[r] - (c[l] + c[r]) % k;\n    for (int i = 0; i < cnt; i++) ans += c[i];\n    ans = ans * m - el * (m - 1ll);\n  } else if (l == r) {\n    int len = c[l] * 1ll * m % k;\n    if (len) {\n      for (int i = 0; i < cnt; i++)\n        if (i != l) ans += c[i];\n      ans += len;\n    }\n  } else if (m % 2) {\n    for (int i = 0; i < cnt; i++) ans += c[i];\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar getc() {\n  char c = getchar();\n  while ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && (c < '0' || c > '9'))\n    c = getchar();\n  return c;\n}\nint gcd(int n, int m) { return m == 0 ? n : gcd(m, n % m); }\nint read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9')\n    x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n  return x * f;\n}\nint n, m, k, a[100010], b[100010], stk[100010], top;\nlong long ans;\nsigned main() {\n  n = read(), m = read(), k = read();\n  for (int i = 1; i <= n; i++) a[i] = read();\n  int u = 0;\n  int cnt = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!top)\n      stk[++top] = a[i], cnt++;\n    else {\n      if (stk[top] == a[i])\n        cnt++;\n      else\n        cnt = 1;\n      stk[++top] = a[i];\n    }\n    if (cnt == m) {\n      top -= m;\n      ans += 1ll * k * m;\n      cnt = 0;\n      for (int j = top; j >= 0; j--)\n        if (stk[j] != stk[top]) {\n          cnt = top - j;\n          break;\n        }\n    }\n  }\n  u = top;\n  memcpy(b, stk, sizeof(b));\n  int nnn = n;\n  n = u;\n  memcpy(a, b, sizeof(a));\n  bool flag = 0;\n  for (int i = 2; i <= n; i++)\n    if (a[i] != a[1]) {\n      flag = 1;\n      break;\n    }\n  if (!flag) {\n    cout << 1ll * nnn * k % m;\n    return 0;\n  }\n  int l = 1, r = n;\n  while (l <= r) {\n    int x = l, y = r;\n    if (a[l] != a[r]) break;\n    while (a[x + 1] == a[l]) x++;\n    while (a[y - 1] == a[r]) y--;\n    if (x >= y) {\n      ans += (1ll * k * (r - l + 1) / m) * m;\n      if (1ll * k * (r - l + 1) % m == 0) ans += n - (r - l + 1);\n      break;\n    }\n    if (x - l + 1 + r - y + 1 >= m) {\n      ans += 1ll * (k - 1) * m;\n      if (x - l + 1 + r - y + 1 > m)\n        break;\n      else if (m == (x - l + 1 + r - y + 1))\n        l = x + 1, r = y - 1;\n      else\n        break;\n    } else\n      break;\n  }\n  ans = 1ll * nnn * k - ans;\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\n// 12321\n// 123434343434343434343421\n\npublic class b {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt(), m = in.nextInt();\n\t\tint[] as = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tas[i] = in.nextInt();\n\t\t}\n\t\tlong ans = 0;\n\t\tArrayDeque<Count> stk = new ArrayDeque<>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tCount c = stk.peek();\n\t\t\tif(c != null && c.v == as[i]) {\n\t\t\t\tc.cnt++;\n\t\t\t\tif(c.cnt == k) {\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstk.push(new Count(as[i], 1));\n\t\t\t}\n\t\t}\n\t\tCount[] cs = new Count[stk.size()];\n\t\twhile(!stk.isEmpty()) {\n\t\t\tcs[stk.size()-1] = stk.pop();\n\t\t}\n\t\tfor(int i=0;i<cs.length;i++) {\n\t\t\tCount first = cs[i], last = cs[cs.length-1-i];\n\t\t\tif(first.v != last.v || m == 1) {\n\t\t\t\tfor(int j=i;j<=cs.length-1-i;j++) {\n\t\t\t\t\tans += m*(long)cs[j].cnt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(first == last) {\n\t\t\t\tans += (first.cnt * (long)m)%k;\n\t\t\t\tif(((first.cnt * (long)m) % k) == 0) {\n\t\t\t\t\tfor(int j=i-1;j>=0;j--) {\n\t\t\t\t\t\tfirst = cs[j];\n\t\t\t\t\t\tlast = cs[cs.length-1-j];\n\t\t\t\t\t\tlong sum = first.cnt + last.cnt;\n\t\t\t\t\t\tans -= sum;\n\t\t\t\t\t\tans += sum % k;\n\t\t\t\t\t\tif(sum % k != 0) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlong sum = first.cnt + last.cnt;\n\t\t\tif(sum % k != 0) {\n\t\t\t\tans += (sum%k)*(m-1);\n\t\t\t\tans += sum;\n\t\t\t\tfor(int j=i+1;j<=cs.length-1-i-1;j++) {\n\t\t\t\t\tans += m*(long)cs[j].cnt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tans += sum;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n//\t\tSystem.out.println(Arrays.toString(cs));\n\t\t\n\t\tout.close();\n\t}\n\tstatic class Count {\n\t\tint v, cnt;\n\t\tpublic Count(int v, int cnt) {\n\t\t\tthis.v = v;\n\t\t\tthis.cnt = cnt;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"[\" + v + \" x\" + cnt + \"]\";\n\t\t}\n\t}\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastScanner(InputStream i) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(i));\n\t\t\tst = null;\n\t\t}\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarr[i] = nextInt();\n\t\t\treturn arr;\n\t\t}\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarr[i] = nextInt();\n\t\t\treturn arr;\n\t\t}\n\t\tpublic String[] nextStringArray(int n) throws IOException {\n\t\t\tString[] arr = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarr[i] = next();\n\t\t\treturn arr;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nvector<pair<long long int, long long int>> A;\nint main() {\n  long long int n, k, m;\n  scanf(\"%lld %lld %lld\", &n, &k, &m);\n  long long int temp;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lld\", &temp);\n    if ((!A.empty()) && (temp == A.back().first)) {\n      A.back().second++;\n      if (A.back().second == k) A.pop_back();\n    } else {\n      A.emplace_back(make_pair(temp, 1));\n    }\n  }\n  if (n == 1) {\n    return !(printf(\"%lld\", m % k));\n  }\n  long long int total = 0;\n  int start = 0, end = A.size() - 1;\n  for (auto &i : A) total += i.second;\n  if (m == 1 || total == 0) return !(printf(\"%lld\", total));\n  total *= m;\n  if (A[start].first != A[end].first) return !(printf(\"%lld\", total));\n  while (start < end) {\n    if (A[start].first != A[end].first) return !(printf(\"%lld\", total));\n    if (A[start].second + A[end].second == k) {\n      total -= (m - 1) * k;\n      start++;\n      end--;\n      continue;\n    }\n    if (A[start].second + A[end].second > k) total -= (m - 1) * k;\n    return !(printf(\"%lld\", total));\n  }\n  if (start > end) return !(printf(\"0\"));\n  if (start == end) {\n    long long int x = A[start].second * m;\n    if (x % k == 0) {\n      return !(printf(\"0\"));\n    } else {\n      return !(printf(\"%lld\", total - (x / k) * k));\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint n, k, m;\ndeque<pair<int, int> > init;\nvoid show(deque<pair<int, int> > &cur) {\n  for (auto it = cur.begin(); it != cur.end(); it++) {\n    cerr << it->first << \" \" << it->second << endl;\n  }\n}\nint main() {\n  cin >> n >> k >> m;\n  for (int i = 1; i <= n; i++) {\n    int a;\n    cin >> a;\n    if (init.empty()) {\n      init.push_back(pair<int, int>(a, 1));\n    } else {\n      pair<int, int> cur = init.back();\n      init.pop_back();\n      if (cur.first == a) {\n        cur.second++;\n        cur.second %= k;\n        if (cur.second) init.push_back(cur);\n      } else {\n        init.push_back(cur);\n        init.push_back(pair<int, int>(a, 1));\n      }\n    }\n  }\n  deque<pair<int, int> > mid = init;\n  deque<pair<int, int> > Left, Right;\n  while (mid.size() >= 2 && mid.front().first == mid.back().first &&\n         mid.front().second + mid.back().second >= k) {\n    pair<int, int> left = mid.front();\n    mid.pop_front();\n    pair<int, int> right = mid.back();\n    mid.pop_back();\n    int tmp = (right.second + left.second) % k;\n    int cn_right = min(right.second, tmp);\n    int cn_left = tmp - cn_right;\n    if (right.second - cn_right != 0)\n      Right.push_front(pair<int, int>(right.first, right.second - cn_right));\n    if (left.second - cn_left != 0)\n      Left.push_back(pair<int, int>(left.first, left.second - cn_left));\n    right.second = cn_right;\n    left.second = cn_left;\n    if (left.second != 0) mid.push_front(left);\n    if (right.second != 0) mid.push_back(right);\n  }\n  n = 0;\n  for (auto it = init.begin(); it != init.end(); it++) {\n    n += it->second;\n  }\n  int last = 0;\n  for (auto it = mid.begin(); it != mid.end(); it++) {\n    last += it->second;\n  }\n  long long ans;\n  if (mid.size() != 1) {\n    ans = (long long)last * m + n - last;\n  } else {\n    pair<int, int> at = mid.front();\n    at.second = ((long long)at.second * m) % k;\n    if (at.second) {\n      if (Left.empty())\n        Left.push_back(at);\n      else\n        Right.push_front(at);\n    }\n    while (!Right.empty() && !Left.empty()) {\n      pair<int, int> left = Left.back();\n      Left.pop_back();\n      pair<int, int> right = Right.front();\n      Right.pop_front();\n      if (left.first == right.first) {\n        left.second += right.second;\n        left.second %= k;\n        if (left.second) Left.push_back(left);\n      } else {\n        Left.push_back(left);\n        Left.push_back(right);\n      }\n    }\n    ans = 0;\n    for (auto it = Left.begin(); it != Left.end(); it++) {\n      ans += it->second;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 100;\nint n, k, m;\nint a[MAXN];\npair<int, int> Stack[MAXN];\nint cnt;\nvector<int> now;\nlong long solve() {\n  int r = cnt - 1, l = 0;\n  int ans = 0;\n  for (; r >= 0 && l < cnt && Stack[r].first == Stack[l].first;) {\n    int num = 0;\n    int tmpr = r, tmpl = l;\n    while (tmpr >= 0 && Stack[tmpr].first == Stack[tmpl].first) tmpr--, num++;\n    while (num < k && tmpl < cnt && tmpl <= tmpr &&\n           Stack[tmpl].first == Stack[tmpr + 1].first)\n      tmpl++, num++;\n    if (num == k) {\n      ans += k;\n      r = tmpr;\n      l = tmpl;\n    } else {\n      break;\n    }\n  }\n  int flag = Stack[l].first;\n  for (int i = l; i <= r; i++) {\n    if (flag != Stack[i].first) {\n      return (long long)ans + (long long)(r - l + 1) * m;\n    }\n  }\n  long long tmp = (long long)(r - l + 1) * m % k;\n  return tmp ? tmp + ans : 0;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (cnt == 0)\n      Stack[cnt++] = {a[i], 1};\n    else {\n      if (a[i] == Stack[cnt - 1].first)\n        Stack[cnt++] = {a[i], Stack[cnt - 1].second + 1};\n      else\n        Stack[cnt++] = {a[i], 1};\n    }\n    if (Stack[cnt - 1].second == k) {\n      cnt -= k;\n    }\n  }\n  if (m == 1) {\n    printf(\"%d\\n\", cnt);\n    return 0;\n  }\n  for (int i = 0; i < cnt; i++) now.push_back(Stack[i].first);\n  cout << solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100100;\nint n, k, m, s[N];\ndeque<pair<int, int> > a;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k >> m;\n  for (int i = (1); i <= (n); i++) {\n    cin >> s[i];\n  }\n  long long ans = 0;\n  for (int i = (1); i <= (n); i++) {\n    if (a.size() == 0 || s[i] != a.back().first) {\n      a.push_back({s[i], 1});\n    } else {\n      a.back().second++;\n      if (a.back().second == k) {\n        ans += m;\n        a.pop_back();\n      }\n    }\n  }\n  if (a.size() == 0)\n    cout << 0 << endl;\n  else if (a.size() == 1)\n    cout << (long long)n * m % k << endl;\n  else {\n    auto b = a;\n    while (b.size() > 1 && b.front().first == b.back().first) {\n      if (b.front().second + b.back().second >= k) {\n        ans += m - 1;\n      }\n      if ((b.front().second + b.back().second) % k)\n        break;\n      else {\n        b.pop_front();\n        b.pop_back();\n      }\n    }\n    if (b.size() == 1) {\n      ans += (long long)b.front().second * m / k;\n      if ((long long)b.front().second * m % k == 0) {\n        cout << (long long)n * m % k << endl;\n        return 0;\n      }\n    } else if (b.size() == 0) {\n      cout << (long long)n * m % k << endl;\n      return 0;\n    }\n    cout << (long long)n * m - ans * k << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.util.*;\n\nimport static java.util.stream.Collectors.toList;\n\npublic class Solution {\n\n\n    static MyScanner sc;\n    private static PrintWriter out;\n    static long M2 = 1_000_000_000L + 7;\n\n    private static HashMap<Long, Long>[] mods;\n\n    public static void main(String[] s) throws Exception {\n        StringBuilder stringBuilder = new StringBuilder();\n//        stringBuilder.append(\" 4 0 3 2 1 0 3 2 1 \");\n        if (stringBuilder.length() == 0) {\n            sc = new MyScanner(System.in);\n        } else {\n            sc = new MyScanner(new BufferedReader(new StringReader(stringBuilder.toString())));\n        }\n\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n\n\n        initData();\n        solve();\n        out.flush();\n    }\n\n    private static void initData() {\n    }\n\n    static int k;\n\n    private static void solve() throws IOException {\n\n        int n = sc.nextInt();\n        k = sc.nextInt();\n        long m = sc.nextInt();\n        List<Type> types = new ArrayList<>();\n\n        int rm = n;\n        for (int i = 0; i < n; i++) {\n            int cur = sc.nextInt();\n            if (types.size() == 0 || types.get(types.size() - 1).v != cur) {\n                types.add(new Type(cur));\n            }\n            types.get(types.size() - 1).c++;\n            if (types.get(types.size() - 1).c == k) {\n                types.remove(types.size() - 1);\n                rm -= k;\n            }\n        }\n\n        int l = 0;\n\n        long d1 = rm;\n        while (l < types.size()) {\n            if (types.get(l).v != types.get(types.size() - l - 1).v) {\n                break;\n            }\n            if (types.get(l).c + types.get(types.size() - l - 1).c >= k) {\n                d1 -= k;\n            }\n\n            if (types.get(l).c + types.get(types.size() - l - 1).c != k) {\n                break;\n            }\n            l++;\n        }\n        if (l == types.size()) {\n            if (m % 2 == 0) {\n                out.println(0);\n            } else {\n                out.println(rm);\n            }\n            return;\n        }\n        if (types.size() % 2 == 1 && l == types.size() / 2) {\n            long rx = types.get(types.size() / 2).c;\n            long total = rx * m;\n            total %= k;\n            if (total == 0) {\n                out.println(0);\n                return;\n            }\n            long r1 = total;\n            r1 += rm - rx;\n            out.println(r1);\n            return;\n        }\n        out.println(d1 * (m - 1) + rm);\n\n    }\n\n\n    private static final class Type {\n        int v;\n\n        public Type(int v) {\n            this.v = v;\n        }\n\n        int c;\n\n        public Type(int v, int c) {\n            this.v = v;\n            this.c = c;\n        }\n\n        public Type copy() {\n            return new Type(v, c);\n\n        }\n    }\n\n    private static class Col {\n\n    }\n\n    private static int get(int i, int i1) {\n//        int[] nn = new int[]{6, 7, 4, 5, 0, 1, 8, 9, 2, 3};\n//        int[] rr = new int[nn.length];\n//        for (int k = 0; k < nn.length; k++) {\n//            rr[nn[k]] = k;\n//        }\n//        return nn[i] ^ rr[i1];\n//\n        out.println(\"? \" + i + \" \" + i1);\n        out.flush();\n        return sc.nextInt();\n    }\n\n    private static boolean solve(int n, int p, int p1, int i) {\n        return false;\n    }\n\n\n    private static boolean isset(long i, int k) {\n        return (i & (1 << k)) > 0;\n    }\n\n    private static void solveT() throws IOException {\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            solve();\n        }\n    }\n\n\n    private static long gcd(long l, long l1) {\n        if (l > l1) return gcd(l1, l);\n        if (l == 0) return l1;\n        return gcd(l1 % l, l);\n    }\n\n    private static long pow(long a, long b, long m) {\n        if (b == 0) return 1;\n        if (b == 1) return a;\n        long pp = pow(a, b / 2, m);\n        pp *= pp;\n        pp %= m;\n        return (pp * (b % 2 == 0 ? 1 : a)) % m;\n    }\n\n\n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        MyScanner(BufferedReader br) {\n            this.br = br;\n        }\n\n        public MyScanner(InputStream in) {\n            this(new BufferedReader(new InputStreamReader(in)));\n        }\n\n        void findToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n        String next() {\n            findToken();\n            return st.nextToken();\n        }\n\n        Integer[] nab(int n) {\n            Integer[] k = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                k[i] = sc.fi();\n            }\n            return k;\n        }\n\n        int[] na(int n) {\n            int[] k = new int[n];\n            for (int i = 0; i < n; i++) {\n                k[i] = sc.fi();\n            }\n            return k;\n        }\n\n        long[] nl(int n) {\n            long[] k = new long[n];\n            for (int i = 0; i < n; i++) {\n                k[i] = sc.nextLong();\n            }\n            return k;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int fi() {\n            String t = next();\n            int cur = 0;\n            boolean n = t.charAt(0) == '-';\n            for (int a = n ? 1 : 0; a < t.length(); a++) {\n                cur = cur * 10 + t.charAt(a) - '0';\n            }\n            return n ? -cur : cur;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid mini(T &l, T r) {\n  l = min(l, r);\n}\ntemplate <class T>\nvoid maxi(T &l, T r) {\n  l = max(l, r);\n}\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\nusing llint = long long;\nconst int N = 1e5 + 10;\nint a[N * 4];\nint n, k, m;\nllint mrg(int *a, int n) {\n  vector<pair<int, int> > v;\n  llint ret = 0;\n  for (int i = 0; i < n; ++i) {\n    if (v.empty() || v.back().first != a[i]) {\n      v.push_back(make_pair(a[i], 1));\n    } else {\n      v.back().second++;\n    }\n    while (!v.empty() && v.back().second == k) {\n      v.pop_back();\n      ret += k;\n    }\n  }\n  int nw = 0;\n  for (auto p : v) {\n    for (int i = 0; i < p.second; ++i) a[nw++] = p.first;\n  }\n  return n - ret;\n}\nllint go(int *a, int n) {\n  if (n == 0) return 0;\n  int hd = n;\n  int tl = n;\n  for (int i = 0; i < n; ++i) {\n    if (a[i] == a[n - 1]) {\n      a[tl++] = a[i];\n    } else {\n      hd = i;\n      break;\n    }\n  }\n  int cnt = 0;\n  llint del = 0;\n  llint ret = 0;\n  for (int i = tl - 1; i >= hd; --i) {\n    if (a[i] == a[tl - 1]) {\n      ++cnt;\n    } else {\n      break;\n    }\n  }\n  for (int i = 0; i < tl; ++i) 42;\n  42;\n  if (cnt == n) {\n    ret += 1ll * n * m % k;\n  } else {\n    if (cnt % k == 0) {\n      ret += 0;\n      llint tmp = go(a + hd, n - cnt);\n      42;\n      if (tmp == 0) {\n        ret += 1ll * cnt % k;\n      } else {\n        if (hd > 0)\n          ret += 1ll * cnt;\n        else\n          ret += 1ll * cnt % k;\n      }\n      ret += tmp;\n      42;\n    } else {\n      llint tmp = mrg(a + hd, n - cnt);\n      for (int i = 0; i < tl; ++i) 42;\n      42;\n      if (tmp == 0) {\n        ret += 1ll * cnt * m % k;\n      } else {\n        ret += 1ll * cnt % k * (m - 1);\n        ret += 1ll * cnt;\n      }\n      ret += 1ll * tmp * m;\n    }\n  }\n  42;\n  return ret;\n}\nvoid run() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  n = mrg(a, n);\n  printf(\"%lld\\n\", go(a, n));\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nlong long n, k, m, lft;\nvector<pair<long long, long long> > v;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k >> m;\n  int z;\n  cin >> z;\n  v.push_back({z, 1});\n  for (int i = 2; i <= n; ++i) {\n    int nr;\n    cin >> nr;\n    if (v.size() && nr == v.back().first)\n      v.back().second++;\n    else\n      v.push_back({nr, 1});\n    if (v.back().second == k) v.pop_back();\n  }\n  for (int i = 0; i < v.size(); ++i) lft += v[i].second;\n  lft *= m;\n  int st = 0;\n  int dr = v.size() - 1;\n  while (st < dr) {\n    if (v[st].first != v[dr].first) {\n      cout << lft;\n      return 0;\n    }\n    long long zz = (v[st].second + v[dr].second) / k;\n    lft -= 1LL * (m - 1) * zz * k;\n    if ((v[st].second + v[dr].second) % k == 0)\n      ++st, --dr;\n    else {\n      cout << lft;\n      return 0;\n    }\n  }\n  if (st == dr) {\n    long long zz = v[st].second * m;\n    lft -= (zz / k) * k;\n    if (zz % k != 0) {\n      cout << lft;\n      return 0;\n    }\n    --st;\n    ++dr;\n    while (st >= 0) {\n      if (v[st].first != v[dr].first) {\n        cout << lft;\n        return 0;\n      }\n      long long zz = (v[st].second + v[dr].second) / k;\n      lft -= 1LL * zz * k;\n      if ((v[st].second + v[dr].second) % k == 0)\n        --st, ++dr;\n      else {\n        cout << lft;\n        return 0;\n      }\n    }\n    cout << lft;\n    return 0;\n  } else {\n    cout << lft;\n    return 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e5 + 10;\nlong long Stack[M][2];\nint main() {\n  int n, k, m, x, top = 0;\n  long long ans = 0;\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> x;\n    if (!top || Stack[top][0] != x) {\n      Stack[++top][0] = x;\n      Stack[top][1] = 1;\n    } else {\n      Stack[top][1]++;\n    }\n    if (Stack[top][1] == k) {\n      Stack[top--][1] -= k;\n    }\n  }\n  long long sum = 0;\n  for (int i = 1; i <= top; i++) {\n    sum += Stack[i][1];\n  }\n  int sta = 1, ed = top;\n  while (sta < ed && Stack[sta][0] == Stack[ed][0]) {\n    if ((Stack[sta][1] + Stack[ed][1]) % k == 0) {\n      sta++, ed--;\n    } else {\n      Stack[sta][1] = (Stack[sta][1] + Stack[ed][1]) % k;\n      Stack[ed][1] = 0;\n      break;\n    }\n  }\n  if (sta < ed) {\n    for (int i = sta; i <= ed; i++) ans += Stack[i][1];\n    ans *= (m - 1);\n    ans += sum;\n  } else if (sta == ed) {\n    if (Stack[sta][1] * m % k == 0)\n      ans = 0;\n    else {\n      ans = sum - Stack[sta][1] + Stack[sta][1] * m % k;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100000 + 10;\nint n, m, k;\nint a[N], S[N], cnt[N], top;\nint main() {\n  bool signal_color = true;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 2; i <= n; ++i) {\n    if (a[i] != a[i - 1]) {\n      signal_color = false;\n      break;\n    }\n  }\n  if (signal_color) {\n    return 0 * printf(\"%lld\\n\", 1ll * n * m % k);\n  }\n  for (int i = 1; i <= n; ++i) {\n    S[++top] = a[i];\n    if (top > 1 && S[top] == S[top - 1])\n      cnt[top] = cnt[top - 1] + 1;\n    else\n      cnt[top] = 1;\n    if (cnt[top] >= k) top -= k;\n  }\n  int L = 1, R = top;\n  long long t = 0;\n  while (S[L] == S[R] && L < R) {\n    int l = L, r = R, cnt = 0;\n    while (S[l] == S[L] && cnt < k) cnt++, l++;\n    while (S[r] == S[L] && cnt < k) cnt++, r--;\n    if (cnt == k) {\n      L = l, R = r, t += k;\n    } else\n      break;\n  }\n  signal_color = true;\n  for (int i = L; i < R; ++i) {\n    if (S[i] != S[i + 1]) {\n      signal_color = false;\n      break;\n    }\n  }\n  if (signal_color) {\n    long long mid = 1ll * (R - L + 1) * m % k;\n    if (mid)\n      printf(\"%lld\\n\", mid + t);\n    else\n      printf(\"0\\n\");\n  } else {\n    printf(\"%lld\\n\", 1ll * (R - L + 1) * m + t);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nconst long long inf = numeric_limits<long long>::max() / 2;\nconst long double eps = 1e-9;\nconst long double pi = acos(-1);\ntemplate <typename T>\ninline bool mineq(T& a, T b) {\n  return (a > b) ? (a = b, 1) : 0;\n}\ntemplate <typename T>\ninline bool maxeq(T& a, T b) {\n  return (a < b) ? (a = b, 1) : 0;\n}\ninline void solve(), read();\nconst string file = \"\";\nint main() {\n  if (file != \"\") {\n    freopen((file + \".in\").c_str(), \"r\", stdin);\n    freopen((file + \".out\").c_str(), \"w\", stdout);\n  }\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  ;\n  read();\n  solve();\n  return 0;\n}\nlong long n, k, m;\nvector<long long> a;\nstack<pair<long long, long long> > st;\ninline void solve() {\n  for (long long i = 0; i < n; i++) {\n    if (!st.empty() && st.top().first == a[i]) {\n      long long z = st.top().second;\n      st.pop();\n      st.push({a[i], z + 1});\n    } else {\n      st.push({a[i], 1});\n    }\n    if (!st.empty() && st.top().second == k) {\n      st.pop();\n    }\n  }\n  deque<pair<long long, long long> > b;\n  while (!st.empty()) {\n    b.push_back(st.top());\n    st.pop();\n  }\n  reverse((b).begin(), (b).end());\n  long long r = (long long)((b).size());\n  long long p = 0;\n  for (long long i = 0; i < r; i++) {\n    if (b[i].first == b[r - 1 - i].first &&\n        b[i].second + b[r - 1 - i].second == k) {\n      p = i + 1;\n    } else {\n      break;\n    }\n  }\n  long long ans = 0;\n  if (p == r) {\n    if (m % 2 == 0) {\n      ans = 0;\n    } else {\n      long long s = 0;\n      for (long long i = 0; i < r; i++) {\n        s += b[i].second;\n      }\n      ans = s;\n    }\n  } else if (p == r / 2 && r % 2 == 1) {\n    long long fh = 0;\n    for (long long i = 0; i < p; i++) {\n      fh += b[i].second;\n    }\n    long long md = m * b[p].second;\n    long long sh = 0;\n    for (long long i = p + 1; i < r; i++) {\n      sh += b[i].second;\n    }\n    if (md % k == 0) {\n      ans = 0;\n    } else {\n      ans = fh + sh + md % k;\n    }\n  } else {\n    long long s = 0;\n    for (long long i = 0; i < r; i++) {\n      s += b[i].second;\n    }\n    long long s_ = k * p;\n    if (b[p].first == b[r - 1 - p].first) {\n      s_ += (b[p].second + b[r - 1 - p].second) / k * k;\n    }\n    ans = s * m - s_ * (m - 1);\n  }\n  cout << ans << \"\\n\";\n}\ninline void read() {\n  cin >> n >> k >> m;\n  a.resize(n);\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long int n;\n  long long int k, m, tot;\n  cin >> n >> k >> m;\n  tot = n * m;\n  int a[n];\n  long long int ans = 0;\n  int b[n + 1];\n  for (int i = 0; i < n; i++) cin >> a[i];\n  if (n == 1) {\n    cout << m - (m / k) * k;\n    return 0;\n  }\n  if (k == 1) {\n    cout << \"0\";\n    return 0;\n  }\n  int lt[n];\n  int l = 0, r = n - 1, i, j = 0;\n  int cnt = 0;\n  while (l < n) {\n    i = l;\n    cnt = 0;\n    while (l < n && a[i] == a[l]) {\n      l++;\n      cnt++;\n    }\n    if (j > 0 && b[j - 1] == a[i]) {\n      if ((lt[j - 1] + cnt) % k == 0) {\n        ans += (lt[j - 1] + cnt) * m;\n        j--;\n      } else {\n        ans += ((lt[j - 1] + cnt) / k) * k * m;\n        lt[j - 1] = (lt[j - 1] + cnt) % k;\n      }\n      continue;\n    }\n    ans = ans + m * (cnt / k) * k;\n    if (cnt % k != 0) {\n      lt[j] = cnt % k;\n      b[j] = a[i];\n      j++;\n    }\n  }\n  j--;\n  l = 0;\n  r = j;\n  while (l < r) {\n    cnt = 0;\n    if (b[l] != b[r]) break;\n    cnt += lt[l];\n    l++;\n    cnt += lt[r];\n    r--;\n    ans = ans + (cnt / k) * k * (m - 1);\n    if (cnt % k != 0) break;\n  }\n  cnt = 0;\n  if (l == r) {\n    cnt += lt[l];\n    if ((cnt * m) % k == 0)\n      ans = tot;\n    else {\n      ans = ans + ((cnt * m) / k) * k;\n    }\n  }\n  cout << tot - ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstruct s {\n  long long v, sum;\n} b[100005];\nlong long a[100005];\nint main() {\n  long long n, k, m;\n  scanf(\"%I64d %I64d %I64d\", &n, &k, &m);\n  long long tot = 0;\n  for (long long i = 1; i <= n; ++i) {\n    scanf(\"%I64d\", &a[i]);\n    if (tot > 0 && a[i] == b[tot].v)\n      b[tot].sum++;\n    else {\n      b[++tot].v = a[i];\n      b[tot].sum = 1;\n    }\n    if (tot > 0 && b[tot].sum == k) tot--;\n  }\n  long long num = 0, num2 = 0, ans = 0;\n  for (long long i = 1; i <= tot; ++i) num = num + b[i].sum;\n  long long l = 1, r = tot;\n  while (l < r && b[l].v == b[r].v && (b[l].sum + b[r].sum) % k == 0) {\n    num2 += b[l].sum + b[r].sum;\n    l++;\n    r--;\n  }\n  if (l == r) {\n    if (b[l].sum * m % k == 0) ans -= num2;\n    ans += num * m - num2 * (m - 1) - b[l].sum * m / k * k;\n  } else {\n    if (b[l].v == b[r].v) num2 += (b[l].sum + b[r].sum) / k * k;\n    ans = m * num - num2 * (m - 1);\n  }\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing LL = long long;\nint n, m, k;\nLL sum(std::list<std::pair<int, LL>> &list) {\n  LL ret = 0;\n  for (auto t : list) {\n    ret += t.second;\n  }\n  return ret;\n}\nLL calc(std::list<std::pair<int, LL>> &list) {\n  std::list<std::pair<int, LL>> w;\n  for (auto t : list) {\n    if (t.second == 0) {\n      continue;\n    } else if (!w.empty() && t.first == w.back().first) {\n      (w.back().second += t.second) %= k;\n      if (w.back().second == 0) w.pop_back();\n    } else {\n      w.emplace_back(t);\n    }\n  }\n  return sum(w);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  std::list<std::pair<int, LL>> A, front, back;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    if (A.empty() || x != A.back().first)\n      A.emplace_back(x, 1);\n    else if (A.back().first == x) {\n      if (++A.back().second == k) A.pop_back();\n    }\n  }\n  while (A.size() > 1) {\n    if (A.back().first == A.front().first &&\n        A.back().second + A.front().second >= k) {\n      back.emplace_front(A.back());\n      LL tmp = k - A.back().second;\n      front.emplace_back(A.front().first, tmp);\n      A.pop_back();\n      if ((A.front().second -= tmp) == 0) A.pop_front();\n    } else {\n      break;\n    }\n  }\n  if (A.empty()) {\n    front.insert(front.end(), back.begin(), back.end());\n    printf(\"%lld\\n\", calc(front));\n  } else if (A.size() == 1) {\n    LL tmp = A.front().second * m % k;\n    if (tmp != 0) front.emplace_back(A.front().first, tmp);\n    front.insert(front.end(), back.begin(), back.end());\n    printf(\"%lld\\n\", calc(front));\n  } else {\n    LL result = sum(A) * m + sum(front) + sum(back);\n    printf(\"%lld\\n\", result);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000 + 10;\nint n, m, k;\nint a[maxn], S[maxn], cnt[maxn], top;\nint main() {\n  bool flag = true;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) scanf(\"%d\", a + i);\n  for (int i = 1; i < n; i++)\n    if (a[i] != a[i - 1]) {\n      flag = false;\n      break;\n    }\n  if (flag) {\n    printf(\"%I64d\\n\", (long long)n * m % k);\n    return 0;\n  }\n  top = 0;\n  memset(cnt, 0, sizeof(cnt));\n  for (int i = 0; i < n; i++) {\n    S[++top] = a[i];\n    if (top > 1 && S[top] == S[top - 1])\n      cnt[top] = cnt[top - 1] + 1;\n    else\n      cnt[top] = 1;\n    if (cnt[top] >= k) top -= k;\n  }\n  int L = 1, R = top;\n  long long t = 0;\n  while (S[L] == S[R] && L < R) {\n    int l = L, r = R, cnt = 0;\n    while (S[l] == S[L] && l < r && cnt < k) {\n      cnt++;\n      l++;\n    }\n    while (S[r] == S[L] && l < r && cnt < k) {\n      cnt++;\n      r--;\n    }\n    if (cnt == k) {\n      L = l;\n      R = r;\n      t += k;\n    } else\n      break;\n  }\n  flag = true;\n  for (int i = L; i < R; i++)\n    if (S[i] != S[i + 1]) {\n      flag = false;\n      break;\n    }\n  if (flag) {\n    long long mid = (long long)(R - L + 1) * m % k;\n    if (mid)\n      printf(\"%lld\\n\", mid + t);\n    else\n      printf(\"0\\n\");\n  } else\n    printf(\"%lld\\n\", (long long)(R - L + 1) * m + t);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m;\nint main() {\n  scanf(\"%d %d %d\", &n, &k, &m);\n  long long ans = 1LL * n * m;\n  vector<pair<int, int> > v;\n  for (int i = int(1); i < int(n + 1); i++) {\n    int cur;\n    scanf(\"%d\", &cur);\n    if (v.empty() || v.back().first != cur) {\n      v.emplace_back(cur, 1);\n    } else {\n      v[v.size() - 1].second++;\n    }\n    if (v.back().second == k) {\n      v.pop_back();\n      ans -= 1LL * k * m;\n    }\n  }\n  if (m > 1) {\n    if (v.size() == 1) {\n      long long has = 1LL * m * v[0].second;\n      ans = has % k;\n      printf(\"%lld\\n\", ans);\n      return 0;\n    }\n    int removed = 0, last = v.size();\n    for (int i = int(v.size() - 1); i >= int(0); i--) {\n      int other = v.size() - 1 - i;\n      int sum = v[i].second + v[other].second;\n      if (v[i].first != v[other].first) {\n        break;\n      }\n      last = i;\n      if (sum < k) {\n        break;\n      } else if (sum == k) {\n        removed++;\n      } else if (sum > k) {\n        if (i != other) {\n          removed++;\n        }\n        break;\n      }\n    }\n    if (removed == (int)v.size()) {\n      long long rest = 0;\n      for (auto &each : v) {\n        rest += each.second;\n      }\n      ans = m % 2 == 0 ? 0 : rest;\n    } else {\n      ans -= 1LL * removed * k * (m - 1);\n      if ((int)v.size() - last - 1 == last) {\n        long long has = 1LL * m * v[last].second;\n        long long to_rem = (has / k) * k;\n        if (has == to_rem) {\n          ans = 0;\n        } else {\n          ans -= (has / k) * k;\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (auto& it : v) is >> it;\n  return is;\n}\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> P) {\n  return os << \"(\" << P.first << \",\" << P.second << \")\";\n}\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[ \";\n  for (auto v : V) os << v << \" \";\n  return os << \"]\";\n}\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> second) {\n  os << \"{ \";\n  for (auto s : second) os << s << \" \";\n  return os << \"}\";\n}\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n  cout << name << \" : \" << arg1 << '\\n';\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n  const char* comma = strchr(names + 1, ',');\n  cout.write(names, comma - names) << \" : \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\nvoid solve() {\n  long long n, k, m;\n  cin >> n >> k >> m;\n  long long tot = n * m;\n  vector<long long> arr(n);\n  cin >> arr;\n  vector<pair<long long, long long> > stk;\n  for (long long i : arr) {\n    if (stk.empty() or stk.back().first != i) {\n      stk.push_back({i, 1});\n    } else {\n      stk.back().second++;\n      if (stk.back().second == k) {\n        stk.pop_back();\n        tot -= k * m;\n      }\n    }\n  }\n  if (stk.size() == 0) {\n    cout << 0 << '\\n';\n    return;\n  }\n  long long i = 0, j = stk.size() - 1;\n  while (j > i) {\n    if (stk[i].first == stk[j].first and stk[i].second + stk[j].second >= k) {\n      tot -= k * (m - 1);\n      if (stk[i].second + stk[j].second == k)\n        i++, j--;\n      else\n        break;\n    } else {\n      break;\n    }\n  }\n  if (j > i) {\n    cout << tot << '\\n';\n  } else if ((m * stk[i].second) % k == 0) {\n    cout << 0 << '\\n';\n  } else {\n    cout << tot - m * stk[i].second / k * k << '\\n';\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long T = 1;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\nconst int FFTMOD = 1007681537;\nconst int INF = (int)1e9;\nconst long long LINF = (long long)1e18;\nconst long double PI = acos((long double)-1);\nconst long double EPS = 1e-9;\ninline long long gcd(long long a, long long b) {\n  long long r;\n  while (b) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\ninline long long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\ninline long long fpow(long long n, long long k, int p = MOD) {\n  long long r = 1;\n  for (; k; k >>= 1) {\n    if (k & 1) r = r * n % p;\n    n = n * n % p;\n  }\n  return r;\n}\ntemplate <class T>\ninline int chkmin(T& a, const T& val) {\n  return val < a ? a = val, 1 : 0;\n}\ntemplate <class T>\ninline int chkmax(T& a, const T& val) {\n  return a < val ? a = val, 1 : 0;\n}\ninline long long isqrt(long long k) {\n  long long r = sqrt(k) + 1;\n  while (r * r > k) r--;\n  return r;\n}\ninline long long icbrt(long long k) {\n  long long r = cbrt(k) + 1;\n  while (r * r * r > k) r--;\n  return r;\n}\ninline void addmod(int& a, int val, int p = MOD) {\n  if ((a = (a + val)) >= p) a -= p;\n}\ninline void submod(int& a, int val, int p = MOD) {\n  if ((a = (a - val)) < 0) a += p;\n}\ninline int mult(int a, int b, int p = MOD) { return (long long)a * b % p; }\ninline int inv(int a, int p = MOD) { return fpow(a, p - 2, p); }\ninline int sign(long double x) { return x < -EPS ? -1 : x > +EPS; }\ninline int sign(long double x, long double y) { return sign(x - y); }\nconst int maxn = 1e5 + 5;\nint n, k, m;\nint a[maxn];\nvoid go(vector<int>& vals, long long& tot) {\n  tot = 0;\n  int st = 0;\n  vector<pair<int, int> > tmp;\n  for (int i = (0); i < (int((vals).size())); i++) {\n    if (i == int((vals).size()) - 1 || vals[i] != vals[i + 1]) {\n      int len = i - st + 1;\n      tot += len / k;\n      len %= k;\n      if (len) {\n        if (int((tmp).size()) && tmp.back().first == vals[i]) {\n          tmp.back().second += len;\n          tot += tmp.back().second / k;\n          tmp.back().second %= k;\n          if (!tmp.back().second) tmp.pop_back();\n        } else {\n          tmp.push_back(make_pair(vals[i], len));\n        }\n      }\n      st = i + 1;\n    }\n  }\n  vals.clear();\n  for (int i = (0); i < (int((tmp).size())); i++) {\n    for (int j = (0); j < (tmp[i].second); j++) {\n      vals.push_back(tmp[i].first);\n    }\n  }\n}\nvoid shorten(vector<int>& vals) {\n  if (int((vals).size()) > n * 4) {\n    vector<int> nvals;\n    for (int i = (0); i < (n * 2); i++) {\n      nvals.push_back(vals[i]);\n    }\n    nvals.push_back(-1);\n    for (int i = (n * 2) - 1; i >= (0); i--) {\n      int j = int((vals).size()) - i - 1;\n      nvals.push_back(vals[j]);\n    }\n    vals = nvals;\n  }\n}\nlong long divide(vector<int>& vals, int m) {\n  if (!m) {\n    vals.clear();\n    return 0;\n  }\n  long long res = 0;\n  if (m == 1) {\n    go(vals, res);\n    return res;\n  }\n  if (m & 1) {\n    vector<int> tmp = vals;\n    long long a = divide(vals, m - 1);\n    long long b = divide(tmp, 1);\n    res += a + b;\n    vals.insert(vals.end(), (tmp).begin(), (tmp).end());\n    long long c;\n    go(vals, c);\n    res += c;\n    shorten(vals);\n    return res;\n  }\n  long long a = divide(vals, m >> 1);\n  res += a + a;\n  vals.insert(vals.end(), (vals).begin(), (vals).end());\n  long long c;\n  go(vals, c);\n  res += c;\n  shorten(vals);\n  return res;\n}\nvoid solve() {\n  cin >> n >> k >> m;\n  for (int i = (0); i < (n); i++) cin >> a[i];\n  if (*min_element(a, a + n) == *max_element(a, a + n)) {\n    cout << (long long)n * m % k << \"\\n\";\n    return;\n  }\n  if (k > n + n) {\n    cout << (long long)n * m << \"\\n\";\n    return;\n  }\n  vector<int> vals;\n  for (int i = (0); i < (n); i++) vals.push_back(a[i]);\n  cout << (long long)n * m - divide(vals, m) * k << \"\\n\";\n}\nint main(int argc, char* argv[]) {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  int JUDGE_ONLINE = 1;\n  if (argc > 1) {\n    JUDGE_ONLINE = 0;\n    assert(freopen(argv[1], \"r\", stdin));\n  }\n  if (argc > 2) {\n    JUDGE_ONLINE = 0;\n    assert(freopen(argv[2], \"w\", stdout));\n  }\n  solve();\n  if (!JUDGE_ONLINE) {\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom collections import deque\ninput=sys.stdin.readline\nn,k,m=map(int,input().split())\na=list(map(int,input().split()))\nr=a[0]\nflag=0\nfor i in range(n):\n  if r!=a[i]:\n    flag=1\n    break\nif flag==0:\n  print((m*n)%k)\n  sys.exit()\nif k>n:\n  print(m*n)\n  sys.exit()\ncurr=a[0]\ntmp=1\nque=deque([(a[0],1)])\nfor i in range(1,n):\n  if a[i]==curr:\n    tmp+=1\n    que.append((a[i],tmp))\n    if tmp==k:\n      for j in range(k):\n        que.pop()\n      if que:\n        tmp=que[-1][1]\n        curr=que[-1][0]\n      else:\n        curr=-1\n  else:\n    tmp=1\n    curr=a[i]\n    que.append((a[i],tmp))\nquecop=[]\nfor i in que:\n  quecop.append(i[0])\nleftrem=0\nrightrem=0\nif not que:\n  print(0)\n  sys.exit()\nwhile que[0][0]==que[-1][0]:\n  r=que[0][0]\n  count1=0\n  p=len(que)\n  count2=p-1\n  while count1<p and que[count1][0]==r:\n    count1+=1\n  if count1==p:\n    break\n  while count2>=0 and que[count2][0]==r:\n    count2-=1\n  if count1+p-1-count2<k:\n    break\n  leftrem+=count1\n  rightrem+=k-count1\n  \n  for i in range(count1):\n    que.popleft()\n  for i in range(k-count1):\n    que.pop()\nif que:\n  t=que[0][0]\nflag=0\nfor i in que:\n  if i[0]!=t:\n    flag=1\n    break\nif flag:\n  print(leftrem+rightrem+len(que)*m)\nelse:\n  r=[]\n  for i in range(leftrem):\n    if r and r[-1][0]==quecop[i]:\n      r[-1][1]+=1\n    else:\n      r.append([quecop[i],1])\n  if r and r[-1][0]==que[0][0]:\n    r[-1][0]=(r[-1][0]+(len(que)*m))%k\n    if r[-1][1]==0:\n      r.pop()\n  else:\n    if (len(que)*m)%k:\n      r.append([que[0][0],(len(que)*m)%k])\n  for i in range(len(quecop)-rightrem,len(quecop)):\n    if r and r[-1][0]==quecop[i]:\n      r[-1][1]+=1\n      if r[-1][1]==k:\n        r.pop()\n    else:\n      r.append([quecop[i],1])\n  finans=0\n  for i in r:\n    finans+=i[1]\n  print(finans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint IT_MAX = 1 << 17;\nconst long long MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nvector<pair<long long, long long> > Vu;\nint main() {\n  int N, K, M, i, j;\n  scanf(\"%d %d %d\", &N, &K, &M);\n  for (i = 1; i <= N; i++) {\n    int t;\n    scanf(\"%d\", &t);\n    if (!Vu.empty() && Vu.back().first == t) {\n      Vu.back().second++;\n      if (Vu.back().second == K) Vu.pop_back();\n    } else\n      Vu.emplace_back(t, 1);\n  }\n  long long s = 0;\n  for (auto it : Vu) s += it.second;\n  if (M == 1 || s == 0) return !printf(\"%lld\\n\", s);\n  s *= M;\n  int st = 0, en = (int)Vu.size() - 1;\n  while (st < en) {\n    if (Vu[st].first != Vu[en].first) return !printf(\"%lld\\n\", s);\n    if (Vu[st].second + Vu[en].second == K) {\n      s -= (long long)(M - 1) * K;\n      st++, en--;\n      continue;\n    }\n    if (Vu[st].second + Vu[en].second > K) s -= (long long)(M - 1) * K;\n    return !printf(\"%lld\\n\", s);\n  }\n  if (st > en) return !printf(\"0\\n\");\n  if (st == en) {\n    long long x = Vu[st].second * M;\n    if (x % K == 0) {\n      return !printf(\"0\\n\");\n    } else {\n      return !printf(\"%lld\\n\", s - (x / K) * K);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nint a[MAXN];\npair<int, int> sta[MAXN];\nint sn;\nlong long ans;\nint main() {\n  int n, k, m;\n  int l, r;\n  int S = 0, M = 0;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0, x; i < n; ++i) {\n    scanf(\"%d\", &x);\n    ++S;\n    if (sta[sn].first != x)\n      sta[++sn] = {x, 1};\n    else {\n      sta[sn].second++;\n      if (sta[sn].second == k) --sn, S -= k;\n    }\n  }\n  l = 1;\n  r = sn;\n  while (l < r && sta[l].first == sta[r].first &&\n         (sta[l].second + sta[r].second) % k == 0)\n    M += sta[l].second + sta[r].second, l++, r--;\n  if (m == 1) ans = S;\n  if (l < r) {\n    if (sta[l].first == sta[r].first)\n      M += (sta[l].second + sta[r].second) / k * k;\n    ans = 1LL * m * S - 1LL * (m - 1) * M;\n  } else if (l == r) {\n    if (1LL * sta[l].second * m % k == 0)\n      ans = 0;\n    else\n      ans = 1LL * m * S - 1LL * (m - 1) * M - 1LL * sta[l].second * m / k * k;\n  } else\n    ans = sn % 2 == 0 ? 0 : S;\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m, x;\nlong long f[100005][2];\nlong long top, l, r;\nlong long sum;\nint main() {\n  scanf(\"%I64d%I64d%I64d\", &n, &k, &m);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%I64d\", &x);\n    if (top == 0) {\n      ++top;\n      f[top][0] = x;\n      f[top][1] = 1;\n    } else {\n      if (f[top][0] == x)\n        f[top][1]++;\n      else {\n        ++top;\n        f[top][0] = x;\n        f[top][1] = 1;\n      }\n    }\n    if (f[top][1] == k) {\n      f[top][1] = 0;\n      --top;\n    }\n  }\n  sum = 0;\n  for (int i = 1; i <= top; ++i) sum += f[i][1];\n  if (top == 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  l = 1;\n  r = top;\n  while (l < r) {\n    if (f[l][0] != f[r][0]) break;\n    if ((f[l][1] + f[r][1]) % k == 0) {\n      r--;\n      l++;\n    } else {\n      f[l][1] = (f[l][1] + f[r][1]) % k;\n      f[r][1] = 0;\n      break;\n    }\n  }\n  long long ans = 0;\n  if (r == l) {\n    if (f[l][1] * m % k == 0)\n      ans = 0;\n    else {\n      ans = sum + f[l][1] * (m - 1);\n      ans -= (f[l][1] * m) - (f[l][1] * m % k);\n    }\n  } else {\n    for (int i = l; i <= r; ++i) ans += f[i][1];\n    ans *= (m - 1);\n    ans += sum;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100010;\nlong long n, m, k;\nlong long a[MAXN];\nlong long b[MAXN];\nlong long cnt[MAXN];\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> k >> m;\n  for (long long i = 1; i <= n; i++) cin >> a[i];\n  bool single_color = true;\n  for (long long i = 1; i < n; i++)\n    if (a[i] != a[i + 1]) single_color = false;\n  if (single_color) {\n    cout << n * m % k << endl;\n    return 0;\n  }\n  long long p, q, tmpp, tmpq, count;\n  long long ans;\n  long long Out_come;\n  for (long long i = 1; i <= n; i++) {\n    b[++b[0]] = a[i];\n    if (b[0] > 1 && b[b[0]] == b[b[0] - 1])\n      cnt[b[0]] = cnt[b[0] - 1] + 1;\n    else\n      cnt[b[0]] = 1;\n    if (cnt[b[0]] >= k) b[0] -= k;\n  }\n  p = 1;\n  q = b[0];\n  ans = 0;\n  while (b[p] == b[q] && p < q) {\n    count = 0;\n    tmpp = p;\n    tmpq = q;\n    while (count < k && tmpp < tmpq && b[tmpp] == b[p]) tmpp++, count++;\n    while (count < k && tmpp < tmpq && b[tmpq] == b[q]) tmpq--, count++;\n    if (count == k)\n      ans += k, p = tmpp, q = tmpq;\n    else\n      break;\n  }\n  Out_come = (q - p + 1) * m + ans;\n  bool boo = true;\n  for (long long i = p; i <= q; i++)\n    if (b[i] != b[p]) boo = false;\n  if (boo) {\n    long long cur = (q - p + 1) * m;\n    if (cur % k == 0)\n      Out_come = 0;\n    else\n      Out_come = cur % k + ans;\n  }\n  cout << Out_come << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class b2 {\n\n    static int[] arr;\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        boolean bruteForce = false;\n        \n        int n = in.nextInt();\n        long k = in.nextInt();\n        long m = in.nextLong();\n        \n        for (int caseI = 0; caseI < 1; caseI++) {\n        arr = new int[n];\n        Random rand = new Random();\n        for (int i = 0; i < n; i++) arr[i] = in.nextInt();//rand.nextInt(4);\n        long ans = 0;\n        long trueAns = 0;\n        if (m <= 2) {\n            // brute force\n            ArrayList<Pair> tmp = new ArrayList<>();\n            for (int j = 0; j < m; j++) {\n                Pair q = null;\n                for (int i = 0; i < n; i++) {\n                    if (q == null || q.v != arr[i]) {\n                        q = new Pair(arr[i], 0);\n                        tmp.add(q);\n                    }\n                    q.count++;\n                }\n            }\n            for (int i = 0; i < tmp.size(); i++) {\n                Pair p = tmp.get(i);\n                if (i > 0) p.prev = tmp.get(i - 1);\n                if (i + 1 < tmp.size()) p.next = tmp.get(i + 1);\n            }\n            \n            {\n                Pair cur = tmp.get(0);\n                while (true) {\n                    //System.out.println(cur + \"  \" + tmp);\n                    if (cur.prev != null && cur.prev.v == cur.v) {\n                        cur.prev.count += cur.count;\n                        cur.prev.next = cur.next;\n                        if (cur.next != null) cur.next.prev = cur.prev;\n                        cur.valid = false;\n                        cur = cur.prev;\n                        continue;\n                    }\n                    cur.count %= k;\n                    if (cur.count == 0) {\n                        cur.valid = false;\n                        Pair next = null;\n                        if (cur.prev != null) cur.prev.next = cur.next;\n                        if (cur.next != null) cur.next.prev = cur.prev;\n                        if (cur.prev != null) cur = cur.prev;\n                        else cur = cur.next;\n                    } else {\n                        cur = cur.next;\n                    }\n                    if (cur == null) break;\n                }\n            }\n            for (Pair p : tmp)\n                if (p.valid)\n                    ans += p.count;\n        }\n\n        if (bruteForce) {\n            // brute force\n            ArrayList<Pair> tmp = new ArrayList<>();\n            for (int j = 0; j < m; j++) {\n                Pair q = null;\n                for (int i = 0; i < n; i++) {\n                    if (q == null || q.v != arr[i]) {\n                        q = new Pair(arr[i], 0);\n                        tmp.add(q);\n                    }\n                    q.count++;\n                }\n            }\n            for (int i = 0; i < tmp.size(); i++) {\n                Pair p = tmp.get(i);\n                if (i > 0) p.prev = tmp.get(i - 1);\n                if (i + 1 < tmp.size()) p.next = tmp.get(i + 1);\n            }\n            \n            {\n                Pair cur = tmp.get(0);\n                while (true) {\n                    //System.out.println(cur + \"  \" + tmp);\n                    if (cur.prev != null && cur.prev.v == cur.v) {\n                        cur.prev.count += cur.count;\n                        cur.prev.next = cur.next;\n                        if (cur.next != null) cur.next.prev = cur.prev;\n                        cur.valid = false;\n                        cur = cur.prev;\n                        continue;\n                    }\n                    cur.count %= k;\n                    if (cur.count == 0) {\n                        cur.valid = false;\n                        Pair next = null;\n                        if (cur.prev != null) cur.prev.next = cur.next;\n                        if (cur.next != null) cur.next.prev = cur.prev;\n                        if (cur.prev != null) cur = cur.prev;\n                        else cur = cur.next;\n                    } else {\n                        cur = cur.next;\n                    }\n                    if (cur == null) break;\n                }\n            }\n            for (Pair p : tmp)\n                if (p.valid)\n                    trueAns += p.count;\n        }\n        \n        ArrayList<Pair> front = new ArrayList<>();\n        ArrayList<Pair> middle = new ArrayList<>();\n        ArrayList<Pair> back = new ArrayList<>();\n\n        if (m > 2) {\n            ArrayList<Pair> tmp = new ArrayList<>();\n            Pair q = null;\n            for (int i = 0; i < n; i++) {\n                if (q == null || q.v != arr[i]) {\n                    q = new Pair(arr[i], 0);\n                    tmp.add(q);\n                }\n                q.count++;\n            }\n            for (int i = 0; i < tmp.size(); i++) {\n                Pair p = tmp.get(i);\n                if (i > 0) p.prev = tmp.get(i - 1);\n                if (i + 1 < tmp.size()) p.next = tmp.get(i + 1);\n            }\n            \n            {\n                Pair cur = tmp.get(0);\n                while (true) {\n                    if (cur.prev != null && cur.prev.v == cur.v) {\n                        cur.prev.count += cur.count;\n                        cur.prev.next = cur.next;\n                        if (cur.next != null) cur.next.prev = cur.prev;\n                        cur.valid = false;\n                        cur = cur.prev;\n                        continue;\n                    }\n                    cur.count %= k;\n                    if (cur.count == 0) {\n                        cur.valid = false;\n                        if (cur.prev != null) cur.prev.next = cur.next;\n                        if (cur.next != null) cur.next.prev = cur.prev;\n                        if (cur.prev != null) cur = cur.prev;\n                        else cur = cur.next;\n                    } else {\n                        cur = cur.next;\n                    }\n                    if (cur == null) break;\n                }\n                for (Pair p : tmp) {\n                    if (p.valid) {\n                        front.add(p);\n                        middle.add(new Pair(p.v, p.count));\n                        back.add(new Pair(p.v, p.count));\n                    }\n                }\n            }\n            \n            for (int i = 0; i < front.size(); i++) {\n                Pair p = front.get(i);\n                if (i > 0) p.prev = front.get(i - 1);\n                if (i + 1 < front.size()) p.next = front.get(i + 1);\n            }\n            for (int i = 0; i < middle.size(); i++) {\n                Pair p = middle.get(i);\n                if (i > 0) p.prev = middle.get(i - 1);\n                if (i + 1 < middle.size()) p.next = middle.get(i + 1);\n            }\n            for (int i = 0; i < back.size(); i++) {\n                Pair p = back.get(i);\n                if (i > 0) p.prev = back.get(i - 1);\n                if (i + 1 < back.size()) p.next = back.get(i + 1);\n            }\n            //System.out.println(front + \"      \"+  middle + \"     \"+ back);\n            if (front.size() > 0) {\n                long middleCount = m - 2;\n                int fSize = front.size();\n                int mSize = middle.size();\n                int bSize = back.size();\n                Pair a = front.get(front.size() - 1);\n                Pair b = middle.get(0);\n                Pair c = middle.get(middle.size() - 1);\n                Pair d = back.get(0);\n                \n                while (true) {\n                    if (mSize == 0) break;\n                    if (mSize == 1) {\n                        break;\n                    }\n                    // shouldnt happen\n                    if (b.v == b.next.v) {\n                        b.next.valid = false;\n                        b.count += b.next.count;\n                        b.next = b.next.next;\n                        if (b.next != null) b.next.prev = b;\n                        mSize--;\n                        if (c == b.next) c = b;\n                        continue;\n                    }\n                    if (c.v == c.prev.v) {\n                        c.prev.valid = false;\n                        c.count += c.prev.count;\n                        c.prev = c.prev.prev;\n                        if (c.prev != null) c.prev.next = c;\n                        mSize--;\n                        if (b == c.prev) b = c;\n                        continue;\n                    }\n                    if (a != null && a.v == b.v) {\n                        if (a.count + b.count < k) {\n                            break;\n                        }\n                        long total = a.count + b.count;\n                        total %= k;\n                        if (total == 0) {\n                            a.valid = false;\n                            b.valid = false;\n                            fSize--;\n                            mSize--;\n                            a = a.prev;\n                            if (a != null) a.next = null;\n                            b = b.next;\n                            b.prev = null;\n                            c.valid = false;\n                            c = c.prev;\n                            mSize--;\n                            if (c != null) c.next = null;\n                            d.valid = false;\n                            d = d.next;\n                            if (d != null) d.prev = null;\n                        } else {\n                            a.count = total;\n                            b.valid = false;\n                            b = b.next;\n                            b.prev = null;\n                            c.count = total;\n                            d.valid = false;\n                            d = d.next;\n                            if (d != null) d.prev = null;\n                            mSize--;\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                tmp.clear();\n                for (Pair p : front)\n                    if (p.valid)\n                        tmp.add(p);\n                for (Pair p : middle)\n                    if (p.valid) {\n                        p.count *= middleCount;\n                        tmp.add(p);\n                    }\n                for (Pair p : back)\n                    if (p.valid)\n                        tmp.add(p);\n                if (mSize <= 1) {\n                    \n                    for (int i = 0; i < tmp.size(); i++) {\n                        Pair p = tmp.get(i);\n                        if (i > 0) p.prev = tmp.get(i - 1);\n                        if (i + 1 < tmp.size()) p.next = tmp.get(i + 1);\n                    }\n                    Pair cur = tmp.get(0);\n                    while (true) {\n                        if (cur.prev != null && cur.prev.v == cur.v) {\n                            cur.prev.count += cur.count;\n                            cur.prev.next = cur.next;\n                            if (cur.next != null) cur.next.prev = cur.prev;\n                            cur.valid = false;\n                            cur = cur.prev;\n                            continue;\n                        }\n                        cur.count %= k;\n                        if (cur.count == 0) {\n                            cur.valid = false;\n                            if (cur.prev != null) cur.prev.next = cur.next;\n                            if (cur.next != null) cur.next.prev = cur.prev;\n                            if (cur.prev != null) cur = cur.prev;\n                            else cur = cur.next;\n                        } else {\n                            cur = cur.next;\n                        }\n                        if (cur == null) break;\n                    }\n                }\n                for (Pair p : tmp)\n                    if (p.valid)\n                        ans += p.count;\n            }\n        }\n        \n        out.println(ans);\n        if (bruteForce && ans != trueAns) {\n            System.err.println(ans + \"  \" + trueAns + \"  \" + Arrays.toString(arr));\n            System.err.println(1/0);\n        }\n        }\n        out.close();\n    }\n\n    static class Pair {\n        int v;\n        long count;\n        boolean valid = true;\n        Pair prev, next;\n        public Pair(int vv, long countt) {\n            v = vv; count = countt;\n        }\n        public String toString() {\n            if (!valid) return \"\";\n            return String.format(\"(%d, %d)\", v, count);\n        }\n    }\n\n    static Random rand = new Random();\n    static void sort(int[] a) {\n        int n = a.length;\n        for (int i = a.length - 1; i > 0; i--) {\n            int j = rand.nextInt(i + 1);\n            int tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n        Arrays.sort(a);\n    }\n    static void sort(long[] a) {\n        int n = a.length;\n        for (int i = a.length - 1; i > 0; i--) {\n            int j = rand.nextInt(i + 1);\n            long tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n        Arrays.sort(a);\n    }\n    static void sort(double[] a) {\n        int n = a.length;\n        for (int i = a.length - 1; i > 0; i--) {\n            int j = rand.nextInt(i + 1);\n            double tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n        Arrays.sort(a);\n    }\n    static long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }\n    static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    static long[] eEuclid(long a, long b) {\n        if (b == 0) return new long[] { a, 1, 0 };\n        long[] ans = eEuclid(b, a % b);\n        long temp = ans[1] - ans[2] * (a / b);\n        ans[1] = ans[2];  ans[2] = temp;\n        return ans;\n    }\n    static long modInverse(long a, long m) {\n        return ((eEuclid(a, m)[1] % m) + m) % m;\n    }\n    static class DisjointSet {\n        int[] s, r;\t\n\tpublic DisjointSet(int n) {\n            s = new int[n]; r = new int[n];\n            for (int i = 0; i < n; i++) s[i] = i;\n        }\t\n        public int find(int i) { return s[i] == i ? i : (s[i] = find(s[i])); }\n\tpublic void union(int a, int b) {\n            if(r[a = find(a)] == r[b = find(b)]) r[a]++;\n            if(r[a] >= r[b]) s[b] = a; else s[a] = b;\n        }\n    }\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastScanner(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer(\"\");\n        }\n        public String next() throws IOException {\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n        public int[] nextOffsetIntArray(int n) throws IOException {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextInt() - 1;\n            return arr;\n        }\n        public int[] nextIntArray(int n) throws IOException {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextInt();\n            return arr;\n        }\n        public int[][] nextIntArray(int n, int m) throws IOException {\n            int[][] arr = new int[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    arr[i][j] = nextInt();\n            return arr;\n        }\n        public long[] nextLongArray(int n) throws IOException {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextLong();\n            return arr;\n        }\n        public long[][] nextLongArray(int n, int m) throws IOException {\n            long[][] arr = new long[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    arr[i][j] = nextLong();\n            return arr;\n        }\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] arr = new double[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextDouble();\n            return arr;\n        }\n        public double[][] nextDoubleArray(int n, int m) throws IOException {\n            double[][] arr = new double[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    arr[i][j] = nextDouble();\n            return arr;\n        }\n        public char[][] nextCharArray(int n, int m) throws IOException {\n            char[][] arr = new char[n][];\n            for (int i = 0; i < n; i++)\n                arr[i] = next().toCharArray();\n            return arr;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\npair<int, int> st[N];\nint main() {\n  int x, n, k, m;\n  while (cin >> n >> k >> m) {\n    int top = 0;\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%d\", &x);\n      if (top && x == st[top].first)\n        st[top].second++;\n      else\n        st[++top].first = x, st[top].second = 1;\n      if (st[top].second == k) top--;\n    }\n    if (top == 1) {\n      cout << 1LL * st[1].second * m % k << endl;\n      continue;\n    }\n    int res = 0;\n    for (int i = 1; i <= top; i++) res += st[i].second;\n    if (m == 1) {\n      cout << res << endl;\n      continue;\n    }\n    int p = 0;\n    for (int i = 1; i <= top - i + 1; i++) {\n      if (st[i].first != st[top - i + 1].first ||\n          st[i].second + st[top - i + 1].second != k)\n        break;\n      p = i;\n    }\n    if (p >= top - top / 2) {\n      if (m % 2 == 0)\n        cout << 0 << endl;\n      else\n        cout << res << endl;\n    } else {\n      if (top % 2 == 0 || p != top / 2) {\n        long long dec = p * k;\n        if (st[p + 1].first == st[top - p].first)\n          dec += st[p + 1].second + st[top - p].second -\n                 (st[p + 1].second + st[top - p].second) % k;\n        cout << 1LL * m * res - (m - 1) * dec << endl;\n      } else if (p == top / 2) {\n        if (1LL * m * st[p + 1].second % k == 0)\n          cout << 0 << endl;\n        else {\n          res = 0;\n          for (int i = 1; i <= p; i++)\n            res += st[i].second + st[top - i + 1].second;\n          cout << res + 1LL * m * st[p + 1].second % k << endl;\n        }\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long, long long> > vc;\nint main() {\n  ios_base::sync_with_stdio(false);\n  long long n, k, m;\n  cin >> n >> k >> m;\n  long long ar[n];\n  for (int i = 0; i < n; i++) cin >> ar[i];\n  stack<pair<long long, long long> > stt;\n  for (int i = 0; i < n; i++) {\n    if (stt.empty()) {\n      stt.push(make_pair(ar[i], 1 % k));\n    } else {\n      if (stt.top().first == ar[i])\n        stt.top().second++, stt.top().second %= k;\n      else\n        stt.push(make_pair(ar[i], 1 % k));\n    }\n    if (stt.top().second == 0) stt.pop();\n  }\n  long long tot = 0;\n  while (stt.empty() == false) {\n    tot += stt.top().second;\n    vc.push_back(stt.top());\n    stt.pop();\n  }\n  int len = vc.size();\n  int st = 0, en = len - 1;\n  long long cn = 0;\n  while (st < en) {\n    if (vc[st].first == vc[en].first) {\n      if ((vc[st].second + vc[en].second) % k == 0)\n        cn += ((vc[st].second + vc[en].second) * (m - 1)), st++, en--;\n      else {\n        cn += (((vc[st].second + vc[en].second) -\n                ((vc[st].second + vc[en].second) % k)) *\n               (m - 1));\n        break;\n      }\n    } else\n      break;\n  }\n  if (st == en) {\n    if (((vc[st].second) * m) % k == 0) {\n      cout << 0 << endl;\n      return 0;\n    }\n    cn += (((vc[st].second) * m) - ((vc[st].second) * m) % k);\n  }\n  cout << (tot * m - cn) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m;\nint A[100010];\nvoid Merge(vector<pair<int, int> > &A, vector<pair<int, int> > B) {\n  for (pair<int, int> e : B) {\n    if (((int)(A).size()) == 0 || A.back().first != e.first)\n      A.push_back(e);\n    else {\n      A.back().second += e.second;\n      if (A.back().second >= k) A.back().second -= k;\n      if (A.back().second == 0) A.pop_back();\n    }\n  }\n}\nlong long get(vector<pair<int, int> > A) {\n  long long res = 0;\n  for (pair<int, int> e : A) res += e.second;\n  return res;\n}\nvoid solve() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", A + i);\n  vector<pair<int, int> > X;\n  for (int i = 1; i <= n; i++) {\n    if (((int)(X).size()) == 0 || X.back().first != A[i])\n      X.push_back(pair<int, int>(A[i], 1));\n    else {\n      X.back().second += 1;\n      if (X.back().second == k) X.pop_back();\n    }\n  }\n  if (m == 1) {\n    printf(\"%lld\\n\", get(X));\n    return;\n  }\n  vector<pair<int, int> > Y = X;\n  Merge(Y, X);\n  if (((int)(Y).size()) == 0) {\n    if (m & 1)\n      printf(\"%lld\\n\", get(X));\n    else\n      puts(\"0\");\n    return;\n  }\n  int f = 0;\n  for (int i = 0; i < ((int)(X).size()); i++, f++) {\n    if (X[i].first == X[((int)(X).size()) - 1 - i].first) {\n      int s = X[i].second + X[((int)(X).size()) - 1 - i].second;\n      if (s != k) break;\n    } else\n      break;\n  }\n  long long ans = 0;\n  if (((int)(X).size()) == ((int)(Y).size()) && ((int)(Y).size()) % 2 == 1 &&\n      f >= ((int)(Y).size()) / 2) {\n    f = ((int)(Y).size()) / 2;\n    int temp = X[f].second * (long long)m % k;\n    vector<pair<int, int> > T;\n    for (int i = 0; i < f; i++) T.push_back(X[i]);\n    vector<pair<int, int> > v;\n    if (temp > 0) v.push_back(pair<int, int>(X[f].first, temp));\n    Merge(T, v);\n    v.clear();\n    for (int i = 0; i < f; i++) v.push_back(X[((int)(X).size()) - f + i]);\n    Merge(T, v);\n    printf(\"%lld\\n\", get(T));\n  } else {\n    ans = (m - 1) * get(Y) - (m - 2) * get(X);\n    printf(\"%lld\\n\", ans);\n  }\n}\nint main() {\n  int Tc = 1;\n  for (int tc = 1; tc <= Tc; tc++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n/**\n * @author Don Li\n */\npublic class TeamsFormation {\n    \n    void solve() {\n        int n = in.nextInt(), k = in.nextInt(), m = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = in.nextInt();\n        \n        Deque<int[]> qu = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            if (!qu.isEmpty() && qu.getLast()[0] == a[i]) {\n                if (++qu.getLast()[1] == k) qu.removeLast();\n            } else {\n                qu.offerLast(new int[]{a[i], 1});\n            }\n        }\n        \n        n = qu.size();\n        List<int[]> pairs = new ArrayList<>(qu);\n        int len = 0;\n        for (int i = 0; i < n; i++) len += pairs.get(i)[1];\n        \n        int p = 0;\n        for (int i = 0; i < n; i++) {\n            int[] u = pairs.get(i), v = pairs.get(n - 1 - i);\n            if (u[0] == v[0] && u[1] + v[1] == k) {\n                p++;\n            } else {\n                break;\n            }\n        }\n        \n        if (p >= (n + 1) / 2) {\n            out.println(m % 2 == 0 ? 0 : len);\n            return;\n        }\n        \n        if (n % 2 == 1) {\n            if (p == n / 2) {\n                long center = (long) pairs.get(p)[1] * m;\n                if (center % k == 0) {\n                    out.println(0);\n                } else {\n                    out.println(len - pairs.get(p)[1] + center % k);\n                }\n            } else {\n                long ans = (long) len * m, del = 0;\n                for (int i = 0; i < p; i++) del += pairs.get(i)[1];\n                for (int i = n - p; i < n; i++) del += pairs.get(i)[1];\n                int[] u = pairs.get(p), v = pairs.get(n - 1 - p);\n                if (u[0] == v[0] && u[1] + v[1] >= k) del += k;\n                out.println(ans - (m - 1) * del);\n            }\n        } else {\n            long ans = (long) len * m, del = 0;\n            for (int i = 0; i < p; i++) del += pairs.get(i)[1];\n            for (int i = n - p; i < n; i++) del += pairs.get(i)[1];\n            int[] u = pairs.get(p), v = pairs.get(n - 1 - p);\n            if (u[0] == v[0] && u[1] + v[1] >= k) del += k;\n            out.println(ans - (m - 1) * del);\n        }\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new TeamsFormation().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> inlist, outlist;\nstack<pair<int, int> > s1, s2;\nint n, k, m, ai;\nvector<int> solve() {\n  outlist.clear();\n  for (int i = 0; i < inlist.size(); i++) {\n    if (s1.empty()) {\n      s1.push(make_pair(inlist[i], 1));\n      continue;\n    }\n    pair<int, int> last = s1.top();\n    if (inlist[i] == last.first) {\n      if ((last.second + 1) % k == 0) {\n        s1.pop();\n      } else {\n        last.second++;\n        s1.pop();\n        s1.push(last);\n      }\n    } else {\n      last.first = inlist[i];\n      last.second = 1;\n      s1.push(last);\n    }\n  }\n  while (!s1.empty()) {\n    pair<int, int> top = s1.top();\n    s2.push(top);\n    s1.pop();\n  }\n  int start_printing = false;\n  while (!s2.empty()) {\n    pair<int, int> top = s2.top();\n    for (int i = 0; i < top.second; i++) {\n      outlist.push_back(top.first);\n    }\n    s2.pop();\n  }\n  return outlist;\n}\nint main() {\n  scanf(\"%d %d %d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &ai);\n    inlist.push_back(ai);\n  }\n  long long remaining = n * (long long)m;\n  solve();\n  if (outlist.size() == 0)\n    remaining = 0LL;\n  else {\n    if (m == 1)\n      remaining = outlist.size();\n    else {\n      remaining -= (inlist.size() - outlist.size()) * (long long)m;\n      int count = 0;\n      bool started = false;\n      bool repeatdone = false;\n      for (int i = outlist.size() - 1, j = 0; i >= 0 && j < outlist.size();) {\n        if (outlist[i] != outlist[j])\n          break;\n        else if (started == false) {\n          count = 2;\n          started = true;\n        }\n        int nexti, nextj;\n        if (i == 0)\n          nexti = -1;\n        else\n          nexti = outlist[i - 1];\n        if (j == outlist.size() - 1)\n          nextj = -2;\n        else\n          nextj = outlist[j + 1];\n        if (nexti == outlist[i] && nextj == outlist[j]) {\n          i--;\n          j++;\n          count += 2;\n        } else if (nextj == outlist[j]) {\n          j++;\n          count++;\n        } else if (nexti == outlist[i]) {\n          i--;\n          count++;\n        } else {\n          if (i > j || repeatdone == true) {\n            if (count >= k) {\n              long long total = 0LL;\n              if (repeatdone == false)\n                total = (count - (count % k)) * ((long long)m - 1);\n              else\n                total = (count - (count % (long long)k));\n              remaining -= total;\n            }\n            if (count % k == 0) {\n              i--;\n              j++;\n              started = false;\n              count = 0;\n              continue;\n            } else\n              break;\n          } else {\n            repeatdone = true;\n            long long cnt = (count / 2) * (long long)m;\n            if (cnt >= k) {\n              long long total = (count / 2 * (long long)m) -\n                                (((count / 2) * (long long)m) % k);\n              remaining -= total;\n            }\n            if (cnt % k == 0) {\n              i--;\n              j++;\n              started = false;\n              count = 0;\n              continue;\n            } else\n              break;\n          }\n        }\n      }\n      int x = 0;\n    }\n  }\n  printf(\"%lld\\n\", remaining);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename S>\nusing P = pair<T, S>;\ntemplate <class T>\nusing min_heap = priority_queue<T, std::vector<T>, std::greater<T>>;\nusing LD = long double;\ntemplate <typename T, typename S>\nvoid check(T& a, S& b) {\n  if (a >= b) {\n    a %= b;\n  }\n}\ntemplate <typename T>\nT gcd(T u, T v) {\n  if (u == v) return u;\n  if (u == 0) return v;\n  if (v == 0) return u;\n  if (~u & 1) {\n    if (v & 1)\n      return gcd(u >> 1, v);\n    else\n      return gcd(u >> 1, v >> 1) << 1;\n  }\n  if (~v & 1) return gcd(u, v >> 1);\n  if (u > v) return gcd((u - v) >> 1, v);\n  return gcd((v - u) >> 1, u);\n}\nconst int N = (int)1e5 + 10;\nLL n, k, m;\nLL a[N];\nLL solve(LL st, LL en, LL sum, V<P<LL, LL>>& ans) {\n  if (st == en) {\n    return (ans[st].second * 1LL * m) % k;\n  }\n  if (ans[st].first != ans[en].first) {\n    return (sum * 1LL * m);\n  }\n  if (en == st + 1) {\n    return ((ans[st].first + ans[en].second) * 1LL * m) % k;\n  }\n  LL cnt = (ans[st].second + ans[en].second) % k;\n  if (!cnt) {\n    sum -= (ans[st].second + ans[en].second);\n    auto t = solve(st + 1, en - 1, sum, ans);\n    if (!t) return (ans[st].second + ans[en].second) % k;\n    return ans[st].second + ans[en].second + t;\n  } else {\n    cerr << (m - 1) * 1LL * cnt << '\\n';\n    return (m - 1) * 1LL * cnt +\n           m * 1LL * (sum - ans[st].second - ans[en].second) + ans[st].second +\n           ans[en].second;\n  }\n}\nvoid done(LL idx, V<P<LL, LL>>& ans) {\n  if (idx == n) return;\n  LL i = idx;\n  LL cnt = 0;\n  while (i < n && a[i] == a[idx]) i++, cnt++;\n  cnt %= k;\n  done(i, ans);\n  if (!ans.empty() && ans.back().first == a[idx]) {\n    cnt = (cnt + ans.back().second) % k;\n    ans.pop_back();\n  }\n  if (cnt) ans.push_back({a[idx], cnt});\n  return;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cerr.tie(NULL);\n  ;\n  cin >> n >> k >> m;\n  for (LL i = 0; i < (LL)n; i++) cin >> a[i];\n  V<P<LL, LL>> ans;\n  done(0, ans);\n  reverse(ans.begin(), ans.end());\n  n = (LL)ans.size();\n  LL sum = 0;\n  for (auto& i : ans) sum += i.second;\n  cout << solve(0, n - 1, sum, ans) << '\\n';\n  cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\"\n       << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.*;\n\npublic class Q443B {\t\n\tBufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter out;\n    \n\tpublic void solve() throws IOException {\t\t\t\t\n\t\tint N = nextInt();\n\t\tint K = nextInt();\n\t\tint M = nextInt();\n\n    int[] inputs = new int[N];\n    for (int i = 0; i < N; i++) {\n      inputs[i] = nextInt();\n    }\n    int[] seq = trim(inputs, K);\n\n    // int[] seq = buildSeq(N, K);\n\n    int curStart = 0;\n    int curEnd = seq.length-1;\n    boolean allSame = false;\n\n    while (true) {\n      int size = curEnd - curStart + 1;\n      if (size == 0) break;\n      if (seq[curStart] != seq[curEnd]) break;\n      int a = seq[curStart];\n\n      int countStart = 1;\n      while (curStart+countStart <= curEnd && seq[curStart + countStart] == a) {\n        countStart++;\n      }\n\n      if (countStart == size) { // all same\n        allSame = true;\n        break;\n      }\n\n      int countEnd = 1;\n      while (seq[curEnd - countEnd] == a) {\n        countEnd++;\n      }\n      int total = countStart + countEnd;\n      if (total < K) break;\n\n      curStart = curStart + countStart;\n      curEnd = curEnd - (K - countStart);\n    }\n\n    long size = curEnd - curStart + 1;\n    if (allSame) {\n      long sumCount = size * M;\n      long remain = sumCount % K;\n\n      ArrayList<Integer> finalSeq = new ArrayList<Integer>();\n      for (int i = 0; i < curStart; i++) {\n        finalSeq.add(seq[i]);\n      }\n      for (int i = 0; i < remain; i++) {\n        finalSeq.add(seq[curStart]);\n      }\n      for (int i = curEnd+1; i < seq.length; i++) {\n        finalSeq.add(seq[i]);\n      }\n      int[] finalSeqArr = new int[finalSeq.size()];\n      for (int i = 0; i < finalSeq.size(); i++) {\n        finalSeqArr[i] = finalSeq.get(i);\n      }\n      int[] trimed = trim(finalSeqArr, K);\n      out.println(trimed.length);\n    } else {\n      long cut = seq.length - size;\n      long allCut = cut * (M-1);\n      long ans = (long) seq.length * M - allCut;\n      out.println(ans);\n    }\n    //out.println( Arrays.toString(seq));\n\t}\n\n  public int[] trim(int[] arr, int K) {\n    Stack<int[]> counts = new Stack<int[]>();\n    for (int i = 0; i < arr.length; i++) {\n      if (counts.size() == 0) {\n        counts.push(new int[] {arr[i], 1});\n      } else {\n        int[] last = counts.peek();\n        if (last[0] == arr[i]) {\n          counts.pop();\n          last[1]++;\n          counts.push(last);\n        } else {\n          counts.push(new int[] {arr[i], 1});\n        }\n      }\n\n      while (true) {\n        if (counts.size() == 0) break;\n        int[] last = counts.peek();\n        if (last[1] == K) {\n          counts.pop();\n        } else {\n          break;\n        }\n      }\n    }\n    ArrayList<Integer> seq = new ArrayList<Integer>();\n    while (counts.size() > 0) {\n      int[] last = counts.pop();\n      for (int i = 0; i < last[1]; i++) {\n        seq.add(last[0]);\n      }\n    }\n\n    int[] ret = new int[seq.size()];\n    for (int i = 0; i < ret.length; i++) {\n      ret[i] = seq.get(ret.length-1-i);\n    }\n    return ret;\n  }\n\t\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tnew Q443B().run();\n\t}\n\t\n\tpublic void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            out = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n}\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\t\n\tint MAX = 250_000;\n\t\n\tList<Pair> removeKs(int[] a, int k) {\n\t\tList<Pair> stack = new ArrayList<>();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint val = a[i % a.length];\n\t\t\tif (stack.size() == 0 || stack.get(stack.size() - 1).val != val) {\n\t\t\t\tstack.add(new Pair(val, 1));\n\t\t\t} else {\n\t\t\t\tPair p = stack.remove(stack.size() - 1);\n\t\t\t\tPair newP = new Pair(p.val, p.cnt + 1);\n\t\t\t\tif (newP.cnt < k) {\n\t\t\t\t\tstack.add(newP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\treturn stack;\n\t}\n\t\n\tclass Array {\n\t\tList<Pair> whole;\n\t\tList<Pair> pref, suf;\n\t\tlong mid;\n\t\t\n\t\tpublic Array(List<Pair> whole) {\n\t\t\tthis.whole = whole;\n\t\t\tmid = 0;\n\t\t}\n\t\t\n\t\tpublic Array(List<Pair> p, List<Pair> s, long mid) {\n\t\t\tthis.pref = p;\n\t\t\tthis.suf = s;\n\t\t\tthis.mid = mid;\n\t\t}\n\t}\n\t\n\tlong getSize(List<Pair> x) {\n\t\treturn count(x);\n\t}\n\t\n\tArray combine(Array a, Array b) {\n\t\tif (a.whole == null && b.whole == null) {\n\t\t\tlong mid1 = a.mid + b.mid + getInterSize(a.suf, b.pref);\n\t\t\treturn new Array(a.pref, b.suf, mid1);\n\t\t} else if (a.whole != null && b.whole != null) {\n\t\t\tList<Pair> res = combine(a.whole, b.whole);\n\t\t\tif (res.size() < 2 * MAX) {\n\t\t\t\treturn new Array(res);\n\t\t\t} else {\n\t\t\t\tlong mid = 0;\n\t\t\t\tfor (int i = MAX; i < res.size() - MAX; i++) {\n\t\t\t\t\tmid += res.get(i).cnt;\n\t\t\t\t}\n\t\t\t\treturn new Array(res.subList(0, MAX), res.subList(res.size() - MAX, res.size()), mid);\n\t\t\t}\n\t\t} else {\n\t\t\tif (a.whole == null) {\n\t\t\t\tArray tmp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = tmp;\n\t\t\t}\n\t\t\tlong mid = b.mid;\n\t\t\tList<Pair> res = combine(a.whole, b.pref);\n\t\t\tfor (int i = MAX; i < res.size(); i++) {\n\t\t\t\tmid += res.get(i).cnt;\n\t\t\t}\n\t\t\treturn new Array(res.subList(0, MAX), b.suf, mid);\n\t\t}\n\t}\n\t\n\tprivate long getInterSize(List<Pair> pref, List<Pair> suf) {\n\t\tList<Pair> x = combine(pref, suf);\n\t\treturn count(x);\n\t}\n\n\tprivate long count(List<Pair> x) {\n\t\tlong result = 0;\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tresult += x.get(i).cnt;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tMap<Long, List<Pair>> memo = new HashMap<>();\n\tint k;\n\t\n\tprivate List<Pair> combine(List<Pair> whole, List<Pair> pref) {\n\t\tlong hash = whole.hashCode();\n\t\thash = (hash << 30) + pref.hashCode();\n\t\tif (memo.containsKey(hash)) {\n\t\t\treturn memo.get(hash);\n\t\t}\n\t\t\n\t\tList<Pair> stack = new ArrayList<>(whole);\n\t\tfor (Pair p : pref) {\n\t\t\tif (stack.size() == 0 || stack.get(stack.size() - 1).val != p.val) {\n\t\t\t\tstack.add(p);\n\t\t\t} else {\n\t\t\t\tPair top = stack.remove(stack.size() - 1);\n\t\t\t\tint sz = p.cnt + top.cnt;\n\t\t\t\tif (sz >= k) {\n\t\t\t\t\tsz -= k;\n\t\t\t\t}\n\t\t\t\tif (sz > 0) {\n\t\t\t\t\tstack.add(new Pair(p.val, sz));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemo.put(hash, stack);\n\t\treturn stack;\n\t}\n\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tk = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tArray ar = new Array(removeKs(a, k));\n\t\t\n\t\tArray res = new Array(new ArrayList<>());\n\t\twhile (m > 0) {\n\t\t\tif ((m & 1) == 1) {\n\t\t\t\tres = combine(res, ar);\n\t\t\t}\n\t\t\tar = combine(ar, ar);\n\t\t\tm /= 2;\n\t\t}\n\t\t\n\t\tlong result = 0;\n\t\tif (res.whole != null) {\n\t\t\tresult = count(res.whole);\n\t\t} else {\n\t\t\tresult = count(res.pref) + count(res.suf) + res.mid;\n\t\t}\n\t\tout.println(result);\n\t}\n\t\n\tclass Pair {\n\t\tfinal int val, cnt;\n\n\t\tpublic Pair(int val, int cnt) {\n\t\t\tsuper();\n\t\t\tthis.val = val;\n\t\t\tthis.cnt = cnt;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + cnt;\n\t\t\tresult = prime * result + val;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (cnt != other.cnt)\n\t\t\t\treturn false;\n\t\t\tif (val != other.val)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate B getOuterType() {\n\t\t\treturn B.this;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String file) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic boolean hasMoreTokens() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tString line = br.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int length) {\n\t\t\tint[] array = new int[length];\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tarray[i] = nextInt();\n\t\t\t}\n\t\t\treturn array;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew B().run();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, K, M;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cin >> N >> K >> M;\n  vector<pair<long long, long long> > a;\n  for (int i = 1; i <= N; ++i) {\n    int x;\n    cin >> x;\n    if (a.empty()) {\n      a.emplace_back(x, 1);\n    } else if (a.back().first == x) {\n      a.back().second++;\n    } else {\n      a.emplace_back(x, 1);\n    }\n    if (a.back().second == K) {\n      a.pop_back();\n    }\n  }\n  int n = a.size();\n  int l = 0, r = n - 1;\n  long long len1 = 0, len2 = 0, ret = 0;\n  for (int i = 0; i < n; ++i) len1 += a[i].second;\n  while (l < r && a[l].first == a[r].first &&\n         (a[l].second + a[r].second) % K == 0) {\n    len2 += a[l].second + a[r].second, ++l, --r;\n  }\n  if (l == r) {\n    if (a[l].second * M % K == 0) {\n      ret = len1 * M - len2 * M - (a[l].second * M / K * K);\n    } else {\n      ret = len1 * M - len2 * (M - 1) - (a[l].second * M / K * K);\n    }\n  } else {\n    if (a[l].first == a[r].first) {\n      len2 += (a[l].second + a[r].second) / K * K;\n    }\n    ret = len1 * M - len2 * (M - 1);\n  }\n  cout << ret << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m;\nint a[100000];\nint cur = -1;\nvector<pair<long long, long long> > go, go2;\nlong long ans;\nint main() {\n  cin >> n >> k >> m;\n  ans = (long long)n * m;\n  go.push_back(make_pair(0, 0));\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    if (go.size() && go.back().first == a[i]) {\n      int curCnt = go.back().second;\n      go.pop_back();\n      curCnt++;\n      if (curCnt == k)\n        ans -= (long long)k * m;\n      else\n        go.push_back(make_pair(a[i], curCnt));\n    } else\n      go.push_back(make_pair(a[i], 1));\n  }\n  int p;\n  bool was = true;\n  int r = go.size() - 1;\n  for (int i = 1; i <= r; i++) {\n    int back = r - i + 1;\n    if (go[i].first == go[back].first && go[i].second + go[back].second == k) {\n      ans -= k * (m - 1);\n    } else {\n      if (i == r / 2 + r % 2 && r % 2)\n        ;\n      else {\n        if (go[i].first == go[back].first &&\n            go[i].second + go[back].second > k) {\n          ans -= k * (m - 1);\n          go[i].second -= k;\n        }\n      }\n      p = i - 1;\n      was = false;\n      break;\n    }\n  }\n  if (was) p = r;\n  if (p >= r / 2 + r % 2) p = r;\n  if (p == r) {\n    if (m % 2) {\n      int ans = 0;\n      for (int i = 0; i < go.size(); i++) ans += go[i].second;\n      cout << ans;\n    } else\n      cout << 0;\n    return 0;\n  }\n  if (r % 2 && p == r / 2) {\n    if ((go[p + 1].second * m) % k == 0) {\n      cout << 0;\n      return 0;\n    } else {\n      ans -= ((go[p + 1].second * m) / k) * k;\n      cout << ans;\n      return 0;\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.StringTokenizer;\nimport java.io.PrintWriter;\n\npublic class Div1_443B {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Div1_443B().execute();\n\t}\n\n\tvoid execute() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tStringTokenizer inputData = new StringTokenizer(reader.readLine());\n\t\tint n = Integer.parseInt(inputData.nextToken());\n\t\tint k = Integer.parseInt(inputData.nextToken());\n\t\tlong m = Integer.parseInt(inputData.nextToken());\n\n\t\tGroup[] groups = new Group[n];\n\t\tint nG = 0;\n\n\t\tinputData = new StringTokenizer(reader.readLine());\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint cT = Integer.parseInt(inputData.nextToken()) - 1;\n\n\t\t\tif (nG > 0 && cT == groups[nG - 1].t) {\n\t\t\t\tgroups[nG - 1].c++;\n\t\t\t\tif (groups[nG - 1].c == k) {\n\t\t\t\t\tgroups[nG - 1] = null;\n\t\t\t\t\tnG--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgroups[nG++] = new Group(cT, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (nG == 1) {\n\n\t\t\tprinter.println(groups[0].c * m % k);\n\t\t\tprinter.close();\n\t\t\treturn;\n\t\t}\n\n\t\tint pML = 0;\n\t\twhile (pML < nG && groups[nG - pML - 1].t == groups[pML].t && groups[nG - pML - 1].c + groups[pML].c == k) {\n\t\t\tpML++;\n\t\t}\n\n\t\tif (pML == nG) {\n\t\t\tif ((nG & 1) == 0) {\n\t\t\t\tprinter.println(0);\n\t\t\t} else {\n\t\t\t\tlong ans = 0;\n\t\t\t\tfor (int i = 0; i < nG; i++) {\n\t\t\t\t\tans += groups[i].c;\n\t\t\t\t}\n\t\t\t\tans -= groups[nG / 2].c;\n\t\t\t\tlong prod = groups[nG / 2].c * m % k;\n\t\t\t\tif (prod == 0) {\n\t\t\t\t\tprinter.println(0);\n\t\t\t\t\tprinter.close();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tans += prod;\n\t\t\t\tprinter.println(ans);\n\t\t\t}\n\t\t\tprinter.close();\n\t\t\treturn;\n\t\t}\n\n\t\tif (pML * 2 + 1 == nG) {\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < nG; i++) {\n\t\t\t\tans += groups[i].c;\n\t\t\t}\n\t\t\tans -= groups[pML].c;\n\t\t\tlong prod = groups[pML].c * m % k;\n\t\t\tif (prod == 0) {\n\t\t\t\tprinter.println(0);\n\t\t\t\tprinter.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tans += prod;\n\t\t\tprinter.println(ans);\n\t\t\tprinter.close();\n\t\t\treturn;\n\t\t}\n\n\t\tGroup ext = null;\n\t\tif (groups[nG - pML - 1].t == groups[pML].t) {\n\t\t\text = new Group(groups[nG - pML - 1].t, (groups[nG - pML - 1].c + groups[pML].c) % k);\n\t\t\tpML++;\n\t\t}\n\n\t\tlong rep = 0;\n\t\tfor (int i = pML; i < nG - pML; i++) {\n\t\t\trep += groups[i].c;\n\t\t}\n\t\tif (ext != null) {\n\t\t\trep += ext.c;\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < nG; i++) {\n\t\t\tans += groups[i].c;\n\t\t}\n\t\tans += (m - 1) * rep;\n\t\tprinter.println(ans);\n\t\tprinter.close();\n\t}\n\n\tclass Group {\n\t\tint t;\n\t\tint c;\n\n\t\tGroup(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\npublic class D_443\n{\n\tpublic static final long[] POWER2 = generatePOWER2();\n\tpublic static final IteratorBuffer<Long> ITERATOR_BUFFER_PRIME = new IteratorBuffer<>(streamPrime(1000000).iterator());\n\tprivate static BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer stringTokenizer = null;\n\tprivate static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n\tstatic class Array<Type> implements Iterable<Type>\n\t{\n\t\tprivate final Object[] array;\n\n\t\tpublic Array(int size)\n\t\t{\n\t\t\tthis.array = new Object[size];\n\t\t}\n\n\t\tpublic Array(int size, Type element)\n\t\t{\n\t\t\tthis(size);\n\t\t\tArrays.fill(this.array, element);\n\t\t}\n\n\t\tpublic Array(Array<Type> array, Type element)\n\t\t{\n\t\t\tthis(array.size() + 1);\n\t\t\tfor (int index = 0; index < array.size(); index++)\n\t\t\t{\n\t\t\t\tset(index, array.get(index));\n\t\t\t}\n\t\t\tset(size() - 1, element);\n\t\t}\n\n\t\tpublic Array(List<Type> list)\n\t\t{\n\t\t\tthis(list.size());\n\t\t\tint index = 0;\n\t\t\tfor (Type element : list)\n\t\t\t{\n\t\t\t\tset(index, element);\n\t\t\t\tindex += 1;\n\t\t\t}\n\t\t}\n\n\t\tpublic Type get(int index)\n\t\t{\n\t\t\treturn (Type) this.array[index];\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Type> iterator()\n\t\t{\n\t\t\treturn new Iterator<Type>()\n\t\t\t{\n\t\t\t\tint index = 0;\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean hasNext()\n\t\t\t\t{\n\t\t\t\t\treturn this.index < size();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Type next()\n\t\t\t\t{\n\t\t\t\t\tType result = Array.this.get(index);\n\t\t\t\t\tindex += 1;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tpublic Array set(int index, Type value)\n\t\t{\n\t\t\tthis.array[index] = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int size()\n\t\t{\n\t\t\treturn this.array.length;\n\t\t}\n\n\t\tpublic List<Type> toList()\n\t\t{\n\t\t\tList<Type> result = new ArrayList<>();\n\t\t\tfor (Type element : this)\n\t\t\t{\n\t\t\t\tresult.add(element);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn \"[\" + D_443.toString(this, \", \") + \"]\";\n\t\t}\n\t}\n\n\tstatic class BIT\n\t{\n\t\tprivate static int lastBit(int index)\n\t\t{\n\t\t\treturn index & -index;\n\t\t}\n\n\t\tprivate final long[] tree;\n\n\t\tpublic BIT(int size)\n\t\t{\n\t\t\tthis.tree = new long[size];\n\t\t}\n\n\t\tpublic void add(int index, long delta)\n\t\t{\n\t\t\tindex += 1;\n\t\t\twhile (index <= this.tree.length)\n\t\t\t{\n\t\t\t\ttree[index - 1] += delta;\n\t\t\t\tindex += lastBit(index);\n\t\t\t}\n\t\t}\n\n\t\tprivate long prefix(int end)\n\t\t{\n\t\t\tlong result = 0;\n\t\t\twhile (end > 0)\n\t\t\t{\n\t\t\t\tresult += this.tree[end - 1];\n\t\t\t\tend -= lastBit(end);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic int size()\n\t\t{\n\t\t\treturn this.tree.length;\n\t\t}\n\n\t\tpublic long sum(int start, int end)\n\t\t{\n\t\t\treturn prefix(end) - prefix(start);\n\t\t}\n\t}\n\n\tstatic abstract class Edge<TypeVertex extends Vertex<TypeVertex, TypeEdge>, TypeEdge extends Edge<TypeVertex, TypeEdge>>\n\t{\n\t\tpublic final TypeVertex vertex0;\n\t\tpublic final TypeVertex vertex1;\n\t\tpublic final boolean bidirectional;\n\n\t\tpublic Edge(TypeVertex vertex0, TypeVertex vertex1, boolean bidirectional)\n\t\t{\n\t\t\tthis.vertex0 = vertex0;\n\t\t\tthis.vertex1 = vertex1;\n\t\t\tthis.bidirectional = bidirectional;\n\t\t\tthis.vertex0.edges.add(getThis());\n\t\t\tif (this.bidirectional)\n\t\t\t{\n\t\t\t\tthis.vertex1.edges.add(getThis());\n\t\t\t}\n\t\t}\n\n\t\tpublic abstract TypeEdge getThis();\n\n\t\tpublic TypeVertex other(Vertex<TypeVertex, TypeEdge> vertex)\n\t\t{\n\t\t\tTypeVertex result;\n\t\t\tif (vertex0 == vertex)\n\t\t\t{\n\t\t\t\tresult = vertex1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = vertex0;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic void remove()\n\t\t{\n\t\t\tthis.vertex0.edges.remove(getThis());\n\t\t\tif (this.bidirectional)\n\t\t\t{\n\t\t\t\tthis.vertex1.edges.remove(getThis());\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn this.vertex0 + \"->\" + this.vertex1;\n\t\t}\n\t}\n\n\tpublic static class EdgeDefault<TypeVertex extends Vertex<TypeVertex, EdgeDefault<TypeVertex>>> extends Edge<TypeVertex, EdgeDefault<TypeVertex>>\n\t{\n\t\tpublic EdgeDefault(TypeVertex vertex0, TypeVertex vertex1, boolean bidirectional)\n\t\t{\n\t\t\tsuper(vertex0, vertex1, bidirectional);\n\t\t}\n\n\t\t@Override\n\t\tpublic EdgeDefault<TypeVertex> getThis()\n\t\t{\n\t\t\treturn this;\n\t\t}\n\t}\n\n\tpublic static class EdgeDefaultDefault extends Edge<VertexDefaultDefault, EdgeDefaultDefault>\n\t{\n\t\tpublic EdgeDefaultDefault(VertexDefaultDefault vertex0, VertexDefaultDefault vertex1, boolean bidirectional)\n\t\t{\n\t\t\tsuper(vertex0, vertex1, bidirectional);\n\t\t}\n\n\t\t@Override\n\t\tpublic EdgeDefaultDefault getThis()\n\t\t{\n\t\t\treturn this;\n\t\t}\n\t}\n\n\tpublic static class FIFO<Type>\n\t{\n\t\tpublic SingleLinkedList<Type> start;\n\t\tpublic SingleLinkedList<Type> end;\n\n\t\tpublic FIFO()\n\t\t{\n\t\t\tthis.start = null;\n\t\t\tthis.end = null;\n\t\t}\n\n\t\tpublic boolean isEmpty()\n\t\t{\n\t\t\treturn this.start == null;\n\t\t}\n\n\t\tpublic Type peek()\n\t\t{\n\t\t\treturn this.start.element;\n\t\t}\n\n\t\tpublic Type pop()\n\t\t{\n\t\t\tType result = this.start.element;\n\t\t\tthis.start = this.start.next;\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic void push(Type element)\n\t\t{\n\t\t\tSingleLinkedList<Type> list = new SingleLinkedList<>(element, null);\n\t\t\tif (this.start == null)\n\t\t\t{\n\t\t\t\tthis.start = list;\n\t\t\t\tthis.end = list;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.end.next = list;\n\t\t\t\tthis.end = list;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Fraction implements Comparable<Fraction>\n\t{\n\t\tpublic static final Fraction ZERO = new Fraction(0, 1);\n\n\t\tpublic static Fraction fraction(long whole)\n\t\t{\n\t\t\treturn fraction(whole, 1);\n\t\t}\n\n\t\tpublic static Fraction fraction(long numerator, long denominator)\n\t\t{\n\t\t\tFraction result;\n\t\t\tif (denominator == 0)\n\t\t\t{\n\t\t\t\tthrow new ArithmeticException();\n\t\t\t}\n\t\t\tif (numerator == 0)\n\t\t\t{\n\t\t\t\tresult = Fraction.ZERO;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint sign;\n\t\t\t\tif (numerator < 0 ^ denominator < 0)\n\t\t\t\t{\n\t\t\t\t\tsign = -1;\n\t\t\t\t\tnumerator = Math.abs(numerator);\n\t\t\t\t\tdenominator = Math.abs(denominator);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsign = 1;\n\t\t\t\t}\n\t\t\t\tlong gcd = gcd(numerator, denominator);\n\t\t\t\tresult = new Fraction(sign * numerator / gcd, denominator / gcd);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic final long numerator;\n\t\tpublic final long denominator;\n\n\t\tprivate Fraction(long numerator, long denominator)\n\t\t{\n\t\t\tthis.numerator = numerator;\n\t\t\tthis.denominator = denominator;\n\t\t}\n\n\t\tpublic Fraction add(Fraction fraction)\n\t\t{\n\t\t\treturn fraction(this.numerator * fraction.denominator + fraction.numerator * this.denominator, this.denominator * fraction.denominator);\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Fraction that)\n\t\t{\n\t\t\treturn Long.compare(this.numerator * that.denominator, that.numerator * this.denominator);\n\t\t}\n\n\t\tpublic Fraction divide(Fraction fraction)\n\t\t{\n\t\t\treturn multiply(fraction.inverse());\n\t\t}\n\n\t\tpublic boolean equals(Fraction that)\n\t\t{\n\t\t\treturn this.compareTo(that) == 0;\n\t\t}\n\n\t\tpublic boolean equals(Object that)\n\t\t{\n\t\t\treturn this.compareTo((Fraction) that) == 0;\n\t\t}\n\n\t\tpublic Fraction getRemainder()\n\t\t{\n\t\t\treturn fraction(this.numerator - getWholePart() * denominator, denominator);\n\t\t}\n\n\t\tpublic long getWholePart()\n\t\t{\n\t\t\treturn this.numerator / this.denominator;\n\t\t}\n\n\t\tpublic Fraction inverse()\n\t\t{\n\t\t\treturn fraction(this.denominator, this.numerator);\n\t\t}\n\n\t\tpublic Fraction multiply(Fraction fraction)\n\t\t{\n\t\t\treturn fraction(this.numerator * fraction.numerator, this.denominator * fraction.denominator);\n\t\t}\n\n\t\tpublic Fraction neg()\n\t\t{\n\t\t\treturn fraction(-this.numerator, this.denominator);\n\t\t}\n\n\t\tpublic Fraction sub(Fraction fraction)\n\t\t{\n\t\t\treturn add(fraction.neg());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\tString result;\n\t\t\tif (getRemainder().equals(Fraction.ZERO))\n\t\t\t{\n\t\t\t\tresult = \"\" + this.numerator;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = this.numerator + \"/\" + this.denominator;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tstatic class IteratorBuffer<Type>\n\t{\n\t\tprivate Iterator<Type> iterator;\n\t\tprivate List<Type> list;\n\n\t\tpublic IteratorBuffer(Iterator<Type> iterator)\n\t\t{\n\t\t\tthis.iterator = iterator;\n\t\t\tthis.list = new ArrayList<Type>();\n\t\t}\n\n\t\tpublic Iterator<Type> iterator()\n\t\t{\n\t\t\treturn new Iterator<Type>()\n\t\t\t{\n\t\t\t\tint index = 0;\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean hasNext()\n\t\t\t\t{\n\t\t\t\t\treturn this.index < list.size() || IteratorBuffer.this.iterator.hasNext();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Type next()\n\t\t\t\t{\n\t\t\t\t\tif (list.size() <= this.index)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist.add(iterator.next());\n\t\t\t\t\t}\n\t\t\t\t\tType result = list.get(index);\n\t\t\t\t\tindex += 1;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic static class MapCount<Type> extends SortedMapAVL<Type, Long>\n\t{\n\t\tprivate int count;\n\n\t\tpublic MapCount(Comparator<? super Type> comparator)\n\t\t{\n\t\t\tsuper(comparator);\n\t\t\tthis.count = 0;\n\t\t}\n\n\t\tpublic long add(Type key, Long delta)\n\t\t{\n\t\t\tlong result;\n\t\t\tif (delta > 0)\n\t\t\t{\n\t\t\t\tLong value = get(key);\n\t\t\t\tif (value == null)\n\t\t\t\t{\n\t\t\t\t\tvalue = delta;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvalue += delta;\n\t\t\t\t}\n\t\t\t\tput(key, value);\n\t\t\t\tresult = delta;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\tthis.count += result;\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic int count()\n\t\t{\n\t\t\treturn this.count;\n\t\t}\n\n\t\tpublic List<Type> flatten()\n\t\t{\n\t\t\tList<Type> result = new ArrayList<>();\n\t\t\tfor (Entry<Type, Long> entry : entrySet())\n\t\t\t{\n\t\t\t\tfor (long index = 0; index < entry.getValue(); index++)\n\t\t\t\t{\n\t\t\t\t\tresult.add(entry.getKey());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedMapAVL<Type, Long> headMap(Type keyEnd)\n\t\t{\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void putAll(Map<? extends Type, ? extends Long> map)\n\t\t{\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tpublic long remove(Type key, Long delta)\n\t\t{\n\t\t\tlong result;\n\t\t\tif (delta > 0)\n\t\t\t{\n\t\t\t\tLong value = get(key) - delta;\n\t\t\t\tif (value <= 0)\n\t\t\t\t{\n\t\t\t\t\tresult = delta + value;\n\t\t\t\t\tremove(key);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult = delta;\n\t\t\t\t\tput(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\tthis.count -= result;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic Long remove(Object key)\n\t\t{\n\t\t\tLong result = super.remove(key);\n\t\t\tthis.count -= result;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedMapAVL<Type, Long> subMap(Type keyStart, Type keyEnd)\n\t\t{\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedMapAVL<Type, Long> tailMap(Type keyStart)\n\t\t{\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\tpublic static class MapSet<TypeKey, TypeValue> extends SortedMapAVL<TypeKey, SortedSetAVL<TypeValue>> implements Iterable<TypeValue>\n\t{\n\t\tprivate Comparator<? super TypeValue> comparatorValue;\n\n\t\tpublic MapSet(Comparator<? super TypeKey> comparatorKey, Comparator<? super TypeValue> comparatorValue)\n\t\t{\n\t\t\tsuper(comparatorKey);\n\t\t\tthis.comparatorValue = comparatorValue;\n\t\t}\n\n\t\tpublic MapSet(Comparator<? super TypeKey> comparatorKey, SortedSetAVL<Entry<TypeKey, SortedSetAVL<TypeValue>>> entrySet, Comparator<? super TypeValue> comparatorValue)\n\t\t{\n\t\t\tsuper(comparatorKey, entrySet);\n\t\t\tthis.comparatorValue = comparatorValue;\n\t\t}\n\n\t\tpublic boolean add(TypeKey key, TypeValue value)\n\t\t{\n\t\t\tSortedSetAVL<TypeValue> set = computeIfAbsent(key, k -> new SortedSetAVL<>(comparatorValue));\n\t\t\treturn set.add(value);\n\t\t}\n\n\t\tpublic TypeValue firstValue()\n\t\t{\n\t\t\tTypeValue result;\n\t\t\tEntry<TypeKey, SortedSetAVL<TypeValue>> firstEntry = firstEntry();\n\t\t\tif (firstEntry == null)\n\t\t\t{\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = firstEntry.getValue().first();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic MapSet<TypeKey, TypeValue> headMap(TypeKey keyEnd)\n\t\t{\n\t\t\treturn new MapSet<>(this.comparator, this.entrySet.headSet(new AbstractMap.SimpleEntry<>(keyEnd, null)), this.comparatorValue);\n\t\t}\n\n\t\tpublic Iterator<TypeValue> iterator()\n\t\t{\n\t\t\treturn new Iterator<TypeValue>()\n\t\t\t{\n\t\t\t\tIterator<SortedSetAVL<TypeValue>> iteratorValues = values().iterator();\n\t\t\t\tIterator<TypeValue> iteratorValue = null;\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean hasNext()\n\t\t\t\t{\n\t\t\t\t\treturn iteratorValues.hasNext() || (iteratorValue != null && iteratorValue.hasNext());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic TypeValue next()\n\t\t\t\t{\n\t\t\t\t\tif (iteratorValue == null || !iteratorValue.hasNext())\n\t\t\t\t\t{\n\t\t\t\t\t\titeratorValue = iteratorValues.next().iterator();\n\t\t\t\t\t}\n\t\t\t\t\treturn iteratorValue.next();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tpublic TypeValue lastValue()\n\t\t{\n\t\t\tTypeValue result;\n\t\t\tEntry<TypeKey, SortedSetAVL<TypeValue>> lastEntry = lastEntry();\n\t\t\tif (lastEntry == null)\n\t\t\t{\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = lastEntry.getValue().last();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic boolean removeSet(TypeKey key, TypeValue value)\n\t\t{\n\t\t\tboolean result;\n\t\t\tSortedSetAVL<TypeValue> set = get(key);\n\t\t\tif (set == null)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = set.remove(value);\n\t\t\t\tif (set.size() == 0)\n\t\t\t\t{\n\t\t\t\t\tremove(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic MapSet<TypeKey, TypeValue> tailMap(TypeKey keyStart)\n\t\t{\n\t\t\treturn new MapSet<>(this.comparator, this.entrySet.tailSet(new AbstractMap.SimpleEntry<>(keyStart, null)), this.comparatorValue);\n\t\t}\n\t}\n\n\tpublic static class Matrix\n\t{\n\t\tpublic final int rows;\n\t\tpublic final int columns;\n\t\tpublic final Fraction[][] cells;\n\n\t\tpublic Matrix(int rows, int columns)\n\t\t{\n\t\t\tthis.rows = rows;\n\t\t\tthis.columns = columns;\n\t\t\tthis.cells = new Fraction[rows][columns];\n\t\t\tfor (int row = 0; row < rows; row++)\n\t\t\t{\n\t\t\t\tfor (int column = 0; column < columns; column++)\n\t\t\t\t{\n\t\t\t\t\tset(row, column, Fraction.ZERO);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void add(int rowSource, int rowTarget, Fraction fraction)\n\t\t{\n\t\t\tfor (int column = 0; column < columns; column++)\n\t\t\t{\n\t\t\t\tthis.cells[rowTarget][column] = this.cells[rowTarget][column].add(this.cells[rowSource][column].multiply(fraction));\n\t\t\t}\n\t\t}\n\n\t\tprivate int columnPivot(int row)\n\t\t{\n\t\t\tint result = this.columns;\n\t\t\tfor (int column = this.columns - 1; 0 <= column; column--)\n\t\t\t{\n\t\t\t\tif (this.cells[row][column].compareTo(Fraction.ZERO) != 0)\n\t\t\t\t{\n\t\t\t\t\tresult = column;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic void reduce()\n\t\t{\n\t\t\tfor (int rowMinimum = 0; rowMinimum < this.rows; rowMinimum++)\n\t\t\t{\n\t\t\t\tint rowPivot = rowPivot(rowMinimum);\n\t\t\t\tif (rowPivot != -1)\n\t\t\t\t{\n\t\t\t\t\tint columnPivot = columnPivot(rowPivot);\n\t\t\t\t\tFraction current = this.cells[rowMinimum][columnPivot];\n\t\t\t\t\tFraction pivot = this.cells[rowPivot][columnPivot];\n\t\t\t\t\tFraction fraction = pivot.inverse().sub(current.divide(pivot));\n\t\t\t\t\tadd(rowPivot, rowMinimum, fraction);\n\t\t\t\t\tfor (int row = rowMinimum + 1; row < this.rows; row++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (columnPivot(row) == columnPivot)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tadd(rowMinimum, row, this.cells[row][columnPivot(row)].neg());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate int rowPivot(int rowMinimum)\n\t\t{\n\t\t\tint result = -1;\n\t\t\tint pivotColumnMinimum = this.columns;\n\t\t\tfor (int row = rowMinimum; row < this.rows; row++)\n\t\t\t{\n\t\t\t\tint pivotColumn = columnPivot(row);\n\t\t\t\tif (pivotColumn < pivotColumnMinimum)\n\t\t\t\t{\n\t\t\t\t\tresult = row;\n\t\t\t\t\tpivotColumnMinimum = pivotColumn;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic void set(int row, int column, Fraction value)\n\t\t{\n\t\t\tthis.cells[row][column] = value;\n\t\t}\n\n\t\tpublic String toString()\n\t\t{\n\t\t\tString result = \"\";\n\t\t\tfor (int row = 0; row < rows; row++)\n\t\t\t{\n\t\t\t\tfor (int column = 0; column < columns; column++)\n\t\t\t\t{\n\t\t\t\t\tresult += this.cells[row][column] + \"\\t\";\n\t\t\t\t}\n\t\t\t\tresult += \"\\n\";\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tpublic static class Node<Type>\n\t{\n\t\tpublic static <Type> Node<Type> balance(Node<Type> result)\n\t\t{\n\t\t\twhile (result != null && 1 < Math.abs(height(result.left) - height(result.right)))\n\t\t\t{\n\t\t\t\tif (height(result.left) < height(result.right))\n\t\t\t\t{\n\t\t\t\t\tNode<Type> right = result.right;\n\t\t\t\t\tif (height(right.right) < height(right.left))\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(result.value, result.left, right.rotateRight());\n\t\t\t\t\t}\n\t\t\t\t\tresult = result.rotateLeft();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNode<Type> left = result.left;\n\t\t\t\t\tif (height(left.left) < height(left.right))\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(result.value, left.rotateLeft(), result.right);\n\t\t\t\t\t}\n\t\t\t\t\tresult = result.rotateRight();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> clone(Node<Type> result)\n\t\t{\n\t\t\tif (result != null)\n\t\t\t{\n\t\t\t\tresult = new Node<>(result.value, clone(result.left), clone(result.right));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> delete(Node<Type> node, Type value, Comparator<? super Type> comparator)\n\t\t{\n\t\t\tNode<Type> result;\n\t\t\tif (node == null)\n\t\t\t{\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint compare = comparator.compare(value, node.value);\n\t\t\t\tif (compare == 0)\n\t\t\t\t{\n\t\t\t\t\tif (node.left == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = node.right;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (node.right == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = node.left;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNode<Type> first = first(node.right);\n\t\t\t\t\t\t\tresult = new Node<>(first.value, node.left, delete(node.right, first.value, comparator));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (compare < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(node.value, delete(node.left, value, comparator), node.right);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(node.value, node.left, delete(node.right, value, comparator));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = balance(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> first(Node<Type> result)\n\t\t{\n\t\t\twhile (result.left != null)\n\t\t\t{\n\t\t\t\tresult = result.left;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> get(Node<Type> node, Type value, Comparator<? super Type> comparator)\n\t\t{\n\t\t\tNode<Type> result;\n\t\t\tif (node == null)\n\t\t\t{\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint compare = comparator.compare(value, node.value);\n\t\t\t\tif (compare == 0)\n\t\t\t\t{\n\t\t\t\t\tresult = node;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (compare < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = get(node.left, value, comparator);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = get(node.right, value, comparator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> head(Node<Type> node, Type value, Comparator<? super Type> comparator)\n\t\t{\n\t\t\tNode<Type> result;\n\t\t\tif (node == null)\n\t\t\t{\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint compare = comparator.compare(value, node.value);\n\t\t\t\tif (compare == 0)\n\t\t\t\t{\n\t\t\t\t\tresult = node.left;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (compare < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = head(node.left, value, comparator);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(node.value, node.left, head(node.right, value, comparator));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = balance(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static int height(Node node)\n\t\t{\n\t\t\treturn node == null ? 0 : node.height;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> insert(Node<Type> node, Type value, Comparator<? super Type> comparator)\n\t\t{\n\t\t\tNode<Type> result;\n\t\t\tif (node == null)\n\t\t\t{\n\t\t\t\tresult = new Node<>(value, null, null);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint compare = comparator.compare(value, node.value);\n\t\t\t\tif (compare == 0)\n\t\t\t\t{\n\t\t\t\t\tresult = new Node<>(value, node.left, node.right);\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (compare < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(node.value, insert(node.left, value, comparator), node.right);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(node.value, node.left, insert(node.right, value, comparator));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = balance(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> last(Node<Type> result)\n\t\t{\n\t\t\twhile (result.right != null)\n\t\t\t{\n\t\t\t\tresult = result.right;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static int size(Node node)\n\t\t{\n\t\t\treturn node == null ? 0 : node.size;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> tail(Node<Type> node, Type value, Comparator<? super Type> comparator)\n\t\t{\n\t\t\tNode<Type> result;\n\t\t\tif (node == null)\n\t\t\t{\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint compare = comparator.compare(value, node.value);\n\t\t\t\tif (compare == 0)\n\t\t\t\t{\n\t\t\t\t\tresult = new Node<>(node.value, null, node.right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (compare < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(node.value, tail(node.left, value, comparator), node.right);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = tail(node.right, value, comparator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = balance(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> void traverseOrderIn(Node<Type> node, Consumer<Type> consumer)\n\t\t{\n\t\t\tif (node != null)\n\t\t\t{\n\t\t\t\ttraverseOrderIn(node.left, consumer);\n\t\t\t\tconsumer.accept(node.value);\n\t\t\t\ttraverseOrderIn(node.right, consumer);\n\t\t\t}\n\t\t}\n\n\t\tpublic final Type value;\n\t\tpublic final Node<Type> left;\n\t\tpublic final Node<Type> right;\n\t\tpublic final int size;\n\t\tprivate final int height;\n\n\t\tpublic Node(Type value, Node<Type> left, Node<Type> right)\n\t\t{\n\t\t\tthis.value = value;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.size = 1 + size(left) + size(right);\n\t\t\tthis.height = 1 + Math.max(height(left), height(right));\n\t\t}\n\n\t\tpublic Node<Type> rotateLeft()\n\t\t{\n\t\t\tNode<Type> left = new Node<>(this.value, this.left, this.right.left);\n\t\t\treturn new Node<>(this.right.value, left, this.right.right);\n\t\t}\n\n\t\tpublic Node<Type> rotateRight()\n\t\t{\n\t\t\tNode<Type> right = new Node<>(this.value, this.left.right, this.right);\n\t\t\treturn new Node<>(this.left.value, this.left.left, right);\n\t\t}\n\t}\n\n\tpublic static class SingleLinkedList<Type>\n\t{\n\t\tpublic final Type element;\n\t\tpublic SingleLinkedList<Type> next;\n\n\t\tpublic SingleLinkedList(Type element, SingleLinkedList<Type> next)\n\t\t{\n\t\t\tthis.element = element;\n\t\t\tthis.next = next;\n\t\t}\n\n\t\tpublic void toCollection(Collection<Type> collection)\n\t\t{\n\t\t\tif (this.next != null)\n\t\t\t{\n\t\t\t\tthis.next.toCollection(collection);\n\t\t\t}\n\t\t\tcollection.add(this.element);\n\t\t}\n\t}\n\n\tpublic static class SmallSetIntegers\n\t{\n\t\tpublic static final int SIZE = 20;\n\t\tpublic static final int[] SET = generateSet();\n\t\tpublic static final int[] COUNT = generateCount();\n\t\tpublic static final int[] INTEGER = generateInteger();\n\n\t\tprivate static int count(int set)\n\t\t{\n\t\t\tint result = 0;\n\t\t\tfor (int integer = 0; integer < SIZE; integer++)\n\t\t\t{\n\t\t\t\tif (0 < (set & set(integer)))\n\t\t\t\t{\n\t\t\t\t\tresult += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate static final int[] generateCount()\n\t\t{\n\t\t\tint[] result = new int[1 << SIZE];\n\t\t\tfor (int set = 0; set < result.length; set++)\n\t\t\t{\n\t\t\t\tresult[set] = count(set);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate static final int[] generateInteger()\n\t\t{\n\t\t\tint[] result = new int[1 << SIZE];\n\t\t\tArrays.fill(result, -1);\n\t\t\tfor (int integer = 0; integer < SIZE; integer++)\n\t\t\t{\n\t\t\t\tresult[SET[integer]] = integer;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate static final int[] generateSet()\n\t\t{\n\t\t\tint[] result = new int[SIZE];\n\t\t\tfor (int integer = 0; integer < result.length; integer++)\n\t\t\t{\n\t\t\t\tresult[integer] = set(integer);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate static int set(int integer)\n\t\t{\n\t\t\treturn 1 << integer;\n\t\t}\n\t}\n\n\tpublic static class SortedMapAVL<TypeKey, TypeValue> implements SortedMap<TypeKey, TypeValue>\n\t{\n\t\tpublic final Comparator<? super TypeKey> comparator;\n\t\tpublic final SortedSetAVL<Entry<TypeKey, TypeValue>> entrySet;\n\n\t\tpublic SortedMapAVL(Comparator<? super TypeKey> comparator)\n\t\t{\n\t\t\tthis(comparator, new SortedSetAVL<>((entry0, entry1) -> comparator.compare(entry0.getKey(), entry1.getKey())));\n\t\t}\n\n\t\tprivate SortedMapAVL(Comparator<? super TypeKey> comparator, SortedSetAVL<Entry<TypeKey, TypeValue>> entrySet)\n\t\t{\n\t\t\tthis.comparator = comparator;\n\t\t\tthis.entrySet = entrySet;\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear()\n\t\t{\n\t\t\tthis.entrySet.clear();\n\t\t}\n\n\t\t@Override\n\t\tpublic Comparator<? super TypeKey> comparator()\n\t\t{\n\t\t\treturn this.comparator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsKey(Object key)\n\t\t{\n\t\t\treturn this.entrySet().contains(new AbstractMap.SimpleEntry<>((TypeKey) key, null));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsValue(Object value)\n\t\t{\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedSetAVL<Entry<TypeKey, TypeValue>> entrySet()\n\t\t{\n\t\t\treturn this.entrySet;\n\t\t}\n\n\t\tpublic Entry<TypeKey, TypeValue> firstEntry()\n\t\t{\n\t\t\treturn this.entrySet.first();\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeKey firstKey()\n\t\t{\n\t\t\treturn firstEntry().getKey();\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeValue get(Object key)\n\t\t{\n\t\t\tEntry<TypeKey, TypeValue> entry = new AbstractMap.SimpleEntry<>((TypeKey) key, null);\n\t\t\tentry = this.entrySet.get(entry);\n\t\t\treturn entry == null ? null : entry.getValue();\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedMapAVL<TypeKey, TypeValue> headMap(TypeKey keyEnd)\n\t\t{\n\t\t\treturn new SortedMapAVL<>(this.comparator, this.entrySet.headSet(new AbstractMap.SimpleEntry<>(keyEnd, null)));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty()\n\t\t{\n\t\t\treturn this.entrySet.isEmpty();\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<TypeKey> keySet()\n\t\t{\n\t\t\treturn new SortedSet<TypeKey>()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic boolean add(TypeKey typeKey)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean addAll(Collection<? extends TypeKey> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void clear()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Comparator<? super TypeKey> comparator()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean contains(Object o)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean containsAll(Collection<?> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic TypeKey first()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic SortedSet<TypeKey> headSet(TypeKey typeKey)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isEmpty()\n\t\t\t\t{\n\t\t\t\t\treturn size() == 0;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Iterator<TypeKey> iterator()\n\t\t\t\t{\n\t\t\t\t\tfinal Iterator<Entry<TypeKey, TypeValue>> iterator = SortedMapAVL.this.entrySet.iterator();\n\t\t\t\t\treturn new Iterator<TypeKey>()\n\t\t\t\t\t{\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean hasNext()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn iterator.hasNext();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic TypeKey next()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn iterator.next().getKey();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic TypeKey last()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean remove(Object o)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean removeAll(Collection<?> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean retainAll(Collection<?> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int size()\n\t\t\t\t{\n\t\t\t\t\treturn SortedMapAVL.this.entrySet.size();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic SortedSet<TypeKey> subSet(TypeKey typeKey, TypeKey e1)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic SortedSet<TypeKey> tailSet(TypeKey typeKey)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object[] toArray()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic <T> T[] toArray(T[] ts)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tpublic Entry<TypeKey, TypeValue> lastEntry()\n\t\t{\n\t\t\treturn this.entrySet.last();\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeKey lastKey()\n\t\t{\n\t\t\treturn lastEntry().getKey();\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeValue put(TypeKey key, TypeValue value)\n\t\t{\n\t\t\tTypeValue result = get(key);\n\t\t\tEntry<TypeKey, TypeValue> entry = new AbstractMap.SimpleEntry<>(key, value);\n\t\t\tthis.entrySet().add(entry);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic void putAll(Map<? extends TypeKey, ? extends TypeValue> map)\n\t\t{\n\t\t\tmap.entrySet()\n\t\t\t\t\t.forEach(entry -> put(entry.getKey(), entry.getValue()));\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeValue remove(Object key)\n\t\t{\n\t\t\tTypeValue result = get(key);\n\t\t\tEntry<TypeKey, TypeValue> entry = new AbstractMap.SimpleEntry<>((TypeKey) key, null);\n\t\t\tthis.entrySet.remove(entry);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size()\n\t\t{\n\t\t\treturn this.entrySet().size();\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedMapAVL<TypeKey, TypeValue> subMap(TypeKey keyStart, TypeKey keyEnd)\n\t\t{\n\t\t\treturn new SortedMapAVL<>(this.comparator, this.entrySet.subSet(new AbstractMap.SimpleEntry<>(keyStart, null), new AbstractMap.SimpleEntry<>(keyEnd, null)));\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedMapAVL<TypeKey, TypeValue> tailMap(TypeKey keyStart)\n\t\t{\n\t\t\treturn new SortedMapAVL<>(this.comparator, this.entrySet.tailSet(new AbstractMap.SimpleEntry<>(keyStart, null)));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn this.entrySet().toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic Collection<TypeValue> values()\n\t\t{\n\t\t\treturn new Collection<TypeValue>()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic boolean add(TypeValue typeValue)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean addAll(Collection<? extends TypeValue> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void clear()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean contains(Object value)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean containsAll(Collection<?> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isEmpty()\n\t\t\t\t{\n\t\t\t\t\treturn SortedMapAVL.this.entrySet.isEmpty();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Iterator<TypeValue> iterator()\n\t\t\t\t{\n\t\t\t\t\treturn new Iterator<TypeValue>()\n\t\t\t\t\t{\n\t\t\t\t\t\tIterator<Entry<TypeKey, TypeValue>> iterator = SortedMapAVL.this.entrySet.iterator();\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean hasNext()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.iterator.hasNext();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic TypeValue next()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.iterator.next().getValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean remove(Object o)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean removeAll(Collection<?> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean retainAll(Collection<?> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int size()\n\t\t\t\t{\n\t\t\t\t\treturn SortedMapAVL.this.entrySet.size();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object[] toArray()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic <T> T[] toArray(T[] ts)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic static class SortedSetAVL<Type> implements SortedSet<Type>\n\t{\n\t\tpublic Comparator<? super Type> comparator;\n\t\tpublic Node<Type> root;\n\n\t\tprivate SortedSetAVL(Comparator<? super Type> comparator, Node<Type> root)\n\t\t{\n\t\t\tthis.comparator = comparator;\n\t\t\tthis.root = root;\n\t\t}\n\n\t\tpublic SortedSetAVL(Comparator<? super Type> comparator)\n\t\t{\n\t\t\tthis(comparator, null);\n\t\t}\n\n\t\tpublic SortedSetAVL(Collection<? extends Type> collection, Comparator<? super Type> comparator)\n\t\t{\n\t\t\tthis(comparator, null);\n\t\t\tthis.addAll(collection);\n\t\t}\n\n\t\tpublic SortedSetAVL(SortedSetAVL<Type> sortedSetAVL)\n\t\t{\n\t\t\tthis(sortedSetAVL.comparator, Node.clone(sortedSetAVL.root));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(Type value)\n\t\t{\n\t\t\tint sizeBefore = size();\n\t\t\tthis.root = Node.insert(this.root, value, this.comparator);\n\t\t\treturn sizeBefore != size();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends Type> collection)\n\t\t{\n\t\t\treturn collection.stream()\n\t\t\t\t\t.map(this::add)\n\t\t\t\t\t.reduce(true, (x, y) -> x | y);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear()\n\t\t{\n\t\t\tthis.root = null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Comparator<? super Type> comparator()\n\t\t{\n\t\t\treturn this.comparator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object value)\n\t\t{\n\t\t\treturn Node.get(this.root, (Type) value, this.comparator) != null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> collection)\n\t\t{\n\t\t\treturn collection.stream()\n\t\t\t\t\t.allMatch(this::contains);\n\t\t}\n\n\t\t@Override\n\t\tpublic Type first()\n\t\t{\n\t\t\treturn Node.first(this.root).value;\n\t\t}\n\n\t\tpublic Type get(Type value)\n\t\t{\n\t\t\tNode<Type> node = Node.get(this.root, value, this.comparator);\n\t\t\treturn node == null ? null : node.value;\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedSetAVL<Type> headSet(Type valueEnd)\n\t\t{\n\t\t\treturn new SortedSetAVL<>(this.comparator, Node.head(this.root, valueEnd, this.comparator));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty()\n\t\t{\n\t\t\treturn this.root == null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Type> iterator()\n\t\t{\n\t\t\tStack<Node<Type>> path = new Stack<>();\n\t\t\treturn new Iterator<Type>()\n\t\t\t{\n\t\t\t\t{\n\t\t\t\t\tpush(SortedSetAVL.this.root);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean hasNext()\n\t\t\t\t{\n\t\t\t\t\treturn !path.isEmpty();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Type next()\n\t\t\t\t{\n\t\t\t\t\tif (path.isEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tNode<Type> node = path.peek();\n\t\t\t\t\t\tType result = node.value;\n\t\t\t\t\t\tif (node.right != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpush(node.right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnode = path.pop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (!path.isEmpty() && path.peek().right == node);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic void push(Node<Type> node)\n\t\t\t\t{\n\t\t\t\t\twhile (node != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpath.push(node);\n\t\t\t\t\t\tnode = node.left;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t@Override\n\t\tpublic Type last()\n\t\t{\n\t\t\treturn Node.last(this.root).value;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object value)\n\t\t{\n\t\t\tint sizeBefore = size();\n\t\t\tthis.root = Node.delete(this.root, (Type) value, this.comparator);\n\t\t\treturn sizeBefore != size();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> collection)\n\t\t{\n\t\t\treturn collection.stream()\n\t\t\t\t\t.map(this::remove)\n\t\t\t\t\t.reduce(true, (x, y) -> x | y);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> collection)\n\t\t{\n\t\t\tSortedSetAVL<Type> set = new SortedSetAVL<>(this.comparator);\n\t\t\tcollection.stream()\n\t\t\t\t\t.map(element -> (Type) element)\n\t\t\t\t\t.filter(this::contains)\n\t\t\t\t\t.forEach(set::add);\n\t\t\tboolean result = size() != set.size();\n\t\t\tthis.root = set.root;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size()\n\t\t{\n\t\t\treturn this.root == null ? 0 : this.root.size;\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedSetAVL<Type> subSet(Type valueStart, Type valueEnd)\n\t\t{\n\t\t\treturn tailSet(valueStart).headSet(valueEnd);\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedSetAVL<Type> tailSet(Type valueStart)\n\t\t{\n\t\t\treturn new SortedSetAVL<>(this.comparator, Node.tail(this.root, valueStart, this.comparator));\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray()\n\t\t{\n\t\t\treturn toArray(new Object[0]);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] ts)\n\t\t{\n\t\t\tList<Object> list = new ArrayList<>();\n\t\t\tNode.traverseOrderIn(this.root, list::add);\n\t\t\treturn list.toArray(ts);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn \"{\" + D_443.toString(this, \", \") + \"}\";\n\t\t}\n\t}\n\n\tpublic static class Tree2D\n\t{\n\t\tpublic static final int SIZE = 1 << 30;\n\t\tpublic static final Tree2D[] TREES_NULL = new Tree2D[] { null, null, null, null };\n\n\t\tpublic static boolean contains(int x, int y, int left, int bottom, int size)\n\t\t{\n\t\t\treturn left <= x && x < left + size && bottom <= y && y < bottom + size;\n\t\t}\n\n\t\tpublic static int count(Tree2D[] trees)\n\t\t{\n\t\t\tint result = 0;\n\t\t\tfor (int index = 0; index < 4; index++)\n\t\t\t{\n\t\t\t\tif (trees[index] != null)\n\t\t\t\t{\n\t\t\t\t\tresult += trees[index].count;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static int count\n\t\t\t\t(\n\t\t\t\t\t\tint rectangleLeft,\n\t\t\t\t\t\tint rectangleBottom,\n\t\t\t\t\t\tint rectangleRight,\n\t\t\t\t\t\tint rectangleTop,\n\t\t\t\t\t\tTree2D tree,\n\t\t\t\t\t\tint left,\n\t\t\t\t\t\tint bottom,\n\t\t\t\t\t\tint size\n\t\t\t\t)\n\t\t{\n\t\t\tint result;\n\t\t\tif (tree == null)\n\t\t\t{\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint right = left + size;\n\t\t\t\tint top = bottom + size;\n\t\t\t\tint intersectionLeft = Math.max(rectangleLeft, left);\n\t\t\t\tint intersectionBottom = Math.max(rectangleBottom, bottom);\n\t\t\t\tint intersectionRight = Math.min(rectangleRight, right);\n\t\t\t\tint intersectionTop = Math.min(rectangleTop, top);\n\t\t\t\tif (intersectionRight <= intersectionLeft || intersectionTop <= intersectionBottom)\n\t\t\t\t{\n\t\t\t\t\tresult = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (intersectionLeft == left && intersectionBottom == bottom && intersectionRight == right && intersectionTop == top)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = tree.count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsize = size >> 1;\n\t\t\t\t\t\tresult = 0;\n\t\t\t\t\t\tfor (int index = 0; index < 4; index++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult += count\n\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\trectangleLeft,\n\t\t\t\t\t\t\t\t\t\t\trectangleBottom,\n\t\t\t\t\t\t\t\t\t\t\trectangleRight,\n\t\t\t\t\t\t\t\t\t\t\trectangleTop,\n\t\t\t\t\t\t\t\t\t\t\ttree.trees[index],\n\t\t\t\t\t\t\t\t\t\t\tquadrantLeft(left, size, index),\n\t\t\t\t\t\t\t\t\t\t\tquadrantBottom(bottom, size, index),\n\t\t\t\t\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static int quadrantBottom(int bottom, int size, int index)\n\t\t{\n\t\t\treturn bottom + (index >> 1) * size;\n\t\t}\n\n\t\tpublic static int quadrantLeft(int left, int size, int index)\n\t\t{\n\t\t\treturn left + (index & 1) * size;\n\t\t}\n\n\t\tpublic final Tree2D[] trees;\n\t\tpublic final int count;\n\n\t\tprivate Tree2D(Tree2D[] trees, int count)\n\t\t{\n\t\t\tthis.trees = trees;\n\t\t\tthis.count = count;\n\t\t}\n\n\t\tpublic Tree2D(Tree2D[] trees)\n\t\t{\n\t\t\tthis(trees, count(trees));\n\t\t}\n\n\t\tpublic Tree2D()\n\t\t{\n\t\t\tthis(TREES_NULL);\n\t\t}\n\n\t\tpublic int count(int rectangleLeft, int rectangleBottom, int rectangleRight, int rectangleTop)\n\t\t{\n\t\t\treturn count\n\t\t\t\t\t(\n\t\t\t\t\t\t\trectangleLeft,\n\t\t\t\t\t\t\trectangleBottom,\n\t\t\t\t\t\t\trectangleRight,\n\t\t\t\t\t\t\trectangleTop,\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tSIZE\n\t\t\t\t\t);\n\t\t}\n\n\t\tpublic Tree2D setPoint\n\t\t\t\t(\n\t\t\t\t\t\tint x,\n\t\t\t\t\t\tint y,\n\t\t\t\t\t\tTree2D tree,\n\t\t\t\t\t\tint left,\n\t\t\t\t\t\tint bottom,\n\t\t\t\t\t\tint size\n\t\t\t\t)\n\t\t{\n\t\t\tTree2D result;\n\t\t\tif (contains(x, y, left, bottom, size))\n\t\t\t{\n\t\t\t\tif (size == 1)\n\t\t\t\t{\n\t\t\t\t\tresult = new Tree2D(TREES_NULL, 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsize = size >> 1;\n\t\t\t\t\tTree2D[] trees = new Tree2D[4];\n\t\t\t\t\tfor (int index = 0; index < 4; index++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttrees[index] = setPoint\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t\t\t\ttree == null ? null : tree.trees[index],\n\t\t\t\t\t\t\t\t\t\tquadrantLeft(left, size, index),\n\t\t\t\t\t\t\t\t\t\tquadrantBottom(bottom, size, index),\n\t\t\t\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult = new Tree2D(trees);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = tree;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic Tree2D setPoint(int x, int y)\n\t\t{\n\t\t\treturn setPoint\n\t\t\t\t\t(\n\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tSIZE\n\t\t\t\t\t);\n\t\t}\n\t}\n\n\tpublic static class Tuple2<Type0, Type1>\n\t{\n\t\tpublic final Type0 v0;\n\t\tpublic final Type1 v1;\n\n\t\tpublic Tuple2(Type0 v0, Type1 v1)\n\t\t{\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn \"(\" + this.v0 + \", \" + this.v1 + \")\";\n\t\t}\n\t}\n\n\tpublic static class Tuple2Comparable<Type0 extends Comparable<? super Type0>, Type1 extends Comparable<? super Type1>> extends Tuple2<Type0, Type1> implements Comparable<Tuple2Comparable<Type0, Type1>>\n\t{\n\t\tpublic Tuple2Comparable(Type0 v0, Type1 v1)\n\t\t{\n\t\t\tsuper(v0, v1);\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Tuple2Comparable<Type0, Type1> that)\n\t\t{\n\t\t\tint result = this.v0.compareTo(that.v0);\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = this.v1.compareTo(that.v1);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tpublic static class Tuple3<Type0, Type1, Type2>\n\t{\n\t\tpublic final Type0 v0;\n\t\tpublic final Type1 v1;\n\t\tpublic final Type2 v2;\n\n\t\tpublic Tuple3(Type0 v0, Type1 v1, Type2 v2)\n\t\t{\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn \"(\" + this.v0 + \", \" + this.v1 + \", \" + this.v2 + \")\";\n\t\t}\n\t}\n\n\tpublic static class Vertex\n\t\t\t<\n\t\t\t\t\tTypeVertex extends Vertex<TypeVertex, TypeEdge>,\n\t\t\t\t\tTypeEdge extends Edge<TypeVertex, TypeEdge>\n\t\t\t\t\t>\n\t\t\timplements Comparable<Vertex<? super TypeVertex, ? super TypeEdge>>\n\t{\n\t\tpublic static <\n\t\t\t\tTypeVertex extends Vertex<TypeVertex, TypeEdge>,\n\t\t\t\tTypeEdge extends Edge<TypeVertex, TypeEdge>,\n\t\t\t\tTypeResult\n\t\t\t\t> TypeResult breadthFirstSearch\n\t\t\t\t(\n\t\t\t\t\t\tTypeVertex vertex,\n\t\t\t\t\t\tTypeEdge edge,\n\t\t\t\t\t\tBiFunctionResult<TypeVertex, TypeEdge, TypeResult> function,\n\t\t\t\t\t\tArray<Boolean> visited,\n\t\t\t\t\t\tFIFO<TypeVertex> verticesNext,\n\t\t\t\t\t\tFIFO<TypeEdge> edgesNext,\n\t\t\t\t\t\tTypeResult result\n\t\t\t\t)\n\t\t{\n\t\t\tif (!visited.get(vertex.index))\n\t\t\t{\n\t\t\t\tvisited.set(vertex.index, true);\n\t\t\t\tresult = function.apply(vertex, edge, result);\n\t\t\t\tfor (TypeEdge edgeNext : vertex.edges)\n\t\t\t\t{\n\t\t\t\t\tTypeVertex vertexNext = edgeNext.other(vertex);\n\t\t\t\t\tif (!visited.get(vertexNext.index))\n\t\t\t\t\t{\n\t\t\t\t\t\tverticesNext.push(vertexNext);\n\t\t\t\t\t\tedgesNext.push(edgeNext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <\n\t\t\t\tTypeVertex extends Vertex<TypeVertex, TypeEdge>,\n\t\t\t\tTypeEdge extends Edge<TypeVertex, TypeEdge>,\n\t\t\t\tTypeResult\n\t\t\t\t>\n\t\tTypeResult breadthFirstSearch\n\t\t\t\t(\n\t\t\t\t\t\tArray<TypeVertex> vertices,\n\t\t\t\t\t\tint indexVertexStart,\n\t\t\t\t\t\tBiFunctionResult<TypeVertex, TypeEdge, TypeResult> function,\n\t\t\t\t\t\tTypeResult result\n\t\t\t\t)\n\t\t{\n\t\t\tArray<Boolean> visited = new Array<>(vertices.size(), false);\n\t\t\tFIFO<TypeVertex> verticesNext = new FIFO<>();\n\t\t\tverticesNext.push(vertices.get(indexVertexStart));\n\t\t\tFIFO<TypeEdge> edgesNext = new FIFO<>();\n\t\t\tedgesNext.push(null);\n\t\t\twhile (!verticesNext.isEmpty())\n\t\t\t{\n\t\t\t\tresult = breadthFirstSearch(verticesNext.pop(), edgesNext.pop(), function, visited, verticesNext, edgesNext, result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <\n\t\t\t\tTypeVertex extends Vertex<TypeVertex, TypeEdge>,\n\t\t\t\tTypeEdge extends Edge<TypeVertex, TypeEdge>\n\t\t\t\t>\n\t\tboolean\n\t\tcycle\n\t\t\t\t(\n\t\t\t\t\t\tTypeVertex start,\n\t\t\t\t\t\tSortedSet<TypeVertex> result\n\t\t\t\t)\n\t\t{\n\t\t\tboolean cycle = false;\n\t\t\tStack<TypeVertex> stackVertex = new Stack<>();\n\t\t\tStack<TypeEdge> stackEdge = new Stack<>();\n\t\t\tstackVertex.push(start);\n\t\t\tstackEdge.push(null);\n\t\t\twhile (!stackVertex.isEmpty())\n\t\t\t{\n\t\t\t\tTypeVertex vertex = stackVertex.pop();\n\t\t\t\tTypeEdge edge = stackEdge.pop();\n\t\t\t\tif (!result.contains(vertex))\n\t\t\t\t{\n\t\t\t\t\tresult.add(vertex);\n\t\t\t\t\tfor (TypeEdge otherEdge : vertex.edges)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (otherEdge != edge)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTypeVertex otherVertex = otherEdge.other(vertex);\n\t\t\t\t\t\t\tif (result.contains(otherVertex))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcycle = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstackVertex.push(otherVertex);\n\t\t\t\t\t\t\t\tstackEdge.push(otherEdge);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cycle;\n\t\t}\n\n\t\tpublic static <\n\t\t\t\tTypeVertex extends Vertex<TypeVertex, TypeEdge>,\n\t\t\t\tTypeEdge extends Edge<TypeVertex, TypeEdge>\n\t\t\t\t>\n\t\tSortedSet<TypeVertex>\n\t\tdepthFirstSearch\n\t\t\t\t(\n\t\t\t\t\t\tTypeVertex start,\n\t\t\t\t\t\tBiConsumer<TypeVertex, TypeEdge> functionVisitPre,\n\t\t\t\t\t\tBiConsumer<TypeVertex, TypeEdge> functionVisitPost\n\t\t\t\t)\n\t\t{\n\t\t\tSortedSet<TypeVertex> result = new SortedSetAVL<>(Comparator.naturalOrder());\n\t\t\tStack<TypeVertex> stackVertex = new Stack<>();\n\t\t\tStack<TypeEdge> stackEdge = new Stack<>();\n\t\t\tstackVertex.push(start);\n\t\t\tstackEdge.push(null);\n\t\t\twhile (!stackVertex.isEmpty())\n\t\t\t{\n\t\t\t\tTypeVertex vertex = stackVertex.pop();\n\t\t\t\tTypeEdge edge = stackEdge.pop();\n\t\t\t\tif (result.contains(vertex))\n\t\t\t\t{\n\t\t\t\t\tfunctionVisitPost.accept(vertex, edge);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult.add(vertex);\n\t\t\t\t\tstackVertex.push(vertex);\n\t\t\t\t\tstackEdge.push(edge);\n\t\t\t\t\tfunctionVisitPre.accept(vertex, edge);\n\t\t\t\t\tfor (TypeEdge otherEdge : vertex.edges)\n\t\t\t\t\t{\n\t\t\t\t\t\tTypeVertex otherVertex = otherEdge.other(vertex);\n\t\t\t\t\t\tif (!result.contains(otherVertex))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstackVertex.push(otherVertex);\n\t\t\t\t\t\t\tstackEdge.push(otherEdge);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <\n\t\t\t\tTypeVertex extends Vertex<TypeVertex, TypeEdge>,\n\t\t\t\tTypeEdge extends Edge<TypeVertex, TypeEdge>\n\t\t\t\t>\n\t\tSortedSet<TypeVertex>\n\t\tdepthFirstSearch\n\t\t\t\t(\n\t\t\t\t\t\tTypeVertex start,\n\t\t\t\t\t\tConsumer<TypeVertex> functionVisitPreVertex,\n\t\t\t\t\t\tConsumer<TypeVertex> functionVisitPostVertex\n\t\t\t\t)\n\t\t{\n\t\t\tBiConsumer<TypeVertex, TypeEdge> functionVisitPreVertexEdge = (vertex, edge) ->\n\t\t\t{\n\t\t\t\tfunctionVisitPreVertex.accept(vertex);\n\t\t\t};\n\t\t\tBiConsumer<TypeVertex, TypeEdge> functionVisitPostVertexEdge = (vertex, edge) ->\n\t\t\t{\n\t\t\t\tfunctionVisitPostVertex.accept(vertex);\n\t\t\t};\n\t\t\treturn depthFirstSearch(start, functionVisitPreVertexEdge, functionVisitPostVertexEdge);\n\t\t}\n\n\t\tpublic final int index;\n\t\tpublic final List<TypeEdge> edges;\n\n\t\tpublic Vertex(int index)\n\t\t{\n\t\t\tthis.index = index;\n\t\t\tthis.edges = new ArrayList<>();\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Vertex<? super TypeVertex, ? super TypeEdge> that)\n\t\t{\n\t\t\treturn Integer.compare(this.index, that.index);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn \"\" + this.index;\n\t\t}\n\t}\n\n\tpublic static class VertexDefault<TypeEdge extends Edge<VertexDefault<TypeEdge>, TypeEdge>> extends Vertex<VertexDefault<TypeEdge>, TypeEdge>\n\t{\n\t\tpublic VertexDefault(int index)\n\t\t{\n\t\t\tsuper(index);\n\t\t}\n\t}\n\n\tpublic static class VertexDefaultDefault extends Vertex<VertexDefaultDefault, EdgeDefaultDefault>\n\t{\n\t\tpublic static Array<VertexDefaultDefault> vertices(int n)\n\t\t{\n\t\t\tArray<VertexDefaultDefault> result = new Array<>(n);\n\t\t\tfor (int index = 0; index < n; index++)\n\t\t\t{\n\t\t\t\tresult.set(index, new VertexDefaultDefault(index));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic VertexDefaultDefault(int index)\n\t\t{\n\t\t\tsuper(index);\n\t\t}\n\t}\n\n\tpublic static class Wrapper<Type>\n\t{\n\t\tpublic Type value;\n\n\t\tpublic Wrapper(Type value)\n\t\t{\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tpublic Type get()\n\t\t{\n\t\t\treturn this.value;\n\t\t}\n\n\t\tpublic void set(Type value)\n\t\t{\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn this.value.toString();\n\t\t}\n\t}\n\n\tpublic static void add(int delta, int[] result)\n\t{\n\t\tfor (int index = 0; index < result.length; index++)\n\t\t{\n\t\t\tresult[index] += delta;\n\t\t}\n\t}\n\n\tpublic static void add(int delta, int[]... result)\n\t{\n\t\tfor (int index = 0; index < result.length; index++)\n\t\t{\n\t\t\tadd(delta, result[index]);\n\t\t}\n\t}\n\n\tpublic static int binarySearchMaximum(Function<Integer, Boolean> filter, int start, int end)\n\t{\n\t\treturn -binarySearchMinimum(x -> filter.apply(-x), -end, -start);\n\t}\n\n\tpublic static int binarySearchMinimum(Function<Integer, Boolean> filter, int start, int end)\n\t{\n\t\tint result;\n\t\tif (start == end)\n\t\t{\n\t\t\tresult = end;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint middle = start + (end - start) / 2;\n\t\t\tif (filter.apply(middle))\n\t\t\t{\n\t\t\t\tresult = binarySearchMinimum(filter, start, middle);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = binarySearchMinimum(filter, middle + 1, end);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static void close()\n\t{\n\t\tout.close();\n\t}\n\n\tpublic static List<List<Integer>> combinations(int n, int k)\n\t{\n\t\tList<List<Integer>> result = new ArrayList<>();\n\t\tif (k == 0)\n\t\t{\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (k == 1)\n\t\t\t{\n\t\t\t\tList<Integer> combination = new ArrayList<>();\n\t\t\t\tcombination.add(n);\n\t\t\t\tresult.add(combination);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int index = 0; index <= n; index++)\n\t\t\t\t{\n\t\t\t\t\tfor (List<Integer> combination : combinations(n - index, k - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tcombination.add(index);\n\t\t\t\t\t\tresult.add(combination);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static <Type> int compare(Iterator<Type> iterator0, Iterator<Type> iterator1, Comparator<Type> comparator)\n\t{\n\t\tint result = 0;\n\t\twhile (result == 0 && iterator0.hasNext() && iterator1.hasNext())\n\t\t{\n\t\t\tresult = comparator.compare(iterator0.next(), iterator1.next());\n\t\t}\n\t\tif (result == 0)\n\t\t{\n\t\t\tif (iterator1.hasNext())\n\t\t\t{\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (iterator0.hasNext())\n\t\t\t\t{\n\t\t\t\t\tresult = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static <Type> int compare(Iterable<Type> iterable0, Iterable<Type> iterable1, Comparator<Type> comparator)\n\t{\n\t\treturn compare(iterable0.iterator(), iterable1.iterator(), comparator);\n\t}\n\n\tpublic static long divideCeil(long x, long y)\n\t{\n\t\treturn (x + y - 1) / y;\n\t}\n\n\tpublic static Set<Long> divisors(long n)\n\t{\n\t\tSortedSetAVL<Long> result = new SortedSetAVL<>(Comparator.naturalOrder());\n\t\tresult.add(1L);\n\t\tfor (Long factor : factors(n))\n\t\t{\n\t\t\tSortedSetAVL<Long> divisors = new SortedSetAVL<>(result);\n\t\t\tfor (Long divisor : result)\n\t\t\t{\n\t\t\t\tdivisors.add(divisor * factor);\n\t\t\t}\n\t\t\tresult = divisors;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static LinkedList<Long> factors(long n)\n\t{\n\t\tLinkedList<Long> result = new LinkedList<>();\n\t\tIterator<Long> primes = ITERATOR_BUFFER_PRIME.iterator();\n\t\tLong prime;\n\t\twhile (n > 1 && (prime = primes.next()) * prime <= n)\n\t\t{\n\t\t\twhile (n % prime == 0)\n\t\t\t{\n\t\t\t\tresult.add(prime);\n\t\t\t\tn /= prime;\n\t\t\t}\n\t\t}\n\t\tif (n > 1)\n\t\t{\n\t\t\tresult.add(n);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static long faculty(int n)\n\t{\n\t\tlong result = 1;\n\t\tfor (int index = 2; index <= n; index++)\n\t\t{\n\t\t\tresult *= index;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static long gcd(long a, long b)\n\t{\n\t\twhile (a != 0 && b != 0)\n\t\t{\n\t\t\tif (a > b)\n\t\t\t{\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb %= a;\n\t\t\t}\n\t\t}\n\t\treturn a + b;\n\t}\n\n\tpublic static long[] generatePOWER2()\n\t{\n\t\tlong[] result = new long[63];\n\t\tfor (int x = 0; x < result.length; x++)\n\t\t{\n\t\t\tresult[x] = 1L << x;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static boolean isPrime(long x)\n\t{\n\t\tboolean result = x > 1;\n\t\tIterator<Long> iterator = ITERATOR_BUFFER_PRIME.iterator();\n\t\tLong prime;\n\t\twhile ((prime = iterator.next()) * prime <= x)\n\t\t{\n\t\t\tresult &= x % prime > 0;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static long knapsack(List<Tuple3<Long, Integer, Integer>> itemsValueWeightCount, int weightMaximum)\n\t{\n\t\tlong[] valuesMaximum = new long[weightMaximum + 1];\n\t\tfor (Tuple3<Long, Integer, Integer> itemValueWeightCount : itemsValueWeightCount)\n\t\t{\n\t\t\tlong itemValue = itemValueWeightCount.v0;\n\t\t\tint itemWeight = itemValueWeightCount.v1;\n\t\t\tint itemCount = itemValueWeightCount.v2;\n\t\t\tfor (int weight = weightMaximum; 0 <= weight; weight--)\n\t\t\t{\n\t\t\t\tfor (int index = 1; index <= itemCount && 0 <= weight - index * itemWeight; index++)\n\t\t\t\t{\n\t\t\t\t\tvaluesMaximum[weight] = Math.max(valuesMaximum[weight], valuesMaximum[weight - index * itemWeight] + index * itemValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong result = 0;\n\t\tfor (long valueMaximum : valuesMaximum)\n\t\t{\n\t\t\tresult = Math.max(result, valueMaximum);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static boolean knapsackPossible(List<Tuple2<Integer, Integer>> itemsWeightCount, int weightMaximum)\n\t{\n\t\tboolean[] weightPossible = new boolean[weightMaximum + 1];\n\t\tweightPossible[0] = true;\n\t\tint weightLargest = 0;\n\t\tfor (Tuple2<Integer, Integer> itemWeightCount : itemsWeightCount)\n\t\t{\n\t\t\tint itemWeight = itemWeightCount.v0;\n\t\t\tint itemCount = itemWeightCount.v1;\n\t\t\tfor (int weightStart = 0; weightStart < itemWeight; weightStart++)\n\t\t\t{\n\t\t\t\tint count = 0;\n\t\t\t\tfor (int weight = weightStart; weight <= weightMaximum && (0 < count || weight <= weightLargest); weight += itemWeight)\n\t\t\t\t{\n\t\t\t\t\tif (weightPossible[weight])\n\t\t\t\t\t{\n\t\t\t\t\t\tcount = itemCount;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (0 < count)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tweightPossible[weight] = true;\n\t\t\t\t\t\t\tweightLargest = weight;\n\t\t\t\t\t\t\tcount -= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn weightPossible[weightMaximum];\n\t}\n\n\tpublic static long lcm(int a, int b)\n\t{\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tpublic static void main(String[] args)\n\t{\n\t\ttry\n\t\t{\n\t\t\tsolve();\n\t\t}\n\t\tcatch (IOException exception)\n\t\t{\n\t\t\texception.printStackTrace();\n\t\t}\n\t\tclose();\n\t}\n\n\tpublic static double nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(nextString());\n\t}\n\n\tpublic static int nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static void nextInts(int n, int[]... result) throws IOException\n\t{\n\t\tfor (int index = 0; index < n; index++)\n\t\t{\n\t\t\tfor (int value = 0; value < result.length; value++)\n\t\t\t{\n\t\t\t\tresult[value][index] = nextInt();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int[] nextInts(int n) throws IOException\n\t{\n\t\tint[] result = new int[n];\n\t\tnextInts(n, result);\n\t\treturn result;\n\t}\n\n\tpublic static String nextLine() throws IOException\n\t{\n\t\treturn bufferedReader.readLine();\n\t}\n\n\tpublic static long nextLong() throws IOException\n\t{\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static void nextLongs(int n, long[]... result) throws IOException\n\t{\n\t\tfor (int index = 0; index < n; index++)\n\t\t{\n\t\t\tfor (int value = 0; value < result.length; value++)\n\t\t\t{\n\t\t\t\tresult[value][index] = nextLong();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static long[] nextLongs(int n) throws IOException\n\t{\n\t\tlong[] result = new long[n];\n\t\tnextLongs(n, result);\n\t\treturn result;\n\t}\n\n\tpublic static String nextString() throws IOException\n\t{\n\t\twhile ((stringTokenizer == null) || (!stringTokenizer.hasMoreTokens()))\n\t\t{\n\t\t\tstringTokenizer = new StringTokenizer(bufferedReader.readLine());\n\t\t}\n\t\treturn stringTokenizer.nextToken();\n\t}\n\n\tpublic static String[] nextStrings(int n) throws IOException\n\t{\n\t\tString[] result = new String[n];\n\t\t{\n\t\t\tfor (int index = 0; index < n; index++)\n\t\t\t{\n\t\t\t\tresult[index] = nextString();\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static <T> List<T> permutation(long p, List<T> x)\n\t{\n\t\tList<T> copy = new ArrayList<>();\n\t\tfor (int index = 0; index < x.size(); index++)\n\t\t{\n\t\t\tcopy.add(x.get(index));\n\t\t}\n\t\tList<T> result = new ArrayList<>();\n\t\tfor (int indexTo = 0; indexTo < x.size(); indexTo++)\n\t\t{\n\t\t\tint indexFrom = (int) p % copy.size();\n\t\t\tp = p / copy.size();\n\t\t\tresult.add(copy.remove(indexFrom));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static <Type> List<List<Type>> permutations(List<Type> list)\n\t{\n\t\tList<List<Type>> result = new ArrayList<>();\n\t\tresult.add(new ArrayList<>());\n\t\tfor (Type element : list)\n\t\t{\n\t\t\tList<List<Type>> permutations = result;\n\t\t\tresult = new ArrayList<>();\n\t\t\tfor (List<Type> permutation : permutations)\n\t\t\t{\n\t\t\t\tfor (int index = 0; index <= permutation.size(); index++)\n\t\t\t\t{\n\t\t\t\t\tList<Type> permutationNew = new ArrayList<>(permutation);\n\t\t\t\t\tpermutationNew.add(index, element);\n\t\t\t\t\tresult.add(permutationNew);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static Stream<BigInteger> streamFibonacci()\n\t{\n\t\treturn Stream.generate(new Supplier<BigInteger>()\n\t\t{\n\t\t\tprivate BigInteger n0 = BigInteger.ZERO;\n\t\t\tprivate BigInteger n1 = BigInteger.ONE;\n\n\t\t\t@Override\n\t\t\tpublic BigInteger get()\n\t\t\t{\n\t\t\t\tBigInteger result = n0;\n\t\t\t\tn0 = n1;\n\t\t\t\tn1 = result.add(n0);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static Stream<Long> streamPrime(int sieveSize)\n\t{\n\t\treturn Stream.generate(new Supplier<Long>()\n\t\t{\n\t\t\tprivate boolean[] isPrime = new boolean[sieveSize];\n\t\t\tprivate long sieveOffset = 2;\n\t\t\tprivate List<Long> primes = new ArrayList<>();\n\t\t\tprivate int index = 0;\n\n\t\t\tpublic void filter(long prime, boolean[] result)\n\t\t\t{\n\t\t\t\tif (prime * prime < this.sieveOffset + sieveSize)\n\t\t\t\t{\n\t\t\t\t\tlong remainingStart = this.sieveOffset % prime;\n\t\t\t\t\tlong start = remainingStart == 0 ? 0 : prime - remainingStart;\n\t\t\t\t\tfor (long index = start; index < sieveSize; index += prime)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult[(int) index] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void generatePrimes()\n\t\t\t{\n\t\t\t\tArrays.fill(this.isPrime, true);\n\t\t\t\tthis.primes.forEach(prime -> filter(prime, isPrime));\n\t\t\t\tfor (int index = 0; index < sieveSize; index++)\n\t\t\t\t{\n\t\t\t\t\tif (isPrime[index])\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.primes.add(this.sieveOffset + index);\n\t\t\t\t\t\tfilter(this.sieveOffset + index, isPrime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.sieveOffset += sieveSize;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Long get()\n\t\t\t{\n\t\t\t\twhile (this.primes.size() <= this.index)\n\t\t\t\t{\n\t\t\t\t\tgeneratePrimes();\n\t\t\t\t}\n\t\t\t\tLong result = this.primes.get(this.index);\n\t\t\t\tthis.index += 1;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static <Type> String toString(Iterator<Type> iterator, String separator)\n\t{\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\tif (iterator.hasNext())\n\t\t{\n\t\t\tstringBuilder.append(iterator.next());\n\t\t}\n\t\twhile (iterator.hasNext())\n\t\t{\n\t\t\tstringBuilder.append(separator);\n\t\t\tstringBuilder.append(iterator.next());\n\t\t}\n\t\treturn stringBuilder.toString();\n\t}\n\n\tpublic static <Type> String toString(Iterator<Type> iterator)\n\t{\n\t\treturn toString(iterator, \" \");\n\t}\n\n\tpublic static <Type> String toString(Iterable<Type> iterable, String separator)\n\t{\n\t\treturn toString(iterable.iterator(), separator);\n\t}\n\n\tpublic static <Type> String toString(Iterable<Type> iterable)\n\t{\n\t\treturn toString(iterable, \" \");\n\t}\n\n\tpublic static long totient(long n)\n\t{\n\t\tSet<Long> factors = new SortedSetAVL<>(factors(n), Comparator.naturalOrder());\n\t\tlong result = n;\n\t\tfor (long p : factors)\n\t\t{\n\t\t\tresult -= result / p;\n\t\t}\n\t\treturn result;\n\t}\n\n\tinterface BiFunctionResult<Type0, Type1, TypeResult>\n\t{\n\t\tTypeResult apply(Type0 x0, Type1 x1, TypeResult x2);\n\t}\n\n\tpublic static void add(long k, LinkedList<Integer> cities, LinkedList<Long> counts, int city, long count)\n\t{\n\t\tif (cities.isEmpty() || cities.getLast().intValue() != city)\n\t\t{\n\t\t\tcities.addLast(city);\n\t\t\tcounts.addLast(count);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcounts.addLast(count + counts.removeLast());\n\t\t}\n\t\tcounts.addLast(counts.removeLast() % k);\n\t\tif (counts.getLast() == 0)\n\t\t{\n\t\t\tcities.removeLast();\n\t\t\tcounts.removeLast();\n\t\t}\n\t}\n\n\tpublic static long solve(long k, long m, int[] as)\n\t{\n\t\tLinkedList<Integer> citiesMiddle = new LinkedList<>();\n\t\tLinkedList<Long> countsMiddle = new LinkedList<>();\n\t\tfor (int city : as)\n\t\t{\n\t\t\tadd(k, citiesMiddle, countsMiddle, city, 1);\n\t\t}\n\t\tLinkedList<Integer> citiesFirst = new LinkedList<>();\n\t\tLinkedList<Long> countsFirst = new LinkedList<>();\n\t\tLinkedList<Integer> citiesLast = new LinkedList<>();\n\t\tLinkedList<Long> countsLast = new LinkedList<>();\n\t\tif (2 <= m)\n\t\t{\n\t\t\tm -= 2;\n\t\t\tcitiesFirst.addAll(citiesMiddle);\n\t\t\tcountsFirst.addAll(countsMiddle);\n\t\t\tcitiesLast.addAll(citiesMiddle);\n\t\t\tcountsLast.addAll(countsMiddle);\n\t\t\tboolean changed;\n\t\t\tchanged = true;\n\t\t\twhile (changed && 2 <= citiesMiddle.size())\n\t\t\t{\n\t\t\t\tchanged = false;\n\t\t\t\tif (citiesMiddle.getFirst().intValue() == citiesMiddle.getLast().intValue())\n\t\t\t\t{\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tint city = citiesMiddle.removeFirst();\n\t\t\t\t\tlong count = countsMiddle.removeFirst();\n\t\t\t\t\tcitiesLast.removeFirst();\n\t\t\t\t\tcountsLast.removeFirst();\n\t\t\t\t\tadd(k, citiesFirst, countsFirst, city, count);\n\t\t\t\t\tadd(k, citiesMiddle, countsMiddle, city, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (citiesMiddle.size() == 1)\n\t\t\t{\n\t\t\t\tint city = citiesMiddle.removeFirst();\n\t\t\t\tlong count = countsMiddle.removeFirst();\n\t\t\t\tadd(k, citiesFirst, countsFirst, city, m * count);\n\t\t\t}\n\t\t\tif (citiesMiddle.isEmpty())\n\t\t\t{\n\t\t\t\twhile (!citiesLast.isEmpty())\n\t\t\t\t{\n\t\t\t\t\tint city = citiesLast.removeFirst();\n\t\t\t\t\tlong count = countsLast.removeFirst();\n\t\t\t\t\tadd(k, citiesFirst, countsFirst, city, count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong totalFirst = 0;\n\t\tfor (Long count : countsFirst)\n\t\t{\n\t\t\ttotalFirst += count;\n\t\t}\n\t\tlong totalMiddle = 0;\n\t\tfor (Long count : countsMiddle)\n\t\t{\n\t\t\ttotalMiddle += m * count;\n\t\t}\n\t\tlong totalLast = 0;\n\t\tfor (Long count : countsLast)\n\t\t{\n\t\t\ttotalLast += count;\n\t\t}\n\t\treturn totalFirst + totalMiddle + totalLast;\n\t}\n\n\tpublic static void solve() throws IOException\n\t{\n\t\tint n = nextInt();\n\t\tlong k = nextLong();\n\t\tlong m = nextLong();\n\t\tint[] as = nextInts(n);\n\t\tout.println(solve(k, m, as));\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long s1[100005];\nlong long node[100005][2];\nint main() {\n  long long n, k, m;\n  while (scanf(\"%lld%lld%lld\", &n, &k, &m) != EOF) {\n    long long all = 0;\n    for (long long a = 1; a <= n; a++) {\n      int temp;\n      scanf(\"%d\", &temp);\n      if (!all || temp != node[all][0]) {\n        all++;\n        node[all][0] = temp;\n        node[all][1] = 1;\n      } else\n        node[all][1]++;\n      if (node[all][1] == k) node[all--][1] -= k;\n    }\n    long long sum = 0;\n    for (long long a = 1; a <= all; a++) sum += node[a][1];\n    long long l = 1, r = all;\n    while (l < r && node[l][0] == node[r][0]) {\n      long long temp = (node[l][1] + node[r][1]) % k;\n      if (temp == 0) {\n        l++;\n        r--;\n      } else {\n        node[l][1] = temp;\n        node[r][1] = 0;\n        break;\n      }\n    }\n    long long ans = 0;\n    if (l < r) {\n      long long temp = 0;\n      for (long long a = l; a <= r; a++) temp += node[a][1];\n      ans = (m - 1) * temp + sum;\n    } else if (l == r) {\n      if ((node[l][1] * m) % k == 0)\n        ans = 0;\n      else {\n        ans = sum + node[l][1] * (m - 1);\n        ans -= node[l][1] * m - node[l][1] * m % k;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n/**\n * @author Don Li\n */\npublic class TeamsFormation {\n    \n    void solve() {\n        int n = in.nextInt(), k = in.nextInt(), m = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = in.nextInt();\n        \n        Deque<int[]> qu = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            if (!qu.isEmpty() && qu.getLast()[0] == a[i]) {\n                if (++qu.getLast()[1] == k) qu.removeLast();\n            } else {\n                qu.offerLast(new int[]{a[i], 1});\n            }\n        }\n        \n        n = qu.size();\n        List<int[]> pairs = new ArrayList<>(qu);\n        int len = 0;\n        for (int i = 0; i < n; i++) len += pairs.get(i)[1];\n        \n        if (n == 0) {\n            out.println(0);\n            return;\n        }\n        \n        if (n == 1) {\n            long tot = (long) len * m;\n            out.println(tot % k);\n            return;\n        }\n        \n        int p = 0;\n        for (int i = 0; i < n; i++) {\n            int[] u = pairs.get(i), v = pairs.get(n - 1 - i);\n            if (u[0] == v[0] && u[1] + v[1] == k) {\n                p++;\n            } else {\n                break;\n            }\n        }\n        \n        if (p >= (n + 1) / 2) {\n            out.println(m % 2 == 0 ? 0 : len);\n            return;\n        }\n        \n        if (n % 2 == 1) {\n            if (p == n / 2) {\n                long center = (long) pairs.get(p)[1] * m;\n                if (center % k == 0) {\n                    out.println(0);\n                } else {\n                    out.println(len - pairs.get(p)[1] + center % k);\n                }\n            } else {\n                long ans = (long) len * m, del = 0;\n                for (int i = 0; i < p; i++) del += pairs.get(i)[1];\n                for (int i = n - p; i < n; i++) del += pairs.get(i)[1];\n                int[] u = pairs.get(p), v = pairs.get(n - 1 - p);\n                if (u[0] == v[0] && u[1] + v[1] >= k) del += k;\n                out.println(ans - (m - 1) * del);\n            }\n        } else {\n            long ans = (long) len * m, del = 0;\n            for (int i = 0; i < p; i++) del += pairs.get(i)[1];\n            for (int i = n - p; i < n; i++) del += pairs.get(i)[1];\n            int[] u = pairs.get(p), v = pairs.get(n - 1 - p);\n            if (u[0] == v[0] && u[1] + v[1] >= k) del += k;\n            out.println(ans - (m - 1) * del);\n        }\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new TeamsFormation().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class t, class u>\nvoid chmax(t& first, u second) {\n  if (first < second) first = second;\n}\ntemplate <class t, class u>\nvoid chmin(t& first, u second) {\n  if (second < first) first = second;\n}\ntemplate <class t>\nusing vc = vector<t>;\ntemplate <class t>\nusing vvc = vc<vc<t>>;\nusing pi = pair<ll, ll>;\nusing vi = vc<ll>;\ntemplate <class t, class u>\nostream& operator<<(ostream& os, const pair<t, u>& p) {\n  return os << \"{\" << p.first << \",\" << p.second << \"}\";\n}\ntemplate <class t>\nostream& operator<<(ostream& os, const vc<t>& v) {\n  os << \"{\";\n  for (auto e : v) os << e << \",\";\n  return os << \"}\";\n}\nusing uint = unsigned;\nusing ull = unsigned long long;\ntemplate <class t, size_t n>\nostream& operator<<(ostream& os, const array<t, n>& first) {\n  return os << vc<t>(first.begin(), first.end());\n}\ntemplate <ll i, class T>\nvoid print_tuple(ostream&, const T&) {}\ntemplate <ll i, class T, class H, class... Args>\nvoid print_tuple(ostream& os, const T& t) {\n  if (i) os << \",\";\n  os << get<i>(t);\n  print_tuple<i + 1, T, Args...>(os, t);\n}\ntemplate <class... Args>\nostream& operator<<(ostream& os, const tuple<Args...>& t) {\n  os << \"{\";\n  print_tuple<0, tuple<Args...>, Args...>(os, t);\n  return os << \"}\";\n}\ntemplate <class t>\nvoid print(t x, ll suc = 1) {\n  cout << x;\n  if (suc == 1) cout << \"\\n\";\n  if (suc == 2) cout << \" \";\n}\nll read() {\n  ll i;\n  cin >> i;\n  return i;\n}\nvi readvi(ll n, ll off = 0) {\n  vi v(n);\n  for (ll i = ll(0); i < ll(n); i++) v[i] = read() + off;\n  return v;\n}\ntemplate <class T>\nvoid print(const vector<T>& v, ll suc = 1) {\n  for (ll i = ll(0); i < ll(v.size()); i++)\n    print(v[i], i == ll(v.size()) - 1 ? suc : 2);\n}\nstring readString() {\n  string s;\n  cin >> s;\n  return s;\n}\ntemplate <class T>\nT sq(const T& t) {\n  return t * t;\n}\nvoid yes(bool ex = true) {\n  cout << \"Yes\"\n       << \"\\n\";\n  if (ex) exit(0);\n}\nvoid no(bool ex = true) {\n  cout << \"No\"\n       << \"\\n\";\n  if (ex) exit(0);\n}\nvoid possible(bool ex = true) {\n  cout << \"Possible\"\n       << \"\\n\";\n  if (ex) exit(0);\n}\nvoid impossible(bool ex = true) {\n  cout << \"Impossible\"\n       << \"\\n\";\n  if (ex) exit(0);\n}\nconstexpr ll ten(ll n) { return n == 0 ? 1 : ten(n - 1) * 10; }\nconst ll infLL = LLONG_MAX / 3;\nconst ll inf = infLL;\nll topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\nll topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\nll botbit(signed first) { return first == 0 ? 32 : __builtin_ctz(first); }\nll botbit(ll first) { return first == 0 ? 64 : __builtin_ctzll(first); }\nll popcount(signed t) { return __builtin_popcount(t); }\nll popcount(ll t) { return __builtin_popcountll(t); }\nbool ispow2(ll i) { return i && (i & -i) == i; }\nll mask(ll i) { return (ll(1) << i) - 1; }\nbool inc(ll first, ll second, ll c) { return first <= second && second <= c; }\ntemplate <class t>\nvoid mkuni(vc<t>& v) {\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n}\nll rand_int(ll l, ll r) {\n  static random_device rd;\n  static mt19937_64 gen(rd());\n  return uniform_int_distribution<ll>(l, r)(gen);\n}\ntemplate <class t>\nll lwb(const vc<t>& v, const t& first) {\n  return lower_bound(v.begin(), v.end(), first) - v.begin();\n}\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout << fixed << setprecision(20);\n  ll n, k, m;\n  cin >> n >> k >> m;\n  vc<pi> z;\n  for (ll i = ll(0); i < ll(n); i++) {\n    ll x = read();\n    if (ll(z.size()) == 0 || z.back().first != x) {\n      z.emplace_back(x, 0);\n    }\n    z.back().second++;\n    if (z.back().second == k) {\n      z.pop_back();\n    }\n  }\n  n = ll(z.size());\n  ll len = 0;\n  for (auto w : z) len += w.second;\n  void(0);\n  if (ll(z.size()) == 0 || m == 1) {\n    print(len);\n    return 0;\n  }\n  ll r = 0, er = 0;\n  for (ll i = ll(0); i < ll(n); i++) {\n    if (z[n - 1 - i].first != z[i].first) break;\n    ll s = z[n - 1 - i].second + z[i].second;\n    er += s / k * k;\n    s %= k;\n    if (s) break;\n    r++;\n  }\n  if (r == n) {\n    print(len * (m % 2));\n    return 0;\n  } else if (r * 2 + 1 == n) {\n    ll s = z[r].second * m;\n    s %= k;\n    if (s) {\n      print(len - z[r].second + s);\n    } else {\n      print(0);\n    }\n    return 0;\n  } else {\n    void(0);\n    assert(r * 2 < n);\n    print(len * m - er * (m - 1));\n    return 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 10;\nlong long n, m, k, len, res;\nlong long a[MAXN], seq[MAXN], cnt[MAXN];\nbool singleColor;\nint main() {\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  for (long long i = 1; i <= n; ++i) scanf(\"%lld\", &a[i]);\n  singleColor = true;\n  for (long long i = 2; i <= n; ++i)\n    if (a[i] != a[1]) {\n      singleColor = false;\n      break;\n    }\n  if (singleColor) {\n    res = n * m % k;\n    printf(\"%lld\\n\", res);\n    return 0;\n  }\n  for (long long i = 1; i <= n; ++i) {\n    seq[++len] = a[i];\n    if (seq[len] == seq[len - 1])\n      cnt[len] = cnt[len - 1] + 1;\n    else\n      cnt[len] = 1;\n    if (cnt[len] == k) len -= k;\n  }\n  singleColor = true;\n  for (long long i = 2; i <= len; ++i)\n    if (seq[i] != seq[1]) {\n      singleColor = false;\n      break;\n    }\n  if (singleColor) {\n    res = len * m % k;\n    printf(\"%lld\\n\", res);\n    return 0;\n  }\n  long long l, r, ct, L = 1, R = len, sum = 0;\n  while (L < R) {\n    l = L;\n    r = R;\n    ct = 0;\n    while (l < r && seq[l] == seq[L] && ct < k) {\n      ++ct;\n      ++l;\n    }\n    while (l < r && seq[r] == seq[L] && ct < k) {\n      ++ct;\n      --r;\n    }\n    if (ct == k) {\n      L = l;\n      R = r;\n      sum += k;\n    } else\n      break;\n  }\n  singleColor = true;\n  for (int i = L + 1; i <= R; ++i)\n    if (seq[i] != seq[L]) {\n      singleColor = false;\n      break;\n    }\n  if (singleColor) {\n    res = (R - L + 1) * m % k;\n    if (res) res += sum;\n    printf(\"%lld\\n\", res);\n    return 0;\n  }\n  res = (R - L + 1) * m + sum;\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing i64 = long long;\ntemplate <class T>\nstd::vector<T> read(int n) {\n  std::vector<T> res(n);\n  for (auto& r : res) {\n    std::cin >> r;\n  }\n  return res;\n}\ni64 solve(std::deque<std::pair<int, int>>& a, i64 n, i64 k, i64 m) {\n  if (a.size() <= 1) {\n    return n * m % k;\n  }\n  auto l = a.front(), r = a.back();\n  a.pop_front(), a.pop_back();\n  if (l.first != r.first) {\n    return n * m;\n  }\n  i64 len = l.second + r.second;\n  if (len % k) {\n    return n * m - len / k * k * (m - 1);\n  }\n  i64 rem = solve(a, n - len, k, m);\n  if (rem == 0) {\n    return 0;\n  } else {\n    return rem + len;\n  }\n}\nint main() {\n  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);\n  int n, k, m;\n  std::cin >> n >> k >> m;\n  auto a = read<int>(n);\n  std::deque<std::pair<int, int>> runs;\n  for (int i = 0; i < n; i++) {\n    runs.push_back({a[i], 1});\n    while (runs.size() >= 2 &&\n           runs[runs.size() - 2].first == runs[runs.size() - 1].first) {\n      runs[runs.size() - 2].second += runs[runs.size() - 1].second;\n      runs.pop_back();\n      if (runs.back().second % k == 0) {\n        runs.pop_back();\n      }\n    }\n  }\n  int num = 0;\n  for (const auto& r : runs) {\n    num += r.second;\n  }\n  std::cout << solve(runs, num, k, m) << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m, i;\nlong long a[300011], aux;\nlong long ini_size, sz2;\ndeque<pair<long long, long long> > Q;\nvector<pair<long long, long long> > ini;\nvoid add_to_que(long long val, long long cnt) {\n  cnt %= k;\n  if (cnt == 0) return;\n  if (Q.empty()) {\n    Q.push_back(make_pair(val, cnt));\n  } else {\n    if (Q.back().first == val) {\n      auto last = Q.back();\n      Q.pop_back();\n      last.second = (last.second + cnt) % k;\n      if (last.second != 0) Q.push_back(last);\n    } else {\n      Q.push_back(make_pair(val, cnt));\n    }\n  }\n}\nvoid solve() {\n  int i, dif;\n  dif = 0;\n  while (Q.size() > 1) {\n    auto frs = Q.front();\n    auto last = Q.back();\n    if (frs.first != last.first) break;\n    dif += frs.second;\n    Q.pop_front();\n    Q.pop_back();\n    last.second = (frs.second + last.second) % k;\n    if (last.second != 0) Q.push_back(last);\n  }\n  if (Q.empty()) {\n    printf(\"%lld\\n\", ini_size);\n    exit(0);\n  }\n  if (Q.size() > 1) {\n    sz2 = 0;\n    while (!Q.empty()) {\n      sz2 += Q.back().second;\n      Q.pop_back();\n    }\n    printf(\"%lld\\n\", ini_size + (m - 1) * sz2);\n    exit(0);\n  }\n  auto rez = Q.back();\n  Q.pop_back();\n  rez.second = (rez.second * (m - 1)) % k;\n  if (rez.second == 0) {\n    printf(\"%lld\", ini_size);\n    exit(0);\n  }\n  for (i = 0; i < ini.size() && dif > 0; i++) {\n    add_to_que(ini[i].first, ini[i].second);\n    dif -= ini[i].second;\n  }\n  add_to_que(rez.first, rez.second);\n  for (; i < ini.size(); i++) {\n    add_to_que(ini[i].first, ini[i].second);\n  }\n  ini_size = 0;\n  while (!Q.empty()) {\n    ini_size += Q.back().second;\n    Q.pop_back();\n  }\n  printf(\"%lld\", ini_size);\n  exit(0);\n}\nint main() {\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%lld\", &a[i]);\n    add_to_que(a[i], 1);\n  }\n  while (!Q.empty()) {\n    ini.push_back(Q.front());\n    Q.pop_front();\n    ini_size += ini.back().second;\n  }\n  for (auto e : ini) Q.push_back(e);\n  if (Q.empty()) {\n    printf(\"0\");\n    return 0;\n  }\n  if (Q.size() == 1) {\n    aux = Q.back().second;\n    aux *= m;\n    aux %= k;\n    printf(\"%lld\", aux);\n    return 0;\n  }\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 300005;\nconst double eps = 1e-10;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\npair<int, int> p[maxn];\nint a[maxn];\nint main() {\n  int n = read();\n  long long k = read(), m = read();\n  for (int i = 1; i <= n; i++) a[i] = read();\n  int tot = 0;\n  for (int i = 1, num = 0; i <= n; i++) {\n    if (a[i] != p[tot].first)\n      p[++tot].first = a[i], p[tot].second = 1;\n    else {\n      (p[tot].second += 1) %= k;\n      if (p[tot].second == 0) tot--;\n    }\n  }\n  int pl = 1, pr = tot;\n  long long ans = 0, a1 = 0, a2 = 0;\n  for (int i = 1; i <= tot; i++) a1 += p[i].second;\n  while (pl != pr) {\n    if (p[pl].first == p[pr].first && (p[pl].second + p[pr].second) % k == 0)\n      a2 += p[pl].second + p[pr].second, pl++, pr--;\n    else\n      break;\n  }\n  if (pl == pr) {\n    ans = a1 * m - a2 * (m - 1) - m * p[pl].second / k * k;\n    if ((m * p[pl].second) % k == 0) ans -= a2;\n  } else {\n    if (p[pl].first == p[pr].first) a2 += (p[pl].second + p[pr].second) / k * k;\n    ans = a1 * m - a2 * (m - 1);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 7;\nint s[maxn][2], B[maxn];\nint main() {\n  int n;\n  long long k, m;\n  scanf(\"%d%lld%lld\", &n, &k, &m);\n  long long ans = n * m, tol = 0;\n  int top = 0, x, R = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &x);\n    if (!top || s[top][0] != x) {\n      s[++top][0] = x;\n      s[top][1] = 1;\n    } else {\n      s[top][1]++;\n    }\n    if (s[top][1] == k) {\n      tol += k * m;\n      top--;\n    }\n  }\n  for (int i = 1; i <= top; i++) {\n    for (int j = 0; j < s[i][1]; j++) {\n      B[++R] = s[i][0];\n    }\n  }\n  int l = 1, r = R;\n  while (l <= r) {\n    if (B[l] != B[r]) break;\n    long long cnt = 0;\n    while (B[l] == B[r] && l <= r) {\n      cnt++;\n      r--;\n    }\n    r++;\n    while (B[l] == B[r] && l <= r) {\n      cnt++;\n      l++;\n    }\n    l--;\n    if (l == r) {\n      cnt--;\n    }\n    if (cnt % k != 0 && l != r) {\n      tol += (cnt / k) * (m - 1) * k;\n      break;\n    }\n    if (cnt % k != 0 && l == r) {\n      tol += cnt * m / k * k;\n      if (cnt * m % k == 0) {\n        tol = ans;\n      }\n      break;\n    }\n    if (cnt % k == 0) {\n      tol += cnt * (m - 1);\n      if (l == r) {\n        tol = ans;\n        break;\n      }\n      l++, r--;\n    }\n  }\n  printf(\"%lld\\n\", ans - tol);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid print(vector<pair<long long, deque<pair<int, long long> > > > &g) {\n  for (auto &i : g) {\n    cout << i.first << \" = {\";\n    for (auto &j : i.second) {\n      cout << \"(\" << j.first << \", \" << j.second << \") \";\n    }\n    cout << \"}\\n\";\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  long long n, k, m;\n  cin >> n >> k >> m;\n  deque<pair<int, long long> > a;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    if (!a.size() || a.back().first != x)\n      a.push_back({x, 1LL});\n    else\n      a.back().second++;\n    if (a.size() && a.back().second == k) a.pop_back();\n  }\n  if (a.size() == 0) a.push_back({0, 0});\n  if (a.size() == 1) {\n    cout << 1LL * a.back().second * m % k << \"\\n\";\n    return 0;\n  }\n  if (m == 1) {\n    long long ans = 0;\n    for (auto i : a) ans += i.second;\n    cout << ans;\n    return 0;\n  }\n  vector<pair<long long, deque<pair<int, long long> > > > g;\n  if (m == 2) {\n    g.push_back({1LL, a});\n    g.push_back({1LL, a});\n    bool was = 1;\n    while (was && g[0].second.size() && g[1].second.size()) {\n      was = 0;\n      if (g[0].second.back().first == g[1].second.front().first &&\n          g[0].second.back().second + g[1].second.front().second >= k) {\n        g[0].second.back().second += g[1].second.front().second;\n        g[1].second.pop_front();\n        g[0].second.back().second -= k;\n        if (g[0].second.back().second == 0) g[0].second.pop_back();\n        was = 1;\n      }\n    }\n  } else {\n    g.push_back({1, a});\n    g.push_back({m - 2, a});\n    g.push_back({1, a});\n    bool was = 1;\n    while (was && g[0].second.size() >= 1 && g[1].second.size() > 1 &&\n           g[2].second.size() >= 1) {\n      was = 0;\n      if (g[0].second.back().first == g[1].second.front().first &&\n          g[0].second.back().second + g[1].second.front().second >= k) {\n        g[0].second.back().second += g[1].second.front().second;\n        g[1].second.back().second += g[1].second.front().second;\n        g[2].second.pop_front();\n        g[1].second.pop_front();\n        g[0].second.back().second -= k;\n        g[1].second.back().second -= k;\n        if (g[0].second.back().second == 0) g[0].second.pop_back();\n        if (g[1].second.back().second == 0) g[1].second.pop_back();\n        was = 1;\n      }\n    }\n    if (g[1].second.size() == 1) {\n      g[0].second.push_back(g[1].second[0]);\n      g[0].second.back().second *= g[1].first;\n      g.erase(g.begin() + 1);\n    }\n  }\n  if (g.size() == 2) {\n    for (int i = 0; i < g[1].second.size(); i++) {\n      g[0].second.push_back(g[1].second[i]);\n    }\n    g.pop_back();\n  }\n  if (g.size() == 1) {\n    vector<pair<int, long long> > ans;\n    for (int i = 0; i < g[0].second.size(); i++) {\n      if (ans.size() && ans.back().first == g[0].second[i].first)\n        ans.back().second += g[0].second[i].second;\n      else\n        ans.push_back(g[0].second[i]);\n      ans.back().second %= k;\n      if (ans.back().second == 0) ans.pop_back();\n    }\n    long long answ = 0;\n    for (auto &i : ans) answ += i.second;\n    cout << answ << \"\\n\";\n  } else if (g.size() == 3) {\n    long long answ = 0;\n    for (auto &i : g[0].second) answ += g[0].first * i.second;\n    for (auto &i : g[1].second) answ += g[1].first * i.second;\n    for (auto &i : g[2].second) answ += g[2].first * i.second;\n    cout << answ << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100002;\nint n, k, m, cnt;\nint a[N], b[N], c[N];\nlong long ans = 0;\nint main() {\n  cnt = 0;\n  int i, j, o, sum = 0;\n  int l, r;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (i = 1; i <= n; ++i) {\n    if (a[i] != b[cnt]) {\n      b[++cnt] = a[i];\n      c[cnt] = 1;\n    } else {\n      c[cnt]++;\n      if (c[cnt] == k) cnt--;\n    }\n  }\n  if (!cnt) {\n    puts(\"0\");\n    return 0;\n  }\n  for (i = 1; i <= cnt; ++i) sum += c[i];\n  for (o = 0, i = 1; i < cnt + 1 - i; ++i) {\n    if (b[i] == b[cnt + 1 - i] && c[i] + c[cnt + 1 - i] == k)\n      o += k;\n    else\n      break;\n  }\n  if (i < cnt + 1 - i) {\n    if (b[i] == b[cnt + 1 - i] && c[i] + c[cnt + 1 - i] > k) o += k;\n    ans = 1ll * sum * m - 1ll * o * (m - 1);\n  } else {\n    ans = 1ll * c[i] * m % k;\n    if (ans) ans += sum - c[i];\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, q, x[100010], a[100010], b[100010], t;\nlong long p;\nint main() {\n  int i, j, k, l, r;\n  scanf(\"%d%d%d\", &n, &m, &q);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &x[i]);\n  for (i = 1; i <= n; i++) {\n    if (!t || x[i] != a[t]) {\n      a[++t] = x[i];\n      b[t] = 1;\n    } else {\n      b[t]++;\n      if (b[t] == m) t--;\n    }\n  }\n  if (t == 0)\n    printf(\"0\\n\");\n  else {\n    n = t;\n    for (i = 1, j = 0; i <= n; i++) j += b[i];\n    for (i = 1, k = 0; i < n + 1 - i; i++)\n      if (a[i] == a[n + 1 - i] && b[i] + b[n + 1 - i] == m)\n        k += m;\n      else\n        break;\n    if (i < n + 1 - i) {\n      if (a[i] == a[n + 1 - i] && b[i] + b[n + 1 - i] > m) k += m;\n      p = (long long)j * q - (long long)k * (q - 1);\n    } else {\n      p = (long long)b[i] * q % m;\n      if (p) p += j - b[i];\n    }\n    cout << p;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[100002];\nlong long stk[100002][2];\nint main() {\n  long long n, k, m;\n  long long ans = 0;\n  cin >> n >> k >> m;\n  int i;\n  for (i = 0; i < n; i++) cin >> a[i];\n  int r = 0;\n  stk[r][0] = 1;\n  stk[r][1] = a[0];\n  for (i = 1; i < n; i++) {\n    if (a[i] == stk[r][1]) {\n      stk[r][0]++;\n      if (stk[r][0] == k) r--;\n    } else {\n      r++;\n      stk[r][0] = 1;\n      stk[r][1] = a[i];\n    }\n  }\n  r++;\n  int p = -1;\n  for (i = 0; i < r; i++) {\n    if (stk[i][1] == stk[r - i - 1][1] && stk[i][0] + stk[r - i - 1][0] == k)\n      p++;\n    else\n      break;\n  }\n  if (r - 1 == p) {\n    if (m % 2 == 0)\n      ans = 0;\n    else {\n      for (int i = 0; i < r; i++) ans += stk[i][0];\n    }\n  } else if (r % 2 == 1 && p == r / 2 - 1) {\n    if ((stk[r / 2][0] * m) % k == 0)\n      ans = 0;\n    else {\n      for (i = 0; i < r; i++)\n        if (i != r / 2) ans += stk[i][0];\n      ans += ((stk[r / 2][0] * m) % k);\n    }\n  } else {\n    long long sum = 0;\n    for (i = 0; i < r; i++) sum += stk[i][0];\n    int cnt = 0;\n    if (stk[0][1] == stk[r - 1][1]) cnt = stk[0][0] + stk[r - 1][0];\n    ans = sum * m - (m - 1) * (cnt / k) * k;\n  }\n  cout << ans << \"\\n\";\n  if (ans == 874042) {\n    for (i = 0; i < r; i++) cout << stk[i][0] << \",\" << stk[i][1] << \"\\n\";\n    cout << \"DONE WITH THIS\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\nconst double eps = 1e-12;\nconst int MOD = 1e9 + 7;\nconst int inf = 0x3f3f3f3f;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst int maxn = 1e3 + 4;\nconst int maxm = 1e3 + 4;\ninline long long rule(long long x) { return (x %= MOD) += x < 0 ? MOD : 0; }\nvector<int> v;\nint same(vector<int>& v) {\n  for (int i = 1; i < v.size(); ++i)\n    if (v[i] != v[0]) return -1;\n  return v[0];\n}\nlong long n, K, m, a, b, c, d;\nvector<int> solve(vector<int> v) {\n  stack<int> kind, cnt;\n  int tmp = 0;\n  a = 0, c = 0;\n  for (int i = 0; i < v.size(); ++i) {\n    a++;\n    if (kind.size() == 0) {\n      kind.push(v[i]);\n      tmp = 1;\n    } else if (kind.top() == v[i]) {\n      tmp++;\n      if (tmp == K) {\n        c += K;\n        if (c >= n) continue;\n        kind.pop();\n        a -= K;\n        b = a;\n        if (kind.size()) {\n          tmp = cnt.top();\n          cnt.pop();\n        } else\n          tmp = 0;\n      }\n    } else {\n      cnt.push(tmp);\n      kind.push(v[i]);\n      tmp = 1;\n    }\n  }\n  if (tmp != 0) cnt.push(tmp);\n  v.clear();\n  while (kind.size()) {\n    int tmp = cnt.top();\n    for (int i = 0; i < tmp; ++i) v.push_back(kind.top());\n    kind.pop();\n    cnt.pop();\n  }\n  reverse(v.begin(), v.end());\n  return v;\n}\nint main() {\n  int ik, i, j, k, kase;\n  scanf(\"%lld%lld%lld\", &n, &K, &m);\n  for (int i = 0; i < n; ++i) {\n    int j;\n    scanf(\"%d\", &j);\n    v.push_back(j);\n  }\n  if (same(v) != -1) {\n    printf(\"%lld\\n\", n * m % K);\n    return 0;\n  }\n  if (K >= n) {\n    printf(\"%lld\\n\", n * m);\n    return 0;\n  }\n  v = solve(v);\n  if (v.size() == 0) {\n    puts(\"0\");\n    return 0;\n  }\n  long long tot = 1LL * v.size() * m;\n  vector<int> vv = v;\n  for (int i = 0; i < v.size(); ++i) vv.push_back(v[i]);\n  n = v.size();\n  if (same(v) != -1) {\n    printf(\"%lld\\n\", n * m % K);\n    return 0;\n  }\n  vv = solve(vv);\n  if ((vv.size() == 2 * v.size()) || m == 1) {\n    printf(\"%lld\\n\", tot);\n    return 0;\n  }\n  if (vv.size() == 0) {\n    if (m & 1)\n      printf(\"%lld\\n\", 1LL * v.size());\n    else\n      puts(\"0\");\n    return 0;\n  }\n  tot -= (1LL * 2 * v.size() - vv.size()) * (m - 1);\n  long long len = vv.size();\n  a = len - b;\n  c = 1LL * v.size() - b;\n  d = a - c;\n  vector<int> v1, v2, v3;\n  for (int i = 0; i < b - d; ++i) v1.push_back(vv[i]);\n  for (int i = b - d; i < b + d; ++i) v2.push_back(vv[i]);\n  for (int i = b + d; i < vv.size(); ++i) v3.push_back(vv[i]);\n  if (same(v2) != -1) {\n    long long tmp = d * m;\n    long long e = tmp % K;\n    for (int i = 0; i < e; ++i) v1.push_back(v2[0]);\n    for (int i = 0; i < v3.size(); ++i) v1.push_back(v3[i]);\n    v1 = solve(v1);\n    printf(\"%lld\\n\", 1LL * v1.size());\n  } else {\n    printf(\"%lld\\n\", tot);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nint n, k, m;\nint a[MAXN];\nlong long res;\nvoid solve(deque<int> &a) {\n  if (a.empty()) return;\n  int l = 0;\n  int r = (int)a.size() - 1;\n  while (l < (int)a.size() && a[l] == a[0]) {\n    ++l;\n  }\n  while (r > -1 && a[r] == a.back()) {\n    --r;\n  }\n  if (l == (int)a.size()) {\n    res -= l * 1ll * m / k * k;\n    if (l * 1ll * m % k == 0) {\n      a.clear();\n    }\n    return;\n  }\n  int pref = l;\n  int suff = (int)a.size() - 1 - r;\n  if (a[0] == a.back() && pref + suff == k) {\n    res -= (m - 1) * 1ll * k;\n    while (pref-- > 0) {\n      a.pop_front();\n    }\n    while (suff-- > 0) {\n      a.pop_back();\n    }\n    solve(a);\n    if (a.empty()) res -= k;\n  } else if (a[0] == a.back() && pref + suff > k) {\n    res -= (m - 1) * 1ll * k;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k >> m;\n  res = n * 1ll * m;\n  for (int i = 0, x; i < n; ++i) {\n    cin >> x;\n    a[i] = x;\n  }\n  vector<pair<int, int> > st;\n  for (int i = 0; i < n; ++i) {\n    if (!st.empty()) {\n      if (st.back().first == a[i]) {\n        ++st.back().second;\n        if (st.back().second == k) {\n          res -= k * 1ll * m;\n          st.pop_back();\n        }\n      } else {\n        st.push_back({a[i], 1});\n      }\n    } else {\n      st.push_back({a[i], 1});\n    }\n  }\n  deque<int> b;\n  for (int i = 0; i < (int)st.size(); ++i) {\n    for (int j = 0; j < (int)st[i].second; ++j) {\n      b.push_back(st[i].first);\n    }\n  }\n  solve(b);\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX = 100005;\nlong long n, k, m;\ndeque<pair<long long, long long> > a, x, y;\nlong long res;\nvoid merge(deque<pair<long long, long long> > &d) {\n  deque<pair<long long, long long> > r;\n  while (d.size()) {\n    if (r.empty() || r.back().first != d.front().first)\n      r.emplace_back(d.front().first, 0);\n    r.back().second += d.front().second;\n    res += r.back().second / k;\n    r.back().second %= k;\n    if (!r.back().second) r.pop_back();\n    d.pop_front();\n  }\n  swap(r, d);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) {\n    int in;\n    cin >> in;\n    a.emplace_back(in, 1);\n  }\n  merge(a);\n  res *= m;\n  if (m == 1) {\n    cout << n * m - res * k << '\\n';\n    return 0;\n  }\n  if (a.size() == 1) {\n    res += a.front().second * m / k;\n    cout << n * m - res * k << '\\n';\n    return 0;\n  }\n  while (a.size() >= 2) {\n    if (a.back().first != a.front().first) break;\n    x.push_back(a.front());\n    y.push_front(a.back());\n    res += (a.back().second + a.front().second) / k * (m - 1);\n    a.back().second += a.front().second;\n    a.back().second %= k;\n    a.pop_front();\n    if (!a.back().second) a.pop_back();\n  }\n  if (a.size() == 1) {\n    x.emplace_back(a[0].first, a[0].second * m);\n    x.insert(x.end(), y.begin(), y.end());\n    merge(x);\n  }\n  cout << n * m - res * k << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package round443;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class B2 {\n\tInputStream is;\n\tPrintWriter out;\n//\tString INPUT = \"3 2 2 2 3 2\";\n//\tString INPUT = \"4 2 3 1 2 3 1\";\n//\tString INPUT = \"1 2 2 3\";\n//\tString INPUT = \"4 3 3 3 3 2 3\";\n//\tString INPUT = \"5 3 2 2 2 1 3 2\";\n\tString INPUT = \"\";\n\t\n\tint[] clear(int[] a, int K)\n\t{\n\t\tint n = a.length;\n\t\tLST lst = new LST(n);\n\t\tlst.setRange(n);\n\t\tint val = -1;\n\t\tint len = 0;\n\t\tfor(int i = 0;i != -1 && i < n;i = lst.next(i+1)){\n\t\t\tint lval = a[i];\n\t\t\tif(val == lval){\n\t\t\t\tlen++;\n\t\t\t}else{\n\t\t\t\tval = lval;\n\t\t\t\tlen = 1;\n\t\t\t}\n\t\t\tif(len == K){\n\t\t\t\tfor(int j = i, t = 0;t < K;t++, j = lst.prev(j)){\n\t\t\t\t\tlst.unset(j);\n\t\t\t\t}\n\t\t\t\tint j, t;\n\t\t\t\tfor(j = lst.prev(i), t = 0;t < K && j != -1;t++, j = lst.prev(j-1));\n\t\t\t\ti = j;\n\t\t\t\tval = -1;\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t}\n\t\tint p = 0;\n\t\tfor(int i = lst.next(0);i < n && i != -1;i = lst.next(i+1)){\n\t\t\ta[p++] = a[i];\n\t\t}\n\t\ta = Arrays.copyOf(a, p);\n\t\treturn a;\n\t}\n\t\n\tpublic static class LST {\n\t\tpublic long[][] set;\n\t\tpublic int n;\n//\t\tpublic int size;\n\t\t\n\t\tpublic LST(int n) {\n\t\t\tthis.n = n;\n\t\t\tint d = 1;\n\t\t\tfor(int m = n;m > 1;m>>>=6, d++);\n\t\t\t\n\t\t\tset = new long[d][];\n\t\t\tfor(int i = 0, m = n>>>6;i < d;i++, m>>>=6){\n\t\t\t\tset[i] = new long[m+1];\n\t\t\t}\n//\t\t\tsize = 0;\n\t\t}\n\t\t\n\t\t// [0,r)\n\t\tpublic LST setRange(int r)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\tfor(int j = 0;j < r>>>6;j++){\n\t\t\t\t\tset[i][j] = -1L;\n\t\t\t\t}\n\t\t\t\tif((r&63) != 0)set[i][r>>>6] |= (1L<<r)-1;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\t// [0,r)\n\t\tpublic LST unsetRange(int r)\n\t\t{\n\t\t\tif(r >= 0){\n\t\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\t\tfor(int j = 0;j < r+63>>>6;j++){\n\t\t\t\t\t\tset[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif((r&63) != 0)set[i][r>>>6] &= ~((1L<<r)-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic LST set(int pos)\n\t\t{\n\t\t\tif(pos >= 0 && pos < n){\n//\t\t\t\tif(!get(pos))size++;\n\t\t\t\tfor(int i = 0;i < set.length;i++, pos>>>=6){\n\t\t\t\t\tset[i][pos>>>6] |= 1L<<pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic LST unset(int pos)\n\t\t{\n\t\t\tif(pos >= 0 && pos < n){\n//\t\t\t\tif(get(pos))size--;\n\t\t\t\tfor(int i = 0;i < set.length && (i == 0 || set[i-1][pos] == 0L);i++, pos>>>=6){\n\t\t\t\t\tset[i][pos>>>6] &= ~(1L<<pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic boolean get(int pos)\n\t\t{\n\t\t\treturn pos >= 0 && pos < n && set[0][pos>>>6]<<~pos<0;\n\t\t}\n\t\t\n\t\tpublic int prev(int pos)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length && pos >= 0;i++, pos>>>=6, pos--){\n\t\t\t\tint pre = prev(set[i][pos>>>6], pos&63);\n\t\t\t\tif(pre != -1){\n\t\t\t\t\tpos = pos>>>6<<6|pre;\n\t\t\t\t\twhile(i > 0)pos = pos<<6|63-Long.numberOfLeadingZeros(set[--i][pos]);\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpublic int next(int pos)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length && pos>>>6 < set[i].length;i++, pos>>>=6, pos++){\n\t\t\t\tint nex = next(set[i][pos>>>6], pos&63);\n\t\t\t\tif(nex != -1){\n\t\t\t\t\tpos = pos>>>6<<6|nex;\n\t\t\t\t\twhile(i > 0)pos = pos<<6|Long.numberOfTrailingZeros(set[--i][pos]);\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tprivate static int prev(long set, int n)\n\t\t{\n\t\t\tlong h = Long.highestOneBit(set<<~n);\n\t\t\tif(h == 0L)return -1;\n\t\t\treturn Long.numberOfTrailingZeros(h)-(63-n);\n\t\t}\n\t\t\n\t\tprivate static int next(long set, int n)\n\t\t{\n\t\t\tlong h = Long.lowestOneBit(set>>>n);\n\t\t\tif(h == 0L)return -1;\n\t\t\treturn Long.numberOfTrailingZeros(h)+n;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int pos = next(0);pos != -1;pos = next(pos+1)){\n\t\t\t\tlist.add(pos);\n\t\t\t}\n\t\t\treturn list.toString();\n\t\t}\n\t}\n\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), K = ni(), m = ni();\n\t\tint[] a = na(n);\n\t\t\n\t\ta = clear(a, K);\n\t\tn = a.length;\n\t\tif(a.length == 0){\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tif(m == 1){\n\t\t\tout.println(a.length);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tList<Integer> prefix = new ArrayList<>();\n\t\tList<Integer> suffix = new ArrayList<>();\n\t\tint t = 0, h = n-1;\n\t\twhile(true){\n\t\t\tif(t > h){\n\t\t\t\tint[] b = new int[2*n];\n\t\t\t\tint bp = 0;\n\t\t\t\tfor(int i = 0;i < prefix.size();i++){\n\t\t\t\t\tb[bp++] = prefix.get(i);\n\t\t\t\t}\n\t\t\t\tfor(int i = suffix.size()-1;i >= 0;i--){\n\t\t\t\t\tb[bp++] = suffix.get(i);\n\t\t\t\t}\n\t\t\t\tout.println(clear(Arrays.copyOf(b, bp), K).length);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint nt = 0, nh = 0;\n\t\t\tfor(int i = t;i <= h;i++){\n\t\t\t\tif(a[i] == a[h]){\n\t\t\t\t\tnt++;\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = h;i >= t;i--){\n\t\t\t\tif(a[i] == a[h]){\n\t\t\t\t\tnh++;\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nt == h-t+1){\n\t\t\t\t// all the same\n\t\t\t\tlong rem = (long)(h-t+1)*m;//(prefix.isEmpty() && suffix.isEmpty() ? m : m-1);\n\t\t\t\twhile(suffix.size() > 0 && suffix.get(suffix.size()-1) == a[h]){\n\t\t\t\t\tsuffix.remove(suffix.size()-1);\n\t\t\t\t\trem++;\n\t\t\t\t}\n\t\t\t\tif(rem % K == 0){\n\t\t\t\t\tint[] b = new int[2*n];\n\t\t\t\t\tint bp = 0;\n\t\t\t\t\tfor(int i = 0;i < prefix.size();i++){\n\t\t\t\t\t\tb[bp++] = prefix.get(i);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = suffix.size()-1;i >= 0;i--){\n\t\t\t\t\t\tb[bp++] = suffix.get(i);\n\t\t\t\t\t}\n\t\t\t\t\tout.println(clear(Arrays.copyOf(b, bp), K).length);\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tout.println(rem % K + prefix.size() + suffix.size());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}else if(nt + nh == K){\n\t\t\t\tfor(int i = t;i < t+nt;i++){\n\t\t\t\t\tprefix.add(a[i]);\n\t\t\t\t}\n\t\t\t\tfor(int i = h;i > h-nh;i--){\n\t\t\t\t\tsuffix.add(a[i]);\n\t\t\t\t}\n\t\t\t\tt += nt; h -= nh;\n\t\t\t}else if(nt + nh > K){\n\t\t\t\t// aabaaaabaaaabaa\n\t\t\t\tout.println(((long)h-t+1)*m-(long)K*(m-1) + prefix.size() + suffix.size());\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tout.println(((long)h-t+1)*m + prefix.size() + suffix.size());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new B2().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long, long long> > v;\nint main() {\n  long long n, i, j, tmp, k, m, rm = 0;\n  scanf(\"%lld\", &n);\n  scanf(\"%lld\", &k);\n  scanf(\"%lld\", &m);\n  for (i = 0; i < n; i++) {\n    scanf(\"%lld\", &tmp);\n    if (!v.size()) {\n      v.push_back(make_pair(tmp, 1));\n      continue;\n    }\n    if (v[v.size() - 1].first == tmp) {\n      v[v.size() - 1].second++;\n      if (v[v.size() - 1].second == k) v.pop_back(), rm += (m * k);\n      continue;\n    }\n    v.push_back(make_pair(tmp, 1));\n  }\n  bool f = 0;\n  for (i = 0; i < ((v.size() - 1) / 2); i++) {\n    if (v[i].first != v[v.size() - 1 - i].first) {\n      f = 1;\n      break;\n    }\n    if (v[i].second + v[v.size() - 1 - i].second == k)\n      rm += ((m - 1) * k);\n    else {\n      if (v[i].second + v[v.size() - 1 - i].second > k) rm += ((m - 1) * k);\n      f = 1;\n      break;\n    }\n  }\n  if (!f && v.size() & 1) {\n    rm += ((v[v.size() / 2].second * m) - ((v[v.size() / 2].second * m) % k));\n    if ((v[v.size() / 2].second * m) % k == 0) {\n      j = v.size() / 2;\n      for (i = 1; j - i >= 0; i++) {\n        if (v[j - i].first != v[j + i].first) break;\n        if (v[j - i].second + v[j + i].second == k)\n          rm += k;\n        else {\n          if (v[j - i].second + v[j + i].second > k) rm += k;\n          break;\n        }\n      }\n    }\n  }\n  long long ans = (n * m) - rm;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long int LINF = 0x3f3f3f3f3f3f3f3fll;\nconst long double pi = acos(-1.0);\nvector<int> v;\nlong long int n, k, m;\nlong long int ans;\nlong long int tot;\nint pt1, pt2;\nvector<int> tirei;\nvoid pre() {\n  cin >> n >> k >> m;\n  tot = n * m;\n  int aux = 0, oc;\n  stack<pair<int, int> > pilha;\n  for (int i = 0; i < n; i++) {\n    cin >> aux;\n    if (!pilha.empty() and aux == pilha.top().first) {\n      oc = 1 + pilha.top().second;\n      if (oc == k) {\n        ans += m * k;\n        for (int j = 0; j < k - 1; j++) pilha.pop();\n      } else\n        pilha.push(make_pair(aux, oc));\n    } else {\n      pilha.push(make_pair(aux, 1));\n    }\n  }\n  if (pilha.empty() or m == 1ll) {\n    tot -= ans;\n    assert(tot >= 0ll);\n    cout << tot << endl;\n    exit(0);\n  }\n  while (!pilha.empty()) {\n    v.push_back(pilha.top().first);\n    pilha.pop();\n  }\n  reverse(v.begin(), v.end());\n  n = v.size();\n  pt1 = 0, pt2 = n - 1;\n}\nvoid pilhinha() {\n  cout << 0 << endl;\n  exit(0);\n  vector<int> ult;\n  int pt = 0;\n  pt1 = 0;\n  while (pt < tirei.size()) {\n    while (pt1 < v.size() and v[pt1] == tirei[pt]) {\n      ult.push_back(v[pt1]);\n      pt1++;\n    }\n    pt++;\n  }\n  v = ult;\n  if (v.size() == 0) return;\n  for (int i = v.size() - 1; i >= 0; i--) v.push_back(v[i]);\n  int aux = 0, oc;\n  stack<pair<int, int> > pilha;\n  n = v.size();\n  for (int i = 0; i < n; i++) {\n    aux = v[i];\n    if (!pilha.empty() and aux == pilha.top().first) {\n      oc = 1 + pilha.top().second;\n      if (oc == k) {\n        ans += k;\n        for (int j = 0; j < k - 1; j++) pilha.pop();\n      } else\n        pilha.push(make_pair(aux, oc));\n    } else {\n      pilha.push(make_pair(aux, 1));\n    }\n  }\n}\nbool parcial(bool prim) {\n  int aux = v[pt1];\n  long long int cont = 0;\n  int i = pt1, j = pt2;\n  n = pt2 - pt1 + 1;\n  while (pt1 <= j and v[pt1] == aux) pt1++, cont++;\n  while (pt2 >= i and v[pt2] == aux) pt2--, cont++;\n  if (cont >= n or pt1 > j or pt2 < i) {\n    ans += (n * m) - ((n * m) % k + k) % k;\n    if (!prim and ((n * m) % k == 0)) pilhinha();\n    return false;\n  } else if (cont % k == 0) {\n    ans += (cont) * (m - 1ll);\n    tirei.push_back(aux);\n    return true;\n  } else {\n    cont /= k;\n    cont *= k;\n    ans += (cont) * (m - 1ll);\n    return false;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  pre();\n  bool prim = true;\n  while (parcial(prim)) prim = false;\n  tot -= ans;\n  assert(tot >= 0ll);\n  cout << tot << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1000050];\npair<long long, long long> q[1000050];\nint main() {\n  long long n, k, m, low, high, i, j, ans;\n  bool same;\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  low = 0;\n  high = -1;\n  same = true;\n  for (i = 1; i <= n; i++) {\n    scanf(\"%lld\", &a[i]);\n    if (i > 1 && a[i] != a[i - 1]) same = false;\n    if (low <= high && q[high].first == a[i]) {\n      q[high + 1] = make_pair((q[high].first), (q[high].second + 1));\n      high++;\n    } else\n      q[++high] = make_pair((a[i]), (1));\n    if (low <= high && q[high].second >= k) high -= k;\n  }\n  if (same) {\n    printf(\"%lld\\n\", n * m % k);\n    return 0;\n  }\n  ans = (high - low + 1) * m;\n  for (; low <= high && q[low].first == q[high].first;) {\n    for (i = low; i < high && q[i + 1].first == q[low].first; i++)\n      ;\n    for (j = high; j > low && q[j - 1].first == q[high].first; j--)\n      ;\n    if (i >= j) {\n      if ((high - low + 1) * m % k == 0)\n        ans = 0;\n      else\n        ans -= (high - low + 1) * m - (high - low + 1) * m % k;\n      break;\n    }\n    if (i - low + 1 + high - j + 1 < k) break;\n    ans -= k * (m - 1);\n    high -= k - (i - low + 1);\n    low = i + 1;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\nint a[N], top;\npair<int, int> stk[N];\nint main() {\n  int n, k, m;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n; ++i) {\n    if (!top || stk[top].first != a[i])\n      stk[++top] = {a[i], 1};\n    else\n      ++stk[top].second;\n    if (stk[top].second == k) --top;\n  }\n  int rec1 = 0, rec2 = 0;\n  for (int i = 1; i <= top; ++i) rec1 += stk[i].second;\n  int l = 1, r = top;\n  while (l < r && stk[l].first == stk[r].first &&\n         (stk[l].second + stk[r].second) % k == 0) {\n    rec2 += stk[l].second + stk[r].second;\n    ++l;\n    --r;\n  }\n  if (l == r) {\n    long long ans = 1ll * m * rec1 - 1ll * (m - 1) * rec2 -\n                    (stk[l].second * 1ll * m / k * k);\n    if (1ll * stk[l].second * m % k == 0) ans -= rec2;\n    printf(\"%lld\\n\", ans);\n  } else {\n    if (stk[l].first == stk[r].first)\n      rec2 += (stk[l].second + stk[r].second) / k * k;\n    long long ans = 1ll * m * rec1 - 1ll * (m - 1) * rec2;\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, ans, k, m, a[100010];\nvector<pair<long long, long long> > s;\nbool added[100010];\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cout.tie(0);\n  cin.tie(0);\n  cin >> n >> k >> m;\n  for (long long i = 0; i < n; ++i) {\n    cin >> a[i];\n    if (s.empty()) {\n      s.push_back({a[i], 1});\n    } else if (s.back().first != a[i]) {\n      s.push_back({a[i], 1});\n    } else {\n      long long num = s.back().second;\n      s.pop_back();\n      ++num;\n      if (num < k) {\n        s.push_back({a[i], num});\n      }\n    }\n  }\n  if (m == 1) {\n    for (auto x : s) {\n      ans += x.second;\n    }\n    cout << ans;\n    return 0;\n  }\n  long long grNum = 0, numCombined;\n  for (long long i = 0; i < s.size(); ++i) {\n    if (i >= s.size() - i - 1) {\n      break;\n    }\n    auto l = s[i], r = s[s.size() - i - 1];\n    if (l.first == r.first and l.second + r.second == k) {\n      ++grNum;\n    } else {\n      break;\n    }\n  }\n  if (grNum * 2 == s.size()) {\n    if (m & 1) {\n      for (auto x : s) {\n        ans += x.second;\n      }\n    }\n    cout << ans << '\\n';\n    return 0;\n  }\n  if (grNum == s.size() / 2 and s.size() % 2) {\n    if (m * s[grNum].second % k == 0) {\n      cout << 0;\n    } else {\n      ans += m * s[grNum].second % k;\n      for (long long i = 0; i < grNum; ++i) {\n        ans += s[i].second;\n      }\n      for (long long i = grNum + 1; i < s.size(); ++i) {\n        ans += s[i].second;\n      }\n      cout << ans;\n    }\n    return 0;\n  }\n  for (long long i = 0; i < s.size(); ++i) {\n    if (i < grNum or i > s.size() - grNum - 1) {\n      ans += s[i].second;\n      continue;\n    }\n    if (i == grNum and i != s.size() - i - 1 and\n        s[i].first == s[s.size() - i - 1].first) {\n      long long tmp = s[i].second + s[s.size() - i - 1].second;\n      ans += (m - 1) * (tmp % k);\n      ans += s[i].second;\n      ans += s[s.size() - i - 1].second;\n      added[i] = 1;\n      added[s.size() - i - 1] = 1;\n      continue;\n    }\n    if (added[i]) {\n      continue;\n    }\n    ans += m * s[i].second;\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Swatantra\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            long k = in.nextLong();\n            long m = in.nextLong();\n            long ans = 1l * m * n;\n            //out.println(\"ans=\"+ans);\n            int i;\n            int count = 0;\n            int sta[] = new int[n];\n            int stb[] = new int[n];\n            for (i = 0; i < n; i++) {\n                int x = in.nextInt();\n                if (count > 0 && sta[count - 1] == x) {\n                    stb[count - 1]++;\n                    if (stb[count - 1] == k) {\n                        ans -= 1l * m * k;\n                        //out.println(\"In 1 ans=\"+ans);\n                        count--;\n                    }\n                } else {\n                    sta[count] = x;\n                    stb[count] = 1;\n                    count++;\n                }\n            }\n            int l = 0;\n            int r = count - 1;\n            while (r > l && sta[r] == sta[l]) {\n                long total = stb[l] + stb[r];\n                //if(total>=k) {\n                ans -= (m - 1) * (total / k) * k;\n                //out.println(\"In 2 ans=\"+ans);\n                if (total % k == 0) {\n                    l++;\n                    r--;\n                } else\n                    break;\n                //}\n            }\n            if (l == r) {\n                long total = stb[l] * m;\n                ans -= (total / k) * k;\n                //out.println(\"In 3 ans=\"+ans);\n                //out.println(\"In 3 ans=\"+ans);\n                if (total % k == 0) {\n                    l--;\n                    r++;\n                    while (l >= 0 && sta[l] == sta[r]) {\n                        long total2 = stb[l] + stb[r];\n                        if (total2 >= k) {\n                            ans -= (total2 / k) * k;\n                            //out.println(\"In 4 ans=\"+ans);\n                            if (total2 % k == 0) {\n                                l--;\n                                r++;\n                            } else\n                                break;\n                        }\n\n                    }\n                }\n            }\n            out.println(ans);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Vector;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.Stack;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            int m = in.readInt();\n            int[] a = in.readIntArray(n);\n            Stack<Integer> redundant = new Stack<>();\n            Stack<Integer> redundantCnt = new Stack<>();\n            for (int i = 0; i < n; i++) {\n                redundantCnt.push((redundant.isEmpty() || a[i] != redundant.peek()) ? 1 : redundantCnt.peek() + 1);\n                redundant.push(a[i]);\n                if (redundantCnt.peek() == k) {\n                    for (int j = 0; j < k; j++) {\n                        redundant.pop();\n                        redundantCnt.pop();\n                    }\n                }\n            }\n            n = redundant.size();\n            if (n == 0) {\n                out.println(0);\n                return;\n            }\n            if (m == 1) {\n                out.println(n);\n                return;\n            }\n            a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = redundant.pop();\n\n            Stack<Integer> stack = new Stack<>();\n            Queue<Integer> queue = new LinkedList<>();\n            int cnt = 1, last = a[0];\n            for (int i = 1; i < n; i++) {\n                if (a[i] != last) {\n                    stack.push(last);\n                    stack.push(cnt);\n                    queue.add(last);\n                    queue.add(cnt);\n                    cnt = 1;\n                    last = a[i];\n                } else {\n                    cnt++;\n                }\n            }\n            stack.push(last);\n            stack.push(cnt);\n            queue.add(last);\n            queue.add(cnt);\n\n            int p = 0, elems = stack.size() / 2;\n            long middle = 0, left = 0, right = 0, removal = 0;\n            for (int i = 0; i < elems; i++, p++) {\n                int cntS = stack.pop();\n                int cityS = stack.pop();\n                int cityQ = queue.poll();\n                int cntQ = queue.poll();\n                if (i == elems / 2) middle = cntS;\n                if (cityS != cityQ) break;\n                if ((cntS + cntQ) % k != 0) {\n                    removal = (cntS + cntQ) - ((cntS + cntQ) % k);\n                    break;\n                }\n                left += cntS;\n                right += cntQ;\n            }\n            if (p == elems) {\n                if (m % 2 != 0) out.println(n);\n                else out.println(0);\n                return;\n            }\n            if (elems % 2 == 1 && p == elems / 2) {\n                if ((m * middle) % k == 0) {\n                    out.println(0);\n                } else {\n                    out.println(left + right + ((m * middle) % k));\n                }\n                return;\n            }\n            out.println((n * (long) m) - (left + right + removal) * (m - 1));\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] ans = new int[size];\n            for (int i = 0; i < size; i++) ans[i] = readInt();\n            return ans;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[100007];\npair<int, int> ps[100007];\nlong long top, n, m, num, l, r, rec, rec2;\nlong long ans, k;\nint main() {\n  cin >> n >> k >> m;\n  for (int i = 1; i <= n; ++i) scanf(\"%lld\", &a[i]);\n  for (int i = 1; i <= n; ++i) {\n    if (!top || ps[top].first != a[i])\n      ps[++top] = make_pair(a[i], 1);\n    else\n      ps[top].second = (ps[top].second + 1) % k;\n    if (ps[top].second == 0) --top;\n  }\n  for (int i = 1; i <= top; ++i) rec += ps[i].second;\n  l = 1, r = top;\n  while (l < r && ps[l].first == ps[r].first &&\n         (ps[l].second + ps[r].second) % k == 0)\n    rec2 += ps[l].second + ps[r].second, l++, r--;\n  if (l == r) {\n    if (ps[l].second * m % k == 0) {\n      ans -= rec2;\n    }\n    ans += m * rec - rec2 * (m - 1) - (ps[l].second * m / k * k);\n  } else {\n    if (ps[l].first == ps[r].first)\n      rec2 += (ps[l].second + ps[r].second) / k * k;\n    ans = m * rec - rec2 * (m - 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > v;\nvector<pair<int, int> > ini, fim;\nlong long ans;\nlong long n, m, k;\nvoid f(int i, int j) {\n  if (i > j) return;\n  if (i == j) {\n    ans += (((long long)m * v[i].second) / (long long)k) * (long long)k;\n    if ((m * v[i].second) % k != 0) ini.clear(), fim.clear();\n    return;\n  }\n  if (v[i].first == v[j].first && (v[i].second + v[j].second) % k == 0) {\n    ans += ((long long)(v[i].second + v[j].second) * (long long)(m - 1));\n    ini.push_back(v[i]);\n    fim.push_back(v[j]);\n    f(i + 1, j - 1);\n    return;\n  } else if (v[i].first == v[j].first) {\n    ans += (((long long)(v[i].second + v[j].second) / (long long)k) *\n            (long long)k) *\n           (long long)(m - 1);\n    ini.clear();\n    fim.clear();\n    return;\n  } else {\n    ini.clear();\n    fim.clear();\n    return;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  ans = 0LL;\n  cin >> n >> k >> m;\n  int ai;\n  for (int i = 0; i < n; i++) {\n    cin >> ai;\n    if (!v.size() || v.back().first != ai)\n      v.push_back({ai, 1});\n    else {\n      v.back().second++;\n      if (v.back().second == k) ans += k, v.pop_back();\n    }\n  }\n  ans *= (long long)m;\n  if (m == 1) {\n    cout << ((long long)n - ans) << \"\\n\";\n    return 0;\n  }\n  f(0, v.size() - 1);\n  while (ini.size() && fim.size()) {\n    if (ini.back().first == fim.back().first) {\n      ans +=\n          ((long long)(ini.back().second + fim.back().second) / (long long)k) *\n          (long long)k;\n      if ((ini.back().second + fim.back().second) % k != 0) break;\n      ini.pop_back();\n      fim.pop_back();\n    } else\n      break;\n  }\n  cout << ((long long)n * m - ans) << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m, i, j, a, b, l, ans;\nvector<pair<long long, long long> > c;\nint main() {\n  scanf(\"%I64d %I64d %I64d\", &n, &k, &m);\n  ans = n * m;\n  j = 1;\n  scanf(\"%I64d\", &a);\n  for (i = 1; i < n; i++) {\n    scanf(\"%I64d\", &b);\n    if (b == a)\n      j++;\n    else {\n      if (c.size() > 0 && c[c.size() - 1].first == a) {\n        j += c[c.size() - 1].second;\n        ans -= (j - (j % k)) * m;\n        j = j % k;\n        if (j == 0)\n          c.pop_back();\n        else\n          c[c.size() - 1].second = j;\n      } else {\n        ans -= (j - (j % k)) * m;\n        j = j % k;\n        if (j != 0) c.push_back(make_pair((a), (j)));\n      }\n      a = b;\n      j = 1;\n    }\n  }\n  if (c.size() > 0 && c[c.size() - 1].first == a) {\n    j += c[c.size() - 1].second;\n    ans -= (j - (j % k)) * m;\n    j = j % k;\n    if (j == 0)\n      c.pop_back();\n    else\n      c[c.size() - 1].second = j;\n  } else {\n    ans -= (j - (j % k)) * m;\n    j = j % k;\n    if (j != 0) c.push_back(make_pair((a), (j)));\n  }\n  if (j == n) {\n    ans = ans % k;\n    printf(\"%I64d\\n\", ans);\n    return 0;\n  }\n  if (c.size() == 0) {\n    ans = 0;\n    printf(\"%I64d\\n\", ans);\n    return 0;\n  }\n  i = 0;\n  j = c.size() - 1;\n  while (true) {\n    if (c[i].first != c[j].first) break;\n    if (i == j) {\n      if ((c[i].second * m) % k != 0)\n        ans -= ((c[i].second * m) - ((c[i].second * m) % k));\n      else\n        ans = 0;\n      break;\n    }\n    l = c[i].second + c[j].second;\n    ans -= (l - (l % k)) * (m - 1);\n    if (l % k != 0) break;\n    i++;\n    j--;\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\nusing vd = vector<double>;\nusing vvd = vector<vd>;\nusing vs = vector<string>;\nvoid print_vars(ostream&) {}\ntemplate <typename Car, typename... Cdr>\nvoid print_vars(ostream& os, const Car& car, const Cdr&... cdr) {\n  print_vars(os << car << (sizeof...(cdr) ? \",\" : \"\"), cdr...);\n}\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& os, const pair<T1, T2>& p) {\n  return os << '(' << p.first << ',' << p.second << ')';\n}\ntemplate <int I, typename Tuple>\nvoid print_tuple(ostream&, const Tuple&) {}\ntemplate <int I, typename Car, typename... Cdr, typename Tuple>\nvoid print_tuple(ostream& os, const Tuple& t) {\n  os << get<I>(t) << (sizeof...(Cdr) ? \",\" : \"\");\n  print_tuple<I + 1, Cdr...>(os, t);\n}\ntemplate <typename... Args>\nostream& operator<<(ostream& os, const tuple<Args...>& t) {\n  print_tuple<0, Args...>(os << '(', t);\n  return os << ')';\n}\ntemplate <typename Ch, typename Tr, typename C>\nbasic_ostream<Ch, Tr>& operator<<(basic_ostream<Ch, Tr>& os, const C& c) {\n  os << '[';\n  for (auto i = begin(c); i != end(c); ++i)\n    os << (i == begin(c) ? \"\" : \" \") << *i;\n  return os << ']';\n}\nconstexpr int INF = 1e9;\nconstexpr int MOD = 1e9 + 7;\nconstexpr double EPS = 1e-9;\nvector<tuple<ll, ll>> compress(const vector<tuple<ll, ll>>& b, ll n, ll k) {\n  vector<tuple<ll, ll>> res;\n  ll cur = -1, cnt = 0;\n  for (int i = int(0); i < int(b.size()); i++) {\n    ll x, c;\n    tie(x, c) = b[i];\n    if (x != cur) {\n      if (cur != -1) res.emplace_back(cur, cnt);\n      cur = x, cnt = c;\n    } else {\n      (cnt += c) %= k;\n      if (cnt == 0) {\n        if (res.empty())\n          cur = -1;\n        else {\n          tie(cur, cnt) = res.back();\n          res.pop_back();\n        }\n      }\n    }\n  }\n  if (cnt > 0) res.emplace_back(cur, cnt);\n  if (res.size() > 2 * n) {\n    int l = n, r = res.size() - n;\n    ll cnt = 0;\n    for (int i = int(l); i < int(r); i++) cnt += get<1>(res[i]);\n    res.erase(begin(res) + l, begin(res) + r);\n    res.emplace(begin(res) + l, INF, cnt);\n  }\n  return res;\n}\nll solve(ll n, ll k, ll m, vl a) {\n  vector<vector<tuple<ll, ll>>> b(30);\n  {\n    vector<tuple<ll, ll>> t;\n    for (int i = int(0); i < int(n); i++) t.emplace_back(a[i], 1);\n    b[0] = compress(t, n, k);\n  }\n  for (int i = int(1); i < int(b.size()); i++) {\n    vector<tuple<ll, ll>> t = b[i - 1];\n    t.insert(end(t), begin(b[i - 1]), end(b[i - 1]));\n    b[i] = compress(t, n, k);\n  }\n  vector<tuple<ll, ll>> c;\n  for (int i = int(0); i < int(30); i++)\n    if (m >> i & 1) {\n      c.insert(end(c), begin(b[i]), end(b[i]));\n      c = compress(c, n, k);\n    }\n  ll res = 0;\n  for (auto t : c) res += get<1>(t);\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  constexpr char endl = '\\n';\n  for (ll n, k, m; cin >> n >> k >> m && n | k | m;) {\n    vl a(n);\n    for (int i = int(0); i < int(n); i++) cin >> a[i];\n    cout << solve(n, k, m, a) << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  ll n, k, m;\n  cin >> n >> k >> m;\n  vector<array<int, 2>> b;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    if (b.empty() || b.back()[0] != x) {\n      b.push_back({x, 0});\n    }\n    b.back()[1]++;\n    if (b.back()[1] == k) b.pop_back();\n  }\n  n = b.size();\n  ll len = 0;\n  for (auto x : b) len += x[1];\n  if (b.size() == 0 || m == 1) {\n    cout << len << '\\n';\n    return 0;\n  }\n  ll r = 0, er = 0;\n  for (int i = 0; i < n; i++) {\n    if (b[n - 1 - i][0] != b[i][0]) break;\n    int sum = b[n - 1 - i][1] + b[i][1];\n    er += sum / k * k;\n    sum %= k;\n    if (sum) break;\n    r++;\n  }\n  if (r == n) {\n    cout << len * (m % 2) << '\\n';\n    return 0;\n  } else if (2 * r + 1 == n) {\n    ll sum = b[r][1] * m;\n    sum %= k;\n    if (sum)\n      cout << len - b[r][1] + sum << '\\n';\n    else\n      cout << 0 << '\\n';\n    return 0;\n  } else {\n    assert(2 * r < n);\n    cout << len * m - er * (m - 1) << '\\n';\n    return 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int>> Q;\nint val(long long x) {\n  printf(\"%lld\\n\", x);\n  return 0;\n}\nint main() {\n  int n, k, m, i, QN, rem, delt, v;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  Q.clear();\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &v);\n    if (Q.empty() || v != Q.back().first) {\n      Q.push_back(make_pair(v, 1));\n    } else\n      Q.back().second++;\n    while (Q.back().second >= k) {\n      Q.back().second -= k;\n    }\n    if (Q.back().second == 0) Q.pop_back();\n  }\n  QN = Q.size();\n  if (QN == 0) {\n    return val(0);\n  }\n  rem = 0;\n  for (i = 0; i < QN; i++) rem += Q[i].second;\n  delt = 0;\n  for (i = 0; i < QN;) {\n    if (Q[i].first == Q[QN - 1 - i].first) {\n      if ((Q[i].second + Q[QN - 1 - i].second) >= k) {\n        delt++;\n        if (Q[i].second + Q[QN - 1 - i].second == k) {\n          i++;\n        } else\n          break;\n      } else\n        break;\n    } else\n      break;\n  }\n  if (i == QN) {\n    if (m % 2 == 0) {\n      return val(0);\n    } else {\n      return val(rem);\n    }\n  } else {\n    if (i == QN - 1 - i) {\n      long long tmp = Q[i].second * (long long)m % k;\n      if (tmp == 0) {\n        return val(0);\n      } else {\n        return val(rem - Q[i].second + tmp);\n      }\n    } else {\n      long long tmp = m;\n      return val(rem * tmp - (tmp - 1) * k * delt);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m;\nint l = 1, r, q[1000100], sum[1000100];\nlong long ans;\nint top, a[1000100];\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  ans = (long long)n * m;\n  int x;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &x);\n    if (l <= r && x == q[r]) {\n      sum[r]++;\n      if (sum[r] == k) {\n        ans -= (long long)k * m;\n        sum[r] = 0;\n        r--;\n      }\n    } else {\n      q[++r] = x;\n      sum[r] = 1;\n    }\n  }\n  if (l == r) {\n    ans -= (long long)k * ((long long)sum[r] * m / k);\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n  while (1) {\n    if (l < r && q[l] == q[r] && sum[l] + sum[r] >= k) {\n      ans -= (long long)(m - 1) * k;\n      if (sum[l] + sum[r] == k) {\n        top++;\n        a[top] = sum[l] + sum[r];\n        l++;\n        r--;\n      } else\n        break;\n    } else if (l == r) {\n      long long now = (long long)m * sum[l];\n      ans -= k * (now / k);\n      if (now % k != 0) break;\n      l++;\n      r--;\n    } else if (l > r) {\n      while (top && a[top] >= k) {\n        ans -= k;\n        if (a[top] == k)\n          top--;\n        else\n          break;\n      }\n      break;\n    } else\n      break;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[100005];\npair<long long, long long> st[100005];\nlong long top, n, m, k, l, r, rec, rec2;\nlong long ans;\nint main() {\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  for (long long i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  for (long long i = 1; i <= n; i++) {\n    if (!top || st[top].first != a[i])\n      st[++top] = make_pair(a[i], 1);\n    else\n      st[top].second = (st[top].second + 1) % k;\n    if (st[top].second == 0) top--;\n  }\n  for (long long i = 1; i <= top; i++) rec += st[i].second;\n  l = 1, r = top;\n  while (l < r && st[l].first == st[r].first &&\n         (st[l].second + st[r].second) % k == 0) {\n    rec2 += st[l].second + st[r].second;\n    l++;\n    r--;\n  }\n  if (l == r) {\n    if (st[l].second * m % k == 0) ans -= rec2;\n    ans += m * rec - rec2 * (m - 1) - (st[l].second * m / k * k);\n  } else {\n    if (st[l].first == st[r].first)\n      rec2 += (st[l].second + st[r].second) / k * k;\n    ans = m * rec - rec2 * (m - 1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double pi = acosl(-1);\nconst int maxn = 100010;\nconst long long mod = 1e6 + 3;\nconst int inf = 1e9;\nint n, k, m;\nint a[maxn];\ndeque<pair<int, int> > vec;\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  int s = n;\n  for (int i = 0; i < n; i++) {\n    if (!vec.empty() && vec.back().first == a[i]) {\n      vec.back().second++;\n    } else {\n      vec.push_back({a[i], 1});\n    }\n    if (!vec.empty() && vec.back().second == k) {\n      vec.pop_back();\n      s -= k;\n    }\n  }\n  long long sum = (long long)s * m;\n  if (m == 1) {\n    cout << sum << endl;\n    return 0;\n  }\n  long long pr = 0;\n  while (vec.size() >= 2 && vec[0].first == vec.back().first) {\n    if (vec[0].second + vec.back().second == k) {\n      vec.pop_back();\n      vec.pop_front();\n      sum -= (long long)k * (m - 1);\n      pr += k;\n    } else if (vec[0].second + vec.back().second > k) {\n      int tmp = vec[0].second + vec.back().second - k;\n      vec.back().second = 0;\n      vec[0].second = tmp;\n      sum -= (long long)k * (m - 1);\n      break;\n    } else {\n      break;\n    }\n  }\n  if (vec.size() == 1) {\n    long long tmp = (long long)vec[0].second * m;\n    sum = tmp % k;\n    if (sum) sum += pr;\n  }\n  cout << sum << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:536870912\")\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int N = 1e5 + 100;\nint a[N];\nvector<pair<int, long long int>> bl;\nint main() {\n  long long int n, k, m;\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  int c = 1, g = 0;\n  for (int i = 0; i < n; i++, c++) {\n    if (a[i + 1] != a[i]) {\n      if (c % k) {\n        if (!bl.empty() && bl.back().first == a[i]) {\n          bl.back().second += c % k;\n          g += bl.back().second / k;\n          bl.back().second %= k;\n          if (bl.back().second == 0) bl.pop_back();\n        } else\n          bl.push_back({a[i], c % k});\n      }\n      g += c / k;\n      c = 0;\n    }\n  }\n  if (m == 1)\n    printf(\"%lld\", n - g * k);\n  else {\n    int p = 0, w = 0;\n    for (; p < bl.size(); p++) {\n      if (bl[p].first != bl[bl.size() - 1 - p].first) break;\n      w += (bl[p].second + bl[bl.size() - 1 - p].second) / k;\n      if ((bl[p].second + bl[bl.size() - 1 - p].second) % k) break;\n    }\n    if (p == bl.size())\n      printf(\"%lld\", (m & 1) ? n - g * k : 0ll);\n    else if (p == bl.size() - 1 - p) {\n      int s = 0;\n      for (int i = 0; i < p; i++)\n        s += bl[i].second + bl[bl.size() - 1 - i].second;\n      int d = 0;\n      if (bl[p].second * m % k == 0) {\n        for (int i = p - 1; i >= 0; i--) {\n          if (bl[i].first != bl[bl.size() - 1 - i].first) break;\n          d += (bl[i].second + bl[bl.size() - 1 - i].second) / k;\n          if ((bl[i].second + bl[bl.size() - 1 - i].second) % k) break;\n        }\n      }\n      printf(\"%lld\", s - d * k + bl[p].second * m % k);\n    } else {\n      printf(\"%lld\", (n - g * k) * m - (m - 1) * w * k);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m, x;\nint main() {\n  cin >> n >> k >> m;\n  vector<pair<long long, long long> > v;\n  long long ans = 0;\n  for (long long i = 1; i <= n; i++) {\n    cin >> x;\n    if (v.empty() || v.back().first != x) {\n      v.push_back({x, 1});\n    } else {\n      v.back().second++;\n      if (v.back().second == k) v.pop_back();\n    }\n  }\n  for (auto it : v) ans += it.second;\n  long long sz = v.size();\n  long long i, aux = 0;\n  for (i = 0; i < sz - i - 1; i++) {\n    if (i >= sz - i - 1) break;\n    if (v[i].first == v[sz - i - 1].first &&\n        v[i].second + v[sz - i - 1].second == k)\n      aux += k;\n    else\n      break;\n  }\n  if (i < sz - i - 1) {\n    if (v[i].first == v[sz - i - 1].first &&\n        v[i].second + v[sz - i - 1].second > k)\n      aux += k;\n    ans = 1ll * m * ans - (m - 1ll) * aux;\n  } else {\n    aux = 1ll * v[i].second * m % k;\n    if (aux) {\n      ans -= v[i].second;\n      ans += aux;\n    } else\n      ans = 0;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[101000], c[101000], num[101000];\nint main() {\n  long long n, cir, m;\n  while (scanf(\"%lld%lld%lld\", &n, &cir, &m) != EOF) {\n    long long cnt = 0;\n    for (long long i = 1; i <= n; i++) {\n      scanf(\"%lld\", &a[i]);\n      if (a[i] != c[cnt]) {\n        c[++cnt] = a[i];\n        num[cnt] = 1;\n      } else {\n        num[cnt]++;\n        if (num[cnt] == cir) cnt--;\n      }\n    }\n    if (!cnt) {\n      printf(\"0\\n\");\n      continue;\n    }\n    long long sum = 0;\n    for (long long i = 1; i <= cnt; i++) sum += num[i];\n    long long k, k1;\n    long long s = 0;\n    for (k = 1, k1 = cnt + 1 - k; k < k1; k++, k1--) {\n      if (c[k] == c[k1] && num[k] + num[k1] == cir)\n        s = s + cir;\n      else\n        break;\n    }\n    if (k < k1) {\n      if (c[k] == c[k1] && num[k] + num[k1] > cir) s = s + cir;\n      printf(\"%lld\\n\", sum * m - s * (m - 1));\n    } else if (k == k1) {\n      long long ans = (num[k] * m) % cir;\n      if (ans) ans += sum - num[k];\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2 * 1e5;\nvector<long long> a;\nlong long num[N], n, k, m, val;\nint main() {\n  cin >> n >> k >> m;\n  for (int i = 1; i <= n; ++i) {\n    cin >> val;\n    if (a.size() && a.back() == val) {\n      ++num[a.size() - 1];\n      if (num[a.size() - 1] == k) a.pop_back();\n    } else {\n      num[a.size()] = 1;\n      a.push_back(val);\n    }\n  }\n  long long x = 0, y = a.size() - 1, b = 0;\n  for (int i = 0; i < a.size(); ++i) b += num[i];\n  if (m == 1) {\n    cout << b;\n    return 0;\n  }\n  int tmp = b;\n  while (x < y) {\n    if (a[x] != a[y]) break;\n    if (num[x] + num[y] == k) {\n      b -= k;\n      ++x;\n      --y;\n      continue;\n    }\n    if (num[x] + num[y] > k) b -= k;\n    break;\n  }\n  long long ans = m * b;\n  tmp -= b;\n  if (x == y) {\n    if (ans % k == 0) tmp = 0;\n    ans = ans % k;\n  }\n  cout << ans + tmp;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class D {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long n = sc.nextLong();\n        long k = sc.nextLong();\n        long m = sc.nextLong();\n        \n        LinkedList<CF> begin = new LinkedList<>();\n        LinkedList<CF> end = new LinkedList<>();\n        LinkedList<CF> middle = new LinkedList<>();\n        \n        for (int i = 0; i < n; i++) {\n            long c = sc.nextLong();\n            if (middle.size() > 0 && middle.get(middle.size()-1).c == c) {\n                middle.get(middle.size()-1).f++;\n                if (middle.get(middle.size()-1).f%k == 0) {\n                    middle.remove(middle.size()-1);\n                }\n            } else {\n                CF cf = new CF();\n                cf.c = c; cf.f = 1;\n                middle.add(cf);\n            }\n        }\n        \n        while (true) {\n            if (middle.size() <= 1) break;\n            CF mf = middle.getFirst(); CF ml = middle.getLast();\n            if (mf.c == ml.c && mf.f+ml.f >= k) {\n                middle.removeLast();\n                end.addFirst(ml);\n                mf.f -= k-ml.f;\n                if (mf.f == 0) middle.removeFirst();\n                CF bl = new CF(); bl.c = mf.c; bl.f = k-ml.f;\n                begin.addLast(bl);\n            } else {\n                break;\n            }\n        }\n        \n        if (middle.size() == 1) {\n            CF mf = middle.getFirst();\n            m *= mf.f; mf.f = 1;\n            m %= k;\n        } else if (middle.size() == 0) {\n            m = 0;\n        }\n        \n        if (m == 0 && !begin.isEmpty() && !end.isEmpty()) {\n            CF bl = begin.getLast();\n            CF ef = end.getFirst();\n            while (bl.c == ef.c && bl.f + ef.f >= k) {\n                end.removeFirst();\n                bl.f -= k-ef.f;\n                if (bl.f == 0) {\n                    begin.removeLast();\n                }\n                if (begin.size() == 0 || end.size() == 0) break;\n                bl = begin.getLast();\n                ef = end.getFirst();\n            }\n        }\n        \n        long size = 0;\n        for (CF cf : begin) {\n            size += cf.f;\n        }\n        for (CF cf : middle) {\n            size += m*cf.f;\n        }\n        for (CF cf : end) {\n            size += cf.f;\n        }\n        System.out.println(size);\n    }\n    \n}\n\nclass CF {\n    long c;\n    long f;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, k, m;\n  vector<pair<int, int>> from;\n  cin >> n >> k >> m;\n  long long preteam = 0ll;\n  for (int i = (0); i < (n); ++i) {\n    int a;\n    cin >> a;\n    if (!from.empty() && from.back().first == a) {\n      ++from.back().second;\n      if (from.back().second == k) {\n        ++preteam;\n        from.pop_back();\n      }\n    } else {\n      from.emplace_back(a, 1);\n    }\n  }\n  long long edgeteam = 0ll;\n  auto froml = from.begin();\n  auto fromr = from.end();\n  while (fromr - froml >= 2) {\n    auto prer = fromr - 1;\n    if (froml->first != prer->first) {\n      break;\n    } else {\n      long long concat = froml->second + prer->second;\n      edgeteam += concat / k;\n      if (concat % k != 0)\n        break;\n      else {\n        ++froml;\n        --fromr;\n      }\n    }\n  }\n  long long centerteam = 0ll;\n  if (fromr - froml == 1) {\n    long long center = m * froml->second;\n    if (center % k == 0) {\n      cout << 0 << endl;\n      return 0;\n    } else {\n      centerteam = center / k;\n    }\n  }\n  cout << n * m - preteam * k * m - edgeteam * k * (m - 1) - centerteam * k\n       << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1000 * 1000 * 1000 + 1;\nconst long long MOD = 1000 * 1000 * 1000 + 7;\nint main() {\n  int n, k, m;\n  cin >> n >> k >> m;\n  vector<vector<long long>> bus;\n  int city;\n  long long sum{n};\n  for (int i = 0; i < n; ++i) {\n    cin >> city;\n    if (bus.size() && bus[bus.size() - 1][0] == city) {\n      ++bus.back()[1];\n      if (bus.back()[1] == k) {\n        bus.pop_back();\n        sum -= k;\n      }\n    } else {\n      bus.push_back({city, 1});\n    }\n  }\n  long long sumAll{sum};\n  int pos = 0;\n  int sz = bus.size();\n  long long pref = 0;\n  while (pos < bus.size() && bus[pos][0] == bus[sz - 1 - pos][0]) {\n    if (bus[pos][1] + bus[sz - 1 - pos][1] >= k) {\n      sum -= k;\n      pref += k;\n      if (bus[pos][1] + bus[sz - 1 - pos][1] == k) {\n        ++pos;\n      } else {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n  --pos;\n  if (pos == sz - 1) {\n    cout << ((m & 1) ? sumAll : 0) << endl;\n    return 0;\n  }\n  if ((sz & 1) && pos + 1 == sz / 2) {\n    sumAll -= bus[sz / 2][1];\n    long long mod = (bus[sz / 2][1] * m) % k;\n    sumAll += mod;\n    cout << (mod ? sumAll : 0) << endl;\n    return 0;\n  }\n  cout << sum * m + pref << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, k, a[101000], g, c[101000], l, x, ans, all;\nint main() {\n  cin >> n >> k >> m;\n  for (int o = n; o--;) {\n    cin >> x;\n    if (x == a[g] && g) {\n      c[g]++;\n    } else {\n      a[++g] = x;\n      c[g] = 1;\n    }\n    if (c[g] == k) g--;\n  }\n  for (int i = 1; i <= g; i++) all += c[i];\n  for (l = 1; l * 2 <= g; l++) {\n    if (a[l] != a[g + 1 - l]) break;\n    if (c[l] = (c[l] + c[g + 1 - l]) % k) {\n      c[g + 1 - l] = 0;\n      break;\n    }\n  }\n  if (l * 2 <= g) {\n    for (int i = l; i <= g + 1 - l; i++) ans += c[i];\n    ans = ans * (m - 1) + all;\n  } else if (c[l] * m % k) {\n    ans = all - c[l] + c[l] * m % k;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int N = 1e6 + 6;\nll ans;\nvoid gg() {\n  cout << ans << endl;\n  exit(0);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> k >> m;\n  vector<int> a(n);\n  for (int &i : a) cin >> i;\n  ans = 1LL * n * m;\n  vector<pair<int, int>> s;\n  if (*min_element((a).begin(), (a).end()) !=\n      *max_element((a).begin(), (a).end())) {\n    for (int i = 0; i < n; ++i) {\n      int x = a[i];\n      if (s.empty() || s.back().first != x) s.push_back({x, 0});\n      if (s.back().first == x) ++s.back().second;\n      if (s.back().second == k) {\n        ans -= 1LL * k * m;\n        s.pop_back();\n      }\n    }\n    vector<int> aa;\n    for (auto p : s)\n      while (p.second--) aa.push_back(p.first);\n    a = aa;\n    n = a.size();\n    s.clear();\n    for (int i = 0; i < n; ++i) {\n      int x = a[i];\n      if (s.empty() || s.back().first != x) s.push_back({x, 0});\n      if (s.back().first == x) ++s.back().second;\n      if (s.back().second == k) s.pop_back();\n    }\n  } else {\n    ans %= k;\n    gg();\n  }\n  cerr << \"ans = \" << ans << endl;\n  for (int x : a) cerr << x << ' ';\n  cerr << endl;\n  if (a.empty()) gg();\n  auto t = s, e = s;\n  for (int i = 0;;) {\n    if (s.back().first == t[i].first) {\n      if (i + 1 == t.size()) {\n        ll l = s.back().second + t[i].second * 1LL * (m - 1);\n        ans -= l - l % k;\n        if (l % k == 0) {\n          s.pop_back();\n          ++i;\n          a.clear();\n          for (int j = 0; j < s.size(); ++j)\n            while (s[j].second--) a.push_back(s[j].first);\n          for (int j = i; j < e.size(); ++j)\n            while (e[j].second--) a.push_back(e[j].first);\n          s.clear();\n          for (int i = 0; i < a.size(); ++i) {\n            int x = a[i];\n            if (s.empty() || s.back().first != x) s.push_back({x, 0});\n            if (s.back().first == x) ++s.back().second;\n            if (s.back().second == k) {\n              ans -= k;\n              s.pop_back();\n            }\n          }\n        }\n        gg();\n      }\n      int l = s.back().second + t[i].second;\n      if (l % k == 0) {\n        ans -= 1LL * (m - 1) * l;\n        s.pop_back();\n        t.pop_back();\n        ++i;\n        continue;\n      } else {\n        ans -= 1LL * (m - 1) * (l - l % k);\n        gg();\n      }\n    } else\n      break;\n  }\n  a.clear();\n  for (auto p : s)\n    while (p.second--) a.push_back(a[p.first]);\n  for (int x : a) cerr << x << ' ';\n  cerr << endl;\n  gg();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int alln, allk, allm;\nlong long int a;\ndeque<pair<long long int, long long int> > dq;\nint main() {\n  scanf(\"%lld%lld%lld\", &alln, &allk, &allm);\n  long long int ans = alln;\n  for (int i = 0; i < alln; ++i) {\n    scanf(\"%lld\", &a);\n    if (!dq.empty() && dq.back().first == a)\n      ++dq.back().second;\n    else\n      dq.push_back({a, 1});\n    if (dq.back().second == allk) {\n      ans -= allk;\n      dq.pop_back();\n    }\n  }\n  ans *= allm;\n  while (dq.size() > 1 && dq.back().first == dq.front().first) {\n    ans -=\n        (((dq.back().second + dq.front().second) / allk) * allk) * (allm - 1);\n    if ((dq.back().second + dq.front().second) % allk == 0) {\n      dq.pop_front();\n      dq.pop_back();\n    } else\n      break;\n  }\n  if (dq.size() == 1) {\n    if ((dq.front().second * allm) % allk)\n      ans -= ((dq.front().second * allm) / allk) * allk;\n    else\n      ans = 0;\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000 + 10;\nint n, m, k;\nint a[maxn], S[maxn], cnt[maxn], top;\nint main() {\n  bool single_color = true;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) scanf(\"%d\", a + i);\n  for (int i = 1; i < n; i++)\n    if (a[i] != a[i - 1]) {\n      single_color = false;\n      break;\n    }\n  if (single_color) {\n    printf(\"%I64d\\n\", (long long)n * m % k);\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    S[++top] = a[i];\n    if (top > 1 && S[top] == S[top - 1])\n      cnt[top] = cnt[top - 1] + 1;\n    else\n      cnt[top] = 1;\n    if (cnt[top] >= k) top -= k;\n  }\n  int L = 1, R = top;\n  long long t = 0;\n  while (S[L] == S[R] && L < R) {\n    int l = L, r = R, cnt = 0;\n    while (S[l] == S[L] && l < r && cnt < k) {\n      cnt++;\n      l++;\n    }\n    while (S[r] == S[L] && l < r && cnt < k) {\n      cnt++;\n      r--;\n    }\n    if (cnt == k) {\n      L = l;\n      R = r;\n      t += k;\n    } else\n      break;\n  }\n  single_color = true;\n  for (int i = L; i < R; i++)\n    if (S[i] != S[i + 1]) {\n      single_color = false;\n      break;\n    }\n  if (single_color) {\n    long long mid = (long long)(R - L + 1) * m % k;\n    if (mid)\n      printf(\"%lld\\n\", mid + t);\n    else\n      printf(\"0\\n\");\n  } else {\n    printf(\"%lld\\n\", (long long)(R - L + 1) * m + t);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100100;\nint a[maxn];\nint s[maxn], top = 0;\nint cnt[maxn];\nint main() {\n  int n, k, m;\n  cin >> n >> k >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  int single_color = 1;\n  for (int i = 1; i < n; i++) {\n    if (a[i] != a[i + 1]) {\n      single_color = 0;\n      break;\n    }\n  }\n  if (single_color) {\n    printf(\"%lld\\n\", (long long)n * m % k);\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    s[++top] = a[i];\n    if (top > 1 && s[top] == s[top - 1]) {\n      cnt[top] = cnt[top - 1] + 1;\n    } else\n      cnt[top] = 1;\n    if (cnt[top] >= k) {\n      top -= k;\n    }\n  }\n  int L = 1, R = top;\n  long long t = 0;\n  while (s[L] == s[R] && L < R) {\n    int l = L, r = R;\n    int cnt = 0;\n    while (s[l] == s[L] && cnt < k && l < r) {\n      cnt++, l++;\n    }\n    while (s[r] == s[L] && cnt < k && l < r) {\n      cnt++, r--;\n    }\n    if (cnt == k) {\n      L = l;\n      R = r;\n      t += k;\n    } else\n      break;\n  }\n  single_color = 1;\n  for (int i = L; i < R; i++) {\n    if (s[i] != s[i + 1]) {\n      single_color = 0;\n      break;\n    }\n  }\n  if (single_color) {\n    long long tmp = (long long)(R - L + 1) * m % k;\n    if (tmp == 0)\n      printf(\"0\\n\");\n    else {\n      printf(\"%lld\\n\", tmp + t);\n    }\n  } else {\n    printf(\"%lld\\n\", (long long)(R - L + 1) * m + t);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nlong long n, k, m, a[N];\ndeque<pair<long long, long long> > frst, last, v;\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  if (m <= 2) {\n    for (int i = 0; i < m; i++)\n      for (int j = 0; j < n; j++) {\n        if (v.size() == 0 || a[j] != v[v.size() - 1].first)\n          v.push_back({a[j], 1});\n        else\n          v[v.size() - 1].second++;\n        if (v[v.size() - 1].second == k) v.pop_back();\n      }\n    long long ans = 0;\n    for (int i = 0; i < v.size(); i++) ans += v[i].second;\n    cout << ans;\n    return 0;\n  }\n  for (int j = 0; j < n; j++) {\n    if (v.size() == 0 || a[j] != v[v.size() - 1].first)\n      v.push_back({a[j], 1});\n    else\n      v[v.size() - 1].second++;\n    if (v[v.size() - 1].second == k) v.pop_back();\n  }\n  frst = v;\n  last = v;\n  for (int i = 0; i < v.size(); i++) assert(v[i].second != 0);\n  while (v.size() > 0) {\n    assert(v[0].second != 0);\n    assert(v[v.size() - 1].second != 0);\n    if (v[0].first != v[v.size() - 1].first) break;\n    if (v.size() == 1) {\n      long long cnt = (m - 2) * v[0].second;\n      if (frst[frst.size() - 1].first == v[0].first) {\n        cnt += frst[frst.size() - 1].second;\n        frst.pop_back();\n      }\n      if (last[0].first == v[0].first) {\n        cnt += last[0].second;\n        last.pop_front();\n      }\n      cnt %= k;\n      if (cnt == 0) {\n        v = frst;\n        for (int i = 0; i < last.size(); i++) {\n          if (v.size() == 0 || last[i].first != v[v.size() - 1].first)\n            v.push_back(last[i]);\n          else\n            v[v.size() - 1].second += last[i].second;\n          while (v[v.size() - 1].second >= k) v[v.size() - 1].second -= k;\n          if (v[v.size() - 1].second == 0) v.pop_back();\n        }\n        long long ans = 0;\n        for (int i = 0; i < v.size(); i++) ans += v[i].second;\n        cout << ans;\n        return 0;\n      }\n      long long ans = cnt;\n      for (int i = 0; i < frst.size(); i++) {\n        assert(frst[i].second != 0);\n        ans += frst[i].second;\n      }\n      for (int i = 0; i < last.size(); i++) {\n        assert(last[i].second != 0);\n        ans += last[i].second;\n      }\n      cout << ans;\n      return 0;\n    }\n    if (v[0].second + v[v.size() - 1].second < k) break;\n    long long dec_first = min(v[0].second, k);\n    long long dec_last = k - dec_first;\n    v[0].second -= dec_first;\n    last[0].second -= dec_first;\n    v[v.size() - 1].second -= dec_last;\n    frst[frst.size() - 1].second -= dec_last;\n    if (v[0].second == 0) {\n      v.pop_front();\n      last.pop_front();\n    }\n    if (v[v.size() - 1].second == 0) {\n      v.pop_back();\n      frst.pop_back();\n    }\n  }\n  if (v.size() == 0) {\n    v = frst;\n    for (int i = 0; i < last.size(); i++) {\n      if (v.size() > 0) assert(v[v.size() - 1].second != 0);\n      assert(last[i].second != 0);\n      if (v.size() == 0 || last[i].first != v[v.size() - 1].first)\n        v.push_back(last[i]);\n      else\n        v[v.size() - 1].second += last[i].second;\n      while (v[v.size() - 1].second >= k) v[v.size() - 1].second -= k;\n      if (v[v.size() - 1].second == 0) v.pop_back();\n    }\n    long long ans = 0;\n    for (int i = 0; i < v.size(); i++) {\n      assert(v[i].second != 0);\n      ans += v[i].second;\n    }\n    cout << ans;\n    return 0;\n  } else {\n    long long ans = 0;\n    long long ans2 = 0;\n    for (int i = 0; i < v.size(); i++) {\n      assert(v[i].second != 0);\n      ans += v[i].second;\n    }\n    for (int i = 0; i < frst.size(); i++) {\n      assert(frst[i].second != 0);\n      ans2 += frst[i].second;\n    }\n    for (int i = 0; i < last.size(); i++) {\n      assert(last[i].second != 0);\n      ans2 += last[i].second;\n    }\n    cout << (m - 2) * ans + ans2;\n    return 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long INF = 2 * 1e9;\nconst long long MOD = 1000000007;\nusing namespace std;\nvoid solve() {\n  long long n, k, m;\n  cin >> n >> k >> m;\n  vector<long long> a(n);\n  vector<pair<long long, long long> > c;\n  long long x;\n  cin >> x;\n  c.push_back({x, 1});\n  long long cnt = 0;\n  for (long long i = 1; i < n; i++) {\n    long long x;\n    cin >> x;\n    if (c.size() == 0) {\n      c.push_back({x, 1});\n      continue;\n    }\n    if (x == c.back().first) {\n      c[(long long)(c).size() - 1].second++;\n      cnt += c[(long long)(c).size() - 1].second / k * k;\n      c[(long long)(c).size() - 1].second %= k;\n      if (c[(long long)(c).size() - 1].second == 0) c.pop_back();\n    } else {\n      c.push_back({x, 1});\n    }\n  }\n  if ((long long)(c).size() == 0) {\n    cout << 0 << '\\n';\n    return;\n  }\n  long long i = 0, j = (long long)(c).size() - 1;\n  auto tmp = c;\n  long long cnt1 = 0;\n  while (1) {\n    if (tmp[i].first == tmp[j].first) {\n      if (i == j) break;\n      cnt1 += (tmp[i].second + tmp[j].second) / k * k;\n      if ((tmp[i].second + tmp[j].second) % k == 0) {\n        i++;\n        j--;\n      } else\n        break;\n    } else {\n      break;\n    }\n  }\n  long long ans = 0;\n  if (i == j && tmp[i].first == tmp[j].first) {\n    long long cur = tmp[i].second * m;\n    long long cnt2 = (cur / k) * k;\n    cur %= k;\n    ans += cnt * m + cnt1 * (m - 1) + cnt2;\n    if (cur == 0) {\n      i--;\n      j++;\n      while (i >= 0 && j < tmp.size()) {\n        if (tmp[i].first == tmp[j].first) {\n          ans += (tmp[i].second + tmp[j].second) / k * k;\n          if ((tmp[i].second + tmp[j].second) % k == 0) {\n            i--;\n            j++;\n          } else\n            break;\n        } else\n          break;\n      }\n    }\n  } else {\n    ans += cnt * m + (cnt1) * (m - 1);\n  }\n  cout << n * m - ans << '\\n';\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cout.fixed;\n  cout.precision(12);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nmap<int, int> bus;\nint a[maxn];\nint num[maxn], Stack[maxn];\nint main() {\n  long long n, m, k;\n  while (cin >> n >> k >> m) {\n    int cnt = 0;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    bool flag = false;\n    for (int i = 1; i < n; i++)\n      if (a[i] != a[i - 1]) {\n        flag = true;\n        break;\n      }\n    if (!flag) {\n      cout << n * m % k << endl;\n      continue;\n    }\n    memset(num, 0, sizeof(num));\n    for (int i = 0; i < n; i++) {\n      Stack[++cnt] = a[i];\n      if (cnt > 1 && Stack[cnt] == Stack[cnt - 1])\n        num[cnt] = num[cnt - 1] + 1;\n      else\n        num[cnt] = 1;\n      if (num[cnt] >= k) cnt -= k;\n    }\n    long long left = 1, right = cnt;\n    long long ans = 0;\n    while (left < right && Stack[left] == Stack[right]) {\n      long long l = left, r = right, tol = 0;\n      while (Stack[l] == Stack[left] && l < r && tol < k) tol++, l++;\n      while (Stack[r] == Stack[right] && l < r && tol < k) tol++, r--;\n      if (tol == k) {\n        left = l;\n        right = r;\n        ans += k;\n      } else\n        break;\n    }\n    flag = false;\n    for (long long i = left; i < right; i++) {\n      if (Stack[i] != Stack[i + 1]) {\n        flag = true;\n        break;\n      }\n    }\n    if (!flag) {\n      long long mid = (right - left + 1) * m % k;\n      if (mid)\n        cout << mid + ans << endl;\n      else\n        cout << 0 << endl;\n    } else\n      cout << (right - left + 1) * m + ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\nusing namespace std;\nconst int INF = (int)1e9 + 123;\nconst long long LINF = (long long)1e18 + 123;\nconst long double EPS = (long double)1e-7;\nconst long long MOD = (long long)1e9 + 7;\nlong long power(long long x, long long y, long long mod = MOD) {\n  if (y == 0) {\n    return 1;\n  }\n  if (y & 1) {\n    return power(x, y - 1, mod) * x % mod;\n  } else {\n    long long tmp = power(x, y / 2, mod);\n    return tmp * tmp % mod;\n  }\n}\ntemplate <typename A, typename B>\nbool mini(A &x, const B &y) {\n  if (y < x) {\n    x = y;\n    return true;\n  }\n  return false;\n}\ntemplate <typename A, typename B>\nbool maxi(A &x, const B &y) {\n  if (y > x) {\n    x = y;\n    return true;\n  }\n  return false;\n}\nvoid run();\nint main() {\n  if (strlen(\"\")) {\n    freopen(\n        \"\"\n        \".in\",\n        \"r\", stdin);\n    freopen(\n        \"\"\n        \".out\",\n        \"w\", stdout);\n  }\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cout << fixed << setprecision(12);\n  run();\n  return 0;\n}\nconst int N = (int)2e5 + 123;\ntemplate <typename T>\nstruct Deque {\n  int l, r;\n  vector<T> q;\n  Deque() {\n    l = 0, r = 0;\n    q.resize(4 * N + 100);\n  }\n  T &front() { return q[l]; }\n  void pop_front() { l++; }\n  T &back() { return q[r - 1]; }\n  void pop_back() { r--; }\n  int size() { return r - l; }\n  void push_back(const T &x) { q[r++] = x; }\n  void push_front(const T &x) { q[l--] = x; }\n  void only_prefix() {\n    if (size() > N) {\n      r = l + N;\n    }\n    shift();\n  }\n  void only_suffix() {\n    if (size() > N) {\n      l = r - N;\n    }\n    shift();\n  }\n  void shift() {\n    int len = size();\n    for (int i = 0; i < len; i++) {\n      q[i] = q[l + i];\n    }\n    l = 0;\n    r = len;\n  }\n};\nint n, k, m;\nint a[N];\nstruct Shit {\n  bool divided;\n  long long rest;\n  Deque<pair<int, int>> l, r;\n  Shit() {\n    divided = 0;\n    rest = 0;\n  }\n};\nShit init;\nvoid convert() {\n  Deque<pair<int, int>> q;\n  long long cnt = 0;\n  for (int i = 0; i < n; i++) {\n    cnt++;\n    if (q.size() == 0) {\n      q.push_back({a[i], 1});\n    } else {\n      if (q.back().first == a[i]) {\n        q.back().second++;\n      } else {\n        q.push_back({a[i], 1});\n      }\n    }\n    if (q.back().second >= k) {\n      cnt -= k;\n      q.pop_back();\n    }\n  }\n  init.rest = cnt;\n  init.l = q;\n}\nShit merge(Shit a, Shit b) {\n  Shit res;\n  if (a.divided && b.divided) {\n    res.rest = a.rest + b.rest;\n    while (a.r.size() && b.l.size() && a.r.back().first == b.l.front().first) {\n      int cntL = a.r.back().second;\n      int cntR = b.l.front().second;\n      assert(cntL < k && cntR < k);\n      if (cntL + cntR < k) {\n        a.r.back().second += cntR;\n        b.l.pop_front();\n        break;\n      }\n      a.r.pop_back();\n      if (cntL + cntR == k) {\n        b.l.pop_front();\n      } else {\n        b.l.front().second -= (k - cntL);\n      }\n      res.rest -= k;\n    }\n    res.divided = 1;\n    res.l = a.l;\n    res.r = b.r;\n  } else if (a.divided) {\n    res.rest = a.rest + b.rest;\n    while (a.r.size() && b.l.size() && a.r.back().first == b.l.front().first) {\n      int cntL = a.r.back().second;\n      int cntR = b.l.front().second;\n      assert(cntL < k && cntR < k);\n      if (cntL + cntR < k) {\n        a.r.back().second += cntR;\n        b.l.pop_front();\n        break;\n      }\n      a.r.pop_back();\n      if (cntL + cntR == k) {\n        b.l.pop_front();\n      } else {\n        b.l.front().second -= (k - cntL);\n      }\n      res.rest -= k;\n    }\n    res.divided = 1;\n    res.l = a.l;\n    while (b.l.size()) {\n      a.r.push_back(b.l.front());\n      b.l.pop_front();\n    }\n    res.r = a.r;\n    res.r.only_suffix();\n  } else if (b.divided) {\n    res.rest = a.rest + b.rest;\n    while (a.l.size() && b.l.size() && a.l.back().first == b.l.front().first) {\n      int cntL = a.l.back().second;\n      int cntR = b.l.front().second;\n      assert(cntL < k && cntR < k);\n      if (cntL + cntR < k) {\n        a.l.back().second += cntR;\n        b.l.pop_front();\n        break;\n      }\n      a.l.pop_back();\n      if (cntL + cntR == k) {\n        b.l.pop_front();\n      } else {\n        b.l.front().second -= (k - cntL);\n      }\n      res.rest -= k;\n    }\n    res.divided = 1;\n    res.r = b.r;\n    while (b.l.size()) {\n      a.l.push_back(b.l.front());\n      b.l.pop_front();\n    }\n    res.l = a.l;\n    res.l.only_prefix();\n  } else {\n    res.rest = a.rest + b.rest;\n    while (a.l.size() && b.l.size() && a.l.back().first == b.l.front().first) {\n      int cntL = a.l.back().second;\n      int cntR = b.l.front().second;\n      assert(cntL < k && cntR < k);\n      if (cntL + cntR < k) {\n        a.l.back().second += cntR;\n        b.l.pop_front();\n        break;\n      }\n      a.l.pop_back();\n      if (cntL + cntR == k) {\n        b.l.pop_front();\n      } else {\n        b.l.front().second -= (k - cntL);\n      }\n      res.rest -= k;\n    }\n    while (b.l.size()) {\n      a.l.push_back(b.l.front());\n      b.l.pop_front();\n    }\n    if (a.l.size() >= 2 * N) {\n      auto l = a.l;\n      auto r = a.l;\n      l.only_prefix();\n      r.only_suffix();\n      res.divided = 1;\n      res.l = l;\n      res.r = r;\n    } else {\n      res.l = a.l;\n    }\n  }\n  return res;\n}\nShit solve(int x) {\n  if (x == 1) {\n    return init;\n  }\n  Shit tmp = solve(x / 2);\n  Shit shit = merge(tmp, tmp);\n  if (x & 1) {\n    shit = merge(shit, init);\n  }\n  return shit;\n}\nvoid run() {\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  convert();\n  cout << solve(m).rest << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long N, M, K;\nvector<pair<long long, long long> > v;\nvoid vpush(pair<long long, long long> &p) {\n  p.second %= K;\n  if (p.second == 0) return;\n  if (!v.empty() && v.back().first == p.first) {\n    v.back().second = (p.second + v.back().second) % K;\n    if (v.back().second == 0) v.pop_back();\n  } else {\n    v.push_back(p);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> N >> K >> M;\n  pair<long long, long long> cur = {-1, 0};\n  for (int i = 0; i < N; i++) {\n    int x;\n    cin >> x;\n    if (cur.first != x) {\n      vpush(cur);\n      cur.first = x;\n      cur.second = 1;\n    } else {\n      cur.second++;\n    }\n  }\n  vpush(cur);\n  long long sum = 0;\n  for (auto &x : v) {\n    sum += x.second;\n  }\n  if (M == 1) {\n    cout << sum << '\\n';\n    return 0;\n  }\n  long long l = 0, r = v.size() - 1, del = 0;\n  while (l < r) {\n    long long tot = v[l].second + v[r].second;\n    if (v[l].first != v[r].first || tot < K) break;\n    del += tot / K * K;\n    tot %= K;\n    if (tot == 0)\n      l++;\n    else\n      v[l].second = tot;\n    r--;\n  }\n  if (l != r) {\n    cout << (sum - del) * M + del << '\\n';\n  } else {\n    long long rem = v[l].second;\n    if (rem * M % K != 0) {\n      cout << rem * M % K + del << '\\n';\n    } else {\n      cout << 0 << '\\n';\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1.0);\nconst double eps = 1e-10;\nconst int MOD = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1e5 + 5;\nint a[MAXN];\nvector<pair<int, int> > v;\nint main() {\n  int n, k, m;\n  scanf(\"%d %d %d\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    if (!v.empty() && a[i] == v.back().first)\n      v.back().second++;\n    else\n      v.push_back(make_pair(a[i], 1));\n    if (v.back().second == k) v.pop_back();\n  }\n  int st = 0, en = (int)v.size() - 1;\n  long long s = 0;\n  for (int i = 0; i < v.size(); i++) s += v[i].second;\n  s *= m;\n  while (st < en) {\n    if (v[st].first != v[en].first) return 0 * printf(\"%lld\\n\", s);\n    if (v[st].second + v[en].second == k) {\n      s -= (long long)(m - 1) * k;\n      st++, en--;\n      continue;\n    }\n    if (v[st].second + v[en].second > k) s -= (long long)(m - 1) * k;\n    return 0 * printf(\"%lld\\n\", s);\n  }\n  if (((long long)m * v[st].second) % k == 0) {\n    puts(\"0\");\n    return 0;\n  }\n  s -= (long long)(1LL * m * v[st].second) / k * k;\n  printf(\"%lld\\n\", s);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\nint IT_MAX = 1 << 17;\nconst long long MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst long long LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\nconst double ERR = 1e-8;\nvector<pair<long long, long long> > Vu;\nint main() {\n  int N, K, M, i, j;\n  scanf(\"%d %d %d\", &N, &K, &M);\n  for (i = 1; i <= N; i++) {\n    int t;\n    scanf(\"%d\", &t);\n    if (!Vu.empty() && Vu.back().first == t) {\n      Vu.back().second++;\n      if (Vu.back().second == K) Vu.pop_back();\n    } else\n      Vu.emplace_back(t, 1);\n  }\n  long long s = 0;\n  for (auto it : Vu) s += it.second;\n  if (M == 1 || s == 0) return !printf(\"%lld\\n\", s);\n  s *= M;\n  int st = 0, en = (int)Vu.size() - 1;\n  while (st < en) {\n    if (Vu[st].first != Vu[en].first) return !printf(\"%lld\\n\", s);\n    if (Vu[st].second + Vu[en].second == K) {\n      s -= (long long)(M - 1) * K;\n      st++, en--;\n      continue;\n    }\n    if (Vu[st].second + Vu[en].second > K) s -= (long long)(M - 1) * K;\n    return !printf(\"%lld\\n\", s);\n  }\n  if (st == en) {\n    long long x = Vu[st].second * M;\n    if (x % K == 0) {\n      return !printf(\"0\\n\");\n    } else {\n      return !printf(\"%lld\\n\", s - (x / K) * K);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint num[maxn], a[maxn], cnt = 0;\nvoid init() {}\nint main() {\n  init();\n  long long n, k, m;\n  scanf(\"%I64d%I64d%I64d\", &n, &k, &m);\n  int now;\n  a[cnt] = -1;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &now);\n    if (now != a[cnt]) {\n      a[++cnt] = now;\n      num[cnt] = 1;\n    } else {\n      num[cnt]++;\n      if (num[cnt] == k) {\n        cnt--;\n      }\n    }\n  }\n  if (cnt == 1) {\n    printf(\"%I64d\\n\", num[1] * m % k);\n    return 0;\n  }\n  int l = 1, r = cnt;\n  while (l < r) {\n    if (a[l] == a[r] && num[l] + num[r] == k) {\n      l++;\n      r--;\n    } else\n      break;\n  }\n  if (n == 100000 && k == 1000000000 && m == 1000000000) {\n  }\n  if (l > r) {\n    if (m & 1) {\n      long long ans = 0;\n      for (int i = 1; i <= cnt; i++) ans += num[i];\n      printf(\"%I64d\\n\", ans);\n      return 0;\n    } else {\n      printf(\"0\\n\");\n      return 0;\n    }\n  }\n  if (l == r) {\n    if (num[l] * m % k == 0) {\n      printf(\"0\\n\");\n    } else\n      printf(\"%I64d\\n\", num[l] * m % k + (l - 1) * k);\n    return 0;\n  } else {\n    long long ans = 0;\n    for (int i = 1; i <= cnt; i++) ans += num[i];\n    ans *= m;\n    ans -= (m - 1) * (l - 1) * k;\n    if (a[l] == a[r]) ans -= (num[l] + num[r]) / k * k * (m - 1);\n    printf(\"%I64d\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nvoid Print() { cout << endl; }\ntemplate <typename T1, typename... T>\nvoid Print(const T1 &t1, const T &...t) {\n  cout << t1 << \" \";\n  Print(t...);\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate <class Iterator>\nostream &output_cantainer(ostream &os, Iterator first, Iterator last,\n                          bool space = true) {\n  if (space) {\n    for (Iterator it = first; it != last; it++) {\n      os << (*it) << ' ';\n    }\n    os << endl;\n  } else\n    for (Iterator it = first; it != last; it++) {\n      os << (*it) << endl;\n    }\n  return os;\n}\nconst int N = 1e5 + 4;\nint n, k, m, a[N], on;\nLL ans;\nvector<pair<int, int> > que, que2;\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  on = n;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n  for (int i = 1; i <= n; i++) {\n    if (!que.empty() && a[i] == que.back().first) {\n      if (++que.back().second == k) {\n        ans += 1ll * k * m;\n        que.pop_back();\n      }\n    } else\n      que.emplace_back(a[i], 1);\n  }\n  n = que.size();\n  int l = 0, r = n - 1;\n  while (l < r) {\n    if (que[l].first != que[r].first) break;\n    int tot = que[l].second + que[r].second;\n    ans += 1ll * (m - 1) * (tot / k * k);\n    if (tot % k != 0) break;\n    l++;\n    r--;\n  }\n  if (l == r) {\n    LL tot = 1ll * que[l].second * m;\n    ans += tot / k * k;\n    if (tot % k == 0) {\n      for (int i = 0; i < l; i++) que2.push_back(que[i]);\n      for (int i = l + 1; i < n; i++) {\n        if (!que2.empty() && que[i].first == que2.back().first) {\n          int t = que2.back().second + que[i].second;\n          ans += t / k * k;\n          que2.back().second = t % k;\n          if (t % k == 0) que2.pop_back();\n        } else\n          que2.push_back(que[i]);\n      }\n    }\n  } else if (l > r) {\n    for (int i = 0; i < n; i++) {\n      if (!que2.empty() && que[i].first == que2.back().first) {\n        int t = que2.back().second + que[i].second;\n        ans += t / k * k;\n        que2.back().second = t % k;\n        if (t % k == 0) que2.pop_back();\n      } else\n        que2.push_back(que[i]);\n    }\n  }\n  printf(\"%lld\\n\", 1ll * m * on - ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint n, k, m, a[N], b[N * 2];\nvoid get(int *a, int n, stack<pair<int, long long> > &q) {\n  int nown = -1;\n  long long now = 0;\n  for (int i = 0; i < n; i++) {\n    if (a[i] != nown) {\n      if (nown != -1) q.push({nown, now});\n      nown = a[i];\n      now = 1;\n    } else {\n      now++;\n      if (now % k == 0) {\n        if (!q.empty()) {\n          pair<int, long long> tp = q.top();\n          q.pop();\n          nown = tp.first;\n          now = tp.second;\n        } else {\n          nown = -1;\n          now = 0;\n        }\n      }\n    }\n  }\n  if (nown != -1) q.push({nown, now});\n  long long ans = 0;\n  while (!q.empty()) {\n    ans += q.top().second;\n    q.pop();\n  }\n  printf(\"%lld\\n\", ans);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  stack<pair<int, long long> > q;\n  if (m == 1)\n    get(a, n, q);\n  else if (m == 2) {\n    for (int i = 0; i < 2 * n; i++) b[i] = a[i % n];\n    get(b, 2 * n, q);\n  } else {\n    deque<pair<int, int> > dq;\n    long long tt = 0;\n    int nown = -1;\n    long long now = 0;\n    for (int i = 0; i < n; i++) {\n      if (a[i] != nown) {\n        if (nown != -1) q.push({nown, now});\n        nown = a[i];\n        now = 1;\n      } else {\n        now++;\n        if (now % k == 0) {\n          if (!q.empty()) {\n            pair<int, long long> tp = q.top();\n            q.pop();\n            nown = tp.first;\n            now = tp.second;\n          } else {\n            nown = -1;\n            now = 0;\n          }\n        }\n      }\n    }\n    if (nown != -1) q.push({nown, now});\n    while (!q.empty()) {\n      dq.push_front(q.top());\n      tt += q.top().second;\n      q.pop();\n    }\n    deque<pair<int, long long> > q1, q2;\n    while (dq.size() > 1) {\n      pair<int, long long> t1 = dq.front();\n      pair<int, long long> t2 = dq.back();\n      if (t1.first == t2.first) {\n        dq.pop_back();\n        dq.pop_front();\n        if ((t1.second + t2.second) % k) {\n          t1.second = (t1.second + t2.second) % k;\n          dq.push_front(t1);\n          break;\n        } else {\n          q1.push_back(t1);\n          q2.push_front(t2);\n        }\n      } else\n        break;\n    }\n    if (dq.size() == 1) {\n      long long t = 0;\n      t = dq.front().second;\n      t *= m;\n      t %= k;\n      if (t) q1.push_back({dq.front().first, t});\n      while (!q2.empty()) {\n        q1.push_back(q2.front());\n        q2.pop_front();\n      }\n      while (!q1.empty()) {\n        q2.push_back(q1.front());\n        q1.pop_front();\n      }\n      stack<pair<int, long long> > s;\n      int nown = -1;\n      long long now = 0;\n      while (!q2.empty()) {\n        if (q2.front().first == nown) {\n          now = now + q2.front().second;\n          now %= k;\n          if (now == 0) {\n            if (!q1.empty()) {\n              nown = q1.back().first;\n              now = q1.back().second;\n              q1.pop_back();\n            } else {\n              nown = -1;\n              now = 0;\n            }\n          }\n        } else {\n          if (nown != -1) q1.push_back({nown, now});\n          nown = q2.front().first;\n          now = q2.front().second;\n        }\n        q2.pop_front();\n      }\n      if (nown != -1) q1.push_back({nown, now});\n      nown = -1;\n      now = 0;\n      while (!q1.empty()) {\n        if (q1.front().first == nown) {\n          now++;\n          if (now % k == 0) {\n            if (!s.empty()) {\n              nown = s.top().first;\n              now = s.top().second;\n              s.pop();\n            } else {\n              nown = -1;\n              now = 0;\n            }\n          }\n        } else {\n          if (nown != -1) s.push({nown, now});\n          nown = q1.front().first;\n          now = q1.front().second;\n        }\n        q1.pop_front();\n      }\n      if (nown != -1) s.push({nown, now});\n      long long ans = 0;\n      while (!s.empty()) {\n        ans += s.top().second;\n        s.pop();\n      }\n      printf(\"%lld\\n\", ans);\n    } else {\n      long long t = 0;\n      while (!dq.empty()) {\n        t += dq.front().second;\n        dq.pop_front();\n      }\n      printf(\"%lld\\n\", tt + t * (m - 1));\n    }\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "#reference sol:-31772413\nr=lambda:map(int,input().split())\nn,k,m=r()\na=list(r())\nstck=[]\nfor i in range(n):\n\tif len(stck)==0 or stck[-1][0]!=a[i]:\n\t\tstck.append([a[i],1])\n\telse:\n\t\tstck[-1][1]+=1\n\tif stck[-1][1]==k:\n\t\tstck.pop()\n\nrem=0\nstrt,end=0,len(stck)-1\nif m > 1:\n\twhile end-strt+1 > 1 and stck[strt][0]==stck[end][0]:\n\t\tjoin=stck[strt][1]+stck[end][1]\n\t\tif join < k:\n\t\t\tbreak\n\t\telif join % k==0:\n\t\t\trem+=join\n\t\t\tstrt+=1\n\t\t\tend-=1\n\n\t\telse:\n\t\t\tstck[strt][1]=join % k\n\t\t\tstck[end][1]=0\n\t\t\trem+=(join//k)*k\n\ntr=0\nslen=end-strt+1\nfor el in stck[:slen]:\n\ttr+=el[1]\nif slen==0:\n\tprint(0)\nelif slen==1:\n\tr=(stck[strt][1]*m)%k\n\tif r==0:\n\t\tprint(0)\n\telse:\n\t\tprint(r+rem)\nelse:\n\tprint(tr*m+rem)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint nbValues, nbMerge, nbRepeat;\ndeque<pair<int, int>> sequence;\ndecltype(sequence) milieux;\ndeque<pair<int, int>> get_sub_sequence(const deque<pair<int, int>>& values,\n                                       int nbElems) {\n  decltype(sequence) seq;\n  for (auto value_count : values) {\n    if (value_count.second >= nbElems) {\n      seq.push_back({value_count.first, nbElems});\n      break;\n    } else {\n      nbElems -= value_count.second;\n      seq.push_back(value_count);\n    }\n  }\n  return seq;\n}\nint main() {\n  scanf(\"%d%d%d\", &nbValues, &nbMerge, &nbRepeat);\n  for (int iValue = 0; iValue < nbValues; iValue++) {\n    int value;\n    scanf(\"%d\", &value);\n    if (!sequence.empty() && sequence.back().first == value) {\n      sequence.back().second++;\n      if (sequence.back().second == nbMerge) {\n        sequence.pop_back();\n      }\n    } else {\n      sequence.push_back({value, 1});\n    }\n  }\n  milieux = sequence;\n  int nbDeleteDeb = 0;\n  int nbDeleteFin = 0;\n  while (milieux.size() >= 2 && milieux[0].first == milieux.back().first &&\n         milieux[0].second + milieux.back().second >= nbMerge) {\n    nbDeleteDeb += min(nbMerge, milieux[0].second);\n    milieux[0].second -= nbMerge;\n    if (milieux[0].second <= 0) {\n      milieux.back().second += milieux[0].second;\n      nbDeleteFin -= milieux[0].second;\n      milieux.pop_front();\n    }\n    if (milieux.back().second == 0) {\n      milieux.pop_back();\n    }\n  }\n  int nbDelete = nbDeleteDeb + nbDeleteFin;\n  long long milieux_size = 0;\n  for (auto value_count : milieux) {\n    milieux_size += value_count.second;\n  }\n  long long total = milieux_size * (long long)nbRepeat;\n  if (milieux.size() == 1) {\n    total = (milieux_size * (long long)nbRepeat) % (long long)nbMerge;\n  }\n  if (total == 0) {\n    decltype(sequence) sequence_deb = get_sub_sequence(sequence, nbDeleteDeb);\n    reverse(sequence.begin(), sequence.end());\n    decltype(sequence) sequence_fin = get_sub_sequence(sequence, nbDeleteFin);\n    reverse(sequence_fin.begin(), sequence_fin.end());\n    for (auto value_count : sequence_fin) {\n      if (!sequence_deb.empty() &&\n          sequence_deb.back().first == value_count.first) {\n        sequence_deb.back().second += value_count.second;\n        sequence_deb.back().second %= nbMerge;\n        if (sequence_deb.back().second == 0) {\n          sequence_deb.pop_back();\n        }\n      } else {\n        sequence_deb.push_back(value_count);\n      }\n    }\n    nbDelete = sequence_deb.size();\n  }\n  total += (long long)nbDelete;\n  printf(\"%lld\", total);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void read(int &x) {\n  x = 0;\n  char c = getchar();\n  int f = 1;\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  x *= f;\n}\ninline int max(int a, int b) { return a > b ? a : b; }\ninline int min(int a, int b) { return a < b ? a : b; }\nconst int N = 200200;\nint n, k, m, x[N], size, len;\npair<int, int> v[N], a[N], s[N];\ninline void insert(pair<int, int> x) {\n  if (s[len].first == x.first) {\n    (s[len].second += x.second) %= k;\n  } else\n    s[++len] = x;\n  if (!s[len].second) len--;\n}\nint main() {\n  read(n);\n  read(k);\n  read(m);\n  for (int i = 1; i <= n; i++) read(x[i]);\n  for (int i = 1; i <= n; i++) {\n    if (x[i] == v[size].first) {\n      v[size].second++;\n      v[size].second %= k;\n    } else\n      v[++size] = pair<int, int>(x[i], 1);\n    if (!v[size].second) size--;\n  }\n  for (int i = 1; i <= size; i++) a[i] = v[i];\n  int l = 1, r = size;\n  while (l < r && a[l].first == a[r].first && a[l].second + a[r].second >= k) {\n    a[l].second = (a[l].second + a[r].second) % k;\n    a[r].second = 0;\n    r--;\n    if (!a[l].second) l++;\n  }\n  long long ans1 = 0, ans2 = 0;\n  for (int i = 1; i <= size; i++) ans1 += v[i].second;\n  for (int i = l; i <= r; i++) ans2 += a[i].second;\n  if (l < r) {\n    printf(\"%lld\", ans1 + ans2 * (m - 1));\n    return 0;\n  }\n  for (int i = 1; i <= l - 1; i++) insert(v[i]);\n  if (l == r) insert(pair<int, int>(a[l].first, 1LL * a[l].second * m % k));\n  for (int i = r + 1; i <= size; i++) insert(v[i]);\n  long long ans = 0;\n  for (int i = 1; i <= len; i++) ans += s[i].second;\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint arr[maxn];\nint now[maxn];\nint nowcnt[maxn];\nint main() {\n  int n, k, m;\n  while (~scanf(\"%d%d%d\", &n, &k, &m)) {\n    bool single_color = true;\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &arr[i]);\n    for (int i = 2; i <= n; i++)\n      if (arr[i] != arr[i - 1]) single_color = false;\n    if (single_color) {\n      printf(\"%d\\n\", (long long)n * m % k);\n      continue;\n    }\n    int tot = 0;\n    now[++tot] = arr[1];\n    nowcnt[tot] = 1;\n    for (int i = 2; i <= n; i++) {\n      now[++tot] = arr[i];\n      if (now[tot] == now[tot - 1])\n        nowcnt[tot] = nowcnt[tot - 1] + 1;\n      else\n        nowcnt[tot] = 1;\n      if (nowcnt[tot] == k) tot -= k;\n    }\n    int L = 1, R = tot, t = 0;\n    int ride = 0;\n    while (now[L] == now[R] && L < R) {\n      int l = L, r = R, cnt = 0;\n      while (now[l] == now[L] && l < r && cnt < k) {\n        cnt++;\n        l++;\n      }\n      while (now[r] == now[L] && l < r && cnt < k) {\n        cnt++;\n        r--;\n      }\n      if (cnt == k) {\n        L = l;\n        R = r;\n        t += k;\n      } else\n        break;\n    }\n    single_color = true;\n    long long ans = 0;\n    for (int i = L + 1; i <= R; i++)\n      if (now[i] != now[i - 1]) {\n        single_color = false;\n        break;\n      }\n    if (single_color) {\n      if ((long long)m * (R - L + 1) % k)\n        ans = (long long)m * (R - L + 1) % k + t;\n      else\n        ans = 0;\n    } else\n      ans = (long long)m * (R - L + 1) + t;\n    printf(\"%lld\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, r;\nlong long c;\nvector<int> V;\ndeque<pair<int, int> > D;\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &r);\n    if (D.size() == 0) {\n      D.push_back(make_pair(r, 1));\n      continue;\n    }\n    if (r == D.back().first)\n      D.back().second++;\n    else\n      D.push_back(make_pair(r, 1));\n    if (D.back().second == k) D.pop_back();\n  }\n  for (int i = 0; i < D.size(); i++) c += 1ll * D[i].second;\n  c *= 1ll * m;\n  while (D.size() > 1) {\n    if (D.front().first != D.back().first) {\n      break;\n    }\n    c -= ((1ll * (D.front().second + D.back().second) / k) * k * (m - 1));\n    if ((D.back().second + D.front().second) % k != 0) {\n      break;\n    }\n    V.push_back(D.front().second + D.back().second);\n    D.pop_front();\n    D.pop_back();\n  }\n  if (D.size() == 1) {\n    c -= (1ll * m * D.front().second / k * k);\n    if ((1ll * D.front().second * m) % k == 0) {\n      D.pop_front();\n    }\n  }\n  if (D.size() == 0) {\n    for (int i = 0; i < (int)V.size(); i++) c -= V[i];\n  }\n  printf(\"%I64d\", c);\n  return (0);\n}\n"
        },
        {
            "language": 4,
            "solution": "//package com.company;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.text.CollationElementIterator;\nimport java.util.*;\n\npublic class Main\n{\n    static class group{\n        int idx;\n        int number;\n        group(int a){idx = a;number = 1;}\n        group copy(){\n            group cp = new group(idx);\n            cp.number = number;\n            return cp;\n        }\n    }\n\n    static group[] g;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(); int k = sc.nextInt(); int m = sc.nextInt();\n        Deque<group> st = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            int c = sc.nextInt();\n            if (st.size() == 0 || st.peek().idx != c){\n                st.push(new group(c));\n            } else {\n                st.peek().number += 1;\n            }\n            if (st.peek().number == k){\n                st.pop();\n            }\n        }\n        Iterator<group> iter = st.iterator();\n        long sum = 0;\n        while (iter.hasNext()){\n            group g = iter.next().copy();\n            sum += g.number;\n        }\n        while (st.size() >= 2){\n            group fr = st.peekFirst();\n            group la = st.peekLast();\n            if (fr.idx == la.idx){\n                int re = (fr.number + la.number)%k;\n                if (re != 0){\n                    fr.number = re;\n                    st.pollLast();\n                    break;\n                } else {\n                    st.pollLast();\n                    st.pollFirst();\n                }\n            } else {\n                break;\n            }\n        }\n        int cur_sum = 0;\n\n        for (group g : st) {\n            cur_sum += g.number;\n        }\n        long delo = (sum - cur_sum);\n        if (st.size() == 0){\n            System.out.println(m %2 == 0 ? 0 : cur_sum);\n        }else if (st.size() == 1){\n            if (st.peekLast().number % k == 0){\n                System.out.println(m%2 == 0 ? 0 : sum);\n            } else {\n                if (st.peekLast().number * (long) m % k == 0){\n                    System.out.println(0);\n                } else {\n                    System.out.println(((long) (m) * (long) cur_sum) % k + delo);\n                }\n            }\n        } else {\n            System.out.println((long)sum*(long)m - delo*(long)(m-1));\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = (long long)1e5 + 100;\nlong long n, k, m, a[maxn], sta[maxn], cnt[maxn];\nlong long top;\nint main() {\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  for (long long i = 1; i <= n; ++i) scanf(\"%lld\", &a[i]);\n  bool single = true;\n  for (long long i = 1; i < n; ++i)\n    if (a[i] != a[i + 1]) {\n      single = false;\n      break;\n    }\n  if (single)\n    printf(\"%lld\\n\", n * m % k);\n  else {\n    top = 0;\n    for (long long i = 1; i <= n; ++i) {\n      sta[++top] = a[i];\n      if (top == 1 || sta[top] != sta[top - 1])\n        cnt[top] = 1;\n      else\n        cnt[top] = cnt[top - 1] + 1;\n      if (cnt[top] >= k) top -= k;\n    }\n    long long L = 1, R = top, eli = 0;\n    while (L < R && sta[L] == sta[R]) {\n      long long l = L, r = R, tmp = 0;\n      while (l < r && sta[l] == sta[R] && tmp < k) {\n        ++l;\n        ++tmp;\n      }\n      while (l < r && sta[r] == sta[L] && tmp < k) {\n        --r;\n        ++tmp;\n      }\n      if (tmp == k) {\n        L = l, R = r;\n        eli += k;\n      } else\n        break;\n    }\n    single = true;\n    for (long long i = L; i < R; ++i)\n      if (sta[i] != sta[i + 1]) {\n        single = false;\n        break;\n      }\n    if (single) {\n      long long tmp = (R - L + 1) * m % k;\n      printf(\"%lld\\n\", tmp + (tmp > 0 ? eli : 0));\n    } else {\n      printf(\"%lld\\n\", (R - L + 1) * m + eli);\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, x;\nlong long o, u, s[100001], S[100001], c, h, t, i;\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &x);\n    if (!c || s[c] != x)\n      s[++c] = x, S[c] = 1;\n    else\n      S[c]++;\n    if (S[c] == k) c--;\n  }\n  for (i = 1; i <= c; i++) u += S[i];\n  h = 1, t = c;\n  while (h < t && s[h] == s[t]) {\n    if (!((S[h] + S[t]) % k))\n      h++, t--;\n    else {\n      S[h] = (S[h] + S[t]) % k, S[t] = 0;\n      break;\n    }\n  }\n  if (h < t) {\n    for (i = h; i <= t; i++) o += S[i];\n    o = o * (m - 1) + u;\n  } else\n    o = !((S[h] * m) % k) ? 0 : u + S[h] * (m - 1) - S[h] * m + S[h] * m % k;\n  printf(\"%lld\\n\", o);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint a[N], s[N], f[N], n, k, m, top;\nlong long ans;\nint main() {\n  cin >> n >> k >> m;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n  if (k >= n) {\n    bool flag = 1;\n    for (int i = 2; i <= n; i++)\n      if (a[i] != a[i - 1]) flag = 0;\n    if (flag)\n      cout << (long long)n * m % k;\n    else\n      cout << (long long)n * m << endl;\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    s[++top] = a[i];\n    if (top > 1 && s[top] == s[top - 1])\n      f[top] = f[top - 1] + 1;\n    else\n      f[top] = 1;\n    if (f[top] == k) top -= k;\n  }\n  int L = 1, R = top;\n  while (s[L] == s[R] && L != R) {\n    int l = L, r = R, cnt = 0;\n    while (s[L] == s[l] && l < r && cnt < k) ++l, ++cnt;\n    while (s[R] == s[r] && l < r && cnt < k) --r, ++cnt;\n    if (cnt == k)\n      L = l, R = r, ans += k;\n    else\n      break;\n  }\n  bool flag = 1;\n  for (int i = L + 1; i <= R; i++)\n    if (s[i] != s[i - 1]) flag = 0;\n  if (flag)\n    cout << ((long long)(R - L + 1) * m % k\n                 ? (long long)(R - L + 1) * m % k + ans\n                 : 0);\n  else\n    cout << ans + (long long)(R - L + 1) * m;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long result = 0;\ndeque<pair<int, int>> solve(vector<int> a, int m, int k) {\n  deque<pair<int, int>> result;\n  for (auto& item : a) {\n    if (!result.empty() && result.back().first == item) {\n      ++result.back().second;\n    } else {\n      result.emplace_back(item, 1);\n    }\n    if (result.back().second == k) {\n      ::result -= 1LL * m * k;\n      result.pop_back();\n    }\n  }\n  return result;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k, m;\n  cin >> n >> k >> m;\n  result = 1LL * n * m;\n  vector<int> a(n);\n  for (auto& item : a) {\n    cin >> item;\n  }\n  if (m == 2) {\n    for (int i = 0; i < n; ++i) {\n      a.push_back(a[i]);\n    }\n    m = 1;\n  }\n  if (m == 1) {\n    solve(a, m, k);\n    cout << result << '\\n';\n    return 0;\n  }\n  auto d = solve(a, m, k);\n  if (d.empty()) {\n    cout << result << '\\n';\n    return 0;\n  }\n  auto lf = d, rt = d;\n  while (((int)d.size()) > 1) {\n    if (d.front().first != d.back().first) {\n      cout << result << '\\n';\n      return 0;\n    }\n    int total = d.front().second + d.back().second;\n    result -= 1LL * (m - 1) * (total / k) * k;\n    if (total % k) {\n      cout << result << '\\n';\n      return 0;\n    }\n    d.pop_front();\n    d.pop_back();\n    lf.pop_back();\n    rt.pop_front();\n  }\n  result -= (1LL * m * d.back().second / k) * k;\n  int val = 1LL * m * d.back().second % k;\n  lf.pop_back();\n  rt.pop_front();\n  if (val > 0) lf.emplace_back(d.back().first, val);\n  lf.insert(lf.end(), rt.begin(), rt.end());\n  vector<int> b;\n  for (auto& item : lf) {\n    while (item.second > 0) {\n      b.push_back(item.first);\n      --item.second;\n    }\n  }\n  solve(b, 1, k);\n  cout << result << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3f;\ntemplate <typename T, typename T2>\ninline void _max(T &a, T2 b) {\n  a = max((T)a, (T)b);\n}\ntemplate <typename T, typename T2>\ninline void _min(T &a, T2 b) {\n  a = min((T)a, (T)b);\n}\nconst int MAX = 2e5 + 10;\nint n, k, m, a[MAX];\nint l[MAX], r[MAX], len[MAX], v[MAX];\nvoid clear() {}\nvoid read() {\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n}\nvoid solve() {\n  long long rem = 1ll * n * m;\n  set<pair<int, int>, greater<pair<int, int>>> s;\n  int x = a[0], c = 0, ns = 0;\n  for (int i = 0; i < n; i++) {\n    if (a[i] != x) {\n      len[ns] = c, v[ns] = x;\n      l[ns] = ns - 1, r[ns] = ns + 1;\n      s.insert({len[ns], ns});\n      c = 0, ns++;\n    }\n    x = a[i], c++;\n  }\n  len[ns] = c, v[ns] = x;\n  l[ns] = ns - 1, r[ns] = -1;\n  s.insert({len[ns], ns});\n  ns++;\n  while (!s.empty() && s.begin()->first >= k) {\n    auto it = s.begin();\n    int tLen = it->first, id = it->second;\n    s.erase(it);\n    if (tLen != len[id]) int a = 3;\n    rem -= tLen / k * k * 1ll * m;\n    if (tLen % k)\n      len[id] = tLen % k, s.insert({tLen % k, id});\n    else {\n      if (r[id] != -1) l[r[id]] = l[id];\n      if (l[id] != -1) r[l[id]] = r[id];\n      if (r[id] != -1 && l[id] != -1 && v[l[id]] == v[r[id]]) {\n        int nid = l[id], nlen = len[l[id]] + len[r[id]];\n        int nl = l[l[id]], nr = r[r[id]];\n        s.erase({len[l[id]], l[id]}), s.erase({len[r[id]], r[id]}),\n            s.insert({nlen, nid});\n        r[nid] = nr, l[nid] = nl, len[nid] = nlen;\n        if (nr != -1) l[nr] = nid;\n        if (nl != -1) r[nl] = nid;\n      }\n    }\n  }\n  if (s.size() == 1)\n    rem -= 1ll * s.begin()->first * m / k * k;\n  else if (rem && m > 1) {\n    int lid = ns - 1, rid = 0;\n    for (auto &p : s) _min(lid, p.second), _max(rid, p.second);\n    while (rid > lid && v[lid] == v[rid]) {\n      int LEN = len[lid] + len[rid];\n      rem -= 1ll * LEN / k * k * (m - 1);\n      if (LEN % k) break;\n      rid = l[rid], lid = r[lid];\n    }\n    if (lid == rid) {\n      rem -= (1ll * len[lid] * m) / k * k;\n      if (1ll * len[lid] * m % k == 0) {\n        rid = l[rid], lid = r[lid];\n        while (rid != -1 && lid != -1 && v[lid] == v[rid]) {\n          int LEN = len[lid] + len[rid];\n          rem -= LEN / k * k;\n          if (LEN % k) break;\n          rid = l[rid], lid = r[lid];\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", rem);\n}\nint main() {\n  while (scanf(\"%d%d%d\", &n, &k, &m) == 3) {\n    clear();\n    read();\n    solve();\n    return 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m;\nint a[100000];\nint d[100000];\nvector<pair<int, int> > v;\nvector<pair<int, int> > v2;\nvoid read_data() {\n  cin >> n >> k >> m;\n  int d, c;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    if (i == 0) {\n      d = 1;\n      c = a[i];\n    } else if (c == a[i]) {\n      d++;\n    } else {\n      v.push_back(make_pair(d, c));\n      d = 1;\n      c = a[i];\n    }\n  }\n  v.push_back(make_pair(d, c));\n}\nvoid merge_two_bus() {\n  int removed = 0;\n  for (int i = 0; i < v.size(); i++) {\n    pair<int, int> di = v[i];\n    pair<int, int> back;\n    if (!v2.empty()) {\n      back = v2.back();\n      if (back.second == di.second) {\n        v2.pop_back();\n        di.first += back.first;\n      }\n    }\n    int t = di.first % k;\n    removed += di.first - t;\n    if (t != 0) v2.push_back(make_pair(t, di.second));\n  }\n  int removed2 = 0;\n  int i;\n  for (i = 0; i < (v2.size() + 1) / 2; i++) {\n    pair<int, int> p1 = v2[i];\n    pair<int, int> p2 = v2[v2.size() - 1 - i];\n    if (p1.second == p2.second) {\n      if (p1.first + p2.first == k) {\n        removed2 += k;\n      } else {\n        removed2 += (p1.first + p2.first) / k * k;\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n  long long int ans = 0;\n  if (i == (v2.size() + 1) / 2) {\n    if (m % 2 == 0) {\n      ans = 0;\n    } else {\n      ans = n - removed;\n    }\n  } else if (i == (v2.size() + 1) / 2 - 1 && v2.size() % 2 == 1) {\n    if ((long long int)m * v2[i].first % k == 0) {\n      ans = 0;\n    } else {\n      ans = (long long int)m * v2[i].first % k + n - removed - v2[i].first;\n    }\n  } else {\n    ans = (long long int)m * (n - removed) - (long long int)(m - 1) * removed2;\n  }\n  cout << ans << endl;\n}\nint main() {\n  read_data();\n  merge_two_bus();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, K, M, n;\nvector<int> arr;\nvector<pair<int, int> > tmp, sub;\nint main() {\n  scanf(\"%d %d %d\", &N, &K, &M);\n  arr.resize(N);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &arr[i]);\n    arr[i]--;\n  }\n  bool ok = true;\n  int c = arr[0];\n  for (int i = 0; i < N; i++) {\n    if (arr[i] != c) {\n      ok = false;\n      break;\n    }\n  }\n  if (ok) {\n    cout << 1LL * N * M % K;\n    return 0;\n  }\n  int col, cnt;\n  for (int i = 0; i < N; i++) {\n    if (i == 0 || arr[i - 1] != arr[i]) {\n      if (i) tmp.push_back(pair<int, int>(col, cnt));\n      col = arr[i];\n      cnt = 1;\n    } else\n      cnt++;\n  }\n  tmp.push_back(pair<int, int>(col, cnt));\n  long long rem = 0;\n  for (int i = 0; i < tmp.size(); i++) {\n    rem += 1LL * M * (tmp[i].second / K) * K;\n    tmp[i].second %= K;\n    if (tmp[i].second == 0) {\n      continue;\n    }\n    if (sub.size() == 0 || sub.back().first != tmp[i].first)\n      sub.push_back(tmp[i]);\n    else {\n      sub.back().second += tmp[i].second;\n      rem += 1LL * M * (sub.back().second / K) * K;\n      sub.back().second %= K;\n      if (sub.back().second == 0) sub.pop_back();\n    }\n  }\n  tmp = sub;\n  if (tmp.size() == 0) {\n    cout << 0;\n    return 0;\n  }\n  if (tmp.size() == 1) {\n    cout << 1LL * tmp[0].second * M % K;\n    return 0;\n  }\n  if (M == 1) {\n    cout << (long long)N - rem;\n    return 0;\n  }\n  int n = tmp.size();\n  for (int i = 0; i < n; i++) {\n    if (tmp[i].first != tmp[n - 1 - i].first) break;\n    if (i > n - 1 - i) {\n      sub.clear();\n      for (int j = 0; j <= n - 1 - i; j++) sub.push_back(tmp[j]);\n      for (int j = i; j < n; j++) sub.push_back(tmp[j]);\n      tmp = sub;\n      sub.clear();\n      for (int j = 0; j < tmp.size(); j++) {\n        rem += 1LL * (tmp[j].second / K) * K;\n        tmp[j].second %= K;\n        if (tmp[j].second == 0) {\n          continue;\n        }\n        if (sub.size() == 0 || sub.back().first != tmp[j].first)\n          sub.push_back(tmp[j]);\n        else {\n          sub.back().second += tmp[j].second;\n          rem += 1LL * (sub.back().second / K) * K;\n          sub.back().second %= K;\n          if (sub.back().second == 0) sub.pop_back();\n        }\n      }\n      break;\n    }\n    if (i == n - 1 - i) {\n      rem += (1LL * M * tmp[i].second / K) * K;\n      if (1LL * M * tmp[i].second % K == 0)\n        continue;\n      else\n        break;\n    }\n    rem += 1LL * (M - 1) * ((tmp[i].second + tmp[n - 1 - i].second) / K) * K;\n    if ((tmp[i].second + tmp[n - 1 - i].second) % K) break;\n  }\n  cout << 1LL * N * M - rem;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000000;\nstruct Edge {\n  int x, y, z, ne;\n};\nEdge e[N * 2];\nint last[N];\nint a[N], b[N];\nint n, m, k, top;\nlong long ans;\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  int cnt = n;\n  ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    if (a[top] == x)\n      b[top]++;\n    else\n      a[++top] = x, b[top] = 1;\n    if (b[top] == k) b[top] = 0, cnt -= k, top--;\n  }\n  int p = 0;\n  for (int i = 1; i * 2 <= top; i++)\n    if (a[i] == a[top + 1 - i] && b[i] + b[top + 1 - i] == k)\n      p = i;\n    else\n      break;\n  if (top % 2 == 0) {\n    ans = 1LL * cnt * m - 1LL * (m - 1) * k * p;\n    if (a[p + 1] == a[top - p] && b[p + 1] + b[top - p] >= k)\n      ans -= 1LL * (m - 1) * k;\n  } else {\n    ans = 1LL * cnt * m - 1LL * (m - 1) * k * p;\n    if (p < top / 2) {\n      if (a[p + 1] == a[top - p] && b[p + 1] + b[top - p] >= k)\n        ans -= 1LL * (m - 1) * k;\n    } else {\n      if (1LL * b[p + 1] * m % k == 0)\n        ans = 0;\n      else\n        ans -= 1LL * b[p + 1] * m / k * k;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint k;\nint s[100009];\nint c[100009];\nint compress(int n) {\n  int m = 0;\n  for (int i = 0; i < n; i++) {\n    c[m] = (m && s[m - 1] == s[i]) ? c[m - 1] + 1 : 1;\n    s[m++] = s[i];\n    if (c[m - 1] == k) m -= k;\n  }\n  return m;\n}\nint main() {\n  int n, m;\n  scanf(\"%d %d %d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", s + i);\n  }\n  n = compress(n);\n  if (n == 0) {\n    cout << 0;\n    return 0;\n  }\n  for (int i = 0, j = n - 1; i <= j;) {\n    if (s[i] != s[j]) {\n      cout << (long long)i + (long long)(n - 1 - j) +\n                  (long long)m * (long long)(j - i + 1);\n      return 0;\n    }\n    int ii = i, jj = j;\n    while (ii <= j && s[ii] == s[i]) ii++;\n    if (ii > j) {\n      long long tmp = ((long long)m * (long long)(j - i + 1)) % (long long)k;\n      if (tmp == 0) {\n        for (int t = j + 1; t < n; t++) {\n          s[t - (j + 1) + i] = s[t];\n        }\n        cout << compress(n - (j - i + 1));\n      } else {\n        cout << (long long)i + (long long)(n - 1 - j) + tmp;\n      }\n      return 0;\n    }\n    while (s[jj] == s[j]) jj--;\n    int tmp = ii - i + j - jj;\n    if (tmp % k) {\n      long long ans = (long long)ii + (long long)(n - 1 - jj);\n      ans += (long long)(tmp % k) * ((long long)(m - 1));\n      ans += (long long)(jj - ii + 1) * (long long)m;\n      cout << ans;\n      return 0;\n    }\n    i = ii;\n    j = jj;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long _ = 1e2;\nconst long long maxn = 1e5 + _;\npair<long long, long long> a[maxn];\nlong long plen, len, id[maxn];\nint main() {\n  long long n, k, m, x;\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  plen = 0;\n  for (long long i = 1; i <= n; i++) {\n    scanf(\"%lld\", &x);\n    if (plen == 0 || a[plen].first != x)\n      a[++plen] = make_pair(x, 1);\n    else\n      a[plen].second++;\n  }\n  long long now, nxt;\n  long long s = 0;\n  len = 0;\n  for (long long i = 1; i <= plen; i = nxt) {\n    now = i, nxt = i + 1;\n    while (now > 0 && a[now].second >= k) {\n      a[now].second %= k;\n      if (a[now].second == 0) {\n        if (len != 0)\n          now = id[len], s -= a[id[len--]].second;\n        else\n          break;\n        if (now > 0 && nxt <= plen && a[now].first == a[nxt].first)\n          a[now].second += a[nxt].second, nxt++;\n      }\n    }\n    if (a[now].second != 0) id[++len] = now, s += a[id[len]].second;\n  }\n  if (len == 0) {\n    puts(\"0\");\n    return 0;\n  }\n  if (len == 1) {\n    printf(\"%lld\\n\", (long long)a[id[len / 2 + 1]].second * m % k);\n    return 0;\n  }\n  long long i;\n  long long g = 0, u = 0;\n  for (i = 1; i <= len / 2; i++) {\n    if (a[id[i]].first == a[id[len - i + 1]].first) {\n      long long num = (a[id[i]].second + a[id[len - i + 1]].second) % k;\n      g += a[id[i]].second + a[id[len - i + 1]].second - num;\n      if (num != 0) {\n        printf(\"%lld\\n\", s * m - g * (m - 1));\n        return 0;\n      }\n    } else {\n      printf(\"%lld\\n\", s * m - g * (m - 1));\n      return 0;\n    }\n  }\n  if (len % 2 == 0)\n    puts(\"0\");\n  else {\n    if (a[id[len / 2 + 1]].second * m % k == 0)\n      puts(\"0\");\n    else\n      printf(\"%lld\\n\", s * m - g * (m - 1) -\n                           (a[id[len / 2 + 1]].second * m -\n                            a[id[len / 2 + 1]].second * m % k));\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, k, m = tuple([int(x) for x in raw_input().rstrip().split()])\n\na = [int(x) for x in raw_input().rstrip().split()]\n\nstack = []\nfor aa in a:\n    if len(stack) == 0 or aa != stack[-1][0]:\n        stack.append([aa, 1])\n    else:\n        stack[-1][1] += 1\n        if stack[-1][1] == k:\n            stack.pop()\n\nrem = 0\nstart, end = 0, len(stack) - 1\nif m > 1:\n    while (end - start + 1) > 1 and stack[start][0] == stack[end][0]:\n        join = stack[start][1] + stack[end][1]\n        if join < k:\n            break\n        elif join % k == 0:\n            start += 1\n            end -= 1\n            rem += join\n        else:\n            stack[start][1] = join % k\n            stack[end][1] = 0\n            rem += (join / k) * k\n\nls = 0\nlen_stack = end - start + 1\nfor ss in stack[start: end + 1]:\n    ls += ss[1]\n\nif len_stack == 0:\n    print 0\nelif len_stack == 1:\n    r = (m * stack[start][1]) % k\n    if r == 0:\n        print 0\n    else:\n        print r + rem\nelse:\n    print ls * m + rem"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m;\nvector<pair<int, int> > v, u;\nint a, b, c;\nint main() {\n  cin >> n >> k >> m;\n  a = n;\n  for (int i = 0; i < n; i++) {\n    int w;\n    cin >> w;\n    if (v.size() > 0 && v.back().first == w) {\n      v.back().second++;\n      if (v.back().second == k) {\n        v.pop_back();\n        a -= k;\n      }\n    } else\n      v.push_back({w, 1});\n  }\n  u = v;\n  int b = a;\n  int x = 0, y = u.size() - 1;\n  while (x < y) {\n    if (u[x].first == u[y].first) {\n      if (u[x].second + u[y].second == k) {\n        x++;\n        y--;\n        b -= k;\n      } else {\n        if (u[x].second + u[y].second > k) b -= k;\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n  long long r = m * b;\n  a -= b;\n  if (x == y) {\n    r = r % k;\n    if (r == 0) a = 0;\n  }\n  cout << a + r << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long inline gcd(long long x, long long y) {\n  return !y ? (long long)abs(x) : gcd(y, x % y);\n}\nlong long inline lcm(long long a, long long b) {\n  return ((long long)abs((a / gcd(a, b)) * b));\n}\ndouble inline cartesian_dist(double x1, double y1, double x2, double y2) {\n  return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\nlong long bigmod(long long b, long long p, long long m) {\n  if (!p)\n    return 1 % m;\n  else if (p & 1)\n    return (((b % m) + m) % m * bigmod(b, p - 1, m)) % m;\n  else {\n    long long ret = bigmod(b, p / 2, m);\n    return (ret * ret) % m;\n  }\n}\nlong long inverse(long long a, long long m) { return bigmod(a, m - 2, m); }\nlong long extended(long long a, long long m) {\n  long long oldr = a, r = m, oldans = 1, ans = 0, quotient;\n  while (r) {\n    quotient = oldr / r;\n    oldr = oldr - r * quotient;\n    swap(oldr, r);\n    oldans = oldans - ans * quotient;\n    swap(oldans, ans);\n  }\n  return ((oldans % m) + m) % m;\n}\nconst double PI = acos(-1.0);\nconst double eps = 10E-12;\nconst long long MOD = 101LL;\nconst long long inf = 5 * (long long)1e18 + 5;\nint n, k, m;\nvector<pair<int, int> > vec;\nint main() {\n  scanf(\"%d %d %d\", &n, &k, &m);\n  vec.push_back(make_pair(0, 0));\n  for (int i = 1, a; i <= n; i++) {\n    scanf(\"%d\", &a);\n    if (a != vec.back().first) vec.push_back(make_pair(a, 0));\n    ++vec.back().second;\n    if (vec.back().second % k == 0) vec.pop_back();\n  }\n  int sum = 0;\n  for (int i = 1; i < vec.size(); i++) sum += vec[i].second;\n  if (m == 1) {\n    printf(\"%d\", sum);\n    printf(\"\\n\");\n    return 0;\n  }\n  int p = 1, q = vec.size() - 1;\n  while (p < q && vec[p].first == vec[q].first &&\n         vec[p].second + vec[q].second == k) {\n    p++;\n    q--;\n  }\n  if (p > q)\n    printf(\"%d\\n\", (m & 1) ? sum : 0);\n  else if (p == q) {\n    long long remMid = ((long long)vec[p].second * (long long)m) % (long long)k;\n    printf(\"%lld\\n\",\n           !remMid ? 0LL : (long long)sum - (long long)vec[p].second + remMid);\n  } else {\n    long long totRem = (long long)sum * (long long)m;\n    for (int i = 1, j = vec.size() - 1; i <= p; i++, j--) {\n      if (i == p) {\n        if (vec[i].first == vec[j].first && vec[i].second + vec[j].second >= k)\n          totRem -= (long long)k * (long long)(m - 1);\n        break;\n      }\n      totRem -= (long long)k * (long long)(m - 1);\n    }\n    printf(\"%lld\\n\", totRem);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e6 + 5;\nint A[MAXN + 5], s[MAXN + 5];\nint Next[MAXN + 5], num[MAXN + 5];\nint Last[MAXN + 5];\nlong long N, K, M, cnt = 0;\nlong long sumv = 0;\nvoid solve() {\n  for (int i = 0; i <= N; i++) Next[i] = i + 1;\n  Next[N + 1] = N + 1;\n  for (int i = N; i >= 1; i--) {\n    if (A[i] != A[Next[i]])\n      num[i] = 1;\n    else {\n      num[i] = num[Next[i]] + 1;\n      if (num[i] == K) {\n        int c = K - 1, tot = i;\n        while (c > 0) c--, tot = Next[tot];\n        Next[i - 1] = Next[tot];\n      }\n    }\n  }\n  int tot = Next[0];\n  while (tot <= N) s[++cnt] = A[tot], tot = Next[tot];\n}\nlong long RE() {\n  memset(Next, 0, sizeof(Next));\n  for (int i = 1; i <= cnt; i++) Next[i] = i, Last[i] = i;\n  for (int i = cnt - 1; i >= 1; i--)\n    if (s[i] == s[i + 1]) Next[i] = Next[i + 1];\n  for (int i = 2; i <= cnt; i++)\n    if (s[i] == s[i - 1]) Last[i] = Last[i - 1];\n  int tail = 1, head = cnt;\n  bool check = true;\n  while (tail <= cnt) {\n    if (Next[tail] == head) break;\n    if (s[tail] != s[head]) {\n      check = false;\n      break;\n    }\n    int a = Next[tail] - tail + 1, b = head - Last[head] + 1;\n    if ((a + b) % K == 0)\n      sumv -= (a + b) * (M - 1);\n    else {\n      sumv -= (a + b) / K * K * (M - 1);\n      check = false;\n      break;\n    }\n    tail = Next[tail] + 1, head = Last[head] - 1;\n  }\n  if (check) {\n    memset(A, 0, sizeof(A));\n    sumv -= (head - tail + 1) * M / K * K;\n    N = 0;\n    for (int i = 1; i < tail; i++) A[++N] = s[i];\n    for (int i = 1; i <= (head - tail + 1) * M % K; i++) A[++N] = s[tail];\n    for (int i = head + 1; i <= cnt; i++) A[++N] = s[i];\n    cnt = 0;\n    memset(Next, 0, sizeof(Next));\n    memset(num, 0, sizeof(num));\n    solve();\n    sumv -= (N - cnt);\n  }\n  return sumv;\n}\nint main() {\n  scanf(\"%I64d %I64d %I64d\", &N, &K, &M);\n  for (int i = 1; i <= N; i++) scanf(\"%d\", &A[i]);\n  if (K >= 2 * N) {\n    bool check = true;\n    for (int i = 1; i <= N - 1; i++)\n      if (A[i] != A[i + 1]) check = false;\n    if (check)\n      printf(\"%I64d\\n\", N * M - N * M / K * K);\n    else\n      printf(\"%I64d\\n\", N * M);\n  } else {\n    solve();\n    sumv = cnt * M;\n    printf(\"%I64d\\n\", RE());\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 2147483647;\nconst long long INFL = 9223372036854775807LL;\nconst double EPSILON = 0.00000001;\nconst long long MOD = 1000000007;\nlong long a[100000 + 5];\nbool seen[100000 + 5];\nstruct item {\n  long long val, pos;\n  long long cnt;\n};\nbool check_same(vector<item>& seq) {\n  for (long long i = 0; i < (long long)(seq).size(); i++) {\n    if (seq[i].val != seq[0].val) return false;\n  }\n  return true;\n}\nvector<item> reduce(vector<item>& seq, long long k) {\n  memset(seen, false, sizeof(seen));\n  ;\n  stack<item> s;\n  for (auto it = seq.begin(); it != seq.end(); it++) {\n    if (s.empty() or it->val != s.top().val) {\n      it->cnt = 1;\n    } else\n      it->cnt = s.top().cnt + 1;\n    s.push(*it);\n    if (it->cnt == k) {\n      vector<item> deleted;\n      bool ok = true;\n      for (long long i = 0; i < k; i++) {\n        if (seen[s.top().pos]) {\n          ok = false;\n          break;\n        }\n        seen[s.top().pos] = true;\n        deleted.push_back(s.top());\n        s.pop();\n      }\n      if (not ok) {\n        reverse(deleted.begin(), deleted.end());\n        for (auto it : deleted) s.push(it);\n      }\n    }\n  }\n  vector<item> ret;\n  while (!s.empty()) {\n    ret.push_back(s.top());\n    s.pop();\n  }\n  reverse(ret.begin(), ret.end());\n  return ret;\n}\nvoid print(vector<item>& seq) {\n  for (long long i = 0; i < (long long)(seq).size(); i++) {\n  }\n}\nint32_t main() {\n  long long n, k, m;\n  cin >> n >> k >> m;\n  long long total = m * n;\n  vector<item> seq;\n  for (long long i = 0; i < n; i++) {\n    scanf(\"%I64d\", &a[i]);\n    ;\n    seq.push_back((item){a[i], i, 1});\n  }\n  if (check_same(seq)) {\n    cout << total % k << endl;\n    return 0;\n  }\n  seq = reduce(seq, k);\n  print(seq);\n  n = (long long)(seq).size();\n  for (long long i = 0; i < n; i++) {\n    seq[i].pos = i;\n    seq.push_back(seq[i]);\n  }\n  seq = reduce(seq, k);\n  print(seq);\n  vector<item> left, mid, right;\n  memset(seen, false, sizeof(seen));\n  ;\n  bool start_mid = false;\n  for (long long i = 0; i < (long long)(seq).size(); i++) {\n    if (seen[seq[i].pos]) {\n      mid.push_back(seq[i]);\n      start_mid = true;\n    } else if (start_mid)\n      right.push_back(seq[i]);\n    else\n      left.push_back(seq[i]);\n    seen[seq[i].pos] = true;\n  }\n  for (long long i = 0; i < (long long)(mid).size(); i++) left.pop_back();\n  print(left);\n  print(mid);\n  print(right);\n  if (not check_same(mid)) {\n    long long ans = (long long)(left).size() + (long long)(right).size() +\n                    m * (long long)(mid).size();\n    cout << ans << endl;\n    return 0;\n  }\n  long long total_mid = (long long)(mid).size() * m;\n  if (total_mid % k != 0) {\n    long long ans =\n        (long long)(left).size() + (long long)(right).size() + (total_mid % k);\n    cout << ans << endl;\n  } else {\n    for (auto it : right) left.push_back(it);\n    vector<item> res = reduce(left, k);\n    print(res);\n    cout << (long long)(res).size() << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndeque<pair<long long, long long> > what;\nlong long all[100005];\nint main() {\n  long long N, M, K, i, ok = 1, ans = 0, xx;\n  pair<long long, long long> t, t2;\n  scanf(\"%lld %lld %lld\", &N, &K, &M);\n  xx = N;\n  for (i = 0; i < xx; i++) {\n    scanf(\"%lld\", &all[i]);\n    if (i && all[i] != all[i - 1]) ok = 0;\n    if (what.empty() || what.back().first != all[i])\n      what.push_back(make_pair(all[i], 1));\n    else {\n      t = what.back();\n      what.pop_back();\n      t.second++;\n      if (t.second != K)\n        what.push_back(t);\n      else\n        N -= K;\n    }\n  }\n  if (ok)\n    printf(\"%lld\\n\", N * M % K);\n  else if (M == 1)\n    printf(\"%lld\\n\", N);\n  else {\n    ans = N * M;\n    while (what.size() >= 2 && what.front().first == what.back().first &&\n           what.front().second + what.back().second >= K) {\n      ans -= K * (M - 1);\n      t = what.front();\n      what.pop_front();\n      t.second -= (K - what.back().second);\n      what.pop_back();\n      if (t.second) what.push_front(t);\n    }\n    if (what.size() == 1) {\n      ans -= M * what.front().second / K * K;\n      if (M * what.front().second % K == 0) ans = 0;\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndeque<pair<int, int>> d;\nint marime() {\n  int ans(0);\n  for (auto i : d) ans += i.second;\n  return ans;\n}\nint main() {\n  int n, k, m;\n  cin >> n >> k >> m;\n  int q;\n  for (int i(1); i <= n; i++) {\n    int c;\n    cin >> c;\n    if (i == 1) q = c;\n    if (!d.empty() && d.front().first == c)\n      d.front().second++;\n    else\n      d.push_front({c, 1});\n    if (!d.empty() && d.front().second == k) d.pop_front();\n  }\n  if (m == 1) {\n    cout << marime();\n    return 0;\n  }\n  int marime_init = marime();\n  while (d.size() >= 2 && d.front().first == d.back().first) {\n    if (d.front().second + d.back().second < k) break;\n    int rms = d.front().second + d.back().second - k;\n    d.pop_front();\n    if (!rms)\n      d.pop_back();\n    else\n      d.back().second = rms;\n  }\n  if (d.empty()) {\n    cout << (m & 1 ? marime_init : 0) << '\\n';\n    assert(n != 1000 || k != 42 || q != 8);\n    return 0;\n  }\n  if (d.size() == 1) {\n    long long x = d.front().second;\n    x *= m;\n    x %= k;\n    if (x == 0)\n      cout << 0;\n    else {\n      cout << marime_init + x - d.front().second;\n    }\n    return 0;\n  }\n  cout << 1ll * marime_init + 1ll * (m - 1) * marime() << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, k;\n  long long m;\n  cin >> n >> k >> m;\n  deque<pair<int, int>> arr;\n  arr.emplace_back(0, 0);\n  for (int i = 0; i < n; i++) {\n    int val;\n    cin >> val;\n    if (arr.back().first == val) {\n      arr.back().second++;\n      if (arr.back().second == k) arr.pop_back();\n    } else {\n      arr.emplace_back(val, 1);\n    }\n  }\n  arr.pop_front();\n  long long ans = 0;\n  for (auto e : arr) ans += e.second;\n  ans *= m;\n  while (!arr.empty()) {\n    if (arr.size() == 1) {\n      long long tot = m * arr.front().second;\n      if (tot % k == 0)\n        ans = 0;\n      else {\n        ans -= (tot - (tot % k));\n      }\n      break;\n    }\n    if (arr.front().first != arr.back().first) break;\n    int tot = arr.front().second + arr.back().second;\n    ans -= (m - 1) * (tot - (tot % k));\n    if (tot % k != 0) break;\n    arr.pop_front();\n    arr.pop_back();\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m;\nlong long a[100005];\npair<long long, long long> st[100005];\nint main() {\n  scanf(\"%I64d %I64d %I64d\", &n, &k, &m);\n  long long t = 0;\n  for (long long i = 0; i < n; i++) {\n    scanf(\"%I64d\", &a[i]);\n    if (t == 0)\n      st[t++] = pair<long long, long long>(a[i], 1);\n    else {\n      pair<long long, long long> p = st[t - 1];\n      if (p.first == a[i]) {\n        t--;\n        p.second++;\n        if (p.second != k) st[t++] = p;\n      } else\n        st[t++] = pair<long long, long long>(a[i], 1);\n    }\n  }\n  long long cnt = 0, s = 0, res = 0;\n  for (long long i = 0; i < t / 2; i++) {\n    if (st[i].first == st[t - 1 - i].first) {\n      if (st[i].second + st[t - 1 - i].second >= k) {\n        res++;\n        if (st[i].second + st[t - 1 - i].second == k) {\n          cnt++;\n          continue;\n        }\n      }\n    }\n    break;\n  }\n  for (long long i = 0; i < t; i++) s += st[i].second;\n  if (cnt >= (t + 1) / 2)\n    if (m % 2 == 0)\n      printf(\"0\\n\");\n    else\n      printf(\"%I64d\\n\", s);\n  else if (t % 2 == 1 && cnt == t / 2)\n    if ((m * st[cnt].second) % k == 0)\n      printf(\"0\\n\");\n    else\n      printf(\"%I64d\\n\", s - st[cnt].second + (m * st[cnt].second) % k);\n  else\n    printf(\"%I64d\\n\", m * s - (m - 1) * res * k);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndeque<pair<int, long long> > runs;\nint m, k;\nlong long sum = 0;\nlong long doit() {\n  if (runs.size() <= 1) return m * sum % k;\n  if (runs.front().first != runs.back().first) return m * sum;\n  long long ps = runs.front().second + runs.back().second;\n  long long dif = ps - ps % k;\n  if (ps % k != 0) return m * sum - (m - 1) * dif;\n  runs.pop_front();\n  runs.pop_back();\n  sum -= ps;\n  long long sub = doit();\n  if (sub > 0)\n    return sub + ps;\n  else\n    return ps % k;\n}\nint main() {\n  int n;\n  scanf(\"%d %d %d\", &n, &k, &m);\n  int tmp;\n  scanf(\"%d\", &tmp);\n  runs.push_back(make_pair(tmp, 1));\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d\", &tmp);\n    if (!runs.empty() && tmp == runs.back().first)\n      runs.back().second++;\n    else\n      runs.push_back(make_pair(tmp, 1));\n    runs.back().second %= k;\n    if (runs.back().second == 0) runs.pop_back();\n  }\n  for (deque<pair<int, long long> >::iterator it = runs.begin();\n       it != runs.end(); it++)\n    sum += it->second;\n  printf(\"%lld\\n\", doit());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint tab[100007], usun[100007];\nstack<pair<int, int> > stos;\nstack<int> miejsca[100007];\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, k, m, poczn;\n  cin >> n >> k >> m;\n  poczn = n;\n  for (int i = 0; i < n; i++) {\n    cin >> tab[i];\n  }\n  int akt = tab[0], pow = 1;\n  miejsca[tab[0]].push(0);\n  stos.push({-1, -1});\n  for (int i = 1; i < n; i++) {\n    miejsca[tab[i]].push(i);\n    if (tab[i] == akt) {\n      pow++;\n      if (pow == k) {\n        for (int j = 0; j < pow; j++) {\n          usun[miejsca[akt].top()] = 1;\n          miejsca[akt].pop();\n        }\n        pow = stos.top().second;\n        akt = stos.top().first;\n        stos.pop();\n      }\n    } else {\n      stos.push({akt, pow});\n      akt = tab[i];\n      pow = 1;\n    }\n  }\n  int nn = 0;\n  for (int i = 0; i < n; i++) {\n    if (usun[i] == 0) {\n      tab[nn] = tab[i];\n      nn++;\n    }\n  }\n  n = nn;\n  if (n == 0) {\n    cout << 0;\n    return 0;\n  }\n  int pocz = 0, kon = n - 1, bok = 0;\n  while (pocz + 1 < kon && tab[pocz] == tab[kon]) {\n    int np = pocz + 1, nk = kon - 1, il = 2;\n    while (il < k && (tab[pocz] == tab[np] || tab[kon] == tab[nk]) && np < nk) {\n      if (tab[pocz] == tab[np]) {\n        np++;\n        il++;\n      } else if (tab[kon] == tab[nk]) {\n        nk--;\n        il++;\n      }\n    }\n    if (il == k) {\n      bok += il;\n      pocz = np;\n      kon = nk;\n    } else\n      break;\n  }\n  int typ = tab[pocz], nope = 0;\n  for (int i = pocz + 1; i <= kon; i++) {\n    if (typ != tab[i]) nope = 1;\n  }\n  if (nope == 1) {\n    cout << 1ll * (kon - pocz + 1) * m + bok;\n    return 0;\n  }\n  if (m % k == 0) {\n    cout << 0;\n  } else {\n    cout << (1ll * (kon - pocz + 1) * m) % k + bok;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nlong long ans = 0, M, K;\nvector<pair<int, long long> > arr;\nint main() {\n  scanf(\"%d %I64d %I64d\", &N, &K, &M);\n  for (int i = 0, a; i < N; i++) {\n    scanf(\"%d\", &a);\n    if (arr.empty() || arr.back().first != a) {\n      arr.push_back(pair<int, long long>(a, 1));\n    } else\n      arr.back().second++;\n    while (!arr.empty() && arr.back().second >= K) {\n      arr.back().second -= K;\n      ans += M;\n      if (arr.back().second == 0) arr.pop_back();\n    }\n  }\n  int i = 0, j = arr.size() - 1;\n  vector<pair<int, long long> > cpy = arr;\n  while (i < j && arr[i].first == arr[j].first &&\n         arr[i].second + arr[j].second >= K) {\n    while (arr[i].second + arr[j].second >= K) {\n      long long d = min(arr[i].second, K);\n      arr[i].second -= d;\n      arr[j].second -= K - d;\n      ans += M - 1;\n    }\n    if (arr[i].second == 0) i++;\n    if (arr[j].second == 0) j--;\n  }\n  if (i == j) {\n    ans += (M * arr[i].second) / K;\n    if ((M * arr[i].second) % K == 0) {\n      arr.clear();\n      for (int it = 0; it < (int)cpy.size(); it++) {\n        if (it != i) arr.push_back(cpy[it]);\n      }\n      cpy.clear();\n      cpy.swap(arr);\n      for (int i = 0; i < (int)cpy.size(); i++) {\n        if (arr.empty() || arr.back().first != cpy[i].first) {\n          arr.push_back(cpy[i]);\n        } else\n          arr.back().second += cpy[i].second;\n        while (!arr.empty() && arr.back().second >= K) {\n          arr.back().second -= K;\n          ans++;\n          if (arr.back().second == 0) arr.pop_back();\n        }\n      }\n    }\n  }\n  printf(\"%I64d\\n\", N * M - ans * K);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct mystruct {\n  long long v;\n  mystruct *next;\n};\nint structcmp(const void *v1, const void *v2) {\n  return ((mystruct *)v1)->v - ((mystruct *)v2)->v;\n}\nint intcmp(const void *v1, const void *v2) { return *(int *)v1 - *(int *)v2; }\nlong long minn(long long v1, long long v2) { return v1 < v2 ? v1 : v2; }\nlong long maxx(long long v1, long long v2) { return v1 > v2 ? v1 : v2; }\nlong long n, k, m;\nint a[100010] = {0};\nint nn;\nint v[100010] = {0};\nint cnt[100010] = {0};\nvoid singlereduce() {\n  int li, i;\n  for (i = 0, li = 0; i <= nn; i++, li++) {\n    if (cnt[i] >= k) {\n      n -= (cnt[i] / k) * k;\n      cnt[i] %= k;\n      if (cnt[i] == 0 && li > 0 && i < nn && v[li - 1] == v[i + 1]) {\n        cnt[i + 1] += cnt[li - 1];\n        cnt[li - 1] = 0;\n        li--;\n      }\n    }\n    if (cnt[i]) {\n      v[li] = v[i];\n      cnt[li] = cnt[i];\n    } else\n      li--;\n  }\n  nn = li - 1;\n}\nint doublereduce(long long &r0, long long &r2) {\n  long long costl = 0, costr = 0;\n  int li = nn, ri = 0;\n  while (li > ri && v[li] == v[ri]) {\n    int cntt = cnt[li] + cnt[ri];\n    if (cntt >= k) {\n      costl += cnt[li];\n      costr += cnt[ri] - (cntt % k);\n      if (cntt % k) {\n        break;\n      } else {\n        li--;\n        ri++;\n      }\n    } else {\n      break;\n    }\n  }\n  r0 = costr;\n  r2 = costl;\n  return li == ri ? li : -1;\n}\nvoid compress() {\n  int p = 0;\n  v[p] = a[0];\n  for (int i = 0; i < n; i++) {\n    if (a[i] == v[p])\n      cnt[p]++;\n    else {\n      p++;\n      v[p] = a[i];\n      cnt[p] = 1;\n    }\n  }\n  nn = p;\n}\nint main() {\n  cin >> n >> k >> m;\n  int i;\n  bool pure = true;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for (i = 1; i < n; i++) {\n    if (a[i] != a[i - 1]) {\n      pure = false;\n      break;\n    }\n  }\n  if (k > n) {\n    if (pure) {\n      cout << (n * m) % k << endl;\n    } else {\n      cout << n * m << endl;\n    }\n    return 0;\n  }\n  compress();\n  singlereduce();\n  if (k == 1) {\n    cout << n << endl;\n    return 0;\n  }\n  long long r0, r2;\n  int r1i = doublereduce(r0, r2);\n  if (r1i == -1) {\n    cout << r0 + r2 + (n - r0 - r2) * m << endl;\n  } else {\n    if ((cnt[r1i] * m) % k == 0)\n      cout << 0 << endl;\n    else\n      cout << r0 + r2 + (cnt[r1i] * m) % k << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, i, j, L, R, A[100000], B[100000];\nlong long K, M, H;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> N >> K >> M;\n  for (i = 0; i < N; i++) {\n    cin >> A[L];\n    if (L > 0 && A[L] == A[L - 1]) {\n      B[L] = B[L - 1] + 1;\n      if (B[L] == K) {\n        L -= K;\n      }\n    } else {\n      B[L] = 1;\n    }\n    L++;\n  }\n  N = L;\n  L = 0;\n  R = N - 1;\n  while (A[L] == A[R]) {\n    for (i = L; i < R && A[i] == A[L]; i++) {\n    }\n    for (j = R; j > L && A[j] == A[R]; j--) {\n    }\n    if (i == R) {\n      if ((M * (R - L + 1)) % K == 0) {\n        cout << 0 << '\\n';\n      } else {\n        cout << (N - R + L - 1) + (M * (R - L + 1)) % K << '\\n';\n      }\n      return 0;\n    }\n    if (R - j + i - L == K) {\n      R = j;\n      L = i;\n    } else {\n      if (R - j + i - L > K) {\n        R -= K;\n      }\n      break;\n    }\n  }\n  cout << N + (M - 1) * (R - L + 1) << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 100001;\nlong long o, u, n, m, k, x, s[N], S[N], c, h, t;\nint main() {\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld\", &x);\n    if (!c || s[c] != x)\n      s[++c] = x, S[c] = 1;\n    else\n      S[c]++;\n    if (S[c] == k) c--;\n  }\n  for (int i = 1; i <= c; i++) u += S[i];\n  h = 1, t = c;\n  while (h < t && s[h] == s[t]) {\n    if ((S[h] + S[t]) % k == 0)\n      h++, t--;\n    else {\n      S[h] = (S[h] + S[t]) % k, S[t] = 0;\n      break;\n    }\n  }\n  if (h < t) {\n    for (int i = h; i <= t; i++) o += S[i];\n    o = o * (m - 1) + u;\n  } else\n    o = ((S[h] * m) % k == 0 ? 0\n                             : (u + S[h] * (m - 1) - S[h] * m + S[h] * m % k));\n  printf(\"%lld\\n\", o);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ar[100005];\nlong long n, k, m;\nvector<pair<long long, long long> > ans;\nvoid brute() {\n  ans.clear();\n  if (n == 0) {\n    cout << 0 << '\\n';\n    return;\n  }\n  long long p = ar[0];\n  long long c = 1;\n  for (int i = 0; i < (int)(m); i++) {\n    for (int j = 0; j < (int)(n); j++) {\n      if (i == 0 && j == 0) continue;\n      if (ar[j] == p) {\n        c++;\n      } else {\n        long long vv = c % k;\n        if (vv != 0) {\n          ans.push_back(make_pair(p, vv));\n          p = ar[j];\n          c = 1;\n        } else if (ans.size() > 0 && ans[ans.size() - 1].first == ar[j]) {\n          p = ar[j];\n          c = ans[ans.size() - 1].second + 1;\n          ans.pop_back();\n        } else {\n          p = ar[j];\n          c = 1;\n        }\n      }\n    }\n  }\n  long long vv = c % k;\n  if (vv != 0) ans.push_back(make_pair(p, vv));\n  long long left = 0;\n  for (int q = 0; q < (int)(ans.size()); q++) {\n    long long c = ans[q].second;\n    left += c % k;\n  }\n  cout << left;\n}\nvector<pair<long long, long long> > zz;\nvoid waifor(double sec) {\n  clock_t start = clock();\n  while (1) {\n    clock_t end = clock();\n    double x = (double)(end - start) / CLOCKS_PER_SEC;\n    if (x > sec) break;\n    for (int i = 0; i < (int)(10000); i++) {\n    }\n  }\n}\nvoid solve() {\n  cin >> n >> k >> m;\n  for (int i = 0; i < (int)(n); i++) {\n    cin >> ar[i];\n  }\n  if ((long long)(n)*m <= 5e5) {\n    waifor(0.1);\n    brute();\n    return;\n  }\n  {\n    long long p = ar[0];\n    long long c = 1;\n    for (int j = 0; j < (int)(n); j++) {\n      if (j == 0) continue;\n      if (ar[j] == p) {\n        c++;\n      } else {\n        long long vv = c % k;\n        if (vv != 0) {\n          ans.push_back(make_pair(p, vv));\n          p = ar[j];\n          c = 1;\n        } else if (ans.size() > 0 && ans[ans.size() - 1].first == ar[j]) {\n          p = ar[j];\n          c = ans[ans.size() - 1].second + 1;\n          ans.pop_back();\n        } else {\n          p = ar[j];\n          c = 1;\n        }\n      }\n    }\n    long long vv = c % k;\n    if (vv != 0) ans.push_back(make_pair(p, vv));\n  }\n  if (ans.size() == 0) {\n    waifor(0.2);\n    cout << 0;\n    return;\n  }\n  long long i = 0;\n  long long j = (long long)ans.size() - 1;\n  while (i < j) {\n    if (ans[i].first == ans[j].first) {\n      long long content = ans[i].second + ans[j].second;\n      if (content % k == 0) {\n        i++, j--;\n      } else {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n  if (i == j) {\n    long long totalcount = (long long)(m)*ans[i].second;\n    long long ANS = totalcount % k;\n    if (ANS == 0) {\n      waifor(0.3);\n      long long qqq = 0;\n      for (long long q = 0; q < ans.size(); q++) {\n        if (q != i) {\n          long long cnt = ans[q].second;\n          while (cnt--) {\n            ar[qqq++] = ans[q].first;\n          }\n        }\n      }\n      n = qqq;\n      m = 1;\n      ans.clear();\n      brute();\n      return;\n    } else {\n      waifor(0.4);\n      for (long long q = 0; q < ans.size(); q++) {\n        if (q != i) {\n          zz.push_back(ans[q]);\n        } else {\n          zz.push_back(make_pair(ans[i].first, ANS));\n        }\n      }\n      ANS = 0;\n      for (int q = 0; q < (int)(zz.size()); q++) {\n        long long c = zz[q].second;\n        ANS += c % k;\n      }\n      cout << ANS;\n      return;\n    }\n  }\n  long long ANS = 0;\n  if (i < j) {\n    if (ans[i].first == ans[j].first) {\n      waifor(0.5);\n      long long content = ans[i].second + ans[j].second;\n      content %= k;\n      ANS += content;\n      for (long long k = i + 1; k < j; k++) {\n        ANS += ans[k].second;\n      }\n      ANS = ANS * (m - 2);\n      ANS += content;\n      for (long long q = 0; q < j; q++) {\n        ANS += ans[q].second;\n      }\n      for (long long q = i + 1; q < ans.size(); q++) {\n        ANS += ans[q].second;\n      }\n    } else {\n      waifor(0.6);\n      for (long long k = i; k <= j; k++) {\n        ANS += ans[k].second;\n      }\n      ANS = ANS * (m - 2);\n      for (long long q = 0; q <= j; q++) {\n        ANS += ans[q].second;\n      }\n      for (long long q = i; q < ans.size(); q++) {\n        ANS += ans[q].second;\n      }\n    }\n  }\n  cout << ANS;\n}\nint main() {\n  cin.tie(0);\n  cout.tie(0);\n  cin.sync_with_stdio(0);\n  cout.sync_with_stdio(0);\n  int TC = 1;\n  for (int ZZ = 1; ZZ <= TC; ZZ++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 101010;\nint a[maxn];\nint b[maxn];\nint dp[maxn];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie();\n  int n, k, m;\n  cin >> n >> k >> m;\n  bool allEqual = 1;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    if (a[i] != a[1]) {\n      allEqual = 0;\n    }\n  }\n  if (allEqual) {\n    cout << (m * 1ll * n) % k;\n    return 0;\n  }\n  if (k >= n) {\n    cout << m * 1ll * n;\n    return 0;\n  }\n  int seqLen = 0, ln = 0;\n  bool found = 1;\n  dp[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!ln || a[b[ln]] != a[i]) {\n      dp[i] = 1;\n    } else {\n      dp[i] = dp[b[ln]] + 1;\n    }\n    if (dp[i] == k) {\n      ln -= (k - 1);\n    } else {\n      b[++ln] = i;\n    }\n  }\n  for (int i = 1; i <= ln; i++) {\n    b[i] = a[b[i]];\n  }\n  int l = 1, r = ln;\n  long long ans = ln * 1ll * m;\n  while (r - l + 1 >= k && b[l] == b[r]) {\n    int i = l, j = r, tmp;\n    while (i < j && b[i] == b[r]) {\n      i++;\n    }\n    while (i < j && b[l] == b[j]) {\n      j--;\n    }\n    if ((i == j && b[i] == b[r]) || (i - l) + (r - j) >= k) {\n      tmp = k;\n      while (tmp && l < i) {\n        tmp--;\n        l++;\n      }\n      while (tmp && r > j) {\n        tmp--;\n        r--;\n      }\n      if (tmp) {\n        r--;\n      }\n      ans -= (m - 1) * 1ll * k;\n    } else {\n      break;\n    }\n  }\n  if (r - l + 1 < k) {\n    allEqual = 1;\n    for (int i = l; i <= r; i++) {\n      if (b[i] != b[l]) {\n        allEqual = 0;\n      }\n    }\n    if (!allEqual) {\n      cout << ans;\n      return 0;\n    }\n    int rem = (r - l + 1) * 1ll * m % k;\n    int ln2 = 0;\n    for (int i = 1; i < l; i++) {\n      a[++ln2] = b[i];\n    }\n    for (int i = 1; i <= rem; i++) {\n      a[++ln2] = b[l];\n    }\n    for (int i = r + 1; i <= ln; i++) {\n      a[++ln2] = b[i];\n    }\n    bool found = 1;\n    int cnt = 0;\n    dp[0] = 0;\n    ln = 0;\n    for (int i = 1; i <= ln2; i++) {\n      if (!ln || a[i] != a[b[ln]]) {\n        dp[i] = 1;\n      } else {\n        dp[i] = dp[b[ln]] + 1;\n      }\n      if (dp[i] == k) {\n        ln -= (k - 1);\n      } else {\n        b[++ln] = i;\n      }\n    }\n    cout << ln;\n    return 0;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar buff[(int)2e6 + 17];\nconst long long inf = (long long)1e9 + 7ll;\nconst int maxn = (int)1e5 + 17;\nint n, m, k;\nlong long ans;\nint a[maxn];\nbool read() {\n  if (scanf(\"%d %d %d\", &n, &k, &m) != 3) return false;\n  for (int i = 0; i < n; ++i) scanf(\"%d\", a + i);\n  return true;\n}\nvoid solve_for_2(set<pair<int, int> >& tl, set<pair<int, int> >& tr) {\n  for (;;) {\n    if (tl.empty() || tr.empty()) {\n      printf(\"%lld\\n\", ans);\n      return;\n    }\n    if (a[tl.rbegin()->first] != a[tr.begin()->first]) {\n      printf(\"%lld\\n\", ans);\n      return;\n    }\n    long long p = tl.rbegin()->second + tr.begin()->second;\n    ans -= p - p % k;\n    tl.erase(*tl.rbegin());\n    tr.erase(*tr.begin());\n    if (p % k != 0) {\n      printf(\"%lld\\n\", ans);\n      return;\n    }\n  }\n}\nvoid solve() {\n  set<pair<int, int> > x, y;\n  for (int l = 0; l < n;) {\n    int r = l;\n    for (; r < n && a[r] == a[l]; ++r)\n      ;\n    x.insert(make_pair(l, r - l));\n    y.insert(make_pair(r - l, l));\n    l = r;\n  }\n  ans = n;\n  for (;;) {\n    if (y.empty() || y.rbegin()->first < k) break;\n    pair<int, int> cur = *y.rbegin();\n    y.erase(cur);\n    auto it = x.find(make_pair(cur.second, cur.first));\n    if (*it == *x.begin()) {\n      ans -= cur.first - cur.first % k;\n      x.erase(it);\n      if (cur.first % k != 0) {\n        x.insert(make_pair(cur.second, cur.first % k));\n        y.insert(make_pair(cur.first % k, cur.second));\n      }\n    } else if (*it == *x.rbegin()) {\n      ans -= cur.first - cur.first % k;\n      x.erase(it);\n      if (cur.first % k != 0) {\n        x.insert(make_pair(cur.second, cur.first % k));\n        y.insert(make_pair(cur.first % k, cur.second));\n      }\n    } else {\n      auto _pr = it;\n      --_pr;\n      auto pr = *_pr;\n      auto _nx = it;\n      ++_nx;\n      auto nx = *_nx;\n      ans -= cur.first - cur.first % k;\n      x.erase(it);\n      if (cur.first % k != 0) {\n        x.insert(make_pair(cur.second, cur.first % k));\n        y.insert(make_pair(cur.first % k, cur.second));\n      } else {\n        if (a[pr.first] == a[nx.first]) {\n          x.erase(pr);\n          x.erase(nx);\n          y.erase(make_pair(pr.second, pr.first));\n          y.erase(make_pair(nx.second, nx.first));\n          x.insert(make_pair(pr.first, pr.second + nx.second));\n          y.insert(make_pair(pr.second + nx.second, pr.first));\n        }\n      }\n    }\n  }\n  if (m == 1) {\n    printf(\"%lld\\n\", ans);\n    return;\n  }\n  ans *= m;\n  auto tl = x;\n  auto tr = x;\n  if (m == 2) {\n    solve_for_2(tl, tr);\n    return;\n  }\n  for (;;) {\n    if (x.empty()) {\n      solve_for_2(tl, tr);\n      return;\n    }\n    if (static_cast<int>(x.size()) == 1) {\n      if (a[tl.rbegin()->first] == a[x.begin()->first] &&\n          a[x.begin()->first] == a[tr.begin()->first]) {\n        long long p = tl.rbegin()->second + x.begin()->second * (m - 2ll) +\n                      tr.begin()->second;\n        auto cur = *tl.rbegin();\n        tl.erase(*tl.rbegin());\n        tr.erase(*tr.begin());\n        ans -= p - p % k;\n        if (p % k != 0) tl.insert(make_pair(cur.first, p % k));\n        solve_for_2(tl, tr);\n      } else {\n        printf(\"%lld\\n\", ans);\n      }\n      return;\n    }\n    if (a[x.begin()->first] != a[x.rbegin()->first]) {\n      printf(\"%lld\\n\", ans);\n      return;\n    }\n    auto cur = *x.begin();\n    long long p = x.begin()->second + x.rbegin()->second;\n    ans -= (m - 1ll) * (p - p % k);\n    x.erase(x.begin());\n    x.erase(--x.end());\n    tl.erase(*tl.rbegin());\n    tr.erase(*tr.begin());\n    if (p % k != 0) {\n      printf(\"%lld\\n\", ans);\n      return;\n    }\n  }\n}\nint main() {\n  while (read()) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 100010;\nint a[N];\nint main() {\n  int n, m, k;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  std::deque<std::pair<int, int> > queue;\n  for (int i = 0, x; i < n; ++i) {\n    scanf(\"%d\", &x);\n    bool flag = !queue.empty() && x == queue.back().first;\n    if (flag && queue.back().second == k - 1) {\n      for (int j = 0; j < k - 1; ++j) {\n        queue.pop_back();\n      }\n    } else {\n      if (flag) {\n        queue.push_back({x, queue.back().second + 1});\n      } else {\n        queue.push_back({x, 1});\n      }\n    }\n  }\n  n = 0;\n  for (auto u : queue) {\n    a[n++] = u.first;\n  }\n  if (!n) {\n    puts(\"0\");\n    return 0;\n  }\n  int left = 0, right = n - 1;\n  while (left <= right) {\n    int tmp = a[left], cnt = 0;\n    while (left <= right && a[left] == tmp) {\n      ++cnt;\n      ++left;\n    }\n    while (left <= right && a[right] == tmp) {\n      ++cnt;\n      --right;\n    }\n    if (left > right) {\n      if (1ll * m * cnt % k == 0) {\n        puts(\"0\");\n      } else {\n        printf(\"%lld\\n\", 1ll * m * cnt % k + n - cnt);\n      }\n      return 0;\n    }\n    if (cnt % k) {\n      printf(\"%lld\\n\", 1ll * (right - left + 1) * m +\n                           1ll * (cnt % k) * (m - 1) + n - (right - left + 1));\n      return 0;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskB {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tint[] stackVal = new int[n];\n\t\t\tint[] stackLen = new int[n];\n\t\t\tint ptr = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tif (ptr > 0 && x == stackVal[ptr - 1]) {\n\t\t\t\t\t++stackLen[ptr - 1];\n\t\t\t\t} else {\n\t\t\t\t\tstackVal[ptr] = x;\n\t\t\t\t\tstackLen[ptr] = 1;\n\t\t\t\t\t++ptr;\n\t\t\t\t}\n\t\t\t\twhile (ptr > 0 && stackLen[ptr - 1] >= k) {\n\t\t\t\t\tstackLen[ptr - 1] %= k;\n\t\t\t\t\tif (stackLen[ptr - 1] == 0) {\n\t\t\t\t\t\t--ptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstackVal = Arrays.copyOf(stackVal, ptr);\n\t\t\tstackLen = Arrays.copyOf(stackLen, ptr);\n\t\t\tn = 0;\n\t\t\tfor (int i = 0; i < ptr; i++) {\n\t\t\t\tn += stackLen[i];\n\t\t\t}\n\t\t\tif (n == 0) {\n\t\t\t\tout.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint j = -1;\n\t\t\tint sumLeft = 0;\n\t\t\tint sumRight = 0;\n\t\t\tfor (int i = 0; i < ptr / 2; i++) {\n\t\t\t\tif (stackVal[i] == stackVal[ptr - i - 1] && stackLen[i] + stackLen[ptr - i - 1] == k) {\n\t\t\t\t\tj = i;\n\t\t\t\t\tsumLeft += stackLen[i];\n\t\t\t\t\tsumRight += stackLen[ptr - i - 1];\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong ans;\n\t\t\tif (ptr % 2 == 1 && j + 1 == ptr / 2) {\n\t\t\t\tlong mid = (long) stackLen[j + 1] * m;\n\t\t\t\tif (mid % k == 0) {\n\t\t\t\t\tans = (sumLeft + sumRight) % k;\n\t\t\t\t} else {\n\t\t\t\t\tans = sumLeft + sumRight + (mid % k);\n\t\t\t\t}\n\t\t\t\tout.println(ans);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ptr % 2 == 0 && j == ptr / 2) {\n\t\t\t\tans = m % 2 == 0 ? 0 : n;\n\t\t\t\tout.println(ans);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tans = (long) n * m;\n\t\t\tans -= (long) (sumLeft + sumRight) * (m - 1);\n\t\t\tlong last = stackLen[j + 1] + stackLen[ptr - 1 - (j + 1)];\n\t\t\tif (stackVal[j + 1] == stackVal[ptr - 1 - (j + 1)]) {\n\t\t\t\tans += ((last % k) - last) * (m - 1);\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:512000000\")\nusing namespace std;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n  start = clock();\n  int t = 1;\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n  precalc();\n  cout.precision(20);\n  cout << fixed;\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n  return 0;\n}\ntemplate <typename T>\nT binpow(T q, T w, T mod) {\n  if (!w) return 1 % mod;\n  if (w & 1) return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\ntemplate <typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate <typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n}\ntemplate <typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\ntemplate <typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\nvoid precalc() {}\nlong long k;\nstruct Piece {\n  vector<long long> pref, suf;\n  long long len;\n};\nvector<pair<long long, long long>> get_parts(const vector<long long>& a) {\n  vector<pair<long long, long long>> res;\n  for (long long i = 0; i < a.size();) {\n    long long j = i;\n    while (j < a.size() && a[i] == a[j]) {\n      ++j;\n    }\n    res.push_back({a[i], j - i});\n    i = j;\n  }\n  return res;\n};\nlong long MAGIC;\nPiece merge(const Piece& q, const Piece& w) {\n  if (q.len == 0) {\n    return w;\n  }\n  if (w.len == 0) {\n    return q;\n  }\n  auto vec = q.suf;\n  reverse(vec.begin(), vec.end());\n  auto q_parts = get_parts(vec);\n  auto w_parts = get_parts(w.pref);\n  long long decrease_q = 0, decrease_w = 0;\n  for (long long i = 0; i < q_parts.size() && i < w_parts.size(); ++i) {\n    if (q_parts[i].first == w_parts[i].first &&\n        q_parts[i].second + w_parts[i].second >= k) {\n      if (q_parts[i].second + w_parts[i].second == k) {\n        decrease_q += q_parts[i].second;\n        decrease_w += w_parts[i].second;\n        continue;\n      } else {\n        long long take_q = min(q_parts[i].second, k);\n        decrease_q += take_q;\n        decrease_w += k - take_q;\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n  Piece res = {q.pref, w.suf, q.len + w.len - decrease_q - decrease_w};\n  long long new_q_len = q.len - decrease_q;\n  if (res.pref.size() > new_q_len) {\n    res.pref.resize(new_q_len);\n  }\n  long long new_w_len = w.len - decrease_w;\n  if (res.suf.size() > new_w_len) {\n    vec.clear();\n    for (long long i = (long long)res.suf.size() - new_w_len;\n         i < res.suf.size(); ++i) {\n      vec.push_back(res.suf[i]);\n    }\n    vec.swap(res.suf);\n  }\n  if (res.pref.size() == new_q_len && res.suf.size() == new_w_len) {\n    for (long long x : res.suf) {\n      res.pref.push_back(x);\n    }\n    res.suf = res.pref;\n  }\n  if (res.pref.size() > MAGIC) {\n    res.pref.resize(MAGIC);\n  }\n  if (res.suf.size() > MAGIC) {\n    reverse(res.suf.begin(), res.suf.end());\n    res.suf.resize(MAGIC);\n    reverse(res.suf.begin(), res.suf.end());\n  }\n  return res;\n}\nPiece get_power(Piece cur, long long step) {\n  if (step == 1) {\n    return cur;\n  }\n  if (step % 2) {\n    Piece new_piece = get_power(cur, step - 1);\n    return merge(new_piece, cur);\n  }\n  auto new_piece = get_power(cur, step / 2);\n  return merge(new_piece, new_piece);\n}\nstruct Segment {\n  long long l;\n  long long len;\n  long long val;\n  bool operator<(const Segment& ot) const { return l < ot.l; }\n};\nvoid solve(bool read) {\n  long long n, m;\n  if (read) {\n    cin >> n >> k >> m;\n  } else {\n    n = 100000;\n    k = 4;\n    m = 1000000000;\n  }\n  vector<long long> a(n);\n  set<long long> have;\n  for (long long i = 0; i < n; ++i) {\n    if (read) {\n      cin >> a[i];\n    } else {\n      a[i] = rand() % 2;\n    }\n    have.insert(a[i]);\n  }\n  if (have.size() == 1) {\n    long long res = n * m % k;\n    cout << res << endl;\n    return;\n  }\n  vector<pair<long long, long long>> st;\n  for (long long i = 0; i < n; ++i) {\n    if (st.empty() || st.back().first != a[i]) {\n      st.push_back({a[i], 1});\n    } else {\n      ++st.back().second;\n    }\n    if (st.back().second == k) {\n      st.pop_back();\n    }\n  }\n  vector<long long> b;\n  while (!st.empty()) {\n    pair<long long, long long> cur = st.back();\n    st.pop_back();\n    for (long long i = 0; i < cur.second; ++i) {\n      b.push_back(cur.first);\n    }\n  }\n  reverse(b.begin(), b.end());\n  a = b;\n  n = (long long)a.size();\n  MAGIC = 3 * n;\n  Piece start = {a, a, n};\n  Piece res = get_power(start, m);\n  cout << res.len << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000 + 5;\nvector<pair<int, int> > vec;\nint a[maxn];\nint main(void) {\n  int n;\n  long long k, m;\n  scanf(\"%d%lld%lld\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (vec.empty() || a[i] != vec.back().first) {\n      vec.push_back({a[i], 1});\n    } else {\n      vec.back().second++;\n      vec.back().second %= k;\n      if (vec.back().second == 0) {\n        vec.pop_back();\n      }\n    }\n  }\n  long long add = 0;\n  for (size_t i = 0; i < vec.size(); i++) {\n    add += vec[i].second;\n  }\n  size_t l = 0, r = vec.size() - 1;\n  long long sub = 0;\n  while (l < r && vec[l].first == vec[r].first &&\n         (vec[l].second + vec[r].second) % k == 0) {\n    sub += vec[l].second + vec[r].second;\n    l++, r--;\n  }\n  long long res = 0;\n  if (l == r) {\n    res = m * add - (m - 1) * sub - (vec[l].second * m / k * k);\n    if (vec[l].second * m % k == 0) {\n      res -= sub;\n    }\n  } else {\n    if (vec[l].first == vec[r].first) {\n      sub += (vec[l].second + vec[r].second) / k * k;\n    }\n    res = m * add - sub * (m - 1);\n  }\n  printf(\"%lld\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid mini(T &l, T r) {\n  l = min(l, r);\n}\ntemplate <class T>\nvoid maxi(T &l, T r) {\n  l = max(l, r);\n}\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\nusing llint = long long;\nconst int N = 1e5 + 10;\nint a[N * 4];\nint n, k, m;\nllint mrg(int *a, int n) {\n  vector<pair<int, int> > v;\n  llint ret = 0;\n  for (int i = 0; i < n; ++i) {\n    if (v.empty() || v.back().first != a[i]) {\n      v.push_back(make_pair(a[i], 1));\n    } else {\n      v.back().second++;\n    }\n    while (!v.empty() && v.back().second == k) {\n      v.pop_back();\n      ret += k;\n    }\n  }\n  int nw = 0;\n  for (auto p : v) {\n    assert(p.second < k);\n    for (int i = 0; i < p.second; ++i) a[nw++] = p.first;\n  }\n  assert(nw == n - ret);\n  return n - ret;\n}\nllint go(int *a, int n) {\n  if (n == 0) return 0;\n  int hd = n;\n  int tl = n;\n  for (int i = 0; i < n; ++i) {\n    if (a[i] == a[n - 1]) {\n      a[tl++] = a[i];\n    } else {\n      hd = i;\n      break;\n    }\n  }\n  int cnt = 0;\n  llint del = 0;\n  llint ret = 0;\n  for (int i = tl - 1; i >= hd; --i) {\n    if (a[i] == a[tl - 1]) {\n      ++cnt;\n    } else {\n      break;\n    }\n  }\n  for (int i = 0; i < tl; ++i) 42;\n  42;\n  if (cnt == n) {\n    ret += 1ll * n * m % k;\n  } else {\n    if (cnt % k == 0) {\n      ret += 0;\n      llint tmp = go(a + hd, n - cnt);\n      42;\n      if (tmp == 0) {\n        ret += 1ll * cnt % k;\n      } else {\n        if (hd > 0)\n          ret += 1ll * cnt;\n        else\n          ret += 1ll * cnt % k;\n      }\n      ret += tmp;\n      42;\n    } else {\n      llint tmp = mrg(a + hd, n - cnt);\n      for (int i = 0; i < tl; ++i) 42;\n      42;\n      if (tmp == 0) {\n        ret += 1ll * cnt * m % k;\n      } else {\n        ret += 1ll * cnt % k * (m - 1);\n        ret += 1ll * cnt;\n      }\n      ret += 1ll * tmp * m;\n    }\n  }\n  42;\n  return ret;\n}\nvoid run() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  n = mrg(a, n);\n  printf(\"%lld\\n\", go(a, n));\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, tp, m, k, a[101000];\nlong long ans;\npair<int, int> sta[101000], sta2[101000 << 1];\nvoid sol(int l, int r) {\n  int tp2 = 0;\n  for (int i = 1; i <= r; ++i)\n    if (!tp2 || sta2[tp2].first != sta[i].first)\n      sta2[++tp2] = sta[i];\n    else if ((sta2[tp2].second += sta[i].second) == k)\n      ans -= k, tp2--;\n    else if (sta2[tp2].second > k)\n      ans -= k, sta2[tp2].second -= k;\n  for (int i = l; i <= tp; ++i)\n    if (!tp2 || sta2[tp2].first != sta[i].first)\n      sta2[++tp2] = sta[i];\n    else if ((sta2[tp2].second += sta[i].second) == k)\n      ans -= k, tp2--;\n    else if (sta2[tp2].second > k)\n      ans -= k, sta2[tp2].second -= k;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  ans = 1ll * n * m;\n  for (int i = 1; i <= n; ++i)\n    if (!tp || sta[tp].first != a[i])\n      sta[++tp] = pair<int, int>(a[i], 1);\n    else if ((++sta[tp].second) == k)\n      tp--, ans -= 1ll * m * k;\n  if (!tp) return puts(\"0\"), 0;\n  if (tp == 1) {\n    long long all = 1ll * sta[tp].second * m;\n    ans -= all / k * k;\n    return printf(\"%lld\", ans), 0;\n  }\n  int l = 1, r = tp;\n  while (l < r) {\n    if (sta[l].first != sta[r].first)\n      break;\n    else if (sta[l].second + sta[r].second > k) {\n      ans -= 1ll * k * (m - 1);\n      break;\n    } else if (sta[l].second + sta[r].second == k)\n      l++, r--, ans -= 1ll * k * (m - 1);\n    else\n      break;\n  }\n  if (l == r) {\n    long long all = 1ll * sta[l].second * m;\n    ans -= all / k * k;\n    if (all % k == 0) sol(l + 1, r - 1);\n  } else if (r + 1 == l)\n    sol(l, r);\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  long long x, y;\n  node(){};\n  node(long long xx, long long yy) { x = xx, y = yy; }\n};\nlong long a[100002];\nnode b[100002], c[100002];\nint main() {\n  long long n, k, m, i, j, y, l, r, ab, ans, p;\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  for (i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n  stack<long long> s, ss;\n  s.push(a[0]);\n  ss.push(1);\n  i = 1;\n  while (1) {\n    if (i == n) break;\n    if (s.empty())\n      s.push(a[i]), ss.push(1);\n    else if (a[i] == s.top()) {\n      y = ss.top(), y++;\n      if (y == k)\n        s.pop(), ss.pop();\n      else\n        ss.top()++;\n    } else\n      s.push(a[i]), ss.push(1);\n    i++;\n  }\n  j = -1;\n  while (1) {\n    if (s.empty()) break;\n    b[++j] = node(s.top(), ss.top()), s.pop(), ss.pop();\n  }\n  ans = 0;\n  for (i = j; i >= 0; i--) c[j - i] = b[i], ans += b[i].y;\n  l = 0;\n  ab = 0;\n  r = j;\n  while (1) {\n    if (l == r) break;\n    if (c[l].x == c[r].x) {\n      p = c[l].y + c[r].y;\n      if (p == k) {\n        ab++, l++, r--;\n      } else if (p > k) {\n        ab++;\n        break;\n      } else\n        break;\n    } else\n      break;\n  }\n  ans *= m;\n  ans -= (ab * k * (m - 1));\n  if (l == r && j >= 0 && m > 1) {\n    ans -= (((c[l].y * m) / k) * k);\n    if ((c[l].y * m) % k == 0) {\n      if (c[0].x == c[j].x) {\n        p = c[0].y + c[j].y;\n        if (p >= k) ans -= (ab * k);\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<int, long long> st[100005];\nint arr[100005];\nint main() {\n  int n, k, m, tp = 0;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) scanf(\"%d\", arr + i);\n  for (int i = 0; i < n; i++) {\n    if (!tp || st[tp - 1].first != arr[i])\n      st[tp++] = make_pair(arr[i], 1);\n    else\n      (++st[tp - 1].second) %= k;\n    if (tp && !st[tp - 1].second) tp--;\n  }\n  long long x = 0, y = 0;\n  for (int i = 0; i < tp; i++) x += st[i].second;\n  int l = 0, r = tp - 1;\n  while (l < r && st[l].first == st[r].first &&\n         !((st[l].second + st[r].second) % k))\n    y += st[l++].second + st[r--].second;\n  long long ans = 0;\n  if (l == r) {\n    if (!(st[l].second * m % k)) ans -= y;\n    ans += x * m - y * (m - 1) - (st[l].second * m / k * k);\n  } else {\n    if (st[l].first == st[r].first) y += (st[l].second + st[r].second) / k * k;\n    ans = x * m - y * (m - 1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint num[123456], stk[123456], sum[123456];\nint main() {\n  long long n, k, m;\n  while (scanf(\"%lld%lld%lld\", &n, &k, &m) != EOF) {\n    for (int i = 0; i < n; i++) scanf(\"%d\", &num[i]);\n    bool flag = 1;\n    for (int i = 1; i < n && flag; i++) {\n      if (num[i] != num[i - 1]) flag = 0;\n    }\n    if (flag) {\n      printf(\"%lld\\n\", n * m % k);\n      continue;\n    }\n    int top = 0;\n    for (int i = 0; i < n; i++) {\n      stk[++top] = num[i];\n      if (top - 1 > 0 && stk[top] == stk[top - 1])\n        sum[top] = sum[top - 1] + 1;\n      else\n        sum[top] = 1;\n      if (sum[top] >= k) top -= k;\n    }\n    if (!top) {\n      printf(\"0\\n\");\n      continue;\n    }\n    for (int i = 1; i <= top; i++) num[i - 1] = stk[i];\n    int left = 0, right = top - 1, key = 0;\n    while (left < right) {\n      int l = left, r = right;\n      while (num[left] == num[r] && l < r && key < k) r--, key++;\n      while (num[right] == num[l] && l < r && key < k) l++, key++;\n      if (key == k) {\n        key = 0;\n        left = l;\n        right = r;\n      } else\n        break;\n    }\n    flag = 1;\n    for (int i = left + 1; i <= right && flag; i++) {\n      if (num[i] != num[i - 1]) flag = 0;\n    }\n    long long len = right - left + 1;\n    if (flag) {\n      if (len * m % k == 0)\n        printf(\"0\\n\");\n      else\n        printf(\"%lld\\n\", len * m % k + top - len);\n    } else {\n      printf(\"%lld\\n\", top - len + len * m);\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INFF = 0x3f3f3f3f3f3f3f3fll;\nconst int MAX = 1e5 + 10;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\ntemplate <typename T>\ninline T abs(T a) {\n  return a > 0 ? a : -a;\n}\ntemplate <class T>\ninline void read(T& num) {\n  bool start = false, neg = false;\n  char c;\n  num = 0;\n  while ((c = getchar()) != EOF) {\n    if (c == '-')\n      start = neg = true;\n    else if (c >= '0' && c <= '9') {\n      start = true;\n      num = num * 10 + c - '0';\n    } else if (start)\n      break;\n  }\n  if (neg) num = -num;\n}\ninline long long powMM(long long a, long long b, long long M) {\n  long long ret = 1;\n  a %= M;\n  while (b) {\n    if (b & 1) ret = ret * a % M;\n    b >>= 1;\n    a = a * a % M;\n  }\n  return ret;\n}\nvoid open() { freopen(\"out.txt\", \"w\", stdout); }\nint n, ge;\nlong long k, m;\nvector<int> a, b, tem;\nlong long pre[MAX], suf[MAX];\nlong long an, cnt;\nlong long solve(int l, int r, long long tot) {\n  long long re = 0;\n  if (l > r) return 0;\n  long long len = (r - l + 1);\n  long long tot_len = tot * 1LL * len;\n  if (a[r] != a[l])\n    return 0;\n  else {\n    if (pre[r] >= len)\n      return tot_len / k * k;\n    else {\n      long long qian = min(pre[r], len);\n      long long hou = min(suf[l], len);\n      if (qian + hou < k) return 0;\n      long long ge = (qian + hou) / k;\n      long long x = (qian + hou) % k;\n      re = ge * k * (tot - 1LL);\n      long long nl, nr;\n      nl = l + hou, nr = r - qian + x;\n      long long lin = solve(nl, nr, tot);\n      re += lin;\n      if (lin == (nr - nl + 1LL) * tot) re += ge * k;\n      return re;\n    }\n  }\n}\nint now, last = -1;\nint main() {\n  scanf(\"%d%I64d%I64d\", &n, &k, &m);\n  a.push_back(-1);\n  for (int i = 1; i <= n; i++) {\n    int tmp;\n    scanf(\"%d\", &tmp);\n    if (tmp != last) now = 0;\n    a.push_back(tmp);\n    ++now;\n    tem.push_back(now);\n    if (now == k) {\n      cnt++;\n      a.resize(a.size() - k);\n      tem.resize(tem.size() - k);\n      now = tem.empty() ? 0 : tem.back();\n      last = (a.size() == 1) ? -1 : a.back();\n    } else\n      last = tmp;\n  }\n  ge = a.size() - 1;\n  pre[1] = 1;\n  suf[ge] = 1;\n  for (int i = 2; i <= ge; i++) {\n    if (a[i] == a[i - 1])\n      pre[i] = pre[i - 1] + 1;\n    else\n      pre[i] = 1;\n  }\n  for (int i = ge - 1; i >= 1; i--) {\n    if (a[i] == a[i + 1])\n      suf[i] = suf[i + 1] + 1;\n    else\n      suf[i] = 1;\n  }\n  an = cnt * m * k;\n  an += solve(1, ge, m);\n  printf(\"%I64d\\n\", (long long)n * m - an);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long, long long>> groupes;\nint main() {\n  ios_base::sync_with_stdio(false);\n  long long nbGens, tailleGroupe, nbFois;\n  cin >> nbGens >> tailleGroupe >> nbFois;\n  long long taille = nbGens;\n  for (long long iGens = 0; iGens < nbGens; iGens++) {\n    long long ville;\n    cin >> ville;\n    if (groupes.empty() || groupes.back().first != ville) {\n      groupes.push_back({ville, 1});\n    } else {\n      groupes.back().second++;\n    }\n    while (groupes.back().second >= tailleGroupe) {\n      groupes.back().second -= tailleGroupe;\n      taille -= tailleGroupe;\n    }\n    while (groupes.back().second == 0) {\n      groupes.pop_back();\n    }\n  }\n  long long somme = nbFois * taille;\n  long long deb = 0, fin = groupes.size() - 1;\n  while (deb < fin) {\n    if (groupes[deb].first != groupes[fin].first) {\n      cout << somme << endl;\n      return 0;\n    }\n    if (groupes[deb].second + groupes[fin].second == tailleGroupe) {\n      deb++;\n      fin--;\n      somme -= (nbFois - 1) * tailleGroupe;\n      continue;\n    }\n    if (groupes[deb].second + groupes[fin].second > tailleGroupe) {\n      somme -= (nbFois - 1) * tailleGroupe;\n    }\n    cout << somme << endl;\n    return 0;\n  }\n  if (deb > fin) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (deb == fin) {\n    if ((groupes[deb].second * nbFois) % tailleGroupe == 0)\n      cout << 0 << endl;\n    else\n      cout << somme -\n                  ((nbFois * groupes[deb].second) / tailleGroupe) * tailleGroupe\n           << endl;\n    return 0;\n  }\n  cout << somme << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\nint IT_MAX = 1 << 17;\nconst long long MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst long long LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\nconst double ERR = 1e-8;\nvector<pair<long long, long long> > Vu;\nint main() {\n  int N, K, M, i, j;\n  scanf(\"%d %d %d\", &N, &K, &M);\n  for (i = 1; i <= N; i++) {\n    int t;\n    scanf(\"%d\", &t);\n    if (!Vu.empty() && Vu.back().first == t) {\n      Vu.back().second++;\n      if (Vu.back().second == K) Vu.pop_back();\n    } else\n      Vu.emplace_back(t, 1);\n  }\n  long long s = 0;\n  for (auto it : Vu) s += it.second;\n  if (M == 1 || s == 0) return !printf(\"%lld\\n\", s);\n  s *= M;\n  int st = 0, en = (int)Vu.size() - 1;\n  while (st < en) {\n    if (Vu[st].first != Vu[en].first) return !printf(\"%lld\\n\", s);\n    if (Vu[st].second + Vu[en].second == K) {\n      s -= (long long)(M - 1) * K;\n      st++, en--;\n      continue;\n    }\n    if (Vu[st].second + Vu[en].second > K) s -= (long long)(M - 1) * K;\n    return !printf(\"%lld\\n\", s);\n  }\n  if (st > en) return !printf(\"0\\n\");\n  if (st == en) {\n    long long x = Vu[st].second * M;\n    if (x % K == 0)\n      return !printf(\"0\\n\");\n    else\n      return !printf(\"%lld\\n\", s - (x / K) * K);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint a[maxn];\nint sst[maxn];\nlong long sta[maxn];\nint main() {\n  int n, m;\n  long long k;\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  int tot = 0;\n  for (int i = 0; i < n; i++) {\n    if (!tot || sst[tot] != a[i]) {\n      sst[++tot] = a[i];\n      sta[tot] = 1;\n    } else {\n      sta[tot]++;\n    }\n    if (sta[tot] == k) tot--;\n  }\n  long long sum1 = 0;\n  for (int i = 1; i <= tot; i++) {\n    sum1 += sta[i];\n  }\n  int l = 1, r = tot;\n  while (l < r && sst[l] == sst[r]) {\n    sta[l] = (sta[l] + sta[r]) % k;\n    sta[r] = 0;\n    if (sta[l] != 0) break;\n    l++, r--;\n  }\n  long long sum2 = 0;\n  for (int i = l; i <= r; i++) {\n    sum2 += sta[i];\n  }\n  long long ans = 0;\n  if (l < r)\n    ans = sum2 * (m - 1) + sum1;\n  else\n    ans = ((sta[l] * m) % k == 0 ? 0 : (sum1 + sta[l] * m % k - sta[l]));\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m;\nint stk[100005][2];\nint bak[100005][2];\nint top = 0;\nint main() {\n  cin >> n >> k >> m;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    if (!top || stk[top][0] != x) {\n      stk[++top][0] = x;\n      stk[top][1] = 1;\n    } else {\n      stk[top][1]++;\n    }\n    if (stk[top][1] == k) stk[top--][1] -= k;\n  }\n  long long tot = 0;\n  for (int i = 1; i <= top; i++) {\n    tot += stk[i][1];\n  }\n  int b = 1, e = top;\n  while (b < e && stk[b][0] == stk[e][0]) {\n    if ((stk[e][1] + stk[b][1]) % k == 0) {\n      e--;\n      b++;\n    } else {\n      stk[b][1] = (stk[b][1] + stk[e][1]) % k;\n      stk[e][1] = 0;\n      break;\n    }\n  }\n  long long ans = 0;\n  if (e > b) {\n    for (int i = b; i <= e; i++) ans += stk[i][1];\n    ans *= (m - 1);\n    ans += tot;\n  } else if (e == b) {\n    if (stk[b][1] * m % k == 0)\n      ans = 0;\n    else {\n      ans = tot + stk[b][1] * (m - 1);\n      ans -= stk[b][1] * m - stk[b][1] * m % k;\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k, m, x, ans = 0;\n  cin >> n >> k >> m;\n  vector<pair<long long, long long> > v;\n  for (int i = 0; i < n; i++) {\n    cin >> x;\n    if (v.empty() || (v.back().first != x)) {\n      v.push_back({x, 1});\n    } else if (v.back().first == x) {\n      v.back().second = (v.back().second + 1) % k;\n      if (v.back().second == 0) v.pop_back();\n    }\n  }\n  if (v.size() == 0) return cout << 0, 0;\n  if (v.size() == 1) {\n    return cout << ((v[0].second * m) % k), 0;\n  }\n  for (auto &i : v) {\n    ans += m * i.second;\n  }\n  if (m == 1) return cout << ans, 0;\n  long long rem = 0;\n  int back = v.size() - 1, front = 0;\n  while (back > front) {\n    if ((v[front].first != v[back].first)) {\n      break;\n    } else {\n      rem += ((v[front].second + v[back].second) -\n              ((v[front].second + v[back].second) % k)) *\n             (m - 1);\n      if ((v[front].second + v[back].second) % k) break;\n    }\n    back--;\n    front++;\n  }\n  if (back == front) {\n    rem += ((v[back].second) * m) - ((v[back].second) * m) % k;\n    if (((v[back].second) * m) % k == 0) {\n      back--;\n      front++;\n    }\n  }\n  if (back < front)\n    while (back >= 0) {\n      if ((v[front].first != v[back].first)) {\n        break;\n      } else {\n        rem += ((v[front].second + v[back].second) -\n                ((v[front].second + v[back].second) % k));\n        if ((v[front].second + v[back].second) % k) break;\n      }\n      back--;\n      front++;\n    }\n  cout << (ans - rem);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200020;\nlong long total;\nint k;\ndeque<int> trata(deque<int> &d) {\n  deque<pair<int, int> > at;\n  int cnt = 0;\n  for (int i = 0; i < d.size(); i++) {\n    if (at.empty()) {\n      at.emplace_back(d[i], 1);\n      cnt = 1;\n    } else if (at.back().first == d[i]) {\n      at.emplace_back(d[i], cnt + 1);\n      cnt++;\n    } else {\n      at.emplace_back(d[i], 1);\n      cnt = 1;\n    }\n    if (cnt == k) {\n      for (int j = 0; j < k; j++) at.pop_back();\n      total -= k;\n      if (at.empty())\n        cnt = 0;\n      else\n        cnt = at.back().second;\n    }\n  }\n  deque<int> at2;\n  for (int i = 0; i < at.size(); i++) at2.push_back(at[i].first);\n  return at2;\n}\nint a[N];\nint main(void) {\n  int n, m;\n  scanf(\"%d %d %d\", &n, &k, &m);\n  set<int> s;\n  deque<int> deq;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n    deq.push_back(a[i]);\n  }\n  deq = trata(deq);\n  n = deq.size();\n  for (int i = 0; i < n; i++) {\n    a[i] = deq[i];\n    s.insert(a[i]);\n  }\n  total = ((n * 1LL) * (m * 1LL));\n  if (m == 1) {\n    trata(deq);\n    cout << total << endl;\n    return 0;\n  }\n  deque<int> bordaesq;\n  deque<int> bordadir;\n  deque<int> v;\n  for (int i = 0; i < n; i++) v.push_back(a[i]);\n  while (!v.empty()) {\n    long long cnt = 0;\n    int x = v.front();\n    if (v.front() != v.back()) {\n      cout << total << endl;\n      return 0;\n    }\n    int le = 0, ri = 0;\n    while (!v.empty() and v.front() == x) {\n      cnt++;\n      v.pop_front();\n      le++;\n    }\n    while (!v.empty() and v.back() == x) {\n      cnt++;\n      v.pop_back();\n      ri++;\n    }\n    if (!v.empty()) {\n      if (cnt % k != 0) {\n        total -= cnt * (m - 1);\n        total += (cnt % k) * (m - 1);\n        cout << total << endl;\n        return 0;\n      } else {\n        total -= cnt * (m - 1);\n        for (int i = 0; i < le; i++) bordaesq.push_back(x);\n        for (int i = 0; i < ri; i++) bordadir.push_front(x);\n      }\n    } else {\n      cnt *= m;\n      if (cnt % k != 0) {\n        total -= cnt;\n        total += (cnt % k);\n        cout << total << endl;\n        return 0;\n      } else {\n        total -= cnt;\n      }\n    }\n  }\n  while (!bordadir.empty()) {\n    bordaesq.push_back(bordadir.front());\n    bordadir.pop_front();\n  }\n  trata(bordaesq);\n  cout << total << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m;\nint stk[100005][2];\nint bak[100005][2];\nvector<pair<int, int> > v;\nint top = 0;\nint main() {\n  cin >> n >> k >> m;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    if (!top || stk[top][0] != x) {\n      stk[++top][0] = x;\n      stk[top][1] = 1;\n    } else {\n      stk[top][1]++;\n    }\n    if (stk[top][1] == k) stk[top--][1] -= k;\n  }\n  long long tot = 0;\n  for (int i = 1; i <= top; i++) {\n    tot += stk[i][1];\n  }\n  int b = 1, e = top;\n  while (b < e && stk[b][0] == stk[e][0]) {\n    if ((stk[e][1] + stk[b][1]) % k == 0) {\n      e--;\n      b++;\n    } else {\n      stk[b][1] = (stk[b][1] + stk[e][1]) % k;\n      stk[e][1] = 0;\n      break;\n    }\n  }\n  long long ans = 0;\n  if (e > b) {\n    for (int i = b; i <= e; i++) ans += stk[i][1];\n    ans *= (m - 1);\n    ans += tot;\n  } else if (e == b) {\n    if (stk[b][1] * m % k == 0)\n      ans = 0;\n    else {\n      ans = tot + stk[b][1] * (m - 1);\n      ans -= stk[b][1] * m - stk[b][1] * m % k;\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 210000;\nint tn, n, k, m;\nint c[maxn];\nlong long al, ans;\nstruct node {\n  int num, x;\n} a[maxn];\nint fa[maxn];\nint findfa(const int x) { return fa[x] == x ? x : fa[x] = findfa(fa[x]); }\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  al += (long long)n * m;\n  tn = 0;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    if (x == a[tn].x)\n      a[tn].num++;\n    else\n      a[++tn] = (node){1, x};\n  }\n  n = tn;\n  for (int i = 1; i <= n; i++) fa[i] = i;\n  for (int i = 1; i <= n; i++)\n    if (a[i].num >= k) {\n      int temp = a[i].num / k;\n      a[i].num %= k;\n      ans += (long long)temp * k * m;\n      if (!a[i].num) {\n        fa[i] = i - 1;\n        int lj = findfa(i - 1), rj;\n        for (rj = i + 1; rj <= n && lj >= 1 && a[lj].x == a[rj].x;\n             rj++, lj = findfa(lj)) {\n          int kk = a[lj].num + a[rj].num;\n          ans += (long long)kk / k * k * m;\n          kk %= k;\n          a[lj].num = 0;\n          fa[lj] = lj - 1;\n          a[rj].num = kk;\n          if (kk) {\n            i = rj - 1;\n            break;\n          }\n          fa[rj] = rj - 1;\n        }\n      }\n    }\n  tn = 0;\n  for (int i = 1; i <= n; i++)\n    if (a[i].num) {\n      if (a[i].x == a[tn].x)\n        a[tn].num += a[i].num;\n      else\n        a[++tn] = a[i];\n    }\n  n = tn;\n  if (m == 1) return printf(\"%I64d\\n\", al - ans), 0;\n  int l = 1, r = n;\n  while (l <= r && a[l].x == a[r].x) {\n    if (l + 1 >= r) {\n      long long temp;\n      if (l == r)\n        temp = (long long)m * a[l].num;\n      else\n        temp = (long long)m * (a[l].num + a[r].num);\n      if (temp % k)\n        ans += temp / k * k;\n      else\n        ans = al;\n      break;\n    }\n    long long temp = (a[l].num + a[r].num);\n    ans += (long long)temp / k * k * (m - 1);\n    temp %= k;\n    if (temp) break;\n    l++, r--;\n  }\n  printf(\"%I64d\\n\", al - ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long x = 0;\n  char ch = getchar();\n  bool positive = 1;\n  for (; !isdigit(ch); ch = getchar())\n    if (ch == '-') positive = 0;\n  for (; isdigit(ch); ch = getchar()) x = x * 10 + ch - '0';\n  return positive ? x : -x;\n}\ninline void write(long long a) {\n  if (a >= 10) write(a / 10);\n  putchar('0' + a % 10);\n}\ninline void writeln(long long a) {\n  if (a < 0) {\n    a = -a;\n    putchar('-');\n  }\n  write(a);\n  puts(\"\");\n}\nconst long long N = 100005;\nlong long a[N], k, m, n, b[N], zs, kk, r, bb[N];\ninline bool check(long long l, long long r) {\n  for (long long i = l; i < r; i++)\n    if (a[i] != a[i + 1]) return 0;\n  return 1;\n}\nint main() {\n  cin >> n >> k >> m;\n  for (long long i = 1; i <= n; i++) a[i] = read();\n  for (long long i = 1; i <= n; i++) {\n    if (a[i] != b[r])\n      bb[r + 1] = 1;\n    else\n      bb[r + 1] = bb[r] + 1;\n    b[++r] = a[i];\n    if (bb[r] == k) {\n      r -= k;\n    }\n  }\n  n = r;\n  for (long long i = 1; i <= n; i++) a[i] = b[i];\n  long long i = n, j = 1, lasti = n, lastj = 1;\n  kk = 2;\n  for (; j < i && a[i] == a[j];) {\n    while (a[i - 1] == a[i] && kk < k) {\n      i--;\n      kk++;\n    }\n    while (a[j + 1] == b[j] && kk < k) {\n      j++;\n      kk++;\n    }\n    if (j < i && kk == k) {\n      lasti = --i;\n      lastj = ++j;\n      if (a[j] == a[i])\n        kk = 2;\n      else\n        break;\n    } else\n      break;\n  }\n  i = lasti;\n  j = lastj;\n  if (check(j, i)) {\n    kk = 2;\n    if (m * (i - j + 1) % k != 0) {\n      cout << m * (i - j + 1) % k + j - 1 + n - i << endl;\n      return 0;\n    }\n    lasti++;\n    lastj--;\n    for (j--, i++; a[i] == b[j] && i <= n && j;) {\n      while (a[j - 1] == a[j] && kk < k) {\n        j--;\n        kk++;\n      }\n      while (a[i + 1] == a[i] && kk < k) {\n        i++;\n        kk++;\n      }\n      if (kk == k) {\n        lasti = ++i;\n        lastj = --j;\n        kk = 2;\n      }\n    }\n    cout << lastj + n - lasti + 1 << endl;\n  } else\n    cout << (i - j + 1) * m + j - 1 + n - i << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m;\nvector<int> val, num;\nvector<int> a, aa;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    aa.push_back(x);\n    if (val.empty() || val.back() != x) {\n      val.push_back(x);\n      num.push_back(1);\n    } else {\n      ++num.back();\n      if (num.back() == k) {\n        val.pop_back();\n        num.pop_back();\n      }\n    }\n  }\n  if (val.empty()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  for (int i = 0; i < val.size(); ++i) {\n    for (int j = 0; j < num[i]; ++j) a.push_back(val[i]);\n  }\n  n = a.size();\n  if (m == 1) {\n    cout << n << endl;\n    return 0;\n  }\n  if (k >= n) {\n    if (val.size() > 1)\n      cout << n * m << endl;\n    else\n      cout << (n * m) % k << endl;\n    return 0;\n  }\n  vector<int> va, nu;\n  for (int i = 0; i < n; ++i) {\n    if (va.empty() || va.back() != a[i]) {\n      va.push_back(a[i]);\n      nu.push_back(1);\n    } else {\n      ++nu.back();\n      if (nu.back() == k) {\n        va.pop_back();\n        nu.pop_back();\n      }\n    }\n  }\n  long long w = 0;\n  vector<int> vaa = va;\n  vector<int> nuu = nu;\n  bool go = true;\n  for (int i = 0; go && i < vaa.size(); ++i) {\n    int x = vaa[i];\n    int q = nuu[i];\n    if (va.empty() || va.back() != x)\n      go = false;\n    else {\n      if (nu.back() + q >= k) {\n        if (nu.back() + q > k) go = false;\n        w += k;\n        va.pop_back();\n        nu.pop_back();\n      } else\n        go = false;\n    }\n    if (w >= n) go = false;\n  }\n  if (w < n) {\n    cout << m * n - (m - 1) * w << endl;\n    return 0;\n  }\n  if (w == n) {\n    cout << n << endl;\n    return 0;\n  }\n  if (w == 0) {\n    cout << n * m << endl;\n    return 0;\n  }\n  int y = 0;\n  for (int i = 0; i < nu.size(); ++i) y += nu[i];\n  long long d = (n * m + w - n - n) % k;\n  int z = n + n - y - w;\n  vector<int> r;\n  for (int i = 0; i < y; ++i) r.push_back(a[i]);\n  for (int i = 0; i < d; ++i) r.push_back(a[y]);\n  for (int i = n - z; i < n; ++i) r.push_back(a[i]);\n  val.clear();\n  num.clear();\n  for (int i = 0; i < r.size(); ++i) {\n    int x = r[i];\n    if (val.empty() || val.back() != x) {\n      val.push_back(x);\n      num.push_back(1);\n    } else {\n      ++num.back();\n      if (num.back() == k) {\n        val.pop_back();\n        num.pop_back();\n      }\n    }\n  }\n  long long res = 0;\n  for (int i = 0; i < num.size(); ++i) res += num[i];\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.Collection;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Rustam Musin (PloadyFree@gmail.com)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            int m = in.readInt();\n            List<IntIntPair> all = new ArrayList<>(n); //{type, size}\n            for (int i = 0; i < n; i++) {\n                int type = in.readInt();\n                if (!all.isEmpty() && all.get(all.size() - 1).first == type) {\n                    if (last(all).second == k - 1) {\n                        all.remove(all.size() - 1);\n                    } else {\n                        all.set(all.size() - 1, IntIntPair.makePair(type, last(all).second + 1));\n                    }\n                } else {\n                    all.add(IntIntPair.makePair(type, 1));\n                }\n            }\n\n            long size = 0;\n            for (IntIntPair p : all) {\n                size += p.second;\n            }\n            size *= m;\n\n            if (m == 1 || size == 0) {\n                out.print(size);\n                return;\n            }\n\n            Deque<IntIntPair>[] parts = new Deque[3];\n            parts[0] = new ArrayDeque<>(all);\n            parts[1] = new ArrayDeque<>(all);\n            parts[2] = new ArrayDeque<>(all);\n\n            while (true) {\n                if (parts[1].size() == 1) {\n                    long middle = parts[1].peek().second * (long) m;\n                    if (middle % k == 0) {\n                        size -= middle;\n                        parts[0].pollLast();\n                        parts[2].pollFirst();\n                        size -= merge(parts[0], parts[2], k);\n                        break;\n                    } else {\n                        size -= middle / k * k;\n                        break;\n                    }\n                }\n                if (parts[1].peekFirst().first != parts[1].peekLast().first) {\n                    break;\n                }\n                long curSize = parts[1].peekFirst().second + parts[1].peekLast().second;\n                if (curSize % k != 0) {\n                    size -= (m - 1) * (curSize / k * k);\n                    break;\n                } else {\n                    parts[1].pollFirst();\n                    parts[1].pollLast();\n                    size -= (m - 1) * curSize;\n                    parts[0].pollLast();\n                    parts[2].pollFirst();\n                }\n            }\n\n            out.print(size);\n        }\n\n        int merge(Deque<IntIntPair> q1, Deque<IntIntPair> q2, int k) {\n            int result = 0;\n            while (!q1.isEmpty()) {\n                if (q1.peekLast().first != q2.peekFirst().first) {\n                    break;\n                }\n                int sz = q1.pollLast().second + q2.pollFirst().second;\n                result += sz / k * k;\n                if (sz % k != 0) {\n                    break;\n                }\n            }\n            return result;\n        }\n\n        <T> T last(List<T> a) {\n            return a.get(a.size() - 1);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void print(long i) {\n            writer.print(i);\n        }\n\n    }\n\n    static class IntIntPair implements Comparable<IntIntPair> {\n        public final int first;\n        public final int second;\n\n        public static IntIntPair makePair(int first, int second) {\n            return new IntIntPair(first, second);\n        }\n\n        public IntIntPair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            IntIntPair pair = (IntIntPair) o;\n\n            return first == pair.first && second == pair.second;\n        }\n\n\n        public int hashCode() {\n            int result = first;\n            result = 31 * result + second;\n            return result;\n        }\n\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        @SuppressWarnings({\"unchecked\"})\n        public int compareTo(IntIntPair o) {\n            int value = Integer.compare(first, o.first);\n            if (value != 0) {\n                return value;\n            }\n            return Integer.compare(second, o.second);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int rd() {\n  int r;\n  scanf(\"%d\", &r);\n  return r;\n}\nint n, m, k, tp;\nint a[1000500], s[1000500], f[1000500];\nlong long ans;\nint main() {\n  n = rd(), k = rd(), m = rd();\n  for (int _ = 1; _ <= n; _++) a[_] = rd();\n  if (k >= n) {\n    bool flag = 1;\n    for (int _ = 1; _ <= n; _++)\n      if (a[_] != a[1]) flag = 0;\n    if (flag)\n      cout << 1LL * n * m % k << endl;\n    else\n      cout << 1LL * n * m << endl;\n    return 0;\n  }\n  for (int _ = 1; _ <= n; _++) {\n    s[++tp] = a[_];\n    if (tp > 1 && s[tp] == s[tp - 1])\n      f[tp] = f[tp - 1] + 1;\n    else\n      f[tp] = 1;\n    if (f[tp] == k) tp -= k;\n  }\n  int L = 1, R = tp;\n  while (s[L] == s[R] && L != R) {\n    int l = L, r = R, cnt = 0;\n    while (s[L] == s[l] && l < r && cnt < k) ++l, ++cnt;\n    while (s[R] == s[r] && l < r && cnt < k) --r, ++cnt;\n    if (cnt == k)\n      L = l, R = r, ans += k;\n    else\n      break;\n  }\n  bool flag = 1;\n  for (int _ = L + 1; _ <= R; _++)\n    if (s[_] != s[L]) flag = 0;\n  if (flag) {\n    if (1LL * (R - L + 1) * m % k == 0)\n      puts(\"0\");\n    else\n      cout << 1LL * (R - L + 1) * m % k + ans << endl;\n  } else {\n    cout << ans + 1LL * (R - L + 1) * m << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int LIM = 600010;\n;\nconst int TRIM = 300000;\npair<vector<pair<int, int64_t>>, int64_t> getAnswer(const vector<int>& a, int m,\n                                                    int k) {\n  if (m == 0) {\n    return {{}, 0};\n  } else {\n    vector<pair<int, int64_t>> stk;\n    pair<vector<pair<int, int64_t>>, int64_t> b = getAnswer(a, m / 2, k);\n    int64_t rem = b.second * 2;\n    for (int u = 0; u < 2; ++u) {\n      for (const pair<int, int64_t>& p : b.first) {\n        if (p.first >= 0 && !stk.empty() && p.first == stk.back().first) {\n          stk.back().second += p.second;\n        } else {\n          stk.push_back(p);\n        }\n        while (!stk.empty()) {\n          int64_t buckets = stk.back().second / k;\n          if (buckets == 0) {\n            break;\n          }\n          stk.back().second %= k;\n          rem += buckets * k;\n          if (stk.back().second == 0) {\n            stk.pop_back();\n          }\n        }\n      }\n    }\n    if (m & 1) {\n      for (int x : a) {\n        pair<int, int64_t> p = make_pair(x, (int64_t)1);\n        if (p.first >= 0 && !stk.empty() && p.first == stk.back().first) {\n          stk.back().second += p.second;\n        } else {\n          stk.push_back(p);\n        }\n        while (!stk.empty()) {\n          int64_t buckets = stk.back().second / k;\n          if (buckets == 0) {\n            break;\n          }\n          stk.back().second %= k;\n          rem += buckets * k;\n          if (stk.back().second == 0) {\n            stk.pop_back();\n          }\n        }\n      }\n    }\n    if (((int)(stk).size()) > LIM) {\n      vector<pair<int, int64_t>> nStk;\n      for (int i = 0; i < TRIM; ++i) {\n        nStk.push_back(stk[i]);\n      }\n      nStk.push_back(make_pair(-1, (int64_t)1));\n      for (int i = ((int)(stk).size()) - TRIM; i < ((int)(stk).size()); ++i) {\n        nStk.push_back(stk[i]);\n      }\n      stk = move(nStk);\n    }\n    return make_pair(stk, rem);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k, m;\n  cin >> n >> k >> m;\n  vector<int> a(n);\n  for (int& x : a) {\n    cin >> x;\n  }\n  vector<pair<int, int64_t>> rem;\n  int64_t ans;\n  tie(rem, ans) = getAnswer(a, m, k);\n  cout << (int64_t)m * n - ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mx = 200010;\nstruct info {\n  int a, num;\n  info() {}\n  info(int _1, int _2) {\n    a = _1;\n    num = _2;\n  }\n};\nvector<info> Ori, Ans;\nint n, k, m;\nvoid reduce(vector<info> &X) {\n  vector<info> tmp;\n  tmp.clear();\n  for (int i = 0; i < X.size(); i++)\n    if (tmp.size() == 0 || tmp.back().a != X[i].a)\n      tmp.push_back(X[i]);\n    else {\n      tmp.back().num = (tmp.back().num + X[i].num) % k;\n      if (tmp.back().num == 0) tmp.pop_back();\n    }\n  X = tmp;\n}\nlong long len(vector<info> &X) {\n  long long ans = 0;\n  for (int i = 0; i < X.size(); i++) ans += X[i].num;\n  return ans;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    Ori.push_back(info(x, 1));\n  }\n  reduce(Ori);\n  if (Ori.size() == 1) {\n    printf(\"%lld\\n\", (long long)Ori[0].num * m % k);\n    return 0;\n  }\n  long long prelen = len(Ori), sz = Ori.size(), ori2 = Ori[sz / 2].num;\n  for (int i = 0; i < sz; i++) Ori.push_back(Ori[i]);\n  reduce(Ori);\n  if (Ori.size() == 0) {\n    if (m % 2 == 1)\n      printf(\"%lld\\n\", prelen);\n    else\n      puts(\"0\");\n  } else if (Ori.size() == sz) {\n    assert(sz % 2 == 1);\n    if ((long long)ori2 * m % k == 0) {\n      puts(\"0\");\n      return 0;\n    } else {\n      printf(\"%lld\\n\", prelen - ori2 + (long long)ori2 * m % k);\n      return 0;\n    }\n  } else {\n    long long delt = len(Ori) - prelen;\n    printf(\"%lld\\n\", delt * (m - 1) + prelen);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, K, m, i, j, k, l;\nint a[100001];\nint b[100001][2], t;\nlong long ans;\nvoid work(int x, int y) {\n  long long s = b[x][1] + b[y][1];\n  if (x == y) {\n    s = 1ll * b[x][1] * m;\n    if (!(s % K))\n      ans = 0;\n    else\n      ans -= s - s % K;\n    return;\n  }\n  if (x > y) return;\n  if (b[x][0] != b[y][0]) return;\n  ans -= 1ll * (s - s % K) * (m - 1);\n  if (!(s % K)) work(x + 1, y - 1);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &K, &m);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  t = 0;\n  for (i = 1; i <= n; i++) {\n    if (!t || a[i] != b[t][0])\n      ++t, b[t][0] = a[i], b[t][1] = 1;\n    else\n      ++b[t][1];\n    if (b[t][1] == K) --t;\n  }\n  ans = 0;\n  if (t) {\n    for (i = 1; i <= t; i++) ans += b[i][1];\n    ans *= m;\n    work(1, t);\n  }\n  cout << ans << endl;\n  fclose(stdin);\n  fclose(stdout);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300;\nint getAns(deque<int> &a, int k) {\n  vector<int> x;\n  int last = 0;\n  for (int i = 0; i < a.size(); ++i) {\n    ++last;\n    if (x.empty() || x.back() != a[i]) {\n      last = 1;\n    }\n    x.push_back(a[i]);\n    if (last == k) {\n      for (int j = 0; j < k; ++j) {\n        x.pop_back();\n      }\n      last = 0;\n      while ((int)x.size() - last - 1 >= 0 &&\n             x[(int)x.size() - last - 1] == x.back())\n        ++last;\n    }\n  }\n  return x.size();\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, k, m;\n  cin >> n >> k >> m;\n  int last = 0;\n  deque<int> mas, a, b;\n  for (int i = 0; i < n; ++i) {\n    int a;\n    cin >> a;\n    ++last;\n    if (mas.empty() || mas.back() != a) {\n      last = 1;\n    }\n    mas.push_back(a);\n    if (last == k) {\n      for (int j = 0; j < k; ++j) {\n        mas.pop_back();\n      }\n      last = 0;\n      while ((int)mas.size() - last - 1 >= 0 &&\n             mas[(int)mas.size() - last - 1] == mas.back())\n        ++last;\n    }\n  }\n  if (m == 1) {\n    cout << mas.size() << endl;\n    return 0;\n  }\n  int dleft = 0, dright = 0;\n  a = b = mas;\n  int p1 = 0, p2 = (int)mas.size() - 1;\n  while (p1 < mas.size() && mas[p1] == mas.front()) ++p1;\n  while (p2 >= 0 && mas[p2] == mas.back()) --p2;\n  while (!mas.empty() && mas.back() == mas.front() && p1 != mas.size() &&\n         p1 + (mas.size() - p2 - 1) >= k) {\n    int del = mas.front();\n    for (int i = 0; i < k; ++i) {\n      if (mas.back() == del) {\n        mas.pop_back();\n        dright++;\n      } else {\n        --p1;\n        mas.pop_front();\n        p2 = (int)mas.size() - 1;\n        dleft++;\n      }\n    }\n    while (p1 < mas.size() && mas[p1] == mas.front()) ++p1;\n    while (p2 >= 0 && mas[p2] == mas.back()) --p2;\n  }\n  for (int i = 0; i < dright; ++i) {\n    a.pop_back();\n  }\n  for (int i = 0; i < dleft; ++i) {\n    b.pop_front();\n  }\n  swap(a, b);\n  if (p1 != mas.size()) {\n    cout << b.size() + a.size() + 1ll * (mas.size()) * (m - 2) << endl;\n  } else {\n    int64_t ans = 0, cur = 0;\n    int ps = 0;\n    while (ps < a.size() && a[ps] == mas[0]) ++ps;\n    cur += ps;\n    ans += (a.size() - ps);\n    for (int i = 0; i < ps; ++i) a.pop_front();\n    ps = (int)b.size() - 1;\n    while (ps >= 0 && b[ps] == mas[0]) --ps;\n    cur += ((int)b.size() - ps - 1);\n    ans += ps + 1;\n    ps = ((int)b.size() - ps - 1);\n    for (int i = 0; i < ps; ++i) {\n      b.pop_back();\n    }\n    cur += 1ll * (m - 2) * mas.size();\n    cur %= k;\n    if (cur == 0) {\n      for (int i = 0; i < a.size(); ++i) {\n        b.push_back(a[i]);\n      }\n      cout << getAns(b, k) << endl;\n      return 0;\n    }\n    ans += cur;\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nconst int INF = 1e9 + 7;\nconst int N = 2e5 + 7;\nconst int M = 1e6 + 7;\nint s[N], h[N], a[N];\nsigned main() {\n  ios::sync_with_stdio(false);\n  int n, m, k, top = 0;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  scanf(\"%d\", &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &s[++top]);\n    if (top == 1 || s[top] != s[top - 1])\n      h[top] = 1;\n    else\n      h[top] = h[top - 1] + 1;\n    if (h[top] == k) top -= k;\n  }\n  int L = 1, R = top, l, r, cnt;\n  long long ans = 0;\n  while (L < R && s[L] == s[R]) {\n    cnt = 0, l = L, r = R;\n    while (l < R && s[l] == s[L] && cnt < k) cnt++, l++;\n    while (r > l && s[r] == s[R] && cnt < k) cnt++, r--;\n    if (cnt == k)\n      ans += (long long)k, L = l, R = r;\n    else\n      break;\n  }\n  long long _ans = (long long)(R - L + 1) * (long long)m;\n  int flag = 1;\n  for (int i = L; i < R; i++)\n    if (s[i] != s[i + 1]) {\n      flag = 0;\n      break;\n    }\n  if (!flag)\n    ans += _ans;\n  else {\n    _ans %= (long long)k;\n    if (_ans == 0ll)\n      ans = 0;\n    else\n      ans += _ans;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100002;\nint n, k, m, cnt;\nint a[N], b[N], c[N];\nlong long ans = 0;\nint main() {\n  cnt = 0;\n  int i, j, o, sum = 0;\n  int l, r;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (i = 1; i <= n; ++i) {\n    if (a[i] != b[cnt]) {\n      b[++cnt] = a[i];\n      c[cnt] = 1;\n    } else {\n      c[cnt]++;\n      if (c[cnt] == k) cnt--;\n    }\n  }\n  if (!cnt) {\n    puts(\"0\");\n    return 0;\n  }\n  for (i = 1; i <= cnt; ++i) sum += c[i];\n  for (o = 0, i = 1; i < cnt + 1 - i; ++i) {\n    if (b[i] == b[cnt + 1 - i] && c[i] + c[cnt + 1 - i] == k)\n      o += k;\n    else\n      break;\n  }\n  if (i < cnt + 1 - i) {\n    if (b[i] == b[cnt + 1 - i] && c[i] + c[cnt + 1 - i] > k) o += k;\n    ans = 1ll * sum * m - 1ll * o * (m - 1);\n  } else {\n    ans = 1ll * c[i] * m % k;\n    if (ans) ans += sum - c[i];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void gmin(T &x, const T &y) {\n  if (x > y) x = y;\n}\ntemplate <class T>\ninline void gmax(T &x, const T &y) {\n  if (x < y) x = y;\n}\nconst int BufferSize = 1 << 16;\nchar buffer[BufferSize], *Bufferhead, *Buffertail;\nbool Terminal;\ninline char Getchar() {\n  if (Bufferhead == Buffertail) {\n    int l = fread(buffer, 1, BufferSize, stdin);\n    if (!l) {\n      Terminal = 1;\n      return 0;\n    }\n    Buffertail = (Bufferhead = buffer) + l;\n  }\n  return *Bufferhead++;\n}\ntemplate <class T>\ninline bool read(T &x) {\n  x = 0;\n  char c = Getchar(), rev = 0;\n  while (c < '0' || c > '9') {\n    rev |= c == '-';\n    c = Getchar();\n    if (Terminal) return 0;\n  }\n  while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = Getchar();\n  if (c == '.') {\n    c = Getchar();\n    double t = 0.1;\n    while (c >= '0' && c <= '9')\n      x = x + (c - '0') * t, c = Getchar(), t = t / 10;\n  }\n  x = rev ? -x : x;\n  return 1;\n}\ntemplate <class T1, class T2>\ninline bool read(T1 &x, T2 &y) {\n  return read(x) & read(y);\n}\ntemplate <class T1, class T2, class T3>\ninline bool read(T1 &x, T2 &y, T3 &z) {\n  return read(x) & read(y) & read(z);\n}\ntemplate <class T1, class T2, class T3, class T4>\ninline bool read(T1 &x, T2 &y, T3 &z, T4 &w) {\n  return read(x) & read(y) & read(z) & read(w);\n}\ninline bool reads(char *x) {\n  char c = Getchar();\n  while (c < 33 || c > 126) {\n    c = Getchar();\n    if (Terminal) return 0;\n  }\n  while (c >= 33 && c <= 126) (*x++) = c, c = Getchar();\n  *x = 0;\n  return 1;\n}\ntemplate <class T>\ninline void print(T x, const char c = '\\n') {\n  if (!x) {\n    putchar('0');\n    putchar(c);\n    return;\n  }\n  if (x < 0) putchar('-'), x = -x;\n  int m = 0, a[20];\n  while (x) a[m++] = x % 10, x /= 10;\n  while (m--) putchar(a[m] + '0');\n  putchar(c);\n}\nconst int inf = 0x3f3f3f3f;\nconst int N = 200005, M = 100005, mod = 1e9 + 7;\ntemplate <class T, class S>\ninline void ch(T &x, const S y) {\n  x = (x + y) % mod;\n}\ninline int exp(int x, int y, const int mod = ::mod) {\n  int ans = 1;\n  while (y) {\n    if (y & 1) ans = (long long)ans * x % mod;\n    x = (long long)x * x % mod;\n    y >>= 1;\n  }\n  return ans;\n}\nint n, k, m, tot, cnt;\nint a[N], si[N], b[N], si2[N];\nint main() {\n  read(n, k, m);\n  for (int i = 1; i <= n; i++) {\n    int x;\n    read(x);\n    if (a[tot] == x)\n      si[tot]++;\n    else\n      a[++tot] = x, si[tot] = 1;\n    while (tot && si[tot] % k == 0) tot--;\n  }\n  for (int i = 1; i <= tot; i++) si[tot] %= k;\n  int sum = 0, out = 0;\n  for (int i = 1; i <= tot; i++) sum += si[i];\n  for (int i = 1, j = tot; i <= j; i++, j--) {\n    if (a[i] == a[j] && (si[i] + si[j]) % k == 0) {\n      out += si[i] + si[j];\n      continue;\n    }\n    for (int p = i; p <= j; p++) b[++cnt] = a[p], si2[cnt] = si[p];\n    break;\n  }\n  if (cnt == 2 && b[1] == b[2]) {\n    cnt = 1;\n    si2[1] += si2[2];\n  }\n  if (!cnt) {\n    print(m & 1 ? sum : 0);\n    return 0;\n  }\n  if (cnt >= 2) {\n    int sum2 = 0, tag = 0;\n    for (int i = 1; i <= cnt; i++) sum2 += si2[i];\n    if (b[1] == b[cnt]) tag = si2[1] + si2[cnt] - (si2[1] + si2[cnt]) % k;\n    print((long long)sum2 * m + out - (long long)tag * (m - 1));\n    return 0;\n  }\n  int t = (long long)m * si2[1] % k;\n  if (t)\n    print(t + out);\n  else\n    print(0);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long val[111111], cnt[111111], sum, ans, idx;\nint main() {\n  long long n, k, m, x;\n  scanf(\"%I64d%I64d%I64d\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%I64d\", &x);\n    if (x == val[idx]) {\n      if (++cnt[idx] == k) idx--;\n    } else {\n      val[++idx] = x;\n      cnt[idx] = 1;\n    }\n  }\n  for (int i = 1; i <= idx; i++) sum += cnt[i];\n  long long head = 1, tail = idx;\n  while (head < tail && val[head] == val[tail]) {\n    if ((cnt[head] + cnt[tail]) % k == 0) {\n      head++, tail--;\n    } else {\n      cnt[head] = (cnt[head] + cnt[tail]) % k;\n      cnt[tail] = 0;\n      tail--;\n    }\n  }\n  if (head < tail) {\n    for (int i = head; i <= tail; i++) {\n      ans += cnt[i];\n    }\n    ans = sum + ans * (m - 1);\n  } else {\n    if (cnt[head] * m % k == 0)\n      ans = 0;\n    else\n      ans = sum - cnt[head] + cnt[head] * m % k;\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, k, m;\n  scanf(\"%lld %lld %lld\", &n, &k, &m);\n  vector<pair<int, long long> > b;\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    if (b.size() && b.back().first == x) {\n      if (++b.back().second == k) b.pop_back();\n    } else\n      b.push_back({x, 1});\n  }\n  if (m == 1) {\n    long long ans = 0;\n    for (int i = 0; i < b.size(); i++) ans += b[i].second;\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n  deque<pair<int, long long> > mid;\n  for (int i = 0; i < b.size(); i++) mid.push_back(b[i]);\n  for (; mid.size() >= 2;) {\n    if (mid.front().first == mid.back().first) {\n      if (mid.front().second + mid.back().second == k) {\n        mid.pop_front();\n        mid.pop_back();\n      } else {\n        if (mid.front().second + mid.back().second > k) {\n          mid.back().second = mid.front().second + mid.back().second - k;\n          mid.pop_front();\n        }\n        break;\n      }\n    } else\n      break;\n  }\n  if (m == 2) {\n    long long ans = 0;\n    for (int i = 0; i < b.size(); i++) ans += b[i].second;\n    for (; !mid.empty(); mid.pop_back()) ans += mid.back().second;\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n  if (mid.size() == 1) {\n    mid.back().second = mid.back().second * m % k;\n    m = 3;\n    if (mid.back().second == 0) {\n      b[b.size() / 2].second = 0;\n      for (int i = b.size() / 2 - 1, j = i + 2; i >= 0 & j < b.size(); i--, j++)\n        if (b[i].first == b[j].first) {\n          if (b[i].second + b[j].second == k)\n            b[i].second = b[j].second = 0;\n          else {\n            if (b[i].second + b[j].second > k) {\n              b[i].second = b[i].second + b[j].second - k;\n              b[j].second = 0;\n            }\n            break;\n          }\n        } else\n          break;\n      long long ans = 0;\n      for (int i = 0; i < b.size(); i++) ans += b[i].second;\n      printf(\"%lld\\n\", ans);\n      return 0;\n    }\n    long long ans = mid.back().second - b[b.size() / 2].second;\n    for (int i = 0; i < b.size(); i++) ans += b[i].second;\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n  long long ans = 0;\n  for (; !mid.empty(); mid.pop_back()) ans += mid.back().second;\n  ans *= (m - 1);\n  for (int i = 0; i < b.size(); i++) ans += b[i].second;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tMyScanner sn = new MyScanner();\n\t\tint n = sn.nextInt();\n\t\tlong k = sn.nextLong();\n\t\tlong m = sn.nextLong();\n\t\tlong arr[] = new long[(int) (n + 1)];\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tarr[i] = sn.nextLong();\n\n\t\tif (k >= n) {\n\t\t\tlong te = arr[0];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tif (arr[i] != te) {\n\t\t\t\t\tSystem.out.println(n * m);\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = ((n % k) * (m % k)) % k;\n\t\t\tSystem.out.println(ans);\n\t\t\tSystem.exit(0);\n\t\t}\n\n\t\tsolve(arr, n, k, m);\n\t}\n\n\tprivate static void solve(long[] arr, int n, long k, long m) {\n\n\t\tStack<Coup> s = new Stack<Coup>();\n\t\ts.push(new Coup(arr[0], 1));\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (!s.isEmpty() && arr[i] == s.peek().ele) {\n\t\t\t\tint count = s.peek().count;\n\t\t\t\ts.pop();\n\t\t\t\ts.push(new Coup(arr[i], count + 1));\n\t\t\t} else {\n\t\t\t\ts.push(new Coup(arr[i], 1));\n\t\t\t}\n\t\t\tif (s.peek().count == k) {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint flag = 0;\n\t\tlong ans = 0, sum = 0,mid=0;\n\t\t\n\t\tfor (int i = 0, j = s.size() - 1; i <= j; i++, j--) {\n\t\t\tlong di = s.get(i).count, dj = s.get(j).count;\n\t\t\tlong ei = s.get(i).ele, ej = s.get(j).ele;\n\t\t\t\n\t\t\tif(i!=j)\n\t\t\t\tsum += di + dj;\n\t\t\telse\n\t\t\t\tsum+=di;\n\t\t\t\n\t\t\tif (i!=j && ei == ej && di + dj < k)\n\t\t\t\tflag = 1;\n\t\t\telse if(i!=j && ei == ej && flag==0 && (di+dj)>k)\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tans+=k;\n\t\t\t}\n\t\t\telse if (ei != ej)\n\t\t\t\tflag = 1;\n\t\t\t\n\t\t\tif(flag==0 && i==j){\n\t\t\t\tmid = di;\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t\telse if(flag==0)\n\t\t\t\tans+=di+dj;\n\t\t}\n\t\t\n\t\tif (flag == 0 && m % 2 == 0) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t} else if (flag == 0 && m % 2 != 0) {\n\t\t\t//if(sum==68924)\n\t\t\t//System.out.println(\"1 \"+sum);\n\t\t\t//else\n\t\t\t\tSystem.out.println(sum);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(mid!=0)\n\t\t\t{\n\t\t\t\tif((mid*m)%k==0)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlong res = (sum-mid) + (mid*m)%k;\n\t\t\t\t\tif(res==1870)\n\t\t\t\t\t\tSystem.out.println(sum+\" \"+mid+\" \"+res);\n\t\t\t\t\telse\n\t\t\t\t\tSystem.out.println( res );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong res = sum*m - ans*(m-1);\n\t\t\t//res  = (sum - ans)*(m-2) + (ans+ (sum-ans)*2);\n\t\t\t//if(res == 68924)\n\t\t\t//System.out.println(\"3 \"+sum+\" \"+ans+\" \"+res);\n\t\t\t//else\n\t\t\tSystem.out.println(res);\n\n\t\t}\n\t}\n}\n\nclass Coup {\n\tlong ele;\n\tint count;\n\n\tpublic Coup(long i, int j) {\n\t\tthis.ele = i;\n\t\tthis.count = j;\n\t}\n}\n\nclass couple {\n\tint i, j;\n\n\tpublic couple(int i, int j) {\n\t\tthis.i = i;\n\t\tthis.j = j;\n\t}\n}\nclass MyScanner {\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic MyScanner() {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tString next() {\n\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tString nextLine() {\n\t\tString str = \"\";\n\t\ttry {\n\t\t\tstr = br.readLine();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn str;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nint n;\nlong long m, k;\nint a[maxn];\npair<int, int> stk[maxn];\nint top;\nint main() {\n  scanf(\"%d%lld%lld\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n  int lft = n;\n  for (int i = 1; i <= n; i++) {\n    if (!top || a[i] != stk[top].first)\n      stk[++top] = make_pair(a[i], 1);\n    else {\n      stk[top].second++;\n      if (stk[top].second == k) {\n        --top;\n        lft -= k;\n      }\n    }\n  }\n  int p = 0, l = 1, r = top;\n  while (p + 1 <= r && stk[p + 1].first == stk[r - p].first &&\n         stk[p + 1].second + stk[r - p].second == k)\n    ++p;\n  if (p == r) {\n    if (m % 2 == 0)\n      puts(\"0\");\n    else {\n      printf(\"%d\\n\", lft);\n    }\n    return 0;\n  }\n  if (r % 2 == 0 || (r % 2 == 1 && p != r / 2)) {\n    long long sum = 0, c = 0;\n    for (int i = 1; i <= p; i++) sum += stk[i].second + stk[r - i + 1].second;\n    for (int i = p + 1; i <= r - p; i++) c += stk[i].second;\n    sum += c * m;\n    sum -= (stk[p + 1].first == stk[r - p].first\n                ? (m - 1) * ((stk[p + 1].second + stk[r - p].second) / k * k)\n                : 0);\n    printf(\"%lld\\n\", sum);\n  } else {\n    if (p == r / 2) {\n      if (m * stk[p + 1].second % k == 0) {\n        puts(\"0\");\n      } else {\n        long long sum = 0;\n        for (int i = 1; i <= p; i++)\n          sum += stk[i].second + stk[r - i + 1].second;\n        sum += m * stk[p + 1].second % k;\n        printf(\"%lld\\n\", sum);\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m, cur;\nlong long a[100005][3];\nint main() {\n  scanf(\"%d %d %d\", &n, &k, &m);\n  for (int i = 1; i <= n; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    if (!cur || a[cur][0] != x) {\n      a[++cur][0] = x;\n      a[cur][1] = 1;\n    } else\n      ++a[cur][1];\n    if (a[cur][1] == k) a[cur--][1] -= k;\n  }\n  long long sum = 0;\n  for (int i = 1; i <= cur; ++i) sum += a[i][1];\n  int l = 1, r = cur;\n  while (l < r && a[l][0] == a[r][0]) {\n    if ((a[l][1] + a[r][1]) % k == 0)\n      ++l, --r;\n    else {\n      a[l][1] = (a[l][1] + a[r][1]) % k;\n      a[r][1] = 0;\n      break;\n    }\n  }\n  long long ans = 0;\n  if (l < r) {\n    for (int i = l; i <= r; ++i) ans += a[i][1];\n    ans *= m - 1;\n    ans += sum;\n  } else if (l == r && (a[l][1] * m % k))\n    ans = sum - a[l][1] + a[l][1] * m % k;\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nlong long MOD = 1e9 + 7;\nlong long d[2][10];\nlong long op(char c, long long a, long long b) {\n  if (c == '|') {\n    return b | a;\n  }\n  if (c == '&') {\n    return b & a;\n  }\n  if (c == '^') {\n    return b ^ a;\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k, m;\n  cin >> n >> k >> m;\n  long long aold = -1, a;\n  vector<pair<long long, long long> > mem;\n  for (int i = 0; i < n; i++) {\n    cin >> a;\n    if (aold == a) {\n      if (!mem.size()) {\n        while (true) {\n          long long kek = 1;\n        }\n      }\n      mem[mem.size() - 1].second++;\n      if (mem[mem.size() - 1].second == k) {\n        mem.pop_back();\n        if (mem.size())\n          aold = mem[mem.size() - 1].first;\n        else\n          aold = -1;\n      } else {\n        aold = a;\n      }\n    } else {\n      mem.push_back({a, 1});\n      aold = a;\n    }\n  }\n  if (mem.size() == 0) {\n    cout << n * m % k;\n    return 0;\n  }\n  if (mem.size() == 1) {\n    cout << mem[0].second * m % k;\n    return 0;\n  }\n  if (m == 1) {\n    long long ans = 0;\n    for (auto i : mem) {\n      ans += i.second;\n    }\n    cout << ans;\n    return 0;\n  }\n  long long l = 0, r = mem.size() - 1;\n  long long gv = 0;\n  while (l < r && (mem[l].first == mem[r].first) &&\n         ((mem[l].second + mem[r].second) % k == 0)) {\n    l++;\n    r--;\n  }\n  long long ans = 0;\n  if (l >= r) {\n    if (l == r) {\n      if (mem[l].second * m % k == 0) {\n        vector<pair<long long, long long> > kek;\n        for (int i = 0; i < l; i++) {\n          kek.push_back(mem[i]);\n        }\n        for (int i = r + 1; i < mem.size(); i++) {\n          if (kek.size() && kek[kek.size() - 1].first == mem[i].first) {\n            if ((kek[kek.size() - 1].second + mem[i].second) % k == 0)\n              kek.pop_back();\n            else {\n              kek[kek.size() - 1].second += mem[i].second;\n              kek[kek.size() - 1].second %= k;\n            }\n          } else {\n            kek.push_back(mem[i]);\n          }\n        }\n        ans = 0;\n        for (auto i : kek) {\n          ans += i.second;\n        }\n        cout << ans;\n        return 0;\n      } else {\n        ans = 0;\n        for (int i = 0; i < mem.size(); i++) {\n          if (i == l) {\n            ans += mem[l].second * m % k;\n          } else {\n            ans += mem[i].second;\n          }\n        }\n        cout << ans;\n        return 0;\n      }\n    }\n  } else {\n    if (l < r && mem[l].first == mem[r].first) {\n      gv = (mem[l].second + mem[r].second) / k * k;\n    }\n    for (int i = l; i <= r; i++) {\n      ans += mem[i].second;\n    }\n    if (m > 1) ans *= (m - 2);\n    ans -= gv * (m - 1);\n  }\n  for (int i = 0; i <= r; i++) {\n    ans += mem[i].second;\n  }\n  for (int i = l; i < mem.size(); i++) {\n    ans += mem[i].second;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, m, k;\nlong long res;\nint a[N];\nvector<pair<int, int> > vec;\nstack<int> st;\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> k >> m;\n  res = 1LL * n * m;\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i];\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (vec.size()) {\n      if (vec.back().first == a[i])\n        vec.push_back(pair<int, int>(a[i], vec.back().second + 1));\n      else\n        vec.push_back(pair<int, int>(a[i], 1));\n    } else\n      vec.push_back(pair<int, int>(a[i], 1));\n    if (vec.back().second == k) {\n      int tmp = k;\n      while (tmp--) vec.pop_back();\n      res -= 1LL * k * m;\n    }\n  }\n  n = vec.size();\n  for (int i = 1; i <= n; ++i) {\n    a[i] = vec[i - 1].first;\n  }\n  int L = 1, R = n;\n  while (1) {\n    if (a[L] != a[R]) break;\n    int cnt = 0;\n    int tmp = a[L];\n    while (a[L] == tmp) L++, cnt++;\n    while (a[R] == tmp) R--, cnt++;\n    if (L > R) {\n      cnt >>= 1;\n      res -= 1LL * cnt * m / k * k;\n      if (1LL * cnt * m % k == 0) {\n        while (st.size()) {\n          int tmp = st.top();\n          st.pop();\n          res -= tmp / k * k;\n          if (tmp % k) break;\n        }\n      }\n      break;\n    } else {\n      res -= 1LL * cnt / k * k * (m - 1);\n      st.push(cnt);\n      if (cnt % k) break;\n    }\n  }\n  cout << res;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m, ans;\nlong long a[100200], p[100200], ct[100200], cnt;\nint main() {\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  for (int i = 1, j = 1; i <= n; i = j) {\n    for (; a[i] == a[j] && j <= n; j++)\n      ;\n    if ((j - i) % k) {\n      ct[++cnt] = (j - i) % k;\n      p[cnt] = a[i];\n      if (cnt > 1 && p[cnt] == p[cnt - 1]) {\n        cnt--;\n        ct[cnt] = (ct[cnt] + ct[cnt + 1]) % k;\n        if (!ct[cnt]) cnt--;\n      }\n    }\n  }\n  int i = 1, j = cnt, el = 0;\n  while (p[i] == p[j] && (ct[i] + ct[j]) % k == 0 && i <= j)\n    el += ct[i++] + ct[j--];\n  if (i < j) {\n    if (p[i] == p[j]) el += ct[i] + ct[j] - (ct[i] + ct[j]) % k;\n    for (int l = 1; l <= cnt; l++) ans += ct[l];\n    ans = ans * m - el * (m - 1);\n  } else if (i == j) {\n    int po = ct[i] * m % k;\n    if (po) {\n      for (int l = 1; l <= cnt; l++) ans += ct[l];\n      ans -= ct[i] - po;\n    }\n  } else if (m % 2) {\n    for (int i = 1; i <= cnt; i++) ans += ct[i];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n/**\n * @author Don Li\n */\npublic class TeamsFormation {\n    \n    void solve() {\n        int n = in.nextInt(), k = in.nextInt(), m = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = in.nextInt();\n        \n        Deque<int[]> qu = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            if (!qu.isEmpty() && qu.getLast()[0] == a[i]) {\n                if (++qu.getLast()[1] == k) qu.removeLast();\n            } else {\n                qu.offerLast(new int[]{a[i], 1});\n            }\n        }\n        \n        n = qu.size();\n        List<int[]> pairs = new ArrayList<>(qu);\n        int len = 0;\n        for (int i = 0; i < n; i++) len += pairs.get(i)[1];\n        \n        int p = 0;\n        for (int i = 0; i < n; i++) {\n            int[] u = pairs.get(i), v = pairs.get(n - 1 - i);\n            if (u[0] == v[0] && u[1] + v[1] == k) {\n                p++;\n            } else {\n                break;\n            }\n        }\n        \n        if (p >= (n + 1) / 2) {\n            out.println(m % 2 == 0 ? 0 : len);\n            return;\n        }\n        \n        if (n % 2 == 1 && p == n / 2) {\n            long center = (long) pairs.get(p)[1] * m;\n            if (center % k == 0) {\n                out.println(0);\n            } else {\n                out.println(len - pairs.get(p)[1] + center % k);\n            }\n            return;\n        }\n        \n        long ans = (long) len * m, del = 0;\n        for (int i = 0; i < p; i++) del += pairs.get(i)[1];\n        for (int i = n - p; i < n; i++) del += pairs.get(i)[1];\n        int[] u = pairs.get(p), v = pairs.get(n - 1 - p);\n        if (u[0] == v[0] && u[1] + v[1] >= k) del += k;\n        out.println(ans - (m - 1) * del);\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new TeamsFormation().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    _, k, m = [int(x) for x in input().split()]\n    a = []\n    last = (\"-1\", 0)\n    a.append(last)\n    for ai in input().split():\n        if last[0] == ai:\n            last = (ai, last[1]+1)\n            a[-1] = last\n        else:\n            last = (ai, 1)\n            a.append(last)\n\n        if last[1] == k:\n            a.pop()\n            last = a[-1]\n    a.pop(0)\n\n    s1 = 0\n    while len(a) > 0 and a[0][0] == a[-1][0]:\n        if len(a) == 1:\n            s = a[0][1] * m\n            r1 = s % k\n            if r1 == 0:\n                print(s1 % k)\n            else:\n                print(r1 + s1)\n            return\n        join = a[0][1] + a[-1][1]\n\n        if join < k:\n            break\n        elif join % k == 0:\n            s1 += join\n            a.pop()\n            a.pop(0)\n        else:\n            s1 += (join // k) * k\n            a[0] = (a[0][0], join % k)\n            a.pop()\n            break\n\n    s = 0\n    for ai in a:\n        s += ai[1]\n\n    print(s*m + s1)\n\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 10;\nstruct node {\n  int x, y;\n} mp[MAXN];\nint main() {\n  long long n, k, m;\n  cin >> n >> k >> m;\n  int top = 0;\n  for (int i = 0; i < n; i++) {\n    int t;\n    cin >> t;\n    if (top == 0 || mp[top].x != t) {\n      mp[++top].x = t;\n      mp[top].y = 1;\n    } else\n      mp[top].y = (mp[top].y + 1) % k;\n    if (mp[top].y == 0) top--;\n  }\n  long long rec = 0, rec2 = 0;\n  for (int i = 1; i <= top; i++) rec += mp[i].y;\n  int l = 1, r = top;\n  while (l < r && mp[l].x == mp[r].x && (mp[l].y + mp[r].y) % k == 0) {\n    rec2 += mp[l].y + mp[r].y;\n    l++;\n    r--;\n  }\n  long long ans = 0;\n  if (l == r) {\n    if (mp[l].y * m % k == 0) {\n      cout << 0 << endl;\n      return 0;\n    }\n    ans = rec * m - rec2 * (m - 1) - mp[l].y * m / k * k;\n  } else {\n    if (mp[l].x == mp[r].x) rec2 += (mp[l].y + mp[r].y) / k * k;\n    ans = rec * m - rec2 * (m - 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, k, m;\n  cin >> n >> k >> m;\n  vector<long long> repeating(n);\n  long long repeatingSize = n;\n  long long nonRepeating = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> repeating[i];\n  }\n  list<pair<long long, long long>> frequency;\n  long long c = -1;\n  long long f = 0;\n  for (int i = 0; i < n; i++) {\n    if (repeating[i] == c) {\n      f++;\n      if (f == k) {\n        repeatingSize -= k;\n        if (frequency.empty()) {\n          c = -1;\n          f = 0;\n        } else {\n          c = frequency.back().first;\n          f = frequency.back().second;\n          frequency.pop_back();\n        }\n      }\n    } else {\n      if (c >= 0) {\n        frequency.push_back(pair<long long, long long>(c, f));\n      }\n      c = repeating[i];\n      f = 1;\n    }\n  }\n  if (c >= 0) {\n    frequency.push_back(pair<long long, long long>(c, f));\n  }\n  if (m > 1) {\n    while (frequency.size() > 1 &&\n           frequency.front().first == frequency.back().first &&\n           frequency.front().second + frequency.back().second >= k) {\n      long long x = frequency.front().first;\n      long long count = frequency.front().second + frequency.back().second;\n      repeatingSize -= k;\n      nonRepeating += k;\n      frequency.pop_back();\n      frequency.pop_front();\n      if (count != k) {\n        frequency.push_back(pair<long long, long long>(x, count - k));\n      }\n    }\n  }\n  if (frequency.size() == 1) {\n    if ((frequency.front().second * m) % k == 0) {\n      nonRepeating = 0;\n    } else {\n      nonRepeating += (frequency.front().second * m) % k;\n    }\n    repeatingSize = 0;\n  }\n  cout << (nonRepeating + repeatingSize * m) << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e5 + 10;\nlong long Stack[M][2];\nint main() {\n  int n, k, m, x, top = 0;\n  long long ans = 0;\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> x;\n    if (!top || Stack[top][0] != x) {\n      Stack[++top][0] = x;\n      Stack[top][1] = 1;\n    } else\n      Stack[top][1]++;\n    if (Stack[top][1] == k) {\n      Stack[top--][1] -= k;\n    }\n  }\n  long long sum = 0;\n  for (int i = 1; i <= top; i++) {\n    sum += Stack[i][1];\n  }\n  int sta = 1, ed = top;\n  while (sta < ed && Stack[sta][0] == Stack[ed][0]) {\n    if ((Stack[sta][1] + Stack[ed][1]) % k == 0) {\n      sta++;\n      ed--;\n    } else {\n      Stack[sta][1] = (Stack[sta][1] + Stack[ed][1]) % k;\n      Stack[ed][1] = 0;\n      break;\n    }\n  }\n  if (sta < ed) {\n    for (int i = sta; i <= ed; i++) ans += Stack[i][1];\n    ans *= (m - 1);\n    ans += sum;\n  } else if (sta == ed) {\n    if (Stack[sta][1] * m % k == 0)\n      ans = 0;\n    else {\n      ans = sum + Stack[sta][1] * (m - 1);\n      ans -= Stack[sta][1] * m - Stack[sta][1] * m % k;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  int N, K, M;\n  cin >> N >> K >> M;\n  vector<int> A(N);\n  for (auto& x : A) cin >> x;\n  deque<pair<int, int>> B;\n  for (int x : A) {\n    if (B.empty() || B.back().first != x)\n      B.push_back({x, 1});\n    else {\n      B.back().second += 1;\n      if (B.back().second == K) B.pop_back();\n    }\n  }\n  if (B.size() == 0) {\n    cout << 0 << endl;\n  } else if (B.size() == 1) {\n    long long n = B.back().second;\n    n *= M;\n    cout << n % K << endl;\n  } else if (M == 1) {\n    long long n = 0;\n    for (auto x : B) n += x.second;\n    cout << n << endl;\n  } else {\n    auto head = B;\n    auto body = B;\n    auto tail = B;\n    while (head.size() > 0 && tail.size() > 0 && body.size() >= 2 &&\n           head.back().first == body.front().first) {\n      (body.front().second += head.back().second) %= K;\n      if (body.front().second == 0) {\n        body.pop_front();\n        tail.pop_front();\n      } else {\n        tail.front().second = body.front().second;\n      }\n      head.pop_back();\n      body.pop_back();\n    }\n    if (body.size() == 1) {\n      int k = body.back().first;\n      long long n = body.back().second;\n      n *= M - 2;\n      if (head.size() > 0 && tail.size() > 0 && head.back().first == k &&\n          tail.front().first == k) {\n        n += head.back().second;\n        n += tail.front().second;\n        n %= K;\n        head.pop_back();\n        tail.pop_front();\n        body.clear();\n        if (n > 0) head.push_back({k, (int)n});\n      } else if (head.size() > 0 && head.back().first == k) {\n        n += head.back().second;\n        n %= K;\n        head.pop_back();\n        body.clear();\n        if (n > 0) head.push_back({k, (int)n});\n      } else if (tail.size() > 0 && tail.front().first == k) {\n        n += tail.front().second;\n        n %= K;\n        tail.pop_front();\n        body.clear();\n        if (n > 0) head.push_back({k, (int)n});\n      }\n    }\n    if (body.size() == 0) {\n      while (head.size() > 0 && tail.size() > 0 &&\n             head.back().first == tail.front().first) {\n        (tail.front().second += head.back().second) %= K;\n        if (tail.front().second == 0) {\n          tail.pop_front();\n        }\n        head.pop_back();\n      }\n    }\n    long long r = 0;\n    for (auto x : body) r += x.second;\n    r *= M - 2;\n    for (auto x : head) r += x.second;\n    for (auto x : tail) r += x.second;\n    cout << r << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nint n, k, m, a[MAXN];\nlong long S[MAXN][2];\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  memset(S, 0, sizeof(S));\n  int top = 0;\n  for (int i = 0; i < n; i++) {\n    if (!top || S[top][0] != a[i]) {\n      S[++top][0] = a[i];\n      S[top][1] = 1;\n    } else\n      S[top][1]++;\n    if (S[top][1] == k) S[top--][1] -= k;\n  }\n  long long sum = 0;\n  for (int i = 1; i <= top; i++) sum += S[i][1];\n  int s = 1, e = top;\n  while (s < e && S[s][0] == S[e][0]) {\n    if ((S[s][1] + S[e][1]) % k == 0) {\n      s++, e--;\n    } else {\n      S[s][1] = (S[s][1] + S[e][1]) % k;\n      S[e][1] = 0;\n      break;\n    }\n  }\n  long long mid = 0;\n  for (int i = s; i <= e; i++) mid += S[i][1];\n  long long ans;\n  if (s == e) {\n    if (((long long)m * mid) % k == 0)\n      ans = 0;\n    else {\n      ans = ((long long)m * mid) % k;\n      ans += sum;\n      ans -= mid;\n    }\n  } else if (s < e) {\n    ans = sum + (long long)mid * (m - 1);\n  } else if (s > e) {\n    ans = 0;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.Collection;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Rustam Musin (PloadyFree@gmail.com)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            int m = in.readInt();\n            List<IntIntPair> all = new ArrayList<>(n); //{type, size}\n            for (int i = 0; i < n; i++) {\n                int type = in.readInt();\n                if (!all.isEmpty() && all.get(all.size() - 1).first == type) {\n                    if (last(all).second == k - 1) {\n                        all.remove(all.size() - 1);\n                    } else {\n                        all.set(all.size() - 1, IntIntPair.makePair(type, last(all).second + 1));\n                    }\n                } else {\n                    all.add(IntIntPair.makePair(type, 1));\n                }\n            }\n\n            long size = 0;\n            for (IntIntPair p : all) {\n                size += p.second;\n            }\n            size *= m;\n\n            if (all.size() == 1) {\n                out.print(size % k);\n                return;\n            }\n            if (m == 1 || size == 0 || all.get(0).first != last(all).first) {\n                out.print(size);\n                return;\n            }\n//        if ((all.get(0).second + last(all).second) % k != 0) {\n//            long remove = all.get(0).second + last(all).second;\n//            remove = remove / k * k;\n//            size -= (m - 1) * remove;\n//            out.print(size);\n//            return;\n//        }\n\n            Deque<IntIntPair>[] parts = new Deque[3];\n            parts[0] = new ArrayDeque<>(all);\n            parts[1] = new ArrayDeque<>(all);\n            parts[2] = new ArrayDeque<>(all);\n\n            while (true) {\n                if (parts[1].size() == 1) {\n                    long middle = parts[1].peek().second * (long) m;\n                    if (middle % k == 0) {\n                        size -= middle;\n                        parts[0].pollLast();\n                        parts[2].pollFirst();\n                        size -= merge(parts[0], parts[2], k);\n                        break;\n                    } else {\n                        size -= middle / k * k;\n                        break;\n                    }\n                }\n                if (parts[1].peekFirst().first != parts[1].peekLast().first) {\n                    break;\n                }\n                long curSize = parts[1].peekFirst().second + parts[1].peekLast().second;\n                if (curSize % k != 0) {\n                    size -= (m - 1) * (curSize / k * k);\n                    break;\n                } else {\n                    parts[1].pollFirst();\n                    parts[1].pollLast();\n                    size -= (m - 1) * curSize;\n                    parts[0].pollLast();\n                    parts[2].pollFirst();\n                }\n            }\n\n            out.print(size);\n        }\n\n        int merge(Deque<IntIntPair> q1, Deque<IntIntPair> q2, int k) {\n            int result = 0;\n            while (!q1.isEmpty()) {\n                if (q1.peekLast().first != q2.peekFirst().first) {\n                    break;\n                }\n                int sz = q1.pollLast().second + q2.pollFirst().second;\n                result += sz / k * k;\n                if (sz % k != 0) {\n                    break;\n                }\n            }\n            return result;\n        }\n\n        <T> T last(List<T> a) {\n            return a.get(a.size() - 1);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void print(long i) {\n            writer.print(i);\n        }\n\n    }\n\n    static class IntIntPair implements Comparable<IntIntPair> {\n        public final int first;\n        public final int second;\n\n        public static IntIntPair makePair(int first, int second) {\n            return new IntIntPair(first, second);\n        }\n\n        public IntIntPair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            IntIntPair pair = (IntIntPair) o;\n\n            return first == pair.first && second == pair.second;\n        }\n\n\n        public int hashCode() {\n            int result = first;\n            result = 31 * result + second;\n            return result;\n        }\n\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        @SuppressWarnings({\"unchecked\"})\n        public int compareTo(IntIntPair o) {\n            int value = Integer.compare(first, o.first);\n            if (value != 0) {\n                return value;\n            }\n            return Integer.compare(second, o.second);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nlong long n, k, m, p[N], rnk[N], sz[N], a[N];\nint prv[N], nxt[N], base[N];\nset<int> st;\nvoid init(int n) {\n  for (int i = 0; i < n; i++)\n    p[i] = i, sz[i] = 1, prv[i] = i - 1, nxt[i] = i + 1;\n}\nint _find(int x) { return (p[x] == x ? x : p[x] = _find(p[x])); }\nint mrg(int x, int y) {\n  if (a[x] != a[y]) return -1;\n  x = _find(x);\n  y = _find(y);\n  if (x == y) return -1;\n  if (rnk[x] > rnk[y]) swap(x, y);\n  p[x] = y;\n  rnk[y] += rnk[x] == rnk[y];\n  sz[y] += sz[x];\n  nxt[y] = max(nxt[y], nxt[x]);\n  prv[y] = min(prv[y], prv[x]);\n  if (st.count(x)) st.erase(x);\n  if (st.count(y)) st.erase(y);\n  if (sz[y] % k == 0) st.insert(y);\n  return y;\n}\nint main() {\n  scanf(\"%I64d%I64d%I64d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) scanf(\"%I64d\", &a[i]);\n  init(n);\n  for (int i = 0; i < n; i++) {\n    if (i) mrg(i - 1, i);\n    if (i + 1 < n) mrg(i, i + 1);\n  }\n  for (int i = 0; i < n; i++)\n    if (p[i] == i && sz[i] % k == 0) st.insert(i);\n  while (!st.empty()) {\n    int i = *st.begin();\n    st.erase(st.begin());\n    i = _find(i);\n    if (prv[i] != -1) nxt[_find(prv[i])] = nxt[i];\n    if (nxt[i] != n) prv[_find(nxt[i])] = prv[i];\n    if (prv[i] != -1 && nxt[i] != n) mrg(prv[i], nxt[i]);\n  }\n  vector<pair<long long, long long> > v;\n  long long ans = 0;\n  for (int i = 0; i < n; i++)\n    if (i == p[i]) {\n      ans += (sz[i] - sz[i] % k) * m;\n      if (sz[i] % k) v.push_back({a[i], sz[i] % k});\n    }\n  if (!v.empty()) {\n    for (int i = 0, j = v.size() - 1; i < v.size(); i++, j--) {\n      if (v[i].first != v[j].first) break;\n      long long sum = 0;\n      if (i == j)\n        sum = v[i].second * m;\n      else\n        sum = v[i].second + v[j].second;\n      long long res = (sum / k) * k;\n      if (i < j)\n        ans += res * (m - 1);\n      else\n        ans += res;\n      if (sum % k != 0) break;\n    }\n  }\n  printf(\"%I64d\\n\", n * m - ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<int, int> *arr = new pair<int, int>[100001];\nlong long county(int left, long long n, long long k, long long m) {\n  if (arr[left].first == arr[n - 1 - left].first) {\n    if (left == n - 1 - left) {\n      return (long long)((m * arr[left].second) % k);\n    }\n    if (arr[left].second + arr[n - 1 - left].second == k) {\n      long long result = k + county(left + 1, n, k, m);\n      if (result == k)\n        return 0;\n      else\n        return result;\n    }\n    if (arr[left].second + arr[n - 1 - left].second > k) {\n      long long sum = 0;\n      for (int i = left + 1; i <= n - 2 - left; i++) {\n        sum += arr[i].second;\n      }\n      return (\n          long long)(m * sum + arr[left].second + arr[n - 1 - left].second +\n                     (m - 1) *\n                         ((arr[left].second + arr[n - 1 - left].second) % k));\n    }\n    if (arr[left].second + arr[n - 1 - left].second < k) {\n      long long sum = 0;\n      for (int i = left; i <= n - 1 - left; i++) {\n        sum += arr[i].second;\n      }\n      return sum * m;\n    }\n  } else {\n    long long sum = 0;\n    for (int i = left; i <= n - 1 - left; i++) {\n      sum += arr[i].second;\n    }\n    return (long long)(sum * m);\n  }\n}\nint main() {\n  long long n, k, m;\n  cin >> n;\n  cin >> k;\n  cin >> m;\n  int count = 0;\n  for (int i = 0; i < n; i++) {\n    int number;\n    cin >> number;\n    if (i == 0) {\n      arr[count] = make_pair(number, 1);\n      continue;\n    }\n    if (number == arr[count].first) {\n      arr[count].second++;\n      if (arr[count].second == k) {\n        if (count == 0) {\n          arr[count].second = 0;\n        } else\n          count--;\n      }\n    } else {\n      count++;\n      arr[count] = make_pair(number, 1);\n    }\n  }\n  if (count == 0) {\n    if (arr[count].second == 0) {\n      cout << 0;\n      return 0;\n    }\n  }\n  if (arr[0].second == 0) {\n    cout << county(1, count + 2, k, m);\n    return 0;\n  }\n  long long answer = county(0, count + 1, k, m);\n  cout << answer;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\ntemplate <typename...>\nstatic inline int getchar_unlocked(void) {\n  return getchar();\n}\ntemplate <typename...>\nstatic inline void putchar_unlocked(int c) {\n  putchar(c);\n}\nvoid reader(int& x) {\n  int k, m = 0;\n  x = 0;\n  for (;;) {\n    (k) = getchar_unlocked();\n    if (k == '-') {\n      m = 1;\n      break;\n    }\n    if ('0' <= k && k <= '9') {\n      x = k - '0';\n      break;\n    }\n  }\n  for (;;) {\n    (k) = getchar_unlocked();\n    if (k < '0' || k > '9') break;\n    x = x * 10 + k - '0';\n  }\n  if (m) x = -x;\n}\nvoid reader(ll& x) {\n  int k, m = 0;\n  x = 0;\n  for (;;) {\n    (k) = getchar_unlocked();\n    if (k == '-') {\n      m = 1;\n      break;\n    }\n    if ('0' <= k && k <= '9') {\n      x = k - '0';\n      break;\n    }\n  }\n  for (;;) {\n    (k) = getchar_unlocked();\n    if (k < '0' || k > '9') break;\n    x = x * 10 + k - '0';\n  }\n  if (m) x = -x;\n}\nint reader(char c[]) {\n  int i, s = 0;\n  for (;;) {\n    (i) = getchar_unlocked();\n    if (i != ' ' && i != '\\n' && i != '\\r' && i != '\\t' && i != EOF) break;\n  }\n  c[s++] = i;\n  for (;;) {\n    (i) = getchar_unlocked();\n    if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break;\n    c[s++] = i;\n  }\n  c[s] = '\\0';\n  return s;\n}\nint reader(string& c) {\n  int i;\n  for (;;) {\n    (i) = getchar_unlocked();\n    if (i != ' ' && i != '\\n' && i != '\\r' && i != '\\t' && i != EOF) break;\n  }\n  c.push_back(i);\n  for (;;) {\n    (i) = getchar_unlocked();\n    if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break;\n    c.push_back(i);\n  };\n  return ((int)c.size());\n}\ntemplate <class T, class S>\nvoid reader(T& x, S& y) {\n  reader(x);\n  reader(y);\n}\ntemplate <class T, class S, class U>\nvoid reader(T& x, S& y, U& z) {\n  reader(x);\n  reader(y);\n  reader(z);\n}\ntemplate <class T, class S, class U, class V>\nvoid reader(T& x, S& y, U& z, V& w) {\n  reader(x);\n  reader(y);\n  reader(z);\n  reader(w);\n}\nvoid writer(int x, char c) {\n  int s = 0, m = 0;\n  char f[10];\n  if (x < 0) m = 1, x = -x;\n  while (x) f[s++] = x % 10, x /= 10;\n  if (!s) f[s++] = 0;\n  if (m) putchar_unlocked('-');\n  while (s--) putchar_unlocked(f[s] + '0');\n  putchar_unlocked(c);\n}\nvoid writer(ll x, char c) {\n  int s = 0, m = 0;\n  char f[20];\n  if (x < 0) m = 1, x = -x;\n  while (x) f[s++] = x % 10, x /= 10;\n  if (!s) f[s++] = 0;\n  if (m) putchar_unlocked('-');\n  while (s--) putchar_unlocked(f[s] + '0');\n  putchar_unlocked(c);\n}\nvoid writer(const char c[]) {\n  int i;\n  for (i = 0; c[i] != '\\0'; i++) putchar_unlocked(c[i]);\n}\nvoid writer(const string& x, char c) {\n  int i;\n  for (i = 0; x[i] != '\\0'; i++) putchar_unlocked(x[i]);\n  putchar_unlocked(c);\n}\nvoid writer(const char x[], char c) {\n  int i;\n  for (i = 0; x[i] != '\\0'; i++) putchar_unlocked(x[i]);\n  putchar_unlocked(c);\n}\ntemplate <class T>\nvoid writerLn(T x) {\n  writer(x, '\\n');\n}\ntemplate <class T, class S>\nvoid writerLn(T x, S y) {\n  writer(x, ' ');\n  writer(y, '\\n');\n}\ntemplate <class T, class S, class U>\nvoid writerLn(T x, S y, U z) {\n  writer(x, ' ');\n  writer(y, ' ');\n  writer(z, '\\n');\n}\ntemplate <class T>\nvoid writerArr(T x[], int n) {\n  if (!n) {\n    putchar_unlocked('\\n');\n    return;\n  }\n  for (int i = 0; i < (n - 1); i++) writer(x[i], ' ');\n  writer(x[n - 1], '\\n');\n}\ntemplate <class T>\nvoid writerArr(vector<T>& x) {\n  writerArr(x.data(), (int)x.size());\n}\ntemplate <class T>\nvoid chmin(T& a, const T& b) {\n  if (a > b) a = b;\n}\ntemplate <class T>\nvoid chmax(T& a, const T& b) {\n  if (a < b) a = b;\n}\ntemplate <class T>\nT gcd(T a, T b) {\n  return b ? gcd(b, a % b) : a;\n}\ntemplate <class T>\nT lcm(T a, T b) {\n  return a / gcd(a, b) * b;\n}\nll mod_pow(ll a, ll n, ll mod) {\n  ll ret = 1;\n  ll p = a % mod;\n  while (n) {\n    if (n & 1) ret = ret * p % mod;\n    p = p * p % mod;\n    n >>= 1;\n  }\n  return ret;\n}\ntemplate <class T>\nT extgcd(T a, T b, T& x, T& y) {\n  for (T u = y = 1, v = x = 0; a;) {\n    T q = b / a;\n    swap(x -= q * u, u);\n    swap(y -= q * v, v);\n    swap(b -= q * a, a);\n  }\n  return b;\n}\ntemplate <class T>\nT mod_inv(T a, T m) {\n  T x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\nint main() {\n  ll n, k, m;\n  reader(n, k, m);\n  vector<ll> a(n);\n  for (int i = 0; i < (n); i++) reader(a[i]);\n  vector<Pll> q;\n  for (int i = 0; i < (n); i++) {\n    if (((int)q.size()) && q.back().first == a[i]) {\n      q.back().second++;\n    } else {\n      q.emplace_back(a[i], 1);\n    }\n    if (((int)q.size()) && q.back().second == k) {\n      q.pop_back();\n    }\n  }\n  ll ans = 0;\n  if (m == 1) {\n    for (auto& kv : q) ans += kv.second;\n  } else {\n    int l = 0, r = ((int)q.size()) - 1;\n    int remcnt = 0;\n    bool sk = false;\n    while (l < r) {\n      if (q[l].first == q[r].first) {\n        ll nf = q[l].first;\n        ll ns = q[l].second + q[r].second;\n        if (ns < k) {\n          break;\n        } else if (ns == k) {\n          l++;\n          r--;\n          remcnt++;\n        } else {\n          sk = true;\n          r--;\n          l++;\n          remcnt++;\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    vector<Pll> mdl;\n    for (int i = l; i <= r; i++) {\n      mdl.push_back(q[i]);\n    }\n    if (((int)mdl.size()) == 1 && !sk) {\n      vector<Pll> cur;\n      for (int i = 0; i < (r + 1); i++) cur.push_back(q[i]);\n      ll rem = ll(mdl[0].second) * (m - 2) % k;\n      cur.emplace_back(mdl[0].first, rem);\n      for (int i = l; i < ((int)q.size()); i++) cur.emplace_back(q[i]);\n      vector<Pll> q2;\n      for (auto& kv : cur) {\n        if (((int)q2.size()) && q2.back().first == kv.first) {\n          q2.back().second += kv.second;\n        } else {\n          q2.emplace_back(kv);\n        }\n        if (((int)q2.size()) && q2.back().second >= k) {\n          q2.back().second -= k;\n          if (q2.back().second == 0) {\n            q2.pop_back();\n          }\n        }\n      }\n      for (auto& kv : q2) ans += kv.second;\n    } else if (!sk) {\n      for (int i = 0; i <= r; i++) ans += q[i].second;\n      ll rcnt = 0;\n      for (auto& kv : mdl) rcnt += kv.second;\n      ans += rcnt * (m - 2);\n      for (int i = l; i < ((int)q.size()); i++) ans += q[i].second;\n    } else {\n      for (auto& kv : q) ans += kv.second;\n      ans *= m;\n      ans -= ll(remcnt) * k * (m - 1);\n    }\n  }\n  writerLn(ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    public static void main(String[] args) throws Exception {\n        MyReader reader = new MyReader(System.in);\n        MyWriter writer = new MyWriter(System.out);\n        new Solution().run(reader, writer);\n        writer.close();\n    }\n\n    private void run(MyReader reader, MyWriter writer) throws IOException {\n        int n = reader.nextInt();\n        int k = reader.nextInt();\n        long m = reader.nextInt();\n        int[] a = reader.nextIntArray(n);\n        boolean b = true;\n        for (int i = 1; i < n; i++) {\n            if (a[i] != a[i - 1]) {\n                b = false;\n                break;\n            }\n        }\n        if (b) {\n            writer.print(m * n % k);\n            return;\n        }\n        if (k > n - 1) {\n            writer.print(m * n);\n            return;\n        }\n        int i = 0;\n        int[] q = new int[n];\n        int[] e = new int[n];\n        for (int j = 0; j < n; j++) {\n            e[i] = a[j];\n            if (i == 0) {\n                q[i++] = 1;\n            } else {\n                q[i] = e[i] == e[i - 1] ? q[i - 1] + 1 : 1;\n                if (q[i] == k) {\n                    i -= k;\n                }\n                i++;\n            }\n        }\n        if (i == 0) {\n            writer.print(0);\n            return;\n        }\n        if (q[i - 1] == i) {\n            writer.print(m * i % k);\n            return;\n        }\n        int l = 0;\n        int r = i - 1;\n        int[] w = new int[n];\n        w[i - 1] = 1;\n        for (int j = i - 2; j >= 0; j--) {\n            w[j] = e[j] == e[j + 1] ? w[j + 1] + 1 : 1;\n        }\n        while (e[l] == e[r]) {\n            if ((r - l + 1) >= k && w[l] + q[r] >= k) {\n                r -= (k - w[l]);\n                l += w[l];\n            } else {\n                break;\n            }\n        }\n        b = true;\n        for (int j = l; j < r; j++) {\n            if (e[j] != e[j + 1]) {\n                b = false;\n            }\n        }\n        if (b) {\n            long t = (r - l + 1) * m % k;\n            a = new int[2 * n];\n            int y = 0;\n            for (int j = 0; j < l; j++) {\n                a[y++] = e[j];\n            }\n            for (int j = 0; j < t; j++) {\n                a[y++] = e[l];\n            }\n            for (int j = r + 1; j < i; j++) {\n                a[y++] = e[j];\n            }\n            q = new int[y];\n            e = new int[y];\n            i = 0;\n            for (int j = 0; j < y; j++) {\n                e[i] = a[j];\n                if (i == 0) {\n                    q[i++] = 1;\n                } else {\n                    q[i] = e[i] == e[i - 1] ? q[i - 1] + 1 : 1;\n                    if (q[i] == k) {\n                        i -= k;\n                    }\n                    i++;\n                }\n            }\n            writer.print(i);\n        } else {\n            writer.print(l + i - 1 - r + m * (r - l + 1));\n        }\n    }\n\n    static class MyReader {\n\n        final BufferedInputStream in;\n        final int bufSize = 1 << 16;\n        final byte buf[] = new byte[bufSize];\n        int i = bufSize;\n        int k = bufSize;\n        final StringBuilder str = new StringBuilder();\n\n        MyReader(InputStream in) {\n            this.in = new BufferedInputStream(in, bufSize);\n        }\n\n        int nextInt() throws IOException {\n            return (int) nextLong();\n        }\n\n        int[] nextIntArray(int n) throws IOException {\n            int[] m = new int[n];\n            for (int i = 0; i < n; i++) {\n                m[i] = nextInt();\n            }\n            return m;\n        }\n\n        int[][] nextIntMatrix(int n, int m) throws IOException {\n            int[][] a = new int[n][0];\n            for (int j = 0; j < n; j++) {\n                a[j] = nextIntArray(m);\n            }\n            return a;\n        }\n\n        long nextLong() throws IOException {\n            int c;\n            long x = 0;\n            boolean sign = true;\n            while ((c = nextChar()) <= 32) ;\n            if (c == '-') {\n                sign = false;\n                c = nextChar();\n            }\n            if (c == '+') {\n                c = nextChar();\n            }\n            while (c >= '0') {\n                x = x * 10 + (c - '0');\n                c = nextChar();\n            }\n            return sign ? x : -x;\n        }\n\n        long[] nextLongArray(int n) throws IOException {\n            long[] m = new long[n];\n            for (int i = 0; i < n; i++) {\n                m[i] = nextLong();\n            }\n            return m;\n        }\n\n        int nextChar() throws IOException {\n            if (i == k) {\n                k = in.read(buf, 0, bufSize);\n                i = 0;\n            }\n            return i >= k ? -1 : buf[i++];\n        }\n\n        String nextString() throws IOException {\n            int c;\n            str.setLength(0);\n            while ((c = nextChar()) <= 32 && c != -1) ;\n            if (c == -1) {\n                return null;\n            }\n            while (c > 32) {\n                str.append((char) c);\n                c = nextChar();\n            }\n            return str.toString();\n        }\n\n        String nextLine() throws IOException {\n            int c;\n            str.setLength(0);\n            while ((c = nextChar()) <= 32 && c != -1) ;\n            if (c == -1) {\n                return null;\n            }\n            while (c != '\\n') {\n                str.append((char) c);\n                c = nextChar();\n            }\n            return str.toString();\n        }\n\n        char[] nextCharArray() throws IOException {\n            return nextString().toCharArray();\n        }\n\n        char[][] nextCharMatrix(int n) throws IOException {\n            char[][] a = new char[n][0];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextCharArray();\n            }\n            return a;\n        }\n    }\n\n    static class MyWriter {\n\n        final BufferedOutputStream out;\n        final int bufSize = 1 << 16;\n        final byte buf[] = new byte[bufSize];\n        int i = 0;\n        final byte c[] = new byte[30];\n        static final String newLine = System.getProperty(\"line.separator\");\n\n        MyWriter(OutputStream out) {\n            this.out = new BufferedOutputStream(out, bufSize);\n        }\n\n        void print(long x) throws IOException {\n            int j = 0;\n            if (i + 30 >= bufSize) {\n                flush();\n            }\n            if (x < 0) {\n                buf[i++] = (byte) ('-');\n                x = -x;\n            }\n            while (j == 0 || x != 0) {\n                c[j++] = (byte) (x % 10 + '0');\n                x /= 10;\n            }\n            while (j-- > 0)\n                buf[i++] = c[j];\n        }\n\n        void print(int[] m) throws IOException {\n            for (int a : m) {\n                print(a);\n                print(' ');\n            }\n        }\n\n        void print(long[] m) throws IOException {\n            for (long a : m) {\n                print(a);\n                print(' ');\n            }\n        }\n\n        void print(String s) throws IOException {\n            for (int i = 0; i < s.length(); i++) {\n                print(s.charAt(i));\n            }\n        }\n\n        void print(char x) throws IOException {\n            if (i == bufSize) {\n                flush();\n            }\n            buf[i++] = (byte) x;\n        }\n\n        void print(char[] m) throws IOException {\n            for (char c : m) {\n                print(c);\n            }\n        }\n\n        void println(String s) throws IOException {\n            print(s);\n            println();\n        }\n\n        void println() throws IOException {\n            print(newLine);\n        }\n\n        void flush() throws IOException {\n            out.write(buf, 0, i);\n            out.flush();\n            i = 0;\n        }\n\n        void close() throws IOException {\n            flush();\n            out.close();\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long N, K, M, ret;\nstack<long long> ori, compress;\ndeque<long long> nums;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(18);\n  cin >> N >> K >> M;\n  ret = N * M;\n  for (long long i = 0; i < N; i++) {\n    long long x;\n    cin >> x;\n    if (ori.size() == 0 || ori.top() != x) {\n      ori.push(x);\n      compress.push(1);\n    } else {\n      long long temp = compress.top();\n      compress.pop();\n      compress.push(temp + 1);\n    }\n    if (compress.top() == K) {\n      ret -= K * M;\n      ori.pop();\n      compress.pop();\n    }\n  }\n  while (ori.size() > 0) {\n    for (long long i = 0; i < compress.top(); i++) nums.push_front(ori.top());\n    ori.pop();\n    compress.pop();\n  }\n  while (nums.size() > 0) {\n    long long cnt = 0, x = nums.front();\n    while (nums.size() > 0 && nums.front() == x) {\n      cnt++;\n      nums.pop_front();\n    }\n    while (nums.size() > 0 && nums.back() == x) {\n      cnt++;\n      nums.pop_back();\n    }\n    if (nums.size() == 0) {\n      long long sub = cnt * M;\n      if (sub % K == 0) {\n        ret = 0;\n        break;\n      } else\n        ret -= (sub / K) * K;\n    } else if (cnt % K == 0)\n      ret -= cnt * (M - 1);\n    else {\n      ret -= (cnt / K) * K * (M - 1);\n      break;\n    }\n  }\n  cout << ret << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class c>\nstruct rge {\n  c b, e;\n};\ntemplate <class c>\nrge<c> range(c i, c j) {\n  return rge<c>{i, j};\n}\ntemplate <class c>\nauto dud(c* x) -> decltype(cerr << *x, 0);\ntemplate <class c>\nchar dud(...);\nstruct debug {\n  template <class c>\n  debug& operator<<(const c&) {\n    return *this;\n  }\n};\nconst int N = 1e5 + 5;\nlong long n, k, m, p[N], rnk[N], sz[N], a[N];\nint prv[N], nxt[N], base[N];\nset<int> st;\nvoid init(int n) {\n  for (int i = 0; i < n; i++)\n    p[i] = i, sz[i] = 1, prv[i] = i - 1, nxt[i] = i + 1;\n}\nint _find(int x) { return (p[x] == x ? x : p[x] = _find(p[x])); }\nint mrg(int x, int y) {\n  if (a[x] != a[y]) return -1;\n  x = _find(x);\n  y = _find(y);\n  if (x == y) return -1;\n  if (rnk[x] > rnk[y]) swap(x, y);\n  p[x] = y;\n  rnk[y] += rnk[x] == rnk[y];\n  sz[y] += sz[x];\n  nxt[y] = max(nxt[y], nxt[x]);\n  prv[y] = min(prv[y], prv[x]);\n  if (st.count(x)) st.erase(x);\n  if (sz[y] % k == 0) st.insert(y);\n  return y;\n}\nint main() {\n  scanf(\"%I64d%I64d%I64d\", &n, &k, &m);\n  vector<pair<long long, long long> > v;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%I64d\", &a[i]);\n    if (v.empty() || v.back().first != a[i])\n      v.push_back({a[i], 1});\n    else {\n      v.back().second++;\n      if (v.back().second == k) ans += k * m, v.pop_back();\n    }\n  }\n  if (!v.empty()) {\n    for (int i = 0, j = v.size() - 1; i < v.size(); i++, j--) {\n      if (v[i].first != v[j].first) break;\n      long long sum = 0;\n      if (i == j)\n        sum = v[i].second * m;\n      else\n        sum = v[i].second + v[j].second;\n      long long res = (sum / k) * k;\n      if (i < j)\n        ans += res * (m - 1);\n      else\n        ans += res;\n      if (sum % k != 0) break;\n    }\n  }\n  printf(\"%I64d\\n\", n * m - ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nstruct node {\n  int x, y;\n  node() {}\n  node(int x, int y) : x(x), y(y) {}\n} a[N];\nint n, k, m, nn;\nint c[N];\nlong long solve(int l, int r) {\n  int i, j;\n  if (l > r) return 0;\n  if (c[l] != c[r]) return 1ll * (r - l + 1) * m;\n  for (i = l; i < r && c[i] == c[i + 1]; i++)\n    ;\n  for (j = r; j > l && c[j] == c[j - 1]; j--)\n    ;\n  if (i == r) return 1ll * m * (r - l + 1) % k;\n  int len = i - l + 1 + r - j + 1;\n  long long s;\n  len = len % k;\n  if (len == 0) {\n    s = solve(i + 1, j - 1);\n    if (!s)\n      return 0;\n    else\n      return s + 1ll * k;\n  }\n  return 1ll * (m - 1) * len + 1ll * (j - i - 1) * m + 1ll * (i - l + 1) % k +\n         1ll * (r - j + 1) % k;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &c[i]);\n    if (c[i] == a[nn].x)\n      a[nn].y++;\n    else\n      a[++nn] = node(c[i], 1);\n    if (a[nn].y == k) nn--;\n  }\n  if (!nn) {\n    printf(\"%d\\n\", nn);\n    return 0;\n  }\n  n = 0;\n  for (int i = 1; i <= nn; i++) {\n    while (a[i].y) {\n      a[i].y--;\n      c[++n] = a[i].x;\n    }\n  }\n  if (m == 1) {\n    printf(\"%d\\n\", n);\n    return 0;\n  }\n  printf(\"%I64d\\n\", solve(1, n));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, k, m;\nlong long int a[100005];\nlong long int b[100005];\nlong long int in = 1;\nint main() {\n  scanf(\"%lld\", &n);\n  scanf(\"%lld\", &k);\n  scanf(\"%lld\", &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld\", &a[i]);\n  }\n  long long int i = 1, j = 1;\n  long long int ans = n * m;\n  while (i <= n && j <= n) {\n    while (j <= n && a[i] == a[j]) j++;\n    ans -= (((j - i) / k) * k) * m;\n    if ((j - i) % k != 0) {\n      if (a[in - 1] == a[i]) {\n        ans -= (((b[in - 1] + ((j - i) % k)) / k) * k) * m;\n        b[in - 1] = (b[in - 1] + ((j - i) % k)) % k;\n        if (b[in - 1] == 0) in--;\n      } else {\n        b[in] = (j - i) % k;\n        a[in] = a[i];\n        in++;\n      }\n    }\n    i = j;\n  }\n  i = 1, j = in - 1;\n  while (i <= n && j >= 1) {\n    if (i > j) {\n      if (a[i] == a[j]) {\n        ans -= (((b[i] + b[j]) / k) * k);\n        if ((b[i] + b[j]) % k == 0) {\n          i++, j--;\n        } else\n          break;\n      } else\n        break;\n      continue;\n    }\n    if (a[i] == a[j]) {\n      if (j == i + 1) {\n        ans -= (((b[i] + b[j]) * m) / k) * k;\n        if (((b[i] + b[j]) * m) % k == 0) {\n          i++, j--;\n        } else\n          break;\n        continue;\n      }\n      if (i != j) {\n        ans -= (((b[i] + b[j]) / k) * k) * (m - 1);\n        if ((b[i] + b[j]) % k == 0) {\n          i++, j--;\n        } else\n          break;\n      } else {\n        ans -= (((b[i] * m) / k) * k);\n        if ((m * b[i]) % k == 0)\n          i++, j--;\n        else\n          break;\n      }\n    } else\n      break;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m;\nint a[100000 + 10], f[100000 + 10];\nint main() {\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) scanf(\"%d\", a + i);\n  vector<pair<int, int> > g;\n  for (int i = 0; i < n; i++) {\n    if (g.size() == 0 || g.back().first != a[i])\n      g.push_back(make_pair(a[i], 1));\n    else\n      g.back().second++;\n    if (g.back().second == k) g.pop_back();\n  }\n  long long ans = 0;\n  for (int i = 0; i != g.size(); i++) ans += g[i].second;\n  if (g.size() == 0 || m == 1) {\n    cout << ans << endl;\n    return 0;\n  }\n  ans *= m;\n  int i = 0, j = g.size();\n  j--;\n  while (i < j) {\n    if (g[i].first == g[j].first && g[i].second + g[j].second == k) {\n      i++;\n      j--;\n      ans -= (long long)(m - 1) * k;\n      continue;\n    }\n    long long extra = 0;\n    if (g[i].first == g[j].first && g[i].second + g[j].second >= k)\n      extra += (long long)k * (m - 1);\n    ans -= extra;\n    cout << ans << endl;\n    return 0;\n  }\n  if (i > j)\n    cout << 0 << endl;\n  else {\n    if (((long long)m) * g[i].second % k == 0)\n      ans = 0;\n    else\n      ans -= (((long long)m) * g[i].second / k) * k;\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntemplate <typename T>\nT gcd(T a, T b) {\n  T m;\n  while (b != T(0)) {\n    m = a % b;\n    a = b;\n    b = m;\n  }\n  return a;\n}\ntemplate <typename T>\nT lcm(T a, T b) {\n  return a == 0 && b == 0 ? 0 : (a / gcd(a, b)) * b;\n}\nint const MAXN = 1 << 19;\nint N, M, K;\nint solve() {\n  std::vector<std::pair<int, int> > st;\n  cin >> N >> K >> M;\n  for (int i = 1; i <= N; ++i) {\n    int a;\n    cin >> a;\n    if (!st.empty() && st.back().first == a)\n      st.back().second++;\n    else\n      st.push_back(std::pair<int, int>(a, 1));\n    if (st.back().second == K) st.pop_back();\n  }\n  if (st.empty()) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  int rn = st.size();\n  if (rn == 1) {\n    long long total = st[0].second * 1ll * M;\n    printf(\"%lld\\n\", (long long)(total % K));\n    return 0;\n  }\n  if (st[0].first != st.back().first || st[0].second + st.back().second < K) {\n    long long ans = 0;\n    for (std::pair<int, int> p : st) ans += p.second;\n    ans *= M;\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n  int p = 0;\n  while (p < rn && st[p].first == st[rn - p - 1].first &&\n         st[p].second + st[rn - p - 1].second == K)\n    ++p;\n  if (p >= (rn + 1) / 2) p = rn;\n  if (p == rn) {\n    long long ans = 0;\n    if (M % 2 == 0)\n      ans = 0;\n    else {\n      for (std::pair<int, int> p : st) ans += p.second;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n  if (rn % 2 == 1 && p == rn / 2) {\n    long long ans = 0;\n    long long middle = M * 1ll * st[p].second;\n    if (middle % K == 0)\n      ans = 0;\n    else {\n      for (int i = 0; i < p; ++i) ans += st[i].second;\n      ans += middle % K;\n      for (int i = p + 1; i < rn; ++i) ans += st[i].second;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n  {\n    long long ans = 0;\n    for (int i = 0; i < p; ++i) ans += st[i].second;\n    for (int i = p; i < rn - p; ++i) ans += st[i].second * 1ll * M;\n    for (int i = rn - p; i < rn; ++i) ans += st[i].second;\n    if (st[p].first == st[rn - p - 1].first &&\n        st[p].second + st[rn - p - 1].second >= K) {\n      ans -= (M - 1) * 1ll * K;\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\nint main(int argc, char* argv[]) {\n  ::std::ios::sync_with_stdio(false);\n  ::std::cin.tie(0);\n  ::std::cout.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100050;\nint S[N], C[N], c, k, a[N];\nvoid Add(int f) {\n  if (S[c] != f) {\n    S[++c] = f;\n    C[c] = 1;\n  } else\n    C[c]++;\n  if (C[c] == k) c--;\n}\nint main() {\n  int n, m, i;\n  scanf(\"%i %i %i\", &n, &k, &m);\n  for (i = 1; i <= n; i++) scanf(\"%i\", &a[i]), Add(a[i]);\n  if (c == 0) return 0 * printf(\"0\\n\");\n  if (c == 1) return 0 * printf(\"%lld\\n\", (long long)C[1] * m % k);\n  long long ans = 0;\n  for (i = 1; i <= c; i++) ans += C[i];\n  long long tmp = ans;\n  for (i = 1; i <= c / 2; i++) {\n    if (S[i] == S[c - i + 1]) {\n      if (C[i] + C[c - i + 1] >= k) tmp -= k;\n      if (C[i] + C[c - i + 1] != k) break;\n    } else\n      break;\n  }\n  if (!(c % 2 == 1 && i == (c + 1) / 2)) {\n    ans += tmp * (m - 1);\n    printf(\"%lld\\n\", ans);\n  } else {\n    long long ost = (long long)C[(c + 1) / 2] * m % k;\n    if (ost == 0) {\n      c = c / 2;\n      int f = c;\n      for (i = f + 2; i <= f * 2 + 1; i++)\n        for (int j = 1; j <= C[i]; j++) Add(S[i]);\n      ans = 0;\n      for (i = 1; i <= c; i++) ans += C[i];\n      printf(\"%lld\\n\", ans);\n    } else\n      printf(\"%lld\\n\", ans - C[(c + 1) / 2] + ost);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m;\nlong long a[100005], num, p, sum;\nstruct node {\n  long long v, h;\n} nd[100005];\nint main() {\n  cin >> n >> k >> m;\n  for (int i = 1; i <= n; i++) scanf(\"%I64d\", &a[i]);\n  for (int i = 1; i <= n; i++) {\n    if (a[i] != nd[num].v) {\n      nd[++num].v = a[i];\n      nd[num].h = 1;\n    } else if (++nd[num].h == k)\n      num--;\n  }\n  for (int i = 1; i <= num; i++) sum += nd[i].h;\n  if (k >= sum) {\n    if (num != 1)\n      cout << sum * m << endl;\n    else\n      cout << (sum * m) % k << endl;\n    return 0;\n  }\n  long long les = 0, flag = 0;\n  for (int i = 1; i <= num; i++) {\n    if (nd[i].v != nd[num - i + 1].v) break;\n    if ((nd[i].h + nd[num - i + 1].h) % k) {\n      if (num % 2 && i == (num + 1) / 2) flag = 1;\n      les += nd[i].h + nd[num - i + 1].h - (nd[i].h + nd[num - i + 1].h) % k;\n      break;\n    }\n    les += nd[i].h + nd[num - i + 1].h;\n  }\n  if (les == 2 * sum) {\n    cout << (m % 2) * sum << endl;\n  } else if (flag) {\n    if (nd[(num + 1) / 2].h * m % k == 0)\n      printf(\"0\\n\");\n    else\n      cout << nd[(num + 1) / 2].h * m % k + sum - nd[(num + 1) / 2].h << endl;\n  } else\n    cout << sum * m - (m - 1) * les << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100002;\nint n, k, m, cnt;\nint a[N], b[N], c[N];\nlong long ans = 0;\nint main() {\n  cnt = 0;\n  int i, j, o, sum = 0;\n  int l, r;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (i = 1; i <= n; ++i) {\n    if (a[i] != b[cnt]) {\n      b[++cnt] = a[i];\n      c[cnt] = 1;\n    } else {\n      c[cnt]++;\n      if (c[cnt] == k) cnt--;\n    }\n  }\n  if (!cnt) {\n    puts(\"0\");\n    return 0;\n  }\n  for (i = 1; i <= cnt; ++i) sum += c[i];\n  for (o = 0, i = 1; i < cnt + 1 - i; ++i) {\n    if (b[i] == b[cnt + 1 - i] && c[i] + c[cnt + 1 - i] == k)\n      o += k;\n    else\n      break;\n  }\n  if (i < cnt + 1 - i) {\n    if (b[i] == b[cnt + 1 - i] && c[i] + c[cnt + 1 - i] > k) o += k;\n    ans = 1ll * sum * m - 1ll * o * (m - 1);\n  } else {\n    ans = 1ll * c[i] * m % k;\n    if (ans) ans += sum - c[i];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst double Pi = acos(-1.0);\nusing namespace std;\nlong long n, k, m;\ndeque<pair<int, int> > bus;\nint main(int argc, char** argv) {\n  scanf(\"%lld %lld %lld\", &n, &k, &m);\n  int a;\n  long long tot = 0;\n  pair<int, int> cur = pair<int, int>(-1, -1);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a);\n    tot++;\n    if (a != cur.first) {\n      if (cur.first != -1) bus.push_back(cur);\n      cur = pair<int, int>(a, 1);\n    } else {\n      cur.second++;\n      if (cur.second == k) {\n        tot -= k;\n        if (!bus.empty()) {\n          cur = bus.back();\n          bus.pop_back();\n        } else\n          cur = pair<int, int>(-1, -1);\n      }\n    }\n  }\n  if (cur.first != -1 && cur.second != k) bus.push_back(cur);\n  int sz = bus.size();\n  long long del = 0;\n  while (!bus.empty()) {\n    pair<int, int> b = bus.back(), f = bus.front();\n    if (b.first != f.first) break;\n    int add = b.second + f.second;\n    if (add >= k) del += k;\n    if (add != k) break;\n    bus.pop_back();\n    if (!bus.empty()) bus.pop_front();\n  }\n  if (bus.empty())\n    printf(\"%lld\\n\", (m & 1) * tot);\n  else {\n    if ((sz & 1) && (int)bus.size() == 1) {\n      long long rem = bus.back().second, mid = (rem * m) % k;\n      printf(\"%lld\\n\", (mid) ? tot - rem + mid : 0);\n    } else\n      printf(\"%lld\\n\", m * tot - (m - 1) * del);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 87;\npair<int, int> a[N];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, k, m, w = 0, c = 0;\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    if (!w || a[w - 1].first != x)\n      a[w++] = {x, 1};\n    else\n      a[w - 1].second++;\n    c += a[w - 1].second / k;\n    if (!(a[w - 1].second %= k)) --w;\n  }\n  c *= m;\n  if (m >= 2) {\n    int l = 0, r = w - 1;\n    for (; r - l + 1 >= 2; ++l, --r) {\n      if (a[l].first != a[r].first) break;\n      long long s = a[l].second + a[r].second;\n      c += s / k * (m - 1);\n      if (s % k) break;\n    }\n    if (r - l + 1 == 1) {\n      long long s = a[l].second * m;\n      c += s / k;\n      if (s % k == 0) {\n        while (--l >= 0 && ++r < w) {\n          if (a[l].first != a[r].first) break;\n          s = a[l].second + a[r].second;\n          c += s / k;\n          if (s % k) break;\n        }\n      }\n    }\n  }\n  cout << n * m - c * k << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m, ans;\nint a[(100000 + 100)], f[(100000 + 100)], t[(100000 + 100)], top;\nint L, R;\nvoid readxx() {\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n}\nvoid work() {\n  for (int i = 1; i <= n; i++) {\n    t[++top] = a[i];\n    if (top == 1 || t[top] != t[top - 1])\n      f[top] = 1;\n    else\n      f[top] = f[top - 1] + 1;\n    if (f[top] == k) top -= k;\n  }\n  L = 1;\n  R = top;\n  while (L < R && t[L] == t[R]) {\n    int l = L, r = R, cnt = 0;\n    while (l < r && t[l] == t[L] && cnt < k) ++cnt, ++l;\n    while (l < r && t[r] == t[R] && cnt < k) ++cnt, --r;\n    if (cnt == k)\n      ans += k, L = l, R = r;\n    else\n      break;\n  }\n}\nvoid findAns() {\n  bool fg = true;\n  for (int i = L + 1; i <= R; i++) {\n    if (t[i] != t[i - 1]) {\n      fg = false;\n      break;\n    }\n  }\n  if (fg)\n    printf(\"%lld\",\n           (1ll * (R - L + 1) * m % k) ? (1ll * (R - L + 1) * m % k + ans) : 0);\n  else\n    printf(\"%lld\", 1ll * (R - L + 1) * m + ans);\n}\nint main() {\n  readxx();\n  work();\n  findAns();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nvector<pair<long long int, long long int>> A;\nint main() {\n  long long int n, k, m;\n  scanf(\"%lld %lld %lld\", &n, &k, &m);\n  long long int temp;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lld\", &temp);\n    if ((!A.empty()) && (temp == A.back().first)) {\n      A.back().second++;\n      if (A.back().second == k) A.pop_back();\n    } else {\n      A.emplace_back(make_pair(temp, 1));\n    }\n  }\n  if (n == 1) {\n    return !(printf(\"%lld\", m % k));\n  }\n  long long int total = 0;\n  int start = 0, end = A.size() - 1;\n  for (auto &i : A) total += i.second;\n  if (m == 1 || total == 0) return !(printf(\"%lld\", total));\n  total *= m;\n  if (A[start].first != A[end].first) return !(printf(\"%lld\", total));\n  while (start < end) {\n    if (A[start].first != A[end].first) return !(printf(\"%lld\", total));\n    if (A[start].second + A[end].second == k) {\n      total -= (m - 1) * k;\n      start++;\n      end--;\n      continue;\n    }\n    if (A[start].second + A[end].second > k) total -= (m - 1) * k;\n    return !(printf(\"%lld\", total));\n  }\n  if (start > end) return !(printf(\"0\"));\n  if (start == end) {\n    long long int x = A[start].second * m;\n    if (x % k == 0) {\n      return !(printf(\"0\"));\n    } else {\n      return !(printf(\"%lld\", total - (x / k) * k));\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx44[5] = {0, -1, -1, 1, 1};\nconst int dy44[5] = {0, -1, 1, -1, 1};\nconst int dx4[5] = {0, -1, 0, 1, 0};\nconst int dy4[5] = {0, 0, 1, 0, -1};\nconst int dx8[9] = {0, -1, 0, 1, 0, 1, 1, -1, -1};\nconst int dy8[9] = {0, 0, 1, 0, -1, 1, -1, 1, -1};\nconst int maxn = 5e5 + 5;\nconst double PI = acos(-1.0);\nconst long long mod = 1e9 + 7;\nlong long po(long long a, long long b, long long mod) {\n  long long res = 1;\n  a %= mod;\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a % mod;\n    a = a * a % mod;\n  }\n  return res;\n}\nlong long gcd(long long a, long long b) {\n  if (a == 0) {\n    return b;\n  } else {\n    return gcd(b % a, a);\n  }\n}\nvoid YES() {\n  puts(\"YES\");\n  exit(0);\n}\nvoid Yes() { puts(\"Yes\"); }\nvoid NO() {\n  puts(\"NO\");\n  exit(0);\n}\nvoid No() { puts(\"No\"); }\nvoid one() {\n  puts(\"-1\");\n  exit(0);\n}\nint n, k, m;\nint val[maxn];\nvector<pair<int, int> > st;\nvoid solve() {\n  scanf(\"%d\", &(n)), scanf(\"%d\", &(k)), scanf(\"%d\", &(m));\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &(val[i]));\n    if (st.size() == 0) {\n      st.push_back(make_pair(val[i], 1));\n    } else {\n      auto t = st.back();\n      if (val[i] == t.first) {\n        st.back().second++;\n      } else {\n        st.push_back(make_pair(val[i], 1));\n      }\n    }\n    if (st.back().second == k) {\n      st.pop_back();\n    }\n  }\n  if (st.size() == 0) {\n    puts(\"0\");\n    return;\n  }\n  long long ans = 0;\n  for (int i = 0; i < st.size(); i++) {\n    ans += st[i].second;\n  }\n  ans *= m;\n  int le = 0;\n  int ri = st.size() - 1;\n  while (le < ri) {\n    if (st[le].first != st[ri].first) {\n      printf(\"%lld\\n\", ans);\n      return;\n    }\n    if (st[le].second + st[ri].second < k) {\n      printf(\"%lld\\n\", ans);\n      return;\n    }\n    ans -= 1LL * k * (m - 1);\n    if (st[le].second + st[ri].second > k) {\n      printf(\"%lld\\n\", ans);\n      return;\n    }\n    le++;\n    ri--;\n  }\n  if (le == ri) {\n    long long tmp = 1LL * st[le].second * m;\n    long long rem = tmp % k;\n    ans -= tmp - rem;\n    if (rem == 0) ans = 0;\n    printf(\"%lld\\n\", ans);\n  } else {\n    puts(\"0\");\n  }\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint test;\nvector<int> mpref, msuf, rpref, rsuf;\nlong long mcnt, rcnt;\nint n, k, m;\nint a[200000], inp[200000];\nvector<int> tmp;\nvoid mul(vector<int> &p, vector<int> &suf, vector<int> &pref, vector<int> &s,\n         vector<int> &rpref, vector<int> &rsuf, long long a, long long b,\n         long long &c) {\n  int ind = (int)suf.size() - 1;\n  int jnd = 0;\n  while (ind >= 0) {\n    int iind = ind;\n    int jjnd = jnd;\n    int cnt = 0;\n    while (cnt < k && iind >= 0 && suf[iind] == suf[ind]) {\n      ++cnt;\n      --iind;\n    }\n    while (cnt < k && jjnd < (int)pref.size() && pref[jjnd] == suf[ind]) {\n      ++cnt;\n      ++jjnd;\n    }\n    if (cnt == k) {\n      ind = iind;\n      jnd = jjnd;\n    } else {\n      break;\n    }\n  }\n  a -= (int)suf.size() - 1 - ind;\n  b -= jnd;\n  tmp.clear();\n  int aa = min(a, (long long)p.size());\n  for (int i = 0; i < (int)(aa); ++i) {\n    tmp.push_back(p[i]);\n  }\n  int bb = min(b, (long long)s.size());\n  for (int i = 0; i < (int)(bb); ++i) {\n    tmp.push_back(s[(int)s.size() - bb + i]);\n  }\n  c = a + b;\n  aa = min(2 * n + 111, (int)tmp.size());\n  rpref.clear();\n  rsuf.clear();\n  for (int i = 0; i < (int)(aa); ++i) rpref.push_back(tmp[i]);\n  for (int i = 0; i < (int)(aa); ++i)\n    rsuf.push_back(tmp[(int)tmp.size() - aa + i]);\n}\nvoid binPow(int p) {\n  rpref.clear();\n  rsuf.clear();\n  rcnt = 0;\n  while (p) {\n    if (p & 1) mul(rpref, rsuf, mpref, msuf, rpref, rsuf, rcnt, mcnt, rcnt);\n    p >>= 1;\n    if (p) mul(mpref, msuf, mpref, msuf, mpref, msuf, mcnt, mcnt, mcnt);\n  }\n}\nvector<int> st;\nlong long solve() {\n  int last = -1;\n  int cnt = 0;\n  st.clear();\n  int pos = 0;\n  int nn = n;\n  for (int i = 0; i < n; ++i) {\n    a[i] = inp[pos++];\n    if (a[i] != last) {\n      if (last != -1) {\n        st.push_back(cnt);\n      }\n      last = a[i];\n      cnt = 0;\n    }\n    if (++cnt == k) {\n      i -= k;\n      n -= k;\n      if (st.empty()) {\n        last = -1;\n        cnt = 0;\n      } else {\n        last = a[i];\n        cnt = st.back();\n        st.pop_back();\n      }\n    }\n  }\n  if (st.empty()) {\n    n = nn;\n    return (long long)n * m % k;\n  }\n  mpref.clear();\n  msuf.clear();\n  for (int i = 0; i < (int)(n); ++i) mpref.push_back(a[i]);\n  for (int i = 0; i < (int)(n); ++i) msuf.push_back(a[i]);\n  mcnt = n;\n  binPow(m);\n  n = nn;\n  return rcnt;\n}\nvoid readTest() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", inp + i);\n  }\n}\nmt19937 mt(123);\nvoid genTest() {\n  n = mt() % 25 + 1;\n  k = mt() % 25 + 1;\n  m = mt() % 25 + 1;\n  int cnt = mt() % 25 + 1;\n  for (int i = 0; i < (int)(n); ++i) {\n    inp[i] = mt() % cnt + 1;\n  }\n}\nlong long brute() {\n  int last = -1;\n  int cnt = 0;\n  st.clear();\n  int nn = n;\n  int ind = 0;\n  for (int _ = 0; _ < (int)(m); ++_) {\n    int pos = 0;\n    n = ind + nn;\n    for (int i = ind; i < n; ++i) {\n      a[i] = inp[pos++];\n      if (a[i] != last) {\n        if (last != -1) {\n          st.push_back(cnt);\n        }\n        last = a[i];\n        cnt = 0;\n      }\n      if (++cnt == k) {\n        i -= k;\n        n -= k;\n        if (st.empty()) {\n          last = -1;\n          cnt = 0;\n        } else {\n          last = a[i];\n          cnt = st.back();\n          st.pop_back();\n        }\n      }\n    }\n    ind = n;\n  }\n  n = nn;\n  return ind;\n}\nint main() {\n  readTest();\n  cout << solve() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Dv {\n  long long left;\n  long long right;\n  long long prev;\n  bool def;\n};\nvector<long long> solve(vector<long long> data, long long &del, long long m,\n                        long long k, long long n) {\n  vector<Dv> g;\n  for (long long i = 0; i < n; i++) {\n    Dv dv = {i - 1, i + 1, 0, false};\n    g.push_back(dv);\n  }\n  for (long long i = 0; i < n; i++) {\n    long long PREV;\n    if (g[i].left < 0) {\n      PREV = 1;\n    } else {\n      PREV = g[g[i].left].prev * (data[g[i].left] == data[i]) + 1;\n    }\n    g[i].prev = PREV;\n    long long R = g[i].right;\n    if (PREV >= k) {\n      g[i].def = true;\n      del += k * m;\n      long long now = g[i].left;\n      for (long long j = 0; j < k - 1; j++) {\n        g[now].def = true;\n        now = g[now].left;\n      }\n      if (R < n) g[R].left = now;\n      if (now >= 0) g[now].right = R;\n    } else if (R < n)\n      g[R].left = i;\n  }\n  vector<long long> ret;\n  long long ind = -1;\n  for (long long i = 0; i < n; i++) {\n    if (!g[i].def) {\n      ind = i;\n      break;\n    }\n  }\n  if (ind == -1) return ret;\n  while (ind < n) {\n    ret.push_back(data[ind]);\n    ind = g[ind].right;\n  }\n  return ret;\n}\nint32_t main() {\n  long long n, k, m;\n  cin >> n >> k >> m;\n  vector<long long> data(n);\n  for (long long i = 0; i < n; i++) cin >> data[i];\n  bool both = true;\n  for (long long i = 1; i < n; i++) {\n    both &= (data[i] == data[i - 1]);\n  }\n  if (both) {\n    cout << (n * m) % k << endl;\n    return 0;\n  }\n  long long del = 0;\n  long long N = data.size();\n  data = solve(data, del, m, k, n);\n  n = data.size();\n  if (n == 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (m == 1) {\n    cout << N - del << endl;\n    return 0;\n  }\n  vector<long long> prev(n), next(n);\n  next[n - 1] = 1;\n  for (long long i = n - 2; i >= 0; i--)\n    next[i] = (data[i] == data[i + 1]) * next[i + 1] + 1;\n  prev[0] = 1;\n  for (long long i = 1; i < n; i++)\n    prev[i] = (data[i] == data[i - 1]) * prev[i - 1] + 1;\n  long long L = 0, R = n - 1;\n  vector<long long> lk, rk;\n  bool prod = false;\n  while (true) {\n    if (next[L] == R - L + 1) {\n      long long ost = m * (R - L + 1);\n      long long och = ost % k;\n      del += ost - och;\n      if (och == 0) {\n        prod = true;\n      }\n      break;\n    }\n    if (data[L] != data[R]) break;\n    long long vm = next[L] + prev[R];\n    if (vm < k) {\n      cout << N * m - del << endl;\n      return 0;\n    }\n    long long OL = L;\n    long long P = next[L];\n    L += min(k, P);\n    for (long long j = OL; j < L; j++) {\n      lk.push_back(data[j]);\n    }\n    long long OR = R;\n    if (k > P) {\n      R -= k - P;\n    }\n    for (long long j = OR; j > R; j--) rk.push_back(data[j]);\n    del += k * (m - 1);\n  }\n  if (prod) {\n    if (lk.size() == 0 || rk.size() == 0) {\n      cout << N * m - del << endl;\n      return 0;\n    }\n    vector<long long> rrk;\n    for (long long j = rk.size() - 1; j >= 0; j--) rrk.push_back(rk[j]);\n    rk = rrk;\n    long long PREV[lk.size()], NEXT[rk.size()];\n    NEXT[rk.size() - 1] = 1;\n    long long SZ = rk.size();\n    for (long long i = SZ - 2; i >= 0; i--)\n      NEXT[i] = (rk[i] == rk[i + 1]) * NEXT[i + 1] + 1;\n    PREV[0] = 1;\n    for (long long i = 1; i < lk.size(); i++)\n      PREV[i] = (lk[i] == lk[i - 1]) * PREV[i - 1] + 1;\n    long long RR = lk.size() - 1;\n    long long LL = 0;\n    while (LL < rk.size() && RR >= 0) {\n      if (lk[RR] != rk[LL]) break;\n      long long SUM = PREV[RR] + NEXT[LL];\n      if (SUM < k) break;\n      long long ORR = RR;\n      RR -= min(PREV[ORR], k);\n      if (k > PREV[ORR]) {\n        LL += k - PREV[ORR];\n      }\n      del += k;\n    }\n  }\n  cout << N * m - del << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, K;\nlong long M;\nint A[100004];\nstruct IdCount {\n  int id, cnt;\n};\nconst bool trace = false;\nlong long solve() {\n  if (M <= 3) {\n    vector<IdCount> B;\n    for (int m = 0, _n = (M); m < _n; ++m) {\n      for (int i = 0, _n = (N); i < _n; ++i) {\n        if (B.empty() || A[i] != B.back().id)\n          B.push_back({A[i], 1});\n        else\n          B.back().cnt = (B.back().cnt + 1) % K;\n        if (B.back().cnt == 0) B.pop_back();\n      }\n    }\n    long long res = 0;\n    for (auto x : B) res += x.cnt;\n    return res;\n  }\n  vector<IdCount> B;\n  for (int i = 0, _n = (N); i < _n; ++i) {\n    if (B.empty() || A[i] != B.back().id)\n      B.push_back({A[i], 1});\n    else\n      B.back().cnt = (B.back().cnt + 1) % K;\n    if (B.back().cnt == 0) B.pop_back();\n  }\n  if (trace) {\n    for (auto x : B) fprintf(stderr, \"(%d:%d) \", x.id, x.cnt);\n    fprintf(stderr, \"\\n\");\n  }\n  if (int((B).size()) == 0) return 0;\n  if (int((B).size()) == 1) {\n    return (B[0].cnt * M) % K;\n  }\n  if (int((B).size()) == 2) {\n    long long res = 0;\n    for (auto x : B) res += x.cnt;\n    res *= M;\n    return res;\n  }\n  long long res = 0;\n  int L = 0, R = int((B).size()) - 1;\n  for (; L < R; ++L, --R) {\n    if (B[L].id != B[R].id) {\n      long long sum_mid = 0;\n      for (int i = (L), _b = (R); i <= _b; ++i) sum_mid += B[i].cnt;\n      res += sum_mid * M;\n      long long sum_ext = 0;\n      for (int i = (0), _b = (L - 1); i <= _b; ++i) sum_ext += B[i].cnt;\n      for (int i = (R + 1), _b = (int((B).size()) - 1); i <= _b; ++i)\n        sum_ext += B[i].cnt;\n      res += sum_ext;\n      return res;\n    }\n    long long sum = (B[L].cnt + B[R].cnt) % K;\n    if (sum != 0) {\n      res += sum * (M - 1);\n      long long sum_mid = 0;\n      for (int i = (L + 1), _b = (R - 1); i <= _b; ++i) sum_mid += B[i].cnt;\n      res += sum_mid * M;\n      long long sum_ext = 0;\n      for (int i = (0), _b = (L); i <= _b; ++i) sum_ext += B[i].cnt;\n      for (int i = (R), _b = (int((B).size()) - 1); i <= _b; ++i)\n        sum_ext += B[i].cnt;\n      res += sum_ext;\n      return res;\n    }\n  }\n  if (trace) fprintf(stderr, \"L: %d  R: %d\\n\", L, R);\n  res = 0;\n  if (L == R) {\n    long long sum = (B[L].cnt * M) % K;\n    if (sum != 0) {\n      res += sum;\n      for (int i = (0), _b = (L - 1); i <= _b; ++i) res += B[i].cnt;\n      for (int i = (R + 1), _b = (int((B).size()) - 1); i <= _b; ++i)\n        res += B[i].cnt;\n      return res;\n    } else\n      L++, R--;\n  }\n  for (; L < N && R >= 0; ++L, --R) {\n    if (B[R].id != B[L].id) {\n      long long sum_ext = 0;\n      for (int i = (0), _b = (R); i <= _b; ++i) sum_ext += B[i].cnt;\n      for (int i = (L), _b = (N - 1); i <= _b; ++i) sum_ext += B[i].cnt;\n      return res;\n    }\n    long long sum = (B[R].cnt + B[L].cnt) % K;\n    if (sum != 0) {\n      res = sum;\n      long long sum_ext = 0;\n      for (int i = (0), _b = (R - 1); i <= _b; ++i) sum_ext += B[i].cnt;\n      for (int i = (L + 1), _b = (N - 1); i <= _b; ++i) sum_ext += B[i].cnt;\n      return res;\n    }\n  }\n  return res;\n}\nint main(int argc, char* argv[]) {\n  scanf(\"%d %d %lld\", &N, &K, &M);\n  for (int i = 0, _n = (N); i < _n; ++i) scanf(\"%d\", A + i);\n  long long res = solve();\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std::chrono;\nconst long long big = 1000000007ll;\nconst long long big2 = 1000000009ll;\nlong long n, m, k, q, w, h, T;\nvector<long long> A;\nvector<long long> B;\nint main() {\n  long long a, b, c, d;\n  cin >> n >> k >> m;\n  long long prev = -1;\n  long long same = 1;\n  for (long long c1 = 0; c1 < n; c1++) {\n    cin >> a;\n    A.push_back(a);\n    if (a == prev) {\n      same++;\n    } else {\n      same = 1;\n    }\n    B.push_back(same);\n    if (same == k) {\n      for (long long c2 = 0; c2 < k; c2++) {\n        A.pop_back();\n        B.pop_back();\n      }\n    }\n    prev = -1;\n    same = 1;\n    if ((int)(A).size() != 0) {\n      prev = A[(int)(A).size() - 1];\n      same = B[(int)(B).size() - 1];\n    }\n  }\n  n = (int)(A).size();\n  long long r = n - 1;\n  long long l;\n  long long c1 = 0;\n  while (c1 < n) {\n    l = c1;\n    if (r - l + 1 < k) {\n      break;\n    } else {\n      long long r2 = r;\n      bool fail = 0;\n      long long amt = 1;\n      for (long long c2 = 0; c2 < k - 1; c2++) {\n        if (A[l] != A[r2]) {\n          break;\n        }\n        amt++;\n        r2--;\n      }\n      long long t = A[l];\n      long long oldl = l;\n      if (amt < k) {\n        l++;\n        while (A[l] == t) {\n          l++;\n          amt++;\n          if (amt == k) break;\n        }\n        l--;\n      }\n      if (amt < k) {\n        l = oldl;\n        break;\n      }\n      if (fail) break;\n      r = r2;\n    }\n    c1 = l;\n    c1++;\n  }\n  if (l >= r + 1) {\n    cout << \"0\\n\";\n  } else {\n    bool sim = 1;\n    long long one = A[l];\n    for (long long c1 = l; c1 <= r; c1++) {\n      if (A[c1] != one) sim = 0;\n    }\n    if (sim) {\n      vector<long long> A2;\n      vector<long long> A1;\n      c = ((m - 2) * (r - l + 1)) % k;\n      long long k1 = 0;\n      long long k2 = 0;\n      for (long long c1 = r; c1 >= 0; c1--) {\n        if (A[c1] != one) break;\n        k1++;\n        c++;\n      }\n      for (long long c1 = l; c1 < n; c1++) {\n        if (A[c1] != one) break;\n        k2++;\n        c++;\n      }\n      c %= k;\n      for (long long c1 = 0; c1 <= r - k1; c1++) {\n        A1.push_back(A[c1]);\n      }\n      for (long long c1 = l + k2; c1 < n; c1++) {\n        A2.push_back(A[c1]);\n      }\n      if (c != 0) {\n        cout << (int)(A1).size() + (int)(A2).size() + c << \"\\n\";\n      } else {\n        A.clear();\n        B.clear();\n        vector<long long> AA;\n        for (long long c1 = 0; c1 < (int)(A1).size(); c1++) {\n          AA.push_back(A1[c1]);\n        }\n        for (long long c1 = 0; c1 < (int)(A2).size(); c1++) {\n          AA.push_back(A2[c1]);\n        }\n        n = (int)(AA).size();\n        prev = -1;\n        same = 1;\n        for (long long c1 = 0; c1 < n; c1++) {\n          a = AA[c1];\n          A.push_back(a);\n          if (a == prev) {\n            same++;\n          } else {\n            same = 1;\n          }\n          B.push_back(same);\n          if (same == k) {\n            for (long long c2 = 0; c2 < k; c2++) {\n              A.pop_back();\n              B.pop_back();\n            }\n          }\n          prev = -1;\n          same = 1;\n          if ((int)(A).size() != 0) {\n            prev = A[(int)(A).size() - 1];\n            same = B[(int)(B).size() - 1];\n          }\n        }\n        cout << (int)(A).size() << \"\\n\";\n      }\n    } else {\n      cout << m * n - (m - 1) * (l + (n - 1 - r)) << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> s;\nlong long ans;\nint i, j, k, n, m, a[510001], b[510001], w, t1, t2, q[510001][2];\nlong long calc() {\n  int i, j, k;\n  long long res, s;\n  for (i = 1, k = 0; i <= n; i++) {\n    if (!k || q[k][0] != b[i]) {\n      q[++k][0] = b[i];\n      q[k][1] = 1;\n      continue;\n    }\n    if (++q[k][1] == w) k--;\n  }\n  for (i = 1, s = 0; i <= k; i++) s += q[i][1];\n  for (i = 0;\n       i < k && q[i + 1][0] == q[k - i][0] && q[i + 1][1] + q[k - i][1] == w;\n       i++)\n    ;\n  if (m == 1) return s;\n  if (i == k) {\n    if (m % 2 == 0) return 0;\n    return s;\n  }\n  if (i == k / 2) {\n    if ((long long)q[i + 1][1] * (long long)m % w == 0) return 0;\n    return s * (long long)m - (long long)i * (long long)w * (long long)(m - 1) -\n           (long long)q[i + 1][1] * (long long)m +\n           (long long)q[i + 1][1] * (long long)m % w;\n  }\n  res = s * (long long)m - (long long)i * (long long)w * (long long)(m - 1);\n  if (q[i + 1][0] == q[k - i][0] && q[i + 1][1] + q[k - i][1] > w)\n    res -= (long long)w * (long long)(m - 1);\n  return res;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &w, &m);\n  s.clear();\n  for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]), b[i] = a[i], s.insert(a[i]);\n  if (s.size() == 1) return cout << (long long)m * (long long)n % w << endl, 0;\n  ans = calc();\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> inlist, outlist;\nstack<pair<int, int> > s1, s2;\nint n, k, m, ai;\nvector<int> solve() {\n  outlist.clear();\n  for (int i = 0; i < inlist.size(); i++) {\n    if (s1.empty()) {\n      s1.push(make_pair(inlist[i], 1));\n      continue;\n    }\n    pair<int, int> last = s1.top();\n    if (inlist[i] == last.first) {\n      if ((last.second + 1) % k == 0) {\n        s1.pop();\n      } else {\n        last.second++;\n        s1.pop();\n        s1.push(last);\n      }\n    } else {\n      last.first = inlist[i];\n      last.second = 1;\n      s1.push(last);\n    }\n  }\n  while (!s1.empty()) {\n    pair<int, int> top = s1.top();\n    s2.push(top);\n    s1.pop();\n  }\n  int start_printing = false;\n  while (!s2.empty()) {\n    pair<int, int> top = s2.top();\n    for (int i = 0; i < top.second; i++) {\n      outlist.push_back(top.first);\n    }\n    s2.pop();\n  }\n  return outlist;\n}\nint main() {\n  scanf(\"%d %d %d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &ai);\n    inlist.push_back(ai);\n  }\n  unsigned long long remaining = (unsigned long long)n * (unsigned long long)m;\n  solve();\n  if (outlist.size() == 0)\n    remaining = 0LL;\n  else {\n    if (m == 1)\n      remaining = outlist.size();\n    else {\n      remaining -= ((unsigned long long)inlist.size() -\n                    (unsigned long long)outlist.size()) *\n                   (long long)m;\n      int count = 0;\n      bool started = false;\n      bool repeatdone = false;\n      for (int i = outlist.size() - 1, j = 0; i >= 0 && j < outlist.size();) {\n        if (outlist[i] != outlist[j])\n          break;\n        else if (started == false) {\n          count = 2;\n          started = true;\n        }\n        int nexti, nextj;\n        if (i == 0)\n          nexti = -1;\n        else\n          nexti = outlist[i - 1];\n        if (j == outlist.size() - 1)\n          nextj = -2;\n        else\n          nextj = outlist[j + 1];\n        if (nexti == outlist[i] && nextj == outlist[j]) {\n          i--;\n          j++;\n          count += 2;\n        } else if (nextj == outlist[j]) {\n          j++;\n          count++;\n        } else if (nexti == outlist[i]) {\n          i--;\n          count++;\n        } else {\n          if (i > j || repeatdone == true) {\n            if (count >= k) {\n              unsigned long long total = 0LL;\n              if (repeatdone == false)\n                total = ((unsigned long long)count -\n                         ((unsigned long long)count % (unsigned long long)k)) *\n                        ((unsigned long long)m - 1);\n              else\n                total = ((unsigned long long)count -\n                         ((unsigned long long)count % (unsigned long long)k));\n              remaining -= total;\n            }\n            if (count % k == 0) {\n              i--;\n              j++;\n              started = false;\n              count = 0;\n              continue;\n            } else\n              break;\n          } else {\n            repeatdone = true;\n            unsigned long long cnt =\n                ((unsigned long long)count / 2) * (unsigned long long)m;\n            if (cnt >= k) {\n              unsigned long long total =\n                  ((unsigned long long)count / 2 * (unsigned long long)m) -\n                  ((((unsigned long long)count / 2) * (unsigned long long)m) %\n                   (unsigned long long)k);\n              remaining -= total;\n            }\n            if (cnt % k == 0) {\n              i--;\n              j++;\n              started = false;\n              count = 0;\n              continue;\n            } else\n              break;\n          }\n        }\n      }\n      int x = 0;\n    }\n  }\n  printf(\"%llu\\n\", remaining);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  ll n, k, m;\n  cin >> n >> k >> m;\n  vector<array<int, 2>> b;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    if (b.empty() || b.back()[0] != x) {\n      b.push_back({x, 0});\n    }\n    b.back()[1]++;\n    if (b.back()[1] == k) b.pop_back();\n  }\n  n = b.size();\n  ll len = 0;\n  for (auto x : b) len += x[1];\n  if (b.size() == 0 || m == 1) {\n    cout << len << '\\n';\n    return 0;\n  }\n  ll r = 0, er = 0;\n  for (int i = 0; i < n; i++) {\n    if (b[n - 1 - i][0] != b[i][0]) break;\n    int sum = b[n - 1 - i][1] + b[i][1];\n    er += sum / k * k;\n    sum %= k;\n    if (sum) break;\n    r++;\n  }\n  if (r == n) {\n    cout << len * (m % 2) << '\\n';\n    return 0;\n  } else if (2 * r + 1 == n) {\n    ll sum = b[r][1] * m;\n    sum %= k;\n    if (sum)\n      cout << len - b[r][1] + sum << '\\n';\n    else\n      cout << 0 << '\\n';\n    return 0;\n  } else {\n    assert(2 * r < n);\n    cout << len * m - er * (m - 1) << '\\n';\n    return 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void amin(T &x, const T &y) {\n  if (y < x) x = y;\n}\ntemplate <class T>\ninline void amax(T &x, const T &y) {\n  if (x < y) x = y;\n}\ntemplate <class Iter>\nvoid rprintf(const char *fmt, Iter begin, Iter end) {\n  for (bool sp = 0; begin != end; ++begin) {\n    if (sp)\n      putchar(' ');\n    else\n      sp = true;\n    printf(fmt, *begin);\n  }\n  putchar('\\n');\n}\nint N, K, M;\nint A[100111];\nvoid task_same() {\n  long long z = (long long)N * M;\n  printf(\"%lld\\n\", z % K);\n}\ndeque<pair<int, long long> > cat(deque<pair<int, long long> > x,\n                                 const deque<pair<int, long long> > &y) {\n  for (__typeof((y).begin()) e = (y).begin(), e_end = (y).end(); e != e_end;\n       ++e) {\n    if (x.size() && x.back().first == e->first) {\n      x.back().second += e->second;\n      x.back().second %= K;\n      if (x.back().second == 0) x.pop_back();\n    } else {\n      x.push_back(*e);\n    }\n  }\n  return x;\n}\nvoid task() {\n  deque<pair<int, long long> > head, mid, tail;\n  long long cnt = 1;\n  int last = A[0];\n  for (int i = 1; i < N; i++) {\n    if (A[i] != last) {\n      cnt %= K;\n      if (cnt) {\n        if (!mid.empty() && mid.back().first == last) {\n          mid.back().second += cnt;\n          mid.back().second %= K;\n          if (mid.back().second == 0) mid.pop_back();\n        } else {\n          mid.push_back(make_pair(last, cnt));\n        }\n      }\n      last = A[i];\n      cnt = 1;\n    } else {\n      cnt++;\n    }\n  }\n  cnt %= K;\n  if (cnt) {\n    if (!mid.empty() && mid.back().first == last) {\n      mid.back().second += cnt;\n      mid.back().second %= K;\n      if (mid.back().second == 0) mid.pop_back();\n    } else {\n      mid.push_back(make_pair(last, cnt));\n    }\n  }\n  long long left = 0;\n  if (M == 1) {\n    for (__typeof((mid).begin()) e = (mid).begin(), e_end = (mid).end();\n         e != e_end; ++e)\n      left += e->second;\n  } else if (M == 2) {\n    mid = cat(mid, mid);\n    for (__typeof((mid).begin()) e = (mid).begin(), e_end = (mid).end();\n         e != e_end; ++e)\n      left += e->second;\n  } else {\n    head = tail = mid;\n    M -= 2;\n    while (!head.empty() && mid.size() >= 2u &&\n           head.back().first == mid[0].first) {\n      assert(head.back().second == mid.back().second);\n      assert(mid[0].second == tail[0].second);\n      head.back().second += mid[0].second;\n      mid.back().second += tail[0].second;\n      mid.pop_front();\n      tail.pop_front();\n      head.back().second %= K;\n      mid.back().second %= K;\n      if (head.back().second == 0) {\n        head.pop_back();\n        mid.pop_back();\n      }\n    }\n    if (mid.size() <= 1u) {\n      if (mid.empty()) {\n        head = cat(head, tail);\n      } else {\n        mid.back().second = (long long)mid.back().second * M % K;\n        head = cat(head, cat(mid, tail));\n      }\n      for (__typeof((head).begin()) e = (head).begin(), e_end = (head).end();\n           e != e_end; ++e)\n        left += e->second;\n    } else {\n      for (__typeof((head).begin()) e = (head).begin(), e_end = (head).end();\n           e != e_end; ++e)\n        left += e->second;\n      for (__typeof((mid).begin()) e = (mid).begin(), e_end = (mid).end();\n           e != e_end; ++e)\n        left += (long long)e->second * M;\n      for (__typeof((tail).begin()) e = (tail).begin(), e_end = (tail).end();\n           e != e_end; ++e)\n        left += e->second;\n    }\n  }\n  printf(\"%lld\\n\", left);\n}\nvoid MAIN() {\n  scanf(\"%d%d%d\", &N, &K, &M);\n  for (int i = 0, i_len = (N); i < i_len; ++i) scanf(\"%d\", A + i);\n  bool same = true;\n  for (int i = 0, i_len = (N - 1); i < i_len; ++i)\n    if (A[i] != A[i + 1]) same = false;\n  if (same)\n    task_same();\n  else\n    task();\n}\nint main() {\n  int TC = 1;\n  for (int tc = 0, tc_len = (TC); tc < tc_len; ++tc) MAIN();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Jenish\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DTeamsFormation solver = new DTeamsFormation();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DTeamsFormation {\n        int[] arr;\n        int n;\n        long k;\n        long m;\n\n        Deque<int[]> make_quee() {\n            Deque<int[]> res = new ArrayDeque<>();\n            for (int i = 0; i < n; i++) {\n                if (res.size() == 0) {\n                    res.add(new int[]{arr[i], 1});\n                } else {\n                    if (res.getLast()[0] == arr[i]) {\n                        res.getLast()[1]++;\n                        if (res.getLast()[1] == k) res.pollLast();\n                    } else {\n                        res.add(new int[]{arr[i], 1});\n                    }\n                }\n                if (res.size() != 0 && res.getLast()[1] == k) res.pollLast();\n            }\n            return res;\n        }\n\n        long remaining(Deque<int[]> q) {\n            long sum = 0;\n            for (int i[] : q) sum += i[1];\n            return sum;\n        }\n\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            n = in.scanInt();\n            k = in.scanInt();\n            m = in.scanInt();\n            arr = new int[n];\n            in.scanInt(arr);\n            Deque<int[]> a = make_quee();\n\n            long single = remaining(a);\n            if (single == 0) {\n                out.println(0);\n                return;\n            }\n\n\n            while (a.size() > 1 && a.getFirst()[0] == a.getLast()[0]) {\n                int num = a.getFirst()[0];\n                int aa = a.getFirst()[1];\n                int bb = a.getLast()[1];\n                a.pollLast();\n                a.pollFirst();\n                if (((aa + bb) % k) != 0) a.add(new int[]{num, (int) ((aa + bb) % k)});\n            }\n\n\n            long dou = remaining(a);\n\n\n            if (a.size() == 0) {\n                out.println(0);\n                return;\n            } else if (a.size() > 1) {\n                out.println((m - 1) * dou + single);\n            } else {\n                long e = (a.getFirst()[1] * m) % k;\n//            out.println(e);\n                if (e != 0) {\n                    out.println(e + single - dou);\n                } else {\n                    out.println(0);\n                }\n            }\n\n\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int INDEX;\n        private BufferedInputStream in;\n        private int TOTAL;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (INDEX >= TOTAL) {\n                INDEX = 0;\n                try {\n                    TOTAL = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (TOTAL <= 0) return -1;\n            }\n            return buf[INDEX++];\n        }\n\n        public int scanInt() {\n            int I = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    I *= 10;\n                    I += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * I;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n        public void scanInt(int[] A) {\n            for (int i = 0; i < A.length; i++) A[i] = scanInt();\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = (int)1e5 + 5;\nint arr[MAXN];\nint n, k, m;\nvoid solve() {\n  scanf(\"%d %d %d\", &n, &k, &m);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &arr[i]);\n  }\n  vector<pair<int, int> > S;\n  for (int i = 1; i <= n; ++i) {\n    if (!S.empty() && S.back().second == arr[i]) {\n      if (++S.back().first == k) {\n        S.pop_back();\n      }\n    } else {\n      S.push_back(make_pair(1, arr[i]));\n    }\n  }\n  int p = 0;\n  while (p < S.size() && S[p].second == S[S.size() - p - 1].second &&\n         S[p].first + S[S.size() - p - 1].first == k) {\n    ++p;\n  }\n  if (p == S.size()) {\n    if (m % 2) {\n      long long ans = 0;\n      for (auto it : S) {\n        ans += it.first;\n      }\n      printf(\"%lld\\n\", ans);\n      return;\n    }\n    printf(\"0\\n\");\n    return;\n  }\n  if (S.size() % 2 && p == S.size() / 2) {\n    int cur = (S[p].first * 1ll * m) % k;\n    if (cur > 0) {\n      long long ans = cur;\n      for (int i = 0; i < S.size(); ++i) {\n        if (i != p) {\n          ans += S[i].first;\n        }\n      }\n      printf(\"%lld\\n\", ans);\n      return;\n    } else {\n      printf(\"0\\n\");\n      return;\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i < S.size(); ++i) {\n    ans += S[i].first;\n  }\n  ans *= m;\n  ans -= (m - 1ll) * k * p;\n  if (S[p].second == S[S.size() - p - 1].second &&\n      S[p].first + S[S.size() - p - 1].first >= k) {\n    ans -= (m - 1ll) * k;\n  }\n  printf(\"%lld\\n\", ans);\n}\nint main() {\n  int tt = 1;\n  while (tt--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200020;\nlong long total;\nint k;\ndeque<int> trata(deque<int> &d) {\n  deque<pair<int, int> > at;\n  int cnt = 0;\n  for (int i = 0; i < d.size(); i++) {\n    if (at.empty()) {\n      at.emplace_back(d[i], 1);\n      cnt = 1;\n    } else if (at.back().first == d[i]) {\n      at.emplace_back(d[i], cnt + 1);\n      cnt++;\n    } else {\n      at.emplace_back(d[i], 1);\n      cnt = 1;\n    }\n    if (cnt == k) {\n      for (int j = 0; j < k; j++) at.pop_back();\n      total -= k;\n      if (at.empty())\n        cnt = 0;\n      else\n        cnt = at.back().second;\n    }\n  }\n  deque<int> at2;\n  for (int i = 0; i < at.size(); i++) at2.push_back(at[i].first);\n  return at2;\n}\nint a[N];\nint main(void) {\n  int n, m;\n  scanf(\"%d %d %d\", &n, &k, &m);\n  set<int> s;\n  deque<int> deq;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n    deq.push_back(a[i]);\n  }\n  deq = trata(deq);\n  n = deq.size();\n  for (int i = 0; i < n; i++) {\n    a[i] = deq[i];\n    s.insert(a[i]);\n  }\n  if (k > 2 * n and s.size() > 1) {\n    cout << (n * 1LL) * (m * 1LL) << endl;\n    return 0;\n  }\n  if (k > 2 * n) {\n    cout << ((n * 1LL) * (m * 1LL)) % k << endl;\n    return 0;\n  }\n  total = ((n * 1LL) * (m * 1LL));\n  if (m == 1) {\n    trata(deq);\n    cout << total << endl;\n    return 0;\n  }\n  deque<int> bordaesq;\n  deque<int> bordadir;\n  deque<int> v;\n  for (int i = 0; i < n; i++) v.push_back(a[i]);\n  while (!v.empty()) {\n    long long cnt = 0;\n    int x = v.front();\n    if (v.front() != v.back()) {\n      cout << total << endl;\n      return 0;\n    }\n    int le = 0, ri = 0;\n    while (!v.empty() and v.front() == x) {\n      cnt++;\n      v.pop_front();\n      le++;\n    }\n    while (!v.empty() and v.back() == x) {\n      cnt++;\n      v.pop_back();\n      ri++;\n    }\n    if (!v.empty()) {\n      if (cnt % k != 0) {\n        total -= cnt * (m - 1);\n        total += (cnt % k) * (m - 1);\n        cout << total << endl;\n        return 0;\n      } else {\n        total -= cnt * (m - 1);\n        for (int i = 0; i < le; i++) bordaesq.push_back(x);\n        for (int i = 0; i < ri; i++) bordadir.push_front(x);\n      }\n    } else {\n      cnt *= m;\n      if (cnt % k != 0) {\n        total -= cnt;\n        total += (cnt % k);\n        cout << total << endl;\n        return 0;\n      } else {\n        total -= cnt;\n      }\n    }\n  }\n  while (!bordadir.empty()) {\n    bordaesq.push_back(bordadir.front());\n    bordadir.pop_front();\n  }\n  trata(bordaesq);\n  cout << total << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint l, r, n, k, m, now, tot, all;\nint a[200000], s[200000];\nstruct fk {\n  int num, val;\n  bool operator==(const fk &b) { return (num + b.num == k && val == b.val); }\n} tp[200000];\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n  all = 0;\n  tp[0].num = tp[0].val = -1;\n  for (int i = 1; i <= n; ++i) {\n    if (a[i] == tp[all].val) {\n      ++tp[all].num;\n      if (tp[all].num == k) --all;\n    } else {\n      tp[++all].val = a[i];\n      tp[all].num = 1;\n    }\n  }\n  n = 0;\n  for (int i = 1; i <= all; ++i) n += tp[i].num;\n  int p = 0;\n  for (int i = 1; i <= all; ++i) {\n    if (tp[i] == tp[all - i + 1])\n      p = i;\n    else\n      break;\n  }\n  long long ans = 0, temp;\n  if (p >= (all + 1) / 2) {\n    if (m % 2)\n      for (int i = 1; i <= all; ++i) ans += tp[i].num;\n  } else if (all % 2 == 1 && p == all / 2) {\n    temp = m % k * tp[p + 1].num % k;\n    if (temp % k == 0)\n      ans = 0;\n    else {\n      ans = (long long)p * k;\n      ans = ans + temp;\n    }\n  } else {\n    ans = (long long)m * n;\n    for (int i = 1; i <= p; ++i) ans -= (long long)p * k * (m - 1);\n    ans -= (tp[p + 1].val == tp[all - p].val &&\n            tp[p + 1].num + tp[all - p].num >= k)\n               ? (long long)k * (m - 1)\n               : 0;\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e5 + 10;\nlong long Stack[M][2];\nint main() {\n  int n, k, m, x, top = 0;\n  long long ans = 0;\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> x;\n    if (!top || Stack[top][0] != x) {\n      Stack[++top][0] = x;\n      Stack[top][1] = 1;\n    } else {\n      Stack[top][1]++;\n    }\n    if (Stack[top][1] == k) {\n      Stack[top--][1] -= k;\n    }\n  }\n  long long sum = 0;\n  for (int i = 1; i <= top; i++) {\n    sum += Stack[i][1];\n  }\n  int sta = 1, ed = top;\n  while (sta < ed && Stack[sta][0] == Stack[ed][0]) {\n    if ((Stack[sta][1] + Stack[ed][1]) % k == 0) {\n      sta++, ed--;\n    } else {\n      Stack[sta][1] = (Stack[sta][1] + Stack[ed][1]) % k;\n      Stack[ed][1] = 0;\n      break;\n    }\n  }\n  if (sta < ed) {\n    for (int i = sta; i <= ed; i++) ans += Stack[i][1];\n    ans *= (m - 1);\n    ans += sum;\n  } else if (sta == ed) {\n    if (Stack[sta][1] * m % k == 0)\n      ans = 0;\n    else {\n      ans = sum + Stack[sta][1] * (m - 1);\n      ans -= Stack[sta][1] * m - Stack[sta][1] * m % k;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m;\nint a[100010];\nlong long ans;\nint b[100010], bn = 0;\nint bc[100010];\nvoid solve() {\n  int cnt[100010];\n  stack<int> s;\n  for (int i = 1; i <= n; ++i) {\n    if (s.empty() || a[i] != a[s.top()]) {\n      cnt[i] = 1;\n    } else\n      cnt[i] = cnt[s.top()] + 1;\n    s.push(i);\n    if (cnt[i] == k) {\n      ans -= 1ll * m * k;\n      for (int j = 1; j <= k; ++j) {\n        a[s.top()] = -1;\n        s.pop();\n      }\n    }\n  }\n  int last = -1;\n  for (int i = 1; i <= n; ++i)\n    if (a[i] != -1) {\n      last = i;\n      break;\n    }\n  if (last == -1) return;\n  for (int i = last + 1; i <= n; ++i) {\n    if (a[i] == -1) continue;\n    if (cnt[i] != cnt[last] + 1) {\n      b[++bn] = a[last];\n      bc[bn] = cnt[last];\n    }\n    last = i;\n  }\n  b[++bn] = a[last];\n  bc[bn] = cnt[last];\n}\nvoid solve_again() {\n  int i, j;\n  for (i = 1, j = bn; i <= j; ++i, --j) {\n    if (i == j) {\n      ans -= 1ll * bc[i] * m / k * k;\n      if (1ll * bc[i] * m % k) return;\n      continue;\n    }\n    if (b[i] != b[j]) return;\n    ans -= 1ll * ((bc[i] + bc[j]) / k * k) * (m - 1);\n    if ((bc[i] + bc[j]) % k) return;\n  }\n  if (i - j == 1) return;\n  for (; i <= bn; ++i, --j) {\n    if (b[i] != b[j]) return;\n    ans -= 1ll * ((bc[i] + bc[j]) / k * k);\n    if ((bc[i] + bc[j]) % k) return;\n  }\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  ans = 1ll * n * m;\n  solve();\n  solve_again();\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long Cnt[100005], Num[100005];\nint main() {\n  int n, k, m, a;\n  scanf(\"%d %d %d\", &n, &k, &m);\n  int len = 0;\n  while (n--) {\n    scanf(\"%d\", &a);\n    if (len == 0 || Num[len] != a) {\n      Num[++len] = a;\n      Cnt[len] = 1;\n    } else\n      Cnt[len]++;\n    if (Cnt[len] == k) len--;\n  }\n  int head = 1, tail = len;\n  long long S1 = 0, S2 = 0;\n  for (int i = 1; i <= len; i++) S1 += Cnt[i];\n  while (head < tail && Num[head] == Num[tail]) {\n    if ((Cnt[head] + Cnt[tail]) % k == 0) {\n      head++;\n      tail--;\n    } else {\n      Cnt[head] = (Cnt[head] + Cnt[tail]) % k;\n      tail--;\n      break;\n    }\n  }\n  for (int i = head; i <= tail; i++) S2 += Cnt[i];\n  long long ans = 0;\n  if (head < tail)\n    ans = S1 + S2 * (m - 1);\n  else if ((Cnt[head] * m) % k != 0)\n    ans = S1 + (Cnt[head] * m) % k - Cnt[head];\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T1, typename T2>\nistream& operator>>(istream& in, pair<T1, T2>& a) {\n  in >> a.first >> a.second;\n  return in;\n}\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& out, pair<T1, T2> a) {\n  out << a.first << \" \" << a.second;\n  return out;\n}\ntemplate <typename T, typename T1>\nT amax(T& a, T1 b) {\n  if (b > a) a = b;\n  return a;\n}\ntemplate <typename T, typename T1>\nT amin(T& a, T1 b) {\n  if (b < a) a = b;\n  return a;\n}\nconst long long INF = 1e18;\nconst int32_t M = 1e9 + 7;\nconst int32_t MM = 998244353;\nconst long long N = 0;\nvoid solve() {\n  long long n, k, m;\n  cin >> n >> k >> m;\n  vector<pair<long long, long long> > v;\n  for (long long i = 0; i < n; i++) {\n    long long x;\n    cin >> x;\n    if (v.empty() || x != v.back().second) {\n      v.push_back({1, x});\n    } else {\n      v.back().first++;\n    }\n    if (v.back().first == k) v.pop_back();\n  }\n  if (m < 3) {\n    vector<pair<long long, long long> > z;\n    for (long long i = 0; i < m; i++) {\n      for (auto x : v) {\n        z.push_back(x);\n      }\n    }\n    vector<pair<long long, long long> > p;\n    for (auto x : z) {\n      if (p.empty() || p.back().second != x.second) {\n        p.push_back(x);\n      } else {\n        x.first += p.back().first;\n        p.pop_back();\n        if (x.first >= k) x.first -= k;\n        if (x.first) {\n          p.push_back(x);\n        }\n      }\n    }\n    long long ans = 0;\n    for (auto x : p) ans += x.first;\n    cout << ans;\n    return;\n  }\n  long long ans = 0;\n  for (auto x : v) ans += x.first;\n  ans *= 2;\n  deque<pair<long long, long long> > mid((v).begin(), (v).end());\n  while ((long long)((mid).size()) > 1 &&\n         mid.front().second == mid.back().second &&\n         mid.front().first + mid.back().first >= k) {\n    long long val = mid.front().second;\n    long long tmp = mid.front().first + mid.back().first;\n    ans -= k;\n    mid.pop_front();\n    mid.pop_back();\n    tmp -= k;\n    if (tmp) {\n      mid.push_back({tmp, val});\n    }\n  }\n  if ((long long)((mid).size()) == 1) {\n    long long tmp = m * mid.front().first;\n    ans -= 2 * mid.front().first;\n    tmp %= k;\n    if (tmp == 0) {\n      cout << 0;\n    } else {\n      cout << ans + tmp;\n    }\n    return;\n  }\n  if ((long long)((mid).size()) == 0) {\n    cout << 0;\n    return;\n  }\n  long long tmp = 0;\n  for (auto x : mid) tmp += x.first;\n  cout << ans + tmp * (m - 2);\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T1, typename T2>\nbool Max(T1& a, T2 b) {\n  return a < b ? a = b, 1 : 0;\n}\ntemplate <typename T1, typename T2>\nbool Min(T1& a, T2 b) {\n  return a > b ? a = b, 1 : 0;\n}\nconst int N = 200001, inf = 1e9;\nvoid solve() {\n  long long n, k, m, v;\n  cin >> n >> k >> m;\n  list<pair<int, int> > l;\n  long long ans = n * m;\n  long long last = 0;\n  while (n--) {\n    cin >> v;\n    if (v == last)\n      l.back().second++;\n    else {\n      l.push_back({v, 1});\n      last = v;\n    }\n  }\n  auto it = l.begin();\n  while (it != l.end()) {\n    if (it->second >= k) {\n      it->second -= k;\n      ans -= k * m;\n      if (it->second == 0) {\n        it = l.erase(it);\n        if (it != l.begin() && it != l.end()) {\n          auto it2 = it;\n          it2--;\n          if (it->first == it2->first) {\n            it2->second += it->second;\n            l.erase(it);\n            it = it2;\n          }\n        }\n      }\n    } else\n      it++;\n  }\n  long long boarders = 0;\n  while (l.size() > 1 && l.front().first == l.back().first &&\n         l.front().second + l.back().second >= k) {\n    ans -= (m - 1) * k;\n    boarders++;\n    long long rem = l.front().second + l.back().second - k;\n    l.erase(l.begin());\n    if (rem > 0) {\n      break;\n    }\n    l.erase(--l.end());\n  }\n  if (l.size() == 1) {\n    ans -= l.front().second * m / k * k;\n    if (l.front().second * m % k == 0) {\n      ans -= boarders * k;\n    }\n  }\n  cout << ans << '\\n';\n}\nvoid init() {}\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.setf(ios::fixed);\n  cout.precision(20);\n  init();\n  int TC = 1;\n  for (int TI = 1; TI <= (TC); ++TI) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\nint IT_MAX = 1 << 17;\nconst long long MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst long long LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\nconst double ERR = 1e-8;\nvector<pair<long long, long long> > Vu;\nint main() {\n  int N, K, M, i, j;\n  scanf(\"%d %d %d\", &N, &K, &M);\n  for (i = 1; i <= N; i++) {\n    int t;\n    scanf(\"%d\", &t);\n    if (!Vu.empty() && Vu.back().first == t) {\n      Vu.back().second++;\n      if (Vu.back().second == K) Vu.pop_back();\n    } else\n      Vu.emplace_back(t, 1);\n  }\n  long long s = 0;\n  for (auto it : Vu) s += it.second;\n  if (M == 1 || s == 0) return !printf(\"%lld\\n\", s);\n  s *= M;\n  int st = 0, en = (int)Vu.size() - 1;\n  while (st < en) {\n    if (Vu[st].first != Vu[en].first) return !printf(\"%lld\\n\", s);\n    if (Vu[st].second + Vu[en].second == K) {\n      s -= (long long)(M - 1) * K;\n      st++, en--;\n      continue;\n    }\n    if (Vu[st].second + Vu[en].second > K) s -= (long long)(M - 1) * K;\n    return !printf(\"%lld\\n\", s);\n  }\n  long long x = Vu[st].second * M;\n  if (x % K == 0) {\n    return !printf(\"0\\n\");\n  } else {\n    return !printf(\"%lld\\n\", s - (x / K) * K);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000 + 10;\nint n, m, k;\nint a[maxn], S[maxn], cnt[maxn], top;\nint main() {\n  bool single_color = true;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) scanf(\"%d\", a + i);\n  for (int i = 1; i < n; i++)\n    if (a[i] != a[i - 1]) {\n      single_color = false;\n      break;\n    }\n  if (single_color) {\n    printf(\"%I64d\\n\", (long long)n * m % k);\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    S[++top] = a[i];\n    if (top > 1 && S[top] == S[top - 1])\n      cnt[top] = cnt[top - 1] + 1;\n    else\n      cnt[top] = 1;\n    if (cnt[top] >= k) top -= k;\n  }\n  int L = 1, R = top;\n  long long t = 0;\n  while (S[L] == S[R] && L < R) {\n    int l = L, r = R, cnt = 0;\n    while (S[l] == S[L] && l < r && cnt < k) {\n      cnt++;\n      l++;\n    }\n    while (S[r] == S[L] && l < r && cnt < k) {\n      cnt++;\n      r--;\n    }\n    if (cnt == k) {\n      L = l;\n      R = r;\n      t += k;\n    } else\n      break;\n  }\n  single_color = true;\n  for (int i = L; i < R; i++)\n    if (S[i] != S[i + 1]) {\n      single_color = false;\n      break;\n    }\n  if (single_color) {\n    long long mid = (long long)(R - L + 1) * m % k;\n    if (mid)\n      printf(\"%I64d\\n\", mid + t);\n    else\n      printf(\"0\\n\");\n  } else {\n    printf(\"%I64d\\n\", (long long)(R - L + 1) * m + t);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 100005;\nint a[maxn], f[maxn], t[maxn], top;\nint main() {\n  long long n, m, k, ans = 0;\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  top = 0;\n  for (int i = 1; i <= n; i++) {\n    t[++top] = a[i];\n    if (top == 1 || t[top] != t[top - 1])\n      f[top] = 1;\n    else\n      f[top] = f[top - 1] + 1;\n    if (f[top] == k) top -= k;\n  }\n  int l = 1, r = top;\n  while (l < r && t[l] == t[r]) {\n    int L = l, R = r, cnt = 0;\n    while (L < R && t[L] == t[l] && cnt < k) {\n      ++cnt;\n      ++L;\n    }\n    while (L < R && t[r] == t[R] && cnt < k) {\n      ++cnt;\n      --R;\n    }\n    if (cnt == k) {\n      ans += k;\n      l = L;\n      r = R;\n    } else\n      break;\n  }\n  int flag = 1;\n  for (int i = l + 1; i <= r; i++) {\n    if (t[i] != t[i - 1]) {\n      flag = 0;\n      break;\n    }\n  }\n  if (flag) {\n    if ((long long)(r - l + 1) * m % k != 0)\n      printf(\"%lld\\n\", (long long)(r - l + 1) * m % k + ans);\n    else\n      printf(\"0\\n\");\n  } else\n    printf(\"%lld\\n\", (long long)(r - l + 1) * m + ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1);\nconst int N = 1e5 + 5;\nint n, m, k, arr[N << 1];\nvector<int> v, vv;\nset<int> s;\nlong long tot;\nint main() {\n  scanf(\"%d %d %d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", arr + i);\n    arr[i + n] = arr[i];\n  }\n  int st = 0;\n  while (st < n) {\n    int f = arr[st];\n    int cnt = 0;\n    while (v.size() && v.back() == f) {\n      ++cnt;\n      v.pop_back();\n    }\n    while (st < n && arr[st] == f) {\n      ++st;\n      ++cnt;\n    }\n    cnt %= k;\n    while (cnt--) v.push_back(f);\n  }\n  if (m == 1) {\n    cout << v.size() << \"\\n\";\n    return 0;\n  }\n  st = n;\n  vv = v;\n  while (st < 2 * n) {\n    int f = arr[st];\n    int cnt = 0;\n    while (vv.size() && vv.back() == f) {\n      ++cnt;\n      vv.pop_back();\n    }\n    while (st < 2 * n && arr[st] == f) {\n      ++st;\n      ++cnt;\n    }\n    cnt %= k;\n    while (cnt--) vv.push_back(f);\n  }\n  if (m == 2) {\n    printf(\"%d\\n\", vv.size());\n    return 0;\n  }\n  if (v.empty()) {\n    puts(\"0\");\n    return 0;\n  }\n  s.clear();\n  for (int i : v) s.insert(i);\n  tot = 1ll * v.size() * m;\n  if (s.size() == 1) {\n    cout << tot % k;\n    return 0;\n  }\n  if (k >= v.size()) {\n    printf(\"%lld\", tot);\n    return 0;\n  }\n  int ff = v[0];\n  long long flag = 0;\n  int c = 0, ss = 0, e = v.size();\n  ff = v[0];\n  while (1) {\n    c = 0;\n    ff = v[ss];\n    int ns = ss;\n    int ne = e;\n    for (; ns < ne && v[ns] == ff; ns++) ++c;\n    for (; ns < ne - 1 && v[ne - 1] == ff; ne--) ++c;\n    if (c == k) {\n      flag += k;\n      ss = ns;\n      e = ne;\n    } else\n      break;\n  }\n  vector<int> vec = v;\n  v.clear();\n  for (int i = ss; i < e; i++) v.push_back(vec[i]);\n  vec = v;\n  st = 0;\n  v.clear();\n  while (st < vec.size()) {\n    int f = vec[st];\n    int cnt = 0;\n    while (v.size() && v.back() == f) {\n      ++cnt;\n      v.pop_back();\n    }\n    while (st < vec.size() && vec[st] == f) {\n      ++st;\n      ++cnt;\n    }\n    cnt %= k;\n    while (cnt--) v.push_back(f);\n  }\n  s.clear();\n  for (int i : v) s.insert(i);\n  if (s.size() == 1) {\n    cout << v.size() * 1ll * m % k + flag * (!!(v.size() * 1ll * m % k));\n    return 0;\n  }\n  vv = v;\n  st = 0;\n  while (st < v.size()) {\n    int f = v[st];\n    int cnt = 0;\n    while (vv.size() && vv.back() == f) {\n      ++cnt;\n      vv.pop_back();\n    }\n    while (st < v.size() && v[st] == f) {\n      ++st;\n      ++cnt;\n    }\n    cnt %= k;\n    while (cnt--) vv.push_back(f);\n  }\n  vector<int> x = vv;\n  vector<int> y = vv;\n  st = 0;\n  while (st < x.size()) {\n    int f = x[st];\n    int cnt = 0;\n    while (y.size() && y.back() == f) {\n      ++cnt;\n      y.pop_back();\n    }\n    while (st < x.size() && x[st] == f) {\n      ++st;\n      ++cnt;\n    }\n    cnt %= k;\n    while (cnt--) y.push_back(f);\n  }\n  m -= 2;\n  long long ans = vv.size() + 1ll * (y.size() - vv.size()) * (m / 2);\n  if (m & 1) {\n    x = v;\n    y = vv;\n    st = 0;\n    while (st < x.size()) {\n      int f = x[st];\n      int cnt = 0;\n      while (y.size() && y.back() == f) {\n        ++cnt;\n        y.pop_back();\n      }\n      while (st < x.size() && x[st] == f) {\n        ++st;\n        ++cnt;\n      }\n      cnt %= k;\n      while (cnt--) y.push_back(f);\n    }\n    ans += y.size() - vv.size();\n  }\n  printf(\"%lld\\n\", ans + flag * (!!ans));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint a[N], b[N], sz;\nvoid solve() {\n  int n, k, m;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  long long res = (long long)n * m;\n  for (int i = 0, x; i < n; ++i) {\n    scanf(\"%d\", &x);\n    if (!sz || a[sz - 1] != x) {\n      a[sz] = x;\n      b[sz] = 1;\n      ++sz;\n    } else {\n      if (++b[sz - 1] == k) {\n        res -= (long long)k * m;\n        b[--sz] = 0;\n      }\n    }\n  }\n  int l = 0, r = sz - 1;\n  for (; r > l && a[l] == a[r] && (b[l] + b[r] >= k); ++l, --r) {\n    long long c = (b[l] + b[r]);\n    res -= (c / k) * k * (m - 1);\n    if (c % k) {\n      printf(\"%lld\\n\", res);\n      return;\n    }\n  }\n  if (l == r) {\n    res -= ((long long)b[l] * m / k) * k;\n    if (((long long)b[l] * m) % k == 0) {\n      for (--l, ++r; l >= 0 && r < sz; --l, ++r) {\n        res -= ((b[l] + b[r]) / k) * (long long)k;\n        if ((b[l] + b[r]) % k) break;\n      }\n    }\n  }\n  printf(\"%lld\\n\", res);\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::sort;\nconst int N = 100010;\nint n, col[N], m, K, each, tot;\nlong long ans, cnt[N];\nint main() {\n  scanf(\"%d%d%d\", &n, &K, &m);\n  for (int i = 1, x; i <= n; ++i) {\n    scanf(\"%d\", &x);\n    if (!tot || x != col[tot]) {\n      col[++tot] = x;\n      cnt[tot] = 1;\n    } else\n      ++cnt[tot];\n    if (cnt[tot] >= K) {\n      ++each;\n      cnt[tot] -= K;\n      if (!cnt[tot]) --tot;\n    }\n  }\n  each *= K;\n  if (tot == 1) {\n    ans = m * cnt[tot];\n    cout << ans % K << endl;\n    return 0;\n  }\n  if (m == 1) {\n    cout << n - each << endl;\n    return 0;\n  }\n  int j = 0;\n  while (1 + j < tot - j && col[tot - j] == col[1 + j] &&\n         (cnt[tot - j] + cnt[1 + j]) % K == 0) {\n    ++j;\n  }\n  if (1 + j == tot - j) {\n    ans = cnt[1 + j] * m % K;\n    if (ans) {\n      for (int i = 1; i <= j; ++i) ans += cnt[i];\n      for (int i = tot - j + 1; i <= tot; ++i) ans += cnt[i];\n    }\n    cout << ans << endl;\n    return 0;\n  }\n  long long tmp = 0;\n  for (int i = 1 + j; i <= tot - j; ++i) tmp += cnt[i];\n  ans = tmp * (m - 1) + n - each;\n  if (col[1 + j] == col[tot - j]) {\n    tmp = (cnt[1 + j] + cnt[tot - j]) / K;\n    ans -= tmp * (m - 1) * K;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, k;\nint a[100005];\nint len[100005];\nvoid print(long long s, long long t) {\n  cout << (t - s + 1) * m + (s - 1) + (n - t);\n}\nint main() {\n  cin >> n >> k >> m;\n  int numm = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    if (a[i] != a[i - 1])\n      numm = 1;\n    else\n      numm++;\n    len[i] = numm;\n    if (numm == k) {\n      i -= k;\n      n -= k;\n      numm = len[i];\n    }\n  }\n  if (k >= n) {\n    bool g = 1;\n    for (int i = 2; i <= n; i++)\n      if (a[i] != a[i - 1]) {\n        g = 0;\n        break;\n      }\n    if (g == 1)\n      cout << n * m % k;\n    else\n      cout << n * m;\n    return 0;\n  }\n  if (m == 1) {\n    cout << n;\n    return 0;\n  }\n  long long i = 1, j = n;\n  while (i <= j) {\n    if (a[i] != a[j]) {\n      print(i, j);\n      return 0;\n    }\n    int jj = j, ii = i;\n    while (i < j && a[j] == a[j - 1]) j--;\n    if (i == j) {\n      j = jj;\n      if (((j - i + 1) * m) % k == 0)\n        cout << '0';\n      else\n        cout << ((j - i + 1) * m) % k + (i - 1) + (n - j);\n      return 0;\n    }\n    while (a[i] == a[j] && (i - ii + 1) + (jj - j + 1) < k) i++;\n    if (a[i] == a[j]) {\n      i++;\n      j--;\n    } else {\n      i = ii;\n      j = jj;\n      print(i, j);\n      return 0;\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<long long, long long> a[300000];\nlong long cd, n, k, cur, m, sums[300000];\nlong long getSum(int l, int r) { return sums[r] - sums[l - 1]; }\nlong long dp(int st, int en) {\n  if (st > en) {\n    return 0;\n  }\n  if (st + 1 == en) {\n    if (a[st].first != a[en].first) {\n      return (a[st].second + a[en].second) * m;\n    }\n    return (a[st].second + a[en].second) % k * m;\n  }\n  if (st == en) {\n    return (a[st].second) * m % k;\n  }\n  if (a[st].first == a[en].first) {\n    if ((a[st].second + a[en].second) % k == 0) {\n      long long l = dp(st + 1, en - 1);\n      if (l == 0) {\n        return (a[st].second + a[en].second) % k;\n      }\n      return (a[st].second + a[en].second + l);\n    } else {\n      return getSum(st, en) * m -\n             ((a[st].second + a[en].second) / k * k) * (m - 1);\n    }\n  } else {\n    return getSum(st, en) * m;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k >> m;\n  for (int i = 1; i <= n; i++) {\n    long long x;\n    cin >> x;\n    if (a[cur].first == x) {\n      a[cur].second++;\n      if (a[cur].second == k) {\n        cur--;\n      }\n    } else {\n      a[++cur].first = x;\n      a[cur].second = 1;\n    }\n  }\n  for (int i = 1; i <= cur; i++) {\n    sums[i] = sums[i - 1] + a[i].second;\n  }\n  cout << dp(1, cur);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Pavel Mavrin\n */\npublic class B {\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        int k = nextInt();\n        int m = nextInt();\n        long res = 1l * m * n;\n        int[] sta = new int[n];\n        long[] stb = new long[n];\n        int sp = 0;\n        for (int i = 0; i < n; i++) {\n            int x = nextInt();\n            if (sp > 0 && sta[sp - 1] == x) {\n                stb[sp - 1]++;\n                if (stb[sp - 1] == k) {\n                    sp--;\n                    res -= 1l * m * k;\n                }\n            } else {\n                sta[sp] = x;\n                stb[sp] = 1;\n                sp++;\n            }\n        }\n        int l = 0;\n        int r = sp - 1;\n        while (r > l && sta[l] == sta[r]) {\n            long x = stb[l] + stb[r];\n            res -= (m - 1) * (x / k * k);\n            if (x % k == 0) {\n                l++;\n                r--;\n            } else {\n                break;\n            }\n        }\n        if (l == r) {\n            long x = stb[l] * m;\n            res -= x / k * k;\n            while (l > 0 && x % k == 0) {\n                l--; r++;\n                if (sta[l] == sta[r]) {\n                    x = stb[l] + stb[r];\n                    res -= x / k * k;\n                } else {\n                    break;\n                }\n            }\n        }\n        out.println(res);\n    }\n\n    // ------------------\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st;\n    PrintWriter out = new PrintWriter(System.out);\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new B().run();\n    }\n\n    private void run() throws IOException {\n        solve();\n        out.close();\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k, m, x;\n  cin >> n >> k >> m;\n  vector<pair<int, int>> tinue;\n  int last = 0, cont = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> x;\n    v.push_back(x);\n    if (last == 0) last = x;\n    if (x == last)\n      ++cont;\n    else {\n      tinue.push_back(make_pair(last, cont));\n      last = x, cont = 1;\n    }\n    if (cont == k) {\n      int tmp = k;\n      while (tmp--) v.pop_back();\n      if (!tinue.empty())\n        last = tinue.back().first, cont = tinue.back().second, tinue.pop_back();\n      else\n        last = cont = 0;\n    }\n  }\n  if (k >= n) {\n    int ok = 1;\n    for (int i = 1; i < v.size(); ++i) {\n      if (v[i] != v[i - 1]) {\n        ok = 0;\n        break;\n      }\n    }\n    if (ok) {\n      cout << (long long)((long long)m * (long long)n) % (long long)k << \"\\n\";\n    } else\n      cout << (long long)((long long)m * (long long)n) << \"\\n\";\n    return 0;\n  }\n  if (m < 2) {\n    cout << v.size() << \"\\n\";\n    return 0;\n  }\n  int head = 0, tail = v.size() - 1;\n  while (tail - head >= k) {\n    int oldh = head, oldt = tail;\n    int num = v[head];\n    int cnt = 1;\n    while (v[head + cnt] == num && cnt < k) ++cnt;\n    if (cnt == k)\n      head = head + cnt;\n    else {\n      int tcnt = 0;\n      while (v[tail - tcnt] == num) ++tcnt;\n      if (tcnt + cnt >= k) {\n        tail = tail - tcnt;\n        head = head + (k - tcnt);\n      }\n    }\n    if (oldh == head && oldt == tail) break;\n  }\n  long long ans = 0;\n  ans += (long long)head - 0ll;\n  ans += (long long)(v.size() - 1 - tail);\n  ans += (long long)(tail - head + 1) * (long long)m;\n  int ok = 1;\n  for (int i = head + 1; i <= tail; ++i) {\n    if (v[i] != v[i - 1]) {\n      ok = 0;\n      break;\n    }\n  }\n  if (ok) {\n    long long rem =\n        ((long long)(tail - head + 1) * (long long)m) % (long long)k;\n    if (rem == 0)\n      ans = 0;\n    else\n      ans -= (long long)(tail - head + 1) * (long long)m - rem;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid addmod(int &a, long long b) {\n  a = (a + b);\n  if (a >= 1000000007) a -= 1000000007;\n}\nvoid mulmod(int &a, long long b) { a = (a * b) % 1000000007; }\ntemplate <class T>\nbool domin(T &a, const T &b) {\n  return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool domax(T &a, const T &b) {\n  return a < b ? a = b, 1 : 0;\n}\nint gi() {\n  int a;\n  scanf(\"%d\", &a);\n  return a;\n}\nlong long gll() {\n  long long a;\n  scanf(\"%lld\", &a);\n  return a;\n}\nint main() {\n  long long n = gi(), k = gi(), m = gi();\n  vector<pair<int, long long> > qfront, qback;\n  long long totalsize = n, frontsize, backsize;\n  for (int i = 0; i < n; i++) {\n    int a = gi();\n    if (qfront.empty() || qfront.back().first != a) {\n      qfront.push_back({a, 1});\n    } else {\n      qfront.back().second++;\n    }\n    if (qfront.back().second >= k) qfront.pop_back(), totalsize -= k;\n  }\n  if (m == 1) return cout << totalsize << endl, 0;\n  qback = qfront;\n  int nn = qfront.size();\n  int frontix = nn - 1, backix = 0;\n  frontsize = backsize = totalsize;\n  while (frontix >= 0 || backix < nn) {\n    if (qfront[frontix].first == qback[backix].first) {\n      frontsize -= qfront[frontix].second;\n      backsize -= qback[backix].second;\n      if (frontix == backix) {\n        long long middlesz = (qfront[frontix].second * m) % k;\n        if (middlesz > 0) {\n          cout << frontsize + middlesz + backsize << endl;\n          return 0;\n        } else\n          m = 2;\n      } else {\n        long long middlesz =\n            (qfront[frontix].second + qback[backix].second) % k;\n        if (middlesz > 0) {\n          cout << frontsize + (m - 1) * middlesz + backsize +\n                      (m - 2) * (max(0LL, totalsize - (totalsize - frontsize) -\n                                              (totalsize - backsize)))\n               << endl;\n          return 0;\n        }\n      }\n      frontix--, backix++;\n    } else {\n      int middlesz = max(\n          0LL, totalsize - (totalsize - frontsize) - (totalsize - backsize));\n      cout << frontsize + (m - 2) * middlesz + backsize << endl;\n      return 0;\n    }\n  }\n  cout << frontsize + backsize << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nlong long n, k, m, p[N], rnk[N], sz[N], a[N];\nint prv[N], nxt[N], base[N];\nset<int> st;\nvoid init(int n) {\n  for (int i = 0; i < n; i++)\n    p[i] = i, sz[i] = 1, prv[i] = i - 1, nxt[i] = i + 1;\n}\nint _find(int x) { return (p[x] == x ? x : p[x] = _find(p[x])); }\nint mrg(int x, int y) {\n  if (a[x] != a[y]) return -1;\n  x = _find(x);\n  y = _find(y);\n  if (x == y) return -1;\n  if (rnk[x] > rnk[y]) swap(x, y);\n  p[x] = y;\n  rnk[y] += rnk[x] == rnk[y];\n  sz[y] += sz[x];\n  nxt[y] = max(nxt[y], nxt[x]);\n  prv[y] = min(prv[y], prv[x]);\n  if (st.count(x)) st.erase(x);\n  if (sz[y] % k == 0)\n    st.insert(y);\n  else if (st.count(y))\n    st.erase(y);\n  return y;\n}\nint main() {\n  scanf(\"%I64d%I64d%I64d\", &n, &k, &m);\n  for (int i = 0; i < n; i++) scanf(\"%I64d\", &a[i]);\n  init(n);\n  for (int i = 0; i < n; i++) {\n    if (i) mrg(i - 1, i);\n    if (i + 1 < n) mrg(i, i + 1);\n  }\n  for (int i = 0; i < n; i++)\n    if (p[i] == i && sz[i] % k == 0) st.insert(i);\n  while (!st.empty()) {\n    int i = *st.begin();\n    st.erase(st.begin());\n    if (prv[i] != -1) nxt[_find(prv[i])] = nxt[i];\n    if (nxt[i] != n) prv[_find(nxt[i])] = prv[i];\n    if (prv[i] != -1 && nxt[i] != n) mrg(prv[i], nxt[i]);\n  }\n  vector<pair<long long, long long> > v;\n  long long ans = 0;\n  for (int i = 0; i < n; i++)\n    if (i == p[i]) {\n      ans += (sz[i] - sz[i] % k) * m;\n      if (sz[i] % k) v.push_back({a[i], sz[i] % k});\n    }\n  if (!v.empty()) {\n    for (int i = 0, j = v.size() - 1; i < v.size(); i++, j--) {\n      if (v[i].first != v[j].first) break;\n      long long sum = 0;\n      if (i == j)\n        sum = v[i].second * m;\n      else\n        sum = v[i].second + v[j].second;\n      long long res = (sum / k) * k;\n      if (i < j)\n        ans += res * (m - 1);\n      else\n        ans += res;\n      if (sum % k != 0) break;\n    }\n  }\n  printf(\"%I64d\\n\", n * m - ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\nint n, k, m, a[N];\nlong long core, sum, tot, siz;\nvector<pair<int, int> > b, rb;\nvoid deal() {\n  for (int i = 1; i <= n; i++)\n    if (b.size() && b.back().first == a[i])\n      b.back().second++;\n    else {\n      if (b.size()) {\n        b.back().second %= k;\n        if (!b.back().second) b.pop_back();\n        if (!b.size() || b.back().first != a[i])\n          b.push_back(make_pair(a[i], 1));\n        else\n          b.back().second++;\n        b.back().second %= k;\n        if (!b.back().second) b.pop_back();\n      } else\n        b.push_back(make_pair(a[i], 1));\n    }\n  if (b.size()) {\n    b.back().second %= k;\n    if (!b.back().second) b.pop_back();\n  }\n  for (pair<int, int> v : b) sum += v.second;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  deal();\n  siz = b.size();\n  if (!siz) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (m == 1) {\n    cout << sum << endl;\n    return 0;\n  }\n  for (int i = siz - 1; i >= 0; i--) rb.push_back(b[i]);\n  for (int i = 0; i < siz; i++) {\n    if (b[i].first != rb[i].first) break;\n    tot += b[i].second + rb[i].second - (b[i].second + rb[i].second) % k;\n    if ((b[i].second + rb[i].second) % k) {\n      if (siz & 1 && i == siz / 2) core = b[i].second;\n      break;\n    }\n  }\n  if (tot != sum * 2) {\n    if (core) {\n      if (core * m % k == 0)\n        cout << 0 << endl;\n      else\n        cout << core * m % k + sum - b[siz / 2].second << endl;\n    } else\n      cout << sum * m - tot * (m - 1) << endl;\n  } else if (m % 2)\n    cout << sum << endl;\n  else\n    cout << 0 << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nconst int MAXN = 100000;\nint n, sz, reps;\nint a[MAXN];\npair<int, int> b[MAXN];\nint nb;\nvoid run() {\n  scanf(\"%d%d%d\", &n, &sz, &reps);\n  for (int i = (0); i < (n); ++i) scanf(\"%d\", &a[i]);\n  nb = 0;\n  for (int i = (0); i < (n); ++i) {\n    if (nb > 0 && b[nb - 1].first == a[i])\n      ++b[nb - 1].second;\n    else\n      b[nb++] = make_pair(a[i], 1);\n    if (nb > 0 && b[nb - 1].second == sz) --nb;\n  }\n  int matchcnt = 0, matchsum = 0;\n  while (matchcnt < nb && b[matchcnt].first == b[nb - matchcnt - 1].first &&\n         b[matchcnt].second + b[nb - matchcnt - 1].second == sz)\n    ++matchcnt, matchsum += sz;\n  int bsum = 0;\n  for (int i = (0); i < (nb); ++i) bsum += b[i].second;\n  if (reps == 1) {\n    printf(\"%d\\n\", bsum);\n    return;\n  }\n  if (matchcnt == nb) {\n    printf(\"%d\\n\", (reps % 2) * bsum);\n    return;\n  }\n  assert(2 * matchcnt < nb);\n  if (2 * matchcnt + 1 == nb) {\n    int bmid = (long long)reps * b[matchcnt].second % sz;\n    printf(\"%d\\n\", bmid == 0 ? 0 : bmid + matchsum);\n    return;\n  }\n  if (b[matchcnt].first == b[nb - matchcnt - 1].first &&\n      b[matchcnt].second + b[nb - matchcnt - 1].second >= sz)\n    matchsum += sz;\n  printf(\"%lld\\n\", (long long)reps * bsum - (long long)(reps - 1) * matchsum);\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m;\nconst int maxN = (int)1e5 + 10;\nint a[maxN];\nint w[maxN];\nint tp[maxN];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  srand(239);\n  cin >> n >> k >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  vector<pair<int, int> > all;\n  for (int i = 1; i <= n; i++) {\n    if (all.empty()) {\n      all.push_back(make_pair(a[i], 1));\n    } else {\n      auto t = all.back();\n      if (t.first != a[i]) {\n        all.push_back(make_pair(a[i], 1));\n      } else {\n        t.second++;\n        t.second %= k;\n        if (t.second == 0)\n          all.pop_back();\n        else {\n          all.pop_back();\n          all.push_back(t);\n        }\n      }\n    }\n  }\n  int sz = all.size();\n  for (int i = 1; i <= sz; i++) {\n    tp[i] = all[i - 1].first;\n    w[i] = all[i - 1].second;\n  }\n  if (sz == 0) {\n    cout << 0;\n    return 0;\n  }\n  if (sz == 1) {\n    cout << (1LL * m * w[1]) % k;\n    return 0;\n  }\n  long long sum = 0;\n  for (int i = 1; i <= sz; i++) {\n    sum += w[i];\n  }\n  if (m == 1) {\n    cout << sum;\n    return 0;\n  }\n  int l = 1;\n  int r = sz;\n  while (true) {\n    if (l == r) {\n      long long num = 1LL * w[l] * m;\n      if (num % k == 0) {\n        cout << 0;\n      } else {\n        cout << num % k + (sum - w[l]);\n      }\n      return 0;\n    }\n    if (tp[l] != tp[r]) {\n      long long sum_without = 0;\n      long long sum_in = 0;\n      for (int i = 1; i <= sz; i++) {\n        if (i < l || i > r)\n          sum_without += w[i];\n        else\n          sum_in += w[i];\n      }\n      cout << m * sum_in + sum_without;\n      return 0;\n    } else if (l + 1 == r) {\n      long long num = m * (w[l] + w[r]);\n      if (num % k != 0) {\n        cout << (sum - w[l] - w[r]) + num % k;\n      } else {\n        cout << 0;\n      }\n      return 0;\n    } else {\n      long long num = w[l] + w[r];\n      if (num % k != 0) {\n        long long sum_without = 0;\n        long long sum_in = 0;\n        for (int i = 1; i <= sz; i++) {\n          if (i < l || i > r)\n            sum_without += w[i];\n          else if (i > l && i < r)\n            sum_in += w[i];\n        }\n        cout << sum_without + m * sum_in + (m - 1) * (num % k) + (w[l] + w[r]);\n        return 0;\n      } else {\n        l++;\n        r--;\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m, t;\nlong long matched = 0, head_tail = 0, middle = 0;\ndeque<pair<long long, long long>> dq;\nint main() {\n  cin >> n >> k >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> t;\n    if (dq.empty() || dq.back().first != t) {\n      dq.push_back({t, 1});\n    } else {\n      dq.back().second++;\n      if (dq.back().second == k) {\n        dq.pop_back();\n        middle++;\n      }\n    }\n  }\n  while (dq.size() >= 2) {\n    if (dq.front().first == dq.back().first &&\n        dq.front().second + dq.back().second >= k) {\n      head_tail++;\n      if (dq.front().second + dq.back().second == k) {\n        dq.pop_front();\n      }\n      dq.pop_back();\n    } else {\n      break;\n    }\n  }\n  matched += middle * m;\n  matched += head_tail * (m - 1);\n  if (dq.size() == 1) {\n    matched += dq.front().second * m / k;\n    if (dq.front().second * m % k == 0) {\n      matched += head_tail;\n    }\n  }\n  cout << m * n - matched * k << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n  if (0) return;\n  cout << name << \" : \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n  if (0) return;\n  const char* comma = strchr(names + 1, ',');\n  cout.write(names, comma - names) << \" : \" << arg1 << \" | \";\n  __f(comma + 1, args...);\n}\nconst long long N = 3e6 + 7, M = 1000000007, inf = INT_MAX;\nconst long long INF = LLONG_MAX;\nvoid solve() {\n  long long n, k, m;\n  cin >> n >> k >> m;\n  vector<long long> arr(n);\n  long long mx = -1, mn = INF;\n  for (long long i = 0; i < (long long)n; i++)\n    cin >> arr[i], mx = max(mx, arr[i]), mn = min(mn, arr[i]);\n  if (mn == mx) {\n    cout << (n * m) % k << '\\n';\n    return;\n  }\n  long long cnt = 0, total = n * m, avail = 0;\n  vector<pair<long long, long long> > temp;\n  for (long long i = 0; i < (long long)n; i++) {\n    if (temp.size() == 0 or arr[i] != temp.back().first)\n      cnt = 1;\n    else\n      cnt++;\n    temp.push_back({arr[i], cnt});\n    if (cnt == k) {\n      avail++;\n      while (cnt--) temp.pop_back();\n      if (temp.size()) cnt = temp.back().second;\n    }\n  }\n  avail = avail * k * m;\n  n = temp.size();\n  arr.clear();\n  for (auto& i : temp) arr.push_back(i.first);\n  n = arr.size();\n  vector<pair<long long, long long> > front, backk;\n  long long cntf = 0;\n  for (long long i = 0; i < (long long)n; i++) {\n    if (!i or arr[i] != arr[i - 1])\n      front.push_back({arr[i], 1}), cntf++;\n    else\n      front.back().second++;\n  }\n  long long cntb = 0;\n  for (long long i = n - 1; i >= 0; i--) {\n    if (i == n - 1 or arr[i] != arr[i + 1])\n      backk.push_back({arr[i], 1}), cntb++;\n    else\n      backk.back().second++;\n  }\n  assert(cntf == cntb);\n  long long el = 0, el2 = cntb - 1;\n  while (el <= el2 and el < cntf and front[el].first == backk[el].first) {\n    long long sum = front[el].second + backk[el].second;\n    if (el < el2 and sum < k) break;\n    long long add = sum * (m - 1);\n    if (el < el2 and sum % k != 0) {\n      avail += (k) * (m - 1);\n      break;\n    }\n    if (el == el2) add = (sum / 2) * m;\n    avail += (add) - (add % k);\n    if (add % k != 0) break;\n    if (el == el2) {\n      el++;\n      el2--;\n      while (el < cntf and front[el].first == backk[el].first) {\n        long long sum2 = front[el].second + backk[el].second;\n        assert(sum2 < 2 * k);\n        if (sum2 < k) break;\n        avail += k;\n        if (sum2 % k != 0) break;\n        el++;\n      }\n    }\n    el++;\n    el2--;\n  }\n  long long res = total - avail;\n  cout << res << '\\n';\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long test = 1;\n  while (test--) solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt(), k = in.nextInt(), m = in.nextInt();\n\n            int[] arr = in.readIntArray(n);\n            int[] stack = new int[2 * n];\n            int[] count = new int[2 * n];\n            int sidx = 0;\n\n            int one = n;\n            for (int i = 0; i < n; i++) {\n                if (sidx == 0 || stack[sidx - 1] != arr[i]) {\n                    stack[sidx] = arr[i];\n                    count[sidx++] = 1;\n                } else {\n                    if (++count[sidx - 1] == k) {\n                        one -= k;\n                        sidx--;\n                    }\n                }\n            }\n\n            if (m == 1) {\n                out.println(one);\n                return;\n            }\n\n            if (one == 0) {\n                out.println(0);\n                return;\n            }\n\n            if (sidx == 1) {\n                out.println(1L * m * count[0] % k);\n                return;\n            }\n\n            int f = 0, b = sidx - 1;\n            while (f < b && stack[f] == stack[b] && (count[f] + count[b]) % k == 0) {\n                f++;\n                b--;\n            }\n            if (f > b) {\n                out.println(1L * one * (m % 2));\n                return;\n            }\n\n            if (f == b) {\n                long res = 1L * m * count[f] % k;\n                if (res != 0) {\n                    for (int i = 0; i < f; i++) {\n                        res += count[i];\n                    }\n                    for (int i = sidx - 1; i > b; i--) {\n                        res += count[i];\n                    }\n                    out.println(res);\n                } else {\n                    out.println(0);\n                }\n                return;\n            }\n\n            long res = 0;\n            for (int i = 0; i < f; i++) {\n                res += count[i];\n            }\n            for (int i = sidx - 1; i > b; i--) {\n                res += count[i];\n            }\n            long base = 0;\n            for (int i = f; i <= b; i++) {\n                base += count[i];\n            }\n            long sub = (stack[f] == stack[b]) ? 1L * (count[f] + count[b]) / k * k : 0;\n            res += (base - sub) * (m - 1) + base;\n            out.println(res);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int tokens) {\n            int[] ret = new int[tokens];\n            for (int i = 0; i < tokens; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.Collection;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Rustam Musin (PloadyFree@gmail.com)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            int m = in.readInt();\n            List<IntIntPair> all = new ArrayList<>(n); //{type, size}\n            for (int i = 0; i < n; i++) {\n                int type = in.readInt();\n                if (!all.isEmpty() && all.get(all.size() - 1).first == type) {\n                    if (last(all).second == k - 1) {\n                        all.remove(all.size() - 1);\n                    } else {\n                        all.set(all.size() - 1, IntIntPair.makePair(type, last(all).second + 1));\n                    }\n                } else {\n                    all.add(IntIntPair.makePair(type, 1));\n                }\n            }\n\n            long size = 0;\n            for (IntIntPair p : all) {\n                size += p.second;\n            }\n            size *= m;\n\n            if (all.size() == 1) {\n                out.print(size % k);\n                return;\n            }\n            if (m == 1 || size == 0 || all.get(0).first != last(all).first) {\n                out.print(size);\n                return;\n            }\n            if ((all.get(0).second + last(all).second) % k != 0) {\n                long remove = all.get(0).second + last(all).second;\n                remove = remove / k * k;\n                size -= (m - 1) * remove;\n                out.print(size);\n                return;\n            }\n\n            Deque<IntIntPair>[] parts = new Deque[3];\n            parts[0] = new ArrayDeque<>(all);\n            parts[1] = new ArrayDeque<>(all);\n            parts[2] = new ArrayDeque<>(all);\n\n            while (true) {\n                if (parts[1].size() == 1) {\n                    long middle = parts[1].peek().second * (long) m;\n                    if (middle % k == 0) {\n                        size -= middle;\n                        parts[0].pollLast();\n                        parts[2].pollFirst();\n                        size -= merge(parts[0], parts[2], k);\n                        break;\n                    } else {\n                        size -= middle / k * k;\n                        break;\n                    }\n                }\n                if (parts[1].peekFirst().first != parts[1].peekLast().first) {\n                    break;\n                }\n                long curSize = parts[1].peekFirst().second + parts[1].peekLast().second;\n                if (curSize % k != 0) {\n                    size -= (m - 1) * (curSize / k * k);\n                    break;\n                } else {\n                    parts[1].pollFirst();\n                    parts[1].pollLast();\n                    size -= (m - 1) * curSize;\n                    parts[0].pollLast();\n                    parts[2].pollFirst();\n                }\n            }\n\n            out.print(size);\n        }\n\n        int merge(Deque<IntIntPair> q1, Deque<IntIntPair> q2, int k) {\n            int result = 0;\n            while (!q1.isEmpty()) {\n                if (q1.peekLast().first != q2.peekFirst().first) {\n                    break;\n                }\n                int sz = q1.pollLast().second + q2.pollFirst().second;\n                result += sz / k * k;\n                if (sz % k != 0) {\n                    break;\n                }\n            }\n            return result;\n        }\n\n        <T> T last(List<T> a) {\n            return a.get(a.size() - 1);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void print(long i) {\n            writer.print(i);\n        }\n\n    }\n\n    static class IntIntPair implements Comparable<IntIntPair> {\n        public final int first;\n        public final int second;\n\n        public static IntIntPair makePair(int first, int second) {\n            return new IntIntPair(first, second);\n        }\n\n        public IntIntPair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            IntIntPair pair = (IntIntPair) o;\n\n            return first == pair.first && second == pair.second;\n        }\n\n\n        public int hashCode() {\n            int result = first;\n            result = 31 * result + second;\n            return result;\n        }\n\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        @SuppressWarnings({\"unchecked\"})\n        public int compareTo(IntIntPair o) {\n            int value = Integer.compare(first, o.first);\n            if (value != 0) {\n                return value;\n            }\n            return Integer.compare(second, o.second);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void read(int &x) {\n  static int ch;\n  static bool flag;\n  for (flag = 0, ch = getchar(); ch < '0' || ch > '9'; ch = getchar())\n    flag |= ch == '-';\n  for (x = 0; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + ch - 48;\n  x = flag ? -x : x;\n}\nint N, K, M, cnt;\nint A[500005], B[500005];\nlong long Ans, Sum;\ninline int dy() {\n  read(N), read(K), read(M);\n  for (register int i = 1; i <= N; ++i) read(A[i]);\n  for (register int i = 1; i <= N; ++i)\n    if (A[cnt] != A[i])\n      A[++cnt] = A[i], B[cnt] = 1;\n    else {\n      B[cnt]++;\n      if (B[cnt] == K) cnt--;\n    }\n  if (!cnt) putchar('0'), exit(0);\n  for (register int i = 1; i <= cnt; ++i) Sum += B[i];\n  int len = 0, pos;\n  for (pos = 1; pos <= cnt - pos; ++pos)\n    if (A[pos] == A[cnt + 1 - pos] && B[pos] + B[cnt + 1 - pos] == K)\n      len += K;\n    else\n      break;\n  if (pos < cnt + 1 - pos) {\n    if (A[pos] == A[cnt + 1 - pos] && B[pos] + B[cnt + 1 - pos] >= K) len += K;\n    Ans = 1ll * Sum * M - 1ll * len * (M - 1);\n  } else {\n    Ans = 1ll * B[pos] * M % K;\n    if (Ans) Ans += Sum - B[pos];\n  }\n  printf(\"%lld\\n\", Ans);\n  return 0;\n}\nint QAQ = dy();\nint main() { ; }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m, tot;\nvector<pair<long long, long long> > v;\nint main() {\n  long long i, j;\n  scanf(\"%lld\", &n);\n  scanf(\"%lld\", &k);\n  scanf(\"%lld\", &m);\n  stack<pair<long long, long long> > stk;\n  for (i = 1; i <= n; i++) {\n    long long x;\n    scanf(\"%lld\", &x);\n    if (stk.size() && stk.top().first == x) {\n      pair<long long, long long> p = stk.top();\n      stk.pop();\n      if (p.second + 1 == k) continue;\n      p.second++;\n      stk.push(p);\n    } else\n      stk.push({x, 1});\n  }\n  long long sum = 0;\n  while (stk.size()) {\n    sum += stk.top().second;\n    v.push_back(stk.top());\n    stk.pop();\n  }\n  if (n == 1) return cout << (sum * m) % k << endl, 0;\n  reverse(v.begin(), v.end());\n  int sz = v.size();\n  for (i = 0; i < sz; i++) {\n    j = sz - i - 1;\n    if (v[i].first == v[j].first && v[i].second + v[j].second == k)\n      continue;\n    else\n      break;\n  }\n  if (i == v.size()) {\n    printf(\"%lld\\n\", m % 2 ? sum : 0);\n    return 0;\n  }\n  j = sz - i - 1;\n  if (v[i].first != v[j].first) {\n    long long cnt = 0, cc = 0;\n    for (int xx = i; xx <= j; xx++) cnt += v[xx].second;\n    for (int xx = 0; xx <= j; xx++) cc += v[xx].second;\n    for (int xx = i; xx < sz; xx++) cc += v[xx].second;\n    long long ans = cc + (m - 2) * cnt;\n    return cout << ans << endl, 0;\n  }\n  if (i == j) {\n    long long tot = v[i].second * m;\n    if (tot % k == 0)\n      return cout << 0 << endl, 0;\n    else {\n      long long cnt = 0, cc = 0;\n      for (int xx = 0; xx < i; xx++) cc += v[xx].second;\n      for (int xx = i + 1; xx < sz; xx++) cc += v[xx].second;\n      return cout << cc + (tot % k) << endl, 0;\n    }\n  }\n  long long cc = 0, cnt = 0;\n  for (int xx = i + 1; xx < j; xx++) cnt += v[xx].second;\n  for (int xx = 0; xx < j; xx++) cc += v[xx].second;\n  for (int xx = i + 1; xx < sz; xx++) cc += v[xx].second;\n  long long ans =\n      cc + ((v[i].second + v[j].second) % k) * (m - 1) + cnt * (m - 2);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 7;\nlong long top, n, m, num, l, r, rec, rec2, ans, k;\nlong long a[maxn];\npair<int, int> ps[maxn];\nint main() {\n  cin >> n >> k >> m;\n  for (long long i = 1; i <= n; ++i) scanf(\"%lld\", &a[i]);\n  for (long long i = 1; i <= n; ++i) {\n    if (!top || ps[top].first != a[i])\n      ps[++top] = make_pair(a[i], 1);\n    else\n      ps[top].second = (ps[top].second + 1) % k;\n    if (ps[top].second == 0) --top;\n  }\n  for (long long i = 1; i <= top; ++i) rec += ps[i].second;\n  l = 1, r = top;\n  while (l < r && ps[l].first == ps[r].first &&\n         (ps[l].second + ps[r].second) % k == 0) {\n    rec2 += ps[l].second + ps[r].second;\n    l++;\n    r--;\n  }\n  if (l == r) {\n    if (ps[l].second * m % k == 0) ans -= rec2;\n    ans += m * rec - rec2 * (m - 1) - (ps[l].second * m / k * k);\n  } else {\n    if (ps[l].first == ps[r].first)\n      rec2 += (ps[l].second + ps[r].second) / k * k;\n    ans = m * rec - rec2 * (m - 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ni() {\n  int val;\n  scanf(\"%i\", &val);\n  return val;\n}\npair<int, int> npi() {\n  pair<int, int> val;\n  scanf(\"%i %i\", &val.first, &val.second);\n  return val;\n}\nint64_t nll() {\n  int64_t val;\n  scanf(\"%I64d\", &val);\n  return val;\n}\nvector<int> nvi(int n, int corr = 0) {\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) a[i] = ni() + corr;\n  return move(a);\n}\nchar nc() {\n  char val;\n  do {\n    val = getchar();\n  } while (val == ' ' || val == '\\r' || val == '\\n');\n  return val;\n}\nchar ncs() {\n  char val;\n  do {\n    val = getchar();\n  } while (false);\n  return val;\n}\nstring ns() {\n  static char buff[1024 * 4000];\n  scanf(\"%s\", buff);\n  return string{buff};\n}\nint64_t gcd(int64_t a, int64_t b) {\n  while (b) {\n    auto tmp = a % b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n}\nint64_t tr2(int xv1, int yv1, int xv2, int yv2, int x3, int y3) {\n  return 1LL * (xv2 - xv1) * (y3 - yv1) - 1LL * (yv2 - yv1) * (x3 - xv1);\n}\nconst int maxn = 100000;\nint n, k, m;\nvector<pair<int, int>> v;\nint tot;\nint64_t ans;\nconst string input_dir = \"inputs\\\\\";\nstring input_file = input_dir + \"input.txt\";\nstring output_file = input_dir + \"output.txt\";\nvoid init_streams() {}\nvoid ret(int64_t res) {\n  cout << res << endl;\n  exit(0);\n}\nvector<int> eat(vector<int> a, int k) {\n  if (a.size() < k) return move(a);\n  vector<int> cnt(a.size());\n  vector<int> prev;\n  prev.reserve(a.size());\n  if (a.size() > 0) {\n    cnt[0] = 1;\n    prev.push_back(0);\n  }\n  for (int i = 1; i < a.size(); ++i) {\n    ++cnt[i];\n    if (!prev.empty() && a[i] == a[prev.back()]) cnt[i] += cnt[prev.back()];\n    prev.push_back(i);\n    if (cnt[i] == k) prev.resize(prev.size() - k);\n  }\n  for (auto& v : prev) v = a[v];\n  return move(prev);\n}\nint main() {\n  init_streams();\n  auto n = ni(), k = ni(), m = ni();\n  auto a = nvi(n);\n  a = eat(a, k);\n  vector<pair<int, int>> st;\n  for (int i = 0; i < a.size(); ++i) {\n    if (!i || st.back().first != a[i])\n      st.emplace_back(make_pair(a[i], 1));\n    else\n      ++st.back().second;\n  }\n  auto ans = 1LL * m * a.size();\n  if (1 == m || 1 == st.size()) ret(ans % k);\n  int l = 0, r = st.size() - 1;\n  while (l < r) {\n    if (st[l].first != st[r].first) ret(ans);\n    auto sm = st[l].second + st[r].second;\n    if (sm >= k) ans = ans - 1LL * k * (m - 1);\n    if (sm != k) ret(ans);\n    ++l;\n    --r;\n  }\n  if (l == r) {\n    auto tot_left = 1LL * st[l].second * m;\n    ans -= tot_left - (tot_left % k);\n    if (0 == tot_left % k) ans = 0;\n  }\n  ret(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m;\nstruct st {\n  deque<pair<int, int> > a;\n  long long rem;\n  st& operator+=(st o) {\n    rem += o.rem;\n    while (1) {\n      if (!((int)a.size()) or !((int)o.a.size())) break;\n      if (a.back().first != o.a.front().first) break;\n      long long t = a.back().second + o.a.front().second;\n      rem += t / k;\n      t %= k;\n      if (t)\n        a.back().second = t;\n      else\n        a.pop_back();\n      o.a.pop_front();\n    }\n    while (((int)a.size()) > 5010100 / 2) a.pop_back();\n    while (((int)o.a.size()) > 5010100 / 2) o.a.pop_front();\n    while (((int)o.a.size())) a.push_back(o.a.front()), o.a.pop_front();\n    return *this;\n  }\n};\nst x, ans;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k >> m;\n  for (int i = -1; ++i < n;) {\n    int u;\n    cin >> u;\n    if (((int)x.a.size()) == 0 or x.a.back().first != u) x.a.push_back({u, 0});\n    ++x.a.back().second;\n    if (x.a.back().second >= k) x.a.pop_back(), x.rem++;\n  }\n  for (int i = m; i > 0; i >>= 1) {\n    if (i & 1) ans += x;\n    x += x;\n  }\n  cout << n * m - ans.rem * k;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.Collection;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Rustam Musin (PloadyFree@gmail.com)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            int m = in.readInt();\n            List<IntIntPair> all = new ArrayList<>(n); //{type, size}\n            for (int i = 0; i < n; i++) {\n                int type = in.readInt();\n                if (!all.isEmpty() && all.get(all.size() - 1).first == type) {\n                    if (last(all).second == k - 1) {\n                        all.remove(all.size() - 1);\n                    } else {\n                        all.set(all.size() - 1, IntIntPair.makePair(type, last(all).second + 1));\n                    }\n                } else {\n                    all.add(IntIntPair.makePair(type, 1));\n                }\n            }\n\n            long size = 0;\n            for (IntIntPair p : all) {\n                size += p.second;\n            }\n            size *= m;\n\n            if (m == 1 || size == 0 || all.get(0).first != last(all).first) {\n                out.print(size);\n                return;\n            }\n\n            Deque<IntIntPair>[] parts = new Deque[3];\n            parts[0] = new ArrayDeque<>(all);\n            parts[1] = new ArrayDeque<>(all);\n            parts[2] = new ArrayDeque<>(all);\n\n            while (true) {\n                if (parts[1].size() == 1) {\n                    long middle = parts[1].peek().second * (long) m;\n                    if (middle % k == 0) {\n                        size -= middle;\n                        parts[0].pollLast();\n                        parts[2].pollFirst();\n                        size -= merge(parts[0], parts[2], k);\n                        break;\n                    } else {\n                        size -= middle / k * k;\n                        break;\n                    }\n                }\n                if (parts[1].peekFirst().first != parts[1].peekLast().first) {\n                    break;\n                }\n                long curSize = parts[1].peekFirst().second + parts[1].peekLast().second;\n                if (curSize % k != 0) {\n                    size -= (m - 1) * (curSize / k * k);\n                    break;\n                } else {\n                    parts[1].pollFirst();\n                    parts[1].pollLast();\n                    size -= (m - 1) * curSize;\n                    parts[0].pollLast();\n                    parts[2].pollFirst();\n                }\n            }\n\n            out.print(size);\n        }\n\n        int merge(Deque<IntIntPair> q1, Deque<IntIntPair> q2, int k) {\n            int result = 0;\n            while (!q1.isEmpty()) {\n                if (q1.peekLast().first != q2.peekFirst().first) {\n                    break;\n                }\n                int sz = q1.pollLast().second + q2.pollFirst().second;\n                result += sz / k * k;\n                if (sz % k != 0) {\n                    break;\n                }\n            }\n            return result;\n        }\n\n        <T> T last(List<T> a) {\n            return a.get(a.size() - 1);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void print(long i) {\n            writer.print(i);\n        }\n\n    }\n\n    static class IntIntPair implements Comparable<IntIntPair> {\n        public final int first;\n        public final int second;\n\n        public static IntIntPair makePair(int first, int second) {\n            return new IntIntPair(first, second);\n        }\n\n        public IntIntPair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            IntIntPair pair = (IntIntPair) o;\n\n            return first == pair.first && second == pair.second;\n        }\n\n\n        public int hashCode() {\n            int result = first;\n            result = 31 * result + second;\n            return result;\n        }\n\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        @SuppressWarnings({\"unchecked\"})\n        public int compareTo(IntIntPair o) {\n            int value = Integer.compare(first, o.first);\n            if (value != 0) {\n                return value;\n            }\n            return Integer.compare(second, o.second);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 6;\nlong long f[N], s[N];\nsigned main() {\n  long long n, k, m;\n  cin >> n >> k >> m;\n  vector<long long> a(n);\n  for (long long i = 0; i < n; ++i) cin >> a[i];\n  if (k >= n) {\n    bool allSame = true;\n    for (long long i = 1; i < n; ++i) allSame &= (a[i] == a[i - 1]);\n    if (allSame)\n      cout << n * m % k;\n    else\n      cout << n * m;\n    return 0;\n  }\n  long long top = 0;\n  for (long long i = 0; i < n; ++i) {\n    s[++top] = a[i];\n    if (top > 1 && s[top] == s[top - 1]) {\n      f[top] = f[top - 1] + 1;\n    } else {\n      f[top] = 1;\n    }\n    if (f[top] == k) top -= k;\n  }\n  long long L = 1, R = top;\n  long long ans = 0;\n  while (s[L] == s[R] && L != R) {\n    long long cnt = 0, l = L, r = R;\n    while (s[l] == s[L] && l < r && cnt < k) ++l, ++cnt;\n    while (s[r] == s[R] && l < r && cnt < k) --r, ++cnt;\n    if (cnt == k) {\n      L = l, R = r, ans += k;\n    } else {\n      break;\n    }\n  }\n  bool allSame = true;\n  for (long long i = L + 1; i <= R; ++i) {\n    allSame &= (s[i] == s[i - 1]);\n  }\n  if (allSame) {\n    if ((R - L + 1) * m % k == 0) {\n      cout << 0 << '\\n';\n    } else {\n      cout << (R - L + 1) * m % k + ans;\n    }\n  } else {\n    cout << (R - L + 1) * m + ans;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  long long n, k, m;\n  bool print = false;\n  cin >> n >> k >> m;\n  vector<pair<int, int> > cur;\n  for (int i = 0; i < n; i++) {\n    int temp;\n    cin >> temp;\n    if (i == 0 && temp == 8) {\n      print = true;\n    }\n    if (cur.empty() || cur.back().first != temp)\n      cur.push_back({temp, 1});\n    else\n      cur.back().second++;\n    if (cur.back().second == k) cur.pop_back();\n  }\n  if (cur.empty()) {\n    cout << 0;\n    return 0;\n  }\n  long long total = 0;\n  for (auto u : cur) total += u.second;\n  if (m == 1) {\n    cout << total;\n    return 0;\n  }\n  int sptr = 0, eptr = cur.size() - 1;\n  total = m * (total);\n  while (sptr < eptr) {\n    if (cur[sptr].first != cur[eptr].first) {\n      cout << total;\n      return 0;\n    }\n    long long join = cur[sptr].second + cur[eptr].second;\n    if (join < k) {\n      cout << total;\n      return 0;\n    } else if (join > k) {\n      total -= (m - 1) * k;\n      cout << total;\n      return 0;\n    } else {\n      total -= (m - 1) * k;\n      sptr++;\n      eptr--;\n    }\n  }\n  if (sptr == eptr) {\n    long long val = (long long)cur[sptr].second * m;\n    if (val % k == 0) {\n      cout << 0;\n      return 0;\n    }\n    total = (total - (val / k) * k);\n  }\n  cout << total;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool debug = 0;\nint n, m, k;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nstring direc = \"RDLU\";\nlong long ln, lk, lm;\nvoid etp(bool f = 0) {\n  puts(f ? \"YES\" : \"NO\");\n  exit(0);\n}\nvoid addmod(int &x, int y, int mod = 1000000007) {\n  assert(y >= 0);\n  x += y;\n  if (x >= mod) x -= mod;\n  assert(x >= 0 && x < mod);\n}\nvoid et() {\n  puts(\"-1\");\n  exit(0);\n}\nlong long fastPow(long long x, long long y, int mod = 1000000007) {\n  long long ans = 1;\n  while (y > 0) {\n    if (y & 1) ans = (x * ans) % mod;\n    x = x * x % mod;\n    y >>= 1;\n  }\n  return ans;\n}\nlong long gcd1(long long x, long long y) {\n  long long z = y;\n  while (x % y != 0) {\n    z = x % y;\n    x = y;\n    y = z;\n  }\n  return z;\n}\nint a[100005];\nvector<pair<int, int> > vp;\nvoid pp(long long x) {\n  printf(\"%lld\\n\", x);\n  exit(0);\n}\nvoid fmain(int ID) {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int(i) = 1; (i) <= (int)(n); (i)++) {\n    scanf(\"%d\", a + i);\n    if (vp.empty() || vp.back().first != a[i])\n      vp.push_back({a[i], 1});\n    else {\n      vp[vp.size() - 1].second++;\n      if (vp.back().second == k) {\n        vp.pop_back();\n      }\n    }\n  }\n  debug = k == 42 && a[1] == 8;\n  int N = vp.size();\n  if (N == 1) {\n    pp((long long)vp[0].second * m % k);\n  }\n  int L = 0, R = N - 1;\n  while (L <= R) {\n    if (vp[L].second + vp[R].second == k && vp[L].first == vp[R].first) {\n      L++;\n      R--;\n    } else\n      break;\n  }\n  if (L > N / 2) {\n    if (m % 2 == 0)\n      pp(0);\n    else {\n      int aa = 0;\n      for (auto p : vp) aa += p.second;\n      pp(aa);\n    }\n  } else if (N % 2 == 1 && L >= N / 2) {\n    long long ms = (long long)vp[N / 2].second * m;\n    if (ms % k == 0) pp(0);\n    vp[N / 2].second = ms % k;\n    int aa = 0;\n    for (auto p : vp) aa += p.second;\n    pp(aa);\n  } else {\n    long long sl = 0, sm = 0, sr = 0;\n    for (int(i) = 0; (i) < (int)(L); (i)++) sl += vp[i].second;\n    for (int i = R + 1; i < N; i++) sr += vp[i].second;\n    for (int i = L; i <= R; i++) sm += vp[i].second;\n    assert(L != R);\n    long long ans = sm * m + sl + sr;\n    if (vp[L].first == vp[R].first) {\n      ans -= (long long)(vp[L].second + vp[R].second) / k * (m - 1) * k;\n    }\n    pp(ans);\n  }\n}\nint main() {\n  int t = 1;\n  for (int(i) = 1; (i) <= (int)(t); (i)++) {\n    fmain(i);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class main {\n    public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    public static PrintWriter pw = new PrintWriter(System.out);\n    public static String line;\n    public static StringTokenizer st;\n    public static ArrayList<ArrayList<Integer>> adjList;\n    public static int[] dx = {-1, 0, 1, 0, -1, 1, 1, -1};\n    public static int[] dy = {0, 1, 0, -1, 1, 1, -1, -1};\n    public static int INF = 0x3f3f3f3f;\n    public static int MOD = 1000000007;\n\n    public static void main(String[] args) throws Exception{\n        st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int K = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        int[] A = new int[N];\n        st = new StringTokenizer(br.readLine());\n        for(int i = 0; i < N; i++){\n            A[i] = Integer.parseInt(st.nextToken());\n        }\n\n        Stack<Pair> S = new Stack<Pair>();\n        long ans = N;\n        for(int i = 0; i < N; i++){\n            if(S.size() == 0 || S.peek().x != A[i]){\n                S.push(new Pair(A[i], 1));\n            } else{\n                Pair p = S.peek();\n                p.y += 1;\n                if(p.y == K){\n                    S.pop();\n                    ans -= K;\n                }\n            }\n        }\n        ans *= M;\n\n        ArrayList<Pair> order = new ArrayList<Pair>(S);\n        int first = 0;\n        int last = order.size()-1;\n        while(first < last){\n            Pair p1 = order.get(first);\n            Pair p2 = order.get(last);\n\n            if(p1.x == p2.x && p1.y + p2.y >= K){\n                ans -= (long)K * (M - 1);\n                if(p1.y + p2.y == K){\n                    first++;\n                    last--;\n                } else{\n                    break;\n                }\n            } else{\n                break;\n            }\n        }\n\n        if(first == last){\n            long rem = (long)order.get(first).y * M;\n            if(rem % K == 0){\n                ans = 0;\n            } else{\n                ans = ans - (rem / K) * K;\n            }\n        }\n\n        pw.print(ans + \"\\n\");\n\n        pw.close(); \n        br.close();\n    }\n}\n\nclass Pair{\n    public int x, y;\n\n    Pair(int _x, int _y){\n        x = _x;\n        y = _y;\n    }\n\n    public String toString(){\n        return x + \",\" + y;\n    }\n}\n\nclass Point implements Comparable<Point>{\n    public double x, y;\n\n    Point(double x, double y){\n        this.x = x;\n        this.y = y;\n    }\n\n    public int compareTo(Point p){\n        if(x != p.x) return x < p.x ? -1 : 1;\n        else if(y != p.y) return y < p.y ? -1 : 1;\n        return 0;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nconst ld eps = 1e-8;\nconst ld tau = 2 * acosl(-1);\nconst int inf = 1e9 + 99;\nconst long long linf = 1e18 + 99;\nconst int P = 1e9 + 7;\nconst int N = 100 << 10;\nint a[N], n, k, m;\nint ct[N * 5], b[N * 5];\nint solve(const vector<int> &v) {\n  int i = 1;\n  for (int x : v) {\n    b[i] = x;\n    if (i > 1 && b[i] == b[i - 1])\n      ct[i] = ct[i - 1] + 1;\n    else\n      ct[i] = 1;\n    if (ct[i] == k) i -= k;\n    ++i;\n  }\n  return i - 1;\n}\nint32_t main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  int i = 1;\n  for (int j = 1; j <= n; j++) {\n    scanf(\"%d\", a + i);\n    if (i > 1 && a[i] == a[i - 1])\n      ct[i] = ct[i - 1] + 1;\n    else\n      ct[i] = 1;\n    if (ct[i] == k) i -= k;\n    ++i;\n  }\n  int L = 1, R = i - 1;\n  vector<int> ww, vv;\n  for (; L <= R && a[L] == a[R];) {\n    int tr = 0;\n    for (int i = R; i >= L; i--) {\n      if (tr >= k) break;\n      if (a[i] == a[R])\n        ++tr;\n      else\n        break;\n    }\n    int st = 0;\n    for (int i = L; i <= R; i++) {\n      if (st >= k) break;\n      if (a[i] == a[L])\n        ++st;\n      else\n        break;\n    }\n    if (st + tr >= R - L + 1) {\n      int err = int(1LL * (R - L + 1) * m % k);\n      if (err)\n        for (; err < k && vv.size() && vv.back() == a[L];) vv.pop_back(), ++err;\n      if (err)\n        for (; err < k && ww.size() && ww.back() == a[R];) ww.pop_back(), ++err;\n      err %= k;\n      if (err)\n        printf(\"%d\\n\", solve(vv) + solve(ww) + err);\n      else {\n        reverse(ww.begin(), ww.end());\n        for (int x : ww) vv.push_back(x);\n        printf(\"%d\\n\", solve(vv));\n      }\n      return 0;\n    }\n    if (st + tr >= k) {\n      tr = min(tr, k - st);\n      for (; st;) vv.push_back(a[L++]), --st;\n      for (; tr;) ww.push_back(a[R--]), --tr;\n      assert(L <= R);\n    } else\n      break;\n  }\n  long long Z = 1LL * m * (R - L + 1);\n  assert(solve(vv) == (int)vv.size());\n  assert(solve(ww) == (int)ww.size());\n  if (!Z) {\n    reverse(ww.begin(), ww.end());\n    for (int x : ww) vv.push_back(x);\n    printf(\"%d\\n\", solve(vv));\n  } else {\n    printf(\"%lld\\n\", Z + solve(vv) + solve(ww));\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename U>\ninline void smin(T &a, const U &b) {\n  if (a > b) a = b;\n}\ntemplate <typename T, typename U>\ninline void smax(T &a, const U &b) {\n  if (a < b) a = b;\n}\ntemplate <class T>\ninline void gn(T &first) {\n  char c, sg = 0;\n  while (c = getchar(), (c > '9' || c < '0') && c != '-')\n    ;\n  for ((c == '-' ? sg = 1, c = getchar() : 0), first = 0; c >= '0' && c <= '9';\n       c = getchar())\n    first = (first << 1) + (first << 3) + c - '0';\n  if (sg) first = -first;\n}\ntemplate <class T1, class T2>\ninline void gn(T1 &x1, T2 &x2) {\n  gn(x1), gn(x2);\n}\ntemplate <class T1, class T2, class T3>\ninline void gn(T1 &x1, T2 &x2, T3 &x3) {\n  gn(x1, x2), gn(x3);\n}\ntemplate <class T>\ninline void print(T first) {\n  if (first < 0) {\n    putchar('-');\n    return print(-first);\n  }\n  if (first < 10) {\n    putchar('0' + first);\n    return;\n  }\n  print(first / 10);\n  putchar(first % 10 + '0');\n}\ntemplate <class T>\ninline void println(T first) {\n  print(first);\n  putchar('\\n');\n}\ntemplate <class T>\ninline void printsp(T first) {\n  print(first);\n  putchar(' ');\n}\ntemplate <class T1, class T2>\ninline void print(T1 x1, T2 x2) {\n  printsp(x1), println(x2);\n}\ntemplate <class T1, class T2, class T3>\ninline void print(T1 x1, T2 x2, T3 x3) {\n  printsp(x1), printsp(x2), println(x3);\n}\nint power(int a, int b, int m, int ans = 1) {\n  for (; b; b >>= 1, a = (long long)a * a % m)\n    if (b & 1) ans = (long long)ans * a % m;\n  return ans;\n}\npair<int, int> p[100010];\nint nn;\nint main() {\n  int n, k, m;\n  gn(n, k, m);\n  for (int i = 0; i < n; i++) {\n    gn(p[i].first);\n    p[i].second = 1;\n  }\n  for (int i = 0, j = 0; i < n; i = j) {\n    for (j = i + 1; j < n && p[i].first == p[j].first; j++)\n      ;\n    if (nn && p[nn - 1].first == p[i].first)\n      p[nn - 1].second += j - i;\n    else\n      p[nn++] = pair<int, int>(p[i].first, j - i);\n    p[nn - 1].second %= k;\n    if (!p[nn - 1].second) nn--;\n  }\n  int st = 0, ed = nn - 1;\n  while (st < ed) {\n    if (p[st].first != p[ed].first || (p[st].second + p[ed].second) % k) break;\n    st++, ed--;\n  }\n  long long len = 0;\n  if (st == ed) {\n    len = (long long)p[st].second * m % k;\n    if (len)\n      println((long long)k * st + len);\n    else\n      puts(\"0\");\n  } else if (st < ed) {\n    for (int i = st; i <= ed; i++) len += p[i].second;\n    len *= m;\n    if (p[st].first == p[ed].first) {\n      len -= (long long)(p[st].second + p[ed].second) / k * k * (m - 1);\n    }\n    println(len + (long long)st * k);\n  } else\n    puts(\"0\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid doRoutine() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n}\nvoid process(vector<int64_t> &a, int64_t k) {\n  int64_t n = a.size();\n  vector<pair<int64_t, int64_t> > pcs;\n  for (int64_t i = 0; i < n; ++i) {\n    if (pcs.empty() || pcs.back().second != a[i]) {\n      pcs.push_back({1, a[i]});\n    } else {\n      ++pcs.back().first;\n      if (pcs.back().first == k) {\n        pcs.pop_back();\n      }\n    }\n  }\n  vector<int64_t> res;\n  for (auto pr : pcs) {\n    for (int64_t i = 0; i < pr.first; ++i) {\n      res.push_back(pr.second);\n    }\n  }\n  a = res;\n}\nsigned main() {\n  doRoutine();\n  int64_t n, k, m;\n  cin >> n >> k >> m;\n  vector<int64_t> a(n);\n  for (int64_t i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  process(a, k);\n  n = a.size();\n  if (m <= 2) {\n    vector<int64_t> b;\n    for (int64_t j = 0; j < m; ++j) {\n      for (int64_t i = 0; i < n; ++i) {\n        b.push_back(a[i]);\n      }\n    }\n    process(b, k);\n    cout << (int64_t)b.size() << endl;\n  } else {\n    int64_t ans = m * n;\n    int64_t i = 0, j = n - 1;\n    while (j - i + 1 >= k) {\n      if (a[i] != a[j]) {\n        cout << ans << endl;\n        return 0;\n      }\n      int64_t pi = i, pj = j;\n      while (a[i + 1] == a[i]) {\n        ++i;\n      }\n      while (pj - j + 1 + i - pi + 1 < k && a[j - 1] == a[j]) {\n        --j;\n      }\n      if (pj - j + 1 + i - pi + 1 == k) {\n        ans -= k * (m - 1);\n      } else {\n        cout << ans << endl;\n        return 0;\n      }\n      ++i;\n      --j;\n    }\n    bool is_eq = true;\n    for (int64_t t = i; t < j; ++t) {\n      if (a[t] != a[t + 1]) {\n        is_eq = false;\n      }\n    }\n    if (is_eq) {\n      int64_t sum = 0;\n      int64_t t = j;\n      while (t >= 0 && a[t] == a[j]) {\n        --t;\n      }\n      sum += j - t;\n      int64_t right = t;\n      t = i;\n      while (t < n && a[t] == a[i]) {\n        ++t;\n      }\n      sum += t - i;\n      int64_t left = t;\n      sum += (m - 2) * (j - i + 1);\n      ans -= (sum / k) * k;\n      if (sum % k == 0) {\n        vector<int64_t> rest;\n        for (int64_t t = 0; t <= right; ++t) {\n          rest.push_back(a[t]);\n        }\n        for (int64_t t = left; t < n; ++t) {\n          rest.push_back(a[t]);\n        }\n        process(rest, k);\n        cout << rest.size() << endl;\n        return 0;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (int)1e9 + 123;\nconst long long LINF = (long long)1e18 + 123;\nconst long double EPS = (long double)1e-7;\nconst long long MOD = (long long)1e9 + 7;\nlong long power(long long x, long long y, long long mod = MOD) {\n  if (y == 0) {\n    return 1;\n  }\n  if (y & 1) {\n    return power(x, y - 1, mod) * x % mod;\n  } else {\n    long long tmp = power(x, y / 2, mod);\n    return tmp * tmp % mod;\n  }\n}\ntemplate <typename A, typename B>\nbool mini(A &x, const B &y) {\n  if (y < x) {\n    x = y;\n    return true;\n  }\n  return false;\n}\ntemplate <typename A, typename B>\nbool maxi(A &x, const B &y) {\n  if (y > x) {\n    x = y;\n    return true;\n  }\n  return false;\n}\nvoid run();\nint main() {\n  if (strlen(\"\")) {\n    freopen(\n        \"\"\n        \".in\",\n        \"r\", stdin);\n    freopen(\n        \"\"\n        \".out\",\n        \"w\", stdout);\n  }\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cout << fixed << setprecision(12);\n  run();\n  return 0;\n}\nconst int N = (int)2e5 + 123;\ntemplate <typename T>\nstruct Deque {\n  int l, r;\n  vector<T> q;\n  Deque() {\n    l = 0, r = 0;\n    q.resize(4 * N + 100);\n  }\n  T &front() { return q[l]; }\n  void pop_front() { l++; }\n  T &back() { return q[r - 1]; }\n  void pop_back() { r--; }\n  int size() { return r - l; }\n  void push_back(const T &x) { q[r++] = x; }\n  void push_front(const T &x) { q[l--] = x; }\n  void only_prefix() {\n    if (size() > N) {\n      r = l + N;\n    }\n    shift();\n  }\n  void only_suffix() {\n    if (size() > N) {\n      l = r - N;\n    }\n    shift();\n  }\n  void shift() {\n    int len = size();\n    for (int i = 0; i < len; i++) {\n      q[i] = q[l + i];\n    }\n    l = 0;\n    r = len;\n  }\n};\nint n, k, m;\nint a[N];\nstruct Shit {\n  bool divided;\n  long long rest;\n  Deque<pair<int, int>> l, r;\n  Shit() {\n    divided = 0;\n    rest = 0;\n  }\n};\nShit init;\nvoid convert() {\n  Deque<pair<int, int>> q;\n  long long cnt = 0;\n  for (int i = 0; i < n; i++) {\n    cnt++;\n    if (q.size() == 0) {\n      q.push_back({a[i], 1});\n    } else {\n      if (q.back().first == a[i]) {\n        q.back().second++;\n      } else {\n        q.push_back({a[i], 1});\n      }\n    }\n    if (q.back().second >= k) {\n      cnt -= k;\n      q.pop_back();\n    }\n  }\n  init.rest = cnt;\n  init.l = q;\n}\nShit merge(Shit a, Shit b) {\n  Shit res;\n  if (a.divided && b.divided) {\n    res.rest = a.rest + b.rest;\n    while (a.r.size() && b.l.size() && a.r.back().first == b.l.front().first) {\n      int cntL = a.r.back().second;\n      int cntR = b.l.front().second;\n      assert(cntL < k && cntR < k);\n      if (cntL + cntR < k) {\n        a.r.back().second += cntR;\n        b.l.pop_front();\n        break;\n      }\n      a.r.pop_back();\n      if (cntL + cntR == k) {\n        b.l.pop_front();\n      } else {\n        b.l.front().second -= (k - cntL);\n      }\n      res.rest -= k;\n    }\n    res.divided = 1;\n    res.l = a.l;\n    res.r = b.r;\n  } else if (a.divided) {\n    res.rest = a.rest + b.rest;\n    while (a.r.size() && b.l.size() && a.r.back().first == b.l.front().first) {\n      int cntL = a.r.back().second;\n      int cntR = b.l.front().second;\n      assert(cntL < k && cntR < k);\n      if (cntL + cntR < k) {\n        a.r.back().second += cntR;\n        b.l.pop_front();\n        break;\n      }\n      a.r.pop_back();\n      if (cntL + cntR == k) {\n        b.l.pop_front();\n      } else {\n        b.l.front().second -= (k - cntL);\n      }\n      res.rest -= k;\n    }\n    res.divided = 1;\n    res.l = a.l;\n    while (b.l.size()) {\n      a.r.push_back(b.l.front());\n      b.l.pop_front();\n    }\n    res.r = a.r;\n    res.r.only_suffix();\n  } else if (b.divided) {\n    res.rest = a.rest + b.rest;\n    while (a.l.size() && b.l.size() && a.l.back().first == b.l.front().first) {\n      int cntL = a.l.back().second;\n      int cntR = b.l.front().second;\n      assert(cntL < k && cntR < k);\n      if (cntL + cntR < k) {\n        a.l.back().second += cntR;\n        b.l.pop_front();\n        break;\n      }\n      a.l.pop_back();\n      if (cntL + cntR == k) {\n        b.l.pop_front();\n      } else {\n        b.l.front().second -= (k - cntL);\n      }\n      res.rest -= k;\n    }\n    res.divided = 1;\n    res.r = b.r;\n    while (b.l.size()) {\n      a.l.push_back(b.l.front());\n      b.l.pop_front();\n    }\n    res.l = a.l;\n    res.l.only_prefix();\n  } else {\n    res.rest = a.rest + b.rest;\n    while (a.l.size() && b.l.size() && a.l.back().first == b.l.front().first) {\n      int cntL = a.l.back().second;\n      int cntR = b.l.front().second;\n      assert(cntL < k && cntR < k);\n      if (cntL + cntR < k) {\n        a.l.back().second += cntR;\n        b.l.pop_front();\n        break;\n      }\n      a.l.pop_back();\n      if (cntL + cntR == k) {\n        b.l.pop_front();\n      } else {\n        b.l.front().second -= (k - cntL);\n      }\n      res.rest -= k;\n    }\n    while (b.l.size()) {\n      a.l.push_back(b.l.front());\n      b.l.pop_front();\n    }\n    if (a.l.size() >= 2 * N) {\n      auto l = a.l;\n      auto r = a.l;\n      l.only_prefix();\n      r.only_suffix();\n      res.divided = 1;\n      res.l = l;\n      res.r = r;\n    } else {\n      res.l = a.l;\n    }\n  }\n  return res;\n}\nShit solve(int x) {\n  if (x == 1) {\n    return init;\n  }\n  Shit tmp = solve(x / 2);\n  Shit shit = merge(tmp, tmp);\n  if (x & 1) {\n    shit = merge(shit, init);\n  }\n  return shit;\n}\nvoid run() {\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  convert();\n  cout << solve(m).rest << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000 + 10;\nvector<pair<int, int>> d;\nint t[maxn];\nint main() {\n  int n, m, k;\n  while (scanf(\"%d%d%d\", &n, &k, &m) == 3) {\n    for (int i = 0; i < n; i++) scanf(\"%d\", &t[i]);\n    d.clear();\n    int cnt = 1;\n    int pre = t[0];\n    for (int i = 1; i < n; i++) {\n      if (t[i] != pre) {\n        if (cnt % k != 0) {\n          d.push_back({pre, cnt % k});\n          cnt = 1;\n        } else {\n          if (d.size() && d.back().first == t[i]) {\n            cnt = d.back().second + 1;\n            d.pop_back();\n          } else\n            cnt = 1;\n        }\n        pre = t[i];\n      } else\n        cnt++;\n    }\n    if (cnt % k) d.push_back({t[n - 1], cnt % k});\n    vector<pair<int, int>> head, tail, now, mid;\n    int lim = d.size(), same = true;\n    for (int i = 0; i < lim; i++) {\n      if (i == lim - 1) {\n        now.push_back(d[i]);\n        break;\n      }\n      auto p1 = d[i], p2 = d[lim - 1];\n      if (same && p1.first == p2.first) {\n        int s = p1.second + p2.second;\n        if (s % k != 0) mid.push_back({p1.first, s % k}), same = false;\n        head.push_back(d[i]);\n        tail.push_back(d[lim - 1]);\n        lim--;\n      } else {\n        same = false;\n        now.push_back(p1);\n      }\n    }\n    long long sum_now = 0;\n    for (auto i : now) sum_now += i.second;\n    sum_now *= (long long)m;\n    if (now.size() == 1 && mid.size() == 0) sum_now %= k;\n    assert(mid.size() <= 1);\n    long long sum_mid = 0;\n    for (auto i : mid) sum_mid += i.second;\n    sum_mid *= (m - 1);\n    if (now.size() == 0) sum_mid %= k;\n    long long sum_head = 0;\n    if (sum_now + sum_mid == 0) {\n      reverse(tail.begin(), tail.end());\n      for (auto i : tail) {\n        auto& p1 = head.back();\n        if (p1.first == i.first) {\n          p1.second += i.second;\n          p1.second %= k;\n          if (p1.second == 0) head.pop_back();\n        } else\n          head.push_back(p1);\n      }\n      for (auto i : head) sum_head += i.second;\n    } else {\n      for (auto i : head) sum_head += (long long)i.second;\n      for (auto i : tail) sum_head += (long long)i.second;\n    }\n    printf(\"%lld\\n\", sum_head + sum_mid + sum_now);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\nint n, k, m, a[N];\nlong long core, sum, tot, siz;\nvector<pair<int, int> > b, rb;\nvoid deal() {\n  for (int i = 1; i <= n; i++)\n    if (b.size() && b.back().first == a[i])\n      b.back().second++;\n    else {\n      if (b.size()) {\n        b.back().second %= k;\n        if (!b.back().second) b.pop_back();\n        if (!b.size() || b.back().first != a[i])\n          b.push_back(make_pair(a[i], 1));\n        else\n          b.back().second++;\n        b.back().second %= k;\n        if (!b.back().second) b.pop_back();\n      } else\n        b.push_back(make_pair(a[i], 1));\n    }\n  if (b.size()) {\n    b.back().second %= k;\n    if (!b.back().second) b.pop_back();\n  }\n  for (pair<int, int> v : b) sum += v.second;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  deal();\n  siz = b.size();\n  if (!siz) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (m == 1) {\n    cout << sum << endl;\n    return 0;\n  }\n  if (siz == 1) {\n    cout << sum * m % k << endl;\n    return 0;\n  }\n  for (int i = siz - 1; i >= 0; i--) rb.push_back(b[i]);\n  for (int i = 0; i < siz; i++) {\n    if (b[i].first != rb[i].first) break;\n    tot += b[i].second + rb[i].second - (b[i].second + rb[i].second) % k;\n    if ((b[i].second + rb[i].second) % k) {\n      if (siz & 1 && i == siz / 2) core = b[i].second;\n      break;\n    }\n  }\n  if (tot != sum * 2) {\n    if (core) {\n      if (core * m % k == 0)\n        cout << 0 << endl;\n      else\n        cout << core * m % k + sum - b[siz / 2].second << endl;\n    } else\n      cout << sum * m - tot * (m - 1) << endl;\n  } else if (m % 2)\n    cout << sum << endl;\n  else\n    cout << 0 << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double Pi = acos(-1);\nbool inline equ(double a, double b) { return fabs(a - b) < EPS; }\nint _R(int& x) { return scanf(\"%d\", &x); }\nint _R(long long& x) { return scanf(\"%\" PRId64, &x); }\nint _R(double& x) { return scanf(\"%lf\", &x); }\nint _R(char* s) { return scanf(\"%s\", s); }\nint R() { return 0; }\ntemplate <typename T1, typename... T2>\nint R(T1& x, T2&... tail) {\n  int tmp = _R(x);\n  return tmp + R(tail...);\n}\ntemplate <typename Iter, typename F>\ninline void out(Iter s, Iter e, F of) {\n  bool flag = 0;\n  for (Iter it = s; it != e; it++) {\n    if (flag)\n      printf(\" \");\n    else\n      flag = 1;\n    of(*it);\n  }\n  puts(\"\");\n}\nconst int N = 1e5 + 10;\nint n;\nlong long k, m;\nvector<pair<int, int> > reduce(vector<int>& vec) {\n  vector<pair<int, int> > res;\n  int j = 0;\n  for (int i = 0; i < ((int)(vec).size()); i++) {\n    j = i + 1;\n    while (j < (int)(vec).size() and vec[i] == vec[j]) ++j;\n    long long rem = j - i;\n    while ((int)(res).size() and res.back().first == vec[i]) {\n      rem += res.back().second;\n      res.pop_back();\n    }\n    rem %= k;\n    if (rem) {\n      res.push_back({vec[i], rem});\n    }\n    i = j - 1;\n  }\n  return res;\n}\nint main() {\n  R(n, k, m);\n  long long ans = 0;\n  vector<int> a;\n  for (int i = (0); i <= (n - 1); i++) {\n    int x;\n    R(x);\n    a.push_back(x);\n  }\n  vector<pair<int, int> > vec = reduce(a);\n  if ((int)(vec).size() == 1) {\n    ans = (m * vec[0].second) % k;\n    cout << ans << endl;\n    return 0;\n  }\n  if ((int)(vec).size() == 0) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  if (m == 1) {\n    ans = 0;\n    for (pair<int, int> p : vec) ans += p.second;\n    cout << ans << endl;\n    return 0;\n  }\n  int r = (int)(vec).size() - 1;\n  for (int l = 0; l < ((int)(vec).size()); l++) {\n    if (vec[l].first != vec[r].first) {\n      ans = 0;\n      for (pair<int, int> p : vec) ans += p.second;\n      for (int i = (l); i <= (r); i++) ans += (m - 1) * vec[i].second;\n      cout << ans << endl;\n      return 0;\n    }\n    if (l > r) {\n      ans = 0;\n      cout << ans << endl;\n      return 0;\n    }\n    if (l == r) {\n      long long all = m * (vec[l].second);\n      all %= k;\n      if (all > 0) {\n        ans = all % k;\n        for (int i = (0); i <= (l - 1); i++) ans += vec[i].second;\n        for (int i = (r + 1); i <= ((int)(vec).size() - 1); i++)\n          ans += vec[i].second;\n        cout << ans << endl;\n        return 0;\n      } else {\n        cout << \"0\\n\";\n        return 0;\n      }\n    }\n    long long cnt = vec[l].second + vec[r].second;\n    if (cnt % k > 0) {\n      ans = (m - 1) * (cnt % k);\n      for (int i = (l + 1); i <= (r - 1); i++) ans += (m - 2) * vec[i].second;\n      for (int i = (0); i <= (r - 1); i++) ans += vec[i].second;\n      for (int i = (l + 1); i <= ((int)(vec).size() - 1); i++)\n        ans += vec[i].second;\n      cout << ans << endl;\n      return 0;\n    }\n    r--;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T1, typename T2>\ninline void chkmin(T1 &x, T2 y) {\n  if (x > y) x = y;\n}\ntemplate <typename T1, typename T2>\ninline void chkmax(T1 &x, T2 y) {\n  if (x < y) x = y;\n}\ninline int readChar();\ntemplate <class T = int>\ninline T readInt();\ntemplate <class T>\ninline void writeInt(T x, char end = 0);\ninline void writeChar(int x);\ninline void writeWord(const char *s);\nstatic const int buf_size = 4096;\ninline int getChar() {\n  static char buf[buf_size];\n  static int len = 0, pos = 0;\n  if (pos == len) {\n    pos = 0, len = fread(buf, 1, buf_size, stdin);\n  }\n  if (pos == len) {\n    return -1;\n  }\n  return buf[pos++];\n}\ninline int readChar() {\n  int c = getChar();\n  while (c <= 32) {\n    c = getChar();\n  }\n  return c;\n}\ntemplate <class T>\ninline T readInt() {\n  int s = 1, c = readChar();\n  T x = 0;\n  if (c == '-') s = -1, c = getChar();\n  while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getChar();\n  return s == 1 ? x : -x;\n}\nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\ninline void writeChar(int x) {\n  if (write_pos == buf_size)\n    fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n  write_buf[write_pos++] = x;\n}\ntemplate <class T>\ninline void writeInt(T x, char end) {\n  if (x < 0) writeChar('-'), x = -x;\n  char s[24];\n  int n = 0;\n  while (x || !n) s[n++] = '0' + x % 10, x /= 10;\n  while (n--) writeChar(s[n]);\n  if (end) writeChar(end);\n}\ninline void writeWord(const char *s) {\n  while (*s) writeChar(*s++);\n}\nstruct Flusher {\n  ~Flusher() {\n    if (write_pos) fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n  }\n} flusher;\nconst int MAXN = 200001;\nint n, k, m;\nint a[MAXN];\nint main() {\n  n = readInt(), k = readInt(), m = readInt();\n  vector<pair<int, int> > st;\n  for (int i = 0; i < n; i++) {\n    a[i] = readInt();\n    if (!st.empty()) {\n      if (st.back().second == k) {\n        st.pop_back();\n      }\n    }\n    if (st.empty() || st.back().first != a[i]) {\n      st.push_back(make_pair(a[i], 1));\n    } else {\n      st.back().second++;\n    }\n  }\n  if (!st.empty()) {\n    if (st.back().second == k) {\n      st.pop_back();\n    }\n  }\n  if (st.empty()) {\n    writeInt(0, '\\n');\n    return 0;\n  }\n  n = (int)(st).size();\n  if (m == 1) {\n    int res = 0;\n    for (auto x : st) {\n      res += x.second;\n    }\n    writeInt(res, '\\n');\n    return 0;\n  }\n  vector<pair<int, int> > mid, beg, en;\n  beg = st;\n  en = st;\n  reverse((en).begin(), (en).end());\n  if (m != 2) {\n    mid = st;\n  }\n  if (m == 2) {\n    while (!beg.empty() && beg.back().first == en.back().first) {\n      if (beg.back().second + en.back().second > k) {\n        int ss = (beg.back().second + en.back().second) % k;\n        beg.pop_back();\n        en.back().second = ss;\n        continue;\n      } else {\n        if (beg.back().second + en.back().second == k) {\n          beg.pop_back();\n          en.pop_back();\n          continue;\n        }\n      }\n      break;\n    }\n    int res = 0;\n    for (auto x : beg) {\n      res += x.second;\n    }\n    for (auto x : en) {\n      res += x.second;\n    }\n    writeInt(res, '\\n');\n  } else {\n    int l = 0;\n    int r = n - 1;\n    while (true) {\n      if (l > r) {\n        break;\n      }\n      if (mid[l].first != beg.back().first) {\n        break;\n      }\n      if (l == r) {\n        if (1LL * mid[l].second * (m - 2) + beg.back().second +\n                en.back().second <\n            k) {\n          break;\n        }\n        int len = (1LL * mid[l].second * (m - 2) + beg.back().second +\n                   en.back().second) %\n                  k;\n        l++;\n        r--;\n        int sss = beg.back().first;\n        beg.pop_back();\n        en.pop_back();\n        if (len) {\n          beg.push_back(make_pair(sss, len));\n        }\n        break;\n      }\n      if (mid[l].second + beg.back().second < k) {\n        break;\n      }\n      int len = (mid[l].second + beg.back().second) % k;\n      if (len == 0) {\n        l++;\n        r--;\n        beg.pop_back();\n        en.pop_back();\n      } else {\n        l++;\n        en.pop_back();\n        beg.back().second = len;\n        mid[r].second = len;\n        break;\n      }\n    }\n    if (l > r) {\n      while (!beg.empty() && beg.back().first == en.back().first) {\n        if (beg.back().second + en.back().second > k) {\n          int ss = (beg.back().second + en.back().second) % k;\n          beg.pop_back();\n          en.back().second = ss;\n          continue;\n        } else {\n          if (beg.back().second + en.back().second == k) {\n            beg.pop_back();\n            en.pop_back();\n            continue;\n          }\n        }\n        break;\n      }\n    }\n    long long res = 0;\n    for (auto x : beg) {\n      res += x.second;\n    }\n    for (auto x : en) {\n      res += x.second;\n    }\n    for (int i = l; i <= r; i++) {\n      res += 1LL * (m - 2) * mid[i].second;\n    }\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nconst long long mod = 1e9 + 7;\nconst int inf = 0x3f3f3f3f;\ntemplate <class T>\ninline bool read(T &ret) {\n  char c;\n  int sgn;\n  if (c = getchar(), c == EOF) return 0;\n  while (c != '-' && (c < '0' || c > '9')) c = getchar();\n  sgn = (c == '-') ? -1 : 1;\n  ret = (c == '-') ? 0 : (c - '0');\n  while (c = getchar(), c >= '0' && c <= '9') ret = ret * 10 + (c - '0');\n  ret *= sgn;\n  return 1;\n}\npair<int, int> p[MAXN];\nint main() {\n  int n, k, m, cnt = 0;\n  cin >> n >> k >> m;\n  int nn = n;\n  for (int i = 1; i <= nn; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    if (cnt == 0 || x != p[cnt].first)\n      p[++cnt] = make_pair(x, 1);\n    else {\n      p[cnt].second++;\n      if (p[cnt].second == k) {\n        cnt--;\n        n -= k;\n      }\n    }\n  }\n  int l = 1, r = cnt, d = 0;\n  while (l < r) {\n    if (p[l].first == p[r].first) {\n      int tmp = p[l].second + p[r].second;\n      if (tmp / k * k == tmp) {\n        d += tmp;\n        l++;\n        r--;\n      } else {\n        d += tmp / k * k;\n        break;\n      }\n    } else\n      break;\n  }\n  long long ans;\n  if (l == r) {\n    ans = (long long)p[l].second * m % k;\n    if (ans) ans += d;\n  } else\n    ans = (long long)(n - d) * m + d;\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ans;\nlong long i, j, temp;\nlong long n, k, m, len;\nlong long a[100010], b[100010];\nlong long mid[100010];\nint main() {\n  while (cin >> n >> k >> m) {\n    memset(a, 0, sizeof(a));\n    memset(b, 0, sizeof(a));\n    memset(mid, 0, sizeof(a));\n    len = 0;\n    bool all = true;\n    long long e;\n    for (i = 0; i < n; i++) {\n      cin >> a[i];\n      if (all) {\n        if (i == 0)\n          e = a[i];\n        else {\n          if (e != a[i]) all = false;\n        }\n      }\n    }\n    if (all) {\n      cout << (long long)(n * m % k) << endl;\n      continue;\n    }\n    if (k <= n) {\n      stack<long long> s, num;\n      long long number = 1, cha = a[0];\n      for (i = 1; i < n; i++) {\n        if (a[i] == cha)\n          number++;\n        else {\n          number %= k;\n          if (number != 0) {\n            num.push(number);\n            s.push(cha);\n            number = 1;\n            cha = a[i];\n          } else {\n            if (s.empty() || s.top() != a[i]) {\n              cha = a[i];\n              number = 1;\n            } else {\n              cha = s.top();\n              s.pop();\n              number = num.top();\n              num.pop();\n              number++;\n            }\n          }\n        }\n      }\n      number %= k;\n      num.push(number);\n      s.push(cha);\n      while (!s.empty()) {\n        cha = s.top();\n        s.pop();\n        number = num.top();\n        num.pop();\n        for (i = 0; i < number; i++) {\n          b[len++] = cha;\n        }\n      }\n    } else {\n      len = n;\n      for (i = 0; i < n; i++) b[i] = a[i];\n    }\n    long long l = 0, r = len - 1;\n    long long ln = -1, rn = len;\n    if (len > 0) {\n      while (b[l] == b[r] && l < r) {\n        temp = b[r];\n        for (i = 2; i < k; i++) {\n          if (l + 1 >= r) break;\n          if (b[r - 1] == temp) {\n            r--;\n            continue;\n          } else if (b[l + 1] == temp) {\n            l++;\n            continue;\n          } else\n            break;\n        }\n        if (i == k) {\n          ln = l;\n          rn = r;\n          l++;\n          r--;\n        } else\n          break;\n      }\n      long long len1 = 0;\n      for (i = ln + 1; i < rn; i++) {\n        mid[len1++] = b[i];\n      }\n      for (i = 0; i < len1 - 1; i++)\n        if (mid[i + 1] != mid[i]) break;\n      if (i == len1 - 1) {\n        long long aa = (long long)(len1 * m % k);\n        if (aa == 0) {\n          ans = 0;\n        } else\n          ans = (long long)((ln + 1) + aa + (len - rn));\n      } else\n        ans = (long long)((ln + 1) + len1 * m + (len - rn));\n    } else {\n      ans = (long long)(len * m);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nlong long n, m, k, a[maxn], l, r, s, re;\ndeque<pair<int, int> > st, v, u;\nbool f;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  int g = 1;\n  a[n] = -1;\n  for (int i = 1; i < n + 1; ++i) {\n    if (a[i] != a[i - 1]) {\n      if (st.size() && st.back().first == a[i - 1]) {\n        if ((g + st.back().second) % k == 0) {\n          st.pop_back();\n        } else\n          st.back().second = (g + st.back().second) % k;\n      } else {\n        if (g % k) st.push_back({a[i - 1], g % k});\n      }\n      g = 1;\n    } else\n      g++;\n  }\n  while (st.size() > 1 && st[0].first == st.back().first &&\n         (st[0].second + st.back().second) % k == 0) {\n    re += st[0].second + st.back().second;\n    v.push_back(st.front());\n    u.push_front(st.back());\n    st.pop_front();\n    st.pop_back();\n  }\n  if (st.size() > 1 && st[0].first == st.back().first) {\n    re += st[0].second + st.back().second +\n          (m - 1) * ((st[0].second + st.back().second) % k);\n    re -= (st[0].second + st.back().second) * m;\n  }\n  if (st.size() == 1) {\n    int x = st.front().second;\n    if ((x * m) % k == 0) {\n      st.pop_back();\n    } else\n      re += (x * m) % k;\n  }\n  if (!st.size()) {\n    cout << 0;\n    return 0;\n  }\n  int h = st.size();\n  while (st.size() && h > 1) {\n    re += st.front().second * m;\n    st.pop_front();\n  }\n  cout << re;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconstexpr int N = 100005;\nint xs[N], cs[N];\nll work() {\n  int n, k, m;\n  cin >> n >> k >> m;\n  int x, s = 0;\n  for (auto _ = (0); _ < (n); _++) {\n    cin >> x;\n    if (s == 0 || x != xs[s - 1]) {\n      xs[s] = x;\n      cs[s] = 1;\n      s++;\n    } else {\n      cs[s - 1]++;\n      if (cs[s - 1] == k) s--;\n    }\n  }\n  int total = accumulate(cs, cs + s, 0);\n  if (m == 1) return total;\n  int t = 0, removed = 0;\n  while (t < s && xs[t] == xs[s - t - 1]) {\n    int match = cs[t] + cs[s - t - 1];\n    if (match >= k) removed += k;\n    if (match != k) break;\n    t++;\n  }\n  if (t == s) return (m % 2) * total;\n  if (s % 2 && s / 2 == t) {\n    ll middle = ((ll)m * cs[t]) % k;\n    return middle ? total - cs[t] + middle : 0;\n  }\n  return (ll)m * total - (ll)(m - 1) * removed;\n}\nint main() {\n  cout << work() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//  package mainpackage;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String... args) throws Exception {\n\t\t\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\tprivate static PrintWriter out;\n\t\n\tprivate BufferedReader reader;\n\tprivate StringTokenizer st;\n\t\n\tprivate int n, m, k;\n\tprivate int[] id, cnt;\n\tprivate int size;\n\t\n\tprivate void solve() throws Exception {\n\t\t\n\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tst = new StringTokenizer(reader.readLine());\n\t\tn = Integer.parseInt(st.nextToken());\n\t\tk = Integer.parseInt(st.nextToken());\n\t\tm = Integer.parseInt(st.nextToken());\n\t\t\n\t\t\n\t\tid = new int[n];\n\t\tcnt = new int[n];\n\t\tsize = 0;\n\t\t\n\t\tst = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint curId = Integer.parseInt(st.nextToken());\n\t\t\t\n\t\t\tif (size == 0) {\n\t\t\t\tid[size] = curId;\n\t\t\t\tcnt[size++] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (id[size - 1] == curId) {\n\t\t\t\tcnt[size - 1]++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tcnt[size - 1] %= k;\n\t\t\tif (cnt[size - 1] == 0) {\n\t\t\t\t\n\t\t\t\tsize--;\n\t\t\t\t\n\t\t\t\tif (size == 0 || id[size - 1] != curId) {\n\t\t\t\t\tid[size] = curId;\n\t\t\t\t\tcnt[size++] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcnt[size - 1]++;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tid[size] = curId;\n\t\t\t\tcnt[size++] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt[size - 1] %= k;\n\t\tif (cnt[size - 1] == 0) {\n\t\t\tsize--;\n\t\t}\n\t\t\n\t\treader.close();\n\t\t\n\t\t\n\t\tlong sum = 0L;\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tsum += (long)cnt[i];\n\t\t}\n\n\t\tif (m == 1) {\n\t\t\tout.println(sum);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tsum *= (long)m;\n\t\t\n\t\t\n\t\tint p1 = 0, p2 = size - 1;\n\t\twhile(p2 > p1 && id[p1] == id[p2]) {\n\t\t\t\n\t\t\tif ((cnt[p1] + cnt[p2]) % k == 0) {\n\t\t\t\tsum -= (long)(cnt[p1] + cnt[p2]) * (m - 1);\n\t\t\t\tp1++;\n\t\t\t\tp2--;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tlong tmp = (cnt[p1] + cnt[p2]) - (cnt[p1] + cnt[p2])%k;\n\t\t\t\tsum -= tmp * (m - 1);\n\t\t\t\tp2--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (p1 == p2) {\n\t\t\t\n\t\t\twhile(p1 >= 0 && id[p1] == id[p2]) {\n\t\t\t\tlong tmp = (p1 == p2) ? (long)cnt[p1] * m : (long)cnt[p1] + cnt[p2];\n\t\t\t\tif ((tmp % k) > 0) {\n\t\t\t\t\tsum -= (tmp - tmp%k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsum -= tmp;\n\t\t\t\tp1--;\n\t\t\t\tp2++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(sum);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7, LINF = 1e18 + 1e16;\nconst int INF = 1e9 + 1;\nconst double EPS = 1e-10;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\nconst int N = 1e5 + 1;\nclass TaskB {\n  int n, k, m, a[N];\n  deque<pair<int, int> > q;\n  long long ans;\n\n public:\n  void solve(istream& cin, ostream& cout) {\n    cin >> n >> k >> m;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      if (!q.empty() && q.front().first == a[i])\n        ++q.front().second;\n      else\n        q.emplace_front(a[i], 1);\n      if (!q.empty() && q.front().second == k) q.pop_front();\n    }\n    long long sum = 0;\n    for (auto p : q) sum += p.second;\n    ans = 1ll * m * sum;\n    if (m == 1) {\n      cout << ans << endl;\n      return;\n    }\n    int residue = 0;\n    while (q.size() >= 2 && q.front().first == q.back().first &&\n           q.front().second + q.back().second >= k) {\n      ans -= 1ll * (m - 1) * k;\n      if (q.front().second + q.back().second > k) break;\n      q.pop_front();\n      q.pop_back();\n      residue += k;\n    }\n    if (q.size() == 1) {\n      ans = 1ll * q.front().second * m % k;\n      if (ans) ans += residue;\n    }\n    cout << ans << endl;\n  }\n};\nclass Solver {\n public:\n  void solve(std::istream& in, std::ostream& out) {\n    TaskB* obj = new TaskB();\n    obj->solve(in, out);\n    delete obj;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  Solver solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing Pair = std::pair<int, int>;\nlong long GetSize(const std::deque<Pair> &a) {\n  return std::accumulate(a.begin(), a.end(), 0, [](long long s, const Pair &x) {\n    return s + x.second;\n  });\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  std::cout.tie(nullptr);\n  int n, k;\n  long long m;\n  std::cin >> n >> k >> m;\n  std::deque<Pair> a;\n  while (n--) {\n    int x;\n    std::cin >> x;\n    if (a.empty() or a.back().first != x)\n      a.push_back({x, 1});\n    else {\n      if (++(a.back().second) == k) a.pop_back();\n    }\n  }\n  long long Y = GetSize(a);\n  ;\n  while (a.size() > 1 and a.front().first == a.back().first) {\n    if ((a.front().second = (a.front().second + a.back().second) % k) == 0)\n      a.pop_front();\n    a.pop_back();\n  }\n  long long X = GetSize(a);\n  ;\n  if (a.empty()) {\n    std::cout << 0;\n  } else if (a.size() > 1) {\n    ;\n    std::cout << (m - 1) * X + Y;\n  } else {\n    auto e = (a.front().second * m) % k;\n    ;\n    if (e) {\n      std::cout << e + Y - X;\n    } else {\n      std::cout << 0;\n    }\n  }\n  std::cout << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid resize(int n, vector<T> &u) {\n  u.resize(n);\n}\ntemplate <typename Head, typename... Tail>\nvoid resize(int n, Head &H, Tail &...T) {\n  resize(n, H);\n  resize(n, T...);\n}\ntemplate <typename T>\nvoid debug_out(T t) {\n  cerr << t;\n}\ntemplate <typename A, typename B>\nvoid debug_out(pair<A, B> &u) {\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\n}\ntemplate <typename T>\nvoid debug_out(vector<T> &t) {\n  int sz = t.size();\n  for (int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if (i != sz - 1) cerr << \", \";\n  }\n}\ntemplate <typename T>\nvoid debug_out(vector<vector<T>> &t) {\n  int sz = t.size();\n  for (int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if (i != sz - 1) cerr << endl;\n  }\n}\nvector<char> lowchar = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\n                        'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n                        's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};\nvector<char> hichar = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',\n                       'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',\n                       'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};\nvector<char> base_10 = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\ntemplate <typename T>\nstring to_string(T t) {\n  ostringstream ss;\n  ss << t;\n  return ss.str();\n}\nlong long to_num(string t) {\n  long long res = 0;\n  for (int i = 0; i < (int)t.length(); i++) {\n    res *= 10;\n    res += t[i] - '0';\n  }\n  return res;\n}\nint n, k, m;\nlong long res;\ndeque<pair<int, int>> a;\nvector<pair<int, int>> cur;\nvoid deplete(vector<pair<int, int>> &s) {\n  vector<pair<int, int>> repel;\n  for (int i = 0; i < (int)s.size(); i++) {\n    if (repel.empty() || repel.back().first != s[i].first)\n      repel.push_back(s[i]);\n    else\n      repel.back().second += s[i].second;\n    repel.back().second %= k;\n    if (repel.back().second == 0) repel.pop_back();\n  }\n  s = repel;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) {\n    int c;\n    cin >> c;\n    if (cur.empty() || cur.back().first != c)\n      cur.emplace_back(c, 1);\n    else\n      cur.back().second++;\n  }\n  deplete(cur);\n  int l = 0, r = cur.size() - 1;\n  while (cur[l].first == cur[r].first && cur[r].second + cur[l].second == k &&\n         r > l) {\n    res += k;\n    l++;\n    r--;\n  }\n  if (r > l) {\n    int aux = 0;\n    for (int i = l; i <= r; i++) aux += cur[i].second;\n    if (cur[l].first == cur[r].first && cur[l].second + cur[r].second > k) {\n      res += cur[l].second + cur[r].second;\n      long long sp = cur[l].second + cur[r].second - k;\n      aux -= cur[l].second + cur[r].second;\n      cout << 1LL * m * aux + res + (m - 1) * sp;\n      return 0;\n    }\n    cout << 1LL * m * aux + res;\n  } else {\n    long long aux = cur[l].second;\n    aux = (aux * m) % k;\n    if (aux == 0) {\n      cout << 0;\n    } else {\n      cout << aux + res;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  for (; c < 48 || c > 57; c = getchar())\n    if (c == '-') f = -1;\n  for (; c > 47 && c < 58; c = getchar()) x = (x << 1) + (x << 3) + c - 48;\n  return x;\n}\nint n, m, k, a[200050];\nint st[200050], cnt[200050], tot;\nlong long ans;\ninline void init() {\n  n = read();\n  k = read();\n  m = read();\n  for (int i = 1; i <= n; ++i) a[i] = read();\n}\ninline void solve() {\n  for (int i = 1; i <= n; ++i)\n    if (tot && st[tot] == a[i]) {\n      if (++cnt[tot] == k) --tot;\n    } else {\n      st[++tot] = a[i];\n      cnt[tot] = 1;\n    }\n  for (int i = 1; i <= tot; ++i) ans += cnt[i];\n  if (m == 1) return;\n  int i = 0;\n  long long dec = 0;\n  for (; i < tot; ++i) {\n    if (st[i + 1] != st[tot - i]) break;\n    int t = cnt[i + 1] + cnt[tot - i];\n    if (t >= k) dec += k;\n    if (t != k) break;\n  }\n  if (i == tot) {\n    if (!(m & 1)) ans = 0;\n    return;\n  }\n  if (i >= (tot + 1 >> 1)) {\n    if (!(m & 1)) ans -= dec;\n    return;\n  }\n  ans *= m;\n  ans -= dec * (m - 1);\n  if ((tot & 1) && i == (tot - 1 >> 1)) {\n    int t = tot + 1 >> 1;\n    ans = (long long)cnt[t] * m % k;\n    if (!ans) return;\n    for (int i = 1; i <= tot; ++i)\n      if (i ^ t) ans += cnt[i];\n    return;\n  }\n}\nint main() {\n  init();\n  solve();\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 6;\nconst long long MOD2 = 998244353;\nconst long long MOD = 1e9 + 7;\nint a[N];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  long long k, n, m;\n  cin >> n >> k >> m;\n  for (int i = 0; i < (n); ++i) {\n    cin >> a[i];\n  }\n  vector<pair<int, int> > v;\n  long long ans = 0;\n  for (int i = 0; i < (n); ++i) {\n    if (!v.empty() && v.back().first == a[i]) {\n      v.back().second++;\n    } else\n      v.push_back({a[i], 1});\n    if (v.back().second == k) {\n      v.pop_back();\n      ans -= m * k;\n    }\n  }\n  int i = 0, j = v.size() - 1;\n  long long pat = 0;\n  bool fl = false;\n  while (j > i) {\n    if (v[i].first == v[j].first && v[i].second + v[j].second == k) {\n      i++;\n      j--;\n      pat += k;\n      continue;\n    }\n    if (v[i].first == v[j].first && v[i].second + v[j].second > k) {\n      pat += k;\n    }\n    fl = true;\n    break;\n  }\n  if (fl) {\n    cout << ans + n * m - (m - 1) * pat << endl;\n    return 0;\n  }\n  if (i == j) {\n    if (((long long)v[i].second * m) % k == 0)\n      cout << 0 << endl;\n    else {\n      cout << ans + n * m - (m - 1) * pat - (long long)v[i].second * m +\n                  (long long)v[i].second * m % k\n           << endl;\n    }\n    return 0;\n  }\n  if (m % 2) {\n    cout << pat << endl;\n  } else\n    cout << 0 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long arr[100010];\nlong long count[100010];\nlong long n, k, m;\nlong long get_ans(long long st, long long ed, long long rep) {\n  if (ed - st + 1 == 0) return 0;\n  if (st == ed) return rep % k;\n  if (ed - st + 1 <= k) {\n    int i;\n    for (i = st; i < ed; ++i)\n      if (arr[i] != arr[i + 1]) break;\n    if (i < ed)\n      return rep * (ed - st + 1);\n    else\n      return (rep * (ed - st + 1)) % k;\n  }\n  if (arr[st] != arr[ed]) return rep * (ed - st + 1);\n  long long cnt = 2, ss = st, ee = ed;\n  while (st <= ed && cnt < k) {\n    if (arr[st + 1] == arr[ed]) {\n      ++st;\n      ++cnt;\n      continue;\n    } else if (arr[st] == arr[ed - 1]) {\n      --ed;\n      ++cnt;\n      continue;\n    } else\n      break;\n  }\n  if (cnt < k) return rep * (ee - ss + 1);\n  long long X = get_ans(st + 1, ed - 1, rep);\n  if (X == 0)\n    return 0;\n  else\n    return X + k;\n}\nint main() {\n  long long i, cnt;\n  scanf(\"%lld%lld%lld\", &n, &k, &m);\n  for (i = 1; i <= n; ++i) {\n    scanf(\"%lld\", &arr[i]);\n    if (i == 1) {\n      count[i] = 1;\n      continue;\n    }\n    if (arr[i] == arr[i - 1]) {\n      count[i] = count[i - 1] + 1;\n      if (count[i] == k) {\n        i -= k;\n        n -= k;\n        continue;\n      }\n    } else\n      count[i] = 1;\n  }\n  printf(\"%lld\", get_ans(1, n, m));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k, m;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  deque<pair<int, int> > q;\n  int s = n;\n  for (int i = 0; i < (int)(n); ++i) {\n    int t;\n    scanf(\"%d\", &t);\n    if (!q.empty() && q.front().first == t)\n      ++q.front().second;\n    else\n      q.push_front(make_pair(t, 1));\n    if (q.front().second == k) q.pop_front(), s -= k;\n  }\n  long long an = (long long)m * s;\n  int pr = 0;\n  if (m == 1) {\n    printf(\"%lld\\n\", an);\n    return 0;\n  }\n  while ((int)q.size() > 1) {\n    if (q.back().first == q.front().first) {\n      int t = q.back().second + q.front().second;\n      if (t == k)\n        q.pop_front(), q.pop_back(), an -= (long long)(m - 1) * k, pr += k;\n      else if (t > k) {\n        an -= (long long)(m - 1) * k;\n        break;\n      } else\n        break;\n    } else\n      break;\n  }\n  if ((int)q.size() == 1) {\n    long long s = (long long)q.front().second * m;\n    an = s % k;\n    if (an) an += pr;\n  }\n  printf(\"%lld\\n\", an);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint a[N], b[N], c[N];\nint main() {\n  int n, k, m;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  int top = -1;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    if (top != -1) {\n      if (b[top] == a[i]) {\n        if (c[top] + 1 == k)\n          top--;\n        else\n          c[top]++;\n      } else {\n        b[++top] = a[i];\n        c[top] = 1;\n      }\n    } else {\n      b[++top] = a[i];\n      c[top] = 1;\n    }\n  }\n  int sum = 0;\n  for (int i = 0; i <= top; i++) sum += c[i];\n  int cnt2 = 0, x;\n  for (x = 0; x < top - x; x++) {\n    if (b[x] == b[top - x]) {\n      if ((c[x] + c[top - x]) == k)\n        cnt2 += k;\n      else if (c[x] + c[top - x] > k) {\n        cnt2 += k;\n        break;\n      } else\n        break;\n    } else\n      break;\n  }\n  if (x + x == top) {\n    long long ans = 1ll * c[x] * m % k;\n    if (ans) ans += sum - c[x];\n    printf(\"%I64d\\n\", ans);\n  } else\n    printf(\"%I64d\\n\", 1ll * sum * m - 1ll * cnt2 * (m - 1));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nlong long a[maxn];\npair<long long, long long> st[maxn];\nlong long top, n, m, k, l, r, rec, rec2;\nlong long ans;\nint main() {\n  cin >> n >> k >> m;\n  for (long long i = 1; i <= n; i++) cin >> a[i];\n  for (long long i = 1; i <= n; i++) {\n    if (!top || st[top].first != a[i])\n      st[++top] = make_pair(a[i], 1);\n    else\n      st[top].second = (st[top].second + 1) % k;\n    if (st[top].second == 0) top--;\n  }\n  for (long long i = 1; i <= top; i++) {\n    rec += st[i].second;\n  }\n  l = 1, r = top;\n  while (l < r && st[l].first == st[r].first &&\n         (st[l].second + st[r].second) % k == 0) {\n    rec2 += st[l].second + st[r].second;\n    l++;\n    r--;\n  }\n  if (l == r) {\n    if (st[l].second * m % k == 0)\n      ans += m * rec - rec2 * (m) - (st[l].second * m / k * k);\n    else\n      ans += m * rec - rec2 * (m - 1) - (st[l].second * m / k * k);\n  } else {\n    if (st[l].first == st[r].first)\n      rec2 += (st[l].second + st[r].second) / k * k;\n    ans = m * rec - rec2 * (m - 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 100000;\npair<int, int> as[MAX_N], bs[MAX_N], cs[MAX_N];\nvoid printps(pair<int, int> ps[], int i0, int j0) {\n  for (int i = i0; i < j0; i++) printf(\"%d*%d \", ps[i].first, ps[i].second);\n  putchar('\\n');\n}\nint main() {\n  int n, k, m;\n  scanf(\"%d%d%d\", &n, &k, &m);\n  long long c = 0, s = (long long)n * m;\n  int l = 0;\n  for (int i = 0; i < n; i++) {\n    int ai;\n    scanf(\"%d\", &ai);\n    if (l > 0 && as[l - 1].first == ai) {\n      if (++as[l - 1].second == k) c += (long long)m * k, l--;\n    } else\n      as[l++] = pair<int, int>(ai, 1);\n  }\n  if (l == 0 || m == 1) {\n    printf(\"%lld\\n\", s - c);\n    return 0;\n  }\n  copy(as, as + l, bs);\n  copy(as, as + l, cs);\n  int i0 = 0, j0 = l;\n  if (m > 2) {\n    while (i0 + 1 < j0 && as[i0].first == as[j0 - 1].first) {\n      long long c0 = as[i0].second + as[j0 - 1].second;\n      c += (long long)(m - 1) * (c0 / k * k);\n      int r = c0 % k;\n      as[j0 - 1].second = bs[j0 - 1].second = 0;\n      j0--;\n      as[i0].second = cs[i0].second = r;\n      if (r == 0)\n        i0++;\n      else\n        break;\n    }\n    if (i0 + 1 == j0) {\n      long long c0 = (long long)(m - 2) * as[i0].second;\n      c += c0 / k * k;\n      int r = c0 % k;\n      as[i0].second = 0;\n      cs[i0].second += r;\n    }\n  }\n  while (j0 > 0 && i0 < l && bs[j0 - 1].first == cs[i0].first) {\n    long long c0 = (long long)bs[j0 - 1].second + cs[i0].second;\n    c += c0 / k * k;\n    int r = c0 % k;\n    i0++, j0--;\n    if (r > 0) break;\n  }\n  printf(\"%lld\\n\", (long long)n * m - c);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k, m;\n  cin >> n >> k >> m;\n  vector<int> a, f;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    if (!a.empty() && a.back() == x) {\n      f.back() += 1;\n      if (f.back() == k) {\n        a.pop_back();\n        f.pop_back();\n      }\n    } else {\n      a.push_back(x);\n      f.push_back(1);\n    }\n  }\n  int len = 0, sz = a.size();\n  for (int x : f) len += x;\n  if (m == 1) {\n    cout << len << endl;\n    return 0;\n  }\n  int i = 0;\n  while (i < sz && a[i] == a[sz - 1 - i] && f[i] + f[sz - 1 - i] == k) i++;\n  int mid = 0;\n  for (int j = 0; j < sz; j++)\n    if (i <= j && j <= sz - 1 - i) mid += f[j];\n  long long int ans = 0;\n  if (i == sz) {\n    if (m % 2 == 1) ans = len;\n  } else if (i == sz / 2) {\n    if (sz % 2 == 0) {\n      if (m % 2 == 1) ans = len;\n    } else {\n      assert(mid == f[sz / 2]);\n      long long int x = (1ll * mid * m) % k;\n      if (x == 0)\n        ans = 0;\n      else\n        ans = x + len - mid;\n    }\n  } else {\n    long long int dx = 0;\n    if (a[i] == a[sz - 1 - i])\n      dx = -(f[i] + f[sz - 1 - i]) + (f[i] + f[sz - 1 - i]) % k;\n    ans = len - mid + 1ll * mid * m + dx * (m - 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e5 + 10;\nconst int inf = 1e18 + 5;\nconst int mod = 1e9 + 7;\nint n, k, m;\nvoid reverse(stack<pair<int, long long> >& st) {\n  stack<pair<int, long long> > stt;\n  while (!st.empty()) {\n    stt.push(st.top());\n    st.pop();\n  }\n  st = stt;\n}\nvoid go(stack<pair<int, long long> >& a, stack<pair<int, long long> > b) {\n  reverse(b);\n  while (!b.empty()) {\n    auto cur = b.top();\n    b.pop();\n    if (a.empty()) {\n      a.push(cur);\n    } else {\n      a.push(cur);\n      while (a.size() >= 2) {\n        auto cur1 = a.top();\n        a.pop();\n        auto cur2 = a.top();\n        a.pop();\n        if (cur1.first != cur2.first) {\n          a.push(cur2);\n          a.push(cur1);\n          break;\n        } else {\n          cur1.second += cur2.second;\n          cur1.second %= k;\n          if (cur1.second) {\n            a.push(cur1);\n          }\n        }\n      }\n    }\n  }\n}\nlong long sz(stack<pair<int, long long> > a) {\n  long long res = 0;\n  while (!a.empty()) {\n    res += a.top().second;\n    a.pop();\n  }\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> k >> m;\n  stack<pair<int, long long> > cur;\n  stack<pair<int, long long> > res;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    stack<pair<int, long long> > tmp;\n    tmp.push({x, 1});\n    go(cur, tmp);\n  }\n  stack<pair<int, long long> > dd = cur;\n  if (k > 1e5 && cur.size() == 1) {\n    cout << (n * 1ll * m) % k << endl;\n  } else if (k > 1e5) {\n    cout << n * 1ll * m << endl;\n  } else {\n    bool flag = 0;\n    int mm = m;\n    while (m) {\n      if (m & 1) {\n        go(res, cur);\n      }\n      go(cur, cur);\n      if (cur.size() > 2 * n) {\n        flag = 1;\n        break;\n      }\n      m /= 2;\n    }\n    if (!flag) {\n      cout << sz(res) << endl;\n    } else {\n      long long fi = sz(dd);\n      go(dd, dd);\n      long long dif = sz(dd) - fi;\n      cout << fi + dif * (mm - 1) << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, i, j, k, x, y, z, m, q, h, r, timer, mx, l;\nint a[100500];\nvector<int> f, g;\nlong long solve() {\n  int lst = 0, cnt = 0;\n  f.clear();\n  g.clear();\n  for (int i = 0; i < n; i++) {\n    if (f.empty()) {\n      f.push_back(a[i]);\n      lst = a[i];\n      cnt = 1;\n    } else {\n      if (a[i] == f.back()) {\n        cnt++;\n        f.push_back(a[i]);\n      } else {\n        cnt = 1;\n        f.push_back(a[i]);\n      }\n      if (cnt == k) {\n        for (int j = 0; j < k; j++) f.pop_back();\n        if (!f.empty()) {\n          int idx = f.size();\n          idx--;\n          lst = f[idx];\n          idx--;\n          cnt = 1;\n          while (idx >= 0 && lst == f[idx]) cnt++, idx--;\n        }\n      }\n    }\n  }\n  int sz = f.size();\n  if (sz == 0) {\n    return 0;\n  }\n  for (int i = 0; i < sz; i++) g.push_back(f[i]);\n  for (int i = 0; i < sz; i++) {\n    if (f.empty()) {\n      f.push_back(g[i]);\n      lst = a[i];\n      cnt = 1;\n    } else {\n      if (g[i] == f.back()) {\n        cnt++;\n        f.push_back(g[i]);\n      } else {\n        cnt = 1;\n        f.push_back(g[i]);\n      }\n      if (cnt == k) {\n        for (int j = 0; j < k; j++) f.pop_back();\n        if (!f.empty()) {\n          int idx = f.size();\n          idx--;\n          lst = f[idx];\n          idx--;\n          cnt = 1;\n          while (idx >= 0 && lst == f[idx]) cnt++, idx--;\n        }\n      }\n    }\n  }\n  int newsz = f.size();\n  if (newsz % 2 != 0) {\n    return (1LL * m * sz - 1LL * (sz * 2 - newsz) * (m - 1));\n  }\n  if (newsz == 0) {\n    if (m % 2 == 0) {\n      return 0;\n    } else {\n      return sz;\n    }\n  }\n  int mag = (2 * sz - newsz) / 2;\n  bool flag = true;\n  for (int i = mag; i < sz - mag - 1; i++)\n    if (g[i] != g[i + 1]) flag = false;\n  if (!flag) {\n    return (1LL * sz * m - 2LL * mag * (m - 1));\n  }\n  long long val = 1LL * m * (sz - 2 * mag);\n  long long ans = 1LL * sz * m - 2LL * mag * (m - 1);\n  if (val % k != 0) {\n    ans -= (val - val % k);\n    return ans;\n  } else {\n    return 0;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  bool flag = true;\n  for (int i = 0; i + 1 < n; i++)\n    if (a[i] != a[i + 1]) flag = false;\n  if (flag) {\n    cout << 1LL * n * m % k << endl;\n    return 0;\n  }\n  cout << solve() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1.0);\nconst double eps = 1e-10;\nconst int MOD = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1e5 + 5;\nint a[MAXN];\nvector<pair<int, int> > v;\nint main() {\n  int n, k, m;\n  scanf(\"%d %d %d\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    if (!v.empty() && a[i] == v.back().first)\n      v.back().second++;\n    else\n      v.push_back(make_pair(a[i], 1));\n    if (v.back().second == k) v.pop_back();\n  }\n  int st = 0, en = (int)v.size() - 1;\n  long long s = 0;\n  for (int i = 0; i < v.size(); i++) s += v[i].second;\n  s *= m;\n  if (s == 0) return 0 * printf(\"0\\n\");\n  while (st < en) {\n    if (v[st].first != v[en].first) return 0 * printf(\"%lld\\n\", s);\n    if (v[st].second + v[en].second == k) {\n      s -= (long long)(m - 1) * k;\n      st++, en--;\n      continue;\n    }\n    if (v[st].second + v[en].second > k) s -= (long long)(m - 1) * k;\n    return 0 * printf(\"%lld\\n\", s);\n  }\n  if (((long long)m * v[st].second) % k == 0) {\n    puts(\"0\");\n    return 0;\n  }\n  s -= (long long)(1LL * m * v[st].second) / k * k;\n  printf(\"%lld\\n\", s);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 500010;\nint n, k, m;\nint a[N];\nlong long ans;\nstruct Node {\n  vector<int> l, r;\n  long long len;\n} ori;\nint col[N], Count[N], tot;\ninline Node join(const Node &a, const Node &b) {\n  tot = 0;\n  long long len = a.len + b.len;\n  for (int i = 0; i < a.r.size(); i++) {\n    if (i == 0 || a.r[i] != col[tot]) {\n      col[++tot] = a.r[i];\n      Count[tot] = 1;\n    } else\n      Count[tot]++;\n    while (Count[tot] >= k) {\n      Count[tot] -= k;\n      len -= k;\n      if (Count[tot] == 0) tot--;\n    }\n  }\n  for (int i = 0; i < b.l.size(); i++) {\n    if (b.l[i] != col[tot]) {\n      col[++tot] = b.l[i];\n      Count[tot] = 1;\n    } else\n      Count[tot]++;\n    while (Count[tot] >= k) {\n      Count[tot] -= k;\n      len -= k;\n      if (Count[tot] == 0) tot--;\n    }\n  }\n  Node ret;\n  ret.len = len;\n  if (a.len < 2 * n) {\n    int C = 0;\n    int up;\n    if (ret.len < 2 * n)\n      up = ret.len;\n    else\n      up = n;\n    for (int i = 1; i <= tot; i++) {\n      for (int j = 1; j <= Count[i]; j++) {\n        ret.l.push_back(col[i]);\n        C++;\n        if (C == up) break;\n      }\n      if (C == up) break;\n    }\n  } else\n    ret.l = a.l;\n  if (b.len < 2 * n) {\n    int C = 0;\n    int up;\n    if (ret.len < 2 * n)\n      up = ret.len;\n    else\n      up = n;\n    for (int i = tot; i > 0; i--) {\n      for (int j = 1; j <= Count[i]; j++) {\n        ret.r.push_back(col[i]);\n        C++;\n        if (C == up) break;\n      }\n      if (C == up) break;\n    }\n    reverse(ret.r.begin(), ret.r.end());\n  } else\n    ret.r = b.r;\n  return ret;\n}\nNode Pow(int x) {\n  if (x == 1) {\n    return ori;\n  }\n  Node ret = Pow(x >> 1);\n  ret = join(ret, ret);\n  if (x & 1) ret = join(ret, ori);\n  return ret;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n  bool flag = true;\n  for (int i = 2; i <= n; i++)\n    if (a[i] != a[i - 1]) flag = false;\n  if (flag) {\n    printf(\"%I64d\\n\", 1ll * n * m % k);\n    return 0;\n  }\n  vector<int> tmp;\n  tot = 0;\n  int len = n;\n  for (int i = 1; i <= n; i++) {\n    if (i == 1 || a[i] != col[tot]) {\n      col[++tot] = a[i];\n      Count[tot] = 1;\n    } else\n      Count[tot]++;\n    while (Count[tot] >= k) {\n      Count[tot] -= k;\n      len -= k;\n      if (Count[tot] == 0) tot--;\n    }\n  }\n  for (int i = 1; i <= tot; i++)\n    for (int j = 1; j <= Count[i]; j++) tmp.push_back(col[i]);\n  ori.l = ori.r = tmp;\n  ori.len = len;\n  Node t = Pow(m);\n  printf(\"%I64d\\n\", t.len);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nint N, K, M;\npair<long long, deque<pair<int, long long>>> get(\n    const deque<pair<int, long long>> d) {\n  long long result = 0;\n  deque<pair<int, long long>> r;\n  for (auto p : d) {\n    if (r.empty() || r.back().first != p.first) r.push_back({p.first, 0});\n    r.back().second += p.second;\n    result += r.back().second / K;\n    r.back().second %= K;\n    if (!r.back().second) r.pop_back();\n  }\n  return make_pair(result, r);\n}\nint main() {\n  scanf(\"%d%d%d\", &N, &K, &M);\n  deque<pair<int, long long>> A;\n  for (int i = 0; i < (N); ++i) {\n    int a;\n    scanf(\"%d\", &a);\n    A.push_back({a, 1});\n  }\n  auto p = get(A);\n  A = p.second;\n  long long result = p.first * M;\n  if (M == 1) {\n    cout << N * (long long)M - result * (long long)K << endl;\n    return 0;\n  } else if (A.size() == 1) {\n    result += A[0].second * M / K;\n    cout << N * (long long)M - result * (long long)K << endl;\n    return 0;\n  }\n  deque<pair<int, long long>> first, last;\n  while (A.size() >= 2) {\n    if (A.back().first != A.front().first) break;\n    first.push_back(A.front());\n    last.push_front(A.back());\n    result += (A.back().second + A.front().second) / K * (long long)(M - 1);\n    A.back().second += A.front().second;\n    A.back().second %= K;\n    A.pop_front();\n    if (!A.back().second) A.pop_back();\n  }\n  if (A.size() == 1) {\n    first.push_back({A[0].first, A[0].second * M});\n    first.insert(first.end(), last.begin(), last.end());\n    result += get(first).first;\n  }\n  cout << N * (long long)M - result * (long long)K << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m, a[100005];\nvector<pair<long long, long long> > st;\nvoid brute() {\n  int x[100005];\n  for (int i = 1; i <= m; i++)\n    for (int j = 1; j <= n; j++) x[(i - 1) * n + j] = a[j];\n  int sz = m * n;\n  while (1) {\n    if (!sz) break;\n    bool good = true;\n    for (int i = 1; i <= sz; i++) {\n      good = true;\n      for (int j = i; j <= i + k - 1; j++) {\n        if (x[i] != x[j] || j > sz) {\n          good = false;\n          break;\n        }\n      }\n      if (good) {\n        for (int j = i; j <= sz; j++) x[j] = x[j + k];\n        sz -= k;\n        break;\n      }\n    }\n    if (!good) break;\n  }\n  cout << \"brute \" << sz << endl;\n}\nint main() {\n  cin >> n >> k >> m;\n  long long ans = m * n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    if (st.empty())\n      st.push_back({a[i], 1});\n    else {\n      if (st[st.size() - 1].first == a[i])\n        st[st.size() - 1].second++;\n      else\n        st.push_back({a[i], 1});\n    }\n    if (st[st.size() - 1].second == k) {\n      st.pop_back();\n      ans -= k * m;\n    }\n  }\n  if (st.empty()) {\n    cout << ans << endl;\n    return 0;\n  }\n  long long idx = -1;\n  for (int i = 0; i < st.size(); i++) {\n    int x = i, y = st.size() - 1 - i;\n    if (st[x].first != st[y].first || st[x].second + st[y].second != k) {\n      idx = i;\n      break;\n    }\n  }\n  if (idx == -1) {\n    if (m % 2) {\n      long long sum = 0;\n      for (int i = 0; i < st.size(); i++) sum += st[i].second;\n      cout << sum << endl;\n    } else\n      puts(\"0\");\n    return 0;\n  }\n  ans -= (m - 1) * k * idx;\n  vector<pair<int, int> > v;\n  for (int i = idx; i < st.size() - idx; i++) {\n    v.push_back(st[i]);\n  }\n  if (v.size() == 1) {\n    ans -= (long long)v[0].second * m / k * k;\n    for (int i = idx - 1; i >= 0; i--) {\n      if ((long long)v[0].second * m % k != 0) break;\n      if (st[i].first != st[st.size() - 1 - i].first ||\n          st[i].second + st[st.size() - 1 - i].second != k)\n        break;\n      ans -= k;\n    }\n    cout << ans << endl;\n    return 0;\n  }\n  int last_idx = v.size() - 1;\n  if (v[0].first != v[last_idx].first || v[0].second + v[last_idx].second < k) {\n    cout << ans << endl;\n    return 0;\n  }\n  long long red = v[0].second + v[last_idx].second;\n  red = (red / k) * k;\n  ans -= red * (m - 1);\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct ii {\n  long long a, b;\n  bool operator<(ii o) const { return make_tuple(a, b) < make_tuple(o.a, o.b); }\n};\nstruct iii {\n  int a, b, c;\n  bool operator<(iii o) const {\n    return make_tuple(a, b, c) < make_tuple(o.a, o.b, o.c);\n  }\n};\nlong long TC, N, M, K, Q, x, y, z;\ndeque<ii> dq;\nint main() {\n  scanf(\"%lld%lld%lld\", &N, &K, &M);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%lld\", &x);\n    if (!dq.empty() && dq.back().a == x)\n      dq.back().b++;\n    else\n      dq.push_back({x, 1});\n    if (dq.back().b == K) dq.pop_back();\n  }\n  int ptr1 = 0, ptr2 = (int)(dq).size() - 1;\n  while (ptr1 < ptr2 && dq[ptr1].a == dq[ptr2].a &&\n         dq[ptr1].b + dq[ptr2].b == K)\n    ptr1++, ptr2--;\n  if (ptr1 < ptr2) {\n    long long ans = 0;\n    for (int i = 0; i <= ptr2; i++) ans += dq[i].b;\n    for (int i = ptr1; i <= ptr2; i++) ans += dq[i].b * (M - 2);\n    for (int i = ptr1; i < (int)(dq).size(); i++) ans += dq[i].b;\n    if (dq[ptr1].a == dq[ptr2].a && dq[ptr1].b + dq[ptr2].b > K)\n      ans -= K * (M - 1);\n    printf(\"%lld\\n\", ans);\n  } else {\n    int batas = -1;\n    if (ptr1 == ptr2) {\n      batas = dq[ptr1].b * M % K;\n      if (batas == 0) ptr1++, ptr2--;\n    } else\n      batas = 0;\n    if (batas == 0) {\n      deque<ii> tmp;\n      for (int i = 0; i <= ptr2; i++) tmp.push_back(dq[i]);\n      for (int i = ptr1; i < (int)(dq).size(); i++) {\n        if (!tmp.empty() && tmp.back().a == dq[i].a)\n          tmp.back().b += dq[i].b;\n        else\n          tmp.push_back(dq[i]);\n        if (tmp.back().b >= K) tmp.back().b -= K;\n        if (tmp.back().b == 0) tmp.pop_back();\n      }\n      long long ans = 0;\n      for (auto i : tmp) ans += i.b;\n      printf(\"%lld\\n\", ans);\n    } else {\n      long long ans = dq[ptr1].b * M % K;\n      for (int i = 0; i < ptr2; i++) ans += dq[i].b;\n      for (int i = ptr1 + 1; i < (int)(dq).size(); i++) ans += dq[i].b;\n      printf(\"%lld\\n\", ans);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 100000 + 20;\nint a[maxn];\nint cont[maxn];\nint S[maxn];\nvoid work() {\n  long long n, k, m;\n  cin >> n >> k >> m;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  int top = 0;\n  for (int i = 0; i < n; ++i) {\n    S[++top] = a[i];\n    if (top > 1 && S[top] == S[top - 1]) {\n      cont[top] = cont[top - 1] + 1;\n    } else {\n      cont[top] = 1;\n    }\n    if (cont[top] >= k) {\n      top -= k;\n    }\n  }\n  int L = 1, R = top;\n  long long side = 0, mid = (R - L + 1);\n  while (S[L] == S[R] && L < R) {\n    int now = 0;\n    int l = L, r = R;\n    while (l < r && S[l] == S[L] && now < k) {\n      ++l;\n      ++now;\n    }\n    while (l < r && S[r] == S[R] && now < k) {\n      --r;\n      ++now;\n    }\n    if (now != k) {\n      break;\n    }\n    side += k;\n    L = l;\n    R = r;\n  }\n  mid = (R - L + 1);\n  int flag = 1;\n  for (int i = L + 1; i <= R; ++i) {\n    if (S[i - 1] != S[i]) {\n      flag = 0;\n      break;\n    }\n  }\n  if (flag) {\n    if (1LL * mid * m % k == 0) {\n      cout << 0 << endl;\n    } else {\n      cout << (1LL * mid * m % k + 1LL * side) << endl;\n    }\n  } else {\n    cout << 1LL * mid * m + 1LL * side << endl;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  work();\n}\n"
        },
        {
            "language": 3,
            "solution": "def process(A, m, k):\n    n = len(A)\n    start = n*m\n    d = []\n    for i in range(n):\n        if len(d)==0 or d[-1][0] != A[i]:\n            d.append([A[i], 1])\n        else:\n            d[-1][1]+=1\n        if d[-1][1]==k:\n            start-=k*m\n            d.pop()\n    if m==1:\n        return start\n    p1 = 0\n    start_d = []\n    middle_d = []\n    end_d = []\n    for x in d:\n        a, b = x\n        start_d.append([a, b])\n        middle_d.append([a, b])\n        end_d.append([a, b])\n    if m==2:\n        middle_d = []\n    else:\n        middle_d = [x for x in d]\n  #  print(start_d, middle_d, end_d, start)\n    #the sequence is start_d + (m-2)* middle_d + end_d\n    while True:\n        if p1 >= len(middle_d):\n            if len(start_d)==0 or p1==len(end_d):\n                break\n            v1, c1 = start_d[-1]\n            v2, c2 = end_d[p1]\n            if v1==v2 and (c1+c2) >= k:\n                start-=k\n                start_d.pop()\n                if (c1+c2)==k:\n                    p1+=1\n                else:\n                    end_d[1] = (c1+c2) % k\n            else:\n                break\n        else:\n            if len(middle_d)-p1==1:\n                v1, c1 = start_d[-1]\n                v2, c2 = middle_d[p1]\n                v3, c3 = end_d[p1]\n                total_value = c2*(m-2)\n                if v2==v1:\n                    total_value+=c1\n                if v2==v3:\n                    total_value+=c3\n                start-=(total_value-(total_value%k))\n                if total_value % k==0:\n                    middle_d = []\n                    if v2==v1:\n                        start_d.pop()\n                    if v2==v3:\n                        end_d = end_d\n                        p1+=1\n                else:\n                    break\n            else:\n                v1, c1 = start_d[-1]\n                v2, c2 = middle_d[p1]\n                v3, c3 = middle_d[-1]\n                v4, c4 = end_d[p1]\n                if v2==v3 and (c2+c3) >= k:\n                    this_value = (c2+c3-(c2+c3) % k)*(m-1)\n                    start-=this_value\n                    middle_d.pop()\n                    start_d.pop()\n                    middle_d[p1][1] = (c2+c3) % k\n                    end_d[p1][1] = (c2+c3) % k\n                    if middle_d[p1][1]==0:\n                        p1+=1\n                 \n                else:\n                    break\n       # print('start', start_d, start)\n       # print('middle', middle_d)\n       # print('end', end_d)\n    return start\n\nn, k, m = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\nprint(process(A, m, k))\n                "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\nint n, k, m, a[N];\nint gao(const vector<pair<int, int> > &x) {\n  int ret = 0;\n  for (int i = ((int)(x).size()) - 1, j = 0; i >= 0; --i, ++j) {\n    if (x[i].first != x[j].first) break;\n    if (x[i].second + x[j].second != k) break;\n    ++ret;\n  }\n  return ret;\n}\nlong long solve() {\n  vector<pair<int, int> > v;\n  for (int i = (0); i < (n); ++i)\n    if (v.empty() || v.back().first != a[i]) {\n      v.push_back({a[i], 1});\n    } else {\n      ++v.back().second;\n      if (v.back().second == k) v.pop_back();\n    }\n  if (((int)(v).size()) == 0) return 0;\n  long long ret = 0;\n  for (int i = (0); i < (((int)(v).size())); ++i) ret += v[i].second;\n  if (m == 1) return ret;\n  if (((int)(v).size()) == 1) {\n    ret = 1ll * v.back().second * m % k;\n    return ret;\n  }\n  int p = gao(v);\n  if (p < ((int)(v).size()) / 2) {\n    ret = 1ll * ret * m - 1ll * p * k * (m - 1);\n    int q = ((int)(v).size()) - p - 1;\n    if (v[p].first == v[q].first && v[p].second + v[q].second >= k)\n      ret -= 1ll * (m - 1) * k;\n    return ret;\n  } else if (p == ((int)(v).size())) {\n    return (m & 1) * ret;\n  } else {\n    assert(p == (((int)(v).size()) / 2));\n    int rm = 1ll * v[((int)(v).size()) >> 1].second * m % k;\n    if (rm == 0) return 0;\n    ret -= v[((int)(v).size()) >> 1].second;\n    ret += rm;\n    return ret;\n  }\n  return -1;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &m);\n  for (int i = (0); i < (n); ++i) scanf(\"%d\", a + i);\n  cout << solve() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n/**\n * Created by shhuan on 2017/11/5.\n */\npublic class Main_878B {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tlong N = scanner.nextLong();\n\t\tlong K = scanner.nextLong();\n\t\tlong M = scanner.nextLong();\n\t\tscanner.nextLine();\n\n\t\tlong[] A = Arrays.stream(scanner.nextLine().split(\" \")).mapToLong(v -> Long.parseLong(v)).toArray();\n\n\t\tStack<Pair> S = new Stack<>();\n\t\tfor (long v : A) {\n\t\t\tif (S.isEmpty()) {\n\t\t\t\tS.push(new Pair(v, 1));\n\t\t\t} else {\n\t\t\t\tPair l = S.peek();\n\t\t\t\tif (l.x == v) {\n\t\t\t\t\tS.pop();\n\t\t\t\t\tlong y = l.y + 1;\n\t\t\t\t\tif (y != K) {\n\t\t\t\t\t\tS.push(new Pair(l.x, (l.y+1) % K));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tS.push(new Pair(v, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLong ans = 0L;\n\t\tif (S.isEmpty()) {\n\t\t\tans = 0L;\n\t\t} else if (S.size() == 1) {\n\t\t\tans = 1L*M*S.get(0).y % K;\n\t\t} else {\n\t\t\tint l = -1;\n\t\t\tfor (int i = 0; i < S.size()/2+1; i++) {\n\t\t\t\tPair p1 = S.get(i);\n\t\t\t\tPair p2 = S.get(S.size()-i-1);\n\t\t\t\tif (p1.x != p2.x || p1.y+p2.y != K) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tl = i;\n\t\t\t}\n\n\t\t\tint r = S.size()-l-1;\n\t\t\tif (l < 0){\n\t\t\t\tPair p1 = S.get(0);\n\t\t\t\tPair p2 = S.get(S.size()-1);\n\t\t\t\tif (p1.x == p2.x && p1.y+p2.y > K) {\n\t\t\t\t\tans = 0L;\n\t\t\t\t\tfor (int i = 1; i < S.size()-1; i++) {\n\t\t\t\t\t\tans += S.get(i).y;\n\t\t\t\t\t}\n\t\t\t\t\tans *= M;\n\t\t\t\t\tans += (M-1) * ((p1.y+p2.y) % K);\n\t\t\t\t\tans += p1.y + p2.y;\n\t\t\t\t\tif (N == 99999L && K == 1000 && M == 1000000000) {\n\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tans = S.stream().mapToLong(v -> v.y).sum();\n\t\t\t\t\tans *= M;\n\t\t\t\t\tif (N == 99999L && K == 1000 && M == 1000000000) {\n\t\t\t\t\t\tSystem.out.println(2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (r < l+2) {\n\t\t\t\tif (M % 2 == 0) {\n\t\t\t\t\tans = 0L;\n\t\t\t\t} else {\n\t\t\t\t\tans = S.stream().mapToLong(v -> v.y).sum();\n\t\t\t\t}\n\t\t\t} else if (r == l+2) {\n\t\t\t\tans = 0L;\n\t\t\t\tLong mid = (1L* M * S.get(l+1).y) % K;\n\t\t\t\tans += mid;\n\t\t\t\tif (mid == 0L && S.get(l).x == S.get(r).x && S.get(l).y + S.get(r).y >= K) {\n\t\t\t\t\twhile (l >= 0 && S.get(l).x == S.get(r).x && S.get(l).y + S.get(r).y == K) {\n\t\t\t\t\t\tl -= 1;\n\t\t\t\t\t\tr += 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int i = 0; i <= l; i++) {\n\t\t\t\t\t\tans += S.get(i).y;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int i = r; i < S.size(); i++) {\n\t\t\t\t\t\tans += S.get(i).y;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i <= l; i++) {\n\t\t\t\t\t\tans += S.get(i).y;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = r; i < S.size(); i++) {\n\t\t\t\t\t\tans += S.get(i).y;\n\t\t\t\t\t}\n\t\t\t\t\tif (N == 99999L && K == 1000 && M == 1000000000) {\n\t\t\t\t\t\tSystem.out.println(4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tPair p1 = S.get(l+1);\n\t\t\t\tPair p2 = S.get(r-1);\n\t\t\t\tif (p1.x != p2.x || p1.y+p2.y < K) {\n\t\t\t\t\tans = 0L;\n\t\t\t\t\tfor (int i = l+1; i < r; i++) {\n\t\t\t\t\t\tans += S.get(i).y;\n\t\t\t\t\t}\n\t\t\t\t\tans *= M;\n\t\t\t\t\tif (N == 99999L && K == 1000 && M == 1000000000) {\n\t\t\t\t\t\tSystem.out.println(5);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = l+2; i < r-1; i++) {\n\t\t\t\t\t\tans += S.get(i).y;\n\t\t\t\t\t}\n\t\t\t\t\tans *= M;\n\t\t\t\t\tans += (M-1) * ((p1.y + p2.y) % K);\n\t\t\t\t\tans += p1.y + p2.y;\n\t\t\t\t\tif (N == 99999L && K == 1000 && M == 1000000000) {\n\t\t\t\t\t\tSystem.out.println(6);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i <= l; i++) {\n\t\t\t\t\tans += S.get(i).y;\n\t\t\t\t}\n\t\t\t\tfor (int i = r; i < S.size(); i++) {\n\t\t\t\t\tans += S.get(i).y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic class Pair{\n\t\tpublic long x;\n\t\tpublic long y;\n\n\t\tpublic Pair() {\n\t\t\tx = 0;\n\t\t\ty = 0;\n\t\t}\n\n\t\tpublic Pair(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\"+x+\", \"+y+\")\";\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e5 + 5;\nint arr[2 * MAX];\nint fin[2 * MAX];\nint n, K, M;\nvector<pair<long long, long long> > Vu;\nint main() {\n  scanf(\"%d %d %d\", &n, &K, &M);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &fin[i]);\n  }\n  int cur = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!Vu.empty() && (Vu.back()).first == fin[i]) {\n      (Vu.back()).second++;\n      if ((Vu.back().second) == K) {\n        Vu.pop_back();\n      }\n    } else {\n      Vu.push_back(make_pair(fin[i], 1));\n    }\n  }\n  long long s = 0;\n  for (auto it : Vu) s += it.second;\n  if (M == 1 || s == 0) return !printf(\"%lld\\n\", s);\n  s *= M;\n  int st = 0, en = (int)Vu.size() - 1;\n  while (st < en) {\n    if (Vu[st].first != Vu[en].first) return !printf(\"%lld\\n\", s);\n    if (Vu[st].second + Vu[en].second == K) {\n      s -= (long long)(M - 1) * K;\n      st++, en--;\n      continue;\n    }\n    if (Vu[st].second + Vu[en].second > K) s -= (long long)(M - 1) * K;\n    return !printf(\"%lld\\n\", s);\n  }\n  if (st > en) return !printf(\"0\\n\");\n  if (st == en) {\n    long long x = Vu[st].second * M;\n    if (x % K == 0)\n      return !printf(\"0\\n\");\n    else\n      return !printf(\"%lld\\n\", s - (x / K) * K);\n  }\n  return 0;\n}\n"
        }
    ]
}