{
    "name": "73_F. Plane of Tanks",
    "source": "CODEFORCES",
    "description": "Vasya plays the Plane of Tanks. The tanks in this game keep trying to finish each other off. But your \"Pedalny\" is not like that... He just needs to drive in a straight line from point A to point B on the plane. Unfortunately, on the same plane are n enemy tanks. We shall regard all the tanks as points. At the initial moment of time Pedalny is at the point A. Enemy tanks would be happy to destroy it immediately, but initially their turrets are tuned in other directions. Specifically, for each tank we know the initial rotation of the turret ai (the angle in radians relative to the OX axis in the counterclockwise direction) and the maximum speed of rotation of the turret wi (radians per second). If at any point of time a tank turret will be aimed precisely at the tank Pedalny, then the enemy fires and it never misses. Pedalny can endure no more than k shots. Gun reloading takes very much time, so we can assume that every enemy will produce no more than one shot. Your task is to determine what minimum speed of v Pedalny must have to get to the point B. It is believed that Pedalny is able to instantly develop the speed of v, and the first k shots at him do not reduce the speed and do not change the coordinates of the tank.\n\nInput\n\nThe first line contains 4 numbers \u2013 the coordinates of points A and B (in meters), the points do not coincide. On the second line number n is given (1 \u2264 n \u2264 104). It is the number of enemy tanks. Each of the following n lines contain the coordinates of a corresponding tank xi, yi and its parameters ai and wi (0 \u2264 ai \u2264 2\u03c0, 0 \u2264 wi \u2264 100). Numbers ai and wi contain at most 5 digits after the decimal point. All coordinates are integers and their absolute values do not exceed 105. Enemy tanks can rotate a turret in the clockwise as well as in the counterclockwise direction at the angular speed of not more than wi. It is guaranteed that each of the enemy tanks will need at least 0.1 seconds to aim at any point of the segment AB and each of the enemy tanks is posistioned no closer than 0.1 meters to line AB. On the last line is given the number k (0 \u2264 k \u2264 n).\n\nOutput\n\nPrint a single number with absolute or relative error no more than 10 - 4 \u2014 the minimum required speed of Pedalny in meters per second.\n\nExamples\n\nInput\n\n0 0 10 0\n1\n5 -5 4.71238 1\n0\n\n\nOutput\n\n4.2441\n\n\nInput\n\n0 0 10 0\n1\n5 -5 4.71238 1\n1\n\n\nOutput\n\n0.0000",
    "difficulty": "F",
    "tags": [
        "brute force",
        "geometry"
    ],
    "rating": 2900,
    "public_test": [
        {
            "input": "0 0 10 0\n1\n5 -5 4.71238 1\n0\n",
            "output": "4.244116\n"
        },
        {
            "input": "0 0 10 0\n1\n5 -5 4.71238 1\n1\n",
            "output": "0.0000\n"
        }
    ],
    "generated_test": [
        {
            "input": "0 -1 10 10\n1\n10 0 0 1.57079\n0\n",
            "output": "14.866008868353\n"
        },
        {
            "input": "-88 -68 -10 -61\n5\n-64 -55 3.09648 0.28346\n-8 -52 2.46781 0.13262\n-8 -59 3.02445 0.00119\n-43 90 2.37292 0.15686\n-29 -34 2.73957 0.18287\n0\n",
            "output": "7.216641673136\n"
        },
        {
            "input": "-1 0 10 10\n2\n10 0 0 1.57079\n10 5 0 0.7854\n1\n",
            "output": "7.433051729677\n"
        },
        {
            "input": "-100000 -100000 100000 100000\n1\n100000 0 0 16.252597429020454\n0\n",
            "output": "2926495.729056010954\n"
        },
        {
            "input": "-3 -7 -14 2\n5\n-16 19 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 8.82294\n20 10 6.25657 0.77605\n-4 17 0.29502 6.31019\n5\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "0 0 10 0\n1\n5 -2 4.71238 1\n0\n",
            "output": "5.124757895825\n"
        },
        {
            "input": "0 -1 10 18\n1\n10 0 0 1.57079\n0\n",
            "output": "21.470824063119\n"
        },
        {
            "input": "-100000 -100000 100000 100000\n1\n100001 0 0 16.252597429020454\n0\n",
            "output": "2926477.098524171393\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.36623987348466 0.77605\n-4 17 0.29502 6.31019\n0\n",
            "output": "50.594514466873\n"
        },
        {
            "input": "1 -1 5 2\n1\n0 -5 4.71238 1\n0\n",
            "output": "1.983062936084\n"
        },
        {
            "input": "2 -1 5 2\n1\n0 -5 4.71238 1\n0\n",
            "output": "1.682684658277\n"
        },
        {
            "input": "2 -2 5 2\n1\n1 -5 4.71238 1\n0\n",
            "output": "1.906609981006\n"
        },
        {
            "input": "2 -2 5 2\n1\n1 0 4.71238 1\n0\n",
            "output": "2.457663128563\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n8 -19 3.27418 0.06595\n-1 17 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "54.557851458803\n"
        },
        {
            "input": "2 -2 10 2\n1\n1 0 4.71238 1\n0\n",
            "output": "4.998267966183\n"
        },
        {
            "input": "2 -2 10 0\n1\n1 0 4.71238 1\n0\n",
            "output": "5.249671086727\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n16 -19 3.27418 0.06595\n-1 1 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "42.982549963710\n"
        },
        {
            "input": "2 -2 10 0\n1\n1 0 4.71238 2\n0\n",
            "output": "10.499342228965\n"
        },
        {
            "input": "2 -2 10 1\n1\n1 0 4.71238 2\n0\n",
            "output": "10.162585939444\n"
        },
        {
            "input": "2 -2 10 2\n1\n1 0 4.71238 2\n0\n",
            "output": "9.996535987877\n"
        },
        {
            "input": "0 0 10 10\n1\n10 1 0 1.57079\n0\n",
            "output": "14.142078619273\n"
        },
        {
            "input": "0 0 10 10\n2\n10 0 0 1.6749386073716397\n10 5 0 0.7854\n1\n",
            "output": "7.071084329180\n"
        },
        {
            "input": "-100000 -100000 100000 100000\n1\n100100 0 0 15.70796\n0\n",
            "output": "2826627.050239171833\n"
        },
        {
            "input": "0 0 10 0\n1\n10 -5 4.71238 1\n0\n",
            "output": "3.183107943894\n"
        },
        {
            "input": "-1 0 10 10\n2\n10 0 0 1.57079\n10 5 0 0.8170852321197289\n1\n",
            "output": "7.732921802894\n"
        },
        {
            "input": "-100000 -100000 100000 100000\n1\n101000 0 0 16.252597429020454\n0\n",
            "output": "2907983.547869308386\n"
        },
        {
            "input": "-12576 -100000 100000 100000\n1\n100001 0 0 16.252597429020454\n0\n",
            "output": "2374628.250618627295\n"
        },
        {
            "input": "-3 -7 -7 1\n5\n-16 8 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "38.868620100274\n"
        },
        {
            "input": "-3 -10 -14 1\n5\n-16 8 2.12587 0.30781\n8 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "57.866238356574\n"
        },
        {
            "input": "2 -1 5 3\n1\n0 -5 4.71238 1\n0\n",
            "output": "1.935731852587\n"
        },
        {
            "input": "2 -2 0 2\n1\n0 -5 4.71238 1\n0\n",
            "output": "1.423529127909\n"
        },
        {
            "input": "-3 -7 -23 1\n5\n-16 8 2.559932973064263 1.0969772175579569\n8 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "73.303456804563\n"
        },
        {
            "input": "2 -4 5 2\n1\n1 -5 4.71238 1\n0\n",
            "output": "2.557985767648\n"
        },
        {
            "input": "2 -2 10 2\n1\n0 0 4.71238 1\n0\n",
            "output": "5.058402585689\n"
        },
        {
            "input": "-3 -7 -14 0\n5\n-16 8 2.559932973064263 1.1354423227049963\n16 -19 3.27418 0.06595\n-1 17 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "52.955770601937\n"
        },
        {
            "input": "2 -2 10 -1\n1\n1 0 4.71238 1\n0\n",
            "output": "5.521534285347\n"
        },
        {
            "input": "2 -2 10 0\n1\n1 -1 4.71238 2\n0\n",
            "output": "9.808379441978\n"
        },
        {
            "input": "-6 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n16 -19 3.27418 0.06595\n-1 1 0.12414 9.535572607019366\n39 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "35.752901916819\n"
        },
        {
            "input": "2 -2 10 1\n1\n1 1 4.71238 2\n0\n",
            "output": "10.878501210954\n"
        },
        {
            "input": "-4 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n1 -19 3.27418 0.06595\n-1 1 0.12414 9.535572607019366\n39 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "40.469537110344\n"
        },
        {
            "input": "2 -2 10 2\n1\n1 -1 4.71238 2\n0\n",
            "output": "9.452055860226\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n1 -8 3.27418 1.0405329008667348\n-1 1 0.12414 9.88636568653965\n39 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.579859441637554\n0\n",
            "output": "44.563784995511\n"
        },
        {
            "input": "0 0 4 10\n1\n10 1 0 1.57079\n0\n",
            "output": "7.836730764321\n"
        },
        {
            "input": "-100000 -100000 100000 100001\n1\n100100 0 0 15.70796\n0\n",
            "output": "2826634.134798889048\n"
        },
        {
            "input": "0 0 1 0\n1\n10 -5 4.71238 1\n0\n",
            "output": "0.481258366491\n"
        },
        {
            "input": "-88 -68 -10 -61\n5\n-64 -55 3.09648 0.7277466706976041\n-8 -52 2.46781 0.13262\n-8 -59 3.02445 0.00119\n-43 90 2.7450826496705716 0.15686\n-29 -34 2.73957 0.18287\n0\n",
            "output": "18.527788692158\n"
        },
        {
            "input": "-12576 -100000 000000 100000\n1\n100001 0 0 16.252597429020454\n0\n",
            "output": "1382285.016732543008\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.886184417306021 0.77605\n-4 17 0.29502 6.31019\n1\n",
            "output": "35.401464038021\n"
        },
        {
            "input": "2 -1 5 3\n1\n0 -5 5.7051121315310525 1\n0\n",
            "output": "3.144119797849\n"
        },
        {
            "input": "2 -4 5 2\n1\n1 -5 4.71238 2\n0\n",
            "output": "5.115971535297\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n8 -19 3.27418 0.06595\n-1 17 0.6228610349280487 9.535572607019366\n20 17 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "45.097004797157\n"
        },
        {
            "input": "-3 -7 -14 0\n5\n-16 8 2.559932973064263 1.1354423227049963\n16 -19 3.27418 0.06595\n-1 14 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "50.885247127042\n"
        },
        {
            "input": "2 -2 13 0\n1\n1 -1 4.71238 2\n0\n",
            "output": "13.519590391642\n"
        },
        {
            "input": "2 -2 2 2\n1\n1 -1 4.71238 2\n0\n",
            "output": "2.837029222658\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n1 -28 3.27418 0.06595\n-1 1 0.12414 9.535572607019366\n39 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.579859441637554\n1\n",
            "output": "32.580594000464\n"
        },
        {
            "input": "-1 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n1 -8 3.27418 0.06595\n-1 1 0.12414 9.535572607019366\n39 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 7.401497308989664\n0\n",
            "output": "48.237442429322\n"
        },
        {
            "input": "-100000 -100000 100000 100001\n1\n101100 0 0 15.70796\n0\n",
            "output": "2808765.326350770891\n"
        },
        {
            "input": "0 0 1 0\n1\n10 -5 4.990259577728749 1\n0\n",
            "output": "0.424490442796\n"
        },
        {
            "input": "-1 0 10 10\n2\n10 0 1 1.57079\n10 5 0 1.659022941703511\n1\n",
            "output": "15.701048350358\n"
        },
        {
            "input": "-12576 -188655 000000 100000\n1\n100001 0 0 16.252597429020454\n0\n",
            "output": "1992973.798103425652\n"
        },
        {
            "input": "-3 -10 -14 1\n5\n-16 8 2.12587 0.30781\n8 -19 3.27418 0.06595\n-2 12 0.12414 9.535572607019366\n20 10 6.36623987348466 1.24988212342287\n-4 0 0.29502 6.31019\n0\n",
            "output": "58.776272293670\n"
        },
        {
            "input": "2 -1 5 3\n1\n0 -3 5.7051121315310525 1\n0\n",
            "output": "3.438479168061\n"
        },
        {
            "input": "-3 -7 -23 1\n5\n-16 8 2.559932973064263 1.0969772175579569\n8 -19 3.27418 0.06595\n-1 12 0.12414 10.192108056362152\n4 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "78.350486487633\n"
        },
        {
            "input": "2 -4 10 2\n1\n1 -5 4.71238 2\n0\n",
            "output": "8.961181796607\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n8 -19 3.27418 0.06595\n-1 16 0.12414 9.535572607019366\n20 19 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.8570681606617905\n0\n",
            "output": "53.838254243654\n"
        },
        {
            "input": "2 -2 14 0\n1\n1 -1 4.71238 2\n0\n",
            "output": "14.767775446956\n"
        },
        {
            "input": "1 0 10 0\n1\n5 -5 4.71238 1\n1\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "-3 -7 -14 2\n5\n-16 19 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.25657 0.77605\n-4 17 0.29502 6.31019\n5\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "1 0 10 0\n1\n5 -5 4.71238 1\n2\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "-3 -7 -14 2\n5\n-16 8 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.25657 0.77605\n-4 17 0.29502 6.31019\n5\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "1 0 10 1\n1\n5 -5 4.71238 1\n2\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "-3 -7 -14 2\n5\n-16 8 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.36623987348466 0.77605\n-4 17 0.29502 6.31019\n5\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "1 0 10 2\n1\n5 -5 4.71238 1\n2\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.36623987348466 0.77605\n-4 17 0.29502 6.31019\n5\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "1 0 10 2\n1\n0 -5 4.71238 1\n2\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "1 -1 10 2\n1\n0 -5 4.71238 1\n2\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.36623987348466 0.77605\n-4 0 0.29502 6.31019\n0\n",
            "output": "50.594514466873\n"
        },
        {
            "input": "1 -1 5 2\n1\n0 -5 4.71238 1\n2\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "50.594514466873\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.12587 0.30781\n8 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "50.594514466873\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.12587 1.0969772175579569\n8 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "50.594514466873\n"
        },
        {
            "input": "2 -2 5 2\n1\n0 -5 4.71238 1\n0\n",
            "output": "1.983062936084\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.0969772175579569\n8 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "50.594514466873\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n8 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "50.594514466873\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n16 -19 3.27418 0.06595\n-1 17 0.12414 9.535572607019366\n20 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "54.557851458803\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n16 -19 3.27418 0.06595\n-1 1 0.12414 9.535572607019366\n39 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "42.982549963710\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n1 -19 3.27418 0.06595\n-1 1 0.12414 9.535572607019366\n39 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.31019\n0\n",
            "output": "42.982549963710\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n1 -19 3.27418 0.06595\n-1 1 0.12414 9.535572607019366\n39 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.579859441637554\n0\n",
            "output": "42.982549963710\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n1 -8 3.27418 0.06595\n-1 1 0.12414 9.535572607019366\n39 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.579859441637554\n0\n",
            "output": "42.982549963710\n"
        },
        {
            "input": "-3 -7 -14 1\n5\n-16 8 2.559932973064263 1.1354423227049963\n1 -8 3.27418 1.0405329008667348\n-1 1 0.12414 9.535572607019366\n39 10 6.36623987348466 1.1879412105959766\n-4 0 0.29502 6.579859441637554\n0\n",
            "output": "42.982549963710\n"
        },
        {
            "input": "-3 -7 -14 2\n5\n-16 18 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 8.82294\n20 10 6.25657 0.77605\n-10 17 0.29502 6.31019\n5\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "0 0 10 -1\n1\n5 -5 4.71238 1\n1\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "0 -1 10 10\n1\n10 0 0 1.57079\n1\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "-88 -68 -10 -61\n5\n-64 -55 3.09648 0.28346\n-8 -52 2.46781 0.13262\n-8 -59 3.02445 0.00119\n-43 90 2.7450826496705716 0.15686\n-29 -34 2.73957 0.18287\n0\n",
            "output": "7.216641673136\n"
        },
        {
            "input": "-3 -7 -14 2\n5\n-16 19 2.12587 0.30781\n9 -19 3.788069562285468 0.06595\n-1 12 0.12414 8.82294\n20 10 6.25657 0.77605\n-4 17 0.29502 6.31019\n5\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "0 0 10 0\n1\n5 -2 4.71238 0\n0\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "1 0 12 0\n1\n5 -5 4.71238 1\n1\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "-3 -7 -14 2\n5\n-16 7 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.25657 0.77605\n-4 17 0.29502 6.31019\n5\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "1 0 10 0\n1\n5 -9 4.71238 1\n2\n",
            "output": "0.000000000000\n"
        },
        {
            "input": "-3 -7 -19 2\n5\n-16 8 2.12587 0.30781\n9 -19 3.27418 0.06595\n-1 12 0.12414 9.535572607019366\n20 10 6.25657 0.77605\n-4 17 0.29502 6.31019\n5\n",
            "output": "0.000000000000\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\ndouble ax, ay, bx, by;\ndouble dis(double x, double y) { return sqrt(x * x + y * y); }\ndouble get(double a, double w) {\n  double v = 0;\n  int num = 100;\n  for (int i = 0; i <= 100; i++) {\n    double x = ax + (bx - ax) * i / (double)num;\n    double y = ay + (by - ay) * i / (double)num;\n    double p = atan2(y, x) - a;\n    if (p > 2 * pi) p -= 2 * pi;\n    while (p < 0) p += 2 * pi;\n    if (p > 2 * pi - p) p = 2 * pi - p;\n    double t = ((w < 1e-5) ? (i == 0 ? 0 : 1e10) : p / w);\n    v = max(v, hypot(x - ax, y - ay) / t);\n  }\n  return v;\n}\ndouble x[10010], y[10010], a[10010], w[10010];\nint main() {\n  int n, k;\n  while (scanf(\"%lf%lf%lf%lf\", &ax, &ay, &bx, &by) != EOF) {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n      scanf(\"%lf%lf%lf%lf\", &x[i], &y[i], &a[i], &w[i]);\n    vector<double> v;\n    v.clear();\n    for (int i = 0; i < n; i++) {\n      ax -= x[i];\n      ay -= y[i];\n      bx -= x[i];\n      by -= y[i];\n      double vv = get(a[i], w[i]);\n      v.push_back(vv);\n      ax += x[i];\n      ay += y[i];\n      bx += x[i];\n      by += y[i];\n    }\n    sort(v.begin(), v.end());\n    reverse(v.begin(), v.end());\n    scanf(\"%d\", &k);\n    if (k >= v.size())\n      printf(\"0.00000\\n\");\n    else\n      printf(\"%.5lf\\n\", v[k]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class F {\n\tpublic static void main(String[] args) throws Exception{\n\t\tScanner in = new Scanner(System.in);\n\t\tst = new Point(in.nextDouble(), in.nextDouble());\n\t\ten = new Point(in.nextDouble(), in.nextDouble());\n\t\tN = in.nextInt();\n\t\tT = new Tank[N];\n\t\tfor(int i = 0; i < N;i++)\n\t\t\tT[i] = new Tank(in.nextDouble(), in.nextDouble(), in.nextDouble(), in.nextDouble());\n\t\t\n\t\tK = in.nextInt();\n\t\t\n\t\ten = en.sub(st);\n\t\tfor(Tank t:T)\n\t\t\tt.p = t.p.sub(st);\n\t\tst = st.sub(st);\n\t\t\n\t\tdouble ang = en.ang();\n\t\tst = st.rot(-ang);\n\t\ten = en.rot(-ang);\n\t\tfor(Tank t:T){\n\t\t\tt.p = t.p.rot(-ang);\n\t\t\tt.a = normang(t.a-ang);\n\t\t}\n\t\t\n\t\tfor(Tank t:T){\n\t\t\tif(t.p.y > 0){\n\t\t\t\tt.p.y = -t.p.y;\n\t\t\t\tt.a = normang(2*PI-t.a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tX = en.x;\n\t\tdouble low = 0;\n\t\tdouble high = Long.MAX_VALUE;\n\t\tfor(int i = 0; i < 100;i++){\n\t\t\tdouble mid = (low+high)/2;\n\t\t\tif(safe(mid)){\n\t\t\t\thigh = mid;\n\t\t\t}else{\n\t\t\t\tlow = mid;\n\t\t\t}\n\t\t}\n\t\tSystem.out.format(\"%.015f\\n\", low);\n\t}\n\tprivate static boolean safe(double v) {\n\t\tint hit = 0;\n\t\tLine l = new Line(st, en);\n\t\tfor(Tank t:T){\n\t\t\tdouble toend = abs(angdiff(en.sub(t.p).ang(), t.a))/t.w;\n\t\t\tif(toend <= X/v){\n\t\t\t\thit++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble dist = pointlinedist(t.p, l);\n\t\t\tif(dist*t.w/v > 1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tdouble alpha1 = asin(sqrt(dist*t.w/v))/t.w;\n\t\t\tdouble alpha2 = (PI-asin(sqrt(dist*t.w/v)))/t.w;\n\n\t\t\tdouble theta1 = alpha1*t.w;\n\t\t\tdouble theta2 = alpha2*t.w;\n\t\t\t\n\t\t\tdouble x1 = t.p.x + dist*cos(theta1)/sin(theta1);\n\t\t\tdouble t1 = abs(angdiff(theta1, t.a))/t.w;\n\t\t\tif(0 <= x1 && x1 <= X && t1 <= x1/v){\n\t\t\t\thit++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdouble x2 = t.p.x + dist*cos(theta2)/sin(theta2);\n\t\t\tdouble t2 = abs(angdiff(theta2, t.a))/t.w;\n\t\t\tif(0 <= x2 && x2 <= X && t2 <= x2/v){\n\t\t\t\thit++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t}\n\t\treturn hit <= K;\n\t}\n\tstatic int N, K;\n\tstatic Tank[] T;\n\tstatic Point st, en;\n\tstatic double X;\n\tstatic class Tank{\n\t\tPoint p;\n\t\tdouble a, w;\n\t\tpublic Tank(double x, double y, double a, double w){\n\t\t\tp = new Point(x, y);\n\t\t\tthis.a = a;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\n\n\n\n\n\n\tstatic double eps = 1e-9;\n\tstatic boolean EQ(double a, double b){return abs(a-b) < eps;}\n\tstatic double SQ(double d){return d*d;}\n\tstatic double normang(double t){ return ((t % (2*PI)) + 2*PI) % (2*PI); }\n\tstatic double angdiff(double t1, double t2){ return normang(t1 - t2 + PI) - PI; }\n\tstatic ArrayList<Point> makeVec(Point...P){\n\t\tArrayList<Point> ans = new ArrayList<Point>();\n\t\tfor(Point p:P)\n\t\t\tans.add(p);\n\t\treturn ans;\n\t}\n\tstatic class Point{\n\t\tdouble x, y;\n\t\tpublic Point(double x, double y){this.x = x;this.y = y;}\n\t\tPoint add(Point p){return new Point(x+p.x, y+p.y);}\n\t\tPoint sub(Point p){return new Point(x-p.x, y-p.y);}\n\t\tPoint mult(double d){return new Point(x*d, y*d);}\n\t\tdouble dot(Point p){return x*p.x+ y*p.y;}\n\t\tdouble cross(Point p){return x*p.y - y*p.x;}\n\t\tdouble len(){return hypot(x, y);}\n\t\tPoint scale(double d){return mult(d/len());}\n\t\tdouble dist(Point p){return sub(p).len();}\n\t\tdouble ang(){return atan2(y, x);}\n\t\tstatic Point polar(double r, double theta){return new Point(r*cos(theta), r*sin(theta));}\n\t\tPoint rot(double theta){return new Point(x*cos(theta)-y*sin(theta), x*sin(theta)+y*cos(theta));}\n\t\tPoint perp(){return new Point(-y, x);}\n\t\tboolean equals(Point p){return EQ(0, dist(p));}\n\t\tdouble norm(){return dot(this);}\n\t\tpublic String toString(){return String.format(\"(%.03f, %.03f)\", x, y);}\n\t}\t\n\tstatic class Line{\n\t\tPoint a, b;\n\t\tLine(Point a, Point b){this.a = a;this.b = b;}\n\t\tpublic String toString(){return String.format(\"{%s -> %s}\", a, b);}\n\t}\n\tstatic class Circle{\n\t\tPoint p;double r;\n\t\tpublic Circle(Point p, double r){this.p = p;this.r = r;}\n\t\tpublic Circle(Point a, Point b, Point c){\n\t\t\tPoint p1 = a.add(b).mult(0.5);\n\t\t\tLine l1 = new Line(p1, p1.add(a.sub(b).perp()));\n\t\t\tPoint p2 = b.add(c).mult(0.5);\n\t\t\tLine l2 = new Line(p2, p2.add(b.sub(c).perp()));\n\t\t\tp = lineline(l1, l2);\n\t\t\tassert(p != null);\n\t\t\tr = p.dist(a);\n\t\t}\n\t}\n\tstatic double ccw(Point p1, Point p2, Point p3){\n\t\treturn p2.sub(p1).cross(p3.sub(p1));\n\t}\n\tstatic Point lineline(Line a, Line b){//tested\n\t\tdouble d = a.b.sub(a.a).cross(b.b.sub(b.a));\n\t\tif(EQ(d, 0))\n\t\t\treturn null;\n\t\treturn a.a.add((a.b.sub(a.a)).mult(b.b.sub(b.a).cross(a.a.sub(b.a))/d));\n\t}\n\tstatic Point segline(Line a, Line b){\n\t\tPoint inter = lineline(a, b);\n\t\tif(inter == null || !onseg(a, inter))\n\t\t\treturn null;\n\t\treturn inter;\n\t}\n\tstatic Point segseg(Line a, Line b){//tested\n\t\tPoint inter = lineline(a, b);\n\t\tif(inter == null || !onseg(a, inter) || !onseg(b, inter))\n\t\t\treturn null;\n\t\treturn inter;\n\t}\n\tstatic boolean onseg(Line l, Point p){ //tested\n\t\tPoint delta = l.b.sub(l.a);\n\t\treturn online(l, p) && delta.dot(l.a)-eps <= delta.dot(p) && delta.dot(p) <= delta.dot(l.b)+eps;\n\t}\n\tstatic boolean online(Line l, Point p){ //tested\n\t\treturn EQ(ccw(l.a, l.b, p), 0);\n\t}\n\tstatic Point pointline(Point p, Line l){\n\t\tPoint v = l.b.sub(l.a).scale(1);\n\t\tdouble dot = p.sub(l.a).dot(v);\n\t\treturn l.a.add(v.mult(dot));\n\t}\n\tstatic Point pointseg(Point p, Line l){\n\t\tPoint v = l.b.sub(l.a).scale(1);\n\t\tdouble dot = p.sub(l.a).dot(v);\n\t\tdot = max(dot, 0);\n\t\tdot = min(dot, l.b.dist(l.a));\n\t\treturn l.a.add(v.mult(dot));\n\t}\n\tstatic double pointsegdist(Point p, Line l){\n\t\treturn pointseg(p, l).dist(p);\n\t}\n\tstatic double pointlinedist(Point p, Line l){\n\t\treturn pointline(p, l).dist(p);\n\t}\n\n\tstatic double polyarea(Point[] poly){\n\t\tdouble area = 0;\n\t\tfor(int i = 0; i < poly.length; i++)\n\t\t\tarea += poly[i].cross(poly[(i+1)%poly.length]);\n\t\treturn abs(area)/2.0;\n\t}\n\tstatic int pointinpoly(Point[] poly, Point p){\n\t\tdouble ang = 0.0;\n\t\tfor(int i = 0; i < poly.length; i++){\n\t\t\tPoint a = poly[i];\n\t\t\tPoint b = poly[(i+1)%poly.length];\n\t\t\tif(onseg(new Line(a, b), p))\n\t\t\t\treturn 0;\n\t\t\tang += angdiff(a.sub(p).ang(), b.sub(p).ang());\n\t\t}\n\t\treturn EQ(ang, 0) ? -1 : 1;\n\t}\n\n\tstatic Point v0;\n\tstatic ArrayList<Point> convexhull(ArrayList<Point> P){//tested\n\t\tv0 = null;\n\t\tfor(Point p:P)\n\t\t\tif(v0 == null || p.x < v0.x - eps || (EQ(p.x, v0.x) && p.y < v0.y))\n\t\t\t\tv0 = p;\n\t\tCollections.sort(P, new Comparator<Point>(){\n\t\t\tpublic int compare(Point a, Point b){\n\t\t\t\tif(a == v0) return -1;\n\t\t\t\tif(b == v0) return 1;\n\t\t\t\tdouble ccw = ccw(v0, a, b);\n\t\t\t\tif(EQ(ccw, 0)){\n\t\t\t\t\tdouble d1 = v0.dist(a);\n\t\t\t\t\tdouble d2 = v0.dist(b);\n\t\t\t\t\tif(d1 < d2) return -1;\n\t\t\t\t\tif(d1 > d2) return 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn (int) -signum(ccw);\n\t\t\t}});\n\t\tArrayList<Point> ch = new ArrayList<Point>();\n\t\tfor(Point p:P){\n\t\t\twhile(ch.size() >= 2 && ccw(ch.get(ch.size()-2), ch.get(ch.size()-1), p) <= 0)\n\t\t\t\tch.remove(ch.size()-1);\n\t\t\tch.add(p);\n\t\t}\n\t\treturn ch;\n\t}\n\t//add half space intersection\n\n\t//circle\n\tstatic ArrayList<Point> circline(Circle c, Line l){\n\t\tPoint x = pointline(c.p, l);\n\t\tdouble d = x.dist(c.p);\n\t\tif(d > c.r + eps) return new ArrayList<Point>();\n\t\tdouble h = sqrt(SQ(c.r) - SQ(d));\n\t\tPoint v = x.sub(c.p);\n\t\treturn makeVec(c.p.add(v.scale(d)).add(v.scale(h)), c.p.add(v.scale(d)).add(v.scale(-h)));\n\t}\n\tstatic ArrayList<Point> circcirc(Circle a, Circle b){\n\t\tdouble d = a.p.dist(b.p);\n\t\tif(d > a.r + b.r + eps) return new ArrayList<Point>();\n\t\tif(d < abs(a.r - b.r) - eps) return new ArrayList<Point>();\n\t\tdouble x = (SQ(d) - SQ(b.r) + SQ(a.r)) / 2*d;\n\t\tdouble y = sqrt(SQ(a.r) - SQ(x));\n\t\tPoint v = b.p.sub(a.p);\n\t\treturn makeVec(a.p.add(v.scale(x)).add(v.perp().scale(y)), a.p.add(v.scale(x)).add(v.perp().scale(-y)));\n\t}\n\tstatic ArrayList<Line> circcirctan(Circle a, Circle b){//tested\n\t\tif(a.r < b.r)\n\t\t\treturn circcirctan(b, a);\n\t\tArrayList<Line> res = new ArrayList<Line>();\n\t\tdouble d = a.p.dist(b.p);\n\t\tdouble d1 = a.r*d/(a.r + b.r);\n\t\tdouble t = acos(a.r/d1);\n\t\tPoint v = b.p.sub(a.p);\n\t\tres.add(new Line(a.p.add(v.scale(a.r).rot(t)), b.p.add(v.scale(-b.r).rot(t))));\n\t\tres.add(new Line(a.p.add(v.scale(a.r).rot(-t)), b.p.add(v.scale(-b.r).rot(-t))));   \n\t\tt = asin((a.r-b.r)/d)+PI/2;\n\t\tv = a.p.sub(b.p);\n\t\tres.add(new Line(a.p.add(v.scale(a.r).rot(t)), b.p.add(v.scale(b.r).rot(t))));\n\t\tres.add(new Line(a.p.add(v.scale(a.r).rot(-t)), b.p.add(v.scale(b.r).rot(-t)))); \n\t\treturn res;\n\t}\n\n\t//3d\n\tstatic class Point3{\n\t\tdouble x, y, z;\n\t\tPoint3(double x, double y, double z) {  this.x = x; this.y = y; this.z = z; }\n\t\tstatic Point3 sphere(double theta, double phi, double r){\n\t\t\treturn new Point3(r*cos(theta)*sin(phi),r*sin(theta)*sin(phi),r*cos(theta));\n\t\t}\n\t\tdouble[] ang(){ return new double[]{atan(y/x), acos(z/len())}; }\n\t\tPoint proj(){ return new Point(x, y); }\n\t\tPoint3 add(Point3 p){ return new Point3(x+p.x, y+p.y, z+p.z); }\n\t\tPoint3 sub(Point3 p){ return new Point3(x-p.x, y-p.y, z-p.z); }\n\t\tdouble dot(Point3 p){ return x*p.x+ y*p.y+ z*p.z; }\n\t\tPoint3 cross(Point3 p){ return new Point3(y*p.z-p.y*z, z*p.x-p.z*x, x*p.y-p.x*y); }\n\t\tPoint3 mult(double d){ return new Point3(x*d, y*d, z*d); }\n\t\tdouble len(){ return sqrt(x*x+y*y+z*z); }\n\t\tPoint3 scale(double d){ return mult(d/len()); }\n\t\tdouble dist(Point3 p){ return sub(p).len(); } \n\t\tboolean equals(Point3 p){ return EQ(dist(p), 0); }\n\t}\n\tstatic Point3[] getbasis(Point3 z){\n\t\tz = z.scale(1);\n\t\tPoint3 t = new Point3(1, 0, 0);\n\t\tPoint3 y = z.cross(t);\n\t\tif(EQ(y.len(), 0)){\n\t\t\tt = new Point3(0, 1, 0);\n\t\t\ty = z.cross(t);\n\t\t}\n\t\tPoint3 x = y.cross(z);\n\t\tassert(x.cross(y).equals(z));\n\t\treturn new Point3[]{x, y, z};\n\t}\n\tstatic Point3 trans(Point3[] B, Point3 p){\n\t\treturn new Point3(B[0].dot(p), B[1].dot(p), B[2].dot(p));\n\t}\n\tstatic Point3 invtrans(Point3[] B, Point3 p){\n\t\treturn B[0].mult(p.x).add(B[1].mult(p.y)).add(B[2].mult(p.z));\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 10000;\nint n;\ndouble x1, y3223789, x2, y2;\ndouble x[MAXN], y[MAXN], w[MAXN], a0[MAXN];\ndouble t1[MAXN], t2[MAXN], d[MAXN], p[MAXN];\ndouble pi = 2 * acos(0.0);\ndouble cross(double x1, double y3223789, double x2, double y2) {\n  return x1 * y2 - x2 * y3223789;\n}\ndouble getmin(double x) {\n  while (x < 0) x += 2 * pi;\n  while (x > 2 * pi) x -= 2 * pi;\n  return min(x, 2 * pi - x);\n}\ndouble get_time(int i, double xx, double yy) {\n  double ang = atan2(yy - y[i], xx - x[i]) - a0[i];\n  return getmin(ang) / w[i];\n}\ndouble inter(double x1, double y3223789, double x2, double y2, double x3,\n             double y3, double x4, double y4) {\n  double d = cross(x2 - x1, y2 - y3223789, x3 - x4, y3 - y4);\n  double p = cross(x2 - x1, y2 - y3223789, x3 - x1, y3 - y3223789);\n  return p / d;\n}\ndouble nt;\nint check(int i, double v) {\n  if (get_time(i, x2, y2) < nt) return 1;\n  if (p[i] < 0) return 0;\n  double l = 0, r = min(1.0, p[i]);\n  for (int o = 0; o < 50; o++) {\n    double c1 = (l * 2 + r) / 3;\n    double c2 = (l + 2 * r) / 3;\n    double cx1 = x1 * (1 - c1) + x2 * c1;\n    double cy1 = y3223789 * (1 - c1) + y2 * c1;\n    double cx2 = x1 * (1 - c2) + x2 * c2;\n    double cy2 = y3223789 * (1 - c2) + y2 * c2;\n    double t1 = get_time(i, cx1, cy1);\n    double t2 = get_time(i, cx2, cy2);\n    t1 -= nt * c1;\n    t2 -= nt * c2;\n    if (t1 < 0 || t2 < 0) return 1;\n    if (t1 < t2)\n      r = c2;\n    else\n      l = c1;\n  }\n  return 0;\n}\nint getans(double v) {\n  int ans = 0;\n  nt = sqrt((x2 - x1) * (x2 - x1) + (y2 - y3223789) * (y2 - y3223789)) / v;\n  for (int i = 0; i < n; i++)\n    if (check(i, v)) ans++;\n  return ans;\n}\nint main() {\n  cin >> x1 >> y3223789 >> x2 >> y2;\n  double dist = sqrt((x2 - x1) * (x2 - x1) + (y2 - y3223789) * (y2 - y3223789));\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> a0[i] >> w[i];\n    double tmp = cross(x[i] - x1, y[i] - y3223789, x[i] - x2, y[i] - y2);\n    t1[i] = get_time(i, x1, y3223789);\n    t2[i] = get_time(i, x2, y2);\n    p[i] = inter(x[i], y[i], x[i] + y2 - y3223789, y[i] + x1 - x2, x1, y3223789,\n                 x2, y2);\n    d[i] = abs(tmp) / dist;\n  }\n  int k;\n  cin >> k;\n  double l = 0, r = 4000000;\n  while (r - l > 1e-5) {\n    double v = (l + r) / 2;\n    if (getans(v) > k)\n      l = v;\n    else\n      r = v;\n  }\n  printf(\"%.4lf\", (l + r) / 2);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble cal_ang(double x, double y) {\n  double res = acos(abs(x / hypot(x, y)));\n  if (x <= 0 && y >= 0) return acos(-1) - res;\n  if (x <= 0 && y < 0) return acos(-1) + res;\n  if (x > 0 && y < 0) return acos(-1) * 2.0 - res;\n  return res;\n}\nint main() {\n  double x0, x1, y0, y1, t0, t1, t2, t3;\n  int n, k;\n  vector<double> time;\n  scanf(\"%lf%lf%lf%lf%d\", &x0, &y0, &x1, &y1, &n);\n  for (long long i = 0; i < ((long long)n); i++) {\n    scanf(\"%lf%lf%lf%lf\", &t0, &t1, &t2, &t3);\n    if (t3 < 1e-5) continue;\n    x0 -= t0;\n    x1 -= t0;\n    y0 -= t1;\n    y1 -= t1;\n    double tmp = 0;\n    for (long long j = 0; j < ((long long)100 + 1); j++) {\n      double x = x0 + (x1 - x0) * j / (double)100;\n      double y = y0 + (y1 - y0) * j / (double)100;\n      double ang = cal_ang(x, y);\n      ang -= t2;\n      if (ang < 0) ang += 2.0 * acos(-1);\n      while (ang > acos(-1) * 2.0) ang -= acos(-1) * 2.0;\n      ang = min(acos(-1) * 2.0 - ang, ang);\n      tmp = max(tmp, hypot(x0 - x, y0 - y) / (ang / t3));\n    }\n    time.push_back(tmp);\n    x0 += t0;\n    x1 += t0;\n    y0 += t1;\n    y1 += t1;\n  }\n  scanf(\"%d\", &k);\n  if (((long long)time.size()) <= k) {\n    printf(\"0.0000\\n\");\n    return 0;\n  }\n  sort(time.begin(), time.end());\n  reverse(time.begin(), time.end());\n  printf(\"%.4lf\\n\", time[k]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.00), eps = 1e-9;\nstruct point {\n  double x, y, w, a;\n};\npoint st, en, tank[11111];\nint n, k;\nvoid norm(double &theta) {\n  while (theta < -pi + eps) theta += 2 * pi;\n  while (theta > pi + eps) theta -= 2 * pi;\n}\nbool check(double v) {\n  int i, j, s, p, q, nk = 0, it;\n  double now_t, theta, dist, T, w;\n  double ltheta, low, high, mid, mt, vs, fs, bs, mx, my, fx, fy;\n  bool ft;\n  dist = sqrt((en.x - st.x) * (en.x - st.x) + (en.y - st.y) * (en.y - st.y));\n  T = dist / v;\n  for (i = 0; i < n; i++) {\n    theta = atan2(en.y - tank[i].y, en.x - tank[i].x);\n    while (theta < tank[i].a - eps) theta += 2 * pi;\n    theta -= tank[i].a;\n    if (theta > pi) theta = 2 * pi - theta;\n    now_t = theta / tank[i].w;\n    if (v * now_t <\n        sqrt((en.x - st.x) * (en.x - st.x) + (en.y - st.y) * (en.y - st.y))) {\n      nk++;\n      continue;\n    }\n    ltheta = atan2(st.y - tank[i].y, st.x - tank[i].x);\n    if (tank[i].w == 0)\n      continue;\n    else {\n      while (ltheta < tank[i].a - eps) ltheta += 2 * pi;\n      ltheta -= tank[i].a;\n      w = tank[i].w;\n      if (ltheta > pi) {\n        w = -w;\n        ltheta = 2 * pi - ltheta;\n      }\n      theta = atan2(en.y - st.y, en.x - st.x);\n      low = ltheta / tank[i].w;\n      high = T;\n      if (low > high) continue;\n      mt = low;\n      fs = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      mt = high;\n      bs = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      if ((fs < eps && bs > -eps) || (fs > -eps && bs < eps)) {\n        nk++;\n        continue;\n      }\n      for (it = 0; it < 50; it++) {\n        mx = mt = (2 * low + high) / 3.;\n        fx =\n            (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n            (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n        my = mt = (low + 2 * high) / 3.;\n        fy =\n            (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n            (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n        if ((fs > 0 && fx > fy) || (fs < 0 && fx < fy))\n          low = mx;\n        else\n          high = my;\n      }\n      mt = 0.5 * (low + high);\n      fx = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      if ((fs > 0 && fx < eps) || (fs < 0 && fx > -eps)) {\n        nk++;\n        continue;\n      }\n    }\n  }\n  return nk <= k;\n}\nint main() {\n  int i, j, s, p, q;\n  double low, high, mid;\n  scanf(\"%lf%lf%lf%lf\", &st.x, &st.y, &en.x, &en.y);\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%lf%lf%lf%lf\", &tank[i].x, &tank[i].y, &tank[i].a, &tank[i].w);\n    norm(tank[i].a);\n  }\n  scanf(\"%d\", &k);\n  low = 0;\n  high = 1e9;\n  while (low < high - eps) {\n    mid = (low + high) * 0.5;\n    if (check(mid))\n      high = mid;\n    else\n      low = mid + eps;\n  }\n  printf(\"%.20f\\n\", (low + high) * 0.5);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void read(T& x) {\n  bool fu = 0;\n  char c;\n  for (c = getchar(); c <= 32; c = getchar())\n    ;\n  if (c == '-') fu = 1, c = getchar();\n  for (x = 0; c > 32; c = getchar()) x = x * 10 + c - '0';\n  if (fu) x = -x;\n};\ntemplate <class T>\ninline void read(T& x, T& y) {\n  read(x);\n  read(y);\n}\ntemplate <class T>\ninline void read(T& x, T& y, T& z) {\n  read(x);\n  read(y);\n  read(z);\n}\ninline char getc() {\n  char c;\n  for (c = getchar(); c <= 32; c = getchar())\n    ;\n  return c;\n}\nconst double pi = 2 * acos(0);\nstruct node {\n  double x, y;\n};\nvoid read(node& a) { read(a.x, a.y); }\nint sgn(double x) {\n  if (x == 0) return 0;\n  return x > 0 ? 1 : -1;\n}\nnode operator+(node a, node b) { return (node){a.x + b.x, a.y + b.y}; }\nnode operator-(node a, node b) { return (node){a.x - b.x, a.y - b.y}; }\nnode operator*(node a, double x) { return (node){a.x * x, a.y * x}; }\nnode operator/(node a, double x) { return (node){a.x / x, a.y / x}; }\nnode mul(node a, node b) { return (node){a.x * b.x, a.y * b.y}; }\ndouble operator*(node a, node b) { return a.x * b.y - a.y * b.x; }\ndouble xj(node a, node b, node c) { return (b - a) * (c - a); }\ndouble len(node a) { return sqrt(a.x * a.x + a.y * a.y); }\nbool on(node a, node b, node c) {\n  if (a.x >= min(b.x, c.x) && a.x <= max(b.x, c.x) && a.y >= min(b.y, c.y) &&\n      a.y <= max(b.y, c.y) && xj(b, a, c) == 0)\n    return 1;\n  return 0;\n}\nbool pdj(node a, node b, node c, node d) {\n  return sgn(xj(a, c, b)) * sgn(xj(a, b, d)) > 0 &&\n         sgn(xj(b, c, a)) * sgn(xj(b, a, d)) > 0 &&\n         sgn(xj(c, b, d)) * sgn(xj(c, d, a)) > 0 &&\n         sgn(xj(d, a, c)) * sgn(xj(d, c, b)) > 0;\n}\nint n, i, j, k, p, K;\ndouble L, R;\nnode A, B, C, D;\ndouble alp, w, a[11111];\nconst int W = 2000;\nint main() {\n  read(A);\n  read(B);\n  read(n);\n  for (i = 1; i <= n; i++) {\n    read(C);\n    scanf(\"%lf%lf\", &alp, &w);\n    double vmax = 0, z;\n    for (int cnt = (0); cnt <= (W); cnt++) {\n      D = (node){(A.x + (B.x - A.x) / W * cnt), (A.y + (B.y - A.y) / W * cnt)};\n      z = alp - atan2(D.y - C.y, D.x - C.x);\n      while (z < 0) z += 2 * pi;\n      while (z >= 2 * pi) z -= 2 * pi;\n      if (z > pi) z = 2 * pi - z;\n      vmax = max(vmax, len(D - A) / (z / w + 1e-12));\n    }\n    a[i] = vmax;\n  }\n  read(K);\n  sort(a + 1, a + 1 + n);\n  cout << fixed << setprecision(10) << a[n - K] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.00), eps = 1e-9;\nstruct point {\n  double x, y, w, a;\n};\npoint st, en, tank[11111];\nint n, k;\nvoid norm(double &theta) {\n  while (theta < -pi + eps) theta += 2 * pi;\n  while (theta > pi + eps) theta -= 2 * pi;\n}\nbool check(double v) {\n  int i, j, s, p, q, nk = 0, it;\n  double now_t, theta, dist, T, w;\n  double ltheta, low, high, mid, mt, vs, fs, bs, mx, my, fx, fy;\n  bool ft;\n  dist = sqrt((en.x - st.x) * (en.x - st.x) + (en.y - st.y) * (en.y - st.y));\n  T = dist / v;\n  for (i = 0; i < n; i++) {\n    theta = atan2(en.y - tank[i].y, en.x - tank[i].x);\n    while (theta < tank[i].a - eps) theta += 2 * pi;\n    theta -= tank[i].a;\n    if (theta > pi) theta = 2 * pi - theta;\n    now_t = theta / tank[i].w;\n    if (v * now_t <\n        sqrt((en.x - st.x) * (en.x - st.x) + (en.y - st.y) * (en.y - st.y))) {\n      nk++;\n      continue;\n    }\n    ltheta = atan2(st.y - tank[i].y, st.x - tank[i].x);\n    if (tank[i].w == 0)\n      continue;\n    else {\n      while (ltheta < tank[i].a - eps) ltheta += 2 * pi;\n      ltheta -= tank[i].a;\n      w = tank[i].w;\n      if (ltheta > pi) {\n        w = -w;\n        ltheta = 2 * pi - ltheta;\n      }\n      theta = atan2(en.y - st.y, en.x - st.x);\n      low = ltheta / tank[i].w;\n      high = T;\n      if (low > high) continue;\n      mt = low;\n      fs = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      mt = high;\n      bs = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      if ((fs < eps && bs > -eps) || (fs > -eps && bs < eps)) {\n        nk++;\n        continue;\n      }\n      for (it = 0; it < 50; it++) {\n        mx = mt = (2 * low + high) / 3.;\n        fx =\n            (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n            (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n        my = mt = (low + 2 * high) / 3.;\n        fy =\n            (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n            (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n        if ((fs > 0 && fx > fy) || (fs < 0 && fx < fy))\n          low = mx;\n        else\n          high = my;\n      }\n      mt = 0.5 * (low + high);\n      fx = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      if ((fs > 0 && fx < eps) || (fs < 0 && fx > -eps)) {\n        nk++;\n        continue;\n      }\n    }\n  }\n  return nk <= k;\n}\nint main() {\n  int i, j, s, p, q;\n  double low, high, mid;\n  scanf(\"%lf%lf%lf%lf\", &st.x, &st.y, &en.x, &en.y);\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%lf%lf%lf%lf\", &tank[i].x, &tank[i].y, &tank[i].a, &tank[i].w);\n    norm(tank[i].a);\n  }\n  scanf(\"%d\", &k);\n  low = 0;\n  high = 3e6;\n  while (low < high - eps) {\n    mid = (low + high) * 0.5;\n    if (check(mid))\n      high = mid;\n    else\n      low = mid + eps;\n  }\n  printf(\"%.20f\\n\", (low + high) * 0.5);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n, m, k;\nstruct Point {\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  double abs() const { return hypot(x, y); }\n  double arg() const { return atan2(y, x); }\n  Point operator*(double o) const { return Point(x * o, y * o); }\n  Point operator+(const Point& o) const { return Point(x + o.x, y + o.y); }\n  Point operator-(const Point& o) const { return Point(x - o.x, y - o.y); }\n  bool operator<(const Point& o) const {\n    return x < o.x - 1e-6 || (x < o.x + 1e-6 && y < o.y - 1e-6);\n  }\n};\nPoint A, B;\nmap<double, int> js;\nint main() {\n  scanf(\"%lf%lf%lf%lf\", &A.x, &A.y, &B.x, &B.y);\n  scanf(\"%d\", &n);\n  double x, y, a, w;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf%lf%lf%lf\", &x, &y, &a, &w);\n    if (abs(w) < 1e-6) continue;\n    Point p = {x, y};\n    double v = -2;\n    for (int j = 0; j <= 100; j++) {\n      Point tp = (B - A) * (j / 100.0) + A;\n      double arg = (tp - p).arg() - a;\n      if (arg > 2 * acos(-1)) arg -= 2 * acos(-1);\n      while (arg < 0) arg += 2 * acos(-1);\n      if (arg > 2 * acos(-1) - arg) arg = 2 * acos(-1) - arg;\n      double t = arg / w;\n      v = v < -1 ? (tp - A).abs() / t : max(v, (tp - A).abs() / t);\n    }\n    js[v]++;\n  }\n  scanf(\"%d\", &k);\n  int sk = 0;\n  double t = -10;\n  for (map<double, int>::reverse_iterator it = js.rbegin(); it != js.rend();\n       it++) {\n    if (sk + it->second > k) {\n      t = it->first;\n      break;\n    }\n    sk += it->second;\n  }\n  printf(\"%.4lf\\n\", t < -1 ? 0 : t);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point {\n  double x, y;\n};\ndouble dist(point &P, point &Q) {\n  double dx = P.x - Q.x, dy = P.y - Q.y;\n  return sqrt(dx * dx + dy * dy);\n}\ndouble inprod(point &O, point &P, point &Q) {\n  return (P.x - O.x) * (Q.x - O.x) + (P.y - O.y) * (Q.y - O.y);\n}\npoint foot(point &P, point &A, point &B) {\n  double t = inprod(A, B, P) / inprod(A, B, B);\n  point ans = {A.x + (B.x - A.x) * t, A.y + (B.y - A.y) * t};\n  return ans;\n}\npoint rotate(point &P, double theta) {\n  double x = P.x * cos(theta) - P.y * sin(theta);\n  double y = P.x * sin(theta) + P.y * cos(theta);\n  point ans = {x, y};\n  return ans;\n}\ndouble arg(point &P) {\n  double ans = atan2(P.y, P.x);\n  if (ans < 0.0) ans += 2.0 * acos(-1.0);\n  return ans;\n}\nbool check(point &A, point &C, double v, double w) {\n  double t = dist(A, C) / v;\n  double theta = arg(C);\n  theta = min(theta, 2.0 * acos(-1.0) - theta);\n  return (w * t > theta);\n}\ndouble func(point A, point B, point P, double a, double w) {\n  int iter;\n  if (w < 1.0E-6) return 0.0;\n  A.x -= P.x;\n  A.y -= P.y;\n  B.x -= P.x;\n  B.y -= P.y;\n  A = rotate(A, -a);\n  B = rotate(B, -a);\n  if (arg(A) > arg(B)) {\n    A.y = -A.y;\n    B.y = -B.y;\n  }\n  point O = {0.0, 0.0};\n  double low = 0.0, high = 1.0E+7, mid;\n  for ((iter) = 0; (iter) < (int)(100); (iter)++) {\n    mid = (high + low) / 2.0;\n    if (check(A, B, mid, w)) {\n      low = mid;\n      continue;\n    }\n    point H = foot(O, A, B);\n    double h = dist(O, H);\n    if (h * w < mid) {\n      double t = sqrt(mid / (h * w) - 1.0);\n      point C = {H.x + H.y * t, H.y - H.x * t};\n      if (inprod(C, A, B) < 0.0 && check(A, C, mid, w)) {\n        low = mid;\n        continue;\n      }\n      point D = {H.x - H.y * t, H.y + H.x * t};\n      if (inprod(D, A, B) < 0.0 && check(A, D, mid, w)) {\n        low = mid;\n        continue;\n      }\n    }\n    high = mid;\n  }\n  return mid;\n}\nint main(void) {\n  int N, K, i;\n  point A, B, P;\n  double a, w;\n  cin >> A.x >> A.y >> B.x >> B.y;\n  cin >> N;\n  vector<double> v;\n  for ((i) = 0; (i) < (int)(N); (i)++) {\n    cin >> P.x >> P.y >> a >> w;\n    double tmp = func(A, B, P, a, w);\n    v.push_back(tmp);\n  }\n  cin >> K;\n  v.push_back(0.0);\n  sort(v.begin(), v.end());\n  double ans = v[N - K];\n  printf(\"%.6f\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 10000;\nint n;\ndouble x1, y3223789, x2, y2;\ndouble x[MAXN], y[MAXN], w[MAXN], a0[MAXN];\ndouble t1[MAXN], t2[MAXN], d[MAXN], p[MAXN];\ndouble pi = 2 * acos(0.0);\ndouble cross(double x1, double y3223789, double x2, double y2) {\n  return x1 * y2 - x2 * y3223789;\n}\ndouble getmin(double x) {\n  while (x < 0) x += 2 * pi;\n  while (x > 2 * pi) x -= 2 * pi;\n  return min(x, 2 * pi - x);\n}\ndouble get_time(int i, double xx, double yy) {\n  double ang = atan2(yy - y[i], xx - x[i]) - a0[i];\n  return getmin(ang) / w[i];\n}\ndouble inter(double x1, double y3223789, double x2, double y2, double x3,\n             double y3, double x4, double y4) {\n  double d = cross(x2 - x1, y2 - y3223789, x3 - x4, y3 - y4);\n  double p = cross(x2 - x1, y2 - y3223789, x3 - x1, y3 - y3223789);\n  return p / d;\n}\ndouble nt;\nint check(int i, double v) {\n  if (get_time(i, x2, y2) < nt) return 1;\n  if (p[i] < 0) return 0;\n  double l = 0, r = min(1.0, p[i]);\n  for (int o = 0; o < 40; o++) {\n    double c1 = (l * 2 + r) / 3;\n    double c2 = (l + 2 * r) / 3;\n    double cx1 = x1 * (1 - c1) + x2 * c1;\n    double cy1 = y3223789 * (1 - c1) + y2 * c1;\n    double cx2 = x1 * (1 - c2) + x2 * c2;\n    double cy2 = y3223789 * (1 - c2) + y2 * c2;\n    double t1 = get_time(i, cx1, cy1);\n    double t2 = get_time(i, cx2, cy2);\n    t1 -= nt * c1;\n    t2 -= nt * c2;\n    if (t1 < 0 || t2 < 0) return 1;\n    if (t1 < t2)\n      r = c2;\n    else\n      l = c1;\n  }\n  return 0;\n}\nint getans(double v) {\n  int ans = 0;\n  nt = sqrt((x2 - x1) * (x2 - x1) + (y2 - y3223789) * (y2 - y3223789)) / v;\n  for (int i = 0; i < n; i++)\n    if (check(i, v)) ans++;\n  return ans;\n}\nint main() {\n  cin >> x1 >> y3223789 >> x2 >> y2;\n  double dist = sqrt((x2 - x1) * (x2 - x1) + (y2 - y3223789) * (y2 - y3223789));\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> a0[i] >> w[i];\n    double tmp = cross(x[i] - x1, y[i] - y3223789, x[i] - x2, y[i] - y2);\n    t1[i] = get_time(i, x1, y3223789);\n    t2[i] = get_time(i, x2, y2);\n    p[i] = inter(x[i], y[i], x[i] + y2 - y3223789, y[i] + x1 - x2, x1, y3223789,\n                 x2, y2);\n    d[i] = abs(tmp) / dist;\n  }\n  int k;\n  cin >> k;\n  double tt[MAXN];\n  for (int i = 0; i < n; i++) {\n    double l = 0, r = 4000000;\n    while (r - l > 1e-5) {\n      double v = (l + r) / 2;\n      nt = sqrt((x2 - x1) * (x2 - x1) + (y2 - y3223789) * (y2 - y3223789)) / v;\n      if (check(i, v))\n        l = v;\n      else\n        r = v;\n    }\n    tt[i] = (l + r) / 2;\n  }\n  sort(tt, tt + n);\n  reverse(tt, tt + n);\n  if (k == n)\n    printf(\"%.4lf\", 0.0);\n  else\n    printf(\"%.4lf\", tt[k]);\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:60777216\")\nusing namespace std;\ndouble xa, ya, xb, yb;\nint n;\ndouble x[11111], y[11111], a[11111], w[11111];\nint k;\nconst double pi = acos(-1.);\ndouble go(double a, double w) {\n  double v = 0;\n  int num = 100;\n  for (int i(0); i < (num + 1); ++i) {\n    double x = xa + (xb - xa) * i / double(num);\n    double y = ya + (yb - ya) * i / double(num);\n    double q = atan2(y, x) - a;\n    if (q > 2 * pi) q -= 2 * pi;\n    while (q < 0) q += 2 * pi;\n    if (q > 2 * pi - q) q = 2 * pi - q;\n    double T = (w < 1e-5 ? (i == 0 ? 0 : 1e10) : q / w);\n    v = max(v, hypot(x - xa, y - ya) / T);\n  }\n  return v;\n}\nint main() {\n  cin >> xa >> ya >> xb >> yb >> n;\n  for (int i(0); i < (n); ++i)\n    scanf(\"%lf %lf %lf %lf\", x + i, y + i, a + i, w + i);\n  cin >> k;\n  vector<double> v;\n  for (int i(0); i < (n); ++i) {\n    xa -= x[i], ya -= y[i], xb -= x[i], yb -= y[i];\n    v.push_back(go(a[i], w[i]));\n    xa += x[i], ya += y[i], xb += x[i], yb += y[i];\n  }\n  sort((v).begin(), (v).end());\n  reverse(v.begin(), v.end());\n  if (k >= v.size())\n    puts(\"0.0000\");\n  else\n    printf(\"%.4lf\\n\", v[k]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 10086;\nconst double EPS = 1e-6;\nconst double PI = atan2(0.0, -1.0);\nstruct Point {\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  double abs() const { return hypot(x, y); }\n  double arg() const { return atan2(y, x); }\n};\nPoint operator+(const Point& lhs, const Point& rhs) {\n  return Point(lhs.x + rhs.x, lhs.y + rhs.y);\n}\nPoint operator-(const Point& lhs, const Point& rhs) {\n  return Point(lhs.x - rhs.x, lhs.y - rhs.y);\n}\nPoint operator*(const double& lhs, const Point& rhs) {\n  return Point(lhs * rhs.x, lhs * rhs.y);\n}\ndouble operator*(const Point& lhs, const Point& rhs) {\n  return lhs.x * rhs.x + lhs.y * rhs.y;\n}\ndouble operator%(const Point& lhs, const Point& rhs) {\n  return lhs.x * rhs.y - rhs.x * lhs.y;\n}\ndouble off(double a, double b) {\n  a -= b;\n  while (a < -PI) {\n    a += 2 * PI;\n  }\n  while (a >= PI) {\n    a -= 2 * PI;\n  }\n  return a;\n}\ndouble dis(double a, double b) { return fabs(off(a, b)); }\ndouble gao(const Point& a, const Point& b, Point p, double q, double w) {\n  double d = (b - a).abs();\n  double h = fabs((p - a) % (b - a)) / d;\n  if ((p - a) % (b - a) > 0) {\n    p = p + 2 * h / d * Point(a.y - b.y, b.x - a.x);\n    q = (b - a).arg() * 2 - q;\n  }\n  double q0 = (b - a).arg() - PI / 2;\n  double qa = off((a - p).arg(), q0);\n  double qb = off((b - p).arg(), q0);\n  double qq = off(q, q0);\n  double l = d / (dis(qq, qb) / w), r = 1e8;\n  while (r - l > EPS) {\n    double m = (l + r) / 2;\n    double qc = h * w >= m ? qb : min(qb, max(qa, -acos(sqrt(h * w / m))));\n    if (dis(qq, qc) / w <= (tan(qc) - tan(qa)) * h / m) {\n      l = m;\n    } else {\n      r = m;\n    }\n  }\n  return (l + r) / 2;\n}\nint main() {\n  int n, m;\n  Point a, b, p;\n  double q, w;\n  vector<double> v;\n  scanf(\"%lf%lf%lf%lf\", &a.x, &a.y, &b.x, &b.y);\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%lf%lf%lf%lf\", &p.x, &p.y, &q, &w);\n    v.push_back(gao(a, b, p, q, w));\n  }\n  v.push_back(0);\n  sort(v.begin(), v.end());\n  scanf(\"%d\", &m);\n  printf(\"%.10lf\\n\", v[n - m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.00), eps = 1e-9;\nstruct point {\n  double x, y, w, a;\n};\npoint st, en, tank[11111];\nint n, k;\nvoid norm(double &theta) {\n  while (theta < -pi + eps) theta += 2 * pi;\n  while (theta > pi + eps) theta -= 2 * pi;\n}\nbool check(double v) {\n  int i, j, s, p, q, nk = 0, it;\n  double now_t, theta, dist, T, w;\n  double ltheta, low, high, mid, mt, vs, fs, bs, mx, my, fx, fy;\n  bool ft;\n  dist = sqrt((en.x - st.x) * (en.x - st.x) + (en.y - st.y) * (en.y - st.y));\n  T = dist / v;\n  for (i = 0; i < n; i++) {\n    theta = atan2(en.y - tank[i].y, en.x - tank[i].x);\n    while (theta < tank[i].a - eps) theta += 2 * pi;\n    theta -= tank[i].a;\n    if (theta > pi) theta = 2 * pi - theta;\n    now_t = theta / tank[i].w;\n    if (v * now_t <\n        sqrt((en.x - st.x) * (en.x - st.x) + (en.y - st.y) * (en.y - st.y))) {\n      nk++;\n      continue;\n    }\n    ltheta = atan2(st.y - tank[i].y, st.x - tank[i].x);\n    if (tank[i].w == 0)\n      continue;\n    else {\n      while (ltheta < tank[i].a - eps) ltheta += 2 * pi;\n      ltheta -= tank[i].a;\n      w = tank[i].w;\n      if (ltheta > pi) {\n        w = -w;\n        ltheta = 2 * pi - ltheta;\n      }\n      theta = atan2(en.y - st.y, en.x - st.x);\n      low = ltheta / tank[i].w;\n      high = T;\n      if (low > high) continue;\n      mt = low;\n      fs = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      mt = high;\n      bs = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      if ((fs < eps && bs > -eps) || (fs > -eps && bs < eps)) {\n        nk++;\n        continue;\n      }\n      for (it = 0; it < 100; it++) {\n        mx = mt = (2 * low + high) / 3.;\n        fx =\n            (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n            (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n        my = mt = (low + 2 * high) / 3.;\n        fy =\n            (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n            (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n        if ((fs > 0 && fx > fy) || (fs < 0 && fx < fy))\n          low = mx;\n        else\n          high = my;\n      }\n      mt = 0.5 * (low + high);\n      fx = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      if ((fs > 0 && fx < eps) || (fs < 0 && fx > -eps)) {\n        nk++;\n        continue;\n      }\n    }\n  }\n  return nk <= k;\n}\nint main() {\n  int i, j, s, p, q;\n  double low, high, mid;\n  scanf(\"%lf%lf%lf%lf\", &st.x, &st.y, &en.x, &en.y);\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%lf%lf%lf%lf\", &tank[i].x, &tank[i].y, &tank[i].a, &tank[i].w);\n    norm(tank[i].a);\n  }\n  scanf(\"%d\", &k);\n  low = 0;\n  high = 1e9;\n  while (low < high - eps) {\n    mid = (low + high) * 0.5;\n    if (check(mid))\n      high = mid;\n    else\n      low = mid + eps;\n  }\n  printf(\"%.20f\\n\", (low + high) * 0.5);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nT abs(T x) {\n  return x > 0 ? x : -x;\n}\nconst double pi = 2 * asin(1.0);\nint n;\nint m;\ndouble x[10000], y[10000], a[10000], w[10000];\ndouble ax, ay, bx, by;\ndouble dist(double x1, double y8687969, double x2, double y2) {\n  return sqrt(\n      abs(((x2 - x1) * (x2 - x1)) + ((y2 - y8687969) * (y2 - y8687969))));\n}\ndouble get(int i, double x, double y) {\n  double b = atan2(y - ::y[i], x - ::x[i]);\n  double ang = abs(a[i] - b);\n  if (ang > 2 * pi) ang -= 2 * pi;\n  return min(ang, 2 * pi - ang) / w[i];\n}\ndouble cross(double x1, double y8687969, double x2, double y2, double x3,\n             double y3, double x4, double y4) {\n  double a = x2 - x1;\n  double b = x3 - x4;\n  double c = x3 - x1;\n  double d = y2 - y8687969;\n  double e = y3 - y4;\n  double f = y3 - y8687969;\n  return (c * e - b * f) / (a * e - b * d);\n}\nint calc(double v) {\n  int tmp = 0;\n  double d = dist(ax, ay, bx, by);\n  double dx = (bx - ax);\n  double dy = (by - ay);\n  double t = d / v;\n  for (int i = 0; i < n; i++) {\n    if (w[i] < 1e-6) continue;\n    if (get(i, bx, by) < t)\n      tmp++;\n    else {\n      double l = 0,\n             r = max(0.0, min(1.0, cross(ax, ay, bx, by, x[i], y[i],\n                                         x[i] + (by - ay), y[i] + (ax - bx))));\n      for (int it = 0; it < 40; it++) {\n        double s1 = (2 * l + r) / 3;\n        double s2 = (l + 2 * r) / 3;\n        double d1 = get(i, ax + dx * s1, ay + dy * s1) - t * s1;\n        double d2 = get(i, ax + dx * s2, ay + dy * s2) - t * s2;\n        if (d1 < d2)\n          r = s2;\n        else\n          l = s1;\n      }\n      double ss = (l + r) / 2;\n      double dd = get(i, ax + dx * ss, ay + dy * ss) - t * ss;\n      if (dd < 0) tmp++;\n    }\n  }\n  return tmp;\n}\nint main() {\n  cin >> ax >> ay >> bx >> by >> n;\n  for (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> a[i] >> w[i];\n  cin >> m;\n  double l = 0, r = 1e10;\n  for (int it = 0; it < 60; it++) {\n    double s = (l + r) / 2;\n    if (calc(s) <= m)\n      r = s;\n    else\n      l = s;\n  }\n  printf(\"%.10f\\n\", r);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<double, double> operator-(pair<double, double> a, pair<double, double> b) {\n  return pair<double, double>(a.first - b.first, a.second - b.second);\n}\npair<double, double> st, dir;\ndouble _w, _s, _len;\ninline double f(double t) {\n  double first = st.first + dir.first * t, second = st.second + dir.second * t;\n  double r = atan2(second, first) - _s;\n  while (r < 0) {\n    r += 2 * M_PI;\n  }\n  while (r > 2 * M_PI) {\n    r -= 2 * M_PI;\n  }\n  return _len * t * _w / min(r, 2 * M_PI - r);\n}\ndouble get(pair<double, double> a, pair<double, double> b, double s, double w) {\n  st = a;\n  dir = b - a;\n  _s = s;\n  _w = w;\n  _len = hypot(dir.first, dir.second);\n  double res = 0;\n  for (int i = 0; i <= 100; i++) {\n    double t = f(i / 100.);\n    if (t > res) {\n      res = t;\n    }\n  }\n  return res;\n}\nvoid read(pair<double, double> &p) {\n  double first, second;\n  scanf(\"%lf%lf\", &first, &second);\n  p.first = first;\n  p.second = second;\n}\nint main(void) {\n  pair<double, double> a, b;\n  read(a);\n  read(b);\n  int n;\n  scanf(\"%d\", &n);\n  vector<double> v(1, 0);\n  for (int i = 0; i < n; i++) {\n    pair<double, double> p;\n    read(p);\n    double s, w;\n    scanf(\"%lf%lf\", &s, &w);\n    v.push_back(get(a - p, b - p, s, w));\n  }\n  sort(v.begin(), v.end());\n  reverse(v.begin(), v.end());\n  int k;\n  scanf(\"%d\", &k);\n  printf(\"%.20lf\\n\", v[k]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:60777216\")\nusing namespace std;\ndouble xa, ya, xb, yb;\nint n;\ndouble x[11111], y[11111], a[11111], w[11111];\nint k;\nconst double pi = acos(-1.);\ndouble go(double a, double w) {\n  double v = 0;\n  int num = 1000;\n  for (int i(0); i < (num + 1); ++i) {\n    double x = xa + (xb - xa) * i / double(num);\n    double y = ya + (yb - ya) * i / double(num);\n    double q = atan2(y, x) - a;\n    if (q > 2 * pi) q -= 2 * pi;\n    while (q < 0) q += 2 * pi;\n    if (q > 2 * pi - q) q = 2 * pi - q;\n    double T = (w < 1e-5 ? (i == 0 ? 0 : 1e10) : q / w);\n    v = max(v, hypot(x - xa, y - ya) / T);\n  }\n  return v;\n}\nint main() {\n  cin >> xa >> ya >> xb >> yb >> n;\n  for (int i(0); i < (n); ++i)\n    scanf(\"%lf %lf %lf %lf\", x + i, y + i, a + i, w + i);\n  cin >> k;\n  vector<double> v;\n  for (int i(0); i < (n); ++i) {\n    xa -= x[i], ya -= y[i], xb -= x[i], yb -= y[i];\n    v.push_back(go(a[i], w[i]));\n    xa += x[i], ya += y[i], xb += x[i], yb += y[i];\n  }\n  sort((v).begin(), (v).end());\n  reverse(v.begin(), v.end());\n  if (k >= v.size())\n    puts(\"0.0000\");\n  else\n    printf(\"%.4lf\\n\", v[k]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi2 = acos(-1.0) * 2;\ndouble g(double x, double y, double a, double v) {\n  double c = atan2(y, x) - a;\n  for (; c >= pi2; c -= pi2)\n    ;\n  for (; c < 0; c += pi2)\n    ;\n  return min(c, pi2 - c) / v;\n}\ndouble f(double x0, double y0, double x1, double y1, double a, double v) {\n  double dx = x1 - x0, dy = y1 - y0, d = sqrt(dx * dx + dy * dy);\n  double res = 1 / g(x1, y1, a, v);\n  for (double t = 1e-4; t < 1; t += 2e-4)\n    res = max(res, t / g(x0 + dx * t, y0 + dy * t, a, v));\n  double L = 1e-4, R = 1, l, r, fl, fr;\n  for (int k(0); k < 256; ++k) {\n    l = (L * 2 + R) / 3;\n    r = (L + R * 2) / 3;\n    fl = l / g(x0 + dx * l, y0 + dy * l, a, v);\n    fr = r / g(x0 + dx * r, y0 + dy * r, a, v);\n    if (fl < fr) {\n      res = max(res, fr);\n      L = l;\n    } else {\n      res = max(res, fl);\n      R = r;\n    }\n  }\n  return d * res;\n}\nint main() {\n  double Ax, Ay, Bx, By;\n  int n;\n  cin >> Ax >> Ay >> Bx >> By >> n;\n  vector<double> v;\n  for (int i(0); i < n; ++i) {\n    double x, y, a, w;\n    scanf(\"%lf%lf%lf%lf\", &x, &y, &a, &w);\n    v.push_back(f(Ax - x, Ay - y, Bx - x, By - y, a, w));\n  }\n  sort(v.rbegin(), v.rend());\n  v.push_back(0);\n  cin >> n;\n  printf(\"%.12lf\\n\", v[n]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.00), eps = 1e-9;\nstruct point {\n  double x, y, w, a;\n};\npoint st, en, tank[11111];\nint n, k;\nvoid norm(double &theta) {\n  while (theta < -pi + eps) theta += 2 * pi;\n  while (theta > pi + eps) theta -= 2 * pi;\n}\nbool check(double v) {\n  int i, j, s, p, q, nk = 0, it;\n  double now_t, theta, dist, T, w;\n  double ltheta, low, high, mid, mt, vs, fs, bs, mx, my, fx, fy;\n  bool ft;\n  dist = sqrt((en.x - st.x) * (en.x - st.x) + (en.y - st.y) * (en.y - st.y));\n  T = dist / v;\n  for (i = 0; i < n; i++) {\n    theta = atan2(en.y - tank[i].y, en.x - tank[i].x);\n    while (theta < tank[i].a - eps) theta += 2 * pi;\n    theta -= tank[i].a;\n    if (theta > pi) theta = 2 * pi - theta;\n    now_t = theta / tank[i].w;\n    if (v * now_t <\n        sqrt((en.x - st.x) * (en.x - st.x) + (en.y - st.y) * (en.y - st.y))) {\n      nk++;\n      continue;\n    }\n    ltheta = atan2(st.y - tank[i].y, st.x - tank[i].x);\n    theta = ltheta;\n    while (theta < tank[i].a - eps) theta += 2 * pi;\n    theta -= tank[i].a;\n    if (theta > pi) theta = 2 * pi - theta;\n    now_t = theta / tank[i].w;\n    if (v * now_t >\n        sqrt((en.x - st.x) * (en.x - st.x) + (en.y - st.y) * (en.y - st.y)))\n      continue;\n    if (tank[i].w == 0)\n      continue;\n    else {\n      while (ltheta < tank[i].a - eps) ltheta += 2 * pi;\n      ltheta -= tank[i].a;\n      w = tank[i].w;\n      if (ltheta > pi) {\n        w = -w;\n        ltheta = 2 * pi - ltheta;\n      }\n      theta = atan2(en.y - st.y, en.x - st.x);\n      low = ltheta / tank[i].w;\n      high = T;\n      if (low > high) continue;\n      mt = low;\n      fs = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      mt = high;\n      bs = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      if ((fs < eps && bs > -eps) || (fs > -eps && bs < eps)) {\n        nk++;\n        continue;\n      }\n      for (it = 0; it < 100; it++) {\n        mx = mt = (2 * low + high) / 3.;\n        fx =\n            (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n            (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n        my = mt = (low + 2 * high) / 3.;\n        fy =\n            (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n            (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n        if ((fs > 0 && fx > fy) || (fs < 0 && fx < fy))\n          low = mx;\n        else\n          high = my;\n      }\n      mt = 0.5 * (low + high);\n      fx = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      if ((fs > 0 && fx < eps) || (fs < 0 && fx > -eps)) {\n        nk++;\n        continue;\n      }\n    }\n  }\n  if (v == 8) printf(\"nk=%d\\n\", nk);\n  return nk <= k;\n}\nint main() {\n  int i, j, s, p, q;\n  double low, high, mid;\n  scanf(\"%lf%lf%lf%lf\", &st.x, &st.y, &en.x, &en.y);\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%lf%lf%lf%lf\", &tank[i].x, &tank[i].y, &tank[i].a, &tank[i].w);\n    norm(tank[i].a);\n  }\n  scanf(\"%d\", &k);\n  low = 0;\n  high = 1e9;\n  while (low < high - eps) {\n    mid = (low + high) * 0.5;\n    if (check(mid))\n      high = mid;\n    else\n      low = mid + eps;\n  }\n  printf(\"%.20f\\n\", (low + high) * 0.5);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble prodvec(complex<double> p1, complex<double> p2) {\n  return imag(conj(p1) * p2);\n}\ndouble prodesc(complex<double> p1, complex<double> p2) {\n  return real(conj(p1) * p2);\n}\nconst int limite = 20000;\ndouble error = 1e-7;\ndouble computa(complex<double> p, complex<double> direccion, double w,\n               double b) {\n  complex<double> pb(b, 0);\n  double tb = abs(arg((pb - p) / direccion)) / w;\n  double sol = b / tb;\n  double x = real(p);\n  double y = imag(p);\n  if (x <= 0) return sol;\n  double inf = sol;\n  double sup = 1000000000;\n  while (inf + error < sup) {\n    double med = (inf + sup) / 2.0;\n    if (med * y / w < y * y) {\n      sup = med;\n    } else {\n      complex<double> corte(x - sqrt(med * y / w - y * y), 0.0);\n      if (real(corte) < 0 or real(corte) > b)\n        sup = med;\n      else {\n        double t = abs(arg((corte - p) / direccion)) / w;\n        double tt = real(corte) / med;\n        if (tt < t)\n          sup = med;\n        else\n          inf = med;\n      }\n    }\n  }\n  return inf;\n}\ncomplex<double> pa, pb;\nint n;\ncomplex<double> p[100000];\ncomplex<double> vp[100000];\ndouble w[100000];\nint k;\ncomplex<double> leer() {\n  double x, y;\n  cin >> x >> y;\n  return complex<double>(x, y);\n}\nint main() {\n  cout.setf(ios::fixed);\n  cout.precision(10);\n  pa = leer();\n  pb = leer();\n  complex<double> divi = pb - pa;\n  divi = divi / abs(divi);\n  cin >> n;\n  vector<double> v;\n  for (int i = 0; i < n; i++) {\n    p[i] = leer();\n    double a;\n    cin >> a;\n    vp[i] = polar(1.0, a);\n    cin >> w[i];\n    p[i] -= pa;\n    p[i] = p[i] / divi;\n    vp[i] = vp[i] / divi;\n    if (imag(p[i]) < 0) {\n      p[i] = conj(p[i]);\n      vp[i] = conj(vp[i]);\n    }\n    v.push_back(computa(p[i], vp[i], w[i], abs(pb - pa)));\n  }\n  cin >> k;\n  sort(v.begin(), v.end());\n  if (k >= int(v.size()))\n    cout << 0.0 << endl;\n  else\n    cout << v[int(v.size()) - 1 - k] << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class F {\n\tpublic static void main(String[] args) throws Exception{\n\t\tScanner in = new Scanner(System.in);\n\t\tst = new Point(in.nextDouble(), in.nextDouble());\n\t\ten = new Point(in.nextDouble(), in.nextDouble());\n\t\tN = in.nextInt();\n\t\tT = new Tank[N];\n\t\tfor(int i = 0; i < N;i++)\n\t\t\tT[i] = new Tank(in.nextDouble(), in.nextDouble(), in.nextDouble(), in.nextDouble());\n\t\tK = in.nextInt();\n\t\ten = en.sub(st);\n\t\tdouble ang = en.ang();\n\t\ten = en.rot(-ang);\n\t\tfor(Tank t:T){\n\t\t\tt.p = t.p.sub(st).rot(-ang);\n\t\t\tt.a = normang(t.a-ang);\n\t\t\t\n\t\t\tif(t.p.y > 0){\n\t\t\t\tt.p.y = -t.p.y;\n\t\t\t\tt.a = normang(2*PI-t.a);\n\t\t\t}\n\t\t}\n\t\tst = st.sub(st);\n\t\tX = en.x;\n\t\tdouble low = 0;\n\t\tdouble high = Long.MAX_VALUE;\n\t\tfor(int i = 0; i < 100;i++){\n\t\t\tdouble mid = (low+high)/2;\n\t\t\tif(safe(mid))\n\t\t\t\thigh = mid;\n\t\t\telse\n\t\t\t\tlow = mid;\n\t\t}\n\t\tSystem.out.format(\"%.015f\\n\", low);\n\t}\n\tprivate static boolean safe(double v) {\n\t\tint hit = 0;\n\t\tLine l = new Line(st, en);\n\t\tfor(Tank t:T){\n\t\t\tdouble toend = abs(angdiff(en.sub(t.p).ang(), t.a))/t.w;\n\t\t\tif(toend <= X/v){\n\t\t\t\thit++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble dist = pointlinedist(t.p, l);\n\t\t\tif(dist*t.w/v > 1)\n\t\t\t\tcontinue;\n\t\t\tdouble theta1 = asin(sqrt(dist*t.w/v));\n\t\t\tdouble theta2 = (PI-asin(sqrt(dist*t.w/v)));\n\t\t\tdouble x1 = t.p.x + dist*cos(theta1)/sin(theta1);\n\t\t\tdouble t1 = abs(angdiff(theta1, t.a))/t.w;\n\t\t\tif(0 <= x1 && x1 <= X && t1 <= x1/v){\n\t\t\t\thit++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble x2 = t.p.x + dist*cos(theta2)/sin(theta2);\n\t\t\tdouble t2 = abs(angdiff(theta2, t.a))/t.w;\n\t\t\tif(0 <= x2 && x2 <= X && t2 <= x2/v){\n\t\t\t\thit++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn hit <= K;\n\t}\n\tstatic int N, K;\n\tstatic Tank[] T;\n\tstatic Point st, en;\n\tstatic double X;\n\tstatic class Tank{\n\t\tPoint p;\n\t\tdouble a, w;\n\t\tpublic Tank(double x, double y, double a, double w){\n\t\t\tp = new Point(x, y);\n\t\t\tthis.a = a;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\n\n\n\n\n\n\tstatic double eps = 1e-9;\n\tstatic boolean EQ(double a, double b){return abs(a-b) < eps;}\n\tstatic double SQ(double d){return d*d;}\n\tstatic double normang(double t){ return ((t % (2*PI)) + 2*PI) % (2*PI); }\n\tstatic double angdiff(double t1, double t2){ return normang(t1 - t2 + PI) - PI; }\n\tstatic ArrayList<Point> makeVec(Point...P){\n\t\tArrayList<Point> ans = new ArrayList<Point>();\n\t\tfor(Point p:P)\n\t\t\tans.add(p);\n\t\treturn ans;\n\t}\n\tstatic class Point{\n\t\tdouble x, y;\n\t\tpublic Point(double x, double y){this.x = x;this.y = y;}\n\t\tPoint add(Point p){return new Point(x+p.x, y+p.y);}\n\t\tPoint sub(Point p){return new Point(x-p.x, y-p.y);}\n\t\tPoint mult(double d){return new Point(x*d, y*d);}\n\t\tdouble dot(Point p){return x*p.x+ y*p.y;}\n\t\tdouble cross(Point p){return x*p.y - y*p.x;}\n\t\tdouble len(){return hypot(x, y);}\n\t\tPoint scale(double d){return mult(d/len());}\n\t\tdouble dist(Point p){return sub(p).len();}\n\t\tdouble ang(){return atan2(y, x);}\n\t\tstatic Point polar(double r, double theta){return new Point(r*cos(theta), r*sin(theta));}\n\t\tPoint rot(double theta){return new Point(x*cos(theta)-y*sin(theta), x*sin(theta)+y*cos(theta));}\n\t\tPoint perp(){return new Point(-y, x);}\n\t\tboolean equals(Point p){return EQ(0, dist(p));}\n\t\tdouble norm(){return dot(this);}\n\t\tpublic String toString(){return String.format(\"(%.03f, %.03f)\", x, y);}\n\t}\t\n\tstatic class Line{\n\t\tPoint a, b;\n\t\tLine(Point a, Point b){this.a = a;this.b = b;}\n\t\tpublic String toString(){return String.format(\"{%s -> %s}\", a, b);}\n\t}\n\tstatic class Circle{\n\t\tPoint p;double r;\n\t\tpublic Circle(Point p, double r){this.p = p;this.r = r;}\n\t\tpublic Circle(Point a, Point b, Point c){\n\t\t\tPoint p1 = a.add(b).mult(0.5);\n\t\t\tLine l1 = new Line(p1, p1.add(a.sub(b).perp()));\n\t\t\tPoint p2 = b.add(c).mult(0.5);\n\t\t\tLine l2 = new Line(p2, p2.add(b.sub(c).perp()));\n\t\t\tp = lineline(l1, l2);\n\t\t\tassert(p != null);\n\t\t\tr = p.dist(a);\n\t\t}\n\t}\n\tstatic double ccw(Point p1, Point p2, Point p3){\n\t\treturn p2.sub(p1).cross(p3.sub(p1));\n\t}\n\tstatic Point lineline(Line a, Line b){//tested\n\t\tdouble d = a.b.sub(a.a).cross(b.b.sub(b.a));\n\t\tif(EQ(d, 0))\n\t\t\treturn null;\n\t\treturn a.a.add((a.b.sub(a.a)).mult(b.b.sub(b.a).cross(a.a.sub(b.a))/d));\n\t}\n\tstatic Point segline(Line a, Line b){\n\t\tPoint inter = lineline(a, b);\n\t\tif(inter == null || !onseg(a, inter))\n\t\t\treturn null;\n\t\treturn inter;\n\t}\n\tstatic Point segseg(Line a, Line b){//tested\n\t\tPoint inter = lineline(a, b);\n\t\tif(inter == null || !onseg(a, inter) || !onseg(b, inter))\n\t\t\treturn null;\n\t\treturn inter;\n\t}\n\tstatic boolean onseg(Line l, Point p){ //tested\n\t\tPoint delta = l.b.sub(l.a);\n\t\treturn online(l, p) && delta.dot(l.a)-eps <= delta.dot(p) && delta.dot(p) <= delta.dot(l.b)+eps;\n\t}\n\tstatic boolean online(Line l, Point p){ //tested\n\t\treturn EQ(ccw(l.a, l.b, p), 0);\n\t}\n\tstatic Point pointline(Point p, Line l){\n\t\tPoint v = l.b.sub(l.a).scale(1);\n\t\tdouble dot = p.sub(l.a).dot(v);\n\t\treturn l.a.add(v.mult(dot));\n\t}\n\tstatic Point pointseg(Point p, Line l){\n\t\tPoint v = l.b.sub(l.a).scale(1);\n\t\tdouble dot = p.sub(l.a).dot(v);\n\t\tdot = max(dot, 0);\n\t\tdot = min(dot, l.b.dist(l.a));\n\t\treturn l.a.add(v.mult(dot));\n\t}\n\tstatic double pointsegdist(Point p, Line l){\n\t\treturn pointseg(p, l).dist(p);\n\t}\n\tstatic double pointlinedist(Point p, Line l){\n\t\treturn pointline(p, l).dist(p);\n\t}\n\n\tstatic double polyarea(Point[] poly){\n\t\tdouble area = 0;\n\t\tfor(int i = 0; i < poly.length; i++)\n\t\t\tarea += poly[i].cross(poly[(i+1)%poly.length]);\n\t\treturn abs(area)/2.0;\n\t}\n\tstatic int pointinpoly(Point[] poly, Point p){\n\t\tdouble ang = 0.0;\n\t\tfor(int i = 0; i < poly.length; i++){\n\t\t\tPoint a = poly[i];\n\t\t\tPoint b = poly[(i+1)%poly.length];\n\t\t\tif(onseg(new Line(a, b), p))\n\t\t\t\treturn 0;\n\t\t\tang += angdiff(a.sub(p).ang(), b.sub(p).ang());\n\t\t}\n\t\treturn EQ(ang, 0) ? -1 : 1;\n\t}\n\n\tstatic Point v0;\n\tstatic ArrayList<Point> convexhull(ArrayList<Point> P){//tested\n\t\tv0 = null;\n\t\tfor(Point p:P)\n\t\t\tif(v0 == null || p.x < v0.x - eps || (EQ(p.x, v0.x) && p.y < v0.y))\n\t\t\t\tv0 = p;\n\t\tCollections.sort(P, new Comparator<Point>(){\n\t\t\tpublic int compare(Point a, Point b){\n\t\t\t\tif(a == v0) return -1;\n\t\t\t\tif(b == v0) return 1;\n\t\t\t\tdouble ccw = ccw(v0, a, b);\n\t\t\t\tif(EQ(ccw, 0)){\n\t\t\t\t\tdouble d1 = v0.dist(a);\n\t\t\t\t\tdouble d2 = v0.dist(b);\n\t\t\t\t\tif(d1 < d2) return -1;\n\t\t\t\t\tif(d1 > d2) return 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn (int) -signum(ccw);\n\t\t\t}});\n\t\tArrayList<Point> ch = new ArrayList<Point>();\n\t\tfor(Point p:P){\n\t\t\twhile(ch.size() >= 2 && ccw(ch.get(ch.size()-2), ch.get(ch.size()-1), p) <= 0)\n\t\t\t\tch.remove(ch.size()-1);\n\t\t\tch.add(p);\n\t\t}\n\t\treturn ch;\n\t}\n\t//add half space intersection\n\n\t//circle\n\tstatic ArrayList<Point> circline(Circle c, Line l){\n\t\tPoint x = pointline(c.p, l);\n\t\tdouble d = x.dist(c.p);\n\t\tif(d > c.r + eps) return new ArrayList<Point>();\n\t\tdouble h = sqrt(SQ(c.r) - SQ(d));\n\t\tPoint v = x.sub(c.p);\n\t\treturn makeVec(c.p.add(v.scale(d)).add(v.scale(h)), c.p.add(v.scale(d)).add(v.scale(-h)));\n\t}\n\tstatic ArrayList<Point> circcirc(Circle a, Circle b){\n\t\tdouble d = a.p.dist(b.p);\n\t\tif(d > a.r + b.r + eps) return new ArrayList<Point>();\n\t\tif(d < abs(a.r - b.r) - eps) return new ArrayList<Point>();\n\t\tdouble x = (SQ(d) - SQ(b.r) + SQ(a.r)) / 2*d;\n\t\tdouble y = sqrt(SQ(a.r) - SQ(x));\n\t\tPoint v = b.p.sub(a.p);\n\t\treturn makeVec(a.p.add(v.scale(x)).add(v.perp().scale(y)), a.p.add(v.scale(x)).add(v.perp().scale(-y)));\n\t}\n\tstatic ArrayList<Line> circcirctan(Circle a, Circle b){//tested\n\t\tif(a.r < b.r)\n\t\t\treturn circcirctan(b, a);\n\t\tArrayList<Line> res = new ArrayList<Line>();\n\t\tdouble d = a.p.dist(b.p);\n\t\tdouble d1 = a.r*d/(a.r + b.r);\n\t\tdouble t = acos(a.r/d1);\n\t\tPoint v = b.p.sub(a.p);\n\t\tres.add(new Line(a.p.add(v.scale(a.r).rot(t)), b.p.add(v.scale(-b.r).rot(t))));\n\t\tres.add(new Line(a.p.add(v.scale(a.r).rot(-t)), b.p.add(v.scale(-b.r).rot(-t))));   \n\t\tt = asin((a.r-b.r)/d)+PI/2;\n\t\tv = a.p.sub(b.p);\n\t\tres.add(new Line(a.p.add(v.scale(a.r).rot(t)), b.p.add(v.scale(b.r).rot(t))));\n\t\tres.add(new Line(a.p.add(v.scale(a.r).rot(-t)), b.p.add(v.scale(b.r).rot(-t)))); \n\t\treturn res;\n\t}\n\n\t//3d\n\tstatic class Point3{\n\t\tdouble x, y, z;\n\t\tPoint3(double x, double y, double z) {  this.x = x; this.y = y; this.z = z; }\n\t\tstatic Point3 sphere(double theta, double phi, double r){\n\t\t\treturn new Point3(r*cos(theta)*sin(phi),r*sin(theta)*sin(phi),r*cos(theta));\n\t\t}\n\t\tdouble[] ang(){ return new double[]{atan(y/x), acos(z/len())}; }\n\t\tPoint proj(){ return new Point(x, y); }\n\t\tPoint3 add(Point3 p){ return new Point3(x+p.x, y+p.y, z+p.z); }\n\t\tPoint3 sub(Point3 p){ return new Point3(x-p.x, y-p.y, z-p.z); }\n\t\tdouble dot(Point3 p){ return x*p.x+ y*p.y+ z*p.z; }\n\t\tPoint3 cross(Point3 p){ return new Point3(y*p.z-p.y*z, z*p.x-p.z*x, x*p.y-p.x*y); }\n\t\tPoint3 mult(double d){ return new Point3(x*d, y*d, z*d); }\n\t\tdouble len(){ return sqrt(x*x+y*y+z*z); }\n\t\tPoint3 scale(double d){ return mult(d/len()); }\n\t\tdouble dist(Point3 p){ return sub(p).len(); } \n\t\tboolean equals(Point3 p){ return EQ(dist(p), 0); }\n\t}\n\tstatic Point3[] getbasis(Point3 z){\n\t\tz = z.scale(1);\n\t\tPoint3 t = new Point3(1, 0, 0);\n\t\tPoint3 y = z.cross(t);\n\t\tif(EQ(y.len(), 0)){\n\t\t\tt = new Point3(0, 1, 0);\n\t\t\ty = z.cross(t);\n\t\t}\n\t\tPoint3 x = y.cross(z);\n\t\tassert(x.cross(y).equals(z));\n\t\treturn new Point3[]{x, y, z};\n\t}\n\tstatic Point3 trans(Point3[] B, Point3 p){\n\t\treturn new Point3(B[0].dot(p), B[1].dot(p), B[2].dot(p));\n\t}\n\tstatic Point3 invtrans(Point3[] B, Point3 p){\n\t\treturn B[0].mult(p.x).add(B[1].mult(p.y)).add(B[2].mult(p.z));\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Tanks implements Runnable {\n    class Point {\n        int x;\n        int y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n    }\n\n    Point readPoint() throws IOException {\n        int x = nextInt();\n        int y = nextInt();\n        return new Point(x, y);\n    }\n\n    private void solve() throws IOException {\n        Point A = readPoint();\n        Point B = readPoint();\n        int n = nextInt();\n        Point[] tank = new Point[n];\n        double[] alpha = new double[n];\n        double[] w = new double[n];\n        for (int i = 0; i < n; ++i) {\n            tank[i] = readPoint();\n            alpha[i] = nextDouble();\n            if (alpha[i] > Math.PI) alpha[i] -= 2 * Math.PI;\n            w[i] = nextDouble();\n        }\n        int canSuffer = nextInt();\n        double[] maxHit = new double[n + 1];\n        for (int i = 0; i < n; ++i) {\n            maxHit[i] = processTank(A, B, tank[i], alpha[i], w[i]);\n        }\n        Arrays.sort(maxHit);\n        writer.println(maxHit[n - canSuffer]);\n    }\n\n    private double processTank(Point A, Point B, Point tank, double alpha, double w) {\n        if (w == 0)\n            return 0;\n        return Math.max(process(A, B, tank, alpha, w), process(A, B, tank, alpha, -w));\n    }\n\n    private double process(Point a, Point b, Point tank, double alpha, double w) {\n        double alphaA = Math.atan2(a.y - tank.y, a.x - tank.x);\n        double alphaB = Math.atan2(b.y - tank.y, b.x - tank.x);\n        if (Math.signum(alphaA - alpha) != Math.signum(w)) alphaA += Math.PI * 2 * Math.signum(w);\n        if (Math.signum(alphaB - alpha) != Math.signum(w)) alphaB += Math.PI * 2 * Math.signum(w);\n        double tA = (alphaA - alpha) / w;\n        double tB = (alphaB - alpha) / w;\n        double dy = b.y - a.y;\n        double dx = b.x - a.x;\n        double dist = Math.sqrt(dx * dx + dy * dy);\n        if (tB <= tA) {\n            return dist / tB;\n        } else {\n            double best = 0;\n            double bestVal = 0;\n            double res = dist / tB;\n            for (int i = 0; i <= 100; ++i) {\n                double middle = i / 100.0;\n                double x = a.x + middle * dx;\n                double y = a.y + middle * dy;\n                double alphaM2 = Math.atan2(y - tank.y, x - tank.x);\n                if (Math.signum(alphaM2 - alpha) != Math.signum(w)) alphaM2 += Math.PI * 2 * Math.signum(w);\n                double tM = (alphaM2 - alpha) / w;\n                double cur = middle * dist / tM;\n                res = Math.max(res, cur);\n                if (cur > bestVal) {\n                    bestVal = cur;\n                    best = middle;\n                }\n            }\n            double left = Math.max(0, best - 0.03);\n            double right = Math.min(1, best + 0.03);\n            for (int i = 0; i < 300; ++i) {\n                double middle2;\n                double tM2;\n                {\n                    middle2 = (left + 2 * right) / 3;\n                    double x = a.x + middle2 * dx;\n                    double y = a.y + middle2 * dy;\n                    double alphaM2 = Math.atan2(y - tank.y, x - tank.x);\n                    if (Math.signum(alphaM2 - alpha) != Math.signum(w)) alphaM2 += Math.PI * 2 * Math.signum(w);\n                    tM2 = (alphaM2 - alpha) / w;\n                }\n                double middle1;\n                double tM1;\n                {\n                    middle1 = (2 * left + right) / 3;\n                    double x = a.x + middle1 * dx;\n                    double y = a.y + middle1 * dy;\n                    double alphaM1 = Math.atan2(y - tank.y, x - tank.x);\n                    if (Math.signum(alphaM1 - alpha) != Math.signum(w)) alphaM1 += Math.PI * 2 * Math.signum(w);\n                    tM1 = (alphaM1 - alpha) / w;\n                }\n                double valM1 = dist * middle1 / tM1;\n                double valM2 = dist * middle2 / tM2;\n                res = Math.max(res, valM1);\n                res = Math.max(res, valM2);\n                if (valM1 > valM2) {\n                    right = middle2;\n                } else {\n                    left = middle1;\n                }\n            }\n            return res;\n        }\n    }\n\n    public static void main(String[] args) {\n        new Tanks().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    public void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.00), eps = 1e-9;\nstruct point {\n  double x, y, w, a;\n};\npoint st, en, tank[11111];\nint n, k;\nvoid norm(double &theta) {\n  while (theta < -pi + eps) theta += 2 * pi;\n  while (theta > pi + eps) theta -= 2 * pi;\n}\nbool check(double v) {\n  int i, j, s, p, q, nk = 0, it;\n  double now_t, theta, dist, T, w;\n  double ltheta, low, high, mid, mt, vs, fs, bs, mx, my, fx, fy;\n  bool ft;\n  dist = sqrt((en.x - st.x) * (en.x - st.x) + (en.y - st.y) * (en.y - st.y));\n  T = dist / v;\n  for (i = 0; i < n; i++) {\n    theta = atan2(en.y - tank[i].y, en.x - tank[i].x);\n    while (theta < tank[i].a - eps) theta += 2 * pi;\n    theta -= tank[i].a;\n    if (theta > pi) theta = 2 * pi - theta;\n    now_t = theta / tank[i].w;\n    if (v * now_t <\n        sqrt((en.x - st.x) * (en.x - st.x) + (en.y - st.y) * (en.y - st.y))) {\n      nk++;\n      continue;\n    }\n    ltheta = atan2(st.y - tank[i].y, st.x - tank[i].x);\n    theta = ltheta;\n    while (theta < tank[i].a - eps) theta += 2 * pi;\n    theta -= tank[i].a;\n    if (theta > pi) theta = 2 * pi - theta;\n    now_t = theta / tank[i].w;\n    if (v * now_t >\n        sqrt((en.x - st.x) * (en.x - st.x) + (en.y - st.y) * (en.y - st.y)))\n      continue;\n    if (tank[i].w == 0)\n      continue;\n    else {\n      while (ltheta < tank[i].a - eps) ltheta += 2 * pi;\n      ltheta -= tank[i].a;\n      w = tank[i].w;\n      if (ltheta > pi) {\n        w = -w;\n        ltheta = 2 * pi - ltheta;\n      }\n      theta = atan2(en.y - st.y, en.x - st.x);\n      low = ltheta / tank[i].w;\n      high = T;\n      if (low > high) continue;\n      mt = low;\n      fs = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      mt = high;\n      bs = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      if ((fs < eps && bs > -eps) || (fs > -eps && bs < eps)) {\n        nk++;\n        continue;\n      }\n      for (it = 0; it < 100; it++) {\n        mx = mt = (2 * low + high) / 3.;\n        fx =\n            (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n            (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n        my = mt = (low + 2 * high) / 3.;\n        fy =\n            (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n            (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n        if ((fs > 0 && fx > fy) || (fs < 0 && fx < fy))\n          low = mx;\n        else\n          high = my;\n      }\n      mt = 0.5 * (low + high);\n      fx = (st.x + v * cos(theta) * mt - tank[i].x) * sin(tank[i].a + w * mt) -\n           (st.y + v * sin(theta) * mt - tank[i].y) * cos(tank[i].a + w * mt);\n      if ((fs > 0 && fx < eps) || (fs < 0 && fx > -eps)) {\n        nk++;\n        continue;\n      }\n    }\n  }\n  return nk <= k;\n}\nint main() {\n  int i, j, s, p, q;\n  double low, high, mid;\n  scanf(\"%lf%lf%lf%lf\", &st.x, &st.y, &en.x, &en.y);\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%lf%lf%lf%lf\", &tank[i].x, &tank[i].y, &tank[i].a, &tank[i].w);\n    norm(tank[i].a);\n  }\n  scanf(\"%d\", &k);\n  low = 0;\n  high = 1e9;\n  while (low < high - eps) {\n    mid = (low + high) * 0.5;\n    if (check(mid))\n      high = mid;\n    else\n      low = mid + eps;\n  }\n  printf(\"%.20f\\n\", (low + high) * 0.5);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble cal_ang(double x, double y) {\n  double res = acos(abs(x / hypot(x, y)));\n  if (x <= 0 && y >= 0) return acos(-1) - res;\n  if (x <= 0 && y < 0) return acos(-1) + res;\n  if (x > 0 && y < 0) return acos(-1) * 2.0 - res;\n  return res;\n}\nint main() {\n  double x0, x1, y0, y1, t0, t1, t2, t3;\n  int n, k;\n  vector<double> time;\n  scanf(\"%lf%lf%lf%lf%d\", &x0, &y0, &x1, &y1, &n);\n  for (long long i = 0; i < ((long long)n); i++) {\n    scanf(\"%lf%lf%lf%lf\", &t0, &t1, &t2, &t3);\n    if (t3 < 1e-5) continue;\n    x0 -= t0;\n    x1 -= t0;\n    y0 -= t1;\n    y1 -= t1;\n    double tmp = 0;\n    for (long long j = 0; j < ((long long)100 + 1); j++) {\n      double x = x0 + (x1 - x0) * j / (double)100;\n      double y = y0 + (y1 - y0) * j / (double)100;\n      double ang = cal_ang(x, y);\n      ang -= t2;\n      if (ang < 0) ang += 2.0 * acos(-1);\n      while (ang > acos(-1) * 2.0) ang -= acos(-1) * 2.0;\n      ang = min(acos(-1) * 2.0 - ang, ang);\n      tmp = max(tmp, hypot(x0 - x, y0 - y) / (ang / t3));\n    }\n    time.push_back(tmp);\n    x0 += t0;\n    x1 += t0;\n    y0 += t1;\n    y1 += t1;\n  }\n  scanf(\"%d\", &k);\n  if (((long long)time.size()) <= k) {\n    printf(\"0.0000\\n\");\n    return 0;\n  }\n  sort(time.begin(), time.end());\n  reverse(time.begin(), time.end());\n  printf(\"%.4lf\\n\", time[k]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1);\nstruct pnt {\n  double x, y;\n  pnt(double x = 0, double y = 0) : x(x), y(y) {}\n  pnt operator+(pnt a) { return pnt(x + a.x, y + a.y); }\n  pnt operator-(pnt a) { return pnt(x - a.x, y - a.y); }\n  pnt operator/(double a) { return pnt(x / a, y / a); }\n  pnt operator*(double a) { return pnt(x * a, y * a); }\n  double operator^(pnt a) { return x * a.y - y * a.x; }\n  double operator&(pnt a) { return x * a.x + y * a.y; }\n  double dist() { return sqrt(x * x + y * y); }\n  void input() { scanf(\"%lf %lf\", &x, &y); }\n  void print() { printf(\"%lf %lf\\n\", x, y); }\n} pos[100010], A, B;\ndouble vec[100010], a[100010], w[100010];\nint n;\ndouble angle(pnt b, pnt a, pnt c) {\n  return acos((b - a & c - a) / (c - a).dist() / (b - a).dist());\n}\ndouble D;\nint P;\ndouble f(double x, int i, double d, double t, double dl, double v, double al) {\n  return dl + v * x - d * sin(w[i] * x) / sin(al + w[i] * x);\n}\nbool check(double v) {\n  int tot = 0;\n  for (int i = 0; i < n; i++) {\n    if (tot > P) return 0;\n    pnt tp = pnt(cos(a[i]), sin(a[i]));\n    double t = angle(pos[i] + tp, pos[i], B) / w[i];\n    if (v * t < D) {\n      tot++;\n      continue;\n    }\n    t = angle(pos[i] + tp, pos[i], A) / w[i];\n    if (v * t > D - 1e-7) continue;\n    double al = angle(pos[i], A, B);\n    if (al > pi / 2 - 1e-7) continue;\n    double d = (pos[i] - A).dist();\n    double T = (D - v * t) / v, dl = v * t;\n    double st = 0, en = T;\n    while (st < en - 1e-7) {\n      double x = (2 * st + en) / 3, y = (st + 2 * en) / 3;\n      if (f(x, i, d, t, dl, v, al) < f(y, i, d, t, dl, v, al))\n        en = y;\n      else\n        st = x;\n    }\n    if (f(st, i, d, t, dl, v, al) < 1e-7) tot++;\n  }\n  if (tot > P) return 0;\n  return 1;\n}\nint main() {\n  A.input(), B.input();\n  D = (A - B).dist();\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    pos[i].input();\n    cin >> a[i] >> w[i];\n  }\n  scanf(\"%d\", &P);\n  double l = 0, r = 1e9;\n  while (l < r - 1e-7) {\n    double mid = (l + r) / 2;\n    if (check(mid))\n      r = mid;\n    else\n      l = mid;\n  }\n  printf(\"%.12lf\\n\", l);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k;\nbool debug = false;\nstruct Point {\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  double abs() const { return hypot(x, y); }\n  double arg() const { return atan2(y, x); }\n  Point operator*(double o) const { return Point(x * o, y * o); }\n  Point operator+(const Point& o) const { return Point(x + o.x, y + o.y); }\n  Point operator-(const Point& o) const { return Point(x - o.x, y - o.y); }\n  bool operator<(const Point& o) const {\n    return x < o.x - 1e-6 || (x < o.x + 1e-6 && y < o.y - 1e-6);\n  }\n};\nPoint A, B;\nmap<double, int> js;\nint main() {\n  scanf(\"%lf%lf%lf%lf\", &A.x, &A.y, &B.x, &B.y);\n  scanf(\"%d\", &n);\n  double x, y, a, w;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf%lf%lf%lf\", &x, &y, &a, &w);\n    if (abs(w) < 1e-6) continue;\n    Point p = {x, y};\n    double v = -2;\n    for (int j = 0; j <= 100; j++) {\n      Point tp = (B - A) * (j / 100.0) + A;\n      double arg = (tp - p).arg() - a;\n      if (arg > 2 * acos(-1)) arg -= 2 * acos(-1);\n      while (arg < 0) arg += 2 * acos(-1);\n      if (arg > 2 * acos(-1) - arg) arg = 2 * acos(-1) - arg;\n      double t = arg / w;\n      v = v < -1 ? (tp - A).abs() / t : max(v, (tp - A).abs() / t);\n    }\n    js[v]++;\n  }\n  scanf(\"%d\", &k);\n  int sk = 0;\n  double t = -10;\n  for (map<double, int>::reverse_iterator it = js.rbegin(); it != js.rend();\n       it++) {\n    if (sk + it->second > k) {\n      t = it->first;\n      break;\n    }\n    sk += it->second;\n  }\n  printf(\"%.4lf\\n\", t < -1 ? 0 : t);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint main(int argc, char** argv) {\n  double x1, y1, x2, y2, x3, y3, x5, y5, x1tab[10000], y1tab[10000],\n      x5tab[10000], y5tab[10000], angle[10000], w[10000];\n  int k, n;\n  double length;\n  double miny[10001];\n  scanf(\"%lf%lf%lf%lf\", &x2, &y2, &x3, &y3);\n  length =\n      sqrt(x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 + y3 * y3);\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf%lf%lf%lf\", &x5tab[i], &y5tab[i], &angle[i], &w[i]);\n    x1tab[i] = cos(angle[i]);\n    y1tab[i] = sin(angle[i]);\n  }\n  scanf(\"%d\", &k);\n  for (int i = 0; i < n; i++) {\n    x1 = x1tab[i];\n    y1 = y1tab[i];\n    x5 = x5tab[i];\n    y5 = y5tab[i];\n    double a, b, c, d, e;\n    a = x1 * (x3 - x2) /\n            sqrt(x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 +\n                 y3 * y3) +\n        y1 * (y3 - y2) /\n            sqrt(x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 +\n                 y3 * y3);\n    b = x1 * (x2 - x5) + y1 * (y2 - y5);\n    c = (x3 - x2) * (x3 - x2) /\n            (x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 +\n             y3 * y3) +\n        (y3 - y2) * (y3 - y2) /\n            (x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 + y3 * y3);\n    d = (2 * (x2 - x5)) * (x3 - x2) /\n            sqrt(x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 +\n                 y3 * y3) +\n        (2 * (y2 - y5)) * (y3 - y2) /\n            sqrt(x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 +\n                 y3 * y3);\n    e = (x2 - x5) * (x2 - x5) + (y2 - y5) * (y2 - y5);\n    double min1 =\n        acos((a * length + b) / sqrt(c * length * length + d * length + e)) /\n        w[i] / length;\n    for (int j = 1; j < 100; j++) {\n      double x = length * j / 100;\n      double min2 = acos((a * x + b) / sqrt(c * x * x + d * x + e)) / w[i] / x;\n      if (min2 < min1) min1 = min2;\n    }\n    miny[i] = 1 / min1;\n  }\n  if (k >= n) {\n    printf(\"%.4f\", 0);\n  } else {\n    std::sort(miny, miny + n);\n    printf(\"%.4f\", miny[n - k - 1]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k;\nstruct Point {\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  double abs() const { return hypot(x, y); }\n  double arg() const { return atan2(y, x); }\n  Point operator*(double o) const { return Point(x * o, y * o); }\n  Point operator+(const Point& o) const { return Point(x + o.x, y + o.y); }\n  Point operator-(const Point& o) const { return Point(x - o.x, y - o.y); }\n  bool operator<(const Point& o) const {\n    return x < o.x - 1e-6 || (x < o.x + 1e-6 && y < o.y - 1e-6);\n  }\n};\nPoint A, B;\nmap<double, int> js;\nint main() {\n  scanf(\"%lf%lf%lf%lf\", &A.x, &A.y, &B.x, &B.y);\n  scanf(\"%d\", &n);\n  double x, y, a, w;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf%lf%lf%lf\", &x, &y, &a, &w);\n    if (abs(w) < 1e-6) continue;\n    Point p = {x, y};\n    double v = -2;\n    for (int j = 0; j <= 100; j++) {\n      Point tp = (B - A) * (j / 100.0) + A;\n      double arg = (tp - p).arg() - a;\n      if (arg > 2 * acos(-1)) arg -= 2 * acos(-1);\n      while (arg < 0) arg += 2 * acos(-1);\n      if (arg > 2 * acos(-1) - arg) arg = 2 * acos(-1) - arg;\n      double t = arg / w;\n      v = v < -1 ? (tp - A).abs() / t : max(v, (tp - A).abs() / t);\n    }\n    js[v]++;\n  }\n  scanf(\"%d\", &k);\n  int sk = 0;\n  double t = -10;\n  for (map<double, int>::reverse_iterator it = js.rbegin(); it != js.rend();\n       it++) {\n    if (sk + it->second > k) {\n      t = it->first;\n      break;\n    }\n    sk += it->second;\n  }\n  printf(\"%.4lf\\n\", t < -1 ? 0 : t);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class _T>\ninline _T sqr(const _T& x) {\n  return x * x;\n}\ntemplate <class _T>\ninline string tostr(const _T& a) {\n  ostringstream os(\"\");\n  os << a;\n  return os.str();\n}\nconst double PI = 3.1415926535897932384626433832795;\nconst double EPS = 1e-11;\nstruct tp {\n  double x, y;\n};\nint n, k;\ntp a[10240];\ndouble ang[10240];\ndouble w[10240];\ntp p1, p2;\ndouble b0[10240];\ndouble tt;\ninline double dist(tp p1, tp p2) {\n  return sqrt(sqr(p1.x - p2.x) + sqr(p1.y - p2.y));\n}\ninline bool hit(double s, int i) {\n  if (w[i] < EPS) return false;\n  double da = fabs(ang[i] - b0[i]);\n  da = min(da, 2.0 * PI - da);\n  double t = da / w[i];\n  if (t <= tt) return true;\n  int z = 2;\n  for (int j = 0; j < (int)(z); j++) {\n    double mi = j * 1.0 / z;\n    double ma = (j + 1.0) / z;\n    for (int tt = 0; tt < (int)(101); tt++) {\n      if (ma - mi < 1e-11) break;\n      double q1 = (mi * 2.0 + ma) / 3.0;\n      double q2 = (mi + 2.0 * ma) / 3.0;\n      tp pp1, pp2;\n      pp1.x = p1.x + (p2.x - p1.x) * q1;\n      pp1.y = p1.y + (p2.y - p1.y) * q1;\n      pp2.x = p1.x + (p2.x - p1.x) * q2;\n      pp2.y = p1.y + (p2.y - p1.y) * q2;\n      double aa1 = atan2(pp1.y - a[i].y, pp1.x - a[i].x);\n      double aa2 = atan2(pp2.y - a[i].y, pp2.x - a[i].x);\n      double a1 = fabs(ang[i] - aa1);\n      a1 = min(a1, 2.0 * PI - a1);\n      double a2 = fabs(ang[i] - aa2);\n      a2 = min(a2, 2.0 * PI - a2);\n      double t1 = a1 / w[i];\n      double t2 = a2 / w[i];\n      double d1 = dist(p1, pp1);\n      double d2 = dist(p1, pp2);\n      t1 -= d1 / s;\n      t2 -= d2 / s;\n      if (t1 <= 0.0) return true;\n      if (t2 <= 0.0) return true;\n      if (t1 < t2)\n        ma = q2;\n      else\n        mi = q1;\n    }\n  }\n  return false;\n}\nbool check(double s) {\n  int cnt = 0;\n  tt = dist(p1, p2) / s;\n  for (int i = 0; i < (int)(n); i++) {\n    if (cnt + n - i <= k) return true;\n    cnt += hit(s, i);\n    if (cnt > k) return false;\n  }\n  return cnt <= k;\n}\nint main() {\n  cout << setiosflags(ios::fixed) << setprecision(10);\n  int x, y;\n  scanf(\"%d%d\", &x, &y);\n  p1.x = x;\n  p1.y = y;\n  scanf(\"%d%d\", &x, &y);\n  p2.x = x;\n  p2.y = y;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < (int)(n); i++) {\n    scanf(\"%d%d\", &x, &y);\n    a[i].x = x;\n    a[i].y = y;\n    double aa, ww;\n    scanf(\"%lf%lf\", &aa, &ww);\n    if (aa > PI) {\n      aa -= 2.0 * PI;\n    }\n    ang[i] = aa;\n    w[i] = ww;\n  }\n  scanf(\"%d\", &k);\n  for (int i = 0; i < (int)(n); i++) {\n    b0[i] = atan2(p2.y - a[i].y, p2.x - a[i].x);\n  }\n  double mi = 3e-5;\n  double ma = 4e+6;\n  while (ma - mi > 3e-5 && (ma - mi) / (ma + mi) > 3e-5) {\n    double q = (mi + ma) * 0.5;\n    *(check(q) ? &ma : &mi) = q;\n  }\n  printf(\"%0.5lf\\n\", (double)mi);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-9, INF = 1e15, PI = acos(-1.0);\ndouble sq(double x) { return x * x; }\nstruct P {\n  double x, y;\n  P() {}\n  P(double x, double y) : x(x), y(y) {}\n  void eat() { scanf(\"%lf%lf\", &x, &y); }\n  P operator+(const P &p) const { return P(x + p.x, y + p.y); }\n  P operator-(const P &p) const { return P(x - p.x, y - p.y); }\n  P operator*(double k) { return P(x * k, y * k); }\n  double operator*(P p) { return x * p.x + y * p.y; }\n  double operator^(P p) { return x * p.y - y * p.x; }\n  double mag2() { return x * x + y * y; }\n  double mag() { return sqrt(mag2()); }\n  bool operator<(const P &p) const {\n    if ((fabs((x) - (p.x)) < EPS)) return ((y) < (p.y) - EPS);\n    return ((x) < (p.x) - EPS);\n  }\n  bool operator==(const P &p) const {\n    return (fabs((x) - (p.x)) < EPS) && (fabs((y) - (p.y)) < EPS);\n  }\n  P rot() { return P(-y, x); }\n  P rot(double the) {\n    return P(x * cos(the) - y * sin(the), x * sin(the) + y * cos(the));\n  }\n  P nor() {\n    if ((fabs((mag()) - (0)) < EPS)) return *this;\n    return *this * (1. / mag());\n  }\n  P ref(P n) {\n    n = n.nor();\n    return n * (n * (*this)) * 2 - *this;\n  }\n  void out() { printf(\"(%f,%f)\\n\", x, y); }\n};\nbool ssi(P a, P b, P c, P d, P &res) {\n  P cd = d - c, ab = b - a;\n  if ((fabs((cd ^ ab) - (0)) < EPS)) return 0;\n  double t = ((a ^ ab) - (c ^ ab)) / (cd ^ ab);\n  double s = ((c ^ cd) - (a ^ cd)) / (ab ^ cd);\n  res = c + cd * t;\n  return 1;\n}\nbool Ccw(P a, P b, P c) { return ((0) < ((b - a) ^ (c - a)) - EPS); }\nbool Btw(P a, P b, P c) {\n  return (fabs(((a - c).mag()) - ((b - a).mag() + (c - b).mag())) < EPS);\n}\ndouble Ang(P a, P b) {\n  double res = atan2(a ^ b, a * b);\n  if (((res) < (0) - EPS)) res += 2 * PI;\n  return res;\n}\nconst int N = 20360;\nP p[N], dir[N];\nP a, b;\ndouble the[N], spd[N], low[N];\nint n, k;\nint main() {\n  a.eat();\n  b.eat();\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    p[i].eat();\n    scanf(\"%lf%lf\", the + i, spd + i);\n    dir[i] = P(cos(the[i]), sin(the[i]));\n  }\n  scanf(\"%d\", &k);\n  double len = (a - b).mag();\n  for (int i = 0; i < n; i++) {\n    low[i] = 0;\n    if (((0) < (spd[i]) - EPS))\n      for (int j = 0; j < 2036 + 1; j++) {\n        P c = a + (b - a) * (j / 2036.0);\n        double ang = Ang(c - p[i], dir[i]);\n        ang = min(ang, 2 * PI - ang);\n        low[i] = max(low[i], len * (j / 2036.0) / (ang / spd[i]));\n      }\n  }\n  sort(low, low + n);\n  double ans = k == n ? 0 : low[n - 1 - k];\n  printf(\"%.20f\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint main(int argc, char** argv) {\n  double x1, y1, x2, y2, x3, y3, x5, y5, x1tab[10000], y1tab[10000],\n      x5tab[10000], y5tab[10000], angle[10000], w[10000];\n  int k, n;\n  double length;\n  double miny[10001];\n  scanf(\"%lf%lf%lf%lf\", &x2, &y2, &x3, &y3);\n  length =\n      sqrt(x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 + y3 * y3);\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf%lf%lf%lf\", &x5tab[i], &y5tab[i], &angle[i], &w[i]);\n    x1tab[i] = cos(angle[i]);\n    y1tab[i] = sin(angle[i]);\n  }\n  scanf(\"%d\", &k);\n  for (int i = 0; i < n; i++) {\n    x1 = x1tab[i];\n    y1 = y1tab[i];\n    x5 = x5tab[i];\n    y5 = y5tab[i];\n    double a, b, c, d, e;\n    a = x1 * (x3 - x2) /\n            sqrt(x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 +\n                 y3 * y3) +\n        y1 * (y3 - y2) /\n            sqrt(x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 +\n                 y3 * y3);\n    b = x1 * (x2 - x5) + y1 * (y2 - y5);\n    c = (x3 - x2) * (x3 - x2) /\n            (x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 +\n             y3 * y3) +\n        (y3 - y2) * (y3 - y2) /\n            (x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 + y3 * y3);\n    d = (2 * (x2 - x5)) * (x3 - x2) /\n            sqrt(x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 +\n                 y3 * y3) +\n        (2 * (y2 - y5)) * (y3 - y2) /\n            sqrt(x2 * x2 - 2 * x2 * x3 + x3 * x3 + y2 * y2 - 2 * y2 * y3 +\n                 y3 * y3);\n    e = (x2 - x5) * (x2 - x5) + (y2 - y5) * (y2 - y5);\n    double min1 =\n        acos((a * length + b) / sqrt(c * length * length + d * length + e)) /\n        w[i] / length;\n    for (int j = 1; j < 1000; j++) {\n      double x = length * j / 1000;\n      double min2 = acos((a * x + b) / sqrt(c * x * x + d * x + e)) / w[i] / x;\n      if (min2 < min1) min1 = min2;\n    }\n    miny[i] = 1 / min1;\n  }\n  if (k >= n) {\n    printf(\"%.4f\", 0);\n  } else {\n    std::sort(miny, miny + n);\n    printf(\"%.4f\", miny[n - k - 1]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble cal_ang(double x, double y) {\n  double res = acos(abs(x / hypot(x, y)));\n  if (x <= 0 && y >= 0) return acos(-1) - res;\n  if (x <= 0 && y < 0) return acos(-1) + res;\n  if (x > 0 && y < 0) return acos(-1) * 2.0 - res;\n  return res;\n}\nint main() {\n  double x0, x1, y0, y1, t0, t1, t2, t3;\n  int n, k;\n  vector<double> time;\n  scanf(\"%lf%lf%lf%lf%d\", &x0, &y0, &x1, &y1, &n);\n  for (long long i = 0; i < ((long long)n); i++) {\n    scanf(\"%lf%lf%lf%lf\", &t0, &t1, &t2, &t3);\n    if (t3 < 1e-5) continue;\n    x0 -= t0;\n    x1 -= t0;\n    y0 -= t1;\n    y1 -= t1;\n    double tmp = 0;\n    for (long long j = 0; j < ((long long)100 + 1); j++) {\n      double x = x0 + (x1 - x0) * j / (double)100;\n      double y = y0 + (y1 - y0) * j / (double)100;\n      double ang = cal_ang(x, y);\n      ang -= t2;\n      if (ang < 0) ang += 2.0 * acos(-1);\n      while (ang > acos(-1) * 2.0) ang -= acos(-1) * 2.0;\n      ang = min(acos(-1) * 2.0 - ang, ang);\n      tmp = max(tmp, hypot(x0 - x, y0 - y) / (ang / t3));\n    }\n    time.push_back(tmp);\n    x0 += t0;\n    x1 += t0;\n    y0 += t1;\n    y1 += t1;\n  }\n  scanf(\"%d\", &k);\n  if (((long long)time.size()) <= k) {\n    printf(\"0.0000\\n\");\n    return 0;\n  }\n  sort(time.begin(), time.end());\n  reverse(time.begin(), time.end());\n  printf(\"%.4lf\\n\", time[k]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<double, double> operator-(pair<double, double> a, pair<double, double> b) {\n  return pair<double, double>(a.first - b.first, a.second - b.second);\n}\npair<double, double> st, dir;\ndouble _w, _s, _len;\ninline double f(double t) {\n  double first = st.first + dir.first * t, second = st.second + dir.second * t;\n  double r = atan2(second, first) - _s;\n  while (r < 0) {\n    r += 2 * M_PI;\n  }\n  while (r > 2 * M_PI) {\n    r -= 2 * M_PI;\n  }\n  return _len * t * _w / min(r, 2 * M_PI - r);\n}\ndouble get(pair<double, double> a, pair<double, double> b, double s, double w) {\n  st = a;\n  dir = b - a;\n  _s = s;\n  _w = w;\n  _len = hypot(dir.first, dir.second);\n  double res = 0;\n  for (int i = 0; i <= 200; i++) {\n    double t = f(i / 200.);\n    if (t > res) {\n      res = t;\n    }\n  }\n  return res;\n}\nvoid read(pair<double, double> &p) {\n  double first, second;\n  scanf(\"%lf%lf\", &first, &second);\n  p.first = first;\n  p.second = second;\n}\nint main(void) {\n  pair<double, double> a, b;\n  read(a);\n  read(b);\n  int n;\n  scanf(\"%d\", &n);\n  vector<double> v(1, 0);\n  for (int i = 0; i < n; i++) {\n    pair<double, double> p;\n    read(p);\n    double s, w;\n    scanf(\"%lf%lf\", &s, &w);\n    v.push_back(get(a - p, b - p, s, w));\n  }\n  sort(v.begin(), v.end());\n  reverse(v.begin(), v.end());\n  int k;\n  scanf(\"%d\", &k);\n  printf(\"%.20lf\\n\", v[k]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble cal_ang(double x, double y) {\n  double res = acos(abs(x / hypot(x, y)));\n  if (x <= 0 && y >= 0) return acos(-1) - res;\n  if (x <= 0 && y < 0) return acos(-1) + res;\n  if (x > 0 && y < 0) return acos(-1) * 2.0 - res;\n  return res;\n}\nint main() {\n  double x0, x1, y0, y1, t0, t1, t2, t3;\n  int n, k;\n  vector<double> time;\n  scanf(\"%lf%lf%lf%lf%d\", &x0, &y0, &x1, &y1, &n);\n  for (long long i = 0; i < ((long long)n); i++) {\n    scanf(\"%lf%lf%lf%lf\", &t0, &t1, &t2, &t3);\n    if (t3 < 1e-5) continue;\n    x0 -= t0;\n    x1 -= t0;\n    y0 -= t1;\n    y1 -= t1;\n    double tmp = 0;\n    for (long long j = 0; j < ((long long)100 + 1); j++) {\n      double x = x0 + (x1 - x0) * j / (double)100;\n      double y = y0 + (y1 - y0) * j / (double)100;\n      double ang = cal_ang(x, y);\n      ang -= t2;\n      if (ang < 0) ang += 2.0 * acos(-1);\n      while (ang > acos(-1) * 2.0) ang -= acos(-1) * 2.0;\n      ang = min(acos(-1) * 2.0 - ang, ang);\n      tmp = max(tmp, hypot(x0 - x, y0 - y) / (ang / t3));\n    }\n    time.push_back(tmp);\n    x0 += t0;\n    x1 += t0;\n    y0 += t1;\n    y1 += t1;\n  }\n  scanf(\"%d\", &k);\n  if (((long long)time.size()) <= k) {\n    printf(\"0.0000\\n\");\n    return 0;\n  }\n  sort(time.begin(), time.end());\n  reverse(time.begin(), time.end());\n  printf(\"%.4lf\\n\", time[k]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble cal_ang(double x, double y) {\n  double res = acos(abs(x / hypot(x, y)));\n  if (x <= 0 && y >= 0) return acos(-1) - res;\n  if (x <= 0 && y < 0) return acos(-1) + res;\n  if (x > 0 && y < 0) return acos(-1) * 2.0 - res;\n  return res;\n}\nint main() {\n  double x0, x1, y0, y1, t0, t1, t2, t3;\n  int n, k;\n  vector<double> time;\n  scanf(\"%lf%lf%lf%lf%d\", &x0, &y0, &x1, &y1, &n);\n  for (long long i = 0; i < ((long long)n); i++) {\n    scanf(\"%lf%lf%lf%lf\", &t0, &t1, &t2, &t3);\n    if (t3 < 1e-5) continue;\n    x0 -= t0;\n    x1 -= t0;\n    y0 -= t1;\n    y1 -= t1;\n    double tmp = 0;\n    for (long long j = 0; j < ((long long)100 + 1); j++) {\n      double x = x0 + (x1 - x0) * j / (double)100;\n      double y = y0 + (y1 - y0) * j / (double)100;\n      double ang = cal_ang(x, y);\n      ang -= t2;\n      if (ang < 0) ang += 2.0 * acos(-1);\n      while (ang > acos(-1) * 2.0) ang -= acos(-1) * 2.0;\n      ang = min(acos(-1) * 2.0 - ang, ang);\n      tmp = max(tmp, hypot(x0 - x, y0 - y) / (ang / t3));\n    }\n    time.push_back(tmp);\n    x0 += t0;\n    x1 += t0;\n    y0 += t1;\n    y1 += t1;\n  }\n  scanf(\"%d\", &k);\n  if (((long long)time.size()) <= k) {\n    printf(\"0.0000\\n\");\n    return 0;\n  }\n  sort(time.begin(), time.end());\n  reverse(time.begin(), time.end());\n  printf(\"%.4lf\\n\", time[k]);\n}\n"
        }
    ]
}