{
    "name": "1045_D. Interstellar battle",
    "source": "CODEFORCES",
    "description": "In the intergalactic empire Bubbledom there are N planets, of which some pairs are directly connected by two-way wormholes. There are N-1 wormholes. The wormholes are of extreme religious importance in Bubbledom, a set of planets in Bubbledom consider themselves one intergalactic kingdom if and only if any two planets in the set can reach each other by traversing the wormholes. You are given that Bubbledom is one kingdom. In other words, the network of planets and wormholes is a tree.\n\nHowever, Bubbledom is facing a powerful enemy also possessing teleportation technology. The enemy attacks every night, and the government of Bubbledom retakes all the planets during the day. In a single attack, the enemy attacks every planet of Bubbledom at once, but some planets are more resilient than others. Planets are number 0,1,\u2026,N-1 and the planet i will fall with probability p_i. Before every night (including the very first one), the government reinforces or weakens the defenses of a single planet.\n\nThe government of Bubbledom is interested in the following question: what is the expected number of intergalactic kingdoms Bubbledom will be split into, after a single enemy attack (before they get a chance to rebuild)? In other words, you need to print the expected number of connected components after every attack.\n\nInput\n\nThe first line contains one integer number N (1 \u2264 N \u2264 10^5) denoting the number of planets in Bubbledom (numbered from 0 to N-1). \n\nThe next line contains N different real numbers in the interval [0,1], specified with 2 digits after the decimal point, denoting the probabilities that the corresponding planet will fall.\n\nThe next N-1 lines contain all the wormholes in Bubbledom, where a wormhole is specified by the two planets it connects.\n\nThe next line contains a positive integer Q (1 \u2264 Q \u2264 10^5), denoting the number of enemy attacks.\n\nThe next Q lines each contain a non-negative integer and a real number from interval [0,1], denoting the planet the government of Bubbledom decided to reinforce or weaken, along with the new probability that the planet will fall.\n\nOutput\n\nOutput contains Q numbers, each of which represents the expected number of kingdoms that are left after each enemy attack. Your answers will be considered correct if their absolute or relative error does not exceed 10^{-4}. \n\nExample\n\nInput\n\n5\n0.50 0.29 0.49 0.95 0.83\n2 3\n0 3\n3 4\n2 1\n3\n4 0.66\n1 0.69\n0 0.36\n\n\nOutput\n\n1.68040\n1.48440\n1.61740",
    "difficulty": "D",
    "tags": [
        "math",
        "probabilities",
        "trees"
    ],
    "rating": 2200,
    "public_test": [
        {
            "input": "5\n0.50 0.29 0.49 0.95 0.83\n2 3\n0 3\n3 4\n2 1\n3\n4 0.66\n1 0.69\n0 0.36\n",
            "output": "1.68040\n1.48440\n1.61740\n"
        }
    ],
    "generated_test": [
        {
            "input": "11\n0.07 0.85 0.27 0.71 0.24 0.43 0.64 0.34 0.03 0.41 0.46\n3 8\n4 1\n5 9\n1 5\n5 2\n1 8\n9 10\n7 1\n0 10\n6 10\n9\n0 0.51\n1 0.75\n8 0.39\n9 0.92\n5 0.27\n2 0.25\n4 0.55\n7 0.01\n4 0.51\n",
            "output": "3.85470\n3.65870\n3.49310\n3.54920\n3.53960\n3.54500\n3.31250\n3.56000\n3.59000\n"
        },
        {
            "input": "23\n0.04 0.12 0.51 0.98 0.97 0.12 0.93 0.90 0.67 0.80 0.18 0.15 0.66 0.69 0.34 0.88 0.79 0.12 0.97 0.81 0.59 0.78 0.61\n12 5\n6 20\n15 18\n3 18\n11 4\n0 14\n7 8\n8 10\n22 19\n14 12\n4 19\n16 9\n17 7\n18 21\n9 22\n22 12\n21 6\n22 21\n10 11\n8 2\n11 1\n3 13\n26\n3 0.73\n2 0.20\n17 0.18\n0 0.59\n8 0.27\n8 0.38\n14 0.69\n7 0.86\n3 0.25\n4 0.71\n18 0.47\n10 0.56\n17 0.00\n2 0.89\n14 0.53\n15 0.32\n20 0.37\n16 0.39\n3 0.83\n16 0.79\n17 0.88\n22 1.00\n3 0.44\n8 0.19\n15 0.04\n11 0.57\n",
            "output": "5.89470\n6.10240\n6.04840\n5.86140\n5.57340\n5.65260\n5.56510\n5.54750\n5.86430\n5.85390\n5.80890\n5.98750\n6.14230\n5.88010\n5.92010\n6.18330\n6.38790\n6.70790\n6.61510\n6.29510\n5.53830\n5.51880\n5.58120\n5.64010\n5.77170\n6.02790\n"
        },
        {
            "input": "22\n0.53 0.11 0.92 0.61 0.06 0.51 0.79 0.64 0.18 0.49 0.76 0.07 0.98 0.36 0.30 0.17 0.06 0.51 0.82 0.22 0.38 0.55\n21 17\n3 17\n18 13\n1 9\n2 9\n0 11\n7 21\n0 14\n0 15\n7 12\n8 0\n1 19\n15 1\n7 1\n11 16\n7 5\n4 20\n11 13\n4 6\n8 6\n3 10\n9\n19 0.43\n1 0.28\n4 0.32\n21 0.65\n6 0.89\n21 0.06\n13 0.12\n16 0.24\n18 0.32\n",
            "output": "4.77950\n4.99540\n4.95120\n4.93620\n4.98620\n5.07470\n5.04830\n5.03570\n5.09570\n"
        },
        {
            "input": "8\n0.52 0.43 0.88 0.82 0.11 0.54 0.29 0.52\n2 5\n5 0\n0 3\n1 7\n1 5\n5 6\n4 3\n7\n6 0.19\n5 0.95\n0 0.42\n3 0.09\n3 0.07\n1 0.39\n4 0.10\n",
            "output": "2.55900\n2.96080\n3.03780\n2.69470\n2.68530\n2.70410\n2.70480\n"
        },
        {
            "input": "11\n0.07 0.85 0.27 0.71 0.24 0.43 0.64 0.34 0.03 0.41 0.46\n3 8\n4 1\n5 9\n1 5\n5 2\n1 8\n9 10\n7 1\n0 10\n6 10\n9\n0 0.51\n1 0.75\n8 0.39\n9 0.92\n2 0.27\n2 0.25\n4 0.55\n7 0.01\n4 0.51\n",
            "output": "3.85470\n3.65870\n3.49310\n3.54920\n3.54920\n3.55780\n3.32530\n3.57280\n3.60280\n"
        },
        {
            "input": "22\n0.53 0.11 0.92 0.61 0.06 0.51 0.79 0.64 0.18 0.49 0.76 0.07 0.98 0.36 0.30 0.17 0.06 0.51 0.82 0.22 0.38 0.55\n21 17\n3 17\n18 13\n1 9\n2 9\n0 11\n7 21\n0 14\n0 15\n7 12\n8 0\n1 19\n15 1\n7 1\n11 16\n7 5\n4 20\n7 13\n4 6\n8 6\n3 10\n9\n19 0.43\n1 0.28\n4 0.32\n21 0.65\n6 0.89\n21 0.06\n13 0.12\n16 0.24\n18 0.32\n",
            "output": "5.14430\n5.36020\n5.31600\n5.30100\n5.35100\n5.43950\n5.54990\n5.53730\n5.59730\n"
        },
        {
            "input": "12\n0.92 0.61 0.96 0.20 0.66 0.10 0.92 0.35 0.39 0.68 0.15 0.28\n6 10\n0 11\n7 11\n9 7\n4 0\n8 1\n6 2\n5 0\n7 8\n9 3\n2 8\n21\n6 0.61\n3 0.94\n3 0.02\n5 0.58\n1 0.25\n0 0.19\n0 0.15\n5 0.67\n5 0.76\n1 0.79\n7 0.35\n1 0.22\n1 0.49\n10 0.67\n2 0.40\n3 0.49\n9 0.33\n4 0.97\n5 0.83\n1 0.68\n5 0.64\n",
            "output": "3.99530\n3.49210\n4.11770\n3.67610\n3.81650\n3.46610\n3.44690\n3.43340\n3.41990\n3.20930\n3.20930\n3.43160\n3.32630\n3.00910\n3.00910\n2.68950\n2.63350\n2.58700\n2.57650\n2.50240\n2.53090\n"
        },
        {
            "input": "11\n0.07 0.85 0.27 0.71 0.24 0.43 0.64 0.34 0.03 0.41 0.46\n3 9\n4 1\n5 9\n1 5\n5 2\n2 8\n9 10\n7 1\n0 10\n6 10\n9\n0 0.51\n1 0.75\n8 0.39\n9 0.92\n5 0.27\n2 0.25\n4 0.55\n7 0.01\n4 0.51\n",
            "output": "3.40230\n3.30330\n3.20610\n3.41010\n3.40050\n3.39370\n3.16120\n3.40870\n3.43870\n"
        },
        {
            "input": "23\n0.04 0.12 0.51 0.98 0.97 0.12 0.93 0.90 0.67 0.80 0.18 0.15 0.66 0.69 0.34 0.88 0.79 0.12 0.97 0.81 0.59 0.78 0.61\n12 5\n6 20\n15 18\n3 18\n11 4\n0 14\n7 8\n8 10\n22 19\n14 12\n4 19\n16 9\n17 10\n18 21\n9 22\n17 12\n21 6\n22 21\n10 11\n8 2\n11 1\n3 13\n26\n3 0.73\n2 0.20\n17 0.18\n0 0.59\n8 0.27\n8 0.38\n14 0.69\n7 0.86\n3 0.25\n4 0.71\n18 0.47\n10 0.56\n17 0.00\n2 0.89\n14 0.53\n15 0.32\n20 0.37\n16 0.39\n3 0.83\n16 0.79\n17 0.88\n22 1.00\n3 0.44\n8 0.19\n15 0.04\n11 0.57\n",
            "output": "5.09450\n5.30220\n5.31180\n5.12480\n4.83680\n4.91600\n4.82850\n4.84370\n5.16050\n5.15010\n5.10510\n5.59530\n5.63490\n5.37270\n5.41270\n5.67590\n5.88050\n6.20050\n6.10770\n5.78770\n5.59410\n5.44200\n5.50440\n5.56330\n5.69490\n5.95110\n"
        },
        {
            "input": "17\n0.41 0.74 0.61 0.67 0.99 0.24 0.74 0.62 0.76 0.33 0.65 0.25 0.37 0.03 0.84 0.52 0.41\n14 12\n6 16\n9 4\n5 8\n6 4\n7 12\n15 8\n3 1\n7 8\n5 0\n12 1\n15 10\n14 9\n13 3\n16 2\n11 9\n13\n3 0.08\n12 0.58\n6 0.48\n0 0.92\n10 0.17\n2 0.40\n0 0.67\n10 0.54\n9 0.74\n2 0.64\n5 0.28\n16 0.99\n3 0.14\n",
            "output": "4.76670\n4.72470\n4.82870\n4.70630\n4.95590\n5.04200\n5.10200\n4.90960\n4.87680\n4.77840\n4.76120\n4.69160\n4.70540\n"
        },
        {
            "input": "22\n0.53 0.11 0.92 0.61 0.06 0.51 0.79 0.64 0.18 0.49 0.76 0.07 0.98 0.36 0.30 0.17 0.06 0.51 0.82 0.22 0.38 0.55\n21 17\n3 17\n18 13\n1 9\n2 9\n0 11\n7 21\n0 14\n0 15\n5 12\n8 0\n1 19\n15 1\n7 1\n11 16\n7 5\n2 20\n11 13\n4 6\n8 6\n3 10\n9\n19 0.43\n1 0.28\n4 0.32\n21 0.65\n6 0.89\n21 0.06\n13 0.12\n16 0.24\n18 0.32\n",
            "output": "5.31010\n5.52600\n5.32060\n5.30560\n5.35560\n5.44410\n5.41770\n5.40510\n5.46510\n"
        },
        {
            "input": "3\n0.62 0.97 0.83\n2 0\n1 0\n26\n1 0.92\n2 0.25\n1 0.01\n1 0.28\n1 0.45\n1 0.59\n0 0.66\n2 0.77\n1 0.83\n0 0.54\n1 0.81\n1 0.19\n0 0.78\n0 0.84\n2 0.75\n0 0.76\n1 0.55\n1 0.85\n2 0.40\n0 0.83\n2 0.99\n0 0.12\n2 0.14\n1 0.72\n1 0.45\n1 0.29\n",
            "output": "0.53500\n0.89460\n1.45880\n1.29140\n1.18600\n1.09920\n1.10560\n0.76240\n0.60400\n0.67600\n0.68680\n1.02160\n1.03120\n1.03360\n1.05040\n1.04560\n0.77200\n0.54400\n0.81000\n0.79250\n0.30280\n0.89920\n1.00120\n1.01680\n1.04920\n1.06840\n"
        },
        {
            "input": "3\n0.45 0.29 0.69\n1 0\n2 0\n6\n2 0.64\n2 0.85\n2 0.63\n1 0.21\n1 0.24\n1 0.03\n",
            "output": "1.03150\n0.93700\n1.03600\n1.07200\n1.05850\n1.15300\n"
        },
        {
            "input": "5\n0.50 0.29 0.49 0.95 0.83\n1 3\n0 3\n3 4\n2 1\n3\n4 0.66\n1 0.69\n0 0.36\n",
            "output": "1.67040\n1.49440\n1.62740\n"
        },
        {
            "input": "11\n0.07 0.85 0.27 0.71 0.24 0.43 0.64 0.34 0.03 0.41 0.46\n3 8\n4 1\n5 9\n1 5\n5 2\n1 8\n9 10\n7 2\n0 10\n6 10\n9\n0 0.51\n1 0.75\n8 0.39\n9 0.92\n5 0.27\n2 0.25\n4 0.55\n7 0.01\n4 0.51\n",
            "output": "3.47190\n3.34190\n3.17630\n3.23240\n3.22280\n3.21500\n2.98250\n3.06500\n3.09500\n"
        },
        {
            "input": "11\n0.07 0.85 0.27 0.71 0.24 0.43 0.64 0.34 0.03 0.41 0.46\n3 8\n4 1\n5 9\n1 5\n5 2\n1 8\n9 10\n7 1\n0 10\n6 10\n9\n0 0.51\n2 0.75\n8 0.39\n9 0.92\n2 0.27\n2 0.25\n4 0.55\n7 0.01\n4 0.51\n",
            "output": "3.85470\n3.64830\n3.44670\n3.50280\n3.70920\n3.71780\n3.45430\n3.73480\n3.76880\n"
        },
        {
            "input": "11\n0.07 0.85 0.27 0.71 0.24 0.43 0.64 0.34 0.03 0.41 0.46\n3 8\n4 1\n5 0\n1 5\n5 2\n1 8\n9 10\n7 1\n0 10\n6 10\n9\n0 0.51\n2 0.75\n8 0.39\n9 0.92\n2 0.27\n2 0.25\n4 0.55\n7 0.01\n4 0.51\n",
            "output": "3.91170\n3.70530\n3.50370\n3.26910\n3.47550\n3.48410\n3.22060\n3.50110\n3.53510\n"
        },
        {
            "input": "12\n0.92 0.61 0.96 0.20 0.66 0.10 0.92 0.35 0.39 0.68 0.15 0.28\n6 10\n0 11\n7 11\n9 7\n4 0\n8 1\n6 2\n5 0\n7 8\n9 3\n2 8\n21\n6 0.61\n3 0.94\n3 0.02\n5 0.58\n1 0.25\n0 0.19\n0 0.15\n5 0.67\n5 0.76\n1 0.79\n3 0.35\n1 0.22\n1 0.49\n10 0.67\n2 0.40\n3 0.49\n9 0.33\n4 0.97\n5 0.83\n1 0.68\n4 0.64\n",
            "output": "3.99530\n3.49210\n4.11770\n3.67610\n3.81650\n3.46610\n3.44690\n3.43340\n3.41990\n3.20930\n2.98490\n3.20720\n3.10190\n2.78470\n2.78470\n2.68950\n2.63350\n2.58700\n2.57650\n2.50240\n2.55190\n"
        },
        {
            "input": "23\n0.04 0.12 0.51 0.98 0.97 0.12 0.93 0.90 0.67 0.80 0.18 0.15 0.66 0.69 0.34 0.88 0.79 0.12 0.97 0.81 0.59 0.78 0.61\n12 5\n6 20\n15 18\n3 18\n11 4\n0 14\n7 8\n8 10\n22 19\n14 12\n4 19\n16 9\n17 10\n18 21\n9 22\n22 12\n21 6\n22 21\n10 11\n8 2\n0 1\n3 13\n26\n3 0.73\n2 0.20\n17 0.18\n0 0.59\n8 0.27\n8 0.38\n14 0.69\n7 0.86\n3 0.25\n4 0.71\n18 0.47\n10 0.56\n17 0.00\n2 0.89\n14 0.53\n15 0.32\n20 0.37\n16 0.39\n3 0.83\n16 0.79\n17 0.88\n22 1.00\n3 0.44\n8 0.19\n15 0.04\n11 0.57\n",
            "output": "5.16430\n5.37200\n5.36120\n5.65820\n5.37020\n5.44940\n5.36190\n5.37710\n5.69390\n5.68350\n5.63850\n6.12870\n6.22950\n5.96730\n6.00730\n6.27050\n6.47510\n6.79510\n6.70230\n6.38230\n5.88950\n5.87000\n5.93240\n5.99130\n6.12290\n6.00950\n"
        },
        {
            "input": "23\n0.60 0.46 0.20 0.71 0.26 0.68 0.11 0.24 0.50 0.93 0.95 0.39 0.74 0.14 0.68 0.59 0.95 0.83 0.97 0.15 0.90 0.23 0.39\n1 10\n1 2\n22 7\n2 13\n11 8\n2 20\n17 14\n4 6\n13 11\n19 17\n18 11\n12 5\n9 8\n22 9\n16 7\n4 7\n17 6\n0 2\n21 0\n16 12\n6 15\n3 13\n6\n4 0.44\n19 0.22\n6 0.59\n16 0.67\n10 0.75\n19 0.58\n",
            "output": "4.95310\n4.89500\n4.96220\n4.95660\n5.04860\n4.74980\n"
        },
        {
            "input": "27\n0.09 0.74 0.27 0.41 0.82 0.35 0.60 0.30 0.99 0.86 0.99 0.41 0.13 0.68 0.22 0.27 0.44 0.38 0.12 0.93 0.17 0.70 0.31 0.21 0.35 0.03 0.86\n0 24\n25 13\n13 11\n12 6\n8 12\n21 8\n8 1\n21 5\n4 24\n2 3\n18 21\n1 3\n5 0\n19 1\n7 3\n20 23\n20 8\n16 25\n14 22\n24 22\n15 10\n23 9\n26 15\n16 21\n5 15\n17 15\n7\n25 0.35\n10 0.52\n4 0.71\n16 0.98\n26 0.23\n26 0.88\n12 0.17\n",
            "output": "7.18670\n7.31360\n7.35210\n7.32510\n7.49520\n7.31970\n7.29610\n"
        },
        {
            "input": "22\n0.53 0.11 0.92 0.61 0.06 0.51 0.79 0.64 0.18 0.49 0.76 0.07 0.98 0.36 0.30 0.17 0.06 0.51 0.82 0.22 0.38 0.55\n21 17\n3 17\n18 13\n1 9\n2 9\n0 11\n7 21\n0 14\n0 15\n5 12\n8 0\n1 19\n15 1\n7 1\n11 16\n7 5\n4 20\n11 13\n4 6\n8 6\n3 10\n9\n19 0.43\n1 0.28\n4 0.32\n21 0.65\n6 0.89\n17 0.06\n13 0.12\n16 0.24\n18 0.32\n",
            "output": "4.77690\n4.99280\n4.94860\n4.93360\n4.98360\n5.10060\n5.07420\n5.06160\n5.12160\n"
        },
        {
            "input": "11\n0.99 0.23 0.01 0.76 0.80 0.46 0.24 0.25 0.91 0.36 0.72\n6 9\n1 10\n6 7\n8 4\n0 10\n0 9\n4 7\n1 5\n6 3\n5 2\n19\n10 0.13\n0 0.68\n10 0.52\n6 0.77\n8 0.25\n8 0.57\n7 0.59\n1 0.67\n6 0.98\n0 0.92\n6 0.94\n2 0.90\n10 0.56\n7 0.21\n0 0.23\n1 0.76\n2 0.84\n3 0.44\n5 0.11\n",
            "output": "2.81780\n2.65970\n2.69480\n3.02870\n3.55670\n3.30070\n3.10690\n3.11570\n3.17660\n3.20540\n3.19380\n2.78440\n2.76080\n3.04200\n2.98680\n2.98500\n3.01260\n3.31340\n3.52340\n"
        },
        {
            "input": "24\n0.73 0.01 0.74 0.45 0.99 0.18 0.40 0.97 0.07 0.79 0.63 0.71 0.34 0.31 0.61 0.07 0.59 0.73 0.20 0.31 0.82 0.04 0.29 0.46\n18 15\n9 4\n7 17\n12 9\n11 0\n0 3\n6 3\n14 5\n18 9\n21 12\n9 17\n14 11\n18 13\n7 22\n11 22\n17 20\n23 22\n16 18\n8 17\n12 10\n22 19\n1 13\n2 14\n22\n10 0.70\n0 0.45\n14 0.52\n23 0.54\n5 0.61\n20 0.49\n22 0.09\n10 0.86\n12 0.87\n1 0.47\n14 0.02\n22 0.92\n3 0.23\n15 0.68\n9 0.50\n2 0.92\n0 0.54\n21 0.86\n7 0.88\n16 0.52\n5 0.26\n0 0.96\n",
            "output": "6.48650\n6.53130\n6.49800\n6.47480\n6.25120\n6.49210\n6.39810\n6.34370\n6.50800\n6.36540\n6.39540\n6.78550\n6.75250\n6.63050\n6.56960\n6.56600\n6.57140\n5.85800\n5.91650\n5.93050\n5.93750\n5.96270\n"
        },
        {
            "input": "3\n0.45 0.29 0.69\n1 0\n2 0\n6\n2 0.64\n2 0.85\n1 0.63\n2 0.21\n1 0.24\n1 0.03\n",
            "output": "1.03150\n0.93700\n0.78400\n1.07200\n1.24750\n1.34200\n"
        },
        {
            "input": "23\n0.04 0.12 0.51 0.98 0.97 0.12 0.93 0.90 0.67 0.80 0.18 0.15 0.66 0.69 0.34 0.88 0.79 0.12 0.97 0.81 0.59 0.78 0.61\n12 5\n6 20\n15 18\n3 18\n11 4\n0 14\n7 8\n8 10\n22 19\n14 12\n4 19\n16 9\n17 7\n18 21\n9 22\n22 12\n21 6\n22 21\n10 11\n8 2\n11 1\n3 13\n26\n3 0.73\n2 0.20\n17 0.18\n0 0.59\n8 0.27\n8 0.38\n14 0.69\n7 0.86\n3 0.25\n4 0.71\n18 0.47\n10 0.56\n17 0.00\n2 0.89\n14 0.53\n17 0.32\n20 0.37\n16 0.39\n3 0.83\n16 0.79\n17 0.88\n22 1.00\n3 0.44\n8 0.19\n15 0.04\n11 0.57\n",
            "output": "5.89470\n6.10240\n6.04840\n5.86140\n5.57340\n5.65260\n5.56510\n5.54750\n5.86430\n5.85390\n5.80890\n5.98750\n6.14230\n5.88010\n5.92010\n5.64490\n5.84950\n6.16950\n6.07670\n5.75670\n5.27510\n5.25560\n5.31800\n5.37690\n5.77170\n6.02790\n"
        },
        {
            "input": "8\n0.52 0.43 0.88 0.82 0.11 0.54 0.29 0.52\n2 5\n5 0\n0 3\n2 7\n1 5\n5 6\n4 3\n7\n6 0.19\n5 0.95\n0 0.42\n3 0.09\n3 0.07\n1 0.39\n4 0.10\n",
            "output": "2.77500\n3.17680\n3.25380\n2.91070\n2.90130\n2.93930\n2.94000\n"
        },
        {
            "input": "12\n0.92 0.61 0.96 0.20 0.66 0.10 0.92 0.35 0.39 0.68 0.15 0.28\n6 10\n0 11\n7 11\n9 7\n4 0\n8 1\n6 2\n5 0\n7 8\n9 3\n2 8\n21\n6 0.61\n3 0.94\n3 0.02\n5 0.58\n1 0.25\n0 0.19\n0 0.15\n5 0.67\n5 0.76\n1 0.79\n7 0.35\n1 0.22\n2 0.49\n10 0.67\n2 0.40\n3 0.49\n9 0.33\n4 0.97\n5 0.83\n1 0.68\n5 0.64\n",
            "output": "3.99530\n3.49210\n4.11770\n3.67610\n3.81650\n3.46610\n3.44690\n3.43340\n3.41990\n3.20930\n3.20930\n3.43160\n3.43160\n3.11440\n3.11440\n2.79480\n2.73880\n2.69230\n2.68180\n2.50240\n2.53090\n"
        },
        {
            "input": "17\n0.41 0.74 0.61 0.67 0.99 0.24 0.74 0.62 0.76 0.33 0.65 0.25 0.37 0.03 0.84 0.52 0.41\n14 12\n6 16\n9 4\n5 8\n6 4\n7 12\n15 8\n3 1\n7 8\n5 0\n12 1\n15 10\n14 9\n13 3\n16 2\n11 9\n13\n3 0.08\n12 0.58\n6 0.48\n0 0.92\n10 0.17\n2 0.40\n0 0.67\n10 0.54\n9 0.74\n2 0.64\n5 0.28\n16 0.99\n5 0.14\n",
            "output": "4.76670\n4.72470\n4.82870\n4.70630\n4.95590\n5.04200\n5.10200\n4.90960\n4.87680\n4.77840\n4.76120\n4.69160\n4.75180\n"
        },
        {
            "input": "22\n0.53 0.11 0.92 0.61 0.06 0.51 0.79 0.64 0.18 0.49 0.76 0.07 0.98 0.36 0.30 0.17 0.06 0.51 0.82 0.22 0.38 0.55\n21 17\n3 17\n18 13\n1 9\n2 9\n0 11\n5 21\n0 14\n0 15\n5 12\n8 0\n1 19\n15 1\n7 1\n11 16\n7 5\n2 20\n11 13\n4 6\n8 6\n3 10\n9\n19 0.43\n1 0.28\n4 0.32\n21 0.65\n6 0.89\n21 0.06\n13 0.12\n16 0.24\n18 0.32\n",
            "output": "5.25160\n5.46750\n5.26210\n5.26010\n5.31010\n5.32190\n5.29550\n5.28290\n5.34290\n"
        },
        {
            "input": "3\n0.62 0.97 0.83\n2 0\n1 0\n26\n1 0.92\n2 0.25\n1 0.01\n1 0.28\n1 0.45\n1 0.59\n0 0.66\n2 0.77\n0 0.83\n0 0.54\n1 0.81\n1 0.19\n0 0.78\n0 0.84\n2 0.75\n0 0.76\n1 0.55\n1 0.85\n2 0.40\n0 0.83\n2 0.99\n0 0.12\n2 0.14\n1 0.72\n1 0.45\n1 0.29\n",
            "output": "0.53500\n0.89460\n1.45880\n1.29140\n1.18600\n1.09920\n1.10560\n0.76240\n0.70120\n0.80560\n0.68680\n1.02160\n1.03120\n1.03360\n1.05040\n1.04560\n0.77200\n0.54400\n0.81000\n0.79250\n0.30280\n0.89920\n1.00120\n1.01680\n1.04920\n1.06840\n"
        },
        {
            "input": "3\n0.45 0.29 0.69\n1 0\n2 0\n6\n2 0.64\n2 0.85\n2 0.63\n1 0.21\n1 0.24\n0 0.03\n",
            "output": "1.03150\n0.93700\n1.03600\n1.07200\n1.05850\n1.00390\n"
        },
        {
            "input": "27\n0.09 0.74 0.27 0.41 0.82 0.35 0.60 0.30 0.99 0.86 0.99 0.41 0.13 0.68 0.22 0.27 0.44 0.38 0.12 0.93 0.17 0.70 0.31 0.21 0.35 0.03 0.86\n1 24\n25 13\n13 11\n12 6\n8 12\n21 8\n8 1\n21 5\n4 24\n2 3\n18 21\n1 3\n5 0\n19 1\n7 3\n20 23\n20 8\n16 25\n14 22\n24 22\n15 10\n23 9\n26 15\n16 21\n5 15\n17 15\n7\n25 0.35\n10 0.52\n4 0.71\n16 0.98\n26 0.23\n26 0.88\n12 0.17\n",
            "output": "7.60920\n7.73610\n7.77460\n7.74760\n7.91770\n7.74220\n7.71860\n"
        },
        {
            "input": "22\n0.53 0.11 0.92 0.61 0.06 0.51 0.79 0.64 0.18 0.49 0.76 0.07 0.98 0.36 0.30 0.17 0.06 0.51 0.82 0.22 0.38 0.55\n21 17\n3 17\n18 13\n1 9\n2 9\n0 11\n7 21\n0 14\n0 15\n0 12\n8 0\n1 19\n15 1\n7 1\n11 16\n7 5\n4 20\n11 13\n4 6\n8 6\n3 10\n9\n19 0.43\n1 0.28\n4 0.32\n21 0.65\n6 0.89\n17 0.06\n13 0.12\n16 0.24\n18 0.32\n",
            "output": "4.77730\n4.99320\n4.94900\n4.93400\n4.98400\n5.10100\n5.07460\n5.06200\n5.12200\n"
        },
        {
            "input": "23\n0.04 0.12 0.51 0.98 0.97 0.12 0.93 0.90 0.67 0.80 0.18 0.15 0.66 0.69 0.34 0.88 0.79 0.12 0.97 0.81 0.59 0.78 0.61\n12 5\n6 20\n15 18\n3 18\n11 4\n0 14\n7 8\n8 10\n22 19\n14 12\n4 19\n16 9\n17 7\n18 21\n9 22\n22 12\n21 6\n22 21\n10 11\n8 2\n11 1\n3 13\n26\n3 0.73\n2 0.20\n17 0.18\n0 0.59\n8 0.27\n8 0.38\n14 0.69\n7 0.86\n3 0.25\n4 0.71\n18 0.47\n10 0.56\n17 0.00\n0 0.89\n14 0.53\n17 0.32\n20 0.37\n16 0.39\n3 0.83\n16 0.79\n17 0.88\n22 1.00\n3 0.44\n8 0.19\n15 0.04\n11 0.57\n",
            "output": "5.89470\n6.10240\n6.04840\n5.86140\n5.57340\n5.65260\n5.56510\n5.54750\n5.86430\n5.85390\n5.80890\n5.98750\n6.14230\n5.93530\n6.02330\n5.74810\n5.95270\n6.27270\n6.17990\n5.85990\n5.37830\n5.35880\n5.42120\n5.34900\n5.74380\n6.00000\n"
        },
        {
            "input": "3\n0.62 0.97 0.83\n2 0\n1 0\n26\n0 0.92\n2 0.25\n1 0.01\n1 0.28\n1 0.45\n1 0.59\n0 0.66\n2 0.77\n0 0.83\n0 0.54\n1 0.81\n1 0.19\n0 0.78\n0 0.84\n2 0.75\n0 0.76\n1 0.55\n1 0.85\n2 0.40\n0 0.83\n2 0.99\n0 0.12\n2 0.14\n1 0.72\n1 0.45\n1 0.29\n",
            "output": "0.26400\n0.79760\n1.68080\n1.43240\n1.27600\n1.14720\n1.10560\n0.76240\n0.70120\n0.80560\n0.68680\n1.02160\n1.03120\n1.03360\n1.05040\n1.04560\n0.77200\n0.54400\n0.81000\n0.79250\n0.30280\n0.89920\n1.00120\n1.01680\n1.04920\n1.06840\n"
        },
        {
            "input": "12\n0.92 0.61 0.96 0.20 0.66 0.10 0.92 0.35 0.39 0.68 0.15 0.28\n6 10\n0 11\n7 11\n9 7\n4 0\n8 1\n6 2\n5 0\n7 8\n9 3\n2 8\n21\n6 0.61\n3 0.94\n3 0.02\n5 0.58\n1 0.25\n0 0.19\n0 0.15\n5 0.67\n5 0.76\n1 0.79\n0 0.35\n1 0.22\n1 0.49\n10 0.67\n2 0.40\n3 0.49\n9 0.33\n4 0.97\n5 0.83\n1 0.68\n4 0.64\n",
            "output": "3.99530\n3.49210\n4.11770\n3.67610\n3.81650\n3.46610\n3.44690\n3.43340\n3.41990\n3.20930\n3.26930\n3.49160\n3.38630\n3.06910\n3.06910\n2.74950\n2.69350\n2.58500\n2.56050\n2.48640\n2.60190\n"
        },
        {
            "input": "26\n0.98 0.64 0.06 0.90 0.01 0.73 0.21 0.98 0.65 1.00 0.87 0.85 0.01 0.06 0.65 0.00 0.65 0.40 0.71 0.80 0.66 0.16 0.54 0.39 0.21 0.29\n20 21\n9 23\n9 0\n17 13\n16 20\n1 8\n9 4\n22 15\n14 17\n14 6\n2 16\n5 19\n11 23\n2 14\n12 10\n23 20\n20 24\n4 25\n6 3\n8 7\n0 22\n10 17\n22 8\n19 21\n4 18\n13\n9 0.04\n2 0.21\n9 0.89\n18 0.93\n11 0.21\n17 0.67\n3 0.03\n4 0.07\n22 0.45\n25 0.47\n0 0.21\n15 0.40\n8 0.90\n",
            "output": "7.05330\n7.00830\n7.53530\n7.53310\n7.78270\n7.89610\n8.07880\n8.07220\n8.03890\n8.02630\n8.28810\n8.10810\n8.09060\n"
        },
        {
            "input": "11\n0.07 0.85 0.27 0.71 0.24 0.43 0.64 0.34 0.03 0.41 0.46\n3 6\n4 1\n5 9\n1 5\n5 2\n2 8\n9 10\n7 1\n0 10\n6 10\n9\n0 0.51\n1 0.75\n8 0.39\n9 0.92\n5 0.27\n2 0.25\n4 0.55\n7 0.01\n4 0.51\n",
            "output": "3.46900\n3.37000\n3.27280\n3.32890\n3.31930\n3.31250\n3.08000\n3.32750\n3.35750\n"
        },
        {
            "input": "9\n0.02 0.64 0.38 0.37 0.32 0.53 0.97 0.07 0.99\n0 2\n2 1\n8 4\n3 6\n1 3\n1 4\n1 5\n4 7\n1\n4 0.63\n",
            "output": "2.67330\n"
        },
        {
            "input": "5\n0.50 0.29 0.49 0.95 0.83\n2 3\n0 3\n3 4\n2 1\n29\n4 0.66\n1 0.69\n0 0.36\n0 0.46\n3 0.05\n4 0.08\n2 0.20\n0 0.01\n4 0.53\n3 0.94\n4 0.36\n0 0.04\n2 0.47\n3 0.45\n1 0.02\n1 0.33\n4 0.32\n3 0.97\n4 0.87\n4 0.48\n1 0.79\n1 0.19\n0 0.10\n4 0.83\n0 0.33\n2 0.99\n3 0.92\n3 0.52\n1 0.28\n",
            "output": "1.68040\n1.48440\n1.61740\n1.52240\n1.17140\n1.20040\n1.12500\n1.14750\n1.12500\n2.24640\n2.40620\n2.37800\n2.20790\n1.65420\n1.96910\n1.82340\n1.84140\n2.44980\n1.91630\n2.29460\n2.07840\n2.36040\n2.30220\n1.96270\n1.73960\n1.65640\n1.66390\n1.72390\n1.63480\n"
        },
        {
            "input": "11\n0.99 0.23 0.01 0.76 0.80 0.46 0.24 0.25 0.91 0.36 0.72\n6 9\n1 10\n6 7\n8 4\n0 10\n0 9\n4 7\n1 5\n6 3\n5 2\n19\n10 0.13\n0 0.68\n10 0.52\n6 0.77\n8 0.25\n8 0.57\n7 0.59\n1 0.67\n6 0.98\n0 0.92\n6 0.94\n1 0.90\n10 0.56\n7 0.21\n0 0.23\n1 0.76\n2 0.84\n3 0.44\n8 0.11\n",
            "output": "2.81780\n2.65970\n2.69480\n3.02870\n3.55670\n3.30070\n3.10690\n3.11570\n3.17660\n3.20540\n3.19380\n3.19840\n3.16560\n3.44680\n3.39160\n3.39440\n3.01260\n3.31340\n3.68140\n"
        },
        {
            "input": "24\n0.73 0.01 0.74 0.45 0.99 0.18 0.40 0.97 0.07 0.79 0.63 0.71 0.34 0.31 0.61 0.07 0.59 0.73 0.20 0.31 0.82 0.04 0.29 0.46\n18 15\n9 4\n7 17\n12 9\n11 0\n0 3\n6 3\n14 5\n18 9\n21 12\n9 17\n14 11\n18 13\n7 22\n11 22\n17 20\n23 22\n16 18\n8 17\n12 10\n22 19\n1 13\n2 14\n22\n10 0.70\n0 0.45\n14 0.52\n23 0.54\n5 0.61\n20 0.49\n22 0.09\n10 0.86\n12 0.87\n1 0.47\n14 0.02\n22 0.92\n4 0.23\n15 0.68\n9 0.50\n2 0.92\n7 0.54\n21 0.86\n7 0.88\n16 0.52\n5 0.26\n0 0.96\n",
            "output": "6.48650\n6.53130\n6.49800\n6.47480\n6.25120\n6.49210\n6.39810\n6.34370\n6.50800\n6.36540\n6.39540\n6.78550\n7.38590\n7.26390\n6.98260\n6.97900\n7.25850\n6.54510\n6.32410\n6.33810\n6.34510\n6.26350\n"
        },
        {
            "input": "8\n0.52 0.43 0.88 0.82 0.11 0.54 0.29 0.52\n2 5\n5 0\n2 3\n1 7\n1 5\n5 6\n4 3\n7\n6 0.19\n5 0.95\n0 0.42\n3 0.09\n0 0.07\n1 0.39\n4 0.10\n",
            "output": "2.62380\n3.02560\n3.12060\n3.11330\n3.44580\n3.46460\n3.46550\n"
        },
        {
            "input": "21\n0.13 0.81 0.85 0.31 0.44 0.55 0.24 0.03 0.10 0.76 0.92 0.99 0.55 0.82 0.92 0.64 0.29 0.47 0.77 0.27 0.57\n7 6\n19 13\n2 0\n19 6\n18 0\n16 5\n1 18\n15 3\n10 11\n14 12\n20 10\n2 14\n5 4\n8 10\n10 2\n5 13\n15 14\n1 6\n9 3\n2 17\n3\n9 0.86\n16 0.57\n5 0.85\n",
            "output": "6.25490\n6.10090\n6.15190\n"
        },
        {
            "input": "3\n0.45 0.29 0.69\n1 0\n2 0\n6\n2 0.64\n2 0.85\n1 0.63\n1 0.21\n2 0.24\n1 0.03\n",
            "output": "1.03150\n0.93700\n0.78400\n0.97300\n1.24750\n1.32850\n"
        },
        {
            "input": "11\n0.07 0.85 0.27 0.71 0.24 0.43 0.64 0.34 0.03 0.41 0.46\n3 8\n4 1\n5 9\n1 5\n5 2\n1 8\n9 10\n7 1\n0 10\n6 9\n9\n0 0.51\n1 0.75\n8 0.39\n9 0.92\n5 0.27\n2 0.25\n4 0.55\n7 0.01\n4 0.51\n",
            "output": "3.83670\n3.64070\n3.47510\n3.71480\n3.70520\n3.71060\n3.47810\n3.72560\n3.75560\n"
        },
        {
            "input": "23\n0.04 0.12 0.51 0.98 0.97 0.12 0.93 0.90 0.67 0.80 0.18 0.15 0.66 0.69 0.34 0.88 0.79 0.12 0.97 0.81 0.59 0.78 0.61\n12 5\n6 20\n15 18\n3 18\n11 4\n0 14\n7 8\n8 10\n22 19\n14 12\n4 19\n16 9\n17 10\n18 21\n9 22\n17 12\n21 6\n22 21\n10 11\n8 2\n11 1\n3 13\n26\n3 0.73\n2 0.20\n17 0.18\n0 0.59\n8 0.27\n8 0.38\n14 0.69\n7 0.86\n3 0.25\n4 0.71\n18 0.47\n10 0.56\n17 0.00\n2 0.89\n14 0.53\n15 0.32\n20 0.37\n16 0.39\n3 0.83\n16 0.79\n17 0.88\n22 1.00\n3 0.44\n4 0.19\n15 0.04\n11 0.57\n",
            "output": "5.09450\n5.30220\n5.31180\n5.12480\n4.83680\n4.91600\n4.82850\n4.84370\n5.16050\n5.15010\n5.10510\n5.59530\n5.63490\n5.37270\n5.41270\n5.67590\n5.88050\n6.20050\n6.10770\n5.78770\n5.59410\n5.44200\n5.50440\n5.48360\n5.61520\n6.08980\n"
        },
        {
            "input": "17\n0.41 0.74 0.61 0.67 0.99 0.24 0.74 0.62 0.76 0.33 0.65 0.25 0.37 0.03 0.84 0.52 0.41\n14 12\n6 16\n9 4\n5 8\n6 4\n10 12\n15 8\n3 1\n7 8\n5 0\n12 1\n15 10\n14 9\n13 3\n16 2\n11 9\n13\n3 0.08\n12 0.58\n6 0.48\n0 0.92\n10 0.17\n2 0.40\n0 0.67\n10 0.54\n9 0.74\n2 0.64\n5 0.28\n16 0.99\n3 0.14\n",
            "output": "4.78560\n4.73730\n4.84130\n4.71890\n4.76690\n4.85300\n4.91300\n4.87600\n4.84320\n4.74480\n4.72760\n4.65800\n4.67180\n"
        },
        {
            "input": "3\n0.62 0.97 0.83\n2 0\n1 0\n26\n1 0.92\n2 0.25\n1 0.01\n1 0.28\n1 0.45\n1 0.59\n0 0.66\n2 0.77\n2 0.83\n0 0.54\n1 0.81\n1 0.19\n0 0.78\n0 0.84\n2 0.75\n0 0.76\n1 0.55\n1 0.85\n2 0.40\n0 0.83\n2 0.99\n0 0.12\n2 0.14\n1 0.72\n1 0.45\n1 0.29\n",
            "output": "0.53500\n0.89460\n1.45880\n1.29140\n1.18600\n1.09920\n1.10560\n0.76240\n0.72280\n0.77320\n0.65440\n0.98920\n0.98440\n0.98320\n1.05040\n1.04560\n0.77200\n0.54400\n0.81000\n0.79250\n0.30280\n0.89920\n1.00120\n1.01680\n1.04920\n1.06840\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint n;\ndouble p[N];\nvector<int> adj[N];\nint par[N];\ndouble sum[N];\nvoid dfs(int u, int pa) {\n  par[u] = pa;\n  for (int v : adj[u]) {\n    if (v == pa) {\n      continue;\n    }\n    dfs(v, u);\n    sum[u] += (1. - p[v]);\n  }\n}\ndouble preCalc() {\n  double res = 1. - p[0];\n  for (int i = 1; i < n; i++) {\n    res += p[par[i]] * (1. - p[i]);\n  }\n  return res;\n}\ndouble getVal(int u) {\n  double res = u ? p[par[u]] * (1. - p[u]) : (1. - p[u]);\n  res += p[u] * sum[u];\n  return res;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf\", p + i);\n  }\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  dfs(0, -1);\n  double res = preCalc();\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int u;\n    double x;\n    scanf(\"%d %lf\", &u, &x);\n    res -= getVal(u);\n    if (u) sum[par[u]] -= (1. - p[u]);\n    p[u] = x;\n    if (u) sum[par[u]] += (1. - p[u]);\n    res += getVal(u);\n    printf(\"%0.14f\\n\", res);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n  int pre, next;\n} pool[200005];\nint N, Q;\nint tot = 0;\ndouble ans = 0;\nint f[100005];\nint head[100005];\ndouble p[100005];\ndouble sum[100005];\ninline int read_int() {\n  register int ret = 0, f = 1;\n  register char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    ret = (ret << 1) + (ret << 3) + int(c - 48);\n    c = getchar();\n  }\n  return ret * f;\n}\ninline void add_edge(int u, int v) {\n  pool[++tot].pre = head[u];\n  pool[tot].next = v;\n  head[u] = tot;\n  pool[++tot].pre = head[v];\n  pool[tot].next = u;\n  head[v] = tot;\n}\ninline void init() {\n  N = read_int();\n  p[0] = 1.0;\n  for (register int i = 1; i <= N; i++) scanf(\"%lf\", &p[i]);\n  for (register int i = 1; i < N; i++) {\n    int u = read_int() + 1, v = read_int() + 1;\n    add_edge(u, v);\n  }\n  Q = read_int();\n}\nvoid dfs(int u, int father) {\n  f[u] = father;\n  ans += p[father] * (1.0 - p[u]);\n  for (register int i = head[u]; i; i = pool[i].pre) {\n    int v = pool[i].next;\n    if (v == father) continue;\n    dfs(v, u);\n    sum[u] += 1.0 - p[v];\n  }\n}\ninline void calc() {\n  while (Q--) {\n    int u = read_int() + 1;\n    double pro;\n    scanf(\"%lf\", &pro);\n    ans -= p[f[u]] * (1.0 - p[u]);\n    ans -= p[u] * sum[u];\n    sum[f[u]] -= 1.0 - p[u];\n    p[u] = pro;\n    ans += p[f[u]] * (1.0 - p[u]);\n    ans += p[u] * sum[u];\n    sum[f[u]] += (1.0 - p[u]);\n    printf(\"%.5lf\\n\", ans);\n  }\n}\nint main() {\n  init();\n  dfs(1, 0);\n  calc();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ndouble p[100006], q[100006], P, ans;\nint a, i, x, y, Q, pa[100006];\nstd::vector<int> G[100006];\nvoid dfs(int r, int par) {\n  pa[r] = par;\n  for (int k = 0; k < G[r].size(); k++) {\n    if (G[r][k] != par) {\n      q[r] += p[G[r][k]];\n      dfs(G[r][k], r);\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &a);\n  for (i = 0; i < a; i++) scanf(\"%lf\", &p[i]), p[i] = 1 - p[i], ans += p[i];\n  for (i = 1; i < a; i++) {\n    scanf(\"%d%d\", &x, &y);\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  dfs(0, -1);\n  for (i = 0; i < a; i++) ans -= p[i] * q[i];\n  scanf(\"%d\", &Q);\n  while (Q--) {\n    scanf(\"%d%lf\", &x, &P);\n    P = 1 - P;\n    ans -= p[x];\n    ans += P;\n    if (pa[x] != -1) {\n      ans += p[pa[x]] * q[pa[x]];\n      q[pa[x]] += (P - p[x]);\n      ans -= p[pa[x]] * q[pa[x]];\n    }\n    ans += p[x] * q[x];\n    ans -= P * q[x];\n    p[x] = P;\n    printf(\"%lf\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nuint64_t rnd_data = 0xDEADBEEFDULL;\ninline void my_srand(int seed) { rnd_data = ((uint64_t)seed << 16) | 0x330E; }\ninline int my_rand() {\n  rnd_data = rnd_data * 0x5DEECE66DULL + 0xB;\n  return (rnd_data >> 17) & 0x7FFFFFFF;\n}\ntemplate <typename T>\nvoid my_random_shuffle(T b, T e) {\n  for (int i = (1); i <= (int)((int)(e - b) - 1); i++) {\n    swap(b[i], b[my_rand() % (i + 1)]);\n  }\n}\ntemplate <class _T>\ninline _T sqr(const _T &x) {\n  return x * x;\n}\ntemplate <typename type_t, typename less_t = std::less<type_t>>\ninline bool uin(type_t &a, const type_t &b, const less_t &ls = less_t()) {\n  return ls(b, a) ? a = b, true : false;\n}\ntemplate <typename type_t, typename less_t = std::less<type_t>>\ninline bool uax(type_t &a, const type_t &b, const less_t &ls = less_t()) {\n  return ls(a, b) ? a = b, true : false;\n}\nconst long double PI = 3.1415926535897932384626433832795L;\nconst long double EPS = 1e-9;\nconst int MAXN = 202400;\nconst size_t LIM = 300;\nint n;\nlong double p[MAXN];\nvector<int> a[MAXN];\nvector<int> al[MAXN];\nvector<int> ah[MAXN];\nlong double s[MAXN];\nlong double sh[MAXN];\nbool hv[MAXN];\nvoid precalc() {\n  for (int i = 0; i < (int)(n); i++) {\n    s[i] = 0.0;\n    for (int vn : al[i]) {\n      s[i] += p[vn];\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < (int)(n); i++) {\n    double x;\n    scanf(\"%lf\", &x);\n    p[i] = x;\n  }\n  for (int i = 0; i < (int)(n - 1); i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  for (int i = 0; i < (int)(n); i++) {\n    hv[i] = a[i].size() > LIM;\n    sh[i] = 0.0;\n  }\n  for (int i = 0; i < (int)(n); i++) {\n    for (int vn : a[i]) {\n      if (hv[vn]) {\n        ah[i].push_back(vn);\n      } else {\n        al[i].push_back(vn);\n      }\n    }\n  }\n  precalc();\n  for (int i = 0; i < (int)(n); i++) {\n    if (hv[i]) {\n      for (auto vn : a[i]) {\n        sh[i] += 1.0 - p[vn];\n      }\n    }\n  }\n  int m;\n  scanf(\"%d\", &m);\n  long double spall = 0.0;\n  for (int i = 0; i < (int)(n); i++) {\n    spall += p[i];\n  }\n  long double sumprev = 0.0;\n  for (int j = 0; j < (int)(n); j++) {\n    sumprev += a[j].size() * p[j];\n    sumprev += (1.0 - p[j]) * s[j];\n    sumprev += p[j] * sh[j];\n  }\n  for (int i = 0; i < (int)(m); i++) {\n    int x;\n    double y;\n    scanf(\"%d%lf\", &x, &y);\n    spall -= p[x];\n    sumprev -= a[x].size() * p[x] + (1.0 - p[x]) * s[x] + p[x] * sh[x];\n    if (!hv[x]) {\n      for (int vn : a[x]) {\n        sumprev -= (1.0 - p[vn]) * s[vn];\n        s[vn] -= p[x];\n      }\n    }\n    for (auto vn : ah[x]) {\n      sumprev -= p[vn] * sh[vn];\n      sh[vn] -= 1.0 - p[x];\n    }\n    p[x] = y;\n    for (auto vn : ah[x]) {\n      sh[vn] += 1.0 - p[x];\n      sumprev += p[vn] * sh[vn];\n    }\n    if (!hv[x]) {\n      for (int vn : a[x]) {\n        s[vn] += p[x];\n        sumprev += (1.0 - p[vn]) * s[vn];\n      }\n    }\n    spall += p[x];\n    sumprev += a[x].size() * p[x] + (1.0 - p[x]) * s[x] + p[x] * sh[x];\n    long double ans = 2.0 + sumprev;\n    ans -= spall * 2.0;\n    ans /= 2.0;\n    printf(\"%0.9f\\n\", (double)ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, q, fa[100050];\nlong double p[100050], sum[100050], ans;\nvector<int> adj[100050];\nvoid dfs(int u) {\n  ans += (1.0 - p[u]) * p[fa[u]];\n  for (register int i = 0; i < adj[u].size(); ++i)\n    if (adj[u][i] != fa[u])\n      fa[adj[u][i]] = u, sum[u] += 1.0 - p[adj[u][i]], dfs(adj[u][i]);\n}\nint main() {\n  int u, v;\n  double w;\n  scanf(\"%d\", &n);\n  p[0] = 1;\n  for (register int i = 1; i <= n; ++i) scanf(\"%lf\", &w), p[i] = w;\n  for (register int i = 1; i < n; ++i)\n    scanf(\"%d%d\", &u, &v), ++u, ++v, adj[u].push_back(v), adj[v].push_back(u);\n  dfs(1);\n  scanf(\"%d\", &q);\n  while (q--) {\n    scanf(\"%d%lf\", &u, &w);\n    ++u;\n    ans -= (1.0 - p[u]) * p[fa[u]];\n    ans -= sum[u] * p[u];\n    sum[fa[u]] -= 1.0 - p[u];\n    p[u] = w;\n    ans += (1.0 - p[u]) * p[fa[u]];\n    ans += sum[u] * p[u];\n    sum[fa[u]] += 1.0 - p[u];\n    printf(\"%.6lf\\n\", double(ans));\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 2e9;\nconst long long LINF = 2e16;\nconst int magic = 348;\nconst int MOD = 998244353;\nconst double eps = 1e-10;\nconst double pi = acos(-1);\nstruct fastio {\n  static const int S = 1e7;\n  char rbuf[S + 48], wbuf[S + 48];\n  int rpos, wpos, len;\n  fastio() { rpos = len = wpos = 0; }\n  inline char Getchar() {\n    if (rpos == len) rpos = 0, len = fread(rbuf, 1, S, stdin);\n    if (!len) return EOF;\n    return rbuf[rpos++];\n  }\n  template <class T>\n  inline void Get(T &first) {\n    char ch;\n    bool f;\n    T res;\n    while (!isdigit(ch = Getchar()) && ch != '-') {\n    }\n    if (ch == '-')\n      f = false, res = 0;\n    else\n      f = true, res = ch - '0';\n    while (isdigit(ch = Getchar())) res = res * 10 + ch - '0';\n    first = (f ? res : -res);\n  }\n  inline void getstring(char *s) {\n    char ch;\n    while ((ch = Getchar()) <= 32) {\n    }\n    for (; ch > 32; ch = Getchar()) *s++ = ch;\n    *s = '\\0';\n  }\n  inline void flush() {\n    fwrite(wbuf, 1, wpos, stdout);\n    fflush(stdout);\n    wpos = 0;\n  }\n  inline void Writechar(char ch) {\n    if (wpos == S) flush();\n    wbuf[wpos++] = ch;\n  }\n  template <class T>\n  inline void Print(T first, char ch) {\n    char s[20];\n    int pt = 0;\n    if (first == 0)\n      s[++pt] = '0';\n    else {\n      if (first < 0) Writechar('-'), first = -first;\n      while (first) s[++pt] = '0' + first % 10, first /= 10;\n    }\n    while (pt) Writechar(s[pt--]);\n    Writechar(ch);\n  }\n  inline void printstring(char *s) {\n    int pt = 1;\n    while (s[pt] != '\\0') Writechar(s[pt++]);\n  }\n} io;\ntemplate <typename T>\ninline void check_max(T &first, T cmp) {\n  first = max(first, cmp);\n}\ntemplate <typename T>\ninline void check_min(T &first, T cmp) {\n  first = min(first, cmp);\n}\ntemplate <typename T>\ninline T myabs(T first) {\n  return first >= 0 ? first : -first;\n}\nconst int MAXN = 1e5;\nint n, q;\ndouble p[MAXN + 48], dp[MAXN + 48], psum[MAXN + 48];\nint fa[MAXN + 48];\nvector<int> v[MAXN + 48];\ninline void dfs(int cur, int father) {\n  dp[cur] = psum[cur] = 0;\n  fa[cur] = father;\n  for (auto second : v[cur])\n    if (second != father)\n      dfs(second, cur), dp[cur] += dp[second],\n          psum[cur] += double(1.0 - p[second]);\n  dp[cur] -= double(1.0 - p[cur]) * (psum[cur] - 1);\n}\nint main() {\n  scanf(\"%d\", &n);\n  int first, second;\n  double nv;\n  for (register int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  for (register int i = 1; i <= n - 1; i++) {\n    scanf(\"%d%d\", &first, &second);\n    first++;\n    second++;\n    v[first].push_back(second);\n    v[second].push_back(first);\n  }\n  dfs(1, -1);\n  scanf(\"%d\", &q);\n  double ans = dp[1];\n  while (q--) {\n    scanf(\"%d%lf\", &first, &nv);\n    first++;\n    ans += double(1.0 - p[first]) * (psum[first] - 1);\n    ans -= double(1.0 - nv) * (psum[first] - 1);\n    if (first != 1) {\n      int f = fa[first];\n      ans += double(1.0 - p[f]) * (psum[f] - 1);\n      psum[f] -= double(1.0 - p[first]);\n      psum[f] += double(1.0 - nv);\n      ans -= double(1.0 - p[f]) * (psum[f] - 1);\n    }\n    p[first] = nv;\n    printf(\"%lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, q;\nvector<int> G[1000005];\nint fa[1000005];\ndouble pr[1000005], sumpr[1000005];\nvoid dfs(int v, int p) {\n  fa[v] = p;\n  for (auto to : G[v]) {\n    if (to == p) continue;\n    sumpr[v] += (1.0 - pr[to]);\n    dfs(to, v);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &pr[i]);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u++;\n    v++;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs(1, 0);\n  double ans = 0;\n  for (int i = 1; i <= n; i++) ans += pr[i] * sumpr[i];\n  ans += (1.0 - pr[1]);\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    int v;\n    double d;\n    scanf(\"%d%lf\", &v, &d);\n    v++;\n    ans -= (1.0 - pr[1]);\n    if (fa[v]) {\n      ans -= pr[fa[v]] * sumpr[fa[v]];\n      sumpr[fa[v]] -= (d - pr[v]);\n      ans += pr[fa[v]] * sumpr[fa[v]];\n    }\n    ans -= pr[v] * sumpr[v];\n    pr[v] = d;\n    ans += pr[v] * sumpr[v];\n    ans += (1.0 - pr[1]);\n    printf(\"%.10f\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint pro[100001];\nvector<int> edge[100001];\nint sum[100001];\nint par[100001];\nvoid dfs(int x, int p) {\n  par[x] = p;\n  for (int i : edge[x]) {\n    if (i == p) continue;\n    dfs(i, x);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    double x;\n    scanf(\"%lf\", &x);\n    pro[i] = llround(100 * (1 - x));\n  }\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    ++x;\n    ++y;\n    edge[x].push_back(y);\n    edge[y].push_back(x);\n  }\n  dfs(1, 0);\n  int v = 0, e = 0;\n  for (int i = 1; i <= n; ++i) {\n    sum[par[i]] += pro[i];\n  }\n  for (int i = 1; i <= n; ++i) {\n    v += pro[i];\n    e += sum[i] * pro[i];\n  }\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int x;\n    double p;\n    scanf(\"%d%lf\", &x, &p);\n    ++x;\n    int pr = pro[x];\n    v -= pro[x];\n    e -= sum[par[x]] * pro[par[x]];\n    e -= sum[x] * pro[x];\n    pro[x] = llround(100 * (1 - p));\n    sum[par[x]] += pro[x] - pr;\n    v += pro[x];\n    e += sum[par[x]] * pro[par[x]];\n    e += sum[x] * pro[x];\n    printf(\"%.5f\\n\", v / 100.0 - e / 10000.0);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int lim = 300;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.setf(ios::fixed);\n  cout.precision(5);\n  int n;\n  cin >> n;\n  vector<double> p(n);\n  vector<vector<int> > t(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i];\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    t[u].push_back(v);\n    t[v].push_back(u);\n  }\n  vector<vector<int> > l(n), h(n);\n  vector<double> sum(n, 0);\n  double ans = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int v : t[i]) {\n      sum[i] += p[v];\n      if (t[v].size() > lim)\n        h[i].push_back(v);\n      else\n        l[i].push_back(v);\n    }\n    ans -= sum[i] * p[i] / 2;\n    ans += (t[i].size() - 1) * p[i];\n  }\n  cerr << \"ep \" << ans << endl;\n  int q;\n  cin >> q;\n  for (int z = 0; z < q; ++z) {\n    int u;\n    double np;\n    cin >> u >> np;\n    if (n == 1) {\n      cout << 1 - np << \"\\n\";\n      continue;\n    }\n    if (t[u].size() > lim) {\n      ans -= (np - p[u]) * sum[u];\n    } else {\n      sum[u] = 0;\n      for (int v : t[u]) {\n        sum[u] += p[v];\n      }\n      ans -= (np - p[u]) * sum[u];\n    }\n    ans += (t[u].size() - 1) * (np - p[u]);\n    for (int v : h[u]) {\n      sum[v] += np - p[u];\n    }\n    p[u] = np;\n    cout << ans << \"\\n\";\n  }\n  cout << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  cout.setf(ios::fixed);\n  cout.precision(12);\n  vector<vector<long long> > G(n);\n  vector<long double> V(n);\n  vector<long long> deg(n);\n  for (auto &x : V) cin >> x;\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n    deg[a]++;\n    deg[b]++;\n  }\n  if (n == 1) {\n    int q;\n    cin >> q;\n    while (q--) {\n      int a;\n      long double p;\n      cin >> a >> p;\n      cout << (1 - p) << endl;\n    }\n    return 0;\n  }\n  long double res = 1;\n  for (int i = 0; i < n; i++) res += V[i] * (G[i].size() - 1);\n  vector<long double> neighp(n, 0.0);\n  for (int i = 0; i < n; i++) {\n    for (auto x : G[i]) {\n      res -= 0.5 * V[i] * V[x];\n      neighp[i] += V[x];\n    }\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    int v;\n    long double p;\n    cin >> v >> p;\n    long double deltap = p - V[v];\n    res += (deg[v] - 1 - neighp[v]) * deltap;\n    for (auto x : G[v]) {\n      neighp[x] += deltap;\n    }\n    V[v] = p;\n    cout << res << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int sqn = 316;\nint n, a[100069], pc[100069];\nvector<int> al[100069];\nbitset<100069> spc;\nint main() {\n  int t, rr, i, j, k, l, w, sz, sm, z = 0;\n  vector<int> v;\n  char ch;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d %c%d\", &k, &ch, &l);\n    a[i] = 100 - (k * 100 + l);\n    z += a[i] * 100;\n  }\n  for (i = 0; i < n - 1; i++) {\n    scanf(\"%d%d\", &k, &l);\n    k++;\n    l++;\n    z -= a[k] * a[l];\n    al[k].push_back(l);\n    al[l].push_back(k);\n  }\n  for (i = 1; i <= n; i++) {\n    sz = al[i].size();\n    spc[i] = sz > sqn;\n  }\n  for (i = 1; i <= n; i++) {\n    v.clear();\n    sz = al[i].size();\n    for (j = 0; j < sz; j++) {\n      l = al[i][j];\n      if (spc[l]) {\n        if (!spc[i]) {\n          pc[l] += a[i];\n        } else {\n          v.push_back(l);\n        }\n      }\n    }\n    if (spc[i]) {\n      al[i] = v;\n    }\n  }\n  scanf(\"%d\", &t);\n  for (rr = 0; rr < t; rr++) {\n    scanf(\"%d%d %c%d\", &k, &l, &ch, &w);\n    k++;\n    w = 100 - (l * 100 + w);\n    sm = pc[k];\n    sz = al[k].size();\n    for (i = 0; i < sz; i++) {\n      l = al[k][i];\n      sm += a[l];\n    }\n    z += (w - a[k]) * (100 - sm);\n    if (!spc[i]) {\n      for (i = 0; i < sz; i++) {\n        l = al[k][i];\n        if (spc[l]) {\n          pc[l] += w - a[k];\n        }\n      }\n    }\n    a[k] = w;\n    printf(\"%d.\", z / 10000);\n    for (k = z % 10000, i = 0; k < 1000 && i < 3; k *= 10, i++) {\n      printf(\"0\");\n    }\n    printf(\"%d\\n\", z % 10000);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\nconst int N = 100005;\ndouble sumEdge[N], node[N], iniNode[N];\nunordered_set<int> edge[N], toUpdate;\ndouble res = 0.0;\nint n;\nvoid input_prepare() {\n  cin >> n;\n  for (int i = 0; i <= n - 1; ++i) {\n    double x;\n    cin >> x;\n    node[i] = 1.0 - x;\n    res += node[i];\n    iniNode[i] = node[i];\n  }\n  for (int i = 1; i <= n - 1; ++i) {\n    int x, y;\n    cin >> x >> y;\n    edge[x].insert(y);\n    edge[y].insert(x);\n    sumEdge[x] += node[y];\n    sumEdge[y] += node[x];\n  }\n  for (int i = 0; i <= n - 1; ++i) {\n    res -= (sumEdge[i] * node[i]) / 2;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  unordered_set<int>::iterator it;\n  input_prepare();\n  int q;\n  cin >> q;\n  while (q--) {\n    int v;\n    double val;\n    cin >> v >> val;\n    val = 1.0 - val;\n    double delta = val - node[v];\n    node[v] = val;\n    toUpdate.insert(v);\n    if ((int)toUpdate.size() >= 100) {\n      for (auto a : toUpdate) {\n        for (auto b : edge[a]) {\n          sumEdge[b] = sumEdge[b] - iniNode[a] + node[a];\n        }\n        iniNode[a] = node[a];\n      }\n      toUpdate.clear();\n    }\n    double temp = sumEdge[v];\n    for (int a : toUpdate) {\n      if (edge[v].find(a) != edge[v].end()) {\n        temp = temp + (-iniNode[a] + node[a]);\n      }\n    }\n    res = res + delta - temp * delta;\n    cout << fixed << setprecision(9) << res << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n  return x * f;\n}\nint n;\ndouble p[100100], sum[100100];\nconst int mod = 998244353;\nint qpow(int a, int b, int ans = 1) {\n  for (; b; b >>= 1, a = 1ll * a * a % mod)\n    if (b & 1) ans = 1ll * ans * a % mod;\n  return ans;\n}\nvector<int> ver[100100];\nint f[100100];\nvoid dfs(int x, int fa) {\n  for (int i = 0; i < ver[x].size(); ++i) {\n    int y = ver[x][i];\n    if (y == fa) continue;\n    dfs(y, x);\n    f[y] = x;\n    sum[x] += (1 - p[y]);\n  }\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; ++i) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; ++i) {\n    int u = read() + 1, v = read() + 1;\n    ver[u].push_back(v);\n    ver[v].push_back(u);\n  }\n  dfs(1, 0);\n  double ans = 0;\n  p[0] = 1;\n  for (int x = 1; x <= n; ++x) {\n    ans += p[f[x]] * (1 - p[x]);\n  }\n  int q = read();\n  while (q--) {\n    int x = read() + 1;\n    ans -= p[f[x]] * (1 - p[x]);\n    ans -= p[x] * sum[x];\n    sum[f[x]] -= (1 - p[x]);\n    scanf(\"%lf\", &p[x]);\n    sum[f[x]] += (1 - p[x]);\n    ans += p[x] * sum[x];\n    ans += p[f[x]] * (1 - p[x]);\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\n\n@SuppressWarnings(\"unchecked\")\npublic class D1045 {\n\t\n\tint n;\n\tArrayList<Integer>[] vs;\n\tdouble[] p;\n\tint[] par;\n\tdouble[] childSum;\n\t\n\tvoid dfs(int node, int pa) {\n\t\tpar[node] = pa;\n\t\tdouble sum = 0;\n\t\tfor(int v : vs[node]) if(v != pa) {\n\t\t\tdfs(v, node);\n\t\t\tsum += 1 - p[v];\n\t\t}\n\t\tchildSum[node] = sum;\n\t}\n\t\n\tpublic void solve(JoltyScanner in, PrintWriter out) {\n\t\tn = in.nextInt();\n\t\tvs = new ArrayList[n];\n\t\tp = new double[n];\n\t\tpar = new int[n];\n\t\tchildSum = new double[n];\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tvs[i] = new ArrayList<>();\n\t\t\tp[i] = in.nextDouble();\n\t\t}\n\t\tfor(int i = 0; i < n - 1; ++i) {\n\t\t\tint u = in.nextInt(), v = in.nextInt();\n\t\t\tvs[u].add(v); vs[v].add(u);\n\t\t}\n\t\tdfs(0, -1);\n\t\tdouble ans = 0;\n\t\tfor(int u = 0; u < n; ++u) ans += p[u] * childSum[u];\n\t\tans += 1 - p[0];\n\t\tint q = in.nextInt();\n\t\twhile(q-->0) {\n\t\t\tint node = in.nextInt();\n\t\t\tdouble np = in.nextDouble();\n\t\t\tdouble children = childSum[node];\n\t\t\t\n\t\t\t//take out all things with previous probability\n\t\t\t{\n\t\t\t\tdouble contrib = 1 - p[node];\n\t\t\t\tif(par[node] != -1) {\n\t\t\t\t\tcontrib *= p[par[node]];\n\t\t\t\t\tchildSum[par[node]] -= 1 - p[node];\n\t\t\t\t}\n\t\t\t\tans -= contrib;\n\t\t\t\tans -= children * p[node];\n\t\t\t}\n\t\t\t\n\t\t\t//add in stuff with new probability\n\t\t\tp[node] = np;\n\t\t\t{\n\t\t\t\tdouble contrib = 1 - p[node];\n\t\t\t\tif(par[node] != -1) {\n\t\t\t\t\tcontrib *= p[par[node]];\n\t\t\t\t\tchildSum[par[node]] += 1 - p[node];\n\t\t\t\t}\n\t\t\t\tans += contrib;\n\t\t\t\tans += children * p[node];\n\t\t\t}\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tJoltyScanner in = new JoltyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tnew D1045().solve(in, out);\n\t\tout.close();\n\t}\n\t\n\tstatic class JoltyScanner {\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\n\t\tpublic JoltyScanner() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\n\t\tpublic JoltyScanner(String s) throws FileNotFoundException {\n\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t}\n\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}\n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t        while(c!='.'&&c!='-'&&(c <'0' || c>'9')) c = nextChar();\n\t        boolean neg = c=='-';\n\t        if(neg)c=nextChar();\n\t        boolean fl = c=='.';\n\t        double cur = nextLong();\n\t        if(fl) return neg ? -cur/num : cur/num;\n\t        if(c == '.') {\n\t            double next = nextLong();\n\t            return neg ? -cur-next/num : cur+next/num;\n\t        }\n\t        else return neg ? -cur : cur;\n\t    }\n\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 205000;\nstruct edge {\n  int x, y;\n} e[maxn * 2];\ndouble a[maxn], f[maxn];\nint n, q;\nint fa[maxn];\ndouble ans;\nvector<int> g[maxn];\nvoid dfs(int u) {\n  for (auto v : g[u]) {\n    if (v == fa[u]) continue;\n    fa[v] = u;\n    f[u] += a[v];\n    dfs(v);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &a[i]), a[i] = 1.0 - a[i];\n  for (int i = 2; i <= n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    x++;\n    y++;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  dfs(1);\n  for (int i = 1; i <= n; i++) ans += a[i] * (1.0 - f[i]);\n  scanf(\"%d\", &q);\n  for (int i = 1; i <= q; i++) {\n    int x;\n    double y;\n    scanf(\"%d%lf\", &x, &y);\n    x++;\n    y = 1.0 - y;\n    ans -= a[x] * (1.0 - f[x]);\n    ans -= a[fa[x]] * (1.0 - f[fa[x]]);\n    f[fa[x]] += y - a[x];\n    a[x] = y;\n    ans += a[x] * (1.0 - f[x]);\n    ans += a[fa[x]] * (1.0 - f[fa[x]]);\n    printf(\"%.10lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble p[100010], s[100010];\nint n, q, d[100010], f[100010];\nvector<int> adj[100010];\nvoid dfs(int x, int fa = -1) {\n  f[x] = fa;\n  for (int i = 0; i < adj[x].size(); i++) {\n    int y = adj[x][i];\n    if (y == fa) continue;\n    dfs(y, x);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%lf\", p + i);\n  memset(d, -1, sizeof d);\n  for (int i = 1, x, y; i < n; i++) {\n    scanf(\"%d%d\", &x, &y);\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n    d[x]++;\n    d[y]++;\n  }\n  dfs(0);\n  for (int i = 0; i < n; i++)\n    if (i) s[f[i]] += p[i];\n  double S = 1;\n  for (int i = 0; i < n; i++) S += p[i] * (d[i] - s[i]);\n  scanf(\"%d\", &q);\n  while (q--) {\n    int x;\n    double px;\n    scanf(\"%d%lf\", &x, &px);\n    double ss = s[x];\n    if (x) ss += p[f[x]];\n    S += (px - p[x]) * (d[x] - ss);\n    printf(\"%lf\\n\", S);\n    if (x) s[f[x]] += px - p[x];\n    p[x] = px;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint n, m, u, v, tot, head[maxn], fa[maxn];\ndouble p[maxn], ps[maxn], ans, vv;\nstruct node {\n  int to, nxt;\n} e[maxn << 1];\nvoid add(int x, int y) {\n  e[++tot] = {y, head[x]};\n  head[x] = tot;\n}\nvoid dfs(int now, int f) {\n  ps[now] = 0;\n  ans -= 1.0 - p[now];\n  fa[now] = f;\n  for (int i = head[now]; ~i; i = e[i].nxt) {\n    int to = e[i].to;\n    if (to == f) continue;\n    ps[now] += p[to];\n    ans -= p[now] * p[to];\n    dfs(to, now);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  memset(head, -1, sizeof(head));\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]), p[i] = 1 - p[i];\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d\", &u, &v);\n    u++, v++;\n    add(u, v);\n    add(v, u);\n  }\n  ans = n;\n  dfs(1, 0);\n  cin >> m;\n  while (m--) {\n    scanf(\"%d%lf\", &u, &vv);\n    u++;\n    ans += p[fa[u]] * ps[fa[u]] + p[u] * ps[u] + 1.0 - p[u];\n    ps[fa[u]] -= p[u];\n    p[u] = 1.0 - vv;\n    ps[fa[u]] += p[u];\n    ans -= p[fa[u]] * ps[fa[u]] + p[u] * ps[u] + 1.0 - p[u];\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int mn = 110000;\nint n, xx, yy, be[mn], et, q, fa[mn];\ndouble p[mn], ans, f[mn], pp;\nstruct edg {\n  int y, ne;\n};\nedg e[mn * 2];\ninline void add_edge(int x, int y) {\n  e[++et].y = y;\n  e[et].ne = be[x];\n  be[x] = et;\n}\nvoid dfs(int x, int ff) {\n  fa[x] = ff;\n  for (int i = be[x]; i; i = e[i].ne)\n    if (e[i].y != ff) {\n      dfs(e[i].y, x);\n      f[x] += p[e[i].y];\n    }\n  ans += p[x] * (1 - f[x]);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lf\", &p[i]);\n    p[i] = 1 - p[i];\n  }\n  for (int i = 2; i <= n; i++) {\n    scanf(\"%d%d\", &xx, &yy);\n    xx++;\n    yy++;\n    add_edge(xx, yy);\n    add_edge(yy, xx);\n  }\n  dfs(1, -1);\n  scanf(\"%d\", &q);\n  while (q--) {\n    scanf(\"%d%lf\", &xx, &pp);\n    xx++;\n    pp = 1 - pp;\n    ans += (pp - p[xx]) * (1 - f[xx]);\n    if (fa[xx] > 0) {\n      int &ff = fa[xx];\n      ans += (-pp + p[xx]) * p[ff];\n      f[ff] += pp - p[xx];\n    }\n    p[xx] = pp;\n    printf(\"%.10f\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void proc_status() {\n  ifstream t(\"/proc/self/status\");\n  cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>())\n       << endl;\n}\ntemplate <typename T>\ninline bool chkmin(T &a, const T &b) {\n  return a > b ? a = b, 1 : 0;\n}\ntemplate <typename T>\ninline bool chkmax(T &a, const T &b) {\n  return a < b ? a = b, 1 : 0;\n}\ntemplate <typename T>\ninline T read() {\n  register T sum(0), fg(1);\n  register char ch(getchar());\n  for (; !isdigit(ch); ch = getchar())\n    if (ch == '-') fg = -1;\n  for (; isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n  return sum * fg;\n}\nconst int MAXN = (int)1e5;\nint n;\ndouble p[MAXN + 5];\nvector<int> adj[MAXN + 5];\ninline void input() {\n  n = read<int>();\n  for (int i = 1; i <= n; ++i) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; ++i) {\n    int u = read<int>() + 1, v = read<int>() + 1;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n}\ninline void solve() {\n  double EV = 0, EE = 0;\n  for (int i = 1; i <= n; ++i) EV += 1 - p[i];\n  const int LIM = (int)500;\n  static vector<int> spe[MAXN + 5];\n  static bool is_spe[MAXN + 5];\n  for (int u = 1; u <= n; ++u)\n    if (((int)(adj[u]).size()) >= LIM) {\n      is_spe[u] = 1;\n      for (auto v : adj[u]) spe[v].push_back(u);\n    }\n  static double sum[MAXN + 5];\n  for (int u = 1; u <= n; ++u)\n    for (auto v : adj[u]) {\n      EE += (1 - p[u]) * (1 - p[v]);\n      if (!is_spe[v]) sum[u] += 1 - p[v];\n    }\n  for (int Q = read<int>(); Q--;) {\n    int u = read<int>() + 1;\n    double p0;\n    scanf(\"%lf\", &p0);\n    EV -= 1 - p[u];\n    EV += 1 - p0;\n    double res = sum[u];\n    for (auto v : spe[u]) res += 1 - p[v];\n    EE -= res * (1 - p[u]) * 2;\n    EE += res * (1 - p0) * 2;\n    if (!is_spe[u])\n      for (auto v : adj[u]) sum[v] += (1 - p0) - (1 - p[u]);\n    p[u] = p0;\n    printf(\"%.6lf\\n\", EV - EE / 2);\n  }\n}\nint main() {\n  input();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 7;\nint n;\nint a[MAXN], d[MAXN];\nvector<int> g[MAXN];\nint r = 0, sum = 0;\nvoid read() {\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    double p;\n    cin >> p;\n    a[i] = round(100 - p * 100);\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n    r += a[u] * a[v];\n  }\n  for (int i = 0; i < n; ++i) sum += a[i];\n}\nint par[MAXN];\nvoid dfs(int u, int parent) {\n  par[u] = parent;\n  if (u) d[parent] += a[u];\n  for (int v : g[u]) {\n    if (v == parent) continue;\n    dfs(v, u);\n  }\n}\nvoid upd(int u, int delt) {\n  if (u) d[par[u]] += delt;\n  r += delt * d[u];\n  if (u) r += delt * a[par[u]];\n  a[u] += delt;\n  sum += delt;\n}\nvoid solve() {\n  dfs(0, -1);\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; ++i) {\n    int u;\n    double p;\n    cin >> u >> p;\n    int delt = round(100 - 100 * p) - a[u];\n    upd(u, delt);\n    cout << sum / 100.0 - r / 10000.0 << '\\n';\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  read();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble ans, p[100005], sum[100005];\nint n, tot, Q, fa[100005];\nstruct edge {\n  int v;\n  edge *next;\n} pool[100005 << 1], *h[100005];\nvoid addedge(int u, int v) {\n  edge *q = &pool[tot++];\n  q->v = v;\n  q->next = h[u];\n  h[u] = q;\n}\nvoid dfs(int u, int f) {\n  fa[u] = f;\n  for (edge *q = h[u]; q; q = q->next)\n    if (q->v != f) dfs(q->v, u), sum[u] += 1 - p[q->v];\n}\nint main() {\n  scanf(\"%d\", &n);\n  p[n] = 1;\n  for (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1, u, v; i < n; i++)\n    scanf(\"%d %d\", &u, &v), addedge(u, v), addedge(v, u);\n  dfs(0, n);\n  ans = 1 - p[0];\n  for (int i = 1; i < n; i++) ans = ans + (1 - p[i]) * p[fa[i]];\n  scanf(\"%d\", &Q);\n  for (int i = 1; i <= Q; i++) {\n    int x;\n    double pnw;\n    scanf(\"%d %lf\", &x, &pnw);\n    ans += (p[x] - pnw) * p[fa[x]];\n    ans += (pnw - p[x]) * sum[x];\n    printf(\"%.5lf\\n\", ans);\n    sum[fa[x]] += p[x] - pnw;\n    p[x] = pnw;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long p[(int)1e5 + 1];\nvector<int> adj[(int)1e5 + 1];\nint parent[(int)1e5 + 1];\nlong long dp[(int)1e5 + 1];\ninline long long getLL() {\n  float x;\n  cin >> x;\n  return (long long)(x * 100.0 + 1e-3);\n}\nvoid bfs(const int start) {\n  static int q[(int)1e5 + 1];\n  int head = 0, tail = 1;\n  q[0] = start;\n  while (head != tail) {\n    const int u = q[head++];\n    for (const int &v : adj[u])\n      if (v != parent[u]) {\n        parent[v] = u;\n        q[tail++] = v;\n      }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  cout << fixed << setprecision(6);\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; ++i) p[i] = getLL();\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  p[n] = 100;\n  adj[n].push_back(0);\n  adj[0].push_back(n);\n  parent[n] = -1;\n  bfs(n);\n  long long ans = 0;\n  for (int i = 0; i < n; ++i) {\n    ans += (100 - p[i]) * p[parent[i]];\n    dp[parent[i]] += 100 - p[i];\n  }\n  int Q;\n  cin >> Q;\n  while (Q--) {\n    int i;\n    cin >> i;\n    const long long x = getLL();\n    ans += (p[i] - x) * p[parent[i]];\n    ans += dp[i] * (x - p[i]);\n    dp[parent[i]] += p[i] - x;\n    p[i] = x;\n    cout << ans / 1e4 << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct line {\n  int v, next;\n} e[200005];\nint b[100005], t, f[100005], n, x, y, m;\ndouble s[100005], w[100005];\ninline void build(int x, int y) { e[++t].v = y, e[t].next = b[x], b[x] = t; }\nvoid dfs(int u) {\n  for (int o = b[u]; o != -1; o = e[o].next) {\n    int v = e[o].v;\n    if (v == f[u]) continue;\n    f[v] = u;\n    dfs(v);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  double ac = 0;\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &w[i]), ac += w[i] = 1 - w[i];\n  memset(b, -1, sizeof b);\n  t = -1;\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d\", &x, &y);\n    ++x, ++y;\n    build(x, y), build(y, x);\n  }\n  dfs(1);\n  for (int i = 2; i <= n; i++) s[f[i]] += w[i], ac -= w[i] * w[f[i]];\n  scanf(\"%d\", &m);\n  while (m--) {\n    scanf(\"%d\", &x);\n    ++x;\n    ac -= w[x] - (s[x] + w[f[x]]) * w[x];\n    s[f[x]] -= w[x];\n    scanf(\"%lf\", &w[x]);\n    w[x] = 1 - w[x];\n    ac += w[x] - (s[x] + w[f[x]]) * w[x];\n    s[f[x]] += w[x];\n    printf(\"%.8lf\\n\", ac);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, tot = 0, q;\nint v[200005], nxt[200005], h[100005], f[100005];\ndouble a[100005], sum[100005];\ndouble ans;\nvoid addedge(int x, int y) {\n  v[++tot] = y;\n  nxt[tot] = h[x];\n  h[x] = tot;\n  v[++tot] = x;\n  nxt[tot] = h[y];\n  h[y] = tot;\n}\nvoid dfs(int u, int fa) {\n  for (int p = h[u]; p; p = nxt[p]) {\n    if (v[p] == fa) continue;\n    f[v[p]] = u;\n    dfs(v[p], u);\n    sum[u] += 1 - a[v[p]];\n  }\n  ans += a[f[u]] * (1 - a[u]);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &a[i]);\n  int x, y;\n  double z;\n  for (int i = 1; i <= n - 1; i++) {\n    scanf(\"%d%d\", &x, &y);\n    addedge(x + 1, y + 1);\n  }\n  a[0] = 1, f[1] = 0;\n  dfs(1, 0);\n  scanf(\"%d\", &q);\n  for (int i = 1; i <= q; i++) {\n    scanf(\"%d%lf\", &x, &z);\n    x++;\n    ans +=\n        z * sum[x] - a[x] * sum[x] + a[f[x]] * (1 - z) - a[f[x]] * (1 - a[x]);\n    sum[f[x]] -= (1 - a[x]) - (1 - z);\n    a[x] = z;\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.util.stream.DoubleStream;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Ben King\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        DInterstellarBattle solver = new DInterstellarBattle();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DInterstellarBattle {\n        int N;\n        int[] parent;\n        List<List<Integer>> bullshit;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            N = in.nextInt();\n            double[] P = new double[N];\n            bullshit = new ArrayList<>();\n            for (int i = 0; i < N; i++) bullshit.add(new ArrayList<>());\n            parent = new int[N];\n            for (int i = 0; i < N; i++) P[i] = 1.0 - in.nextDouble();\n            List<List<Integer>> graph = new ArrayList<>();\n            for (int i = 0; i < N; i++) graph.add(new ArrayList<>());\n            for (int i = 0; i < N - 1; i++) {\n                int u = in.nextInt();\n                int v = in.nextInt();\n                graph.get(u).add(v);\n                graph.get(v).add(u);\n            }\n            int Q = in.nextInt();\n\n            double[] values = new double[N];\n            dfs(0, graph, P, -1, values);\n            double sum = Arrays.stream(values).sum();\n\n            for (int t = 0; t < Q; t++) {\n                int i = in.nextInt();\n                double qv = 1.0 - in.nextDouble();\n\n                sum -= P[i] * (parent[i] == -1 ? 1.0 : (1.0 - P[parent[i]]));\n                for (int j : bullshit.get(i))\n                    sum -= P[j] * (parent[j] == -1 ? 1.0 : (1.0 - P[parent[j]]));\n                P[i] = qv;\n                sum += P[i] * (parent[i] == -1 ? 1.0 : (1.0 - P[parent[i]]));\n                for (int j : bullshit.get(i))\n                    sum += P[j] * (parent[j] == -1 ? 1.0 : (1.0 - P[parent[j]]));\n                out.println(sum);\n            }\n\n            out.flush();\n        }\n\n        void dfs(int index, List<List<Integer>> graph, double[] P, int from, double[] answers) {\n            double prob = P[index] * (from == -1 ? 1.0 : (1.0 - P[from]));\n            answers[index] = prob;\n            parent[index] = from;\n            for (int neighbor : graph.get(index)) {\n                if (neighbor == from) continue;\n                bullshit.get(index).add(neighbor);\n                dfs(neighbor, graph, P, index, answers);\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                outputStream)));\n        }\n\n        public OutputWriter(java.io.Writer outputStreamWriter) {\n            writer = new PrintWriter(new BufferedWriter(outputStreamWriter));\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n\n        public void close() {\n            writer.flush();\n            writer.close();\n        }\n\n        public void println(double i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private static final int DEFAULT_BUFFER_SIZE = 1 << 16;\n        private static final InputStream DEFAULT_STREAM = System.in;\n        private int c;\n        private byte[] buf;\n        private int bufferSize;\n        private int bufIndex;\n        private int numBytesRead;\n        private InputStream stream;\n        private static final byte EOF = -1;\n        private static final byte SPACE = 32;\n        private static final byte DASH = 45;\n        private char[] charBuffer;\n        private static byte[] bytes = new byte[58];\n        private static int[] ints = new int[58];\n        private static char[] chars = new char[128];\n\n        static {\n            char ch = ' ';\n            int value = 0;\n            byte _byte = 0;\n            for (int i = 48; i < 58; i++) bytes[i] = _byte++;\n            for (int i = 48; i < 58; i++) ints[i] = value++;\n            for (int i = 32; i < 128; i++) chars[i] = ch++;\n        }\n\n        public InputReader() {\n            this(DEFAULT_STREAM, DEFAULT_BUFFER_SIZE);\n        }\n\n        public InputReader(int bufferSize) {\n            this(DEFAULT_STREAM, bufferSize);\n        }\n\n        public InputReader(InputStream stream) {\n            this(stream, DEFAULT_BUFFER_SIZE);\n        }\n\n        public InputReader(InputStream stream, int bufferSize) {\n            if (stream == null || bufferSize <= 0)\n                throw new IllegalArgumentException();\n            buf = new byte[bufferSize];\n            charBuffer = new char[128];\n            this.bufferSize = bufferSize;\n            this.stream = stream;\n        }\n\n        private int readJunk(int token) {\n\n            if (numBytesRead == EOF) return EOF;\n\n            // Seek to the first valid position index\n            do {\n\n                while (bufIndex < numBytesRead) {\n                    if (buf[bufIndex] > token) return 0;\n                    bufIndex++;\n                }\n\n                // reload buffer\n                try {\n                    numBytesRead = stream.read(buf);\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (numBytesRead == EOF) return EOF;\n                bufIndex = 0;\n\n            } while (true);\n\n        }\n\n        public int nextInt() {\n            try {\n                if (readJunk(DASH - 1) == EOF) throw new IOException();\n                int sgn = 1, res = 0;\n\n                c = buf[bufIndex];\n                if (c == DASH) {\n                    sgn = -1;\n                    bufIndex++;\n                }\n\n                do {\n\n                    while (bufIndex < numBytesRead) {\n                        if (buf[bufIndex] > SPACE) {\n                            res = (res << 3) + (res << 1);\n                            res += ints[buf[bufIndex++]];\n                        }\n                        else {\n                            bufIndex++;\n                            return res * sgn;\n                        }\n                    }\n\n                    // Reload buffer\n                    numBytesRead = stream.read(buf);\n                    if (numBytesRead == EOF) return res * sgn;\n                    bufIndex = 0;\n\n                } while (true);\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n                return -1;\n            }\n\n        }\n\n        private void doubleCharBufferSize() {\n            char[] newBuffer = new char[charBuffer.length << 1];\n            for (int i = 0; i < charBuffer.length; i++) newBuffer[i] = charBuffer[i];\n            charBuffer = newBuffer;\n        }\n\n        public String next() {\n            try {\n                if (numBytesRead == EOF) return null;\n                if (readJunk(SPACE) == EOF) return null;\n\n                for (int i = 0; ; ) {\n                    while (bufIndex < numBytesRead) {\n                        if (buf[bufIndex] > SPACE) {\n                            if (i == charBuffer.length) doubleCharBufferSize();\n                            charBuffer[i++] = (char) buf[bufIndex++];\n                        }\n                        else {\n                            bufIndex++;\n                            return new String(charBuffer, 0, i);\n                        }\n                    }\n\n                    // Reload buffer\n                    numBytesRead = stream.read(buf);\n                    if (numBytesRead == EOF) return new String(charBuffer, 0, i);\n                    bufIndex = 0;\n                }\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        public double nextDouble() {\n            String doubleVal = next();\n            if (doubleVal == null) throw new InputMismatchException();\n            return Double.valueOf(doubleVal);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, h[100005], cnt;\ndouble p[100005], ans = 0;\nstruct Edge {\n  int to, next;\n} w[200005];\nvoid add(int x, int y) {\n  w[++cnt] = (Edge){y, h[x]};\n  h[x] = cnt;\n}\nvoid dfs(int x, int fa) {\n  ans += (1 - p[x]);\n  for (int i = h[x]; i; i = w[i].next) {\n    int to = w[i].to;\n    if (to == fa) continue;\n    dfs(to, x);\n    ans -= (1 - p[x]) * (1 - p[to]);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    add(x, y);\n    add(y, x);\n  }\n  dfs(0, 0);\n  int m;\n  scanf(\"%d\", &m);\n  while (m--) {\n    int x;\n    double v;\n    scanf(\"%d%lf\", &x, &v);\n    ans -= 1 - p[x];\n    ans += 1 - v;\n    for (int i = h[x]; i; i = w[i].next) {\n      int to = w[i].to;\n      ans += (1 - p[x]) * (1 - p[to]);\n      ans -= (1 - v) * (1 - p[to]);\n    }\n    p[x] = v;\n    printf(\"%0.5lf\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read_int() {\n  char ch = getchar();\n  int res = 0, k = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-')\n      k = -1;\n    else\n      k = 1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    res = (res << 1) + (res << 3) + ch - '0';\n    ch = getchar();\n  }\n  return res * k;\n}\nint read_unsigned() {\n  char ch = getchar();\n  int res = 0;\n  while (ch < '0' || ch > '9') ch = getchar();\n  while (ch >= '0' && ch <= '9') {\n    res = (res << 1) + (res << 3) + ch - '0';\n    ch = getchar();\n  }\n  return res;\n}\nint n, fa[100005];\ndouble p[100005], sum[100005], ans;\nvector<int> tree[100005];\ninline void add(int a, int b) {\n  tree[a].push_back(b);\n  return;\n}\nvoid dfs(int root) {\n  for (int i = 0; i < tree[root].size(); ++i) {\n    int x = tree[root][i];\n    if (x == fa[root]) continue;\n    fa[x] = root;\n    dfs(x);\n    sum[root] += p[x];\n  }\n  ans += ((double)1 - p[fa[root]]) * p[root];\n}\nint main() {\n  n = read_unsigned();\n  for (int i = 1; i <= n; ++i) scanf(\"%lf\", &p[i]), p[i] = (double)1 - p[i];\n  for (int i = 1; i < n; ++i) {\n    int a = read_unsigned() + 1, b = read_unsigned() + 1;\n    add(a, b);\n    add(b, a);\n  }\n  dfs(1);\n  int q = read_unsigned();\n  while (q--) {\n    int x = read_unsigned() + 1;\n    double g, h = p[x];\n    scanf(\"%lf\", &g);\n    g = (double)1 - g;\n    ans += (g - h) * ((double)1 - p[fa[x]]);\n    ans += (h - g) * sum[x];\n    sum[fa[x]] += g - h;\n    p[x] = g;\n    printf(\"%.15lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\ndouble p[100001], q[100001], sum[100001];\nint par[100001];\nvector<int> adj[100001];\nint d[100001];\nbool vis[100001];\nvoid dfs(int id) {\n  vis[id] = true;\n  for (auto cur : adj[id]) {\n    if (vis[cur]) continue;\n    par[cur] = id;\n    d[id]++;\n    dfs(cur);\n  }\n}\ndouble ans = 1;\nvoid in(int& x) {\n  char c = getchar();\n  while (c < 48 || c > 57) c = getchar();\n  x = 0;\n  while (c >= 48 && c <= 57) {\n    x = x * 10 + c - 48;\n    c = getchar();\n  }\n}\nvoid in(double& x) {\n  char c = getchar();\n  while (c < 48 || c > 57) c = getchar();\n  x = 0;\n  while (c >= 48 && c <= 57) {\n    x = x * 10 + c - 48;\n    c = getchar();\n  }\n  int y = 0;\n  c = getchar();\n  while (c >= 48 && c <= 57) {\n    y = y * 10 + c - 48;\n    c = getchar();\n  }\n  x += y * 0.01;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  in(n);\n  for (int i = 1; i <= n; i++) in(q[i]);\n  p[0] = 1;\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    in(u);\n    in(v);\n    u++;\n    v++;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  dfs(1);\n  for (int i = 1; i <= n; i++) {\n    sum[par[i]] += q[i];\n    ans -= q[i] * (p[par[i]] - d[i] + sum[i]);\n    p[i] = q[i];\n  }\n  int q;\n  in(q);\n  for (int i = 1; i <= q; i++) {\n    int pos;\n    double r, s;\n    in(pos);\n    in(r);\n    pos++;\n    s = r - p[pos];\n    sum[par[pos]] += s;\n    ans -= s * (p[par[pos]] - d[pos] + sum[pos]);\n    p[pos] = r;\n    printf(\"%.5lf\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 512345;\ndouble p[N];\ndouble first[N];\nvector<int> adj[N];\nint pai[N];\nvoid dfs(int u, int a = -1) {\n  pai[u] = a;\n  for (int v : adj[u])\n    if (v != a) {\n      dfs(v, u);\n    }\n}\ndouble contrib(int i) { return (pai[i] == -1 ? 1 : p[pai[i]]) * (1.0 - p[i]); }\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf\", p + i);\n  }\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  dfs(0);\n  double e = 0;\n  for (int i = 0; i < n; i++) {\n    double ci = contrib(i);\n    e += ci;\n    if (pai[i] != -1) first[pai[i]] += 1 - p[i];\n  }\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int x;\n    scanf(\"%d\", &x);\n    double old = contrib(x);\n    e -= old;\n    if (pai[x] != -1) {\n      first[pai[x]] -= 1 - p[x];\n    }\n    e -= p[x] * first[x];\n    scanf(\"%lf\", p + x);\n    e += p[x] * first[x];\n    double nv = contrib(x);\n    e += nv;\n    if (pai[x] != -1) {\n      first[pai[x]] += 1 - p[x];\n    }\n    printf(\"%.16lf\\n\", e);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e5 + 50;\nint n, q;\nvector<int> G[N];\nint par[N];\ndouble pro[N], sum[N];\ndouble res = 0;\nvoid dfs(int v, int p = 0) {\n  par[v] = p;\n  sum[p] += pro[v];\n  for (int nxt : G[v]) {\n    if (nxt != p) dfs(nxt, v);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> pro[i], pro[i] = 1 - pro[i];\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    a++, b++;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  dfs(1, 0);\n  for (int i = 0; i <= n; i++) res += (1 - pro[i]) * sum[i];\n  cin >> q;\n  while (q--) {\n    int v;\n    double val;\n    cin >> v >> val;\n    v++;\n    val = 1 - val;\n    res -= (1 - pro[v]) * sum[v];\n    res -= (1 - pro[par[v]]) * sum[par[v]];\n    sum[par[v]] -= pro[v];\n    pro[v] = val;\n    sum[par[v]] += pro[v];\n    res += (1 - pro[v]) * sum[v];\n    res += (1 - pro[par[v]]) * sum[par[v]];\n    cout << fixed << setprecision(6) << res << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  char c = getchar();\n  long long u = 0, f = 1;\n  while (c != '-' && (c < '0' || '9' < c)) c = getchar();\n  if (c == '-') {\n    f = -1;\n    c = getchar();\n  }\n  while ('0' <= c && c <= '9') {\n    u = u * 10 + c - '0';\n    c = getchar();\n  }\n  return u * f;\n}\ninline char readc() {\n  for (;;) {\n    char c = getchar();\n    if ('A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') return c;\n  }\n}\ninline int read_digit() {\n  for (;;) {\n    char c = getchar();\n    if ('0' <= c && c <= '9') return c - '0';\n  }\n}\ninline int max(int a, int b) { return a > b ? a : b; }\ninline int min(int a, int b) { return a < b ? a : b; }\ntemplate <typename T>\ninline void updmax(T &a, T b) {\n  if (b > a) a = b;\n}\ntemplate <typename T>\ninline void updmin(T &a, T b) {\n  if (b < a) a = b;\n}\ninline void swap(int &a, int &b) {\n  int t = a;\n  a = b;\n  b = t;\n}\ninline void fileio(string s) {\n  if (s == \"txt\") {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n  } else {\n    freopen((s + \".in\").c_str(), \"r\", stdin);\n    freopen((s + \".out\").c_str(), \"w\", stdout);\n  }\n}\ndouble pos[100010], cpos[100010], sum[100010];\nvector<int> nspe[100010], spe[100010];\nint s[100010], t[100010], ck[100010], w[100010];\nint cnt[100010];\nbool isspe[100010];\ndouble ans = 1.0;\nvoid update(int k, double p) {\n  double p0 = pos[k], s0 = sum[k];\n  pos[k] = p;\n  if (!isspe[k]) {\n    sum[k] = 0;\n    for (auto u : spe[k]) sum[k] += pos[u];\n    for (auto u : nspe[k]) sum[k] += pos[u];\n  }\n  ans += p0 * sum[k];\n  ans -= p * sum[k];\n  ans -= p0 * (w[k] - 1);\n  ans += p * (w[k] - 1);\n  for (auto u : spe[k]) sum[u] += p - p0;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &pos[i]);\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d\", &s[i], &t[i]);\n    s[i]++;\n    t[i]++;\n  }\n  int q;\n  scanf(\"%d\", &q);\n  for (int i = 1; i <= q; i++) {\n    scanf(\"%d%lf\", &ck[i], &cpos[i]);\n    ck[i]++;\n  }\n  int v = int(sqrt(n));\n  for (int i = 1; i <= n; i++) cnt[ck[i]]++;\n  for (int i = 1; i <= n; i++)\n    if (cnt[i] >= v) isspe[i] = true;\n  for (int i = 1; i < n; i++) {\n    if (isspe[s[i]])\n      spe[t[i]].push_back(s[i]);\n    else\n      spe[t[i]].push_back(s[i]);\n    if (isspe[t[i]])\n      spe[s[i]].push_back(t[i]);\n    else\n      nspe[s[i]].push_back(t[i]);\n    ans -= pos[s[i]] * pos[t[i]];\n    w[s[i]]++;\n    w[t[i]]++;\n    sum[s[i]] += pos[t[i]];\n    sum[t[i]] += pos[s[i]];\n  }\n  for (int i = 1; i <= n; i++) ans += (w[i] - 1.0) * pos[i];\n  for (int i = 1; i <= q; i++) {\n    update(ck[i], cpos[i]);\n    printf(\"%.8lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 7;\ndouble a[N], c[N];\nint n, b[N], fa[N], bfn[N], cl[N], cr[N];\nvector<int> p[N];\nbool vis[N];\nvoid add(int x, double y) {\n  while (x <= n) {\n    c[x] += y;\n    x += x & -x;\n  }\n}\ndouble get(int x) {\n  double y = 0;\n  while (x > 0) {\n    y += c[x];\n    x -= x & -x;\n  }\n  return y;\n}\nqueue<int> Q;\nint main() {\n  int u, v;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%lf\", &a[i]), c[i] = 0.0;\n  for (int i = 0; i < n - 1; i++) {\n    scanf(\"%d%d\", &u, &v);\n    p[u].push_back(v);\n    p[v].push_back(u);\n  }\n  int cnt = 0;\n  Q.push(0);\n  vis[0] = true;\n  fa[0] = -1;\n  while (!Q.empty()) {\n    int now = Q.front();\n    Q.pop();\n    bfn[++cnt] = now;\n    b[now] = cnt;\n    for (auto v : p[now]) {\n      if (vis[v]) continue;\n      fa[v] = now;\n      vis[v] = true;\n      Q.push(v);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    cl[i] = 0x3f3f3f3f;\n    cr[i] = -0x3f3f3f3f;\n    for (auto v : p[i]) {\n      if (v == fa[i]) continue;\n      cl[i] = min(b[v], cl[i]);\n      cr[i] = max(b[v], cr[i]);\n    }\n  }\n  for (int i = 1; i <= n; i++) add(i, 1.0 - a[bfn[i]]);\n  int m, x;\n  double y, ans = 0.0, res;\n  for (int i = 0; i < n; i++) {\n    if (fa[i] != -1)\n      ans += (1.0 - a[i]) * a[fa[i]];\n    else\n      ans += (1.0 - a[i]);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d%lf\", &x, &y);\n    res = (fa[x] == -1 ? 1.0 : a[fa[x]]);\n    ans -= res * (1.0 - a[x]);\n    ans += res * (1.0 - y);\n    if (cl[x] != 0x3f3f3f3f) {\n      ans += (y - a[x]) * (get(cr[x]) - get(cl[x] - 1));\n    }\n    add(b[x], a[x] - y);\n    a[x] = y;\n    printf(\"%.6lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int setBit(int N, int pos) { return N = N | (1 << pos); }\ninline int resetBit(int N, int pos) { return N = N & ~(1 << pos); }\ninline bool checkBit(int N, int pos) { return (bool)(N & (1 << pos)); }\nstruct data {\n  int childCnt, parent;\n  double pChildSum, prob;\n} A[100000 + 10];\nint n;\nvector<int> E[100000 + 10];\ndouble ans, sum;\nvoid dfs(int node, int par) {\n  A[node].childCnt = E[node].size();\n  if (par != -1) A[node].childCnt--;\n  A[node].parent = par;\n  sum += A[node].prob;\n  A[node].pChildSum = 0;\n  if (par != -1) ans += (1 - A[par].prob) * A[node].prob;\n  for (auto v : E[node]) {\n    if (v != par) {\n      A[node].pChildSum += A[v].prob;\n      dfs(v, node);\n    }\n  }\n  ans += A[node].prob * A[node].childCnt;\n}\nvoid update(int node, double p) {\n  sum -= A[node].prob;\n  sum += p;\n  int par = A[node].parent;\n  if (par != -1) {\n    ans -= (1 - A[par].prob) * A[node].prob;\n    ans += (1 - A[par].prob) * p;\n    A[par].pChildSum -= A[node].prob;\n    A[par].pChildSum += p;\n  }\n  ans -= A[node].prob * A[node].childCnt;\n  ans += p * A[node].childCnt;\n  ans -= (1 - A[node].prob) * A[node].pChildSum;\n  ans += (1 - p) * A[node].pChildSum;\n  A[node].prob = p;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &A[i].prob);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    u++, v++;\n    E[u].push_back(v);\n    E[v].push_back(u);\n  }\n  dfs(1, -1);\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int u;\n    double p;\n    scanf(\"%d\", &u);\n    u++;\n    scanf(\"%lf\", &p);\n    update(u, p);\n    printf(\"%.9f\\n\", ans - sum + 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, q, f[N];\ndouble sum[N], a[N], ans;\nvector<int> v[N];\nvoid dfs(int pos, int fa) {\n  f[pos] = fa;\n  for (auto &i : v[pos])\n    if (i != fa) dfs(i, pos), sum[pos] += a[i];\n  ans += (1 - a[pos]) * sum[pos];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i], a[i] = 1 - a[i];\n  int t1, t2;\n  for (int i = 1; i < n; i++)\n    cin >> t1 >> t2, ++t1, ++t2, v[t1].push_back(t2), v[t2].push_back(t1);\n  dfs(1, 0);\n  sum[0] = a[1];\n  ans += a[1];\n  cin >> q;\n  double t3;\n  for (int i = 1; i <= q; i++) {\n    cin >> t1 >> t3;\n    ++t1;\n    t3 = 1 - t3;\n    ans -= (1 - a[f[t1]]) * sum[f[t1]];\n    sum[f[t1]] += t3 - a[t1];\n    ans += (1 - a[f[t1]]) * sum[f[t1]];\n    ans -= (1 - a[t1]) * sum[t1];\n    a[t1] = t3;\n    ans += (1 - a[t1]) * sum[t1];\n    printf(\"%.8lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n;\ndouble p[1000005], ans, sum[1000005];\nint head[1000005], tot, fa[1000005];\nstruct edge {\n  int nxt, v;\n} e[1000005 << 1];\ninline void addedge(int u, int v) {\n  e[++tot] = (edge){head[u], v};\n  head[u] = tot;\n}\ninline void dfs(int u, int Fa) {\n  ans += (1 - p[Fa]) * p[u];\n  fa[u] = Fa;\n  for (int i = head[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v) {\n    if (v == Fa) continue;\n    dfs(v, u);\n    sum[u] += p[v];\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = (1); i <= (n); ++i) {\n    scanf(\"%lf\", &p[i]);\n    p[i] = 1 - p[i];\n  }\n  for (int i = (2); i <= (n); ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    ++u;\n    ++v;\n    addedge(u, v);\n    addedge(v, u);\n  }\n  dfs(1, 0);\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int x;\n    double px;\n    scanf(\"%d %lf\", &x, &px);\n    ++x;\n    px = 1 - px;\n    ans -= p[x] * (1 - p[fa[x]]) + (1 - p[x]) * sum[x];\n    sum[fa[x]] -= p[x];\n    p[x] = px;\n    ans += p[x] * (1 - p[fa[x]]) + (1 - p[x]) * sum[x];\n    sum[fa[x]] += p[x];\n    printf(\"%lf\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint cnt, head[N], u, v, n, m, x, fa[N];\ndouble p[N], y, ans, sum[N];\nstruct node {\n  int to, next;\n} num[N << 1];\nvoid add(int x, int y) {\n  num[++cnt].to = y;\n  num[cnt].next = head[x];\n  head[x] = cnt;\n}\nvoid dfs(int x) {\n  if (x == 1)\n    ans += 1 - p[x];\n  else\n    ans += (1 - p[x]) * p[fa[x]];\n  for (int i = head[x]; i; i = num[i].next)\n    if (num[i].to != fa[x]) {\n      fa[num[i].to] = x;\n      sum[x] += 1 - p[num[i].to];\n      dfs(num[i].to);\n    }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; i++)\n    scanf(\"%d%d\", &u, &v), u++, v++, add(u, v), add(v, u);\n  dfs(1);\n  scanf(\"%d\", &m);\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d%lf\", &x, &y);\n    x++;\n    ans -= sum[x] * p[x];\n    if (x == 1)\n      ans -= 1 - p[x];\n    else\n      ans -= (1 - p[x]) * p[fa[x]];\n    sum[fa[x]] -= 1 - p[x];\n    p[x] = y;\n    ans += sum[x] * p[x];\n    if (x == 1)\n      ans += 1 - p[x];\n    else\n      ans += (1 - p[x]) * p[fa[x]];\n    sum[fa[x]] += 1 - p[x];\n    printf(\"%.10lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, fa[100010];\ndouble sum[100010], a[100010], ans;\nvector<int> v[100010];\nvoid read(int& x) {\n  char c = getchar();\n  x = 0;\n  while (!isdigit(c)) c = getchar();\n  while (isdigit(c)) {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n}\nvoid dfs(int x) {\n  for (int y : v[x]) {\n    if (y == fa[x]) continue;\n    fa[y] = x;\n    sum[x] += (1.0 - a[y]);\n    dfs(y);\n  }\n  ans += sum[x] * a[x];\n}\nint main() {\n  read(n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lf\", &a[i]);\n  }\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    read(x);\n    read(y);\n    x++;\n    y++;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  a[0] = 1.0;\n  v[0].push_back(1);\n  dfs(0);\n  read(m);\n  for (int i = 1; i <= m; i++) {\n    int x;\n    read(x);\n    x++;\n    ans -= sum[fa[x]] * a[fa[x]];\n    ans -= a[x] * sum[x];\n    sum[fa[x]] -= (1.0 - a[x]);\n    scanf(\"%lf\", &a[x]);\n    sum[fa[x]] += (1.0 - a[x]);\n    ans += a[x] * sum[x];\n    ans += sum[fa[x]] * a[fa[x]];\n    printf(\"%.5lf\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9 + 7;\nconst int MAXN = 1e6 + 7;\nconst double EPS = 1e-8;\nint n;\nvector<vector<int> > data;\nvector<double> my, sons, f;\nvoid dfs(int vertex, int last) {\n  f[vertex] = last;\n  for (int i = 0; i < data[vertex].size(); i++) {\n    int to = data[vertex][i];\n    if (to == last) continue;\n    sons[vertex] += my[to];\n    dfs(to, vertex);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  data.resize(n), my.resize(n), sons.resize(n, 0.), f.resize(n);\n  for (int i = 0; i < n; i++) cin >> my[i];\n  for (int i = 0; i < n; i++) my[i] = 1. - my[i];\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    data[a].push_back(b);\n    data[b].push_back(a);\n  }\n  dfs(0, -1);\n  double ans = 0;\n  for (int i = 0; i < n; i++) ans += my[i] * (1. - sons[i]);\n  int q;\n  cin >> q;\n  cout << fixed << setprecision(6);\n  for (int i = 0; i < q; i++) {\n    int a;\n    double x;\n    cin >> a >> x;\n    x = 1. - x;\n    double old = my[a] * (1. - sons[a]);\n    int F = f[a];\n    if (F != -1) old += my[F] * (1. - sons[F]);\n    if (F != -1) sons[F] += x - my[a];\n    my[a] = x;\n    double nw = my[a] * (1. - sons[a]);\n    if (F != -1) nw += my[F] * (1. - sons[F]);\n    ans += nw - old;\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\npublic class d1045 implements Runnable{\n\t\n    public static void main(String[] args) {\n    \ttry{\n            new Thread(null, new d1045(), \"process\", 1<<26).start();\n        }\n        catch(Exception e){\n            System.out.println(e);\n        }\n    }\n\tpublic void run() {\n\t\tFastReader scan = new FastReader();\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t//PrintWriter out = new PrintWriter(\"file.out\");\n\t\tTask solver = new Task();\n\t\t//int t = scan.nextInt();\n\t\tint t = 1;\n\t\tfor(int i = 1; i <= t; i++) solver.solve(i, scan, out);\n\t\tout.close();\n\t}\n\n\tstatic class Task {\n\t\tstatic final int oo = Integer.MAX_VALUE;\n\t\tstatic final long OO = Long.MAX_VALUE;\n\n\t\tstatic double[] probs;\n\t\tstatic List<List<Integer>> adj = new ArrayList<>();\n\t\tstatic double pairs = 0;\n\t\tpublic void solve(int testNumber, FastReader sc, PrintWriter out) {\n\t\t\tint N = sc.nextInt();\n\t\t\tprobs = new double[N];\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tprobs[i] = 1 - sc.nextDouble();\n\t\t\t\tsum += probs[i];\n\t\t\t\tadj.add(new ArrayList<>());\n\t\t\t}\n\t\t\t//System.out.println(sum);\n\t\t\t\n\t\t\tfor(int i = 0; i < N-1; i++) {\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tadj.get(u).add(v);\n\t\t\t\tadj.get(v).add(u);\n\t\t\t}\n\t\t\tchildren = new double[N];\n\t\t\tparent = new int[N];\n\t\t\tdfs(0, -1);\n\t\t\t//System.out.println(pairs);\n\t\t\t\n\t\t\tint Q = sc.nextInt();\n\t\t\twhile(Q --> 0) {\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tdouble prob = sc.nextDouble();\n\t\t\t\t\n\t\t\t\tsum = sum - probs[u] + ( 1 - prob);\n\t\t\t\t\n\t\t\t\tif(parent[u] != -1)\n\t\t\t\t\tpairs -= probs[parent[u]] * children[parent[u]];\n\t\t\t\tpairs -= probs[u] * children[u];\n\t\t\t\tif(parent[u] != -1)\n\t\t\t\t\tchildren[parent[u]] = children[parent[u]] - probs[u] + 1 - prob;\n\t\t\t\tprobs[u] = 1 - prob;\n\t\t\t\t\n\t\t\t\tif(parent[u] != -1)\n\t\t\t\t\tpairs += probs[parent[u]] * children[parent[u]];\n\t\t\t\tpairs += probs[u] * children[u];\n\t\t\t\tout.println(sum - pairs);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void dfs(int node, int par) {\n\t\t\tparent[node] = par;\n\t\t\tdouble sum = 0;\n\t\t\tfor(int each: adj.get(node)) {\n\t\t\t\tif(each != par) {\n\t\t\t\t\tpairs += probs[each] * probs[node];\n\t\t\t\t\tsum += probs[each];\n\t\t\t\t\tdfs(each, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tchildren[node] = sum;\n\t\t}\n\t\t\n\t\tstatic double[] children;\n\t\tstatic int[] parent;\n\t}\n\t\n\tstatic long modDivide(long a, long b, long MOD) {\n\t\ta %= MOD;\n\t\treturn (binpow(b, MOD-2, MOD) * a) % MOD;\n\t}\n\tstatic long binpow(long a, long b, long m) {\n\t\ta %= m;\n\t\tlong res = 1;\n\t\twhile (b > 0) {\n\t\t\tif ((b & 1) == 1)\n\t\t\t\tres = res * a % m;\n\t\t\ta = a * a % m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int[] reverse(int a[]) \n    { \n        int[] b = new int[a.length]; \n        for (int i = 0, j = a.length; i < a.length; i++, j--) { \n            b[j - 1] = a[i]; \n        } \n        \n        return b;\n    }\n\tstatic long[] reverse(long a[]) \n    { \n        long[] b = new long[a.length]; \n        for (int i = 0, j = a.length; i < a.length; i++, j--) { \n            b[j - 1] = a[i]; \n        } \n        \n        return b;\n    }\n\tstatic void sort(int[] x){\n\t\tshuffle(x);\n\t\tArrays.sort(x);\n\t}\n\tstatic void sort(long[] x){\n\t\tshuffle(x);\n\t\tArrays.sort(x);\n\t}\n\tstatic class tup implements Comparable<tup>, Comparator<tup>{\n\t\tint a, b;\n\t\ttup(int a,int b){\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\tpublic tup() {\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(tup o){\n\t\t\treturn Integer.compare(b,o.b);\n\t\t}\n\t\t@Override\n\t\tpublic int compare(tup o1, tup o2) {\n\t\t\treturn Integer.compare(o1.b, o2.b);\n\t\t}\n\t\t\n\t\t@Override\n\t    public int hashCode() {\n\t\t\treturn Objects.hash(a, b);\n\t    }\n \n\t    @Override\n\t    public boolean equals(Object obj) {\n\t    \tif (this == obj)\n                return true;\n\t    \tif (obj == null)\n                return false;\n\t    \tif (getClass() != obj.getClass())\n                return false;\n\t    \ttup other = (tup) obj;\n\t    \treturn a==other.a && b==other.b;\n\t    }\n\t    \n\t    @Override\n\t    public String toString() {\n\t    \treturn a + \" \" + b;\n\t    }\n\t}\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t}\n\n\tstatic void shuffle(long[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tlong temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastReader(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\t\n\tstatic void dbg(int[] arr) {\n\t\tSystem.out.println(Arrays.toString(arr));\n\t}\n\tstatic void dbg(long[] arr) {\n\t\tSystem.out.println(Arrays.toString(arr));\n\t}\n\tstatic void dbg(boolean[] arr) {\n\t\tSystem.out.println(Arrays.toString(arr));\n\t}\n\n\tstatic void dbg(Object... args) {\n        for (Object arg : args)\n            System.out.print(arg + \" \");\n        System.out.println();\n    }\n\t\n\tstatic int[] readArray(int size, FastReader in) {\n\t\tint[] a = new int[size];\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tstatic long[] readLongArray(int size, FastReader in) {\n\t\tlong[] a = new long[size];\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\ta[i] = in.nextLong();\n\t\t}\n\t\treturn a;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int B = 400;\nint n;\nint pro[100000];\nvector<int> edge[100000];\nvector<int> vs;\nint sum[B];\nvector<bool> con[B];\nint idx[100000];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    double x;\n    scanf(\"%lf\", &x);\n    pro[i] = llround(100 * (1 - x));\n  }\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    edge[x].push_back(y);\n    edge[y].push_back(x);\n  }\n  int v = 0;\n  for (int i = 0; i < n; ++i) v += pro[i];\n  int e = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j : edge[i]) {\n      if (i < j) continue;\n      e += pro[i] * pro[j];\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    if (edge[i].size() > B) {\n      idx[i] = vs.size();\n      vs.push_back(i);\n      con[idx[i]].resize(n, false);\n      for (int j : edge[i]) {\n        con[idx[i]][j] = 1;\n        sum[idx[i]] += pro[j];\n      }\n    } else\n      idx[i] = -1;\n  }\n  int q;\n  scanf(\"%d\", &q);\n  for (int it = 0; it < q; ++it) {\n    int x;\n    double p;\n    scanf(\"%d%lf\", &x, &p);\n    v -= pro[x];\n    int pr = pro[x];\n    pro[x] = llround(100 * (1 - p));\n    v += pro[x];\n    if (idx[x] != -1) {\n      e += sum[idx[x]] * (pro[x] - pr);\n    } else {\n      for (int j : edge[x]) {\n        e += pro[j] * (pro[x] - pr);\n      }\n    }\n    for (int i = 0; i < vs.size(); ++i) {\n      if (con[i][x]) {\n        sum[i] += pro[x] - pr;\n      }\n    }\n    printf(\"%.5f\\n\", v / 100.0 - e / 10000.0);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, q;\ndouble p[100010], s[100010];\nint x[100010], y[100010];\nint d[100010];\nvector<int> g[100010];\nint main() {\n  scanf(\"%d\", &n);\n  double sum = 0;\n  for (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]), p[i] = 1 - p[i], sum += p[i];\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    d[x[i]]++, d[y[i]]++;\n    sum -= p[x[i]] * p[y[i]];\n  }\n  for (int i = 1; i < n; i++) {\n    if (d[x[i]] < d[y[i]]) swap(x[i], y[i]);\n    g[y[i]].push_back(x[i]);\n    s[x[i]] += p[y[i]];\n  }\n  int u;\n  double d;\n  scanf(\"%d\", &q);\n  while (q--) {\n    scanf(\"%d%lf\", &u, &d);\n    d = 1 - d;\n    d = d - p[u];\n    sum += d;\n    sum -= d * s[u];\n    p[u] += d;\n    for (auto v : g[u]) {\n      sum -= d * p[v];\n      s[v] += d;\n    }\n    printf(\"%lf\\n\", sum);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclock_t __stt;\ninline void TStart() { __stt = clock(); }\ninline void TReport() {\n  printf(\"\\nTaken Time : %.3lf sec\\n\",\n         (double)(clock() - __stt) / CLOCKS_PER_SEC);\n}\ntemplate <typename T>\nT MIN(T a, T b) {\n  return a < b ? a : b;\n}\ntemplate <typename T>\nT MAX(T a, T b) {\n  return a > b ? a : b;\n}\ntemplate <typename T>\nT ABS(T a) {\n  return a > 0 ? a : (-a);\n}\ntemplate <typename T>\nvoid UMIN(T &a, T b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\nvoid UMAX(T &a, T b) {\n  if (b > a) a = b;\n}\nint n, q, fa[100005], deg[100005];\ndouble p[100005], s[100005], ini;\nvector<int> adj[100005];\nvoid dfs(int ver) {\n  if (!ver) fa[ver] = -1;\n  int i;\n  ini += ((double)deg[ver]) * p[ver];\n  for (i = 0; i < (int)adj[ver].size(); ++i) {\n    if (adj[ver][i] != fa[ver]) {\n      fa[adj[ver][i]] = ver;\n      s[ver] += p[adj[ver][i]];\n      dfs(adj[ver][i]);\n    }\n  }\n}\nint main() {\n  int i, j, k;\n  scanf(\"%d\", &n);\n  ini = 0;\n  for (i = 0; i < n; ++i) {\n    scanf(\"%lf\", p + i);\n  }\n  memset(deg, -1, sizeof(deg));\n  for (i = 0; i < n - 1; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    ++deg[u];\n    ++deg[v];\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  dfs(0);\n  for (i = 0; i < n; ++i) {\n    ini -= p[i] * s[i];\n  }\n  scanf(\"%d\", &q);\n  while (q--) {\n    int u;\n    double d;\n    scanf(\"%d%lf\", &u, &d);\n    ini += (d - p[u]) * (double)deg[u];\n    if (fa[u] != -1) {\n      ini += p[fa[u]] * s[fa[u]];\n      s[fa[u]] += d - p[u];\n      ini -= p[fa[u]] * s[fa[u]];\n    }\n    ini += p[u] * s[u];\n    p[u] = d;\n    ini -= p[u] * s[u];\n    printf(\"%.5lf\\n\", ini + 1.0);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (int)1e9;\nconst long long INF = (long long)5e18;\nconst int MOD = 998244353;\nint _abs(int x) { return x < 0 ? -x : x; }\nint add(int x, int y) {\n  x += y;\n  return x >= MOD ? x - MOD : x;\n}\nint sub(int x, int y) {\n  x -= y;\n  return x < 0 ? x + MOD : x;\n}\nvoid Add(int &x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n}\nvoid Sub(int &x, int y) {\n  x -= y;\n  if (x < 0) x += MOD;\n}\nvoid Mul(int &x, int y) { x = (long long)(x) * (y) % MOD; }\nint qpow(int x, int y) {\n  int ret = 1;\n  while (y) {\n    if (y & 1) ret = (long long)(ret) * (x) % MOD;\n    x = (long long)(x) * (x) % MOD;\n    y >>= 1;\n  }\n  return ret;\n}\nvoid checkmin(int &x, int y) {\n  if (x > y) x = y;\n}\nvoid checkmax(int &x, int y) {\n  if (x < y) x = y;\n}\nvoid checkmin(long long &x, long long y) {\n  if (x > y) x = y;\n}\nvoid checkmax(long long &x, long long y) {\n  if (x < y) x = y;\n}\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c > '9' || c < '0') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9')\n    x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n  return x * f;\n}\nconst int N = 500005;\nconst int M = 1005;\nint n, fa[N];\nvector<int> v[N];\ndouble a[N], sum[N], ans = 0;\nvoid dfs(int u) {\n  for (auto &to : v[u]) {\n    if (to == fa[u]) continue;\n    fa[to] = u;\n    dfs(to);\n    sum[u] += 1 - a[to];\n  }\n  ans += a[u] * sum[u];\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &a[i]);\n  for (int i = 1; i < n; i++) {\n    int x = read() + 1, y = read() + 1;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  dfs(1);\n  ans += (1 - a[1]);\n  int Q = read();\n  while (Q--) {\n    int x = read() + 1;\n    double P;\n    scanf(\"%lf\", &P);\n    if (x != 1) {\n      ans -= (1 - a[x]) * a[fa[x]], sum[fa[x]] -= (1 - a[x]);\n      ans -= a[x] * sum[x];\n      a[x] = P;\n      ans += (1 - a[x]) * a[fa[x]], sum[fa[x]] += (1 - a[x]);\n      ans += a[x] * sum[x];\n    } else {\n      ans -= (1 - a[1]);\n      ans -= a[x] * sum[x];\n      a[x] = P;\n      ans += (1 - a[1]);\n      ans += a[x] * sum[x];\n    }\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5;\ndouble p[N];\nint prnt[N];\nvector<int> edges[N];\ndouble ans = 0.0;\nvoid dfs(int v, int pr = -1) {\n  if (v == 0) {\n    ans += p[v];\n  } else {\n    ans += p[v] * (1.0 - p[pr]);\n  }\n  prnt[v] = pr;\n  for (int u : edges[v]) {\n    if (u != pr) dfs(u, v);\n  }\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  for (int v = 0; v < n; v++) {\n    cin >> p[v];\n    p[v] = 1.0 - p[v];\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int v, u;\n    cin >> v >> u;\n    edges[v].push_back(u);\n    edges[u].push_back(v);\n  }\n  dfs(0);\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    int v;\n    double np;\n    cin >> v >> np;\n    np = 1.0 - np;\n    if (v == 0) {\n      ans -= p[v];\n      ans += np;\n      for (int u : edges[v]) {\n        if (v == prnt[u]) {\n          ans -= p[u] * (1.0 - p[v]);\n          ans += p[u] * (1.0 - np);\n        }\n      }\n      p[v] = np;\n    } else {\n      ans -= p[v] * (1.0 - p[prnt[v]]);\n      ans += np * (1.0 - p[prnt[v]]);\n      for (int u : edges[v]) {\n        if (v == prnt[u]) {\n          ans -= p[u] * (1.0 - p[v]);\n          ans += p[u] * (1.0 - np);\n        }\n      }\n      p[v] = np;\n    }\n    cout << ans << \"\\n\";\n  }\n}\nint main() {\n  ios::sync_with_stdio(NULL), cin.tie(0), cout.tie(0);\n  cout.setf(ios::fixed), cout.precision(20);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Nmax = 2e5 + 5;\nconst int Bsize = 1 << 17;\ndouble val, fail[Nmax], sum[Nmax];\nint t[Nmax], x, y, i, n, q;\nvector<int> v[Nmax];\nchar buffer[Bsize + 2];\nint cursor = 0;\nvoid read(int &x) {\n  x = 0;\n  while (!isdigit(buffer[cursor])) {\n    ++cursor;\n    if (cursor == Bsize) fread(buffer, 1, Bsize, stdin), cursor = 0;\n  }\n  while (isdigit(buffer[cursor])) {\n    x = x * 10 + buffer[cursor] - '0';\n    ++cursor;\n    if (cursor == Bsize) fread(buffer, 1, Bsize, stdin), cursor = 0;\n  }\n}\nvoid read(double &x) {\n  x = 0;\n  while (!isdigit(buffer[cursor])) {\n    ++cursor;\n    if (cursor == Bsize) fread(buffer, 1, Bsize, stdin), cursor = 0;\n  }\n  while (isdigit(buffer[cursor])) {\n    x = x * 10 + buffer[cursor] - '0';\n    ++cursor;\n    if (cursor == Bsize) fread(buffer, 1, Bsize, stdin), cursor = 0;\n  }\n  if (buffer[cursor] != '.') return;\n  ++cursor;\n  if (cursor == Bsize) fread(buffer, 1, Bsize, stdin), cursor = 0;\n  double y = 0;\n  while (isdigit(buffer[cursor])) {\n    y = y * 10 + buffer[cursor] - '0';\n    ++cursor;\n    if (cursor == Bsize) fread(buffer, 1, Bsize, stdin), cursor = 0;\n  }\n  x += y / 100;\n}\nvoid dfs(int node, int dad = -1) {\n  t[node] = dad;\n  for (auto it : v[node])\n    if (it != dad) {\n      dfs(it, node);\n      sum[node] += fail[it];\n    }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  fread(buffer, 1, Bsize, stdin), cursor = 0;\n  read(n);\n  for (i = 0; i < n; ++i) read(fail[i]);\n  for (i = 1; i < n; ++i) {\n    read(x);\n    read(y);\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  dfs(0);\n  double ans = -1;\n  for (i = 0; i < n; ++i) {\n    ans += (1 - fail[i]) * (2 - (int)v[i].size());\n    ans += fail[i];\n    ans -= fail[i] * sum[i];\n  }\n  cout << setprecision(5) << fixed;\n  int node;\n  read(q);\n  for (i = 1; i <= q; ++i) {\n    read(node);\n    read(val);\n    val -= fail[node];\n    fail[node] += val;\n    if (t[node] != -1) sum[t[node]] += val, ans -= val * fail[t[node]];\n    ans += val;\n    ans -= val * sum[node];\n    ans -= val * (2 - (int)v[node].size());\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize \"-O3\"\nusing namespace std;\nconst int MAXN = 120000;\nconst int SQ = 300;\nint n;\nstring s;\nlong double p[MAXN];\nlong double read() {\n  cin >> s;\n  return s[0] - '0' + 0.1 * (s[2] - '0') + 0.01 * (s[3] - '0');\n}\nvector<int> eds[MAXN];\nint fl[MAXN];\nlong double cs[MAXN];\nvector<int> eds2[MAXN];\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  cout.setf(ios::fixed);\n  cout.precision(6);\n  cin >> n;\n  long double ans = 0;\n  for (int i = 0; i < n; ++i) {\n    p[i] = read();\n    p[i] = 1 - p[i];\n    ans += p[i];\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    int a, b;\n    cin >> a >> b;\n    ans -= p[a] * p[b];\n    eds[a].push_back(b);\n    eds[b].push_back(a);\n    cs[a] += p[b];\n    cs[b] += p[a];\n  }\n  for (int i = 0; i < n; ++i)\n    if (eds[i].size() > SQ) fl[i] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int x : eds[i])\n      if (fl[x]) eds2[i].push_back(x);\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; ++i) {\n    int x;\n    cin >> x;\n    long double np = 1 - read();\n    ans += np - p[x];\n    if (fl[x]) {\n      ans -= (np - p[x]) * cs[x];\n    } else {\n      for (int y : eds[x]) ans -= (np - p[x]) * p[y];\n    }\n    for (int y : eds2[x]) cs[y] += (np - p[x]);\n    p[x] = np;\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e5 + 7;\nint n;\ndouble p[N];\ndouble ans;\ndouble sum[N];\nint pa[N];\nvector<int> G[N];\nvoid dfs(int u, int fa) {\n  pa[u] = fa;\n  ans += p[fa] * (1 - p[u]);\n  for (auto v : G[u]) {\n    if (v == fa) continue;\n    dfs(v, u);\n    sum[u] += 1 - p[v];\n  }\n}\nint main() {\n  p[0] = 1;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u++;\n    v++;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs(1, 0);\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int u;\n    double x;\n    scanf(\"%d%lf\", &u, &x);\n    u++;\n    if (pa[u]) sum[pa[u]] -= 1 - p[u];\n    ans -= (1 - p[u]) * p[pa[u]];\n    ans -= p[u] * sum[u];\n    p[u] = x;\n    if (pa[u]) sum[pa[u]] += 1 - p[u];\n    ans += (1 - p[u]) * p[pa[u]];\n    ans += p[u] * sum[u];\n    printf(\"%.12f\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nmt19937_64 mt_rand(chrono::system_clock::now().time_since_epoch().count());\ntemplate <typename T1, typename T2>\ninline bool upmax(T1& a, T2 b) {\n  return (a < b ? (a = b, true) : false);\n}\ntemplate <typename T1, typename T2>\ninline bool upmin(T1& a, T2 b) {\n  return (b < a ? (a = b, true) : false);\n}\nconst int maxn = (int)1e5 + 20;\nconst int maxlog = 21;\nconst int base = (int)1e9 + 7;\nconst long double eps = (long double)1e-7;\nconst long double PI = acos(-1.);\nconst int pp = 41;\ndouble p[maxn];\nvector<int> g[maxn];\nlong double f[maxn][2];\nint n;\nint pre[maxn];\ndouble sump[maxn];\nvoid dfs(int v, int pred = -1) {\n  pre[v] = pred;\n  for (int to : g[v]) {\n    if (to == pred) continue;\n    dfs(to, v);\n    sump[v] += p[to];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf\", p + i);\n  }\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  double ans = 1;\n  for (int i = 0; i < n; i++) {\n    ans += 1. * p[i] * ((int)g[i].size() - 1);\n    for (int j : g[i]) {\n      if (i < j) ans -= 1. * p[i] * p[j];\n    }\n  }\n  dfs(0);\n  int q;\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    int u;\n    double x;\n    scanf(\"%d %lf\", &u, &x);\n    ans -= p[u] * ((int)g[u].size() - 1);\n    ans += x * ((int)g[u].size() - 1);\n    ans += p[u] * (sump[u] + (u == 0 ? 0. : p[pre[u]]));\n    ans -= x * (sump[u] + (u == 0 ? 0. : p[pre[u]]));\n    if (u != 0) {\n      sump[pre[u]] -= p[u];\n      sump[pre[u]] += x;\n    }\n    p[u] = x;\n    printf(\"%6lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble P[100005], sum[100005], ans = 0;\nint n, q, first[100005], cnt = 0, fa[100005];\nstruct edge {\n  int v, next;\n} e[100005 << 1];\ninline void add(int u, int v) {\n  e[++cnt].v = v, e[cnt].next = first[u], first[u] = cnt;\n}\ninline void dfs(int p) {\n  ans += P[fa[p]] * (1 - P[p]);\n  for (int i = first[p]; i; i = e[i].next) {\n    int v = e[i].v;\n    if (v == fa[p]) continue;\n    fa[v] = p, dfs(v), sum[p] += 1 - P[v];\n  }\n}\ninline int read() {\n  int ans = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) ch = getchar();\n  while (isdigit(ch)) ans = (ans << 3) + (ans << 1) + (ch ^ 48), ch = getchar();\n  return ans;\n}\nint main() {\n  n = read(), P[0] = 1;\n  for (int i = 1; i <= n; ++i) scanf(\"%lf\", &P[i]);\n  for (int i = 1; i < n; ++i) {\n    int u = read() + 1, v = read() + 1;\n    add(u, v), add(v, u);\n  }\n  dfs(1), q = read();\n  while (q--) {\n    int a = read() + 1;\n    double b;\n    scanf(\"%lf\", &b);\n    ans -= P[a] * sum[a] + P[fa[a]] * (1 - P[a]), sum[fa[a]] -= 1 - P[a];\n    P[a] = b;\n    ans += P[a] * sum[a] + P[fa[a]] * (1 - P[a]), sum[fa[a]] += 1 - P[a];\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100000;\nconst double pi = acos(-1.0);\nstruct node {\n  int to, nxt;\n} sq[200200];\nint n, all = 0, head[100100], fa[100100], q;\ndouble ans = 0.0, sum[100100], p[100100];\nint read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while ((ch < '0') || (ch > '9')) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while ((ch >= '0') && (ch <= '9')) {\n    x = x * 10 + (ch - '0');\n    ch = getchar();\n  }\n  return x * f;\n}\nvoid add(int u, int v) {\n  all++;\n  sq[all].to = v;\n  sq[all].nxt = head[u];\n  head[u] = all;\n}\nvoid dfs(int u, int fu) {\n  ans += p[fu] * (1 - p[u]);\n  fa[u] = fu;\n  int i;\n  for (i = head[u]; i; i = sq[i].nxt) {\n    int v = sq[i].to;\n    if (v == fu) continue;\n    sum[u] += (1 - p[v]);\n    dfs(v, u);\n  }\n}\nint main() {\n  n = read();\n  for (register int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  p[0] = 1.0;\n  for (register int i = 1; i <= n - 1; i++) {\n    int u = read() + 1, v = read() + 1;\n    add(u, v);\n    add(v, u);\n  }\n  dfs(1, 0);\n  q = read();\n  while (q--) {\n    int u = read() + 1;\n    double nowp;\n    scanf(\"%lf\", &nowp);\n    ans -= (p[fa[u]] * (1 - p[u]) + p[u] * sum[u]);\n    ans += (p[fa[u]] * (1 - nowp) + nowp * sum[u]);\n    sum[fa[u]] += (p[u] - nowp);\n    p[u] = nowp;\n    printf(\"%.6lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[100005];\nvector<int> G[100005];\nint f[100005];\nint p[100005];\nlong long sV, sE;\nvoid dfs(int u) {\n  for (auto v : G[u]) {\n    if (v == p[u]) continue;\n    p[v] = u;\n    dfs(v);\n    f[u] += a[v];\n  }\n}\nvoid up(int x, int nv) {\n  sV -= a[x];\n  sE -= a[x] * f[x];\n  if (x) {\n    sE -= a[p[x]] * f[p[x]];\n    f[p[x]] -= a[x];\n  }\n  a[x] = nv;\n  sV += a[x];\n  if (x) {\n    f[p[x]] += a[x];\n    sE += a[p[x]] * f[p[x]];\n  }\n  sE += a[x] * f[x];\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    double x;\n    scanf(\"%lf\", &x);\n    a[i] = 100 - (int)(x * 100 + 0.5);\n  }\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  p[0] = -1;\n  dfs(0);\n  for (int i = 0; i < n; i++) {\n    sV += a[i];\n    sE += a[i] * f[i];\n  }\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int u;\n    double x;\n    scanf(\"%d%lf\", &u, &x);\n    up(u, 100 - (int)(x * 100 + 0.5));\n    double ans = (sV * 100 - sE) / 10000.0;\n    printf(\"%.4f\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100100;\nint n, par[N], q;\ndouble a[N], children[N], Dec, sum;\nchar A[10];\nstring s;\nvector<int> adj[N];\ndouble read() {\n  scanf(\"%s\", &A);\n  s = A;\n  return ((s[0] - '0') + (s[2] - '0') * 0.1 + (s[3] - '0') * 0.01);\n}\nvoid dfs(int u, int v = 1) {\n  for (auto &x : adj[u])\n    if (x != v) {\n      children[u] += a[x];\n      par[x] = u;\n      dfs(x, u);\n    }\n}\nvoid update(int pos, double val) {\n  val = 1.0 - val;\n  int &p = par[pos];\n  sum -= a[pos];\n  sum += val;\n  Dec -= a[pos] * children[pos];\n  Dec += val * children[pos];\n  Dec -= a[p] * children[p];\n  Dec += a[p] * (children[p] - a[pos] + val);\n  children[p] -= a[pos];\n  children[p] += val;\n  a[pos] = val;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    a[i] = read();\n    a[i] = 1.0 - a[i];\n    sum += a[i];\n  }\n  for (int i = 1; i <= n - 1; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    x++;\n    y++;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  dfs(1);\n  for (int i = 1; i <= n; i++) Dec += a[i] * children[i];\n  scanf(\"%d\", &q);\n  while (q--) {\n    int pos;\n    scanf(\"%d\", &pos);\n    pos++;\n    double val = read();\n    update(pos, val);\n    printf(\"%.5f\\n\", sum - Dec);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble p[100005], f[100005];\nint pa[100005];\nvector<int> v[100005];\nvoid DFS(int now, int fa) {\n  pa[now] = fa;\n  for (int i : v[now]) {\n    if (i != fa) {\n      f[now] += p[i];\n      DFS(i, now);\n    }\n  }\n}\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> p[i], p[i] = 1 - p[i];\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  double ans = 0;\n  DFS(0, -1);\n  for (int i = 0; i < n; i++) ans += p[i];\n  for (int i = 0; i < n; i++) ans -= p[i] * f[i];\n  int m;\n  cin >> m;\n  while (m--) {\n    int wh;\n    double ch;\n    cin >> wh >> ch;\n    ch = 1 - ch;\n    ans -= p[wh];\n    ans += p[wh] * f[wh];\n    if (wh != 0) {\n      ans += p[pa[wh]] * f[pa[wh]];\n      f[pa[wh]] -= p[wh];\n    }\n    p[wh] = ch;\n    ans += p[wh];\n    ans -= p[wh] * f[wh];\n    if (wh != 0) {\n      f[pa[wh]] += p[wh];\n      ans -= p[pa[wh]] * f[pa[wh]];\n    }\n    cout << fixed << setprecision(15) << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10, sq = 400;\ndouble sum[maxn], a[maxn];\nbool bad[maxn];\nvector<int> adj[maxn], adj_bad[maxn];\nint32_t main() {\n  double ans = 0;\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf\", a + i);\n    a[i] = 1 - a[i];\n    ans += a[i];\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    scanf(\"%d%d\", &v, &u);\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n    ans -= a[u] * a[v];\n  }\n  for (int i = 0; i < n; i++) {\n    bad[i] = (adj[i].size() > sq);\n    if (bad[i])\n      for (auto j : adj[i]) adj_bad[j].push_back(i);\n  }\n  int q;\n  cin >> q;\n  for (int it = 0; it < q; it++) {\n    int u;\n    double p;\n    scanf(\"%d%lf\", &u, &p);\n    p = 1 - p;\n    ans -= a[u];\n    ans += p;\n    if (bad[u])\n      ans -= (p - a[u]) * sum[u];\n    else {\n      for (int v : adj[u]) ans -= (p - a[u]) * a[v];\n    }\n    for (int v : adj_bad[u]) sum[v] += p - a[u];\n    printf(\"%.8lf\\n\", ans);\n    a[u] = p;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100000 + 10;\nint n, par[N];\nvector<int> g[N];\ndouble p[N], sum[N], ans = 0;\ndouble E = 0, V = 0;\nvoid dfs(int u, int f) {\n  par[u] = f;\n  for (auto v : g[u])\n    if (v != f) {\n      dfs(v, u);\n      sum[u] += p[v];\n    }\n  E = E + p[u] * sum[u];\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lf\", &p[i]);\n    p[i] = 1 - p[i];\n    V += p[i];\n  }\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u++, v++;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs(1, 0);\n  ans = V - E;\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int pos;\n    double x;\n    scanf(\"%d%lf\", &pos, &x);\n    x = 1 - x;\n    pos++;\n    V -= p[pos];\n    sum[par[pos]] -= p[pos];\n    E -= p[pos] * sum[pos];\n    if (par[pos]) E -= p[pos] * p[par[pos]];\n    p[pos] = x;\n    V += p[pos];\n    sum[par[pos]] += p[pos];\n    E += p[pos] * sum[pos];\n    if (par[pos]) E += p[pos] * p[par[pos]];\n    printf(\"%.8f\\n\", V - E);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 50;\nint n, q, fa[N];\nvector<int> g[N];\ndouble p[N], s[N], ans;\ninline void dfs(int x, int f) {\n  ans += p[f] * (1 - p[x]);\n  for (auto v : g[x])\n    if (v != f) fa[v] = x, s[x] += (1 - p[v]), dfs(v, x);\n}\nint main() {\n  scanf(\"%d\", &n);\n  p[0] = 1;\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    ++x;\n    ++y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  dfs(1, 0);\n  scanf(\"%d\", &q);\n  for (int i = 1; i <= q; i++) {\n    int x;\n    double t;\n    scanf(\"%d%lf\", &x, &t);\n    ++x;\n    ans -= p[x] * s[x];\n    ans -= p[fa[x]] * (1 - p[x]);\n    ans += t * s[x];\n    ans += p[fa[x]] * (1 - t);\n    s[fa[x]] -= (1 - p[x]);\n    s[fa[x]] += (1 - t);\n    p[x] = t;\n    printf(\"%.5f\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nint const nmax = 100000;\nint type[1 + nmax], degree[1 + nmax];\nld chance[1 + nmax], sumnode[1 + nmax];\nvector<int> g[1 + nmax][2];\nvector<int> special[1 + nmax];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> chance[i];\n    chance[i] = 1 - chance[i];\n  }\n  vector<pair<int, int>> edge;\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    ++x;\n    ++y;\n    degree[x]++;\n    degree[y]++;\n    edge.push_back({x, y});\n  }\n  int rad = sqrt(n);\n  ld sum = 0, sumedge = 0;\n  for (int i = 1; i <= n; i++) {\n    if (degree[i] <= rad)\n      type[i] = 0;\n    else\n      type[i] = 1;\n    sum += chance[i];\n  }\n  for (int i = 0; i < edge.size(); i++) {\n    int x = edge[i].first, y = edge[i].second;\n    sumedge += chance[x] * chance[y];\n    if (type[x] == type[y]) {\n      special[x].push_back(y);\n      special[y].push_back(x);\n    } else {\n      g[x][type[y]].push_back(y);\n      g[y][type[x]].push_back(x);\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (type[i] == 0)\n      for (int h = 0; h < g[i][1].size(); h++) {\n        int to = g[i][1][h];\n        sumnode[to] += chance[i];\n      }\n  int q;\n  cin >> q;\n  for (int i = 1; i <= q; i++) {\n    int id;\n    ld chc;\n    cin >> id >> chc;\n    id++;\n    chc = 1 - chc;\n    chc = chc - chance[id];\n    sum += chc;\n    chance[id] += chc;\n    if (type[id] == 0)\n      for (int h = 0; h < g[id][1].size(); h++) {\n        int to = g[id][1][h];\n        sumnode[to] += chc;\n        sumedge += chc * chance[to];\n      }\n    else\n      sumedge += chc * sumnode[id];\n    for (int h = 0; h < special[id].size(); h++)\n      sumedge += chc * chance[special[id][h]];\n    cout << setprecision(6) << fixed << sum - sumedge << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ndouble p[100006], q[100006], P, ans;\nint a, i, x, y, Q, pa[100006];\nstd::vector<int> G[100006];\nvoid dfs(int r, int par) {\n  pa[r] = par;\n  for (int k = 0; k < G[r].size(); k++) {\n    if (G[r][k] != par) {\n      q[r] += p[G[r][k]];\n      dfs(G[r][k], r);\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &a);\n  for (i = 0; i < a; i++) scanf(\"%lf\", &p[i]), p[i] = 1 - p[i], ans += p[i];\n  for (i = 1; i < a; i++) {\n    scanf(\"%d%d\", &x, &y);\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  dfs(0, a);\n  for (i = 0; i < a; i++) ans -= p[i] * q[i];\n  scanf(\"%d\", &Q);\n  while (Q--) {\n    scanf(\"%d%lf\", &x, &P);\n    P = 1 - P;\n    ans += (P - p[x]) * (1.0 - q[x] - p[pa[x]]);\n    q[pa[x]] += (P - p[x]);\n    p[x] = P;\n    printf(\"%lf\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1e6 + 10;\nstruct edge {\n  int next, to;\n} e[N << 1];\nint n, last[N], fa[N], m, cnt;\ndouble v[N], t[N], ans;\nvoid add(int a, int b) {\n  cnt++;\n  e[cnt].next = last[a], last[a] = cnt;\n  e[cnt].to = b;\n}\nvoid dfs(int x, int f) {\n  fa[x] = f;\n  ans -= v[x];\n  for (int i = last[x]; i; i = e[i].next) {\n    if (e[i].to == f) continue;\n    dfs(e[i].to, x);\n    t[x] += 1.0 - v[e[i].to];\n  }\n  ans -= (1.0 - v[x]) * t[x];\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%lf\", &v[i]);\n  for (int i = 1; i < n; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    a++, b++;\n    add(a, b), add(b, a);\n  }\n  ans = n;\n  dfs(1, 0);\n  scanf(\"%d\", &m);\n  while (m--) {\n    int a;\n    double x;\n    scanf(\"%d %lf\", &a, &x);\n    a++;\n    ans += (1.0 - v[a]) * t[a];\n    if (fa[a]) ans += (1.0 - v[fa[a]]) * t[fa[a]];\n    if (fa[a]) t[fa[a]] -= 1.0 - v[a];\n    ans += v[a];\n    v[a] = x;\n    ans -= v[a];\n    if (fa[a]) t[fa[a]] += 1.0 - v[a];\n    ans -= (1.0 - v[a]) * t[a];\n    if (fa[a]) ans -= (1.0 - v[fa[a]]) * t[fa[a]];\n    printf(\"%lf\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint head[100001], nxt[100001 << 1], ver[100001 << 1], tot;\nint n;\ninline void addedge(int a, int b) {\n  nxt[++tot] = head[a];\n  ver[tot] = b;\n  head[a] = tot;\n  nxt[++tot] = head[b];\n  ver[tot] = a;\n  head[b] = tot;\n}\ndouble a[100001];\ninline void init() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", a + i);\n  for (int i = 1, a, b; i < n; i++)\n    scanf(\"%d%d\", &a, &b), a++, b++, addedge(a, b);\n}\ndouble f[100001][2];\nint fa[100001];\ninline void update(int x) {\n  f[x][1] = 1;\n  f[x][0] = 0;\n  for (int i = head[x]; i; i = nxt[i]) {\n    int y = ver[i];\n    if (y == fa[x]) continue;\n    f[x][0] += a[y] * f[y][0] + (1.0 - a[y]) * f[y][1];\n    f[x][1] += a[y] * f[y][0] + (1.0 - a[y]) * (f[y][1] - 1);\n  }\n  if (fa[x]) update(fa[x]);\n}\ninline void dp(int x, int fat) {\n  f[x][1] = 1;\n  f[x][0] = 0;\n  fa[x] = fat;\n  for (int i = head[x]; i; i = nxt[i]) {\n    int y = ver[i];\n    if (y == fat) continue;\n    dp(y, x);\n    f[x][0] += a[y] * f[y][0] + (1.0 - a[y]) * f[y][1];\n    f[x][1] += a[y] * f[y][0] + (1.0 - a[y]) * (f[y][1] - 1);\n  }\n}\nint main() {\n  init();\n  dp(1, 0);\n  int q;\n  cin >> q;\n  while (q--) {\n    int x;\n    scanf(\"%d\", &x);\n    x++;\n    scanf(\"%lf\", a + x);\n    update(x);\n    printf(\"%0.5f\\n\", a[1] * f[1][0] + (1.0 - a[1]) * f[1][1]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int kNmax = 1e5 + 10;\nint n, par[kNmax], q;\ndouble prob[kNmax], sumSons[kNmax], ecc;\nvector<int> g[kNmax];\nvoid dfs(int node, int father) {\n  par[node] = father;\n  for (int vec : g[node]) {\n    if (vec != father) {\n      dfs(vec, node);\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  prob[0] = 1.0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lf\", &prob[i]);\n  }\n  for (int i = 1, x, y; i < n; i++) {\n    scanf(\"%d %d\", &x, &y);\n    x++;\n    y++;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  dfs(1, 0);\n  for (int i = 1; i <= n; i++) {\n    sumSons[par[i]] += 1.0 - prob[i];\n  }\n  for (int i = 0; i <= n; i++) {\n    ecc += prob[i] * sumSons[i];\n  }\n  scanf(\"%d\", &q);\n  for (; q; q--) {\n    int node;\n    double newProb;\n    scanf(\"%d %lf\", &node, &newProb);\n    node++;\n    ecc -= prob[par[node]] * sumSons[par[node]];\n    ecc -= prob[node] * sumSons[node];\n    sumSons[par[node]] -= 1.0 - prob[node];\n    prob[node] = newProb;\n    sumSons[par[node]] += 1.0 - prob[node];\n    ecc += prob[par[node]] * sumSons[par[node]];\n    ecc += prob[node] * sumSons[node];\n    printf(\"%.10lf\\n\", ecc);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint n;\ndouble ans;\ndouble p[maxn];\ndouble sum[maxn];\nint father[maxn];\nvector<int> G[maxn];\nvoid Init() {\n  p[0] = 1;\n  for (int i = 1; i <= n; ++i) G[i].clear(), sum[i] = 0;\n}\nvoid DFS(int u, int fa) {\n  father[u] = fa;\n  ans += p[fa] * (1 - p[u]);\n  for (auto it : G[u])\n    if (it != fa) {\n      DFS(it, u);\n      sum[u] += 1 - p[it];\n    }\n}\nvoid RUN() {\n  while (~scanf(\"%d\", &n)) {\n    Init();\n    for (int i = 1; i <= n; ++i) scanf(\"%lf\", p + i);\n    for (int i = 1, u, v; i < n; ++i) {\n      scanf(\"%d %d\", &u, &v);\n      ++u, ++v;\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n    ans = 0;\n    DFS(1, 0);\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n      int x;\n      double v;\n      scanf(\"%d %lf\", &x, &v);\n      ++x;\n      ans -= p[father[x]] * (1 - p[x]) + p[x] * sum[x];\n      sum[father[x]] -= 1.0 - p[x];\n      p[x] = v;\n      ans += p[father[x]] * (1 - p[x]) + p[x] * sum[x];\n      sum[father[x]] += 1.0 - p[x];\n      printf(\"%.5f\\n\", ans);\n    }\n  }\n}\nint main() {\n  RUN();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nconst int maxn = 100005;\ndouble p[maxn], s[maxn], ans, t;\nint fa[maxn], n, Q, x, y;\nvector<int> e[maxn];\nvoid dfs(int u) {\n  for (auto v : e[u])\n    if (v != fa[u]) {\n      fa[v] = u;\n      dfs(v);\n    }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = (1), _E = (n); i <= _E; i++) scanf(\"%lf\", &p[i]);\n  for (int i = (1), _E = (n - 1); i <= _E; i++) {\n    scanf(\"%d%d\", &x, &y);\n    x++;\n    y++;\n    e[x].push_back(y);\n    e[y].push_back(x);\n  }\n  dfs(1);\n  p[0] = 1;\n  for (int i = (1), _E = (n); i <= _E; i++) s[fa[i]] += 1 - p[i];\n  for (int i = (0), _E = (n); i <= _E; i++) ans += p[i] * s[i];\n  scanf(\"%d\", &Q);\n  while (Q--) {\n    scanf(\"%d%lf\", &x, &t);\n    x++;\n    ans -= p[fa[x]] * s[fa[x]];\n    ans -= p[x] * s[x];\n    s[fa[x]] -= 1 - p[x];\n    s[fa[x]] += 1 - (p[x] = t);\n    ans += p[x] * s[x];\n    ans += p[fa[x]] * s[fa[x]];\n    printf(\"%.8lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nint pr[maxn];\ndouble sum[maxn];\ndouble p[maxn];\nint n;\nvector<int> gr[maxn];\nvoid dfs(int v, int pp = -1) {\n  pr[v] = pp;\n  sum[v] = 0;\n  for (auto u : gr[v]) {\n    if (u == pp) continue;\n    sum[v] += p[u];\n    dfs(u, v);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  scanf(\"%d\", &n);\n  for (auto i = 0; i < n; ++i) {\n    float tmp;\n    scanf(\"%f\", &tmp);\n    p[i] = tmp;\n  }\n  for (auto i = 0; i < n - 1; ++i) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    gr[v].push_back(u);\n    gr[u].push_back(v);\n  }\n  dfs(0);\n  int q;\n  scanf(\"%d\", &q);\n  double ans = 0;\n  for (auto i = 1; i < n; ++i) ans += p[pr[i]] * (1 - p[i]);\n  ans += 1 - p[0];\n  for (auto i = 0; i < q; ++i) {\n    int v;\n    float _np;\n    double np;\n    scanf(\"%d%f\", &v, &_np);\n    np = _np;\n    if (v == 0) {\n      ans = ans - gr[0].size() * p[0] + sum[0] * p[0];\n      ans = ans - sum[0] * np + np * gr[0].size();\n      ans = ans - (1 - p[0]) + (1 - np);\n      p[0] = np;\n    } else {\n      ans = ans - p[pr[v]] * (1 - p[v]);\n      ans = ans + p[pr[v]] * (1 - np);\n      ans = ans - (gr[v].size() - 1) * p[v];\n      ans = ans + (gr[v].size() - 1) * np;\n      ans = ans + p[v] * sum[v];\n      ans = ans - np * sum[v];\n      sum[pr[v]] = sum[pr[v]] - p[v] + np;\n      p[v] = np;\n    }\n    printf(\"%.6lf\\n\", (double)ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid getint(int &v) {\n  char ch, fu = 0;\n  for (ch = '*'; (ch < '0' || ch > '9') && ch != '-'; ch = getchar())\n    ;\n  if (ch == '-') fu = 1, ch = getchar();\n  for (v = 0; ch >= '0' && ch <= '9'; ch = getchar()) v = v * 10 + ch - '0';\n  if (fu) v = -v;\n}\ndouble p[500010], B[500010], C[500010], Y, ans, d, f[500010], g[500010];\nint A[500010], q, n, x[500010], y[500010], X, dfn, L[500010], R[500010],\n    w[500010], fa[500010], nedge, too[500010], hed[500010], nxt[500010];\nvoid ae(int x, int y) {\n  nxt[++nedge] = hed[x];\n  hed[x] = nedge;\n  too[nedge] = y;\n}\nvoid dfs(int x, int l) {\n  fa[x] = l;\n  L[x] = ++dfn;\n  w[dfn] = x;\n  f[x] = g[x] = 0;\n  for (int i = hed[x]; i; i = nxt[i]) {\n    int y = too[i];\n    if (y == l) continue;\n    ++A[x];\n    B[x] += p[y];\n    dfs(y, x);\n    f[x] += p[y] * g[y] + (1.0 - p[y]) * f[y];\n    g[x] += p[y] * g[y] + (1.0 - p[y]) * (f[y] + 1);\n  }\n  C[x] = A[x] - B[x];\n  R[x] = dfn;\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i <= n - 1; i++) {\n    getint(x[i]), getint(y[i]);\n    ++x[i], ++y[i];\n    ae(x[i], y[i]), ae(y[i], x[i]);\n  }\n  cin >> q;\n  dfs(1, 0);\n  ans = f[1];\n  while (q--) {\n    scanf(\"%d%lf\", &X, &Y);\n    ++X;\n    d = Y - p[X];\n    if (fa[X]) {\n      int f = fa[X];\n      ans += d * C[X];\n      int ff = fa[f];\n      if (ff) {\n        ans += p[f] * (-d);\n      }\n      C[f] -= d;\n    }\n    p[X] = Y;\n    double ANS = p[1] * (ans + C[1]) + (1.0 - p[1]) * (ans + 1);\n    printf(\"%.5f\\n\", ANS);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, Q, fa[100010], k, la[100010], ff[100010 * 2];\ndouble s[100010], sum[100010], ans;\nstruct node {\n  int a, b;\n} e[100010 * 2];\nvoid add(int a, int b) {\n  e[++k] = (node){a, b};\n  ff[k] = la[a];\n  la[a] = k;\n  e[++k] = (node){b, a};\n  ff[k] = la[b];\n  la[b] = k;\n}\nvoid dfs(int x) {\n  ans += (1 - s[x]) * s[fa[x]];\n  sum[fa[x]] += 1 - s[x];\n  for (int a = la[x]; a; a = ff[a])\n    if (e[a].b != fa[x]) fa[e[a].b] = x, dfs(e[a].b);\n}\nint main() {\n  int a, b, x;\n  double y;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &s[i]);\n  for (int i = 1; i < n; i++) scanf(\"%d%d\", &a, &b), add(a + 1, b + 1);\n  s[0] = 1;\n  dfs(1);\n  scanf(\"%d\", &Q);\n  while (Q--) {\n    scanf(\"%d%lf\", &x, &y);\n    x++;\n    ans -= (1 - s[x]) * s[fa[x]];\n    ans -= s[x] * sum[x];\n    sum[fa[x]] -= 1 - s[x];\n    s[x] = y;\n    sum[fa[x]] += 1 - s[x];\n    ans += (1 - s[x]) * s[fa[x]];\n    ans += s[x] * sum[x];\n    printf(\"%lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\nstruct node {\n  int v, nxt;\n} edge[maxn << 1];\nint first[maxn], tot = 0;\nvoid add(int u, int v) {\n  edge[++tot].v = v;\n  edge[tot].nxt = first[u];\n  first[u] = tot;\n}\nint n, m;\ndouble dp[maxn], p[maxn], ans = 0;\nint f[maxn];\nvoid dfs(int u, int fa) {\n  ans += (1.0 - p[u]) * p[fa];\n  for (int i = first[u]; i; i = edge[i].nxt) {\n    int v = edge[i].v;\n    if (v == fa) continue;\n    dfs(v, u);\n    f[v] = u;\n    dp[u] += 1.0 - p[v];\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  p[0] = 1.0;\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    x++, y++;\n    add(x, y);\n    add(y, x);\n  }\n  dfs(1, 0);\n  scanf(\"%d\", &m);\n  while (m--) {\n    int u;\n    double pp;\n    scanf(\"%d%lf\", &u, &pp);\n    u++;\n    ans -= dp[u] * p[u] + (1.0 - p[u]) * p[f[u]];\n    dp[f[u]] -= 1.0 - p[u];\n    p[u] = pp;\n    ans += dp[u] * p[u] + (1.0 - p[u]) * p[f[u]];\n    dp[f[u]] += 1.0 - p[u];\n    printf(\"%.5f\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma warning(disable : 4996)\nconst int N = 1e5 + 5, P = 400;\ndouble p[N], sum[N];\nvector<int> g[N], w[N];\nbool vip[N];\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  double ans = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    p[i] = 1 - p[i];\n    ans += p[i];\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n    ans -= p[a] * p[b];\n  }\n  for (int i = 0; i < n; i++) {\n    if (g[i].size() > P) {\n      vip[i] = 1;\n      for (int to : g[i]) w[to].push_back(i);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int to : g[i]) {\n      if (!vip[to]) sum[i] += p[to];\n    }\n  }\n  int q;\n  cin >> q;\n  cout << fixed << setprecision(10);\n  while (q--) {\n    int x;\n    double y;\n    cin >> x >> y;\n    y = 1 - y;\n    ans += y - p[x];\n    double s = sum[x];\n    for (int to : w[x]) {\n      s += p[to];\n    }\n    if (!vip[x]) {\n      for (int to : g[x]) {\n        sum[to] += y - p[x];\n      }\n    }\n    ans = ans - s * y + p[x] * s;\n    p[x] = y;\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int MOD = 1000000007;\nlong long int modpow(long long int a, long long int b, long long int mod) {\n  long long int res = 1;\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a;\n    res %= mod;\n    a = a * a;\n    a %= mod;\n  }\n  return res;\n}\nlong long int gcd(long long int a, long long int b) {\n  return b ? gcd(b, a % b) : a;\n}\nvector<long long int> cnt(1e5 + 10);\nvector<long long int> anc(1e5 + 10);\nvector<double> sum(1e5 + 10);\nvector<double> p(1e5 + 10);\nvoid dfs(long long int node, long long int par,\n         vector<vector<long long int>>& g) {\n  anc[node] = par;\n  for (long long int i : g[node]) {\n    if (i == par) continue;\n    cnt[node]++;\n    sum[node] += p[i];\n    dfs(i, node, g);\n  }\n}\nvoid testcases(long long int test) {\n  long long int n;\n  cin >> n;\n  for (long long int i = (long long int)0; i < (long long int)n; ++i)\n    cin >> p[i];\n  vector<vector<long long int>> g(n);\n  for (long long int i = (long long int)0; i < (long long int)n - 1; ++i) {\n    long long int x, y;\n    cin >> x >> y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  dfs(0, -1, g);\n  vector<double> val(n);\n  double ans = 0;\n  for (long long int i = (long long int)0; i < (long long int)n; ++i) {\n    val[i] = (1.0 - p[i]) * (1.0 + sum[i] - cnt[i]);\n    ans += val[i];\n  }\n  long long int q;\n  cin >> q;\n  while (q--) {\n    long long int x;\n    double np;\n    cin >> x >> np;\n    double temp = p[x];\n    p[x] = np;\n    double nval = (1.0 - p[x]) * (1.0 + sum[x] - cnt[x]);\n    ans += (nval - val[x]);\n    val[x] = nval;\n    if (anc[x] > -1) {\n      long long int y = anc[x];\n      sum[y] += np - temp;\n      nval = (1.0 - p[y]) * (1.0 + sum[y] - cnt[y]);\n      ans += (nval - val[y]);\n      val[y] = nval;\n    }\n    cout << fixed << setprecision(12) << ans << \"\\n\";\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t;\n  t = 1;\n  for (long long int i = (long long int)0; i < (long long int)t; ++i)\n    testcases(i);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 100007;\nlong double pr[MAX];\nlong double sonsum[MAX];\nvector<int> edg[MAX];\nint parent[MAX];\nvoid dfs(int u, int p = -1) {\n  sonsum[u] = 0;\n  for (int v : edg[u]) {\n    if (v == p) continue;\n    sonsum[u] += pr[v];\n    parent[v] = u;\n    dfs(v, u);\n  }\n}\nlong double ans;\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%Lf\", &pr[i]);\n  }\n  for (int i = 1; i < N; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    edg[u].push_back(v);\n    edg[v].push_back(u);\n  }\n  dfs(0);\n  ans = 1;\n  for (int i = 0; i < N; i++) {\n    ans += pr[i] * ((long double)edg[i].size() - 1);\n    ans -= pr[i] * sonsum[i];\n  }\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int u;\n    long double wut;\n    scanf(\"%d %Lf\", &u, &wut);\n    long double del = wut - pr[u];\n    ans += del * ((long double)edg[u].size() - 1);\n    ans -= del * sonsum[u];\n    pr[u] = wut;\n    if (u > 0) {\n      ans -= pr[parent[u]] * del;\n      sonsum[parent[u]] += del;\n    }\n    printf(\"%.8Lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, x, y, tot, head[300000], fa[300000];\ndouble z, son[300000], a[300000], ans;\nstruct edge {\n  int v, nxt;\n} e[300000];\nvoid add(int x, int y) {\n  e[++tot].v = y;\n  e[tot].nxt = head[x];\n  head[x] = tot;\n}\nvoid dfs(int u) {\n  for (int i = head[u], v; i; i = e[i].nxt)\n    if ((v = e[i].v) != fa[u]) {\n      fa[v] = u;\n      dfs(v);\n      son[u] += 1 - a[v];\n    }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%lf\", a + i);\n  for (int i = 1; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    add(++x, ++y);\n    add(y, x);\n  }\n  dfs(1);\n  scanf(\"%d\", &m);\n  a[0] = 1;\n  for (int i = 1; i <= n; ++i) ans += a[fa[i]] * (1 - a[i]);\n  while (m--) {\n    scanf(\"%d%lf\", &x, &z);\n    ++x;\n    ans -= a[fa[x]] * (1 - a[x]) + a[x] * son[x];\n    son[fa[x]] -= 1 - a[x];\n    a[x] = z;\n    ans += a[fa[x]] * (1 - a[x]) + a[x] * son[x];\n    son[fa[x]] += 1 - a[x];\n    printf(\"%.8lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\ndouble p[N], sum[N], ans;\nint fa[N];\nvector<int> G[N];\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  for (; ch < '0' || ch > '9'; ch = getchar())\n    if (ch == '-') f = -1;\n  for (; ch >= '0' && ch <= '9'; ch = getchar())\n    x = (x << 1) + (x << 3) + ch - '0';\n  return x * f;\n}\nvoid dfs(int u, int Fa) {\n  fa[u] = Fa;\n  ans += (1 - p[u]) * p[Fa];\n  for (int v : G[u])\n    if (v ^ Fa) dfs(v, u), sum[u] += (1 - p[v]);\n}\nint main() {\n  int n = read();\n  for (register int i = (1); i <= (n); ++i) scanf(\"%lf\", &p[i]);\n  p[0] = 1;\n  for (register int i = (1); i <= (n - 1); ++i) {\n    int u = read() + 1, v = read() + 1;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs(1, 0);\n  int q = read();\n  for (register int i = (1); i <= (q); ++i) {\n    int u = read() + 1;\n    double P;\n    scanf(\"%lf\", &P);\n    ans += (p[u] - P) * p[fa[u]];\n    ans += (P - p[u]) * sum[u];\n    sum[fa[u]] += p[u] - P;\n    p[u] = P;\n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble fall[100005];\ndouble sumaround[100005];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<vector<int> > graph(n, vector<int>());\n  vector<vector<int> > graph2(n, vector<int>());\n  double sum2 = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf\", &fall[i]);\n    sum2 += fall[i];\n  }\n  double sum = 0;\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n    sumaround[a] += (1 - fall[b]);\n    sumaround[b] += (1 - fall[a]);\n    sum += (1 - fall[a]) * (1 - fall[b]);\n  }\n  for (int i = 0; i < n; i++) {\n    if (graph[i].size() >= 250) {\n      for (int u : graph[i]) {\n        graph2[u].push_back(i);\n      }\n    }\n  }\n  int q;\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    int x;\n    double p;\n    scanf(\"%d %lf\", &x, &p);\n    sum2 += p - fall[x];\n    double cursum = 0;\n    if (graph[x].size() > 250) {\n      cursum = sumaround[x];\n    } else {\n      for (int u : graph[x]) {\n        cursum += 1 - fall[u];\n      }\n    }\n    for (int u : graph2[x]) {\n      sumaround[u] += fall[x] - p;\n    }\n    sum -= (1 - fall[x]) * cursum;\n    sum += (1 - p) * cursum;\n    fall[x] = p;\n    printf(\"%.6f\\n\", n - sum - sum2);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int Get() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while ('0' <= ch && ch <= '9') {\n    x = (x << 1) + (x << 3) + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint n, m;\ndouble p[100005];\nstruct load {\n  int to, next;\n} s[100005 << 1];\nint h[100005], cnt;\nvoid add(int i, int j) {\n  s[++cnt] = (load){j, h[i]};\n  h[i] = cnt;\n}\nint fa[100005];\ndouble sum[100005];\nvoid dfs(int v, int fr) {\n  for (int i = h[v]; i; i = s[i].next) {\n    int to = s[i].to;\n    if (to == fr) continue;\n    fa[to] = v;\n    dfs(to, v);\n    sum[v] += (1 - p[to]);\n  }\n}\ndouble ans, c;\nint main() {\n  n = Get();\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  p[0] = 1;\n  int a, b;\n  for (int i = 1; i < n; i++) {\n    a = Get() + 1, b = Get() + 1;\n    add(a, b), add(b, a);\n  }\n  dfs(1, 0);\n  for (int i = 1; i <= n; i++) {\n    ans += p[fa[i]] * (1 - p[i]);\n  }\n  m = Get();\n  while (m--) {\n    a = Get() + 1;\n    scanf(\"%lf\", &c);\n    ans -= p[fa[a]] * (1 - p[a]);\n    ans -= sum[a] * p[a];\n    sum[fa[a]] -= 1 - p[a];\n    p[a] = c;\n    ans += p[fa[a]] * (1 - p[a]);\n    ans += sum[a] * p[a];\n    sum[fa[a]] += 1 - p[a];\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, from, to, num, head[100010], father[100010], q;\ndouble p[100010], sum, g[100010], ans;\nint read() {\n  int x = 0;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') ch = getchar();\n  while (ch >= '0' && ch <= '9') {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = getchar();\n  }\n  return x;\n}\nstruct xx {\n  int next, to;\n} way[200010];\nvoid add(int from, int to) {\n  way[++num].next = head[from];\n  way[num].to = to;\n  head[from] = num;\n}\nvoid dfs(int x, int fa) {\n  father[x] = fa;\n  for (int i = head[x]; i; i = way[i].next) {\n    int y = way[i].to;\n    if (y == fa) continue;\n    dfs(y, x);\n    g[x] += (1 - p[y]);\n  }\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; i++) {\n    from = read() + 1;\n    to = read() + 1;\n    add(from, to);\n    add(to, from);\n  }\n  dfs(1, 0);\n  for (int i = 1; i <= n; i++) {\n    ans = ans + (g[i]) * (1 - p[i]) + p[i];\n  }\n  q = read();\n  p[0] = 1;\n  while (q--) {\n    int x = read() + 1;\n    double r;\n    scanf(\"%lf\", &r);\n    ans -= p[x] + (g[x]) * (1 - p[x]);\n    ans += r + (g[x]) * (1 - r);\n    ans -= g[father[x]] * (1 - p[father[x]]);\n    g[father[x]] = g[father[x]] - (1 - p[x]) + (1 - r);\n    ans += g[father[x]] * (1 - p[father[x]]);\n    printf(\"%lf\\n\", n - ans);\n    p[x] = r;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1.1e5;\nint N;\nint V[MAXN];\nvector<int> adj[MAXN];\nint par[MAXN];\nint chsum[MAXN];\nvoid dfs(int cur, int prv = 0) {\n  par[cur] = prv;\n  chsum[par[cur]] += 100 - V[cur];\n  for (int nxt : adj[cur]) {\n    if (nxt == prv) continue;\n    dfs(nxt, cur);\n  }\n}\nint readReal() {\n  int a, b;\n  (void)scanf(\"%d.%d\", &a, &b);\n  return a * 100 + b;\n}\nint main() {\n  (void)scanf(\"%d\", &N);\n  V[0] = 100;\n  for (int i = 1; i <= N; i++) {\n    V[i] = readReal();\n  }\n  for (int i = 0; i < N - 1; i++) {\n    int u, v;\n    (void)scanf(\"%d %d\", &u, &v);\n    u++, v++;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  dfs(1);\n  int res = 0;\n  for (int i = 0; i <= N; i++) {\n    res += V[i] * chsum[i];\n  }\n  int Q;\n  (void)scanf(\"%d\", &Q);\n  for (int q = 1; q <= Q; q++) {\n    int i;\n    (void)scanf(\"%d\", &i);\n    i++;\n    int v = readReal();\n    res -= (v - V[i]) * V[par[i]];\n    res += (v - V[i]) * chsum[i];\n    chsum[par[i]] -= (v - V[i]);\n    V[i] = v;\n    printf(\"%d.%04d\\n\", res / 10000, res % 10000);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int mxN = int(1e5) + 5;\ndouble dp[mxN], arr[mxN];\nvector<int> adj[mxN];\nint par[mxN];\nvoid dfs(int u, int p) {\n  par[u] = p;\n  for (auto v : adj[u]) {\n    if (v == p) {\n      continue;\n    }\n    dp[u] += arr[v];\n    dfs(v, u);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n    arr[i] = 1 - arr[i];\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  dfs(0, 0);\n  double res = 0;\n  for (int i = 0; i < n; i++) {\n    res += arr[i] - arr[i] * dp[i];\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int node;\n    double p;\n    cin >> node >> p;\n    p = 1 - p;\n    res -= arr[node] - arr[node] * dp[node];\n    if (node != 0) {\n      res += arr[node] * arr[par[node]];\n      dp[par[node]] -= arr[node];\n    }\n    arr[node] = p;\n    if (node != 0) {\n      dp[par[node]] += arr[node];\n      res -= arr[node] * arr[par[node]];\n    }\n    res += arr[node] - arr[node] * dp[node];\n    cout << res << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, q, fa[N], u, v;\ndouble ans, pb[N], sum[N];\nstruct tree {\n  int to;\n  int nxt;\n} e[N * 2];\nint head[N * 2], cnt;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\ninline void add(int x, int y) {\n  e[++cnt].nxt = head[x];\n  e[cnt].to = y;\n  head[x] = cnt;\n}\nvoid dfs(int x, int f) {\n  fa[x] = f;\n  ans += pb[fa[x]] * (1 - pb[x]);\n  for (int i = head[x]; i; i = e[i].nxt) {\n    int y = e[i].to;\n    if (y == f) continue;\n    dfs(y, x);\n    sum[x] += (1 - pb[y]);\n  }\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; ++i) scanf(\"%lf\", &pb[i]);\n  for (int i = 1; i < n; ++i) {\n    int x = read() + 1, y = read() + 1;\n    add(x, y);\n    add(y, x);\n  }\n  pb[0] = 1;\n  dfs(1, 0);\n  q = read();\n  for (int i = 1; i <= q; ++i) {\n    double del;\n    int x = read();\n    scanf(\"%lf\", &del);\n    x++;\n    ans += pb[fa[x]] * (1 - del) - pb[fa[x]] * (1 - pb[x]);\n    ans += del * sum[x] - pb[x] * sum[x];\n    sum[fa[x]] += -del + pb[x];\n    pb[x] = del;\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nconst int block = 314;\nvector<int> ed[N];\nvector<int> big[N];\nint n, q;\ndouble p[N], sum[N];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u++;\n    v++;\n    ed[u].push_back(v);\n    ed[v].push_back(u);\n  }\n  for (int i = 1; i <= n; i++) {\n    for (auto to : ed[i]) sum[i] += 1 - p[to];\n    for (auto to : ed[i])\n      if (ed[to].size() > block) big[i].push_back(to);\n  }\n  double global = 0;\n  double ans = 0;\n  for (int i = 1; i <= n; i++) {\n    global += p[i];\n    ans -= sum[i] * (1 - p[i]);\n    ans += ed[i].size();\n  }\n  cin >> q;\n  for (; q >= 1; q--) {\n    int v;\n    double c;\n    scanf(\"%d%lf\", &v, &c);\n    v++;\n    global += c - p[v];\n    if (ed[v].size() <= block) {\n      for (auto to : ed[v]) ans += 2 * (1 - p[to]) * (c - p[v]);\n      for (auto to : big[v]) {\n        sum[to] -= (1 - p[v]);\n        sum[to] += (1 - c);\n      }\n      p[v] = c;\n    } else {\n      ans += 2 * (1 - p[v]) * sum[v];\n      ans -= 2 * (1 - c) * sum[v];\n      for (auto to : big[v]) {\n        sum[to] -= (1 - p[v]);\n        sum[to] += (1 - c);\n      }\n    }\n    printf(\"%.5lf\\n\", ans / 2 + 1 - global);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nvector<int> G[maxn];\ndouble P[maxn], f[maxn], sp, sf;\nint parent[maxn];\nvoid dfs(int nodo, int p) {\n  parent[nodo] = p;\n  for (auto i : G[nodo]) {\n    if (i == p) continue;\n    f[nodo] += P[i];\n    dfs(i, nodo);\n  }\n  sf += P[nodo] * f[nodo];\n}\ndouble solve() { return sp - sf; }\nvoid update(int n, double p) {\n  sp -= P[n];\n  sp += p;\n  sf -= P[n] * f[n];\n  sf += p * f[n];\n  if (parent[n] != -1) {\n    sf -= P[parent[n]] * f[parent[n]];\n    f[parent[n]] -= P[n];\n    f[parent[n]] += p;\n    sf += P[parent[n]] * f[parent[n]];\n  }\n  P[n] = p;\n}\nint main() {\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    scanf(\"%lf\", &P[i]);\n    P[i] = 1 - P[i];\n    sp += P[i];\n  }\n  int a, b;\n  for (int i = 1; i < N; i++) {\n    scanf(\"%d%d\", &a, &b);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  dfs(0, -1);\n  int Q, v;\n  double p;\n  scanf(\"%d\", &Q);\n  while (Q--) {\n    scanf(\"%d%lf\", &v, &p);\n    update(v, 1 - p);\n    printf(\"%lf\\n\", solve());\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint head[100001], nxt[100001 << 1], ver[100001 << 1], tot;\nint n;\ninline void addedge(int a, int b) {\n  nxt[++tot] = head[a];\n  ver[tot] = b;\n  head[a] = tot;\n  nxt[++tot] = head[b];\n  ver[tot] = a;\n  head[b] = tot;\n}\ndouble a[100001];\ninline void init() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", a + i);\n  for (int i = 1, a, b; i < n; i++)\n    scanf(\"%d%d\", &a, &b), a++, b++, addedge(a, b);\n}\ndouble f[100001][2];\nint fa[100001];\ninline void update(int x) {\n  f[x][1] = 1;\n  f[x][0] = 0;\n  for (int i = head[x]; i; i = nxt[i]) {\n    int y = ver[i];\n    if (y == fa[x]) continue;\n    f[x][0] += a[y] * f[y][0] + (1.0 - a[y]) * f[y][1];\n    f[x][1] += a[y] * f[y][0] + (1.0 - a[y]) * (f[y][1] - 1);\n  }\n  if (fa[x]) update(fa[x]);\n}\ninline void dp(int x, int fat) {\n  f[x][1] = 1;\n  f[x][0] = 0;\n  fa[x] = fat;\n  for (int i = head[x]; i; i = nxt[i]) {\n    int y = ver[i];\n    if (y == fat) continue;\n    dp(y, x);\n    f[x][0] += a[y] * f[y][0] + (1.0 - a[y]) * f[y][1];\n    f[x][1] += a[y] * f[y][0] + (1.0 - a[y]) * (f[y][1] - 1);\n  }\n}\nint main() {\n  init();\n  dp(1, 0);\n  int q;\n  cin >> q;\n  while (q--) {\n    int x;\n    scanf(\"%d\", &x);\n    x++;\n    scanf(\"%lf\", a + x);\n    update(x);\n    printf(\"%0.5f\\n\", a[1] * f[1][0] + (1.0 - a[1]) * f[1][1]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5;\nstruct BIT {\n  int n;\n  double b[N];\n  void init(int _n) {\n    n = _n;\n    for (int i = 0; i <= n; i++) b[i] = 0.0;\n  }\n  void add(int i, double x) {\n    for (; i <= n; i += i & -i) {\n      b[i] += x;\n    }\n  }\n  double sum(int i) {\n    double s = 0.0;\n    for (; i > 0; i -= i & -i) {\n      s += b[i];\n    }\n    return s;\n  }\n} B;\nint n, q, u, v, t, L[N], R[N], fa[N];\ndouble x, p[N], dp[N][2];\nvector<int> G[N];\nvoid dfs(int u, int f) {\n  fa[u] = f;\n  L[u] = ++t;\n  dp[u][0] = 0.0;\n  dp[u][1] = 1.0;\n  for (int i = 0; i < G[u].size(); i++) {\n    int v = G[u][i];\n    if (v == f) continue;\n    dfs(v, u);\n    dp[u][0] += p[v] * dp[v][1] + (1.0 - p[v]) * dp[v][0];\n    dp[u][1] += p[v] * (dp[v][1] - 1.0) + (1.0 - p[v]) * dp[v][0];\n  }\n  R[u] = t;\n}\ndouble get_ans() {\n  double sum = B.sum(n) - B.sum(1);\n  double dp0 = dp[0][0] + sum;\n  double dp1 = dp[0][1] + sum;\n  return p[0] * dp1 + (1.0 - p[0]) * dp0;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf\", &p[i]);\n    p[i] = 1.0 - p[i];\n  }\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d %d\", &u, &v);\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  t = 0;\n  dfs(0, -1);\n  B.init(n);\n  scanf(\"%d\", &q);\n  while (q--) {\n    scanf(\"%d %lf\", &v, &x);\n    x = 1.0 - x;\n    if (v != 0) {\n      double det = x - p[v];\n      double sum = B.sum(R[v]) - B.sum(L[v]);\n      double dp0 = dp[v][0] + sum;\n      double dp1 = dp[v][1] + sum;\n      u = fa[v];\n      dp[u][0] += det * (dp1 - dp0);\n      dp[u][1] += det * (dp1 - dp0 - 1);\n      B.add(L[u], det * (dp1 - dp0 - p[u]));\n    }\n    p[v] = x;\n    printf(\"%.6f\\n\", get_ans());\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, q, f[N];\ndouble sum[N], a[N], ans;\nvector<int> v[N];\nvoid dfs(int pos, int fa) {\n  f[pos] = fa;\n  for (auto &i : v[pos])\n    if (i != fa) dfs(i, pos), sum[pos] += a[i];\n  ans += (1 - a[pos]) * sum[pos];\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &a[i]), a[i] = 1 - a[i];\n  int t1, t2;\n  for (int i = 1; i < n; i++)\n    scanf(\"%d%d\", &t1, &t2), ++t1, ++t2, v[t1].push_back(t2),\n        v[t2].push_back(t1);\n  dfs(1, 0);\n  sum[0] = a[1];\n  ans += a[1];\n  scanf(\"%d\", &q);\n  double t3;\n  for (int i = 1; i <= q; i++) {\n    scanf(\"%d%lf\", &t1, &t3);\n    ++t1;\n    t3 = 1 - t3;\n    ans -= (1 - a[f[t1]]) * sum[f[t1]];\n    sum[f[t1]] += t3 - a[t1];\n    ans += (1 - a[f[t1]]) * sum[f[t1]];\n    ans -= (1 - a[t1]) * sum[t1];\n    a[t1] = t3;\n    ans += (1 - a[t1]) * sum[t1];\n    printf(\"%.8lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nusing D = float;\nint n;\nint parents[(int)1e5];\nD p_fail[(int)1e5];\nD contrib[(int)1e5];\nvector<int> g[(int)1e5];\narray<D, 2> dfs(int root, int parent) {\n  parents[root] = parent;\n  D expect_sum = 0;\n  D expect_num = 0;\n  for (auto child : g[root]) {\n    if (child == parent) continue;\n    auto expect = dfs(child, root);\n    expect_sum += p_fail[child] * expect[0] + (1 - p_fail[child]) * expect[1];\n    expect_num += 1 - p_fail[child];\n  }\n  contrib[root] = 1 - expect_num;\n  return {expect_sum, expect_sum + contrib[root]};\n}\nD result;\nD query(int node, D np_fail) {\n  result -= (1 - p_fail[node]) * contrib[node];\n  result += (1 - np_fail) * contrib[node];\n  if (node != 0) {\n    result -= (1 - p_fail[parents[node]]) * contrib[parents[node]];\n    contrib[parents[node]] += (1 - p_fail[node]);\n    contrib[parents[node]] -= (1 - np_fail);\n    result += (1 - p_fail[parents[node]]) * contrib[parents[node]];\n  }\n  p_fail[node] = np_fail;\n  return result;\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  int n;\n  cin >> n;\n  for (int i = 0; i < (n); i++) cin >> p_fail[i];\n  for (int i = 0; i < (n - 1); i++) {\n    int a, b;\n    cin >> a >> b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  auto expect = dfs(0, -1);\n  result = p_fail[0] * expect[0] + (1 - p_fail[0]) * expect[1];\n  int q;\n  cin >> q;\n  cout << fixed << setprecision(15);\n  for (int i = 0; i < (q); i++) {\n    int node;\n    D np_fail;\n    cin >> node >> np_fail;\n    cout << query(node, np_fail) << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<int, int>;\nusing VI = vector<int>;\nconst int N = 1e5 + 10;\nVI adj[N];\nusing ld = double;\nint par[N];\nld prob[N], ch[N];\nld ans = 0;\nvoid dfs(int u, int p) {\n  par[u] = p;\n  ans += (1 - prob[u]) * prob[p];\n  for (int v : adj[u]) {\n    if (v == p) continue;\n    ch[u] += 1 - prob[v];\n    dfs(v, u);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  prob[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    cin >> prob[i];\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    u++, v++;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  dfs(1, 0);\n  int q;\n  cin >> q;\n  cout << setprecision(10) << fixed;\n  while (q--) {\n    int u;\n    ld pp;\n    cin >> u >> pp;\n    u++;\n    ans -= (1 - prob[u]) * prob[par[u]];\n    ans -= prob[u] * ch[u];\n    ch[par[u]] -= (1 - prob[u]);\n    prob[u] = pp;\n    ch[par[u]] += (1 - prob[u]);\n    ans += prob[u] * ch[u];\n    ans += (1 - prob[u]) * prob[par[u]];\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\n\npublic class d {\n\n\t/* @formatoff\n\n12\n0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5\n0 6\n0 7\n6 2\n7 3\n7 10\n7 11\n2 8\n2 1\n2 5\n11 9O\n11 4\n\n\n\t * @formaton\n\t */\n\tstatic class Solver {\n\n\t\tint N, Q, par[], map[], l[], r[];\n\t\tdouble plive[], pfall[], iprob[], EXP_NODES, EXP_EDGES;\n\t\tArrayList<Integer>[] adj;\n\t\tNode st;\n\n\t\tvoid rootDFS(int n, int p) {\n\t\t\t// ORIGINAL NUMBERING\n\t\t\tpar[n] = p;\n\t\t\tadj[n].removeIf(x -> x == p);\n\t\t\tfor (int i : adj[n])\n\t\t\t\trootDFS(i, n);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tvoid solve(FastScanner s, PrintWriter out) {\n\t\t\tN = s.nextInt();\n\t\t\tiprob = new double[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tiprob[i] = s.nextDouble();\n\t\t\tadj = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tadj[i] = new ArrayList<>();\n\t\t\tEXP_EDGES = 0;\n\t\t\tfor (int i = 1; i < N; i++) {\n\t\t\t\tint u = s.nextInt(), v = s.nextInt();\n\t\t\t\tEXP_EDGES += (1 - iprob[u]) * (1 - iprob[v]);\n\t\t\t\tadj[u].add(v);\n\t\t\t\tadj[v].add(u);\n\t\t\t}\n\t\t\tpar = new int[N];\n\t\t\trootDFS(0, -1);\n\t\t\t// numbering\n\t\t\tmap = new int[N];\n\t\t\tint ind = 0, cur;\n\t\t\tArrayDeque<Integer> q = new ArrayDeque<>();\n\t\t\tq.add(0);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tcur = q.poll();\n\t\t\t\tmap[cur] = ind++;\n\t\t\t\tfor (int i : adj[cur])\n\t\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\t// ORIGINAL IDs -> NEW IDS\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tif (par[i] != -1)\n\t\t\t\t\tpar[i] = map[par[i]];\n\t\t\tl = new int[N];\n\t\t\tr = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t// use mapped IDs for left/right children\n\t\t\t\tif (adj[i].size() == 0)\n\t\t\t\t\tl[i] = r[i] = -1;\n\t\t\t\telse {\n\t\t\t\t\tl[i] = r[i] = map[adj[i].get(0)];\n\t\t\t\t\tfor (int k : adj[i])\n\t\t\t\t\t\tr[i] = map[k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// initialize segtree - probability a node lives\n\t\t\tst = new Node(0, N - 1);\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tst.set(map[i], 1 - iprob[i]);\n\n\t\t\tQ = s.nextInt();\n\t\t\tfor (int qu = 1; qu <= Q; qu++) {\n\t\t\t\tint x = s.nextInt(), mx = map[x];\n\t\t\t\tdouble newProb = 1 - s.nextDouble();\n\t\t\t\tdouble changeInProb = newProb - st.get(mx);\n\t\t\t\tdouble adj = (l[x] == -1 ? 0 : st.sum(l[x], r[x])) + (par[x] == -1 ? 0 : st.get(par[x]));\n\t\t\t\tst.set(mx, newProb);\n\t\t\t\tEXP_NODES = st.sum(0, N - 1);\n\t\t\t\tEXP_EDGES += changeInProb * adj;\n\t\t\t\tout.printf(\"%.12f%n\", EXP_NODES - EXP_EDGES);\n\t\t\t}\n\t\t}\n\n\t\tclass Node {\n\n\t\t\tint l, m, r;\n\t\t\tdouble sum;\n\t\t\tNode L, R;\n\n\t\t\tNode(int ll, int rr) {\n\t\t\t\tl = ll;\n\t\t\t\tr = rr;\n\t\t\t\tm = l + (r - l) / 2;\n\t\t\t\tif (ll == rr)\n\t\t\t\t\treturn;\n\t\t\t\tsum = 0;\n\t\t\t\tL = new Node(l, m);\n\t\t\t\tR = new Node(m + 1, r);\n\t\t\t}\n\n\t\t\tvoid set(int i, double x) {\n\t\t\t\tif (l == i && r == i) {\n\t\t\t\t\tsum = x;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (i <= m)\n\t\t\t\t\tL.set(i, x);\n\t\t\t\telse\n\t\t\t\t\tR.set(i, x);\n\t\t\t\tsum = L.sum + R.sum;\n\t\t\t}\n\n\t\t\tdouble get(int i) {\n\t\t\t\treturn sum(i, i);\n\t\t\t}\n\n\t\t\tdouble sum(int s, int e) {\n\t\t\t\tif (s <= l && r <= e)\n\t\t\t\t\treturn sum;\n\t\t\t\tdouble res = 0;\n\t\t\t\tif (s <= m)\n\t\t\t\t\tres += L.sum(s, e);\n\t\t\t\tif (m < e)\n\t\t\t\t\tres += R.sum(s, e);\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class BruteSolver {\n\n\t\tint N, Q, edges[][];\n\t\tdouble plive[], pfall[], EXP_NODES, EXP_EDGES;\n\n\t\tvoid solve(FastScanner s, PrintWriter out) {\n\t\t\tEXP_NODES = N = s.nextInt();\n\t\t\tpfall = s.nextDoubleArray(N);\n\t\t\tplive = new double[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tplive[i] = 1 - pfall[i];\n\t\t\t\tEXP_NODES -= pfall[i];\n\t\t\t}\n\t\t\tedges = s.next2DIntArray(N - 1, 2);\n\t\t\tQ = s.nextInt();\n\t\t\tfor (int q = 1; q <= Q; q++) {\n\t\t\t\tint x = s.nextInt();\n\t\t\t\tdouble np = s.nextDouble();\n\t\t\t\tEXP_NODES -= np - pfall[x];\n\t\t\t\tplive[x] = 1 - (pfall[x] = np);\n\t\t\t\tEXP_EDGES = 0;\n\t\t\t\tfor (int[] e : edges)\n\t\t\t\t\tEXP_EDGES += plive[e[0]] * plive[e[1]];\n\t\t\t\tout.printf(\"%.12f%n\", EXP_NODES - EXP_EDGES);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tFastScanner s = new FastScanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tSolver solver = new Solver();\n\t\tsolver.solve(s, out);\n\n\t\tout.close();\n\t\ts.close();\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic FastScanner(File f) throws FileNotFoundException {\n\t\t\tthis(new FileInputStream(f));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\tthis.stream = new ByteArrayInputStream(s.getBytes(StandardCharsets.UTF_8));\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\t// Jacob Garbage\n\n\t\tpublic int[] nextIntArray(int N) {\n\t\t\tint[] ret = new int[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tret[i] = this.nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int[][] next2DIntArray(int N, int M) {\n\t\t\tint[][] ret = new int[N][];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tret[i] = this.nextIntArray(M);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int N) {\n\t\t\tlong[] ret = new long[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tret[i] = this.nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[][] next2DLongArray(int N, int M) {\n\t\t\tlong[][] ret = new long[N][];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tret[i] = nextLongArray(M);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int N) {\n\t\t\tdouble[] ret = new double[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tret[i] = this.nextDouble();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double[][] next2DDoubleArray(int N, int M) {\n\t\t\tdouble[][] ret = new double[N][];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tret[i] = this.nextDoubleArray(M);\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, q, fa[100005], u, v;\ndouble ans, pb[100005], sum[100005];\nstruct tree {\n  int v;\n  tree *next;\n} * h[100005], pool[100005 << 1], *tot = pool;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\ninline void addedge(int u, int v) {\n  tree *p = tot++;\n  p->v = v;\n  p->next = h[u];\n  h[u] = p;\n}\nvoid dfs(int u, int f) {\n  fa[u] = f;\n  ans += pb[fa[u]] * (1 - pb[u]);\n  for (tree *p = h[u]; p; p = p->next)\n    if (p->v != f) {\n      dfs(p->v, u);\n      sum[u] += (1 - pb[p->v]);\n    }\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &pb[i]);\n  for (int i = 1; i < n; i++) {\n    u = read();\n    v = read();\n    u++;\n    v++;\n    addedge(u, v);\n    addedge(v, u);\n  }\n  pb[0] = 1;\n  dfs(1, 0);\n  q = read();\n  for (int i = 1; i <= q; i++) {\n    double del;\n    u = read();\n    scanf(\"%lf\", &del);\n    u++;\n    ans += pb[fa[u]] * (1 - del) - pb[fa[u]] * (1 - pb[u]);\n    ans += del * sum[u] - pb[u] * sum[u];\n    sum[fa[u]] += -del + pb[u];\n    pb[u] = del;\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, q, fa[100010];\nvector<int> v[100010];\ndouble p[100010], sum[100010], ans;\nvoid dfs(int np, int fath) {\n  fa[np] = fath;\n  ans += p[fa[np]] * (1 - p[np]);\n  for (auto &x : v[np]) {\n    if (x == fath) continue;\n    dfs(x, np);\n    sum[np] += 1 - p[x];\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  p[0] = 1;\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1, ti, tj; i < n; i++) {\n    scanf(\"%d%d\", &ti, &tj);\n    ti++;\n    tj++;\n    v[ti].push_back(tj);\n    v[tj].push_back(ti);\n  }\n  dfs(1, 0);\n  scanf(\"%d\", &q);\n  while (q--) {\n    int x;\n    double y;\n    scanf(\"%d%lf\", &x, &y);\n    x++;\n    ans -= p[x] * sum[x] + p[fa[x]] * (1 - p[x]), sum[fa[x]] -= 1 - p[x];\n    p[x] = y;\n    ans += p[x] * sum[x] + p[fa[x]] * (1 - p[x]), sum[fa[x]] += 1 - p[x];\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, q, fa[666666];\ndouble a[666666], sc[666666], ans = 0;\nint M = 0, fst[666666], vb[666666], nxt[666666];\nvoid ad_de(int a, int b) {\n  ++M;\n  nxt[M] = fst[a];\n  fst[a] = M;\n  vb[M] = b;\n}\nvoid adde(int a, int b) {\n  ad_de(a, b);\n  ad_de(b, a);\n}\nvoid dfs(int x, int f = 0) {\n  fa[x] = f;\n  for (int e = fst[x], b = vb[e]; e; e = nxt[e], b = vb[e])\n    if (b != f) sc[x] += a[b], dfs(b, x);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%lf\", a + i), a[i] = 1 - a[i];\n  for (int i = 1, a, b; i < n; ++i) scanf(\"%d%d\", &a, &b), ++a, ++b, adde(a, b);\n  dfs(1);\n  for (int i = 1; i <= n; ++i) ans += a[i] - a[i] * sc[i];\n  scanf(\"%d\", &q);\n  while (q--) {\n    int x;\n    double u;\n    scanf(\"%d%lf\", &x, &u);\n    u = 1 - u;\n    ++x;\n    u = u - a[x];\n    ans += u * (1 - sc[x]);\n    if (fa[x]) ans -= a[fa[x]] * u, sc[fa[x]] += u;\n    a[x] += u;\n    printf(\"%.10lf\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, x, y, q, pa[111111];\ndouble p[111111], dp[111111], cur, ans, sum[111111];\nvector<int> g[111111];\nvoid dfs(int i, int fa) {\n  pa[i] = fa;\n  for (int j = 0; j < g[i].size(); j++) {\n    int to = g[i][j];\n    if (to == fa) continue;\n    dfs(to, i);\n    dp[i] += dp[to];\n    sum[i] += (1.00 - p[to]);\n  }\n  dp[i] -= (1.00 - p[i]) * (sum[i] - 1.00);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d\", &x, &y);\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  dfs(0, -1);\n  scanf(\"%d\", &q);\n  ans = dp[0];\n  while (q--) {\n    scanf(\"%d%lf\", &x, &cur);\n    if (x == 0) {\n      ans -= (p[0] - cur) * (sum[0] - 1);\n    } else {\n      ans -= (p[x] - cur) * (sum[x] - 1);\n      sum[pa[x]] -= (cur - p[x]);\n      ans += (1.00 - p[pa[x]]) * (cur - p[x]);\n    }\n    p[x] = cur;\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int INF = std::numeric_limits<int>::max() / 2;\nconst long long INFLL = std::numeric_limits<long long>::max() / 2;\nconst int MAX_N = 1e5;\nint n, q, par[MAX_N];\nstd::vector<int> adj[MAX_N];\ndouble prb[MAX_N], sub[MAX_N];\nvoid dfs(int i) {\n  for (int j : adj[i])\n    if (j != par[i]) {\n      sub[i] += 1.0 - prb[j];\n      par[j] = i;\n      dfs(j);\n    }\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  std::cout.tie(nullptr);\n  std::cin >> n;\n  for (int i = 0; i < n; ++i) std::cin >> prb[i];\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    std::cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  par[0] = -1;\n  dfs(0);\n  double ans = (1.0 - prb[0]);\n  for (int i = 0; i < n; ++i) ans += prb[i] * sub[i];\n  std::cin >> q;\n  while (q--) {\n    int i;\n    double p;\n    std::cin >> i >> p;\n    ans += (prb[i] - p) * (par[i] == -1 ? 1.0 : prb[par[i]]);\n    ans += (p - prb[i]) * sub[i];\n    if (par[i] != -1) sub[par[i]] += prb[i] - p;\n    prb[i] = p;\n    std::cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, q;\nvector<int> adj[100010];\ndouble pr[100010];\ndouble res;\nint sn[100010];\ndouble snm[100010];\nint fa[100010];\nvoid dfs(int i) {\n  res += (1 - pr[i]) * pr[fa[i]];\n  for (int j = adj[i].size() - 1; ~j; --j) {\n    if (adj[i][j] != fa[i])\n      fa[adj[i][j]] = i, dfs(adj[i][j]), ++sn[i], snm[i] += pr[adj[i][j]];\n  }\n}\nint main(void) {\n  fa[1] = 0;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lf\", &pr[i]);\n    snm[i] = 0;\n  }\n  pr[0] = 1;\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    ++u;\n    ++v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  dfs(1);\n  scanf(\"%d\", &q);\n  while (q--) {\n    int x;\n    double nw;\n    scanf(\"%d%lf\", &x, &nw);\n    ++x;\n    res -= (1 - pr[x]) * pr[fa[x]];\n    res -= (sn[x] - snm[x]) * pr[x];\n    snm[fa[x]] -= pr[x];\n    pr[x] = nw;\n    snm[fa[x]] += pr[x];\n    res += (1 - pr[x]) * pr[fa[x]];\n    res += (sn[x] - snm[x]) * pr[x];\n    printf(\"%.8f\\n\", res);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\nint n, q, S;\nint a[MAXN];\nvector<int> e[MAXN], be[MAXN];\nint deg[MAXN];\nint bs[MAXN];\nint qa, qb;\nvoid init();\nvoid input();\nvoid inputq();\nvoid work();\nint main() {\n  init();\n  input();\n  work();\n}\nvoid init() { ios::sync_with_stdio(false); }\nvoid input() {\n  scanf(\"%d\", &n);\n  double tb;\n  for (int i = 1; i <= n; ++i)\n    scanf(\"%lf\", &tb), a[i] = 100 - static_cast<int>(floor(tb * 100 + 0.5));\n  int u, v;\n  for (int i = 1; i < n; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    ++u, ++v;\n    e[u].push_back(v);\n    e[v].push_back(u);\n    ++deg[u], ++deg[v];\n  }\n  scanf(\"%d\", &q);\n}\nvoid inputq() {\n  double tb;\n  scanf(\"%d %lf\", &qa, &tb);\n  qb = static_cast<int>(floor(tb * 100 + 0.5));\n}\nvoid work() {\n  int sv = 0, se = 0;\n  for (int i = 1; i <= n; ++i) sv += a[i];\n  for (int i = 1; i <= n; ++i)\n    for (auto v : e[i])\n      if (i < v) se += a[i] * a[v];\n  S = static_cast<int>(ceil(sqrt(static_cast<long double>(n))));\n  for (int i = 1; i <= n; ++i) {\n    if (deg[i] >= S) {\n      for (auto v : e[i]) bs[i] += a[v];\n    }\n  }\n  for (int i = 1; i <= n; ++i)\n    for (auto v : e[i])\n      if (deg[v] >= S) be[i].push_back(v);\n  int ns, del, ans;\n  for (int _q = 0; _q < q; ++_q) {\n    inputq();\n    ++qa;\n    qb = 100 - qb;\n    del = qb - a[qa];\n    if (deg[qa] < S) {\n      ns = 0;\n      for (auto v : e[qa]) ns += a[v];\n      sv += del;\n      se += del * ns;\n    } else {\n      sv += del;\n      se += del * bs[qa];\n    }\n    for (auto v : be[qa]) bs[v] += del;\n    a[qa] = qb;\n    ans = sv * 100 - se;\n    printf(\"%d.%04d\\n\", ans / 10000, ans % 10000);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, x, y, q, o[N];\ndouble p[N], c[N], z, fp;\nvector<int> v[N];\nvoid sgd(int dg, int op) {\n  o[dg] = op;\n  for (int i = 0; i < v[dg].size(); ++i) {\n    if (v[dg][i] != op) {\n      sgd(v[dg][i], dg);\n      c[dg] += p[v[dg][i]];\n    }\n  }\n  fp -= p[dg] * c[dg];\n}\nvoid G(int x, double y) {\n  y = 1.0 - y;\n  c[o[x]] += y - p[x];\n  fp += (1.0 - c[x] - p[o[x]]) * (y - p[x]);\n  p[x] = y;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> p[i];\n    p[i] = 1.0 - p[i];\n    fp += p[i];\n  }\n  for (int i = 1; i < n; ++i) {\n    cin >> x >> y;\n    v[x + 1].push_back(y + 1);\n    v[y + 1].push_back(x + 1);\n  }\n  sgd(1, 0);\n  cin >> q;\n  for (int i = 1; i <= q; ++i) {\n    cin >> x >> z;\n    G(x + 1, z);\n    cout << setprecision(5) << fp << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int MAGIC = 320;\ndouble read() {\n  string s;\n  cin >> s;\n  return s[0] - '0' + 0.1 * (s[2] - '0') + 0.01 * (s[3] - '0');\n}\nint n, q;\ndouble p[N], fp[N];\ndouble ans;\nvector<int> g[N], new_g[N];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    p[i] = 1 - read();\n    ans += p[i];\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u].push_back(v), g[v].push_back(u);\n    ans -= p[u] * p[v];\n    fp[u] += p[v];\n    fp[v] += p[u];\n  }\n  for (int u = 0; u < n; ++u)\n    if (g[u].size() >= MAGIC) {\n      for (int v : g[u]) new_g[v].push_back(u);\n    }\n  cin >> q;\n  while (q--) {\n    int u;\n    cin >> u;\n    double np = 1 - read();\n    ans += np - p[u];\n    if (g[u].size() >= MAGIC) {\n      ans -= (np - p[u]) * fp[u];\n    } else {\n      for (int v : g[u]) ans -= (np - p[u]) * p[v];\n    }\n    for (int v : new_g[u]) fp[v] += (np - p[u]);\n    p[u] = np;\n    cout << fixed << setprecision(6) << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble p[100005];\nvector<int> v[100005];\ndouble sum[100005], ans;\nint d[100005], n, q;\nstruct edge {\n  int u, v;\n} e[100005];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf\", p + i);\n    p[i] = 1 - p[i];\n    ans += p[i];\n  }\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d\", &e[i].u, &e[i].v);\n    d[e[i].u]++;\n    d[e[i].v]++;\n  }\n  for (int i = 1; i < n; i++) {\n    if (d[e[i].u] < d[e[i].v]) {\n      v[e[i].u].push_back(e[i].v);\n      sum[e[i].v] += p[e[i].u];\n    } else {\n      v[e[i].v].push_back(e[i].u);\n      sum[e[i].u] += p[e[i].v];\n    }\n  }\n  for (int i = 1; i < n; i++) ans -= p[e[i].u] * p[e[i].v];\n  scanf(\"%d\", &q);\n  vector<int>::iterator it;\n  for (int i = 1, u; i <= q; i++) {\n    double w = 0;\n    scanf(\"%d\", &u);\n    w = sum[u];\n    for (it = v[u].begin(); it != v[u].end(); ++it) {\n      w += p[*it], sum[*it] -= p[u];\n    }\n    ans += p[u] * w;\n    ans -= p[u];\n    scanf(\"%lf\", &p[u]);\n    p[u] = 1 - p[u];\n    ans -= p[u] * w;\n    ans += p[u];\n    for (it = v[u].begin(); it != v[u].end(); ++it) sum[*it] += p[u];\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 100100;\nstruct T {\n  int to, nxt;\n} way[maxn << 1];\nint h[maxn], num;\ninline void adde(int x, int y) {\n  way[++num] = {y, h[x]}, h[x] = num;\n  way[++num] = {x, h[y]}, h[y] = num;\n}\nint fa[maxn], vis[maxn];\ndouble sum[maxn], v[maxn];\ninline void dfs(int a) {\n  vis[a] = 1;\n  for (int i = h[a]; i; i = way[i].nxt)\n    if (!vis[way[i].to]) {\n      dfs(way[i].to);\n      fa[way[i].to] = a;\n      sum[a] += v[way[i].to];\n    }\n}\ndouble ans = 0, Sm = 0;\nint main() {\n  int n, q;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%lf\", v + i), Sm += v[i] = 1 - v[i];\n  for (int i = 1, x, y; i < n; ++i)\n    scanf(\"%d%d\", &x, &y), adde(x + 1, y + 1), ans += v[x + 1] * v[y + 1];\n  dfs(1);\n  scanf(\"%d\", &q);\n  while (q--) {\n    int x;\n    double p;\n    scanf(\"%d%lf\", &x, &p), p = 1 - p, ++x;\n    Sm -= v[x], Sm += p;\n    ans -= (v[fa[x]] + sum[x]) * v[x];\n    if (x != 1) sum[fa[x]] -= v[x], sum[fa[x]] += p;\n    v[x] = p;\n    ans += (v[fa[x]] + sum[x]) * v[x];\n    printf(\"%.6lf\\n\", Sm - ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma warning(disable : 4996)\nconst int N = 1e5 + 5, P = 500;\ndouble p[N], sum[N];\nvector<int> g[N], w[N];\nbool vip[N];\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  double ans = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    p[i] = 1 - p[i];\n    ans += p[i];\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n    ans -= p[a] * p[b];\n  }\n  for (int i = 0; i < n; i++) {\n    if (g[i].size() > P) {\n      vip[i] = 1;\n      for (int to : g[i]) w[to].push_back(i);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int to : g[i]) {\n      if (!vip[to]) sum[i] += p[to];\n    }\n  }\n  int q;\n  cin >> q;\n  cout << fixed << setprecision(10);\n  while (q--) {\n    int x;\n    double y;\n    cin >> x >> y;\n    y = 1 - y;\n    ans += y - p[x];\n    double s = sum[x];\n    for (int to : w[x]) {\n      s += p[to];\n    }\n    if (!vip[x]) {\n      for (int to : g[x]) {\n        sum[to] += y - p[x];\n      }\n    }\n    ans = ans - s * y + p[x] * s;\n    p[x] = y;\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ninline int in() {\n  int k = 0;\n  char ch = getchar();\n  while (ch < '-') ch = getchar();\n  while (ch > '-') k = k * 10 + ch - '0', ch = getchar();\n  return k;\n}\nconst int N = 1e5 + 5;\nint head[N], to[N << 1], nxt[N << 1], cnt;\ndouble sum = 0;\ndouble p[N];\ninline void add(int u, int v) {\n  to[++cnt] = v, nxt[cnt] = head[u], head[u] = cnt;\n  to[++cnt] = u, nxt[cnt] = head[v], head[v] = cnt;\n  sum -= (1 - p[u]) * (1 - p[v]);\n}\nint main() {\n  int n = in();\n  for (int i = 1; i <= n; ++i) scanf(\"%lf\", p + i);\n  for (int i = 1; i < n; ++i) add(in() + 1, in() + 1);\n  for (int i = 1; i <= n; ++i) sum += (1.0 - p[i]);\n  int Q = in();\n  while (Q--) {\n    int u = in() + 1;\n    double P;\n    scanf(\"%lf\", &P);\n    for (int i = head[u]; i; i = nxt[i]) sum += (1.0 - p[u]) * (1.0 - p[to[i]]);\n    sum -= (1.0 - p[u]);\n    p[u] = P;\n    sum += (1.0 - p[u]);\n    for (int i = head[u]; i; i = nxt[i]) sum -= (1.0 - p[u]) * (1.0 - p[to[i]]);\n    printf(\"%.5lf\\n\", sum);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nvoid qread(int &x) {\n  int neg = 1;\n  x = 0;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') neg = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') x = 10 * x + c - '0', c = getchar();\n  x *= neg;\n}\nconst int maxn = 100005;\nint n, q;\ndouble p[maxn], sum[maxn], tot1, tot2;\nvector<int> edge[maxn];\nint par[maxn];\nvoid dfs(int x, int f) {\n  par[x] = f;\n  for (int(i) = 0; (i) < edge[x].size(); i++) {\n    int y = edge[x][i];\n    if (y == f) continue;\n    dfs(y, x);\n    tot2 += p[x] * p[y];\n    sum[x] += p[y];\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int(i) = 0; (i) < n; i++)\n    scanf(\"%lf\", &p[i]), p[i] = 1.0 - p[i], tot1 += p[i];\n  for (int(i) = 0; (i) < n - 1; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n  dfs(0, -1);\n  scanf(\"%d\", &q);\n  while (q--) {\n    int x;\n    double val;\n    scanf(\"%d%lf\", &x, &val);\n    val = 1.0 - val;\n    tot1 -= p[x];\n    tot1 += val;\n    tot2 -= p[x] * (sum[x] + (par[x] < 0 ? 0 : p[par[x]]));\n    tot2 += val * (sum[x] + (par[x] < 0 ? 0 : p[par[x]]));\n    if (par[x] >= 0) {\n      sum[par[x]] -= p[x];\n      sum[par[x]] += val;\n    }\n    p[x] = val;\n    printf(\"%lf\\n\", tot1 - tot2);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int BLOCK_SIZE = 317;\nusing namespace std;\ndouble S2;\nstruct Tree {\n  int NumOfVertex;\n  vector<double> p;\n  vector<vector<int>> adj;\n  vector<double> SumOfSmallDeg;\n  vector<vector<int>> adjBigDeg;\n  Tree(int n) {\n    NumOfVertex = n;\n    p.assign(n, 0);\n    adj.assign(n, vector<int>());\n    adjBigDeg.assign(n, vector<int>());\n    SumOfSmallDeg.assign(n, 0);\n  }\n  void addP(int u, double value) { p[u] = value; }\n  int deg(int u) { return adj[u].size(); }\n  void addEdge(int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n    S2 += p[u] * p[v];\n  }\n  void Build() {\n    for (int i = 0; i < NumOfVertex; ++i) {\n      for (int j : adj[i]) {\n        if (deg(j) <= BLOCK_SIZE) {\n          SumOfSmallDeg[i] += p[j];\n        } else {\n          adjBigDeg[i].push_back(j);\n        }\n      }\n    }\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  int n, u, v;\n  double pi, Ev = 0;\n  cin >> n;\n  Tree myTree(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> pi;\n    myTree.addP(i, 1 - pi);\n    Ev += (1 - pi);\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    cin >> u >> v;\n    myTree.addEdge(u, v);\n  }\n  myTree.Build();\n  int q, pos;\n  double nval, c;\n  cin >> q;\n  while (q--) {\n    cin >> pos >> nval;\n    nval = 1 - nval;\n    Ev -= myTree.p[pos];\n    Ev += nval;\n    double d = nval - myTree.p[pos];\n    if (myTree.deg(pos) <= BLOCK_SIZE) {\n      for (int i : myTree.adj[pos]) {\n        myTree.SumOfSmallDeg[i] += (nval - myTree.p[pos]);\n      }\n    }\n    c = 0;\n    for (int i : myTree.adjBigDeg[pos]) {\n      c += myTree.p[i];\n    }\n    S2 += d * (c + myTree.SumOfSmallDeg[pos]);\n    cout << Ev - S2 << \"\\n\";\n    myTree.p[pos] = nval;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, q;\nfloat p[100005];\nvector<int> g[100005];\nfloat sumc[100005], cont[100005];\nint par[100005];\nvoid dfs(int st, int pr) {\n  par[st] = pr;\n  for (int v : g[st])\n    if (v != pr) {\n      dfs(v, st);\n      sumc[st] += (1.0 - p[v]);\n    }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << setiosflags(ios::fixed | ios::showpoint) << setprecision(20);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) cin >> p[i];\n  for (int i = 1; i <= n - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    u++;\n    v++;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs(1, 1);\n  float ans = 1.0 - p[1];\n  for (int st = 1; st <= n; ++st) {\n    ans += p[st] * sumc[st];\n    cont[st] = p[st] * sumc[st];\n  }\n  cin >> q;\n  while (q--) {\n    int u;\n    float pp;\n    cin >> u >> pp;\n    u++;\n    float temp = p[u];\n    p[u] = pp;\n    int st = u;\n    ans -= cont[st];\n    cont[st] = sumc[st] * p[st];\n    ans += cont[st];\n    if (st == 1) {\n      ans -= (1.0 - temp);\n      ans += (1.0 - p[1]);\n    } else {\n      int pr = par[st];\n      ans -= cont[pr];\n      sumc[pr] -= (1.0 - temp);\n      sumc[pr] += (1.0 - p[st]);\n      cont[pr] = sumc[pr] * p[pr];\n      ans += cont[pr];\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9;\nconst long long Inf = 1e18;\nconst int N = 1e5 + 10;\nconst int mod = 0;\nint gi() {\n  int x = 0, o = 1;\n  char ch = getchar();\n  while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();\n  if (ch == '-') o = -1, ch = getchar();\n  while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n  return x * o;\n}\ntemplate <typename T>\nbool chkmax(T &a, T b) {\n  return a < b ? a = b, 1 : 0;\n};\ntemplate <typename T>\nbool chkmin(T &a, T b) {\n  return a > b ? a = b, 1 : 0;\n};\nint add(int a, int b) { return a + b >= mod ? a + b - mod : a + b; }\nint sub(int a, int b) { return a - b < 0 ? a - b + mod : a - b; }\nvoid inc(int &a, int b) { a = (a + b >= mod ? a + b - mod : a + b); }\nvoid dec(int &a, int b) { a = (a - b < 0 ? a - b + mod : a - b); }\nint n, q, du[N], fa[N];\ndouble V, E, a[N], tag[N], sum[N];\nvector<int> G[N];\nvoid dfs(int u, int ff) {\n  fa[u] = ff;\n  for (int v : G[u])\n    if (v != ff) dfs(v, u);\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &a[i]), a[i] = 1 - a[i];\n  for (int i = 1, u, v; i < n; i++)\n    u = gi() + 1, v = gi() + 1, G[u].push_back(v), G[v].push_back(u);\n  dfs(1, 0);\n  for (int i = 1; i <= n; i++) V += a[i];\n  for (int u = 1; u <= n; u++) {\n    for (int v : G[u]) sum[u] += a[v];\n    E += a[u] * sum[u];\n  }\n  cin >> q;\n  while (q--) {\n    int x = gi() + 1;\n    double y;\n    scanf(\"%lf\", &y);\n    y = 1 - y;\n    V += y - a[x];\n    E -= 2 * (sum[x] + tag[fa[x]]) * a[x];\n    tag[x] += y - a[x];\n    if (fa[x]) sum[fa[x]] += y - a[x];\n    a[x] = y;\n    E += 2 * (sum[x] + tag[fa[x]]) * a[x];\n    printf(\"%.5lf\\n\", V - E / 2);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nstruct edge {\n  int link, next;\n} e[N << 1];\nint tot, head[N], n, fa[N];\ndouble ans, sum[N], p[N];\ninline void add_edge(int u, int v) {\n  e[++tot] = (edge){v, head[u]};\n  head[u] = tot;\n}\ninline void insert(int u, int v) {\n  add_edge(u, v);\n  add_edge(v, u);\n}\ninline void init() {\n  scanf(\"%d\", &n);\n  p[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lf\", &p[i]);\n  }\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u++;\n    v++;\n    insert(u, v);\n  }\n}\nvoid dfs(int u, int Fa) {\n  ans += p[Fa] * (1 - p[u]);\n  for (int i = head[u]; i; i = e[i].next) {\n    int v = e[i].link;\n    if (v != Fa) {\n      dfs(v, u);\n      fa[v] = u;\n      sum[u] += (1 - p[v]);\n    }\n  }\n}\nint q;\ninline void solve() {\n  dfs(1, 0);\n  scanf(\"%d\", &q);\n  for (int i = 1; i <= q; i++) {\n    double y;\n    int x;\n    scanf(\"%d%lf\", &x, &y);\n    x++;\n    ans -= sum[x] * p[x] + (1 - p[x]) * p[fa[x]];\n    sum[fa[x]] -= 1 - p[x];\n    p[x] = y;\n    ans += sum[x] * p[x] + (1 - p[x]) * p[fa[x]];\n    sum[fa[x]] += 1 - p[x];\n    printf(\"%.5lf\\n\", ans);\n  }\n}\nint main() {\n  init();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  char c = getchar();\n  int d = 0, f = 1;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') f = -1;\n  for (; c >= '0' && c <= '9'; d = d * 10 + c - 48, c = getchar())\n    ;\n  return d * f;\n}\nchar Read() {\n  char c = getchar();\n  while (c < '0' || c > '9') c = getchar();\n  return c;\n}\nconst int N = 200001;\nint n, q;\nint cnt, head[N];\nstruct edge {\n  int to, next;\n} e[N * 2];\nvoid addedge(int x, int y) {\n  e[++cnt] = (edge){y, head[x]};\n  head[x] = cnt;\n}\nvoid Addedge(int x, int y) {\n  addedge(x, y);\n  addedge(y, x);\n}\nint p[N], pp[N];\nint fa[N];\nvoid dfs(int f, int x) {\n  for (int i = head[x], y = e[i].to; y; i = e[i].next, y = e[i].to)\n    if (y != f) fa[y] = x, dfs(x, y);\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; ++i) p[i] = read() * 100, p[i] += read();\n  for (int i = 2; i <= n; ++i) Addedge(read() + 1, read() + 1);\n  dfs(0, 1);\n  p[0] = 100;\n  fa[1] = 0;\n  long long ans = 0;\n  for (int i = 1; i <= n; ++i) ans += p[fa[i]] * (100 - p[i]);\n  for (int i = 1; i <= n; ++i) pp[fa[i]] += 100 - p[i];\n  q = read();\n  for (int i = 1; i <= q; ++i) {\n    int x = read() + 1;\n    int P = read() * 100;\n    P += read();\n    ans += p[fa[x]] * ((1 - P) - (1 - p[x])) + (P - p[x]) * pp[x];\n    pp[fa[x]] += (100 - P) - (100 - p[x]);\n    p[x] = P;\n    printf(\"%.4lf\\n\", 1.0 * ans / 10000);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "//package bubble11;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class D {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tdouble[] ps = new double[n];\n\t\tdouble psum = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tps[i] = 1-nd();\n\t\t\tpsum += ps[i];\n\t\t}\n\t\t\n\t\tint[] from = new int[n - 1];\n\t\tint[] to = new int[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfrom[i] = ni();\n\t\t\tto[i] = ni();\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\tint[][] pars = parents3(g, 0);\n\t\tint[] par = pars[0], ord = pars[1], dep = pars[2];\n\t\t\n\t\tint B = (int)Math.sqrt(n);\n\t\tint[] map = new int[n];\n\t\tint[] imap = new int[n];\n\t\tArrays.fill(imap, -1);\n\t\t\n\t\tint p = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(g[i].length >= B){\n\t\t\t\tmap[p] = i;\n\t\t\t\timap[i] = p;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tboolean[][] bg = new boolean[p][p];\n\t\t\n\t\tdouble[] osum = new double[p];\n\t\tfor(int i = 0;i < p;i++){\n\t\t\tfor(int e : g[map[i]]){\n\t\t\t\tosum[i] += ps[e];\n\t\t\t\tif(imap[e] != -1){\n\t\t\t\t\tbg[i][imap[e]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble ans = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int e : g[i]){\n\t\t\t\tif(i < e){\n\t\t\t\t\tans += 1-ps[i]*ps[e];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int z = ni();z > 0;z--){\n\t\t\tint ind = ni();\n\t\t\tdouble P = 1-nd();\n\t\t\tpsum += P - ps[ind];\n\t\t\t\n\t\t\tif(imap[ind] == -1){\n\t\t\t\tfor(int e : g[ind]){\n\t\t\t\t\tans -= 1-ps[ind]*ps[e];\n\t\t\t\t\tans += 1-P*ps[e];\n\t\t\t\t\tif(imap[e] != -1){\n\t\t\t\t\t\tosum[imap[e]] -= ps[ind];\n\t\t\t\t\t\tosum[imap[e]] += P;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tans -= 1-osum[imap[ind]]*ps[ind];\n\t\t\t\tans += 1-osum[imap[ind]]*P;\n\t\t\t\tfor(int j = 0;j < p;j++){\n\t\t\t\t\tif(bg[imap[ind]][j]){\n\t\t\t\t\t\tosum[j] -= ps[ind];\n\t\t\t\t\t\tosum[j] += P;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tps[ind] = P;\n\t\t\tout.printf(\"%.14f\\n\", ans + 1 - (n-psum));\n\t\t}\n\t}\n\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new D().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 101010;\nint fa[N], n, Q;\ndouble f[N], prob[N];\nvector<int> g[N];\nvoid Dfs(int x) {\n  for (int v : g[x]) {\n    if (v == fa[x]) continue;\n    fa[v] = x;\n    f[x] += prob[v];\n    Dfs(v);\n  }\n}\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lf\", &prob[i]);\n    prob[i] = 1 - prob[i];\n  }\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u++;\n    v++;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  Dfs(1);\n  double Ans = 0;\n  for (int i = 1; i <= n; i++) {\n    Ans += prob[i] * (1 - f[i]);\n  }\n  scanf(\"%d\", &Q);\n  while (Q--) {\n    int x;\n    double p;\n    scanf(\"%d%lf\", &x, &p);\n    x++;\n    double delta = (1 - p - prob[x]);\n    prob[x] = 1 - p;\n    Ans += delta * (1 - f[x]);\n    if (fa[x]) {\n      f[fa[x]] += delta;\n      Ans -= delta * prob[fa[x]];\n    }\n    printf(\"%.10f\\n\", Ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, q;\nint fa[100005];\ndouble a[100005], sum[100005], ans;\nvector<int> g[100005];\nvoid dfs(int now, int f) {\n  fa[now] = f;\n  for (int i = 0; i < g[now].size(); i++) {\n    int v = g[now][i];\n    if (v == f) continue;\n    dfs(v, now);\n    sum[now] += (1 - a[v]);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &a[i]);\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    x++, y++;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  a[0] = 1;\n  sum[0] = 1 - a[1];\n  dfs(1, 0);\n  for (int i = 0; i <= n; i++) ans += a[i] * sum[i];\n  scanf(\"%d\", &q);\n  while (q--) {\n    int x;\n    double y;\n    scanf(\"%d%lf\", &x, &y);\n    x++;\n    ans = ans - sum[x] * a[x] + sum[x] * y;\n    ans = ans - a[fa[x]] * (1 - a[x]) + a[fa[x]] * (1 - y);\n    sum[fa[x]] = sum[fa[x]] - (1 - a[x]) + (1 - y);\n    a[x] = y;\n    printf(\"%lf\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, fu = 0;\n  char ch = getchar();\n  for (; ch < 48 || ch > 57; ch = getchar()) fu |= (ch == '-');\n  for (; ch > 47 && ch < 58; ch = getchar()) x = x * 10 + ch - '0';\n  return fu ? -x : x;\n}\nint n, head[100005], eot, fa[100005];\nstruct edge {\n  int t, nxt;\n} e[200005];\nvoid add(int u, int v) {\n  e[++eot] = (edge){v, head[u]};\n  head[u] = eot;\n  e[++eot] = (edge){u, head[v]};\n  head[v] = eot;\n}\ndouble p[100005], sump[100005], ans, P;\nvoid dfs(int x) {\n  ans += p[fa[x]] * (1.00 - p[x]);\n  for (int i = head[x]; i; i = e[i].nxt) {\n    if (e[i].t == fa[x]) continue;\n    fa[e[i].t] = x, dfs(e[i].t), sump[x] += 1.00 - p[e[i].t];\n  }\n}\nint main() {\n  n = read(), p[0] = 1.00;\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1, u, v; i < n; i++) u = read() + 1, v = read() + 1, add(u, v);\n  dfs(1);\n  for (int Q = read(), x; Q--; printf(\"%.5lf\\n\", ans)) {\n    x = read() + 1, scanf(\"%lf\", &P);\n    ans -= p[x] * sump[x] + (1.00 - p[x]) * p[fa[x]],\n        sump[fa[x]] -= 1.00 - p[x];\n    p[x] = P;\n    ans += p[x] * sump[x] + (1.00 - p[x]) * p[fa[x]],\n        sump[fa[x]] += 1.00 - p[x];\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\ndouble a[N], f[N], ans;\nvector<int> G[N];\nint fa[N];\nvoid dfs(int F, int u) {\n  fa[u] = F;\n  for (int v : G[u]) {\n    if (v != F) {\n      f[u] += a[v];\n      dfs(u, v);\n    }\n  }\n  ans -= f[u] * a[u];\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, q;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i] = 1 - a[i];\n    ans += a[i];\n  }\n  for (int i = 1, u, v; i < n; i++) {\n    cin >> u >> v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs(n, 0);\n  cin >> q;\n  while (q--) {\n    int u;\n    double x;\n    cin >> u >> x;\n    x = 1 - x;\n    ans = ans - a[u] + x;\n    ans = ans + f[u] * (a[u] - x);\n    if (u) {\n      ans = ans + f[fa[u]] * a[fa[u]];\n      f[fa[u]] = f[fa[u]] - a[u] + x;\n      ans = ans - f[fa[u]] * a[fa[u]];\n    }\n    a[u] = x;\n    printf(\"%.10f\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\ndouble p[maxn], s[maxn], ans;\nvector<int> V[maxn];\nint fa[maxn];\nvoid dfs(int u) {\n  ans += p[fa[u]] * (1.0 - p[u]);\n  for (int i = 0; i < V[u].size(); i++) {\n    if (V[u][i] == fa[u]) continue;\n    fa[V[u][i]] = u;\n    dfs(V[u][i]);\n    s[u] += 1.0 - p[V[u][i]];\n  }\n}\nint main() {\n  int n, u, v;\n  cin >> n;\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d\", &u, &v);\n    u++, v++;\n    V[u].push_back(v);\n    V[v].push_back(u);\n  }\n  fa[1] = 0;\n  p[0] = 1.0;\n  dfs(1);\n  int Q, x;\n  double y;\n  cin >> Q;\n  while (Q--) {\n    scanf(\"%d%lf\", &x, &y);\n    x++;\n    ans -= p[fa[x]] * (1.0 - p[x]);\n    ans -= p[x] * s[x];\n    s[fa[x]] -= (1.0 - p[x]);\n    p[x] = y;\n    ans += p[fa[x]] * (1.0 - p[x]);\n    ans += p[x] * s[x];\n    s[fa[x]] += (1.0 - p[x]);\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::abs;\nusing std::array;\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::generate;\nusing std::get;\nusing std::make_pair;\nusing std::make_tuple;\nusing std::map;\nusing std::max;\nusing std::max_element;\nusing std::min;\nusing std::min_element;\nusing std::pair;\nusing std::queue;\nusing std::reverse;\nusing std::set;\nusing std::sort;\nusing std::string;\nusing std::swap;\nusing std::tuple;\nusing std::unique;\nusing std::vector;\ntemplate <typename T>\nT input() {\n  T res;\n  cin >> res;\n  {};\n  return res;\n}\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n  std::generate(b, e,\n                input<typename std::remove_reference<decltype(*b)>::type>);\n}\nint main() {\n  std::iostream::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int n = input<int>();\n  vector<double> pr(n);\n  for (int i = 0; i < n; ++i) cin >> pr[i];\n  vector<vector<int>> graph(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int v, u;\n    cin >> v >> u;\n    graph[v].push_back(u);\n    graph[u].push_back(v);\n  }\n  vector<int> HEAVY;\n  vector<char> is_heavy(n, false);\n  for (int i = 0; i < n; ++i)\n    if (int((graph[i]).size()) >= 500) {\n      HEAVY.push_back(i);\n      is_heavy[i] = true;\n    }\n  vector<vector<int>> subgr(n);\n  for (int v = 0; v < n; ++v)\n    for (int u : graph[v])\n      if (is_heavy[u]) subgr[v].push_back(u);\n  double ans = 0;\n  for (int i = 0; i < n; ++i) ans += (1.0 - pr[i]);\n  for (int v = 0; v < n; ++v)\n    for (int u : graph[v])\n      if (v < u) ans -= (1 - pr[v]) * (1 - pr[u]);\n  vector<double> sums_for_disabled(n);\n  for (int i = 0; i < n; ++i)\n    if (is_heavy[i]) {\n      for (int u : graph[i]) sums_for_disabled[i] += (1 - pr[u]);\n    }\n  auto account = [&](int v, int w) {\n    ans += w * (1.0 - pr[v]);\n    if (is_heavy[v]) {\n      ans -= w * (1 - pr[v]) * sums_for_disabled[v];\n    } else {\n      for (int u : graph[v]) ans -= w * (1 - pr[v]) * (1 - pr[u]);\n    }\n    for (int u : subgr[v]) sums_for_disabled[u] += w * (1 - pr[v]);\n  };\n  for (int Q = input<int>(); Q != 0; --Q) {\n    int x = input<int>();\n    account(x, -1);\n    pr[x] = input<double>();\n    account(x, +1);\n    cout << std::fixed;\n    cout.precision(6);\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DInterstellarBattle solver = new DInterstellarBattle();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DInterstellarBattle {\n        double[] pfall;\n        double[] palive;\n        double[] contributionofparent;\n        int[] par;\n        ArrayList<Integer>[] arrayList;\n\n        void DFS(int s, int p) {\n            par[s] = p;\n            double temp = 0;\n            for (int tt : arrayList[s]) {\n                if (p != tt) {\n                    DFS(tt, s);\n                    temp += palive[tt];\n                }\n            }\n            contributionofparent[s] = temp;\n        }\n\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            int n = in.scanInt();\n            arrayList = new ArrayList[n + 1];\n            par = new int[n + 1];\n            pfall = new double[n + 1];\n            palive = new double[n + 1];\n            contributionofparent = new double[n + 1];\n            for (int i = 0; i <= n; i++) {\n                arrayList[i] = new ArrayList<>();\n            }\n\n            for (int i = 1; i <= n; i++) {\n                pfall[i] = in.scanDouble();\n                palive[i] = 1 - pfall[i];\n            }\n\n            for (int i = 0; i < n - 1; i++) {\n                int x = in.scanInt() + 1;\n                int y = in.scanInt() + 1;\n                arrayList[x].add(y);\n                arrayList[y].add(x);\n            }\n            Arrays.fill(par, -1);\n            DFS(1, 0);\n            palive[0] = 1;\n            pfall[0] = 0;\n            contributionofparent[0] = palive[1];\n            int q = in.scanInt();\n\n\n            double ans = 0;\n            for (int i = 1; i <= n; i++) {\n                ans += pfall[i] * contributionofparent[i];\n            }\n            ans += palive[1];\n\n            while (q-- > 0) {\n                int p = in.scanInt() + 1;\n                if (p != 1) {\n                    ans -= contributionofparent[par[p]] * pfall[par[p]];\n                    ans -= pfall[p] * contributionofparent[p];\n                    contributionofparent[par[p]] -= palive[p];\n                    pfall[p] = in.scanDouble();\n                    palive[p] = 1 - pfall[p];\n                    contributionofparent[par[p]] += palive[p];\n                    ans += contributionofparent[par[p]] * pfall[par[p]];\n                    ans += pfall[p] * contributionofparent[p];\n                    out.printf(\"%.5f\\n\", ans);\n                } else {\n                    ans -= pfall[1] * contributionofparent[1];\n                    ans -= palive[1];\n                    pfall[p] = in.scanDouble();\n                    palive[p] = 1 - pfall[p];\n                    ans += pfall[1] * contributionofparent[1];\n                    ans += palive[1];\n                    out.printf(\"%.5f\\n\", ans);\n\n                }\n\n\n            }\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int INDEX;\n        private BufferedInputStream in;\n        private int TOTAL;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (INDEX >= TOTAL) {\n                INDEX = 0;\n                try {\n                    TOTAL = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (TOTAL <= 0) return -1;\n            }\n            return buf[INDEX++];\n        }\n\n        public int scanInt() {\n            int I = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    I *= 10;\n                    I += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * I;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n        public double scanDouble() {\n            int c = scan();\n            while (isWhiteSpace(c)) c = scan();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = scan();\n            }\n            double RESULT = 0;\n            while (!isWhiteSpace(c) && c != '.') {\n                if (c == 'e' || c == 'E') {\n                    return RESULT * Math.pow(10, scanInt());\n                }\n                RESULT *= 10;\n                RESULT += c - '0';\n                c = scan();\n            }\n            if (c == '.') {\n                c = scan();\n                double m = 1;\n                while (!isWhiteSpace(c)) {\n                    if (c == 'e' || c == 'E') {\n                        return RESULT * Math.pow(10, scanInt());\n                    }\n                    m /= 10;\n                    RESULT += (c - '0') * m;\n                    c = scan();\n                }\n            }\n            return RESULT * sgn;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1);\ntemplate <class T>\nT sqr(T x) {\n  return x * x;\n}\ntemplate <class T>\nT alex(T x) {\n  return (x > 0) ? x : -x;\n}\ntemplate <class T>\nvoid read(T& x) {\n  x = 0;\n  T f = 1;\n  char ch = getchar();\n  while ((ch < 48 || ch > 57) && ch != 45) ch = getchar();\n  if (ch == 45) f = -1, ch = getchar();\n  while (ch >= 48 && ch <= 57) x = x * 10 + ch - 48, ch = getchar();\n  x *= f;\n}\nint n;\ndouble a[100005];\nvector<int> E[100005];\nint x[100005], y[100005];\ndouble solve() {\n  double res = 0.0;\n  for (int i = (0); i < (n); i++) res += a[i];\n  for (int i = (1); i < (n); i++) res -= a[x[i]] * a[y[i]];\n  return res;\n}\nstruct Tree {\n  int l, r;\n  double v;\n} T[100005 << 2];\nvoid build(int rot, int l, int r) {\n  T[rot].l = l;\n  T[rot].r = r;\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  build(rot << 1, l, mid);\n  build(rot << 1 | 1, mid + 1, r);\n}\nvoid update(int rot) { T[rot].v = T[rot << 1].v + T[rot << 1 | 1].v; }\nvoid change(int rot, int pos, double v) {\n  if (T[rot].l == T[rot].r) {\n    T[rot].v = v;\n    return;\n  }\n  int mid = (T[rot].l + T[rot].r) >> 1;\n  if (pos <= mid)\n    change(rot << 1, pos, v);\n  else\n    change(rot << 1 | 1, pos, v);\n  update(rot);\n}\ndouble query(int rot, int l, int r) {\n  if (l > r) return 0;\n  if (T[rot].l == l && T[rot].r == r) return T[rot].v;\n  int mid = (T[rot].l + T[rot].r) >> 1;\n  if (r <= mid)\n    return query(rot << 1, l, r);\n  else if (l > mid)\n    return query(rot << 1 | 1, l, r);\n  else\n    return query(rot << 1, l, mid) + query(rot << 1 | 1, mid + 1, r);\n}\nint que[100005], f[100005];\nbool vis[100005];\nint l[100005], r[100005];\nint ind[100005];\nvoid bfs() {\n  que[1] = 0;\n  vis[0] = true;\n  ind[0] = 1;\n  int head = 0, tail = 1;\n  while (head != tail) {\n    head++;\n    int x = que[head];\n    l[x] = tail + 1;\n    for (int i = (0); i < (E[x].size()); i++)\n      if (!vis[E[x][i]]) {\n        f[E[x][i]] = x;\n        que[++tail] = E[x][i];\n        vis[E[x][i]] = true;\n        ind[E[x][i]] = tail;\n      }\n    r[x] = tail;\n  }\n}\ndouble get(int x) {\n  if (x == 0)\n    return query(1, l[x], r[x]);\n  else\n    return query(1, l[x], r[x]) + a[f[x]];\n}\nint main() {\n  read(n);\n  for (int i = (0); i < (n); i++) scanf(\"%lf\", &a[i]), a[i] = 1.0 - a[i];\n  for (int i = (1); i < (n); i++) {\n    read(x[i]), read(y[i]);\n    E[x[i]].push_back(y[i]);\n    E[y[i]].push_back(x[i]);\n  }\n  int q;\n  read(q);\n  double res = solve();\n  build(1, 1, n);\n  bfs();\n  for (int i = (0); i < (n); i++) change(1, ind[i], a[i]);\n  for (int i = (1); i <= (q); i++) {\n    int x;\n    double p;\n    read(x);\n    scanf(\"%lf\", &p);\n    res -= a[x];\n    res += a[x] * get(x);\n    a[x] = 1.0 - p;\n    res += a[x];\n    res -= a[x] * get(x);\n    change(1, ind[x], a[x]);\n    printf(\"%lf\\n\", res);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edges {\n  int to, next;\n} edge[202020];\nint first[101010], now;\nvoid adde(int x, int y) {\n  now++;\n  edge[now].to = y;\n  edge[now].next = first[x];\n  first[x] = now;\n}\ndouble v[101010], sum[101010];\nint fa[101010];\nvoid work(int p) {\n  for (int e = first[p]; e; e = edge[e].next)\n    if (edge[e].to != fa[p]) {\n      fa[edge[e].to] = p;\n      work(edge[e].to);\n    }\n}\nint main() {\n  int n, x, y, q;\n  double nv, ans = 0.0;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%lf\", &v[i]);\n  memset(first, 0, sizeof(first));\n  now = 0;\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d\", &x, &y);\n    adde(x, y);\n    adde(y, x);\n  }\n  v[n] = 1.0;\n  fa[0] = n;\n  work(0);\n  for (int i = 0; i < n; i++) {\n    ans += (1.0 - v[i]) * v[fa[i]];\n    sum[fa[i]] += 1.0 - v[i];\n  }\n  scanf(\"%d\", &q);\n  for (int i = 1; i <= q; i++) {\n    scanf(\"%d%lf\", &x, &nv);\n    ans += sum[x] * (nv - v[x]);\n    ans -= (nv - v[x]) * v[fa[x]];\n    sum[fa[x]] -= nv - v[x];\n    v[x] = nv;\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nconst int maxe = 2e5 + 5;\nint nxt[maxe];\nint head[maxn];\nint to[maxe];\nint cnt = 0;\ndouble sum[maxn];\ndouble p[maxn];\nint fa[maxn];\nvoid add(int u, int v) {\n  cnt++;\n  nxt[cnt] = head[u];\n  head[u] = cnt;\n  to[cnt] = v;\n}\ndouble ans = 0.0;\nvoid dfs(int u, int ba) {\n  ans += (1 - p[u]) * p[ba];\n  fa[u] = ba;\n  for (int i = head[u]; i != -1; i = nxt[i]) {\n    int v = to[i];\n    if (v != ba) {\n      dfs(v, u);\n      sum[u] += (1 - p[v]);\n    }\n  }\n}\nint main() {\n  memset(head, -1, sizeof(head));\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  p[0] = 1;\n  int u, v;\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d %d\", &u, &v);\n    add(u + 1, v + 1);\n    add(v + 1, u + 1);\n  }\n  dfs(1, 0);\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int u;\n    double b;\n    scanf(\"%d %lf\", &u, &b);\n    u++;\n    ans -= sum[u] * p[u] + (1 - p[u]) * p[fa[u]];\n    sum[fa[u]] -= 1 - p[u];\n    p[u] = b;\n    ans += sum[u] * p[u] + (1 - p[u]) * p[fa[u]];\n    sum[fa[u]] += 1 - p[u];\n    printf(\"%.5lf\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long int;\nusing ii = pair<int, int>;\nusing ii64 = pair<i64, i64>;\ndouble p[100005];\nint parent[100005];\nvector<int> adj[100005];\ndouble psum[100005];\nvoid dfs(int root) {\n  for (auto& e : adj[root]) {\n    if (e == parent[root]) continue;\n    parent[e] = root;\n    psum[root] += p[e];\n    dfs(e);\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf\", &p[i]);\n    p[i] = 1 - p[i];\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  dfs(0);\n  parent[0] = -1;\n  double ans = 0;\n  for (int i = 0; i < n; i++) ans += p[i] * (1 - psum[i]);\n  int q;\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    int v;\n    double np;\n    scanf(\"%d %lf\", &v, &np);\n    np = 1 - np;\n    ans -= p[v] * (1 - psum[v]);\n    if (v != 0) {\n      ans += p[parent[v]] * psum[parent[v]];\n      psum[parent[v]] -= p[v];\n    }\n    p[v] = np;\n    if (v != 0) {\n      psum[parent[v]] += p[v];\n      ans -= p[parent[v]] * psum[parent[v]];\n    }\n    ans += p[v] * (1 - psum[v]);\n    printf(\"%lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nvoid printvec(vector<T>& vec) {\n  for (int i = 0; i < vec.size(); i++) {\n    cout << vec[i] << \" \";\n  }\n  cout << endl;\n}\ndouble neigh[123456];\nvector<vector<int> > adj(123456);\nvector<vector<int> > big(123456);\ndouble pr[123456];\nint deg[123456];\nint rootn = 300;\nint main() {\n  int n, i, j, k;\n  scanf(\"%d\", &n);\n  double sum = 1;\n  for (i = 0; i < n; i++) {\n    scanf(\"%lf\", pr + i);\n    sum -= pr[i];\n  }\n  for (i = 0; i < n - 1; i++) {\n    int u, v;\n    scanf(\"%d\", &u);\n    scanf(\"%d\", &v);\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n    deg[u]++;\n    deg[v]++;\n  }\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < adj[i].size(); j++) {\n      if (deg[adj[i][j]] > rootn)\n        big[i].push_back(adj[i][j]);\n      else\n        neigh[i] += pr[adj[i][j]];\n    }\n  }\n  double ans = 0;\n  for (i = 0; i < n; i++) {\n    double temp = neigh[i];\n    for (j = 0; j < big[i].size(); j++) {\n      temp += pr[big[i][j]];\n    }\n    temp = temp / 2;\n    temp = deg[i] - temp;\n    temp = temp * pr[i];\n    ans += temp;\n  }\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int v;\n    double newprob;\n    scanf(\"%d\", &v);\n    scanf(\"%lf\", &newprob);\n    if (deg[v] <= rootn) {\n      for (i = 0; i < adj[v].size(); i++) {\n        neigh[adj[v][i]] += (newprob - pr[v]);\n      }\n    }\n    double temp = neigh[v];\n    for (j = 0; j < big[v].size(); j++) {\n      temp += pr[big[v][j]];\n    }\n    temp = temp;\n    temp = deg[v] - temp;\n    temp = temp * (newprob - pr[v]);\n    ans += temp;\n    sum += pr[v] - newprob;\n    pr[v] = newprob;\n    printf(\"%0.16lf\\n\", ans + sum);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 500001;\nint n;\nint father[N];\ndouble p[N];\ndouble sum_child[N];\nstruct edge {\n  int to, nxt;\n} tree[N << 1];\nint head[N], cnt = 0;\nvoid addedge(int u, int v) {\n  edge node = {v, head[u]};\n  tree[head[u] = ++cnt] = node;\n}\nvoid dfs(int u, int fa) {\n  father[u] = fa;\n  for (int i = head[u]; i; i = tree[i].nxt) {\n    int v = tree[i].to;\n    if (v != fa) dfs(v, u);\n  }\n}\ndouble ans1 = 0.0, ans2 = 0.0;\nvoid change(int u, double prob) {\n  if (u) sum_child[father[u]] += prob - p[u];\n  ans1 += prob - p[u];\n  ans2 += (prob - p[u]) * sum_child[u];\n  if (u) ans2 += (prob - p[u]) * p[father[u]];\n  p[u] = prob;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) head[i] = 0;\n  for (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    addedge(u, v), addedge(v, u);\n  }\n  dfs(0, -1);\n  for (int i = 0; i < n; i++) p[i] = 1.0 - p[i], ans1 += p[i];\n  for (int i = 1; i < n; i++) ans2 += p[i] * p[father[i]];\n  for (int i = 0; i < n; i++) {\n    for (int j = head[i]; j; j = tree[j].nxt) {\n      int k = tree[j].to;\n      if (k != father[i]) sum_child[i] += p[k];\n    }\n  }\n  int q;\n  scanf(\"%d\", &q);\n  for (int i = 1; i <= q; i++) {\n    int u;\n    double p;\n    scanf(\"%d%lf\", &u, &p);\n    change(u, 1.0 - p);\n    printf(\"%lf\\n\", ans1 - ans2);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class InterstellarBattle {\n    static ArrayList<Integer>[] graph;\n    static double[] vals;\n    static int[] par;\n    static double[] tots;\n    static double sumEdges = 0;\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int N = scanner.nextInt();\n        vals = new double[N+1];\n        graph = new ArrayList[N];\n        for(int i = 0; i < N; i++) graph[i] = new ArrayList<>();\n        double sum = 0;\n        for(int i = 0; i < N; i++) {\n            vals[i] = 1.0-scanner.nextDouble();\n            sum += vals[i];\n        }\n        int[][] edges = new int[N][2];\n        for(int i = 1; i < N; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            graph[a].add(b);\n            graph[b].add(a);\n            edges[i-1][0] = a;\n            edges[i-1][1] = b;\n        }\n        //edges only computed in the parent, sum kept seperately.\n        tots = new double[N +1];\n        par = new int[N];\n        dfs(0, N);\n        int Q = scanner.nextInt();\n        while(Q-->0) {\n            int ind = scanner.nextInt();\n            double nval = 1.0-scanner.nextDouble();\n            sumEdges -= vals[ind] * tots[ind];\n            sum -= vals[ind];\n            sumEdges -= tots[par[ind]] * vals[par[ind]];\n            tots[par[ind]] -= vals[ind];\n            vals[ind] = nval;\n            sumEdges += vals[ind] * tots[ind];\n            tots[par[ind]] += vals[ind];\n            sumEdges += tots[par[ind]] * vals[par[ind]];\n            sum += vals[ind];\n            out.println(sum - sumEdges);\n//            double nsum = 0;\n//            for(int i = 0; i < N; i++) {\n//                nsum += vals[i];\n//            }\n//            double lnsum = 0;\n//            for(int i = 0; i < N-1; i++) {\n//                lnsum += vals[edges[i][0]] * vals[edges[i][1]];\n//            }\n//            out.println(nsum - lnsum);\n        }\n        out.flush();\n    }\n    \n    static void dfs(int v, int p) {\n        par[v] = p;\n        for(int edge: graph[v]) {\n            if (edge == p) continue;\n            tots[v] += vals[edge];\n            dfs(edge, v);\n        }\n        sumEdges += vals[v] * tots[v];\n    }\n    \n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble dp[1000000], sum[1000000], ans;\nint d[1000000], dis[1000000], vis[1000000], n, q;\nvector<int> v[1000000];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf\", &dp[i]);\n    dp[i] = 1 - dp[i];\n    ans = ans + dp[i];\n  }\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d\", &dis[i], &vis[i]);\n    d[dis[i]]++;\n    d[vis[i]]++;\n  }\n  for (int i = 1; i < n; i++) {\n    if (d[dis[i]] < d[vis[i]]) {\n      v[dis[i]].push_back(vis[i]);\n      sum[vis[i]] = sum[vis[i]] + dp[dis[i]];\n    } else {\n      v[vis[i]].push_back(dis[i]);\n      sum[dis[i]] = sum[dis[i]] + dp[vis[i]];\n    }\n  }\n  for (int i = 1; i < n; i++) {\n    ans = ans - dp[dis[i]] * dp[vis[i]];\n  }\n  scanf(\"%d\", &q);\n  vector<int>::iterator it;\n  for (int i = 1, u; i <= q; i++) {\n    double book = 0;\n    scanf(\"%d\", &u);\n    book = sum[u];\n    for (it = v[u].begin(); it != v[u].end(); ++it) {\n      book = book + dp[*it];\n      sum[*it] = sum[*it] - dp[u];\n    }\n    ans = ans + dp[u] * book;\n    ans = ans - dp[u];\n    scanf(\"%lf\", &dp[u]);\n    dp[u] = 1 - dp[u];\n    ans = ans - dp[u] * book;\n    ans = ans + dp[u];\n    for (it = v[u].begin(); it != v[u].end(); ++it) {\n      sum[*it] = sum[*it] + dp[u];\n    }\n    printf(\"%lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint n, x, y, q, fa[N];\ndouble p[N], sum[N], w, ans;\nvector<int> G[N];\nvoid dfs(int u, int pr) {\n  ans -= p[u];\n  for (auto v : G[u])\n    if (v != pr) {\n      fa[v] = u;\n      dfs(v, u);\n      ans -= (1 - p[u]) * (1 - p[v]);\n      sum[u] += 1 - p[v];\n    }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = (1); i <= (n); i++) scanf(\"%lf\", &p[i]);\n  p[0] = 1;\n  for (int i = (1); i <= (n - 1); i++)\n    scanf(\"%d%d\", &x, &y), x++, y++, G[x].push_back(y), G[y].push_back(x);\n  ans = n;\n  dfs(1, 0);\n  scanf(\"%d\", &q);\n  for (int i = (1); i <= (q); i++) {\n    scanf(\"%d%lf\", &x, &w);\n    x++;\n    ans += p[x] + (1 - p[x]) * sum[x] + (1 - p[fa[x]]) * (1 - p[x]);\n    sum[fa[x]] -= 1 - p[x];\n    p[x] = w;\n    ans -= p[x] + (1 - p[x]) * sum[x] + (1 - p[fa[x]]) * (1 - p[x]);\n    sum[fa[x]] += 1 - p[x];\n    printf(\"%.10lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\nint n, q, fa[N];\ndouble p[N], sum[N], ans;\nvector<int> son[N];\nvoid dfs(int x, int f) {\n  fa[x] = f;\n  for (int i = 0; i < son[x].size(); ++i) {\n    int y = son[x][i];\n    if (y == f) continue;\n    dfs(y, x);\n    sum[x] += 1 - p[y];\n    ans += p[x] * (1 - p[y]);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  p[0] = 1;\n  for (int i = 1; i <= n; ++i) scanf(\"%lf\", p + i);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    ++u, ++v;\n    son[u].push_back(v);\n    son[v].push_back(u);\n  }\n  ans = 1 - p[1];\n  dfs(1, 0);\n  scanf(\"%d\", &q);\n  while (q--) {\n    int k;\n    double p1;\n    scanf(\"%d%lf\", &k, &p1);\n    ++k;\n    sum[fa[k]] -= p1 - p[k];\n    ans += sum[k] * (p1 - p[k]) - (p1 - p[k]) * p[fa[k]];\n    p[k] = p1;\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long int;\nvoid init();\nvoid process();\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  init();\n  process();\n  cout.flush();\n  return 0;\n}\nint n;\nvector<double> p;\nvector<tuple<int, int>> edge;\nvector<int> pa;\nvoid dfs(int u, int p, vector<vector<int>> &tree) {\n  pa[u] = p;\n  for (auto v : tree[u]) {\n    if (v == p) continue;\n    dfs(v, u, tree);\n  }\n}\nvoid init() {\n  cin >> n;\n  p.assign(n + 1, 0);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    p[i] = 1 - p[i];\n  }\n  pa.assign(n + 1, n);\n  vector<vector<int>> tree(n);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    edge.emplace_back(u, v);\n    tree[u].emplace_back(v);\n    tree[v].emplace_back(u);\n  }\n  dfs(0, n, tree);\n}\nvoid process() {\n  double vsum = 0;\n  for (int i = 0; i < n; i++) vsum += p[i];\n  double esum = 0;\n  for (auto [x, y] : edge) esum += p[x] * p[y];\n  vector<double> csum(n + 1, 0);\n  for (int i = 1; i < n; i++) csum[pa[i]] += p[i];\n  int q;\n  cin >> q;\n  while (q--) {\n    int v;\n    double np;\n    cin >> v >> np;\n    np = 1 - np;\n    vsum -= p[v];\n    esum -= p[v] * csum[v];\n    esum -= p[pa[v]] * csum[pa[v]];\n    csum[pa[v]] = csum[pa[v]] - p[v] + np;\n    p[v] = np;\n    vsum += p[v];\n    esum += p[v] * csum[v];\n    esum += p[pa[v]] * csum[pa[v]];\n    cout << fixed << setprecision(6) << vsum - esum << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint x, y;\ndouble a[100005];\nstruct Edge {\n  int v;\n  Edge *next;\n} * h[100005], pool[100005 << 1];\nint tot;\nvoid addEdge(int u, int v) {\n  Edge *p = &pool[tot++];\n  p->v = v;\n  p->next = h[u];\n  h[u] = p;\n}\ndouble ans;\nint um;\ndouble r;\nint fa[100005];\ndouble son[100005];\nvoid dfs(int u, int father) {\n  fa[u] = father;\n  ans += (1 - a[u]) * a[fa[u]];\n  for (Edge *p = h[u]; p; p = p->next)\n    if (p->v != father) {\n      dfs(p->v, u);\n      son[u] += (1 - a[p->v]);\n    }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &a[i]);\n  for (int i = 1; i <= n - 1; i++) {\n    scanf(\"%d%d\", &x, &y);\n    x++;\n    y++;\n    addEdge(x, y);\n    addEdge(y, x);\n  }\n  a[0] = 1;\n  scanf(\"%d\", &m);\n  dfs(1, 0);\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d%lf\", &um, &r);\n    um++;\n    ans += a[fa[um]] * (-(r - a[um]));\n    ans += son[um] * (r - a[um]);\n    son[fa[um]] -= (r - a[um]);\n    a[um] = r;\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e5 + 50;\nint n, q;\nvector<int> G[N];\nint par[N];\ndouble pro[N], sum[N];\ndouble res = 0;\nvoid dfs(int v, int p = 0) {\n  par[v] = p;\n  sum[p] += pro[v];\n  for (int nxt : G[v]) {\n    if (nxt != p) dfs(nxt, v);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> pro[i], pro[i] = 1 - pro[i];\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    a++, b++;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  dfs(1, 0);\n  for (int i = 0; i <= n; i++) res += (1 - pro[i]) * sum[i];\n  cin >> q;\n  while (q--) {\n    int v;\n    double val;\n    cin >> v >> val;\n    v++;\n    val = 1 - val;\n    double delta = val - pro[v];\n    res -= delta * sum[v];\n    res += (1 - pro[par[v]]) * delta;\n    sum[par[v]] += delta;\n    pro[v] += delta;\n    cout << fixed << setprecision(4) << res << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, q, fa[110000];\ndouble p[110000], sum[110000];\nint edgenum, vet[210000], Next[210000], Head[110000];\nvoid addedge(int u, int v) {\n  vet[++edgenum] = v;\n  Next[edgenum] = Head[u];\n  Head[u] = edgenum;\n}\nvoid dfs(int u) {\n  for (int e = Head[u]; e; e = Next[e])\n    if (vet[e] != fa[u]) {\n      fa[vet[e]] = u;\n      dfs(vet[e]);\n    }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  int u, v;\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d\", &u, &v);\n    u++;\n    v++;\n    addedge(u, v);\n    addedge(v, u);\n  }\n  p[0] = 1;\n  dfs(1);\n  double ans = 0;\n  for (int i = 1; i <= n; i++) {\n    ans += p[fa[i]] * (1 - p[i]);\n    sum[fa[i]] += (1 - p[i]);\n  }\n  scanf(\"%d\", &q);\n  int x;\n  double y;\n  while (q--) {\n    scanf(\"%d%lf\", &x, &y);\n    x++;\n    ans -= p[fa[x]] * (1 - p[x]);\n    ans -= p[x] * sum[x];\n    sum[fa[x]] -= (1 - p[x]);\n    p[x] = y;\n    sum[fa[x]] += (1 - p[x]);\n    ans += p[x] * sum[x];\n    ans += p[fa[x]] * (1 - p[x]);\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> par;\nvoid bryceorz(int v, int p, const vector<vector<int>> &graph) {\n  par[v] = p;\n  for (int nxt : graph[v]) {\n    if (nxt == p) continue;\n    bryceorz(nxt, v, graph);\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<double> fail(n);\n  for (int i = 0; i < n; ++i) scanf(\"%lf\", &fail[i]);\n  vector<vector<int>> tree(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    tree[a].push_back(b);\n    tree[b].push_back(a);\n  }\n  par.assign(n, -1);\n  bryceorz(0, -1, tree);\n  par.push_back(-1);\n  fail.push_back(1.0);\n  par[0] = n;\n  vector<double> childrenSums(n + 1);\n  vector<int> childCount(n + 1);\n  for (int i = 0; i < n; ++i) childrenSums[par[i]] += fail[i];\n  for (int i = 0; i <= n; ++i)\n    if (par[i] != -1) ++childCount[par[i]];\n  double allSum = 0;\n  for (int i = 0; i < n; ++i) allSum += fail[i];\n  auto getAns = [&]() {\n    double ans = 0;\n    for (int i = 0; i < n; ++i) {\n      ans += (1 - fail[i]) * fail[par[i]];\n    }\n    return ans;\n  };\n  double currentAns = getAns();\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int v;\n    double new_f;\n    scanf(\"%d %lf\", &v, &new_f);\n    double d = new_f - fail[v];\n    double answerChange =\n        d * childCount[v] - (fail[par[v]] + childrenSums[v]) * d;\n    currentAns += answerChange;\n    fail[v] += d;\n    childrenSums[par[v]] += d;\n    printf(\"%.6lf\\n\", currentAns);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, q;\nfloat p[100005];\nvector<int> g[100005];\nfloat sumc[100005], cont[100005];\nint par[100005];\nvoid dfs(int st, int pr) {\n  par[st] = pr;\n  for (int v : g[st])\n    if (v != pr) {\n      dfs(v, st);\n      sumc[st] += (1.0 - p[v]);\n    }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << setiosflags(ios::fixed | ios::showpoint) << setprecision(8);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) cin >> p[i];\n  for (int i = 1; i <= n - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    u++;\n    v++;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs(1, 1);\n  float ans = 1.0 - p[1];\n  for (int st = 1; st <= n; ++st) {\n    ans += p[st] * sumc[st];\n    cont[st] = p[st] * sumc[st];\n  }\n  cin >> q;\n  while (q--) {\n    int u;\n    float pp;\n    cin >> u >> pp;\n    u++;\n    float temp = p[u];\n    p[u] = pp;\n    int st = u;\n    ans -= cont[st];\n    cont[st] = sumc[st] * p[st];\n    ans += cont[st];\n    if (st == 1) {\n      ans -= (1.0 - temp);\n      ans += (1.0 - p[1]);\n    } else {\n      int pr = par[st];\n      ans -= cont[pr];\n      sumc[pr] -= (1.0 - temp);\n      sumc[pr] += (1.0 - p[st]);\n      cont[pr] = sumc[pr] * p[pr];\n      ans += cont[pr];\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 19;\nint pa[MAXN];\nbool visited[MAXN];\nvector<int> adj[MAXN];\ndouble pp[MAXN], p[MAXN];\nvoid dfs(int n) {\n  visited[n] = true;\n  for (auto& it : adj[n]) {\n    if (!visited[it]) {\n      pp[n] += p[it];\n      pa[it] = n;\n      dfs(it);\n    }\n  }\n  return;\n}\nint main() {\n  cin.sync_with_stdio(0);\n  cin.tie(0);\n  cin.exceptions(cin.failbit);\n  cout << setprecision(10);\n  int n;\n  cin >> n;\n  for (int i = 0; i < (n); ++i) {\n    float temp;\n    cin >> temp;\n    p[i] = temp;\n  }\n  for (int i = 0; i < (n - 1); ++i) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  int q;\n  cin >> q;\n  pa[0] = -1;\n  dfs(0);\n  double ans = 0;\n  for (int i = 1; i <= (n - 1); ++i) {\n    ans += p[pa[i]] * (1 - p[i]);\n  }\n  ans += (1 - p[0]);\n  for (int i = 0; i < (q); ++i) {\n    int in;\n    cin >> in;\n    float temp;\n    cin >> temp;\n    double np;\n    np = temp;\n    if (in == 0) {\n      ans -= (1 - p[0]);\n      ans += (1 - np);\n      ans -= p[0] * ((int)(adj[0]).size() - pp[0]);\n      ans += np * ((int)(adj[0]).size() - pp[0]);\n      p[0] = np;\n    } else {\n      ans -= p[pa[in]] * (1 - p[in]);\n      ans += p[pa[in]] * (1 - np);\n      pp[pa[in]] -= p[in];\n      pp[pa[in]] += np;\n      if ((int)(adj[in]).size() != 0) {\n        ans -= p[in] * (((int)(adj[in]).size() - 1) - pp[in]);\n        ans += np * (((int)(adj[in]).size() - 1) - pp[in]);\n      }\n      p[in] = np;\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, L[400010], R[400010], D[400010], Head[400010], Next[400010], Go[400010],\n    Cnt = 0;\ndouble Val[400010], O[400010];\nvector<int> big[400010];\nvoid addedge(int x, int y) {\n  Go[++Cnt] = y;\n  Next[Cnt] = Head[x];\n  Head[x] = Cnt;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%lf\", &Val[i]);\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d\", &L[i], &R[i]);\n    D[L[i]]++;\n    D[R[i]]++;\n    addedge(L[i], R[i]);\n    addedge(R[i], L[i]);\n  }\n  for (int i = 0; i < n; i++)\n    if (D[i] * D[i] > n) {\n      for (int T = Head[i]; T; T = Next[T]) big[Go[T]].push_back(i);\n    }\n  int q;\n  scanf(\"%d\", &q);\n  double ans = 1;\n  for (int j = 0; j < n; j++) {\n    ans += (D[j] - 1) * Val[j];\n  }\n  for (int j = 1; j < n; j++) ans -= Val[L[j]] * Val[R[j]];\n  for (int i = 0; i < n; i++)\n    if (D[i] * D[i] <= n)\n      for (int T = Head[i]; T; T = Next[T]) O[Go[T]] -= Val[i];\n  for (int i = 1; i <= q; i++) {\n    int a;\n    double b;\n    scanf(\"%d%lf\", &a, &b);\n    if (D[a] * D[a] <= n) {\n      for (int T = Head[a]; T; T = Next[T]) O[Go[T]] += Val[a];\n    }\n    for (int j = 0; j < big[a].size(); j++) ans += Val[a] * Val[big[a][j]];\n    ans -= O[a] * Val[a];\n    ans -= (D[a] - 1) * Val[a];\n    Val[a] = b;\n    ans += O[a] * Val[a];\n    ans += (D[a] - 1) * Val[a];\n    if (D[a] * D[a] <= n) {\n      for (int T = Head[a]; T; T = Next[T]) O[Go[T]] -= Val[a];\n    }\n    for (int j = 0; j < big[a].size(); j++) ans -= Val[a] * Val[big[a][j]];\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e5 + 50;\nint n, q;\nvector<int> G[N];\nint par[N];\ndouble pro[N], sum[N];\ndouble res = 0;\nvoid dfs(int v, int p = 0) {\n  par[v] = p;\n  sum[p] += pro[v];\n  for (int nxt : G[v]) {\n    if (nxt != p) dfs(nxt, v);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> pro[i], pro[i] = 1 - pro[i];\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    a++, b++;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  dfs(1, 0);\n  for (int i = 0; i <= n; i++) res += (1 - pro[i]) * sum[i];\n  cin >> q;\n  while (q--) {\n    int v;\n    double val;\n    cin >> v >> val;\n    v++;\n    val = 1 - val;\n    res -= (1 - pro[v]) * sum[v];\n    res -= (1 - pro[par[v]]) * sum[par[v]];\n    sum[par[v]] -= pro[v];\n    pro[v] = val;\n    sum[par[v]] += pro[v];\n    res += (1 - pro[v]) * sum[v];\n    res += (1 - pro[par[v]]) * sum[par[v]];\n    cout << fixed << setprecision(4) << res << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, from, to, num, head[100010], father[100010], q;\ndouble p[100010], sum, g[100010], ans;\nint read() {\n  int x = 0;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') ch = getchar();\n  while (ch >= '0' && ch <= '9') {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = getchar();\n  }\n  return x;\n}\nstruct xx {\n  int next, to;\n} way[200010];\nvoid add(int from, int to) {\n  way[++num].next = head[from];\n  way[num].to = to;\n  head[from] = num;\n}\nvoid dfs(int x, int fa) {\n  father[x] = fa;\n  for (int i = head[x]; i; i = way[i].next) {\n    int y = way[i].to;\n    if (y == fa) continue;\n    dfs(y, x);\n    g[x] += (1 - p[y]);\n  }\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n  for (int i = 1; i < n; i++) {\n    from = read() + 1;\n    to = read() + 1;\n    add(from, to);\n    add(to, from);\n  }\n  dfs(1, 0);\n  for (int i = 1; i <= n; i++) {\n    ans = ans + (g[i]) * (1 - p[i]) + p[i];\n  }\n  q = read();\n  p[0] = 1;\n  while (q--) {\n    int x = read() + 1;\n    double r;\n    scanf(\"%lf\", &r);\n    ans -= p[x] + (g[x]) * (1 - p[x]);\n    ans += r + (g[x]) * (1 - r);\n    ans -= g[father[x]] * (1 - p[father[x]]);\n    g[father[x]] = g[father[x]] - (1 - p[x]) + (1 - r);\n    ans += g[father[x]] * (1 - p[father[x]]);\n    printf(\"%lf\\n\", n - ans);\n    p[x] = r;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int B = 400;\nconst int N = 100100;\nvector<int> g[N];\nvector<int> toBig[N];\nbool isBig[N];\ndouble sumForBig[N];\ndouble p[N];\ndouble ANS;\nint n;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf\", &p[i]);\n    p[i] = 1 - p[i];\n  }\n  for (int i = 1; i < n; i++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n  for (int v = 0; v < n; v++) isBig[v] = (int)g[v].size() > B;\n  for (int v = 0; v < n; v++)\n    for (int u : g[v])\n      if (isBig[u]) toBig[v].push_back(u);\n  for (int v = 0; v < n; v++) {\n    ANS += p[v];\n    for (int u : g[v])\n      if (u > v) ANS -= p[v] * p[u];\n    if (!isBig[v]) continue;\n    for (int u : g[v]) sumForBig[v] += p[u];\n  }\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int v;\n    double x;\n    scanf(\"%d%lf\", &v, &x);\n    x = 1 - x;\n    ANS -= p[v];\n    ANS += x;\n    if (isBig[v])\n      ANS -= (x - p[v]) * sumForBig[v];\n    else {\n      for (int u : g[v]) ANS -= (x - p[v]) * p[u];\n    }\n    for (int u : toBig[v]) sumForBig[u] += x - p[v];\n    p[v] = x;\n    printf(\"%.12lf\\n\", ANS);\n  }\n  return 0;\n}\n"
        }
    ]
}