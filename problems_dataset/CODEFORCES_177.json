{
    "name": "177_C1. Party",
    "source": "CODEFORCES",
    "description": "To celebrate the second ABBYY Cup tournament, the Smart Beaver decided to throw a party. The Beaver has a lot of acquaintances, some of them are friends with each other, and some of them dislike each other. To make party successful, the Smart Beaver wants to invite only those of his friends who are connected by friendship relations, and not to invite those who dislike each other. Both friendship and dislike are mutual feelings.\n\nMore formally, for each invited person the following conditions should be fulfilled: \n\n  * all his friends should also be invited to the party; \n  * the party shouldn't have any people he dislikes; \n  * all people who are invited to the party should be connected with him by friendship either directly or through a chain of common friends of arbitrary length. We'll say that people a1 and ap are connected through a chain of common friends if there exists a sequence of people a2, a3, ..., ap - 1 such that all pairs of people ai and ai + 1 (1 \u2264 i < p) are friends. \n\n\n\nHelp the Beaver find the maximum number of acquaintances he can invite.\n\nInput\n\nThe first line of input contains an integer n \u2014 the number of the Beaver's acquaintances. \n\nThe second line contains an integer k <image> \u2014 the number of pairs of friends. Next k lines contain space-separated pairs of integers ui, vi <image> \u2014 indices of people who form the i-th pair of friends.\n\nThe next line contains an integer m <image> \u2014 the number of pairs of people who dislike each other. Next m lines describe pairs of people who dislike each other in the same format as the pairs of friends were described.\n\nEach pair of people is mentioned in the input at most once <image>. In particular, two persons cannot be friends and dislike each other at the same time.\n\nThe input limitations for getting 30 points are: \n\n  * 2 \u2264 n \u2264 14\n\n\n\nThe input limitations for getting 100 points are: \n\n  * 2 \u2264 n \u2264 2000\n\nOutput\n\nOutput a single number \u2014 the maximum number of people that can be invited to the party. If a group of people that meets all the requirements is impossible to select, output 0.\n\nExamples\n\nInput\n\n9\n8\n1 2\n1 3\n2 3\n4 5\n6 7\n7 8\n8 9\n9 6\n2\n1 6\n7 9\n\n\nOutput\n\n3\n\nNote\n\nLet's have a look at the example. \n\n<image>\n\nTwo groups of people can be invited: {1, 2, 3} and {4, 5}, thus the answer will be the size of the largest of these groups. Group {6, 7, 8, 9} doesn't fit, since it includes people 7 and 9 who dislike each other. Group {1, 2, 3, 4, 5} also doesn't fit, because not all of its members are connected by a chain of common friends (for example, people 2 and 5 aren't connected).",
    "difficulty": "C",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "rating": 1500,
    "public_test": [
        {
            "input": "9\n8\n1 2\n1 3\n2 3\n4 5\n6 7\n7 8\n8 9\n9 6\n2\n1 6\n7 9\n",
            "output": "3"
        }
    ],
    "generated_test": [
        {
            "input": "14\n6\n1 2\n2 3\n3 4\n4 5\n8 10\n9 10\n3\n5 6\n6 7\n7 8\n",
            "output": "5"
        },
        {
            "input": "14\n20\n1 2\n4 5\n4 8\n4 11\n5 7\n5 8\n5 13\n5 14\n7 8\n7 14\n8 9\n8 11\n8 12\n8 14\n10 11\n10 12\n10 14\n11 13\n11 14\n12 14\n5\n1 8\n1 13\n2 10\n7 12\n8 10\n",
            "output": "2"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n6 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n6 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 5\n12 6\n4 3\n13 3\n12 2\n9 3\n11 7\n7 3\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n4 1\n7 6\n10 6\n12 1\n10 4\n5 2\n9 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n78\n11 1\n10 6\n6 2\n10 1\n11 6\n11 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 4\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 11\n11 9\n9 4\n8 7\n12 6\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n2 1\n6 5\n12 2\n11 8\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "3\n3\n2 3\n2 1\n2 3\n0\n",
            "output": "3"
        },
        {
            "input": "14\n20\n1 2\n4 5\n4 8\n4 11\n5 7\n5 8\n5 13\n5 14\n7 8\n7 14\n8 9\n8 11\n8 12\n8 14\n10 11\n10 12\n10 14\n11 13\n4 14\n12 14\n5\n1 8\n1 13\n2 10\n7 12\n8 10\n",
            "output": "2"
        },
        {
            "input": "13\n78\n11 1\n10 11\n6 2\n10 1\n11 6\n11 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 4\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 11\n11 9\n9 4\n8 7\n12 6\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n2 1\n6 5\n12 2\n11 8\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "14\n6\n1 2\n2 3\n3 4\n4 5\n8 9\n9 10\n3\n5 6\n6 8\n7 8\n",
            "output": "5"
        },
        {
            "input": "14\n10\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 4\n2 4\n2 5\n2 6\n1\n2 7\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n6 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 5\n12 6\n4 3\n13 3\n12 2\n9 3\n11 7\n7 3\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n9 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n78\n11 1\n10 6\n6 2\n10 1\n11 6\n11 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 4\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 6\n11 9\n9 4\n8 7\n12 6\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n4 1\n6 5\n12 2\n11 8\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "9\n8\n1 2\n1 3\n2 3\n4 5\n6 7\n7 8\n8 9\n9 6\n2\n2 6\n7 9\n",
            "output": "3"
        },
        {
            "input": "14\n6\n1 2\n2 3\n3 4\n4 5\n9 10\n9 10\n3\n5 6\n6 7\n7 8\n",
            "output": "5"
        },
        {
            "input": "13\n78\n11 1\n10 6\n6 2\n10 1\n11 6\n11 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 4\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n5 3\n8 11\n11 9\n9 4\n8 7\n12 6\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n2 1\n6 5\n12 2\n11 8\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "14\n10\n1 2\n1 3\n1 4\n1 5\n2 6\n1 7\n2 4\n2 4\n2 5\n2 6\n1\n2 7\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n6 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 5\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 3\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n9 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n78\n11 1\n10 6\n6 2\n10 1\n11 6\n11 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 4\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 6\n11 9\n9 4\n8 7\n12 3\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n4 1\n6 5\n12 2\n11 8\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n6 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 3\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n9 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n78\n11 1\n10 6\n6 2\n10 1\n11 6\n11 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 4\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 6\n11 9\n9 4\n8 7\n12 3\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n4 1\n6 5\n12 2\n11 5\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 3\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n9 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n78\n11 1\n10 6\n6 2\n10 1\n11 6\n11 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 4\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 2\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 6\n11 9\n9 4\n8 7\n12 3\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n4 1\n6 5\n12 2\n11 5\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n9 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n78\n11 1\n10 6\n6 2\n10 1\n11 6\n11 3\n5 3\n13 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 4\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 2\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 6\n11 9\n9 4\n8 7\n12 3\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n4 1\n6 5\n12 2\n11 5\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n6 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n3 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n6 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n3 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 6\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n6 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n12 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n3 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 6\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n6 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "14\n10\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 3\n2 4\n2 5\n2 9\n1\n2 7\n",
            "output": "1"
        },
        {
            "input": "14\n20\n1 2\n4 5\n4 6\n4 11\n5 7\n5 8\n5 13\n5 14\n7 8\n7 14\n8 9\n8 11\n8 12\n8 14\n10 11\n10 12\n10 14\n11 13\n11 14\n12 14\n5\n1 8\n1 13\n2 10\n7 5\n8 10\n",
            "output": "2"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n6 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n10 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n6 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 5\n12 6\n4 3\n13 3\n12 2\n9 3\n11 7\n7 3\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n9 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n78\n11 1\n10 6\n6 2\n10 1\n11 6\n11 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n9 4\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 6\n11 9\n9 4\n8 7\n12 6\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n2 1\n6 5\n12 2\n11 8\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "9\n8\n1 2\n1 3\n2 3\n6 5\n6 7\n7 8\n8 9\n9 6\n2\n1 6\n7 9\n",
            "output": "3"
        },
        {
            "input": "14\n20\n1 2\n4 5\n4 8\n4 11\n5 7\n5 8\n5 13\n5 14\n7 8\n7 14\n8 9\n8 11\n13 12\n8 14\n10 11\n10 12\n10 14\n11 13\n11 14\n12 14\n5\n1 8\n1 13\n2 10\n7 12\n8 10\n",
            "output": "2"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n6 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n3 9\n12 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n6 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 5\n12 6\n4 3\n13 3\n12 2\n9 3\n11 7\n7 3\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n4 1\n7 6\n10 6\n12 1\n10 4\n5 2\n9 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n78\n11 1\n10 6\n6 2\n10 1\n11 6\n5 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 4\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 11\n11 9\n9 4\n8 7\n12 6\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n2 1\n6 5\n12 2\n11 8\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "13\n78\n11 1\n10 11\n6 2\n10 1\n11 6\n11 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 6\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 11\n11 9\n9 4\n8 7\n12 6\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n2 1\n6 5\n12 2\n11 8\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "13\n78\n11 1\n10 6\n6 2\n10 1\n11 6\n11 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 4\n11 4\n13 1\n10 7\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 6\n11 9\n9 4\n8 7\n12 6\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n4 1\n6 5\n12 2\n11 8\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "14\n10\n1 2\n2 3\n1 4\n1 5\n2 6\n1 7\n2 4\n2 4\n2 5\n2 6\n1\n2 7\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n6 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 5\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 3\n2 1\n10 2\n13 7\n13 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n9 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n78\n11 1\n10 6\n6 2\n10 1\n11 6\n11 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 4\n11 4\n13 1\n10 5\n4 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 6\n11 9\n9 4\n8 7\n12 3\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n4 1\n6 5\n12 2\n11 8\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n6 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n9 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n6 4\n11 6\n3 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 3\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n3 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n6 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n3 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 6\n10 1\n7 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n6 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n12 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n3 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 6\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 1\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n6 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n6 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n10 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n6 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 5\n12 2\n4 3\n13 3\n12 2\n9 3\n11 7\n7 3\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n9 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "14\n20\n1 2\n4 5\n4 8\n4 11\n5 7\n5 8\n5 13\n5 14\n7 8\n7 14\n8 9\n8 11\n13 12\n8 14\n10 11\n10 12\n10 14\n11 13\n11 14\n12 14\n5\n1 8\n1 13\n2 10\n7 12\n8 1\n",
            "output": "2"
        },
        {
            "input": "13\n78\n11 1\n10 6\n6 2\n10 1\n11 6\n5 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 4\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n9 3\n8 11\n11 9\n9 4\n8 7\n12 6\n5 1\n13 10\n13 6\n10 7\n13 4\n8 7\n13 2\n2 1\n6 5\n12 2\n11 8\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "13\n78\n11 1\n10 11\n6 2\n10 1\n11 6\n11 3\n5 3\n8 1\n12 11\n4 2\n10 3\n13 8\n9 8\n11 7\n7 5\n11 2\n7 1\n4 1\n11 10\n8 3\n13 11\n9 6\n13 9\n12 7\n12 8\n12 9\n10 2\n5 2\n12 10\n9 2\n9 7\n3 2\n7 6\n11 4\n13 1\n10 5\n11 5\n8 5\n10 4\n8 2\n10 9\n4 3\n9 5\n13 12\n13 5\n7 2\n12 4\n9 1\n10 8\n6 3\n6 4\n7 6\n7 3\n12 3\n5 4\n6 1\n12 5\n8 4\n13 3\n12 1\n6 3\n8 11\n11 9\n9 4\n8 7\n12 6\n5 1\n13 10\n13 6\n10 7\n13 4\n13 7\n13 2\n2 1\n6 5\n12 2\n11 8\n3 1\n0\n",
            "output": "13"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n9 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n6 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n9 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n11 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n13 1\n10 4\n5 2\n6 4\n11 6\n3 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 4\n5 1\n9 8\n11 3\n13 12\n6 3\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n3 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 3\n10 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n6 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n8 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n3 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 6\n10 1\n7 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 2\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n6 4\n11 6\n9 7\n7 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        },
        {
            "input": "13\n0\n78\n11 8\n8 4\n13 9\n12 1\n10 5\n5 1\n9 8\n11 3\n13 12\n6 2\n10 9\n9 1\n10 3\n13 6\n8 1\n11 10\n11 1\n11 9\n12 4\n12 11\n3 4\n8 6\n9 6\n13 10\n13 8\n7 2\n8 6\n4 1\n12 10\n10 5\n8 2\n5 4\n9 2\n13 1\n4 1\n13 2\n12 5\n10 7\n7 4\n8 2\n12 6\n4 3\n13 3\n12 1\n9 2\n11 7\n7 5\n2 1\n10 2\n13 7\n7 5\n13 4\n12 7\n4 2\n12 9\n11 5\n10 8\n11 2\n12 3\n3 1\n7 6\n10 6\n12 1\n10 4\n5 2\n6 4\n11 6\n9 7\n5 3\n7 1\n8 7\n6 3\n13 5\n12 8\n6 4\n13 11\n9 5\n3 2\n",
            "output": "1"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N_max = 0;\nclass graph {\n private:\n  long long V;\n  long long k, m;\n  vector<pair<long long, long long>> L;\n  vector<pair<long long, long long>> L2;\n\n public:\n  graph(long long n) { V = n; }\n  void add_edge(long long u, long long v) { L.push_back({u, v}); }\n  long long find_set(long long i, long long parent[]) {\n    if (parent[i] == -1) return i;\n    parent[i] = find_set(parent[i], parent);\n    return find_set(parent[i], parent);\n  }\n  void union_set(long long x, long long y, long long parent[],\n                 long long rank[]) {\n    long long S1 = find_set(x, parent);\n    long long S2 = find_set(y, parent);\n    if (S1 != S2) {\n      if (rank[S1] < rank[S2]) {\n        parent[S1] = S2;\n        rank[S2] += rank[S1];\n      } else {\n        parent[S2] = S1;\n        rank[S1] += rank[S2];\n      }\n    }\n  }\n  void solve() {\n    long long m, i, x, y, u, v, ans, leader, sz;\n    long long parent[V];\n    long long rank[V];\n    bool isValid[V];\n    for (i = 0; i < V; i++) {\n      parent[i] = -1;\n      rank[i] = 1;\n      isValid[i] = true;\n    }\n    for (auto edge : L) {\n      u = edge.first;\n      v = edge.second;\n      union_set(u, v, parent, rank);\n    }\n    cin >> m;\n    for (i = 0; i < m; i++) {\n      cin >> u >> v;\n      u -= 1, v -= 1;\n      x = find_set(u, parent);\n      y = find_set(v, parent);\n      if (x == y) {\n        isValid[x] = false;\n      }\n    }\n    ans = 0;\n    for (i = 0; i < V; i++) {\n      leader = find_set(i, parent);\n      if (isValid[leader]) {\n        sz = rank[leader];\n        ans = max(ans, sz);\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n};\nvoid run_case() {\n  long long n, i, k, u, v;\n  cin >> n;\n  graph G(n);\n  cin >> k;\n  for (i = 0; i < k; i++) {\n    cin >> u >> v;\n    u -= 1, v -= 1;\n    G.add_edge(u, v);\n  }\n  G.solve();\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long T = 1;\n  while (T--) run_case();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\n\n\npublic class C {\n\n    static StreamTokenizer st;\n    public static void main(String[] args) throws IOException{\n        st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n = nextInt();\n        byte[][]a = new byte[n+1][n+1];\n        int k = nextInt();\n        for (int i = 1; i <= k; i++) {\n            int v1 = nextInt();\n            int v2 = nextInt();\n            a[v1][v2] = a[v2][v1] = 1;\n        }\n        int m = nextInt();\n        for (int i = 1; i <= m; i++) {\n            int v1 = nextInt();\n            int v2 = nextInt();\n            a[v1][v2] = a[v2][v1] = -1;\n        }\n        boolean[]used = new boolean[n+1];\n        boolean[]current = new boolean[n+1];\n        int[]q = new int[n+1];\n        int max = 0;\n        for (int i = 1; i <= n; i++) {\n            Arrays.fill(current, false);\n            if (!used[i]) {\n                int head = 0, tail = 1;\n                used[i] = true;\n                q[1] = i;\n                boolean f = true;\n                current[i] = true;\n                while (head < tail) {\n                    int v = q[++head];\n                    for (int j = 1; j <= n; j++) {\n                        if (a[v][j]==1) {\n                            if (!used[j]) {\n                                used[j] = true;\n                                current[j] = true;\n                                q[++tail] = j;\n                            }\n                        }\n                        else if (a[v][j]==-1) {\n                            if (current[j]) {\n                                f = false;\n                            }\n                        }\n                    }\n                }\n                if (f)\n                    max = Math.max(max, tail);\n            }\n        }\n        pw.print(max);\n        pw.close();\n    }\n     \n    private static int nextInt() throws IOException{\n        st.nextToken();\n        return (int) st.nval;\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint Belong[2009];\nint Cnt[2009];\nbool f[2009];\nint find(int x) {\n  int j, t = x;\n  while (x != Belong[x]) {\n    x = Belong[x];\n  }\n  while (t != Belong[t]) {\n    j = Belong[t];\n    Belong[t] = x;\n    t = j;\n  }\n  return x;\n}\nvoid merge(int x, int y) {\n  int xx = find(x), yy = find(y);\n  if (xx != yy) {\n    Belong[xx] = yy;\n    Cnt[yy] += Cnt[xx];\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) Belong[i] = i, Cnt[i] = 1;\n  scanf(\"%d\", &m);\n  int u, v;\n  while (m--) {\n    scanf(\"%d%d\", &u, &v);\n    merge(u, v);\n  }\n  scanf(\"%d\", &m);\n  int x, y;\n  memset(f, false, sizeof(f));\n  while (m--) {\n    scanf(\"%d%d\", &u, &v);\n    x = find(u);\n    y = find(v);\n    if (x == y) f[x] = true;\n  }\n  int ret = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (Belong[i] == i && !f[i]) ret = max(ret, Cnt[i]);\n  }\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T, typename U>\nstatic inline void amin(T &x, U y) {\n  if (y < x) x = y;\n}\ntemplate <typename T, typename U>\nstatic inline void amax(T &x, U y) {\n  if (x < y) x = y;\n}\nusing namespace std;\nconst int N = 2005;\nint par[N], r[N];\nint find(int a) {\n  if (par[a] < 0)\n    return a;\n  else\n    return (par[a] = find(par[a]));\n}\nvoid merge(int a, int b) {\n  a = find(a);\n  b = find(b);\n  if (a == b) return;\n  if (r[a] > r[b]) {\n    par[b] = a;\n    r[a] += r[b];\n  } else {\n    par[a] = b;\n    r[b] += r[a];\n  }\n}\nvoid solve() {\n  int n, m, k, a, b, i;\n  cin >> n >> k;\n  for (i = 1; i < n + 1; i++) par[i] = -1, r[i] = 1;\n  for (i = 0; i < k; i++) {\n    cin >> a >> b;\n    merge(a, b);\n  }\n  cin >> m;\n  if (k == 0 && m != 0) {\n    for (i = 0; i < m; i++) {\n      cin >> a >> b;\n      merge(a, b);\n    }\n    int cnt = 0;\n    for (i = 1; i < n + 1; i++)\n      if (par[i] < 0) cnt++;\n    cout << cnt;\n    return;\n  }\n  set<pair<int, int> > s;\n  for (i = 1; i < n + 1; i++) {\n    if (r[i] > 1) s.insert(make_pair(r[i], i));\n    if (r[i] == 1 && par[i] < 0) s.insert(make_pair(r[i], i));\n  }\n  for (i = 0; i < m; i++) {\n    cin >> a >> b;\n    if (find(a) == find(b)) {\n      int p = find(a);\n      for (auto i : s) {\n        if (i.second == p) {\n          s.erase(i);\n          break;\n        }\n      }\n    }\n  }\n  if (k == 0 && m == 0)\n    cout << 1;\n  else if ((int)s.size()) {\n    auto it = s.end();\n    it--;\n    cout << it->first;\n  } else\n    cout << 0;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> V[3000];\nint vis[3000];\nint k = 1;\nint siz[3000];\nvoid dfs(int x) {\n  for (int i = 0; i < V[x].size(); i++) {\n    if (vis[V[x][i]] == 0) {\n      vis[V[x][i]] = k;\n      siz[k]++;\n      dfs(V[x][i]);\n    }\n  }\n}\nint main() {\n  int n, kk, m;\n  int x, y;\n  cin >> n;\n  cin >> kk;\n  for (int i = 0; i < kk; i++) {\n    cin >> x >> y;\n    V[x].push_back(y);\n    V[y].push_back(x);\n  }\n  for (int i = 1; i <= n; i++)\n    if (vis[i] == 0) {\n      siz[k]++;\n      vis[i] = k;\n      dfs(i);\n      k++;\n    }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> x >> y;\n    if (vis[x] == vis[y]) siz[vis[x]] = 0;\n  }\n  sort(siz, siz + n);\n  reverse(siz, siz + n);\n  int ans = 0;\n  for (int i = 0; siz[i] != 0; i++) ans = max(ans, siz[i]);\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mxn = 2000 + 10;\nvector<int> v[mxn];\nvector<pair<int, int> > v2;\nint n, m;\nint mx;\nbool viz[mxn];\nint dfs(int nod) {\n  int nr = 0;\n  stack<int> s;\n  s.push(nod);\n  viz[nod] = 1;\n  int nx;\n  while (!s.empty()) {\n    nx = s.top();\n    s.pop();\n    nr++;\n    for (auto it : v[nx])\n      if (viz[it] == 0) {\n        s.push(it);\n        viz[it] = 1;\n      }\n  }\n  bool ok = 1;\n  for (int i = 0; i < v2.size(); i++) {\n    if (viz[v2[i].first] && viz[v2[i].second]) {\n      ok = 0;\n      v2.erase(v2.begin() + i);\n    }\n  }\n  if (nr == 1) return 1;\n  return nr * ok;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = 1, xx, yy; i <= m; i++) {\n    cin >> xx >> yy;\n    v[xx].push_back(yy);\n    v[yy].push_back(xx);\n  }\n  cin >> m;\n  for (int i = 1, xx, yy; i <= m; i++) {\n    cin >> xx >> yy;\n    v2.push_back(make_pair(xx, yy));\n  }\n  sort(v2.begin(), v2.end(), less<pair<int, int> >());\n  for (int i = 1; i <= n; i++)\n    if (viz[i] == 0) mx = max(mx, dfs(i));\n  cout << mx;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n//4/22/12 1:43 AM\n//by Abrackadabra\n\npublic class C1 {\n    public static void main(String[] args) throws IOException {\n        if (args.length > 0 && args[0].equals(\"Abra\")) debugMode = true;\n        new C1().run();\n        /*new Thread(null, new Runnable() {\n            public void run() {\n                try {\n                    new C1().run();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"1\", 1 << 24).start();*/\n    }\n\n    int IOMode = 0; //0 - consoleIO, 1 - <taskName>.in/out, 2 - input.txt/output.txt, 3 - test case generator\n    String taskName = \"\";\n\n    void solve() throws IOException {\n        int n = nextInt();\n        HashMap<Integer, HashSet<Integer>> friends = new HashMap<Integer, HashSet<Integer>>();\n        HashMap<Integer, HashSet<Integer>> enemies = new HashMap<Integer, HashSet<Integer>>();\n        HashSet<Integer> badColors = new HashSet<Integer>();\n        int[] coloring = new int[n];\n        int[] colorCount = new int[n + 100];\n        int currentColor = 1;\n        int m = nextInt();\n        for (int i = 0; i < m; i++) {\n            int a = nextInt() - 1, b = nextInt() - 1;\n            if (!friends.containsKey(a))\n                friends.put(a, new HashSet<Integer>());\n            if (!friends.containsKey(b))\n                friends.put(b, new HashSet<Integer>());\n            friends.get(a).add(b);\n            friends.get(b).add(a);\n        }\n        m = nextInt();\n        for (int i = 0; i < m; i++) {\n            int a = nextInt() - 1, b = nextInt() - 1;\n            if (!enemies.containsKey(a))\n                enemies.put(a, new HashSet<Integer>());\n            if (!enemies.containsKey(b))\n                enemies.put(b, new HashSet<Integer>());\n            enemies.get(a).add(b);\n            enemies.get(b).add(a);\n        }\n        for (int i = 0; i < n; i++) {\n            if (coloring[i] == 0) {\n                int toColor = currentColor++;\n                Queue<Integer> queue = new LinkedList<Integer>();\n                queue.add(i);\n                coloring[i] = toColor;\n                colorCount[toColor]++;\n                while (!queue.isEmpty()) {\n                    int q = queue.poll();\n                    if (friends.containsKey(q))\n                    for (int t : friends.get(q)) {\n                        if (coloring[t] == 0) {\n                            coloring[t] = toColor;\n                            colorCount[toColor]++;\n                            queue.add(t);\n                        }\n                    }\n                    if (enemies.containsKey(q))\n                    for (int t : enemies.get(q)) {\n                        if (coloring[t] == toColor) {\n                            badColors.add(toColor);\n                        }\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 1; i < currentColor; i++) {\n            if (!badColors.contains(i) && colorCount[i] > res)\n                res = colorCount[i];\n        }\n        out.println(res);\n    }\n\n    long startTime = System.nanoTime(), tempTime = startTime, finishTime = startTime;\n    long startMem = Runtime.getRuntime().totalMemory(), finishMem = startMem;\n\n    void run() throws IOException {\n        init();\n        if (debugMode) {\n            con.println(\"Start\");\n            con.println(\"Console:\");\n        }\n        solve();\n        finishTime = System.nanoTime();\n        finishMem = Runtime.getRuntime().totalMemory();\n        out.flush();\n        if (debugMode) {\n            int maxSymbols = 1000;\n            BufferedReader tbr = new BufferedReader(new FileReader(\"input.txt\"));\n            char[] a = new char[maxSymbols];\n            tbr.read(a);\n            if (a[0] != 0) {\n                con.println(\"File input:\");\n                con.println(a);\n                if (a[maxSymbols - 1] != 0) con.println(\"...\");\n            }\n            tbr = new BufferedReader(new FileReader(\"output.txt\"));\n            a = new char[maxSymbols];\n            tbr.read(a);\n            if (a[0] != 0) {\n                con.println(\"File output:\");\n                con.println(a);\n                if (a[maxSymbols - 1] != 0) con.println(\"...\");\n            }\n            con.println(\"Execution time: \" + (finishTime - startTime) / 1000000000.0 + \" sec\");\n            con.println(\"Used memory:    \" + (finishMem - startMem) + \" bytes\");\n            con.println(\"Total memory:   \" + Runtime.getRuntime().totalMemory() + \" bytes\");\n        }\n    }\n\n    boolean tick(double x) {\n        if (System.nanoTime() - tempTime > x * 1e9) {\n            tempTime = System.nanoTime();\n            con.println(\"Tick at \" + (tempTime - startTime) / 1000000000 + \" sec\");\n            con.print(\"   \");\n            return true;\n        }\n        return false;\n    }\n\n    static boolean debugMode = false;\n    PrintStream con = System.out;\n\n    void init() throws IOException {\n        if (debugMode && IOMode != 3) {\n            br = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(new FileWriter(\"output.txt\"));\n        } else\n            switch (IOMode) {\n                case 0:\n                    br = new BufferedReader(new InputStreamReader(System.in));\n                    out = new PrintWriter(System.out);\n                    break;\n                case 1:\n                    br = new BufferedReader(new FileReader(taskName + \".in\"));\n                    out = new PrintWriter(new FileWriter(taskName + \".out\"));\n                    break;\n                case 2:\n                    br = new BufferedReader(new FileReader(\"input.txt\"));\n                    out = new PrintWriter(new FileWriter(\"output.txt\"));\n                    break;\n                case 3:\n                    out = new PrintWriter(new FileWriter(\"input.txt\"));\n                    break;\n            }\n    }\n\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer in;\n\n    boolean hasMoreTokens() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            String line = br.readLine();\n            if (line == null) return false;\n            in = new StringTokenizer(line);\n        }\n        return true;\n    }\n\n    String nextString() throws IOException {\n        return hasMoreTokens() ? in.nextToken() : null;\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextString());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextString());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextString());\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf177c2 {\n    static BufferedReader __in;\n    static PrintWriter __out;\n    static StringTokenizer input;\n\n    static int par[], sz[];\n\n    static int find(int u) {\n        return par[u] == -1 ? -1 : par[u] == u ? u : (par[u] = find(par[u]));\n    }\n\n    static void union(int u, int v) {\n        int a = find(u), b = find(v);\n        if(a != b && a != -1 && b != -1) {\n            par[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    static void disunion(int u, int v) {\n        int a = find(u), b = find(v);\n        if(a != -1 && a == b) {\n            par[a] = -1;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        __in = new BufferedReader(new InputStreamReader(System.in));\n        __out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        int n = ri(), k = ri();\n        par = new int[n];\n        sz = new int[n];\n        for(int i = 0; i < n; ++i) {\n            par[i] = i;\n            sz[i] = 1;\n        }\n        for(int i = 0; i < k; ++i) {\n            union(rni() - 1, ni() - 1);\n        }\n        int m = ri();\n        for(int i = 0; i < m; ++i) {\n            disunion(rni() - 1, ni() - 1);\n        }\n        int ans = 0;\n        for(int i = 0; i < n; ++i) {\n            if(i == find(i)) {\n                ans = max(ans, sz[i]);\n            }\n        }\n        prln(ans);\n\n        close();\n    }\n\n    // references\n    // IBIG = 1e9 + 7\n    // IRAND ~= 3e8\n    // IMAX ~= 2e10\n    // LMAX ~= 9e18\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IRAND = 327859546;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {return x.length == 1 ? x[0] : x.length == 2 ? min(x[0], x[1]) : min(x[0], minstarting(1, x));}\n    static int minstarting(int offset, int... x) {assert x.length > 2; return offset == x.length - 2 ? min(x[offset], x[offset + 1]) : min(x[offset], minstarting(offset + 1, x));}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {return x.length == 1 ? x[0] : x.length == 2 ? min(x[0], x[1]) : min(x[0], minstarting(1, x));}\n    static long minstarting(int offset, long... x) {assert x.length > 2; return offset == x.length - 2 ? min(x[offset], x[offset + 1]) : min(x[offset], minstarting(offset + 1, x));}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {return x.length == 1 ? x[0] : x.length == 2 ? max(x[0], x[1]) : max(x[0], maxstarting(1, x));}\n    static int maxstarting(int offset, int... x) {assert x.length > 2; return offset == x.length - 2 ? max(x[offset], x[offset + 1]) : max(x[offset], maxstarting(offset + 1, x));}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {return x.length == 1 ? x[0] : x.length == 2 ? max(x[0], x[1]) : max(x[0], maxstarting(1, x));}\n    static long maxstarting(int offset, long... x) {assert x.length > 2; return offset == x.length - 2 ? max(x[offset], x[offset + 1]) : max(x[offset], maxstarting(offset + 1, x));}\n    static int powi(int a, int b) {if(a == 0) return 0; int ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if(a == 0) return 0; long ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int floori(double d) {return (int)d;}\n    static int ceili(double d) {return (int)ceil(d);}\n    static long floorl(double d) {return (long)d;}\n    static long ceill(double d) {return (long)ceil(d);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(__in.readLine());}\n    static int ri() throws IOException {return Integer.parseInt(__in.readLine());}\n    static long rl() throws IOException {return Long.parseLong(__in.readLine());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()); return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Long.parseLong(input.nextToken()); return a;}\n    static char[] rcha() throws IOException {return __in.readLine().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static int rni() throws IOException {input = new StringTokenizer(__in.readLine()); return Integer.parseInt(input.nextToken());}\n    static int ni() {return Integer.parseInt(input.nextToken());}\n    static long rnl() throws IOException {input = new StringTokenizer(__in.readLine()); return Long.parseLong(input.nextToken());}\n    static long nl() {return Long.parseLong(input.nextToken());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {__out.println(\"yes\");}\n    static void pry() {__out.println(\"Yes\");}\n    static void prY() {__out.println(\"YES\");}\n    static void prno() {__out.println(\"no\");}\n    static void prn() {__out.println(\"No\");}\n    static void prN() {__out.println(\"NO\");}\n    static void pryesno(boolean b) {__out.println(b ? \"yes\" : \"no\");};\n    static void pryn(boolean b) {__out.println(b ? \"Yes\" : \"No\");}\n    static void prYN(boolean b) {__out.println(b ? \"YES\" : \"NO\");}\n    static void prln(int... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static void prln(long... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for(int i = 0; i < n; __out.print(iter.next()), __out.print(' '), ++i); __out.println(iter.next());}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\nusing namespace std;\nint gcd(int a, int b) { return ((b == 0) ? a : gcd(b, a % b)); }\nstruct DSU {\n  int S;\n  struct node {\n    int parent;\n    long long sum;\n  };\n  vector<node> dsu;\n  DSU(int n) {\n    S = n;\n    for (int i = 0; i < (int)(n); i++) {\n      node tmp;\n      tmp.parent = i;\n      tmp.sum = 1;\n      dsu.push_back(tmp);\n    }\n  }\n  void reset(int n) {\n    dsu.clear();\n    S = n;\n    for (int i = 0; i < (int)(n); i++) {\n      node tmp;\n      tmp.parent = i;\n      tmp.sum = 1;\n      dsu.push_back(tmp);\n    }\n  }\n  int root(int u) {\n    if (dsu[u].parent == u) return u;\n    dsu[u].parent = root(dsu[u].parent);\n    return dsu[u].parent;\n  }\n  void merge(int u, int v) {\n    u = root(u);\n    v = root(v);\n    if (u == v) return;\n    if (getsum(u) < getsum(v)) swap(u, v);\n    dsu[v].parent = u;\n    dsu[u].sum += dsu[v].sum;\n  }\n  bool sameset(int u, int v) {\n    if (root(u) == root(v)) return true;\n    return false;\n  }\n  long long getsum(int u) { return dsu[root(u)].sum; }\n};\nint bad[100005];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  int k;\n  cin >> k;\n  DSU dsu(n);\n  memset(bad, 0, sizeof(bad));\n  for (int i = 0; i < (int)(k); i++) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    dsu.merge(a, b);\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < (int)(m); i++) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    if (dsu.root(u) == dsu.root(v)) bad[dsu.root(u)] = 1;\n  }\n  long long ans = 0;\n  for (int i = 0; i < (int)(n); i++)\n    if (dsu.root(i) == i && !bad[dsu.root(i)]) ans = max(ans, dsu.getsum(i));\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nimport heapq\nimport bisect\nimport math\n\nINF = 10**9+7\nOFFLINE = 0\nN = 101010\nsys.setrecursionlimit(INF)\n\ndef fi():\n\treturn int(sys.stdin.readline())\n\ndef fi2():\n\treturn map(int, sys.stdin.readline().split())\n\ndef fi3():\n\treturn sys.stdin.readline().rstrip()\n\ndef fo(*args):\n\tfor s in args:\n\t\tsys.stdout.write(str(s)+\" \")\n\tsys.stdout.write(\"\\n\")\n\n##\nif OFFLINE:\n\tsys.stdin = open(\"fin.txt\", \"r\")\n\tsys.stdout = open(\"fout.txt\", \"w\")\n##\n\ndef root(x):\n\n\twhile parent[x] != x:\n\t\tparent[x] = parent[parent[x]]\n\t\tx = parent[x]\n\n\treturn x\n\ndef union(x, y):\n\n\tpx = root(x)\n\tpy = root(y)\n\n\tif px == py:\n\t\treturn\n\n\tparent[px] = py\n\tsize[py] += size[px]\n\troots.remove(px)\n\tenemy[py] = enemy[py].union(enemy[px])\n\n\n##main\n\nn = fi()\n\nparent = [i for i in range(n+1)]\nsize = [1 for i in range(n+1)]\nroots = set([i+1 for i in range(n)])\n\nE = []\nenemy = [set() for i in range(n+1)] \n\nk = fi()\n\nfor i in range(k):\n\tu, v = fi2()\n\tunion(u, v)\n\n\nm = fi()\n\nfor i in range(m):\n\tu, v = fi2()\n\n\tif root(u) == root(v):\n\t\tif root(u) in roots:\n\t\t\troots.remove(root(u))\n\n\nans = 0\n\nfor r in roots:\n\tans = max(ans, size[r])\n\nfo(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint q(vector<vector<int> >& a, vector<int>& s, vector<int>& v, int i) {\n  int an = 1;\n  s.push_back(i);\n  v[i] = 1;\n  for (int j = 0; j < a[i].size(); j++)\n    if (v[a[i][j]] == 0) an += q(a, s, v, a[i][j]);\n  return an;\n}\nint main() {\n  int n, f, d;\n  cin >> n >> f;\n  vector<vector<int> > a(n);\n  for (int i = 0; i < f; i++) {\n    int s, e;\n    cin >> s >> e;\n    a[s - 1].push_back(e - 1);\n    a[e - 1].push_back(s - 1);\n  }\n  cin >> d;\n  vector<vector<int> > e(n, vector<int>(n));\n  for (int i = 0; i < d; i++) {\n    int s, ed;\n    cin >> s >> ed;\n    e[s - 1][ed - 1] = e[ed - 1][s - 1] = 1;\n  }\n  vector<int> v(n);\n  int an = 0;\n  for (int i = 0; i < n; i++) {\n    if (v[i] == 1) continue;\n    vector<int> s;\n    int t = q(a, s, v, i), fl = 0;\n    for (int j = 0; j < t; j++) {\n      for (int k = j + 1; k < t; k++) {\n        if (e[s[j]][s[k]]) {\n          fl = 1;\n          break;\n        }\n      }\n      if (fl) break;\n    }\n    if (fl == 0) an = max(an, t);\n  }\n  cout << an << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2050;\nint p1[maxn];\nint find(int x, int *p) { return p[x] == x ? x : p[x] = find(p[x], p); }\nvoid un(int a, int b, int *p) { p[find(a, p)] = find(b, p); }\nbool atOneSet(int a, int b, int *p) { return find(a, p) == find(b, p); }\nset<pair<int, int> > p2;\nint main(void) {\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  for (int i = 0; i < (n); ++i) p1[i] = i;\n  int ct;\n  cin >> ct;\n  while (ct--) {\n    int a, b;\n    cin >> a >> b;\n    --a;\n    --b;\n    un(a, b, p1);\n  }\n  cin >> ct;\n  while (ct--) {\n    int a, b;\n    cin >> a >> b;\n    --a;\n    --b;\n    p2.insert(make_pair(a, b));\n    p2.insert(make_pair(b, a));\n  }\n  set<int> s;\n  map<int, int> mp;\n  for (int i = 0; i < (n); ++i) s.insert(find(i, p1));\n  ct = 0;\n  for (auto it = (s).begin(); it != (s).end(); ++it) mp[*it] = ct++;\n  vector<vector<int> > vec(s.size());\n  for (int i = 0; i < (n); ++i) vec[mp[find(i, p1)]].push_back(i);\n  int ans = 0;\n  for (int i = 0; i < (ct); ++i) {\n    bool tag = true;\n    for (auto a = (vec[i]).begin(); a != (vec[i]).end(); ++a)\n      for (auto b = (vec[i]).begin(); b != (vec[i]).end(); ++b)\n        if (*a != *b) {\n          if (p2.count(make_pair(*a, *b))) tag = false;\n        }\n    if (tag) ans = max(ans, (int)vec[i].size());\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class C implements Runnable{\n    \n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    \n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n    \n    void init() throws FileNotFoundException{\n        if (ONLINE_JUDGE){\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }else{\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        }\n    }\n    \n    String readString() throws IOException{\n        while(!tok.hasMoreTokens()){\n            try{\n                tok = new StringTokenizer(in.readLine());\n            }catch (Exception e){\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n    \n    int readInt() throws IOException{\n        return Integer.parseInt(readString());\n    }\n    \n    long readLong() throws IOException{\n        return Long.parseLong(readString());\n    }\n    \n    double readDouble() throws IOException{\n        return Double.parseDouble(readString());\n    }\n    \n    public static void main(String[] args){\n        new Thread(null, new C(), \"\", 256 * (1L << 20)).start();\n    }\n    \n    long timeBegin, timeEnd;\n\n    void time(){\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n    \n    long memoryTotal, memoryFree;\n    \n\n    void memory(){\n        memoryFree = Runtime.getRuntime().freeMemory();\n        System.err.println(\"Memory = \" + ((memoryTotal - memoryFree) >> 10) + \" KB\");\n    }\n    \n    void debug(Object... objects){\n        if (DEBUG){\n            for (Object o: objects){\n                System.err.println(o.toString());\n            }\n        }\n    }\n    \n    public void run(){\n        try{\n            timeBegin = System.currentTimeMillis();\n            memoryTotal = Runtime.getRuntime().freeMemory();\n            init();\n            solve();\n            out.close();\n            time();\n            memory();\n        }catch (Exception e){\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n    \n    boolean DEBUG = false;\n    \n    int n;\n    ArrayList<Integer>[] graph;\n    \n    boolean[][] bad;\n    \n    boolean[] used;\n    \n    void solve() throws IOException{\n        n = readInt();\n        \n        graph = new ArrayList[n];\n        for (int i = 0; i < n; i++){\n            graph[i] = new ArrayList<Integer>();\n        }\n        \n        int k = readInt();\n        for (int i = 0; i < k; i++){\n            int from = readInt() - 1;\n            int to = readInt() - 1;\n            graph[from].add(to);\n            graph[to].add(from);\n        }\n        \n        bad = new boolean[n][n];\n        int m = readInt();\n        for (int i = 0; i < m; i++){\n            int from = readInt() - 1;\n            int to = readInt() - 1;\n            bad[from][to] = bad[to][from] = true;\n        }\n        \n        used = new boolean[n];\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++){\n            if (!used[i]){\n                ans = max(ans, bfs(i));\n            }\n        }\n        \n        out.print(ans);\n    }\n    \n    int bfs(int begin){\n        ArrayList<Integer> list = new ArrayList<Integer>();\n        list.add(begin);\n        \n        ArrayDeque<Integer> q = new ArrayDeque<Integer>();\n        q.add(begin);\n        used[begin] = true;\n        \n        while (q.size() > 0){\n            int from = q.poll();\n            \n            for (int to: graph[from]){\n                if (!used[to]){\n                    q.add(to);\n                    list.add(to);\n                    used[to] = true;\n                }\n            }\n        }\n        \n        int len = list.size();\n        for (int i = 0; i < len; i++){\n            for (int j = 0; j < len; j++){\n                if (bad[list.get(i)][list.get(j)]) return 0;\n            }\n        }\n        \n        return len;\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class C1 {\n\n    int n;\n    int mp[][];\n    int groups[];\n\n    int join(int a,int b){\n        int pA = getParent(a);\n        int pB = getParent(b);\n        if(pA == pB) return pA;\n        while(groups[a] != a)\n        {\n            b = groups[a];\n            groups[a] = pB;\n            a = b;\n        }\n        return groups[a] = pB;\n    }\n    int getParent(int a){\n        if(groups[a] == a) return a;\n        return groups[a] = getParent(groups[a]);\n    }\n    \n    public void run() {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        mp = new int[n][];\n        groups = new int[n];\n        for (int i = 0; i < n; i++) {\n            mp[i] = new int[n];\n            groups[i] = i;\n            Arrays.fill(mp[i], 0);\n        }\n        int k = sc.nextInt();\n        for (int i = 0; i < k; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            mp[a][b] = mp[b][a] = 1;\n        }\n        int m = sc.nextInt();\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            mp[a][b] = mp[b][a] = -1;\n        }\n        for(int i = 0; i < n; i++)\n            if(getParent(i) == i)\n                go(i,i);\n        HashSet<Integer> conflicts = new HashSet<Integer>();\n        for(int i = 0; i < n; i++)\n            for(int j = i + 1; j < n; j++)\n                if(mp[i][j] == -1 && getParent(i) == getParent(j))\n                    conflicts.add(getParent(i));\n        HashMap<Integer, Integer> groups = new HashMap<Integer, Integer>();\n        for(int i = 0; i < n;i++)\n        {\n            int g = getParent(i);\n            if(conflicts.contains(g)) continue;\n            if(!groups.containsKey(g)) groups.put(g, 1);\n            else groups.put(g, groups.get(g) + 1);\n                \n        }\n        int max = 0;\n        for(Integer c: groups.values())\n            max = (max < c)?c:max;\n        System.out.println(max);    \n    }\n//---\n//  0 1\n//  0 2\n//  1 2\n//  3 4\n//  5 6\n//  6 7\n//  7 8\n//  8 5\n//---\n//  0 5\n//  6 8\n    private void go(int i, int i2) {\n        join(i,i2);\n        for(int k = 0;k < n; k++)\n            if(mp[i][k] == 1 && getParent(i) != getParent(k))\n                go(k,i2);\n    }\n    public static void main(String[] args) throws FileNotFoundException {\n//      System.setIn(new FileInputStream(\"c.in\"));\n        new C1().run();\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nshort fre[2001];\nint main(int argc, const char* argv[]) {\n  int n, k, m;\n  cin >> n;\n  memset(fre, -1, 2001);\n  cin >> k;\n  while (k--) {\n    int i, j;\n    cin >> i >> j;\n    while (fre[j] > 0) {\n      j = fre[j];\n    }\n    while (fre[i] > 0) {\n      i = fre[i];\n    }\n    if (i != j) {\n      fre[j] = i;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    while (fre[fre[i]] > 0) {\n      fre[i] = fre[fre[i]];\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (fre[i] > 0) {\n      fre[fre[i]]--;\n    }\n  }\n  cin >> m;\n  while (m--) {\n    int i, j;\n    cin >> i >> j;\n    if (fre[i] == fre[j]) fre[fre[i]] = 0;\n  }\n  int min = 0;\n  for (int i = 1; i <= n; i++) {\n    if (fre[i] < min) {\n      min = fre[i];\n    }\n  }\n  cout << -min;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstd::vector<vector<int> > g;\nvector<bool> vis;\nvector<bool> fal;\nset<pair<int, int> > mp;\nint cnt = 0;\nvoid edge(int x, int y) {\n  g[x].push_back(y);\n  g[y].push_back(x);\n}\nbool bfs(int s) {\n  queue<int> qt;\n  qt.push(s);\n  vis[s] = true;\n  fal[s] = true;\n  while (!qt.empty()) {\n    int s = qt.front();\n    qt.pop();\n    cnt++;\n    for (auto x : g[s]) {\n      if (!vis[x]) {\n        vis[x] = true;\n        fal[x] = true;\n        qt.push(x);\n      }\n    }\n  }\n  for (auto it = mp.begin(); it != mp.end(); it++) {\n    int y = it->first;\n    int z = it->second;\n    if (fal[y] == true && fal[z] == true) {\n      return false;\n    }\n  }\n  return true;\n}\nint main() {\n  int n;\n  cin >> n;\n  g.assign(n + 1, vector<int>());\n  vis.assign(n + 1, false);\n  int k;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int x, y;\n    cin >> x >> y;\n    edge(x, y);\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    mp.insert(make_pair(x, y));\n  }\n  int mx = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      fal.assign(n + 1, false);\n      bool z = bfs(i);\n      if (z == true) mx = max(mx, cnt);\n      cnt = 0;\n    }\n  }\n  cout << mx << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> p[2010];\nint a[2010][2010], b[2010][2010];\nint vis[2010], n, m;\nvoid dfs(int x, int y) {\n  int i, j, k;\n  for (i = 1; i <= n; i++)\n    if (a[x][i] && vis[i] == 0) {\n      vis[i] = y;\n      dfs(i, y);\n    }\n}\nint main() {\n  int i, j, k, x, y, ans, flag, s;\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= m; i++) {\n    scanf(\"%d%d\", &x, &y);\n    a[x][y] = a[y][x] = 1;\n  }\n  scanf(\"%d\", &m);\n  for (i = 1; i <= m; i++) {\n    scanf(\"%d%d\", &x, &y);\n    b[x][y] = b[y][x] = 1;\n  }\n  memset(vis, 0, sizeof(vis));\n  k = 1;\n  for (i = 1; i <= n; i++) {\n    if (vis[i]) continue;\n    vis[i] = k;\n    dfs(i, k);\n    k++;\n  }\n  ans = 0;\n  for (i = 1; i <= n; i++) p[vis[i]].push_back(i);\n  for (i = 1; i < k; i++) {\n    j = p[i].size();\n    flag = 1;\n    for (x = 0; x < j; x++) {\n      for (y = x + 1; y < j; y++)\n        if (b[p[i][x]][p[i][y]]) {\n          flag = 0;\n          break;\n        }\n      if (flag == 0) break;\n    }\n    if (flag) ans = max(ans, j);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> grafo[2000];\nset<int> nemici[2000];\nint rapp[2000];\nlist<int> liste[2000];\nint N, k, m, maxi = 0;\nint main(void) {\n  cin >> N;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int da, a;\n    cin >> da >> a;\n    da--;\n    a--;\n    grafo[da].push_back(a);\n    grafo[a].push_back(da);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int da, a;\n    cin >> da >> a;\n    da--;\n    a--;\n    nemici[da].insert(a);\n    nemici[a].insert(da);\n  }\n  for (int i = 0; i < N; i++) {\n    rapp[i] = i;\n    liste[i].push_back(i);\n  }\n  for (int i = 0; i < N; i++)\n    for (int k = 0; k < grafo[i].size(); k++) {\n      int a = grafo[i][k];\n      if (rapp[i] != rapp[a]) {\n        int rpicc, rgrand;\n        if (liste[rapp[i]].size() <= liste[rapp[a]].size()) {\n          rpicc = rapp[i];\n          rgrand = rapp[a];\n        } else {\n          rpicc = rapp[a];\n          rgrand = rapp[i];\n        }\n        for (list<int>::iterator it = liste[rpicc].begin();\n             it != liste[rpicc].end(); it++)\n          rapp[*it] = rgrand;\n        liste[rgrand].merge(liste[rpicc]);\n      }\n    }\n  for (int i = 0; i < N; i++) {\n    if (liste[i].size() > maxi) {\n      for (list<int>::iterator it = liste[i].begin(); it != liste[i].end();\n           it++)\n        for (list<int>::iterator sec = it; sec != liste[i].end(); sec++)\n          if (*it != *sec && nemici[*it].find(*sec) != nemici[*it].end())\n            goto next;\n      maxi = max(maxi, (int)liste[i].size());\n    }\n  next:;\n  }\n  cout << maxi;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class PartyC1 {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n\n    void solve() throws IOException {\n        int n= ni();\n        ArrayList<ArrayList<Integer>> list= new ArrayList<>();\n        for (int i = 0; i <=n; i++)\n            list.add(new ArrayList<>());\n\n        int m= ni();\n        for (int i = 0; i < m; i++)\n        {\n            int from= ni(), to= ni();\n            list.get(from).add(to);\n            list.get(to).add(from);\n        }\n\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<>();\n        m= ni();\n        for (int i = 0; i <m; i++)\n        {\n            int from= ni(), to= ni();\n            if(map.containsKey(from))\n                map.get(from).add(to);\n            else\n                map.put(from, new HashSet<>(Arrays.asList(to)));\n\n            if(map.containsKey(to))\n                map.get(to).add(from);\n            else\n                map.put(to, new HashSet<>(Arrays.asList(from)));\n        }\n\n        int ans=0;\n        boolean[] visited= new boolean[n+1];\n        for(int i=1;i<=n;i++)\n        {\n            if(visited[i]) continue;\n            HashSet<Integer> nodes= new HashSet<>();\n            DFSREC(list, visited, i, nodes);\n\n            boolean bool= true;\n            outer: for(int node: nodes)\n            {\n                HashSet<Integer> temp= map.getOrDefault(node, new HashSet<>());\n                for(int find: nodes)\n                    if(temp.contains(find))\n                    {\n                        bool= false;\n                        break outer;\n                    }\n            }\n\n            if(bool)\n            {\n                ans= Math.max(ans, nodes.size());\n                //out.println(nodes);\n            }\n        }\n\n        out.println(ans);\n    }\n\n    private void DFSREC(ArrayList<ArrayList<Integer>> list, boolean[] visited, int curr, HashSet<Integer> nodes) {\n        visited[curr]= true;\n        nodes.add(curr);\n\n        for(int i: list.get(curr))\n        {\n            if(visited[i]) continue;\n            DFSREC(list, visited, i, nodes);\n        }\n    }\n\n    void run() throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n\n        solve();\n        out.flush();\n    }\n\n    public static void main(String[] args) throws Exception {\n        new PartyC1().run();\n    }\n\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b)) ;\n        return b;\n    }\n\n    private double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    private char nc() {\n        return (char) skip();\n    }\n\n    private String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    private int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private void tr(Object... o) {\n        if (INPUT.length() > 0) System.out.println(Arrays.deepToString(o));\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "\timport java.io.BufferedWriter;\n\timport java.io.IOException;\n\timport java.io.InputStream;\n\timport java.io.OutputStream;\n\timport java.io.OutputStreamWriter;\n\timport java.io.PrintWriter;\n\timport java.io.Writer;\n\timport java.util.Arrays;\n\timport java.util.InputMismatchException;\n\timport java.util.*;\n\timport java.io.*;\n\timport java.math.*;\n\tpublic class Main7{\n\n\tstatic class Pair\n\t\t{ \n\t\t\tint x; \n\t\t\tint y;\n\t\t\tpublic Pair(int x, int y) \n\t\t\t{\t \n\t\t\t\tthis.x = x; \n\t\t\t\tthis.y = y; \n\t\t\t}\t \n\t\t} \n\t\tstatic class Compare\n\t\t{ \n\t\t\tstatic void compare(Pair arr[], int n) \n\t\t\t{ \n\t\t\t\t// Comparator to sort the pair according to second element \n\t\t\t\tArrays.sort(arr, new Comparator<Pair>() { \n\t\t\t\t\t@Override public int compare(Pair p1, Pair p2) \n\t\t\t\t\t{ \n\t\t\t\t\t\tif(p1.x>p2.x)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(p2.x>p1.x)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(p1.y>p2.y)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(p1.y<p2.y)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t} \n\t\t\t\t\t} \n\t\t\t\t}); \n\t\t\t} \n\t\t}\n\t\tpublic static long pow(long a, long b)\n\t\t{\n\t\t\tlong result=1;\n\t\t\twhile(b>0)\n\t\t\t{\n\t\t\t\tif (b % 2 != 0)\n\t\t\t\t{\n\t\t\t\t\tresult=(result*a)%mod;\n\t\t\t\t\tb--;\n\t\t\t\t} \n\t\t\t\ta=(a*a)%mod;\n\t\t\t\tb /= 2;\n\t\t\t}   \n\t\t\treturn result;\n\t\t}\n\t\tpublic static long fact(long num)\n\t\t{\n\t\t\t\t\tlong value=1;\n\t\t\t\t\tint i=0;\n\t\t\t\t\tfor(i=2;i<num;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue=((value%mod)*i%mod)%mod;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tpublic static int gcd(int a, int b)\n\t\t\t\t{\n\t\t\t\t\tif (a == 0)\n\t\t\t\t\t\treturn b;\n\t\t\t\t\treturn gcd(b%a, a);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic static long lcm(int a,int b)\n\t\t\t\t{\n\t\t\t\t\treturn a * (b / gcd(a, b));\n\t\t\t\t}\n\t\t\t\tpublic static long sum(int h)\n\t\t\t\t{\n\t\t\t\t\treturn (h*(h+1)/2);\n\t\t\t\t}\n\t\t\t\tpublic static void dfs(int parent,boolean[] visited)\n\t\t\t\t{\n\t\t\t\t\tArrayList<Integer> arr=new ArrayList<Integer>();\n\t\t\t\t\tarr=graph.get(parent);\n\t\t\t\t\tvisited[parent]=true;\n\t\t\t\t\tfor(int i=0;i<arr.size();i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint num=arr.get(i);\n\t\t\t\t\t\tif(visited[num]==false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdfs(num,visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tstatic int[] bache;\n\t\t\t\tstatic ArrayList<Integer> ar3;\n\t\t\t\tstatic long mod=1000000007L;\n\t\t\t\tstatic ArrayList<ArrayList<Integer>> graph;\n\t\t\t\tpublic static void bfs(int num,boolean[] visited)\n\t\t\t\t{\n\t\t\t\t\tQueue<Integer> q=new LinkedList<>();\n\t\t\t\t\tq.add(num);\n\t\t\t\t\tvisited[num]=true;\n\t\t\t\t\tdis[num]=0;\n\t\t\t\t\twhile(!q.isEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tint x=q.poll();\n\t\t\t\t\t\tArrayList<Integer> al=graph.get(x);\n\t\t\t\t\t\tfor(int i=0;i<al.size();i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint y=al.get(i);\n\t\t\t\t\t\t\tif(visited[y]==false)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\t\t\t\tq.add(y);\n\t\t\t\t\t\t\t\tvisited[y]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatic int[] dis;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tpublic static void main(String args[])throws IOException\n\t\t\t\t{\n\t\t\t\t//\tInputReader in=new InputReader(System.in);\n\t\t\t\t//\tOutputWriter out=new OutputWriter(System.out);\n\t\t\t\t//\tlong a=pow(26,1000000005);\n\t\t\t\t    BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\t\tArrayList<Integer> ar=new ArrayList<>();\n\t\t\t\t\tArrayList<Integer> ar1=new ArrayList<>();\n\t\t\t\t\tArrayList<Integer> ar2=new ArrayList<>();\n\t\t\t//\t\tArrayList<Integer> ar3=new ArrayList<>();\n\t\t\t\t\tArrayList<Integer> ar4=new ArrayList<>();\n\t\t\t\t\tTreeSet<Integer> ts1=new TreeSet<>();\n\t\t\t\t\tTreeSet<String> pre=new TreeSet<>();\n\t\t\t\t//\tHashMap<Long,Long> hash=new HashMap<>();\n\t\t\t\t\t//HashMap<Long,Integer> hash1=new HashMap<Long,Integer>();\n\t\t\t\t\tHashMap<Integer,Integer> hash2=new HashMap<Integer,Integer>();\n\t\t\t\t/*\tboolean[] prime=new boolean[10001];\n\t\t\t\t\tfor(int i=2;i*i<=10000;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(prime[i]==false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int j=2*i;j<=10000;j+=i)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprime[j]=true;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}*/\n\t\t\t\t\tint n=i();\n\t\t\t\t\tint k=i();\n\t\t\t\t\tint[] a=new int[k];\n\t\t\t\t\tint[] b=new int[k];\n\t\t\t\t\tgraph=new ArrayList<>();\n\t\t\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tgraph.add(new ArrayList<>());\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<k;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i]=i()-1;\n\t\t\t\t\t\tb[i]=i()-1;\n\t\t\t\t\t\tgraph.get(a[i]).add(b[i]);\n\t\t\t\t\t\tgraph.get(b[i]).add(a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tint m=i();\n\t\t\t\t\tint[] x=new int[m];\n\t\t\t\t\tint[] y=new int[m];\n\t\t\t\t\tHashMap<Integer,HashMap<Integer,Integer>> hash=new HashMap<>();\n\t\t\t\t\tfor(int i=0;i<m;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tx[i]=i()-1;\n\t\t\t\t\t\ty[i]=i()-1;\n\t\t\t\t\t\tif(hash.containsKey(x[i])==false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHashMap<Integer,Integer> hlo=new HashMap<>();\n\t\t\t\t\t\t\thlo.put(y[i],1);\n\t\t\t\t\t\t\thash.put(x[i],hlo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHashMap<Integer,Integer> hlo=hash.get(x[i]);\n\t\t\t\t\t\t\thlo.put(y[i],1);\n\t\t\t\t\t\t\thash.put(x[i],hlo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(hash.containsKey(y[i])==false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHashMap<Integer,Integer> hlo=new HashMap<>();\n\t\t\t\t\t\t\thlo.put(x[i],1);\n\t\t\t\t\t\t\thash.put(y[i],hlo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHashMap<Integer,Integer> hlo=hash.get(y[i]);\n\t\t\t\t\t\t\thlo.put(x[i],1);\n\t\t\t\t\t\t\thash.put(y[i],hlo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint ans=0,flag=0,max=0;\n\t\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tboolean[] visited=new boolean[n];\n\t\t\t\t\t\tdfs(i,visited);\n\t\t\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(visited[j]==true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(hash.containsKey(j))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tHashMap<Integer,Integer> hi=hash.get(j);\n\t\t\t\t\t\t\t\t\tfor (Map.Entry<Integer,Integer> entry : hi.entrySet())\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif(visited[(int)entry.getKey()]==true)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tflag=1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(visited[j]==true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag!=1)\n\t\t\t\t\t\t\tmax=Math.max(ans,max);\n\t\t\t\t\t\tans=0;\n\t\t\t\t\t\tflag=0;\n\t\t\t\t\t}\n\t\t\t\t\tpln(max+\"\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t \n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/**/\n\t\t\t\tstatic InputReader in=new InputReader(System.in);\n\t\t\t\t\tstatic OutputWriter out=new OutputWriter(System.out);\n\t\t\t\t\tpublic static long l()\n\t\t\t\t\t{\n\t\t\t\t\t\tString s=in.String();\n\t\t\t\t\t\treturn Long.parseLong(s);\n\t\t\t\t\t}\n\t\t\t\t\tpublic static void pln(String value)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(value);\n\t\t\t\t\t}\n\t\t\t\t\tpublic static int i()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn in.Int();\n\t\t\t\t\t}\n\t\t\t\t\tpublic static String s()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn in.String();\n\t\t\t\t\t}\n\t\t}\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tclass InputReader {\n\t\t\t\t \n\t\t\t\tprivate InputStream stream;\n\t\t\t\tprivate byte[] buf = new byte[1024];\n\t\t\t\tprivate int curChar;\n\t\t\t\tprivate int numChars;\n\t\t\t\tprivate SpaceCharFilter filter;\n\t\t\t \n\t\t\t\tpublic InputReader(InputStream stream) {\n\t\t\t\t\tthis.stream = stream;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic int read() {\n\t\t\t\t\tif (numChars== -1)\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tif (curChar >= numChars) {\n\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (numChars <= 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic int Int() {\n\t\t\t\t\tint c = read();\n\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\tc = read();\n\t\t\t\t\tint sgn = 1;\n\t\t\t\t\tif (c == '-') {\n\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\tc = read();\n\t\t\t\t\t}\n\t\t\t\t\tint res = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\tc = read();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res * sgn;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic String String() {\n\t\t\t\t\tint c = read();\n\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\tc = read();\n\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\tdo {\n\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\tc = read();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res.toString();\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic boolean isSpaceChar(int c) {\n\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic String next() {\n\t\t\t\t\treturn String();\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic interface SpaceCharFilter {\n\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tclass OutputWriter {\n\t\t\t\tprivate final PrintWriter writer;\n\t\t\t \n\t\t\t\tpublic OutputWriter(OutputStream outputStream) {\n\t\t\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic OutputWriter(Writer writer) {\n\t\t\t\t\tthis.writer = new PrintWriter(writer);\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic void print(Object...objects) {\n\t\t\t\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\t\t\t\tif (i != 0)\n\t\t\t\t\t\t\twriter.print(' ');\n\t\t\t\t\t\twriter.print(objects[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic void printLine(Object...objects) {\n\t\t\t\t\tprint(objects);\n\t\t\t\t\twriter.println();\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic void close() {\n\t\t\t\t\twriter.close();\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic void flush() {\n\t\t\t\t\twriter.flush();\n\t\t\t\t}\n\t\t\t \n\t\t\t\t}\n\t\t\t \n\t\t\t\tclass IOUtils {\n\t\t\t \n\t\t\t\tpublic static int[] readIntArray(InputReader in, int size) {\n\t\t\t\t\tint[] array = new int[size];\n\t\t\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\t\t\tarray[i] = in.Int();\n\t\t\t\t\treturn array;\n\t\t\t\t}\n\t\t\t \n\t\t\t\t} "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2002;\nint N, M, res, c;\nint gr[MAXN];\nint cnt[MAXN];\nbool forb[MAXN];\nvector<int> g[MAXN];\nvoid dfs(int nd) {\n  cnt[c]++;\n  gr[nd] = c;\n  for (vector<int>::iterator it = g[nd].begin(); it != g[nd].end(); it++)\n    if (!gr[*it]) dfs(*it);\n}\nint main() {\n  scanf(\" %d %d\", &N, &M);\n  for (int a, b, i = 0; i < M; i++) {\n    scanf(\" %d %d\", &a, &b);\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  for (int i = 1; i <= N; i++)\n    if (!gr[i]) {\n      c++;\n      dfs(i);\n    }\n  scanf(\" %d\", &M);\n  for (int a, b, i = 0; i < M; i++) {\n    scanf(\" %d %d\", &a, &b);\n    if (gr[a] == gr[b]) forb[gr[a]] = 1;\n  }\n  for (int i = 1; i <= c; i++)\n    if (!forb[i]) res = max(res, cnt[i]);\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> tree[2], siz[2];\nvoid ini(long long n) {\n  tree[0].resize(n + 1);\n  tree[1].resize(n + 1);\n  siz[0].resize(n + 1);\n  siz[1].resize(n + 1);\n  for (long long i = 1; i <= n; i++) {\n    tree[0][i] = i;\n    tree[1][i] = i;\n    siz[0][i] = 1;\n    siz[1][i] = 1;\n  }\n}\nlong long root(long long n, long long f) {\n  while (tree[f][n] != n) {\n    tree[f][n] = tree[f][tree[f][n]];\n    n = tree[f][n];\n  }\n  return n;\n}\nvoid uni(long long a, long long b, long long f) {\n  a = root(a, f);\n  b = root(b, f);\n  if (siz[f][a] < siz[f][b]) {\n    siz[f][b] += siz[f][a];\n    tree[f][a] = tree[f][b];\n  } else {\n    siz[f][a] += siz[f][b];\n    tree[f][b] = tree[f][a];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  srand(time(NULL));\n  ;\n  long long n;\n  cin >> n;\n  ini(n);\n  vector<pair<long long, long long> > a, b;\n  long long k;\n  cin >> k;\n  for (long long i = 0; i < k; i++) {\n    long long t, tt;\n    cin >> t >> tt;\n    a.push_back(make_pair(t, tt));\n  }\n  cin >> k;\n  for (long long i = 0; i < k; i++) {\n    long long tt, t;\n    cin >> t >> tt;\n    b.push_back(make_pair(t, tt));\n  }\n  for (long long i = 0; i < a.size(); i++) {\n    if (root(a[i].first, 0) != root(a[i].second, 0)) {\n      uni(a[i].first, a[i].second, 0);\n    }\n  }\n  for (long long i = 0; i < b.size(); i++) {\n    if (root(b[i].second, 0) == root(b[i].first, 0)) {\n      siz[0][root(b[i].second, 0)] = 0;\n    }\n  }\n  long long mx = 0;\n  for (long long i = 1; i <= n; i++) {\n    mx = max(mx, siz[0][root(i, 0)]);\n  }\n  cout << mx << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\n/**\n * @Author Mikhail Linkov\n * Date: 21.04.12\n */\npublic class ProblemC {\n    private static int [][] matrix;\n    private static int [] comp;\n    private static int count = 0;\n    private static int compNum;\n    private static int flag;\n\n    private static void dfs(int vertex) {\n        count++;\n        comp[vertex] = compNum;\n\n        for (int i = 0; i < comp.length; i++) {\n            if (matrix[vertex][i] == 1) {\n                if (comp[i] == -1) {\n                    dfs(i);\n                }\n            }\n            if (matrix[vertex][i] == 2) {\n                if (comp[i] == comp[vertex]) {\n                    flag = 1;\n                }\n            }\n        }\n    }\n\n    public static void main(String [] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int vertexCount = scanner.nextInt();\n\n        int friendPairsCount = scanner.nextInt();\n\n        matrix = new int[vertexCount][vertexCount];\n        comp = new int[vertexCount];\n        compNum = 0;\n\n        for (int i = 0; i < vertexCount; i++) {\n            comp[i] = -1;\n        }\n\n        for (int i = 0; i < friendPairsCount; i++) {\n            int a = scanner.nextInt() - 1;\n            int b = scanner.nextInt() - 1;\n\n            matrix[a][b] = 1;\n            matrix[b][a] = 1;\n        }\n\n        int unFriendPairsCount = scanner.nextInt();\n\n        for (int i = 0; i < unFriendPairsCount; i++) {\n            int a = scanner.nextInt() - 1;\n            int b = scanner.nextInt() - 1;\n\n            matrix[a][b] = 2;\n            matrix[b][a] = 2;\n        }\n\n        int answer = 0;\n\n        for (int i = 0; i < vertexCount; i++) {\n            if (comp[i] == -1) {\n                compNum++;\n                flag = 0;\n                count = 0;\n                dfs(i);\n                if (flag == 0) {\n                    if (answer < count) {\n                        answer = count;\n                    }\n                }\n            }\n        }\n\n        System.out.println(answer);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nlong long T, n, m, k, x, y, z, l, r, d, ans, a[N], b[N], c[N], mod = 1e9 + 7;\nint find(int i) { return (a[i] == i ? i : (a[i] = find(a[i]))); }\nvoid solve() {\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) a[i] = i;\n  for (long long i = 1; i <= m; i++) cin >> x >> y, a[find(x)] = find(y);\n  cin >> m;\n  for (long long i = 1; i <= m; i++) {\n    cin >> x >> y;\n    if (a[find(x)] == find(y)) b[find(x)] = -1;\n  }\n  for (int i = 1; i <= n; i++) c[find(i)]++;\n  for (int i = 1; i <= n; i++)\n    if (b[find(i)] != -1) ans = max(ans, c[find(i)]);\n  cout << ans;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass unionfind {\n public:\n  vector<int> a, size;\n\n public:\n  int comp;\n\n public:\n  void setsize(int n) {\n    comp = n;\n    for (int i = 0; i < n; i++) {\n      a.push_back(i);\n      size.push_back(1);\n    }\n  }\n\n public:\n  void refresh() {\n    a.clear();\n    size.clear();\n    comp = 0;\n  }\n\n public:\n  int root(int i) { return (a[i] == i) ? i : (a[i] = root(a[i])); }\n\n public:\n  bool find(int n1, int n2) { return (root(n1) == root(n2)); }\n\n public:\n  void uni(int n1, int n2) {\n    int r1 = root(n1);\n    int r2 = root(n2);\n    if (r1 == r2) return;\n    if (size[r1] < size[r2]) {\n      a[r1] = r2;\n      size[r2] += size[r1];\n    } else {\n      a[r2] = r1;\n      size[r1] += size[r2];\n    }\n    comp--;\n  }\n};\nint dx[] = {-1, 1, 0, 0, 0, 0, 0, 0};\nint dy[] = {0, 0, 1, -1, 0, 0, 0, 0};\nconst int inf = 1000000000;\nconst int seivesize = 10005;\nconst double eps = 0.000000009;\nint main() {\n  int n;\n  cin >> n;\n  int m1, m2;\n  cin >> m1;\n  unionfind ob;\n  ob.setsize(n);\n  for (int i = 0; i < m1; i++) {\n    int t1, t2;\n    cin >> t1 >> t2;\n    t1--;\n    t2--;\n    ob.uni(t1, t2);\n  }\n  cin >> m2;\n  for (int i = 0; i < m2; i++) {\n    int t1, t2;\n    cin >> t1 >> t2;\n    t1--;\n    t2--;\n    if (ob.find(t1, t2)) {\n      ob.size[ob.root(t1)] = -1;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    ans = max(ans, ob.size[ob.root(i)]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m;\nvector<pair<int, int> > fr, en;\nint v, u;\nint cnt[2100], dead[2100];\nclass dsu {\n public:\n  int p[2100];\n  dsu() {\n    for (int i = 0; i < 2100; i++) {\n      p[i] = i;\n    }\n  }\n  int getset(int v) {\n    if (p[v] == v) return v;\n    return p[v] = getset(p[v]);\n  }\n  void unionsets(int a, int b) {\n    a = getset(a);\n    b = getset(b);\n    if (rand() % 2) {\n      p[a] = b;\n    } else {\n      p[b] = a;\n    }\n  }\n};\nint main() {\n  cin >> n;\n  dsu d;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    scanf(\"%d%d\", &v, &u);\n    v--, u--;\n    fr.push_back(make_pair(v, u));\n    d.unionsets(v, u);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &v, &u);\n    v--, u--;\n    en.push_back(make_pair(v, u));\n    if (d.getset(v) == d.getset(u)) {\n      dead[d.getset(v)] = 1;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    cnt[d.getset(i)]++;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (!dead[i]) ans = max(ans, cnt[i]);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 2e9 + 3;\nconst int N = 2e3 + 3;\nconst int MOD = 1e9 + 7;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\nvector<int> gr[N];\nchar used[N];\nbool enemies[N][N];\nvector<int> comp;\nvoid dfs(int cur) {\n  used[cur] = 1;\n  for (int v : gr[cur]) {\n    if (!used[v]) dfs(v);\n  }\n  comp.push_back(cur);\n}\nint check() {\n  for (int x : comp) {\n    for (int y : comp) {\n      if (x != y && enemies[x][y]) return 0;\n    }\n  }\n  return comp.size();\n}\nvoid solve() {\n  int n, k, m;\n  cin >> n >> k;\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    gr[a].push_back(b);\n    gr[b].push_back(a);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    enemies[a][b] = enemies[b][a] = 1;\n  }\n  int ans = 0;\n  for (int v = 1; v <= n; v++) {\n    if (!used[v]) {\n      comp.clear();\n      dfs(v);\n      ans = max(ans, check());\n    }\n  }\n  cout << ans;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  int t;\n  t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4444;\nconst int M = 444444;\nint ev[M], nxt[M], head[N];\nint dfn[N], low[N], stk[N], id[N], sum[N];\nint scc, top, idx, e;\nbool use[N];\nvoid init() {\n  memset(head, -1, sizeof(head));\n  memset(dfn, 0, sizeof(dfn));\n  memset(sum, 0, sizeof(sum));\n  memset(use, 0, sizeof(use));\n  scc = top = idx = e = 0;\n}\nvoid addedge(int u, int v) {\n  ev[e] = v;\n  nxt[e] = head[u];\n  head[u] = e++;\n}\nvoid tarjan(int u) {\n  int i, v;\n  dfn[u] = low[u] = ++idx;\n  use[u] = 1;\n  stk[++top] = u;\n  for (i = head[u]; ~i; i = nxt[i]) {\n    v = ev[i];\n    if (!dfn[v])\n      tarjan(v), low[u] = min(low[u], low[v]);\n    else if (use[v])\n      low[u] = min(low[u], low[v]);\n  }\n  if (dfn[u] == low[u]) {\n    do {\n      v = stk[top--];\n      use[v] = 0;\n      id[v] = scc;\n      sum[scc]++;\n    } while (v != u);\n    scc++;\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  int k;\n  cin >> k;\n  init();\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    addedge(u, v);\n    addedge(v, u);\n  }\n  for (int i = 1; i <= n; i++)\n    if (!dfn[i]) tarjan(i);\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    if (id[u] == id[v]) sum[id[u]] = 0;\n  }\n  int ans = 0;\n  for (int i = 0; i < scc; i++) ans = max(ans, sum[i]);\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int x;\n  node *next;\n};\nint visit[2005];\nnode *li[100005];\nint ans[2005];\nnode *new_node() {\n  static node t[100005];\n  static int top = 0;\n  t[top].x = 0;\n  t[top].next = 0;\n  return &t[top++];\n}\nint insertedge(int x, int y) {\n  node *t = new_node();\n  t->x = y;\n  t->next = li[x];\n  li[x] = t;\n  node *t2 = new_node();\n  t2->x = x;\n  t2->next = li[y];\n  li[y] = t2;\n  return 0;\n}\nint dfs(int now, int temp) {\n  if (visit[now] != 0) return 0;\n  visit[now] = temp;\n  node *x;\n  int sum = 0;\n  for (x = li[now]; x != 0; x = x->next) {\n    sum += dfs(x->x, temp);\n  }\n  return sum + 1;\n}\nint main() {\n  memset(li, 0, sizeof(li));\n  int n;\n  int i;\n  int k, m;\n  int x, y;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  for (i = 1; i <= k; i++) {\n    scanf(\"%d%d\", &x, &y);\n    insertedge(x, y);\n  }\n  scanf(\"%d\", &m);\n  int ma = 0;\n  memset(visit, 0, sizeof(visit));\n  for (i = 1; i <= n; i++) {\n    ans[i] = dfs(i, i);\n  }\n  for (i = 1; i <= m; i++) {\n    scanf(\"%d%d\", &x, &y);\n    if (visit[x] == visit[y]) ans[visit[x]] = 0;\n  }\n  for (i = 1; i <= n; i++) {\n    ma = max(ma, ans[i]);\n  }\n  printf(\"%d\\n\", ma);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k;\nbool flag[2003];\nint pred[2003];\nint size[2003];\nint findset(int v) {\n  if (v == pred[v]) return v;\n  return pred[v] = findset(pred[v]);\n}\nvoid makeset(int v) {\n  size[v] = 1;\n  pred[v] = v;\n}\nvoid uniset(int a, int b) {\n  int x = findset(a);\n  int y = findset(b);\n  if (x != y) {\n    if (size[x] >= size[y]) {\n      size[x] += size[y];\n      pred[y] = x;\n    } else {\n      size[y] += size[x];\n      pred[x] = y;\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  int i;\n  int x, y;\n  for (i = 0; i < n; i++) makeset(i);\n  for (i = 0; i < k; i++) {\n    scanf(\"%d %d\", &x, &y);\n    x--;\n    y--;\n    uniset(x, y);\n  }\n  scanf(\"%d\", &m);\n  for (i = 0; i < m; i++) {\n    scanf(\"%d %d\", &x, &y);\n    x--;\n    y--;\n    x = findset(x);\n    y = findset(y);\n    if (x == y) flag[x] = true;\n  }\n  int ans = 0;\n  for (i = 0; i < n; i++) {\n    x = findset(i);\n    if (!flag[x]) ans = max(ans, size[x]);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint arr[100001];\nint siz[100001];\nint root(int i) {\n  while (arr[i] != i) {\n    arr[i] = arr[arr[i]];\n    i = arr[i];\n  }\n  return i;\n}\nvoid we_uni(int a, int b) {\n  int ra = root(a);\n  int rb = root(b);\n  if (siz[ra] < siz[rb]) {\n    arr[ra] = rb;\n    siz[rb] += siz[ra];\n  } else {\n    arr[rb] = ra;\n    siz[ra] += siz[rb];\n  }\n}\nbool fin(int a, int b) {\n  if (root(a) == root(b))\n    return 1;\n  else\n    return 0;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    arr[i] = i;\n    siz[i] = 1;\n  }\n  set<int> s;\n  for (int i = 1; i <= n; i++) s.insert(i);\n  while (k--) {\n    int x, y;\n    cin >> x >> y;\n    if (fin(x, y)) continue;\n    s.erase(root(x));\n    s.erase(root(y));\n    we_uni(x, y);\n    s.insert(root(x));\n  }\n  int m;\n  cin >> m;\n  while (m--) {\n    int x, y;\n    cin >> x >> y;\n    if (fin(x, y)) s.erase(root(x));\n  }\n  set<int>::iterator itr;\n  int maxi = 0;\n  for (itr = s.begin(); itr != s.end(); ++itr) maxi = max(maxi, siz[*itr]);\n  cout << maxi;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass vertex {\n public:\n  bool mark;\n  int comp;\n  vector<pair<int, bool>> to;\n};\nint n, k, m;\nvertex f[2000];\nint sz[2000];\nint counter = 1;\nint maxInv = 0;\nbool checkComponentX(int c) {\n  bool good = true;\n  for_each(f + 1, f + n + 1, [&good, c](vertex v) mutable {\n    bool x = true;\n    if (v.comp == c) {\n      for_each(v.to.begin(), v.to.end(), [&x, c](pair<int, bool> w) mutable {\n        x = f[w.first].comp == c && w.second == 0 ? 0 : x;\n      });\n    }\n    if (x == false) good = false;\n  });\n  return good;\n}\nbool checkComponent(int c) {\n  for (int i = 1; i <= n; i++) {\n    if (f[i].comp == c) {\n      for (int j = 0; j < f[i].to.size(); j++) {\n        if (f[f[i].to[j].first].comp == c && f[i].to[j].second == false)\n          return false;\n      }\n    }\n  }\n  return true;\n}\nvoid dfs(int v) {\n  f[v].mark = true;\n  f[v].comp = counter;\n  sz[counter]++;\n  for (auto w : f[v].to) {\n    if (w.second == 1 && f[w.first].mark == false) {\n      dfs(w.first);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> n >> k;\n  int a, b;\n  for (int i = 0; i <= k - 1; i++) {\n    cin >> a >> b;\n    f[a].to.push_back({b, 1});\n    f[b].to.push_back({a, 1});\n  }\n  cin >> m;\n  for (int i = 0; i <= m - 1; i++) {\n    cin >> a >> b;\n    f[a].to.push_back({b, 0});\n    f[b].to.push_back({a, 0});\n  }\n  for (int i = 1; i <= n; i++) {\n    if (f[i].mark == false) {\n      dfs(i);\n      counter++;\n    }\n  }\n  int compN = counter - 1;\n  for (int i = 1; i <= compN; i++) {\n    if (checkComponentX(i)) {\n      if (sz[i] > maxInv) maxInv = sz[i];\n    }\n  }\n  cout << maxInv;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 20202;\nvector<int> adj[N];\nbool vis[N];\nvector<int> component;\nint n, k, m, ans;\nset<pair<int, int> > noFriend;\nvoid dfs(int node) {\n  vis[node] = 1;\n  component.push_back(node);\n  for (auto v : adj[node]) {\n    if (!vis[v]) dfs(v);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> k;\n  for (int i = 1; i <= k; i++) {\n    int x, y;\n    cin >> x >> y;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  memset(vis, 0, sizeof vis);\n  cin >> m;\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    cin >> x >> y;\n    noFriend.insert({x, y});\n    noFriend.insert({y, x});\n  }\n  for (int k = 1; k <= n; k++) {\n    component.clear();\n    if (!vis[k]) dfs(k);\n    bool f = 1;\n    for (int i = 0; i < component.size(); i++) {\n      for (int j = i + 1; j < component.size(); j++) {\n        pair<int, int> t = {component[i], component[j]};\n        if (noFriend.count(t) > 0) {\n          f = false;\n          break;\n        }\n      }\n    }\n    if (f && component.size() >= ans) {\n      ans = component.size();\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e3 + 10, big = 1e18, mod = 1e9 + 7;\nvector<long long> a[N], now, ans;\nlong long n, x, y, m, maxi;\nbool vis[N], mp[N][N];\nvoid dfs(long long i) {\n  vis[i] = 1, now.push_back(i);\n  for (int j = 0; j < a[i].size(); j++)\n    if (!vis[a[i][j]]) dfs(a[i][j]);\n}\nint main() {\n  cin >> n;\n  cin >> m;\n  while (m--) {\n    cin >> x >> y;\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  cin >> m;\n  while (m--) {\n    cin >> x >> y;\n    mp[x][y] = mp[y][x] = 1;\n  }\n  for (int i = 1; i <= n; i++)\n    if (!vis[i]) {\n      now.clear();\n      dfs(i);\n      bool check = 1;\n      if (now.size() == 1)\n        maxi = max(1LL, maxi);\n      else {\n        for (int j = 0; j < now.size() - 1; j++)\n          for (int k = j + 1; k < now.size(); k++)\n            if (mp[now[j]][now[k]]) check = 0;\n        if (check) maxi = max((long long)now.size(), maxi);\n      }\n    }\n  cout << maxi;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nimport math\nint_ = lambda x: int(x)-1\nn = int(sys.stdin.readline())\np = [-1]*n\n#p[0]=-1\nk = int(sys.stdin.readline())\ngroups = []\nfor i in xrange(k):\n    p1, p2 = map(int_, sys.stdin.readline().split())\n    if p[p1] == p[p2] == -1:\n        #new group\n        grp_ind = len(groups)\n        groups.append([p1,p2])\n        p[p1] = grp_ind\n        p[p2] = grp_ind\n    elif p[p1] == -1:\n        #move first to group of 2\n        p[p1] = p[p2]\n        groups[p[p2]].append(p1)\n    elif p[p2] == -1:\n        p[p2] = p[p1]\n        groups[p[p1]].append(p2)\n    else:\n        #in dif groups, together!\n        #from second group to first group\n        for ind in xrange(len(p)):\n            del_grp = p[p2]\n            if p[ind] == del_grp:\n                groups[del_grp].pop(groups[del_grp].index(ind))\n                p[ind] = p[p1]\n                groups[p[p1]].append(ind)\n                \n#print p\n#print groups\n\nm = int(sys.stdin.readline())\nen = []\nfor i in xrange(m):\n    p1, p2 = map(int_, sys.stdin.readline().split())\n    if p[p1]==p[p2] and p[p1]!=-1:\n        #a oni v odno' gryppe (((\n        groups[p[p1]] = []\n\nx = 0    \nif len(groups):\n    x = max(map(len, groups))\n\nif x==0 and -1 in p:\n    x = 1\nprint str(x)\n#\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "/*\n ID: govind.3, GhpS, govindpatel\n LANG: JAVA\n TASK: Main \n */\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\n    /**\n     * Min segment Tree takes the minimum number at the root\n     */\n    class MinSegmentTree {\n\n        /**\n         * root: Tree root, balance: input array, rl,rr:\n         * rl=0,rr=inputArray.length-1 minTree:segment Tree\n         */\n        private void initMinTree(int root, int rl, int rr, int[] balance, int[] minTree) {\n            if (rl == rr) {\n                minTree[root] = balance[rl];\n                return;\n            }\n            int rm = (rl + rr) / 2;\n            initMinTree(root * 2 + 1, rl, rm, balance, minTree);\n            initMinTree(root * 2 + 2, rm + 1, rr, balance, minTree);\n            minTree[root] = Math.min(minTree[root * 2 + 1], minTree[root * 2 + 2]);\n        }\n\n        /**\n         * minTree:segment tree root:0 rl:0,rr:inputarray.length-1\n         * l=queryleft-1(If 1 based index),r = queryright(1-based)\n         */\n        private int getMin(int[] minTree, int root, int rl, int rr, int l, int r) {\n            //l = query left-1, r = query right\n            if (l > r) {\n                return Integer.MAX_VALUE;\n            }\n            if (l == rl && r == rr) {\n                return minTree[root];\n            }\n            int rm = (rl + rr) / 2;\n            return Math.min(getMin(minTree, root * 2 + 1, rl, rm, l, Math.min(r, rm)),\n                    getMin(minTree, root * 2 + 2, rm + 1, rr, Math.max(rm + 1, l), r));\n        }\n    }\n    //dsu next operation\n    int[] next;\n\n    private int next(int i) {\n        if (next[i] == i) {\n            return i;\n        }\n        return next[i] = next(next[i]);\n    }\n\n    //segment tree...\n    private void set(int[] t, int ind, int val) {\n        ind += (t.length / 2);\n        t[ind] = val;\n        int curr = 0;\n        while (ind > 1) {\n            ind >>= 1;\n            if (curr == 0) {\n                t[ind] = t[ind * 2] | t[ind * 2 + 1];\n            } else {\n                t[ind] = t[ind * 2] ^ t[2 * ind + 1];\n            }\n            curr ^= 1;\n        }\n    }\n\n    //Binary Index tree\n    class FenwickTree {\n\n        int[] ft;\n        int N;\n\n        FenwickTree(int n) {\n            this.N = n;\n            ft = new int[N];\n        }\n\n        private int lowbit(int x) {\n            return x & (-x);\n        }\n\n        void update(int pos, int val) {\n            while (pos < N) {\n                ft[pos] += val;\n                pos |= pos + 1;//0-index\n            }\n        }\n\n        int sum(int pos) {\n            int sum = 0;\n            while (pos >= 0) {\n                sum += ft[pos];\n                pos = (pos & (pos + 1)) - 1;\n            }\n            return sum;\n        }\n\n        int rangeSum(int left, int right) {\n            return sum(right) - sum(left - 1);\n        }\n    }\n\n    /**\n     * BINARY SEARCH IN FENWICK TREE: l=1, r=N(length), at=sumRequired,\n     * letter=TreeIndex(if there are many ft), ft=arrays of FT\n     */\n    private int binarySearch(int l, int r, int at, int letter, FenwickTree[] ft) {\n        while (r - l > 0) {\n            int mid = (l + r) / 2;\n            int sum = ft[letter].sum(mid);\n            if (sum < at) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return l;\n    }\n\n    private int[] compress(int[] a) {\n        int[] b = new int[a.length];\n        for (int i = 0; i < a.length; i++) {\n            b[i] = a[i];\n        }\n        Arrays.sort(b);\n        int m = 0;\n        for (int i = 0; i < b.length;) {\n            int j = i;\n            while (j < b.length && b[j] == b[i]) {\n                j++;\n            }\n            b[m++] = b[i];\n            i = j;\n        }\n        for (int i = 0; i < a.length; i++) {\n            a[i] = Arrays.binarySearch(b, 0, m, a[i]);\n        }\n        return a;\n    }\n\n    class Dijkstra {\n\n        class Edge implements Comparable<Edge> {\n\n            int to;\n            long weight;\n\n            Edge(int t, long w) {\n                to = t;\n                weight = w;\n            }\n\n            public int compareTo(Edge other) {\n                return (int) Math.signum(weight - other.weight);\n            }\n        }\n        public static final long INF = (long) 1e17;\n        private ArrayList<Edge> adj[];\n        private int nodes;\n        private long[] dist;\n        private int[] prev;\n        private boolean[] visited;\n\n        public Dijkstra(int n) {\n            nodes = n;\n            adj = new ArrayList[nodes];\n            dist = new long[nodes];\n            prev = new int[nodes];\n            visited = new boolean[nodes];\n            for (int i = 0; i < nodes; i++) {\n                adj[i] = new ArrayList<Edge>();\n                dist[i] = INF;\n                prev[i] = -1;\n            }\n        }\n\n        public void add(int u, int v, long cost) {\n            adj[u].add(new Edge(v, cost));\n        }\n\n        public void dist() {\n            //src vertex = 0;\n            dist[0] = 0;\n            Queue<Edge> q = new PriorityQueue<Edge>();\n            q.add(new Edge(0, 0));\n            while (!q.isEmpty()) {\n                Edge e = q.poll();\n                int ind = e.to;\n                if (visited[ind]) {\n                    continue;\n                }\n                visited[ind] = true;\n\n                for (Edge edge : adj[ind]) {\n                    long newDistance = e.weight + edge.weight;\n                    if (newDistance < dist[edge.to]) {\n                        dist[edge.to] = newDistance;\n                        prev[edge.to] = ind;\n                        q.add(new Edge(edge.to, dist[edge.to]));\n                    }\n                }\n            }\n        }\n\n        public ArrayList<Integer> getPrevList(int last) {\n            ArrayList<Integer> al = new ArrayList<Integer>();\n            while (last != -1) {\n                al.add(last);\n                last = prev[last];\n            }\n            return al;\n        }\n\n        public int[] getPrev() {\n            return prev;\n        }\n\n        public long[] getDistance() {\n            return dist;\n        }\n\n        public boolean[] getVisited() {\n            return visited;\n        }\n    }\n\n    class Edge {\n\n        int id, to, cap;\n        boolean rev;\n\n        Edge(int to, int id, int cap, boolean rev) {\n            this.to = to;\n            this.id = id;\n            this.cap = cap;\n            this.rev = rev;\n        }\n    }\n    int[] p;\n\n    private void solve() throws IOException {\n        int N = nextInt();\n        int M = nextInt();\n        p = new int[2005];\n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n        }\n        for (int i = 0; i < M; i++) {\n            int f1 = nextInt() - 1;\n            int f2 = nextInt() - 1;\n            merge(f1, f2);\n        }\n        boolean[] good = new boolean[N];\n        int[] size = new int[N];\n        for (int i = 0; i < N; i++) {\n            size[get(i)]++;\n            good[i] = true;\n        }\n        int E = nextInt();\n        for (int i = 0; i < E; i++) {\n            int e1 = nextInt() - 1;\n            int e2 = nextInt() - 1;\n            int pe1 = get(e1);\n            int pe2 = get(e2);\n            if (pe1 == pe2) {\n                good[pe1] = false;\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < N; i++) {\n            if (good[i]) {\n                ans = Math.max(ans, size[i]);\n            }\n        }\n        out.println(ans);\n    }\n\n    void merge(int a, int b) {\n        a = get(a);\n        b = get(b);\n        if (a != b) {\n            p[a] = b;\n        }\n    }\n\n    int get(int a) {\n//        if (p[a] == a) {\n//            return a;\n//        }\n        while (p[a] != a) {\n            p[a] = p[p[a]];\n            a = p[a];\n        }\n//        return p[a] = get(p[a]);\n        return a;\n    }\n\n    boolean isSorted(ArrayList<Integer> al) {\n        int size = al.size();\n        for (int i = 1; i < size - 2; i++) {\n            if (al.get(i) > al.get(i + 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * SHUFFLE: shuffle the array 'a' of size 'N'\n     */\n    private void shuffle(int[] a, int N) {\n        for (int i = 0; i < N; i++) {\n            int r = i + (int) ((N - i) * Math.random());\n            int t = a[i];\n            a[i] = a[r];\n            a[r] = t;\n        }\n    }\n\n    /**\n     * TEMPLATE-STUFF: main method, run method - ( fileIO and stdIO ) and\n     * various methods for input like nextInt, nextLong, nextToken and\n     * nextDouble with some declarations.\n     */\n    /**\n     * For solution to the problem ... see the solve method\n     */\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    public void run() {\n        try {\n            in = new BufferedReader(new FileReader(\"D-large.in\"));\n            out = new PrintWriter(new BufferedWriter(new FileWriter(\"Main.out\")));\n            tok = null;\n            solve();\n            in.close();\n            out.close();\n            System.exit(0);\n        } catch (IOException e) {//(FileNotFoundException e) {\n            try {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(new OutputStreamWriter(System.out));\n                tok = null;\n                solve();\n                in.close();\n                out.close();\n                System.exit(0);\n            } catch (IOException ex) {\n                System.out.println(ex.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n\n    private String nextToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    BufferedReader in;\n    StringTokenizer tok;\n    PrintWriter out;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m;\nvector<int> fr[100010];\nvector<int> dis[100010];\nbool vis[2010];\nbool red[2010];\nvector<int> V;\nvector<int> ans;\nvoid bfs(int in) {\n  V.resize(0);\n  memset(vis, false, sizeof vis);\n  memset(red, false, sizeof red);\n  V.push_back(in);\n  vis[in] = true;\n  int cnt = 0;\n  for (int i = 0; i < (int)dis[in].size(); i++) red[dis[in][i]] = true;\n  while (1) {\n    while (cnt < (int)V.size()) {\n      int cur = V[cnt];\n      if (red[cur]) return;\n      for (int i = 0; i < (int)dis[cur].size(); i++) red[dis[cur][i]] = true;\n      for (int i = 0; i < (int)fr[cur].size(); i++) {\n        int moj = fr[cur][i];\n        if (vis[moj] == false) {\n          vis[moj] = true;\n          V.push_back(moj);\n        }\n      }\n      cnt++;\n    }\n    ans.push_back((int)V.size());\n    for (int i = 1; i <= n; i++)\n      if (vis[i] == false && red[i] == false) {\n        for (int j = 0; j < (int)dis[i].size(); j++) red[dis[i][j]] = true;\n        V.push_back(i);\n        continue;\n      }\n    return;\n  }\n}\nint main() {\n  cin >> n;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    cin >> u >> v;\n    fr[u].push_back(v);\n    fr[v].push_back(u);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    dis[u].push_back(v);\n    dis[v].push_back(u);\n  }\n  for (int i = 1; i <= n; i++) bfs(i);\n  int ANS = 0;\n  for (int i = 0; i < (int)ans.size(); i++) ANS = max(ans[i], ANS);\n  cout << ANS << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5;\nstatic int comp[maxn];\nstatic int pr[maxn];\nstatic int n;\nvoid make_set() {\n  for (int i = 0; i < n; ++i) {\n    pr[i] = i;\n    comp[i] = 1;\n  }\n}\nint find_set(int a) {\n  if (pr[a] == a) return a;\n  return pr[a] = find_set(pr[a]);\n}\nvoid union_set(int a, int b) {\n  a = find_set(a);\n  b = find_set(b);\n  pr[a] = b;\n  comp[b] += comp[a];\n  comp[a] = 0;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  cin >> n;\n  int m;\n  cin >> m;\n  make_set();\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    if (find_set(a) != find_set(b)) union_set(a, b);\n  }\n  int k;\n  cin >> k;\n  for (int j = 0; j < k; ++j) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    if (find_set(a) == find_set(b)) {\n      comp[find_set(a)] = 0;\n    }\n  }\n  int mx = 0;\n  for (int l = 0; l < n; ++l) {\n    mx = max(mx, comp[l]);\n  }\n  cout << mx;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint g[2001][2001], n, k = 0, a[2001], s[2001] = {0}, m;\nbool viz[2001] = {0};\nset<int> mys;\nvoid dfs(int x) {\n  viz[x] = 1;\n  a[x] = k;\n  s[k]++;\n  for (int i = 1; i <= n; i++)\n    if ((g[x][i] == 1) && (!viz[i])) dfs(i);\n};\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    cin >> x >> y;\n    g[x][y] = 1;\n    g[y][x] = 1;\n  };\n  for (int i = 1; i <= n; i++)\n    if (viz[i] == 0) {\n      k++;\n      dfs(i);\n    };\n  cin >> m;\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    cin >> x >> y;\n    if (a[x] == a[y])\n      if (mys.find(a[x]) == mys.end()) mys.insert(a[x]);\n  };\n  int max = 0;\n  for (int i = 1; i <= k; i++) {\n    if ((s[i] > max) && (mys.find(i) == mys.end())) max = s[i];\n  };\n  cout << max;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dsu[2001];\nint size[2001];\nvoid assign(int n) {\n  for (int i = 0; i <= n; i++) {\n    dsu[i] = i;\n    size[i] = 1;\n  }\n}\nint find(int i) {\n  while (i != dsu[i]) {\n    dsu[i] = dsu[dsu[i]];\n    i = dsu[i];\n  }\n  return i;\n}\nvoid unionn(int x, int y) {\n  int xx = find(x);\n  int yy = find(y);\n  if (size[xx] <= size[yy]) {\n    size[yy] += size[xx];\n    dsu[xx] = yy;\n  } else {\n    size[xx] += size[yy];\n    dsu[yy] = xx;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  assign(n);\n  int k;\n  cin >> k;\n  int x, y;\n  for (int i = 0; i < int(k); i++) {\n    cin >> x >> y;\n    unionn(x, y);\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < int(m); i++) {\n    cin >> x >> y;\n    if (find(x) == find(y)) {\n      unionn(0, x);\n    }\n  }\n  int NOO = find(0);\n  map<int, int> count;\n  for (int i = 0; i < int(n + 1); i++) {\n    if (find(i) != NOO) {\n      count[find(i)]++;\n    }\n  }\n  int MAX = 0;\n  for (auto it : count) {\n    if (it.second > MAX) MAX = it.second;\n  }\n  cout << MAX << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n \npublic class Worms {\n\tstatic List<Integer>[] adj;\n\tstatic boolean visited[];\n\tstatic int[] group;\n\tpublic static void groupify(int u,int col)\n\t{\n\t\tvisited[u]=true;\n\t\tgroup[u]=col;\n\t\t\n\t\tfor(int v: adj[u])\n\t\t{\n\t\t\tif(!visited[v])\n\t\t\t\tgroupify(v,col);\n\t\t}\n\t}\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    Scanner sc = new Scanner(System.in);\n\t    int n  =sc.nextInt();\n\t    adj = new LinkedList[n+1];\n\t    visited = new boolean[n+1];\n\t    group = new int[n+1];\n\t    for(int i=1;i<=n;i++)adj[i]=new LinkedList();\n\t    int k = sc.nextInt();\n\t    for(int i=0;i<k;i++)\n\t    {\n\t    \tint u = sc.nextInt();int v = sc.nextInt();\n\t    \tadj[u].add(v);adj[v].add(u);\n\t    }\n\t    for(int i=1;i<=n;i++)\n\t    {\n\t    \tif(!visited[i])\n\t    \t\tgroupify(i,i);\n\t    }\n\t    int leftouts=n+1;\n\t    Map<Integer,Integer> groupsize = new HashMap<Integer,Integer>();\n\t    for(int i=1;i<=n;i++)\n\t    {\n\t    \tif(group[i]==0)\n\t    \t{\n\t    \t\tgroupsize.put(group[i] , leftouts);\n\t    \t\tleftouts++;\n\t    \t}\n\t    \telse\n\t    \t{\n\t    \t\tif(groupsize.containsKey(group[i]))groupsize.replace(group[i],groupsize.get(group[i])+1);\n\t    \t\telse groupsize.put(group[i] , 1);\n\t    \t}\n\t    }\n\t    int m = sc.nextInt();\n\t    while(m-->0)\n\t    {\n\t    \tint u = sc.nextInt();int v = sc.nextInt();\n\t    \tif(group[u]==group[v])groupsize.remove(group[u]);\n\t    }\n\t    \n\t    int max=0;\n\t    if(groupsize.size() > 0)\n\t    {\n\t    \tfor(Map.Entry<Integer, Integer> entry : groupsize.entrySet())\n\t    \t{\n\t    \t\tmax = Math.max(max, entry.getValue());\n\t    \t}\n\t    }\n\t    System.out.println(max);\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class ab1 {\n\n    public static void debug(Object... obs)\n    {\n        System.out.println(Arrays.deepToString(obs));\n    }\n\n    public static void main(String[] args) throws Throwable\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        \n        int k=Integer.parseInt(br.readLine());\n        boolean dn[]=new boolean[n];\n        FR[]fri=new FR[n];\n        for(int i=0;i<n;i++)\n            fri[i]=new FR(i);\n        \n        StringTokenizer st=null;\n        for(int i=0;i<k;i++)\n        {\n            st=new StringTokenizer(br.readLine());\n            int a=Integer.parseInt(st.nextToken())-1;\n            int b=Integer.parseInt(st.nextToken())-1;\n            fri[a].fr.add(b);\n            fri[b].fr.add(a);\n        }\n        \n        int m=Integer.parseInt(br.readLine());\n        for(int i=0;i<m;i++)\n        {\n            st=new StringTokenizer(br.readLine());\n            int a=Integer.parseInt(st.nextToken())-1;\n            int b=Integer.parseInt(st.nextToken())-1;\n            fri[a].dis.add(b);\n            fri[b].dis.add(a);\n        }\n        \n        int ma=0;\n        for(int i=0;i<n;i++)\n        {\n            if(!dn[i])\n            {\n                Set<Integer>seen= new HashSet<Integer>();\n                seen.add(i);\n                if(dfs(i,fri,dn,seen))\n                {\n                    //debug(seen);\n                    ma = Math.max(ma, seen.size());\n                }\n            }\n        }\n        System.out.println(ma);\n    }\n    \n    private static boolean dfs(int i, FR[] fri, boolean[] dn, Set<Integer> seen)\n    {\n        boolean ok=true;\n        dn[i]=true;\n        for(Integer d : fri[i].dis)\n        {\n            if(seen.contains(d))\n                ok=false;\n        }\n        \n        for(Integer f : fri[i].fr)\n        {\n            if(!dn[f])\n            {\n                seen.add(f);\n                if(!dfs(f,fri,dn,seen))\n                    ok=false;\n            }\n        }\n        \n        return ok;\n    }\n\n    private static class FR\n    {\n        List<Integer> fr = new ArrayList<Integer>();\n        List<Integer> dis = new ArrayList<Integer>();\n        int id;\n        public FR(int id)\n        {\n            super();\n            this.id = id;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\nimport java.io.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\n\tlong mod1 = (long) 1e9 + 7;\n\tint mod2 = 998244353;\n\n\tpublic void solve() throws Exception {\n\t\tint n=sc.nextInt();\n\t\tint arr[]=new int[n];\n\t\tint size[]=new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tarr[i]=i;\n\t\t\tsize[i]=1;\n\t\t}\n\t\tint m=sc.nextInt();\n\t\twhile(m-->0) {\n\t\t\tint x=sc.nextInt();\n\t\t\tint y=sc.nextInt();\n\t\t\ty--; x--;\n\t\t\tx=find(arr,x);\n\t\t\ty=find(arr,y);\n\t\t\tif(x==y) continue;\n\t\t\tif(size[x]>size[y]) {\n\t\t\t\tarr[y]=x;\n\t\t\t\tsize[x]+=size[y];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarr[x]=y;\n\t\t\t\tsize[y]+=size[x];\n\t\t\t}\n\t\t}\n\t\tm=sc.nextInt();\n\t\tboolean flagit[]=new boolean[n];\n\t\twhile(m-->0) {\n\t\t\tint x=sc.nextInt();\n\t\t\tint y=sc.nextInt();\n\t\t\tx--; y--;\n\t\t\tint p1=find(arr,x);\n\t\t\tint p2=find(arr,y);\n\t\t\tif(p1==p2) {\n\t\t\t\tflagit[p1]=true;\n\t\t\t}\n\t\t}\n\t\tint max=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tarr[i]=find(arr,i);\n\t\t}\n//\t\tout.println(Arrays.toString(size));\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(!flagit[arr[i]]) {\n\t\t\t\tmax=Math.max(max, size[i]);\n\t\t\t}\n\t\t}\n\t\tout.println(max);\n\n\t}\n\t\n\tpublic int find(int arr[], int x) {\n\t\tif(x==arr[x]) return x;\n\t\treturn arr[x]=find(arr,arr[x]);\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n\t}\n\n\tstatic long ncr(int n, int r, long p) {\n\t\tif (r > n)\n\t\t\treturn 0l;\n\t\tif (r > n - r)\n\t\t\tr = n - r;\n\n\t\tlong C[] = new long[r + 1];\n\n\t\tC[0] = 1;\n\n\t\tfor (int i = 1; i <= n; i++) {\n\n\t\t\tfor (int j = Math.min(i, r); j > 0; j--)\n\t\t\t\tC[j] = (C[j] + C[j - 1]) % p;\n\t\t}\n\t\treturn C[r] % p;\n\t}\n\n\tvoid sieveOfEratosthenes(boolean prime[], int size) {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tprime[i] = true;\n\n\t\tfor (int p = 2; p * p < size; p++) {\n\t\t\tif (prime[p] == true) {\n\t\t\t\tfor (int i = p * p; i < size; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int LowerBound(int a[], int x) { // smallest index having value >= x; returns 0-based index\n\t\tint l = -1, r = a.length;\n\t\twhile (l + 1 < r) {\n\t\t\tint m = (l + r) >>> 1;\n\t\t\tif (a[m] >= x)\n\t\t\t\tr = m;\n\t\t\telse\n\t\t\t\tl = m;\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int UpperBound(int a[], int x) {// biggest index having value <= x; returns 1-based index\n\t\tint l = -1, r = a.length;\n\t\twhile (l + 1 < r) {\n\t\t\tint m = (l + r) >>> 1;\n\t\t\tif (a[m] <= x)\n\t\t\t\tl = m;\n\t\t\telse\n\t\t\t\tr = m;\n\t\t}\n\t\treturn l + 1;\n\t}\n\n\tpublic long power(long x, long y, long p) {\n\t\tlong res = 1;\n\t\t// out.println(x+\" \"+y);\n\t\tx = x % p;\n\t\tif (x == 0)\n\t\t\treturn 0;\n\n\t\twhile (y > 0) {\n\t\t\tif ((y & 1) == 1)\n\t\t\t\tres = (res * x) % p;\n\t\t\ty = y >> 1;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic Throwable uncaught;\n\n\tBufferedReader in;\n\tFastScanner sc;\n\tPrintWriter out;\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsc = new FastScanner(in);\n\t\t\tsolve();\n\t\t} catch (Throwable uncaught) {\n\t\t\tSolution.uncaught = uncaught;\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Throwable {\n\t\tThread thread = new Thread(null, new Solution(), \"\", (1 << 26));\n\t\tthread.start();\n\t\tthread.join();\n\t\tif (Solution.uncaught != null) {\n\t\t\tthrow Solution.uncaught;\n\t\t}\n\t}\n\n}\n\nclass FastScanner {\n\n\tBufferedReader in;\n\tStringTokenizer st;\n\n\tpublic FastScanner(BufferedReader in) {\n\t\tthis.in = in;\n\t}\n\n\tpublic String nextToken() throws Exception {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic int[] readArray(int n) throws Exception {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic double nextDouble() throws Exception {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n/**\n * Created with IntelliJ IDEA.\n * Author   : Dylan\n * Date     : 2013-08-10\n * Time     : 14:40\n * Project  : Party 3\n */\n\npublic class Main {\n    static LinkedList<Integer>[] graph;\n    static int[] root;\n    static boolean[] visited;\n    static int n, current, max;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        graph = new LinkedList[n + 1];\n        visited = new boolean[n + 1];\n        root = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            graph[i] = new LinkedList<Integer>();\n            root[i] = i;\n        }\n        int k = in.nextInt();\n        while (k-- > 0) {\n            int x = in.nextInt();\n            int y = in.nextInt();\n            graph[x].add(y);\n            graph[y].add(x);\n            int rootX = findRoot(x);\n            int rootY = findRoot(y);\n            if (rootX != rootY) {\n                root[rootX] = rootY;\n            }\n        }\n        k = in.nextInt();\n        while (k-- > 0) {\n            int rootX = findRoot(in.nextInt());\n            int rootY = findRoot(in.nextInt());\n            if (rootX == rootY) {\n                visited[rootX] = true;\n            }\n        }\n        max = 0;\n        for (int i = 1; i <= n; i++) {\n            if (visited[findRoot(i)]) continue;\n            current = 0;\n            dfs(i);\n            max = Math.max(max, current);\n        }\n        System.out.println(max);\n    }\n\n    static void dfs(int x) {\n        boolean res = true;\n        visited[x] = true;\n        current++;\n        for (int i : graph[x]) {\n            if (visited[i]) continue;\n            dfs(i);\n        }\n    }\n\n    static int findRoot(int x) {\n        return x == root[x] ? x : (root[x] = findRoot(root[x]));\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint m, n, t, q, r, w, a, b;\nint p[3000], cnt[3000] = {0};\nbool ok[3000];\nint find(int x) { return x == p[x] ? x : (p[x] = find(p[x])); }\nvoid uni(int x, int y) { p[find(x)] = find(y); }\nbool eqi(int x, int y) { return find(x) == find(y); }\nint main() {\n  for (int i = 0; i < 3000; i++) {\n    ok[i] = 1;\n    p[i] = i;\n  }\n  scanf(\"%d\", &t);\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d\", &a, &b);\n    uni(a, b);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &a, &b);\n    if (eqi(a, b)) {\n      ok[find(a)] = 0;\n    }\n  }\n  for (int i = 1; i <= t; i++) {\n    if (ok[find(i)]) cnt[find(i)]++;\n  }\n  int ret = 0;\n  for (int i = 1; i <= t; i++)\n    if (cnt[i] > ret) ret = cnt[i];\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = (int)((1e5) + 10);\nint gcd(int a, int b) {\n  if (a == 0) return b;\n  return gcd(b % a, a);\n}\nint max(int a, int b) {\n  if (a > b)\n    return a;\n  else\n    return b;\n}\nint min(int a, int b) {\n  if (a < b)\n    return a;\n  else\n    return b;\n}\nbool isPrime(int N) {\n  for (int i = 2; i * i <= N; ++i) {\n    if (N % i == 0) return false;\n  }\n  return true;\n}\nint cbrt(int x) {\n  int lo = 1, hi = min(2000000ll, x);\n  while (hi - lo > 1) {\n    int mid = (lo + hi) / 2;\n    if (mid * mid * mid < x) {\n      lo = mid;\n    } else\n      hi = mid;\n  }\n  if (hi * hi * hi <= x)\n    return hi;\n  else\n    return lo;\n}\nconst int dx[4] = {-1, 1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\nconst int nax = (int)(100000 + 10);\nint n, t, a, b, m, m2, ans = 0, s = 0;\nvector<int> adj[200002], em[200002];\nint vis[200002];\nvoid dfs(int u) {\n  vis[u] = 1;\n  s += 1;\n  for (auto &i : adj[u]) {\n    if (!vis[i]) {\n      dfs(i);\n    }\n  }\n  for (auto &i : em[u]) {\n    if (vis[i]) {\n      s = -1e9;\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL);\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  cin >> m2;\n  for (int i = 0; i < m2; i++) {\n    cin >> a >> b;\n    em[a].push_back(b);\n    em[b].push_back(a);\n  }\n  for (int i = 1; i <= n; i++) {\n    s = 0;\n    dfs(i);\n    ans = max(ans, s);\n    memset(vis, 0, sizeof vis);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\n\n/*\n */\npublic class A {\n\tstatic FastReader sc=null;\n\tstatic boolean po[];\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tsc=new FastReader();\n\t\tint n=sc.nextInt();\n\t\tDU du=new DU(n);\n\t\tpo=new boolean[n];\n\t\tArrays.fill(po, true);\n\t\tint k=sc.nextInt();\n\t\tfor(int i=0;i<k;i++) {\n\t\t\tint p=sc.nextInt()-1,q=sc.nextInt()-1;\n\t\t\tdu.unify(p, q);\n\t\t}\n\t\tint m=sc.nextInt();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint r=du.find(i);\n\t\t}\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint p=sc.nextInt()-1,q=sc.nextInt()-1;\n\t\t\tint r1=du.find(p),r2=du.find(q);\n\t\t\tif(r1==r2)po[r1]=false;\n\t\t}\n\t\tint max=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint r=du.find(i);\n\t\t\tif(po[r])max=Math.max(max, du.sz[r]);\n\t\t}\n\t\tSystem.out.println(max);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\n\t\t\n\n\t\t\n\t\t\n\t}\n\tstatic class DU{\n\t\t int id[];\n\t\t int size;\n\t\t int comp;\n\t\t int sz[];\n\t\t Map<Integer,ArrayList<Integer>> map=new HashMap<>();\n\t\t\n\t\t DU(int size){\n\t\t\tthis.size=size;\n\t\t\tid=new int[size];\n\t\t\tsz=new int[size];\n\t\t\tfor(int i=0;i<size;i++) {\n\t\t\t\tid[i]=i;\n\t\t\t\tsz[i]=1;\n\t\t\t\t\n\t\t\t}\n\t\t\tcomp=size;\n\t\t\t\t\n\t\t}\n\t\tpublic int find(int p) {\n\t\t\tint root=p;\n\t\t\t\n\t\t\twhile(id[root]!=root)\n\t\t\t\troot=id[root];\n\t\t\t\n\t\t\twhile(p!=root) {\n\t\t\t\t\n\t\t\t\tint next=id[p];\n\t\t\t\tid[p]=root;\n\t\t\t\tp=next;\n\t\t\t}\n\t\t\treturn root;\n\t\t\t\n\t\t}\n\t\tpublic boolean connected(int p,int q) {\n\t\t\treturn id[p]==id[q];\n\t\t}\n\t\tpublic int compsize(int p) {\n\t\t\treturn sz[find(p)];\n\t\t}\n\t\tpublic void unify(int p,int q) {\n\t\t\tint r1=find(p),r2=find(q);\n\t\t\t\n\t\t\t\n\t\t\tif(r1==r2)return;\n\t\t\t\n\t\t\tif(sz[r1]<sz[r2]) {\n\t\t\t\tsz[r2]+=sz[r1];\n\t\t\t\tid[r1]=id[r2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsz[r1]+=sz[r2];\n\t\t\t\tid[r2]=id[r1];\n\t\t\t}\n\t\t\t\n\t\t\tcomp--;\t\n\t\t}\t\n\t}\n\n\t\n\tstatic int[] reverse(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al,Collections.reverseOrder());\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\t\n\tstatic void print(long a[]) {\n\t\tfor(long e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\t\n\t\n\t\n\tstatic void print(int a[]) {\n\t\tfor(int e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n        int[] readArray(int n) {\n    \t\tint a[]=new int [n];\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\ta[i]=sc.nextInt();\n    \t\t}\n    \t\treturn a;\n    \t}\n    } \n}\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2010;\nstruct NodeDSU {\n  int rank, parent;\n} dsu[N];\nint n, k, m, c, p, sol;\nset<int> skup[N];\nvector<int> hate[N];\nmap<int, int> hes;\nvoid MakeSet(int n) {\n  for (int i = 1; i <= n; i++) {\n    dsu[i].rank = 0;\n    dsu[i].parent = i;\n  }\n}\nint FindSet(int x) {\n  if (dsu[x].parent == x) return x;\n  dsu[x].parent = FindSet(dsu[x].parent);\n  return dsu[x].parent;\n}\nvoid UniteSet(int x, int y) {\n  x = FindSet(x);\n  y = FindSet(y);\n  if (x == y) return;\n  if (dsu[x].rank < dsu[y].rank)\n    dsu[x].parent = y;\n  else\n    dsu[y].parent = x;\n  if (dsu[x].rank == dsu[y].rank) dsu[x].rank++;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  MakeSet(n);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    UniteSet(a, b);\n  }\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    hate[a].push_back(b);\n    hate[b].push_back(a);\n  }\n  for (int i = 1; i <= n; i++) {\n    p = FindSet(i);\n    if (hes.count(p) == 0) hes[p] = c++;\n    skup[hes[p]].insert(i);\n  }\n  for (int i = 0; i < c; i++) {\n    bool ok = true;\n    for (auto it : skup[i]) {\n      int v = it;\n      for (int j = 0; j < hate[v].size(); j++) {\n        int u = hate[v][j];\n        if (skup[i].find(u) != skup[i].end()) ok = false;\n      }\n    }\n    if (ok) sol = max(sol, (int)(skup[i].size()));\n  }\n  cout << sol;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long id[100005];\nlong long sz[100005];\nvoid initialize() {\n  for (long long i = 1; i <= 100000; i++) {\n    id[i] = i;\n    sz[i] = 1;\n  }\n}\nlong long root(long long x) {\n  while (x != id[x]) {\n    id[x] = id[id[x]];\n    x = id[x];\n  }\n  return x;\n}\nvoid union_(long long x, long long y) {\n  long long a = root(x);\n  long long b = root(y);\n  if (a != b) {\n    if (sz[a] <= sz[b]) {\n      id[a] = b;\n      sz[b] += sz[a];\n    } else {\n      id[b] = a;\n      sz[a] += sz[b];\n    }\n  }\n}\nint main() {\n  initialize();\n  long long n;\n  cin >> n;\n  long long k;\n  cin >> k;\n  for (long long i = 0; i < k; i++) {\n    long long x, y;\n    cin >> x >> y;\n    if (root(x) != root(y)) union_(x, y);\n  }\n  long long m;\n  cin >> m;\n  for (long long i = 0; i < m; i++) {\n    long long x, y;\n    cin >> x >> y;\n    if (root(x) == root(y)) id[root(x)] = 0;\n  }\n  long long ma = 0;\n  for (long long i = 1; i <= n; i++) {\n    if (id[i] == i) ma = max(ma, sz[i]);\n  }\n  cout << ma;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid bfs(vector<vector<int> >& G, vector<int>& components, vector<int>& sizes,\n         int vertex_s, int number_of_component) {\n  queue<int> Queue;\n  Queue.push(vertex_s);\n  components[vertex_s] = number_of_component;\n  int current_vertex;\n  int cur_size = 1;\n  while (!Queue.empty()) {\n    current_vertex = Queue.front();\n    Queue.pop();\n    for (int i = 0; i < G.size(); i++) {\n      if ((G[current_vertex][i] == 1) && (components[i] == -1)) {\n        components[i] = number_of_component;\n        cur_size++;\n        Queue.push(i);\n      };\n    };\n  };\n  sizes.push_back(cur_size);\n}\nint main() {\n  int N, K, M;\n  cin >> N >> K;\n  vector<vector<int> > love(N, vector<int>(N, 0));\n  vector<vector<int> > hate(N, vector<int>(N, 0));\n  for (int i = 0; i < K; i++) {\n    int a, b;\n    cin >> a >> b;\n    love[a - 1][b - 1] = love[b - 1][a - 1] = 1;\n  }\n  cin >> M;\n  for (int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b;\n    hate[a - 1][b - 1] = hate[b - 1][a - 1] = 1;\n  }\n  vector<int> components(N, -1);\n  vector<int> sizes;\n  int cur_ver = 0;\n  int i = -1;\n  while (cur_ver < N) {\n    i++;\n    bfs(love, components, sizes, cur_ver, i);\n    while ((cur_ver < N) && (components[cur_ver] != -1)) {\n      cur_ver++;\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      if ((components[i] == components[j]) && (hate[i][j] == 1))\n        sizes[components[i]] = 0;\n    }\n  }\n  int max = 0;\n  for (int i = 0; i < sizes.size(); i++) {\n    if (max < sizes[i]) max = sizes[i];\n  }\n  cout << max << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# maa chudaaye duniya\nn = int(input())\nparents = [i for i in range(n+1)]\nranks = [1 for i in range(n+1)]\n\ndef find(x):\n\tif parents[x] != x:\n\t\tparents[x] = find(parents[x])\n\treturn parents[x]\n\ndef union(x, y):\n\txs = find(x)\n\tys = find(y)\n\tif xs == ys:\n\t\treturn\n\tif ranks[xs] > ranks[ys]:\n\t\tparents[ys] = xs\n\telif ranks[ys] > ranks[xs]:\n\t\tparents[xs] = ys\n\telse:\n\t\tparents[ys] = xs\n\t\tranks[xs] += 1\n\nfor _ in range(int(input())):\n\tu, v = map(int, input().split())\n\tunion(u, v)\n\n# print(parents)\nrejects = set([])\nfor _ in range(int(input())):\n\tp, q = map(int, input().split())\n\tps = find(p)\n\tqs = find(q)\n\tif ps == qs:\n\t\trejects.add(ps)\nps = {}\nfor i in range(1, n+1):\n\tp = find(i)\n\tif p not in rejects:\n\t\tif p in ps:\n\t\t\tps[p] += 1\n\t\telse:\n\t\t\tps[p] = 1\n# print(ps)\nans = 0\nfor i in ps:\n\tans = max(ans, ps[i])\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, m, grp, p, mat[2005][2005], ans;\nbool mark[2005];\nvector<long long int> adj[2005], comp[2005];\nvoid dfs(long long int v) {\n  mark[v] = true;\n  comp[grp].push_back(v);\n  for (long long int j = 0; j < adj[v].size(); j++) {\n    if (!mark[adj[v][j]]) dfs(adj[v][j]);\n  }\n}\nbool check(long long int x) {\n  for (long long int i = 0; i < comp[x].size() - 1; i++) {\n    for (long long int j = i + 1; j < comp[x].size(); j++) {\n      if (mat[comp[x][i]][comp[x][j]] == 1) return false;\n    }\n  }\n  return true;\n}\nint main() {\n  long long int i, x, y;\n  cin >> n >> m;\n  for (i = 0; i < m; i++) {\n    cin >> x >> y;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  cin >> p;\n  for (i = 0; i < p; i++) {\n    cin >> x >> y;\n    mat[x][y] = 1;\n    mat[y][x] = 1;\n  }\n  for (i = 1; i <= n; i++) {\n    if (!mark[i]) {\n      dfs(i);\n      grp++;\n    }\n  }\n  for (i = 0; i < grp; i++) {\n    if (check(i)) {\n      ans = ans > comp[i].size() ? ans : comp[i].size();\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  unsigned int n, k, m, ans = 0;\n  scanf(\"%d\", &n);\n  vector<vector<int> > like(n + 1);\n  vector<set<int> > hate(n + 1);\n  scanf(\"%d\", &k);\n  for (unsigned int(i) = 0; (i) < (k); ++(i)) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    like[x].push_back(y);\n    like[y].push_back(x);\n  }\n  scanf(\"%d\", &m);\n  for (unsigned int(i) = 0; (i) < (m); ++(i)) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    hate[x].insert(y);\n    hate[y].insert(x);\n  }\n  vector<bool> used(n + 1);\n  for (unsigned int(i) = 0; (i) < (n); ++(i)) {\n    int first_p = i + 1;\n    if (!used[first_p]) {\n      used[first_p] = true;\n      bool HateFlag = false;\n      vector<int> f_group;\n      f_group.push_back(first_p);\n      for (unsigned int(j) = 0; (j) < (f_group.size()); ++(j)) {\n        int p1 = f_group[j];\n        for (unsigned int(q) = 0; (q) < (like[p1].size()); ++(q)) {\n          int p2 = like[p1][q];\n          if (!used[p2]) {\n            used[p2] = true;\n            for (unsigned int(r) = 0; (r) < (f_group.size()); ++(r)) {\n              if (hate[f_group[r]].count(p2) > 0) {\n                HateFlag = true;\n              }\n            }\n            f_group.push_back(p2);\n          }\n        }\n      }\n      if (!HateFlag) {\n        if (f_group.size() > ans) {\n          ans = f_group.size();\n        }\n      }\n    }\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid dfs(long long &m, vector<bool> &dist,\n         unordered_map<long long, vector<long long>> &adjlist,\n         unordered_map<long long, vector<long long>> &dislike,\n         vector<bool> &temp, long long y) {\n  for (auto i : adjlist[y]) {\n    if (!dist[i]) {\n      dist[i] = true;\n      temp[i] = true;\n      m++;\n      dfs(m, dist, adjlist, dislike, temp, i);\n    }\n  }\n  for (auto i : dislike[y]) {\n    if (temp[i]) {\n      m = -1e9;\n      break;\n    }\n  }\n}\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  unordered_map<long long, vector<long long>> adjlist, dislike;\n  for (long long i = 0; i < m; i++) {\n    long long x, y;\n    cin >> x >> y;\n    adjlist[x].push_back(y);\n    adjlist[y].push_back(x);\n  }\n  long long p;\n  cin >> p;\n  for (long long i = 0; i < p; i++) {\n    long long x, y;\n    cin >> x >> y;\n    dislike[x].push_back(y);\n    dislike[y].push_back(x);\n  }\n  long long ans(0), s(0);\n  vector<bool> dist(n + 1, false);\n  for (long long i = 1; i <= n; i++) {\n    if (!dist[i]) {\n      vector<bool> temp(n + 1, false);\n      s = 1;\n      dist[i] = true;\n      dfs(s, dist, adjlist, dislike, temp, i);\n      ans = max(ans, s);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class DisjointSetImplementationUsingArray \n{\n\tpublic int [] rank;\n\tpublic int [] parent;\n\tpublic int size[] ;\n\t\n\t\t\t\n\tint n;\n\t\n\tpublic DisjointSetImplementationUsingArray(int n) \n\t{\n\n\t\trank = new int[n+1];\n\t\tparent = new int[n+1];\n\t\tthis.n= n;\n\t\tsize = new int[n+1];\n\t\tmakeSet();\n\t}\n\t\n\t\n\tpublic void makeSet()\n\t{\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n\tvoid union(int x, int y) \n    { \n        int xRoot = findSet(x), yRoot = findSet(y); \n        if (xRoot == yRoot) \n            return; \n  \n        if (rank[xRoot] < rank[yRoot])  \n        {\n            parent[xRoot] = yRoot; \n            size[yRoot] += size[xRoot];\n        }\n        else if (rank[yRoot] < rank[xRoot]) \n        {\n\n            size[xRoot] += size[yRoot];\n            parent[yRoot] = xRoot; \n        }\n  \n        else \n        {  \n            parent[yRoot] = xRoot; \n            size[xRoot] += size[yRoot];\n            // And increment the the result tree's \n            // rank by 1 \n            rank[xRoot] = rank[xRoot] + 1; \n        } \n    }\n\t\n\tvoid union(int x, int y, int par) \n    { \n\t\tfor(int i=x;i<=y;i++)\n\t\t{\n\t        int xRoot = findSet(i); \n//\t        if (xRoot == yRoot) \n//\t            return; \n//\t  \n//\t        else\n//\t        {\n//\t        \tparent[xRoot] = par;\n//\t        \tparent[yRoot] = par;\n//\t        }\n\t       parent[xRoot] = par;\n\t\t}\n    }\n\t\n\t\n\tpublic int findSet(int x)\n\t{\n\t\t\n\t\tif(parent[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t{\n\t\t\twhile(parent[x]!=x)\n\t\t\t{\n\t\t\t\tx=parent[x];\n\t\t\t}\n\t\t}\n\t\treturn x;\n\t}\n\t\n\t\n\tpublic int findSetSize(int element)\n\t{\n\t\tint parent = findSet(element);\n\t\treturn size[parent];\n\t}\n\tpublic int findNoOfSets() \n\t{\n\t\tHashSet<Integer> hash = new HashSet<Integer>();\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\thash.add(findSet(i));\n\t\t}\n\t\treturn hash.size();\n\t}\n\t\n\t\n\tpublic static void main(String args[])\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tDisjointSetImplementationUsingArray  set = new DisjointSetImplementationUsingArray(n);\n\t\tint m = scan.nextInt();\n\t\twhile(m-- !=0)\n\t\t{\n\t\t\tset.union(scan.nextInt(), scan.nextInt());\n\t\t}\n\t\tHashSet<Integer> hash = new HashSet<Integer>();\n\t\tint enemy = scan.nextInt();\n\t\twhile(enemy-- !=0)\n\t\t{\n\t\t    int a = scan.nextInt();\n\t\t    int b = scan.nextInt();\n\t\t    if(set.findSet(a) != set.findSet(b))\n\t\t        continue;\n\t\t    else\n\t\t        hash.add(set.findSet(a));\n\t\t}\n\t\t\n\t\tint result = 0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t    int size = set.findSetSize(i);\n\t\t    if(size>result && !hash.contains(set.findSet(i)))\n\t\t        result = size;\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\t\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint get_root(int P[], int u) {\n  while (u != P[u]) {\n    P[u] = P[P[u]];\n    u = P[u];\n  }\n  return u;\n}\nvoid union_sets(int P[], int S[], int u, int v) {\n  u = get_root(P, u);\n  v = get_root(P, v);\n  if (u != v) {\n    if (S[u] >= S[v]) {\n      P[v] = u;\n      S[u] += S[v];\n    } else {\n      P[u] = v;\n      S[v] += S[u];\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, k, m, u, v;\n  cin >> n;\n  int P[n + 1], S[n + 1];\n  for (int i = 1; i <= n; i++) {\n    P[i] = i;\n    S[i] = 1;\n  }\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    cin >> u >> v;\n    union_sets(P, S, u, v);\n  }\n  cin >> m;\n  map<int, bool> F;\n  map<int, vector<int>> C;\n  for (int i = 1; i <= n; i++) {\n    F[get_root(P, i)] = true;\n    C[get_root(P, i)].push_back(i);\n  }\n  for (int i = 1; i <= m; i++) {\n    cin >> u >> v;\n    if (get_root(P, u) == get_root(P, v)) {\n      F[get_root(P, u)] = false;\n    }\n  }\n  int maxf = 0;\n  for (auto f : F) {\n    if (f.second) {\n      if ((int)C[f.first].size() > maxf) maxf = C[f.first].size();\n    }\n  }\n  cout << maxf << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def dfs (chain):\n    if chain:\n        for c in chain:\n            if c not in groups:\n                groups.add(c)\n                dfs(graph[c-1])\n            graph[c-1].clear()\ngraph= [[] for _ in range(int(input()))]; sev = len(graph)\ngroups,inv,ind = set(),{},1\nfor _ in range(int(input())):\n    u,v = map(int,input().split())\n    graph[u-1].append(v)\nfor i,g in enumerate(graph):\n    if g:\n        groups.add(i+1)\n        dfs(g); inv[ind] = [p for p in groups]\n        ind+=1; groups.clear()\ngraph = [set() for _ in range(sev)]\nfor f in inv:\n    for k in inv[f]: graph[k-1].add(f)\nfor g in range(sev):\n    if not graph[g]: inv[g+1] = [g+1]\nfor _ in range(int(input())):\n    cat = [x for x in map(int,input().split())]\n    gat = graph[cat[0]-1].intersection(graph[cat[1]-1])\n    if gat:\n        for s in cat:\n            for l in graph[s-1]:\n                try: inv.pop(l)\n                except KeyError: continue\nif inv: print(len(max(inv.items(),key = lambda x: len(x[1]))[1]))\nelse: print(0)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n \npublic class Solution {\n\tpublic static void main (String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n\t\tString[] temp=br.readLine().trim().split(\" \");\n\t\tint V=Integer.parseInt(temp[0]);\n\t\tint m=Integer.parseInt(br.readLine());\n\t\tDSU graph=new DSU(V);\n\t\tfor(int i=0;i<m;i++){\n\t\t    temp=br.readLine().trim().split(\" \");\n\t\t    int u=Integer.parseInt(temp[0]);\n\t\t    int v=Integer.parseInt(temp[1]);\n\t\t    \n\t\t    graph.makeUnion(u,v);\n\t\t}\n\t\tm=Integer.parseInt(br.readLine());\n\t\tboolean[] friendsAndEnemiesPresent=new boolean[V+1];\n\t\tfor(int i=0;i<m;i++){\n\t\t    temp=br.readLine().trim().split(\" \");\n\t\t    int u=Integer.parseInt(temp[0]);\n\t\t    int v=Integer.parseInt(temp[1]);\n\t\t    \n\t\t    int parent1=graph.getParent(u);\n\t\t    int parent2=graph.getParent(v);\n\t\t    if(parent1==parent2){\n\t\t        friendsAndEnemiesPresent[parent1]=true;\n\t\t    }\n\t\t}\n\t\tint maxComponentSize=0;\n\t\tfor(int i=1;i<=V;i++){\n\t\t    int parent=graph.getParent(i);\n\t\t    if(friendsAndEnemiesPresent[parent]==false){\n\t\t        maxComponentSize=Math.max(maxComponentSize,graph.componentSize(parent));\n\t\t    }\n\t\t}\n\t\tSystem.out.println(maxComponentSize);\n\t}\n}\n\nclass DSU{\n    private int[] parent;\n    private int[] size;\n    \n    public DSU(int V){\n        parent=new int[V+1];\n        size=new int[V+1];\n        for(int i=1;i<=V;i++){\n            parent[i]=i;\n            size[i]=1;\n        }\n    }\n    public int getParent(int vertex){\n        int temp=vertex;\n        while(vertex!=parent[vertex]){\n            vertex=parent[vertex];\n        }\n        parent[temp]=vertex;\n        return vertex;\n    }\n    public void makeUnion(int u,int v){\n        int parent1=this.getParent(u);\n        int parent2=this.getParent(v);\n        if(parent1==parent2){\n            return;\n        }\n        int size1=size[parent1];\n        int size2=size[parent2];\n        if(size2<size1){\n            parent[parent2]=parent1;\n            size[parent1]+=size[parent2];\n        }\n        else{\n            parent[parent1]=parent2;\n            size[parent2]+=size[parent1];\n        }\n    }\n    public int componentSize(int vertex){\n        int parent=this.getParent(vertex);\n        return size[parent];\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int mod = 1e9 + 7;\nlong long int const maxn = 2e3 + 5;\nlong long int const inf = 1e18;\nlong long int add(long long int a, long long int b) {\n  return ((a % mod) + (b % mod)) % mod;\n}\nlong long int mul(long long int a, long long int b) {\n  return ((a % mod) * (b % mod)) % mod;\n}\nlong long int powm(long long int x, long long int n, long long int M) {\n  long long int result = 1;\n  while (n > 0) {\n    if (n % 2 == 1) result = (result * x) % M;\n    x = (x * x) % M;\n    n = n / 2;\n  }\n  return result;\n}\nbool prime(long long int x) {\n  if (x < 2) return false;\n  for (int i = 2; i <= sqrt(x); i++) {\n    if (x % i == 0) return false;\n  }\n  return true;\n}\nlong long int P[maxn];\nlong long int sz[maxn];\nlong long int find_set(long long int x) {\n  if (x != P[x]) P[x] = find_set(P[x]);\n  return P[x];\n}\nvoid merge_set(long long int a, long long int b) {\n  a = find_set(a);\n  b = find_set(b);\n  if (a != b) {\n    if (sz[b] >= sz[a]) swap(a, b);\n    P[b] = a;\n    sz[a] += sz[b];\n    sz[b] = 0;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  for (int i = 0; i <= 2000; i++) {\n    P[i] = i;\n    sz[i] = 1;\n  }\n  long long int n;\n  cin >> n;\n  long long int k;\n  cin >> k;\n  while (k--) {\n    long long int x, y;\n    cin >> x >> y;\n    if (find_set(x) != find_set(y)) {\n      merge_set(x, y);\n    }\n  }\n  long long int m;\n  cin >> m;\n  while (m--) {\n    long long int x, y;\n    cin >> x >> y;\n    x = find_set(x);\n    y = find_set(y);\n    if (x == y) {\n      sz[x] = 0;\n      sz[y] = 0;\n    }\n  }\n  long long int ans = 0;\n  for (int i = 1; i <= n; i++) ans = max(ans, sz[P[i]]);\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, k, m;\nmap<pair<long long int, long long int>, long long int> mp;\nvector<vector<long long int>> v(2005);\nvector<long long int> vis;\nvector<long long int> s;\nvoid dfs(long long int r) {\n  vis[r] = 1;\n  s.push_back(r);\n  for (auto cc : v[r]) {\n    if (vis[cc] == 0) {\n      dfs(cc);\n    }\n  }\n}\nint32_t main() {\n  cin >> n;\n  vis.resize(n + 1, 0);\n  v.resize(n + 1);\n  long long int mx = 0;\n  cin >> k;\n  for (long long int i = 0; i < k; i++) {\n    long long int x, y;\n    cin >> x >> y;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  cin >> m;\n  for (long long int i = 0; i < m; i++) {\n    long long int x, y;\n    cin >> x >> y;\n    mp[make_pair(x, y)]++;\n    mp[make_pair(y, x)]++;\n  }\n  vector<vector<long long int>> v;\n  for (long long int i = 1; i <= n; i++) {\n    if (vis[i] == 0) {\n      vector<long long int> t;\n      dfs(i);\n      v.push_back(s);\n      s = t;\n    }\n  }\n  for (long long int i = 0; i < v.size(); i++) {\n    long long int in = 0;\n    for (long long int j = 0; j < v[i].size() - 1; j++) {\n      for (long long int jj = j + 1; jj < v[i].size(); jj++) {\n        if (mp[{v[i][j], v[i][jj]}] > 0 || mp[{v[i][jj], v[i][j]}] > 0) in++;\n      }\n    }\n    long long int xx = v[i].size();\n    if (in == 0) mx = max(mx, xx);\n  }\n  cout << mx << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 3e4 + 100;\nint root[MAXN], sz[MAXN];\nbool mark[MAXN];\nint get_root(int u) { return (root[u] ? root[u] = get_root(root[u]) : u); }\nvoid merge(int u, int v) {\n  int ru = get_root(u);\n  int rv = get_root(v);\n  if (rv == ru) return;\n  root[ru] = rv;\n  sz[rv] += sz[ru];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n, k, m, x, y;\n  cin >> n >> k;\n  fill(sz + 1, sz + n + 1, 1);\n  for (int i = 0; i < k; i++) {\n    cin >> x >> y;\n    merge(x, y);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> x >> y;\n    if (get_root(x) == get_root(y)) mark[get_root(y)] = true;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int r = get_root(i);\n    if (mark[r]) continue;\n    ans = max(ans, sz[r]);\n    mark[r] = true;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<vector<int>> friends;\nvector<vector<int>> enemies;\nvector<int> parent;\nint cnt;\nbool dfs(int node, int color) {\n  parent[node] = color;\n  cnt++;\n  bool result = true;\n  for (int next : friends[node])\n    if (parent[next] == 0) result = dfs(next, color) && result;\n  for (int next : enemies[node])\n    if (parent[next] == color) result = false;\n  return result;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  cin >> n;\n  friends.resize(n);\n  enemies.resize(n);\n  parent.resize(n, 0);\n  int m, a, b;\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    cin >> a >> b;\n    a--;\n    b--;\n    friends[a].push_back(b);\n    friends[b].push_back(a);\n  }\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    cin >> a >> b;\n    a--;\n    b--;\n    enemies[a].push_back(b);\n    enemies[b].push_back(a);\n  }\n  int result = 0, color = 0;\n  for (int i = 0; i < n; ++i)\n    if (parent[i] == 0) {\n      cnt = 0;\n      if (dfs(i, ++color)) {\n        result = max(result, cnt);\n      }\n    }\n  cout << result << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000;\nbool fr[N][N], en[N][N];\nbool u[N];\nint comp[N];\nvoid dfs(int v, int k, int n) {\n  u[v] = true;\n  comp[v] = k;\n  for (int i = 0; i < n; ++i)\n    if (fr[v][i] && !u[i]) dfs(i, k, n);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, k, m;\n  cin >> n >> k;\n  for (int i = 0; i < n; ++i) u[i] = false;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j) fr[i][j] = en[i][j] = false;\n  for (int i = 0; i < k; ++i) {\n    int a, b;\n    cin >> a >> b;\n    --a;\n    --b;\n    fr[a][b] = fr[b][a] = true;\n  }\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    cin >> a >> b;\n    --a;\n    --b;\n    en[a][b] = en[b][a] = true;\n  }\n  int kf = 0;\n  for (int i = 0; i < n; ++i)\n    if (!u[i]) dfs(i, kf++, n);\n  int ans = 0;\n  for (int i = 0; i < kf; ++i) {\n    int s = 0;\n    for (int j = 0; j < n; ++j)\n      if (comp[j] == i) ++s;\n    vector<int> v;\n    for (int j = 0; j < n; ++j)\n      if (comp[j] == i) v.push_back(j);\n    bool ok = true;\n    for (int ii = 0; ii < v.size() && ok; ++ii)\n      for (int j = ii + 1; j < v.size() && ok; ++j)\n        if (en[v[ii]][v[j]]) ok = false;\n    if (ok) ans = max(ans, s);\n  }\n  cout << ans;\n  cin >> n;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long N, M, K;\nvector<pair<long long, long long>> enemies;\nvector<long long> adj[2001];\nbool visited[2001];\nlong long comp_count = 0;\nlong long component[2001];\nlong long numNodes[2001];\nlong long currNode = 0;\nunordered_set<long long> hateComps[2001];\nlong long maxInvite = INT_MIN;\nvoid dfs(long long s) {\n  if (visited[s]) return;\n  visited[s] = true;\n  component[s] = comp_count;\n  currNode++;\n  for (auto u : adj[s]) dfs(u);\n}\nvoid findComponents() {\n  for (auto(i) = 0; i < N; i++) {\n    if (!visited[i]) {\n      comp_count++;\n      currNode = 0;\n      dfs(i);\n      numNodes[comp_count - 1] = currNode;\n    }\n  }\n}\nvoid findHated() {\n  for (auto(i) = 0; i < M; i++) {\n    pair<long long, long long> curr = enemies[i];\n    long long comp1 = component[curr.first] - 1;\n    long long comp2 = component[curr.second] - 1;\n    hateComps[comp1].insert(comp2);\n    hateComps[comp2].insert(comp1);\n  }\n}\nvoid findMaxInvite() {\n  for (auto(i) = 0; i < comp_count; i++) {\n    long long curr = numNodes[i];\n    for (auto u : hateComps[i]) {\n      if (u == i) {\n        curr = 0;\n        break;\n      }\n    }\n    maxInvite = max(maxInvite, curr);\n  }\n}\nvoid debugPrint() {\n  cout << \"The number of connected components : \" << comp_count << \"\\n\";\n  cout << \"The number of nodes in each connected component : \";\n  for (auto(i) = 0; i < comp_count; i++) cout << numNodes[i] << \" \";\n  cout << \"\\nHated Components : \";\n  for (auto(i) = 0; i < comp_count; i++) {\n    cout << i << \" : \";\n    for (auto u : hateComps[i]) cout << u << \" \";\n    cout << \"--> \";\n  }\n  cout << \"\\nFINAL ANSWER : \" << maxInvite;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> N;\n  cin >> K;\n  for (auto(i) = 0; i < K; i++) {\n    long long a, b;\n    cin >> a >> b;\n    --a;\n    --b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  cin >> M;\n  for (auto(i) = 0; i < M; i++) {\n    long long a, b;\n    cin >> a >> b;\n    --a;\n    --b;\n    enemies.push_back(make_pair(a, b));\n  }\n  for (auto(i) = 0; i < N; i++) visited[i] = false;\n  findComponents();\n  findHated();\n  findMaxInvite();\n  cout << maxInvite;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> *friends = new vector<int>[n + 1];\n  int k;\n  cin >> k;\n  int u, v;\n  for (int t = 0; t < k; t++) {\n    cin >> u >> v;\n    friends[u].push_back(v);\n    friends[v].push_back(u);\n  }\n  vector<int> component_sizes;\n  int *in_which = new int[n + 1];\n  for (int i = 1; i <= n; i++) in_which[i] = -1;\n  int component = 0;\n  for (int i = 1; i <= n; i++) {\n    if (in_which[i] == -1) {\n      int compSize = 1;\n      int seed = i;\n      stack<int> all_vert;\n      all_vert.push(seed);\n      in_which[seed] = component;\n      while (!all_vert.empty()) {\n        seed = all_vert.top();\n        all_vert.pop();\n        for (int j = 0; j < friends[seed].size(); j++) {\n          int nova = friends[seed][j];\n          if (in_which[nova] == -1) {\n            all_vert.push(nova);\n            in_which[nova] = component;\n            compSize++;\n          }\n        }\n      }\n      component++;\n      component_sizes.push_back(compSize);\n    }\n  }\n  bool *can_take = new bool[component];\n  memset(can_take, true, component);\n  int m;\n  cin >> m;\n  for (int t = 0; t < m; t++) {\n    cin >> u >> v;\n    if (in_which[u] == in_which[v]) {\n      can_take[in_which[u]] = false;\n    }\n  }\n  int result = 0;\n  for (int i = 0; i < component; i++) {\n    if (can_take[i]) result = max(result, component_sizes[i]);\n  }\n  cout << result;\n  delete[] friends, in_which, can_take;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int qpow(int b, int e, int m = 998244353) {\n  int a = 1;\n  for (; e; e >>= 1, b = (long long)b * b % m)\n    if (e & 1) a = (long long)a * b % m;\n  return a;\n}\nint vis[2001];\nint cc[2001];\nvoid dfs(int u, vector<vector<int>> &adj) {\n  vis[u] = 1;\n  cc[u] = 1;\n  for (int j = 0; j < adj[u].size(); j++) {\n    int v = adj[u][j];\n    if (vis[v] == 0) {\n      dfs(v, adj);\n    }\n  }\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<vector<int>> adj(n + 1);\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  memset(vis, 0, sizeof vis);\n  int ans = 0;\n  int m;\n  cin >> m;\n  vector<vector<bool>> dislike(n + 1, vector<bool>(n + 1));\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    dislike[u][v] = 1;\n    dislike[v][u] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (vis[i] == 0) {\n      memset(cc, 0, sizeof cc);\n      dfs(i, adj);\n      int cnt = 0;\n      int test = 0;\n      for (int j = 1; j <= n; j++) {\n        if (cc[j] == 1) {\n          for (int k = 1; k <= n; k++) {\n            if (dislike[j][k] && cc[k]) {\n              test = 1;\n              goto out;\n            }\n          }\n          cnt++;\n        }\n      }\n      int c;\n    out:\n      if (test == 0) {\n        ans = max(cnt, ans);\n      }\n    }\n  }\n  cout << ans << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t;\n  t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MOD = 1e9 + 7;\nusing namespace std;\nconst int N = 299;\nvector<int> adj[N], dislike[N];\nbool vis[N];\nvector<int> V;\nint ans = 0, group = 0;\nvoid dfs(int u) {\n  vis[u] = 1;\n  ++group;\n  for (int v : adj[u]) {\n    if (!vis[v]) {\n      dfs(v);\n    }\n  }\n  for (int v : dislike[u]) {\n    if (vis[v]) group = -1e9;\n  }\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  int k;\n  cin >> k;\n  for (int i = 0; i < k; ++i) {\n    int u, v;\n    cin >> u >> v;\n    dislike[u].push_back(v);\n    dislike[v].push_back(u);\n  }\n  for (int i = 1; i <= n; ++i) {\n    dfs(i);\n    ans = max(ans, group);\n    group = 0;\n    memset(vis, 0, sizeof(vis));\n  }\n  cout << ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n}\n"
        },
        {
            "language": 4,
            "solution": " import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.lang.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.regex.*;\npublic class Main {\n           public static ArrayList a[]=new ArrayList[300001];\n           static boolean visited[]=new boolean[3000001];\n           static int parent[]=new int[300001];\n           static int size[]=new int[3000001];\n           static void ini() {\n        \t   for(int i=0;i<=2000;i++) {\n        \t\t   size[i]=1;\n        \t\t   parent[i]=i;\n        \t   }\n           }\n           static int root(int n) {\n        \t   while(parent[n]!=n) {\n        \t\t   parent[n]=parent[parent[n]];\n        \t\t   n=parent[n];\n        \t   }\n        \t   return n;\n           }\n           static void union(int a,int b) {\n        \t   int root_a=root(a);\n        \t   int root_b=root(b);\n        \t   if(root_a==root_b)\n        \t\t  return ;\n        \t   size[root_a]+=size[root_b];\n        \t   parent[root_b]=root_a; \n        \t   size[root_b]=0;\n           }\n           static boolean find(int a,int b) {\n        \t   if(root(a)==root(b))\n        \t\t   return true;\n        \t   else\n        \t\t   return false;\n           }\n\t\t\tpublic static void main(String[] args) \n\t        {\n\t            InputReader in = new InputReader(System.in);\n\t            PrintWriter pw = new PrintWriter(System.out);\n\t            ini();\n\t            int n=in.nextInt();\n\t            int m=in.nextInt();\n\t            for(int i=0;i<m;i++) {\n\t            \t\n\t            \tint x=in.nextInt();\n\t            \tint y=in.nextInt();\n\t            \tunion(x,y);\n\n\t            }\n\t            m=in.nextInt();\n\t            for(int i=0;i<m;i++) {\n\t            \tint x=in.nextInt();\n\t            \tint y=in.nextInt();\n\t            \tif(find(x,y)) {\n\t            \t\tint r=root(x);\n\t            \t\tsize[r]=0;\n\t            \t}\n\t            }\n\t            int ans=Integer.MIN_VALUE;\n\t            for(int i=1;i<=n;i++) {\n\t            \tans=Math.max(ans, size[i]);\n\t            }\n\t            pw.println(ans);\n\t            pw.flush();\n\t            pw.close();\n\t        \n\t        }\n\t\tprivate static void debug(Object... o) {\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t\t}\n\t\tstatic class trie{\n\t\t\t\n\t\t\tInteger cnt;\n\t\t\ttrie a[];\n\t\t\ttrie(){\n\t\t\t\tcnt=0;\n\t\t\t    a=new trie[2];\n\t\t\t}\n\t\t\t\n\t\t}\n        static class InputReader \n        {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) \n        {\n            this.stream = stream;\n        }\n        public int snext() \n        {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) \n            {\n                curChar = 0;\n                try \n                {\n                    snumChars = stream.read(buf);\n                } \n                \n                catch (IOException e) \n                {\n                    throw new InputMismatchException();\n                }\n                \n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n \n        public int nextInt() \n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public long nextLong()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') \n            {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public int[] nextIntArray(int n) \n        {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) \n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        static class tri implements Comparable<tri> {\n            int p, c, l;\n \n            tri(int p, int c, int l) {\n                this.p = p;\n                this.c = c;\n                this.l = l;\n            }\n \n            public int compareTo(tri o) {\n                return Integer.compare(l, o.l);\n            }\n        }\n \n        public String readString()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n \n        public String nextLine() \n        {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n \n        public boolean isSpaceChar(int c) \n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        private boolean isEndOfLine(int c) \n        {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n \n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n        public static long mod = 1000000007;\n        public static long d;\n        //public static long p;\n        public static long q;\n        \n        public static int[] suffle(int[] a,Random gen)\n        {\n            int n = a.length;\n            for(int i=0;i<n;i++)\n            {\n                int ind = gen.nextInt(n-i)+i;\n                int temp = a[ind];\n                a[ind] = a[i];\n                a[i] = temp;\n            }\n            return a;\n        }\n        \n        public static void swap(int a, int b){\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        public static int primeFactorization(int n)\n        {\n            HashSet<Integer> a =new HashSet<Integer>();\n            int ans=Integer.MIN_VALUE;\n            for(int i=2;i*i<=n;i++)\n            {\n                while(n%i==0)\n                {\n                    ans=Math.max(ans, i);\n                    n/=i;\n                }\n            }\n            if(n!=1)\n            \tans=Math.max(ans, n);\n            return ans;\n        }\n        \n        public static void sieve(boolean[] isPrime,int n)\n        {\n            for(int i=1;i<n;i++)\n                isPrime[i] = true;\n            \n            isPrime[0] = false;\n            isPrime[1] = false;\n            \n            for(int i=2;i*i<n;i++)\n            {\n                if(isPrime[i] == true)\n                {\n                    for(int j=(2*i);j<n;j+=i)\n                        isPrime[j] = false;\n                }\n            }\n        }\n        \n        public static int GCD(int a,int b)\n        {\n            if(b==0)\n                return a;\n            else\n                return GCD(b,a%b);\n        }\n        \n        \n        public static long GCD(long a,long b)\n        {\n            if(b==0)\n                return a;\n            else\n                return GCD(b,a%b);\n        }\n        \n        public static void extendedEuclid(long d1,long d2)\n        {\n            if(d2==0)\n            {\n                d = d1;\n             //   p = 1 ;\n                q = 0;\n            }\n            else\n            {\n                extendedEuclid(d2, d1%d2);\n             //   long temp = p;\n              //  p = q;\n                //q = temp - (d1/d2)*q;\n            }\n        }\n        \n        public static long LCM(long a,long b)\n        {\n            return (a*b)/GCD(a,b);\n        }\n        \n        public static int LCM(int a,int b)\n        {\n            return (a*b)/GCD(a,b);\n        }\n        \n        public static int binaryExponentiation(int x,int n)\n        {\n            int result=1;\n            while(n>0)\n            {\n                if(n % 2 ==1)\n                    result=result * x;\n                x=x*x;\n                n=n/2;\n            }\n            return result;\n        }\n        \n        public static long binaryExponentiation(long x,long n)\n        {\n            long result=1;\n            while(n>0)\n            {\n                if(n % 2 ==1)\n                    result=result * x;\n                x=x*x;\n                n=n/2;\n            }\n            return result;\n        }\n        \n        public static int modularExponentiation(int x,int n,int M)\n        {\n            int result=1;\n            while(n>0)\n            {\n                if(n % 2 ==1)\n                    result=(result * x)%M;\n                x=(x%M*x)%M;\n                n=n/2;\n            }\n            return result;\n        }\n        \n        public static long modularExponentiation(long x,long n,long M)\n        {\n            long result=1;\n            while(n>0)\n            {\n                if(n % 2 ==1)\n                    result=(result%M * x%M)%M;\n                x=(x%M * x%M)%M;\n                n=n/2;\n            }\n            return result;\n        }\n        \n        public static long modInverse(int A,int M)\n        {\n            return modularExponentiation(A,M-2,M);\n        }\n        \n        public static long modInverse(long A,long M)\n        {\n            return modularExponentiation(A,M-2,M);\n        }\n        \n        public static boolean isPrime(int n)\n        {\n            \n            if (n <= 1)  return false;\n            if (n <= 3)  return true;\n            \n            if (n%2 == 0 || n%3 == 0) \n                return false;\n         \n            for (int i=5; i*i<=n; i=i+6)\n            {\n                if (n%i == 0 || n%(i+2) == 0)\n                   return false;\n            }\n            \n            return true;\n        }\n        \n         public static pair[] shuffle(pair[] t, Random gen){ \n                for(int i = 0, n = t.length;i < n;i++){ \n                    int ind = gen.nextInt(n-i)+i; \n                    pair d = t[i]; \n                    t[i] = t[ind]; \n                    t[ind] = d; \n                } \n                return t; \n            }\n        static class pair implements Comparable<pair>\n        {\n            Long x;\n            Integer y;\n            Integer z;\n            pair(long a,int w,int z)\n            {\n                this.x=a;\n                this.y=w;\n                this.z=z;\n            }\n \n\n \n \n \n \n \n        public int compareTo(pair o) {\n                int result = x.compareTo(o.x);\n                if(result==0)\n                    result = y.compareTo(o.y);\n                return result;\n            }  \n            \n            public String toString()\n            {\n                return x+\" \"+y+\" \"+z;\n            }\n            \n            public boolean equals(Object o)\n            {\n                if (o instanceof pair)\n                {\n                    pair p = (pair)o;\n                    return p.x == x && p.y == y ;\n                }\n                return false;\n            }\n            \n            public int hashCode()\n            {\n                return new Long(x).hashCode()*31 + new Long(y).hashCode();\n            }\n        }\n        \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int nMax = 2e3 + 2;\nvector<int> good[nMax];\nbool bad[nMax][nMax] = {false}, used[nMax] = {false};\nvector<int> comp;\ninline void dfs(int v) {\n  used[v] = true;\n  comp.push_back(v);\n  for (int i = 0; i < (int)good[v].size(); ++i) {\n    int to = good[v][i];\n    if (!used[to]) dfs(to);\n  }\n}\nsigned main() {\n  int n, m;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    good[u - 1].push_back(v - 1);\n    good[v - 1].push_back(u - 1);\n  }\n  int k;\n  scanf(\"%d\", &k);\n  while (k-- > 0) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    u--;\n    v--;\n    bad[u][v] = bad[v][u] = true;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (!used[i]) {\n      comp.clear();\n      dfs(i);\n      int curAns = (int)comp.size();\n      for (int i = 0; i < (int)comp.size() && curAns; i++) {\n        for (int j = 0; j < (int)comp.size() && curAns; ++j) {\n          int v = comp[i], to = comp[j];\n          if (i == j) continue;\n          if (bad[v][to]) {\n            curAns = -1;\n            break;\n          }\n        }\n      }\n      ans = max(ans, curAns);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n    //<editor-fold desc=\"input parse\" defaultstate=\"collapsed\">\n\n    private static StringTokenizer st;\n    private static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n    private static long nextLong() {\n        return Long.parseLong(st.nextToken());\n    }\n\n    private static int nextInt() {\n        return Integer.parseInt(st.nextToken());\n    }\n\n    private static double nextDouble() {\n        return Double.parseDouble(st.nextToken());\n    }\n\n    private static short nextShort() {\n        return Short.parseShort(st.nextToken());\n    }\n\n    private static byte nextByte() {\n        return Byte.parseByte(st.nextToken());\n    }\n\n    private static void initTokenizer() throws Exception {\n        st = new StringTokenizer(reader.readLine());\n    }\n\n    //</editor-fold>\n\n    private static ArrayList<Integer>[] graph;\n    private static ArrayList<Integer>[] tgraph;\n\n    private static boolean[] used;\n\n    private static int[] traversal;\n    private static int trav_index;\n\n    private static ArrayList<Integer> component;\n\n    private static void dfs(int v) {\n        used[v] = true;\n\n        for (int child : graph[v]) {\n            if (!used[child]) {\n                dfs(child);\n            }\n        }\n\n        traversal[trav_index++] = v;\n    }\n\n    private static void tdfs(int v) {\n        used[v] = true;\n        component.add(v);\n\n        for (int child : tgraph[v]) {\n            if (!used[child]) {\n                tdfs(child);\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        initTokenizer();\n\n        int nodes = nextInt();\n\n        initTokenizer();\n        int edges = nextInt();\n\n        graph  = new ArrayList[nodes];\n        tgraph = new ArrayList[nodes];\n\n        for (int i = 0; i < graph.length; i++) {\n            graph[i] = new ArrayList<>();\n            tgraph[i] = new ArrayList<>();\n        }\n\n        for (int edge = 0; edge < edges; edge++) {\n            initTokenizer();\n\n            int from = nextInt() - 1;\n            int to   = nextInt() - 1;\n\n            graph[from].add(to);\n            graph[to].add(from);\n            tgraph[to].add(from);\n            tgraph[from].add(to);\n        }\n\n        used        = new boolean   [nodes];\n        traversal   = new int       [nodes];\n\n        trav_index = 0;\n\n        for (int i = 0; i < used.length; i++) {\n            if (!used[i]) {\n                dfs(i);\n            }\n        }\n\n        graph = null;\n\n        Arrays.fill(used, false);\n\n        int[] comp = new int[nodes];\n        ArrayList<Integer> csize = new ArrayList<>();\n\n        component = new ArrayList<>();\n\n        int count = 0;\n\n        for (trav_index = traversal.length - 1; trav_index >= 0; trav_index--) {\n            if (!used[traversal[trav_index]]) {\n                tdfs(traversal[trav_index]);\n\n                for (int node : component) {\n                    comp[node] = count;\n                }\n\n                csize.add(component.size());\n                component.clear();\n\n                count++;\n            }\n        }\n\n        initTokenizer();\n\n        edges = nextInt();\n\n        boolean[] comps = new boolean[count];\n\n        for (int i = 0; i < edges; i++) {\n            initTokenizer();\n            int a = nextInt() - 1;\n            int b = nextInt() - 1;\n\n            if (comp[a] == comp[b]) {\n                comps[comp[a]] = true;\n            }\n        }\n\n        int best = 0;\n\n        for (int c = 0; c < count; c++) {\n            if (!comps[c]) {\n                best = Math.max(best, csize.get(c));\n            }\n        }\n\n        System.out.println(best);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> parent, s;\nvector<vector<long long int> > adj;\nvoid make_set(long long int v) {\n  parent[v] = v;\n  s[v] = 1;\n}\nlong long int find_set(long long int v) {\n  if (parent[v] == v)\n    return v;\n  else\n    return parent[v] = find_set(parent[v]);\n}\nvoid union_sets(long long int a, long long int b) {\n  a = find_set(a);\n  b = find_set(b);\n  if (a != b) {\n    parent[b] = a;\n    s[a] += s[b];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  long long int n, k;\n  cin >> n >> k;\n  adj.resize(n + 1);\n  s.resize(n + 1, 0);\n  parent.resize(n + 1);\n  for (long long int i = 1; i <= n; i++) make_set(i);\n  for (long long int i = 1; i <= k; i++) {\n    long long int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n    union_sets(u, v);\n  }\n  long long int m;\n  cin >> m;\n  for (long long int i = 1; i <= m; i++) {\n    long long int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n    if (find_set(u) == find_set(v)) {\n      parent[find_set(u)] = 0;\n    }\n  }\n  long long int ans = 0;\n  for (long long int i = 1; i <= n; i++)\n    if (parent[i] == i) {\n      ans = max(ans, s[i]);\n    }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint link[300000], next[300000], e[300000], top, f[10000];\nvoid connect(int t, int w) {\n  top++;\n  e[top] = w;\n  next[top] = link[t];\n  link[t] = top;\n}\nint main() {\n  int n, m1, m2, num[10000], b[10000], i, t, w, t2, p;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m1);\n  for (i = 0; i < m1; i++) {\n    scanf(\"%d%d\", &t, &w);\n    connect(t, w);\n    connect(w, t);\n  }\n  t2 = 0;\n  for (i = 1; i <= n; i++)\n    if (!f[i]) {\n      t = 0;\n      w = 1;\n      b[1] = i;\n      t2++;\n      f[i] = t2;\n      while (w > t) {\n        t++;\n        p = link[b[t]];\n        while (p) {\n          if (!f[e[p]]) {\n            f[e[p]] = t2;\n            w++;\n            b[w] = e[p];\n          }\n          p = next[p];\n        }\n      }\n      num[t2] = w;\n    }\n  scanf(\"%d\", &m2);\n  for (i = 0; i < m2; i++) {\n    scanf(\"%d%d\", &t, &w);\n    if (f[t] == f[w]) num[f[t]] = 0;\n  }\n  for (i = 2; i <= t2; i++)\n    if (num[i] > num[1]) num[1] = num[i];\n  printf(\"%d\", num[1]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 2010;\nint N;\nint ar[MAXN][MAXN];\nint used[MAXN];\nint vis[MAXN];\nint par;\nint enemy[MAXN][MAXN];\nvoid read() {\n  int i, M, a, b;\n  scanf(\" %d %d\", &N, &M);\n  for (i = 1; i <= M; i++) {\n    scanf(\" %d %d\", &a, &b);\n    ar[a][b] = ar[b][a] = 1;\n  }\n  scanf(\" %d\", &M);\n  for (i = 1; i <= M; i++) {\n    scanf(\" %d %d\", &a, &b);\n    enemy[a][b] = enemy[b][a] = 1;\n  }\n}\nvoid dfs(int a) {\n  vis[++par] = a;\n  used[a] = 1;\n  int i;\n  for (i = 1; i <= N; i++)\n    if (ar[a][i] && !used[i]) dfs(i);\n}\nbool control() {\n  int i, j;\n  for (i = 1; i <= par; i++)\n    for (j = 1; j <= par; j++)\n      if (enemy[vis[i]][vis[j]]) return false;\n  return true;\n}\nint main() {\n  read();\n  int i, max = 0;\n  for (i = 1; i <= N; i++)\n    if (!used[i]) {\n      par = 0;\n      dfs(i);\n      if (par > max && control()) max = par;\n    }\n  printf(\"%d\\n\", max);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint friends[2001][2001];\nint enemies[2001][2001];\nint vis[2001];\nvoid dfs(int v, vector<int> &gr, int &n) {\n  vis[v] = 1;\n  gr.push_back(v);\n  for (int i = 1; i <= n; i++) {\n    if (friends[v][i] && vis[i] == 0) {\n      dfs(i, gr, n);\n    }\n  }\n  return;\n}\nbool noenemy(vector<int> &gr) {\n  for (int i = 0; i < gr.size() - 1; i++) {\n    for (int j = i + 1; j < gr.size(); j++) {\n      if (enemies[gr[i]][gr[j]]) {\n        return 0;\n      }\n    }\n  }\n  return 1;\n}\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i <= 2000; i++) {\n    for (int j = 0; j <= 2000; j++) {\n      friends[i][j] = 0;\n      enemies[2001][2001] = 0;\n      vis[i] = 0;\n    }\n  }\n  int k;\n  cin >> k;\n  while (k) {\n    int u, v;\n    cin >> u >> v;\n    friends[u][v] = 1;\n    friends[v][u] = 1;\n    k--;\n  }\n  int m;\n  cin >> m;\n  while (m) {\n    int u, v;\n    cin >> u >> v;\n    enemies[u][v] = 1;\n    enemies[v][u] = 1;\n    m--;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (vis[i] == 0) {\n      vector<int> gr;\n      dfs(i, gr, n);\n      if (noenemy(gr)) {\n        ans = max(ans, (int)gr.size());\n      }\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint arr[1000000];\nint Size[1000000];\nvoid makeSet(int v) {\n  for (int i = 0; i < v; i++) {\n    arr[i] = i;\n    Size[i] = 1;\n  }\n}\nint find(int u) {\n  if (arr[u] == u) return u;\n  arr[u] = find(arr[u]);\n  return arr[u];\n}\nvoid munion(int u, int v) {\n  int rootu = find(u);\n  int rootv = find(v);\n  if (rootu == rootv) return;\n  if (Size[rootu] < Size[rootv]) {\n    arr[rootu] = arr[rootv];\n    Size[rootv] += Size[rootu];\n  } else {\n    arr[rootv] = arr[rootu];\n    Size[rootu] += Size[rootv];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  int n, k, m;\n  cin >> n >> k;\n  makeSet(n);\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    munion(u, v);\n  }\n  cin >> m;\n  bool stat[n];\n  for (int i = 0; i < n; i++) stat[i] = true;\n  ;\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    if (find(u) == find(v)) stat[find(u)] = false;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (stat[find(i)] == true) ans = max(ans, Size[find(i)]);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double pi = 3.141593;\nconst long long mod = 1000000007;\nconst long long INF = 1e15;\nconst long long nax = 1e5 + 5;\nlong long dx[] = {0, 0, 1, -1};\nlong long dy[] = {1, -1, 0, 0};\nstring ds = \"RLDU\";\nlong long parent[200001] = {0};\nlong long size[200001] = {0};\nlong long vi[200001] = {0};\nlong long find_set(long long v) {\n  while (parent[v] != v) v = parent[v];\n  return v;\n}\nvoid unite(long long a, long long b) {\n  a = find_set(a);\n  b = find_set(b);\n  if (a != b) {\n    parent[b] = a;\n    size[a] += size[b];\n  }\n}\nint32_t main() {\n  long long n, k;\n  cin >> n >> k;\n  for (long long i = 1; i <= n; i++) {\n    parent[i] = i;\n    size[i] = 1;\n  }\n  for (long long i = 0; i < k; i++) {\n    long long u, v;\n    cin >> u >> v;\n    unite(u, v);\n  }\n  long long m;\n  cin >> m;\n  map<long long, long long> M;\n  for (long long i = 0; i < m; i++) {\n    long long u, v;\n    cin >> u >> v;\n    long long a = find_set(u);\n    long long b = find_set(v);\n    if (a == b) M[a] = 1;\n  }\n  long long mx = 0;\n  for (long long i = 1; i <= n; i++) {\n    if (M[find_set(i)] == 0) {\n      mx = max(mx, size[find_set(i)]);\n    }\n  }\n  cout << mx << \"\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Solution {\n  Scanner in;\n\n  public void solve(\n    List<List<Integer>> friends,\n    List<List<Integer>> haters,\n    int n\n  ) {\n    int[] groupIds = new int[n];\n\n    int maxGroupSize = 0;\n    int curGroupId = 1;\n\n    for (int i = 0; i < n; i++) {\n      if (groupIds[i] != 0) {\n        // Already visited\n        continue;\n      }\n\n      ArrayDeque<Integer> stack = new ArrayDeque<>();\n      stack.push(i);\n      groupIds[i] = curGroupId;\n      int groupSize = 1;\n      boolean groupInvalid = false;\n      while (stack.size() != 0) {\n        int curPerson = stack.pop();\n\n        for (int hater : haters.get(curPerson)) {\n          if (groupIds[hater] == groupIds[curPerson]) {\n            groupInvalid = true;\n          }\n        }\n\n        for (int friend : friends.get(curPerson)) {\n          if (groupIds[friend] != 0) {\n            continue;\n          }\n          groupIds[friend] = curGroupId;\n          stack.push(friend);\n          groupSize += 1;\n        }\n      }\n\n      groupSize = groupInvalid ? -1 : groupSize;\n      if (groupSize > maxGroupSize) {\n        maxGroupSize = groupSize;\n      }\n\n      curGroupId += 1;\n    }\n\n    System.out.println(maxGroupSize);\n  }\n\n  public void run() {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n\n    List<List<Integer>> friends = new ArrayList<>(n);\n    List<List<Integer>> haters = new ArrayList<>(n);\n    for (int i = 0; i < n; i++) {\n      friends.add(i, new ArrayList<Integer>());\n      haters.add(i, new ArrayList<Integer>());\n    }\n\n    int k = in.nextInt();\n    for (int i = 0; i < k; i++) {\n      int from = in.nextInt() - 1;\n      int to = in.nextInt() - 1;\n      friends.get(from).add(to);\n      friends.get(to).add(from);\n    }\n\n    int m = in.nextInt();\n    for (int i = 0; i < m; i++) {\n      int from = in.nextInt() - 1;\n      int to = in.nextInt() - 1;\n      haters.get(from).add(to);\n      haters.get(to).add(from);\n    }\n\n    solve(friends, haters, n);\n  }\n\n  public static void main(String[] args) {\n    new Solution().run();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author El-Bishoy\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D2C177_Party solver = new D2C177_Party();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D2C177_Party {\n        boolean[][] dislkeEachOther;\n        ArrayList<Integer>[] adj;\n        boolean[] visited;\n        ArrayList<Integer> component = new ArrayList<>();\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            int n = in.nextInt(), k = in.nextInt();\n\n            dislkeEachOther = new boolean[n][n];\n            visited = new boolean[n];\n            buildAdj(n);\n            readAndConnectEdges(in, k);\n            readRelationship(in);\n\n\n            int max = 0;\n            for (int i = 0; i < n; i++) {\n                component.clear();\n                if (!visited[i]) {\n                    int cnt = dfs(i);\n                    if (checkForDislike()) {\n                        max = Math.max(cnt, max);\n                    }\n\n                }\n\n            }\n            out.println(max);\n\n\n        }\n\n        private boolean checkForDislike() {\n\n            for (int i = 0; i < component.size(); i++) {\n                int u = component.get(i);\n                for (int j = i + 1; j < component.size(); j++) {\n                    int v = component.get(j);\n\n                    if (dislkeEachOther[v][u])\n                        return false;\n                }\n            }\n\n\n            return true;\n        }\n\n        private void readRelationship(InputReader in) {\n            int m = in.nextInt();\n            while (m-- > 0) {\n                int u = in.nextInt() - 1, v = in.nextInt() - 1;\n                dislkeEachOther[u][v] = dislkeEachOther[v][u] = true;\n\n            }\n        }\n\n        int dfs(int v) {\n            visited[v] = true;\n            component.add(v);\n            int cnt = 1;\n            for (int u : adj[v]) {\n                if (!visited[u]) {\n                    cnt += dfs(u);\n                }\n            }\n\n            return cnt;\n        }\n\n        private void readAndConnectEdges(InputReader in, int k) {\n            while (k-- > 0) {\n                int u = in.nextInt() - 1, v = in.nextInt() - 1;\n                adj[u].add(v);\n                adj[v].add(u);\n\n            }\n        }\n\n        private void buildAdj(int n) {\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.util.List;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author hheng\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC1 solver = new TaskC1();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC1 {\n    boolean[] checked;\n    int[][] friend;\n    int n;\n    List<Integer> curList = new ArrayList<Integer>();\n    \n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        n = in.nextInt();\n        friend = new int[n][n];\n        for (int i=0; i<n; i++) Arrays.fill(friend[i], -1);\n        int k = in.nextInt();\n        for (int i=0; i<k; i++) {\n            int a = in.nextInt()-1, b = in.nextInt()-1;\n            friend[a][b] = 1;\n            friend[b][a] = 1;\n        }\n        int m = in.nextInt();\n        for (int i=0; i<m; i++) {\n            int a = in.nextInt()-1, b = in.nextInt()-1;\n            friend[a][b] = 0;\n            friend[b][a] = 0;\n        }\n        \n        checked = new boolean[n];\n        int res = 0;\n        while (true) {\n            int cur = -1;\n            for (int i=0; i<n; i++) if (!checked[i]) { cur = i; break; }\n            if (cur == -1) break;\n           \n            curList.clear();\n            populate(cur);\n            boolean ok = true;\n            for (int i=0; i<curList.size(); i++)\n                for (int j=i+1; j<curList.size(); j++) {\n                    if (friend[curList.get(i)][curList.get(j)] == 0) { ok = false; break; }\n                }\n            if (ok) res = Math.max(res, curList.size());\n        }\n        out.println(res);\n\t}\n    \n    public void populate(int a) {\n        if (checked[a]) return;\n        checked[a] = true;\n        curList.add(a);\n        for (int i=0; i<n; i++) {\n            if (friend[a][i] == 1) {\n                populate(i);\n            }\n        }\n    }\n    \n    \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1.0e-11;\nconst double pi = acos(-1.0);\nconst int N = 2009;\nvector<vector<int> > g;\nvector<vector<int> > components;\nbool adj[N][N];\nint used[N];\nvoid dfs(int v) {\n  used[v] = true;\n  components[components.size() - 1].push_back(v);\n  for (long long i = 0; i < (int)(g[v]).size(); i++) {\n    int to = g[v][i];\n    if (!used[to]) {\n      dfs(to);\n    }\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  g.resize(n);\n  int k, m;\n  cin >> k;\n  for (long long i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  cin >> m;\n  for (long long i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    adj[a][b] = adj[b][a] = 1;\n  }\n  for (long long i = 0; i < n; i++) {\n    if (!used[i]) {\n      components.push_back(vector<int>());\n      dfs(i);\n    }\n  }\n  long long res = 0;\n  for (long long i = 0; i < (int)(components).size(); i++) {\n    bool ok = true;\n    for (long long j = 0; j < (int)(components[i]).size(); j++) {\n      for (long long t = 0; t < (int)(components[i]).size(); t++) {\n        if (j == t) {\n          continue;\n        }\n        if (adj[components[i][j]][components[i][t]]) {\n          ok = false;\n        }\n      }\n    }\n    if (ok) {\n      res = max(res, (long long)components[i].size());\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 2e3 + 100;\nlong long n, m, k;\nvector<long long> adj[MAXN], path;\nbool vis[MAXN], Bad[MAXN][MAXN];\nvoid dfs(long long x) {\n  vis[x] = true;\n  path.push_back(x);\n  for (long long i = 0; i < adj[x].size(); i++) {\n    if (!vis[adj[x][i]]) {\n      dfs(adj[x][i]);\n    }\n  }\n  return;\n}\nint check(long long x) {\n  path.clear();\n  dfs(x);\n  for (long long i = 0; i < path.size(); i++)\n    for (long long j = i + 1; j < path.size(); j++)\n      if (Bad[path[i]][path[j]]) return 0;\n  return path.size();\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (long long i = 0; i < m; i++) {\n    long long u, v;\n    cin >> u >> v;\n    adj[u].push_back(v), adj[v].push_back(u);\n  }\n  cin >> k;\n  for (long long i = 0; i < k; i++) {\n    long long u, v;\n    cin >> u >> v;\n    Bad[u][v] = true, Bad[v][u] = true;\n  }\n  int ans = -1;\n  for (long long i = 1; i <= n; i++) {\n    ans = max(ans, check(i));\n    for (long long i = 1; i <= n; i++) vis[i] = false;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long const MAX = 1e5 + 5;\nusing namespace std;\nset<pair<long long, long long> > st;\nvector<long long> adj[2001];\nlong long vis[2001];\nvector<long long> visit;\nvoid dfs(long long v) {\n  vis[v] = 1;\n  visit.push_back(v);\n  for (auto i : adj[v]) {\n    if (!vis[i]) dfs(i);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  for (long long i = 0; i < k; i++) {\n    long long x, y;\n    cin >> x >> y;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  long long m;\n  cin >> m;\n  for (long long i = 0; i < m; i++) {\n    long long x, y;\n    cin >> x >> y;\n    if (x > y) swap(x, y);\n    st.insert({x, y});\n  }\n  long long ans = 0;\n  for (long long i = 1; i < n + 1; i++) {\n    if (!vis[i]) {\n      visit.clear();\n      dfs(i);\n      long long cnt = visit.size();\n      int f = 0;\n      for (long long j = 0; j < cnt; j++) {\n        for (long long k = 0; k < cnt; k++) {\n          if (st.find({min(visit[j], visit[k]), max(visit[j], visit[k])}) !=\n              st.end())\n            f = 1;\n        }\n      }\n      if (f == 0) ans = max(ans, cnt);\n    }\n  }\n  return cout << ans, 0;\n  ;\n}\n"
        },
        {
            "language": 1,
            "solution": "from collections import deque\n\ndef bfs(friends, enemies, root, visited):\n    visited[root] = True\n    q = deque([root])\n    haters = set()\n    not_valid = False\n    num_elements = 0\n    while len(q) > 0:\n        node = q.popleft()\n        if node in haters:\n            not_valid = True\n        num_elements += 1\n        haters.update(enemies[node])\n        for child in friends[node]:\n            if child in haters:\n                not_valid = True\n            if not visited[child]:\n                visited[child] = True\n                q.append(child)\n    return num_elements, not_valid\n\n\nn = int(raw_input())\n#Friends\nk = int(raw_input())\nfriends = [[] for _ in range(n)]\nfor _ in range(k):\n    node1, node2 = map(int, raw_input().split(' '))\n    node1 -= 1\n    node2 -= 1\n    friends[node1].append(node2)\n    friends[node2].append(node1)\n# Enemies\nm = int(raw_input())\nenemies = [[] for _ in range(n)]\nfor _ in range(m):\n    node1, node2 = map(int, raw_input().split(' '))\n    node1 -= 1\n    node2 -= 1\n    enemies[node1].append(node2)\n    enemies[node2].append(node1)\n\nvisited = n * [False]\nmax_people = 0\nfor node in range(n):\n    if not visited[node]:\n        num, not_valid = bfs(friends, enemies, node, visited)\n        if not not_valid:\n            if max_people < num:\n                max_people = num\n\nprint max_people\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class Main\n\t{\n\tpublic static void main(String args[])\tthrows IOException\n\t\t{\n\t\t//BufferedReader c=new BufferedReader(new InputStreamReader(System.in));\n\t\tScanner c=new Scanner(System.in);\n\t\tint N=c.nextInt();\n\t\tuGraph G=new uGraph(N);\n\t\tint M=c.nextInt();\n\t\tfor(int i=0;i<M;i++) \n\t\t\tG.add_edge(c.nextInt()-1,c.nextInt()-1);\n\t\tList<TreeSet<Integer>> scc=G.getConnectedComponents();\n\t\tint K=c.nextInt();\n\t\tint U[]=new int[K];\n\t\tint V[]=new int[K];\n\t\t\n\t\tfor(int i=0;i<K;i++) \n\t\t\t{\n\t\t\tU[i]=c.nextInt()-1;\n\t\t\tV[i]=c.nextInt()-1;\n\t\t\t}\n\t\tint max=0;\n\t\tIterator<TreeSet<Integer>> it=scc.iterator();\n\t\twhile(it.hasNext())\n\t\t\t{\n\t\t\tTreeSet<Integer> L=it.next();\n\t\t\tboolean valid=true;\n\t\t\tfor(int i=0;i<K;i++) \n\t\t\t\t{\n\t\t\t\tif(L.contains(U[i])&&L.contains(V[i]))\n\t\t\t\t\tvalid=false;\n\t\t\t\t}\n\t\t\tif(valid&&L.size()>max)\n\t\t\t\tmax=L.size();\n\t\t\t}\n\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n/*Undirected graph class. Vertices are indexed 0-->N-1*/\nclass uGraph\n\t{\n\tint N;\t\t\t\t\t\t\t//number of nodes\n\tTreeSet<Integer> edge_list[];\t\t\n\tpublic uGraph(int N)\n\t\t{\n\t\tthis.N=N;\n\t\tedge_list=new TreeSet[N];\n\t\tfor(int i=0;i<N;i++) \t\t//create N Linked Lists\n\t\t\tedge_list[i]=new TreeSet<Integer>();\n\t\t}\n\n\t/*\n\t * Adds a new undirected edge u-v to the graph\n\t */\n\tpublic void add_edge(int u,int v)\n\t\t{\n\t\tedge_list[u].add(v);\n\t\tedge_list[v].add(u);\n\t\t}\n\t/*\n\t * Returns a List containing >=1 linked lists. Each linked list \t\n\t * is a separate connected component of the undirected graph.\n\t */\n\tpublic List<TreeSet<Integer>> getConnectedComponents()\n\t\t{\t\t\n\t\tList<TreeSet<Integer>> scc=new LinkedList<TreeSet<Integer>>();\t\t//a list of linked lists\t\n\t\tboolean visited[]=new boolean[N];\t\t\n\t\tfor(int i=0;i<N;i++) \t\t\n\t\t\t{\n\t\t\tif(!visited[i])\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//choose an unvisited node\n\t\t\t\t{\n\t\t\t\tvisited[i]=true;\n\t\t\t\tTreeSet<Integer> newComponent= new TreeSet<Integer>();\t\t//a Linked List for the new component\n\t\t\t\tQueue<Integer> Q=new LinkedList<Integer>();\t\t\t\t\t\t\t//a queue for BFS\n\t\t\t\tQ.add(i);\n\t\t\t\tnewComponent.add(i);\n\t\t\n\t\t\t\twhile(!Q.isEmpty())\n\t\t\t\t\t{\n\t\t\t\t\tint node=Q.poll();\n\t\t\t\t\tIterator<Integer> it=edge_list[node].iterator();\n\t\t\t\t\twhile(it.hasNext())\n\t\t\t\t\t\t{\n\t\t\t\t\t\tint neighbour=it.next();\n\t\t\t\t\t\tif(!visited[neighbour])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvisited[neighbour]=true;\n\t\t\t\t\t\t\tQ.add(neighbour);\n\t\t\t\t\t\t\tnewComponent.add(neighbour);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tscc.add(newComponent);\t\t\t\t\t\t\t\t\t\t\t\t//add a new strongly connected component\n\t\t\t\t}\n\t\t\t}\n\t\treturn scc;\n\t\t}\n\t}\n\n//must declare new classes here"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n\nimport java.util.*;\n\nimport sun.management.counter.Variability;\n\npublic class CodeForces {\n\n\tpublic void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\tMap<Integer, List<Integer>> fr = new HashMap<Integer, List<Integer>>();\n\t\tboolean[][] unfr = new boolean[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfr.put(i, new ArrayList<Integer>());\n\t\t\tArrays.fill(unfr[i], false);\n\t\t}\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint a = nextInt() - 1;\n\t\t\tint b = nextInt() - 1;\n\t\t\tfr.get(a).add(b);\n\t\t\tfr.get(b).add(a);\n\t\t}\n\t\tint m = nextInt();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = nextInt() - 1;\n\t\t\tint b = nextInt() - 1;\n\t\t\tunfr[a][b] = true;\n\t\t\tunfr[b][a] = true;\n\t\t}\n\t\tSet<Integer> vert = new HashSet<Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvert.add(i);\n\t\t}\n\t\tint max = 0;\n\t\tList<Integer[]> res = new ArrayList<Integer[]>();\n\t\twhile (!vert.isEmpty()) {\n\t\t\tList<Integer> zf = new ArrayList<Integer>();\n\t\t\tList<Integer> res1 = new ArrayList<Integer>();\n\t\t\tint z = vert.iterator().next();\n\t\t\tvert.remove(z);\n\t\t\tres1.add(z);\n\t\t\tfor (int s : fr.get(z)) {\n\t\t\t\tzf.add(s);\n\t\t\t}\n\t\t\twhile (!zf.isEmpty()) {\n\t\t\t\tint vert1 = zf.get(0);\n\t\t\t\tzf.remove(0);\n\t\t\t\tif (vert.contains(vert1)) {\n\t\t\t\t\tfor (int s : fr.get(vert1)) {\n\t\t\t\t\t\tzf.add(s);\n\t\t\t\t\t}\n\t\t\t\t\tres1.add(vert1);\n\t\t\t\t}\n\t\t\t\tvert.remove(vert1);\n\t\t\t}\n\t\t\tres.add(res1.toArray(new Integer[0]));\n\t\t}\n\t\tfor (Integer[] arr : res) {\n\t\t\tBoolean can = true;\n\t\t\tfor (int i = 0, l = arr.length; i < l; i++) {\n\t\t\t\tif (!can)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int j = i + 1, ll = arr.length; j < ll; j++) {\n\t\t\t\t\tif (unfr[arr[i]][arr[j]]) {\n\t\t\t\t\t\tcan = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(can){\n\t\t\t\tmax=Math.max(max, arr.length);\n\t\t\t}\n\t\t}\n\n\t\tout.println(max);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew CodeForces().run();\n\t}\n\n\tint NOD(int a, int b) {\n\t\twhile (a != 0 && b != 0) {\n\t\t\tif (a >= b)\n\t\t\t\ta = a % b;\n\t\t\telse\n\t\t\t\tb = b % a;\n\t\t}\n\t\treturn a + b;\n\t}\n\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter out;\n\tboolean isOuterFile = false;\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tif (isOuterFile) {\n\t\t\t\treader = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\tout = new PrintWriter(new BufferedWriter(new FileWriter(\n\t\t\t\t\t\t\"output.txt\")));\n\t\t\t} else {\n\t\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\ttokenizer = null;\n\t\t\t// long time = new Date().getTime();\n\t\t\tsolve();\n\t\t\t// out.println(time - new Date().getTime());\n\t\t\treader.close();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 203600;\nint p[N], sz[N];\nint n, m;\nvoid init() {\n  for (int i = (0); i < (int)(n); i++) p[i] = i, sz[i] = 1;\n}\nint f(int first) {\n  if (first == p[first]) return first;\n  return p[first] = f(p[first]);\n}\nbool gao[N];\nint main() {\n  while (cin >> n) {\n    int m;\n    cin >> m;\n    init();\n    for (int i = (0); i < (int)(m); i++) {\n      int first, second;\n      cin >> first >> second;\n      --first;\n      --second;\n      int px = f(first), py = f(second);\n      if (px ^ py) {\n        sz[py] += sz[px];\n        sz[px] = 0;\n        p[px] = py;\n      }\n    }\n    memset(gao, 0, sizeof(gao));\n    cin >> m;\n    for (int i = (0); i < (int)(m); i++) {\n      int first, second;\n      cin >> first >> second;\n      --first;\n      --second;\n      if (f(first) == f(second)) {\n        gao[f(first)] = true;\n      }\n    }\n    int ans = 0;\n    for (int i = (0); i < (int)(n); i++)\n      if (f(i) == i && !gao[i]) {\n        ans = max(ans, sz[i]);\n      }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> > f;\nvector<vector<int> > d;\nvector<int> ch;\ninline int dfs(int v) {\n  ch[v] = 1;\n  for (int i = 0; i < (int)d[v].size(); i++)\n    if (ch[d[v][i]] == 1) return 0;\n  int ret = 1;\n  for (int i = 0; i < (int)f[v].size(); i++) {\n    if (ch[f[v][i]] == -1) return -1;\n    if (ch[f[v][i]] == 0) {\n      int newr = dfs(f[v][i]);\n      if (newr == 0) return 0;\n      if (newr == -1) return -1;\n      ret += newr;\n    }\n  }\n  return ret;\n}\nint main() {\n  ch.clear();\n  f.clear();\n  d.clear();\n  int n, k, m;\n  cin >> n;\n  cin >> k;\n  ch.resize(n, 0);\n  f.resize(n);\n  d.resize(n);\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    f[a - 1].push_back(b - 1);\n    f[b - 1].push_back(a - 1);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    d[a - 1].push_back(b - 1);\n    d[b - 1].push_back(a - 1);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int ne = dfs(i);\n    ans = max(ans, ne);\n    ch[i] = -1;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n = int(input())\nl = int(input())\nlikes_list = [[] for i in range(n + 1)]\nfor i in range(l):\n    a, b = map(int, input().split())\n    likes_list[a].append(b)\n    likes_list[b].append(a)\n\nd = int(input())\ndislikes_list = [[] for i in range(n + 1)]\nfor i in range(d):\n    a, b = map(int, input().split())\n    dislikes_list[a].append(b)\n    dislikes_list[b].append(a)\n\nv = [False] * (n + 1)\ngroups = {}\nf_id = [i for i in range(n + 1)]\n\nfor i in range(1, n + 1):\n    if not v[i]:\n        f = set()\n        s = [i]\n        while len(s) > 0:\n            x = s.pop()\n            f_id[x] = i\n            f.add(x)\n            if v[x]:\n                continue\n            v[x] = True\n            for y in likes_list[x]:\n                s.append(y)\n        groups[i] = f\n\nfor i in range(1, n + 1):\n    for ds in dislikes_list[i]:\n        groups[f_id[i]].difference_update({ds}.union(groups[f_id[ds]]))\n\nans = 0\nfor v in groups.values():\n    ans = max(ans, len(v))\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\tpublic static BufferedReader in;\n\tpublic static PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\n\t\tboolean showLineError = true;\n\t\tif (showLineError) {\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tsolve();\n\t\t\t} catch (Exception e) {\n\t\t\t} finally {\n\t\t\t\tout.close();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic void debug(Object... os) {\n\t\tout.println(Arrays.deepToString(os));\n\t}\n\tprivate static int comp;\n\n\tprivate static void solve() throws IOException {\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tint m1 = Integer.parseInt(in.readLine());\n\t\tList<Integer>[] g = (List<Integer>[]) new List[n];\n\t\tfor(int i =0;i<n;i++)\n\t\t\tg[i]= new ArrayList<Integer>();\n\t\tfor(int i =0;i<m1;i++){\n\t\t\tString[] line = in.readLine().split(\" \");\n\t\t\tint u = Integer.parseInt(line[0])-1;\n\t\t\tint v = Integer.parseInt(line[1])-1;\n\t\t\tg[u].add(v);\n\t\t\tg[v].add(u);\n\t\t}\n\t\tint[] ok =new int[n];\n\t\tArrays.fill(ok, -1);\n\t\tList<Integer> size=new ArrayList<Integer>();\n\t\tfor(int i =0;i<n;i++)\n\t\t\tif(ok[i]==-1){\n\t\t\t\tok[i]=comp;\n\t\t\t\tsize.add(dfs(g,ok,i));\n\t\t\t\tcomp++;\n\t\t\t}\n\t\tint m2 = Integer.parseInt(in.readLine());\n\t\tfor(int i =0;i<m2;i++){\n\t\t\tString[] line = in.readLine().split(\" \");\n\t\t\tint u = Integer.parseInt(line[0])-1;\n\t\t\tint v = Integer.parseInt(line[1])-1;\n\t\t\t\n\t\t\tif(ok[u]==ok[v])\n\t\t\t\tsize.set(ok[u], 0);\n\t\t}\n\t\tint ret= 0;\n\t\tfor(int a : size)\n\t\t\tret = Math.max(ret, a);\n\t\tout.println(ret);\n\t}\n\n\tprivate static int dfs(List<Integer>[] g, int[] ok, int u) {\n\t\tint ret=1;\n\t\tfor(int v : g[u]){\n\t\t\tif(ok[v]==-1){\n\t\t\t\tok[v]=comp;\n\t\t\t\tret+=dfs(g,ok,v);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package party2;\n\nimport java.util.Scanner;\n\n/**\n *\n * @author Pascal-PC\n */\npublic class Party2 {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        int k=in.nextInt();\n        int[] un=new int[n+10];\n        int[] size=new int[n+10];\n        \n        for (int i = 1; i <= n; i++) {\n           un[i]=i;\n           size[i]=1; \n        }\n        for (int i = 0; i < k; i++) {\n            int r=in.nextInt();\n            int l=in.nextInt();\n            r=find(un,r);\n            l=find(un,l);\n            if(l!=r){\n                un[r]=l;\n                int temp=size[r];\n                //size[r]+=size[l];\n                size[l]+=temp;\n            }\n        }\n        int q=in.nextInt();\n        for (int i = 0; i < q; i++) {\n                 int r=in.nextInt();\n                int l=in.nextInt();\n            r=find(un,r);\n            l=find(un,l);\n            if(l==r&&l!=-1){\n                un[r]=-1;\n                size[r]=0;\n                size[l]=0;\n            }\n        }\n        int m=0;\n        for (int i = 1; i <= n; i++) {\n            if(size[i]>m&&find(un,i)==i)\n                m=size[i];\n        }\n        System.out.println(m);\n    }\n    public static int find(int[] un,int p){\n        if(un[p]==p)return p;\n        else if(un[p]==-1) return -1;\n        else return find(un,un[p]);\n    }\n    \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint f[2048], z[2048];\nint rt(int x) { return (x == f[x] ? x : (f[x] = rt(f[x]))); }\nint main(void) {\n  int n, m, v = 0;\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) f[i] = i, z[i] = 1;\n  for (int i = 0, a, b; i < m && cin >> a >> b; ++i) {\n    a = rt(a), b = rt(b);\n    if (a != b) f[b] = a, z[a] += z[b];\n  }\n  cin >> m;\n  for (int i = 0, a, b; i < m && cin >> a >> b; ++i) {\n    a = rt(a), b = rt(b);\n    if (a == b) z[a] = 0;\n  }\n  for (int i = 1; i <= n; ++i)\n    if (i == rt(i) && z[i] > v) v = z[i];\n  cout << v << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int max(int a, int b) { return a > b ? a : b; }\ninline int min(int a, int b) { return a < b ? a : b; }\ninline int gcd(int a, int b) {\n  if (a % b)\n    return gcd(b, a % b);\n  else\n    return b;\n}\ninline int lcm(int a, int b) { return (a * (b / gcd(a, b))); }\ninline int And(int mask, int bit) { return mask & (1 << bit); }\ninline int Or(int mask, int bit) { return mask | (1 << bit); }\ninline int Xor(int mask, int bit) { return mask & (~(1 << bit)); }\nvector<int> adj[2010];\nvector<int> str;\nstack<int> S;\nint low[2010], num[2010], scc, color[2010];\nint a[2010][2010], cnt;\nbool check() {\n  int sz = str.size();\n  for (int i = 0; i < sz - 1; i++)\n    for (int j = i + 1; j < sz; j++) {\n      int x = str[i];\n      int y = str[j];\n      if (a[x][y] || a[y][x]) return false;\n    }\n  return true;\n}\nvoid tajan(int u) {\n  num[u] = low[u] = ++cnt;\n  S.push(u);\n  for (int i = 0; i < adj[u].size(); i++) {\n    int v = adj[u][i];\n    if (!color[v])\n      if (num[v])\n        low[u] = min(low[u], num[v]);\n      else {\n        tajan(v);\n        low[u] = min(low[u], low[v]);\n      }\n  }\n  if (low[u] == num[u]) {\n    ++scc;\n    int x;\n    do {\n      x = S.top();\n      S.pop();\n      color[x] = 1;\n      str.push_back(x);\n    } while (x != u);\n  }\n}\nint main() {\n  int n, m, x, y, sz, Ans;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    color[i] = 0;\n    low[i] = num[i] = 0;\n    for (int j = 1; j <= n; j++) a[i][j] = 0;\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d\", &x, &y);\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  scanf(\"%d\", &sz);\n  for (int i = 0; i < sz; i++) {\n    scanf(\"%d %d\", &x, &y);\n    a[x][y] = 1;\n    a[y][x] = 1;\n  }\n  Ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!color[i]) {\n      tajan(i);\n      if (check()) Ans = max(Ans, str.size());\n      str.clear();\n    }\n  }\n  printf(\"%d\\n\", Ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e9, MOD = 998244353;\nlong long gcd(long long a, long long b) { return (b ? gcd(b, a % b) : a); }\nlong long power(long long a, long long b) {\n  return (!b ? 1 : power(a, b / 2) * power(a, b / 2) * (b % 2 ? a : 1));\n}\nlong long mod(long long a) { return (a % MOD + MOD) % MOD; }\nconst long long N = 2e3 + 20;\nlong long par[N];\nlong long sz[N];\nlong long getPar(long long v) {\n  return (par[v] == v ? v : par[v] = getPar(par[v]));\n}\nvoid merge(long long v, long long u) {\n  v = getPar(v);\n  u = getPar(u);\n  if (v == u) return;\n  if (sz[v] > sz[u]) swap(v, u);\n  par[v] = u;\n  sz[u] += sz[v];\n  sz[v] = 0;\n}\nvoid unmerge(long long v, long long u) {\n  v = getPar(v);\n  u = getPar(u);\n  if (v != u) return;\n  sz[v] = sz[u] = 0;\n}\nint32_t main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  long long n;\n  cin >> n;\n  for (long long i = 1; i <= n; i++) par[i] = i, sz[i] = 1;\n  long long k;\n  cin >> k;\n  for (long long i = 0; i < k; i++) {\n    long long x, y;\n    cin >> x >> y;\n    merge(x, y);\n  }\n  long long m;\n  cin >> m;\n  for (long long i = 0; i < m; i++) {\n    long long x, y;\n    cin >> x >> y;\n    unmerge(x, y);\n  }\n  long long mx = 0;\n  for (long long i = 1; i <= n; i++) mx = max(mx, sz[getPar(i)]);\n  cout << mx << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint par[100005];\nint cnt[100005];\nint find(int x) {\n  while (x != par[x]) {\n    par[x] = par[par[x]];\n    x = par[x];\n  }\n  return x;\n}\nvoid uni(int a, int b) {\n  int px = find(a);\n  int py = find(b);\n  if (px == py) return;\n  if (cnt[py] > cnt[px]) {\n    par[px] = py;\n    cnt[py] += cnt[px];\n  } else {\n    par[py] = px;\n    cnt[px] += cnt[py];\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    par[i] = i;\n    cnt[i] = 1;\n  }\n  int k;\n  cin >> k;\n  int a, b;\n  for (int i = 0; i < k; i++) {\n    cin >> a >> b;\n    uni(a, b);\n  }\n  int l;\n  cin >> l;\n  for (int i = 0; i < l; i++) {\n    cin >> a >> b;\n    int pa = find(a);\n    int push_back = find(b);\n    if (pa == push_back) {\n      cnt[pa] = 0;\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (par[i] == i) ans = max(ans, cnt[i]);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint par[2004], siz[2004];\nint find_set(int a) {\n  if (par[a] == a) return a;\n  return par[a] = find_set(par[a]);\n}\nvoid union_set(int a, int b) {\n  a = find_set(a);\n  b = find_set(b);\n  if (a != b) {\n    if (siz[a] < siz[b]) swap(a, b);\n    par[b] = a;\n    siz[a] += siz[b];\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  int k;\n  cin >> k;\n  for (int i = 0; i <= 2003; i++) par[i] = i, siz[i] = 1;\n  int u, v;\n  for (int i = 0; i < k; i++) {\n    cin >> u >> v;\n    union_set(u, v);\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> u >> v;\n    u = find_set(u);\n    v = find_set(v);\n    if (u == v) {\n      siz[u] = -1;\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int z = find_set(i);\n    ans = max(ans, siz[z]);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class A\n{\n\tString line;\n\tStringTokenizer inputParser;\n\tBufferedReader is;\n\tFileInputStream fstream;\n\tDataInputStream in;\n\tString FInput=\"\";\n\t\n\tvoid openInput(String file)\n\t{\n\n\t\tif(file==null)is = new BufferedReader(new InputStreamReader(System.in));//stdin\n\t\telse\n\t\t{\n\t\t\ttry{\n\t\t\n\t\t\t\t\n\t\t\tfstream = new FileInputStream(file);\n\t\t\tin = new DataInputStream(fstream);\n\t\t\tis = new BufferedReader(new InputStreamReader(in));\n\t\t\t}catch(Exception e)\n\t\t\t{\n\t\t\t\tSystem.err.println(e);\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\tvoid readNextLine()\n\t{\n\t\ttry {\n\t\t\tline = is.readLine();\n\t\t\tinputParser = new StringTokenizer(line, \" \");\n\t\t\t//System.err.println(\"Input: \" + line);\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(\"Unexpected IO ERROR: \" + e);\n\t\t}\t\n\t\tcatch (NullPointerException e)\n\t\t{\n\t\t\tline=null;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tint NextInt()\n\t{\n\t\tString n = inputParser.nextToken();\n\t\tint val = Integer.parseInt(n);\n\t\t\n\t\t//System.out.println(\"I read this number: \" + val);\n\t\treturn val;\n\t}\n\t\n\tlong NextLong()\n\t{\n\t\tString n = inputParser.nextToken();\n\t\tlong val = Long.parseLong(n);\n\t\t\n\t\t//System.out.println(\"I read this number: \" + val);\n\t\treturn val;\n\t}\n\t\n\tString NextString()\n\t{\n\t\tString n = inputParser.nextToken();\n\t\treturn n;\n\t}\n\t\n\tvoid closeInput()\n\t{\n\t\ttry {\n\t\t\tis.close();\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(\"Unexpected IO ERROR: \" + e);\n\t\t}\n\t\t\t\n\t}\n\t\n\t\n\tpublic static void main(String [] argv)\n\t{\n\t\tString filePath=null;\n\t\tif(argv.length>0)filePath=argv[0];\n\t\tnew A(filePath);\n\t}\n\t\n\tpublic void readFInput()\n\t{\n\t\tfor(;;)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treadNextLine();\n\t\t\t\tFInput+=line+\" \";\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tinputParser = new StringTokenizer(FInput, \" \");\n\t}\n\t \n\tpublic A(String inputFile)\n\t{\n\t\topenInput(inputFile);\n\t\t\n\t\treadNextLine();\n\t\tint ret=0;\n\t\t\n\t\t\n\t\tint N=NextInt();\n\t\treadNextLine();\n\t\tint K=NextInt();\n\t\tboolean [] []f = new boolean [N][N];\n\t\tboolean [] []d = new boolean [N][N];\n\t\t\n\t\tfor(int i=0; i<K; i++)\n\t\t{\n\t\t\treadNextLine();\n\t\t\tint a=NextInt()-1;\n\t\t\tint b=NextInt()-1;\n\t\t\tf[a][b]=f[b][a]=true;\n\t\t}\n\t\treadNextLine();\n\t\tK=NextInt();\n\t\tfor(int i=0; i<K; i++)\n\t\t{\n\t\t\treadNextLine();\n\t\t\tint a=NextInt()-1;\n\t\t\tint b=NextInt()-1;\n\t\t\td[a][b]=d[b][a]=true;\n\t\t}\n\t\t\n\t\t\n\t\tboolean [] t = new boolean [N];\n\t\t\n\t\tfor(int x=0; x<N; x++)\n\t\tif(!t[x])\n\t\t{\n\t\t\tt[x]=true;\n\t\t\tQueue<Integer>q = new LinkedList<Integer>();\n\t\t\tSet <Integer> invited = new TreeSet<Integer>();\n\t\t\tSet <Integer> disliked = new TreeSet<Integer>();\n\t\t\tq.add(x);\n\t\t\tinvited.add(x);\n\t\t\tboolean ok=true;\n\t\t\twhile(q.size()>0)\n\t\t\t{\n\t\t\t\tint a=q.poll();\n\t\t\t\tinvited.add(a);\n\t\t\t\tt[a]=true;\n\t\t\t\tfor(int i=0; i<N; i++)\n\t\t\t\t{\n\t\t\t\t\tif(f[a][i]&&!t[i])q.add(i);\n\t\t\t\t\tif(d[a][i])disliked.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i:invited)if(disliked.contains(i))ok=false;\n\t\t\tif(ok)ret=Math.max(ret, invited.size());\n\t\t}\n\t\tSystem.out.println(ret);\n\t\t\n\t\t\n\t\t\n\t\t\n\n        closeInput();\t\t\n\t}\n\n\n\n\t\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9;\nconst int mod = 1000000007;\nint N, M;\nvector<int> g[2001];\nvector<int> cur;\nvector<bool> vis(2001);\nint Gbad[2001][2001];\nint ans;\nvoid dfs(int v) {\n  cur.push_back(v);\n  vis[v] = true;\n  for (int x : g[v])\n    if (!vis[x]) dfs(x);\n}\nvoid check(vector<int> &v) {\n  bool good = true;\n  int N = v.size();\n  for (int i = 0; i < N; i++) {\n    for (int j = i + 1; j < N; j++)\n      if (Gbad[cur[j]][cur[i]] == 1) {\n        good = false;\n        break;\n      }\n  }\n  int cur = v.size();\n  if (good) ans = max(ans, cur);\n}\nvoid slv() {\n  cin >> N >> M;\n  int x, y;\n  for (int i = 1; i <= M; i++) {\n    cin >> x >> y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int K;\n  cin >> K;\n  for (int i = 1; i <= K; i++) {\n    cin >> x >> y;\n    Gbad[x][y] = Gbad[y][x] = 1;\n  }\n  for (int i = 1; i <= N; i++) {\n    if (vis[i] == 0) {\n      dfs(i);\n      check(cur);\n      cur.clear();\n    }\n  }\n  cout << ans;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T = 1;\n  while (T--) slv();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> > v, q;\nint vis1[2001] = {0};\nint f(int k) {\n  queue<int> z;\n  int vis[2001] = {0};\n  int c = 1, i;\n  z.push(k);\n  vis[k] = 1;\n  while (!z.empty()) {\n    k = z.front();\n    z.pop();\n    for (i = 0; i < v[k].size(); i++) {\n      if (vis[v[k][i]] == 2) return 0;\n      if (vis[v[k][i]] == 0) {\n        vis[v[k][i]] = 1;\n        vis1[v[k][i]] = 1;\n        c++;\n        z.push(v[k][i]);\n      }\n    }\n    for (i = 0; i < q[k].size(); i++) {\n      if (vis[q[k][i]] == 1) return 0;\n      if (vis[q[k][i]] == 0) vis[q[k][i]] = 2;\n    }\n  }\n  return c;\n}\nint main() {\n  int n, m, k, x, y, i;\n  cin >> n;\n  cin >> k;\n  v.resize(n + 1);\n  q.resize(n + 1);\n  for (i = 0; i < k; i++) {\n    cin >> x >> y;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  cin >> m;\n  for (i = 0; i < m; i++) {\n    cin >> x >> y;\n    q[x].push_back(y);\n    q[y].push_back(x);\n  }\n  int p, m1 = 0;\n  for (i = 1; i <= n; i++)\n    if (!vis1[i]) {\n      p = f(i);\n      if (m1 < p) m1 = p;\n    }\n  cout << m1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class B {\n\tpublic static void main(String[] args) {\n\t\tMScanner sc = new MScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint N = sc.nextInt();\n\t\tDisjointSet DJ = new DisjointSet(N+1);\n\t\t\n\t\tint A = sc.nextInt();\n\t\tfor(int a=0;a<A;a++)\n\t\t\tDJ.union(sc.nextInt(), sc.nextInt());\n\t\t\n\t\tint B = sc.nextInt();\n\t\tfor(int a=0;a<B;a++){\n\t\t\tint s = sc.nextInt();\n\t\t\tint e = sc.nextInt();\n\t\t\tif(DJ.find(s)==DJ.find(e))\n\t\t\t\tDJ.union(0,s);\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint[] size = new int[N+1];\n\t\tfor(int a=0;a<=N;a++)\n\t\t\tsize[DJ.find(a)]++;\n\t\t\n\t\tfor(int a=1;a<=N;a++)\n\t\t\tif(DJ.find(0)!=a)\n\t\t\t\tans = Math.max(ans,size[a]);\n\t\t\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n\n\t\n\tstatic class DisjointSet {\n\t\tint[] p, r;\n\n\t\tDisjointSet(int s) {\n\t\t\tp = new int[s];\n\t\t\tr = new int[s];\n\t\t\tfor (int i = 0; i < s; i++)\n\t\t\t\tp[i] = i;\n\n\t\t}\n\t\t\n\t\tvoid union(int x, int y) {\n\t\t\tint a = find(x);\n\t\t\tint b = find(y);\n\t\t\tif (a == b)\n\t\t\t\treturn;\n\t\t\tif (r[a] == r[b])\n\t\t\t\tr[p[b] = a]++;\n\t\t\telse\n\t\t\t\tp[a] = p[b] = r[a] < r[b] ? b : a;\n\t\t}\n\n\t\tint find(int x) {\n\t\t\treturn p[x] = p[x] == x ? x : find(p[x]);\n\t\t}\n\n\t}\n\n\t\n\tstatic class MScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic MScanner() {\n\t\t\tstream = System.in;\n\t\t\t// stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextInt(int N) {\n\t\t\tint[] ret = new int[N];\n\t\t\tfor (int a = 0; a < N; a++)\n\t\t\t\tret[a] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLong(int N) {\n\t\t\tlong[] ret = new long[N];\n\t\t\tfor (int a = 0; a < N; a++)\n\t\t\t\tret[a] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDouble(int N) {\n\t\t\tdouble[] ret = new double[N];\n\t\t\tfor (int a = 0; a < N; a++)\n\t\t\t\tret[a] = nextDouble();\n\t\t\treturn ret;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] next(int N) {\n\t\t\tString[] ret = new String[N];\n\t\t\tfor (int a = 0; a < N; a++)\n\t\t\t\tret[a] = next();\n\t\t\treturn ret;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextLine(int N) {\n\t\t\tString[] ret = new String[N];\n\t\t\tfor (int a = 0; a < N; a++)\n\t\t\t\tret[a] = nextLine();\n\t\t\treturn ret;\n\t\t}\n\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2010;\nconst int FRIEND = 1;\nconst int ENEMY = -1;\nint n, k, m, num_colors;\nint a[MAXN][MAXN];\nint colors[MAXN];\nint good_color[MAXN];\nvoid dfs(int vertex, int color) {\n  colors[vertex] = color;\n  for (int j = 0; j < n; ++j) {\n    if (a[vertex][j] == ENEMY) {\n      if (colors[j] == colors[vertex]) {\n        good_color[colors[vertex]] = false;\n      }\n    }\n    if (a[vertex][j] == FRIEND && colors[j] == 0) {\n      dfs(j, color);\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      a[i][j] = 0;\n    }\n  }\n  for (int i = 0; i < k; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u--;\n    v--;\n    a[u][v] = FRIEND;\n    a[v][u] = FRIEND;\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u--;\n    v--;\n    a[u][v] = ENEMY;\n    a[v][u] = ENEMY;\n  }\n  num_colors = 0;\n  for (int i = 0; i < n; ++i) {\n    colors[i] = 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    if (colors[i] == 0) {\n      good_color[++num_colors] = true;\n      dfs(i, num_colors);\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n  }\n  int res = 0;\n  for (int i = 1; i <= num_colors; ++i) {\n    if (good_color[i]) {\n      int num_so_colored = 0;\n      for (int j = 0; j < n; ++j) {\n        if (colors[j] == i) {\n          num_so_colored++;\n        }\n      }\n      if (num_so_colored > res) {\n        res = num_so_colored;\n      }\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Constructor;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class CodeI \n{\n\tstatic class Scanner\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\t\n\t\tpublic String nextLine()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn br.readLine();\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow(new RuntimeException());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String next()\n\t\t{\n\t\t\twhile(!st.hasMoreTokens())\n\t\t\t{\n\t\t\t\tString l = nextLine();\n\t\t\t\tif(l == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(l);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tpublic double nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n)\n\t\t{\n\t\t\tint[] res = new int[n];\n\t\t\tfor(int i = 0; i < res.length; i++)\n\t\t\t\tres[i] = nextInt();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n)\n\t\t{\n\t\t\tlong[] res = new long[n];\n\t\t\tfor(int i = 0; i < res.length; i++)\n\t\t\t\tres[i] = nextLong();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tpublic double[] nextDoubleArray(int n)\n\t\t{\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor(int i = 0; i < res.length; i++)\n\t\t\t\tres[i] = nextDouble();\n\t\t\treturn res;\n\t\t}\n\t\tpublic void sortIntArray(int[] array)\n\t\t{\n\t\t\tInteger[] vals = new Integer[array.length];\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tvals[i] = array[i];\n\t\t\tArrays.sort(vals);\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tarray[i] = vals[i];\n\t\t}\n\t\t\n\t\tpublic void sortLongArray(long[] array)\n\t\t{\n\t\t\tLong[] vals = new Long[array.length];\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tvals[i] = array[i];\n\t\t\tArrays.sort(vals);\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tarray[i] = vals[i];\n\t\t}\n\t\t\n\t\tpublic void sortDoubleArray(double[] array)\n\t\t{\n\t\t\tDouble[] vals = new Double[array.length];\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tvals[i] = array[i];\n\t\t\tArrays.sort(vals);\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tarray[i] = vals[i];\n\t\t}\n\n\t\tpublic String[] nextStringArray(int n) \n\t\t{\t\n\t\t\tString[] vals = new String[n];\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\tvals[i] = next();\n\t\t\treturn vals;\n\t\t}\n\t\t\n\t\tpublic Integer nextInteger()\n\t\t{\n\t\t\tString s = next();\n\t\t\tif(s == null)\n\t\t\t\treturn null;\n\t\t\treturn Integer.parseInt(s);\n\t\t}\n\t\t\n\t\tpublic int[][] nextIntMatrix(int n, int m)\n\t\t{\n\t\t\tint[][] ans = new int[n][];\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\tans[i] = nextIntArray(m);\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\tpublic char[][] nextGrid(int r, int c) \n\t\t{\n\t\t\tchar[][] grid = new char[r][];\n\t\t\tfor(int i = 0; i < r; i++)\n\t\t\t\tgrid[i] = next().toCharArray();\n\t\t\treturn grid;\n\t\t}\n\t\t\n\t\tpublic static <T> T fill(T arreglo, int val)\n\t\t{\n\t\t\tif(arreglo instanceof Object[])\n\t\t\t{\n\t\t\t\tObject[] a = (Object[]) arreglo;\n\t\t\t\tfor(Object x : a)\n\t\t\t\t\tfill(x, val);\n\t\t\t}\n\t\t\telse if(arreglo instanceof int[])\n\t\t\t\tArrays.fill((int[]) arreglo, val);\n\t\t\telse if(arreglo instanceof double[])\n\t\t\t\tArrays.fill((double[]) arreglo, val);\n\t\t\telse if(arreglo instanceof long[])\n\t\t\t\tArrays.fill((long[]) arreglo, val);\n\t\t\treturn arreglo;\n\t\t}\n\t\t\n\t\t<T> T[] nextObjectArray(Class <T> clazz, int size)\n\t\t{\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT[] result = (T[]) java.lang.reflect.Array.newInstance(clazz, size);\n\t\t\tfor(int c = 0; c < 3; c++)\n\t\t\t{\n\t\t\t\tConstructor <T> constructor;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tif(c == 0)\n\t\t\t\t\t\tconstructor = clazz.getDeclaredConstructor(Scanner.class, Integer.TYPE);\n\t\t\t\t\telse if(c == 1)\n\t\t\t\t\t\tconstructor = clazz.getDeclaredConstructor(Scanner.class);\n\t\t\t\t\telse\n\t\t\t\t\t\tconstructor = clazz.getDeclaredConstructor();\n\t\t\t\t} \n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tfor(int i = 0; i < result.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(c == 0)\n\t\t\t\t\t\t\tresult[i] = constructor.newInstance(this, i);\n\t\t\t\t\t\telse if(c == 1)\n\t\t\t\t\t\t\tresult[i] = constructor.newInstance(this);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tresult[i] = constructor.newInstance();\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tthrow new RuntimeException(\"Constructor not found\");\n\t\t}\n\t\t\n\t\tpublic void printLine(int... vals)\n\t\t{\n\t\t\tif(vals.length == 0)\n\t\t\t\tSystem.out.println();\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.print(vals[0]);\n\t\t\t\tfor(int i = 1; i < vals.length; i++)\n\t\t\t\t\tSystem.out.print(\" \".concat(String.valueOf(vals[i])));\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void printLine(long... vals)\n\t\t{\n\t\t\tif(vals.length == 0)\n\t\t\t\tSystem.out.println();\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.print(vals[0]);\n\t\t\t\tfor(int i = 1; i < vals.length; i++)\n\t\t\t\t\tSystem.out.print(\" \".concat(String.valueOf(vals[i])));\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void printLine(double... vals)\n\t\t{\n\t\t\tif(vals.length == 0)\n\t\t\t\tSystem.out.println();\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.print(vals[0]);\n\t\t\t\tfor(int i = 1; i < vals.length; i++)\n\t\t\t\t\tSystem.out.print(\" \".concat(String.valueOf(vals[i])));\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void printLine(int prec, double... vals)\n\t\t{\n\t\t\tif(vals.length == 0)\n\t\t\t\tSystem.out.println();\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.printf(\"%.\" + prec + \"f\", vals[0]);\n\t\t\t\tfor(int i = 1; i < vals.length; i++)\n\t\t\t\t\tSystem.out.printf(\" %.\" + prec + \"f\", vals[i]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Person\n\t{\n\t\tint id;\n\t\tboolean visited = false;\n\t\tArrayList <Person> friends = new ArrayList <Person> ();\n\t\tArrayList <Person> foes = new ArrayList <Person> ();\n\t\t\n\t\tpublic Person(Scanner sc, int i)\n\t\t{\n\t\t\tid = i;\n\t\t}\n\t}\n\t\n\tstatic ArrayList <Person> inComponent = new ArrayList <Person> ();\n\tstatic boolean[] inComponentB;\n\t\n\tprivate static void floodFill(Person person) \n\t{\n\t\tif(person.visited) return;\n\t\tinComponent.add(person);\n\t\tperson.visited = true;\n\t\tfor(Person f : person.friends)\n\t\t\tfloodFill(f);\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tPerson[] allPersons = sc.nextObjectArray(Person.class, n);\n\t\tinComponentB = new boolean[n];\n\t\tint k = sc.nextInt();\n\t\tfor(int i = 0; i < k; i++)\n\t\t{\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tallPersons[u].friends.add(allPersons[v]);\n\t\t\tallPersons[v].friends.add(allPersons[u]);\n\t\t}\n\t\tint m = sc.nextInt();\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tallPersons[u].foes.add(allPersons[v]);\n\t\t\tallPersons[v].foes.add(allPersons[u]);\n\t\t}\n\t\tint best = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(!allPersons[i].visited)\n\t\t\t{\n\t\t\t\tinComponent.clear();\n\t\t\t\tfloodFill(allPersons[i]);\n\t\t\t\tfor(Person p : inComponent)\n\t\t\t\t\tinComponentB[p.id] = true;\n\t\t\t\tboolean viable = true;\n\t\t\t\tfor(Person p : inComponent)\n\t\t\t\t\tfor(Person p1 : p.foes)\n\t\t\t\t\t\tif(inComponentB[p1.id])\n\t\t\t\t\t\t\tviable = false;\n\t\t\t\tfor(Person p : inComponent)\n\t\t\t\t\tinComponentB[p.id] = false;\n\t\t\t\tif(viable)\n\t\t\t\t\tbest = Math.max(best, inComponent.size());\n\t\t\t}\n\t\t}\n\t\tsc.printLine(best);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, d, maxi = 0;\nint adj[2010][2010] = {{0}};\nint vis[2010] = {0};\nvoid bfs(int x) {\n  set<int> res;\n  set<int> hate;\n  queue<int> q;\n  q.push(x);\n  res.insert(x);\n  vis[x] = 1;\n  while (!q.empty()) {\n    int t = q.front();\n    q.pop();\n    for (int k = 1; k <= n; k++) {\n      if (adj[t][k] == -1) {\n        if (res.count(k) > 0) return;\n        hate.insert(k);\n      }\n      if (adj[t][k] == 1) {\n        if (hate.count(k) > 0) {\n          vis[k] = 1;\n          return;\n        } else if (!vis[k]) {\n          q.push(k);\n          res.insert(k);\n          vis[k] = 1;\n        }\n      }\n    }\n  }\n  if (res.size() > maxi) maxi = res.size();\n  int k;\n}\nint main() {\n  cin >> n >> l;\n  int j, k, a, b;\n  for (j = 0; j < l; j++) {\n    cin >> a >> b;\n    adj[a][b] = adj[b][a] = 1;\n  }\n  cin >> d;\n  for (j = 0; j < d; j++) {\n    cin >> a >> b;\n    adj[a][b] = adj[b][a] = -1;\n  }\n  for (k = 1; k <= n; k++)\n    if (vis[k] == 0) bfs(k);\n  cout << maxi << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 2e3 + 4;\nvector<int> circle;\nbool vis[N];\nbool bad_Relation[N][N];\nint parent[N];\nll chk[N];\nint color[N];\nint tim[N];\nint dis[N];\nint position[N];\nvector<int> adj[N];\nvector<int> adj1[N];\nvector<int> graph[N];\nbool has_cycle;\nint maxdis, maxnode, Totnode, depth = 1;\nbool ok;\nqueue<int> q;\nstack<int> stk;\nvector<int> solution;\nint indegree[N];\nint go[N];\nint to[N];\nll x1, x2, x3, x4, x5, x6;\nstring ss;\nint gn, gk;\nvector<int> vec;\nvoid dfs(int node) {\n  vis[node] = true;\n  vec.push_back(node);\n  for (int i = 0; i < adj[node].size(); i++) {\n    int u = adj[node][i];\n    if (!vis[u]) {\n      dfs(u);\n    }\n  }\n}\nbool check() {\n  for (int i = 0; i < vec.size(); i++) {\n    for (int j = 0; j < vec.size(); j++) {\n      if (bad_Relation[vec[i]][vec[j]]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nint main() {\n  int t = 1;\n  int cas = 0;\n  while (t--) {\n    int n, m, i, j, cnt = 0, cnt1 = 0, cnt2 = 0, even = 0, odd = 0, len, k, r,\n                    l, z = 0, x = 0, y = 0, flag = 0, sum = 0, tottal = 0;\n    int a = 0, b = 0, c = 0, d = 0, ans = 0, rem, quot, zero = 0, fst = 0,\n        null = 0, snd = 0, lst = 0, rone = 0, one = 0, pos = 0, neg = 0,\n        mn = INT_MAX, mx = INT_MIN;\n    char ch;\n    int h1, h2, m1, m2, h;\n    int velo1, velo2, ac1, ac2, tim, hour, mint, sec;\n    int node, edge, u, v, cost;\n    int bst, wrst;\n    double nd, ad, bd, cd, dd, xd, sumd = 0.00;\n    string str, str1 = \"\", str2 = \"\", str3 = \"\", strstore1 = \"\", strstore2 = \"\";\n    cin >> node >> edge;\n    for (i = 0; i < edge; i++) {\n      cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n    cin >> m;\n    for (i = 0; i < m; i++) {\n      cin >> u >> v;\n      bad_Relation[u][v] = true;\n    }\n    ans = 0;\n    for (i = 1; i <= node; i++) {\n      if (!vis[i]) {\n        vec.clear();\n        dfs(i);\n        if (check()) {\n          x = vec.size();\n          ans = max(ans, x);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint rela[2000][2000];\nint par[2000];\nbool dislike[2000][2000];\nvoid init_par(int n) {\n  for (int i = 0; i < (n); i++) par[i] = i;\n}\nint root(int x) { return (par[x] == x ? x : par[x] = root(par[x])); }\nvoid unite(int x, int y) {\n  x = root(x);\n  y = root(y);\n  if (x != y) {\n    (y < x ? par[x] = y : par[y] = x);\n  }\n}\nbool same(int x, int y) { return (root(x) == root(y)); }\nint main() {\n  memset(rela, 0, sizeof(rela));\n  memset(dislike, false, sizeof(dislike));\n  int n;\n  scanf(\"%d\", &n);\n  init_par(n);\n  int k;\n  scanf(\"%d\", &k);\n  for (int i = 0; i < (k); i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    a--;\n    b--;\n    unite(a, b);\n  }\n  int m;\n  scanf(\"%d\", &m);\n  for (int i = 0; i < (m); i++) {\n    int c, d;\n    scanf(\"%d %d\", &c, &d);\n    c--;\n    d--;\n    dislike[c][d] = true;\n    dislike[d][c] = true;\n  }\n  map<int, int> group;\n  vector<int> acqu(n);\n  for (int i = 0; i < (n); i++) {\n    group[root(i)]++;\n    acqu[i] = root(i);\n  }\n  int res = 0;\n  map<int, int>::iterator it = group.begin();\n  for (; it != group.end(); it++) {\n    int g = (*it).first;\n    bool found = false;\n    if ((*it).second > res) {\n      for (int i = 0; i < (n); i++)\n        for (int j = 0; j < (n); j++)\n          if (i != j && g == acqu[i] && g == acqu[j]) {\n            if (dislike[i][j]) {\n              found = true;\n              break;\n            }\n          }\n      if (!found) {\n        res = (*it).second;\n      }\n    }\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# Problem: C1. Party\n# Contest: Codeforces - ABBYY Cup 2.0 - Easy\n# URL: https://codeforces.com/contest/177/problem/C1\n# Memory Limit: 256 MB\n# Time Limit: 2000 ms\n# \n# KAPOOR'S\n\nfrom sys import stdin, stdout \n\ndef INI():\n\treturn int(stdin.readline())\n\t\ndef INL():\n\treturn [int(_) for _ in stdin.readline().split()]\n\t\ndef INS():\n\treturn stdin.readline()\n\ndef MOD():\n    return pow(10,9)+7\n\t\ndef OPS(ans):\n\tstdout.write(str(ans)+\"\\n\")\n\t\ndef OPL(ans):\n\t[stdout.write(str(_)+\" \") for _ in ans]\n\tstdout.write(\"\\n\")\n\nrank=[0 for _ in range(2000+1)]\npar=[_ for _ in range(2000+1)]\t\nSize=[1 for _ in range(2000+1)]\n\n\ndef findpar(x):\n\tif x==par[x]:\n\t\treturn x\n\treturn findpar(par[x])\n\t\ndef union(pu,pv):\n\tif rank[pu]<rank[pv]:\n\t\tpar[pu]=pv\n\t\tSize[pv]+=Size[pu]\n\telif rank[pv]<rank[pu]:\n\t\tpar[pv]=pu\n\t\tSize[pu]+=Size[pv]\n\telse:\n\t\tpar[pv]=pu\n\t\trank[pu]+=1\n\t\tSize[pu]+=Size[pv]\n\t\nif __name__==\"__main__\":\n\t# for _ in range(INI()):\n\tt=INI()\n\tn=INI()\n\tfor _ in range(n):\n\t\tu,v=INL()\n\t\tpu=findpar(u)\n\t\tpv=findpar(v)\n\t\t\n\t\tif pu!=pv:\n\t\t\tunion(pu,pv)\n\t\n\tq=int(input())\n\tfor _ in range(q):\n\t\tu,v=INL()\n\t\tpu=findpar(u)\n\t\tpv=findpar(v)\n\t\tif pu==pv:\n\t\t\tSize[pu]=0\n\t\n\tans=0\n\tfor _ in range(1,t+1):\n\t\tans=max(ans,Size[findpar(_)])\n\tprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m;\nvector<vector<long long> > friends, enemies;\nvector<long long> group_nums;\nvector<bool> visited;\nlong long dfs(long long node, bool &ok, long long num) {\n  long long cnt = 1;\n  visited[node] = true;\n  group_nums[node] = num;\n  for (auto neigh : friends[node]) {\n    if (!visited[neigh]) {\n      cnt += dfs(neigh, ok, num);\n    }\n  }\n  for (auto e : enemies[node]) {\n    if (group_nums[e] == group_nums[node]) {\n      ok = false;\n    }\n  }\n  return cnt;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  ;\n  cin >> n;\n  friends.resize(n + 1);\n  enemies.resize(n + 1);\n  cin >> k;\n  for (long long i = 0; i < k; ++i) {\n    long long a, b;\n    cin >> a >> b;\n    friends[a].push_back(b);\n    friends[b].push_back(a);\n  }\n  cin >> m;\n  for (long long i = 0; i < m; ++i) {\n    long long a, b;\n    cin >> a >> b;\n    enemies[a].push_back(b);\n    enemies[b].push_back(a);\n  }\n  group_nums.resize(n + 1, -1);\n  visited.resize(n + 1, false);\n  long long ans = 0, num = 1;\n  for (long long i = 1; i <= n; ++i) {\n    if (!visited[i]) {\n      bool ok = true;\n      long long val = dfs(i, ok, num++);\n      if (ok) {\n        ans = max(ans, val);\n      }\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-5;\nconst int MODULO = 1000000007;\ntemplate <int size>\nclass UnionFind {\n  int par[size];\n  int rank[size];\n\n public:\n  UnionFind() { reset(); }\n  void reset() {\n    for (int i = 0; i < (size); i++) par[i] = i, rank[i] = 0;\n  }\n  int find(int x) {\n    if (par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y) { return find(x) == find(y); }\n};\nint n, l, d;\nbool dis[2000][2000];\nbool b[2000];\nbool check(vector<int> &v) {\n  for (int i = 0; i < int((v).size()); i++) {\n    for (int j = i + 1; j < int((v).size()); j++) {\n      if (dis[v[i]][v[j]]) return false;\n    }\n  }\n  return true;\n}\nint main() {\n  UnionFind<2000> u;\n  cin >> n;\n  cin >> l;\n  for (int i = 0; i < (l); i++) {\n    int a, b;\n    cin >> a >> b;\n    u.unite(a - 1, b - 1);\n  }\n  cin >> d;\n  for (int i = 0; i < (d); i++) {\n    int a, b;\n    cin >> a >> b;\n    dis[a - 1][b - 1] = 1;\n    dis[b - 1][a - 1] = 1;\n  }\n  int ans = 0;\n  vector<int> v;\n  for (int i = 0; i < (n); i++) {\n    if (b[i]) continue;\n    v.clear();\n    for (int j = 0; j < (n); j++)\n      if (u.same(i, j)) v.push_back(j);\n    for (__typeof__((v).begin()) it = (v).begin(); it != (v).end(); ++it)\n      b[*it] = true;\n    if (check(v)) ans = max(ans, int((v).size()));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 123456;\nint Father[N + 1], s[N + 1];\nvoid init() {\n  for (int i = 1; i <= N; i++) Father[i] = i, s[i] = 1;\n}\nint find(int x) { return x == Father[x] ? x : Father[x] = find(Father[x]); }\nint main() {\n  ios::sync_with_stdio(false);\n  init();\n  int x, y, ans = 0;\n  int n, k, m;\n  cin >> n >> k;\n  for (int i = 1; i <= k; i++) {\n    cin >> x >> y;\n    int fx = find(x), fy = find(y);\n    if (fx != fy) {\n      Father[fx] = fy;\n      s[fy] += s[fx];\n    }\n  }\n  cin >> m;\n  for (int i = 1; i <= m; i++) {\n    cin >> x >> y;\n    int fx = find(x), fy = find(y);\n    if (fx == fy) s[fy] = 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (ans < s[i] && s[find(i)] != 0) ans = s[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> adj[2005];\nvector<long long int> lan[2005];\nlong long int parent[2005];\nlong long int cnt[2005];\nlong long int find_parent(long long int x) {\n  if (x == parent[x]) return x;\n  return parent[x] = find_parent(parent[x]);\n}\nint main() {\n  long long int n;\n  cin >> n;\n  for (long long int i = 1; i < n + 1; i++) {\n    parent[i] = i;\n    cnt[i] = 1;\n  }\n  long long int m;\n  cin >> m;\n  while (m--) {\n    long long int u, v;\n    cin >> u >> v;\n    long long int pu = find_parent(u);\n    long long int pv = find_parent(v);\n    if (pu != pv) {\n      cnt[pu] += cnt[pv];\n      cnt[pv] = 0;\n      parent[pv] = pu;\n    }\n  }\n  long long int k;\n  cin >> k;\n  while (k--) {\n    long long int u, v;\n    cin >> u >> v;\n    long long int pu = find_parent(u);\n    long long int pv = find_parent(v);\n    if (pu == pv) {\n      cnt[pu] = 0;\n    }\n  }\n  long long int ans = LONG_LONG_MIN;\n  for (long long int i = 1; i < n + 1; i++) {\n    if (parent[i] == i) ans = max(cnt[i], ans);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool link[2001][2001], ulink[2001][2001];\nbool visited[2001];\nint n, k, m;\nvector<int> data;\nvoid dfs(int st) {\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i] && link[st][i]) {\n      visited[i] = 1;\n      data.push_back(i);\n      dfs(i);\n    }\n  }\n}\nint stop;\nint main() {\n  while (scanf(\" %d\", &n) == 1) {\n    memset(link, 0, sizeof(link));\n    memset(ulink, 0, sizeof(ulink));\n    scanf(\" %d\", &m);\n    for (int i = 0; i < m; i++) {\n      int a, b;\n      scanf(\" %d %d\", &a, &b);\n      link[a][b] = link[b][a] = 1;\n    }\n    scanf(\" %d\", &k);\n    for (int i = 0; i < k; i++) {\n      int a, b;\n      scanf(\" %d %d\", &a, &b);\n      ulink[a][b] = ulink[b][a] = 1;\n    }\n    int ans = 0;\n    memset(visited, 0, sizeof(visited));\n    for (int i = 1; i <= n; i++) {\n      if (!visited[i]) {\n        data.clear();\n        visited[i] = 1;\n        data.push_back(i);\n        dfs(i);\n        bool flag = true;\n        for (int j = 0; j < data.size(); j++) {\n          for (int k = j + 1; k < data.size(); k++) {\n            if (ulink[data[j]][data[k]]) {\n              flag = false;\n              j = data.size();\n              break;\n            }\n          }\n        }\n        if (flag && data.size() > ans) ans = data.size();\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e6 + 5, inf = 1e18, mod = 1e9 + 7;\nconst long double pi = 3.141592653589793238;\nbool check_prime(long long n) {\n  long long flag = 0, i;\n  for (i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      flag = 1;\n      break;\n    }\n  }\n  if (n == 1) {\n    return false;\n  } else if (flag == 0 || n == 2 || n == 3) {\n    return true;\n  } else {\n    return false;\n  }\n}\nlong long fastexpo(long long a, long long b, long long MOD) {\n  long long result = 1;\n  while (b > 0) {\n    if (b % 2 == 1) {\n      result = (result * a) % MOD;\n    }\n    a = (a * a) % MOD;\n    b = b / 2;\n  }\n  return result;\n}\nvector<long long> G[N];\nlong long vis[N];\nvector<long long> vec[2005];\nvoid dfs(long long node, long long count) {\n  long long i;\n  vis[node] = 1;\n  vec[count].push_back(node);\n  for (i = 0; i < G[node].size(); i++) {\n    if (vis[G[node][i]] == 0) {\n      dfs(G[node][i], count);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, u, v, i, k, m, ma, c, j, count;\n  cin >> n;\n  cin >> m;\n  for (i = 1; i <= m; i++) {\n    cin >> u >> v;\n    G[u].push_back(v);\n    if (u != v) {\n      G[v].push_back(u);\n    }\n  }\n  vector<pair<long long, long long> > vi;\n  cin >> k;\n  for (i = 1; i <= k; i++) {\n    cin >> u >> v;\n    vi.push_back({u, v});\n  }\n  count = 0;\n  for (i = 1; i <= n; i++) {\n    if (vis[i] == 0) {\n      dfs(i, count);\n      count++;\n    }\n  }\n  ma = 0;\n  for (i = 0; i < count; i++) {\n    sort(vec[i].begin(), vec[i].end());\n    c = 1;\n    for (j = 0; j < k; j++) {\n      if (binary_search(vec[i].begin(), vec[i].end(), vi[j].first) &&\n          binary_search(vec[i].begin(), vec[i].end(), vi[j].second)) {\n        c = 0;\n        break;\n      }\n    }\n    if (c == 1) {\n      c = vec[i].size();\n      ma = max(ma, c);\n    }\n  }\n  cout << ma << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct DS {\n  vector<int> p, s;\n  void reset(int n) {\n    p.resize(n);\n    s.resize(n);\n    for (int i = 0; i < n; ++i) {\n      p[i] = i;\n      s[i] = 1;\n    }\n  }\n  int getParent(int v) {\n    if (v != p[v]) p[v] = getParent(p[v]);\n    return p[v];\n  }\n  void link(int u, int v) {\n    u = getParent(u);\n    v = getParent(v);\n    if (u == v) return;\n    if (s[u] > s[v]) swap(u, v);\n    p[u] = v;\n    s[v] += s[u];\n  }\n};\nint main() {\n  int n;\n  cin >> n;\n  DS friends;\n  friends.reset(n);\n  int k;\n  cin >> k;\n  while (k--) {\n    int u, v;\n    cin >> u >> v;\n    friends.link(u - 1, v - 1);\n  }\n  vector<bool> ok(n, true);\n  cin >> k;\n  while (k--) {\n    int u, v;\n    cin >> u >> v;\n    --u;\n    --v;\n    if (friends.getParent(u) == friends.getParent(v))\n      ok[friends.getParent(u)] = false;\n  }\n  int res = 0;\n  for (int i = 0; i < n; ++i) {\n    int p = friends.getParent(i);\n    if (ok[p]) res = max(res, friends.s[p]);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5000;\nvector<int> good[maxn];\nvector<int> bad[maxn];\nint colorg[maxn], colorb[maxn];\nint n, k, m;\nint mg = 1, mb = 1;\nvoid dfsg(int v, int c) {\n  colorg[v] = c;\n  for (int i = 0; i < (int)(good[v].size()); i++)\n    if (!colorg[good[v][i]]) dfsg(good[v][i], c);\n}\nset<int> bbad[maxn];\nvoid dfsb(int v, int c) {\n  colorb[v] = c;\n  for (int i = 0; i < (int)(bad[v].size()); i++)\n    if (!colorb[bad[v][i]]) dfsb(bad[v][i], c);\n}\nvector<int> colors[maxn];\nint main(void) {\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v), --u, --v;\n    good[u].push_back(v), good[v].push_back(u);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v), --u, --v;\n    bad[u].push_back(v), bad[v].push_back(u);\n    bbad[u].insert(v), bbad[v].insert(u);\n  }\n  for (int i = 0; i < n; i++) {\n    if (!colorg[i]) dfsg(i, mg), mg++;\n    if (!colorb[i]) dfsb(i, mb), mb++;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) colors[colorg[i]].push_back(i);\n  for (int i = 1; i < n; i++) {\n    bool flag = true;\n    for (int j = 0; j < (int)(colors[i].size()); j++)\n      for (int k = j + 1; k < (int)(colors[i].size()); k++) {\n        int u = colors[i][j], v = colors[i][k];\n        if (bbad[u].find(v) != bbad[u].end()) flag = false;\n      }\n    if (flag) ans = max(ans, (int)colors[i].size());\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dfs(long long i, vector<vector<long long>> &v,\n              vector<vector<long long>> &v1, vector<long long> &isit,\n              vector<long long> &temp) {\n  if (isit[i] != 0) {\n    return 0;\n  }\n  isit[i]++;\n  temp[i]++;\n  bool flag = 0;\n  long long t = 1;\n  for (long long j = 0; j < v[i].size(); j++) {\n    if (isit[v[i][j]] == 0) {\n      long long k = dfs(v[i][j], v, v1, isit, temp);\n      if (k == -1) {\n        flag = 1;\n      }\n      t += k;\n    }\n  }\n  for (long long j = 0; j < v1[i].size(); j++) {\n    if (temp[v1[i][j]] == 1) {\n      return -1;\n    }\n  }\n  if (flag == 1) {\n    return -1;\n  } else {\n    return t;\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n;\n  cin >> n;\n  long long l;\n  long long dl;\n  cin >> l;\n  vector<vector<long long>> like(n + 1);\n  for (long long i = 0; i < l; i++) {\n    long long a, b;\n    cin >> a >> b;\n    like[a].push_back(b);\n    like[b].push_back(a);\n  }\n  cin >> dl;\n  vector<vector<long long>> dlike(n + 1);\n  for (long long i = 0; i < dl; i++) {\n    long long a, b;\n    cin >> a >> b;\n    dlike[a].push_back(b);\n    dlike[b].push_back(a);\n  }\n  vector<long long> ans;\n  long long ians = 0;\n  vector<long long> isit(n + 1);\n  for (long long i = 1; i <= n; i++) {\n    if (isit[i] == 0) {\n      vector<long long> temp(n + 1);\n      long long t = dfs(i, like, dlike, isit, temp);\n      ans.push_back(t);\n    }\n  }\n  for (long long i : ans) {\n    ians = max(ians, i);\n  }\n  cout << ians;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint p[10000];\nint parent(int x) { return p[x] == x ? x : parent(p[x]); }\nvoid join(int x, int y) { p[parent(y)] = parent(x); }\nvector<int> graph[10000];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int u, v, n, k, m;\n  cin >> n >> k;\n  for (int i = 0; i < n; i++) p[i] = i;\n  for (int i = 0; i < k; i++) {\n    cin >> u >> v;\n    graph[u - 1].push_back(v - 1);\n    graph[v - 1].push_back(u - 1);\n    join(u - 1, v - 1);\n  }\n  set<int> s;\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> u >> v;\n    if (parent(u - 1) == parent(v - 1)) s.insert(parent(v - 1));\n  }\n  int h, ans = INT_MIN, count[10000] = {0};\n  for (int i = 0; i < n; i++) {\n    h = parent(i);\n    if (s.count(h) == 0) {\n      count[h]++;\n    }\n    ans = max(ans, count[h]);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n * by: Tyler Brazill\n * problem: p117C1\n **/\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class p117C1 {\n\t\n\tint[][] adj;\n\tpublic void start() throws Exception {\n\t\tScanner in = new Scanner(System.in);\n\t\tint numPeople = in.nextInt();\n\t\tadj = new int[numPeople][numPeople];\n\t\tint friendEdges = in.nextInt();\n\t\tfor(int x = 0; x<friendEdges; x++){\n\t\t\tint v1,v2;\n\t\t\tv1 = in.nextInt()-1;\n\t\t\tv2 = in.nextInt()-1;\n\t\t\tadj[v1][v2] = adj[v2][v1] = 1;\n\t\t}\n\t\tint enemyEdges = in.nextInt();\n\t\tfor(int x = 0; x<enemyEdges; x++){\n\t\t\tint v1,v2;\n\t\t\tv1 = in.nextInt()-1;\n\t\t\tv2 = in.nextInt()-1;\n\t\t\tadj[v1][v2] = adj[v2][v1] = -1;\n\t\t}\n\t\t\n\t\tboolean[] visited = new boolean[numPeople];\n\t\tint max = 0;\n\t\tfor(int x = 0; x<numPeople; x++){\n\t\t\tif(!visited[x]){\n\t\t\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\t\t\tArrayList<Integer> build = new ArrayList<Integer>();\n\t\t\t\tqueue.add(x);\n\t\t\t\tint total = 0;\n\t\t\t\twhile(!queue.isEmpty()){\n\t\t\t\t\tint v = queue.remove();\n\t\t\t\t\tif(!visited[v]){\n\t\t\t\t\t\tvisited[v] = true;\n\t\t\t\t\t\tbuild.add(v);\n\t\t\t\t\t\ttotal++;\n\t\t\t\t\t\tfor(int n = 0; n<numPeople; n++){\n\t\t\t\t\t\t\tif(adj[v][n] == 1) queue.add(n);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean noProblems = true;\n\t\t\t\tfor(int i = 0; i<build.size(); i++){\n\t\t\t\t\tint v1 = build.get(i);\n\t\t\t\t\tfor(int v2: build){\n\t\t\t\t\t\tif(adj[v1][v2] == -1){\n\t\t\t\t\t\t\tnoProblems = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!noProblems) break;\n\t\t\t\t}\n\t\t\t\tif(noProblems) max = Math.max(max, total);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tnew p117C1().start();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> color;\nvector<vector<int> > fr, enemies, heap(2001, vector<int>(0));\nbool cmp(vector<int> a, vector<int> b) { return (int)a.size() < (int)b.size(); }\nvoid DFS(int v, int val) {\n  color[v] = val;\n  heap[val].push_back(v);\n  int sz = (int)fr[v].size();\n  for (int i = 0; i < sz; i++)\n    if (!color[fr[v][i]]) DFS(fr[v][i], val);\n}\nbool can(vector<int> a) {\n  int sz = (int)a.size(), i, j;\n  for (i = 0; i < sz; i++)\n    for (j = 0; j < sz; j++)\n      if (enemies[a[i]][a[j]]) return false;\n  return true;\n}\nint main() {\n  long long n, x, a, b, i, j;\n  long long col = 1;\n  cin >> n >> x;\n  enemies.resize(n, vector<int>(n));\n  fr.resize(n, vector<int>(0));\n  color.resize(n);\n  for (i = 0; i < x; i++) {\n    cin >> a >> b;\n    a--, b--;\n    fr[a].push_back(b);\n    fr[b].push_back(a);\n  }\n  cin >> x;\n  for (i = 0; i < x; i++) {\n    cin >> a >> b;\n    a--, b--;\n    enemies[a][b] = enemies[b][a] = 1;\n  }\n  col = 1;\n  for (i = 0; i < n; i++) {\n    if (!color[i]) {\n      DFS(i, col);\n      col++;\n    }\n  }\n  sort(heap.rbegin(), heap.rend(), &cmp);\n  for (i = 0; i < 2001; i++)\n    if (can(heap[i])) {\n      cout << (int)heap[i].size();\n      return 0;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> > f;\nvector<vector<int> > d;\nint ch[2000 + 100];\ninline int dfs(int v) {\n  for (int i = 0; i < (int)d[v].size(); i++)\n    if (ch[d[v][i]] == 1) return 0;\n  ch[v] = 1;\n  int ret = 1;\n  for (int i = 0; i < (int)f[v].size(); i++) {\n    if (ch[f[v][i]] == 0) {\n      int newr = dfs(f[v][i]);\n      if (newr == 0) return 0;\n      ret += newr;\n    }\n  }\n  return ret;\n}\nint main() {\n  f.clear();\n  d.clear();\n  int n, k, m;\n  cin >> n;\n  cin >> k;\n  f.resize(n);\n  d.resize(n);\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    f[a - 1].push_back(b - 1);\n    f[b - 1].push_back(a - 1);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    d[a - 1].push_back(b - 1);\n    d[b - 1].push_back(a - 1);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    memset(ch, 0, sizeof ch);\n    int ne = dfs(i);\n    ans = max(ans, ne);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ran[200009];\nlong long parent[200009];\nlong long find(long long i) {\n  if (parent[i] == i) {\n    return i;\n  }\n  return parent[i] = find(parent[i]);\n}\nvoid merge(long long i, long long j) {\n  long long pi = find(i);\n  long long pj = find(j);\n  long long r1 = ran[pi];\n  long long r2 = ran[pj];\n  if (pi == pj) return;\n  if (r1 < r2) {\n    parent[pi] = pj;\n  } else if (r1 == r2) {\n    parent[pj] = pi;\n    ran[pi]++;\n  } else {\n    parent[pj] = pi;\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n;\n  cin >> n;\n  long long z[n + 1];\n  for (long long i = 0; i < n + 1; i++) {\n    ran[i] = 0;\n    z[i] = 0;\n    parent[i] = i;\n  }\n  long long m;\n  cin >> m;\n  for (long long i = 0; i < m; i++) {\n    long long x, y;\n    cin >> x >> y;\n    merge(x, y);\n  }\n  long long p;\n  cin >> p;\n  for (long long i = 0; i < p; i++) {\n    long long x, y;\n    cin >> x >> y;\n    x = find(x);\n    y = find(y);\n    if (x == y) {\n      z[x] = -1;\n    }\n  }\n  for (long long i = 1; i < n + 1; i++) {\n    long long x = find(i);\n    if (z[x] != -1) z[x]++;\n  }\n  long long c = 0;\n  for (long long i = 1; i < n + 1; i++) c = max(c, z[i]);\n  cout << c << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n  int groupId;\n  vector<int> friends;\n  Node() { groupId = -1; }\n} G[2000];\nint groupCount = 0, groupSize[2000], n;\nint enemyX[100000], enemyY[10000], enemyCnt;\nvoid dfs(int u);\nint getMax();\nint main() {\n  int k, u, v;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < k; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    G[u - 1].friends.push_back(v - 1);\n    G[v - 1].friends.push_back(u - 1);\n  }\n  scanf(\"%d\", &enemyCnt);\n  for (int i = 0; i < enemyCnt; ++i) {\n    scanf(\"%d%d\", enemyX + i, enemyY + i);\n    --enemyX[i];\n    --enemyY[i];\n  }\n  int ans = getMax();\n  printf(\"%d\\n\", ans);\n}\nint getMax() {\n  for (int i = 0; i < n; ++i) {\n    if (G[i].groupId == -1) {\n      dfs(i);\n      ++groupCount;\n    }\n  }\n  int g;\n  for (int i = 0; i < n; ++i) {\n    g = G[i].groupId;\n    ++groupSize[g];\n  }\n  int x, y, gx, gy;\n  for (int i = 0; i < enemyCnt; ++i) {\n    x = enemyX[i];\n    y = enemyY[i];\n    gx = G[x].groupId;\n    gy = G[y].groupId;\n    if (gx == gy) groupSize[gx] = 0;\n  }\n  return *max_element(groupSize, groupSize + groupCount);\n}\nvoid dfs(int u) {\n  G[u].groupId = groupCount;\n  const int f = G[u].friends.size();\n  for (int i = 0; i < f; ++i) {\n    int v = G[u].friends[i];\n    if (G[v].groupId == -1) dfs(v);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Party {\n\tstatic int[] parent;\n\tstatic int n;\n\tstatic int[] size;\n\tstatic boolean[] cant;\n\tstatic int find(int x) {\n\t\treturn (x == parent[x] ? x : (parent[x] = find(parent[x])));\n\t}\n\tstatic void union(int a, int b) {\n\t\tint pa = find(a);\n\t\tint pb = find(b);\n\t\tif(pa != pb) {\n\t\t\tif(size[pa] > size[pb]) {\n\t\t\t\tparent[pb] = pa;\n\t\t\t\tsize[pa] += size[pb];\n\t\t\t} else {\n\t\t\t\tparent[pa] = pb;\n\t\t\t\tsize[pb] += size[pa];\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tn = Integer.parseInt(br.readLine());\n\t\tparent = new int[n]; size = new int[n]; cant = new boolean[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t\tint k = Integer.parseInt(br.readLine());\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\t//System.out.println(i);\n\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\tunion(Integer.parseInt(st.nextToken())-1, Integer.parseInt(st.nextToken())-1);\n\t\t}\n\t\tint m = Integer.parseInt(br.readLine());\n\t\t//System.out.println(Arrays.toString(parent));\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\t//System.out.println(i);\n\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\tint a = Integer.parseInt(st.nextToken())-1, b = Integer.parseInt(st.nextToken())-1;\n\t\t\tif(find(a) == find(b)) {\n\t\t\t\tcant[find(a)] = true;\n\t\t\t}\n\t\t}\n\t\t//System.out.println(Arrays.toString(size));\n\t\tint max = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\t//System.out.println(i);\n\t\t\tif(!cant[find(i)]) {\n\t\t\t\tmax = Math.max(max, size[find(i)]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint fa[10000];\nint num[10000];\nint i, j, n, k;\nint find(int u) { return (u == fa[u]) ? u : fa[u] = find(fa[u]); }\nint main() {\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) fa[i] = i;\n  scanf(\"%d\", &k);\n  for (i = 1; i <= k; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    fa[find(u)] = find(v);\n  }\n  scanf(\"%d\", &k);\n  for (i = 1; i <= k; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    int f1 = find(u), f2 = find(v);\n    if (f1 == f2) num[f1] = -1;\n  }\n  for (i = 1; i <= n; i++) {\n    int f = find(i);\n    if (num[f] != -1) num[f]++;\n  }\n  int maxx = 0;\n  for (i = 1; i <= n; i++) {\n    int f = find(i);\n    if (num[f] > maxx) maxx = num[f];\n  }\n  printf(\"%d\\n\", maxx);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "'''\nCreated on 12.05.2012\n\n@author: matt\n'''\nimport Queue\n\n\n\ndef solve():\n    try: input = raw_input\n    except: pass\n    N = int(input())\n    friends = {}\n    dislikes = {}\n    for i in range(N):\n        friends[i] = set()\n        dislikes[i] = set()\n        \n    # friends\n    k = int(input())\n    for i in range(k):\n        s = input().split()\n        i, j = list(map(int, s))\n        friends[i-1].add(j-1)\n        friends[j-1].add(i-1)\n    m = int(input())\n    for i in range(m):\n        s = input().split()\n        i, j = list(map(int, s))\n        dislikes[i-1].add(j-1)\n        dislikes[j-1].add(i-1)\n  \n    # find ppl\n    grouppp = [-1 for _ in range(N)]\n    groups = {}\n    groupids = iter(xrange(0, N))\n    for i in xrange(N):\n        if grouppp[i] == -1:\n            curgroup = next(groupids)\n            grouppp[i] = curgroup\n            groups[curgroup] = set()\n            groups[curgroup].add(i)\n            tagfriends(i, curgroup, friends, groups, grouppp)\n    c = sorted([(len(y), y) for x, y in groups.items()], reverse=True)\n    for size, members in c:\n        if not has_dislikes(members, dislikes):\n            return size\n    return 0\n\ndef readmap(res, n):\n    for i in range(n):\n        s = input().split()\n        i, j = list(map(int, s))\n        res[i-1].add(j-1)\n        res[j-1].add(i-1)\n    return res\n   \ndef has_dislikes(members, dislikes):\n    for m1 in members:\n        for dislike in dislikes[m1]:\n            if dislike in members:\n                return True\n    return False\n\ndef tagfriends(i, curgroup, friends, groups, grouppp):\n    for f in friends[i]:\n        if grouppp[f] != curgroup:\n            grouppp[f] = curgroup\n            groups[curgroup].add(f)\n            tagfriends(f, curgroup, friends, groups, grouppp)\n\n    \nprint(solve())"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class OJ {\n\n    public static void main(String args[]) throws Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = ints(br.readLine());\n        DisjointSet leo = new DisjointSet(n);\n        int k = ints(br.readLine());\n        for(int i=0;i<k;i++)\n        {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a = ints(st.nextToken());\n            int b = ints(st.nextToken());\n            a--;\n            b--;\n            leo.merge(a, b);\n        }\n        boolean cr[] = new boolean[n];\n        int m = ints(br.readLine());\n        for(int i=0;i<m;i++)\n        {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a = ints(st.nextToken());\n            int b = ints(st.nextToken());\n            a--;\n            b--;\n            if(leo.find(a)==leo.find(b))\n            {\n                cr[leo.find(a)]=true;\n            }\n        }\n        int ans = 0;\n        for(int i=0;i<n;i++)\n        {\n            if(cr[leo.find(i)]==false)\n            {\n                ans = Math.max(ans,leo.d[leo.find(i)]);\n            }\n        }\n        pw.println(ans);\n        pw.close();\n    }\n    public static int ints(String s)\n    {\n        return Integer.parseInt(s);\n    }\n    public static long longs(String s)\n    {\n        return Long.parseLong(s);\n    }\n}\n\nclass DisjointSet {\n    int p[] = new int[2005];\n    int r[] = new int[2005];\n    int d[] = new int[2005];\n    DisjointSet(int n)\n    {\n        for(int i=0;i<n;i++)\n        {\n            p[i]=i;\n            r[i]=1;\n            d[i]=1;\n        }\n    }\n    public int find(int x)\n    {\n        if(p[x]!=x)\n        {\n            p[x] = find(p[x]);\n        }\n        return p[x];\n    }\n    public void merge(int x,int y)\n    {\n        x = find(x);\n        y = find(y);\n        if(x==y)\n            return;\n        if(r[x]<r[y])\n        {\n            p[x]=y;\n            d[y]+=d[x];\n        }\n        else if(r[y]<r[x])\n        {\n            p[y]=x;\n            d[x]+=d[y];\n        }\n        else\n        {\n            p[y]=x;\n            r[x]++;\n            d[x]+=d[y];\n        }\n    }   \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3005;\nvector<int> edge[maxn];\nint st[maxn], dfn[maxn], low[maxn];\nint Top, Btype, Time;\nint Belong[maxn], n, m;\nbool ins[maxn];\nvoid tarjan(int s) {\n  int i, t;\n  dfn[s] = low[s] = ++Time;\n  ins[s] = true;\n  st[++Top] = s;\n  for (i = 0; i < edge[s].size(); i++) {\n    t = edge[s][i];\n    if (!dfn[t]) {\n      tarjan(t);\n      if (low[t] < low[s]) low[s] = low[t];\n    } else if (ins[t] && dfn[t] < low[s])\n      low[s] = dfn[t];\n  }\n  if (dfn[s] == low[s]) {\n    Btype++;\n    do {\n      t = st[Top--];\n      ins[t] = false;\n      Belong[t] = Btype;\n    } while (t != s);\n  }\n}\nvoid SCC(int n) {\n  int i;\n  Top = Btype = Time = 0;\n  memset(ins, 0, sizeof(ins));\n  memset(dfn, 0, sizeof(dfn));\n  for (i = 1; i <= n; i++)\n    if (!dfn[i]) tarjan(i);\n  return;\n}\nint chu[maxn], cnt[maxn];\nbool mark[maxn];\nint main() {\n  int i, a, b;\n  while (scanf(\"%d\", &n) != -1) {\n    scanf(\"%d\", &m);\n    for (i = 1; i <= n; i++) edge[i].clear();\n    for (i = 0; i < m; i++) {\n      scanf(\"%d%d\", &a, &b);\n      edge[a].push_back(b);\n      edge[b].push_back(a);\n    }\n    SCC(n);\n    memset(mark, false, sizeof(mark));\n    scanf(\"%d\", &m);\n    for (i = 0; i < m; i++) {\n      scanf(\"%d%d\", &a, &b);\n      if (Belong[a] == Belong[b]) mark[Belong[a]] = 1;\n    }\n    int ans[maxn], Max = 0;\n    memset(ans, 0, sizeof(ans));\n    for (i = 1; i <= n; i++) {\n      if (!mark[Belong[i]]) ans[Belong[i]]++;\n      Max = Max < ans[Belong[i]] ? ans[Belong[i]] : Max;\n    }\n    printf(\"%d\\n\", Max);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid qmax(int &x, int y) {\n  if (x < y) x = y;\n}\nvoid qmin(int &x, int y) {\n  if (x > y) x = y;\n}\ninline int read() {\n  char s;\n  int k = 0, base = 1;\n  while ((s = getchar()) != '-' && s != EOF && !(isdigit(s)))\n    ;\n  if (s == EOF) exit(0);\n  if (s == '-') base = -1, s = getchar();\n  while (isdigit(s)) k = k * 10 + (s ^ '0'), s = getchar();\n  return k * base;\n}\ninline void write(int x) {\n  static char cnt, num[15];\n  cnt = 0;\n  if (!x) {\n    putchar('0');\n    return;\n  }\n  for (; x; x /= 10) num[++cnt] = x % 10;\n  for (; cnt; putchar(num[cnt--] + 48))\n    ;\n}\nconst int maxn = 2e3 + 100;\nint n, m;\nint u, v;\nint fa[maxn], sz[maxn];\nint gf(int x) {\n  if (fa[x] == x) return x;\n  return fa[x] = gf(fa[x]);\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) sz[i] = 1, fa[i] = i;\n  m = read();\n  while (m--) {\n    u = read();\n    v = read();\n    u = gf(u);\n    v = gf(v);\n    if (u != v) {\n      fa[u] = v;\n      sz[v] += sz[u];\n      sz[u] = 0;\n    }\n  }\n  m = read();\n  while (m--) {\n    u = read();\n    v = read();\n    u = gf(u);\n    v = gf(v);\n    if (u == v) {\n      sz[u] = 0;\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (fa[i] == i) {\n      ans = max(ans, sz[i]);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, x, y, a[100001], b[100001], visit[2001], t;\nset<int> gr, fin;\nvector<long long> v[2001];\nvoid dfs(int x) {\n  visit[x] = 1;\n  gr.insert(x);\n  for (int i = 0; i < v[x].size(); i++)\n    if (!visit[v[x][i]]) dfs(v[x][i]);\n}\nint main() {\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &t);\n  for (int i = 0; i < t; i++) {\n    scanf(\"%d%d\", &x, &y);\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) scanf(\"%d%d\", &a[i], &b[i]);\n  for (int i = 1; i <= n; i++) {\n    gr.clear();\n    if (!visit[i]) {\n      dfs(i);\n      for (int i = 0; i < m; i++) {\n        if (gr.find(a[i]) != gr.end() && gr.find(b[i]) != gr.end()) {\n          gr.clear();\n          break;\n        }\n      }\n      for (auto i = gr.begin(); i != gr.end(); i++) {\n        if (i == prev(gr.end())) continue;\n        set<int>::iterator p = i;\n        p++;\n        if ((*i) + 1 != *p) {\n          gr.clear();\n          break;\n        }\n      }\n      fin.insert(gr.size());\n    }\n  }\n  if (fin.empty())\n    printf(\"0\");\n  else {\n    set<int>::iterator i = prev(fin.end());\n    printf(\"%d\", *i);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, res;\nint w[2002];\nbool a[2002][2002];\nvector<int> ed[2002];\nvector<int> q;\nvoid dfs(int u) {\n  w[u] = 1;\n  q.push_back(u);\n  for (int i = 0; i < ((int)ed[u].size()); i++)\n    if (!w[ed[u][i]]) dfs(ed[u][i]);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    ed[u].push_back(v);\n    ed[v].push_back(u);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    a[u][v] = a[v][u] = 1;\n  }\n  for (int i = 1; i <= n; i++)\n    if (!w[i]) {\n      q.clear();\n      dfs(i);\n      bool ok = 1;\n      for (int j = 0; j < ((int)q.size()) && ok; j++)\n        for (int k = j + 1; k < ((int)q.size()) && ok; k++)\n          if (a[q[j]][q[k]]) ok = 0;\n      if (ok) res = max(res, ((int)q.size()));\n    }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint visit[2008];\nvector<int> v[2008];\nvector<int> conn(2008);\nvector<int> parent(2008);\nmap<int, int> m;\nint kk;\nvoid dfs(int node) {\n  kk++;\n  int com = 0;\n  stack<int> st;\n  st.push(node);\n  while (st.size()) {\n    int ff = st.top();\n    st.pop();\n    if (visit[ff]) {\n      continue;\n    }\n    visit[ff] = 1;\n    com++;\n    conn[ff] = kk;\n    parent[ff] = node;\n    for (int child : v[ff]) {\n      if (!visit[child]) st.push(child);\n    }\n  }\n  m[com]++;\n  parent[node] = -com;\n}\nint main() {\n  int n, e;\n  cin >> n >> e;\n  int a, b;\n  while (e--) {\n    cin >> a >> b;\n    if (a == b) continue;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (visit[i]) continue;\n    dfs(i);\n  }\n  int dis;\n  cin >> dis;\n  while (dis--) {\n    cin >> a >> b;\n    if (conn[a] != conn[b]) continue;\n    if (parent[a] < 0)\n      m[-parent[a]]--;\n    else {\n      m[-parent[parent[a]]]--;\n    }\n  }\n  bool flag = true;\n  for (auto it = m.rbegin(); it != m.rend(); it++) {\n    if (it->second > 0) {\n      cout << it->first << endl;\n      flag = false;\n      break;\n    }\n  }\n  if (flag) cout << 0 << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long M = 1e18;\nmap<int, int> q;\nvector<int> a[2005];\nint vis[2005], s;\nvoid dfs(int i) {\n  q[i] = 1;\n  vis[i] = 1;\n  s++;\n  for (auto j : a[i]) {\n    if (!vis[j]) {\n      dfs(j);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n, k, m, x, y;\n  cin >> n >> k;\n  vector<pair<int, int> > b;\n  for (int i = 0; i < k; i++) {\n    cin >> x >> y;\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> x >> y;\n    b.push_back({x, y});\n  }\n  if (k == 0 && m == 0) {\n    cout << 1;\n    return 0;\n  }\n  int z = 0, ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      dfs(i);\n      if (s == 1) {\n        ans = max(ans, s);\n        continue;\n      }\n      for (int j = 0; j < m; j++) {\n        if (q[b[j].first] == 1 && q[b[j].second] == 1) {\n          z = 1;\n          break;\n        }\n      }\n      if (z == 0) ans = max(ans, s);\n      s = 0;\n      q.clear();\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid dfs(const vector<vector<int> > &g, int v, vector<int> &components,\n         vector<int> &comp_length, int comp_n) {\n  components[v] = comp_n;\n  ++comp_length[comp_n];\n  for (int i = 0; i < (int)g[v].size(); ++i) {\n    if (components[g[v][i]] == -1) {\n      dfs(g, g[v][i], components, comp_length, comp_n);\n    }\n  }\n}\nint main() {\n  int n, k, m, a, b;\n  cin >> n >> k;\n  vector<vector<int> > graph(n);\n  for (int i = 0; i < k; ++i) {\n    cin >> a >> b;\n    --a;\n    --b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n  vector<pair<int, int> > enemies;\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    cin >> a >> b;\n    --a;\n    --b;\n    enemies.push_back(make_pair(a, b));\n  }\n  vector<int> components(n, -1);\n  vector<int> comp_length;\n  for (int i = 0; i < n; ++i) {\n    if (components[i] == -1) {\n      comp_length.push_back(0);\n      dfs(graph, i, components, comp_length, comp_length.size() - 1);\n    }\n  }\n  vector<bool> is_acceptable(comp_length.size(), true);\n  for (int i = 0; i < (int)enemies.size(); ++i) {\n    if (components[enemies[i].first] == components[enemies[i].second]) {\n      is_acceptable[components[enemies[i].first]] = false;\n    }\n  }\n  int max = 0;\n  for (int i = 0; i < (int)comp_length.size(); ++i) {\n    if (is_acceptable[i] && comp_length[i] > max) {\n      max = comp_length[i];\n    }\n  }\n  cout << max << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int sz = 1e5 + 5;\nvector<int> a[sz];\nbool mark[sz];\nint items[sz];\nint com[sz];\nint cc;\nint n;\nint k;\nvoid dfs(int u) {\n  com[u] = cc;\n  items[cc]++;\n  for (int i = 0; i < (int)a[u].size(); i++) {\n    int v = a[u][i];\n    if (!com[v]) dfs(v);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  ;\n  scanf(\"%d\", &k);\n  ;\n  for (int i = 0; i < k; i++) {\n    int u;\n    int v;\n    scanf(\"%d\", &u);\n    ;\n    scanf(\"%d\", &v);\n    ;\n    a[u].push_back(v);\n    a[v].push_back(u);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (com[i] == 0) {\n      cc++;\n      dfs(i);\n    }\n  }\n  int m;\n  scanf(\"%d\", &m);\n  ;\n  for (int i = 0; i < m; i++) {\n    int u;\n    int v;\n    scanf(\"%d\", &u);\n    ;\n    scanf(\"%d\", &v);\n    ;\n    if (com[u] == com[v]) mark[com[u]] = true;\n  }\n  int ans = 0;\n  for (int i = 1; i <= cc; i++) {\n    if (mark[i] == false) ans = max(ans, items[i]);\n  }\n  printf(\"%d\", ans);\n  ;\n  puts(\"\");\n  ;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n\npublic class Main {\n    static int i, j, k, n, m, t, y, x, sum=0;\n    static long mod = 1000000007;\n    static FastScanner fs = new FastScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    static String str;\n    static long ans;\n\n    static List<Integer>[] friends = new ArrayList[2005];\n    static List<Integer>[] enemy = new ArrayList[2005];\n\n    static int[] friendCircle = new int[2005];\n    static int[] enemyCircle = new int[2005];\n\n    public static void main(String[] args) {\n        t = 1;\n\n        while (t-- >0){\n\n            n = fs.nextInt();\n\n            for(i=0;i<=n;i++){\n                friends[i] = new ArrayList<>();\n                enemy[i] = new ArrayList<>();\n            }\n\n            k = fs.nextInt();\n\n            for(i=0;i<k;i++){\n                x = fs.nextInt();\n                y = fs.nextInt();\n\n                friends[x].add(y);\n                friends[y].add(x);\n            }\n\n            m = fs.nextInt();\n\n            for(i=0;i<m;i++){\n                x = fs.nextInt();\n                y = fs.nextInt();\n\n                enemy[x].add(y);\n                enemy[y].add(x);\n            }\n\n            j=0;\n            for(i=1;i<=n;i++){\n                if(friendCircle[i] == 0){\n                    j++;\n                    dfs(i, friends, friendCircle);\n                }\n            }\n\n            j=0;\n            for(i=1;i<=n;i++){\n                if(enemyCircle[i] == 0){\n                    j++;\n                    dfs(i, enemy, enemyCircle);\n                }\n            }\n\n\n           List<Integer>[] friends = new ArrayList[n+5];\n\n            for(i=0;i<=n;i++)\n                friends[i] = new ArrayList<>();\n\n            for(i=1;i<=n;i++){\n                friends[friendCircle[i]].add(i);\n            }\n\n            int ans = 0;\n\n            for(i=1;i<=n;i++){\n                if(friends[i].size()> ans){\n\n                    int f =0;\n\n\n\n                    for(j=0;j<friends[i].size();j++){\n\n                        int ele = friends[i].get(j);\n\n                       for(k=0;k<enemy[ele].size();k++){\n                           if(friends[i].contains(enemy[ele].get(k)))\n                           {\n                               f=1;\n                               break;\n                           }\n                       }\n                    }\n\n                    if(f==0)\n                        ans = friends[i].size();\n                }\n            }\n\n            out.print(ans);\n\n        }\n        out.close();\n    }\n\n    static void dfs(int pos, List<Integer>[] graph, int [] arr){\n\n        arr[pos] = j;\n\n        for(int i = 0; i<graph[pos].size();i++)\n            if(arr[graph[pos].get(i)] ==0)\n                dfs(graph[pos].get(i), graph, arr);\n    }\n\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n    static class Pair  {\n        int first, second;\n\n        public Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n\n        }\n\n    }\n\n    static void ruffleSort(int[] a) {\n        //ruffle\n        int n=a.length;\n        Random r=new Random();\n        for (int i=0; i<a.length; i++) {\n            int oi=r.nextInt(n), temp=a[i];\n            a[i]=a[oi];\n            a[oi]=temp;\n        }\n\n        //then sort\n        Arrays.sort(a);\n    }\n\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> p;\nvector<long long int> sz;\nvector<vector<long long int>> g;\nlong long int find_set(long long int x) {\n  if (x == p[x]) return x;\n  return p[x] = find_set(p[x]);\n}\nvoid union_set(long long int x, long long int y) {\n  x = find_set(x);\n  y = find_set(y);\n  if (x != y) {\n    p[y] = x;\n    sz[x] += sz[y];\n    sz[y] = 0;\n  }\n}\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long int n, k;\n  cin >> n >> k;\n  p = vector<long long int>(n + 1);\n  sz = vector<long long int>(n + 1, 1);\n  g = vector<vector<long long int>>(n + 1);\n  for (long long int i = 1; i <= n; ++i) p[i] = i;\n  for (long long int i = 0; i < k; ++i) {\n    long long int u, v;\n    cin >> u >> v;\n    union_set(u, v);\n  }\n  long long int m;\n  cin >> m;\n  long long int ans = 0;\n  vector<long long int> w(n + 1, 0);\n  for (long long int i = 0; i < m; ++i) {\n    long long int u, v;\n    cin >> u >> v;\n    long long int x = find_set(u);\n    long long int y = find_set(v);\n    if (x == y) w[x] = 1;\n  }\n  for (long long int i = 1; i <= n; ++i) {\n    if (!w[i]) {\n      ans = max(ans, sz[i]);\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000 * 3 + 10, INF = 1e9 + 10;\nstruct UnionFind {\n  int parent[MAXN], sz[MAXN];\n  UnionFind(int n) {\n    for (int i = 0; i < n; i++) {\n      parent[i] = i;\n      sz[i] = 1;\n    }\n  }\n  int find(int v) {\n    int root = v;\n    while (parent[root] != root) root = parent[root];\n    while (v != root) {\n      int old = v;\n      v = parent[v];\n      parent[old] = root;\n    }\n    return root;\n  }\n  void merge(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return;\n    if (sz[u] < sz[v]) swap(u, v);\n    sz[u] += sz[v];\n    parent[v] = u;\n  }\n};\nint mark[MAXN];\nvector<int> dis[MAXN];\nint main() {\n  ios::sync_with_stdio(false);\n  int n, k, m;\n  cin >> n >> k;\n  UnionFind a(n);\n  for (int i = 0; i < k; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    a.merge(x, y);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    dis[x].push_back(y);\n    dis[y].push_back(x);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++)\n    if (!mark[i]) {\n      vector<int> cur;\n      int root = a.find(i);\n      for (int j = 0; j < n; j++)\n        if (a.find(j) == root) {\n          cur.push_back(j);\n          mark[j] = i + 1;\n        }\n      bool check = true;\n      for (int j = 0; j < ((int)cur.size()); j++) {\n        int v = cur[j];\n        for (int k = 0; k < ((int)dis[v].size()); k++) {\n          if (mark[dis[v][k]] == i + 1) check = false;\n        }\n      }\n      if (!check) continue;\n      ans = max(ans, ((int)cur.size()));\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class C177 {\n\n    static BufferedReader br;\n    static StringTokenizer st;\n    static PrintWriter pw;\n\n    static String nextToken() {\n        try {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return st.nextToken();\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    static long nextLong() {\n        return Long.parseLong(nextToken());\n    }\n\n    static String nextLine() throws IOException {\n        return br.readLine();\n    }\n\n    static char nextChar() throws IOException {\n        return (char) br.read();\n    }\n\n    public static void main(String[] args) {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n        run();\n        pw.close();\n    }\n\n    static ArrayList<Integer> grafF[];\n    static ArrayList<Integer> grafUnF[];\n\n    private static void run() {\n        int n = nextInt();\n        int k = nextInt();\n        grafF = buildGraf(k, n);\n        int m = nextInt();\n        grafUnF = buildGraf(m, n);\n        used = new boolean[n];\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            max = 0;\n            set = new TreeSet<>();\n            was = new ArrayList<>();\n            dfs(i);\n            boolean tr = true;\n            for (int j = 0; j < was.size(); j++) {\n                if (set.contains(was.get(j))) {\n                    tr = false;\n                    break;\n                }\n            }\n            if (tr) {\n                ans = Math.max(max, ans);\n            }\n        }\n        pw.println(ans);\n    }\n\n    static int max;\n    static TreeSet<Integer> set = new TreeSet<>();\n    static ArrayList<Integer> was = new ArrayList<>();\n\n    private static void dfs(int v) {\n        if (used[v]) return;\n        max++;\n        used[v] = true;\n        was.add(v);\n        for (int i = 0; i < grafUnF[v].size(); i++) {\n            set.add(grafUnF[v].get(i));\n        }\n        for (int i = 0; i < grafF[v].size(); i++) {\n            dfs(grafF[v].get(i));\n        }\n    }\n\n    static boolean used[];\n\n    private static ArrayList<Integer>[] buildGraf(int k, int n) {\n        ArrayList<Integer>[] graf = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            graf[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < k; i++) {\n            int x = nextInt() - 1;\n            int y = nextInt() - 1;\n            graf[x].add(y);\n            graf[y].add(x);\n        }\n        return graf;\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n// very unsure\npublic class C2177 {\n\tprivate static int[] parent, size;\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tparent = new int[n];\n\t\tfor( int i = 0; i < n; i++ ) parent[i] = i;\n\t\tsize = new int[n];\n\t\tArrays.fill(size,1);\n\t\t\n\t\tint L = in.nextInt();\n\t\tfor( int i = 0; i < L; i++ ) {\n\t\t\tint u = in.nextInt()-1;\n\t\t\tint v = in.nextInt()-1;\n\t\t\tunion(u,v);\n\t\t}\n\t\t\n\t\tHashMap<Integer, Integer> hm = new HashMap<>();\n\t\tfor( int i = 0; i < n; i++ ) {\n\t\t\tif(!hm.containsKey(root(i))) {\n\t\t\t\thm.put(root(i),1);\n\t\t\t} else {\n\t\t\t\tint temp = hm.get(root(i));\n\t\t\t\thm.put(root(i),temp+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint D = in.nextInt();\n\t\tfor( int i = 0; i < D; i++ ) {\n\t\t\tint u = in.nextInt()-1;\n\t\t\tint v = in.nextInt()-1;\n\t\t\tif( find(u,v) ) {\n\t\t\t\thm.remove(root(u));\n\t\t\t}\n\t\t}\n\t\tint max = -1;\n\t\tIterator it = hm.entrySet().iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tMap.Entry pair = (Map.Entry) it.next();\n\t\t\tmax = Math.max(max, (int)pair.getValue());\n\t\t}\n\t\t\n\t\tif( max == -1 ) max = 0;\n\t\tSystem.out.println(max);\n\t}\n\t\n\tpublic static int root( int curr ) {\n\t\tif(parent[curr] != curr)\n\t\t\tparent[curr] = root(parent[curr]);\n\t\treturn parent[curr];\n\t}\n\t\n\tpublic static boolean find(int u,int v) {\n\t\treturn root(u) == root(v);\n\t}\n\t\n\tpublic static void union(int u, int v) {\n\t\tu = root(u);\n\t\tv = root(v);\n\t\tif( u == v ) return;\n\t\tif( size[u] < size[v] ) {\n\t\t\tparent[u] = v;\n\t\t\tsize[v] += size[u];\n\t\t} else {\n\t\t\tparent[v] = u;\n\t\t\tsize[u] += size[v];\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long LLINF = 1e17 + 7;\nconst int INF = 1e9 + 7;\nconst int MAX = 2000 + 7;\nconst int MOD = 1e9 + 7;\nstruct Node {\n  vector<int> adj;\n  bool vis = false;\n};\nNode node[MAX];\nbool enemy[MAX][MAX];\nvector<int> path;\nint mx = 0;\nvoid clean() {\n  for (int i = 0; i < MAX; i++) {\n    node[i].vis = false;\n  }\n}\nvoid addFriend(int v, int u) {\n  node[v].adj.push_back(u);\n  node[u].adj.push_back(v);\n}\nvoid addEnemy(int v, int u) {\n  enemy[v][u] = true;\n  enemy[u][v] = true;\n}\nvoid DFS(int v) {\n  node[v].vis = true;\n  path.push_back(v);\n  for (auto i : node[v].adj) {\n    if (!node[i].vis) DFS(i);\n  }\n}\nbool hasEnemy() {\n  for (auto i : path) {\n    for (auto j : path) {\n      if (enemy[i][j]) return true;\n    }\n  }\n  return false;\n}\nint main() {\n  int n;\n  cin >> n;\n  int f;\n  cin >> f;\n  while (f--) {\n    int v, u;\n    cin >> v >> u;\n    v--, u--;\n    addFriend(u, v);\n  }\n  int e;\n  cin >> e;\n  while (e--) {\n    int v, u;\n    cin >> v >> u;\n    v--, u--;\n    addEnemy(v, u);\n  }\n  for (int i = 0; i < n; i++) {\n    if (node[i].vis) continue;\n    path.clear();\n    DFS(i);\n    if (hasEnemy()) continue;\n    int sz = path.size();\n    mx = max(mx, sz);\n  }\n  cout << mx;\n  return EXIT_SUCCESS;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2000;\nint head[maxn], tol, vis[maxn], ans, flag[maxn][maxn], que[maxn * maxn], st;\nstruct node {\n  int next, to, val;\n} edge[maxn * maxn];\nvoid add(int u, int v, int w) {\n  edge[tol].to = v;\n  edge[tol].next = head[u];\n  edge[tol].val = w;\n  head[u] = tol++;\n}\nvoid dfs(int u) {\n  vis[u] = 1;\n  que[++st] = u;\n  for (int i = head[u]; i != -1; i = edge[i].next) {\n    int v = edge[i].to;\n    if (!vis[v] && edge[i].val) dfs(v);\n  }\n}\nint fun(int u) {\n  st = 0;\n  dfs(u);\n  for (int i = 1; i <= st; i++)\n    for (int j = i + 1; j <= st; j++)\n      if (flag[que[i]][que[j]] == -1) return 0;\n  return st;\n}\nint main() {\n  int i, j, k, m, n;\n  while (~scanf(\"%d\", &n)) {\n    memset(head, -1, sizeof(head));\n    tol = 0;\n    memset(vis, 0, sizeof(vis));\n    memset(flag, 0, sizeof(flag));\n    cin >> m;\n    while (m--) {\n      cin >> i >> j;\n      add(i, j, 1);\n      add(j, i, 1);\n      flag[i][j] = 1;\n      flag[j][i] = 1;\n    }\n    cin >> m;\n    while (m--) {\n      cin >> i >> j;\n      add(i, j, 0);\n      add(j, i, 0);\n      flag[i][j] = flag[j][i] = -1;\n    }\n    int cnt = 0;\n    for (i = 1; i <= n; i++)\n      if (vis[i] == 0) {\n        j = fun(i);\n        cnt = max(cnt, j);\n      }\n    cout << cnt << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst char IN[] = \"_.in\";\nconst char OUT[] = \"_.out\";\nconst int maxn = 2100;\nint ntest = 0, test;\nint n, k, m, u, v, res, dem;\nvector<int> a[maxn];\nbool dis[maxn][maxn];\nbool tham[maxn];\nint b[maxn];\nvoid nhap() {\n  cin >> n;\n  cin >> k;\n  for (int i = (1); i <= (k); i++) {\n    cin >> u >> v;\n    a[u].push_back(v);\n    a[v].push_back(u);\n  }\n  cin >> m;\n  for (int i = (1); i <= (m); i++) {\n    cin >> u >> v;\n    dis[u][v] = true;\n  }\n}\nvoid dfs(int u) {\n  tham[u] = true;\n  dem++;\n  b[dem] = u;\n  for (__typeof(a[u].begin()) i = a[u].begin(); i != a[u].end(); i++) {\n    int v = *i;\n    if (!tham[v]) dfs(v);\n  }\n}\nvoid solve() {\n  res = 0;\n  memset((tham), (false), sizeof(tham));\n  for (int i = (1); i <= (n); i++)\n    if (!tham[i]) {\n      dem = 0;\n      dfs(i);\n      bool ok = true;\n      for (int j = (1); j <= (dem); j++)\n        for (int o = (1); o <= (dem); o++)\n          if (dis[b[j]][b[o]]) {\n            ok = false;\n            break;\n          }\n      if (ok) res = max(res, dem);\n    }\n  cout << res;\n}\nint main() {\n  nhap();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "class DisjointSetStructure():\n    def __init__(self, n):\n        self.A = [[i,0,1] for i in range(n)]\n        self.size = n\n    def getpair(self, i):\n        p = i\n        while self.A[p][0] != p: p = self.A[p][0]\n        j = self.A[i][0]\n        while j != p:\n            self.A[i][0] = p\n            i, j = j, self.A[j][0]\n        return (p, self.A[p][2])\n    def __getitem__(self, i):\n        return self.getpair(i)[0]\n    def union(self, i, j):\n        u, v = self[i], self[j]\n        if u == v: return\n        self.size -= 1\n        if self.A[u][1] > self.A[v][1]:\n            self.A[v][0] = u\n            self.A[u][2] += self.A[v][2]\n        else:\n            self.A[u][0] = v\n            self.A[v][2] += self.A[u][2]\n            if self.A[u][1] == self.A[v][1]:\n                self.A[v][1] += 1\n    def __len__(self): return self.size\n\nn = int(input())\nk = int(input())\nD = DisjointSetStructure(n)\nfor i in range(k):\n    u, v = [int(x) - 1 for x in input().split()]\n    D.union(u, v)\nl = int(input())\nfriendly = [True for i in range(n)]\nfor i in range(l):\n    u, v = [int(x) - 1 for x in input().split()]\n    if D[u] == D[v]: friendly[D[u]] = False\n\nprint(max(D.getpair(i)[1] if friendly[D[i]] else 0 for i in range(n)))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, bool>> g[2005];\nint a = 0, cnt = 0;\nbool vs[2004];\nvector<set<int>> h;\nvoid dfs(int u, set<int> &s) {\n  vs[u] = 1;\n  s.insert(u);\n  for (pair<int, bool> v : g[u]) {\n    if (v.second == 1) {\n      if (!vs[v.first]) {\n        dfs(v.first, s);\n      }\n    }\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  int m;\n  cin >> m;\n  int u, v;\n  for (int i = 0; i < m; i++) {\n    cin >> u >> v;\n    g[u].push_back({v, 1});\n    g[v].push_back({u, 1});\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> u >> v;\n    g[u].push_back({v, 0});\n    g[v].push_back({u, 0});\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!vs[i]) {\n      set<int> s;\n      dfs(i, s);\n      h.push_back(s);\n    }\n  }\n  for (int i = 0; i < h.size(); i++) {\n    set<int> r = h[i];\n    bool f = 1;\n    for (int el : r) {\n      for (pair<int, bool> u : g[el]) {\n        if (u.second == 0) {\n          if (r.find(u.first) != r.end()) f = 0;\n        }\n      }\n    }\n    int l = r.size();\n    if (f) a = max(a, l);\n  }\n  cout << a << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Codeforces {\n    \n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n    \n\n//----------------------------------------------------------------------------------------------------//\n    void solve() {\n        int n=ni();\n        int k=ni();\n        Dsu uf=new Dsu(n);\n        for (int i = 0; i < k; i++) {\n            int u=ni()-1;\n            int v=ni()-1;\n            uf.union(v, u);\n        }\n        Set<Integer> roots = uf.getRoots();\n        int m=ni();\n        for (int i = 0; i < m; i++) {\n            int u=ni()-1;\n            int v=ni()-1;\n            int ru=uf.root(u);\n            int rv=uf.root(v);\n            if(ru==rv)roots.remove(ru);\n            \n        }\n        int ans=0;\n        for (Integer r : roots) {\n            ans=Math.max(ans, uf.size[r]);\n        }\n        out.println(ans);\n    }\n\n//----------------------------------------------------------------------------------------------------//\n    boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= (int) Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    Vector<Integer> sieveOfEratosthenes(int n) {\n        boolean[] prime = new boolean[n + 1];\n        for (int i = 0; i < n; i++) {\n            prime[i] = true;\n        }\n        for (int p = 2; p * p <= n; p++) {\n            if (prime[p] == true) {\n                for (int j = p * p; j <= n; j += p) {\n                    prime[j] = false;\n                }\n            }\n        }\n        Vector<Integer> v = new Vector<>();\n        for (int i = 2; i <= n; i++) {\n            if (prime[i]) {\n                v.add(i);\n            }\n        }\n        return v;\n    }\n    \n    void swap(int a[], int l, int r) {\n        int temp = a[l];\n        a[l] = a[r];\n        a[r] = temp;\n    }\n    \n    long nCr(int n, int k) {\n        long C[] = new long[k + 1];\n        // nC0 is 1 \n        C[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = Math.min(i, k); j > 0; j--) {\n                C[j] = C[j] + C[j - 1];\n            }\n        }\n        return C[k];\n    }\n    \n    int gcd(int s, int l) {\n        if (s == 0) {\n            return l;\n        }\n        \n        return gcd(l % s, s);\n    }\n    \n    int power(long x, long y, int m) { //log(y)\n        if (y == 0) {\n            return 1;\n        }\n        long p = power(x, y / 2, m) % m;\n        p = (p * p) % m;\n        return (int) ((y % 2 == 0) ? p : (x * p) % m);\n    }\n    \n    int modInverse(int a, int m) // O(Log m) whem m is prime (fermat's little theorem)\n    {        \n        if (gcd(a, m) != 1) {\n            return -1;\n        } else {            \n            return power(a, m - 2, m);            \n        }        \n    }    \n    \n    public HashMap<Integer, Integer> sortByValue(HashMap<Integer, Integer> hm) {\n        // Create a list from elements of HashMap \n        List<Map.Entry<Integer, Integer>> list\n                = new LinkedList<>(hm.entrySet());\n\n        //->change o1,o2 for reverseorder\n        Collections.sort(list, (Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) -> (o1.getValue()).compareTo(o2.getValue()));\n\n        // put data from sorted list to hashmap  \n        HashMap<Integer, Integer> temp = new LinkedHashMap<>();\n        list.forEach((aa) -> {\n            temp.put(aa.getKey(), aa.getValue());\n        });\n        return temp;\n    }\n    \n    void run() throws Exception {\n        is = System.in;//oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        \n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        tr(System.currentTimeMillis() - s + \"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception {\n        new Codeforces().run();\n    }\n    \n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte() {\n        if (lenbuf == -1) {\n            throw new InputMismatchException();\n        }\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) {\n                return -1;\n            }\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n    \n    private int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b));\n        return b;\n    }\n    \n    private double nd() {\n        return Double.parseDouble(ns());\n    }\n    \n    private char nc() {\n        return (char) skip();\n    }\n    \n    private String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) {\n            map[i] = ns(m);\n        }\n        return map;\n    }\n    \n    private int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = ni();\n        }\n        return a;\n    }\n    \n    private int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        \n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        \n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    \n    private void tr(Object... o) {\n        if (!oj) {\n            System.out.println(Arrays.deepToString(o));\n            \n        }\n    }\n    \n    class Pair {\n\n        /*SORTING PAIRS BY COMPARING Y OF PAIR.\n    Pair[] p=new Pair[n];\n    p[i]=new Pair(i,ni());\n    Arrays.sort(p,( p1, p2) -> {return p1.y-p2.y;});\n         */\n        int x;\n        int y;\n        \n        Pair(int u, int v) {\n            x = u;\n            y = v;\n        }\n        \n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (!(o instanceof Pair)) {\n                return false;\n            }\n            Pair key = (Pair) o;\n            return x == key.x && y == key.y;\n        }\n        \n        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            return result;\n        }\n        \n    }\n    \n    class Dsu {\n\n        int par[];\n        int size[];\n        int cnt;\n        Set<Integer> roots = new HashSet<>();\n        //boolean belongs[];\n        \n        Dsu(int n) {\n            cnt = n;//cnt=0;\n            par = new int[n];\n            size = new int[n];\n            //belongs=new boolean[n];\n            for (int i = 0; i < n; i++) {\n                par[i] = i;\n                size[i] = 1;\n                roots.add(i);\n                //belongs[i]=false;\n            }\n        }\n        \n        int root(int i) {\n            if (i == par[i]) {\n                return i;\n            }\n            return par[i] = root(par[i]);\n        }\n        \n        boolean find(int p, int q) {\n            return root(p) == root(q);\n        }\n        \n        void union(int p, int q) {\n            int a = root(p);\n            int b = root(q);\n            if (a != b) {\n                cnt--;\n            }\n            /*if(!belongs[p]&&!belongs[q])cnt++;\n            else if(belongs[p]&&belongs[q]){\n                if(a!=b)cnt--;\n            }\n            belongs[p]=belongs[q]=true;*/\n            if (a == b) {\n                return;\n            }\n            if (size[a] < size[b]) {\n                int temp = a;\n                a = b;\n                b = temp;\n            }\n            par[b] = a;\n            size[a] += size[b];\n            roots.add(a);\n            if (roots.contains(b)) {\n                roots.remove(b);\n            }\n        }\n        \n        Set<Integer> getRoots() {\n            return roots;\n        }\n        \n        int count() {            \n            return cnt;\n        }\n        \n    }\n}\n//isPrime(int)\n//Vector<Integer> sieveOfEratosthenes(int n){PRIME NO <=n}\n//swap(arr,i,j)\n//HashMap sortByValue(map);\n//long comb=nCr(5,2);\n//int gcd(s,l);\n//Pair p=new Pair(x,y);\n// Dsu dsu=new Dsu(n);"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> parent;\nint find(int u) {\n  while (parent[u] != -1) u = parent[u];\n  return u;\n}\nvoid unionop(int u, int v) {\n  int xp = find(u);\n  int yp = find(v);\n  if (xp != yp) parent[xp] = yp;\n}\nvoid solve() {\n  int n, k, m, x, y;\n  cin >> n;\n  parent.resize(n + 1, -1);\n  vector<pair<int, int> > p, d;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> x >> y;\n    p.push_back({x, y});\n  }\n  for (auto &it : p) {\n    unionop(it.first, it.second);\n  }\n  cin >> m;\n  vector<int> count(n + 1, 0);\n  for (int i = 0; i < m; i++) {\n    cin >> x >> y;\n    int xp = find(x);\n    int yp = find(y);\n    if (xp == yp) {\n      count[xp] = -1;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    int par = find(i);\n    if (count[par] != -1) {\n      count[par]++;\n    }\n  }\n  int mx = 0;\n  for (int i = 1; i <= n; i++) mx = max(mx, count[i]);\n  cout << mx;\n}\nint main(void) {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class ProblemC {\n\tScanner sc = new Scanner(System.in);\n\tPrintStream out = System.out;\n\n\tboolean[][] like;\n\tboolean[][] dislike;\n\t\n\tvoid start() {\n\t\tint n = sc.nextInt();\n\t\tlike = new boolean[n][n];\n\t\tdislike = new boolean[n][n];\n\t\t\n\t\tint m = sc.nextInt();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x = sc.nextInt() - 1;\n\t\t\tint y = sc.nextInt() - 1;\n\t\t\tlike[x][y] = true;\n\t\t\tlike[y][x] = true;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlike[i][i] = true;\n\t\t\n\t\tm = sc.nextInt();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x = sc.nextInt() - 1;\n\t\t\tint y = sc.nextInt() - 1;\n\t\t\tdislike[x][y] = true;\n\t\t\tdislike[y][x] = true;\n\t\t}\n\t\t\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tlike[i][j] = like[i][j] || (like[i][k] && like[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t//\tfor (int i = 0; i < n; i++) {\n\t//\t\tfor (int j = 0; j < n; j++) {\n\t//\t\t\tSystem.out.print(like[i][j] + \" \");\n\t//\t\t}\n\t//\t\tout.println();\n\t//\t}\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint row = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (!like[i][j]) continue;\n\t\t\t\trow++;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) \n\t\t\t\t\tif (like[i][k] && like[i][j] && dislike[j][k]) row = 0;\t\n\t\t\t}\n\t\t\t\n\t\t\tans = Math.max(ans, row);\n\t\t}\n\t\t\n\t\tout.println (ans);\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew ProblemC().start();\n\t}\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Max = 2e3 + 9;\nvector<int> G[Max], V;\nbool B[Max][Max], mark[Max];\nvoid dfs(int sv) {\n  mark[sv] = 1;\n  V.push_back(sv);\n  for (int i = 0; i < G[sv].size(); i++)\n    if (!mark[G[sv][i]]) dfs(G[sv][i]);\n}\nint main() {\n  int n, m, mx = 0, u, v;\n  scanf(\"%d%d\", &n, &m);\n  while (m--) scanf(\"%d%d\", &u, &v), G[u].push_back(v), G[v].push_back(u);\n  scanf(\"%d\", &m);\n  while (m--) scanf(\"%d%d\", &u, &v), B[u][v] = 1, B[v][u] = 1;\n  for (int i = 1; i <= n; i++)\n    if (!mark[i]) {\n      dfs(i);\n      for (int i = 0; i < V.size(); i++)\n        for (int j = i + 1; j < V.size(); j++)\n          if (B[V[i]][V[j]]) V.clear();\n      int sz = V.size();\n      mx = max(mx, sz);\n      V.clear();\n    }\n  printf(\"%d\", mx);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class First {\n    private static final Scanner sc = new Scanner(System.in);\n    private static final PrintWriter pw = new PrintWriter(System.out);\n    private static StringBuffer ans = new StringBuffer();\n    private static HashMap<Integer, HashSet<Integer>> g = new HashMap<>();\n    private static HashSet<Integer> curr;\n    private static boolean[] marked;\n\n    public static void main(String[] args) throws Exception {\n        int n = sc.nextInt(), m = sc.nextInt(), max = 0;\n        marked = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            g.put(i, new HashSet<>());\n            marked[i] = false;\n        }\n        for (int i = 0; i < m; i++) {\n            int x = sc.nextInt() - 1, y = sc.nextInt() - 1;\n            g.get(x).add(y);\n            g.get(y).add(x);\n        }\n        int k = sc.nextInt();\n        int[] dis = new int[k * 2];\n        for (int i = 0; i < dis.length; i += 2) {\n            dis[i] = sc.nextInt() - 1;\n            dis[i + 1] = sc.nextInt() - 1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (!marked[i]) {\n                curr = new HashSet<>();\n                boolean pair = true;\n                dfs(i);\n                for (int j = 0; j < dis.length && pair; j += 2)\n                    if (curr.contains(dis[j]) && curr.contains(dis[j + 1])) pair = false;\n                if (pair) max = Math.max(max, curr.size());\n            }\n        }\n        ans.append(max);\n        pw.print(ans);\n        sc.close();\n        pw.close();\n    }\n    private static void dfs(int u) {\n        marked[u] = true;\n        curr.add(u);\n        for (int x : g.get(u)) if (!marked[x]) dfs(x);\n    }\n}\nclass Scanner {\n    private final BufferedReader br;\n    private StringTokenizer st;\n    public Scanner(InputStream in) {\n        br = new BufferedReader(new InputStreamReader(in));\n        st = new StringTokenizer(\"\");\n    }\n    public String next() throws IOException {\n        if (!st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public void close() throws IOException {\n        br.close();\n    }\n}\nclass PrintWriter {\n    private final BufferedOutputStream pw;\n    public PrintWriter(OutputStream out) {\n        pw = new BufferedOutputStream(out);\n    }\n    public void print(Object o) throws IOException {\n        pw.write(o.toString().trim().getBytes());\n        pw.flush();\n    }\n    public void close() throws IOException {\n        pw.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n \n \npublic class Graph {\n    \n    private static int parent[];\n    private static int size[];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n \n        int n = sc.nextInt();\n        parent = new int[n];\n        \n        for(int i=0;i<n;i++) {\n            parent[i] = i;\n        }\n        \n        size = new int[n];\n        Arrays.fill(size, 1);\n        int f = sc.nextInt();\n        \n        for(int i=0;i<f;i++) {\n            int u = sc.nextInt()-1;\n            int v = sc.nextInt()-1;\n            Union(u, v);\n        }\n        \n        HashMap<Integer, Integer> hm = new HashMap<>();\n        \n        for(int i=0;i<n;i++) {\n            if(!hm.containsKey(root(i))) {\n                hm.put(root(i), 1);\n            } else {\n                int val = hm.get(root(i));\n                hm.put(root(i), val+1);\n            }\n        }\n        \n        int e = sc.nextInt();\n        for(int i=0;i<e;i++) {\n            int u = sc.nextInt()-1;\n            int v = sc.nextInt()-1;\n            if(find(u, v)) {\n                hm.remove(root(u));\n            } \n        }\n        \n        int max = -1;\n        Iterator it = hm.entrySet().iterator();\n        while(it.hasNext()) {\n            Map.Entry pair = (Map.Entry)it.next();\n            max = Math.max(max, (int)pair.getValue());\n        }\n        if(max==-1) {\n            max = 0;\n        }\n        System.out.println(max);\n    }\n    \n    public static boolean find(int u, int v) {\n        return root(u) == root(v);\n    }\n    \n    public static int root(int curr) {\n        if(parent[curr]!=curr) {\n            parent[curr] = root(parent[curr]);\n        }\n        return parent[curr];\n    }\n    \n    public static void Union(int u, int v) {\n        u = root(u);\n        v = root(v);\n        \n        if(u==v) {\n            return;\n        }\n        \n        if( size[u] < size[v] ) {\n\t\t\tparent[u] = v;\n\t\t\tsize[v] += size[u];\n\t\t} else {\n\t\t\tparent[v] = u;\n\t\t\tsize[u] += size[v];\n\t\t}\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\n\npublic class AbbyCupC1Party {\n\n\tpublic static void main(String args[] ) throws Exception {\n\t\t   \n\t\tInputReader in = new InputReader(System.in);\n\t    PrintWriter w = new PrintWriter(System.out);\n\t    \n\t    int n = in.nextInt();\n\t          \n\t    DisjointSet ds = new DisjointSet(n);\n\t        \n\t    int k = in.nextInt();\n\t    for(int i=0;i<k;i++)\n\t    \tds.merge(in.nextInt()-1, in.nextInt()-1);\n\t    \n\t    int m = in.nextInt();\n\t    for(int i=0;i<m;i++)\n\t    \tds.destroy(in.nextInt()-1,in.nextInt()-1);\n\t    \n\t    int ans = 0;\n\t    \n\t    for(int i=0;i<n;i++){\n\t    \tint root = ds.find(i);\n\t    \tif(ds.canTake[root])\n\t    \t\tans = Math.max(ans, ds.size[root]);\n\t    }\n\t    \n\t    w.println(ans);\n\t    w.close(); \n\t}\n\t\n\t\n\tstatic public class DisjointSet {\n\n\t\tpublic int rank[],parent[],size[];\n\t\tpublic int n;\n\t\tpublic boolean canTake[];\n\t\t\n\t\tpublic DisjointSet(int n){\n\t\t    this.n = n;\n\t\t\tmakeSet();\n\t\t}\n\t\t\n\t\tpublic void makeSet(){\n\t\t\trank = new int[n];\n\t\t\tparent = new int[n];\n\t\t\tsize = new int[n];\n\t\t\tcanTake = new boolean[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tparent[i] = i;\n\t\t\t\tsize[i] = 1;\n\t\t\t\tcanTake[i] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(parent[x] != x)\n\t\t\t\tparent[x] = find(parent[x]);\n\t\t\treturn parent[x];\n\t\t}\n\t\t\n\t\tpublic void merge(int x,int y){\n\t\t\tint xRoot = find(x);\n\t\t\tint yRoot = find(y);\n\t\t\t\n\t\t\tif(xRoot == yRoot)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif(rank[xRoot] < rank[yRoot]){\n\t\t\t\tparent[xRoot] = yRoot;\n\t\t\t\tsize[yRoot] += size[xRoot];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tparent[yRoot] = xRoot;\n\t\t\t\tif(rank[xRoot] == rank[yRoot]){\n\t\t\t\t\tparent[yRoot] = xRoot;\n\t\t\t\t\trank[xRoot]++;\n\t\t\t\t}\n\t\t\t\tsize[xRoot] += size[yRoot];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void destroy(int x,int y){\n\t\t\tint xRoot = find(x);\n\t\t\tint yRoot = find(y);\n\t\t\tif(xRoot == yRoot)\n\t\t\t\tcanTake[xRoot] = false;\n\t\t}\n\t\t\n\t}\n\t\n\tstatic public class InputReader {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\t\t\n\t\tpublic int snext() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.StreamTokenizer;\nimport java.io.Writer;\nimport java.util.HashSet;\nimport java.util.Set;\n/**\n * Date     : 21.04.2012\n * Time     : 16:48:27\n * Email    : denys.astanin@gmail.com\n */\n\npublic class e_d {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew e_d().run();\n\t}\n\n\tint nextInt() throws IOException {\n\t\tin.nextToken();\n\t\treturn (int) in.nval;\n\t}\n\n\tString nextString() throws IOException {\n\t\tin.nextToken();\n\t\treturn (String) in.sval;\n\t}\n\n\tStreamTokenizer in;\n\tWriter writer;\n\tReader reader;\n\n\tvoid run() throws IOException {\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\treader = oj ? new InputStreamReader(System.in, \"ISO-8859-1\")\n\t\t\t\t: new FileReader(\"input/ie_d.txt\");\n\t\twriter = new OutputStreamWriter(System.out, \"ISO-8859-1\");\n\t\tin = new StreamTokenizer(new BufferedReader(reader));\n\t\tPrintWriter out = new PrintWriter(writer);\n\t\tint count = nextInt();\n\t\tint fpairs = nextInt();\n\t\tboolean[][] friend = new boolean[count + 1][count + 1];\n\t\tfor (int i = 0; i < fpairs; i++) {\n\t\t\tint first = nextInt();\n\t\t\tint second = nextInt();\n\t\t\tfriend[first][second] = true;\n\t\t\tfriend[second][first] = true;\n\t\t}\n\t\tint epairs = nextInt();\n\t\tboolean[][] enemy = new boolean[count + 1][count + 1];\n\t\tfor (int i = 0; i < epairs; i++) {\n\t\t\tint first = nextInt();\n\t\t\tint second = nextInt();\n\t\t\tenemy[first][second] = true;\n\t\t\tenemy[second][first] = true;\n\t\t}\n\t\tint max = 0;\n\t\tfor (int i = 1; i <= count; i++) {\n\t\t\tSet<Integer> friendChain = new HashSet<Integer>();\n\t\t\tfriendChain.add(i);\n\t\t\tdfs(friend, friendChain, i);\n\t\t\tboolean possible = true;\n\t\t\tcycle : for (int j = 1; j <= count; j++) {\n\t\t\t\tfor (int k = 1; k <= count; k++) {\n\t\t\t\t\tif (enemy[j][k]) {\n\t\t\t\t\t\tif (friendChain.contains(j) && friendChain.contains(k)) {\n\t\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\t\tbreak cycle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (possible) {\n\t\t\t\tmax = Math.max(max, friendChain.size());\n\t\t\t}\n\t\t}\n\t\tout.println(max);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\tvoid dfs(boolean[][] friend, Set<Integer> friendChain, int from) {\n\t\tfor (int i = 1; i < friend.length; ++i) {\n\t\t\tif (friend[from][i] && !friendChain.contains(i)) {\n\t\t\t\tfriendChain.add(i);\n\t\t\t\tdfs(friend, friendChain, i);\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long BigMod(long long B, long long P, long long M) {\n  long long R = 1;\n  while (P > 0) {\n    if (P % 2 == 1) {\n      R = (R * B) % M;\n    }\n    P /= 2;\n    B = (B * B) % M;\n  }\n  return R;\n}\nint pr[2001];\nint find(int r) {\n  if (pr[r] == r)\n    return r;\n  else\n    return pr[r] = find(pr[r]);\n}\nint n, k, m;\nint seg[2001];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(nullptr);\n  cin >> n;\n  for (int i = 1; i <= n; i++) pr[i] = i, seg[i] = 1;\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    int a, b;\n    cin >> a >> b;\n    int u = find(a);\n    int v = find(b);\n    if (u != v) {\n      pr[v] = u;\n      seg[u] += seg[v];\n    }\n  }\n  int mx = 0;\n  cin >> m;\n  for (int i = 1; i <= m; i++) {\n    int a, b;\n    cin >> a >> b;\n    int u = find(a);\n    int v = find(b);\n    if (u == v) {\n      seg[u] = 0;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (find(i) == i) mx = max(mx, seg[i]);\n  }\n  cout << mx;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> grav[2050];\nint n;\nint m, k;\nint mark[2050];\nbool bad[2050];\nint sz[2050];\nvoid dfs(int v, int color) {\n  mark[v] = color;\n  for (int i = 0; i < (int)grav[v].size(); i++) {\n    int u = grav[v][i];\n    if (mark[u] == 0) dfs(u, color);\n  }\n}\nint main() {\n  int u, v;\n  cin >> n;\n  cin >> m;\n  for (int i = 0; i < (int)(m); i++) {\n    cin >> u >> v;\n    --u;\n    --v;\n    grav[u].push_back(v);\n    grav[v].push_back(u);\n  }\n  int color = 1;\n  for (int i = 0; i < (int)(n); i++) {\n    if (mark[i] == 0) dfs(i, color++);\n    sz[mark[i]]++;\n  }\n  cin >> k;\n  for (int i = 0; i < (int)(k); i++) {\n    cin >> u >> v;\n    --u;\n    --v;\n    if (mark[u] == mark[v]) bad[mark[u]] = true;\n  }\n  int mx = 0;\n  for (int c = 1; c < color; ++c) {\n    if (!bad[c] && (mx == 0 || sz[c] > sz[mx])) mx = c;\n  }\n  cout << sz[mx] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main implements Runnable {\n        int N, F, E;\n        ArrayList<Integer>[] graph;\n        boolean[][] enemy;\n        boolean[] was;\n        List<Integer> q;\n        \n\tpublic void solve() throws IOException {\n            N = nextInt();\n            graph = new ArrayList[N];\n            for(int i = 0; i < N; i++) graph[i] = new ArrayList<>();\n            enemy = new boolean[N][N];\n            was = new boolean[N];\n            \n            F = nextInt();\n            for(int i = 0; i < F; i++){\n                int from = nextInt() - 1;\n                int to = nextInt() - 1;\n                graph[from].add(to);\n                graph[to].add(from);\n            }\n            \n            E = nextInt();\n            for(int i = 0; i < E; i++){\n                int from = nextInt() - 1;\n                int to = nextInt() - 1;\n                enemy[from][to] = enemy[to][from] = true;\n            }\n            \n            int answer = 0;\n            for(int i = 0; i < N; i++){\n                if(!was[i]){\n                    q = new LinkedList<>();\n                    dfs(i);\n                    \n                    if(ok()){\n                        answer = Math.max(answer, q.size());\n                    }\n                }\n            }\n            \n            System.out.println(answer);\n\t}\n\n        private void dfs(int x){\n            was[x] = true;\n            q.add(x);\n            for(int i = 0; i < graph[x].size(); i++){\n                if(!was[graph[x].get(i)]){\n                    dfs(graph[x].get(i));\n                }\n            }\n        }\n\t\n        private boolean ok(){\n            int sz = q.size();\n            for(int i = 0; i < sz; i++){\n                for(int j = i + 1; j < sz; j++){\n                    if(enemy[q.get(i)][q.get(j)]) return false;\n                }\n            }\n            \n            return true;\n        }\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t//-----------------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n        public void print1Int(int[] a){\n                for(int i = 0; i < a.length; i++)\n                        System.out.print(a[i] + \" \");\n                System.out.println();\n        }\n        \n        public void print2Int(int[][] a){\n                for(int i = 0; i < a.length; i++){\n                        for(int j = 0; j < a[0].length; j++){\n                                System.out.print(a[i][j] + \" \");\n                        }\n                        System.out.println();\n                }\n        }\n        \n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttok = null;\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\n\tpublic String nextToken() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tBufferedReader in;\n\tStringTokenizer tok;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass Set {\n public:\n  long long rank;\n  long long parent;\n};\nlong long find(Set *set, long long i) {\n  if (set[i].parent != i) set[i].parent = find(set, set[i].parent);\n  return set[i].parent;\n}\nvoid Union(Set *set, long long v1, long long v2) {\n  long long v1_root = find(set, v1);\n  long long v2_root = find(set, v2);\n  if (set[v1_root].rank < set[v2_root].rank) {\n    set[v1_root].parent = v2_root;\n  } else if (set[v2_root].rank > set[v2_root].rank) {\n    set[v2_root].parent = v1_root;\n  } else {\n    set[v2_root].parent = v1_root;\n    set[v1_root].rank++;\n  }\n}\nint main() {\n  long long n, k;\n  cin >> n >> k;\n  Set *set = new Set[n + 1];\n  for (long long i = 1; i < n + 1; i++) {\n    set[i].parent = i;\n    set[i].rank = 0;\n  }\n  while (k--) {\n    long long a, b;\n    cin >> a >> b;\n    Union(set, a, b);\n  }\n  long long m;\n  cin >> m;\n  long long mark[2001] = {0};\n  while (m--) {\n    long long a, b;\n    cin >> a >> b;\n    long long p = find(set, a), q = find(set, b);\n    if (p == q) mark[p] = 1;\n  }\n  map<long long, long long> mp;\n  for (long long i = 1; i < n + 1; i++) {\n    long long q = find(set, i);\n    if (mark[q] != 1) mp[q]++;\n  }\n  long long ans = 0;\n  for (auto i : mp) {\n    ans = max(ans, i.second);\n  }\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 3,
            "solution": "t, p, k = [0] * (int(input()) + 1), {0: []}, 1\nfor i in range(int(input())):\n    a, b = map(int, input().split())\n    if t[a] == t[b]:\n        if t[a] == 0:\n            t[a] = t[b] = k\n            p[k] = [a, b]\n            k += 1            \n    else:\n        if t[a] == 0:\n            t[a] = t[b]\n            p[t[b]].append(a)\n        elif t[b] == 0:\n            t[b] = t[a]\n            p[t[a]].append(b)\n        else:\n            x, y = t[b], t[a]\n            for c in p[x]:\n                t[c] = y\n            p[y] += p[x]\n            p[x] = []          \nfor i in range(int(input())):\n    a, b = map(int, input().split())\n    if t[a] == t[b]: p[t[a]] = []\nans = max(len(p[i]) for i in p)\nprint(ans if ans > 0 else int(0 in t[1:]))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> adj[1000005];\nvector<long long> grp;\nvector<vector<long long> > cycle;\nlong long visited[1000005];\nvoid dfs(long long x) {\n  visited[x] = 1;\n  grp.push_back(x);\n  for (int i = 0; i < adj[x].size(); i++) {\n    int u = adj[x][i];\n    if (visited[u] == 0) {\n      dfs(u);\n    }\n  }\n}\nint main() {\n  int n, k, m;\n  cin >> n >> k;\n  int p, q, r = 0;\n  for (int i = 0; i < k; i++) {\n    cin >> p >> q;\n    adj[p].push_back(q);\n    adj[q].push_back(p);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (visited[i] == 0) {\n      grp.clear();\n      dfs(i);\n      cycle.push_back(grp);\n    }\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> p >> q;\n    for (int j = 0; j < cycle.size(); j++) {\n      int a = 0, b = 0;\n      for (int k = 0; k < cycle[j].size(); k++) {\n        if (cycle[j][k] == p) a = 1;\n        if (cycle[j][k] == q) b = 1;\n      }\n      if (a == 1 && b == 1) cycle[j][0] = n + 10;\n    }\n  }\n  int max = 0;\n  for (int i = 0; i < cycle.size(); i++) {\n    if (cycle[i].size() > max && cycle[i][0] != n + 10) max = cycle[i].size();\n  }\n  cout << max << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e5 + 10;\nvector<int> P(N), R(N), S(N);\nint find(int x) {\n  if (x == P[x]) return x;\n  return P[x] = find(P[x]);\n}\nvoid join(int a, int b) {\n  a = find(a);\n  b = find(b);\n  if (a != b) {\n    if (R[a] > R[b]) {\n      P[b] = a;\n      S[a] += S[b];\n    } else if (R[a] < R[b]) {\n      P[a] = b;\n      S[b] += S[a];\n    } else {\n      R[a]++;\n      P[b] = a;\n      S[a] += S[b];\n    }\n  }\n}\nvoid solve() {\n  int n, k, m;\n  scanf(\"%d\", &n), scanf(\"%d\", &k);\n  for (int i = 1; i <= n; i++) {\n    P[i] = i;\n    R[i] = 1;\n    S[i] = 1;\n  }\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    scanf(\"%d\", &u), scanf(\"%d\", &v);\n    join(u, v);\n  }\n  scanf(\"%d\", &m);\n  unordered_set<int> bad;\n  int mx = 0;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    scanf(\"%d\", &x), scanf(\"%d\", &y);\n    x = find(x), y = find(y);\n    if (x == y) {\n      bad.insert(x);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    int x = find(i);\n    if (bad.count(x)) continue;\n    mx = max(mx, S[find(x)]);\n  }\n  printf(\"%d\\n\", mx);\n}\nint main() {\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, k, m, a, b, sol;\nint p[2001];\nint depth[2001];\nint del[2001];\nint done[2001];\nint size[2001];\nint max(int i, int j) { return (i > j) ? i : j; }\nint dsu_find(int i) {\n  while (i != p[i]) {\n    p[i] = p[p[i]];\n    i = p[i];\n  }\n  return i;\n}\nvoid dsu_union(int i, int j) {\n  i = dsu_find(i);\n  j = dsu_find(j);\n  if (depth[i] > depth[j])\n    p[j] = i;\n  else {\n    p[i] = j;\n    if (depth[i] == depth[j]) depth[j]++;\n  }\n}\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    p[i] = i;\n    depth[i] = 1;\n  }\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; ++i) {\n    scanf(\"%d %d\", &a, &b);\n    dsu_union(a, b);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", &a, &b);\n    a = dsu_find(a);\n    b = dsu_find(b);\n    if (a == b) del[a]++;\n  }\n  for (int i = 1; i <= n; ++i) {\n    a = dsu_find(i);\n    if (!del[a]) size[a]++;\n  }\n  for (int i = 1; i <= n; ++i) sol = max(sol, size[i]);\n  printf(\"%d\", sol);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nunordered_map<long long, set<long long> > friends, hate;\nvector<bool> visited;\nlong long n, m;\nset<long long> addedInThisSet;\nbool possible;\nlong long length;\nvoid dfs(int i) {\n  if (visited[i]) return;\n  visited[i] = true;\n  length++;\n  for (auto j : addedInThisSet) {\n    if (hate[i].count(j)) possible = false;\n  }\n  addedInThisSet.insert(i);\n  for (auto j : friends[i]) {\n    dfs(j);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    friends[a].insert(b);\n    friends[b].insert(a);\n  }\n  long long k;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    hate[a].insert(b);\n    hate[b].insert(a);\n  }\n  visited.resize(n + 1);\n  long long ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (visited[i]) continue;\n    possible = true;\n    length = 0;\n    dfs(i);\n    if (possible) {\n      ans = max(ans, length);\n    }\n    addedInThisSet.clear();\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        StringTokenizer token = new StringTokenizer(reader.readLine());\n        int n = Integer.parseInt(token.nextToken());\n\n        int a[][] = new int[n][n];\n\n        token = new StringTokenizer(reader.readLine());\n        int fr = Integer.parseInt(token.nextToken());\n        for (int i = 0; i < fr; i++) {\n            token = new StringTokenizer(reader.readLine());\n            int u = Integer.parseInt(token.nextToken());\n            int v = Integer.parseInt(token.nextToken());\n            u--;\n            v--;\n            a[v][u] = 1;\n            a[u][v] = 1;\n        }\n\n        token = new StringTokenizer(reader.readLine());\n        int ang = Integer.parseInt(token.nextToken());\n        for (int i = 0; i < ang; i++) {\n            token = new StringTokenizer(reader.readLine());\n            int u = Integer.parseInt(token.nextToken());\n            int v = Integer.parseInt(token.nextToken());\n            u--;\n            v--;\n            a[u][v] = -1;\n            a[v][u] = -1;\n        }\n\n        int maxfr = 0;\n\n        boolean used[] = new boolean[n];\n\n        for (int i = 0; i < used.length; i++) {\n            boolean fail = false;\n\n            if (!used[i]) {\n                boolean frset[] = new boolean[n];\n                frset[i] = true;\n\n                Deque<Integer> st = new ArrayDeque<Integer>();\n                st.push(i);\n\n                while (!st.isEmpty()) {\n                    int v = st.pop();\n                    used[v] = true;\n\n                    for (int k = 0; k < n; k++) {\n                        if (a[v][k] == 1 && !frset[k]) {\n                            frset[k] = true;\n                            st.push(k);\n                        }\n\n                        if (a[v][k] == -1) {\n                            if (frset[k]) {\n                                fail = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (fail)\n                        break;\n                }\n\n                if (fail)\n                    continue;\n\n                int c = 0;\n                for (boolean aFrset : frset) {\n                    if (aFrset)\n                        c++;\n                }\n\n                maxfr = Math.max(c, maxfr);\n            }\n\n        }\n\n        System.out.println(maxfr);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Task {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Task().solve();\n\t}\n\tint n;\n\tboolean f[][];\n\tboolean h[][];\n\tboolean d[];\n\tArrayList <Integer> list= new ArrayList <Integer> ();\n\t\n\tvoid dfs(int v)\n\t{\n\t\td[v] = true;\n//\t\tSystem.out.println(v);\n\t\tlist.add(v);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif(!d[i] && f[i][v])\n\t\t\t\tdfs(i);\n\t\t}\n\t}\n\t\n\tvoid solve() throws Exception {\n\n\t\tReader in = new Reader();\n\t\tPrintWriter out = new PrintWriter(new BufferedWriter(\n\t\tnew OutputStreamWriter(System.out)));\n\t\tn = in.nextInt();\n\t\tf = new boolean[n][n];\n\t\th = new boolean[n][n];\n\t\td = new boolean[n];\n\t\tint k = in.nextInt();\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint x = in.nextInt()-1;\n\t\t\tint y = in.nextInt()-1;\n\t\t\tf[x][y] = true;\n\t\t\tf[y][x] = true;\n\t\t}\n\t\tint l = in.nextInt();\n\t\t\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\tint x = in.nextInt()-1;\n\t\t\tint y = in.nextInt()-1;\n\t\t\th[x][y] = true;\n\t\t\th[y][x] = true;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlist.clear();\n//\t\t\tSystem.out.println(\"!\");\n\t\t\tif(!d[i])\n\t\t\t\tdfs(i);\n\t\t\tboolean tr = true;\n\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\tfor (int j2 = 0; j2 < list.size(); j2++) {\n\t\t\t\t\tif(j != j2)\n\t\t\t\t\t\ttr = tr && (f[list.get(j)][list.get(j2)] || !(h[list.get(j)][list.get(j2)]) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tr)\n\t\t\t\tres = Math.max(res, list.size());\n\t\t}\n\t\tSystem.out.println(res);\n\t\t// BufferedWriter out = new BufferedWriter( new\n\t\t// OutputStreamWriter(System.out) );\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tclass Reader {\n\n\t\tBufferedReader br;\n\t\tStringTokenizer token;\n\n\t\tReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString Next() throws Exception {\n\t\t\twhile (token == null || !token.hasMoreElements()) {\n\t\t\t\ttoken = new StringTokenizer(br.readLine());\n\t\t\t}\n\n\t\t\treturn token.nextToken();\n\n\t\t}\n\n\t\tint nextInt() throws Exception, Exception {\n\t\t\treturn Integer.valueOf(Next());\n\t\t}\n\n\t\tlong nextLong() throws Exception, Exception {\n\t\t\treturn Long.valueOf(Next());\n\t\t}\n\n\t\tString nextString() throws Exception {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Main implements Runnable {\n\n    boolean[] visited;\n\n    public void solve() throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n        }\n        for (int i = 0; i < m; i++) {\n            int a = nextInt() - 1;\n            int b = nextInt() - 1;\n            merge(p, a, b);\n        }\n        boolean[] good = new boolean[n];\n\n        int[] size = new int[n];\n        for (int i = 0; i < n; i++) {\n            size[get(p, i)]++;\n            good[i] = true;\n        }\n        m = nextInt();\n        for (int i = 0; i < m; i++) {\n            int a = nextInt() - 1;\n            int b = nextInt() - 1;\n            if (get(p, a) == get(p, b)) {\n                good[get(p, a)] = false;\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (good[i]) {\n                ans = Math.max(ans, size[i]);\n            }\n        }\n        System.out.println(ans);\n    }\n\n    void dfs(boolean[][] board, int ind) {\n        visited[ind] = true;\n        for (int i = 0; i < board.length; i++) {\n            if (board[ind][i] && !visited[i]) {\n                dfs(board, i);\n            }\n        }\n\n    }\n\n    int answer(int[] a, int[] b) {\n        int n = a.length;\n        b = b.clone();\n        a = a.clone();\n        for (int i = 0; i < n; i++) {\n            if (b[i] >= 0) {\n                merge(a, i, b[i]);\n            }\n        }\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] < 0) {\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n\n    void merge(int[] arr, int a, int b) {\n        a = get(arr, a);\n        b = get(arr, b);\n        if (a != b) {\n            arr[a] = b;\n        }\n    }\n\n    int get(int[] arr, int a) {\n        if (arr[a] == a) {\n            return a;\n        }\n        return arr[a] = get(arr, arr[a]);\n    }\n\n    void shuffle(int[] a) {\n        int N = a.length;\n        for (int i = 0; i < N / 2; i++) {\n            int j = (int) (Math.random() * N);\n            int t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n        }\n    }\n\n    void print(int[] a) {\n        System.out.println();\n        for (int i = 0; i < a.length; i++) {\n            System.out.print(a[i] + \" \");\n        }\n    }\n\n    void print(int[][] arr) {\n        System.out.println();\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[i].length; j++) {\n                System.out.print(arr[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    void print(boolean[][] arr) {\n        System.out.println();\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[i].length; j++) {\n                System.out.print(arr[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    boolean nextPermutation(int[] arr) {\n        int f = -1;\n        for (int i = arr.length - 2; i >= 0; i--) {\n            if (arr[i + 1] > arr[i]) {\n                f = i;\n                break;\n            }\n        }\n        if (f == -1) {\n            return false;\n        }\n        int s = -1;\n        for (int i = arr.length - 1; i >= 0; i--) {\n            if (arr[i] > arr[f]) {\n                s = i;\n                break;\n            }\n        }\n        int d = arr[f];\n        arr[f] = arr[s];\n        arr[s] = d;\n\n        f++;\n        int l = arr.length - 1;\n        while (f < l) {\n            d = arr[f];\n            arr[f] = arr[l];\n            arr[l] = d;\n            f++;\n            l--;\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    public void run() {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            tok = null;\n            solve();\n            in.close();\n        } catch (IOException e) {\n            System.exit(0);\n        }\n    }\n\n    public String nextToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    BufferedReader in;\n    StringTokenizer tok;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid addedge(vector<long long int> adj[], int u, int v) {\n  adj[u].push_back(v);\n  adj[v].push_back(u);\n}\nvector<long long int> v;\nvoid dfs(vector<long long int> adj[], long long int u,\n         vector<long long int> &vis) {\n  vis[u] = true;\n  v.push_back(u);\n  for (long long int i = 0; i < adj[u].size(); i++) {\n    if (!vis[adj[u][i]]) dfs(adj, adj[u][i], vis);\n  }\n}\nvoid solve() {\n  long long int i, j, k, n, m, m2;\n  cin >> n >> m;\n  vector<long long int> adj[n];\n  for (i = 0; i < m; i++) {\n    cin >> j >> k;\n    addedge(adj, j - 1, k - 1);\n  }\n  cin >> m2;\n  vector<vector<long long int> > mp(2001, vector<long long int>(2001, 0));\n  for (i = 0; i < m2; i++) {\n    cin >> j >> k;\n    mp[j - 1][k - 1] = 1;\n  }\n  vector<long long int> vis(n, 0);\n  long long int ans = 0;\n  for (i = 0; i < n; i++) {\n    if (!vis[i]) {\n      v.clear();\n      dfs(adj, i, vis);\n      long long int u = 1;\n      for (j = 0; j < v.size(); j++) {\n        for (k = j + 1; k < v.size(); k++) {\n          if (mp[v[j]][v[k]]) u = 0;\n        }\n      }\n      if (u) ans = max(ans, (long long int)v.size());\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 5;\nconst int inf = 0x3f3f3f3f;\nint n, m;\nvector<int> G[maxn];\nint color[maxn];\nint sz[maxn];\nint vis[maxn];\nvoid dfs(int u, int col) {\n  color[u] = col;\n  for (auto it : G[u]) {\n    if (!color[it]) {\n      color[it] = col;\n      dfs(it, col);\n    }\n  }\n}\nint main() {\n  cin >> n;\n  int x;\n  cin >> x;\n  for (int i = 1; i <= x; i++) {\n    int u, v;\n    cin >> u >> v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  int tmp = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!color[i]) {\n      dfs(i, ++tmp);\n    }\n  }\n  for (int i = 1; i <= n; i++) sz[color[i]]++;\n  int y;\n  cin >> y;\n  for (int i = 1; i <= y; i++) {\n    int u, v;\n    cin >> u >> v;\n    if (color[u] == color[v]) {\n      vis[color[u]] = 1;\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      ans = max(ans, sz[i]);\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.security.SecureRandom;\nimport java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n    \n    \n\tint n, k, m;\n\tArrayList<ArrayList<Integer>> friend = new ArrayList<>();\n\tArrayList<ArrayList<Integer>> enemy = new ArrayList<>();\n\tboolean used[];\n\tboolean dfs(int s) {\n\t\tused[s] = true;\n\t\tfor (int i : friend.get(s)) {\n\t\t\tif (!used[i]) {\n\t\t\t\tdfs(i);\n\t\t\t\tfor (int j : enemy.get(i)) {\n\t\t\t\t\tif (used[j]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic void solve() throws Exception {\n\t\tn = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\tfor (int i = 0;i < n; ++ i) {\n\t\t\tfriend.add(new ArrayList<Integer>());\n\t\t\tenemy.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor (int i = 0;i < k; ++ i) {\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tfriend.get(s).add(t);\n\t\t\tfriend.get(t).add(s);\n\t\t}\n\t\tm = sc.nextInt();\n\t\tfor (int i = 0;i < m; ++ i) {\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tenemy.get(s).add(t);\n\t\t\tenemy.get(t).add(s);\n\t\t}\n\t\tint ans = 0;\n\t\tused = new boolean[n];\n\n\t\tfor (int i = 0;i < n; ++ i) {\n\t\t\tArrays.fill(used, false);\n\t\t\tif (dfs(i)) {\n\t\t\t\tint col = 0;\n\t\t\t\tboolean can = true;\n\t\t\t\tfor (int ii = 0;ii < n; ++ ii) {\n\t\t\t\t\tif (used[ii]) {\n\t\t\t\t\t\t++ col;\n\t\t\t\t\t\tfor (int j : enemy.get(ii)) {\n\t\t\t\t\t\t\tif (used[j]) {\n\t\t\t\t\t\t\t\tcan = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (can)\n\t\t\t\t\tans = max(ans, col);\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n    }\n    \n    \n    \n    \n    /*--------------------------------------------------------------*/\n    \n    static String filename = \"\";\n    static boolean fromFile = false;\n    \n    BufferedReader in;\n    PrintWriter out;\n    FastScanner sc;\n    \n    public static void main(String[] args) {\n        new Thread(null, new Solution(), \"\", 1 << 25).start();\n    }\n   \n    public void run() {\n        try {\n            init();\n            solve();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            out.close();\n        }\n    }\n    \n    void init() throws Exception {\n    \tif (fromFile) {\n    \t\tin = new BufferedReader(new FileReader(filename+\".in\"));\n        \tout = new PrintWriter(new FileWriter(filename+\".out\"));\n    \t} else {\n    \t\tin = new BufferedReader(new InputStreamReader(System.in));\n        \tout = new PrintWriter(System.out);\n    \t}\n        sc = new FastScanner(in);\n    }\n}\n\nclass FastScanner {\n    \n    BufferedReader reader;\n    StringTokenizer strTok;\n    \n    public FastScanner(BufferedReader reader) {\n        this.reader = reader;\n    }\n    \n    public String nextToken() throws IOException {\n        while (strTok == null || !strTok.hasMoreTokens()) {\n            strTok = new StringTokenizer(reader.readLine());\n        }\n        \n        return strTok.nextToken();\n    }\n    \n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    \n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    \n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    \n    public BigInteger nextBigInteger() throws IOException {\n    \treturn new BigInteger(nextToken());\n    }\n    \n    public BigDecimal nextBigDecimal() throws IOException {\n    \treturn new BigDecimal(nextToken());\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict \n \ndef Root(child):\n    while(Parent[child]!=child):\n        child = Parent[child]\n    return child\n \ndef Union(a,b):\n    root_a = Root(a)\n    root_b = Root(b)\n    \n    if(root_a!=root_b):\n        if(Size[root_a]<Size[root_b]):\n            Parent[root_a] = root_b\n            Size[root_b]+=Size[root_a]\n        else:\n            Parent[root_b] = root_a\n            Size[root_a]+=Size[root_b]\n        return 1\n    \n    return 0\n \nn = int(input())\nParent = [i for i in range(n)]\nSize   = [1 for i in range(n)]\n \nk = int(input())\nfor i in range(k):\n    u,v = map(int,input().split())\n    u-=1;v-=1\n    Union(u,v)\n \nm = int(input())\nfor i in range(m):\n    u,v = map(int,input().split())\n    root_u = Root(u-1)\n    root_v = Root(v-1)\n    \n    if(root_u==root_v):\n        Size[root_u] = 0\n \n \nMax  = -float('inf')\nfor i in range(n):\n   Max = max(Max,Size[Root(i)]) \nprint(Max)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dsu {\n  vector<int> p, siz;\n  int get(int x) {\n    if (p[x] == x) return x;\n    return p[x] = get(p[x]);\n  }\n  bool same(int x, int y) {\n    x = get(x), y = get(y);\n    return x == y;\n  }\n  void unite(int x, int y) {\n    x = get(x), y = get(y);\n    if (x == y) return;\n    if (siz[x] < siz[y]) swap(x, y);\n    p[y] = x;\n    siz[x] += siz[y];\n  }\n  dsu(int n) {\n    siz.resize(n, 1);\n    p.resize(n);\n    for (int i = 0; i < n; i++) p[i] = i;\n  }\n};\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  dsu d(n);\n  for (int i = 0; i < k; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    --y;\n    d.unite(x, y);\n  }\n  int m;\n  cin >> m;\n  vector<bool> bad(n);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    --y;\n    if (d.same(x, y)) {\n      bad[d.get(x)] = true;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (!bad[d.get(i)]) {\n      ans = max(ans, d.siz[d.get(i)]);\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dfs(vector<vector<pair<int, bool> > >& Graph, vector<int>& visited,\n        vector<bool>& is_enemy, int root, int idx, bool& is_valid) {\n  if (is_enemy[root]) is_valid = false;\n  visited[root] = idx;\n  int count = 1;\n  for (auto a : Graph[root])\n    if (!a.second && visited[a.first] != idx)\n      is_enemy[a.first] = true;\n    else if (!a.second && visited[a.first] == idx)\n      is_valid = false;\n    else if (a.second && visited[a.first] == -1) {\n      count += dfs(Graph, visited, is_enemy, a.first, idx, is_valid);\n    }\n  return count;\n}\nint main(void) {\n  int n, m, k;\n  cin >> n >> k;\n  vector<vector<pair<int, bool> > > Graph(n);\n  for (int i = 0; i < k; ++i) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    Graph[u].push_back(make_pair(v, 1));\n    Graph[v].push_back(make_pair(u, 1));\n  }\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    Graph[u].push_back(make_pair(v, 0));\n    Graph[v].push_back(make_pair(u, 0));\n  }\n  int result = 0;\n  vector<int> visited(n, -1);\n  for (int i = 0; i < n; ++i)\n    if (visited[i] == -1) {\n      vector<bool> is_enemy(n, false);\n      bool is_valid = true;\n      int tmp = dfs(Graph, visited, is_enemy, i, i, is_valid);\n      if (is_valid) result = max(result, tmp);\n    }\n  cout << result << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> g[2002];\nvector<bool> fr(2002);\nlong long dis = 0;\nvoid dfs(long long x) {\n  fr[x] = true;\n  for (auto i : g[x]) {\n    if (!fr[i]) ++dis, dfs(i);\n  }\n}\nint32_t main() {\n  long long n, k, m;\n  cin >> n >> k;\n  unordered_map<long long, long long> mp;\n  for (long long i = 1; i <= n; ++i) fr[i] = false;\n  while (k--) {\n    long long a, b;\n    cin >> a >> b;\n    g[a].push_back(b), g[b].push_back(a);\n  }\n  cin >> m;\n  while (m--) {\n    long long a, b;\n    cin >> a >> b;\n    mp[a] = b, mp[b] = a;\n  }\n  bool flag = false, check = false;\n  long long c = 0, ans = 0;\n  for (long long i = 1; i <= n; ++i) {\n    dis = 0, c = 0;\n    if (!fr[i]) {\n      dfs(i);\n      if (dis == 0) ans = max(ans, dis), check = true;\n      if (ans < dis) {\n        for (long long i = 1; i <= n; ++i) {\n          if (fr[i] && mp[i] > 0 && fr[mp[i]]) {\n            flag = true;\n            break;\n          }\n        }\n        if (!flag) ans = max(ans, dis), check = true;\n      }\n    }\n    for (long long i = 1; i <= n; ++i) fr[i] = false;\n  }\n  if (check) ++ans;\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import setrecursionlimit\n\nsetrecursionlimit(10 ** 9)\n\ndef dfs(g, col, st):\n    global used\n    used[st] = col\n    for w in g[st]:\n        if used[w] is False:\n            dfs(g, col, w)\n\n\nn = int(input())\nk = int(input())\n\ng = []\n\nused = [False] * n\n\nfor i in range(n):\n    g.append([])\nfor i in range(k):\n    x, y = map(int, input().split())\n    g[x - 1].append(y - 1)\n    g[y - 1].append(x - 1)\ncur = 0\nfor i in range(n):\n    if used[i] is False:\n        dfs(g, cur, i)\n        cur += 1\nk = int(input())\nlst = [0] * n\nfor i in range(k):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    if used[x] == used[y]:\n        lst[used[x]] = -1\n\nfor i in range(n):\n    if lst[used[i]] != -1:\n        lst[used[i]] += 1\n\nprint(max(0, max(lst)))\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k;\n  cin >> n >> k;\n  list<int> friends[n + 1];\n  int temp1, temp2;\n  for (int i = 0; i < k; i++) {\n    cin >> temp1 >> temp2;\n    friends[temp1].push_back(temp2);\n    friends[temp2].push_back(temp1);\n  }\n  int m;\n  cin >> m;\n  vector<pair<int, int>> dislikes;\n  for (int i = 0; i < m; i++) {\n    cin >> temp1 >> temp2;\n    dislikes.push_back(pair<int, int>(temp1, temp2));\n  }\n  vector<int> seg_vect(n + 1, 0);\n  vector<bool> visited(n + 1, false);\n  vector<unordered_set<int>> segment_list;\n  unordered_set<int> segment;\n  stack<int> pending;\n  int work, count;\n  count = 0;\n  for (int i = 1; i <= n; i++) {\n    if (visited[i]) continue;\n    visited[i] = true;\n    pending.push(i);\n    while (!pending.empty()) {\n      work = pending.top();\n      pending.pop();\n      seg_vect[work] = count;\n      segment.insert(work);\n      for (auto neighbour : friends[work]) {\n        if (visited[neighbour]) continue;\n        visited[neighbour] = true;\n        pending.push(neighbour);\n      }\n    }\n    segment_list.push_back(segment);\n    segment = {};\n    count++;\n  }\n  unordered_set<int> not_allowed;\n  for (auto val : dislikes) {\n    if (seg_vect[val.first] == seg_vect[val.second]) {\n      not_allowed.insert(seg_vect[val.first]);\n    }\n  }\n  int greatest = 0;\n  for (int i = 0; i < (int)segment_list.size(); i++) {\n    if (not_allowed.count(i)) continue;\n    greatest = max(greatest, (int)segment_list[i].size());\n  }\n  cout << greatest;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> adj[1000], Color(1000);\nint mp[50][50];\nint grid[1000][1000];\nvoid BFS(int source);\nint mx;\nint main() {\n  int i, u, v, nodes, edges, source, j;\n  scanf(\"%d %d\", &nodes, &edges);\n  for (i = 0; i < nodes; i++) {\n    adj[i].clear();\n  }\n  for (i = 0; i < nodes; i++)\n    for (j = 0; j < nodes; j++) grid[i][j] = 0;\n  for (i = 0; i < edges; i++) {\n    scanf(\"%d %d\", &u, &v);\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  int dis;\n  scanf(\"%d\", &dis);\n  for (i = 1; i <= dis; i++) {\n    scanf(\"%d %d\", &u, &v);\n    grid[u][v] = 1;\n    grid[v][u] = 1;\n  }\n  for (i = 0; i <= nodes; i++) {\n    Color[i] = 0;\n  }\n  mx = 0;\n  for (i = 1; i <= nodes; i++)\n    if (Color[i] == 0) BFS(i);\n  cout << mx << endl;\n  return 0;\n}\nvoid BFS(int source) {\n  queue<int> Q;\n  int i, u, v, cnt = 0, trk = 0, k = 0;\n  Color[source] = 1;\n  Q.push(source);\n  cnt++;\n  int V[105];\n  V[0] = source;\n  k = 1;\n  while (!Q.empty()) {\n    u = Q.front();\n    Q.pop();\n    for (i = 0; i < adj[u].size(); i++) {\n      v = adj[u][i];\n      if (Color[v] == 0) {\n        V[k++] = v;\n        cnt++;\n        Color[v] = 1;\n        Q.push(v);\n      }\n    }\n  }\n  for (i = 0; i < k; i++)\n    for (int j = i + 1; j < k; j++)\n      if (grid[V[i]][V[j]] == 1 && grid[V[j]][V[i]] == 1) {\n        trk = 1;\n        goto ab;\n      }\nab:;\n  if (trk == 0) mx = max(mx, cnt);\n  while (!Q.empty()) Q.pop();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Head>\nvoid print(Head&& head) {\n  cout << head << '\\n';\n}\ntemplate <typename Head, typename... Tail>\nvoid print(Head&& head, Tail... tail) {\n  cout << head << \" \";\n  print(tail...);\n}\nvoid chandan1() {\n  int y = 1;\n  return;\n}\nvoid chandan2() {\n  for (int i = 0; i < 10; i++) {\n    int x = 1;\n  }\n  return (chandan1());\n}\nstruct DSU {\n  static const int MAXN = 100005;\n  int parent[MAXN];\n  int size[MAXN];\n  bool enemie[200005];\n  void init() {\n    for (int i = 0; i < MAXN; i++) {\n      parent[i] = i;\n      size[i] = 1;\n      enemie[i] = 0;\n    }\n  }\n  int root(int i) {\n    while (parent[i] != i) {\n      parent[i] = parent[parent[i]];\n      i = parent[i];\n    }\n    return i;\n  }\n  void Union(int a, int b) {\n    int root_a = root(a);\n    int root_b = root(b);\n    if (root_a == root_b) return;\n    if (size[root_a] < size[root_b]) {\n      parent[root_a] = parent[root_b];\n      size[root_b] += size[root_a];\n    } else {\n      parent[root_b] = parent[root_a];\n      size[root_a] += size[root_b];\n    }\n  }\n  bool find(int a, int b) { return (a == b or root(a) == root(b)); }\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  chandan2();\n  while (t--) {\n    int n, m, q, k;\n    cin >> n >> k;\n    DSU uf;\n    uf.init();\n    for (int i = 0; i < k; i++) {\n      int x, y;\n      cin >> x >> y;\n      uf.Union(x, y);\n    }\n    cin >> m;\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      if (uf.find(x, y)) uf.enemie[uf.root(x)] = 1;\n    }\n    int maxi = -1;\n    for (int i = 1; i <= n; i++)\n      if (uf.enemie[uf.root(i)] == 0) maxi = max(maxi, uf.size[uf.root(i)]);\n    if (maxi == -1)\n      print(0);\n    else\n      print(maxi);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a, b, c, d, e, f, m, x, y;\nvector<int> v[2100], v2[2100];\nint tanda[2100];\nbool bole;\nvoid cari(int x) {\n  int i;\n  if (tanda[x] == 3) bole = 1;\n  tanda[x] = 2;\n  for (i = 0; i < v2[x].size(); i++)\n    if (tanda[v2[x][i]] == 2)\n      bole = 1;\n    else\n      tanda[v2[x][i]] = 3;\n  for (i = 0; i < v[x].size(); i++)\n    if (tanda[v[x][i]] != 2) cari(v[x][i]);\n}\nint main() {\n  scanf(\"%d\", &a);\n  scanf(\"%d\", &b);\n  m = 0;\n  memset(tanda, 0, sizeof(tanda));\n  for (c = 1; c <= b; c++) {\n    scanf(\"%d %d\", &x, &y);\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  scanf(\"%d\", &d);\n  for (c = 1; c <= d; c++) {\n    scanf(\"%d %d\", &x, &y);\n    v2[x].push_back(y);\n    v2[y].push_back(x);\n  }\n  for (c = 1; c <= a; c++) {\n    bole = 0;\n    if (tanda[c] == 0) cari(c);\n    if (bole == 0) {\n      f = 0;\n      for (e = 1; e <= a; e++)\n        if (tanda[e] == 2) {\n          f++;\n          tanda[e] = 1;\n        } else if (tanda[e] == 3)\n          tanda[e] = 0;\n      m = max(m, f);\n    } else {\n      for (e = 1; e <= a; e++)\n        if (tanda[e] == 2) {\n          tanda[e] = 1;\n        } else if (tanda[e] == 3)\n          tanda[e] = 0;\n    }\n  }\n  printf(\"%d\\n\", m);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e3 + 4;\nvector<vector<int> > G(N);\nvector<int> par(N);\nvector<bool> vis(N);\nmap<int, int> MP;\nint cnt;\nvoid dfs(int root, int u) {\n  vis[root] = true;\n  cnt++;\n  par[root] = u;\n  for (int i = 0; i < G[root].size(); i++) {\n    int v = G[root][i];\n    if (!vis[v]) dfs(v, u);\n  }\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) par[i] = i;\n  for (int i = 1; i <= k; i++) {\n    int a, b;\n    cin >> a >> b;\n    G[a].push_back(b), G[b].push_back(a);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      cnt = 0;\n      dfs(i, i);\n      MP[i] = cnt;\n    }\n  }\n  int m;\n  cin >> m;\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    cin >> u >> v;\n    if (par[u] == par[v]) MP[par[u]] = 0;\n  }\n  int mx = 0;\n  map<int, int>::iterator it;\n  for (it = MP.begin(); it != MP.end(); it++) mx = max(mx, it->second);\n  cout << mx << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package abbyy2.easy;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class C {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint K = ni();\n\t\tint[][] f = new int[K][2];\n\t\tfor(int i = 0;i < K;i++){\n\t\t\tf[i][0] = ni()-1;\n\t\t\tf[i][1] = ni()-1;\n\t\t}\n\t\tint m = ni();\n\t\tint[][] u = new int[m][2];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tu[i][0] = ni()-1;\n\t\t\tu[i][1] = ni()-1;\n\t\t}\n\t\t\n\t\tDJSet ds = new DJSet(n);\n\t\tfor(int i = 0;i < K;i++){\n\t\t\tds.union(f[i][0], f[i][1]);\n\t\t}\n\t\t\n\t\tboolean[] dead = new boolean[n];\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(ds.equiv(u[j][0], u[j][1])){\n\t\t\t\tdead[ds.root(u[j][0])] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint max = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(ds.upper[i] < 0 && !dead[i]){\n\t\t\t\tmax = Math.max(max, -ds.upper[i]);\n\t\t\t}\n\t\t}\n\t\tout.println(max);\n\t}\n\t\n\tpublic static class DJSet { public int[] upper; public DJSet(int n){ upper = new int[n]; Arrays.fill(upper, -1);} public int root(int x){\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));}\tpublic boolean equiv(int x, int y){ return root(x) == root(y);} public void union(int x, int y){ x = root(x);y = root(y);if(x != y) { if(upper[y] < upper[x]) { int d = x; x = y; y = d;\t} upper[x] += upper[y]; upper[y] = x;}} public int count(){\tint ct = 0;\tfor(int i = 0;i < upper.length;i++){ if(upper[i] < 0)ct++; } return ct; }}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew C().run();\n\t}\n\t\n\tpublic int ni()\n\t{\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic long nl()\n\t{\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic String ns()\n\t{\n\t\ttry{\n\t\t\tint b = 0;\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile((b = is.read()) != -1 && (b == '\\r' || b == '\\n' || b == ' '));\n\t\t\tif(b == -1)return \"\";\n\t\t\tsb.append((char)b);\n\t\t\twhile(true){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1)return sb.toString();\n\t\t\t\tif(b == '\\r' || b == '\\n' || b == ' ')return sb.toString();\n\t\t\t\tsb.append((char)b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\tpublic char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\ttry{\n\t\t\tint b = 0, p = 0;\n\t\t\twhile((b = is.read()) != -1 && (b == ' ' || b == '\\r' || b == '\\n'));\n\t\t\tif(b == -1)return null;\n\t\t\tbuf[p++] = (char)b;\n\t\t\twhile(p < n){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1 || b == ' ' || b == '\\r' || b == '\\n')break;\n\t\t\t\tbuf[p++] = (char)b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t\n\tdouble nd() { return Double.parseDouble(ns()); }\n\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tvoid tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long ans, b[2001], s;\nvector<int> f[2001], e[2001];\nvoid dfs(int x) {\n  b[x] = 1;\n  s++;\n  for (long long i = 0; i < f[x].size(); i++)\n    if (!b[f[x][i]]) dfs(f[x][i]);\n  for (int j = 0; j < e[x].size() && s >= 0; j++)\n    if (b[e[x][j]]) s = -1e9;\n}\nint main() {\n  long long n, m, x, y, k;\n  cin >> n >> k;\n  for (long long i = 0; i < k; i++) {\n    cin >> x >> y;\n    f[x].push_back(y);\n    f[y].push_back(x);\n  }\n  cin >> m;\n  for (long long i = 0; i < m; i++) {\n    cin >> x >> y;\n    e[x].push_back(y);\n    e[y].push_back(x);\n  }\n  for (long long i = 1; i <= n; i++) {\n    s = 0;\n    dfs(i);\n    ans = max(s, ans);\n    memset(b, 0, sizeof(b));\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid dfs(int x, vector<vector<int> > adj, vector<vector<int> >& group, int c,\n         vector<int>& id, vector<bool>& vis) {\n  vis[x] = 1;\n  group[c].push_back(x);\n  id[x] = c;\n  for (int i = 0; i < adj[x].size(); i++) {\n    if (vis[adj[x][i]] == 0) {\n      dfs(adj[x][i], adj, group, c, id, vis);\n    }\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  int k;\n  cin >> k;\n  int i, j;\n  vector<vector<int> > adj(n + 1);\n  vector<bool> vis(n + 1, 0);\n  while (k--) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  vector<vector<int> > group(n + 1);\n  vector<int> id(n + 1);\n  int c = 0;\n  for (i = 1; i <= n; i = i + 1) {\n    if (vis[i] == 0) {\n      dfs(i, adj, group, c, id, vis);\n      c++;\n    }\n  }\n  int m;\n  cin >> m;\n  vector<bool> black(n, 0);\n  while (m--) {\n    int u, v;\n    cin >> u >> v;\n    if (id[u] == id[v]) {\n      black[id[u]] = 1;\n    }\n  }\n  int res = 0;\n  for (i = 0; i < c; i++) {\n    if (black[i] == 0) {\n      int x = group[i].size();\n      res = max(res, x);\n    }\n  }\n  cout << res << endl;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nimport heapq\nimport bisect\nimport math\n\nINF = 10**9+7\nOFFLINE = 0\nN = 101010\nsys.setrecursionlimit(INF)\n\ndef fi():\n\treturn int(sys.stdin.readline())\n\ndef fi2():\n\treturn map(int, sys.stdin.readline().split())\n\ndef fi3():\n\treturn sys.stdin.readline().rstrip()\n\ndef fo(*args):\n\tfor s in args:\n\t\tsys.stdout.write(str(s)+\" \")\n\tsys.stdout.write(\"\\n\")\n\n##\nif OFFLINE:\n\tsys.stdin = open(\"fin.txt\", \"r\")\n\tsys.stdout = open(\"fout.txt\", \"w\")\n##\n\ndef root(x):\n\n\twhile parent[x] != x:\n\t\tparent[x] = parent[parent[parent[parent[x]]]]\n\t\tx = parent[x]\n\n\treturn x\n\ndef union(x, y):\n\n\tpx = root(x)\n\tpy = root(y)\n\n\tif px == py:\n\t\treturn\n\n\tparent[px] = py\n\tsize[py] += size[px]\n\troots.remove(px)\n\tenemy[py] = enemy[py].union(enemy[px])\n\n\n##main\n\nn = fi()\n\nparent = [i for i in range(n+1)]\nsize = [1 for i in range(n+1)]\nroots = set([i+1 for i in range(n)])\n\nE = []\nenemy = [set() for i in range(n+1)] \n\nk = fi()\n\nfor i in range(k):\n\tu, v = fi2()\n\tunion(u, v)\n\n\nm = fi()\n\nfor i in range(m):\n\tu, v = fi2()\n\n\tif root(u) == root(v):\n\t\tif root(u) in roots:\n\t\t\troots.remove(root(u))\n\n\nans = 0\n\nfor r in roots:\n\tans = max(ans, size[r])\n\nfo(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std::chrono;\nlong long mod = 1000000007;\nstruct modified_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  long long operator()(uint64_t x) const {\n    static const uint64_t random =\n        steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + random);\n  }\n};\nlong long N;\nvector<long long> grph[2001];\nvector<long long> dis[2001];\nset<long long> st;\nbool vis[2001];\nlong long ans = 0;\nbool flag = true;\nvector<long long> vp;\nvoid dfs(long long i, long long p1) {\n  vis[i] = true;\n  st.insert(i);\n  for (auto x : grph[i]) {\n    if (!vis[x]) {\n      dfs(x, i);\n    }\n  }\n}\nvoid solve() {\n  long long a, b, k, c, n, d, m, x, y, l, r;\n  cin >> n >> m;\n  memset(vis, false, sizeof(vis));\n  for (long long i = 0; i < m; i++) {\n    cin >> a >> b;\n    grph[a].push_back(b);\n    grph[b].push_back(a);\n  }\n  cin >> k;\n  for (long long i = 0; i < k; i++) {\n    cin >> a >> b;\n    dis[a].push_back(b);\n    dis[b].push_back(a);\n  }\n  long long ans1 = 0;\n  for (long long i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      flag = true;\n      ans = 0;\n      st.clear();\n      dfs(i, -1LL);\n      for (auto p : st) {\n        for (auto p1 : dis[p]) {\n          if (st.find(p1) != st.end()) {\n            flag = false;\n          }\n        }\n      }\n      if (flag) {\n        long long fm = st.size();\n        ans1 = max(ans1, fm);\n      }\n    }\n  }\n  cout << ans1 << \"\\n\";\n  return;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long a, b, c, n, tt, d, m, k, x, y;\n  tt = 1;\n  while (tt--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\n\n/*\n *\t\n *\tC.java\n *\tWritten by Andy Huang: 12:43:35 PM Apr 21, 2012\n */\npublic class C {\n\tstatic byte graph[][];\n\tstatic boolean moi[];\n\tstatic int ppl[];\n\tstatic int cnt;\n\t\n\tstatic void solve() {\n\t\tint n = in.nInt();\n\t\tint k = in.nInt();\n\t\tgraph = new byte[n][n];\n\t\tmoi = new boolean[n];\n\t\tppl = new int[n];\n\t\twhile(k-- > 0){\n\t\t\tint a = in.nInt() - 1;\n\t\t\tint b = in.nInt() - 1;\n\t\t\tgraph[a][b] = 1;\n\t\t\tgraph[b][a] = 1;\n\t\t}\n\t\tint m = in.nInt();\n\t\twhile(m -- > 0){\n\t\t\tint a = in.nInt() - 1;\n\t\t\tint b = in.nInt() - 1;\n\t\t\tgraph[a][b] = -1;\n\t\t\tgraph[b][a] = -1;\n\t\t}\n//\t\tint mask = 1 << n;\n//\t\tint ppl[] = new int[n];\n//\t\tint ans = 0;\n//\t\twhile(mask > 0){\n//\t\t\tint len = 0;\n//\t\t\tfor(int i = 0; i < n ; i++){\n//\t\t\t\tif ((1 << i & mask) >= 1){\n//\t\t\t\t\tppl[len++] = i;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tboolean val = true;\n//\t\t\tArrays.fill(moi, false);\n//\t\t\tcnt = 0;\n//\t\t\tdfs(ppl[0]);\n//\t\t\tif (cnt != len)\n//\t\t\t\tval = false;\n//\t\t\tfor(int i = 0; i < len && val; i++){\n//\t\t\t\tif (!moi[ppl[i]]){\n//\t\t\t\t\tval = false;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t\tfor(int j = i+1; j < len; j++){\n//\t\t\t\t\tif (graph[ppl[i]][ppl[j]] == -1){\n//\t\t\t\t\t\tval = false;\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tif(val && len > ans)\n//\t\t\t\tans = len;\n//\t\t\tmask--;\n//\t\t}\n//\t\tout.appendln(ans);\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(moi[i])\n\t\t\t\tcontinue;\n\t\t\tcnt = 0;\n\t\t\tdfs(i);\n\t\t\tboolean val = true;\n\t\t\tfor(int j = 0; j < cnt && val; j++){\n\t\t\t\tfor(int l = j + 1; l < cnt; l++){\n\t\t\t\t\tif(graph[ppl[j]][ppl[l]] == -1){\n\t\t\t\t\t\tval = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tif (val){\n//\t\t\t\tpln(Arrays.toString(Arrays.copyOf(ppl,cnt)));\n//\t\t\t}\n\t\t\tif(val && cnt > ans)\n\t\t\t\tans = cnt;\n\t\t}\n\t\tout.appendln(ans);\n\t}\n\t\n\tstatic void dfs(int cur){\n\t\tmoi[cur] = true;\n\t\tppl[cnt++] = cur;\n\t\tfor(int i = 0; i < graph[cur].length; i++){\n\t\t\tif(!moi[i] && graph[cur][i] == 1)\n\t\t\t\tdfs(i);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tin = new Input();\n\t\tout = new Output();\n\t\tsolve();\n\t\tout.print();\n\t}\n\n\tstatic Output out;\n\tstatic Input in;\n\n\tstatic void pln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tstatic void pf(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\n\n}\n\nfinal class Input {\n\tprivate java.io.BufferedReader reader;\n\tprivate java.util.StringTokenizer tokenizer;\n\n\tpublic Input() {\n\t\treader = new java.io.BufferedReader(new java.io.InputStreamReader(System.in));\n\t\ttokenizer = null;\n\t}\n\n\tpublic String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new java.util.StringTokenizer(reader.readLine());\n\t\t\t}\n\t\t\tcatch (java.io.IOException e) {\n\t\t\t\tthrow new RuntimeException(\"I/O Error\");\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic String nLine() {\n\t\ttry {\n\t\t\treturn reader.readLine();\n\t\t}\n\t\tcatch (java.io.IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic long nLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic int nInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic double nDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n}\n\nfinal class Output {\n\tpublic StringBuilder buffer;\n\n\tOutput() {\n\t\tbuffer = new StringBuilder();\n\t}\n\n\tOutput(int size) {\n\t\tbuffer = new StringBuilder(size);\n\t}\n\n\tvoid print() {\n\t\tSystem.out.print(buffer.toString());\n\t}\n\n\tvoid flush() {\n\t\tSystem.out.flush();\n\t}\n\n\t<T> void append(T obj) {\n\t\tbuffer.append(obj);\n\t}\n\n\t<T> void appendln(T obj) {\n\t\tappend(obj);\n\t\tappend('\\n');\n\t}\n\n\tvoid delete(int index) {\n\t\tbuffer.deleteCharAt(index);\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    StringTokenizer str = null;\n    BufferedReader in;\n    PrintWriter out;\n\n    void run() throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n        solve();\n        out.flush();\n        out.close();\n    }\n\n    String nextString() throws IOException {\n        return in.readLine();\n    }\n\n    String nextToken() throws IOException {\n        if (str == null || !str.hasMoreElements()) {\n            str = new StringTokenizer(nextString());\n        }\n        return str.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    class Point implements Comparable<Point> {\n        int x;\n        int y;\n\n        @Override\n        public int compareTo(Point p) {\n            if (p.x > x)\n                return -1;\n            if (p.x < x)\n                return 1;\n            if (p.y > y)\n                return -1;\n            if (p.y < y)\n                return 1;\n            return 0;\n        }\n    }\n\n    private double Rastoyanie(Point p[], int i, int l) {\n        int xx = p[i].x - p[l].x;\n        int yy = p[i].y - p[l].y;\n        xx = xx * xx;\n        yy = yy * yy;\n        return Math.sqrt(xx + yy);\n    }\n\n    private boolean Na_odnoy_pramoy(Point p[], int i, int j, int l) {\n        return (p[i].y - p[j].y) * p[l].x + (p[j].x - p[i].x) * p[l].y\n                + (p[i].x * p[j].y - p[j].x * p[i].y) == 0;\n    }\n\n    boolean isPrime(long p) {\n        int t = (int) (Math.sqrt(p) + 1);\n        for (int i = 2; i < t; i++) {\n            if (p % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    void solve() throws IOException {\n        int n = nextInt();\n        List<List<Integer>> g = new ArrayList<List<Integer>>(n);\n        for (int i = 0; i < n; i++) {\n            g.add(new ArrayList<Integer>());\n        }\n\n        int k = nextInt();\n        for (int i = 0; i < k; i++) {\n            int x = nextInt() - 1;\n            int y = nextInt() - 1;\n            g.get(x).add(y);\n            g.get(y).add(x);\n        }\n\n        List<List<Integer>> f = new ArrayList<List<Integer>>(n);\n        for (int i = 0; i < n; i++) {\n            f.add(new ArrayList<Integer>());\n        }\n        int m = nextInt();\n        for (int i = 0; i < m; i++) {\n            int x = nextInt() - 1;\n            int y = nextInt() - 1;\n            f.get(x).add(y);\n            f.get(y).add(x);\n        }\n\n        boolean a[] = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = false;\n        }\n        int p[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int t : g.get(i)) {\n                union(p, i, t);\n            }\n        }\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i])\n                continue;\n            int r = root(p, i);\n            a[i] = true;\n            int b = 0;\n            if (C(f, p, r, n)) {\n                for (int x = 0; x < n; x++) {\n                    if (root(p, x) == r)\n                        b++;\n                }\n            }\n            if (b > h)\n                h = b;\n        }\n        // if (h == 0)\n        // h = 1;\n        out.println(h);\n    }\n\n    private boolean C(List<List<Integer>> f, int[] p, int r, int n) {\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = 0;\n        }\n        for (int x = 0; x < n; x++) {\n            if (root(p, x) == r)\n                a[x] = 1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (root(p, i) == r)\n                for (int t : f.get(i)) {\n                    if (root(p, t) == r) {\n                        return false;\n                    }\n                }\n        }\n        return true;\n    }\n\n    int root(int p[], int x) {\n        if (p[x] == x)\n            return x;\n        return p[x] = root(p, p[x]);\n    }\n\n    boolean isUnion(int p[], int x, int y) {\n        return root(p, x) == root(p, y);\n    }\n\n    Random rand = new Random();\n\n    void union(int p[], int x, int y) {\n        x = root(p, x);\n        y = root(p, y);\n        if (rand.nextBoolean()) {\n            p[x] = y;\n        } else {\n            p[y] = x;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.sql.Struct;\nimport java.util.*;\n\npublic class Main {\n    private static PrintWriter out;\n    static void dbg(Object... args) {\n        for (Object arg : args)\n            out.print(arg + \" \");\n        out.println();\n    }\n    static class DSU{\n        private int n;\n        private int[] path;\n        public DSU(int _n){\n            n = _n; path = new int[n+5];\n            for(int i = 0;i<=n;i++){\n                path[i] = i;\n            }\n        }\n        public int findUnion(int u){\n            if(path[u]==u) return u;\n            return path[u] = findUnion(path[u]);\n        }\n        public void mergeUnion(int x, int y){\n            path[findUnion(x)] = findUnion(y);\n        }\n        public boolean sameSet(int x, int y){\n            return findUnion(x)==findUnion(y);\n        }\n    }\n    public static void solve(int testCase, Reader in, PrintWriter out){\n        int n = in.nextInt();\n        int k = in.nextInt();\n        DSU dsu = new DSU(n);\n        while (k-->0){\n            int u = in.nextInt(), v =in.nextInt();\n            dsu.mergeUnion(u,v);\n        }\n        int m = in.nextInt();\n        Set<Integer> st = new HashSet<>();\n        while (m-->0){\n            int u = in.nextInt(), v = in.nextInt();\n            if(dsu.sameSet(u, v)) st.add(dsu.findUnion(u));\n        }\n        Map<Integer, Integer> mp = new HashMap<>();\n        for(int i =1;i<=n;i++){\n            int x = dsu.findUnion(i);\n            if(mp.containsKey(x)){\n                mp.put(x, mp.get(x)+1);\n            }else mp.put(x, 1);\n        }\n        int mx = 0;\n        for(Integer it:mp.keySet()){\n            if(st.contains(it)) continue;\n            mx = Math.max(mx, mp.get(it));\n        }\n        out.println(mx);\n    }\n\n    public static void main(String... args) {\n        Reader in = new Reader();\n        out = new PrintWriter(System.out);\n        int testCase = 1;\n        for(int i = 1;i<=testCase;i++){\n            solve(i, in, out);\n        }\n        out.flush();\n        out.close();\n    }\n\n    static class Reader {\n        private StringTokenizer tokenizer;\n        private BufferedReader reader;\n\n        public Reader() {\n            tokenizer = null;\n            try {\n                reader = new BufferedReader(new InputStreamReader(System.in)); // for file IO, replace this with new FileReader (\"in.txt\")\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() { return Integer.parseInt(this.next()); }\n        public long nextLong() { return Long.parseLong(this.next()); }\n        public double nextDouble() { return Double.parseDouble(this.next()); }\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return \"\";\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct djset {\n  int set_size;\n  djset *rep;\n};\ninline djset *create_set(int n) {\n  djset *node = (djset *)malloc(sizeof(djset));\n  node->set_size = 1;\n  node->rep = node;\n  return node;\n}\ndjset *find_set(djset *a) {\n  if (a->rep != a) {\n    a->rep = find_set(a->rep);\n  }\n  return a->rep;\n}\ninline void merge_sets(djset *a, djset *b) {\n  a = find_set(a);\n  b = find_set(b);\n  if (a == b) {\n    return;\n  }\n  if (a->set_size > b->set_size) {\n    b->rep = a;\n    a->set_size += b->set_size;\n    b->set_size = 0;\n  } else if (a->set_size < b->set_size) {\n    a->rep = b;\n    b->set_size += a->set_size;\n    a->set_size = 0;\n  } else {\n    b->rep = a;\n    a->set_size += b->set_size;\n    b->set_size = 0;\n  }\n}\nint main() {\n  int n, k, m, a, b;\n  int i, j;\n  scanf(\"%d\", &n);\n  djset **dja = (djset **)malloc((n + 1) * sizeof(djset *));\n  for (i = 1; i <= n; i++) {\n    dja[i] = create_set(i);\n  }\n  scanf(\"%d\", &k);\n  for (i = 1; i <= k; i++) {\n    scanf(\"%d%d\", &a, &b);\n    if (find_set(dja[a]) != find_set(dja[b])) {\n      merge_sets(dja[a], dja[b]);\n    }\n  }\n  scanf(\"%d\", &m);\n  for (i = 1; i <= m; i++) {\n    scanf(\"%d%d\", &a, &b);\n    if (find_set(dja[a]) == find_set(dja[b])) {\n      find_set(dja[a])->set_size = 0;\n      find_set(dja[b])->set_size = 0;\n    }\n  }\n  int max = 0;\n  for (i = 1; i <= n; i++) {\n    max = ((max) >= (dja[i]->set_size) ? (max) : (dja[i]->set_size));\n  }\n  printf(\"%d\\n\", max);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1E-9;\nvector<int> used;\nint ccolor = 1;\nlong long dfs(int u, vector<vector<int>>& g) {\n  long long ans = 0;\n  used[u] = ccolor;\n  for (int i = 1; i < g[u].size(); ++i) {\n    if (g[u][i] == -1 && used[i] == ccolor)\n      return 0;\n    else if (used[i] != ccolor && g[u][i] == 1) {\n      long long k = dfs(i, g);\n      if (k == 0) return 0;\n      ans += k;\n    }\n  }\n  return ans + 1;\n}\nint main(int argc, char** argv) {\n  ios::sync_with_stdio(false);\n  int n, k;\n  cin >> n >> k;\n  used.resize(n + 1);\n  vector<vector<int>> v(n + 1, vector<int>(n + 1));\n  for (int i = 0; i < k; ++i) {\n    int u, w;\n    cin >> u >> w;\n    v[u][w] = 1;\n    v[w][u] = 1;\n  }\n  cin >> k;\n  for (int i = 0; i < k; ++i) {\n    int u, w;\n    cin >> u >> w;\n    v[u][w] = -1;\n    v[w][u] = -1;\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    ans = std::max(ans, dfs(i, v));\n    ++ccolor;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint p[1000], sum[1000], good[1000], n, k, m, x, y;\nint find(int x) {\n  if (p[x] == x)\n    return x;\n  else\n    return p[x] = find(p[x]);\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) p[i] = i;\n  for (int i = 1; i <= k; i++) {\n    cin >> x >> y;\n    p[find(y)] = find(x);\n  }\n  cin >> m;\n  for (int i = 1; i <= m; i++) {\n    cin >> x >> y;\n    if (find(x) == find(y)) good[find(x)] = -1;\n  }\n  m = 0;\n  for (int i = 1; i <= n; i++) sum[find(i)]++;\n  for (int i = 1; i <= n; i++) {\n    x = find(i);\n    if (good[find(i)] == 0) m = max(m, sum[x]);\n  }\n  cout << m;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e3 + 10;\nint par[maxN];\nint h[maxN];\nint find_root(int x) {\n  if (x == par[x])\n    return x;\n  else\n    par[x] = find_root(par[x]);\n  return par[x];\n}\nvoid merge(int x, int y) {\n  x = find_root(x);\n  y = find_root(y);\n  if (h[x] == h[y]) {\n    par[y] = x;\n    h[x]++;\n  }\n  if (h[x] > h[y]) par[y] = x;\n  if (h[x] < h[y]) par[x] = y;\n}\nbool hate[maxN][maxN];\nvector<int> g[maxN];\nint main() {\n  ios_base::sync_with_stdio(false);\n  for (int i = 0; i < maxN; i++) par[i] = i;\n  int n, k, m;\n  cin >> n >> k;\n  for (int i = 0; i < k; i++) {\n    int v, u;\n    cin >> v >> u;\n    v--, u--;\n    if (find_root(v) != find_root(u)) merge(v, u);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int v, u;\n    cin >> v >> u;\n    v--, u--;\n    hate[v][u] = hate[u][v] = true;\n  }\n  for (int i = 0; i < n; i++) g[find_root(i)].push_back(i);\n  int mx = 0;\n  for (int i = 0; i < n; i++) {\n    vector<int> cur = g[i];\n    bool ok = 1;\n    for (int x = 0; x < cur.size(); x++) {\n      for (int y = 0; y < cur.size(); y++) ok &= !(hate[cur[x]][cur[y]]);\n    }\n    if (ok) mx = max(mx, (int)cur.size());\n  }\n  cout << mx << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nbool debug = false;\nint k;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nvector<int> mp[2005];\nint c[2005], col, cnt, cc[2005];\nvector<pair<int, int>> v;\nvoid dfs(int x) {\n  c[x] = col;\n  cnt++;\n  for (int child : mp[x])\n    if (!c[child]) dfs(child);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0, u, v; i < k; i++) {\n    scanf(\"%d%d\", &u, &v);\n    mp[u].push_back(v);\n    mp[v].push_back(u);\n  }\n  for (int i = 1; i <= n; i++)\n    if (!c[i]) {\n      col++;\n      cnt = 0;\n      dfs(i);\n      v.push_back({-cnt, col});\n    }\n  scanf(\"%d\", &m);\n  for (int i = 0, u, v; i < m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    if (c[u] == c[v]) cc[c[u]] = 1;\n  }\n  sort(v.begin(), v.end());\n  for (auto p : v)\n    if (!cc[p.second]) {\n      printf(\"%d\\n\", -p.first);\n      return 0;\n    }\n  puts(\"0\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint parent[2000];\nint Find(int x) {\n  if (parent[x] != x) parent[x] = Find(parent[x]);\n  return parent[x];\n}\nvoid Union(int x, int y) {\n  x = Find(x);\n  y = Find(y);\n  parent[x] = y;\n}\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; ++i) parent[i] = i;\n  for (int i = 0, u, v; i < m; ++i) {\n    scanf(\"%d %d\", &u, &v);\n    Union(u - 1, v - 1);\n  }\n  int sz[n];\n  memset(sz, 0, sizeof sz);\n  for (int i = 0; i < n; ++i) ++sz[Find(i)];\n  scanf(\"%d\", &m);\n  bool valid[n];\n  memset(valid, true, sizeof valid);\n  for (int i = 0, u, v; i < m; ++i) {\n    scanf(\"%d %d\", &u, &v);\n    --u;\n    --v;\n    u = Find(u);\n    v = Find(v);\n    if (u == v) valid[u] = false;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; ++i)\n    if (valid[i]) ans = max(ans, sz[i]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2002;\nint n, m, fa[maxn], num[maxn];\nbool ok[maxn];\nvoid make_set() {\n  for (int i = 1; i <= n; ++i) fa[i] = i, num[i] = 1, ok[i] = true;\n}\nint find(int x) {\n  if (fa[x] == x) return x;\n  fa[x] = find(fa[x]);\n  return fa[x];\n}\nvoid Union(int x, int y) {\n  int xx = find(x), yy = find(y);\n  if (xx == yy) return;\n  if (num[xx] > num[yy]) {\n    fa[yy] = xx;\n    num[xx] += num[yy];\n  } else {\n    fa[xx] = yy;\n    num[yy] += num[xx];\n  }\n}\nint main(void) {\n  while (~scanf(\"%d\", &n)) {\n    make_set();\n    scanf(\"%d\", &m);\n    int a, b;\n    for (int i = 0; i < m; ++i) {\n      scanf(\"%d%d\", &a, &b);\n      Union(a, b);\n    }\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; ++i) {\n      scanf(\"%d%d\", &a, &b);\n      int xx = find(a), yy = find(b);\n      if (xx == yy) ok[xx] = 0;\n    }\n    int maxx = 0;\n    for (int i = 1; i <= n; ++i) {\n      int tmp = find(i);\n      if (ok[tmp]) maxx = max(maxx, num[tmp]);\n    }\n    cout << maxx << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n    //<editor-fold desc=\"input parse\" defaultstate=\"collapsed\">\n\n    private static StringTokenizer st;\n    private static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n    private static long nextLong() {\n        return Long.parseLong(st.nextToken());\n    }\n\n    private static int nextInt() {\n        return Integer.parseInt(st.nextToken());\n    }\n\n    private static double nextDouble() {\n        return Double.parseDouble(st.nextToken());\n    }\n\n    private static short nextShort() {\n        return Short.parseShort(st.nextToken());\n    }\n\n    private static byte nextByte() {\n        return Byte.parseByte(st.nextToken());\n    }\n\n    private static void initTokenizer() throws Exception {\n        st = new StringTokenizer(reader.readLine());\n    }\n\n    //</editor-fold>\n\n    private static ArrayList<Integer>[] graph;\n\n    private static boolean[] used;\n\n    private static int[] traversal;\n    private static int trav_index;\n\n    private static ArrayList<Integer> component;\n\n    private static void dfs(int v) {\n        used[v] = true;\n\n        for (int child : graph[v]) {\n            if (!used[child]) {\n                dfs(child);\n            }\n        }\n\n        traversal[trav_index++] = v;\n    }\n\n    private static void tdfs(int v) {\n        used[v] = true;\n        component.add(v);\n\n        for (int child : graph[v]) {\n            if (!used[child]) {\n                tdfs(child);\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        initTokenizer();\n\n        int nodes = nextInt();\n\n        initTokenizer();\n        int edges = nextInt();\n\n        graph  = new ArrayList[nodes];\n\n        for (int i = 0; i < graph.length; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for (int edge = 0; edge < edges; edge++) {\n            initTokenizer();\n\n            int from = nextInt() - 1;\n            int to   = nextInt() - 1;\n\n            graph[from].add(to);\n            graph[to].add(from);\n        }\n\n        used        = new boolean   [nodes];\n        traversal   = new int       [nodes];\n\n        trav_index = 0;\n\n        for (int i = 0; i < used.length; i++) {\n            if (!used[i]) {\n                dfs(i);\n            }\n        }\n\n        Arrays.fill(used, false);\n\n        int[] comp = new int[nodes];\n        ArrayList<Integer> csize = new ArrayList<>();\n\n        component = new ArrayList<>();\n\n        int count = 0;\n\n        for (trav_index = traversal.length - 1; trav_index >= 0; trav_index--) {\n            if (!used[traversal[trav_index]]) {\n                tdfs(traversal[trav_index]);\n\n                for (int node : component) {\n                    comp[node] = count;\n                }\n\n                csize.add(component.size());\n                component.clear();\n\n                count++;\n            }\n        }\n\n        initTokenizer();\n\n        edges = nextInt();\n\n        boolean[] comps = new boolean[count];\n\n        for (int i = 0; i < edges; i++) {\n            initTokenizer();\n            int a = nextInt() - 1;\n            int b = nextInt() - 1;\n\n            if (comp[a] == comp[b]) {\n                comps[comp[a]] = true;\n            }\n        }\n\n        int best = 0;\n\n        for (int c = 0; c < count; c++) {\n            if (!comps[c]) {\n                best = Math.max(best, csize.get(c));\n            }\n        }\n\n        System.out.println(best);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\n\n/*\n *\t\n *\tC.java\n *\tWritten by Andy Huang: 12:43:35 PM Apr 21, 2012\n */\npublic class C {\n\tstatic byte graph[][];\n\tstatic boolean moi[];\n\tstatic int cnt;\n\t\n\tstatic void solve() {\n\t\tint n = in.nInt();\n\t\tint k = in.nInt();\n\t\tgraph = new byte[n][n];\n\t\tmoi = new boolean[n];\n\t\twhile(k-- > 0){\n\t\t\tint a = in.nInt() - 1;\n\t\t\tint b = in.nInt() - 1;\n\t\t\tgraph[a][b] = 1;\n\t\t\tgraph[b][a] = 1;\n\t\t}\n\t\tint m = in.nInt();\n\t\twhile(m -- > 0){\n\t\t\tint a = in.nInt() - 1;\n\t\t\tint b = in.nInt() - 1;\n\t\t\tgraph[a][b] = -1;\n\t\t\tgraph[b][a] = -1;\n\t\t}\n\t\tint mask = 1 << n;\n\t\tint ppl[] = new int[n];\n\t\tint ans = 0;\n\t\twhile(mask > 0){\n\t\t\tint len = 0;\n\t\t\tfor(int i = 0; i < n ; i++){\n\t\t\t\tif ((1 << i & mask) >= 1){\n\t\t\t\t\tppl[len++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean val = true;\n\t\t\tArrays.fill(moi, false);\n\t\t\tcnt = 0;\n\t\t\tdfs(ppl[0]);\n\t\t\tif (cnt != len)\n\t\t\t\tval = false;\n\t\t\tfor(int i = 0; i < len && val; i++){\n\t\t\t\tif (!moi[ppl[i]]){\n\t\t\t\t\tval = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j = i+1; j < len; j++){\n\t\t\t\t\tif (graph[ppl[i]][ppl[j]] == -1){\n\t\t\t\t\t\tval = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(val && len > ans)\n\t\t\t\tans = len;\n\t\t\tmask--;\n\t\t}\n\t\tout.appendln(ans);\n\t}\n\t\n\tstatic void dfs(int cur){\n\t\tmoi[cur] = true;\n\t\tcnt++;\n\t\tfor(int i = 0; i < graph[cur].length; i++){\n\t\t\tif(!moi[i] && graph[cur][i] == 1)\n\t\t\t\tdfs(i);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tin = new Input();\n\t\tout = new Output();\n\t\tsolve();\n\t\tout.print();\n\t}\n\n\tstatic Output out;\n\tstatic Input in;\n\n\tstatic void pln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tstatic void pf(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\n\n}\n\nfinal class Input {\n\tprivate java.io.BufferedReader reader;\n\tprivate java.util.StringTokenizer tokenizer;\n\n\tpublic Input() {\n\t\treader = new java.io.BufferedReader(new java.io.InputStreamReader(System.in));\n\t\ttokenizer = null;\n\t}\n\n\tpublic String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new java.util.StringTokenizer(reader.readLine());\n\t\t\t}\n\t\t\tcatch (java.io.IOException e) {\n\t\t\t\tthrow new RuntimeException(\"I/O Error\");\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic String nLine() {\n\t\ttry {\n\t\t\treturn reader.readLine();\n\t\t}\n\t\tcatch (java.io.IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic long nLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic int nInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic double nDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n}\n\nfinal class Output {\n\tpublic StringBuilder buffer;\n\n\tOutput() {\n\t\tbuffer = new StringBuilder();\n\t}\n\n\tOutput(int size) {\n\t\tbuffer = new StringBuilder(size);\n\t}\n\n\tvoid print() {\n\t\tSystem.out.print(buffer.toString());\n\t}\n\n\tvoid flush() {\n\t\tSystem.out.flush();\n\t}\n\n\t<T> void append(T obj) {\n\t\tbuffer.append(obj);\n\t}\n\n\t<T> void appendln(T obj) {\n\t\tappend(obj);\n\t\tappend('\\n');\n\t}\n\n\tvoid delete(int index) {\n\t\tbuffer.deleteCharAt(index);\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "//package albert.codeforces.party177c1;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int k = scan.nextInt();\n        int[] uf = new int[n];\n        for (int i = 0; i < uf.length; i++) {\n            uf[i] = i;\n        }\n        for (int i = 0; i < k; i++) {\n            int s = scan.nextInt() - 1;\n            int d = scan.nextInt() - 1;\n            int sP = parent(uf, s);\n            int sD = parent(uf, d);\n            uf[sP] = sD;\n        }\n        int m = scan.nextInt();\n        int[][] h = new int[m][];\n        for (int i = 0; i < m; i++) {\n            h[i] = new int[]{scan.nextInt() - 1, scan.nextInt() - 1};\n        }\n        Map<Integer, Set<Integer>> groups = new HashMap<>();\n        for (int i = 0; i < uf.length; i++) {\n            groups.computeIfAbsent(parent(uf, i), key -> new HashSet<>()).add(i);\n        }\n        int ans = 0;\n        for (Set<Integer> group : groups.values()) {\n            boolean no = false;\n            for (int[] i : h) {\n                if (group.contains(i[0]) && group.contains(i[1])) {\n                    no = true;\n                    break;\n                }\n            }\n            if (!no) {\n                ans = Math.max(ans, group.size());\n            }\n        }\n        System.out.println(ans);\n    }\n\n    private static Integer parent(int[] uf, int n) {\n        int p = n;\n        while (p != uf[p]) {\n            p = uf[p];\n        }\n        uf[n] = p;\n        return p;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2010;\nconst int M = 100010;\nbool f[N][N], z[N][N], used[N], can[N];\nint cnt, n;\nbool good = true;\nvoid dfs(int v) {\n  used[v] = true;\n  cnt++;\n  for (int i = 0; i < n; i++)\n    if (z[v][i]) can[i] = true;\n  bool all = true;\n  for (int j = 0; j < n; j++)\n    if (f[v][j]) {\n      if (used[j]) continue;\n      if (can[j])\n        all = false;\n      else\n        dfs(j);\n    }\n  if (!all) good = false;\n}\nint main() {\n  int m, k;\n  cin >> n >> k;\n  int a, b;\n  for (int i = 0; i < k; i++) {\n    cin >> a >> b;\n    a--, b--;\n    f[a][b] = f[b][a] = true;\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b;\n    a--, b--;\n    z[a][b] = z[b][a] = true;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    memset(used, false, n);\n    memset(can, false, n);\n    cnt = 0;\n    good = true;\n    dfs(i);\n    if (!good) cnt = 0;\n    ans = max(ans, cnt);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> likes[2001];\nvector<int> dislikes[2001];\nint visited[2001] = {0};\nvector<int> temp;\nvoid DFS(int s) {\n  int i;\n  visited[s] = 1;\n  temp.push_back(s);\n  for (i = 0; i < likes[s].size(); i++) {\n    if (visited[likes[s][i]] == 0) DFS(likes[s][i]);\n  }\n}\nint check() {\n  int i, j, flag = 0;\n  vector<int> c;\n  for (i = 0; i < temp.size(); i++) {\n    c = dislikes[temp[i]];\n    for (j = 0; j < c.size(); j++) {\n      if (find(temp.begin(), temp.end(), c[j]) != temp.end()) {\n        flag = 1;\n        break;\n      }\n    }\n    if (flag) break;\n  }\n  if (flag)\n    return 0;\n  else\n    return 1;\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  ;\n  int n, k, m, i, u, v, ans = 0;\n  cin >> n;\n  cin >> k;\n  for (i = 0; i < k; i++) {\n    cin >> u >> v;\n    likes[u].push_back(v);\n    likes[v].push_back(u);\n  }\n  cin >> m;\n  for (i = 0; i < m; i++) {\n    cin >> u >> v;\n    dislikes[u].push_back(v);\n    dislikes[v].push_back(u);\n  }\n  for (i = 1; i <= n; i++) {\n    if (visited[i] == 0) {\n      DFS(i);\n      if (check()) {\n        k = temp.size();\n        ans = max(ans, k);\n      }\n      temp.clear();\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.StreamTokenizer;\nimport java.io.Writer;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n/**\n * Date     : 21.04.2012\n * Time     : 16:48:27\n * Email    : denys.astanin@gmail.com\n */\n\npublic class e_d {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew e_d().run();\n\t}\n\n\tint nextInt() throws IOException {\n\t\tin.nextToken();\n\t\treturn (int) in.nval;\n\t}\n\n\tString nextString() throws IOException {\n\t\tin.nextToken();\n\t\treturn (String) in.sval;\n\t}\n\n\tStreamTokenizer in;\n\tWriter writer;\n\tReader reader;\n\tprivate int count = 0;\n\tvoid run() throws IOException {\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\treader = oj ? new InputStreamReader(System.in, \"ISO-8859-1\")\n\t\t\t\t: new FileReader(\"input/ie_d.txt\");\n\t\twriter = new OutputStreamWriter(System.out, \"ISO-8859-1\");\n\t\tin = new StreamTokenizer(new BufferedReader(reader));\n\t\tPrintWriter out = new PrintWriter(writer);\n\t\tcount = nextInt();\n\t\tint fpairs = nextInt();\n\t\tMap<Integer, Set<Integer>> friend = new HashMap<Integer, Set<Integer>>();\n\t\tMap<Integer, Set<Integer>> readyChains = new HashMap<Integer, Set<Integer>>();\n\t\tfor (int i = 0; i < fpairs; i++) {\n\t\t\tint first = nextInt();\n\t\t\tint second = nextInt();\n\t\t\tSet<Integer> lst = friend.get(first);\n\t\t\tSet<Integer> lst2 = friend.get(second);\n\t\t\tif (lst == null) {\n\t\t\t\tlst = new HashSet<Integer>();\n\t\t\t\tfriend.put(first, lst);\n\t\t\t}\n\t\t\tif (lst2 == null) {\n\t\t\t\tlst2 = new HashSet<Integer>();\n\t\t\t\tfriend.put(second, lst2);\n\t\t\t}\n\t\t\tlst.add(second);\n\t\t\tlst2.add(first);\n\t\t}\n\t\tint epairs = nextInt();\n\t\tMap<Integer, Set<Integer>> enemy = new HashMap<Integer, Set<Integer>>();\n\t\tfor (int i = 0; i < epairs; i++) {\n\t\t\tint first = nextInt();\n\t\t\tint second = nextInt();\n\t\t\tSet<Integer> lst = enemy.get(first);\n\t\t\tSet<Integer> lst2 = enemy.get(second);\n\t\t\tif (lst == null) {\n\t\t\t\tlst = new HashSet<Integer>();\n\t\t\t\tenemy.put(first, lst);\n\t\t\t}\n\t\t\tif (lst2 == null) {\n\t\t\t\tlst2 = new HashSet<Integer>();\n\t\t\t\tenemy.put(second, lst2);\n\t\t\t}\n\t\t\tlst.add(second);\n\t\t\tlst2.add(first);\n\t\t}\n\t\tint max = 0;\n\t\tfor (int i = 1; i <= count; i++) {\n\t\t\tSet<Integer> friendChain = new HashSet<Integer>();\n\t\t\tif (!readyChains.containsKey(i)) {\n\t\t\t\tfriendChain.add(i);\n\t\t\t\tdfs(friend, friendChain, i);\n\t\t\t\tfor (Integer v : friendChain) {\n\t\t\t\t\treadyChains.put(v, friendChain);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfriendChain = readyChains.get(i);\n\t\t\t}\n\n\t\t\tboolean possible = true;\n\t\t\tcycle : for (Map.Entry<Integer, Set<Integer>> entry : enemy.entrySet()) {\n\t\t\t\tfor (Integer en : entry.getValue()) {\n\t\t\t\t\tif (friendChain.contains(en) \n\t\t\t\t\t\t\t&& friendChain.contains(entry.getKey())) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak cycle;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (possible) {\n\t\t\t\tmax = Math.max(max, friendChain.size());\n\t\t\t}\n\t\t}\n\t\tout.println(max);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\tvoid dfs(Map<Integer, Set<Integer>> friend, Set<Integer> friendChain, int from) {\n\t\tSet<Integer> lst = friend.get(from);\n\t\tif (lst != null) \n\t\t\tfor (Integer v : lst) {\n\t\t\t\tif (!friendChain.contains(v)) {\n\t\t\t\t\tfriendChain.add(v);\n\t\t\t\t\tdfs(friend, friendChain, v);\n\t\t\t\t}\n\t\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int maxn = 2e3 + 5;\nvector<long long int> parent(maxn), sz(maxn);\nvoid make_set(long long int v) {\n  parent[v] = v;\n  sz[v] = 1;\n}\nlong long int find_set(long long int v) {\n  if (v == parent[v]) return v;\n  return parent[v] = find_set(parent[v]);\n}\nvoid union_set(long long int u, long long int v) {\n  u = find_set(u);\n  v = find_set(v);\n  if (u != v) {\n    if (sz[u] < sz[v]) swap(u, v);\n    parent[v] = u;\n    sz[u] += sz[v];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int n, k, m, i;\n  cin >> n;\n  for (i = 0; i < n; i++) make_set(i + 1);\n  cin >> k;\n  for (i = 0; i < k; i++) {\n    long long int u, v;\n    cin >> u >> v;\n    union_set(u, v);\n  }\n  cin >> m;\n  vector<bool> vis(n + 1, true);\n  for (i = 0; i < m; i++) {\n    long long int u, v;\n    cin >> u >> v;\n    u = find_set(u);\n    v = find_set(v);\n    if (u == v) vis[u] = false;\n  }\n  long long int mx = 0;\n  for (i = 1; i <= n; i++) {\n    if (i == parent[i] && vis[i] == true) mx = max(mx, sz[i]);\n  }\n  cout << mx << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid DFS(int i, vector<bool> &visited, set<int> &group,\n         vector<vector<int> > &L) {\n  group.insert(i);\n  visited[i] = true;\n  for (vector<int>::iterator it = L[i].begin(); it != L[i].end(); ++it) {\n    if (!visited[*it]) {\n      DFS(*it, visited, group, L);\n    }\n  }\n}\nbool anyDislikes(set<int> &group, vector<vector<int> > &F) {\n  vector<int> G(group.begin(), group.end());\n  int size = G.size();\n  if (size == 0) return true;\n  for (int i = 0; i < size - 1; ++i)\n    for (int j = i + 1; j < size; ++j)\n      if (F[G[i]][G[j]] == 2) return true;\n  return false;\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<vector<int> > F(n + 1, vector<int>(n + 1, 0));\n  vector<vector<int> > L(n + 1, vector<int>());\n  vector<vector<int> > D(n + 1, vector<int>());\n  int l;\n  cin >> l;\n  for (int i = (0); i < (l); ++i) {\n    int a, b;\n    cin >> a >> b;\n    F[a][b] = 1;\n    F[b][a] = 1;\n    L[a].push_back(b);\n    L[b].push_back(a);\n  }\n  int d;\n  cin >> d;\n  for (int i = (0); i < (d); ++i) {\n    int a, b;\n    cin >> a >> b;\n    F[a][b] = 2;\n    F[b][a] = 2;\n    D[a].push_back(b);\n    D[b].push_back(a);\n  }\n  vector<bool> visited(n + 1, false);\n  int maxx = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (!visited[i]) {\n      set<int> group;\n      DFS(i, visited, group, L);\n      int size = group.size();\n      if (!anyDislikes(group, F)) {\n        maxx = max(maxx, size);\n      }\n    }\n  }\n  cout << maxx << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m, u, v;\nint p[2048];\nvoid init() {\n  for (int i = 0; i < 2048; i++) {\n    p[i] = i;\n  }\n}\nint find(int x) { return p[x] == x ? x : find(p[x]); }\nvoid merge(int u, int v) {\n  if (find(u) == find(v)) {\n    return;\n  }\n  p[find(u)] = find(v);\n}\nint main() {\n  cin >> n;\n  cin >> k;\n  init();\n  for (int i = 0; i < k; i++) {\n    cin >> u >> v;\n    u--;\n    v--;\n    merge(u, v);\n  }\n  cin >> m;\n  unordered_set<int> blacklist;\n  unordered_map<long long, long long> ct;\n  for (int i = 0; i < m; i++) {\n    cin >> u >> v;\n    u--;\n    v--;\n    if (find(u) == find(v)) {\n      blacklist.insert(find(u));\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    ct[find(i)]++;\n  }\n  long long ans = 0;\n  for (auto p : ct) {\n    if (blacklist.find(p.first) == blacklist.end()) {\n      ans = max(ans, p.second);\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class CF177C {\n\n    static List<Set<Integer>> groups = new ArrayList<>();\n    static List<Boolean> groupHasDislikes = new ArrayList<>();\n    static Map<Integer, Integer> groupOfPerson = new HashMap<>();\n\n    public static int getOrCreateGroupId(int person) {\n        Integer groupId = groupOfPerson.get(person);\n        if (groupId != null) {\n            return groupId;\n        }\n        int gid = groups.size();\n        Set<Integer> group = new TreeSet<>();\n        group.add(person);\n        groupOfPerson.put(person, gid);\n        groups.add(group);\n        groupHasDislikes.add(false);\n        return gid;\n    }\n\n    public static void joinGroups(int gi1, int gi2) {\n        Set<Integer> g1 = groups.get(gi1);\n        Set<Integer> g2 = groups.get(gi2);\n        g1.addAll(g2);\n        for (int p : g2) {\n            groupOfPerson.put(p, gi1);\n        }\n        g2.clear();\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br =\n                new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.valueOf(br.readLine());\n        for (int i = 1; i <= n; i++) {\n            groupOfPerson.put(i, getOrCreateGroupId(i));\n        }\n        int k = Integer.valueOf(br.readLine());\n        for (int i = 0; i < k; i++) {\n            String[] s = br.readLine().split(\" \");\n            int i1 = Integer.valueOf(s[0]), i2 = Integer.valueOf(s[1]);\n            int gi1 = getOrCreateGroupId(i1);\n            if (groups.get(gi1).contains(i2)) {\n                continue;\n            }\n            int gi2 = getOrCreateGroupId(i2);\n            if (groups.get(gi2).contains(i1)) {\n                continue;\n            }\n            joinGroups(gi1, gi2);\n        }\n        int m = Integer.valueOf(br.readLine());\n        for (int i = 0; i < m; i++) {\n            String[] s = br.readLine().split(\" \");\n            int i1 = Integer.valueOf(s[0]), i2 = Integer.valueOf(s[1]);\n            int gi1 = getOrCreateGroupId(i1);\n            if (!groupHasDislikes.get(gi1) && !groups.get(gi1).contains(i2)) {\n                continue;\n            }\n            groupHasDislikes.set(gi1, true);\n        }\n\n        int size = 0;\n        for (int i = 0; i < groups.size(); i++) {\n            if (groupHasDislikes.get(i)) {\n                continue;\n            }\n            int gs = groups.get(i).size();\n            if (gs > size) {\n                size = gs;\n            }\n        }\n        System.out.println(size);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nconst int N = 2003;\nvector<int> g[N];\nbool vis[N];\nvector<int> q;\nvoid dfs(int u) {\n  vis[u] = true;\n  q.push_back(u);\n  for (auto i : g[u]) {\n    if (!vis[i]) dfs(i);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m, a, b;\n  cin >> n;\n  cin >> m;\n  bool arr[n + 1][n + 1];\n  memset(arr, false, sizeof(arr));\n  for (int j = 0; j < m; ++j) {\n    cin >> a >> b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  cin >> m;\n  for (int j = 0; j < m; ++j) {\n    cin >> a >> b;\n    arr[a][b] = arr[b][a] = true;\n  }\n  int ans = 0;\n  int flag;\n  for (int i = 1; i <= n; ++i) {\n    if (!vis[i]) {\n      q.clear();\n      flag = 1;\n      dfs(i);\n      for (int j = 0; j < q.size() && flag; ++j) {\n        for (int k = j + 1; k < q.size() && flag; ++k) {\n          if (arr[q[j]][q[k]]) flag = 0;\n        }\n      }\n      int ss = q.size();\n      if (flag) ans = max(ans, ss);\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint f[2020];\nint c[2020];\nint v[2020];\nint n, m, x, y;\nint F(int x) { return f[x] != x ? f[x] = F(f[x]) : x; }\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) f[i] = i;\n  scanf(\"%d\", &m);\n  for (int i = 1; i <= m; i++) scanf(\"%d %d\", &x, &y), f[F(x)] = F(y);\n  scanf(\"%d\", &m);\n  for (int i = 1; i <= m; i++) scanf(\"%d %d\", &x, &y), v[F(x)] |= F(x) == F(y);\n  for (int i = 1; i <= n; i++)\n    if (!v[F(i)]) c[f[i]]++;\n  printf(\"%d\\n\", *max_element(c, c + n + 1));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nint pow(int a, int b) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) {\n      ans = (ans * a) % MOD;\n    }\n    b /= 2;\n    a = (a * a) % MOD;\n  }\n  return ans;\n}\nbool visited[100005];\nint id;\nint group[100005];\nint cnt[100005];\nvoid dfs(int s, vector<int> graph[]) {\n  visited[s] = true;\n  group[s] = id;\n  cnt[id]++;\n  for (int i : graph[s]) {\n    if (!visited[i]) {\n      dfs(i, graph);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, k, m;\n  cin >> n;\n  vector<int> graph[n + 1];\n  bool relation[n + 1][n + 1];\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    cin >> u >> v;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n  cin >> m;\n  memset(relation, false, sizeof(relation));\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    relation[u][v] = true;\n    relation[v][u] = true;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      id++;\n      dfs(i, graph);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      if (i == j) {\n        continue;\n      }\n      if ((group[i] == group[j]) && (relation[i][j])) {\n        cnt[group[i]] = 0;\n      }\n    }\n  }\n  int mm = INT_MIN;\n  for (int i = 1; i <= n; i++) {\n    if (cnt[i] > mm) {\n      mm = cnt[i];\n    }\n  }\n  cout << mm << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid fun() {}\nconst long long int N = 2007;\nstd::vector<long long int> v[N];\nbool visited[N];\nstd::vector<long long int> friends;\nlong long int enemy[N][N];\nvoid dfs(long long int node) {\n  visited[node] = true;\n  for (auto to : v[node]) {\n    if (!visited[to]) {\n      dfs(to);\n    }\n  }\n  friends.push_back(node);\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  fun();\n  long long int tests = 1;\n  while (tests--) {\n    long long int n;\n    cin >> n;\n    long long int m;\n    cin >> m;\n    for (long long int i = 1; i <= m; i++) {\n      long long int x, y;\n      cin >> x >> y;\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n    cin >> m;\n    for (long long int i = 1; i <= m; i++) {\n      long long int x, y;\n      cin >> x >> y;\n      enemy[x][y] = 1;\n      enemy[y][x] = 1;\n    }\n    long long int maxInvitations = 0;\n    for (long long int i = 1; i <= n; i++) {\n      if (!visited[i]) {\n        friends.clear();\n        dfs(i);\n        bool stillFriends = true;\n        for (long long int j = 0; j < friends.size(); j++) {\n          for (long long int k = 0; k < friends.size(); k++) {\n            if (enemy[friends[j]][friends[k]]) {\n              stillFriends &= false;\n            }\n          }\n        }\n        if (stillFriends) {\n          maxInvitations = max(maxInvitations, (long long int)friends.size());\n        }\n      }\n    }\n    cout << maxInvitations;\n  }\n  cerr << \"time elapsed : \" << 1.0 * clock() / CLOCKS_PER_SEC << \" sec \\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass vertex {\n public:\n  bool mark;\n  int comp;\n  vector<pair<int, bool>> to;\n};\nint n, k, m;\nvertex f[2000];\nint sz[2000];\nint counter = 1;\nint maxInv = 0;\nbool checkComponent(int c) {\n  for (int i = 1; i <= n; i++) {\n    if (f[i].comp == c) {\n      for (int j = 0; j < f[i].to.size(); j++) {\n        if (f[f[i].to[j].first].comp == c && f[i].to[j].second == false)\n          return false;\n      }\n    }\n  }\n  return true;\n}\nvoid dfs(int v) {\n  f[v].mark = true;\n  f[v].comp = counter;\n  sz[counter]++;\n  for (auto w : f[v].to) {\n    if (w.second == 1 && f[w.first].mark == false) {\n      dfs(w.first);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> n >> k;\n  int a, b;\n  for (int i = 0; i <= k - 1; i++) {\n    cin >> a >> b;\n    f[a].to.push_back({b, 1});\n    f[b].to.push_back({a, 1});\n  }\n  cin >> m;\n  for (int i = 0; i <= m - 1; i++) {\n    cin >> a >> b;\n    f[a].to.push_back({b, 0});\n    f[b].to.push_back({a, 0});\n  }\n  for (int i = 1; i <= n; i++) {\n    if (f[i].mark == false) {\n      dfs(i);\n      counter++;\n    }\n  }\n  int compN = counter - 1;\n  for (int i = 1; i <= compN; i++) {\n    if (checkComponent(i)) {\n      if (sz[i] > maxInv) maxInv = sz[i];\n    }\n  }\n  cout << maxInv;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> > fri, dis;\nint n, k;\nvector<int> vis;\nvoid purge(int x) {\n  vis[x] = 3;\n  for (int i = 0; i < fri[x].size(); i++) {\n    int s = fri[x][i];\n    if (vis[s] != 3) purge(s);\n  }\n}\nint dfs(int x, int p) {\n  vis[x] = 1;\n  int res = 1;\n  for (int i = 0; i < dis[x].size(); i++) {\n    int s = dis[x][i];\n    if (vis[s] == 1) {\n      purge(x);\n      return -1;\n    }\n    vis[s] = 2;\n  }\n  for (int i = 0; i < fri[x].size(); i++) {\n    int s = fri[x][i];\n    if (vis[s] == 2) {\n      purge(x);\n      return -1;\n    }\n    if (vis[s] == 1) continue;\n    if (vis[s] == 0) {\n      int lol = dfs(s, x);\n      if (lol == -1) {\n        return -1;\n      }\n      res += lol;\n    }\n  }\n  return res;\n}\nvoid clean() {\n  for (int i = 0; i < n; i++) {\n    if (vis[i] == 2)\n      vis[i] = 0;\n    else if (vis[i] == 1)\n      vis[i] = 3;\n  }\n}\nint main() {\n  cin >> n;\n  fri = vector<vector<int> >(n);\n  dis = vector<vector<int> >(n);\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    fri[a].push_back(b);\n    fri[b].push_back(a);\n  }\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    dis[a].push_back(b);\n    dis[b].push_back(a);\n  }\n  vis = vector<int>(n, 0);\n  int res = 0;\n  for (int i = 0; i < n; i++) {\n    if (vis[i] == 0) {\n      int r = dfs(i, -1);\n      if (r != -1) res = max(res, r);\n      clean();\n    }\n  }\n  cout << res << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int k = 2001;\nvector<long long int> parent(k);\nvector<long long int> size(k);\nlong long int find_set(long long int v) {\n  if (v == parent[v]) return v;\n  return parent[v] = find_set(parent[v]);\n}\nvoid union_set(long long int a, long long int b) {\n  a = find_set(a);\n  b = find_set(b);\n  if (a == b) return;\n  if (size[b] > size[a]) swap(a, b);\n  parent[b] = a;\n  size[a] += size[b];\n}\nsigned main() {\n  long long int n, m;\n  cin >> n >> m;\n  long long int k1, k2;\n  for (long long int i = 1; i <= n; i++) {\n    parent[i] = i;\n    size[i] = 1;\n  }\n  while (m--) {\n    cin >> k1 >> k2;\n    union_set(k1, k2);\n  }\n  set<long long int> s;\n  for (long long int i = 1; i <= n; i++) {\n    parent[i] = find_set(i);\n    s.insert(parent[i]);\n  }\n  cin >> m;\n  while (m--) {\n    cin >> k1 >> k2;\n    k1 = find_set(k1);\n    k2 = find_set(k2);\n    if (k1 == k2) {\n      if (s.find(k1) != s.end()) s.erase(k1);\n    }\n  }\n  long long int max1 = 0;\n  for (auto i = s.begin(); i != s.end(); i++) {\n    max1 = max(max1, size[*i]);\n  }\n  cout << max1;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1e18;\nint n, m, k, c, a, b, sum[2020], chk[2020], bo[2020], ans;\nvector<int> v[2020];\nvoid dfs(int pos) {\n  if (chk[pos]) return;\n  chk[pos] = c;\n  sum[c]++;\n  for (auto p : v[pos]) {\n    dfs(p);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (chk[i] != 0) continue;\n    c++;\n    dfs(i);\n  }\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> a >> b;\n    if (chk[a] == chk[b]) {\n      bo[chk[a]] = 1;\n    }\n  }\n  for (int i = 1; i <= c; i++) {\n    if (bo[i] == 1) continue;\n    ans = max(ans, sum[i]);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m, a[2000 + 1][2000 + 1], t1, t2, ans = 0, hold[2000 + 1];\nbool holded[2000 + 1], checked[2000 + 1];\nvoid DFS(int neo, int d);\nvoid DFS(int neo, int d) {\n  hold[d] = neo;\n  holded[neo] = true;\n  checked[neo] = true;\n  bool all = true;\n  for (int i = 1; i <= d; i++) {\n    for (int j = 1; j <= n; j++) {\n      if (a[hold[i]][j] == 1 && !holded[j]) {\n        all = false;\n        break;\n      }\n    }\n    if (!all) break;\n  }\n  if (all) ans = (d > ans) ? d : ans;\n  for (int i = 1; i <= n; i++) {\n    if (!checked[i] && !holded[i]) {\n      bool flag = false;\n      for (int j = 1; j <= d; j++) {\n        if (a[hold[j]][i] == 1) {\n          flag = true;\n          break;\n        }\n      }\n      for (int j = 1; j <= d; j++) {\n        if (a[hold[j]][i] == 2) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        DFS(i, d + 1);\n      }\n    }\n  }\n  holded[neo] = false;\n}\nint main(int argc, const char* argv[]) {\n  cin >> n;\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    cin >> t1 >> t2;\n    a[t1][t2] = a[t2][t1] = 1;\n  }\n  cin >> m;\n  for (int i = 1; i <= m; i++) {\n    cin >> t1 >> t2;\n    a[t1][t2] = a[t2][t1] = 2;\n  }\n  for (int i = 1; i <= n; i++) {\n    holded[i] = false;\n    checked[i] = false;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!checked[i]) DFS(i, 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def root(Arr,i):\n    while(Arr[i]!=i):\n        Arr[i]=Arr[Arr[i]]\n        i=Arr[i]\n    return i\ndef Union(Arr,A,B):\n    root_A= root(Arr,A)\n    root_B=root(Arr,B)\n    if size[root_B]<size[root_A]:\n        Arr[root_B]=Arr[root_A]\n        size[root_A]+=size[root_B]\n    else:\n        Arr[root_A]=Arr[root_B]\n        size[root_B]+=size[root_A]\n        \n        \n        \ndef Find(A,B):\n    if root(Arr,A)==root(Arr,B):\n        return True\n    return False\n\nn=int(input())\nArr=list(range(n))\nsize=[1]*(n)\nlst=[]\n\nf=int(input())\nfor i in range(f):\n    A,B=map(int,input().split())\n    if not Find(A-1,B-1):\n        Union(Arr,A-1,B-1)\n\n\ne=int(input())\n\nenemy=[]\n#print(enemy)\nfor x in range(e):\n    a,b=map(int,input().split())\n    enemy.append([a-1,b-1])\n#print(enemy)\nfor i in range(n):\n    if Arr[i]==i:\n        lst.append([size[i],i])\nlst=sorted(lst)[::-1]\n\n\nans=0\ntest=0\nif e==0:\n    print(lst[0][0])\nelse:\n    for i in range(len(lst)):\n        Root=lst[i][1]\n        test=0\n        for k in range(e):\n            if root(Arr,enemy[k][0])==Root and root(Arr,enemy[k][1])==Root:\n                test=1\n                break\n        if test==0:\n            ans=lst[i][0]\n            break\n#print(enemy)\n#print(lst)       \n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m, a, b, vis[2010];\nvector<int> like[2010];\nvector<int> dislike[2010];\nvector<int> ac;\nint is;\nvoid dfs(int x) {\n  vis[x] = 1;\n  ac.push_back(x);\n  for (int i = 0; i < dislike[x].size(); i++) {\n    if (count(ac.begin(), ac.end(), dislike[x][i])) {\n      is = 0;\n      return;\n    }\n  }\n  for (int i = 0; i < like[x].size(); i++) {\n    if (!vis[like[x][i]]) {\n      dfs(like[x][i]);\n    }\n  }\n}\nint main(void) {\n  cin >> n >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> a >> b;\n    like[a].push_back(b);\n    like[b].push_back(a);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b;\n    dislike[a].push_back(b);\n    dislike[b].push_back(a);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    is = 1;\n    memset(vis, 0, sizeof(vis));\n    ac.clear();\n    dfs(i);\n    if (is && ac.size() > ans) {\n      ans = (int)ac.size();\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 2010;\nstruct node {\n  int p;\n  node *next;\n} h[N];\nvoid add(int x, int y) {\n  node *tmp = new node;\n  tmp->p = y;\n  tmp->next = h[x].next;\n  h[x].next = tmp;\n}\nint p[N], d = 0, cnt[N];\nbool flag[N];\nvoid DFS(int x) {\n  flag[x] = true;\n  p[x] = d;\n  cnt[d]++;\n  for (node *tmp = h[x].next; tmp != NULL; tmp = tmp->next)\n    if (!flag[tmp->p]) DFS(tmp->p);\n}\nint main() {\n  int n, m1, m2, x, y;\n  scanf(\"%d%d\", &n, &m1);\n  for (int i = 1; i <= n; i++) h[i].next = NULL;\n  while (m1--) {\n    scanf(\"%d%d\", &x, &y);\n    add(x, y);\n    add(y, x);\n  }\n  for (int i = 1; i <= n; i++)\n    if (!flag[i]) {\n      ++d;\n      DFS(i);\n    }\n  scanf(\"%d\", &m2);\n  while (m2--) {\n    scanf(\"%d%d\", &x, &y);\n    if (p[x] == p[y]) cnt[p[x]] = 0;\n  }\n  int ans = 0;\n  for (int i = 1; i <= d; i++)\n    if (ans < cnt[i]) ans = cnt[i];\n  printf(\"%d\\n\", ans);\n  scanf(\" \");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, vis[2005], sz[2005];\nvector<int> e[2005];\npair<int, int> f[2005];\nvoid dfs(int u, int c) {\n  if (vis[u] != -1) return;\n  vis[u] = c;\n  sz[c]++;\n  for (int i = 0; i < e[u].size(); i++) dfs(e[u][i], c);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.clear();\n  cin >> n >> m;\n  while (m--) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    f[i] = make_pair(u, v);\n  }\n  memset(vis, -1, sizeof vis);\n  for (int i = 0; i < n; i++) {\n    dfs(i, i);\n  }\n  int mx = 0;\n  for (int i = 0; i < m; i++) {\n    int u = f[i].first, v = f[i].second;\n    if (vis[u] == vis[v]) {\n      sz[vis[u]] = 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    mx = max(mx, sz[i]);\n  }\n  cout << mx;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxN = 1e5 + 12;\nconst long long INF = 1e18 + 12;\nconst long long Inf = 1e9 + 12;\nlong long n, k, m, mx, par[maxN], sz[maxN];\nlong long find(long long x) {\n  if (par[x] == x) return x;\n  return par[x] = find(par[x]);\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long long i = 0; i <= n; i++) par[i] = i, sz[i] = 1;\n  while (k--) {\n    long long x, y;\n    cin >> x >> y;\n    x = find(x);\n    y = find(y);\n    if (y - x) {\n      par[y] = x;\n      sz[x] += sz[y];\n    }\n  }\n  cin >> m;\n  while (m--) {\n    long long x, y;\n    cin >> x >> y;\n    x = find(x);\n    y = find(y);\n    if (x == y) sz[y] = 0;\n  }\n  for (long long i = 1; i <= n; i++) {\n    mx = max(mx, sz[find(i)]);\n  }\n  cout << mx << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, m, ans;\nvector<long long> e[1000005], v;\nset<long long> hate[1000005];\nbool mark[1000005];\nvoid dfs(int u) {\n  mark[u] = 1;\n  v.push_back(u);\n  for (int x : e[u]) {\n    if (mark[x]) continue;\n    dfs(x);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    long long x, y;\n    cin >> x >> y;\n    e[x].push_back(y);\n    e[y].push_back(x);\n  }\n  cin >> m;\n  for (int i = 1; i <= m; i++) {\n    long long x, y;\n    cin >> x >> y;\n    hate[x].insert(y);\n    hate[y].insert(x);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!mark[i]) {\n      v.clear();\n      dfs(i);\n      set<long long> s(v.begin(), v.end());\n      bool check = true;\n      for (int x : s) {\n        for (int y : hate[x]) {\n          if (s.count(y)) {\n            check = false;\n            break;\n          }\n          if (!check) break;\n        }\n        if (!check) break;\n      }\n      if (check) ans = max(ans, (long long)v.size());\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n/**\n * Created with IntelliJ IDEA.\n * Author   : Dylan\n * Date     : 2013-08-10\n * Time     : 14:40\n * Project  : Party 3\n */\n\npublic class Main {\n    static LinkedList<Integer>[] graph;\n    static int[] root;\n    static boolean[] visited;\n    static int n, current, max;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        graph = new LinkedList[n + 1];\n        visited = new boolean[n + 1];\n        root = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            graph[i] = new LinkedList<Integer>();\n            root[i] = i;\n        }\n        int k = in.nextInt();\n        while (k-- > 0) {\n            int x = in.nextInt();\n            int y = in.nextInt();\n            graph[x].add(y);\n            graph[y].add(x);\n            int rootX = findRoot(x);\n            int rootY = findRoot(y);\n            if (rootX != rootY) {\n                root[rootX] = rootY;\n            }\n        }\n        k = in.nextInt();\n        while (k-- > 0) {\n            int rootX = findRoot(in.nextInt());\n            int rootY = findRoot(in.nextInt());\n            if (rootX == rootY) {\n                visited[rootX] = true;\n            }\n        }\n        max = 0;\n        for (int i = 1; i <= n; i++) {\n            if (visited[findRoot(i)]) continue;\n            current = 0;\n            dfs(i);\n            max = Math.max(max, current);\n        }\n        System.out.println(max);\n    }\n\n    static void dfs(int x) {\n        visited[x] = true;\n        current++;\n        for (int i : graph[x]) {\n            if (visited[i]) continue;\n            dfs(i);\n        }\n    }\n\n    static int findRoot(int x) {\n        return x == root[x] ? x : (root[x] = findRoot(root[x]));\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n\nimport java.math.BigInteger;\nimport java.util.*;\n \n \n \n public class Main {\n\tpublic static InputReader in;\n    public static PrintWriter pw;\n \n \n \n\tpublic static void main(String args[]) {\n\t\tnew Thread(null, new Runnable() {\n            public void run() {\n                try{\n                    solve();\n                }\n                catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n        }, \"1\", 1 << 26).start();\n    }\n\tstatic ArrayList<Pair> g[];\n\tstatic ArrayList<Integer> h[];\n\tstatic boolean visited[];\n\tstatic boolean visit[];\n\tstatic int par[];\n\tstatic int degree[];\n\tstatic int edjes=0;\n\tstatic int start=-1;\n\tstatic int end=-1;\n\tstatic int Total=0;\n\tstatic int time1[];\n\tstatic int time2[];\n\tstatic int glob=0;\n\tstatic int ans[];\n\tstatic boolean vis2[][];\n\t//static long sum1=0;\n\t//static long val[];\n    static ArrayList<Integer> levels[];\n    static int max=0;\n    static int lev=1;\n    static ArrayList<Integer> nodes[];\n    static ArrayList<Integer> values[];\n    static int depth[];\n    static boolean found=false;\n    static long sm[];\n    static int sum1=0;\n    static int pre[][];\n    \n   static  int mn=1000001;\n    static Stack<Integer> tt=new Stack();\n    public static void solve(){\n\t\t\n\t\n\t\t in = new InputReader(System.in);\n\t\t pw = new PrintWriter(System.out);\n         int n=in.nextInt();\n         int k=in.nextInt();\n         g=new ArrayList[n+1];\n         DSU d=new DSU(n+1);\n         for(int i=0;i<k;i++)\n         {\n        \t int x=in.nextInt();\n        \t int y=in.nextInt();\n        \t d.Merge(x, y);\n         }\n         HashMap<Integer,Integer> hm=new HashMap();\n         HashSet<Integer> set=new HashSet();\n         for(int i=1;i<=n;i++)\n         {\n        \t set.add(d.find(i));\n         }\n         int size[]=d.size;\n         for(int x:set)\n         {\n        \t if(!hm.containsKey(size[x]))\n        \t\t hm.put(size[x],1);\n        \t else\n        \t\t hm.put(size[x],hm.get(size[x]+1));\n         }\n         \n         int m=in.nextInt();\n         int cnt[]=new int[n+1];\n         for(int i=0;i<m;i++)\n         {\n        \t int x=in.nextInt();\n        \t int y=in.nextInt();\n        \t if(d.find(x)==d.find(y))\n        \t {\n        \t\t int curr=size[d.find(x)];\n        \t\t if(hm.containsKey(curr)){\n        \t\t hm.put(curr,hm.get(curr)-1);\n        \t\t if(hm.get(curr)==0)\n        \t\t\t hm.remove(curr);\n        \t\t }\n        \t }\n        \t else\n        \t {\n        \t\t continue;\n        \t }\n         }\n         int ans=0;\n         for(int x:hm.keySet())\n         {\n        \t// System.out.println(x+\" \"+hm.get(x));\n        \t ans=Math.max(ans, x);\n        \t \n         }\n         System.out.println(ans);\n    }\n\n    \n\n\tpublic static int countNumber(int n)\n    {\n        int result = 0;\n     \n        // Pushing 1 to 9 because all number from 1\n        // to 9 have this propert.\n        for (int i = 1; i <= 9; i++)\n        {\n            Stack<Integer> s=new Stack();\n            if (i <= n)\n            {\n                s.push(i);\n                result++;\n            }\n     \n            // take a number from stack and add\n            // a digit smaller than last digit\n            // of it.\n            while (!s.empty())\n            {\n                int tp = s.peek();\n                s.pop();\n                for (int j = tp%10; j <= 9; j++)\n                {\n                    int x = tp*10 + j;\n                 //   System.out.println(x);\n                    if (x <= n)\n                    {\n                        s.push(x);\n                        result++;\n                    }\n                }\n              //  System.out.println();\n            }\n        }\n     \n        return result;\n    }\n    public static boolean IsPrime(long l) {\n\t\t// Corner cases\n\t\tif (l <= 1)\n\t\t\treturn false;\n\t\tif (l <= 3)\n\t\t\treturn true;\n \n\t\t// This is checked so that we can skip \n\t\t// middle five numbers in below loop\n\t\tif (l % 2 == 0 || l % 3 == 0)\n\t\t\treturn false;\n \n\t\tfor (long i = 5; i * i <= l; i = i + 6)\n\t\t\tif (l % i == 0 || l % (i + 2) == 0)\n\t\t\t\treturn false;\n \n\t\treturn true;\n\t}\n \n   // import java.util.*;  \n    \n    \n    static class DSU \n        {\n        public int rank[];\n        public int parent[];\n        public int n;\n        public int size[];\n        public int val[];\n        public int comp;\n        public boolean vis[];\n        static long sm;\n        public int as[];\n        ArrayList<String> extra=new ArrayList<String>();\n        int sum[]=new int[100001];\n        public DSU(int n)\n        {\n        \tthis.val=val;\n        \tthis.n=n;\n        \t\n        \tmakeSet();\n        }\n        private void makeSet() \n        {\n        \trank=new int[n+1];\n        \tparent=new int[n+1];\n        \tsize=new int[n+1];\n        \tcomp=n;\n        \tfor(int i=1;i<=n;i++)\n        \t{\n        \t\trank[i]=1;\n                parent[i]=i;\n        \t    size[i]=1;\n        \t}\n        }\n        public int find(int x)\n        {\n        \tif(parent[x]!=x)\n        \t\tparent[x]=find(parent[x]);\n        \treturn parent[x];\n        }\n        public void Merge(int x,int y)\n        {\n            int xRoot=find(x);\n        \tint yRoot=find(y);\n        \tif(xRoot==yRoot){\n        \t\textra.add(x+\" \"+y);\n        \t\treturn;\n        \t}\n            comp--;\n           \n        if(rank[xRoot]<rank[yRoot])\n        \t{\n        \t\tparent[xRoot]=yRoot;\n        \t\trank[yRoot]++;\n        \t    size[yRoot]+=size[xRoot];\n        \t    \n        \t}\n        \telse\n        \t{\n        \t\tparent[yRoot]=xRoot;\n        \t\trank[xRoot]++;\n        \t\tsize[xRoot]+=size[yRoot];\n        \t     \n        \t}\n        }\n     \n     \n        }\n     \n        \n  \n        \n     \n        \n\n   \n/*public static void dfs2(int curr,int lev)\n{\n\ttime1[curr]=glob++;\n\t\n\tdepth[curr]=lev;\n\tvisited[curr]=true;\n\tnodes[lev].add(time1[curr]);\n\tvalues[lev].add(a[curr]);\n\tfor(int x:g[curr])\n\t{\n\t\tif(!visited[x])\n\t\t{\n\t\t\tdfs2(x,lev+1);\n\t\t}\n\t}\ntime2[curr]=glob++;\n}\n \n \n \npublic static void bfs1(int curr)\n{\nQueue<Integer> Q=new LinkedList<Integer>();\nQ.add(1);\nvisit[1]=true;\nint lev=2;\nlevels[1].add(1);\nwhile(!Q.isEmpty())\n{\n\tint cnt=Q.size();\n\twhile(cnt>0)\n\t{\n\t\tint p=Q.poll();\n\t\tvisit[p]=true;\n\t\tfor(int x:g[p])\n\t\t{\n\t\t\tif(!visit[x])\n\t\t\t{\n\t\t\t\tQ.add(x);\n\t\t\t\tlevels[lev].add(x);\n\t\t\t}\n\t\t}\n\t\tcnt--;\n\t}\n\tmax=Math.max(lev, max);\n\tlev++;\n}\n}\n \n \n\t\n \tprivate static long fact(int len) {\n\tlong ans=1;\n\tfor(int i=1;i<=len;i++)\n\t\tans*=i;\n\treturn ans;\n}\n \n \n \n\t\n\t// SubTree Checker DFS (TO CHECK IF X IS IN A SUBTREE OF Y)\n\tpublic static void dfs3(int curr)\n\t{\n\t\tvisited[curr]=true;\n\t\ttime1[curr]=glob++;\n\t\tfor(int x:g[curr])\n\t\t{\n\t\tif(!visited[x])\n\t\t\tdfs3(x);\n\t\t}\n\t\ttime2[curr]=glob++;\n\t}\n    \n\t\n\t\n \n    /*NO OF EDJES IN WHOLE CONNECTED COMPONENTS\n  \n\tpublic static void dfs1(int curr)\n\t{\n\t\tvisited[curr]=true;\n\t\tfor(int next:g[curr])\n\t\t{\n\t\t\tedje++;\n\t\t\tif(!visited[next])\n\t\t\t\tdfs1(next);\n\t\t}\n\t}\n\t/*SUM OF ALL SUBTREE NODE'S VLAUES DFS\n\tpublic static void dfs(int curr,int prev)\n\t\t{\n\t\tval[curr]=1;\n\t\t\tfor(int x:g[curr])\n\t\t\t{\n\t\t\t\tif(x!=prev)\n\t\t\t\t{\n\t\t            dfs(x,curr);\n\t\t            val[curr]+=val[x];\n\t\t\t\t\t\n\t\t\t    }\n\t\t\t}\n\t\t}*/\n\t\n\t\tpublic static long power(long a,long b)\n\t\t{\n\t\t\tlong result=1;\n\t\t\twhile(b>0)\n\t\t\t{\n\t\t\t\tif(b%2==1)\n\t\t\t\t\tresult*=a;\n\t\t\t\ta=a*a;\n\t\t\t\tb/=2;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t\t\tpublic static long pow(long n,long p,long m)\n\t{\n\t\t long  result = 1;\n\t\t  if(p==0)\n\t\t    return 1;\n\t\tif (p==1)\n\t\t    return n;\n\t\twhile(p!=0)\n\t\t{\n\t\t    if(p%2==1)\n\t\t        result *= n;\n\t\t    if(result>=m)\n\t\t    result%=m;\n\t\t    p >>=1;\n\t\t    n*=n;\n\t\t    if(n>=m)\n\t\t    n%=m;\n\t\t}\n\t\treturn result;\n\t}\n\tstatic class Pair implements Comparable<Pair>{\n\tint dist;\n\t\tint fuel;\n\t\tPair(int ver,int weight){\n\t     \tthis.dist=ver;\n\t\t\tthis.fuel=weight;\n\t\t\t\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t//\tif(o.finish<this.finish)\n\t\t  //  return 1;\n\t\t//\telse\n\t\t\treturn 1;\n\t\t}\n\t}\n\tpublic static long gcd(long a, long b) {\n\t\t  if (b == 0) return a;\n\t\t  return gcd(b, a%b);\n\t\t}\n\tstatic class InputReader {\n \n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\t\tprivate SpaceCharFilter filter;\n \n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n \n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n \n\t\tpublic   int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic String readString() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n \n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstd::vector<std::vector<unsigned>*> parties;\nstd::list<std::vector<unsigned>> groups;\nclass Pair {\n public:\n  unsigned m_first;\n  unsigned m_second;\n  Pair() : m_first(0), m_second(0) {}\n  void read(bool is_a_friends) {\n    std::cin >> m_first >> m_second;\n    m_first--;\n    m_second--;\n    if (is_a_friends && parties[m_first] != parties[m_second]) {\n      parties[m_first]->insert(parties[m_first]->end(),\n                               parties[m_second]->begin(),\n                               parties[m_second]->end());\n      std::vector<unsigned>* ptr = parties[m_second];\n      for (auto i = ptr->begin(), end = ptr->end(); i != end; ++i)\n        parties[*i] = parties[m_first];\n      ptr->clear();\n    } else if (!is_a_friends && parties[m_first] == parties[m_second])\n      parties[m_first]->clear();\n  }\n};\nvoid read(bool is_a_friends) {\n  unsigned k(0);\n  Pair pair;\n  std::cin >> k;\n  for (unsigned i = 0; i < k; i++) pair.read(is_a_friends);\n}\nint main() {\n  unsigned size(0);\n  std::cin >> size;\n  parties.assign(size, nullptr);\n  for (unsigned i = 0; i < size; i++) {\n    groups.push_front(std::vector<unsigned>(1, i));\n    parties[i] = &groups.front();\n    parties[i]->reserve(size);\n  }\n  read(true);\n  read(false);\n  unsigned max(0);\n  for (auto i = groups.begin(); i != groups.end(); ++i)\n    if (max < i->size()) max = i->size();\n  std::cout << max;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> g[2001], v;\nbool dis[2001][2001], vit[2001];\nvoid dfs(int u) {\n  vit[u] = true;\n  v.push_back(u);\n  for (int i = 0; i < g[u].size(); i++) {\n    int t = g[u][i];\n    if (!vit[t]) dfs(t);\n  }\n}\nbool ok() {\n  for (int i = 0; i < v.size(); i++)\n    for (int k = i + 1; k < v.size(); k++)\n      if (dis[v[i]][v[k]]) return false;\n  return true;\n}\nint main() {\n  int n, i, a, b, ret = 0;\n  scanf(\"%d %d\", &n, &i);\n  while (i--) {\n    scanf(\"%d %d\", &a, &b);\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  scanf(\"%d\", &i);\n  while (i--) {\n    scanf(\"%d %d\", &a, &b);\n    dis[a][b] = dis[b][a] = true;\n  }\n  for (i = 1; i <= n; i++)\n    if (!vit[i]) {\n      v.clear();\n      dfs(i);\n      if (ok()) {\n        ret = max(ret, (int)v.size());\n      }\n    }\n  printf(\"%d\", ret);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:66777216\")\nusing namespace std;\nvoid sIO();\nint n, m, k, x, y, p[2222], ans, kk, tt;\nbool f[2222][2222], w[2222], ok;\nvector<int> cur;\nint findSet(int v) {\n  if (p[v] != v) p[v] = findSet(p[v]);\n  return p[v];\n}\nvoid unite(int a, int b) {\n  a = findSet(a);\n  b = findSet(b);\n  if (a != b) {\n    if (rand() & 1) swap(a, b);\n    p[a] = b;\n  }\n}\nint main() {\n  sIO();\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; ++i) p[i] = i;\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", &x, &y);\n    unite(x, y);\n  }\n  memset(f, 0, sizeof(f));\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; ++i) {\n    scanf(\"%d %d\", &x, &y);\n    f[x][y] = f[y][x] = true;\n  }\n  for (int i = 1; i <= n; ++i) p[i] = findSet(i);\n  memset(w, 0, sizeof(w));\n  ans = 0;\n  for (int i = 1; i <= n; ++i)\n    if (!w[i]) {\n      tt = p[i];\n      cur.clear();\n      ok = true;\n      for (int j = i; j <= n; ++j)\n        if (p[j] == tt) {\n          kk = (int)cur.size();\n          for (k = 0; k < kk; ++k)\n            if (f[cur[k]][j]) {\n              ok = false;\n              break;\n            }\n          if (!ok) break;\n          cur.push_back(j);\n        }\n      for (int j = i; j <= n; ++j) w[j] |= p[j] == tt;\n      ans = max(ans, (int)cur.size() * ok);\n    }\n  printf(\"%d\", ans);\n  return 0;\n}\nvoid sIO() {}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\nint ans, n, m;\nint f[maxn], size[maxn], use[maxn];\nint findset(int x) {\n  if (f[x] == x) return x;\n  int fx = findset(f[x]);\n  f[x] = fx;\n  return fx;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) f[i] = i, size[i] = 1, use[i] = 1;\n  scanf(\"%d\", &m);\n  for (int i = 1; i <= m; i++) {\n    int x, y, f1, f2;\n    scanf(\"%d%d\", &x, &y);\n    f1 = findset(x);\n    f2 = findset(y);\n    if (f1 == f2) continue;\n    f[f1] = f2;\n    size[f2] += size[f1];\n  }\n  scanf(\"%d\", &m);\n  for (int i = 1; i <= m; i++) {\n    int x, y, f1, f2;\n    scanf(\"%d%d\", &x, &y);\n    f1 = findset(x);\n    f2 = findset(y);\n    if (f1 == f2) use[f1] = 0;\n  }\n  for (int i = 1; i <= n; i++)\n    if (f[i] == i && use[i])\n      if (size[i] > ans) ans = size[i];\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n \npublic class bfs_dfs { \n\tpublic static ArrayList<Integer> x;\n\tpublic static TreeSet<Integer> X;\n\tpublic static boolean t;\n\tpublic static vertex[] V;\n\tpublic static boolean[] vis ;\n\tpublic static void main(String[] args)\n\t{\t\t\n\t\tmYScanner in = new mYScanner();\n\t\tint n = in.nextInt();\n\t\t V = new vertex[n+1];\n\t\tfor(int i = 1;i<=n;i++)\n\t\t{\n\t\t\tV[i] = new vertex();\n\t\t\tV[i].value = i;\n\t\t}\n\t\tint k = in.nextInt();\n\t\tfor(int i = 0;i<k;i++)\n\t\t{\n\t\t\tint src = in.nextInt();\n\t\t\tint dest = in.nextInt();\n\t\t\tV[src].frnd.add(dest);\n\t\t\tV[dest].frnd.add(src);\n\t\t}\n\t\tint m = in.nextInt();\n\t\tfor(int i = 0;i<m;i++)\n\t\t{\n\t\t\tint src = in.nextInt();\n\t\t\tint dest = in.nextInt();\n\t\t\tV[src].hate.add(dest);\n\t\t\tV[dest].hate.add(src);\n\t\t}\n\t\tint ans = 0;\n\t\tvis = new boolean[n+1];\n\t\tfor(int i = 1;i<=n;i++)\n\t\t{\n\t\t\tx = new ArrayList<>();\n\t\t\tX = new TreeSet<>();\n\t\t\tt = true;\n\t\t\tif(!vis[i])\n\t\t\t{\n\t\t\t\tx.add(i);\n\t\t\t\tX.addAll(V[i].hate);\n\t\t\t\tvis[i] = true;\n\t\t\t\tdfs(V[i]);\n\t\t\t}\n\t\t\tint size = X.size();\n\t\t\tX.addAll(x);\n\t\t\tif(X.size()==size+x.size() && ans<x.size())\n\t\t\tans = x.size();\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static void dfs(vertex v)\n\t{\n\t\tfor(int i = 0;t && i<v.frnd.size();i++)\n\t\t{\n\t\t   if(!vis[v.frnd.get(i)])\n\t\t\t{\n\t\t\t\tx.add(v.frnd.get(i));\n\t\t\t\tX.addAll(V[v.frnd.get(i)].hate);\n\t\t\t\tvis[v.frnd.get(i)] = true;\n\t\t\t\tdfs(V[v.frnd.get(i)]);\n\t\t\t}\n\t\t}\n\t}\n}\nclass vertex\n{\n     int value;\n     ArrayList<Integer> frnd = new ArrayList<>();\n     TreeSet<Integer> hate = new TreeSet<>(); \n }\n\tclass mYScanner\n{\n\tBufferedReader br ;\n\tStringTokenizer st;\n\t\n\tpublic mYScanner()\n\t{\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tst = null;\n\t}\n\t public String next() {\n\t        while (st == null || !st.hasMoreElements()) {\n\t            try {\n\t                st = new StringTokenizer(br.readLine());\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t        return st.nextToken();\n\t    }\n\tpublic int nextInt()\n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\tpublic long nextLong()\n\t{\n\t  return\tLong.parseLong(next());\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n//import java.math.*;\n\npublic class Task{\n        //  ..............code begins here..............\n\nstatic long mod=(long)1e9+7;\nstatic Set<Integer> dfs(List<Integer>[] g, int s,boolean[] b,Set<Integer> ss){\n    ss.add(s); b[s]=true;\n    for(int c:g[s]){\n        if(!b[c]){\n            dfs(g,c,b,ss);\n        }\n    }\n    return ss;    \n}\nstatic void solve() throws  IOException {\n            int n=int_v(read()),m=int_v(read());\n            List<Integer>[] g=new ArrayList[n+1];\n            List<Integer>[] dis=new ArrayList[n+1];\n            for(int i=0;i<=n;i++){\n                g[i]=new ArrayList<>();\n                g[i].add(i);\n                dis[i]=new ArrayList<>();\n            }\n            for(int i=0;i<m;i++){\n                int[] e=int_arr();\n                g[e[0]].add(e[1]); g[e[1]].add(e[0]);\n            }\n            int k=int_v(read()); boolean[] b=new boolean[n+1];\n            for(int i=0;i<k;i++){\n                int[] e=int_arr();\n                dis[e[0]].add(e[1]); dis[e[1]].add(e[0]);\n            }\n            List<Set<Integer>> comp=new ArrayList<>();\n            for(int i=1;i<=n;i++){\n                if(g[i].size()==0||b[i]) continue;\n                comp.add(dfs(g,i,b,new HashSet<>()));\n            }\n            int res=0;\n            for(Set<Integer> s:comp){\n                boolean[] b1=new boolean[n+1];\n                boolean bb=true;\n                for(int x:s)b1[x]=true;\n                for(int x:s){\n                    for(int c:dis[x]){\n                        if(b1[c]) bb=false;\n                    }\n                }\n                if(bb) res=Math.max(res,s.size());\n            }\n            out.write(res+\"\");\n\n}\npublic static void main(String[] args) throws  IOException{\n                assign();\n                int t=1;//int_v(read());\n                while(t--!=0) solve();\n                out.flush();\n}\n\n// taking inputs\nstatic BufferedReader s1;\nstatic BufferedWriter out;\nstatic String read() throws IOException{String line=\"\";while(line.length()==0){line=s1.readLine();continue;}return line;}\nstatic int int_v (String s1){return Integer.parseInt(s1);}\nstatic long long_v(String s1){return Long.parseLong(s1);}\nstatic void sort(int[] a){List<Integer> l=new ArrayList<>();for(int x:a){l.add(x);}Collections.sort(l);for(int i=0;i<a.length;i++){a[i]=l.get(i);}}\nstatic int[] int_arr() throws IOException{String[] a=read().split(\" \");int[] b=new int[a.length];for(int i=0;i<a.length;i++){b[i]=int_v(a[i]);}return b;}\nstatic long[] long_arr() throws IOException{String[] a=read().split(\" \");long[] b=new long[a.length];for(int i=0;i<a.length;i++){b[i]=long_v(a[i]);}return b;}\nstatic void assign(){s1=new BufferedReader(new InputStreamReader(System.in));out=new BufferedWriter(new OutputStreamWriter(System.out));}\n//static String setpreciosion(double d,int k){BigDecimal d1 = new BigDecimal(Double.toString(d));return d1.setScale(k,RoundingMode.HALF_UP).toString();}//UP DOWN HALF_UP\nstatic int gcd(int a,int b){if(b==0){return a;}return gcd(b,a%b);}\nstatic long Modpow(long a,long p,long m){long res=1;while(p>0){if((p&1)!=0){res=(res*a)%m;}p >>=1;a=(a*a)%m;}return res%m;}\nstatic long Modmul(long a,long b,long m){return ((a%m)*(b%m))%m;}\nstatic long ModInv(long a,long m){return Modpow(a,m-2,m);}\n//static long nck(int n,int r,long m){if(r>n){return 0l;}return Modmul(f[n],ModInv(Modmul(f[n-r],f[r],m),m),m);}\n//static long[] f;\n}\n             "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 2000;\nstruct UFT {\n  int links[MAX_N], ranks[MAX_N], sizes[MAX_N];\n  UFT() {}\n  void init(int n) {\n    for (int i = 0; i < n; i++) links[i] = i, ranks[i] = sizes[i] = 1;\n  }\n  int root(int i) {\n    int i0 = i;\n    while (links[i0] != i0) i0 = links[i0];\n    return (links[i] = i0);\n  }\n  int rank(int i) { return ranks[root(i)]; }\n  int size(int i) { return sizes[root(i)]; }\n  bool same(int i, int j) { return root(i) == root(j); }\n  int merge(int i0, int i1) {\n    int r0 = root(i0), r1 = root(i1), mr;\n    if (r0 == r1) return r0;\n    if (ranks[r0] == ranks[r1]) {\n      links[r1] = r0;\n      sizes[r0] += sizes[r1];\n      ranks[r0]++;\n      mr = r0;\n    } else if (ranks[r0] > ranks[r1]) {\n      links[r1] = r0;\n      sizes[r0] += sizes[r1];\n      mr = r0;\n    } else {\n      links[r0] = r1;\n      sizes[r1] += sizes[r0];\n      mr = r1;\n    }\n    return mr;\n  }\n};\nUFT uft;\nbool ngs[MAX_N];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  uft.init(n);\n  int k;\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u--, v--;\n    uft.merge(u, v);\n  }\n  int m;\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u--, v--;\n    if (uft.same(u, v)) ngs[uft.root(u)] = true;\n  }\n  int maxg = 0;\n  for (int i = 0; i < n; i++)\n    if (!ngs[i] && i == uft.root(i) && maxg < uft.size(i)) maxg = uft.size(i);\n  printf(\"%d\\n\", maxg);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (1 << 30) - 1;\nconst long double eps = 1e-9;\nconst long double pi = fabs(atan2(0.0, -1.0));\nint *ass;\nvoid ML() {\n  for (;;) {\n    ass = new int[2500000];\n    for (int i = 0; i < 2500000; i++) ass[i] = rand();\n  }\n}\nint n, k, m;\nvector<list<int> > fr;\nvector<list<int> > en;\nvoid LoAd() {\n  cin >> n >> k;\n  fr.resize(n + 1);\n  en.resize(n + 1);\n  for (int x, y, i = 0; i < k; i++) {\n    scanf(\"%d %d\", &x, &y);\n    fr[x].push_back(y);\n    fr[y].push_back(x);\n  }\n  cin >> m;\n  for (int x, y, i = 0; i < m; i++) {\n    scanf(\"%d %d\", &x, &y);\n    en[x].push_back(y);\n    en[y].push_back(x);\n  }\n}\nvector<list<int> > co;\nvector<bool> was;\nvector<bool> goodCompany;\nvector<int> company;\nvoid dfs(const int v, const int cnt) {\n  was[v] = true;\n  company[v] = cnt;\n  co[cnt].push_back(v);\n  for (list<int>::iterator it = fr[v].begin(); it != fr[v].end(); it++) {\n    if (!was[*it]) dfs(*it, cnt);\n  }\n}\nvoid SoLvE() {\n  co.reserve(n + 1);\n  was.resize(n + 1, false);\n  company.resize(n + 1);\n  int cnt = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!was[i]) {\n      co.push_back(list<int>());\n      dfs(i, cnt);\n      cnt++;\n    }\n  }\n  goodCompany.resize(co.size(), true);\n  for (int i = 1; i < (int)en.size(); i++) {\n    for (list<int>::iterator it = en[i].begin(); it != en[i].end(); it++) {\n      if (company[i] == company[*it]) goodCompany[company[i]] = false;\n    }\n  }\n  int ind = -1;\n  for (int i = 0; i < (int)co.size(); i++) {\n    if (!goodCompany[i]) continue;\n    if (-1 == ind) {\n      ind = i;\n      continue;\n    }\n    if (co[i].size() > co[ind].size()) ind = i;\n  }\n  if (-1 == ind) {\n    cout << \"0\";\n    return;\n  }\n  cout << co[ind].size();\n}\nint main() {\n  srand((int)time(NULL));\n  LoAd();\n  SoLvE();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint parent[2002];\nint comp[2002];\nint ans[2002];\nint fp(int x) {\n  if (x == parent[x])\n    return x;\n  else\n    return parent[x] = fp(parent[x]);\n}\nint main() {\n  int n, good, bad;\n  cin >> n;\n  for (int i = 1; i < n + 1; i++) parent[i] = i;\n  cin >> good;\n  while (good--) {\n    int a, b;\n    cin >> a >> b;\n    int pa = fp(a), pb = fp(b);\n    parent[pa] = parent[pb];\n  }\n  cin >> bad;\n  while (bad--) {\n    int a, b;\n    cin >> a >> b;\n    int pa = fp(a), pb = fp(b);\n    if (pa != pb) continue;\n    parent[pa] = parent[pb];\n    comp[pa] = comp[pb] = 1;\n  }\n  int maxi = 0;\n  for (int i = 1; i < n + 1; i++) {\n    int pa = fp(i);\n    if (not comp[pa]) ans[pa]++;\n    maxi = max(maxi, ans[pa]);\n  }\n  cout << maxi << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass dsu {\n public:\n  int *id;\n  int *compSize;\n  int compCount;\n  dsu(int N) {\n    compCount = N + 1;\n    compSize = new int[compCount];\n    id = new int[compCount];\n    for (int i = 0; i <= compCount; i++) {\n      id[i] = i;\n      compSize[i] = 1;\n    }\n  }\n  int Find(int p) {\n    int root = p;\n    while (root != id[root]) root = id[root];\n    while (p != root) {\n      int newp = id[p];\n      id[p] = root;\n      p = newp;\n    }\n    return root;\n  }\n  bool Connected(int p, int q) { return Find(p) == Find(q); }\n  void Union(int p, int q) {\n    int i = Find(p);\n    int j = Find(q);\n    if (i == j) return;\n    id[i] = j;\n    compSize[j] += compSize[i];\n    compCount--;\n  }\n};\nint n, m, p, q, i, sol, rp, rq;\nint main() {\n  scanf(\"%d\", &n);\n  dsu uf(n);\n  scanf(\"%d\", &m);\n  for (i = 0; i < m; i++) {\n    scanf(\"%d %d\", &p, &q);\n    uf.Union(p, q);\n  }\n  scanf(\"%d\", &m);\n  for (i = 0; i < m; i++) {\n    scanf(\"%d %d\", &p, &q);\n    rp = uf.Find(p);\n    rq = uf.Find(q);\n    if (rp == rq) {\n      uf.compSize[rp] = 0;\n    }\n  }\n  sol = 0;\n  for (i = 1; i <= n; i++) {\n    if (i == uf.id[i]) sol = max(sol, uf.compSize[i]);\n  }\n  printf(\"%d\\n\", sol);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package contest_abbyy_easy;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.StreamTokenizer;\nimport java.io.Writer;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n/**\n * Date     : 30.04.2012\n * Time     : 10:42:51\n * Email    : denys.astanin@gmail.com\n */\n\npublic class C2 {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew C2().run();\n\t}\n\n\tint nextInt() throws IOException {\n\t\tin.nextToken();\n\t\treturn (int) in.nval;\n\t}\n\n\tString nextString() throws IOException {\n\t\tin.nextToken();\n\t\treturn (String) in.sval;\n\t}\n\n\tStreamTokenizer in;\n\tWriter writer;\n\tReader reader;\n\tprivate int count = 0;\n\tvoid run() throws IOException {\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\treader = oj ? new InputStreamReader(System.in, \"ISO-8859-1\")\n\t\t\t\t: new FileReader(\"src/contest_abbyy_easy/C2.txt\");\n\t\twriter = new OutputStreamWriter(System.out, \"ISO-8859-1\");\n\t\tin = new StreamTokenizer(new BufferedReader(reader));\n\t\tPrintWriter out = new PrintWriter(writer);\n\t\tcount = nextInt();\n\t\tint fpairs = nextInt();\n\t\tMap<Integer, Set<Integer>> friend = new HashMap<Integer, Set<Integer>>();\n\t\tMap<Integer, Set<Integer>> readyChains = new HashMap<Integer, Set<Integer>>();\n\t\tfor (int i = 0; i < fpairs; i++) {\n\t\t\tint first = nextInt();\n\t\t\tint second = nextInt();\n\t\t\tSet<Integer> lst = friend.get(first);\n\t\t\tSet<Integer> lst2 = friend.get(second);\n\t\t\tif (lst == null) {\n\t\t\t\tlst = new HashSet<Integer>();\n\t\t\t\tfriend.put(first, lst);\n\t\t\t}\n\t\t\tif (lst2 == null) {\n\t\t\t\tlst2 = new HashSet<Integer>();\n\t\t\t\tfriend.put(second, lst2);\n\t\t\t}\n\t\t\tlst.add(second);\n\t\t\tlst2.add(first);\n\t\t}\n\t\tint epairs = nextInt();\n\t\tMap<Integer, Set<Integer>> enemy = new HashMap<Integer, Set<Integer>>();\n\t\tfor (int i = 0; i < epairs; i++) {\n\t\t\tint first = nextInt();\n\t\t\tint second = nextInt();\n\t\t\tSet<Integer> lst = enemy.get(first);\n\t\t\tSet<Integer> lst2 = enemy.get(second);\n\t\t\tif (lst == null) {\n\t\t\t\tlst = new HashSet<Integer>();\n\t\t\t\tenemy.put(first, lst);\n\t\t\t}\n\t\t\tif (lst2 == null) {\n\t\t\t\tlst2 = new HashSet<Integer>();\n\t\t\t\tenemy.put(second, lst2);\n\t\t\t}\n\t\t\tlst.add(second);\n\t\t\tlst2.add(first);\n\t\t}\n\t\tint max = 0;\n\t\tfor (int i = 1; i <= count; i++) {\n\t\t\tSet<Integer> friendChain = new HashSet<Integer>();\n\t\t\tif (!readyChains.containsKey(i)) {\n\t\t\t\tfriendChain.add(i);\n\t\t\t\tdfs(friend, friendChain, i);\n\t\t\t\tfor (Integer v : friendChain) {\n\t\t\t\t\treadyChains.put(v, friendChain);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfriendChain = readyChains.get(i);\n\t\t\t}\n\n\t\t\tboolean possible = true;\n\t\t\tcycle : for (Map.Entry<Integer, Set<Integer>> entry : enemy.entrySet()) {\n\t\t\t\tfor (Integer en : entry.getValue()) {\n\t\t\t\t\tif (friendChain.contains(en) \n\t\t\t\t\t\t\t&& friendChain.contains(entry.getKey())) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak cycle;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (possible) {\n\t\t\t\tmax = Math.max(max, friendChain.size());\n\t\t\t}\n\t\t}\n\t\tout.println(max);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\tvoid dfs(Map<Integer, Set<Integer>> friend, Set<Integer> friendChain, int from) {\n\t\tSet<Integer> lst = friend.get(from);\n\t\tif (lst != null) \n\t\t\tfor (Integer v : lst) {\n\t\t\t\tif (!friendChain.contains(v)) {\n\t\t\t\t\tfriendChain.add(v);\n\t\t\t\t\tdfs(friend, friendChain, v);\n\t\t\t\t}\n\t\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "//package contest_abbyy_easy;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.StreamTokenizer;\nimport java.io.Writer;\nimport java.util.HashSet;\nimport java.util.Set;\n/**\n * Date     : 30.04.2012\n * Time     : 10:42:47\n * Email    : denys.astanin@gmail.com\n */\n\npublic class C1 {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew C1().run();\n\t}\n\n\tint nextInt() throws IOException {\n\t\tin.nextToken();\n\t\treturn (int) in.nval;\n\t}\n\n\tString nextString() throws IOException {\n\t\tin.nextToken();\n\t\treturn (String) in.sval;\n\t}\n\n\tStreamTokenizer in;\n\tWriter writer;\n\tReader reader;\n\n\tvoid run() throws IOException {\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\treader = oj ? new InputStreamReader(System.in, \"ISO-8859-1\")\n\t\t\t\t: new FileReader(\"src/contest_abbyy_easy/C1.txt\");\n\t\twriter = new OutputStreamWriter(System.out, \"ISO-8859-1\");\n\t\tin = new StreamTokenizer(new BufferedReader(reader));\n\t\tPrintWriter out = new PrintWriter(writer);\n\t\tint count = nextInt();\n\t\tint fpairs = nextInt();\n\t\tboolean[][] friend = new boolean[count + 1][count + 1];\n\t\tfor (int i = 0; i < fpairs; i++) {\n\t\t\tint first = nextInt();\n\t\t\tint second = nextInt();\n\t\t\tfriend[first][second] = true;\n\t\t\tfriend[second][first] = true;\n\t\t}\n\t\tint epairs = nextInt();\n\t\tboolean[][] enemy = new boolean[count + 1][count + 1];\n\t\tfor (int i = 0; i < epairs; i++) {\n\t\t\tint first = nextInt();\n\t\t\tint second = nextInt();\n\t\t\tenemy[first][second] = true;\n\t\t\tenemy[second][first] = true;\n\t\t}\n\t\tint max = 0;\n\t\tfor (int i = 1; i <= count; i++) {\n\t\t\tSet<Integer> friendChain = new HashSet<Integer>();\n\t\t\tfriendChain.add(i);\n\t\t\tdfs(friend, friendChain, i);\n\t\t\tboolean possible = true;\n\t\t\tcycle : for (int j = 1; j <= count; j++) {\n\t\t\t\tfor (int k = 1; k <= count; k++) {\n\t\t\t\t\tif (enemy[j][k]) {\n\t\t\t\t\t\tif (friendChain.contains(j) && friendChain.contains(k)) {\n\t\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\t\tbreak cycle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (possible) {\n\t\t\t\tmax = Math.max(max, friendChain.size());\n\t\t\t}\n\t\t}\n\t\tout.println(max);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\tvoid dfs(boolean[][] friend, Set<Integer> friendChain, int from) {\n\t\tfor (int i = 1; i < friend.length; ++i) {\n\t\t\tif (friend[from][i] && !friendChain.contains(i)) {\n\t\t\t\tfriendChain.add(i);\n\t\t\t\tdfs(friend, friendChain, i);\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.max;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        run();\n        end();\n    }\n\n    static int[] DSU;\n    static int max = 0;\n\n    static void run() throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        DSU = new int[n];\n        for (int i = 0; i < n; i++)\n            DSU[i] = i;\n        for (int i = 0; i < m; i++)\n            build(nextInt() - 1, nextInt() - 1);\n        int k = nextInt();\n        int[][] bad = new int[k][2];\n        for (int i = 0; i < k; i++) {\n            bad[i][0] = nextInt()-1;\n            bad[i][1] = nextInt()-1;\n        }\n        for (int i = 0; i < n; i++)\n            find(i);\n        int[] parent = new int[n];\n        for (int i = 0; i < n; i++)\n            ++parent[DSU[i]];\n        boolean[] used = new boolean[n];\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            int par = find(i);\n            if (!used[i]) {\n                used[i] = true;\n                boolean ok = true;\n                for (int j = 0; j < k; j++) {\n                    int first = find(bad[j][0]);\n                    int second = find(bad[j][1]);\n                    if ((first == par) || (second == par))\n                        if (first == second) {\n                            ok = false;\n                            break;\n                        }\n                }\n                if (ok)\n                    max = max(max, parent[par]);\n            }\n        }\nout.println(max);\n    }\n\n    static void build(int a, int b) {\n        int f = find(a);\n        int s = find(b);\n        if (s != f)\n            DSU[s] = f;\n    }\n\n    static int find(int a) {\n        if (DSU[a] == a)\n            return a;\n        DSU[a] = find(DSU[a]);\n        return DSU[a];\n    }\n\n    static long stepenb(long a, long b) {\n        long h = 1;\n        while (b > 0) {\n            if (b % 2 != 0) {\n                h *= a;\n                b--;\n            }\n            b /= 2;\n            a *= a;\n        }\n        return h;\n    }\n\n    static long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    private static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    static void end() {\n        out.flush();\n        out.close();\n    }\n\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n    static PrintWriter out = new PrintWriter(System.out);\n\n    static StringTokenizer in = new StringTokenizer(\"\");\n\n    public static String nextToken() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            String s = br.readLine();\n            if (s == null) return null;\n            in = new StringTokenizer(s);\n        }\n        return in.nextToken();\n    }\n\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class ABBYY_Cup_2012_Div2_C implements Runnable {\n\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new ABBYY_Cup_2012_Div2_C(), \"\", 256 * (1L << 20)).start();\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tlong startTime = System.currentTimeMillis();\n\t\t\tif (ONLINE_JUDGE) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t} else {\n\t\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t\t}\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t\tlong freeMemory = Runtime.getRuntime().freeMemory();\n\t\t\tlong totalMemory = Runtime.getRuntime().totalMemory();\n\t\t\tlong endTime = System.currentTimeMillis();\n\t\t\tSystem.err.println(\"Time = \" + (endTime - startTime));\n\t\t\tSystem.err.println(\"Memory = \" + ((totalMemory - freeMemory) >> 10));\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\n\tString readString() throws IOException {\n\t\twhile (!tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tint readInt() throws IOException {\n\t\treturn Integer.parseInt(readString());\n\t}\n\n\tlong readLong() throws IOException {\n\t\treturn Long.parseLong(readString());\n\t}\n\n\tdouble readDouble() throws IOException {\n\t\treturn Double.parseDouble(readString());\n\t}\n\t\n\tvoid debug(Object... o) {\n\t\tif (!ONLINE_JUDGE) {\n\t\t\tSystem.err.println(Arrays.deepToString(o));\n\t\t}\n\t}\n\n\t/** http://pastebin.com/j0xdUjDn */\n\tstatic class Utils {\n\n\t\tprivate Utils() {}\n\n\t\tpublic static void mergeSort(int[] a) {\n\t\t\tmergeSort(a, 0, a.length - 1);\n\t\t}\n\n\t\tprivate static final int MAGIC_VALUE = 50;\n\n\t\tprivate static void mergeSort(int[] a, int leftIndex, int rightIndex) {\n\t\t\tif (leftIndex < rightIndex) {\n\t\t\t\tif (rightIndex - leftIndex <= MAGIC_VALUE) {\n\t\t\t\t\tinsertionSort(a, leftIndex, rightIndex);\n\t\t\t\t} else {\n\t\t\t\t\tint middleIndex = (leftIndex + rightIndex) / 2;\n\t\t\t\t\tmergeSort(a, leftIndex, middleIndex);\n\t\t\t\t\tmergeSort(a, middleIndex + 1, rightIndex);\n\t\t\t\t\tmerge(a, leftIndex, middleIndex, rightIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {\n\t\t\tint length1 = middleIndex - leftIndex + 1;\n\t\t\tint length2 = rightIndex - middleIndex;\n\t\t\tint[] leftArray = new int[length1];\n\t\t\tint[] rightArray = new int[length2];\n\t\t\tSystem.arraycopy(a, leftIndex, leftArray, 0, length1);\n\t\t\tSystem.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n\t\t\tfor (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n\t\t\t\tif (i == length1) {\n\t\t\t\t\ta[k] = rightArray[j++];\n\t\t\t\t} else if (j == length2) {\n\t\t\t\t\ta[k] = leftArray[i++];\n\t\t\t\t} else {\n\t\t\t\t\ta[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void insertionSort(int[] a, int leftIndex, int rightIndex) {\n\t\t\tfor (int i = leftIndex + 1; i <= rightIndex; i++) {\n\t\t\t\tint current = a[i];\n\t\t\t\tint j = i - 1;\n\t\t\t\twhile (j >= leftIndex && a[j] > current) {\n\t\t\t\t\ta[j + 1] = a[j];\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\ta[j + 1] = current;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// solution\n\t\n\tvoid solve() throws IOException {\n\t\tint n = readInt();\n\t\tint k = readInt();\n\t\tint[][] a = new int[n][n];\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint x = readInt() - 1;\n\t\t\tint y = readInt() - 1;\n\t\t\ta[x][y] = a[y][x] = 1;\n\t\t}\n\t\tint m = readInt();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x = readInt() - 1;\n\t\t\tint y = readInt() - 1;\n\t\t\ta[x][y] = a[y][x] = -1;\n\t\t}\n\t\tboolean[] vis = new boolean[n];\n\t\tint best = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tx.clear();\n\t\t\t\tdfs(i, vis, a, n);\n\t\t\t\tif (good(a)) {\n\t\t\t\t\tbest = max(best, x.size());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(best);\n\t}\n\t\n\tprivate boolean good(int[][] a) {\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tint z = x.get(i);\n\t\t\tfor (int j = 0; j < x.size(); j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tint y = x.get(j);\n\t\t\t\t\tif (a[z][y] == -1) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tList<Integer> x = new ArrayList<Integer>();\n\t\n\tprivate void dfs(int i, boolean[] vis, int[][] a, int n) {\n\t\tvis[i] = true;\n\t\tx.add(i);\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (a[i][j] == 1) {\n\t\t\t\tif (!vis[j]) {\n\t\t\t\t\tdfs(j, vis, a, n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N_MAX = 2020;\nint n, m, k;\nbool used[N_MAX], nenr[N_MAX][N_MAX];\nvector<int> druz[N_MAX];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> m;\n  while (m--) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    druz[a].push_back(b);\n    druz[b].push_back(a);\n  }\n  cin >> k;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      nenr[i][j] = false;\n    }\n  }\n  while (k--) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    nenr[a][b] = true;\n    nenr[b][a] = true;\n  }\n  for (int i = 0; i < n; i++) {\n    used[i] = false;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (!used[i]) {\n      vector<int> grp;\n      queue<int> q;\n      used[i] = true;\n      q.push(i);\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        grp.push_back(v);\n        for (auto u : druz[v]) {\n          if (!used[u]) {\n            q.push(u);\n            used[u] = true;\n          }\n        }\n      }\n      bool jojo = true;\n      for (auto v : grp) {\n        for (auto u : grp) {\n          jojo &= !nenr[v][u];\n        }\n      }\n      if (jojo) {\n        ans = max(ans, (int)grp.size());\n      }\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, vector<int> > like;\nmap<int, vector<int> > dislike;\nvector<int> memo_all;\nvector<int> memo;\nint dfs(int &n) {\n  int r = 1, s;\n  vector<int> v = like[n];\n  for (int i = 0; i < v.size(); i++) {\n    if (find(memo_all.begin(), memo_all.end(), v[i]) == memo_all.end()) {\n      memo.push_back(v[i]);\n      memo_all.push_back(v[i]);\n      s = dfs(v[i]);\n      if (!s) return 0;\n      r += s;\n    }\n  }\n  return r;\n}\nint main() {\n  int n, k, x, y;\n  for (scanf(\"%d%d\", &n, &k); k; k--) {\n    scanf(\"%d%d\", &x, &y);\n    like[x].push_back(y);\n    like[y].push_back(x);\n  }\n  for (scanf(\"%d\", &k); k; k--) {\n    scanf(\"%d%d\", &x, &y);\n    dislike[x].push_back(y);\n    dislike[y].push_back(x);\n  }\n  for (x = 0, y = 1; y <= n; y++) {\n    if (find(memo_all.begin(), memo_all.end(), y) == memo_all.end()) {\n      memo.clear();\n      memo.push_back(y);\n      memo_all.push_back(y);\n      k = dfs(y);\n      for (int i = 0; i < memo.size() - 1; i++)\n        for (int j = i + 1; j < memo.size(); j++) {\n          if (find(dislike[memo[i]].begin(), dislike[memo[i]].end(), memo[j]) !=\n              dislike[memo[i]].end())\n            goto next;\n        }\n      if (x < k) x = k;\n    }\n  next:;\n  }\n  printf(\"%d\\n\", x);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint f[100100], kl[100100], used[100100], K;\nvector<int> g[100100];\nvoid dfs(int v) {\n  used[v] = K;\n  kl[K]++;\n  for (int i = 0; i < g[v].size(); i++)\n    if (!used[g[v][i]]) dfs(g[v][i]);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, k, m;\n  cin >> n >> k;\n  for (int i = 0; i < k; i++) {\n    int x, y;\n    cin >> x >> y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!used[i]) {\n      K++;\n      dfs(i);\n    }\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    if (used[x] == used[y]) f[used[x]] = 1;\n  }\n  int ans = 0;\n  for (int i = 1; i <= K; i++) {\n    if (!f[i]) ans = max(ans, kl[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> groups;\nbool visited[2001];\nint group_num[2001];\nvector<int> graph[2001];\nvoid dfs(vector<int> &group, int i) {\n  visited[i] = 1;\n  group.push_back(i);\n  for (int v : graph[i]) {\n    if (!visited[v]) dfs(group, v);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  long long n, k, u, v, i = 1, m;\n  vector<int> group_len;\n  cin >> n >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> u >> v;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n  for (int i = 0; i < n + 1; i++) visited[i] = 0;\n  for (int i = 1; i < n + 1; i++) {\n    if (!visited[i]) {\n      vector<int> group;\n      dfs(group, i);\n      groups.push_back(group);\n    }\n  }\n  for (vector<int> temp : groups) {\n    for (int v : temp) group_num[v] = i;\n    group_len.push_back(temp.size());\n    i++;\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> u >> v;\n    if (group_num[u] == group_num[v]) group_len[group_num[u] - 1] = 0;\n  }\n  cout << *max_element(group_len.begin(), group_len.end());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, like, dislike, a, b, flag[2005], jum[2005];\nint main() {\n  while (scanf(\"%d\", &n) != EOF) {\n    vector<int> vec1[2005];\n    vector<pair<int, int> > vec2;\n    scanf(\"%d\", &like);\n    for (int i = 0; i < like; i++) {\n      scanf(\"%d %d\", &a, &b);\n      vec1[a].push_back(b);\n      vec1[b].push_back(a);\n    }\n    scanf(\"%d\", &dislike);\n    for (int i = 0; i < dislike; i++) {\n      scanf(\"%d %d\", &a, &b);\n      vec2.push_back(make_pair(a, b));\n    }\n    memset(flag, -1, sizeof(flag));\n    memset(jum, 0, sizeof(jum));\n    int pos = 0;\n    for (int i = 1; i <= n; i++) {\n      if (flag[i] == -1) {\n        pos++;\n        queue<pair<int, int> > q;\n        q.push(make_pair(i, pos));\n        flag[i] = pos;\n        while (!q.empty()) {\n          pair<int, int> tmp;\n          tmp = q.front();\n          q.pop();\n          int v = tmp.first, curr = tmp.second;\n          for (int j = 0; j < vec1[v].size(); j++) {\n            if (flag[vec1[v][j]] == -1) {\n              flag[vec1[v][j]] = curr;\n              q.push(make_pair(vec1[v][j], curr));\n            }\n          }\n        }\n      }\n    }\n    for (int i = 1; i <= 2000; i++) jum[flag[i]]++;\n    for (int i = 0; i < vec2.size(); i++) {\n      if (flag[vec2[i].first] == flag[vec2[i].second]) {\n        jum[flag[vec2[i].first]] = 0;\n      }\n    }\n    int res = 0;\n    for (int i = 1; i <= 2000; i++) {\n      res = max(res, jum[i]);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\n\npublic class Main {\n    \n    /**\n     * @param args\n     */\n        \n        BufferedReader in;\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer tok;\n         String readToken() throws IOException { // reads the token; to read a full line use in.readLine()\n        while (tok == null || !tok.hasMoreTokens()) {\n        tok = new StringTokenizer(in.readLine());\n            \n        }\n        return tok.nextToken(); // sometimes it's better to use nextToken(String) method here\n        }\n         int readInt() throws IOException { // write readDouble(), readLong(), readlong() methods if necessary\n        return Integer.parseInt(readToken());\n        }\n         long readLong() throws IOException { // write readDouble(), readLong(), readlong() methods if necessary\n            return Long.parseLong(readToken());\n            }\n         public String readLine() throws IOException{\n            return in.readLine();\n             \n         }\n         double readDouble() throws IOException { // write readDouble(), readLong(), readlong() methods if necessary\n                return Double.parseDouble(readToken());\n                }\n        public static void main(String[] args) throws IOException\n        {\n           new Main().run();\n        }\n       \n        void run() throws IOException\n        {\n        \n             in = new BufferedReader(new InputStreamReader(System.in));\n                \n            \n            out = new PrintWriter(new OutputStreamWriter(System.out));\n           solve();\n           out.flush();\n           tok=null;\n        }\n        \n    void solve()  throws IOException{     \n        /*\n         * des spoj rainbow ride gt:   metaferw mono sinistwses\n         *arxika kanw enan grafo me akmes (a,b) an eiani filoi\n         *briskw  tis sinistwses\n         *meta gia kathe zeugos  (c,d) misiountai\n         *blepw an einai stin idia sinistwsa\n         *an einai, akirwnw tin sinistwsa afou dn borei na prosferei tpt parapanw...\n         */\n        int n=readInt();\n        ArrayList<ArrayList<Integer>> edges=new ArrayList<ArrayList<Integer>>(n);\n        int[] cc=new int[n];\n        int ncc=0;\n        int[] sz=new int[n];\n        int[] toVisit=new int[n];\n        for (int i=0;i<n;++i){\n            cc[i]=-1;\n            edges.add(new ArrayList<Integer>());\n        }\n        int k=readInt();\n        for (int i=0;i<k;++i){\n            int a=readInt()-1;\n            int b=readInt()-1;\n            edges.get(a).add(b);\n            edges.get(b).add(a);\n        }\n        int pos=0;\n        int cpos=0;\n        for (int i=0;i<n;++i){\n            if (cc[i]==-1){\n                \n                int s=0;\n                toVisit[pos++]=i;\n                cc[i]=ncc;\n                while (cpos<pos){\n                    s++;\n                    int x=toVisit[cpos++];\n                    for (Integer g: edges.get(x)){\n                        if (cc[g]==-1){\n                            toVisit[pos++]=g;\n                            cc[g]=ncc;\n                        }\n                    }\n                }\n                sz[ncc]=s;\n                ncc++;\n            }\n        }\n        int m=readInt();\n        for (int i=0;i<m;++i){\n            int a=readInt()-1;\n            int b=readInt()-1;\n            if (cc[a]==cc[b]){\n                sz[cc[a]]=-1;\n            }\n        }\n        int max=0;\n        for (int i=0;i<ncc;++i){\n            if (sz[i]>=0){\n                max=Math.max(max,sz[i]);\n            }\n        }\n        out.println(max);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2005;\nconst int inf = 1 << 29;\nconst double eps = 1e-8;\nint par[maxn], siz[maxn];\nbool vis[maxn];\nint findset(int x) {\n  if (par[x] != x) par[x] = findset(par[x]);\n  return par[x];\n}\nvoid unionset(int x, int y) {\n  int fx = findset(x);\n  int fy = findset(y);\n  if (fx == fy)\n    return;\n  else {\n    par[fx] = fy;\n    siz[fy] += siz[fx];\n  }\n}\nint main() {\n  int n, k, m, a, b;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    par[i] = i;\n    siz[i] = 1;\n  }\n  scanf(\"%d\", &k);\n  while (k--) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    unionset(a, b);\n  }\n  scanf(\"%d\", &m);\n  while (m--) {\n    scanf(\"%d%d\", &a, &b);\n    if (findset(a) == findset(b)) {\n      vis[findset(a)] = 1;\n    }\n  }\n  int res = 0;\n  for (int i = 1; i <= n; i++) {\n    if (par[i] == i && !vis[i]) {\n      res = max(res, siz[i]);\n    }\n  }\n  printf(\"%d\\n\", res);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, K;\nint A, B;\nstruct UnionFind {\n  int par[2000], ra[2000];\n  UnionFind() {\n    for (int(i) = 0; (i) < (2000); (i)++) par[i] = i, ra[i] = 1;\n  }\n  int find(int x) { return par[x] == x ? x : par[x] = find(par[x]); }\n  bool same(int a, int b) { return find(a) == find(b); }\n  void unite(int a, int b) {\n    if ((a = find(a)) != (b = find(b))) {\n      if (ra[a] < ra[b]) swap(a, b);\n      par[b] = a;\n      ra[a] += ra[b];\n    }\n  }\n} uf;\nbool cant[2000];\nint main() {\n  scanf(\"%d\", &N);\n  scanf(\"%d\", &K);\n  while (K--) scanf(\"%d%d\", &A, &B), uf.unite(A - 1, B - 1);\n  scanf(\"%d\", &K);\n  while (K--) {\n    scanf(\"%d%d\", &A, &B);\n    A = uf.find(A - 1), B = uf.find(B - 1);\n    if (A == B) uf.ra[A] = 0;\n  }\n  int res = 0;\n  for (int(i) = 0; (i) < (N); (i)++)\n    if (uf.find(i) == i) res = max(res, uf.ra[i]);\n  printf(\"%d\\n\", res);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k;\nint p[111111];\nint s[111111];\nint P(int first) {\n  return ((p[first] == first) ? (first) : (p[first] = P(p[first])));\n}\ninline void U(int first, int second) {\n  first = P(first);\n  second = P(second);\n  if (rand() % 2) {\n    p[first] = second;\n    s[second] += s[first];\n  } else {\n    p[second] = first;\n    s[first] += s[second];\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) p[i] = i, s[i] = 1;\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; ++i) {\n    int first, second;\n    scanf(\"%d%d\", &first, &second);\n    --first;\n    --second;\n    if (P(first) != P(second)) U(first, second);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; ++i) {\n    int first, second;\n    scanf(\"%d%d\", &first, &second);\n    --first;\n    --second;\n    if (P(first) == P(second)) s[P(first)] = 0;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; ++i)\n    if (P(i) == i) ans = max(ans, s[i]);\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n/**\n * Created with IntelliJ IDEA.\n * Author   : Dylan\n * Date     : 2013-08-10\n * Time     : 14:40\n * Project  : Party 3\n */\n\npublic class Main {\n    static LinkedList<Integer>[] graph;\n    static LinkedList<Integer>[] enemy;\n    static boolean[] visited;\n    static HashSet<Integer> enemySet;\n    static int n, current, max;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        graph = new LinkedList[n + 1];\n        enemy = new LinkedList[n + 1];\n        for (int i = 1; i <= n; i++) {\n            graph[i] = new LinkedList<Integer>();\n            enemy[i] = new LinkedList<Integer>();\n        }\n        int k = in.nextInt();\n        while (k-- > 0) {\n            int x = in.nextInt();\n            int y = in.nextInt();\n            graph[x].add(y);\n            graph[y].add(x);\n        }\n        k = in.nextInt();\n        while (k-- > 0) {\n            int x = in.nextInt();\n            int y = in.nextInt();\n            enemy[x].add(y);\n            enemy[y].add(x);\n        }\n        visited = new boolean[n + 1];\n        enemySet = new HashSet<Integer>(n);\n        max = 0;\n        for (int i = 1; i <= n; i++) {\n            if (visited[i]) continue;\n            current = 0;\n            if (dfs(i)) max = Math.max(max, current);\n            enemySet.clear();\n        }\n        System.out.println(max);\n    }\n\n    static boolean dfs(int x) {\n        boolean res = true;\n        visited[x] = true;\n        if (enemySet.contains(x)) return false;\n        current++;\n        for (int i : enemy[x])\n            enemySet.add(i);\n        for (int i : graph[x]) {\n            if (visited[i]) continue;\n            res = res && dfs(i);\n        }\n        return res;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> like[2000 + 1];\nvector<int> dislike[2000 + 1];\nint main() {\n  int n, m1, m2;\n  cin >> n >> m1;\n  for (int i = 0; i < m1; i++) {\n    int a, b;\n    cin >> a >> b;\n    like[a].push_back(b);\n    like[b].push_back(a);\n  }\n  cin >> m2;\n  for (int i = 0; i < m2; i++) {\n    int a, b;\n    cin >> a >> b;\n    dislike[a].push_back(b);\n    dislike[b].push_back(a);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int ans1 = 0;\n    bool vis[2000 + 1];\n    memset(vis, false, sizeof vis);\n    vis[i] = true;\n    queue<int> q;\n    queue<int> q1;\n    q.push(i);\n    q1.push(i);\n    while (!q.empty()) {\n      int cur = q.front();\n      ans1++;\n      q1.push(cur);\n      q.pop();\n      for (int j = 0; j < int(like[cur].size()); j++) {\n        if (!vis[like[cur][j]]) {\n          vis[like[cur][j]] = true;\n          q.push(like[cur][j]);\n        }\n      }\n    }\n    bool sw1 = true;\n    while (!q1.empty()) {\n      bool sw = true;\n      int cur = q1.front();\n      q1.pop();\n      for (int j = 0; j < int(dislike[cur].size()); j++)\n        if (vis[dislike[cur][j]]) {\n          sw = false;\n          break;\n        }\n      if (!sw) {\n        sw1 = false;\n        break;\n      }\n    }\n    if (!sw1) continue;\n    ans = max(ans, ans1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> v(100002);\nvector<int> vis(100002);\nvector<int> dfs(int src) {\n  stack<int> st;\n  st.push(src);\n  vector<int> sts;\n  vis[src] = 1;\n  sts.push_back(src);\n  while (!st.empty()) {\n    int x = st.top();\n    st.pop();\n    if (!vis[x]) {\n      sts.push_back(x);\n      vis[x] = 1;\n    }\n    for (int i = 0; i < v[x].size(); i++) {\n      if (vis[v[x][i]] == 0) st.push(v[x][i]);\n    }\n  }\n  return sts;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m;\n  cin >> n >> m;\n  fill(vis.begin(), vis.end(), 0);\n  for (int i = 0; i < v.size(); i++) v[i].clear();\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  vector<vector<int>> dis(1000005);\n  int k;\n  cin >> k;\n  while (k--) {\n    int a, b;\n    cin >> a >> b;\n    dis[a].push_back(b);\n    dis[b].push_back(a);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      vector<int> tr = dfs(i);\n      sort(tr.begin(), tr.end());\n      int f = 0;\n      for (int i = 0; i < tr.size(); i++) {\n        for (int j = 0; j < dis[tr[i]].size(); j++) {\n          if (dis[tr[i]][j] != 0) {\n            int disx = dis[tr[i]][j];\n            if (binary_search(tr.begin(), tr.end(), disx)) {\n              f = 1;\n              break;\n            }\n          }\n        }\n      }\n      if (f == 0) {\n        int xx = tr.size();\n        ans = max(ans, xx);\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int oo = 1 << 20;\nconst double PI = M_PI;\nconst double EPS = 1e-15;\nconst int MaxN = 3001;\nint N, A, B;\nvector<int> G[MaxN];\nbool M[MaxN][MaxN];\nbool visited[MaxN];\nint comp[MaxN], size;\nvoid dfs(int u) {\n  comp[size++] = u;\n  visited[u] = true;\n  for (int i = (int)G[u].size() - 1; i >= 0; i--) {\n    int w = G[u][i];\n    if (!visited[w]) dfs(w);\n  }\n}\nint main() {\n  cin.sync_with_stdio(false);\n  cin >> N;\n  cin >> A;\n  for (int i = 0; i < (A); i++) {\n    int u, v;\n    cin >> u >> v;\n    G[u - 1].push_back(v - 1);\n    G[v - 1].push_back(u - 1);\n  }\n  cin >> B;\n  for (int i = 0; i < (B); i++) {\n    int u, v;\n    cin >> u >> v;\n    M[u - 1][v - 1] = true;\n    M[v - 1][u - 1] = true;\n  }\n  int answer = 0;\n  for (int i = 0; i < (N); i++)\n    if (!visited[i]) {\n      size = 0;\n      dfs(i);\n      bool valid = true;\n      for (int j = 0; j < (size); j++) {\n        for (int k = 0; k < (j); k++)\n          if (M[comp[j]][comp[k]]) {\n            valid = false;\n            break;\n          }\n        if (!valid) break;\n      }\n      if (valid) answer = max(answer, size);\n    }\n  cout << answer << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long amount, k, m, x, y, *block_in_stack, res, max;\n  char *object;\n  bool *obj;\n  cin >> amount >> k;\n  object = new char[amount * amount];\n  obj = new bool[amount];\n  block_in_stack = new long[amount];\n  for (long i = 0; i < amount; i++) obj[i] = 0;\n  for (long i = 0; i < amount * amount; i++) {\n    object[i] = 0;\n  }\n  for (long i = 0; i < k; i++) {\n    cin >> x >> y;\n    object[amount * (x - 1) + y - 1] = object[amount * (y - 1) + x - 1] = 1;\n  }\n  cin >> m;\n  for (long i = 0; i < m; i++) {\n    cin >> x >> y;\n    object[amount * (x - 1) + y - 1] = object[amount * (y - 1) + x - 1] = 2;\n  }\n  max = 0;\n  bool flag;\n  for (long i = 0; i < amount; i++) {\n    res = 0;\n    flag = 1;\n    if (!obj[i]) {\n      obj[i] = 1;\n      block_in_stack[res] = i;\n      res++;\n      for (long place = 0; place < res; place++) {\n        for (long j = 0; j < amount; j++) {\n          if (object[j * amount + block_in_stack[place]] == 1 && !obj[j]) {\n            obj[j] = 1;\n            block_in_stack[res] = j;\n            res++;\n          }\n        }\n      }\n    }\n    for (long place = 0; place < res; place++) {\n      for (long j = 0; j < res; j++) {\n        if (object[block_in_stack[j] * amount + block_in_stack[place]] == 2)\n          flag = 0;\n      }\n    }\n    if (res > max && flag) max = res;\n  }\n  cout << max << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Solution {\n  Scanner in;\n\n  public void solve(\n    boolean[][] friends,\n    boolean[][] haters,\n    int n\n  ) {\n    int[] groupIds = new int[n];\n\n    int maxGroupSize = 0;\n    int curGroupId = 1;\n\n    for (int i = 0; i < n; i++) {\n      if (groupIds[i] != 0) {\n        // Already visited\n        continue;\n      }\n\n      ArrayDeque<Integer> stack = new ArrayDeque<>();\n      stack.push(i);\n      groupIds[i] = curGroupId;\n      int groupSize = 1;\n      boolean groupInvalid = false;\n      while (stack.size() != 0) {\n        int curPerson = stack.pop();\n\n        for (int hater = 0; hater < n; hater++) {\n          if (!haters[curPerson][hater]) {\n            continue;\n          }\n          if (groupIds[hater] == groupIds[curPerson]) {\n            groupInvalid = true;\n          }\n        }\n        for (int friend = 0; friend < n; friend++) {\n          if (!friends[curPerson][friend]) {\n            continue;\n          }\n          if (groupIds[friend] != 0) {\n            continue;\n          }\n          groupIds[friend] = curGroupId;\n          stack.push(friend);\n          groupSize += 1;\n        }\n      }\n\n      groupSize = groupInvalid ? -1 : groupSize;\n      if (groupSize > maxGroupSize) {\n        maxGroupSize = groupSize;\n      }\n\n      curGroupId += 1;\n    }\n\n    System.out.println(maxGroupSize);\n  }\n\n  public void run() {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n\n    boolean[][] friends = new boolean[n][n];\n    boolean[][] haters = new boolean[n][n];\n\n    int k = in.nextInt();\n    for (int i = 0; i < k; i++) {\n      int from = in.nextInt() - 1;\n      int to = in.nextInt() - 1;\n      friends[from][to] = true;\n      friends[to][from] = true;\n    }\n\n    int m = in.nextInt();\n    for (int i = 0; i < m; i++) {\n      int from = in.nextInt() - 1;\n      int to = in.nextInt() - 1;\n      haters[from][to] = true;\n      haters[to][from] = true;\n    }\n\n    solve(friends, haters, n);\n  }\n\n  public static void main(String[] args) {\n    new Solution().run();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Main implements Runnable {\n    \n    boolean[] visited;\n    \n    public void solve() throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        int[] p = new int[n];\n        //Arrays.fill(p, -1);\n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n        }\n        for (int i = 0; i < m; i++) {\n            int a = nextInt() - 1;\n            int b = nextInt() - 1;\n            merge(p, a, b);\n        }\n        m = nextInt();\n        int[] size = new int[n];\n        for (int i = 0; i < n; i++) {\n            ++size[get(p, i)];\n        }\n        boolean[] can = new boolean[n];\n        Arrays.fill(can, true);\n        for (int i = 0; i < m; i++) {\n            int a = nextInt() - 1;\n            int b = nextInt() - 1;\n            if (get(p, a) == get(p, b)) {\n                can[get(p, a)] = false;\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (can[i]) {\n                ans = Math.max(ans, size[i]);\n            }\n        }\n        System.out.println(ans);\n    }\n    \n    void dfs(boolean[][] board, int ind) {\n        visited[ind] = true;\n        for (int i = 0; i < board.length; i++) {\n            if (board[ind][i] && !visited[i]) {\n                dfs(board, i);\n            }\n        }\n        \n    }\n    \n    int answer(int[] a, int[] b) {\n        int n = a.length;\n        b = b.clone();\n        a = a.clone();\n        for (int i = 0; i < n; i++) {\n            if (b[i] >= 0) {\n                merge(a, i, b[i]);\n            }\n        }\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] < 0) {\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n    \n    void merge(int[] arr, int a, int b) {\n        a = get(arr, a);\n        b = get(arr, b);\n        if (a != b) {\n            arr[a] = b;\n        }\n    }\n    \n    int get(int[] arr, int a) {\n        if (arr[a] == a) {\n            return a;\n        }\n        return arr[a] = get(arr, arr[a]);\n    }\n    \n    void shuffle(int[] a) {\n        int N = a.length;\n        for (int i = 0; i < N / 2; i++) {\n            int j = (int) (Math.random() * N);\n            int t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n        }\n    }\n    \n    void print(int[] a) {\n        System.out.println();\n        for (int i = 0; i < a.length; i++) {\n            System.out.print(a[i] + \" \");\n        }\n    }\n    \n    void print(int[][] arr) {\n        System.out.println();\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[i].length; j++) {\n                System.out.print(arr[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n    \n    boolean nextPermutation(int[] arr) {\n        int f = -1;\n        for (int i = arr.length - 2; i >= 0; i--) {\n            if (arr[i + 1] > arr[i]) {\n                f = i;\n                break;\n            }\n        }\n        if (f == -1) {\n            return false;\n        }\n        int s = -1;\n        for (int i = arr.length - 1; i >= 0; i--) {\n            if (arr[i] > arr[f]) {\n                s = i;\n                break;\n            }\n        }\n        int d = arr[f];\n        arr[f] = arr[s];\n        arr[s] = d;\n        \n        f++;\n        int l = arr.length - 1;\n        while (f < l) {\n            d = arr[f];\n            arr[f] = arr[l];\n            arr[l] = d;\n            f++;\n            l--;\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------\n    public static void main(String[] args) {\n        new Main().run();\n    }\n    \n    public void run() {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            tok = null;\n            solve();\n            in.close();\n        } catch (IOException e) {\n            System.exit(0);\n        }\n    }\n    \n    public String nextToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n    \n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    \n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    \n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    BufferedReader in;\n    StringTokenizer tok;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> E[2005];\nint belong[2000 + 5], used[2000 + 5];\nint group[2000 + 5], cnt[2000 + 4];\nvoid dfs(int p, int d) {\n  int i;\n  if (used[p] == 1) return;\n  used[p] = 1;\n  belong[p] = d;\n  for (i = 0; i < E[p].size(); i++) dfs(E[p][i], d);\n}\nint main() {\n  int i, j, k;\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (i = 1; i <= m; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    E[a].push_back(b);\n    E[b].push_back(a);\n  }\n  int idx = 0;\n  for (i = 1; i <= n; i++) {\n    if (used[i] == 0) {\n      idx++;\n      dfs(i, idx);\n    }\n  }\n  int mm = 0;\n  scanf(\"%d\", &mm);\n  for (i = 1; i <= n; i++) {\n    cnt[belong[i]]++;\n  }\n  for (i = 1; i <= mm; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    if (belong[a] == belong[b]) group[belong[a]] = 1;\n  }\n  int Max = 0;\n  for (i = 1; i <= idx; i++) {\n    if (group[i] == 0) {\n      if (cnt[i] > Max) Max = cnt[i];\n    }\n  }\n  printf(\"%d\\n\", Max);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n\tBufferedReader in;\n\tStringTokenizer st;\n\tPrintWriter out;\n\n\tString next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws Exception {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() throws Exception {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() throws Exception {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tint g[][], used[], n;\n\n\tvoid dfs(int v, int c) {\n\t\tused[v] = c;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (used[i] == 0 && g[i][v] == 1)\n\t\t\t\tdfs(i, c);\n\t}\n\n\tvoid solve() throws Exception {\n\t\tn = nextInt();\n\t\tg = new int[n][n];\n\t\tint fc = nextInt();\n\t\tfor (int i = 0; i < fc; i++) {\n\t\t\tint q = nextInt() - 1, w = nextInt() - 1;\n\t\t\tg[q][w] = 1;\n\t\t\tg[w][q] = 1;\n\t\t}\n\t\tint ec = nextInt();\n\t\tfor (int i = 0; i < ec; i++) {\n\t\t\tint q = nextInt() - 1, w = nextInt() - 1;\n\t\t\tg[q][w] = -1;\n\t\t\tg[w][q] = -1;\n\t\t}\n\t\tused = new int[n];\n\t\tArrays.fill(used, 0);\n\t\tint clr = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// Arrays.fill(used, 0);\n\t\t\tif (used[i] == 0)\n\t\t\t\tdfs(i, clr++);\n\t\t}\n\t\tint size[] = new int[n + 1];\n\t\tint able[] = new int[n + 1];\n\t\tArrays.fill(able, 1);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsize[used[i]]++;\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j && used[i] == used[j] && g[i][j] == -1)\n\t\t\t\t\table[used[i]] = 0;\n\t\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tans = Math.max(ans, size[i] * able[i]);\n\n\t\tout.println(ans);\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\t\tReader reader = oj ? new InputStreamReader(System.in) : new FileReader(\"input.txt\");\n\t\t\tWriter writer = oj ? new OutputStreamWriter(System.out) : new FileWriter(\"output.txt\");\n\t\t\tin = new BufferedReader(reader);\n\t\t\tout = new PrintWriter(writer);\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew C().run();\n\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000 + 100;\nint fa[N];\nint Find(int x) { return fa[x] < 0 ? x : fa[x] = Find(fa[x]); }\nvoid Union(int x, int y) {\n  int rx = Find(x);\n  int ry = Find(y);\n  if (rx != ry) {\n    fa[rx] += fa[ry];\n    fa[ry] = rx;\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &(n));\n  memset((fa), -1, sizeof(fa));\n  int m;\n  scanf(\"%d\", &(m));\n  while (m--) {\n    int x, y;\n    scanf(\"%d\", &(x)), scanf(\"%d\", &(y));\n    Union(x, y);\n  }\n  int k;\n  scanf(\"%d\", &(k));\n  int cant[N];\n  memset((cant), 0, sizeof(cant));\n  while (k--) {\n    int x, y;\n    scanf(\"%d\", &(x)), scanf(\"%d\", &(y));\n    if (Find(x) == Find(y)) cant[Find(x)] = 1;\n  }\n  int ans = 0;\n  for (int i(1), _h(n); i <= _h; ++i)\n    if (Find(i) == i) {\n      if (!cant[i] && -fa[i] > ans) ans = -fa[i];\n    }\n  printf(\"%d\\n\", (ans));\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author \u0414\u043e\u043c\u0430\u0448\u043d\u0438\u0439\n */\nimport java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.ArrayList;\nimport static java.lang.Math.*;\n\npublic class A {\n\n        final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\")!=null;\n        BufferedReader in;\n        PrintWriter out;\n        StringTokenizer tok = new StringTokenizer(\"\");\n\n        void init() throws FileNotFoundException{\n                if (ONLINE_JUDGE){\n                        in = new BufferedReader(new InputStreamReader(System.in));\n                        out = new PrintWriter(System.out);\n                }else{\n                        in = new BufferedReader(new FileReader(\"input.txt\"));\n                        out = new PrintWriter(\"output.txt\");\n                }\n        }\n\n        String readString() throws IOException{\n                while(!tok.hasMoreTokens()){\n                        tok = new StringTokenizer(in.readLine());\n                }\n                return tok.nextToken();\n        }\n\n        int readInt() throws IOException{\n                return Integer.parseInt(readString());\n        }\n\n        long readLong() throws IOException{\n                return Long.parseLong(readString());\n        }\n\n        double readDouble() throws IOException{\n                return Double.parseDouble(readString());\n        }\n\n        int[] readArr(int n) throws IOException{\n        \tint[] res = new int[n];\n        \tfor(int i = 0; i < n; i++){\n        \t\tres[i] = readInt();\n        \t}\n        \treturn res;\n        }\n\n        long[] readArrL(int n) throws IOException{\n        \tlong[] res = new long[n];\n        \tfor(int i = 0; i < n; i++){\n        \t\tres[i] = readLong();\n        \t}\n        \treturn res;\n        }\n\n        public static void main(String[] args){\n                new A().run();\n        }\n\n        public void run(){\n                try{\n                        long t1 = System.currentTimeMillis();\n                        init();\n                        solve();\n                        out.close();\n                        long t2 = System.currentTimeMillis();\n                        System.err.println(\"Time = \"+(t2-t1));\n                }catch (Exception e){\n                        e.printStackTrace(System.err);\n                        System.exit(-1);\n                }\n        }\n\n        ArrayList<Integer>[] fr;\n\n        ArrayList<Integer>[] vr;\n\n        int[] res;\n        int[] cur;\n        boolean check;\n        int curNum;\n\n        void dfs(int curV){\n            curNum++;\n            cur[curV] = 1;\n            for(int to: vr[curV]){\n                if(cur[to] == 1){\n                    check = false;\n                }\n                else cur[to] = -1;\n            }\n            for(int to: fr[curV]){\n                if(cur[to] == -1){\n                    check = false;\n                }\n                if(cur[to] != 1) dfs(to);\n            }\n        }\n\n        void solve() throws IOException{\n           int n = readInt();\n           res = new int[n];\n           cur = new int[n];\n           int m = readInt();\n           fr = new ArrayList[n];\n           vr = new ArrayList[n];\n           for(int i = 0; i < n; i++){\n               fr[i] = new ArrayList<Integer>();\n               vr[i] = new ArrayList<Integer>();\n           }\n           for(int i = 0; i < m; i++){\n               int a = readInt()-1;\n               int b = readInt()-1;\n               fr[a].add(b);\n               fr[b].add(a);\n           }\n           int k = readInt();\n           for(int i = 0; i < k; i++){\n               int a = readInt()-1;\n               int b = readInt()-1;\n               vr[a].add(b);\n               vr[b].add(a);\n           }\n           for(int i = 0; i < n; i++){\n               Arrays.fill(cur, 0);\n               curNum = 0;\n               check = true;\n               if(res[i] == 0) dfs(i);\n               for(int j = 0; j < n; j++){\n                   if(cur[j] == 1) res[j] = check ? curNum : -1;\n               }\n            }\n           int max = -2;\n           for(int i = 0; i < n; i++){\n              max = max(res[i],max);\n\n           }\n           if(max == -1) out.println(0);\n           else out.println(max);\n\n\n        }\n\n        void maxHepify(int[] a, int i, int length){\n        \tint l = (i<<1) + 1;\n        \tint r = (i<<1) + 2;\n        \tint largest = i;\n        \tif(l < length && a[l] > a[largest])\n        \t\tlargest = l;\n        \tif(r < length && a[r] > a[largest])\n        \t\tlargest = r;\n        \tif(largest != i){\n        \t\ta[largest] += a[i];\n        \t\ta[i] = a[largest] - a[i];\n        \t\ta[largest] -= a[i];\n        \t\tmaxHepify(a, largest, length);\n        \t}\n        }\n\n        void buildMaxHeap(int[] a){\n        \tfor(int i = a.length/2 - 1; i >= 0; i--){\n        \t\tmaxHepify(a, i, a.length);\n        \t}\n        }\n\n        void heapSort(int[] a){\n        \tbuildMaxHeap(a);\n        \tfor(int i = a.length - 1; i > 0; i--){\n        \t\ta[i] += a[0];\n        \t\ta[0] = a[i] - a[0];\n        \t\ta[i] -= a[0];\n        \t\tmaxHepify(a, 0, i);\n        \t}\n        }\n\n\n        int[] zFunction(char[] s){\n        \tint[] z = new int[s.length];\n        \tz[0] = 0;\n        \tfor (int i=1, l=0, r=0; i<s.length; ++i) {\n        \t\tif (i <= r)\n        \t\t\tz[i] = min (r-i+1, z[i-l]);\n        \t\twhile (i+z[i] < s.length && s[z[i]] == s[i+z[i]])\n        \t\t\t++z[i];\n        \t\tif (i+z[i]-1 > r){\n        \t\t\tl = i;\n        \t\t\tr = i+z[i]-1;\n        \t\t}\n        \t}\n        \treturn z;\n        }\n\n        int[] prefixFunction(char[] s){\n        \tint[] pr = new int[s.length];\n        \tfor (int i = 1; i< s.length; ++i) {\n        \t\tint j = pr[i-1];\n        \t\twhile (j > 0 && s[i] != s[j])\n        \t\t\tj = pr[j-1];\n        \t\tif (s[i] == s[j])  ++j;\n        \t\tpr[i] = j;\n        \t}\n        \treturn pr;\n        }\n\n        int ModExp(int a, int n, int mod){\n        \tint res = 1;\n        \twhile (n!=0)\n        \t\tif ((n & 1) != 0) {\n        \t\t\tres = (res*a)%mod;\n        \t\t\t--n;\n        \t\t}\n        \t\telse {\n        \t\t\ta = (a*a)%mod;\n        \t\t\tn >>= 1;\n        \t\t}\n        \treturn res;\n        }\n\n\n        public static class Utils {\n\n        \tprivate Utils() {}\n\n        \tpublic static void mergeSort(int[] a) {\n                    mergeSort(a, 0, a.length - 1);\n            }\n\n        \tprivate static void mergeSort(int[] a, int leftIndex, int rightIndex) {\n                    final int MAGIC_VALUE = 50;\n                    if (leftIndex < rightIndex) {\n                            if (rightIndex - leftIndex <= MAGIC_VALUE) {\n                                    insertionSort(a, leftIndex, rightIndex);\n                            } else {\n                                    int middleIndex = (leftIndex + rightIndex) / 2;\n                                    mergeSort(a, leftIndex, middleIndex);\n                                    mergeSort(a, middleIndex + 1, rightIndex);\n                                    merge(a, leftIndex, middleIndex, rightIndex);\n                            }\n                    }\n            }\n\n            private static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {\n            \tint length1 = middleIndex - leftIndex + 1;\n            \tint length2 = rightIndex - middleIndex;\n                int[] leftArray = new int[length1];\n                int[] rightArray = new int[length2];\n                System.arraycopy(a, leftIndex, leftArray, 0, length1);\n                System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n                for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n                    if (i == length1) {\n                            a[k] = rightArray[j++];\n                    } else if (j == length2) {\n                            a[k] = leftArray[i++];\n                    } else {\n                            a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];\n                    }\n                }\n            }\n\n            private static void insertionSort(int[] a, int leftIndex, int rightIndex) {\n                for (int i = leftIndex + 1; i <= rightIndex; i++) {\n            \t\tint current = a[i];\n                    int j = i - 1;\n                \twhile (j >= leftIndex && a[j] > current) {\n                        a[j + 1] = a[j];\n                        j--;\n                        }\n                    a[j + 1] = current;\n                }\n            }\n        }\n\n\n\n\n        boolean isPrime(int a){\n        \tfor(int i = 2; i <= sqrt(a); i++)\n        \t\tif(a % i == 0) return false;\n        \treturn true;\n        }\n\n        static double distance(long x1, long y1, long x2, long y2){\n        \treturn Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n        }\n\n        static long gcd(long a, long b){\n        \tif(min(a,b) == 0) return max(a,b);\n        \treturn gcd(max(a, b) % min(a,b), min(a,b));\n        }\n\n        static long lcm(long a, long b){\n        \treturn a * b /gcd(a, b);\n        }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (int)1e9;\nconst int mod = inf + 7;\nconst double eps = 1e-9;\nconst double pi = acos(-1.0);\nint n, k, m, used[2020][2020];\nvector<int> g[2020];\nbool c[2020];\nvector<int> cur;\nvoid dfs(int v) {\n  c[v] = 1;\n  cur.push_back(v);\n  for (__typeof(g[v].begin()) it = g[v].begin(); it != g[v].end(); it++) {\n    int to = *it;\n    if (!c[to]) dfs(to);\n  }\n}\nint main() {\n  scanf(\"%d\\n\", &n);\n  scanf(\"%d\\n\", &k);\n  for (int i = 0, x, y; i < k; i++) {\n    scanf(\"%d%d\", &x, &y);\n    x--;\n    y--;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  scanf(\"%d\\n\", &m);\n  for (int i = 0, x, y; i < m; i++) {\n    scanf(\"%d%d\\n\", &x, &y);\n    x--;\n    y--;\n    used[x][y] = used[y][x] = 1;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (!c[i]) {\n      cur.clear();\n      dfs(i);\n      bool ok = 1;\n      for (int i = 0; i < cur.size(); i++) {\n        for (int j = 0; j < cur.size(); j++) {\n          if (used[cur[i]][cur[j]]) ok = 0;\n        }\n      }\n      if (ok) ans = max(ans, (int)cur.size());\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int in() {\n  int32_t x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline string get() {\n  char ch[1000010];\n  scanf(\"%s\", ch);\n  return ch;\n}\nconst int MAX_LG = 21;\nconst long long maxn = 2e3 + 10;\nconst long long base = 29;\nconst long long mod = 1e9 + 7;\nconst long long INF = 1e9;\nvector<long long> g[maxn], b[maxn];\nlong long bad[maxn][maxn];\nlong long res;\nbool mark[maxn];\nbool vis[maxn];\nint32_t main() {\n  long long n = in(), k = in();\n  for (long long i = 0; i < k; i++) {\n    long long v = in(), u = in();\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n  long long m = in();\n  for (long long i = 0; i < m; i++) {\n    long long v = in(), u = in();\n    b[v].push_back(u), b[u].push_back(v);\n  }\n  for (long long i = 1; i <= n; i++) {\n    if (vis[i]) continue;\n    for (long long x = 1; x <= n; x++) mark[x] = false;\n    long long cnt = 0;\n    queue<long long> q;\n    q.push(i);\n    vector<long long> vc;\n    while (q.empty() == false) {\n      long long v = q.front();\n      q.pop();\n      vc.push_back(v);\n      vis[v] = true;\n      mark[v] = true;\n      cnt++;\n      for (auto u : g[v]) {\n        if (!mark[u]) mark[u] = true, q.push(u);\n      }\n    }\n    for (auto v : vc) {\n      for (auto u : b[v]) {\n        if (mark[u]) {\n          cnt = 0;\n        }\n      }\n    }\n    res = max(res, cnt);\n  }\n  cout << res << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> friends[2010];\nvector<int> enemies[2010];\nbool visited[2010];\nint main() {\n  int n;\n  cin >> n;\n  int k;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    friends[a].push_back(b);\n    friends[b].push_back(a);\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    enemies[a].push_back(b);\n    enemies[b].push_back(a);\n  }\n  int best = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      set<int> good;\n      set<int> bad;\n      stack<int> next;\n      next.push(i);\n      while (!next.empty()) {\n        int v = next.top();\n        good.insert(v);\n        next.pop();\n        if (visited[v]) continue;\n        visited[v] = true;\n        for (int j = 0; j < friends[v].size(); j++) {\n          if (!visited[friends[v][j]]) {\n            next.push(friends[v][j]);\n          }\n        }\n        for (int j = 0; j < enemies[v].size(); j++) {\n          bad.insert(enemies[v][j]);\n        }\n      }\n      bool found = true;\n      for (set<int>::iterator it = good.begin(); it != good.end(); ++it) {\n        if (bad.find(*it) != bad.end()) {\n          found = false;\n          break;\n        }\n      }\n      if (found) {\n        if (good.size() > best) best = good.size();\n      }\n    }\n  }\n  cout << best << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long component = 0, no_of_com = 0;\nunordered_map<long long, long long> com;\nvoid dfs(vector<long long> adj[], long long s) {\n  no_of_com++;\n  com[s] = component;\n  for (long long a : adj[s]) {\n    if (com[a] == 0) dfs(adj, a);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n;\n  cin >> n;\n  long long k, m;\n  cin >> k;\n  vector<long long> adj[n + 1];\n  unordered_map<long long, long long> mp;\n  for (long long i = 0; i < k; i++) {\n    long long a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  for (long long i = 1; i <= n; i++) {\n    if (com[i] == 0) {\n      component++;\n      no_of_com = 0;\n      dfs(adj, i);\n      mp[com[i]] = no_of_com;\n    }\n  }\n  cin >> k;\n  for (long long i = 0; i < k; i++) {\n    long long a, b;\n    cin >> a >> b;\n    if (com[a] == com[b]) {\n      mp[com[a]] = 0;\n    }\n  }\n  long long maxx = -1;\n  for (long long i = 1; i <= component; i++) {\n    if (maxx < mp[i]) maxx = mp[i];\n  }\n  cout << maxx;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import itertools\n\ntry: input = raw_input\nexcept: pass\n\ndef solve():\n    # read\n    n, k = rint(), rint()\n    fs = [[] for _ in range(n)]\n    dl = [[] for _ in range(n)]\n    group = [i for i in range(n)]\n    for i in range(k):\n        i, j = list(map(int, input().split()))\n        fs[i-1].append(j-1)\n        fs[j-1].append(i-1)\n    m = int(input())\n    for i in range(m):\n        i, j = list(map(int, input().split()))\n        dl[i-1].append(j-1)\n        dl[j-1].append(i-1)\n    \n    # solve\n    for i in range(n):\n        if group[i] == i:\n            spreadgroup(i, fs, group, group[i])\n    genum = sorted(enumerate(group), key=lambda x: x[1])\n    gr = [list(first(g)) for (k, g) in itertools.groupby(genum, key=lambda x: x[1])]\n    gr.sort(key=lambda x: len(x), reverse=True)\n    for pg in gr:\n        have = set(pg)\n        dislike = set()\n        for x in (dl[i] for i in pg):\n            for t in x:\n                dislike.add(int(t))\n        if have.isdisjoint(dislike):\n            print(len(pg))\n            return\n    print(0)\n            \ndef spreadgroup(i, fs, group, curgroupid):\n    for f in fs[i]:\n        if group[f] != curgroupid:\n            group[f] = curgroupid\n            spreadgroup(f, fs, group, curgroupid)   \n    \ndef first(x): \n    for i in x: yield i[0]\n    \ndef rint(): return int(input())\n\nsolve()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> G[2001];\nvector<int> T[2001];\nbool vist[2001];\nbool no[2001];\nbool here[2001];\nint as;\nbool dfs(int u) {\n  as++;\n  vist[u] = 1;\n  here[u] = 1;\n  bool f = true;\n  for (typeof T[u].begin() i = T[u].begin(); i != T[u].end(); i++) {\n    if (here[*i]) f = false;\n    no[*i] = 1;\n  }\n  for (typeof G[u].begin() i = G[u].begin(); i != G[u].end(); i++) {\n    if (no[*i]) f = false;\n    if (!vist[*i])\n      if (!dfs(*i)) f = false;\n  }\n  return f;\n}\nint main(int argc, char const *argv[]) {\n  int n, k, m, a, b;\n  cin >> n >> k;\n  for (int i = 0; i < k; ++i) {\n    cin >> a >> b;\n    a--, b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    cin >> a >> b;\n    a--, b--;\n    T[a].push_back(b);\n    T[b].push_back(a);\n  }\n  int ans = 0;\n  memset(vist, 0, sizeof vist);\n  for (int i = 0; i < n; ++i) {\n    memset(no, 0, sizeof no);\n    memset(here, 0, sizeof here);\n    if (!vist[i]) {\n      as = 0;\n      if (dfs(i)) ans = max(as, ans);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Comparator;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractList;\nimport java.io.Writer;\nimport java.util.Collection;\nimport java.util.List;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n\tpublic void solve(int testNumber, InputReader in, OutputWriter out) {\n\t\tint count = in.readInt();\n\t\tint friendshipsCount = in.readInt();\n\t\tIndependentSetSystem setSystem = new RecursiveIndependentSetSystem(count);\n\t\tfor (int i = 0; i < friendshipsCount; i++) {\n\t\t\tint first = in.readInt() - 1;\n\t\t\tint second = in.readInt() - 1;\n\t\t\tsetSystem.join(first, second);\n\t\t}\n\t\tint[] result = new int[count];\n\t\tfor (int i = 0; i < count; i++)\n\t\t\tresult[setSystem.get(i)]++;\n\t\tint enemiesCount = in.readInt();\n\t\tfor (int i = 0; i < enemiesCount; i++) {\n\t\t\tint first = in.readInt() - 1;\n\t\t\tint second = in.readInt() - 1;\n\t\t\tif (setSystem.get(first) == setSystem.get(second))\n\t\t\t\tresult[setSystem.get(first)] = 0;\n\t\t}\n\t\tout.printLine(CollectionUtils.maxElement(Array.wrap(result)));\n\t}\n}\n\nclass InputReader {\n\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic static boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\t}\n\nclass OutputWriter {\n\tprivate final PrintWriter writer;\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\twriter = new PrintWriter(outputStream);\n\t}\n\n\tpublic OutputWriter(Writer writer) {\n\t\tthis.writer = new PrintWriter(writer);\n\t}\n\n\tpublic void print(Object...objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n\tpublic void printLine(Object...objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void close() {\n\t\twriter.close();\n\t}\n\n\t}\n\ninterface IndependentSetSystem {\n\tpublic boolean join(int first, int second);\n\n\tpublic int get(int index);\n\n\tpublic static interface Listener {\n\t\tpublic void joined(int joinedRoot, int root);\n\t}\n}\n\nclass RecursiveIndependentSetSystem implements IndependentSetSystem {\n\tprivate final int[] color;\n\tprivate int setCount;\n\tprivate Listener listener;\n\n\tpublic RecursiveIndependentSetSystem(int size) {\n\t\tcolor = new int[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tcolor[i] = i;\n\t\tsetCount = size;\n\t}\n\n\tpublic RecursiveIndependentSetSystem(RecursiveIndependentSetSystem other) {\n\t\tcolor = other.color.clone();\n\t\tsetCount = other.setCount;\n\t}\n\n\tpublic boolean join(int first, int second) {\n\t\tfirst = get(first);\n\t\tsecond = get(second);\n\t\tif (first == second)\n\t\t\treturn false;\n\t\tsetCount--;\n\t\tcolor[second] = first;\n\t\tif (listener != null)\n\t\t\tlistener.joined(second, first);\n\t\treturn true;\n\t}\n\n\tpublic int get(int index) {\n\t\tif (color[index] == index)\n\t\t\treturn index;\n\t\treturn color[index] = get(color[index]);\n\t}\n\n\t}\n\nclass CollectionUtils {\n\n\tpublic static<T extends Comparable<T>> T maxElement(Iterable<T> collection) {\n\t\tT result = null;\n\t\tfor (T element : collection) {\n\t\t\tif (result == null || result.compareTo(element) < 0)\n\t\t\t\tresult = element;\n\t\t}\n\t\treturn result;\n\t}\n\n\t}\n\nabstract class Array<T> extends AbstractList<T> {\n\n\tpublic static List<Integer> wrap(int...array) {\n\t\treturn new IntArray(array);\n\t}\n\n\tprotected static class IntArray extends Array<Integer> {\n\t\tprotected final int[] array;\n\n\t\tprotected IntArray(int[] array) {\n\t\t\tthis.array = array;\n\t\t}\n\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic Integer get(int index) {\n\t\t\treturn array[index];\n\t\t}\n\n\t\tpublic Integer set(int index, Integer value) {\n\t\t\tint result = array[index];\n\t\t\tarray[index] = value;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring tostr(int n) {\n  stringstream rr;\n  rr << n;\n  return rr.str();\n}\nlong long power(long long a, long long b) {\n  return b == 0 ?: a * power(a, b - 1);\n}\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long lcm(long long a, long long b) { return a * (b / gcd(a, b)); }\nvector<int> graph[2020];\nbool vis[2020];\nint dislike[2020];\nint mp[2020];\nint bfs(int s, int mx) {\n  bool ok = true;\n  vis[s] = 1;\n  queue<int> q;\n  vector<int> vec;\n  vec.clear();\n  vec.push_back(s);\n  q.push(s);\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int i = 0; i < graph[u].size(); i++) {\n      int v = graph[u][i];\n      if (vis[v] == 0) {\n        vec.push_back(v);\n        vis[v] = 1;\n        q.push(v);\n      }\n    }\n  }\n  for (int i = 0; i <= 2010; i++) mp[i] = 0;\n  int len = vec.size();\n  for (int i = 0; i < vec.size(); i++) mp[dislike[vec[i]]]++;\n  for (int i = 2; i <= 2010; i++) {\n    if (mp[i] > 1) {\n      ok = false;\n      break;\n    }\n  }\n  if (ok) mx = max(mx, len);\n  return mx;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  int n, k;\n  while (cin >> n >> k) {\n    int c = 2, m, mx = 0;\n    for (int i = 0; i <= n; i++) graph[i].clear();\n    for (int i = 1; i <= k; i++) {\n      int a, b;\n      cin >> a >> b;\n      graph[a].push_back(b);\n      graph[b].push_back(a);\n    }\n    cin >> m;\n    for (int i = 0; i <= 2010; i++) dislike[i] = 0;\n    for (int i = 1; i <= m; i++) {\n      int a, b;\n      cin >> a >> b;\n      if (dislike[a] == 0) dislike[a] = c;\n      if (dislike[b] == 0) dislike[b] = c;\n      c++;\n    }\n    for (int i = 0; i <= 2010; i++) vis[i] = 0;\n    for (int i = 1; i <= n; i++) {\n      if (!vis[i]) {\n        mx = bfs(i, mx);\n      }\n    }\n    cout << mx << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2005;\nvector<long long> adj[N];\nbool cant[N];\nlong long numcomp, comp[N], cursz, friends[N];\nvoid dfs(long long v) {\n  comp[v] = numcomp;\n  cursz++;\n  for (auto &u : adj[v])\n    if (!comp[u]) dfs(u);\n  return;\n}\nint main() {\n  long long n, k, i, v, u, m, ans;\n  cin >> n >> k;\n  for (i = 1; i <= k; i++) {\n    cin >> v >> u;\n    adj[v].push_back(u);\n    adj[u].push_back(v);\n  }\n  numcomp = 0;\n  for (i = 1; i <= n; i++) {\n    if (!comp[i]) {\n      numcomp++;\n      cursz = 0;\n      dfs(i);\n      friends[numcomp] = cursz;\n    }\n  }\n  cin >> m;\n  for (i = 1; i <= m; i++) {\n    cin >> v >> u;\n    if (comp[v] == comp[u]) cant[comp[v]] = true;\n  }\n  ans = 0;\n  for (i = 1; i <= numcomp; i++) {\n    if (!cant[i]) ans = max(ans, friends[i]);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  BufferedReader br;\n  int n, k, m;\n  int[] p, num;\n  boolean[] dead;\n  \n  public int findParent(int n) {\n    if (p[n] == n)\n      return n;\n    else\n      return p[n] = findParent(p[n]);\n  }\n  \n  public void go() throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n\n    n = Integer.parseInt(br.readLine());\n    k = Integer.parseInt(br.readLine());\n    p = new int[n+1];\n    num = new int[n+1];\n    dead = new boolean[n+1];\n\n    for (int i = 1; i <= n; i++)\n      p[i] = i;\n    Arrays.fill(num, 1);\n    Arrays.fill(dead, false);\n    \n    for (int i = 0; i < k; i++) {\n      String[] ss = br.readLine().split(\" \");\n      int u = Integer.parseInt(ss[0]);\n      int v = Integer.parseInt(ss[1]);\n      int pu = findParent(u);\n      int pv = findParent(v);\n      if (pu != pv) {\n        if (pu < pv) {\n          p[pv] = pu;\n          num[pu] += num[pv];\n          num[pv] = 0;\n        }\n        else {\n          p[pu] = pv;\n          num[pv] += num[pu];\n          num[pu] = 0;\n        }\n      }\n    }\n    \n    m = Integer.parseInt(br.readLine());\n    for (int i = 0; i < m; i++) {\n      String[] ss = br.readLine().split(\" \");\n      int u = Integer.parseInt(ss[0]);\n      int v = Integer.parseInt(ss[1]);\n      int pu = findParent(u);\n      int pv = findParent(v);\n      if (pu == pv)\n        dead[pu] = true;\n    }\n    \n    int ac = 0;\n    for (int i = 1; i <= n; i++)\n      if (!dead[i])\n        ac = Math.max(ac, num[i]);\n    \n    System.out.println(ac);\n  }\n  \n  public static void main(String[] args) throws Exception {\n    new Main().go();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint g[2048];\nint num[2048];\nvoid un(int a, int b);\nint Find(int x);\nint main() {\n  int n, like, dislike, a, b, grp;\n  while (cin >> n) {\n    grp = 0;\n    for (int i = 1; i <= n; i++) {\n      g[i] = i;\n      num[i] = 1;\n    }\n    cin >> like;\n    for (int i = 0; i < like; i++) {\n      cin >> a >> b;\n      un(a, b);\n    }\n    cin >> dislike;\n    for (int i = 0; i < dislike; i++) {\n      cin >> a >> b;\n      a = Find(a);\n      b = Find(b);\n      if (a == b) num[a] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n      grp = max(grp, num[i]);\n    }\n    cout << grp << endl;\n  }\n  return 0;\n}\nvoid un(int a, int b) {\n  a = Find(a);\n  b = Find(b);\n  if (a != b) {\n    if (num[a] > num[b]) {\n      g[b] = a;\n      num[a] += num[b];\n      num[b] = 0;\n    } else {\n      g[a] = b;\n      num[b] += num[a];\n      num[a] = 0;\n    }\n  }\n}\nint Find(int x) { return x == g[x] ? x : g[x] = Find(g[x]); }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1.0);\nconst int inf = int(2e9);\nconst int _inf = -inf;\nconst int mod = inf + 7;\nusing namespace std;\nbool bad[2002][2002];\nvector<int> g[2002];\nbool used[2002];\nqueue<int> q;\nint cnt;\nvector<int> res;\nvoid bfs(int v) {\n  used[v] = 1;\n  cnt++;\n  res.push_back(v);\n  for (int i = 0; i < g[v].size(); ++i) {\n    int to = g[v][i];\n    if (!used[to] && !bad[v][to]) {\n      bfs(to);\n    }\n  }\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < k; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    bad[u][v] = 1;\n    bad[v][u] = 1;\n  }\n  int mx = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (!used[i]) {\n      cnt = 0;\n      res.clear();\n      bfs(i);\n      bool flag = 1;\n      for (int j = 0; j < res.size(); ++j) {\n        for (int k = j + 1; k < res.size(); ++k) {\n          if (bad[res[j]][res[k]]) flag = 0;\n        }\n      }\n      if (flag) mx = max(mx, (int)res.size());\n    }\n  }\n  cout << mx;\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\narray<vector<int>, 2001> adj;\nbool vis[2001];\nbool like[2001][2001];\nvector<int> group;\nvoid dfs(int f) {\n  vis[f] = true;\n  group.push_back(f);\n  for (auto to : adj[f])\n    if (like[f][to] && !vis[to]) dfs(to);\n}\nint main() {\n  adj.fill({});\n  memset(like, true, sizeof like);\n  int n, k, m, i, j;\n  cin >> n >> k;\n  while (k--) {\n    cin >> i >> j;\n    adj[i].push_back(j);\n    adj[j].push_back(i);\n  }\n  cin >> m;\n  while (m--) {\n    cin >> i >> j;\n    adj[i].push_back(j);\n    adj[j].push_back(i);\n    like[i][j] = like[j][i] = false;\n  }\n  int mx = 0;\n  for (int i = 1; i <= n; i++) {\n    group.clear();\n    memset(vis, false, sizeof vis);\n    dfs(i);\n    bool b = true;\n    for (auto f1 : group)\n      for (auto f2 : group)\n        if (f1 != f2 && !like[f1][f2]) {\n          b = false;\n          break;\n        }\n    if (b) mx = max(mx, int(group.size()));\n  }\n  cout << mx;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, x, y, p[2000], sz[2000], ans;\nint root(int x) { return p[x] != x ? p[x] = root(p[x]) : x; }\nvoid join(int x, int y) {\n  x = root(x), y = root(y);\n  if (x == y) return;\n  if (sz[x] <= sz[y])\n    sz[p[x] = y] += sz[x];\n  else\n    sz[p[y] = x] += sz[y];\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) sz[p[i] = i] = 1;\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &x, &y);\n    join(x - 1, y - 1);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &x, &y);\n    if (root(--x) == root(--y)) sz[root(x)] = 0;\n  }\n  for (int i = 0; i < n; i++) ans = max(ans, sz[root(i)]);\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e5 + 7;\nvector<int> adj[MAX];\nbool mark[MAX], group[MAX];\nint gr[MAX], fr[MAX];\nvoid dfs(int u, int groupID);\nint n, k, m;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i <= k; ++i) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  int groupID = 1;\n  for (int i = 1; i <= n; ++i) {\n    if (!mark[i]) {\n      dfs(i, groupID);\n      group[groupID] = true;\n      ++groupID;\n    }\n  }\n  cin >> m;\n  for (int i = 1; i <= m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    if (gr[u] == gr[v]) {\n      group[gr[u]] = false;\n    }\n  }\n  memset(fr, 0, sizeof(fr));\n  int res = 0;\n  for (int i = 1; i <= n; ++i) {\n    fr[gr[i]]++;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (group[i]) {\n      res = max(res, fr[i]);\n    }\n  }\n  cout << res << \"\\n\";\n  return 0;\n}\nvoid dfs(int u, int groupID) {\n  gr[u] = groupID;\n  mark[u] = true;\n  int size = adj[u].size();\n  for (int i = 0; i < size; ++i) {\n    if (!mark[adj[u][i]]) {\n      dfs(adj[u][i], groupID);\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m;\nint par[2007];\nint find(int x) {\n  if (par[x] == -1) return x;\n  return find(par[x]);\n}\nvoid uni(int x, int y) {\n  int u = find(x);\n  int v = find(y);\n  if (u != v) par[u] = v;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  memset(par, -1, sizeof(par));\n  for (int i = 0; i < k; i++) {\n    int x, y;\n    cin >> x >> y;\n    uni(x, y);\n  }\n  map<int, int> mp;\n  for (int i = 1; i <= n; i++) mp[find(i)]++;\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    int u = find(x);\n    int v = find(y);\n    if (u == v) mp[u] = 0;\n  }\n  int ans = 0;\n  for (auto it : mp) ans = max(ans, it.second);\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main\n{\nstatic int q,sum,mx,c,level;\nstatic int freq[];\nstatic int lvl[];\nstatic boolean vis[];\nstatic ArrayList<Integer>adj[];\nstatic Set<Integer>set=new TreeSet<>();\nstatic LinkedList<Integer>li=new LinkedList<>();\npublic static void main(String args[])throws \nUnsupportedEncodingException, IOException, Exception\n  {\n   Reader.init(System.in);\n   PrintWriter pw=new PrintWriter(System.out);\n    q=Reader.nextInt();\n    vis=new boolean[q];\n    lvl=new int[q];\n    Arrays.fill(lvl,-1);\n    freq=new int[q];\n    adj=new ArrayList[q];\n    for(int i=0;i<q;i++)\n    adj[i]=new ArrayList<Integer>();\n   \n    int k=Reader.nextInt();\n    for(int i=0;i<k;i++)\n    {\n      int u=Reader.nextInt();u--;\n      int v=Reader.nextInt();v--;\n      adj[u].add(v);\n      adj[v].add(u);\n    }\n    int m=Reader.nextInt();\n    int arr[][]=new int[m][2];\n    int cn=count();\n    for(int i=0;i<m;i++)\n    {\n      arr[i][0]=Reader.nextInt()-1;arr[i][1]=Reader.nextInt()-1;\n      int one=arr[i][0];\n      int two=arr[i][1];\n      if(lvl[one]==lvl[two])freq[lvl[one]]=-1;\n    }\n    for(int i=0;i<m;i++)\n    {\n      int one=arr[i][0];\n      int two=arr[i][1];\n      if(freq[lvl[one]]!=-1)mx=Math.max(freq[lvl[one]],mx);\n      if(freq[lvl[two]]!=-1)mx=Math.max(freq[lvl[two]],mx);\n    }\n    for(int i=0;i<freq.length;i++)\n    {\n      if(lvl[i]==-1) freq[i]=1;\n    }\n    Arrays.sort(freq);mx=Math.max(freq[freq.length-1],mx);\n     pw.println(mx);\n     pw.close();\n  }\n  private static long gcd(long a, long b) {\n    while (b > 0) {\n      long temp = b;\n      b = a % b;\n      a = temp;\n    }\n    return a;\n  }\n  \n  private static long lcm(long a, long b) {\n    return a * (b / gcd(a, b));\n  }\n  \n  public static boolean isPrime(long n)\n  {\n        boolean flag = false;\n        for(int i = 2; i <= n/2; ++i)\n        {\n            if(n% i == 0)\n            {\n                flag = true;\n                break;\n            }\n        }\n\n        if (!flag)\n            return true;\n        else\n            return false;\n  }\n  \n  public static void dfs(int i)\n  {\n   vis[i]=true;\n   lvl[i]=level;\n   freq[level]++;\n   \n   for(int j=0;j<adj[i].size();j++)\n   {\n   \n   if(!vis[adj[i].get(j)])\n   dfs(adj[i].get(j));\n   }\n  }\n  \n  public static int count()\n  {\n    int cnt=0;\n    int index;\n while((index=check())!=-1)\n {\n dfs(index);cnt++;\n level++; \n }\n    return cnt;\n  }\n  \n  public static int check()\n  {\n    for(int i=0;i<vis.length; i++)\n   \n      if(!vis[i])return i;\n   return -1;\n  }\n}\n\nclass Pair<S extends Comparable<S>, T extends Comparable<T>> implements Comparable<Pair<S, T>> {\n    S first;\n    T second;\n    \n    Pair(S f, T s) {\n        first = f;\n        second = s;\n    }\n    @Override\n    public int compareTo(Pair<S, T> o) {\n        int t = first.compareTo(o.first);\n        if (t == 0) return second.compareTo(o.second);\n        return t;\n    }\n    @Override\n    public int hashCode() {\n        return (31 + first.hashCode()) * 31 + second.hashCode();\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof Pair)) return false;\n        if (o == this) return true;\n        Pair p = (Pair) o;\n        return first.equals(p.first) && second.equals(p.second);\n    }\n    @Override\n    public String toString() {\n        return \"Pair{\" + first + \", \" + second + \"}\";\n    }\n}\n\nclass Reader {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n    static void init(InputStream input) throws UnsupportedEncodingException {\n        reader = new BufferedReader(\n                new InputStreamReader(input, \"UTF-8\"));\n        tokenizer = new StringTokenizer(\"\");\n    }\n    static void init(String url) throws FileNotFoundException {\n        reader = new BufferedReader(new FileReader(url));\n        tokenizer = new StringTokenizer(\"\");\n    }\n    static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            //TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                    reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n    static String nextLine() throws IOException {\n        return reader.readLine();\n    }\n \n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n \n    static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n \n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool F[2001][2001];\nbool D[2001][2001];\nint C[2001];\nvector<int> V[2001];\nint n;\nvoid f(int v, int c) {\n  if (C[v]) return;\n  C[v] = c;\n  V[c].push_back(v);\n  for (int i = 1; i <= n; ++i)\n    if (F[v][i]) f(i, c);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  int k;\n  cin >> k;\n  while (k--) {\n    int a, b;\n    cin >> a >> b;\n    F[a][b] = 1;\n    F[b][a] = 1;\n  }\n  cin >> k;\n  while (k--) {\n    int a, b;\n    cin >> a >> b;\n    D[a][b] = 1;\n    D[b][a] = 1;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    f(i, i);\n    int t = V[i].size();\n    for (int j = 0; j < t; ++j)\n      for (int l = 0; l < t; ++l)\n        if (D[V[i][j]][V[i][l]]) goto skip;\n    ans = max(ans, t);\n  skip:;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err(istream_iterator<string> it) {}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n  cout << *it << \" = \" << a << '\\n';\n  err(++it, args...);\n}\nconst long long mod = 1e9 + 7;\nvector<int> par(20001), sz(20001, 1);\nint find(int v) {\n  if (v == par[v]) return v;\n  return par[v] = find(par[v]);\n}\nvoid _union(int a, int b) {\n  a = find(a);\n  b = find(b);\n  if (a != b) {\n    if (sz[a] > sz[b]) swap(a, b);\n    par[b] = a;\n    sz[a] += sz[b];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n;\n  cin >> n;\n  int k;\n  cin >> k;\n  iota(par.begin(), par.end(), 0);\n  for (__typeof(k) i = (0) - (0 > k); i != (k) - (0 > k);\n       i += 1 - 2 * (0 > k)) {\n    int x, y;\n    cin >> x >> y;\n    _union(x, y);\n  }\n  int m;\n  cin >> m;\n  for (__typeof(m) i = (0) - (0 > m); i != (m) - (0 > m);\n       i += 1 - 2 * (0 > m)) {\n    int x, y;\n    cin >> x >> y;\n    if (find(x) == find(y)) {\n      sz[find(x)] = 0;\n    }\n  }\n  int ans = 0;\n  for (__typeof(n + 1) i = (1) - (1 > n + 1); i != (n + 1) - (1 > n + 1);\n       i += 1 - 2 * (1 > n + 1))\n    ans = max(ans, sz[find(i)]);\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = (int)(1e5 + 123);\nvector<int> gg[MAXN], gb[MAXN];\nbool was[MAXN], been[MAXN];\nint cnt = 0;\nvoid dfs(int v) {\n  cnt++;\n  was[v] = been[v] = true;\n  for (auto to : gg[v]) {\n    if (was[to]) continue;\n    dfs(to);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  int good;\n  cin >> good;\n  for (int i = 1; i <= good; i++) {\n    int a, b;\n    cin >> a >> b;\n    gg[a].push_back(b);\n    gg[b].push_back(a);\n  }\n  int bad;\n  cin >> bad;\n  for (int i = 1; i <= bad; i++) {\n    int a, b;\n    cin >> a >> b;\n    gb[a].push_back(b);\n    gb[b].push_back(a);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (was[i]) continue;\n    cnt = 0;\n    dfs(i);\n    bool no = false;\n    for (int j = 1; j <= n; j++) {\n      if (been[j]) {\n        for (auto to : gb[j])\n          if (been[to]) {\n            no = true;\n            break;\n          }\n      }\n      if (no) break;\n    }\n    if (!no) ans = max(ans, cnt);\n    for (int j = 1; j <= n; j++) been[j] = false;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout\n\ndef find(node):\n    x = []\n    while dsu[node] > 0:\n        x.append(node)\n        node = dsu[node]\n    for i in x:\n        dsu[i] = node\n    return node\n\ndef union(node1, node2):\n    if node1 != node2:\n        if dsu[node1] > dsu[node2]:\n            node1, node2 = node2, node1\n        dsu[node1] += dsu[node2]\n        dsu[node2] = node1\n\nn = int(stdin.readline().strip())\ndsu = [-1]*(n+1)\nm = int(stdin.readline().strip())\nfor __ in range(m):\n    a, b = map(int, stdin.readline().strip().split())\n    union(find(a), find(b))\nk = int(stdin.readline().strip())\n\nfor __ in range(k):\n    a, b = map(int, stdin.readline().strip().split())\n    p_a = find(a)\n    p_b = find(b)\n    if p_a == p_b:\n        dsu[p_a] = 0\nmaxm = 0\nfor i in range(1, n+1):\n    if dsu[i] < 0:\n        maxm = max(maxm, abs(dsu[i]))\nstdout.write(f'{maxm}')\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    boolean vis[ ];\n    List< Integer > g[ ];\n    boolean bad[ ][ ];\n    public void solve( ) throws Throwable {\n        int n = in.nextInt( );\n        g = new List[ n ];\n        vis = new boolean[ n ];\n        bad = new boolean[ n ][ n ];\n        for ( int i = 0; i < n; ++i ) {\n            g[ i ] = new ArrayList< Integer >( );\n        }\n        int nfriends = in.nextInt( );\n        for ( int i = 0; i < nfriends; ++i ) {\n            int u = in.nextInt( ) - 1, v = in.nextInt( ) - 1;\n            g[ u ].add( v );\n            g[ v ].add( u );\n        }\n\n        int foes = in.nextInt( );\n        for ( int i = 0; i < foes; ++i ) {\n            int u = in.nextInt( ) - 1, v = in.nextInt( ) - 1;\n            bad[ u ][ v ] = bad[ v ][ u ] = true;\n        }\n        int ans = 0;\n        for ( int i = 0; i < n; ++i ) {\n            if ( !vis[ i ] ) {\n                ans = Math.max( ans, bfs( i ) );\n            }\n        }\n        out.println( ans );\n    }\n\n    int bfs( int s ) {\n        List< Integer > ring = new ArrayList< Integer >( );\n        int ans = 1;\n        Deque< Integer > q = new ArrayDeque< Integer >( );\n        q.add( s );\n        boolean ok = true;\n        ring.add( s );\n        vis[ s ] = true;\n        while ( q.size( ) > 0 ) {\n            int cur = q.poll( );\n            \n            for ( int i = 0, len = g[ cur ].size( ); i < len; ++i ) {\n                int to = g[ cur ].get( i );\n                if ( !vis[ to ] ) {\n                    if ( ok ) {\n                        for ( int u : ring ) {\n                            if ( bad[ to ][ u ] ) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                    }\n                    if ( ok ) {\n                        ring.add( to );\n                    }\n                    q.add( to );\n                    vis[ to ] = true;\n                }\n            }\n        }\n        //debug( ok, ring );\n        return ok ? ring.size( ) : 0;\n    }\n\n    public void run( ) {\n        in = new FastScanner( System.in );\n        out = new PrintWriter( new PrintStream( System.out ), true );\n\n        try {\n            solve( );\n            out.close( );\n            System.exit( 0 );\n        } catch( Throwable e ) {\n            e.printStackTrace( );\n            System.exit( -1 ); \n        }\n    }\n\n\n    public void debug( Object...os ) {\n        System.err.println( Arrays.deepToString( os ) );\n    }\n\n    public static void main( String[ ] args ) {\n        ( new Main( ) ).run( );\n    }\n\n\n\n    private FastScanner in;\n    private PrintWriter out;\n\n    private static class FastScanner {\n        private int charsRead;\n        private int currentRead;\n        private byte buffer[ ] = new byte[ 0x1000 ];\n        private InputStream reader;\n\n        public FastScanner( InputStream in ) {\n            reader = in;\n        }\n\n        public int read( ) {\n            if ( charsRead == -1 ) {\n                throw  new InputMismatchException( );\n            }\n\n            if ( currentRead >= charsRead ) {\n                currentRead = 0;\n                try {\n                    charsRead = reader.read( buffer );\n\n                } catch( IOException e ) {\n                    throw new InputMismatchException(  );\n                }\n\n                if ( charsRead <= 0 ) {\n                    return -1;\n                }\n            }\n\n            return buffer[ currentRead++ ];\n        }\n\n        public int nextInt( ) {\n            int c = read( );\n\n            while ( isWhitespace( c ) ) {\n                c = read( );\n            }\n\n            if ( c == -1 ) {\n                throw new NullPointerException( );\n            } \n\n            if ( c != '-' && !( c >= '0' && c <= '9' ) ) {\n                throw new InputMismatchException( );\n            }\n\n            int sign = c == '-' ? -1 : 1;\n            if ( sign == -1 ) {\n                c = read( );\n            }\n\n            if ( c == -1 || !( c >= '0' && c <= '9' ) ) {\n                throw new InputMismatchException( );\n            }\n\n            int ans = 0;\n            while ( !isWhitespace( c )  && c != -1 ) {\n                if ( !( c >= '0' && c <= '9' ) ) {\n                    throw  new InputMismatchException( );\n                }\n                int num = c - '0';\n                ans = ans * 10 + num;\n                c = read( );\n            }\n\n            return ans * sign;\n        }\n\n        public long nextLong( ) {\n            int c = read( );\n\n            while ( isWhitespace( c ) ) {\n                c = read( );\n            }\n\n            if ( c == -1 ) {\n                throw new NullPointerException( );\n            }\n\n            if ( c != '-' && !( c >= '0' && c <= '9' ) ) {\n                throw new InputMismatchException( );\n            }\n\n            int sign = c == '-' ? -1 : 1;\n            if ( sign == -1 ) {\n                c = read( );\n            }\n\n            if ( c == -1 || !( c >= '0' && c <= '9' ) ) {\n                throw new InputMismatchException( );\n            }\n\n            long ans = 0;\n            while ( !isWhitespace( c )  && c != -1 ) {\n                if ( !( c >= '0' && c <= '9' ) ) {\n                    throw  new InputMismatchException( );\n                }\n                int num = c - '0';\n                ans = ans * 10 + num;\n                c = read( );\n            }\n\n            return ans * sign;\n        }\n\n\n\n        public boolean isWhitespace( int c ) {\n            return  c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public String next( ) {\n            int c = read( );\n            StringBuffer ans = new StringBuffer( );\n\n            while ( isWhitespace( c ) && c != -1 ) {\n                c  = read( );\n            }\n\n            if ( c == -1 ) {\n                return null;\n            }\n\n            while ( !isWhitespace( c ) && c != -1 ) {\n                ans.appendCodePoint( c );\n                c = read( );\n            }\n\n            return ans.toString( );\n\n        }\n\n               \n        public String nextLine( ) {\n            String ans = nextLine0( );\n\n            while ( ans.trim( ).length( ) == 0 ) {\n                ans = nextLine0( );\n            }\n\n            return ans;\n        }\n        \n        private String nextLine0( ) {\n            int c = read( );\n            if ( c == -1 ) {\n                return null;\n            }\n            StringBuffer ans = new StringBuffer( );\n            while ( c != '\\n' && c != '\\r' && c != -1 ) {\n                ans.appendCodePoint( c );\n                c = read( );\n            }\n\n            return ans.toString( );\n\n        }\n\n\n       \n        public double nextDouble( ) {\n            int c = read( );\n            while ( isWhitespace( c ) ) {\n                c = read( );\n            }\n\n            if ( c == -1 ) {\n                throw new NullPointerException( ); \n            }\n\n            if ( c != '.' && c != '-' && !( c >= '0' && c <= '9' ) ) {\n                throw new InputMismatchException( );\n            }\n\n            int sign = c == '-' ? -1 : 1;\n            if ( c == '-' ) {\n                c = read( );\n            }\n            double ans = 0;\n            while ( c != -1 && c != '.' && !isWhitespace( c ) ) {\n                if ( !( c >= '0' && c <= '9' ) ) {\n                    throw new InputMismatchException( );\n                }\n\n                int num = c - '0'; \n                ans = ans * 10.0 + num;\n                c = read( );\n            }\n\n            if ( !isWhitespace( c ) && c != -1 && c != '.' ) {\n                throw new InputMismatchException( );\n            }\n\n            double pow10 = 1.0;\n\n            if ( c == '.' ) {\n                c = read( );\n            }\n\n            while ( !isWhitespace( c ) && c != -1 ) {\n                pow10 *= 10.0;\n\n                if ( !( c >= '0' && c <= '9' ) ) {\n                    throw new InputMismatchException( );\n                }\n                int num = c - '0';\n                ans = ans * 10.0 + num; \n                c = read( );\n            }\n\n            return ans * sign / pow10;\n        }\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint p[120000], size[120000], br[120000], is[120000];\nvoid make(int x) {\n  size[x] = 1;\n  p[x] = x;\n}\nint find(int x) {\n  if (x == p[x]) return x;\n  return p[x] = find(p[x]);\n}\nvoid uni(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x != y) {\n    if (x < y) swap(x, y);\n    p[y] = x;\n    size[x] += size[y];\n  }\n}\nint main() {\n  int x, y, n, m, k, i, j;\n  cin >> n >> m;\n  for (i = 0; i < n; i++) make(i);\n  for (i = 0; i < m; i++) {\n    cin >> x >> y;\n    x--;\n    y--;\n    uni(x, y);\n  }\n  cin >> k;\n  for (i = 0; i < k; i++) {\n    cin >> x >> y;\n    x--;\n    y--;\n    j = find(x);\n    if (j == find(y)) br[j] = 1;\n  }\n  int mx = 0;\n  for (i = 0; i < n; i++) {\n    j = find(i);\n    is[j] = 1;\n  }\n  for (i = 0; i < n; i++)\n    if (size[i] > mx && br[i] == 0 && is[i]) {\n      mx = size[i];\n    }\n  cout << mx << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dsu {\n  int n;\n  int m;\n  int idx;\n  vector<int> e;\n  vector<int> root_hash;\n  vector<int> idx_hash;\n  dsu(int n_) : n(n_) {\n    m = n;\n    idx = 0;\n    e.resize(n, -1);\n    root_hash.resize(n, -1);\n    idx_hash.resize(n, -1);\n  }\n  int size(int first) { return -e[find(first)]; }\n  int find(int first) {\n    return e[first] < 0 ? first : e[first] = find(e[first]);\n  }\n  bool join(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a == b) {\n      return false;\n    }\n    if (e[a] > e[b]) {\n      swap(a, b);\n    }\n    e[a] += e[b];\n    e[b] = a;\n    m--;\n    return true;\n  }\n  int get_root(int ix) {\n    assert(0 <= ix && ix < n);\n    assert(root_hash[ix] != -1);\n    return root_hash[ix];\n  }\n  int get_idx(int root) {\n    assert(0 <= root && root < n);\n    if (idx_hash[root] == -1) {\n      idx_hash[root] = idx;\n      root_hash[idx] = root;\n      idx++;\n    }\n    return idx_hash[root];\n  }\n  vector<vector<int>> groups() {\n    vector<vector<int>> ret(m);\n    for (int i = 0; i < n; i++) {\n      int root = find(i);\n      ret[get_idx(root)].push_back(i);\n    }\n    return ret;\n  }\n};\nvoid solve() {\n  int n;\n  cin >> n;\n  int m;\n  cin >> m;\n  dsu ds(n);\n  for (int i = 0; i < m; i++) {\n    int first, second;\n    cin >> first >> second;\n    first--, second--;\n    ds.join(first, second);\n  }\n  (void)ds.groups();\n  vector<int> g(n);\n  for (int i = 0; i < n; i++) {\n    g[i] = ds.find(i);\n  }\n  vector<int> invite(ds.m, 1);\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    int first, second;\n    cin >> first >> second;\n    first--, second--;\n    int rx = ds.find(first);\n    int ry = ds.find(second);\n    if (rx == ry) {\n      invite[ds.get_idx(rx)] = 0;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < ds.m; i++) {\n    if (invite[i]) {\n      ans = max(ans, ds.size(ds.get_root(i)));\n    }\n  };\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint p[N], n, k, m, r[N];\nint find(int x) {\n  if (x != p[x]) p[x] = find(p[x]);\n  return p[x];\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) p[i] = i;\n  for (int i = 1; i <= k; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    p[find(a)] = find(b);\n  }\n  unordered_set<int> S;\n  cin >> m;\n  for (int i = 1; i <= m; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    if (find(a) == find(b)) S.insert(find(a));\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!S.count(find(i))) r[find(i)]++;\n  }\n  int res = 0;\n  for (int i = 1; i <= n; i++) {\n    res = max(res, r[i]);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> arr[2001], enemy[2001], ele;\nbool vis[2001];\nvoid dfs(int node) {\n  vis[node] = true;\n  ele.push_back(node);\n  for (int child : arr[node]) {\n    if (!vis[child]) {\n      dfs(child);\n    }\n  }\n}\nint main(int argc, char const *argv[]) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n, k, m, a, b;\n  cin >> n >> k;\n  while (k--) {\n    cin >> a >> b;\n    arr[a].push_back(b);\n    arr[b].push_back(a);\n  }\n  cin >> m;\n  while (m--) {\n    cin >> a >> b;\n    enemy[a].push_back(b);\n    enemy[b].push_back(a);\n  }\n  int res = 0;\n  bool flag;\n  for (int i = 1; i < n + 1; i++) {\n    if (!vis[i]) {\n      ele.clear();\n      flag = true;\n      dfs(i);\n      for (int per : ele) {\n        for (int ene : enemy[per]) {\n          for (int fri : ele) {\n            if (ene == fri) {\n              flag = false;\n              break;\n            }\n            if (!flag) {\n              break;\n            }\n          }\n          if (!flag) {\n            break;\n          }\n        }\n      }\n      if (flag) {\n        res = max(res, int(ele.size()));\n      }\n    }\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint mas[4000][4000] = {0}, i, j, vers[4000] = {0}, n, k, m, u, v, ans = 0, sum,\n    b;\nvoid dfs(int ver) {\n  for (int fi = 1; fi <= n; ++fi)\n    if (mas[ver][fi] == 1 && vers[fi] == 0) {\n      vers[fi] = 1;\n      dfs(fi);\n    } else if (mas[ver][fi] == -1 && vers[fi] == 1)\n      b = 0;\n}\nint main() {\n  cin >> n >> k;\n  for (i = 0; i < k; ++i) {\n    cin >> u >> v;\n    mas[u][v] = mas[v][u] = 1;\n  }\n  cin >> m;\n  for (i = 0; i < m; ++i) {\n    cin >> u >> v;\n    mas[u][v] = mas[v][u] = -1;\n  }\n  for (i = 1; i <= n; ++i) {\n    for (j = 1; j <= n; ++j) vers[j] = 0;\n    b = 1;\n    vers[i] = 1;\n    dfs(i);\n    sum = 0;\n    if (b == 1) {\n      for (j = 1; j <= n; ++j)\n        if (vers[j] == 1) ++sum;\n      if (ans < sum) ans = sum;\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst int maxn = 2e3 + 4;\nvector<int> edge1[maxn];\nvector<int> edge2[maxn];\nint vis[maxn];\nvector<int> cc;\nint now;\nvoid dfs(int u) {\n  vis[u] = now;\n  cc.push_back(u);\n  for (int i = 0; i < edge1[u].size(); i++) {\n    int v = edge1[u][i];\n    if (!vis[v]) dfs(v);\n  }\n}\nbool check(int u) {\n  for (int i = 0; i < edge2[u].size(); i++) {\n    int v = edge2[u][i];\n    if (vis[v] == now) return false;\n  }\n  return true;\n}\nint ans;\nint main() {\n  int n;\n  cin >> n;\n  int k;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    cin >> u >> v;\n    edge1[u].push_back(v);\n    edge1[v].push_back(u);\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    edge2[u].push_back(v);\n    edge2[v].push_back(u);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      now++;\n      cc.clear();\n      dfs(i);\n      bool flag = true;\n      for (int j = 0; j < cc.size(); j++) {\n        if (check(cc[j]) == false) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) ans = max(ans, (int)cc.size());\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m, parent[2005], num[2005];\nint largest = 0;\nint find(int i) {\n  if (parent[i] == i) return i;\n  return parent[i] = find(parent[i]);\n}\nvoid Union(int x, int y) {\n  int xset = find(x);\n  int yset = find(y);\n  parent[xset] = yset;\n}\nvoid disjoin(int x, int y) {\n  int local = find(x);\n  if (local == find(y)) parent[local] = 0;\n}\nint main() {\n  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n  };\n  for (int i = 0; i < 2005; i++) parent[i] = i;\n  memset(num, 0, sizeof(num));\n  cin >> n >> k;\n  int x, y;\n  for (int i = 0; i < k; i++) {\n    cin >> x >> y;\n    Union(x, y);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> x >> y;\n    disjoin(x, y);\n  }\n  for (int i = 1; i <= n; i++) {\n    int local = find(i);\n    num[local]++;\n    if (local != 0 && num[local] > largest) largest = num[local];\n  }\n  cout << largest << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v[2003];\nset<int> s[2003], temp;\nint ans[2003];\nbool vis[2003];\nint cnt = 0;\nvoid dfs(int x) {\n  temp.insert(x);\n  vis[x] = 1;\n  cnt++;\n  for (int i = 0; i < v[x].size(); i++) {\n    if (!vis[v[x][i]]) dfs(v[x][i]);\n  }\n}\nint main() {\n  int bla = 0;\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  int k;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    s[a].insert(b);\n    s[b].insert(a);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (ans[i] == 0) {\n      temp.clear();\n      cnt = 0;\n      dfs(i);\n      for (auto nx : temp) {\n        for (auto nx1 : s[nx]) {\n          if (temp.find(nx1) != temp.end()) {\n            cnt = -1;\n            break;\n          }\n        }\n        if (cnt == -1) break;\n      }\n      for (auto nx : temp) {\n        ans[nx] = cnt;\n      }\n      bla = max(bla, cnt);\n    }\n    if (ans[i] == 0) ans[i] = 1;\n    bla = max(bla, ans[i]);\n  }\n  cout << bla << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 2e3 + 4;\nvector<int> circle;\nbool vis[N];\nbool bad_Relation[N][N];\nint parent[N];\nll chk[N];\nint color[N];\nint tim[N];\nint dis[N];\nint position[N];\nvector<int> adj[N];\nvector<int> adj1[N];\nvector<int> graph[N];\nbool has_cycle;\nint maxdis, maxnode, Totnode, depth = 1;\nbool ok;\nqueue<int> q;\nstack<int> stk;\nvector<int> solution;\nint indegree[N];\nint go[N];\nint to[N];\nll x1, x2, x3, x4, x5, x6;\nstring ss;\nint gn, gk;\nvector<int> vec;\nvoid dfs(int node) {\n  vis[node] = true;\n  vec.push_back(node);\n  for (int i = 0; i < adj[node].size(); i++) {\n    int u = adj[node][i];\n    if (!vis[u]) {\n      dfs(u);\n    }\n  }\n}\nbool check() {\n  for (int i = 0; i < vec.size(); i++) {\n    for (int j = 0; j < vec.size(); j++) {\n      if (bad_Relation[vec[i]][vec[j]]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int t = 1;\n  int cas = 0;\n  while (t--) {\n    int n, m, i, j, cnt = 0, cnt1 = 0, cnt2 = 0, even = 0, odd = 0, len, k, r,\n                    l, z = 0, x = 0, y = 0, flag = 0, sum = 0, tottal = 0;\n    int a = 0, b = 0, c = 0, d = 0, ans = 0, rem, quot, zero = 0, fst = 0,\n        null = 0, snd = 0, lst = 0, rone = 0, one = 0, pos = 0, neg = 0,\n        mn = INT_MAX, mx = INT_MIN;\n    char ch;\n    int h1, h2, m1, m2, h;\n    int velo1, velo2, ac1, ac2, tim, hour, mint, sec;\n    int node, edge, u, v, cost;\n    int bst, wrst;\n    double nd, ad, bd, cd, dd, xd, sumd = 0.00;\n    string str, str1 = \"\", str2 = \"\", str3 = \"\", strstore1 = \"\", strstore2 = \"\";\n    cin >> node >> edge;\n    for (i = 0; i < edge; i++) {\n      cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n    cin >> m;\n    for (i = 0; i < m; i++) {\n      cin >> u >> v;\n      bad_Relation[u][v] = true;\n      bad_Relation[v][u] = true;\n    }\n    ans = 0;\n    for (i = 1; i <= node; i++) {\n      if (!vis[i]) {\n        vec.clear();\n        dfs(i);\n        if (check()) {\n          x = vec.size();\n          ans = max(ans, x);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5, inf = 1e9 + 7;\nint siz[N], par[N];\nint _find(int x) {\n  if (x == par[x]) return x;\n  return par[x] = _find(par[x]);\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) siz[i] = 1, par[i] = i;\n  while (m--) {\n    int u, v;\n    cin >> u >> v;\n    int p = _find(u);\n    int q = _find(v);\n    if (p == q) continue;\n    par[p] = q;\n    siz[q] += siz[p];\n  }\n  cin >> m;\n  while (m--) {\n    int u, v;\n    cin >> u >> v;\n    int p = _find(u);\n    int q = _find(v);\n    if (p != q) continue;\n    siz[q] = 0;\n  }\n  int res = 0;\n  for (int i = 1; i <= n; i++) res = max(res, siz[_find(i)]);\n  cout << res << \"\\n\";\n}\n"
        },
        {
            "language": 3,
            "solution": "n = int(input())\nnum_likes = int(input())\nlike = [ [] for u in range(n + 1) ]\nfor i in range(num_likes):\n    u, v = map(int, input().split())\n    like[u].append(v)\n    like[v].append(u)\nnum_dislikes = int(input())\ndislike = [ (n + 1) * [ False ] for u in range(n + 1) ]\nfor i in range(num_dislikes):\n    u, v = map(int, input().split())\n    dislike[u][v] = True\n    dislike[v][u] = True\nresult = 0\n\nseen = (n + 1) * [ False ]\nfor u in range(1, n + 1):\n    if seen[u]:\n        continue\n    seen[u] = True\n    group = [ u ]\n    queue = [ u ]\n    tail = 0\n    while tail < len(queue):\n        u = queue[tail]\n        tail += 1\n        for v in like[u]:\n            if seen[v]:\n                continue\n            seen[v] = True\n            group.append(v)\n            queue.append(v)\n    okay = True\n    for i, u in enumerate(group):\n        for j in range(i + 1, len(group)):\n            v = group[j]\n            if dislike[u][v]:\n                okay = False\n                break\n        if not okay:\n            break\n    if okay:\n        result = max(result, len(group))\nprint(result)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint prime[1000000 + 5], in;\nbool isp[1000000 + 5];\nusing namespace std;\nvector<int> ar[2005], v1, v2;\nint vis[6000000];\nint flag[2005][2005];\nvoid dfs(int n) {\n  v1.push_back(n);\n  vis[n] = 1;\n  for (int i = 0; i < ar[n].size(); i++) {\n    if (!vis[ar[n][i]]) {\n      dfs(ar[n][i]);\n    }\n  }\n}\nint main() {\n  int n;\n  while (cin >> n) {\n    memset(vis, 0, sizeof(ar));\n    memset(flag, 0, sizeof(flag));\n    for (int i = 0; i < 1000; i++) {\n      ar[i].clear();\n    }\n    v1.clear();\n    v2.clear();\n    int k;\n    cin >> k;\n    int a, b;\n    for (int i = 0; i < k; i++) {\n      cin >> a >> b;\n      --a;\n      --b;\n      ar[a].push_back(b);\n      ar[b].push_back(a);\n    }\n    cin >> k;\n    for (int i = 0; i < k; i++) {\n      cin >> a >> b;\n      --a;\n      --b;\n      flag[a][b] = 1;\n      flag[b][a] = 1;\n    }\n    int flu = 0, mx = 0;\n    for (int i = 0; i < n; i++) {\n      if (!vis[i]) {\n        v1.clear();\n        dfs(i);\n        flu = 1;\n        for (int j = 0; j < v1.size() && flu; j++) {\n          for (int l = j + 1; l < v1.size() && flu; l++) {\n            if (flag[v1[j]][v1[l]]) flu = 0;\n          }\n        }\n        if (flu) mx = max(mx, (int)v1.size());\n      }\n    }\n    cout << mx << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> e[2000];\nint x[2000];\nint c[2000];\nvoid dfs(int from, int k) {\n  if (x[from] == 0) {\n    ++c[k];\n    x[from] = k;\n    for (int i = 0; i < e[from].size(); ++i) dfs(e[from][i], k);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  int m;\n  cin >> m;\n  while (m--) {\n    int a, b;\n    cin >> a >> b;\n    --a;\n    --b;\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n  int k = 1;\n  for (int i = 0; i < n; ++i)\n    if (x[i] == 0) dfs(i, k++);\n  set<int> cand;\n  for (int i = 1; i < k; ++i) cand.insert(i);\n  cin >> m;\n  while (m--) {\n    int a, b;\n    cin >> a >> b;\n    --a;\n    --b;\n    if (x[a] == x[b]) cand.erase(x[a]);\n  }\n  int ans = 0;\n  for (set<int>::iterator i = cand.begin(); i != cand.end(); ++i) {\n    ans = max(ans, c[*i]);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long po(long long a, long long b) {\n  if (b == 0) return 1;\n  long long ans = 1;\n  if (b % 2 == 0) {\n    ans = po(a, b / 2) % 1000000007;\n    ans = (ans % 1000000007 * ans % 1000000007) % 1000000007;\n  } else {\n    ans = po(a, (b - 1) / 2) % 1000000007;\n    ans = (ans % 1000000007 * ans % 1000000007 * a) % 1000000007;\n  }\n  return ans % 1000000007;\n}\nvector<string> tokens;\nvoid separate_string(string line) {\n  stringstream check1(line);\n  string lav;\n  while (getline(check1, lav, '*')) {\n    tokens.push_back(lav);\n  }\n}\nvector<long long> divisors;\nvoid get_Divisors(long long n) {\n  for (int i = 1; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      if (n / i == i) {\n        divisors.push_back(n / i);\n      } else {\n        divisors.push_back(i);\n        divisors.push_back(n / i);\n      }\n    }\n  }\n}\nbool sortbysec(const pair<int, int> &a, const pair<int, int> &b) {\n  return (a.second < b.second);\n}\nint parent[2002];\nint ran[2002];\nint findset(int i) {\n  if (parent[i] == -1) return i;\n  return parent[i] = findset(parent[i]);\n}\nvoid union_set(int x, int y) {\n  int sx = findset(x);\n  int sy = findset(y);\n  if (sx != sy) {\n    if (ran[sx] < ran[sy]) {\n      parent[sx] = sy;\n      ran[sy] = ran[sy] + ran[sx];\n      ran[sx] = 0;\n    } else {\n      parent[sy] = sx;\n      ran[sx] = ran[sx] + ran[sy];\n      ran[sy] = 0;\n    }\n  }\n}\nvoid solve() {\n  int n, m, i, j, u, v;\n  cin >> n >> m;\n  for (i = 0; i < 2002; i++) {\n    parent[i] = -1;\n    ran[i] = 1;\n  }\n  while (m--) {\n    cin >> u >> v;\n    union_set(u, v);\n  }\n  int k;\n  cin >> k;\n  while (k--) {\n    cin >> u >> v;\n    int aa = findset(u);\n    int bb = findset(v);\n    if (aa == bb) {\n      ran[aa] = 0;\n    }\n  }\n  int ma = 0;\n  for (i = 1; i <= n; i++) {\n    ma = max(ma, ran[i]);\n  }\n  cout << ma;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<pair<int, int> > > graph;\nint caninvite[2000];\nint visited[2000];\nint group[2000];\nint qg;\nint sz;\nbool invalid;\nvoid expand(int v) {\n  group[v] = qg;\n  visited[v] = true;\n  for (int i = 0; i < graph[v].size(); ++i) {\n    int nv = graph[v][i].first;\n    int r = graph[v][i].second;\n    if (r) {\n      if (!visited[nv]) expand(nv);\n    } else {\n      if (group[nv] == qg) {\n        invalid = true;\n      }\n    }\n  }\n  ++sz;\n}\nint main() {\n  memset(visited, 0, sizeof caninvite);\n  memset(group, -1, sizeof group);\n  int n;\n  cin >> n;\n  graph.assign(n, vector<pair<int, int> >());\n  int k;\n  cin >> k;\n  int a, b;\n  for (int i = 0; i < k; ++i) {\n    cin >> a >> b;\n    --a;\n    --b;\n    graph[a].push_back(make_pair(b, 1));\n    graph[b].push_back(make_pair(a, 1));\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    cin >> a >> b;\n    --a;\n    --b;\n    graph[a].push_back(make_pair(b, 0));\n    graph[b].push_back(make_pair(a, 0));\n  }\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    if (!visited[i]) {\n      sz = 0;\n      qg = i;\n      invalid = false;\n      expand(i);\n      if (!invalid) ans = max(ans, sz);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid bfs(vector<vector<int> >& G, vector<int>& CC, vector<bool>& exp, int start,\n         int cca, map<int, int>& count) {\n  queue<int> Q;\n  Q.push(start);\n  while (not Q.empty()) {\n    int v = Q.front();\n    Q.pop();\n    if (not exp[v]) {\n      CC[v] = cca;\n      ++count[cca];\n      exp[v] = true;\n      for (int i = 0; i < G[v].size(); ++i) Q.push(G[v][i]);\n    }\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<vector<int> > G(n);\n  vector<int> CC(n, -1);\n  vector<bool> exp(n, false);\n  int m;\n  cin >> m;\n  while (m--) {\n    int u, v;\n    cin >> u >> v;\n    G[u - 1].push_back(v - 1);\n    G[v - 1].push_back(u - 1);\n  }\n  int cca = 0;\n  map<int, int> count;\n  for (int i = 0; i < n; ++i) {\n    if (not exp[i]) bfs(G, CC, exp, i, cca, count), ++cca;\n  }\n  int p;\n  cin >> p;\n  while (p--) {\n    int odio1, odio2;\n    cin >> odio1 >> odio2;\n    if (CC[odio1 - 1] == CC[odio2 - 1]) {\n      map<int, int>::iterator it = count.find(CC[odio1 - 1]);\n      if (it != count.end()) count.erase(it);\n    }\n  }\n  int max = 0;\n  map<int, int>::iterator it = count.begin();\n  while (it != count.end()) {\n    if (it->second > max) max = it->second;\n    ++it;\n  }\n  cout << max << endl;\n}\n"
        },
        {
            "language": 1,
            "solution": "class var:\n  p=0\n  r=0\ns1=var()\narr=[]\nn=200001\nfor i in range(0,n):\n  c=var()\n  c.p=i\n  arr.append(c)\ndef find(i):\n  if arr[i].p!=i:\n    arr[i].p=find(arr[i].p)\n  return arr[i].p\ndef union(a,b):\n  xr=find(a)\n  yr=find(b)\n  if arr[xr].r<arr[yr].r:\n    arr[xr].p=yr\n    arr[yr].r+=1\n  elif arr[xr].r>arr[yr].r:\n    arr[yr].p=xr\n    arr[xr].r+=1\n  else:\n    arr[yr].p=xr\n    arr[xr].r+=1\n  #for i in arr:\n    #print i.p,i.r\n  #print \"hi\"\nn=input()\nk=input()\nfor _ in range(0,k):\n    a,b=map(int,raw_input().split())\n    union(a,b)\nans=[]\nfor i in range(0,n+2):\n  l2=[]\n  ans.append(l2)\nfor i in range(1,n+1):\n  val=find(i)\n  ans[val].append(i)\n#print ans\n\nt=input()\nz=[]\nfor _ in range(0,t):\n    a,b=map(int,raw_input().split())\n    z.append((a,b))\nfrom collections import *\nfv=[0]\nfor i in ans:\n\n    if len(i)>0:\n        ans=0\n        ck=Counter(i)\n        for j in z:\n            if j[0] in ck and j[1] in ck:\n                ans=-1\n                break\n        if ans==0:\n            fv.append(len(i))\nprint max(fv)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 3000;\nint n, k, m;\nvector<int> v[MAXN];\nint x, y;\nbool u[MAXN][MAXN];\nvector<vector<int> > a;\nbool vis[MAXN];\nint sum;\nvoid dfs(int uu) {\n  vis[uu] = true;\n  for (int i = 0; i < (int)(v[uu].size()); i++)\n    if (!vis[v[uu][i]]) dfs(v[uu][i]);\n  a.back().push_back(uu);\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < (int)(k); i++) {\n    cin >> x >> y;\n    x--, y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  cin >> m;\n  for (int i = 0; i < (int)(m); i++) {\n    cin >> x >> y;\n    x--, y--;\n    u[x][y] = true;\n    u[y][x] = true;\n  }\n  for (int i = 0; i < (int)(n); i++)\n    if (!vis[i]) {\n      a.push_back(vector<int>());\n      dfs(i);\n    }\n  for (int i = 0; i < (int)(a.size()); i++) {\n    bool flag = true;\n    for (int j = 0; j < (int)(a[i].size()); j++) {\n      for (int l = j + 1; l < a[i].size(); l++) {\n        if (u[a[i][j]][a[i][l]]) {\n          flag = false;\n          break;\n        }\n      }\n      if (!flag) break;\n    }\n    if (flag) sum = max(sum, (int)a[i].size());\n  }\n  cout << sum << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> vec(2002);\nint findind(int i);\nint main() {\n  int i, j, k, n, m, a, b, c;\n  cin >> n;\n  vector<int> res(n + 1, 0);\n  vector<int> incl(n + 1, 1);\n  for (i = 1; i <= n; i++) vec[i] = i;\n  cin >> k;\n  for (i = 0; i < k; i++) {\n    cin >> a >> b;\n    vec[findind(a)] = findind(b);\n  }\n  cin >> m;\n  for (i = 0; i < m; i++) {\n    cin >> a >> b;\n    if (findind(a) == findind(b)) {\n      incl[findind(a)] = 0;\n    }\n  }\n  for (i = 1; i <= n; i++) {\n    if (incl[findind(i)] == 1) res[findind(i)]++;\n  }\n  m = 0;\n  for (i = 1; i <= n; i++) {\n    m = max(m, res[i]);\n  }\n  cout << m << \"\\n\";\n  return 0;\n}\nint findind(int i) {\n  if (i == vec[i])\n    return i;\n  else\n    return findind(vec[i]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > G[2002];\nint vis[2002];\nvoid go(int i, int col) {\n  vis[i] = col;\n  for (int j = 0; j < G[i].size(); j++) {\n    int v = G[i][j].first;\n    int w = G[i][j].second;\n    if (w == 1) {\n      if (vis[v] != 3) go(v, col);\n    }\n  }\n  return;\n}\nint flag = 0;\nvoid dfs(int i, int col) {\n  if (flag == 1) {\n    return;\n  }\n  if (vis[i] == 3) {\n    return;\n  }\n  if (vis[i] == 0) {\n    vis[i] = col;\n  } else {\n    if (vis[i] != col) {\n      go(i, 3);\n      flag = 1;\n      return;\n    } else {\n      return;\n    }\n  }\n  if (col == 1) {\n    for (int j = 0; j < G[i].size(); j++) {\n      int v = G[i][j].first;\n      int w = G[i][j].second;\n      if (w == 1) {\n        dfs(v, 1);\n      } else {\n        dfs(v, 2);\n      }\n    }\n  } else {\n    for (int j = 0; j < G[i].size(); j++) {\n      int v = G[i][j].first;\n      int w = G[i][j].second;\n      if (w == 1) {\n        dfs(v, 2);\n      }\n    }\n  }\n}\nint main() {\n  int n, k, m;\n  cin >> n;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    G[a].push_back(make_pair(b, 1));\n    G[b].push_back(make_pair(a, 1));\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    G[a].push_back(make_pair(b, 2));\n    G[b].push_back(make_pair(a, 2));\n  }\n  int mx = 0;\n  for (int i = 1; i <= n; i++) {\n    flag = 0;\n    if (vis[i] == 0) {\n      dfs(i, 1);\n      if (flag == 0) {\n        int cnt = 0;\n        for (int j = 1; j <= n; j++) {\n          if (vis[j] == 1) {\n            vis[j] = 3;\n            cnt++;\n          } else if (vis[j] == 2) {\n            vis[j] = 0;\n          }\n        }\n        mx = max(mx, cnt);\n      }\n    }\n  }\n  cout << mx << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\n/**\n * 111118315581\n *\n * -3 3 2 3 2 3 2 3 -3 3 -3 3 -3 3 2 3\n *\n * @author pttrung\n */\npublic class C {\n\n    public static long x, y, gcd;\n    public static int Mod = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner();\n        PrintWriter out = new PrintWriter(System.out);\n        // PrintWriter out = new PrintWriter(new FileOutputStream(new File(\"output.txt\")));\n        int n = in.nextInt();\n        ArrayList<Integer>[] map = new ArrayList[n];\n          HashSet<Integer> []dis = new HashSet[n];\n        for (int i = 0; i < map.length; i++) {\n            map[i] = new ArrayList();\n            dis[i] = new HashSet();\n        }\n        int k = in.nextInt();\n        for (int i = 0; i < k; i++) {\n            int a = in.nextInt() - 1;\n            int b = in.nextInt() - 1;\n            map[a].add(b);\n            map[b].add(a);\n        }\n      \n        int m = in.nextInt();\n        for(int i = 0; i < m; i++){\n            int a = in.nextInt() - 1;\n            int b = in.nextInt() - 1;\n            dis[a].add(b);\n            dis[b].add(a);\n        }\n        boolean []visit = new boolean [n];\n        int result = 0;\n        for(int i = 0; i < n; i++){\n            if(!visit[i]){\n                HashSet<Integer> temp = new HashSet();\n                dfs(map, temp, visit,i);\n                boolean ok = true;\n                for(int cur : temp){\n                    for(int next : dis[cur]){\n                        if(temp.contains(next)){\n                            ok = false;\n                            break;\n                        }\n                    }\n                    if(!ok){\n                        break;\n                    }\n                }\n                if(ok){\n                    result = Math.max(result, temp.size());\n                }\n            }\n        }\n        out.println(result);\n        out.close();\n    }\n\n    public static void dfs(ArrayList<Integer>[] map ,HashSet<Integer> result, boolean []visit , int node){\n        visit[node] = true;\n        result.add(node);\n        for(int next : map[node]){\n            if(!visit[next]){\n                dfs(map, result , visit , next);\n            }\n        }\n        \n    }\n    \n    \n    public static long pow(long a, long b) {\n        if (b == 0) {\n            return 1;\n        }\n        long val = pow(a, b / 2);\n        if (b % 2 == 0) {\n            return val * val;\n        } else {\n            return val * val * a;\n        }\n    }\n\n    public static int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static void extendEuclid(long a, long b) {\n        if (b == 0) {\n            x = 1;\n            y = 0;\n            gcd = a;\n            return;\n        }\n        extendEuclid(b, a % b);\n        long x1 = y;\n        long y1 = x - (a / b) * y;\n        x = x1;\n        y = y1;\n\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() {\n            // System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n            //      br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"basketball_game.txt\"))));\n        }\n\n        public String next() {\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (int)1e9;\nconst long long INF64 = (long long)1e18;\nconst long double eps = 1e-9;\nconst long double pi = 3.14159265358979323846;\nbool ineedoutputfile = false;\nvector<int> g[2002];\nint used[2002];\nvoid dfs(int s, int cnt) {\n  used[s] = cnt;\n  for (int i = 0; i < int(g[s].size()); ++i)\n    if (!used[g[s][i]]) dfs(g[s][i], cnt);\n}\nint main() {\n  int n, t1, t2, k;\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < int(k); ++i) {\n    scanf(\"%d %d\", &t1, &t2);\n    t1--, t2--;\n    g[t1].push_back(t2);\n    g[t2].push_back(t1);\n  }\n  scanf(\"%d\", &k);\n  int cnt = 1;\n  for (int i = 0; i < int(n); ++i)\n    if (!used[i]) dfs(i, cnt), cnt++;\n  bool ok[2002];\n  memset(ok, true, sizeof(ok));\n  for (int i = 0; i < int(k); ++i) {\n    scanf(\"%d %d\", &t1, &t2);\n    t1--, t2--;\n    if (used[t1] != used[t2]) continue;\n    if (used[t1] == used[t2]) ok[used[t1]] = false;\n  }\n  int ans = 0;\n  for (int i = int(1); i <= int(cnt - 1); ++i) {\n    if (ok[i]) {\n      int res = 0;\n      for (int j = 0; j < int(n); ++j)\n        if (used[j] == i) res++;\n      ans = max(ans, res);\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class C1_177 {\n    static class DisjointSet {\n\n        private int[] id;\n        private int[] sz;\n        private int count;\n\n        public DisjointSet(int N) {\n            count = N;\n            id = new int[N];\n            sz = new int[N];\n            for (int i = 0; i < N; i++) {\n                id[i] = i;\n                sz[i] = 1;\n            }\n        }\n\n        public int count() {\n            return count;\n        }\n\n        public int find(int p) {\n            while (p != id[p])\n                p = id[p];\n            return p;\n        }\n\n        public boolean connected(int p, int q) {\n            return find(p) == find(q);\n        }\n\n        public void union(int p, int q) {\n            int i = find(p);\n            int j = find(q);\n            if (i == j)\n                return;\n\n            if (sz[i] < sz[j]) {\n                id[i] = j;\n                sz[j] += sz[i];\n            } else {\n                id[j] = i;\n                sz[i] += sz[j];\n            }\n            count--;\n        }\n    }\n\n    public static void main(String args[]) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        DisjointSet d = new DisjointSet(n);\n        HashMap<Integer, Integer> grp = new HashMap<Integer, Integer>();\n        int k = in.nextInt();\n        for (int i = 0; i < k; i++) {\n            int u = in.nextInt() - 1;\n            int v = in.nextInt() - 1;\n            d.union(u, v);\n        }\n        for (int i = 0; i < n; i++) {\n            int p = d.find(i);\n            if (grp.containsKey(p))\n                grp.put(p, grp.get(p) + 1);\n            else\n                grp.put(p, 1);\n        }\n        int m = in.nextInt();\n        for (int i = 0; i < m; i++) {\n            int u = in.nextInt() - 1;\n            int v = in.nextInt() - 1;\n            int a = d.find(u);\n            int b = d.find(v);\n            if (a == b)\n                grp.put(a, 0);\n        }\n        int max = Integer.MIN_VALUE;\n        for (int key : grp.keySet()) {\n            max = Math.max(max, grp.get(key));\n        }\n        System.out.println(max <= 0 ? 0 : max);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.util.Comparator;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractList;\nimport java.io.Writer;\nimport java.util.Collection;\nimport java.util.List;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Nguyen Trung Hieu - vuondenthanhcong11@yahoo.com\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC1 solver = new TaskC1();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskC1 {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int count = in.readInt();\n        int friendshipsCount = in.readInt();\n        IndependentSetSystem setSystem = new RecursiveIndependentSetSystem(count);\n        for (int i = 0; i < friendshipsCount; i++) {\n            int first = in.readInt() - 1;\n            int second = in.readInt() - 1;\n            setSystem.join(first, second);\n        }\n\n        int[] result = new int[count];\n        for (int i = 0; i < count; i++)\n            result[setSystem.get(i)]++;\n        int enemiesCount = in.readInt();\n        for (int i = 0; i < enemiesCount; i++) {\n            int first = in.readInt() - 1;\n            int second = in.readInt() - 1;\n            if (setSystem.get(first) == setSystem.get(second))\n                result[setSystem.get(first)] = 0;\n        }\n\n        out.printLine(CollectionUtils.maxElement(Array.wrap(result)));\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n\n    }\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}\n\ninterface IndependentSetSystem {\n    public boolean join(int first, int second);\n\n    int get(int index);\n\n    public static interface Listener {\n        public void joined(int joinedRoot, int root);\n    }\n}\n\nclass RecursiveIndependentSetSystem implements IndependentSetSystem {\n    private final int[] color;\n    private int setCount;\n    private Listener listener;\n\n    public RecursiveIndependentSetSystem(int size) {\n        color = new int[size];\n        for (int i = 0; i < size; i++)\n            color[i] = i;\n        setCount = size;\n    }\n\n    public RecursiveIndependentSetSystem(RecursiveIndependentSetSystem other) {\n        color = other.color.clone();\n        setCount = other.setCount;\n    }\n\n    public boolean join(int first, int second) {\n        first = get(first);\n        second = get(second);\n        if (first == second)\n            return false;\n        setCount--;\n        color[second] = first;\n        if (listener != null)\n            listener.joined(second, first);\n        return true;\n    }\n\n    public int get(int index) {\n        if (color[index] == index)\n            return index;\n        return color[index] = get(color[index]);\n    }\n\n    }\n\nclass CollectionUtils {\n\n    public static<T extends Comparable<T>> T maxElement(Iterable<T> collection) {\n        T result = null;\n        for (T element : collection) {\n            if (result == null || result.compareTo(element) < 0)\n                result = element;\n        }\n        return result;\n    }\n\n    }\n\nabstract class Array<T> extends AbstractList<T> {\n\n    public static List<Integer> wrap(int...array) {\n        return new IntArray(array);\n    }\n\n    protected static class IntArray extends Array<Integer> {\n        protected final int[] array;\n\n        protected IntArray(int[] array) {\n            this.array = array;\n        }\n\n        public int size() {\n            return array.length;\n        }\n\n        public Integer get(int index) {\n            return array[index];\n        }\n\n        public Integer set(int index, Integer value) {\n            int result = array[index];\n            array[index] = value;\n            return result;\n        }\n    }\n\n    }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nvector<int> adj[N], dislikes[N];\nint vis[N];\nset<int> temp;\nint mx = 0;\nint vid = 1;\nint ans = 0;\nvoid DFS(int u) {\n  vis[u] = vid;\n  for (int i : adj[u])\n    if (!vis[i]) DFS(i), temp.insert(i);\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int k;\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  int m;\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    dislikes[u].push_back(v);\n    dislikes[v].push_back(u);\n  }\n  for (int i = 1; i <= n; i++) {\n    int cnt = 0;\n    if (!vis[i]) {\n      temp.insert(i);\n      DFS(i);\n      cnt = temp.size();\n      for (auto it = temp.begin(); it != temp.end(); it++) {\n        for (auto it1 = it; it1 != temp.end(); it1++) {\n          auto found = find(dislikes[*it].begin(), dislikes[*it].end(), *it1);\n          if (found != dislikes[*it].end()) {\n            cnt = 0;\n            break;\n          }\n        }\n        if (!cnt) break;\n      }\n    }\n    ans = max(ans, cnt);\n    temp.clear();\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nint len(const T &c) {\n  return (int)c.size();\n}\ntemplate <class T>\nvoid cmin(T &a, T b) {\n  if (b < a) a = b;\n}\ntemplate <class T>\nvoid cmax(T &a, T b) {\n  if (b > a) a = b;\n}\nusing namespace std;\nint n, m, res;\nint w[2002];\nbool a[2002][2002];\nvector<int> ed[2002];\nvector<int> q;\nvoid dfs(int u) {\n  w[u] = 1;\n  q.push_back(u);\n  for (int i = 0; i < ((int)ed[u].size()); i++)\n    if (!w[ed[u][i]]) dfs(ed[u][i]);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    ed[u].push_back(v);\n    ed[v].push_back(u);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    a[u][v] = a[v][u] = 1;\n  }\n  for (int i = 1; i <= n; i++)\n    if (!w[i]) {\n      q.clear();\n      dfs(i);\n      bool ok = 1;\n      for (int j = 0; j < ((int)q.size()) && ok; j++)\n        for (int k = j + 1; k < ((int)q.size()) && ok; k++)\n          if (a[q[j]][q[k]]) ok = 0;\n      if (ok) res = max(res, ((int)q.size()));\n    }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint groupId[2001];\nvector<int> FGr[2001];\nint grSize[2001];\nvector<pair<int, int> > EN;\nint dfs(int n, int grid) {\n  groupId[n] = grid;\n  for (int i = 0; i < FGr[n].size(); i++) {\n    if (groupId[FGr[n][i]] == -1) {\n      dfs(FGr[n][i], grid);\n    }\n  }\n  return 0;\n}\nint main() {\n  memset(groupId, -1, sizeof(groupId));\n  int n;\n  scanf(\"%d\", &n);\n  int f;\n  scanf(\"%d\", &f);\n  for (int i = 0; i < f; i++) {\n    int from, to;\n    scanf(\"%d %d\", &from, &to);\n    --from;\n    --to;\n    FGr[from].push_back(to);\n    FGr[to].push_back(from);\n  }\n  int grid = -1;\n  for (int i = 0; i < n; i++) {\n    if (groupId[i] == -1) dfs(i, ++grid);\n  }\n  for (int i = 0; i < n; i++) {\n    grSize[groupId[i]]++;\n  }\n  ++grid;\n  vector<bool> FailedGroup(grid, false);\n  int e;\n  scanf(\"%d\", &e);\n  for (int i = 0; i < e; i++) {\n    int from, to;\n    scanf(\"%d %d\", &from, &to);\n    --from;\n    --to;\n    if (groupId[from] == groupId[to]) {\n      FailedGroup[groupId[from]] = true;\n    }\n  }\n  int maxS = 0;\n  for (int i = 0; i < grid; i++) {\n    if (!FailedGroup[i]) maxS = max(maxS, grSize[i]);\n  }\n  printf(\"%d\\n\", maxS);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayDeque;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        byte F = 1;\n        byte H = 2;\n        \n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        byte[][] a = new byte[n + 1][n + 1];\n        int u, v;\n        \n        int k = sc.nextInt();\n        for (int i = 0; i < k; i++) {\n            u = sc.nextInt();\n            v = sc.nextInt();\n            a[u][v] = a[v][u] = F;\n        }\n        \n        int m = sc.nextInt();\n        for (int i = 0; i < m; i++) {\n            u = sc.nextInt();\n            v = sc.nextInt();\n            a[u][v] = a[v][u] = H;\n        }\n        \n        boolean[] d = new boolean[n + 1];\n        ArrayDeque<Integer> s = new ArrayDeque<Integer>();\n        \n        boolean[] fr = new boolean[n + 1];\n        \n        int count;\n        int max_count = 0;\n        for (u = 1; u <= n; u++) {\n            if (!d[u]) {\n                s.push(u);\n                count = 0;\n                for (int i = 1; i <= n; i++) {\n                    fr[i] = false;\n                }\n                fr[u] = true;\n                while (!s.isEmpty()) {\n                    u = s.pop();\n                    d[u] = true;\n                    count++;\n                    for (v = 1; v <= n; v++) {\n                        if (a[u][v] == F && !fr[v]) {\n                            fr[v] = true;\n                            s.push(v);\n                        }\n                        else if (a[u][v] == H && fr[v]) {\n                            s.clear();\n                            count = 0;\n                            break;\n                        }\n                    }\n                }\n                \n                if (count > max_count) {\n                    max_count= count;\n                }\n            }\n        }\n        \n        System.out.println(max_count);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    static int maxn=2001;\n    static int parent[]=new int[maxn];\n    static int rnk[]=new int[maxn];\n    static boolean bad[][]=new boolean[maxn][maxn];\n    static ArrayList<Integer>[] cmp=new ArrayList[maxn];\n\n\n    static int _find(int v) {\n        if(v==parent[v]){\n            return v;\n        }\n        return parent[v]=_find(parent[v]);\n    }\n    static void unit(int a,int b) {\n        a = _find(a);\n        b = _find(b);\n        if (a != b) {\n            if (rnk[a] < rnk[b])\n                parent[a] = b;\n            else {\n                if (rnk[a] == rnk[b])\n                    ++rnk[a];\n                parent[b] = a;\n            }\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        String s=bf.readLine();\n\n        int n=Integer.parseInt(s);\n        s=bf.readLine();\n        int k=Integer.parseInt(s);\n\n        for(int i=1; i<=n; ++i)\n            parent[i]=i;\n        for(int i=1; i<=k; ++i) {\n            s=bf.readLine();\n            StringTokenizer st=new StringTokenizer(s);\n            int u=Integer.parseInt(st.nextToken());\n            int v=Integer.parseInt(st.nextToken());\n            unit(u,v);\n        }\n        s=bf.readLine();\n        int m=Integer.parseInt(s);\n        for(int i=1; i<=m; ++i) {\n            s=bf.readLine();\n            StringTokenizer st=new StringTokenizer(s);\n            int u=Integer.parseInt(st.nextToken());\n            int v=Integer.parseInt(st.nextToken());\n            bad[u][v]=bad[v][u]=true;\n        }\n        for(int i=1; i<=n; ++i)\n            cmp[i]=new ArrayList<>();\n        for(int i=1; i<=n; ++i)\n            cmp[_find(i)].add(i);\n\n        int ans=0;\n        for(int i=1; i<=n; ++i){\n            if (cmp[i].isEmpty())\n                continue;\n            boolean good=true;\n            for(int j=0; j<cmp[i].size(); ++j )\n                for(int e=j+1; e<cmp[i].size(); ++e)\n                    if (bad[cmp[i].get(j)][cmp[i].get(e)])\n                        good=false;\n            if (good)\n                ans=Math.max(ans,cmp[i].size());\n        }\n        PrintWriter pw=new PrintWriter(System.out);\n        pw.print(ans);\n        pw.close();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long hell = 1e9 + 7;\nlong long inf = 1e18;\nconst long long N = 1e5 + 9;\nbool prime(long long n) {\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\nlong long power(long long a, long long b, long long m) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % m;\n    b /= 2;\n    a = (a * a) % m;\n  }\n  return ans;\n}\nset<long long> adj[N], jkl[N];\nlong long parent[N];\nlong long f[N];\nvoid initial() {\n  for (long long i = 0; i < N; i++) {\n    parent[i] = i;\n    adj[i].insert(i);\n  }\n}\nlong long find(long long u) {\n  if (u == parent[u]) return u;\n  return find(parent[u]);\n}\nvoid union_(long long u, long long v) {\n  long long u_rep = find(u);\n  long long v_rep = find(v);\n  if (u_rep == v_rep) return;\n  if (adj[u_rep].size() >= adj[v_rep].size()) {\n    for (auto x : adj[v_rep]) adj[u_rep].insert(x);\n    adj[v_rep].clear();\n    parent[v_rep] = u_rep;\n  } else {\n    for (auto x : adj[u_rep]) adj[v_rep].insert(x);\n    adj[u_rep].clear();\n    parent[u_rep] = v_rep;\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t = 1;\n  while (t--) {\n    initial();\n    long long n;\n    cin >> n;\n    vector<pair<long long, long long>> v;\n    long long m;\n    cin >> m;\n    for (long long i = 0; i < m; i++) {\n      long long x, y;\n      cin >> x >> y;\n      jkl[x].insert(y);\n      jkl[y].insert(x);\n      union_(x, y);\n    }\n    cin >> m;\n    for (long long i = 0; i < m; i++) {\n      long long x, y;\n      cin >> x >> y;\n      long long x_rep = find(x);\n      long long y_rep = find(y);\n      if (x_rep == y_rep) {\n        for (auto u : jkl[y]) {\n          if (jkl[x].lower_bound(u) != jkl[x].end()) adj[x_rep].clear();\n        }\n        if (adj[x_rep].size()) {\n          adj[x_rep].erase(y);\n          adj[y_rep].erase(x);\n        }\n      }\n    }\n    long long ans = 0;\n    for (long long i = 1; i <= n; i++) {\n      ans = max(ans, (long long)adj[i].size());\n    }\n    cout << ans;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization(\"unroll-loops\")\nusing namespace std;\nlong long binpow(long long base, long long exp, int mod) {\n  long long res = 1;\n  while (exp > 0) {\n    if (exp % 2 == 1) res = (res * base) % mod;\n    exp = exp >> 1;\n    base = (base * base) % mod;\n  }\n  return res;\n}\nlong long mod(long long x) {\n  return ((x % 1000000007LL + 1000000007LL) % 1000000007LL);\n}\nlong long add(long long a, long long b) { return mod(mod(a) + mod(b)); }\nlong long mul(long long a, long long b) { return mod(mod(a) * mod(b)); }\nbool isPrime(int n) {\n  if (n <= 1) return false;\n  for (int i = 2; i * i <= n; i++)\n    if (n % i == 0) return false;\n  return true;\n}\nlong long int n, k, m;\nvector<bool> vis;\nvector<long long int> friends;\nvector<pair<long long int, vector<long long int>>> groups;\nvector<pair<long long int, long long int>> enemy;\nunordered_map<long long int, vector<long long int>> adj;\nbool mysort(pair<long long int, vector<long long int>>& a,\n            pair<long long int, vector<long long int>>& b) {\n  if (a.first > b.first) {\n    return true;\n  } else {\n    return false;\n  }\n}\nlong long int connected_nodes = 0;\nvoid dfs(int x) {\n  vis[x] = true;\n  connected_nodes++;\n  friends.push_back(x);\n  for (auto u : adj[x]) {\n    if (vis[u] == false) {\n      dfs(u);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n;\n  cin >> k;\n  vis.resize(n + 1, false);\n  for (long long int i = 1; i <= k; i++) {\n    long long int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  cin >> m;\n  for (long long int i = 1; i <= m; i++) {\n    long long int a, b;\n    cin >> a >> b;\n    enemy.push_back({a, b});\n  }\n  for (int i = 1; i <= n; i++) {\n    friends.clear();\n    if (vis[i] == false) {\n      connected_nodes = 0;\n      dfs(i);\n      groups.push_back({connected_nodes, friends});\n    }\n  }\n  sort(groups.begin(), groups.end(), mysort);\n  for (auto x : groups) {\n    long long int count = 0;\n    vector<long long int> now = x.second;\n    for (auto y : enemy) {\n      long long int a = y.first;\n      long long int b = y.second;\n      if (find(now.begin(), now.end(), a) != now.end() &&\n          find(now.begin(), now.end(), b) != now.end()) {\n        count++;\n      }\n    }\n    if (count == 0) {\n      cout << x.first;\n      return 0;\n    }\n  }\n  cout << 0;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint parent[2000 + 342];\nint sizze[2000 + 342];\nbool possible[2000 + 342];\nvoid init(int n) {\n  for (int i = 1; i <= n; i++) {\n    parent[i] = i;\n    sizze[i] = 1;\n    possible[i] = true;\n  }\n}\nint root(int x) {\n  while (parent[x] != x) {\n    parent[x] = parent[parent[x]];\n    x = parent[x];\n  }\n  return x;\n}\nvoid uni(int a, int b) {\n  int ra, rb;\n  ra = root(a);\n  rb = root(b);\n  if (ra == rb) return;\n  if (sizze[ra] < sizze[rb]) {\n    parent[ra] = rb;\n    sizze[rb] += sizze[ra];\n  } else {\n    parent[rb] = ra;\n    sizze[ra] += sizze[rb];\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n, k;\n  cin >> n;\n  init(n);\n  cin >> k;\n  int x, y;\n  while (k--) {\n    cin >> x >> y;\n    uni(x, y);\n  }\n  cin >> k;\n  while (k--) {\n    cin >> x >> y;\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      possible[x] = false;\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (possible[i]) {\n      if (parent[i] == i) {\n        ans = max(ans, sizze[i]);\n      }\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\n\npublic class DisJoinSetUnion {\n\n    int[] Parent;\n    int[] Group;\n    int[] counts;\n\n    public DisJoinSetUnion(int n) {\n        Parent = new int[n ];\n        Group = new int[n];\n        counts = new int[n];\n        for (int i = 0; i < n ; i++) {\n            Parent[i] = i;\n            Group[i] = 1;\n            counts[i] = 0;\n        }\n    }\n\n    int FindLeader(int node) {\n        if (Parent[node] == node) {\n            return node;\n        }\n        return Parent[node] = FindLeader(Parent[node]);\n    }\n\n    boolean SameSet(int i, int k) {\n        int leader1 = FindLeader(i);\n        int leader2 = FindLeader(k);\n        return leader1 == leader2;\n    }\n\n    void MergeGroup(int i, int k) {\n        int leader1 = FindLeader(i);\n        int leader2 = FindLeader(k);\n        if (leader1 == leader2) {\n            return;\n        }\n        counts[i] = 1;\n        counts[k] = 1;\n\n        int a = FindLeader(i);\n        int b = FindLeader(k);\n\n        Parent[a] = b;\n        Group[b] = Group[b] + Group[a];\n        Group[a] = 0;\n    }\n\n    int GetSize(int node) {\n        int leader = FindLeader(node);\n        return Group[leader];\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        DisJoinSetUnion dsu = new DisJoinSetUnion(n);\n        int k = in.nextInt();\n        int[] Dis = new int[n ];\n        for (int i = 0; i < k; i++) {\n            int f = in.nextInt()-1;\n            int s = in.nextInt()-1;\n            dsu.MergeGroup(f, s);\n        }\n\n        k = in.nextInt();\n        for (int i = 0; i < k; i++) {\n            int u = in.nextInt()-1;\n            int v = in.nextInt()-1;\n            if (dsu.SameSet(u, v)) {\n                Dis[dsu.FindLeader(u)] = 1;\n            }\n        }\n\n        int max = 0;\n        for (int i = 0; i < dsu.Group.length; i++) {\n            int g = dsu.FindLeader(i);\n            if (Dis[g] != 0) {\n                continue;\n            } else {\n                max = Math.max(max, dsu.Group[g]);\n            }\n        }\n        System.out.println(max);\n\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tvoid run() throws IOException {\n\t\tint n = cin.nextInt();\n\t\tint good[][] = new int[n][n];\n\t\tint bad[][] = new int[n][n];\n\n\t\tint u, v, m;\n\t\tm = cin.nextInt();\n\t\twhile (m-- > 0) {\n\t\t\tu = cin.nextInt() - 1;\n\t\t\tv = cin.nextInt() - 1;\n\t\t\tgood[u][v] = good[v][u] = 1;\n\t\t}\n\t\tm = cin.nextInt();\n\t\twhile (m-- > 0) {\n\t\t\tu = cin.nextInt() - 1;\n\t\t\tv = cin.nextInt() - 1;\n\t\t\tbad[u][v] = bad[v][u] = 1;\n\t\t}\n\n\t\tfor (int k = 0; k < n; ++k)\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\tif (good[i][k] == 1 && good[k][j] == 1)\n\t\t\t\t\t\tgood[i][j] = 1;\n\t\t\t\t}\n\n\t\tint mx = (1 << n) - 1;\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= mx; ++i) {\n\t\t\tint f = 1;\n\t\t\tfor (int j = 0; f == 1 && j < n; ++j)\n\t\t\t\tif ((i >> j & 1) == 1)\n\t\t\t\t\tfor (int k = 0; f == 1 && k < n; ++k) {\n\t\t\t\t\t\tif ((i >> k & 1) == 1 && k != j) {\n\t\t\t\t\t\t\tif (good[j][k] == 0 || bad[j][k] == 1)\n\t\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (good[j][k] == 1 && (i >> k & 1) == 0)\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t}\n\t\t\tif (f > 0) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\tif ((i >> j & 1) == 1)\n\t\t\t\t\t\t++cnt;\n\t\t\t\tif (cnt > ans)\n\t\t\t\t\tans = cnt;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tMain() {\n\t\t// cin = new InputReader(System.in);\n\t\tcin = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t}\n\n\tPrintWriter out;\n\t// InputReader cin;\n\n\tScanner cin;\n\n\tclass InputReader {\n\t\tInputReader(InputStream in) {\n\t\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\t\t// try {\n\t\t\t// reader = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t// } catch (FileNotFoundException ex) {\n\t\t\t// }\n\t\t\ttokenizer = new StringTokenizer(\"\");\n\t\t}\n\n\t\tprivate String next() throws IOException {\n\t\t\twhile (!tokenizer.hasMoreTokens()) {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic Integer nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tprivate BufferedReader reader;\n\t\tprivate StringTokenizer tokenizer;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long parent[10000];\nlong long find(long long x) {\n  if (parent[parent[x]] == parent[x]) return parent[x];\n  return parent[x] = find(parent[x]);\n}\nvoid unite(long long x, long long y) {\n  long long px = find(x);\n  long long py = find(y);\n  if (px != py) parent[py] = px;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n + 1; i++) parent[i] = i;\n  for (int i = 0; i < m; i++) {\n    long long x, y;\n    cin >> x >> y;\n    unite(x, y);\n  }\n  long long k;\n  cin >> k;\n  set<long long> s;\n  for (int i = 0; i < k; i++) {\n    long long x, y;\n    cin >> x >> y;\n    long long px = find(x);\n    long long py = find(y);\n    if (px == py) s.insert(px);\n  }\n  map<long long, long long> ma;\n  for (int i = 1; i <= n; i++) {\n    long long pi = find(i);\n    if (ma.find(pi) == ma.end())\n      ma[pi] = 1;\n    else\n      ma[pi]++;\n  }\n  long long ans = 0;\n  for (auto it : ma) {\n    long long x, y;\n    x = it.first;\n    y = it.second;\n    if (s.find(x) == s.end()) ans = max(ans, y);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint f[2002], num[2002];\nvoid init() {\n  for (int i = 1; i <= n; ++i) {\n    f[i] = i;\n    num[i] = 1;\n  }\n}\nint getroot(int x) { return x == f[x] ? x : f[x] = getroot(f[x]); }\nvoid unions(int x, int y) {\n  x = getroot(x);\n  y = getroot(y);\n  if (x == y) return;\n  if (num[x] > num[y]) {\n    num[f[y] = x] += num[y];\n    num[y] = 0;\n  } else {\n    num[f[x] = y] += num[x];\n    num[x] = 0;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int mmin = 0, x, y, m;\n  cin >> n >> m;\n  init();\n  for (int i = 0; i < m; ++i) {\n    cin >> x >> y;\n    unions(x, y);\n  }\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    cin >> x >> y;\n    if (getroot(x) == getroot(y)) num[getroot(x)] = 0;\n  }\n  for (int i = 1; i <= n; ++i) {\n    mmin = max(mmin, num[i]);\n  }\n  cout << mmin << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Template implements Runnable {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init() throws FileNotFoundException {\n        try {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } catch (Exception e) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n    }\n\n    class GraphBuilder {\n        int n, m;\n        int[] x, y;\n        int index;\n        int[] size;\n\n\n        GraphBuilder(int n, int m) {\n            this.n = n;\n            this.m = m;\n            x = new int[m];\n            y = new int[m];\n            size = new int[n];\n        }\n\n        void add(int u, int v) {\n            x[index] = u;\n            y[index] = v;\n            size[u]++;\n            size[v]++;\n            index++;\n        }\n\n        int[][] build() {\n            int[][] graph = new int[n][];\n            for (int i = 0; i < n; i++) {\n                graph[i] = new int[size[i]];\n            }\n            for (int i = index - 1; i >= 0; i--) {\n                int u = x[i];\n                int v = y[i];\n                graph[u][--size[u]] = v;\n                graph[v][--size[v]] = u;\n            }\n            return graph;\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    int[] readIntArray(int size) throws IOException {\n        int[] res = new int[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readInt();\n        }\n        return res;\n    }\n\n    long[] readLongArray(int size) throws IOException {\n        long[] res = new long[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readLong();\n        }\n        return res;\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    <T> List<T>[] createGraphList(int size) {\n        List<T>[] list = new List[size];\n        for (int i = 0; i < size; i++) {\n            list[i] = new ArrayList<>();\n        }\n        return list;\n    }\n\n    public static void main(String[] args) {\n        new Template().run();\n        // new Thread(null, new Template(), \"\", 1l * 200 * 1024 * 1024).start();\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    long memoryTotal, memoryFree;\n\n    void memory() {\n        memoryFree = Runtime.getRuntime().freeMemory();\n        System.err.println(\"Memory = \" + ((memoryTotal - memoryFree) >> 10)\n                + \" KB\");\n    }\n\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            memoryTotal = Runtime.getRuntime().freeMemory();\n            init();\n            solve();\n            out.close();\n            if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n                time();\n                memory();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    void dfs(int x, boolean[][] friend, boolean[] used, List<Integer> component) {\n        component.add(x);\n        used[x] = true;\n        for (int to = 0; to < friend.length; to++) {\n            if (friend[x][to]) {\n                if (!used[to]) {\n                    dfs(to, friend, used, component);\n                }\n            }\n        }\n    }\n\n    void solve() throws IOException {\n        int n = readInt();\n        boolean[][] friend = new boolean[n][n];\n        boolean[][] enemies = new boolean[n][n];\n        int k = readInt();\n        while (k-- > 0) {\n            int x = readInt() - 1;\n            int y = readInt() - 1;\n            friend[x][y] = friend[y][x] = true;\n        }\n        k = readInt();\n        while (k-- > 0) {\n            int x = readInt() - 1;\n            int y = readInt() - 1;\n            enemies[x][y] = enemies[y][x] = true;\n        }\n        boolean[] used = new boolean[n];\n        int size = 0;\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                List<Integer> list = new ArrayList<>();\n                dfs(i, friend, used, list);\n                boolean ok = true;\n                for (int f = 0; f < list.size(); f++) {\n                    for (int s = 0; s < list.size(); s++) {\n                        if (enemies[list.get(f)][list.get(s)]) {\n                            ok = false;\n                        }\n                    }\n                }\n                if (ok) {\n                    size = Math.max(size, list.size());\n                }\n            }\n        }\n        out.println(size);\n\n\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<long long>> graph(2002);\nbool visit[2002];\nunordered_set<long long> us;\nvoid dfs(long long n) {\n  if (visit[n] == true) return;\n  us.insert(n);\n  visit[n] = true;\n  for (auto u : graph[n]) dfs(u);\n}\nint main() {\n  memset(visit, sizeof(visit), false);\n  long long n, m;\n  cin >> n;\n  cin >> m;\n  for (long long i = 0; i < m; i++) {\n    long long x, y;\n    cin >> x >> y;\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n  long long k;\n  cin >> k;\n  vector<pair<long long, long long>> vct(k);\n  for (long long i = 0; i < k; i++) cin >> vct[i].first >> vct[i].second;\n  if (n == 0) {\n    cout << \"0\" << endl;\n    exit(0);\n  }\n  long long max = 0;\n  for (long long i = 1; i <= m; i++) {\n    us.clear();\n    bool condition = true;\n    if (visit[i] == false) dfs(i);\n    for (long long i = 0; i < k; i++) {\n      if (us.find(vct[i].first) != us.end() &&\n          us.find(vct[i].second) != us.end()) {\n        condition = false;\n        break;\n      } else\n        condition == true;\n    }\n    if (condition == true) {\n      if (us.size() > max) max = us.size();\n    }\n  }\n  bool cond = true;\n  for (long long i = 1; i <= n; i++) {\n    if (visit[i] == false) cond = false;\n  }\n  if (cond == false && max == 0)\n    cout << 1 << endl;\n  else\n    cout << max << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> parent(1000001);\nmap<long long int, long long int> urank;\nvoid create(long long int x) {\n  parent[x] = x;\n  urank[x] = 0;\n}\nlong long int find(long long int x) {\n  if (parent[x] != x) {\n    parent[x] = find(parent[x]);\n  }\n  return parent[x];\n}\nvoid merge(long long int x, long long int y) {\n  long long int xroot = find(x);\n  long long int yroot = find(y);\n  if (urank[xroot] <= urank[yroot]) {\n    parent[xroot] = yroot;\n    urank[yroot] = urank[yroot] + urank[xroot];\n  } else {\n    parent[yroot] = xroot;\n    urank[xroot] = urank[xroot] + urank[yroot];\n  }\n}\nvoid solve() {\n  long long int n, m1, m2;\n  cin >> n >> m1;\n  for (long long int i = 1; i < n + 1; i++) create(i);\n  for (long long int i = 0; i < m1; i++) {\n    long long int a, b;\n    cin >> a >> b;\n    if (find(a) != find(b)) merge(a, b);\n  }\n  map<long long int, long long int> m;\n  for (long long int i = 1; i < n + 1; i++) {\n    m[find(i)]++;\n  }\n  cin >> m2;\n  for (long long int i = 0; i < m2; i++) {\n    long long int a, b;\n    cin >> a >> b;\n    long long int root1 = find(a);\n    long long int root2 = find(b);\n    if (root1 == root2) m.erase(root1);\n  }\n  map<long long int, long long int>::iterator it;\n  long long int max = 0;\n  for (it = m.begin(); it != m.end(); it++) {\n    if (it->second > max) max = it->second;\n  }\n  cout << max;\n}\nsigned main() {\n  std::ios::sync_with_stdio(false);\n  int T = 1;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class C177 {\n\n    static int[] comps;\n    static boolean[] used;\n    static ArrayList<Integer>[] g;\n    static int comp;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        g = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            g[i] = new ArrayList<Integer>();\n        }\n        int m = Integer.parseInt(in.readLine());\n        for (int i = 0; i < m; i++) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int a = Integer.parseInt(st.nextToken()) - 1;\n            int b = Integer.parseInt(st.nextToken()) - 1;\n            g[a].add(b);\n            g[b].add(a);\n        }\n        comps = new int[n];\n        used = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                comp++;\n                dfs(i);\n            }\n        }\n        int[] amComps = new int[comp];\n        for (int i = 0 ; i < n ; i++)\n            amComps[comps[i] - 1]++;\n        m = Integer.parseInt(in.readLine());\n        for (int i = 0; i < m; i++) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int a = Integer.parseInt(st.nextToken()) - 1;\n            int b = Integer.parseInt(st.nextToken()) - 1;\n            if (comps[a] == comps[b]) {\n                amComps[comps[a] - 1] = -1;\n            }\n        }\n        int res = 0;\n        for (int i = 0 ; i < comp ; i++)\n            res = Math.max(res , amComps[i]);\n        System.out.println(res);\n    }\n\n    public static void dfs(int v) {\n        used[v] = true;\n        comps[v] = comp;\n        for (int i = 0; i < g[v].size(); i++) {\n            int to = g[v].get(i);\n            if (!used[to]) {\n                dfs(to);\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve();\nint main() {\n  solve();\n  return 0;\n}\nconst int maxV = 2000;\nconst int maxE = 2000 * (2000 - 1) / 2;\nint terminal1[maxE + 1];\nint terminal2[maxE + 1];\nint head[maxV + 1];\nint next_el[maxE + 1];\nint k = 0;\nvoid add(int u, int v, int t) {\n  k++;\n  terminal1[k] = v;\n  terminal2[k] = t;\n  next_el[k] = head[u];\n  head[u] = k;\n}\nint dest[maxV + 1];\nset<int> mn[maxV + 1];\nint kol_mn = 0;\nvoid DFS(int v) {\n  dest[v] = 1;\n  mn[kol_mn].insert(v);\n  int i = head[v];\n  while (i > 0) {\n    v = terminal1[i];\n    if (terminal2[i] && dest[v] == 0) {\n      DFS(v);\n    }\n    i = next_el[i];\n  }\n}\nint dest1[maxV + 1];\nint BFS(int v, int mn_kol) {\n  queue<int> och;\n  och.push(v);\n  dest[v] = 1;\n  int i;\n  while (!och.empty()) {\n    v = och.front();\n    och.pop();\n    i = head[v];\n    while (i > 0) {\n      v = terminal1[i];\n      if (dest1[v] == 0 && terminal2[i] == 1) {\n        och.push(v);\n        dest1[v] = 1;\n      } else {\n        if (terminal2[i] == 0 && mn[mn_kol].find(v) != mn[mn_kol].end()) {\n          break;\n        }\n      }\n      i = next_el[i];\n    }\n    if (i) {\n      break;\n    }\n  }\n  if (!och.empty()) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\nvoid solve() {\n  memset(dest, 0, sizeof(dest));\n  memset(dest1, 0, sizeof(dest1));\n  int n, K, m;\n  scanf(\"%d %d\", &n, &K);\n  int u, v;\n  for (int i = 0; i < K; i++) {\n    scanf(\"%d %d\", &u, &v);\n    add(u, v, 1);\n    add(v, u, 1);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d\", &u, &v);\n    add(u, v, 0);\n    add(v, u, 0);\n  }\n  int max_size = 0;\n  for (int i = 1; i <= n; i++) {\n    if (dest[i] == 0) {\n      DFS(i);\n      if (BFS(*mn[kol_mn].begin(), kol_mn)) {\n        if (max_size < mn[kol_mn].size()) {\n          max_size = mn[kol_mn].size();\n        }\n      }\n      kol_mn++;\n    }\n  }\n  cout << max_size;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint par[2010], notinvited[2010];\nint root(int i) { return par[i] < 0 ? i : (par[i] = root(par[i])); }\nvoid merge(int x, int y) {\n  if ((x = root(x)) == (y = root(y))) return;\n  if (par[y] < par[x]) swap(x, y);\n  par[x] += par[y];\n  par[y] = x;\n}\nint main() {\n  int n, k, m, x, y;\n  cin >> n >> k;\n  for (int i = 0; i <= n; ++i) par[i] = -1;\n  for (int i = 0; i < k; ++i) {\n    cin >> x >> y;\n    merge(x, y);\n  }\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    cin >> x >> y;\n    if ((x = root(x)) == (y = root(y))) notinvited[x] = 1;\n  }\n  int cnt = 0;\n  for (int i = 1; i <= n; ++i)\n    if (par[i] < 0 && notinvited[i] == 0) cnt = max(cnt, -par[i]);\n  cout << cnt << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nunordered_map<int, vector<int> > g;\nmap<pair<int, int>, int> li;\nunordered_map<int, bool> visited, dislikevisited;\nint bfs(int i) {\n  queue<int> q;\n  visited[i] = true;\n  q.push(i);\n  int c = 1;\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (auto v : g[u]) {\n      if (li[{u, v}] == 1 && dislikevisited[u] == true) return 0;\n      if (li[{u, v}] == -1) {\n        dislikevisited[v] = true;\n      }\n      if (li[{u, v}] == 1 && !visited[v]) {\n        visited[v] = true;\n        ++c;\n        q.push(v);\n      }\n    }\n  }\n  return c;\n}\nint dfs(int n) {\n  int i, j, c, m = 0, f;\n  for (i = 1; i <= n; ++i) {\n    if (!visited[i]) {\n      dislikevisited.clear();\n      c = 0;\n      f = 0;\n      c = bfs(i);\n      m = max(m, c);\n    }\n  }\n  return m;\n}\nint main() {\n  int n;\n  cin >> n;\n  int i, j, u, v, k, m;\n  cin >> k;\n  for (i = 1; i <= k; ++i) {\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n    li[{u, v}] = li[{v, u}] = 1;\n  }\n  cin >> m;\n  for (i = 1; i <= m; ++i) {\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n    li[{u, v}] = li[{v, u}] = -1;\n  }\n  int ans = dfs(n);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> like[2010];\nbool dislike[2010][2010], visted[2010];\nvoid DFS(int x, int father, vector<int>& friends) {\n  friends.push_back(x);\n  visted[x] = true;\n  for (int i = 0; i < like[x].size(); ++i) {\n    if (like[x][i] != father && !visted[like[x][i]]) {\n      DFS(like[x][i], x, friends);\n    }\n  }\n}\nint check(int x) {\n  vector<int> friends;\n  DFS(x, -1, friends);\n  for (int i = 0; i < friends.size(); ++i) {\n    for (int j = 0; j < friends.size(); ++j) {\n      if (dislike[friends[i]][friends[j]]) {\n        return 0;\n      }\n    }\n  }\n  return friends.size();\n}\nint main() {\n  int n;\n  while (cin >> n) {\n    int k, m, x, y;\n    cin >> k;\n    for (int i = 0; i < k; ++i) {\n      cin >> x >> y;\n      like[x].push_back(y), like[y].push_back(x);\n    }\n    cin >> m;\n    for (int i = 0; i < m; ++i) {\n      cin >> x >> y;\n      dislike[x][y] = dislike[y][x] = true;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n      if (!visted[i]) {\n        ans = max(ans, check(i));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint parent[2100], invalid[2100], vis[2100];\nstd::vector<int> comp[2100], adj[2100];\nvoid dfs(int v, int index) {\n  if (vis[v]) return;\n  vis[v] = 1;\n  comp[index].push_back(v);\n  parent[v] = index;\n  for (int i = 0; i < adj[v].size(); i++) {\n    dfs(adj[v][i], index);\n  }\n}\nint main() {\n  int n, i, m, index, temp1, temp2, ans = 0;\n  scanf(\"%d\", &n);\n  int k;\n  scanf(\"%d\", &k);\n  for (i = 0; i < k; i++) {\n    scanf(\"%d\", &temp1);\n    scanf(\"%d\", &temp2);\n    adj[temp1].push_back(temp2);\n    adj[temp2].push_back(temp1);\n  }\n  scanf(\"%d\", &m);\n  index = 0;\n  for (i = 1; i <= n; i++) {\n    if (!vis[i]) dfs(i, index++);\n  }\n  for (i = 0; i < m; i++) {\n    scanf(\"%d\", &temp1);\n    scanf(\"%d\", &temp2);\n    if (parent[temp1] == parent[temp2]) invalid[parent[temp1]] = 1;\n  }\n  for (i = 0; i < index; i++) {\n    if (!invalid[i]) ans = max(ans, (int)comp[i].size());\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint parent[(long long int)(1e6)], s[(long long int)(1e6)];\nint findroot(int x) {\n  if (x == parent[x]) return x;\n  return parent[x] = findroot(parent[x]);\n}\nvoid initial(int n = (long long int)(1e6) - 1) {\n  for (int i = 1; i <= n; i++) {\n    parent[i] = i;\n    s[i] = 1;\n  }\n}\nvoid make_union(int a, int b) {\n  a = findroot(a);\n  b = findroot(b);\n  if (a != b) {\n    if (s[a] < s[b]) swap(a, b);\n    parent[b] = a;\n    s[a] += s[b];\n  }\n}\nvoid solve() {\n  int n, k, m, ans = 0;\n  cin >> n >> k;\n  vector<bool> eligible(n + 1, 1);\n  initial(n + 1);\n  while (k--) {\n    int u, v;\n    cin >> u >> v;\n    make_union(u, v);\n  }\n  cin >> m;\n  while (m--) {\n    int u, v;\n    cin >> u >> v;\n    if (findroot(u) == findroot(v)) {\n      eligible[parent[u]] = 0;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    ans =\n        eligible[findroot(i)] ? (ans > s[parent[i]] ? ans : s[parent[i]]) : ans;\n  }\n  cout << ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "class DSNode:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n        self.correct = True\n\n    def __str__(self):\n        return str(self.find().val)\n\n    def find(self):\n        x = self\n        if x != x.parent:\n            x.parent = x.parent.find()\n        return x.parent\n\ndef union(x, y):\n    x = x.find()\n    y = y.find()\n    if x == y:\n        return\n    if x.rank > y.rank:\n        y.parent = x\n    else:\n        x.parent = y\n        if x.rank == y.rank:\n            y.rank += 1\n\n\n# Amount of people\nn = int(input())\n\n# Pairs of friends\nk = int(input())\n\nP = [DSNode(x) for x in range(n+1)]\n\nfor i in range(k):\n    u, v = map(int, input().split(' '))\n    union(P[u], P[v])\n\n# Pairs of people who dislike each other\nm = int(input())\n\nfor i in range(m):\n    u, v = map(int, input().split(' '))\n    u1, v1 = P[u].find(), P[v].find()\n\n    if u1 == v1:\n        u1.correct = False\n\nmax_size = 0\nA = [0 for _ in range(n + 1)]\n\nfor i in range(1, n+1):\n    p = P[i]\n    p = p.find()\n    if p.correct:\n        A[p.val] += 1\n\nprint(max(A))\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class C implements Runnable {\n\n\tclass Edge {\n\t\tint a, b;\n\n\t\tEdge(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n\tArrayList<Edge> graph;\n\tArrayList<Integer>[] g;\n\tboolean used[];\n\tint[][] d;\n\tint[] p, r;\n\tint n, ans, count;\n\tboolean ok;\n\n\tprivate void Solution() throws IOException {\n\t\tn = nextInt();\n\t\tg = new ArrayList[n];\n\t\td = new int[n][n];\n\t\tgraph = new ArrayList<Edge>();\n\t\tp = new int[n];\n\t\tr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[i] = i;\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new ArrayList<Integer>();\n\t\tint k = nextInt();\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint x = nextInt() - 1, y = nextInt() - 1;\n\t\t\tgraph.add(new Edge(x, y));\n\t\t\tunite(x, y);\n\t\t\td[x][y] = 1;\n\t\t\td[y][x] = 1;\n\t\t}\n\t\tint m = nextInt();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x = nextInt() - 1, y = nextInt() - 1;\n\t\t\tif (get(x) == get(y))\n\t\t\t\tgraph.add(new Edge(x, y));\n\t\t\td[x][y] = 2;\n\t\t\td[y][x] = 2;\n\t\t}\n\t\tfor (Edge edge : graph) {\n\t\t\tg[edge.a].add(edge.b);\n\t\t\tg[edge.b].add(edge.a);\n\t\t}\n\t\tused = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!used[i]) {\n\t\t\t\tcount = 0;\n\t\t\t\tok = true;\n\t\t\t\tdfs(i);\n\t\t\t\tif (ok)\n\t\t\t\t\tans = Math.max(ans, count);\n\t\t\t}\n\t\t}\n\t\tprint(ans);\n\t}\n\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\tcount++;\n\t\tfor (int next : g[v]) {\n\t\t\tif (d[v][next] == 2)\n\t\t\t\tok = false;\n\t\t\tif (!used[next])\n\t\t\t\tdfs(next);\n\t\t}\n\t}\n\n\tint get(int v) {\n\t\treturn v == p[v] ? v : (p[v] = get(p[v]));\n\t}\n\n\tvoid unite(int a, int b) {\n\t\ta = get(a);\n\t\tb = get(b);\n\t\tif (a != b) {\n\t\t\tif (r[a] < r[b]) {\n\t\t\t\tint temp = b;\n\t\t\t\tb = a;\n\t\t\t\ta = temp;\n\t\t\t}\n\t\t\tp[b] = a;\n\t\t\tif (r[a] == r[b])\n\t\t\t\tr[a]++;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew C().run();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tokenizer;\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tSolution();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\n\tvoid print(Object... o) {\n\t\tfor (int i = 0; i < o.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\tout.print(\" \");\n\t\t\tout.print(o[i]);\n\t\t}\n\t}\n\n\tvoid println(Object... o) {\n\t\tfor (int i = 0; i < o.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\tprint(\" \");\n\t\t\tprint(o[i]);\n\t\t}\n\t\tprint(\"\\n\");\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() throws NumberFormatException, IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tString nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tString next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\ttokenizer = new StringTokenizer(nextLine());\n\t\treturn tokenizer.nextToken();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint father[2005];\nint c[2005];\nint N, M;\nint sum[2005];\nint getfather(int x) {\n  return father[x] == x ? x : father[x] = getfather(father[x]);\n}\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  for (int i = 1; i <= N; i++) father[i] = i;\n  for (int i = 1; i <= M; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    a = getfather(a);\n    b = getfather(b);\n    if (a != b) father[a] = b;\n  }\n  scanf(\"%d\", &M);\n  for (int i = 1; i <= M; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    a = getfather(a);\n    b = getfather(b);\n    if (a == b) c[a] |= 1;\n  }\n  memset(sum, 0, sizeof(sum));\n  for (int i = 1; i <= N; i++)\n    if (!c[getfather(i)]) sum[getfather(i)]++;\n  int ret = 0;\n  for (int i = 1; i <= N; i++) ret = max(ret, sum[i]);\n  cout << ret << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/stack:67108864\")\nusing namespace std;\ntemplate <class T>\ninline T abs(T a) {\n  return (a) > 0 ? (a) : -(a);\n}\ntemplate <class T>\ninline T sqr(T a) {\n  return (a) * (a);\n}\nconst long double PI = 3.1415926535897932, EPS = 1E-9;\nconst int INF = 1000 * 1000 * 1000, NMAX = 100005;\nint ans = 0, cur = 0;\nint used[NMAX];\nvector<pair<int, int> > g[NMAX];\nbool fail = false;\nint y = 0;\nvoid dfs(int v, int prev) {\n  if (fail) return;\n  ++cur;\n  used[v] = y;\n  for (int i = 0; i < int((g[v]).size()); ++i) {\n    if (fail) return;\n    int to = g[v][i].first;\n    if (to == prev) continue;\n    int t = g[v][i].second;\n    if (t == 1) {\n      if (used[to] == 0) dfs(to, v);\n    } else {\n      if (used[to] == y) fail = true;\n    }\n  }\n}\nint main() {\n  for (int i = 0; i < int(NMAX); ++i) used[i] = 0;\n  int n, k, m;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < int(k); ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    --u, --v;\n    g[u].push_back(make_pair(v, 1));\n    g[v].push_back(make_pair(u, 1));\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < int(m); ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    --u, --v;\n    g[u].push_back(make_pair(v, 2));\n    g[v].push_back(make_pair(u, 2));\n  }\n  for (int i = 0; i < int(n); ++i)\n    if (used[i] == 0) {\n      ++y;\n      fail = false;\n      cur = 0;\n      dfs(i, i);\n      if (!fail) ans = max(ans, cur);\n    }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, a, b, k = 0, t1, t2, m;\n  cin >> n;\n  vector<int> c(n);\n  for (int i = 0; i < n; i++) c[i] = 0;\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b;\n    if (c[a - 1] == 0 && c[b - 1] == 0) {\n      k++;\n      c[a - 1] = k;\n      c[b - 1] = k;\n    }\n    if (c[a - 1] == 0 && c[b - 1] > 0) c[a - 1] = c[b - 1];\n    if (c[b - 1] == 0 && c[a - 1] > 0) c[b - 1] = c[a - 1];\n    if (c[b - 1] && c[a - 1] && c[b - 1] != c[a - 1]) {\n      t1 = max(c[a - 1], c[b - 1]);\n      t2 = min(c[a - 1], c[b - 1]);\n      for (int j = 0; j < n; j++) {\n        if (c[j] == t1) c[j] = t2;\n        if (c[j] > t1) c[j]--;\n      }\n      k--;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (c[i] == 0) {\n      k++;\n      c[i] = k;\n    }\n  }\n  vector<int> numb(k);\n  for (int i = 0; i < k; i++) numb[i] = 0;\n  for (int i = 0; i < n; i++) {\n    numb[c[i] - 1]++;\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b;\n    if (c[a - 1] == c[b - 1]) numb[c[a - 1] - 1] = 0;\n  }\n  sort(numb.begin(), numb.end());\n  ;\n  cout << numb[k - 1] << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> adj[100100];\nvector<int> enemies[100100];\nbool vis[100100];\nset<int> curgroup;\nvoid dfs(int a) {\n  if (vis[a]) return;\n  vis[a] = true;\n  curgroup.insert(a);\n  for (int i = 0; i < (int)adj[a].size(); i++) {\n    int b = adj[a][i];\n    dfs(b);\n  }\n}\nint main() {\n  int n, k, m;\n  cin >> n;\n  cin >> k;\n  while (k--) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  cin >> m;\n  while (m--) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    enemies[a].push_back(b);\n  }\n  int bestsz = 0;\n  for (int i = 0; i < n; i++) {\n    if (vis[i]) continue;\n    curgroup.clear();\n    dfs(i);\n    bool ok = true;\n    for (set<int>::iterator iter = curgroup.begin(); iter != curgroup.end();\n         iter++) {\n      int a = *iter;\n      for (int j = 0; j < (int)enemies[a].size(); j++) {\n        int b = enemies[a][j];\n        if (curgroup.count(b)) {\n          ok = false;\n          break;\n        }\n      }\n      if (!ok) break;\n    }\n    if (ok) bestsz = max(bestsz, (int)curgroup.size());\n  }\n  cout << bestsz << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> adj[1000005];\nlong long vis[1000005];\nvector<long long int> a[1000005];\nvector<long long int> v[1000005];\nlong long q[1000005];\nlong long n, k, m;\nlong long c = 1;\nvoid dfs(long long i, long long p) {\n  if (vis[i]) return;\n  vis[i] = c;\n  v[p].push_back(i);\n  for (auto x : adj[i]) {\n    dfs(x, p);\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  for (long long i = 1; i <= k; i++) {\n    long long x, y;\n    cin >> x >> y;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  cin >> m;\n  for (long long i = 1; i <= m; i++) {\n    long long x, y;\n    cin >> x >> y;\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  long long z = 0;\n  for (long long i = 1; i <= n; i++) {\n    dfs(i, i);\n    for (auto x : v[i]) {\n      for (auto y : a[x]) {\n        if (vis[y] == c) {\n          q[i] = -1;\n          break;\n        }\n      }\n      if (q[i] == -1) {\n        break;\n      }\n    }\n    c++;\n  }\n  long long ans = 0;\n  for (long long i = 1; i <= n; i++) {\n    if (q[i] != -1 && v[i].size() > 0) {\n      long long sz = v[i].size();\n      ans = max(ans, sz);\n    }\n  }\n  cout << ans << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  t = 1;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbitset<2005> used, b;\nvector<int> like[2005], dislike[2005];\nint n;\nint solve(int idx) {\n  b.reset();\n  queue<int> q;\n  q.push(idx);\n  b.set(idx);\n  used.set(idx);\n  int ans = 1;\n  bool flag = false;\n  while (!q.empty()) {\n    int curr = q.front();\n    q.pop();\n    for (int i = 0; i < like[curr].size(); i++) {\n      int u = like[curr][i];\n      if (b.test(u)) continue;\n      for (int j = 0; !flag && j < dislike[u].size(); j++) {\n        int v = dislike[u][j];\n        if (b.test(v)) flag = true;\n      }\n      q.push(u);\n      b.set(u);\n      used.set(u);\n      ans++;\n    }\n  }\n  if (flag) return 0;\n  return ans;\n}\nint solve() {\n  int ans = 0;\n  used.reset();\n  for (int i = 1; i <= n; i++) {\n    if (used.test(i)) continue;\n    ans = max(ans, solve(i));\n  }\n  return ans;\n}\nint main() {\n  int k, m, u, v;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; i++) {\n    scanf(\"%d%d\", &u, &v);\n    like[u].push_back(v);\n    like[v].push_back(u);\n  }\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    dislike[u].push_back(v);\n    dislike[v].push_back(u);\n  }\n  printf(\"%d\\n\", solve());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5000;\nint p[MAXN], size[MAXN], n, m;\nint find_set(int v) { return v == p[v] ? v : p[v] = find_set(p[v]); }\nvoid union_set(int x, int y) {\n  x = find_set(x);\n  y = find_set(y);\n  if (x != y) {\n    if (size[x] < size[y]) swap(x, y);\n    p[x] = y;\n    size[y] += size[x];\n  }\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) size[i] = 1, p[i] = i;\n  while (m--) {\n    int x, y;\n    cin >> x >> y;\n    union_set(x, y);\n  }\n  int mx = 0;\n  cin >> m;\n  while (m--) {\n    int x, y;\n    cin >> x >> y;\n    if (find_set(x) == find_set(y)) size[find_set(x)] = 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    mx = max(mx, size[find_set(i)]);\n  }\n  cout << mx << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2020;\nlong long par[N], c[N];\nlong long getpar(int x) {\n  if (x == par[x]) return x;\n  return par[x] = getpar(par[x]);\n}\nbool mrg(int x, int y) {\n  x = getpar(x);\n  y = getpar(y);\n  if (x == y) return 1;\n  c[x] += c[y];\n  par[y] = x;\n  return 1;\n}\nint main() {\n  int n, m, x;\n  cin >> n;\n  for (int i = 0; i <= n; i++) {\n    par[i] = i;\n    c[i] = 1;\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    if (getpar(x) != getpar(y)) mrg(x, y);\n  }\n  cin >> x;\n  for (int i = 0; i < x; i++) {\n    int x, y;\n    cin >> x >> y;\n    x = getpar(x);\n    y = getpar(y);\n    if (getpar(x) == getpar(y)) c[x] = -1;\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n; i++) ans = max(ans, c[getpar(i)]);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class bfs_dfs { \n\tpublic static ArrayList<Integer> x;\n\tpublic static TreeSet<Integer> X;\n\tpublic static boolean t;\n\tpublic static vertex[] V;\n\tpublic static boolean[] vis;\n\tpublic static void main(String[] args)\n\t{\t\t\n\t\tmYScanner in = new mYScanner();\n\t\tint n = in.nextInt();\n\t\t V = new vertex[n+1];\n\t\tfor(int i = 1;i<=n;i++)\n\t\t{\n\t\t\tV[i] = new vertex();\n\t\t\tV[i].value = i;\n\t\t}\n\t\tint k = in.nextInt();\n\t\tfor(int i = 0;i<k;i++)\n\t\t{\n\t\t\tint src = in.nextInt();\n\t\t\tint dest = in.nextInt();\n\t\t\tV[src].frnd.add(dest);\n\t\t\tV[dest].frnd.add(src);\n\t\t}\n\t\tint m = in.nextInt();\n\t\tfor(int i = 0;i<m;i++)\n\t\t{\n\t\t\tint src = in.nextInt();\n\t\t\tint dest = in.nextInt();\n\t\t\tV[src].hate.add(dest);\n\t\t\tV[dest].hate.add(src);\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 1;i<=n;i++)\n\t\t{\n\t\t\tvis = new boolean[n+1];\n\t\t\tx = new ArrayList<>();\n\t\t\tX = new TreeSet<>();\n\t\t\tx.add(i);\n\t\t\tX.addAll(V[i].hate);\n\t\t\tt = true;\n\t\t\tif(!vis[i])\n\t\t\t{\n\t\t\t\tvis[i] = true;\n\t\t\t\tdfs(V[i]);\n\t\t\t}\n\t\t\tif(t && x.size()>ans)\n\t\t\t{\n\t\t\t\tans = x.size();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static void dfs(vertex v)\n\t{\n\t\tfor(int i = 0;t && i<v.frnd.size();i++)\n\t\t{\n\t\t\tif(X.contains(v.frnd.get(i)))\n\t\t\t    t = false;\n\t\t\telse if(!vis[v.frnd.get(i)])\n\t\t\t{\n\t\t\t\tx.add(v.frnd.get(i));\n\t\t\t\tX.addAll(V[v.frnd.get(i)].hate);\n\t\t\t\tvis[v.frnd.get(i)] = true;\n\t\t\t\tdfs(V[v.frnd.get(i)]);\n\t\t\t}\n\t\t}\n\t}\n}\nclass vertex\n{\n     int value;\n     ArrayList<Integer> frnd = new ArrayList<>();\n     TreeSet<Integer> hate = new TreeSet<>(); \n }\n\tclass mYScanner\n{\n\tBufferedReader br ;\n\tStringTokenizer st;\n\t\n\tpublic mYScanner()\n\t{\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tst = null;\n\t}\n\t public String next() {\n\t        while (st == null || !st.hasMoreElements()) {\n\t            try {\n\t                st = new StringTokenizer(br.readLine());\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t        return st.nextToken();\n\t    }\n\tpublic int nextInt()\n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\tpublic long nextLong()\n\t{\n\t  return\tLong.parseLong(next());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 20010;\nint father[maxn];\nbool Not[maxn];\nint cnt[maxn];\nvoid init() {\n  for (int i = 0; i < maxn; ++i) father[i] = i;\n  memset(Not, false, sizeof(Not));\n  memset(cnt, 0, sizeof(cnt));\n}\nint find(int x) {\n  if (father[x] != x) father[x] = find(father[x]);\n  return father[x];\n}\nvoid Union(int a, int b) {\n  a = find(a);\n  b = find(b);\n  if (a == b) return;\n  father[a] = b;\n}\nint main() {\n  int n, k, m;\n  int u, v;\n  while (scanf(\"%d\", &n) != EOF) {\n    init();\n    scanf(\"%d\", &k);\n    for (int i = 0; i < k; ++i) {\n      scanf(\"%d %d\", &u, &v);\n      Union(u, v);\n    }\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; ++i) {\n      scanf(\"%d %d\", &u, &v);\n      if (find(u) == find(v)) {\n        Not[find(u)] = true;\n      }\n    }\n    int ret = 0;\n    for (int i = 1; i <= n; ++i) {\n      if (!Not[find(i)]) cnt[find(i)]++;\n    }\n    for (int i = 1; i <= n; ++i) ret = max(ret, cnt[i]);\n    printf(\"%d\\n\", ret);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n = 0;\nint **relation;\nbool *invited;\nint *result_set;\nint cur_num = 0;\nbool canInvite(int x) {\n  for (int i = 0; i < cur_num; i++) {\n    if (relation[x][result_set[i]] == -1) {\n      return false;\n    }\n  }\n  return true;\n}\nvoid fill(bool *filled, int x, bool value) {\n  invited[x] = value;\n  filled[x] = true;\n  for (int i = 0; i < n; i++) {\n    if (relation[x][i] == 1 && filled[i] == false) {\n      fill(filled, i, value);\n    }\n  }\n}\nvoid fillHisFriends(int x, bool value) {\n  bool *filled;\n  filled = new bool[n];\n  for (int i = 0; i < n; i++) {\n    filled[i] = false;\n  }\n  fill(filled, x, value);\n}\nbool invite(int x) {\n  if (invited[x] == true) {\n    return true;\n  }\n  if (canInvite(x) == true) {\n    result_set[cur_num++] = x;\n    invited[x] = true;\n  } else {\n    fillHisFriends(x, true);\n    cur_num = 0;\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    if (relation[x][i] == 1) {\n      if (invite(i) == false) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nint main() {\n  cin >> n;\n  invited = new bool[n];\n  result_set = new int[n];\n  relation = new int *[n];\n  for (int i = 0; i < n; i++) {\n    relation[i] = new int[n];\n    invited[i] = false;\n    for (int j = 0; j < n; j++) {\n      relation[i][j] = 0;\n    }\n  }\n  int likes = 0;\n  cin >> likes;\n  for (int i = 0; i < likes; i++) {\n    int m = 0, n = 0;\n    cin >> m >> n;\n    relation[m - 1][n - 1] = 1;\n    relation[n - 1][m - 1] = 1;\n  }\n  int dislikes = 0;\n  cin >> dislikes;\n  for (int i = 0; i < dislikes; i++) {\n    int m = 0, n = 0;\n    cin >> m >> n;\n    relation[m - 1][n - 1] = -1;\n    relation[n - 1][m - 1] = -1;\n  }\n  int result = 0;\n  for (int i = 0; i < n; i++) {\n    if (invited[i] == false) {\n      cur_num = 0;\n      if (invite(i) == true) {\n        if (cur_num > result) {\n          result = cur_num;\n        }\n      }\n    }\n  }\n  cout << result;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000007;\nconst int N = 100100;\nint adj[N], link_[N], head[N], x[N], y[N], n, m, k;\nint lab[N], d[N], ans, num, ed, nd;\nvoid dfs(int u) {\n  lab[u] = num;\n  d[++nd] = u;\n  int i = head[u];\n  while (i) {\n    int v = adj[i];\n    if (!lab[v]) dfs(v);\n    i = link_[i];\n  }\n}\nvoid add(int u, int v) {\n  link_[++ed] = head[u];\n  head[u] = ed;\n  adj[ed] = v;\n}\nint main() {\n  int u, v;\n  cin >> n >> m;\n  for (int i = 1; i <= m; i++) {\n    cin >> u >> v;\n    add(u, v);\n    add(v, u);\n  }\n  cin >> k;\n  for (int i = 1; i <= k; i++) cin >> x[i] >> y[i];\n  for (int i = 1; i <= n; i++)\n    if (!lab[i]) {\n      bool ok = true;\n      num++;\n      nd = 0;\n      dfs(i);\n      for (int ii = 1; ii <= nd; ii++)\n        for (int j = 1; j <= k; j++)\n          if (d[ii] == x[j]) {\n            if (lab[d[ii]] == lab[y[j]]) ok = false;\n          } else if (d[ii] == y[j] && lab[d[ii]] == lab[x[j]])\n            ok = false;\n      if (ok) ans = max(ans, nd);\n    }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass DSU {\n public:\n  vector<int> parent, rank;\n  void MakeSet(int x) {\n    parent[x] = x;\n    rank[x] = 0;\n  }\n  int Find(int x) { return (x == parent[x] ? x : parent[x] = Find(parent[x])); }\n  void Union(int x, int y) {\n    if ((x = Find(x)) == (y = Find(y))) return;\n    if (rank[x] < rank[y])\n      parent[x] = y;\n    else\n      parent[y] = x;\n    if (rank[x] == rank[y]) ++rank[x];\n  }\n  DSU(int n) {\n    parent.assign(n + 10, 0);\n    rank.assign(n + 10, 0);\n    for (int i = 0; i < n + 3; i++) parent[i] = i;\n  };\n};\nint main() {\n  int n, k, m;\n  cin >> n >> k;\n  DSU dsu(n);\n  int l, j;\n  for (int i = 0; i < k; i++) {\n    cin >> j >> l;\n    dsu.Union(j, l);\n  }\n  vector<int> size(n + 10);\n  vector<int> can(n + 10);\n  for (int i = 1; i <= n; i++) {\n    dsu.parent[i] = dsu.Find(i);\n    size[dsu.parent[i]]++;\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> j >> l;\n    if (dsu.parent[j] == dsu.parent[l]) can[dsu.parent[j]] = 1;\n  }\n  int max = 0;\n  for (int i = 1; i <= n; i++)\n    if (can[i] == 0 && i == dsu.parent[i] && max < size[i]) max = size[i];\n  cout << max;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.awt.*;\nimport java.io.*;\nimport java.math.*;\npublic class Tests{\n\tstatic Scanner in = new Scanner (System.in);\t\n\tstatic PrintWriter out = new PrintWriter (System.out);\n\n\tpublic static void main (String []args) throws IOException{\n\t\t\n\t\tint n = in.nextInt(); int e = in.nextInt();\n\t\tint unlike [] = new int [n];\n\n\t\tDUS o = new DUS (n);\n\t\tfor(int i = 0 ; i<e ; i++){\n\t\t\to.union(in.nextInt()-1,in.nextInt()-1);\n\t\t}\n\t\tint unlikee = in.nextInt();\n\t\t\n\t\tfor(int i  = 0 ;i<unlikee ; i++){\n\t\t\tint u = in.nextInt()-1; int v = in.nextInt()-1;\n\t\t\tif(o.isSameSet(u, v)){\n\t\t\t\tunlike[o.findSet(u)] = 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tint max = 0;\n\t\t//for(int i = 0 ;i<o.sizes.length ; i++){\n\t   //   out.println(o.sizes[i]+\" \");\n\t\t//}\n\t\n\t//\tout.println();\n\t\tfor(int i = 0 ; i<o.sizes.length ; i++){\n\t\t\tint num = o.findSet(i);\n\t\t\tif(unlike[num] != 0)continue;\n\t\t\t\n\t\t\tmax = Math.max(max,o.sizes[num]);\n\t\t}\n\t\t\n\t\t\n\t\tout.println(max);\n\t\t\n\n\t\n\t  out.flush();\n\tout.close();\n\t\t\t\t\n\t}\n\t\n\n}\nclass DUS {\n\n\tstatic int count;\n\tstatic int[] arr;\n\tstatic int[] sizes;\n\tstatic int[] counts;\n\t\n\tDUS(int n)\n\t{\n\t\tcount = n;\n\t\tarr = new int[n];\n\t\tsizes = new int[n];\n\t\tcounts = new int[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tarr[i] = i;\n\t\t\tsizes[i] = 1;\n\t\t\tcounts[i] = 0;\n\t\t}\n\t}\n\t\n\tstatic int findSet(int i)\n\t{\n\t\tif(arr[i] == i)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn findSet(arr[i]);\n\t\t}\n\t}\n\t\n\tstatic boolean isSameSet(int i, int j)\n\t{\n\t\treturn findSet(i) == findSet(j);\n\t}\n\t\n\tvoid union(int i, int j)\n\t{\n\t\tif(isSameSet(i,j))\n\t\t\treturn;\n\t\t\n\t\tcounts[i] = 1;\n\t\tcounts[j] = 1;\n\t\t\n\t\tint a = findSet(i);\n\t\tint b = findSet(j);\n\t\t\n\t\tarr[a] = b;\n\t\tsizes[b] = sizes[b] + sizes[a];\n\t\tsizes[a] = 0;\n\t}\n\t\n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> g[2005], g2[2005];\nint v[2005], x, ans;\nvoid dfs(int u) {\n  v[u] = 1, x++;\n  for (auto it : g[u]) {\n    if (v[it] == 0) dfs(it);\n  }\n  for (auto it : g2[u]) {\n    if (v[it]) x = 0;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k, l;\n  cin >> n >> k;\n  while (k--) {\n    int a, b;\n    cin >> a >> b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  cin >> l;\n  while (l--) {\n    int a, b;\n    cin >> a >> b;\n    g2[a].push_back(b);\n    g2[b].push_back(a);\n  }\n  for (int i = 1; i <= n; i++) {\n    x = 0;\n    dfs(i);\n    ans = max(ans, x);\n    memset(v, 0, sizeof(v));\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import sun.reflect.generics.tree.Tree;\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.net.Inet4Address;\nimport java.text.DecimalFormat;\nimport java.util.*;\n\n\npublic class Newbie {\n\n    static InputReader sc = new InputReader(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        solver s = new solver();\n        long t = 1;\n        while (t > 0) {\n            s.solve();\n            t--;\n        }\n        out.close();\n    }\n\n       /* static class descend implements Comparator<pair1> {\n            public int compare(pair1 o1, pair1 o2) {\n                if (o1.pop != o2.pop)\n                    return (int) (o1.pop - o2.pop);\n                else\n                    return o1.in - o2.in;\n            }\n        }*/\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream), 32768);\n            token = null;\n        }\n\n        public String sn() {\n            while (token == null || !token.hasMoreTokens()) {\n                try {\n                    token = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(sn());\n        }\n\n        public String snl() throws IOException {\n            return br.readLine();\n        }\n\n        public long nlo() {\n            return Long.parseLong(sn());\n        }\n\n        public double nd() {\n            return Double.parseDouble(sn());\n        }\n\n        public int[] na(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = sc.ni();\n            return a;\n        }\n\n        public long[] nal(int n) {\n            long a[] = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = sc.nlo();\n            return a;\n        }\n    }\n\n    static class ascend implements Comparator<pair> {\n        public int compare(pair o1, pair o2) {\n            return o2.b - o1.b;\n        }\n    }\n\n    static class extra {\n\n        static boolean v[] = new boolean[100001];\n        static List<Integer> l = new ArrayList<>();\n        static int t;\n\n        static void shuffle(int a[]) {\n            for (int i = 0; i < a.length; i++) {\n                int t = (int) Math.random() * a.length;\n                int x = a[t];\n                a[t] = a[i];\n                a[i] = x;\n            }\n        }\n\n        static void shufflel(long a[]) {\n            for (int i = 0; i < a.length; i++) {\n                int t = (int) Math.random() * a.length;\n                long x = a[t];\n                a[t] = a[i];\n                a[i] = x;\n            }\n        }\n\n        static long gcd(long a, long b) {\n            if (b == 0)\n                return a;\n            else\n                return gcd(b, a % b);\n        }\n\n        static boolean valid(int i, int j, int r, int c) {\n            if (i >= 0 && i < r && j >= 0 && j < c) {\n                // System.out.println(i+\" /// \"+j);\n                return true;\n            } else {\n                //  System.out.println(i+\" //f \"+j);\n                return false;\n            }\n        }\n\n        static void seive() {\n            for (int i = 2; i < 101; i++) {\n                if (!v[i]) {\n                    t++;\n                    l.add(i);\n                    for (int j = 2 * i; j < 101; j += i)\n                        v[j] = true;\n                }\n            }\n        }\n\n        static int binary(LinkedList<Integer> a, long val, int n) {\n            int mid = 0, l = 0, r = n - 1, ans = 0;\n            while (l <= r) {\n                mid = (l + r) >> 1;\n                if (a.get(mid) == val) {\n                    r = mid - 1;\n                    ans = mid;\n                } else if (a.get(mid) > val)\n                    r = mid - 1;\n                else {\n                    l = mid + 1;\n                    ans = l;\n                }\n            }\n            return (ans + 1);\n        }\n\n        static long fastexpo(long x, long y) {\n            long res = 1;\n            while (y > 0) {\n                if ((y & 1) == 1) {\n                    res *= x;\n                }\n                y = y >> 1;\n                x = x * x;\n            }\n            return res;\n        }\n\n        static long lfastexpo(long x, long y, long p) {\n            long res = 1;\n            x = x % p;\n            while (y > 0) {\n                if ((y & 1) == 1) {\n                    res = (res * x) % p;\n                }\n                y = y >> 1;\n                x = (x * x) % p;\n            }\n            return res;\n        }\n\n           /* void dijsktra(int s, List<pair> l[], int n) {\n                PriorityQueue<pair> pq = new PriorityQueue<>(new ascend());\n                int dist[] = new int[100005];\n                boolean v[] = new boolean[100005];\n                for (int i = 1; i <= n; i++)\n                    dist[i] = 1000000000;\n                dist[s] = 0;\n                for (int i = 1; i < n; i++) {\n                    if (i == s)\n                        pq.add(new pair(s, 0));\n                    else\n                        pq.add(new pair(i, 1000000000));\n                }\n                while (!pq.isEmpty()) {\n                    pair node = pq.remove();\n                    v[node.a] = true;\n                    for (int i = 0; i < l[node.a].size(); i++) {\n                        int v1 = l[node.a].get(i).a;\n                        int w = l[node.a].get(i).b;\n                        if (v[v1])\n                            continue;\n                        if ((dist[node.a] + w) < dist[v1]) {\n                            dist[v1] = dist[node.a] + w;\n                            pq.add(new pair(v1, dist[v1]));\n                        }\n                    }\n                }\n            }*/\n    }\n\n    static class pair {\n        int a;\n        int b;\n\n        public pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    static class pair1 {\n        pair p;\n        int in;\n\n        public pair1(pair a, int n) {\n            this.p = a;\n            this.in = n;\n        }\n    }\n\n    static int inf = 5000013;\n\n    static class solver {\n        DecimalFormat df = new DecimalFormat(\"0.00\");\n        extra e = new extra();\n        int mod = 1000000007;\n        boolean v[] = new boolean[1001];\n        void solve() throws IOException {\n            int n=sc.ni();\n            int p[]=new int[n];\n            for(int i=0;i<n;i++)\n                p[i]=i;\n            HashMap<Integer, Integer> count=new HashMap<>();\n            int k=sc.ni();\n            while (k-->0)\n            {\n                int u=sc.ni()-1;\n                int v=sc.ni()-1;\n                int p1=find(p,u);\n                int p2=find(p,v);\n                if(p1!=p2)\n                    union(p,u,v);\n            }\n            for(int i=0;i<n;i++)\n                find(p,i);\n            for(int i=0;i<n;i++)\n            {\n                count.put(p[i],count.getOrDefault(p[i],0)+1);\n            }\n            int m=sc.ni();\n            //System.out.println(count);\n            while (m-->0) {\n                int u = sc.ni() - 1;\n                int v = sc.ni() - 1;\n                int p1 = find(p, u);\n                int p2 = find(p, v);\n                if (p1 == p2)\n                    count.remove(p1);\n            }\n            int ans=0;\n            if(!count.isEmpty())\n                ans=Collections.max(count.values());\n            System.out.println(ans);\n        }\n        int rank[]=new int[100000];\n        int find(int p[],int x){\n            if(p[x]==x)\n                return x;\n            p[x]=find(p,p[x]);\n            return p[x];\n        }\n        void union(int p[],int x,int y)\n        {\n            int p1=find(p,x);\n            int p2=find(p,y);\n            if(rank[p1]>rank[p2])\n            {\n                p[p2]=p1;\n                rank[p1]=rank[p2]+1;\n            }\n            else\n            {\n                p[p1]=p2;\n                rank[p2]=Math.max(rank[p1]+1,rank[p2]);\n            }\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport javafx.util.Pair;\n\npublic class Solve4 {\n\n    public static void main(String[] args) throws IOException {\n        PrintWriter pw = new PrintWriter(System.out);\n        new Solve4().solve(pw);\n        pw.flush();\n        pw.close();\n    }\n\n    public void solve(PrintWriter pw) throws IOException {\n        FastReader sc = new FastReader();\n        int n = sc.nextInt(), k = sc.nextInt();\n        int[] parent = new int[n + 1], size = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n        for (int i = 0; i < k; i++) {\n            merge(sc.nextInt(), sc.nextInt(), parent, size);\n        }\n        int m = sc.nextInt();\n        for (int i = 0; i < m; i++) {\n            int x = sc.nextInt(), y = sc.nextInt();\n            if (sameParent(x, y, parent)) {\n                size[getParent(x, parent)] = -1;\n            }\n        }\n        int max = 0;\n        for (int i = 1; i <= n; i++) {\n            if(parent[i]!=i) continue;\n            max = Math.max(max, size[i]);\n        }\n        pw.println(max);\n    }\n\n    public int getParent(int x, int[] parent) {\n        if (x == parent[x]) {\n            return x;\n        }\n        return parent[x] = getParent(parent[x], parent);\n    }\n\n    public boolean sameParent(int x, int y, int[] parent) {\n        return getParent(x, parent) == getParent(y, parent);\n    }\n\n    public void merge(int x, int y, int[] parent, int[] size) {\n        x = getParent(x, parent);\n        y = getParent(y, parent);\n        if (x == y) {\n            return;\n        }\n        if (size[x] < size[y]) {\n            size[y] += size[x];\n            parent[x] = y;\n        } else {\n            size[x] += size[y];\n            parent[y] = x;\n        }\n    }\n\n    static class FastReader {\n\n        StringTokenizer st;\n        BufferedReader br;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public boolean hasNext() throws IOException {\n            if (st != null && st.hasMoreTokens()) {\n                return true;\n            }\n            String s = br.readLine();\n            if (s == null || s.isEmpty()) {\n                return false;\n            }\n            st = new StringTokenizer(s);\n            return true;\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dsu(10e5 + 1);\nvector<int> s(10e5 + 1, 1);\nint find(int a) {\n  if (dsu[a] == 0 || dsu[a] == -1)\n    return a;\n  else\n    return dsu[a] = find(dsu[a]);\n}\nvoid join(int a, int b) {\n  if (s[find(a)] < s[find(b)]) swap(a, b);\n  s[find(a)] += s[find(b)];\n  dsu[find(b)] = find(a);\n}\nint main() {\n  int n;\n  cin >> n;\n  int k;\n  cin >> k;\n  for (int i = 0; i < k; ++i) {\n    int a, b;\n    cin >> a >> b;\n    if (find(a) != find(b)) join(a, b);\n  }\n  cin >> k;\n  for (int i = 0; i < k; ++i) {\n    int a, b;\n    cin >> a >> b;\n    if (find(a) == find(b)) dsu[find(a)] = -1;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (dsu[find(i)] != -1) ans = max(ans, s[find(i)]);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long max(long long a, long long b) {\n  if (a > b)\n    return a;\n  else\n    return b;\n}\nlong long min(long long a, long long b) {\n  if (a < b)\n    return a;\n  else\n    return b;\n}\nlong long power(long long B, long long P) {\n  if (P == 0) return 1;\n  long long X = power(B, P / 2);\n  if (P % 2 == 0)\n    return X * X;\n  else\n    return B * X * X;\n}\nlong long fx4[] = {1, -1, 0, 0};\nlong long fy4[] = {0, 0, 1, -1};\nlong long Parent[200005], Size[200005];\nvoid INIT(long long N) {\n  for (long long i = 1; i <= N; i++) {\n    Parent[i] = i;\n    Size[i] = 1;\n  }\n}\nlong long Find(long long r) {\n  if (Parent[r] == r) return r;\n  return Parent[r] = Find(Parent[r]);\n}\nvoid Union(int X, int Y) {\n  int PX = Find(X);\n  int PY = Find(Y);\n  if (PX != PY) {\n    Parent[PY] = PX;\n    Size[PX] += Size[PY];\n  }\n}\nint main() {\n  long long T, N, M, X, Y, W, K, Q, R, P;\n  cin >> N;\n  INIT(N);\n  cin >> K;\n  for (int i = 1; i <= K; i++) {\n    cin >> X >> Y;\n    Union(X, Y);\n  }\n  cin >> M;\n  for (int i = 1; i <= M; i++) {\n    cin >> X >> Y;\n    int PX = Find(X);\n    int PY = Find(Y);\n    if (PX == PY) {\n      Size[PX] = 0;\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= N; i++) {\n    int Pi = Find(i);\n    ans = max(ans, Size[Pi]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n = int(raw_input())\n\nlike = dict((i, set()) for i in range(1, n + 1))\ndislike = dict((i, set()) for i in range(1, n + 1))\n\nk = int(raw_input())\nfor person1, person2 in (map(int, raw_input().split()) for i in range(k)):\n    like[person1].add(person2)\n    like[person2].add(person1)\n\nm = int(raw_input())\nfor person1, person2 in (map(int, raw_input().split()) for i in range(m)):\n    dislike[person1].add(person2)\n    dislike[person2].add(person1)\n\ndef find_solutions(root):\n    graph_follow = set([root])\n    graph = set()\n    graph_likes = set()\n    graph_dislikes = set()\n\n    while graph_follow:\n        for follow in graph_follow:\n            graph.add(follow)\n            graph_likes |= like[follow]\n            graph_dislikes |= dislike[follow]\n        graph_follow = (graph_likes - graph_dislikes) - graph\n\n    if graph_likes & graph_dislikes:\n        return 0\n    else:\n        return len(graph)\n\nprint max(find_solutions(root) for root in range(1, n + 1))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2005;\nbool mark[maxn], srg[maxn];\nint n, lk, dk, ans, grp[maxn], cnt[maxn], k;\nvector<int> like[maxn];\nvector<pair<int, int>> dislike;\nvoid dfs(int v) {\n  mark[v] = true;\n  grp[v] = k;\n  cnt[k]++;\n  for (int u : like[v]) {\n    if (!mark[u]) dfs(u);\n  }\n}\nvoid dsu(int v) {\n  if (grp[dislike[v].first] == grp[dislike[v].second])\n    srg[grp[dislike[v].first]] = maxn / maxn;\n}\nint main() {\n  scanf(\"%d%d\", &n, &lk);\n  for (int u, v, i = 0; i < lk; i++) {\n    scanf(\"%d%d\", &u, &v);\n    like[u].push_back(v);\n    like[v].push_back(u);\n  }\n  scanf(\"%d\", &dk);\n  for (int u, v, i = 0; i < dk; i++) {\n    scanf(\"%d%d\", &u, &v);\n    dislike.push_back({u, v});\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!mark[i]) dfs(i);\n    k++;\n  }\n  for (int i = dislike.size() - 1; ~i; i--) {\n    dsu(i);\n  }\n  for (int i = 0; i < k; i++) {\n    if (!srg[i]) {\n      ans = max(ans, cnt[i]);\n    }\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class C {\n    static InputStreamReader in = new InputStreamReader(System.in);\n    static BufferedReader bf = new BufferedReader(in);\n    static StreamTokenizer st = new StreamTokenizer(bf);\n    static int n, k, m, cnt;\n    static int [][] endes;\n    static boolean []used,t;\n    static boolean f;\n    static Set<Integer> []s;\n    public static void main(String[] args) throws IOException {\n        n = nextInt();\n        k = nextInt();\n        endes = new int[n + 1][n+1];\n        used = new boolean [n+1];\n        for (int i = 1; i <= k; i++) {\n            int v = nextInt();\n            int u = nextInt();\n            endes[v][u] = endes[u][v] = 1;\n        }\n        m = nextInt();\n        for (int i = 0; i < m; i++) {\n            int u = nextInt();\n            int v = nextInt();\n            endes[v][u] = endes[u][v] = 2;\n        }\n        int ans = 0;\n        t = new boolean [n+1];\n        for (int i = 1; i <=n; i++) {\n            if (!used[i]){\n                Arrays.fill(t, false);\n                Queue<Integer> queue = new LinkedList<Integer>();\n                t[i] = true;\n                queue.add(i);\n                boolean f = true;\n                used[i] = true;\n                int cnt = 0;\n                while (!queue.isEmpty()){\n                    int v = queue.poll();\n                    for (int j = 1; j <=n; j++) {\n                        if (endes[v][j] == 1){\n                            if (!used[j]){\n                                used[j] = t[j] = true;\n                                queue.add(j);\n                                cnt++;\n                            }\n                        }else{\n                            if (endes[v][j] == 2){\n                                if (t[j]){\n                                    f = false;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (f){\n                    ans = Math.max(ans, cnt+1);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n        private static int nextInt() throws IOException {\n        st.nextToken();\n        return (int) st.nval;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5;\nconst long long MOD = 998244353;\ntemplate <typename P>\nstruct Cmp {\n  bool operator()(const P &p1, const P &p2) {\n    if (p1.first < p2.first) return true;\n    if (p1.first == p2.first) return p1.second < p2.second;\n    return false;\n  }\n};\nlong long vis[N];\nvector<long long> vp[N];\nlong long size[N];\nlong long a[N];\nvoid initialize() {\n  for (long long i = 0; i < 2005; i++) {\n    a[i] = i;\n    size[i] = 1;\n  }\n}\nlong long root(long long i) {\n  while (a[i] != i) {\n    a[i] = a[a[i]];\n    i = a[i];\n  }\n  return i;\n}\nvoid merge(long long x, long long y) {\n  long long root_A = root(x);\n  long long root_B = root(y);\n  if (size[root_A] < size[root_B]) {\n    a[root_A] = a[root_B];\n    size[root_B] += size[root_A];\n  } else {\n    a[root_B] = a[root_A];\n    size[root_A] += size[root_B];\n  }\n}\nbool mark;\nvoid dfs(long long n) {\n  vis[n] = 1;\n  for (long long i = 0; i < vp[n].size(); i++) {\n    if (!vis[vp[n][i]]) {\n      dfs(vp[n][i]);\n    }\n  }\n}\nint32_t main() {\n  long long n;\n  long long m;\n  cin >> n >> m;\n  long long x, y;\n  initialize();\n  for (long long i = 0; i < m; i++) {\n    cin >> x >> y;\n    vp[x].push_back(y);\n    vp[y].push_back(x);\n    if (root(x) != root(y)) {\n      merge(x, y);\n    }\n  }\n  long long q;\n  cin >> q;\n  for (long long i = 0; i < q; i++) {\n    cin >> x >> y;\n    if (root(x) == root(y)) {\n      size[root(x)] = 0;\n    }\n  }\n  long long mx = 0;\n  for (long long i = 1; i <= n; i++) {\n    mark = true;\n    if (!vis[i]) {\n      dfs(i);\n      if (mark) {\n        mx = max(mx, size[root(i)]);\n      }\n    }\n  }\n  cout << mx << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fac[2000005] = {0};\nvoid factorial() {\n  fac[0] = 1;\n  fac[1] = 1;\n  for (long long i = 2; i < 200005; i++)\n    fac[i] = ((i % 1000000007) * (fac[i - 1] % 1000000007)) % 1000000007;\n}\nlong long power(long long n, long long m) {\n  long long p = 1;\n  if (m == 0) return 1;\n  p = (power(n, m / 2) % 1000000007);\n  p = (p % 1000000007 * p % 1000000007) % 1000000007;\n  return (m & 1 ? ((p % 1000000007 * n % 1000000007) % 1000000007)\n                : (p % 1000000007));\n}\nlong long ncr(long long n, long long r) {\n  return ((fac[n] * power(fac[r], 1000000007 - 2)) % 1000000007 *\n          power(fac[n - r], 1000000007 - 2)) %\n         1000000007;\n}\nvector<long long> graph[100005];\nlong long n, m;\nlong long mx = -1;\nset<pair<long long, long long> > s;\nvector<long long> v;\nlong long used[100005];\nvoid dfs(long long t) {\n  used[t] = 1;\n  v.push_back(t);\n  for (auto x : graph[t]) {\n    if (!used[x]) dfs(x);\n  }\n}\nvoid ram5564() {\n  cin >> n;\n  long long z;\n  cin >> z;\n  memset(used, 0, sizeof(used));\n  for (long long i = 0; i < z; i++) {\n    long long x, y;\n    cin >> x >> y;\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n  cin >> m;\n  for (long long i = 0; i < m; i++) {\n    long long x, y;\n    cin >> x >> y;\n    s.insert({x, y});\n    s.insert({y, x});\n  }\n  for (long long i = 1; i < n + 1; i++) {\n    if (!used[i]) {\n      v.clear();\n      dfs(i);\n      long long ok = 0;\n      for (long long j = 0; j < v.size(); j++)\n        if (!ok)\n          for (long long k = j + 1; k < v.size(); k++)\n            if (!ok)\n              if (s.count({v[j], v[k]})) ok = 1;\n      if (!ok) {\n        long long sz = v.size();\n        mx = max(mx, sz);\n      }\n    }\n  }\n  cout << max(mx, 0ll);\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  while (t--) ram5564();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int UNDEF = -1;\nconst int INF = 2000000000;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\ntemplate <typename T>\nconst T sqr(const T &x) {\n  return x * x;\n}\ntemplate <typename T>\nconst string GetString(const T &val) {\n  ostringstream sout;\n  sout << val;\n  return sout.str();\n}\nstruct Node {\n  vector<int> edge;\n  int id;\n  Node() : id(UNDEF) {}\n};\nconst int MAXN = 2000 + 5;\nint n, k, m;\nNode g[MAXN];\nbool q[MAXN][MAXN];\nvector<int> mas[MAXN];\nint cnt = 0;\nvoid Init() {\n  cin >> n >> k;\n  for (int i = 0; i < (k); ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    --u, --v;\n    g[u].edge.push_back(v);\n    g[v].edge.push_back(u);\n  }\n  cin >> m;\n  for (int i = 0; i < (m); ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    --u, --v;\n    q[u][v] = q[v][u] = true;\n  }\n}\nvoid DFS(int u) {\n  g[u].id = cnt;\n  mas[cnt].push_back(u);\n  for (int i = 0; i < (g[u].edge.size()); ++i) {\n    int v = g[u].edge[i];\n    if (g[v].id == UNDEF) DFS(v);\n  }\n}\nint main() {\n  Init();\n  for (int u = 0; u < (n); ++u) {\n    if (g[u].id == UNDEF) {\n      DFS(u);\n      ++cnt;\n    }\n  }\n  int res = 0;\n  for (int id = 0; id < (cnt); ++id) {\n    bool ok = true;\n    for (int i = 0; ok && i < mas[id].size(); ++i) {\n      for (int j = i + 1; ok && j < mas[id].size(); ++j) {\n        ok = !q[mas[id][i]][mas[id][j]];\n      }\n    }\n    if (ok) res = max(res, (int)mas[id].size());\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\n\npublic class C177 {\n\n    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    static int nextInt() throws Exception {\n        in.nextToken();\n        return (int)in.nval;\n    }\n    \n    static String nextString() throws Exception {\n        in.nextToken();\n        return in.sval;\n    }\n    \n    public static void main(String[] args) throws Exception {\n        n = nextInt();\n        f = new boolean[n][n];\n        e = new boolean[n][n];\n        for (int i = nextInt(); i > 0; i--) {\n            int a = nextInt()-1, b = nextInt()-1;\n            f[a][b] = f[b][a] = true;\n        }\n        for (int i = nextInt(); i > 0; i--) {\n            int a = nextInt()-1, b = nextInt()-1;\n            e[a][b] = e[b][a] = true;\n        }\n        int ans = 0;\n        b = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (b[i] == 0) {\n                q++;\n                good = true;\n                count = 0;\n                dfs(i);\n                check(i);\n                if (good) ans = Math.max(ans, count);\n            }\n        }\n        out.println(ans);\n        out.flush();\n    }\n\n    static int n;\n    static boolean[][] f, e;\n    static int[] b;\n    static boolean good;\n    static int count, q = 0;\n    \n    static void dfs(int x) {\n        if (b[x] == 0) {\n            b[x] = q;\n            count++;\n            for (int i = 0; i < n; i++)\n                if (f[x][i])\n                    dfs(i);\n        }\n    }\n    \n    static void check(int x) {\n        if (b[x] == q) {\n            b[x] = -q;\n            for (int i = 0; i < n; i++)\n                if (e[x][i] && Math.abs(b[i]) == q)\n                    good = false;\n            for (int i = 0; i < n; i++)\n                if (f[x][i])\n                    check(i);\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long power(long long b, long long p) {\n  long long res = 1;\n  while (p) {\n    if (p % 2) {\n      res = (res * b) % 1000000007;\n      p--;\n    } else {\n      b = (b * b) % 1000000007;\n      p /= 2;\n    }\n  }\n  return res;\n}\nvoid update(int node, int start, int end, int idx, int val, vector<int> &tree) {\n  if (start == end) {\n    tree[node] = val;\n    return;\n  }\n  int mid = (start + end) / 2;\n  if (idx >= start && idx <= mid)\n    update(2 * node, start, mid, idx, val, tree);\n  else\n    update(2 * node + 1, mid + 1, end, idx, val, tree);\n  tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n}\nint query(int node, int start, int end, int l, int r, vector<int> &tree) {\n  if (r < start || l > end) return 0;\n  if (start >= l && end <= r) return tree[node];\n  int mid = (start + end) / 2;\n  return max(query(2 * node, start, mid, l, r, tree),\n             query(2 * node + 1, mid + 1, end, l, r, tree));\n}\nlong long f, c;\nvoid dfs(long long r, vector<vector<long long> > &v,\n         vector<vector<long long> > &e, vector<long long> &vis, long long s) {\n  vis[r] = s;\n  c++;\n  for (long long i = 0; i < e[r].size(); i++)\n    if (vis[e[r][i]] == vis[r]) f = 1;\n  for (long long i = 0; i < v[r].size(); i++)\n    if (!vis[v[r][i]]) dfs(v[r][i], v, e, vis, s);\n}\nint main() {\n  long long n, m, k, i, ans = 0, a, b;\n  cin >> n;\n  vector<long long> vis(n + 1);\n  vector<vector<long long> > v(n + 1), e(n + 1);\n  cin >> k;\n  while (k--) {\n    cin >> a >> b;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  cin >> m;\n  while (m--) {\n    cin >> a >> b;\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n  for (i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      f = 0, c = 0;\n      dfs(i, v, e, vis, i);\n      if (!f) ans = max(ans, c);\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class C2 {\n\t\n\tboolean[][] like, hate;\n\tboolean[] visit;\n\tint[] stk;\n\tint n, cnt;\n\t\n\tpublic void solve() throws IOException {\n\t\tn = nextInt();\n\t\tlike = new boolean[n][n];\n\t\thate = new boolean[n][n];\n\t\tint K = nextInt();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tint u = nextInt();\n\t\t\tint v = nextInt();\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tlike[u][v] = true;\n\t\t\tlike[v][u] = true;\n\t\t}\n\t\tint M = nextInt();\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint u = nextInt();\n\t\t\tint v = nextInt();\n\t\t\tu--;\n\t\t\tv--;\n\t\t\thate[u][v] = true;\n\t\t\thate[v][u] = true;\n\t\t}\n\t\tvisit = new boolean[n];\n\t\tstk = new int[n];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!visit[i]) {\n\t\t\t\tcnt = 0;\n\t\t\t\tgo(i);\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (int x = 0; x < cnt; x++)\n\t\t\t\t\tfor (int y = 0; y < cnt; y++)\n\t\t\t\t\t\tif (hate[stk[x]][stk[y]])  {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\tif (ok) ans = Math.max(ans, cnt);\n\t\t\t}\n\t\twriter.println(ans);\n\t}\n\t\n\tpublic void go(int i) {\n\t\tvisit[i] = true;\n\t\tstk[cnt++] = i;\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (!visit[j] && like[i][j]) go(j);\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew C2().run();\n\t}\n\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tlong tbegin = System.currentTimeMillis();\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t//reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\t//writer = new PrintWriter(new FileOutputStream(\"output.txt\"));\n\t\t\tsolve();\n\t\t\t//reader.close();\n\t\t\t//System.out.println(System.currentTimeMillis() - tbegin + \"ms\");\n\t\t\twriter.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic long sx = 0, sy = 0, m = (long) (1e9 + 7);\n\n\tstatic ArrayList<Integer>[] a;\n\tstatic int[][] dp;\n\tstatic long[] farr;\n\t// static boolean b = true;\n\tstatic HashMap<Integer, Integer> hm = new HashMap<>();\n\n\t// static TreeMap<Integer, Integer> hm = new TreeMap<>();\n\tpublic static PrintWriter out;\n\tstatic ArrayList<pair> ans = new ArrayList<>();\n\tstatic long[] fact = new long[(int) 1e6];\n\tstatic boolean b = false;\n\tstatic StringBuilder sb = new StringBuilder();\n\tstatic boolean cycle = false;\n\tstatic long mod = 998244353;\n\tstatic int[] col;\n\tstatic HashSet<Integer> p = new HashSet<>();\n\tstatic int cnt;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tReader scn = new Reader();\n\n\t\tint n = scn.nextInt();\n\n\t\tDSU ds = new DSU(n);\n\n\t\tint k = scn.nextInt();\n\n\t\twhile (k-- != 0)\n\t\t\tds.merge(scn.nextInt(), scn.nextInt());\n\n\t\tint m = scn.nextInt();\n\n\t\twhile (m-- != 0) {\n\n\t\t\tint x = scn.nextInt(), y = scn.nextInt();\n\n\t\t\tif (ds.find(x) == ds.find(y))\n\t\t\t\tds.size[ds.find(x)] = 0;\n\t\t}\n\t\tint ans = 0;\n\n\t\tfor (int i = 1; i <= n; i++) {\n\n\t\t\tans = Math.max(ans, ds.size[ds.find(i)]);\n\t\t}\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tprivate static class DSU {\n\n\t\tint[] size;\n\t\tint[] parent;\n\t\tint connected;\n\n\t\tpublic DSU(int n) {\n\t\t\tsize = new int[n + 1];\n\t\t\tparent = new int[n + 1];\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tsize[i] = 1;\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\n\t\t\tconnected = n;\n\n\t\t}\n\n\t\tpublic int find(int v) {\n\t\t\tif (v == parent[v])\n\t\t\t\treturn v;\n\n\t\t\tparent[v] = find(parent[v]);\n\t\t\treturn parent[v];\n\t\t}\n\n\t\tpublic void merge(int u, int v) {\n\n\t\t\tint p1 = find(u);\n\t\t\tint p2 = find(v);\n\n\t\t\tif (p1 == p2)\n\t\t\t\treturn;\n\t\t\tconnected--;\n\n\t\t\tif (size[p1] > size[p2]) {\n\t\t\t\tsize[p1] += size[p2];\n\t\t\t\tparent[p2] = p1;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tsize[p2] += size[p1];\n\t\t\t\tparent[p1] = p2;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// _________________________TEMPLATE_____________________________________________________________\n\n\t// private static int gcd(int a, int b) {\n\t// if (a == 0)\n\t// return b;\n\t//\n\t// return gcd(b % a, a);\n\t// }\n\n\t// static class comp implements Comparator<Integer> {\n\t//\n\t// @Override\n\t// public int compare(Integer o1, Integer o2) {\n\t// if (b[o1])\n\t// return -1;\n\t// else if (b[o2])\n\t// return 1;\n\t// else\n\t// return (int) (a[o2].size() - a[o1].size());\n\t// }\n\t//\n\t// }\n\n\t// public static long pow(long a, long b) {\n\t//\n\t// if(b<0)return 0;\n\t// if (b == 0 || b == 1)\n\t// return (long) Math.pow(a, b);\n\t//\n\t// if (b % 2 == 0) {\n\t//\n\t// long ret = pow(a, b / 2);\n\t// ret = (ret % mod * ret % mod) % mod;\n\t// return ret;\n\t// }\n\t//\n\t// else {\n\t// return ((pow(a, b - 1) % mod) * a % mod) % mod;\n\t// }\n\t// }\n\n\tprivate static class pair implements Comparable<pair> {\n\n\t\tint v, deg;\n\n\t\tpair(int a, int b) {\n\t\t\tv = a;\n\t\t\tdeg = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\n\t\t\treturn 1;\n\t\t}\n\n\t}\n\n\tpublic static class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[1000000 + 1]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic int[][] nextInt2DArray(int m, int n) throws IOException {\n\t\t\tint[][] arr = new int[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tarr[i][j] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\t// kickstart - Solution\n\t\t// atcoder - Main\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing vvll = vector<vector<long long int> >;\nusing vll = vector<long long int>;\nconst long long int inf = 1e18;\nconst long long int maxs = 200200;\nconst long long int mod = 1e9 + 7;\nlong long int getPow(long long int num, long long int pow) {\n  long long int res = 1;\n  num %= mod;\n  while (pow) {\n    if (pow & 1) res = (res * num) % mod;\n    num = (num * num) % mod;\n    pow >>= 1;\n  }\n  return res;\n}\nlong long int INV(long long int num) {\n  num %= mod;\n  return getPow(num, mod - 2);\n}\nint connected;\nint root[2005], sz[2005], isValid[2005];\nint n;\nvoid init() {\n  for (int i = 1; i <= n; i++) {\n    root[i] = i;\n    sz[i] = 1;\n  }\n  connected = n;\n}\nint rt(int k) {\n  while (k != root[k]) {\n    root[k] = root[root[k]];\n    k = root[k];\n  }\n  return k;\n}\nvoid merge(int u, int v) {\n  int rt1 = rt(u);\n  int rt2 = rt(v);\n  if (rt1 == rt2) return;\n  connected--;\n  if (sz[rt1] > sz[rt2]) swap(rt1, rt2);\n  sz[rt2] += sz[rt1];\n  sz[rt1] = 0;\n  root[rt1] = root[rt2];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  cin >> n;\n  init();\n  int k;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    merge(a, b);\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    if (root[a] == root[b]) isValid[root[a]] = 1;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++)\n    if (isValid[root[i]] == 0) ans = max(ans, sz[i]);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct uni {\n  int p[2222];\n  uni() { fill(p, p + 2222, -1); }\n  int root(int a) { return p[a] < 0 ? a : (p[a] = root(p[a])); }\n  bool find(int a, int b) { return root(a) == root(b); }\n  void merge(int a, int b) {\n    if (!find(a, b)) p[root(a)] = root(b);\n  }\n};\nbool chk[2222];\nbool di[2222][2222];\nint main(void) {\n  int n, a, b;\n  uni v, w;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &a);\n  for (int i = 0; i < a; i++) {\n    int f, t;\n    scanf(\"%d%d\", &f, &t);\n    --f;\n    --t;\n    v.merge(f, t);\n  }\n  scanf(\"%d\", &b);\n  for (int i = 0; i < b; i++) {\n    int f, t;\n    scanf(\"%d%d\", &f, &t);\n    --f;\n    --t;\n    di[f][t] = di[t][f] = true;\n  }\n  int res = 0;\n  for (int i = 0; i < n; i++) {\n    if (chk[i]) continue;\n    int p[2222], c;\n    c = 0;\n    for (int j = 0; j < n; j++) {\n      if (v.find(i, j)) {\n        if (chk[j]) return -1;\n        p[c++] = j;\n        chk[j] = true;\n      }\n    }\n    if (res > c) continue;\n    bool ok = true;\n    for (int j = 0; ok && j < c; j++) {\n      for (int k = j + 1; ok && k < c; k++) {\n        if (di[p[j]][p[k]]) ok = false;\n      }\n    }\n    if (ok) res = max(res, c);\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint arr[2001];\nint byk[2001];\nvoid joint(int a, int b) {\n  int _a = a;\n  int _b = b;\n  while (arr[_b] != _b) _b = arr[_b];\n  while (arr[_a] != _a) _a = arr[_a];\n  if (_a == _b) return;\n  byk[_a] += byk[_b];\n  arr[_b] = a;\n  return;\n}\nvoid pecah(int a, int b) {\n  int _a = a;\n  int _b = b;\n  while (arr[_b] != _b) _b = arr[_b];\n  while (arr[_a] != _a) _a = arr[_a];\n  if (_a == _b) {\n    byk[_a] = 0;\n  }\n}\nint main() {\n  for (int i = 0; i < 2001; i++) {\n    arr[i] = i;\n    byk[i] = 1;\n  }\n  int n;\n  cin >> n;\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    if (a > b) {\n      int temp = a;\n      a = b;\n      b = temp;\n    }\n    joint(a, b);\n  }\n  int d;\n  cin >> d;\n  for (int i = 0; i < d; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    if (a > b) {\n      int temp = a;\n      a = b;\n      b = temp;\n    }\n    pecah(a, b);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (arr[i] == i) {\n      ans = max(ans, byk[i]);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nimport math\nint_ = lambda x: int(x)-1\nn = int(sys.stdin.readline())\np = [-1]*n\n#p[0]=-1\nk = int(sys.stdin.readline())\ngroups = []\nfor i in xrange(k):\n    p1, p2 = map(int_, sys.stdin.readline().split())\n    if p[p1] == p[p2]:\n        if p[p1] == -1:\n            #new group\n            grp_ind = len(groups)\n            groups.append([p1,p2])\n            p[p1] = grp_ind\n            p[p2] = grp_ind\n    elif p[p1] == -1:\n        #move first to group of 2\n        p[p1] = p[p2]\n        groups[p[p2]].append(p1)\n    elif p[p2] == -1:\n        p[p2] = p[p1]\n        groups[p[p1]].append(p2)\n    else:\n        #in dif groups, together!\n        #from second group to first group\n        old_grp = p[p2]\n        new_grp = p[p1]\n        for pp in groups[old_grp]:\n            p[pp] = new_grp\n        groups[new_grp].extend(groups[old_grp])\n        groups[old_grp] = []\n\n    #print p\n    #print groups\n#print p\n#print groups\n\nm = int(sys.stdin.readline())\nen = []\nfor i in xrange(m):\n    p1, p2 = map(int_, sys.stdin.readline().split())\n    if p[p1]!=-1 and p[p2]!= -1:\n        if p[p1] == p[p2]:\n            #a oni v odno' gryppe (((\n            groups[p[p1]] = []\n\nx = 0    \nif len(groups):\n    x = max(map(len, groups))\n\nif x==0 and -1 in p:\n    x = 1\nprint str(x)\n#\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private IO io;\n    private int ioMode = -1;\n    private String problemName = \"\";\n    private final String mjArgument = \"master_j\";\n\n    public static void main(String programArguments[]) throws IOException{\n        if(programArguments != null && programArguments.length > 0)\n            new Main().run(programArguments[0]);\n        else\n            new Main().run(null);\n    }\n\n    private void run(String programArgument) throws IOException {\n//         _______________________________________________ _________\n//        |   Input Mode     |      Output Mode    | mode | comment |\n//        |------------------|---------------------|----- |---------|\n//        |   input.txt      |      System.out     |  0   |    mj   |\n//        |   System.in      |      System.out     |  1   |  T / CF |\n//        |<problemName>.in  |  <problemName>.out  |  2   |         |\n//        |   input.txt      |      output.txt     |  3   |    C    |\n//        |__________________|_____________________|______|_________|\n        if(programArgument != null && programArgument.equals(mjArgument)) // mj\n            ioMode = 0;\n        else if(System.getProperty(\"ONLINE_JUDGE\") != null) // T / CF\n            ioMode = 1;\n        else\n            ioMode = 2;\n\n        switch(ioMode){\n            case -1:\n                try{\n                    throw new Exception(\"<ioMode> init failure\") ;\n                }catch (Exception e){\n                    e.printStackTrace();\n                }\n                return;\n            case 0:\n                break;\n            case 1:\n                break;\n            case 2:\n                if(problemName.length() == 0){\n                    try{\n                        throw new Exception(\"<problemName> init failure\");\n                    }catch (Exception e){\n                        e.printStackTrace();\n                    }\n                    return;\n                }\n            case 3:\n                break;\n        }\n        io = new IO(ioMode, problemName);\n        if(ioMode == 0){\n            System.out.println(\"File output : \\n<start>\");\n            System.out.flush();\n        }\n        solve();\n        io.flush();\n        if(ioMode == 0){\n            System.out.println(\"</start>\");\n            System.out.flush();\n        }\n    }\n\n    private void solve() throws IOException {\n        int n = io.nI(), frs = io.nI(), ens, max = 0;\n        List<Set<Integer>> friends = new ArrayList<Set<Integer>>();\n        Set<Integer> people = new HashSet<Integer>();\n        F:for(int i = 0; i<frs; i++){\n            int u = io.nI(), v = io.nI();\n            Iterator<Set<Integer>> I = friends.iterator();\n            while(I.hasNext()){\n                Set<Integer> t = I.next();\n                if(t.contains(u)){\n                    t.add(v);\n                    people.add(v);\n                    continue F;\n                }else if(t.contains(v)){\n                    t.add(u);\n                    people.add(u);\n                    continue F;\n                }\n            }\n            friends.add(new HashSet<Integer>(Arrays.asList(u, v)));\n            people.add(u); people.add(v);\n        }\n        ens = io.nI();\n        F:for(int i = 0; i<ens; i++){\n            int u = io.nI(), v = io.nI();\n            Iterator<Set<Integer>> I = friends.iterator();\n            while(I.hasNext()){\n                Set<Integer> t = I.next();\n                if(t.contains(u) && t.contains(v)){\n                    friends.remove(t);\n                    continue F;\n                }\n            }\n            friends.add(new HashSet<Integer>(Arrays.asList(u)));\n            friends.add(new HashSet<Integer>(Arrays.asList(v)));\n            people.add(u); people.add(v);\n        }\n        for(Set<Integer> t : friends)\n            max = Math.max(t.size(), max);\n        io.wln(Math.max(max, (n - people.size()) == 0 ? 0 : 1));\n    }//2.2250738585072012e-308\n\n    /**\n     * Input-output class\n     * @author master_j\n     * @version 0.2.0\n     */\n    @SuppressWarnings(\"unused\")\n    private class IO{\n        StreamTokenizer in; PrintWriter out; BufferedReader br; Reader reader; Writer writer;\n        public IO(int ioMode, String problemName) throws IOException{\n            Locale.setDefault(Locale.US);\n//         _______________________________________________ _________\n//        |   Input Mode     |      Output Mode    | mode | comment |\n//        |------------------|---------------------|----- |---------|\n//        |   input.txt      |      System.out     |  0   |    mj   |\n//        |   System.in      |      System.out     |  1   |  T / CF |\n//        |<problemName>.in  |  <problemName>.out  |  2   |         |\n//        |   input.txt      |      output.txt     |  3   |    C    |\n//        |__________________|_____________________|______|_________|\n            switch(ioMode){\n                case 0:\n                    reader = new FileReader(\"input.txt\");\n                    writer = new OutputStreamWriter(System.out);\n                    break;\n                case 1:\n                    reader = new InputStreamReader(System.in);\n                    writer = new OutputStreamWriter(System.out);\n                    break;\n                case 2:\n                    reader = new FileReader(problemName + \".in\");\n                    writer = new FileWriter(problemName + \".out\");\n                    break;\n                case 3:\n                    reader = new FileReader(\"input.txt\");\n                    writer = new FileWriter(\"output.txt\");\n                    break;\n            }\n            br = new BufferedReader(reader);\n            in = new StreamTokenizer(br);\n            out = new PrintWriter(writer);\n        }\n        public void wln(){out.println();}\n        public void wln(int arg){out.println(arg);}\n        public void wln(long arg){out.println(arg);}\n        public void wln(double arg){out.println(arg);}\n        public void wln(String arg){out.println(arg);}\n        public void wln(boolean arg){out.println(arg);}\n        public void wln(char arg){out.println(arg);}\n        public void wln(float arg){out.println(arg);}\n        public void wln(Object arg){out.println(arg);}\n        public void w(int arg){out.print(arg);}\n        public void w(long arg){out.print(arg);}\n        public void w(double arg){out.print(arg);}\n        public void w(String arg){out.print(arg);}\n        public void w(boolean arg){out.print(arg);}\n        public void w(char arg){out.print(arg);}\n        public void w(float arg){out.print(arg);}\n        public void w(Object arg){out.print(arg);}\n        public void wf(String format, Object...args){out.printf(format, args);}\n        public void flush(){out.flush();}\n        public int nI() throws IOException {in.nextToken(); return(int)in.nval;}\n        public long nL() throws IOException {in.nextToken(); return(long)in.nval;}\n        public String nS() throws IOException {in.nextToken(); return in.sval;}\n        public double nD() throws IOException {in.nextToken(); return in.nval;}\n        public float nF() throws IOException {in.nextToken(); return (float)in.nval;}\n        public void wc(char...a){for(char c : a){in.ordinaryChar(c);in.wordChars(c, c);}}\n        public void wc(char c1, char c2){in.ordinaryChars(c1, c2); in.wordChars(c1, c2);}\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mxN = 2e3 + 5;\nint par[mxN], par1[mxN], Size[mxN], Size1[mxN];\nint find_Set(int x) { return par[x] = x == par[x] ? x : find_Set(par[x]); }\nint find_Set1(int x) { return par1[x] = x == par1[x] ? x : find_Set1(par1[x]); }\nvoid union_Set(int x, int y) {\n  x = find_Set(x);\n  y = find_Set(y);\n  if (x != y) {\n    if (Size[x] < Size[y]) swap(x, y);\n    Size[x] += Size[y];\n    par[y] = x;\n  }\n}\nvoid union_Set1(int x, int y) {\n  x = find_Set1(x);\n  y = find_Set1(y);\n  if (x != y) {\n    if (Size1[x] < Size1[y]) swap(x, y);\n    Size1[x] += Size1[y];\n    par1[y] = x;\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) Size[i] = Size1[i] = 1, par[i] = par1[i] = i;\n  while (m--) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    union_Set(u, v);\n  }\n  cin >> m;\n  set<int> testing[n + 1];\n  while (m--) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    testing[u].insert(v);\n    testing[v].insert(u);\n  }\n  for (int i = 1; i <= n; ++i) find_Set(i), find_Set1(i);\n  vector<int> adj[n + 1];\n  for (int i = 1; i <= n; ++i)\n    adj[par[i]].push_back(i), testing[par1[i]].insert(i);\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    bool ok = true;\n    for (int j = 0; j < (int)adj[i].size() && ok; ++j) {\n      int x = adj[i][j];\n      for (int k = 0; k < (int)adj[i].size() && ok; ++k) {\n        if (j == k) continue;\n        if (testing[x].find(adj[i][k]) != testing[x].end()) ok = false;\n      }\n    }\n    if (ok) ans = max(ans, (int)adj[i].size());\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class CF_177C {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint nfriends = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tHashMap<Integer, List<Integer>> plus  = new HashMap<Integer, List<Integer>>();\n\t\tHashMap<Integer, List<Integer>> minus = new HashMap<Integer, List<Integer>>();\n\t\tfor(int i = 0; i < nfriends; i++) {\n\t\t\tplus.put(i, new ArrayList<Integer>());\n\t\t\tminus.put(i, new ArrayList<Integer>());\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tint f1 = in.nextInt() - 1;\n\t\t\tint f2 = in.nextInt() - 1;\n\t\t\tplus.get(f1).add(f2);\n\t\t\tplus.get(f2).add(f1);\n\t\t}\n\t\t\n\t\tint m = in.nextInt();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint f1 = in.nextInt() - 1;\n\t\t\tint f2 = in.nextInt() - 1;\n\t\t\tminus.get(f1).add(f2);\n\t\t\tminus.get(f2).add(f1);\t\t\n\t\t}\n\t\t\n\t\tboolean[] checked = new boolean[nfriends];\n\t\tint msize = 0;\n\t\t\n\t\tfor(int i = 0; i < nfriends; i++) {\n\t\t\tif(checked[i]) continue;\n\t\t\t\n\t\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\t\tqueue.add(i);\n\t\t\t\n\t\t\tSet<Integer> ps = new HashSet<Integer>();\n\t\t\tSet<Integer> ms = new HashSet<Integer>();\n\t\t\t\n\t\t\tps.add(i);\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tint elem = queue.poll();\n\t\t\t\tchecked[elem] = true;\n\n\t\t\t\tList<Integer> nf = plus.get(elem);\n\t\t\t\tnf.removeAll(ps);\n\t\t\t\tps.addAll(nf);\n\t\t\t\tms.addAll(minus.get(elem));\n\t\t\t\t\n\t\t\t\tqueue.addAll(nf);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint size = ps.size();\n\t\t\t\n\t\t\tps.retainAll(ms);\n\t\t\tif(ps.size() == 0) {\n\t\t\t\tmsize = Math.max(msize, size);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(msize);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\nimport java.util.*;\n\npublic class A_GENERAL {\n   \n\t// for fast output printing  : use printwriter or stringbuilder\n\t// remember to close pw using pw.close()\n\tstatic StringBuilder sb = new StringBuilder();\n\tstatic long seive_size = (long) 1e6;\n\tstatic String alpha = \"abcdefghijklmnopqrstuvwxyz\";\n    static ArrayList<Integer> primes = new ArrayList<>();\n    static boolean[] set = new boolean[(int) seive_size+1];\n    static int n, m, k;\n    static ArrayList<Integer>[] adj;\n    static boolean[] visited;\n    static ArrayDeque<Integer> q = new ArrayDeque<>();\n    static final long MOD = 998244353;\n    static int[] dx = new int[] {1, 0, -1, 0, 1, 1, -1, -1};\n    static int[] dy = new int[] {0, 1, 0, -1, 1, -1, 1, -1};\n    static long[][] arr;\n    static int[] rank;\n    static int[] parent;\n    \n    static int[] comp;\n    static int c = 0;\n    public static void main(String[] args) {\n\t\tPrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\tMyScanner sc = new MyScanner();\n\t\tn = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\tcomp = new int[n+1];\n\t\tinit(n);\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tadj[u].add(v);\n\t\t\tadj[v].add(u);\n\t\t}\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\tc = 0;\n\t\t\t\tdfs(i, i);\n\t\t\t\tcomp[i] = c;\n\t\t\t}\n\t\t}\n\t\tm = sc.nextInt();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tif(parent[u] == parent[v]) {\n\t\t\t\tcomp[parent[u]] = 0;\n\t\t\t}\n\t\t}\n\t\tint max = 0;\n\t\tfor(int x : comp) {\n\t\t\tmax = Math.max(max, x);\n\t\t}\n\t\tout.println(max);\n\t\tout.close();\n\t}\n    \n\tpublic static void dfs(int u, int p) {\n\t\tvisited[u] = true;\n\t\tparent[u] = p;\n\t\tc++;\n\t\tfor(int v : adj[u]) {\n\t\t\tif(!visited[v]) \n\t\t\t\tdfs(v, p);\n\t\t}\n\t}\n\t\n\tpublic static class Triplet implements Comparable<Triplet> {\n\t\tint x;\n    \tint y;\n    \tint z;\n    \tTriplet(int x, int y, int z) {\n    \t\tthis.x = x;\n    \t\tthis.y = y;\n    \t\tthis.z = z;\n    \t}\n    \tpublic int compareTo(Triplet o) {\n    \t\treturn Integer.compare(this.x, o.x);\n    \t}\n    }\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tlong f;\n\t\tlong s;\n\t\tPair(long f, long s) {\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn Long.compare(this.f, o.f);\n\t\t}\n\t}\n\tpublic static void init(int n) {\n    \tadj = new ArrayList[n+1];\n    \tvisited = new boolean[n+1];\n    \tparent = new int[n+1];\n\t\trank = new int[n+1];\n    \tfor(int i = 1; i <= n; i++) {\n    \t\tadj[i] = new ArrayList();\n    \t\tparent[i] = i;\n\t\t\trank[i] = 0;\n    \t}\n    }\n\t// print string \"s\" multiple times \n\t// prefer to use this function for multiple printing\n\tpublic static String mp(String s, int times) {\n\t\treturn String.valueOf(new char[times]).replace(\"\\0\", s);\n\t}\n\t// take log with base 2\n \tpublic static long log2(long k) {\n \t\treturn 63-Long.numberOfLeadingZeros(k);\n \t}\n\n \t// using lambda function for sorting\n   \tpublic static void lambdaSort() {\n   \t\tArrays.sort(arr, (a, b) -> Double.compare(a[0], b[0]));\n   \t}\n  \t\n  \t// (n choose k) = (n/k) * ((n-1) choose (k-1))\n  \tpublic static long choose(long n, long k) {\n \t\treturn (k == 0) ? 1 : (n*choose(n-1, k-1))/k;\n \t}\n\n \t// just for keeping gcd function for other personal purposes\n \tpublic static long gcd(long a, long b) {\n \t\treturn (a == 0) ? b : gcd(b%a, a);\n \t}\n \t\n\tpublic static long max(long... as) {\n        long max = Long.MIN_VALUE;\n        for (long a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    public static long min(int... as) {\n        long min = Long.MAX_VALUE;\n        for (long a : as) min = Math.min(a, min);\n        return min;\n    }\n \t\n    public static long modpow(long x, long n, long mod) {\n    \tif(n == 0) return 1%mod;\n    \tlong u = modpow(x, n/2, mod);\n    \tu = (u*u)%mod;\n    \tif(n%2 == 1) u = (u*x)%mod;\n    \treturn u;\n    }\n \t// ======================= binary search (lower and upper bound) =======================\n\tpublic static int lowerBound(long[] a, int x) {\n\t\tint lo = 0;\n \t\tint hi = a.length-1;\n \t\tint ans = -1;\n \t\twhile(lo <= hi) {\n \t\t\tint mid = (lo+hi)/2;\n \t\t\tif(x < a[mid]) {\n \t\t\t\thi = mid-1;\n \t\t\t} else if(x > a[mid]) {\n \t\t\t\tlo = mid+1;\n \t\t\t} else if(lo != hi) {\n \t\t\t\t hi = mid-1; \t\t// for first occurrence\n \t\t\t\t ans = mid;\n \t\t\t} else {\n \t\t\t\treturn mid;\n \t\t\t}\n \t\t}\n \t\treturn ans;\n\t}\n\t\n\tpublic static int upperBound(long[] a, long x) {\n\t\tint lo = 0;\n\t\tint hi = a.length-1;\n\t\tint ans = -1;\n\t\twhile(lo <= hi) {\n\t\t\tint mid = (lo+hi)/2;\n\t\t\tif(x < a[mid]) {\n\t\t\t\thi = mid-1;\n\t\t\t} else if(x > a[mid]) {\n\t\t\t\tlo = mid+1;\n\t\t\t} else if(lo != hi) {\n\t\t\t\tlo = mid+1;\t\t\t// for last occurrence\n\t\t\t\tans = mid;\n\t\t\t} else {\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t// ================================================================\n\n\t// ================== SEIVE OF ERATOSTHENES =======================\n\t// Complexity : O(N * log(log(N)))       ( almost O(N) )\n\tpublic static void generatePrimes() {\n\t\t// set.add(0);\n\t\t// set.add(1);\n\t\tArrays.fill(set, true);\n\t\tset[0] = false;\n\t\tset[1] = false;\n\t\tfor(int i = 2; i <= seive_size; i++) {\n\t\t\tif(set[i]) {\n\t\t\t\tfor(long j = (long) i*i; j <= seive_size; j+=i) \n\t\t\t\t\tset[(int)j] = false;\n\t\t\t\tprimes.add(i);\n\t\t\t}\n\t\t}\n\t}\n  \n\tpublic static boolean isPrime(long N) {\n\t\tif(N <= seive_size) return set[(int)N];\n\t\tfor (int i = 0; i < (int)primes.size(); i++)\n\t\t\tif (N % primes.get(i) == 0) return false;\n\t\treturn true;\n\t}\n\t// ===========================================================\n  \n \t// ================ Permutation of String ====================\n \tpublic static void permute(String str) {\n \t\tpermute(str, 0, str.length()-1);\n \t}\n \tpublic static void permute(String str, int l, int r) \n    { \n        if (l == r) \n            System.out.println(str); \n        else\n        { \n            for (int i = l; i <= r; i++) \n            { \n                str = swap(str,l,i); \n                permute(str, l+1, r); \n                str = swap(str,l,i); \n            } \n        } \n    }\n\tpublic static String swap(String a, int i, int j) \n    { \n        char temp; \n        char[] charArray = a.toCharArray(); \n        temp = charArray[i] ; \n        charArray[i] = charArray[j]; \n        charArray[j] = temp; \n        return String.valueOf(charArray); \n    } \n\t// Union-find\n\t// static int[] parent, rank;\n//\tpublic static void makeSet(int n) {\n//\n//\t\tparent = new int[n+1];\n//\t\trank = new int[n+1];\n//\t\tfor(int i = 1; i <= n; i++) {\n//\t\t\tparent[i] = i;\n//\t\t\trank[i] = 0;\n//\t\t}\n//\t}\n\tpublic static int find(int u) {\n\n\t\tif(parent[u] == u)\treturn u;\n\n\t\tint v = find(parent[u]);\n\t\tparent[u] = v;\n\t\treturn v;\n\n\t}\n\tpublic static boolean connected(int u, int v) {\n\t\treturn find(u) == find(v);\n\t}\n\tpublic static void Union(int u, int v) {\n\n\t\tint x = find(u);\t\t\t\t//root of u\n\t\tint y = find(v);\t\t\t\t//root of v\n\n\t\tif(x == y)\t\treturn;\n\t\tif(rank[x] == rank[y]) {\n\t\t\tparent[y] = x;\n\t\t\trank[x]++;\n\t\t}\n\t\telse if(rank[x] > rank[y]) {\n\t\t\tparent[y] = x;\n\t\t}\n\t\telse {\n\t\t\tparent[x] = y;\n\t\t}\n\n\t}\n\t\n//\tpublic static int dijkstra(int x, int y) {\n//    \tint[] dist = new int[n+1];\n//    \tArrays.fill(dist, Integer.MAX_VALUE);\n//    \tPriorityQueue<Node> q = new PriorityQueue<>();\n//    \tq.add(new Node(x, 0));\n//    \tdist[x] = 0;\n//    \twhile(!q.isEmpty()) {\n//    \t\tNode node = q.poll();\n//    \t\tint u = node.key;\n//    \t\tif(u == y) {\n//    \t\t\tbreak;\n//    \t\t}\n//    \t\tfor(int v : res[u]) {\n//    \t\t\tif(dist[v] > dist[u]+count[u]) {\n//    \t\t\t\tdist[v] = dist[u] + count[u];\n//    \t\t\t\tq.add(new Node(v, dist[v]));\n//    \t\t\t}\n//    \t\t}\n//    \t}\n//    \tif(dist[y] == Integer.MAX_VALUE) {\n//    \t\treturn -1;\n//    \t}\n//    \treturn dist[y];\n//    }\n\t\n\tpublic static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {while (st == null || !st.hasMoreElements()) {\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (IOException e) {e.printStackTrace();}}\n\t\treturn st.nextToken();}\n\t\tint nextInt() {return Integer.parseInt(next());}\n\t\tlong nextLong() {return Long.parseLong(next());}\n\t\tdouble nextDouble() {return Double.parseDouble(next());}\n\t\tString nextLine(){String str = \"\";\n\t\ttry {str = br.readLine();}\n\t\tcatch (IOException e) {e.printStackTrace();}\n\t\treturn str;}\n\t\tint[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long power(long long b, long long e, long long m) {\n  if (e == 0) return 1;\n  if (e & 1) return b * power(b * b % m, e / 2, m) % m;\n  return power(b * b % m, e / 2, m);\n}\nlong long power(long long b, long long e) {\n  if (e == 0) return 1;\n  if (e & 1) return b * power(b * b, e / 2);\n  return power(b * b, e / 2);\n}\nvector<vector<int>> v;\nvector<bool> check;\nvector<set<int>> s;\nint mx = 0;\nvector<int> se;\nset<int> s1, s2;\nvoid dfs(int x) {\n  check[x] = true;\n  se.push_back(x);\n  for (auto i : v[x]) {\n    if (!check[i]) {\n      dfs(i);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  v.resize(n + 1);\n  check.resize(n + 1);\n  s.resize(n + 1);\n  int a, b;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  int k;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> a >> b;\n    s[a].insert(b);\n    s[b].insert(a);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!check[i]) {\n      dfs(i);\n    }\n    int f = 1;\n    for (int i = 0; i < se.size(); i++) {\n      for (int j = i + 1; j < se.size(); j++) {\n        if (s[se[i]].count(se[j])) {\n          f = 0;\n        }\n      }\n    }\n    if (f == 1)\n      mx = max(mx, (int)se.size() - min((int)s1.size(), (int)s2.size()));\n    se.clear();\n    s1.clear();\n    s2.clear();\n  }\n  cout << mx;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e6 + 256;\nconst int N = 1256;\nconst int INF = int(1e9);\nint n, k, m;\nvector<int> v[MAXN], g[MAXN];\nmap<pair<int, int>, bool> M;\nint u[MAXN], clr = 1;\nvoid dfs(int x, bool &T, int &comp) {\n  u[x] = clr;\n  comp++;\n  for (int i = 0; i < v[x].size(); ++i) {\n    int to = v[x][i];\n    if (!u[to]) {\n      for (int j = 0; j < g[to].size(); ++j) {\n        if (u[g[to][j]] == clr) {\n          T = 1;\n          break;\n        }\n      }\n      dfs(to, T, comp);\n    }\n  }\n}\nint main() {\n  ios_base ::sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 1; i <= k; ++i) {\n    int x, y;\n    cin >> x >> y;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  cin >> m;\n  for (int i = 1; i <= m; ++i) {\n    int x, y;\n    cin >> x >> y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (!u[i]) {\n      bool U = 0;\n      int com = 0;\n      dfs(i, U, com);\n      if (!U) {\n        ans = max(ans, com);\n      }\n      clr++;\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> G[2002];\nint mat[2002][2002];\nvector<int> te;\nint vis[2002];\nvoid go(int i) {\n  vis[i] = 1;\n  te.push_back(i);\n  for (int j = 0; j < G[i].size(); j++) {\n    int v = G[i][j];\n    if (vis[v] == 0) {\n      go(v);\n    }\n  }\n}\nint main() {\n  int n, m, k;\n  cin >> n;\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    mat[a][b] = 1;\n    mat[b][a] = 1;\n  }\n  int mx = 0;\n  for (int i = 1; i <= n; i++) {\n    if (vis[i] == 0) {\n      te.clear();\n      go(i);\n      int ok = 1;\n      for (int i = 0; i < te.size() && ok; i++) {\n        for (int j = i + 1; j < te.size() && ok; j++) {\n          if (mat[te[i]][te[j]] == 1) {\n            ok = 0;\n          }\n        }\n      }\n      if (ok == 1) {\n        mx = max(mx, (int)te.size());\n      }\n    }\n  }\n  cout << mx << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint prime[1000000 + 5], in;\nbool isp[1000000 + 5];\nusing namespace std;\nvector<int> ar[2005], v1, v2;\nint vis[6000000];\nint flag[2005][2005];\nvoid dfs(int n) {\n  v1.push_back(n);\n  vis[n] = 1;\n  for (int i = 0; i < ar[n].size(); i++) {\n    if (!vis[ar[n][i]]) {\n      dfs(ar[n][i]);\n    }\n  }\n}\nint main() {\n  int n;\n  while (cin >> n) {\n    v1.clear();\n    v2.clear();\n    int k;\n    cin >> k;\n    int a, b;\n    for (int i = 0; i < k; i++) {\n      cin >> a >> b;\n      --a;\n      --b;\n      ar[a].push_back(b);\n      ar[b].push_back(a);\n    }\n    cin >> k;\n    for (int i = 0; i < k; i++) {\n      cin >> a >> b;\n      --a;\n      --b;\n      flag[a][b] = 1;\n      flag[b][a] = 1;\n    }\n    int flu = 0, mx = 0;\n    for (int i = 0; i < n; i++) {\n      if (!vis[i]) {\n        v1.clear();\n        dfs(i);\n        flu = 1;\n        for (int j = 0; j < v1.size() && flu; j++) {\n          for (int l = j + 1; l < v1.size() && flu; l++) {\n            if (flag[v1[j]][v1[l]]) flu = 0;\n          }\n        }\n        if (flu) mx = max(mx, (int)v1.size());\n      }\n    }\n    cout << mx << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tstatic List<Vertex> sets = new ArrayList<Vertex>();\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\t\n\t\tList<Vertex> people = new ArrayList<Main.Vertex>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpeople.add(new Vertex(i + 1));\n\t\t}\n\t\tint k = sc.nextInt();\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tVertex v1 = people.get(sc.nextInt()-1);\n\t\t\tVertex v2 = people.get(sc.nextInt()-1);\n\t\t\tEdge e = new Edge(v1, v2, true);\n\t\t\tv1.edges.add(e);\n\t\t\tv2.edges.add(e);\n\t\t}\n\t\tint m = sc.nextInt();\n\t\tList<Edge> hateEdges = new ArrayList<Main.Edge>();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tVertex v1 = people.get(sc.nextInt()-1);\n\t\t\tVertex v2 = people.get(sc.nextInt()-1);\n\t\t\tEdge e = new Edge(v1, v2, false);\n\t\t\tv1.hate = true;\n\t\t\tv2.hate = true;\n\t\t\thateEdges.add(e);\n\t\t\tv1.edges.add(e);\n\t\t\tv2.edges.add(e);\n\t\t}\n\t\t\n\t\tfor(Vertex v : people){\n\t\t\tif(v.set == null) sets.add(v);\n\t\t\tcalcSet(v, v);\n\t\t}\n\t\t\n\t\tfor(Vertex p : sets){\n\t\t\tcalcSetSize(p, p);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tSet<Vertex> badSet = new TreeSet<Main.Vertex>();\n\t\tfor(Edge e : hateEdges){\n\t\t\tif(e.v1.set == e.v2.set) badSet.add(e.v1.set);\n\t\t}\n\t\tint max = 0;\n\t\tfor(Vertex set : sets){\n\t\t\tif(!badSet.contains(set)){\n\t\t\t\tmax = Math.max(set.setSize, max);\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(max);\n\t}\n\t\n\tstatic void calcSet(Vertex v, Vertex set){\n\t\tif(v.set != null) return;\n\t\tv.set = set;\n\t\tfor(Edge e : v.edges){\n\t\t\tif(!e.isFriends) continue;\n\t\t\tVertex nextVertex = e.getOtherHand(v);\n\t\t\tcalcSet(nextVertex, set);\n\t\t}\n\t}\n\t\n\tstatic void calcSetSize(Vertex v, Vertex set){\n\t\tif(v.visited) return;\n\t\tv.visited = true;\n\t\tset.setSize++;\n\t\tfor(Edge e : v.edges){\n\t\t\tif(!e.isFriends) continue;\n\t\t\tVertex nextVertex = e.getOtherHand(v);\n\t\t\tcalcSetSize(nextVertex, set);\n\t\t}\n\t}\n\t\n\tstatic int count = 0; \n\tstatic void dfs(Vertex v){\n\t\tif(v.visited) return;\n\t\tv.visited = true;\n\t\tcount++;\n\t\tfor(Edge e : v.edges){\n\t\t\tVertex nextVertex = e.getOtherHand(v);\n\t\t\tdfs(nextVertex);\n\t\t}\n\t}\n\t\n\tstatic class Vertex implements Comparable<Vertex>{\n\t\tint id;\n\t\tboolean visited;\n\t\tList<Edge> edges;\n\t\tVertex set;\n\t\tint setSize;\n\t\tboolean hate;\n\t\tboolean badSet;\n\t\tpublic Vertex(int id) {\n\t\t\tthis.id = id;\n\t\t\tedges = new ArrayList<Main.Edge>();\n\t\t\tvisited = false;\n\t\t\tset = null;\n\t\t\thate = false;\n\t\t\tsetSize = 0;\n\t\t\tbadSet = false;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Vertex o) {\n\t\t\t\n\t\t\treturn id - o.id;\n\t\t}\n\t\t\t\n\t}\n\t\n\tstatic class Edge{\n\t\tVertex v1, v2;\n\t\tboolean isFriends;\n\t\tpublic Edge(Vertex v1, Vertex v2, boolean isFriends) {\n\t\t\tsuper();\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.isFriends = isFriends;\n\t\t\t\n\t\t}\n\n\t\tVertex getOtherHand(Vertex v){\n\t\t\tif(v == v1)return v2;\n\t\t\treturn v1;\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private IO io;\n    private int ioMode = -1;\n    private String problemName = \"\";\n    private final String mjArgument = \"master_j\";\n\n    public static void main(String programArguments[]) throws IOException{\n        if(programArguments != null && programArguments.length > 0)\n            new Main().run(programArguments[0]);\n        else\n            new Main().run(null);\n    }\n\n    private void run(String programArgument) throws IOException {\n//         _______________________________________________ _________\n//        |   Input Mode     |      Output Mode    | mode | comment |\n//        |------------------|---------------------|----- |---------|\n//        |   input.txt      |      System.out     |  0   |    mj   |\n//        |   System.in      |      System.out     |  1   |  T / CF |\n//        |<problemName>.in  |  <problemName>.out  |  2   |         |\n//        |   input.txt      |      output.txt     |  3   |    C    |\n//        |__________________|_____________________|______|_________|\n        if(programArgument != null && programArgument.equals(mjArgument)) // mj\n            ioMode = 0;\n        else if(System.getProperty(\"ONLINE_JUDGE\") != null) // T / CF\n            ioMode = 1;\n        else\n            ioMode = 2;\n\n        switch(ioMode){\n            case -1:\n                try{\n                    throw new Exception(\"<ioMode> init failure\") ;\n                }catch (Exception e){\n                    e.printStackTrace();\n                }\n                return;\n            case 0:\n                break;\n            case 1:\n                break;\n            case 2:\n                if(problemName.length() == 0){\n                    try{\n                        throw new Exception(\"<problemName> init failure\");\n                    }catch (Exception e){\n                        e.printStackTrace();\n                    }\n                    return;\n                }\n            case 3:\n                break;\n        }\n        io = new IO(ioMode, problemName);\n        if(ioMode == 0){\n            System.out.println(\"File output : \\n<start>\");\n            System.out.flush();\n        }\n        solve();\n        io.flush();\n        if(ioMode == 0){\n            System.out.println(\"</start>\");\n            System.out.flush();\n        }\n    }\n\n    private void solve() throws IOException {\n        int n = io.nI(), frs = io.nI(), ens, max = 0;\n        List<Set<Integer>> friends = new ArrayList<Set<Integer>>();\n        Set<Integer> people = new HashSet<Integer>();\n        F:for(int i = 0; i<frs; i++){\n            int u = io.nI(), v = io.nI();\n            for(Set<Integer> t : friends)\n                if(t.contains(u)){\n                    t.add(v);\n                    people.add(v);\n                    continue F;\n                }else if(t.contains(v)){\n                    t.add(u);\n                    people.add(u);\n                    continue F;\n                }\n            friends.add(new HashSet<Integer>(Arrays.asList(u, v)));\n            people.add(u); people.add(v);\n        }\n        ens = io.nI();\n        F:for(int i = 0; i<ens; i++){\n            int u = io.nI(), v = io.nI();\n            for(Set<Integer> t : friends)\n                if(t.contains(u) && t.contains(v)){\n                    t.clear();\n                    continue F;\n                }\n            friends.add(new HashSet<Integer>(Arrays.asList(u)));\n            friends.add(new HashSet<Integer>(Arrays.asList(v)));\n            people.add(u); people.add(v);\n        }\n        for(Set<Integer> t : friends)\n            max = Math.max(t.size(), max);\n        io.wln(Math.max(max, n - people.size() == 0 ? 0 : 1));\n    }//2.2250738585072012e-308\n\n    /**\n     * Input-output class\n     * @author master_j\n     * @version 0.2.0\n     */\n    @SuppressWarnings(\"unused\")\n    private class IO{\n        StreamTokenizer in; PrintWriter out; BufferedReader br; Reader reader; Writer writer;\n        public IO(int ioMode, String problemName) throws IOException{\n            Locale.setDefault(Locale.US);\n//         _______________________________________________ _________\n//        |   Input Mode     |      Output Mode    | mode | comment |\n//        |------------------|---------------------|----- |---------|\n//        |   input.txt      |      System.out     |  0   |    mj   |\n//        |   System.in      |      System.out     |  1   |  T / CF |\n//        |<problemName>.in  |  <problemName>.out  |  2   |         |\n//        |   input.txt      |      output.txt     |  3   |    C    |\n//        |__________________|_____________________|______|_________|\n            switch(ioMode){\n                case 0:\n                    reader = new FileReader(\"input.txt\");\n                    writer = new OutputStreamWriter(System.out);\n                    break;\n                case 1:\n                    reader = new InputStreamReader(System.in);\n                    writer = new OutputStreamWriter(System.out);\n                    break;\n                case 2:\n                    reader = new FileReader(problemName + \".in\");\n                    writer = new FileWriter(problemName + \".out\");\n                    break;\n                case 3:\n                    reader = new FileReader(\"input.txt\");\n                    writer = new FileWriter(\"output.txt\");\n                    break;\n            }\n            br = new BufferedReader(reader);\n            in = new StreamTokenizer(br);\n            out = new PrintWriter(writer);\n        }\n        public void wln(){out.println();}\n        public void wln(int arg){out.println(arg);}\n        public void wln(long arg){out.println(arg);}\n        public void wln(double arg){out.println(arg);}\n        public void wln(String arg){out.println(arg);}\n        public void wln(boolean arg){out.println(arg);}\n        public void wln(char arg){out.println(arg);}\n        public void wln(float arg){out.println(arg);}\n        public void wln(Object arg){out.println(arg);}\n        public void w(int arg){out.print(arg);}\n        public void w(long arg){out.print(arg);}\n        public void w(double arg){out.print(arg);}\n        public void w(String arg){out.print(arg);}\n        public void w(boolean arg){out.print(arg);}\n        public void w(char arg){out.print(arg);}\n        public void w(float arg){out.print(arg);}\n        public void w(Object arg){out.print(arg);}\n        public void wf(String format, Object...args){out.printf(format, args);}\n        public void flush(){out.flush();}\n        public int nI() throws IOException {in.nextToken(); return(int)in.nval;}\n        public long nL() throws IOException {in.nextToken(); return(long)in.nval;}\n        public String nS() throws IOException {in.nextToken(); return in.sval;}\n        public double nD() throws IOException {in.nextToken(); return in.nval;}\n        public float nF() throws IOException {in.nextToken(); return (float)in.nval;}\n        public void wc(char...a){for(char c : a){in.ordinaryChar(c);in.wordChars(c, c);}}\n        public void wc(char c1, char c2){in.ordinaryChars(c1, c2); in.wordChars(c1, c2);}\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstd::vector<int> e[2000];\nbool t[2000][2000];\nint main() {\n  int n, k, u, v;\n  bool d[2000] = {};\n  std::queue<int> q;\n  std::vector<int> w;\n  int r(0);\n  std::scanf(\"%d%d\", &n, &k);\n  while (0 < k--) {\n    std::scanf(\"%d%d\", &u, &v);\n    --u, --v;\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  std::scanf(\"%d\", &k);\n  while (0 < k--) {\n    std::scanf(\"%d%d\", &u, &v);\n    --u, --v;\n    t[u][v] = t[v][u] = true;\n  }\n  for (int i(0); i < n; ++i) {\n    if (d[i]) continue;\n    q.push(i);\n    while (!q.empty()) {\n      int x = q.front();\n      q.pop();\n      if (d[x]) continue;\n      d[x] = true;\n      w.push_back(x);\n      for (int y : e[x]) {\n        if (!d[y]) q.push(y);\n      }\n    }\n    for (int x : w) {\n      for (int y : w) {\n        if (t[x][y]) goto N;\n      }\n    }\n    r = std::max<int>(r, w.size());\n  N:\n    w.clear();\n  }\n  std::printf(\"%d\\n\", r);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint par[2010];\nint rankk[2010];\nint n;\nvoid init() {\n  for (int i = 1; i <= n; ++i) {\n    par[i] = i;\n    rankk[i] = 1;\n  }\n}\nint findset(int u) {\n  if (u == par[u])\n    return u;\n  else\n    return par[u] = findset(par[u]);\n}\nvoid link(int u, int v) {\n  int a = findset(u);\n  int b = findset(v);\n  if (a != b) {\n    par[b] = a;\n    rankk[a] += rankk[b];\n  }\n}\nint main() {\n  int k, m, u, v;\n  scanf(\"%d\", &n);\n  ;\n  init();\n  scanf(\"%d\", &k);\n  ;\n  for (int i = 0; i < k; ++i) {\n    scanf(\"%d\", &u);\n    ;\n    scanf(\"%d\", &v);\n    ;\n    link(u, v);\n  }\n  scanf(\"%d\", &m);\n  ;\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d\", &u);\n    ;\n    scanf(\"%d\", &v);\n    ;\n    int a = findset(u);\n    int b = findset(v);\n    if (a == b) rankk[a] = 0;\n  }\n  int maxx = 0;\n  for (int i = 1; i <= n; ++i) maxx = max(maxx, rankk[findset(i)]);\n  cout << maxx << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int rdi() {\n  int d;\n  scanf(\"%d\", &d);\n  return d;\n}\ninline char rdc() {\n  scanf(\" \");\n  return getchar();\n}\ninline string rds() {\n  string s;\n  cin >> s;\n  return s;\n}\ninline double rddb() {\n  double d;\n  scanf(\"%lf\", &d);\n  return d;\n}\ntemplate <class T>\ninline bool setmin(T& a, T b) {\n  return a > b ? a = b, true : false;\n}\ntemplate <class T>\ninline bool setmax(T& a, T b) {\n  return a < b ? a = b, true : false;\n}\nstruct debugger {\n  template <typename T>\n  debugger& operator,(const T& x) {\n    cerr << x << \",\";\n    return *this;\n  }\n} dbgr;\nconst int N = 4096, M = 524288;\nbool vis[N];\nint n, ans, cnt, nu, us[N];\nint ne, head[N], vex[M], nxt[M];\nint ne2, head2[N], vex2[M], nxt2[M];\nvoid add_edge(int u, int v) {\n  ++ne;\n  vex[ne] = v;\n  nxt[ne] = head[u];\n  head[u] = ne;\n}\nvoid add_2edge(int u, int v) {\n  add_edge(u, v);\n  add_edge(v, u);\n}\nvoid add_edge2(int u, int v) {\n  ++ne2;\n  vex2[ne2] = v;\n  nxt2[ne2] = head2[u];\n  head2[u] = ne2;\n}\nvoid add_2edge2(int u, int v) {\n  add_edge2(u, v);\n  add_edge2(v, u);\n}\nvoid dfs(int u) {\n  if (vis[u] == true) return;\n  vis[u] = true, ++cnt, us[nu++] = u;\n  for (int i = head[u]; i != 0; i = nxt[i]) dfs(vex[i]);\n}\nbool ok() {\n  for (int i = (0); i < (nu); ++i) {\n    int u = us[i];\n    for (int i = head2[u]; i != 0; i = nxt2[i]) {\n      int v = vex2[i];\n      if (vis[v]) return false;\n    }\n  }\n  return true;\n}\nint main() {\n  n = rdi();\n  for (int repp_b = (rdi()), repp = 0; repp < repp_b; ++repp) {\n    int u = rdi(), v = rdi();\n    add_2edge(u, v);\n  }\n  for (int repp_b = (rdi()), repp = 0; repp < repp_b; ++repp) {\n    int u = rdi(), v = rdi();\n    add_2edge2(u, v);\n  }\n  for (int i = (1); i <= (n); ++i)\n    if (!vis[i]) {\n      cnt = 0, nu = 0, dfs(i);\n      if (ok()) setmax(ans, cnt);\n      for (int i = (0); i < (nu); ++i) vis[us[i]] = false;\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> par(20001, -1), ran(20001, 1), can_parent(20001, 1);\nvector<int> arr[20001];\nint vis[20001];\nint siz;\nbool flag;\nint find(int node) {\n  if (par[node] == -1) return node;\n  return par[node] = find(par[node]);\n}\nvoid unite(int a, int b) {\n  int s1 = find(a);\n  int s2 = find(b);\n  if (s1 != s2) {\n    if (ran[s1] >= ran[s2]) {\n      par[s2] = s1;\n      ran[s1] += ran[s2];\n    } else {\n      par[s1] = s2;\n      ran[s2] += ran[s1];\n    }\n  }\n  return;\n}\nbool dfs(int node) {\n  vis[node] = 1;\n  if (can_parent[node] == 0)\n    flag = false;\n  else\n    siz++;\n  for (int child : arr[node])\n    if (vis[child] == 0) dfs(child);\n  return flag;\n}\nint main() {\n  int v, k, m, a, b;\n  cin >> v;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> a >> b;\n    arr[a].push_back(b);\n    arr[b].push_back(a);\n    unite(a, b);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b;\n    int s1 = find(a);\n    int s2 = find(b);\n    if (s1 == s2) {\n      can_parent[s1] = 0;\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= v; i++) {\n    if (vis[i] == 0) {\n      siz = 0, flag = true;\n      if (dfs(i)) {\n        ans = max(ans, siz);\n      }\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n ID: govind.3, GhpS, govindpatel\n LANG: JAVA\n TASK: Main \n */\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\n    /**\n     * Min segment Tree takes the minimum number at the root\n     */\n    class MinSegmentTree {\n\n        /**\n         * root: Tree root, balance: input array, rl,rr:\n         * rl=0,rr=inputArray.length-1 minTree:segment Tree\n         */\n        private void initMinTree(int root, int rl, int rr, int[] balance, int[] minTree) {\n            if (rl == rr) {\n                minTree[root] = balance[rl];\n                return;\n            }\n            int rm = (rl + rr) / 2;\n            initMinTree(root * 2 + 1, rl, rm, balance, minTree);\n            initMinTree(root * 2 + 2, rm + 1, rr, balance, minTree);\n            minTree[root] = Math.min(minTree[root * 2 + 1], minTree[root * 2 + 2]);\n        }\n\n        /**\n         * minTree:segment tree root:0 rl:0,rr:inputarray.length-1\n         * l=queryleft-1(If 1 based index),r = queryright(1-based)\n         */\n        private int getMin(int[] minTree, int root, int rl, int rr, int l, int r) {\n            //l = query left-1, r = query right\n            if (l > r) {\n                return Integer.MAX_VALUE;\n            }\n            if (l == rl && r == rr) {\n                return minTree[root];\n            }\n            int rm = (rl + rr) / 2;\n            return Math.min(getMin(minTree, root * 2 + 1, rl, rm, l, Math.min(r, rm)),\n                    getMin(minTree, root * 2 + 2, rm + 1, rr, Math.max(rm + 1, l), r));\n        }\n    }\n    //dsu next operation\n    int[] next;\n\n    private int next(int i) {\n        if (next[i] == i) {\n            return i;\n        }\n        return next[i] = next(next[i]);\n    }\n\n    //segment tree...\n    private void set(int[] t, int ind, int val) {\n        ind += (t.length / 2);\n        t[ind] = val;\n        int curr = 0;\n        while (ind > 1) {\n            ind >>= 1;\n            if (curr == 0) {\n                t[ind] = t[ind * 2] | t[ind * 2 + 1];\n            } else {\n                t[ind] = t[ind * 2] ^ t[2 * ind + 1];\n            }\n            curr ^= 1;\n        }\n    }\n\n    //Binary Index tree\n    class FenwickTree {\n\n        int[] ft;\n        int N;\n\n        FenwickTree(int n) {\n            this.N = n;\n            ft = new int[N];\n        }\n\n        private int lowbit(int x) {\n            return x & (-x);\n        }\n\n        void update(int pos, int val) {\n            while (pos < N) {\n                ft[pos] += val;\n                pos |= pos + 1;//0-index\n            }\n        }\n\n        int sum(int pos) {\n            int sum = 0;\n            while (pos >= 0) {\n                sum += ft[pos];\n                pos = (pos & (pos + 1)) - 1;\n            }\n            return sum;\n        }\n\n        int rangeSum(int left, int right) {\n            return sum(right) - sum(left - 1);\n        }\n    }\n\n    /**\n     * BINARY SEARCH IN FENWICK TREE: l=1, r=N(length), at=sumRequired,\n     * letter=TreeIndex(if there are many ft), ft=arrays of FT\n     */\n    private int binarySearch(int l, int r, int at, int letter, FenwickTree[] ft) {\n        while (r - l > 0) {\n            int mid = (l + r) / 2;\n            int sum = ft[letter].sum(mid);\n            if (sum < at) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return l;\n    }\n\n    private int[] compress(int[] a) {\n        int[] b = new int[a.length];\n        for (int i = 0; i < a.length; i++) {\n            b[i] = a[i];\n        }\n        Arrays.sort(b);\n        int m = 0;\n        for (int i = 0; i < b.length;) {\n            int j = i;\n            while (j < b.length && b[j] == b[i]) {\n                j++;\n            }\n            b[m++] = b[i];\n            i = j;\n        }\n        for (int i = 0; i < a.length; i++) {\n            a[i] = Arrays.binarySearch(b, 0, m, a[i]);\n        }\n        return a;\n    }\n\n    class Dijkstra {\n\n        class Edge implements Comparable<Edge> {\n\n            int to;\n            long weight;\n\n            Edge(int t, long w) {\n                to = t;\n                weight = w;\n            }\n\n            public int compareTo(Edge other) {\n                return (int) Math.signum(weight - other.weight);\n            }\n        }\n        public static final long INF = (long) 1e17;\n        private ArrayList<Edge> adj[];\n        private int nodes;\n        private long[] dist;\n        private int[] prev;\n        private boolean[] visited;\n\n        public Dijkstra(int n) {\n            nodes = n;\n            adj = new ArrayList[nodes];\n            dist = new long[nodes];\n            prev = new int[nodes];\n            visited = new boolean[nodes];\n            for (int i = 0; i < nodes; i++) {\n                adj[i] = new ArrayList<Edge>();\n                dist[i] = INF;\n                prev[i] = -1;\n            }\n        }\n\n        public void add(int u, int v, long cost) {\n            adj[u].add(new Edge(v, cost));\n        }\n\n        public void dist() {\n            //src vertex = 0;\n            dist[0] = 0;\n            Queue<Edge> q = new PriorityQueue<Edge>();\n            q.add(new Edge(0, 0));\n            while (!q.isEmpty()) {\n                Edge e = q.poll();\n                int ind = e.to;\n                if (visited[ind]) {\n                    continue;\n                }\n                visited[ind] = true;\n\n                for (Edge edge : adj[ind]) {\n                    long newDistance = e.weight + edge.weight;\n                    if (newDistance < dist[edge.to]) {\n                        dist[edge.to] = newDistance;\n                        prev[edge.to] = ind;\n                        q.add(new Edge(edge.to, dist[edge.to]));\n                    }\n                }\n            }\n        }\n\n        public ArrayList<Integer> getPrevList(int last) {\n            ArrayList<Integer> al = new ArrayList<Integer>();\n            while (last != -1) {\n                al.add(last);\n                last = prev[last];\n            }\n            return al;\n        }\n\n        public int[] getPrev() {\n            return prev;\n        }\n\n        public long[] getDistance() {\n            return dist;\n        }\n\n        public boolean[] getVisited() {\n            return visited;\n        }\n    }\n\n    class Edge {\n\n        int id, to, cap;\n        boolean rev;\n\n        Edge(int to, int id, int cap, boolean rev) {\n            this.to = to;\n            this.id = id;\n            this.cap = cap;\n            this.rev = rev;\n        }\n    }\n    int[] p;\n\n    private void solve() throws IOException {\n        int N = nextInt();\n        int M = nextInt();\n        p = new int[2005];\n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n        }\n        for (int i = 0; i < M; i++) {\n            int f1 = nextInt() - 1;\n            int f2 = nextInt() - 1;\n            merge(f1, f2);\n        }\n        boolean[] good = new boolean[N];\n        int[] size = new int[N];\n        for (int i = 0; i < N; i++) {\n            size[get(i)]++;\n            good[i] = true;\n        }\n        int E = nextInt();\n        for (int i = 0; i < E; i++) {\n            int e1 = nextInt() - 1;\n            int e2 = nextInt() - 1;\n            int pe1 = get(e1);\n            int pe2 = get(e2);\n            if (pe1 == pe2) {\n                good[pe1] = false;\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < N; i++) {\n            if (good[i]) {\n                ans = Math.max(ans, size[i]);\n            }\n        }\n        out.println(ans);\n    }\n\n    void merge(int a, int b) {\n        a = get(a);\n        b = get(b);\n        if (a != b) {\n            p[a] = b;\n        }\n    }\n\n    int get(int a) {\n        if (p[a] == a) {\n            return a;\n        }\n//        while (p[a] != a) {\n//            p[a] = p[p[a]];\n//            a = p[a];\n//        }\n        return p[a] = get(p[a]);\n    }\n\n    boolean isSorted(ArrayList<Integer> al) {\n        int size = al.size();\n        for (int i = 1; i < size - 2; i++) {\n            if (al.get(i) > al.get(i + 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * SHUFFLE: shuffle the array 'a' of size 'N'\n     */\n    private void shuffle(int[] a, int N) {\n        for (int i = 0; i < N; i++) {\n            int r = i + (int) ((N - i) * Math.random());\n            int t = a[i];\n            a[i] = a[r];\n            a[r] = t;\n        }\n    }\n\n    /**\n     * TEMPLATE-STUFF: main method, run method - ( fileIO and stdIO ) and\n     * various methods for input like nextInt, nextLong, nextToken and\n     * nextDouble with some declarations.\n     */\n    /**\n     * For solution to the problem ... see the solve method\n     */\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    public void run() {\n        try {\n            in = new BufferedReader(new FileReader(\"D-large.in\"));\n            out = new PrintWriter(new BufferedWriter(new FileWriter(\"Main.out\")));\n            tok = null;\n            solve();\n            in.close();\n            out.close();\n            System.exit(0);\n        } catch (IOException e) {//(FileNotFoundException e) {\n            try {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(new OutputStreamWriter(System.out));\n                tok = null;\n                solve();\n                in.close();\n                out.close();\n                System.exit(0);\n            } catch (IOException ex) {\n                System.out.println(ex.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n\n    private String nextToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    BufferedReader in;\n    StringTokenizer tok;\n    PrintWriter out;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 2002;\nint N, K, M;\nint a, b;\nbool uf[MAX], mk[MAX];\nvector<int> cf;\nvector<int> Gf[MAX], Ge[MAX];\nvoid dfs1(int x) {\n  mk[x] = true;\n  uf[x] = true;\n  cf.push_back(x);\n  for (typeof(Gf[x].begin()) k = Gf[x].begin(); k != Gf[x].end(); ++k) {\n    int j = *k;\n    if (!mk[j]) dfs1(j);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> N;\n  cin >> K;\n  for (int i = 0; i < (K); ++i) {\n    cin >> a >> b;\n    --a;\n    --b;\n    Gf[a].push_back(b);\n    Gf[b].push_back(a);\n  }\n  cin >> M;\n  for (int i = 0; i < (M); ++i) {\n    cin >> a >> b;\n    --a;\n    --b;\n    Ge[a].push_back(b);\n    Ge[b].push_back(a);\n  }\n  int ans = 0;\n  for (int i = 0; i < (N); ++i)\n    if (!mk[i]) {\n      cf.clear();\n      for (int j = 0; j < (N); ++j) uf[j] = false;\n      dfs1(i);\n      for (typeof(cf.begin()) k = cf.begin(); k != cf.end(); ++k)\n        for (typeof(Ge[*k].begin()) j = Ge[*k].begin(); j != Ge[*k].end(); ++j)\n          if (uf[*j]) goto error;\n      ans = max(ans, ((int)(cf).size()));\n    error:;\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> > a;\nvector<int> pset;\nvoid make_set(int N) {\n  pset.assign(N + 1, 0);\n  for (int i = 1; i <= N; i++) {\n    pset[i] = i;\n  }\n}\nint find_set(int i) {\n  if (pset[i] == i) {\n    return pset[i];\n  }\n  return pset[i] = find_set(pset[i]);\n}\nbool is_same_set(int i, int j) { return find_set(i) == find_set(j); }\nvoid union_set(int i, int j) { pset[find_set(i)] = find_set(j); }\nvector<int> flag, gr_size;\nint main() {\n  int n, i, x, y;\n  scanf(\"%d\", &n);\n  flag.resize(n + 1);\n  gr_size.resize(n + 1);\n  for (i = 1; i <= n; i++) gr_size[i] = 1;\n  make_set(n);\n  int k;\n  scanf(\"%d\", &k);\n  for (i = 0; i < k; i++) {\n    scanf(\"%d %d\", &x, &y);\n    if (find_set(x) != find_set(y))\n      gr_size[find_set(y)] += gr_size[find_set(x)];\n    union_set(x, y);\n  }\n  int m, max_size = 0;\n  scanf(\"%d\", &m);\n  for (i = 0; i < m; i++) {\n    scanf(\"%d %d\", &x, &y);\n    if (find_set(x) == find_set(y)) {\n      flag[find_set(x)] = -1;\n    }\n  }\n  for (i = 1; i <= n; i++) {\n    if (find_set(i) == i && flag[i] != -1) max_size = max(max_size, gr_size[i]);\n  }\n  printf(\"%d\", max_size);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid fast_io() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\nconst long long SIZE = (long long)2e3 + 10;\nconst int MOD = (long long)1e9;\nvector<int> adj[SIZE + 10];\nvector<int> anti[SIZE + 10];\nint vis[SIZE + 10] = {0};\npair<int, bool> dfs(int u, int color) {\n  vis[u] = color;\n  bool valid = true;\n  int cnt = 1;\n  for (int i = 0; i < adj[u].size(); ++i) {\n    int v = adj[u][i];\n    if (vis[v] == 0) {\n      pair<int, bool> ret = dfs(v, color);\n      valid = valid && ret.second;\n      cnt += ret.first;\n    }\n  }\n  if (!valid) return make_pair(cnt, valid);\n  for (int i = 0; i < anti[u].size(); ++i) {\n    int v = anti[u][i];\n    if (vis[v] == color) return make_pair(cnt, false);\n  }\n  return make_pair(cnt, true);\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int k;\n  scanf(\"%d\", &k);\n  for (long long i = 0; i <= k - 1; i++) {\n    int u, v;\n    scanf(\"%d\", &u);\n    scanf(\"%d\", &v);\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  int m;\n  scanf(\"%d\", &m);\n  for (long long i = 0; i <= m - 1; i++) {\n    int u, v;\n    scanf(\"%d\", &u);\n    scanf(\"%d\", &v);\n    anti[u].push_back(v);\n    anti[v].push_back(u);\n  }\n  int mx = 0;\n  for (long long i = 1; i <= n; i++)\n    if (vis[i] == 0) {\n      pair<int, bool> ret = dfs(i, i);\n      if (ret.second) mx = max(ret.first, mx);\n    }\n  cout << mx;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, x, y, e1, e2;\nint par[2010], ch[2010];\nint ans = 0;\nint get_par(int x) { return par[x] == x ? x : par[x] = get_par(par[x]); }\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    par[i] = i;\n    ch[i] = 1;\n  }\n  for (int i = 1; i <= m; i++) {\n    cin >> x >> y;\n    x = get_par(x), y = get_par(y);\n    if (x != y) {\n      par[y] = x;\n      ch[x] += ch[y];\n    }\n  }\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    cin >> x >> y;\n    x = get_par(x), y = get_par(y);\n    if (x == y) ch[x] = 0;\n  }\n  for (int i = 1; i <= n; i++)\n    if (get_par(i) == i && ans < ch[i]) ans = ch[i];\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\n   Scanner in;\n   PrintWriter out;\n\n   void asserT(boolean e) {\n      if (!e) {\n         throw new Error();\n      }\n   }\n\n   class Man {\n      int id;\n      HashSet<Man> friends = new HashSet<Main.Man>();\n      HashSet<Man> realFriends = new HashSet<Main.Man>();\n      HashSet<Man> enimes = new HashSet<Main.Man>();\n      boolean wasUsed = false;\n      int nUsedFriends = 0;\n\n      public Man(int id) {\n         this.id = id;\n      }\n\n      @Override\n      public int hashCode() {\n         final int prime = 31;\n         int result = 1;\n         result = prime * result + getOuterType().hashCode();\n         result = prime * result + id;\n         return result;\n      }\n\n      @Override\n      public boolean equals(Object obj) {\n         if (this == obj)\n            return true;\n         if (obj == null)\n            return false;\n         if (getClass() != obj.getClass())\n            return false;\n         Man other = (Man) obj;\n         if (!getOuterType().equals(other.getOuterType()))\n            return false;\n         if (id != other.id)\n            return false;\n         return true;\n      }\n\n      private Main getOuterType() {\n         return Main.this;\n      }\n\n      void dfs(HashSet<Man> set) {\n         this.wasUsed = true;\n         set.add(this);\n         for (Man next : friends) {\n            if (next.id != this.id && !next.wasUsed && this.friends.contains(next)) {\n               next.dfs(set);\n            }\n\n         }\n      }\n\n   }\n\n   void solve() {\n      int nMans = in.nextInt();\n      Man mans[] = new Man[1 + nMans];\n      int nPairs = in.nextInt();\n      for (int i = 0; i < mans.length; i++) {\n         mans[i] = new Man(i);\n      }\n      for (int i = 0; i < nPairs; i++) {\n         int first = in.nextInt();\n         int second = in.nextInt();\n         mans[first].friends.add(mans[second]);\n         mans[second].friends.add(mans[first]);\n\n      }\n      nPairs = in.nextInt();\n      for (int i = 0; i < nPairs; i++) {\n         int first = in.nextInt();\n         int second = in.nextInt();\n         mans[first].enimes.add(mans[second]);\n         mans[second].enimes.add(mans[first]);\n      }\n      int best = 0;\n      for (int i = 1; i <= nMans; i++) {\n         Man man = mans[i];\n         if (!man.wasUsed) {\n            HashSet<Man> com = new HashSet<Main.Man>();\n            man.dfs(com);\n            if (isOk(com)) {\n               best = Math.max(best, com.size());\n            }\n         }\n\n      }\n      out.println(best);\n   }\n\n   void reset(HashSet<Man> set) {\n      for (Man man : set) {\n         man.nUsedFriends = 0;\n      }\n   }\n\n   boolean isOk(HashSet<Man> set) {\n      reset(set);\n      for (Man first : set) {\n         for (Man second : set) {\n            if (first.id != second.id) {\n               if (first.friends.contains(second)) {\n                  first.nUsedFriends++;\n               } else if (first.enimes.contains(second)) {\n                  return false;\n               }\n            }\n         }\n      }\n      for (Man man : set) {\n         if (man.nUsedFriends != man.friends.size()) {\n            return false;\n         }\n      }\n      return true;\n   }\n\n   void run() {\n\n      in = new Scanner(System.in);\n      out = new PrintWriter(System.out);\n\n      try {\n         solve();\n      } finally {\n         out.close();\n      }\n   }\n\n   public static void main(String[] args) {\n      new Main().run();\n   }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint P[111111];\nint sz[111111];\nint find(int x) { return (P[x] == x ? x : P[x] = find(P[x])); }\nvoid Union(int x, int y, int type) {\n  x = find(x), y = find(y);\n  if (sz[x] < sz[y]) swap(x, y);\n  if (x == y) {\n    if (type == -1) P[x] = 0;\n    return;\n  }\n  if (type == -1) return;\n  sz[x] += sz[y];\n  P[y] = x;\n}\nint main() {\n  int N, K;\n  cin >> N >> K;\n  for (int i = 1; i <= N; i++) P[i] = i, sz[i] = 1;\n  while (K--) {\n    int u, v;\n    cin >> u >> v;\n    Union(u, v, 1);\n  }\n  cin >> K;\n  while (K--) {\n    int u, v;\n    cin >> u >> v;\n    Union(u, v, -1);\n  }\n  int best = 0;\n  for (int i = 1; i <= N; i++)\n    if (find(i)) best = max(best, sz[find(i)]);\n  cout << best << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long power(long long b, long long e) {\n  if (e == 0) return 1;\n  if (e & 1) return b * power(b * b, e / 2);\n  return power(b * b, e / 2);\n}\nlong long power(long long b, long long e, long long m) {\n  if (e == 0) return 1;\n  if (e & 1) return b * power(b * b % m, e / 2, m) % m;\n  return power(b * b % m, e / 2, m);\n}\nbool sortinrev(const pair<int, int> &a, const pair<int, int> &b) {\n  return (a.first > b.first);\n}\nlong long modinv(long long a, long long m) { return power(a, m - 2, m); }\nvector<vector<long long int>> adj;\nvector<bool> visited;\nset<long long int> s;\nvector<pair<long long int, long long int>> v;\nlong long int flag = 0, c = 0;\nvoid dfs(long long x) {\n  visited[x] = true;\n  s.insert(x);\n  for (long long int i = 0; i < adj[x].size(); i++) {\n    if (!visited[adj[x][i]]) dfs(adj[x][i]);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int t = 1;\n  for (long long int g = 0; g < t; g++) {\n    long long int n, m, l, r, k;\n    cin >> n >> m;\n    set<long long int> ans;\n    visited.resize(n + 1);\n    adj.resize(n + 1);\n    for (long long int i = 0; i < m; i++) {\n      cin >> l >> r;\n      adj[l].push_back(r);\n      adj[r].push_back(l);\n    }\n    cin >> k;\n    for (long long int i = 0; i < k; i++) {\n      cin >> l >> r;\n      v.push_back(make_pair(l, r));\n    }\n    for (long long int i = 1; i <= n; i++) {\n      if (!visited[i]) {\n        flag = 0;\n        c = 0;\n        dfs(i);\n        for (long long int j = 0; j < v.size(); j++) {\n          if (s.count(v[j].first) && s.count(v[j].second)) {\n            flag = 1;\n            ans.insert(0);\n          }\n        }\n        if (flag == 0) ans.insert(s.size());\n        s.clear();\n      }\n    }\n    cout << *ans.rbegin();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class C {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid doIt()\n\t{\n\t\tint n = sc.nextInt();\n\t\tUnionFindTree uft = new UnionFindTree(n);\n\t\tint k = sc.nextInt();\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tint u = sc.nextInt()-1, v = sc.nextInt()-1;\n\t\t\tuft.unite(u, v);\n\t\t}\n\t\tHashMap<Integer, Integer> grp = new HashMap<Integer, Integer>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint root = uft.find(i);\n\t\t\tif(grp.containsKey(root)) {\n\t\t\t\tgrp.put(root, grp.get(root)+1);\n\t\t\t} else {\n\t\t\t\tgrp.put(root, 1);\n\t\t\t}\n\t\t}\n\t\tint m = sc.nextInt();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt()-1, v = sc.nextInt()-1;\n\t\t\tint r1 = uft.find(u), r2 = uft.find(v);\n\t\t\tif(r1 == r2) grp.put(r1, 0);\n\t\t}\n\t\tint ans = 0;\n\t\tfor(Integer key: grp.keySet()) {\n\t\t\t//System.out.println(key + \" \" + grp.get(key));\n\t\t\tans = Math.max(ans, grp.get(key));\n\t\t}\n\t\tif(ans <= 0) ans = 0;\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew C().doIt();\n\t}\n\tclass UnionFindTree\n\t{\n\t\tint [] par, rank;\n\t\tUnionFindTree(int n)\n\t\t{\n\t\t\tpar = new int [n];\n\t\t\trank = new int [n];\n\t\t\tfor(int i = 0; i < n; i++) par[i] = i;\n\t\t}\n\t\tint find (int x) {\n\t\t\tif(par[x] == x) {\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t\t}\n\t\t}\n\t\tvoid unite(int x, int y)\n\t\t{\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif( x == y) return;\n\t\t\t\n\t\t\tif(rank[x] < rank[y]) {\n\t\t\t\tpar[x] = y;\n\t\t\t} else {\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t\tboolean same(int x, int y)\n\t\t{\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "t, p, k = [0] * (int(input()) + 1), {0: []}, 1\nfor i in range(int(input())):\n    a, b = map(int, input().split())\n    if t[a] == t[b]:\n        if t[a] == 0:\n            t[a] = t[b] = k\n            p[k] = [a, b]\n            k += 1            \n    else:\n        if t[a] == 0:\n            t[a] = t[b]\n            p[t[b]].append(a)\n        elif t[b] == 0:\n            t[b] = t[a]\n            p[t[a]].append(b)\n        else:\n            x, y = t[b], t[a]\n            for c in p[x]:\n                t[c] = y\n            p[y] += p[x]\n            p[x] = []          \nfor i in range(int(input())):\n    a, b = map(int, input().split())\n    if t[a] == t[b]: p[t[a]] = []\nans = max(map(len, p.values()))\nif ans == 0: ans = int(0 in t[1:])\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> arr[2005];\nvector<int> arrr[2005];\nint visit[2005];\nint maxx = 0;\nunordered_map<int, int> umap;\nvector<int> dang;\nbool dfss(int node, int enemy) {\n  visit[node] = 1;\n  if (node == enemy) return false;\n  int y = arr[node].size();\n  for (int i = 0; i < y; i++) {\n    if (!visit[arr[node][i]]) {\n      visit[arr[node][i]] = 1;\n      if (dfss(arr[node][i], enemy) == false) return false;\n    } else if (arr[node][i] == enemy)\n      return false;\n  }\n  return true;\n}\nvoid dfs(int node) {\n  visit[node] = 1;\n  dang.push_back(node);\n  maxx++;\n  int y = arr[node].size();\n  for (int i = 0; i < y; i++) {\n    if (!visit[arr[node][i]]) {\n      visit[arr[node][i]] = 1;\n      dfs(arr[node][i]);\n    }\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  int k;\n  for (int i = 1; i <= n; i++) umap[i]++;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    cin >> u >> v;\n    arr[u].push_back(v);\n    arr[v].push_back(u);\n  }\n  int m;\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    arrr[x].push_back(y);\n    arrr[y].push_back(x);\n    umap[x]++;\n    umap[y]++;\n    if (dfss(x, y) == false) {\n      for (int i = 1; i <= n; i++) visit[i] = 0;\n      dfs(x);\n      int z = dang.size();\n      for (int i = 0; i < z; i++) {\n        arr[dang[i]].clear();\n        umap[dang[i]] = 0;\n      }\n      dang.clear();\n      for (int i = 1; i <= n; i++) visit[i] = 0;\n    }\n  }\n  for (int i = 1; i <= n; i++) visit[i] = 0;\n  int h = 0;\n  for (int i = 1; i <= n; i++) {\n    if (visit[i] == 0 && (umap[i] > 0)) {\n      int y = arrr[i].size();\n      for (int l = 0; l < y; l++) {\n        umap[arrr[i][l]] = 0;\n      }\n      umap[i] = 0;\n      maxx = 0;\n      dfs(i);\n      if (maxx > h) h = maxx;\n    }\n  }\n  cout << h << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int id[1000002], vis[1000002], sz[1000004];\nint find(long long int u) {\n  if (u == id[u]) return u;\n  return find(id[u]);\n}\nvoid merge(long long int u, long long int v) {\n  long long int p = find(u);\n  long long int q = find(v);\n  if (p != q) {\n    id[p] = q;\n    sz[q] += sz[p];\n  }\n}\nint main() {\n  long long int n, q, m, i;\n  cin >> n >> q;\n  for (i = 1; i <= n; i++) id[i] = i, sz[i] = 1;\n  for (i = 0; i < q; i++) {\n    long long int u, v;\n    cin >> u >> v;\n    merge(u, v);\n  }\n  cin >> m;\n  for (i = 0; i < m; i++) {\n    long long int u, v;\n    cin >> u >> v;\n    u = find(u), v = find(v);\n    if (u == v) vis[u] = 1;\n  }\n  long long int ma = 0;\n  for (i = 1; i <= n; i++) {\n    if (find(i) == i && vis[i] == 0) ma = max(ma, sz[i]);\n  }\n  cout << ma << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntypedef struct {\n  int to, nextid;\n} ne;\nint l[100005];\nne le[200005];\nint d[2001][2001];\nint s[2001], vis[2001];\nint c;\nvoid dfs(int a) {\n  s[c++] = a;\n  vis[a] = 1;\n  int i;\n  for (i = l[a]; i != -1; i = le[i].nextid) {\n    if (vis[le[i].to] == 0) {\n      dfs(le[i].to);\n    }\n  }\n}\nint main() {\n  int n, i, u, v, m, k, j;\n  scanf(\"%d%d\", &n, &k);\n  for (i = 0; i <= n + 5; i++) l[i] = -1;\n  for (i = 0; i < k; i++) {\n    scanf(\"%d%d\", &u, &v);\n    le[2 * i].nextid = l[u];\n    le[2 * i].to = v;\n    l[u] = 2 * i;\n    le[2 * i + 1].nextid = l[v];\n    le[2 * i + 1].to = u;\n    l[v] = 2 * i + 1;\n  }\n  scanf(\"%d\", &m);\n  for (i = 0; i < m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    d[u][v] = d[v][u] = 1;\n  }\n  int ans = 0, l;\n  for (i = 1; i <= n; i++) {\n    c = 0;\n    if (vis[i] == 0) {\n      dfs(i);\n      for (j = 0; j < c; j++) {\n        for (l = j; l < c; l++) {\n          if (d[s[j]][s[l]]) c = 0;\n        }\n      }\n      if (c > ans) ans = c;\n    }\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v[100000];\nvector<int> s[190000];\nint vis[100000], w = 0;\nvoid dfs(int x) {\n  int j;\n  vis[x] = 1;\n  for (j = 0; j < v[x].size(); j++) {\n    if (vis[v[x][j]] == 0) dfs(v[x][j]);\n  }\n}\nint main() {\n  int n, i, ans = 0, j, m, k, a, b, o, t, e;\n  cin >> n >> k;\n  for (i = 0; i < k; i++) {\n    cin >> a >> b;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  cin >> m;\n  for (i = 0; i < m; i++) {\n    cin >> a >> b;\n    s[a].push_back(b);\n    s[b].push_back(a);\n  }\n  for (i = 1; i <= n; i++) {\n    o = 0;\n    for (j = 1; j <= n; j++) vis[j] = 0;\n    dfs(i);\n    w = 0;\n    for (j = 1; j <= n; j++) {\n      if (vis[j] == 1) {\n        o++;\n        for (t = 0; t < s[j].size(); t++) {\n          if (vis[s[j][t]] == 1) {\n            w = 1;\n            break;\n          }\n        }\n      }\n    }\n    if (w == 0) {\n      ans = max(ans, o);\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool q[2000] = {false};\nint fri[2000] = {0};\nint ene[2000] = {0};\nint cnt = 0;\nvector<int> a[2000];\nvector<int> b[2000];\nvoid cHeck(int ii) {\n  q[ii] = true;\n  fri[ii] = 1;\n  if (a[ii].size() > 0)\n    for (int i = 0; i <= a[ii].size() - 1; i++) {\n      if (q[a[ii][i]] == false) cHeck(a[ii][i]);\n    }\n  if (b[ii].size() > 0)\n    for (int i = 0; i <= b[ii].size() - 1; i++) {\n      ene[b[ii][i]] = 1;\n    }\n  cnt++;\n  return;\n}\nint main() {\n  int n, k, m;\n  cin >> n >> k;\n  for (int i = 1; i <= k; i++) {\n    int u, v;\n    cin >> u >> v;\n    a[u].push_back(v);\n    ;\n    a[v].push_back(u);\n    ;\n  }\n  cin >> m;\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    cin >> u >> v;\n    b[u].push_back(v);\n    ;\n    b[v].push_back(u);\n    ;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int qq = 1; qq <= n; qq++) fri[qq] = ene[qq] = 0;\n    cnt = 0;\n    if (q[i] == false) {\n      cHeck(i);\n    }\n    for (int j = 1; j <= n; j++)\n      if (fri[j] * ene[j] == 1) {\n        cnt = 0;\n        break;\n      }\n    ans = max(cnt, ans);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n = int(raw_input())\nfriends = [[] for i in xrange(n)]\nfoes = [[] for i in xrange(n)]\n\nk = int(raw_input())\nfor i in xrange(k):\n    a,b = map(int, raw_input().split())\n    friends[a-1].append(b-1)\n    friends[b-1].append(a-1)\n\nf = int(raw_input())\nfor i in xrange(f):\n    a,b = map(int, raw_input().split())\n    foes[a-1].append(b-1)\n    foes[b-1].append(a-1)\n\nused = [False] * n\nout = 0\n\nwhile not all(used):\n    i = used.index(False)\n    used[i] = True\n    fr_set = set()\n    qq = [i]\n    cur_res = 0\n    while len(qq):\n        elem = qq.pop(0)\n        fr_set.add(elem)\n        for friend in friends[elem]:\n            if used[friend] == False:\n                qq.append(friend)\n                used[friend] = True\n        for foe in foes[elem]:\n            if foe in fr_set:\n                cur_res = -1\n                break\n    if cur_res == -1:\n        continue\n    cur_res = len(fr_set)\n    if out < cur_res:\n        out = cur_res\nprint out"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\n/*\nbr = new BufferedReader(new FileReader(\"input.txt\"));\npw = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\nbr = new BufferedReader(new InputStreamReader(System.in));\npw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n */\n\npublic class Main {\n\tprivate static BufferedReader br;\n\tprivate static StringTokenizer st;\n\tprivate static PrintWriter pw;\n\n\tpublic static void main(String[] args) throws IOException\t{\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tint n = readInt();\n\t\tint m = readInt();\n\t\tLinkedList<Integer>[] edges = new LinkedList[n];\n\t\tfor(int i = 0; i < n; i++)\t{\n\t\t\tedges[i] = new LinkedList<Integer>();\n\t\t}\n\t\twhile(m-- > 0)\t{\n\t\t\tint a = readInt()-1;\n\t\t\tint b = readInt()-1;\n\t\t\tedges[a].add(b);\n\t\t\tedges[b].add(a);\n\t\t}\n\t\tboolean[][] bad = new boolean[n][n];\n\t\tm = readInt();\n\t\twhile(m-- > 0)\t{\n\t\t\tint a = readInt()-1;\n\t\t\tint b = readInt()-1;\n\t\t\tbad[a][b] = bad[b][a] = true;\n\t\t}\n\t\tint ret = 0;\n\t\tboolean[] seen = new boolean[n];\n\t\tfor(int i = 0; i < n; i++)\t{\n\t\t\tif(!seen[i])\t{\n\t\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\t\tlist.add(i);\n\t\t\t\tseen[i] = true;\n\t\t\t\tLinkedList<Integer> q = new LinkedList<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\twhile(!q.isEmpty())\t{\n\t\t\t\t\tint curr = q.removeFirst();\n\t\t\t\t\tfor(int out: edges[curr])\t{\n\t\t\t\t\t\tif(!seen[out])\t{\n\t\t\t\t\t\t\tseen[out] = true;\n\t\t\t\t\t\t\tq.addLast(out);\n\t\t\t\t\t\t\tlist.add(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean win = true;\n\t\t\t\tfor(int a = 0; win && a < list.size(); a++)\t{\n\t\t\t\t\tfor(int b = 0; win && b < a; b++)\t{\n\t\t\t\t\t\twin = !bad[list.get(a)][list.get(b)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(win)\n\t\t\t\t\tret = Math.max(ret, list.size());\n\t\t\t}\n\t\t}\n\t\tpw.println(ret);\n\t\tpw.close(); \n\t}\n\n\t/* NOTEBOOK CODE */\n\n\tpublic static void loadArray(int[][] grid) throws IOException {\n\t\tfor(int[] a: grid)\n\t\t\tloadArray(a);\n\t}\n\n\tpublic static void loadArray(int[] in) throws IOException {\n\t\tfor(int i = 0; i < in.length; i++)\n\t\t\tin[i] = readInt();\n\t}\n\n\tpublic static void loadArray(long[] in) throws IOException {\n\t\tfor(int i = 0; i < in.length; i++)\n\t\t\tin[i] = readLong();\n\t}\n\n\n\tprivate static long readLong() throws IOException\t{\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate static double readDouble() throws IOException\t{\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tprivate static int readInt() throws IOException\t{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate static String nextToken() throws IOException\t{\n\t\twhile(st == null || !st.hasMoreTokens())\t{\n\t\t\tif(!br.ready())\t{\n\t\t\t\tpw.close();\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\tst = new StringTokenizer(br.readLine().trim());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "def find(a):\n    if parent[a]!=a:\n        parent[a]=find(parent[a])\n    return parent[a]\n\ndef union(a,b):\n    u,v=find(a),find(b)\n    if u==v:\n        return\n    if rank[u]>rank[v]:\n        parent[v]=u\n    else:\n        parent[u]=v\n    if rank[u]==rank[v]:\n        rank[v]+=1\n\nn=int(input())\nk=int(input())\n\nparent=list(map(int,range(n+1)))\nrank=[0]*(n+1)\nans=[0]*(n+1)\ncount=[0]*(n+1)\n\nfor i in range(k):\n        u,v=map(int,input().split())\n        union(u,v)\n\nfor i in range(len(ans)):\n    ans[find(i)]+=1\n\nfor i in range(len(parent)):\n    count[parent[i]]+=1\n\nd={}\n\nm=int(input())\nfor i in range(m):\n    u,v=map(int,input().split())\n    if parent[u]==parent[v]:\n        d[parent[u]]=False\n\nsak=0\nfor i in range(len(count)):\n    if count[i]!=0 and i not in d and i!=0:\n        sak=max(sak,count[i])\nprint(sak)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1e+9 + 7;\nstruct DSU {\n private:\n  vector<int> parent, size;\n  int N;\n\n public:\n  DSU(int n) {\n    N = n;\n    size.resize(N + 1, 1);\n    parent.resize(N + 1);\n    for (int i = 0; i <= N; i++) parent[i] = i;\n  }\n  void makeParent(int a, int b) {\n    a = getParent(a);\n    b = getParent(b);\n    if (a != b) {\n      if (size[a] < size[b]) swap(a, b);\n      parent[b] = a;\n      size[a] += size[b];\n    }\n  }\n  int getParent(int a) {\n    if (parent[a] == a) return a;\n    return parent[a] = getParent(parent[a]);\n  }\n  vector<vector<int>> components() {\n    vector<vector<int>> component(N + 1);\n    vector<vector<int>> ans;\n    for (int i = 1; i <= N; i++) component[getParent(i)].push_back(i);\n    for (int i = 1; i <= N; i++)\n      if (!component[i].empty()) ans.push_back(component[i]);\n    return ans;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  cout << fixed;\n  cout << setprecision(10);\n  int n;\n  cin >> n;\n  DSU d(n);\n  int k;\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    int a, b;\n    cin >> a >> b;\n    d.makeParent(a, b);\n  }\n  int m;\n  cin >> m;\n  set<int> bad;\n  for (int i = 1; i <= m; i++) {\n    int a, b;\n    cin >> a >> b;\n    if (d.getParent(a) == d.getParent(b)) bad.insert(d.getParent(a));\n  }\n  map<int, int> cnt;\n  for (int i = 1; i <= n; i++)\n    if (!bad.count(d.getParent(i))) cnt[d.getParent(i)]++;\n  int ans = 0;\n  for (auto p : cnt) ans = max(ans, p.second);\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n  int gid, v;\n};\nvector<int> fr[2003];\nint root[2003], n;\nbool hate[2003][2003];\nNode node[2003];\nbool cmp(const Node &a, const Node &b) { return a.gid < b.gid; }\nint find(int x) {\n  if (x != root[x]) root[x] = find(root[x]);\n  return root[x];\n}\nbool check(int s, int e) {\n  int i, j;\n  for (i = s; i < e; ++i) {\n    for (j = i + 1; j < e; ++j) {\n      if (hate[node[i].v][node[j].v]) return 0;\n    }\n  }\n  return 1;\n}\nint main(int argc, char *argv[]) {\n  int i, j;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; ++i) root[i] = i;\n  int k, u, v, m;\n  scanf(\"%d\", &k);\n  for (i = 0; i < k; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    root[find(u)] = find(v);\n  }\n  for (i = 1; i <= n; ++i) {\n    node[i].gid = find(i);\n    node[i].v = i;\n  }\n  sort(node + 1, node + n + 1, cmp);\n  for (i = 1; i <= n; ++i) {\n    for (j = 1; j <= n; ++j) hate[i][j] = 0;\n  }\n  scanf(\"%d\", &m);\n  for (i = 0; i < m; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    hate[u][v] = 1;\n    hate[v][u] = 1;\n  }\n  int ma = 0;\n  for (j = 1, i = 2; i <= n; ++i) {\n    if (node[i].gid != node[j].gid) {\n      if (check(j, i)) {\n        if (ma < (i - j)) ma = i - j;\n      }\n      j = i;\n    }\n  }\n  if (check(j, i)) {\n    if (ma < (i - j)) ma = i - j;\n  }\n  printf(\"%d\\n\", ma);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, m;\nstd::vector<int> visited(10000, 0);\nint ans = 0, temp = 0;\nstd::vector<pair<int, int>> g[10000];\nvoid dfs(int v) {\n  visited[v] = 1;\n  temp++;\n  for (auto i : g[v]) {\n    if ((i.second == 1 && visited[i.first] == 2) ||\n        (i.second == 2 && visited[i.first] == 1)) {\n      temp = 0;\n      return;\n    } else if (visited[i.first] == 0) {\n      if (i.second == 2) {\n        visited[i.first] = 2;\n      } else\n        dfs(i.first);\n    }\n  }\n}\nint main() {\n  cin >> n;\n  cin >> k;\n  int u, v;\n  for (int i = 0; i < k; i++) {\n    cin >> u >> v;\n    g[u].push_back({v, 1});\n    g[v].push_back({u, 1});\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> u >> v;\n    g[u].push_back({v, 2});\n    g[v].push_back({u, 2});\n  }\n  for (int i = 1; i <= n; i++) {\n    fill(visited.begin(), visited.end(), 0);\n    temp = 0;\n    dfs(i);\n    ans = max(ans, temp);\n  }\n  std::cout << ans << std::endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int LIM = 2000, GREEN = 1, RED = 2;\nint n, k, m;\nint dsu[LIM], cnt[LIM], used[LIM];\nbool bad[LIM];\nvector<pair<int, int> > g[LIM];\nint dsu_find(int a) { return dsu[a] == a ? a : dsu[a] = dsu_find(dsu[a]); }\nvoid dsu_union(int a, int b) {\n  a = dsu_find(a);\n  b = dsu_find(b);\n  if (a == b) return;\n  if (cnt[a] > cnt[b]) swap(a, b);\n  dsu[a] = b;\n  cnt[b] += cnt[a];\n  bad[b] = bad[b] | bad[a];\n  bad[a] = bad[b];\n}\nvoid read() {\n  cin >> n >> k;\n  for (int i = 0; i < n; i++) {\n    dsu[i] = i;\n    cnt[i] = 1;\n  }\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    g[u].push_back(make_pair(v, GREEN));\n    g[v].push_back(make_pair(u, GREEN));\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    g[u].push_back(make_pair(v, RED));\n    g[v].push_back(make_pair(u, RED));\n  }\n}\nvoid dfs(int u) {\n  used[u] = true;\n  for (int i = 0; i < (int)g[u].size(); i++) {\n    int v = g[u][i].first, color = g[u][i].second;\n    if (color == GREEN) {\n      dsu_union(u, v);\n      if (!used[v]) dfs(v);\n    } else {\n      if (dsu_find(u) == dsu_find(v)) {\n        bad[dsu_find(u)] = true;\n      }\n    }\n  }\n}\nint main() {\n  read();\n  for (int i = 0; i < n; i++) {\n    if (!used[i]) dfs(i);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int p = dsu_find(i);\n    if (!bad[p] && cnt[p] > ans) ans = cnt[p];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int find_parent(long long int parent[], long long int i) {\n  while (parent[i] != i) i = parent[i];\n  return i;\n}\nvoid Union(long long int parent[], long long int i, long long int j) {\n  long long int pii = find_parent(parent, i);\n  long long int pj = find_parent(parent, j);\n  if (pii != pj) parent[pj] = pii, parent[j] = pii;\n}\nvoid test_case() {\n  long long int n;\n  cin >> n;\n  long long int m;\n  cin >> m;\n  long long int parent[n];\n  for (long long int i = 0; i < n; i++) parent[i] = i;\n  while (m--) {\n    long long int x, y;\n    cin >> x >> y;\n    Union(parent, x - 1, y - 1);\n  }\n  unordered_map<long long int, long long int> mp;\n  for (long long int i = 0; i < n; i++) {\n    long long int p = find_parent(parent, i);\n    mp[p]++;\n  }\n  cin >> m;\n  while (m--) {\n    long long int x, y;\n    cin >> x >> y;\n    if (find_parent(parent, x - 1) == find_parent(parent, y - 1)) {\n      mp[find_parent(parent, x - 1)] = -1;\n    }\n  }\n  long long int max = 0;\n  for (auto x : mp)\n    if (x.second > max) max = x.second;\n  cout << max << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t = 1;\n  while (t--) test_case();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class cf177c {\n  public static void main(String[] args) {\n    FastIO in = new FastIO(), out = in;\n    int n = in.nextInt();\n    DisjointSet ds = new DisjointSet(n);\n    int m = in.nextInt();\n    for(int i=0; i<m; i++) {\n      int a = in.nextInt()-1;\n      int b = in.nextInt()-1;\n      ds.union(a, b);\n    }\n    int[] size = new int[n];\n    for(int i=0; i<n; i++)\n      size[ds.find(i)]++;\n    boolean[] bad = new boolean[n];\n    int k = in.nextInt();\n    for(int i=0; i<k; i++) {\n      int a = in.nextInt()-1;\n      int b = in.nextInt()-1;\n      if(ds.find(a) == ds.find(b))\n        bad[ds.find(a)] = true;\n    }\n    int ans = 0;\n    for(int i=0; i<n; i++)\n      if(!bad[i])\n        ans = Math.max(ans,size[i]);\n    out.println(ans);\n    out.close();\n  }\n  static class DisjointSet {\n    int[] p, r;\n    public DisjointSet(int s) {\n      p = new int[s];\n      r = new int[s];\n      for(int i=0; i<s; i++)\n        p[i] = i;\n    }\n    public void union(int x, int y) {\n      int a = find(x);\n      int b = find(y);\n      if(a==b) return;\n      if(r[a] == r[b])\n        r[p[b]=a]++;\n      else \n        p[a]=p[b]=r[a]<r[b]?b:a;\n    }\n    public int find(int x) {\n      return p[x]=p[x]==x?x:find(p[x]);\n    }\n  }\n  static class FastIO extends PrintWriter {\n    BufferedReader br;\n    StringTokenizer st;\n    \n    public FastIO() {\n      this(System.in,System.out);\n    }\n    public FastIO(InputStream in, OutputStream out) {\n      super(new BufferedWriter(new OutputStreamWriter(out)));\n      br = new BufferedReader(new InputStreamReader(in));\n      scanLine();\n    }\n    public void scanLine() {\n      try {\n        st = new StringTokenizer(br.readLine().trim());\n      } catch(Exception e) {\n        throw new RuntimeException(e.getMessage());\n      }\n    }\n    public int numTokens() {\n      if(!st.hasMoreTokens()) {\n        scanLine();\n        return numTokens();\n      }\n      return st.countTokens();\n    }\n    public String next() {\n      if(!st.hasMoreTokens()) {\n        scanLine();\n        return next();\n      }\n      return st.nextToken();\n    }\n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, x, y;\nvector<int> v[2001];\nvector<int> g[2001];\nint size;\nint res;\nbool vis[2001];\nbool valid;\nvoid DFS(int src) {\n  if (vis[src] || !valid) return;\n  ++size;\n  vis[src] = 1;\n  for (int i = 0; valid && i < g[src].size(); ++i)\n    if (vis[g[src][i]]) valid = 0;\n  for (int i = 0; i < v[src].size(); ++i) DFS(v[src][i]);\n}\nint main() {\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  while (k--) {\n    scanf(\"%d%d\", &x, &y);\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  scanf(\"%d\", &k);\n  while (k--) {\n    scanf(\"%d%d\", &x, &y);\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  for (int i = 1; i <= n; ++i) {\n    size = 0;\n    memset(vis, 0, sizeof(vis));\n    valid = 1;\n    DFS(i);\n    if (valid) res = max(res, size);\n  }\n  printf(\"%d\\n\", res);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint l[2010][2010], d[2010][2010];\nint computed[2010];\nint group[2010];\nint n;\nint conflict(int s) {\n  int size = d[s][0];\n  int sizeG = group[0];\n  for (int j = 1; j <= sizeG; j++)\n    for (int i = 1; i <= size; i++)\n      if (d[s][i] == group[j]) {\n        return 1;\n      }\n  return 0;\n}\nint foo(int s) {\n  int size = l[s][0];\n  if (conflict(s)) return -1;\n  computed[s] = 1;\n  group[0]++;\n  group[group[0]] = s;\n  int sum = 1;\n  for (int i = 1; i <= size; i++)\n    if (!(computed[l[s][i]] == 1)) {\n      int ret = foo(l[s][i]);\n      if (ret == -1)\n        return -1;\n      else\n        sum += ret;\n    }\n  return sum;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i <= n; i++)\n    for (int j = 0; j <= n; j++) l[i][j] = d[i][j] = computed[i] = 0;\n  int k;\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    int size = l[a][0];\n    l[a][size + 1] = b;\n    l[a][0]++;\n    int sizeB = l[b][0];\n    l[b][sizeB + 1] = a;\n    l[b][0]++;\n  }\n  int m;\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    int size = d[a][0];\n    d[a][size + 1] = b;\n    d[a][0]++;\n    int sizeB = d[b][0];\n    d[b][sizeB + 1] = a;\n    d[b][0]++;\n  }\n  int out = 0;\n  for (int i = 1; i <= n; i++) {\n    group[0] = 0;\n    if (!computed[i]) {\n      int res = foo(i);\n      out = max(out, res);\n    }\n    int sizeG = group[0];\n    for (int j = 1; j <= sizeG; j++) computed[group[j]] = 2;\n  }\n  printf(\"%d\\n\", out);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2020;\nint p[N], sz[N];\nbool hate[N][N];\nvector<int> v[N];\nset<int> st;\nint get(int x) {\n  if (x == p[x]) return x;\n  return p[x] = get(p[x]);\n}\nvoid join(int x, int y) {\n  x = get(x);\n  y = get(y);\n  if (x == y) return;\n  if (rand() & 1) swap(x, y);\n  p[x] = y;\n  sz[y] += sz[x];\n}\nvoid input_edges(bool b) {\n  int m;\n  scanf(\"%d\", &m);\n  int u, v;\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d %d\", &u, &v);\n    if (b) {\n      join(u, v);\n    } else {\n      hate[u][v] = hate[v][u] = 1;\n    }\n  }\n}\nint main() {\n  for (int i = 1; i < N; i++) p[i] = i, sz[i] = 1;\n  int n;\n  scanf(\"%d\", &n);\n  input_edges(1);\n  input_edges(0);\n  for (int i = 1; i <= n; i++) {\n    v[get(i)].push_back(i);\n    st.insert(get(i));\n  }\n  int mx = 0;\n  for (auto S : st) {\n    bool ok = 1;\n    for (auto ss : v[S]) {\n      for (auto ss2 : v[S])\n        if (hate[ss][ss2]) {\n          ok = 0;\n          break;\n        }\n      if (ok == 0) break;\n    }\n    if (ok) mx = max(mx, sz[S]);\n  }\n  printf(\"%d\\n\", mx);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M, K, C;\nvector<pair<int, int> > G[100005];\nbool vis[100005], group[100005], F;\nvoid dfs(int v) {\n  vis[v] = 1;\n  group[v] = 1;\n  C++;\n  for (int i = 0; i < G[v].size(); i++)\n    if (!vis[G[v][i].first]) {\n      if (G[v][i].second) dfs(G[v][i].first);\n    } else {\n      if (group[G[v][i].first] && !G[v][i].second) {\n        F = 1;\n        C--;\n        return;\n      }\n    }\n}\nint main() {\n  int u, v;\n  scanf(\"%d %d\", &N, &M);\n  for (int i = 0; i < M; i++) {\n    scanf(\"%d %d\", &u, &v);\n    G[u].push_back(make_pair(v, 1));\n    G[v].push_back(make_pair(u, 1));\n  }\n  scanf(\"%d\", &K);\n  for (int i = 0; i < K; i++) {\n    scanf(\"%d %d\", &u, &v);\n    G[u].push_back(make_pair(v, 0));\n    G[v].push_back(make_pair(u, 0));\n  }\n  int ANS = 0;\n  for (int i = 1; i <= N; i++)\n    if (!vis[i]) {\n      C = F = 0;\n      dfs(1);\n      if (!F) ANS = max(ANS, C);\n      memset(group, 0, sizeof group);\n    }\n  printf(\"%d\", ANS);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct UFDS {\n  int n;\n  int p[2010], rank[2010], size[2010];\n  UFDS(int n) : n(n) {\n    for (int i = 1; i <= n; i++) {\n      p[i] = i;\n      rank[i] = 0;\n      size[i] = 1;\n    }\n  }\n  int findSet(int i) {\n    if (p[i] == i) return i;\n    return p[i] = findSet(p[i]);\n  }\n  bool isSameSet(int i, int j) { return findSet(i) == findSet(j); }\n  int sizeOfSet(int i) { return size[findSet(i)]; }\n  void unionSet(int i, int j) {\n    int x = findSet(i);\n    int y = findSet(j);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      p[x] = y;\n      size[y] += size[x];\n    } else {\n      p[y] = x;\n      size[x] += size[y];\n      if (rank[y] == rank[x]) rank[x]++;\n    }\n  }\n  void printSet(int i) {\n    cout << \"set id:\" << findSet(i) << \":\" << endl;\n    for (int j = 0; j <= n; j++) {\n      if (isSameSet(i, j)) cout << j << endl;\n    }\n    cout << \"size:\" << sizeOfSet(i) << endl;\n  }\n};\nint n;\nvector<int> adjList[2010];\nbitset<2010> visited;\nUFDS like(2010);\nint dfs(int c) {\n  if (visited[c]) return 0;\n  visited[c] = 1;\n  int ans = like.sizeOfSet(c);\n  for (int i = 0; i < adjList[c].size(); i++) {\n    if (!visited[adjList[c][i]]) {\n      ans = max(ans, dfs(adjList[c][i]));\n    }\n  }\n  return ans;\n}\nint main() {\n  cin >> n;\n  int k, m;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int u, v;\n    cin >> u >> v;\n    like.unionSet(u, v);\n  }\n  set<int> superNodes;\n  for (int i = 1; i <= n; i++) {\n    superNodes.insert(like.findSet(i));\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    int x = like.findSet(u);\n    int y = like.findSet(v);\n    if (x == y) superNodes.erase(x);\n  }\n  int ans = 0;\n  for (set<int>::iterator si = superNodes.begin(); si != superNodes.end();\n       si++) {\n    ans = max(ans, like.sizeOfSet(*si));\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e5 + 10;\nint n, m, k, cnt;\nvector<int> adj[MAX];\nvector<pair<int, int> > disl;\nint visit[MAX], qua[MAX];\nvoid dfs(int x) {\n  visit[x] = cnt;\n  qua[cnt]++;\n  for (auto i : adj[x]) {\n    if (visit[i]) continue;\n    dfs(i);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> k;\n  for (int i = 0; i < k; i++) {\n    int t1, t2;\n    cin >> t1 >> t2;\n    adj[t1].push_back(t2);\n    adj[t2].push_back(t1);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    int t1, t2;\n    cin >> t1 >> t2;\n    disl.push_back({t1, t2});\n  }\n  for (int i = 1; i <= n; i++) {\n    if (visit[i]) continue;\n    cnt++;\n    dfs(i);\n  }\n  for (auto o : disl) {\n    int x = o.first, y = o.second;\n    if (visit[x] == visit[y]) qua[visit[x]] = 0;\n  }\n  int ans = -1;\n  for (int i = 0; i <= cnt; i++) ans = max(ans, qua[i]);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package javaapplication12;\n\nimport java.util.Scanner;\n\n/**\n *\n * @author Josepe\n */\npublic class JavaApplication12 {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n         Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int max=0;\n        int[] un=new int[n+1];\n        int[] size=new int[n+1];\n        for (int i = 1; i <=n; i++) {\n            un[i]=i;\n            size[i]=1;\n        }\n        int d=in.nextInt();\n        for (int i = 0; i < d; i++) {\n            int l=in.nextInt();\n            int r=in.nextInt();\n            l=find(un,l);\n            r=find(un,r);\n            if(l!=r)\n                if(size[r]>size[l]){\n                    un[l]=r;\n                     int temp=size[l];\n                    size[l]+=size[r];\n                size[r]+=temp;}\n                else{\n                    un[r]=l;\n                    int temp=size[r];\n                     size[r]+=size[l];\n                     size[l]+=temp;\n                }\n            \n        }\n        int e=in.nextInt();\n        for (int i = 0; i < e; i++) {\n                int l=in.nextInt();\n            int r=in.nextInt();\n            l=find(un,l);\n            r=find(un,r);\n            if(l==r){\n                size[l]=0;\n            }\n                \n        }\n        for (int i = 1; i <=n; i++) {\n            if  (size[i]>max&& find(un,i)==i)\n                max=size[i];\n        }\n        System.out.println(max);\n    }\n    public static int find(int[] un,int i){\n        if(un[i]==i) return i;\n        else return find(un,un[i]);\n    }\n}\n"
        }
    ]
}