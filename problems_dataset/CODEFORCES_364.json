{
    "name": "364_D. Ghd",
    "source": "CODEFORCES",
    "description": "John Doe offered his sister Jane Doe find the gcd of some set of numbers a.\n\nGcd is a positive integer g, such that all number from the set are evenly divisible by g and there isn't such g' (g' > g), that all numbers of the set are evenly divisible by g'.\n\nUnfortunately Jane couldn't cope with the task and John offered her to find the ghd of the same subset of numbers.\n\nGhd is a positive integer g, such that at least half of numbers from the set are evenly divisible by g and there isn't such g' (g' > g) that at least half of the numbers from the set are evenly divisible by g'.\n\nJane coped with the task for two hours. Please try it, too.\n\nInput\n\nThe first line contains an integer n (1 \u2264 n \u2264 106) showing how many numbers are in set a. The second line contains space-separated integers a1, a2, ..., an (1 \u2264 ai \u2264 1012). Please note, that given set can contain equal numbers.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the %I64d specifier.\n\nOutput\n\nPrint a single integer g \u2014 the Ghd of set a.\n\nExamples\n\nInput\n\n6\n6 2 3 4 5 6\n\n\nOutput\n\n3\n\n\nInput\n\n5\n5 5 6 10 15\n\n\nOutput\n\n5",
    "difficulty": "D",
    "tags": [
        "brute force",
        "math",
        "probabilities"
    ],
    "rating": 2900,
    "public_test": [
        {
            "input": "6\n6 2 3 4 5 6\n",
            "output": "3\n"
        },
        {
            "input": "5\n5 5 6 10 15\n",
            "output": "5\n"
        }
    ],
    "generated_test": [
        {
            "input": "1\n9\n",
            "output": "9\n"
        },
        {
            "input": "2\n2 7\n",
            "output": "7\n"
        },
        {
            "input": "100\n32 40 7 3 7560 21 7560 7560 10 12 3 7560 7560 7560 7560 5 7560 7560 6 7560 7560 7560 35 7560 18 7560 7560 7560 7560 7560 48 2 7 25 7560 2 2 49 7560 7560 15 16 7560 7560 2 7560 27 4136 7560 7560 7560 3 5 7560 8 7560 42 45 5 7560 5 7560 4 7 3 7560 7 3 7560 7 2 7560 7560 5 3 7560 7560 28 7560 7560 14 7560 5 7560 20 7560 24 7560 2 9 36 7 7560 7560 7560 7560 7560 30 7560 50\n",
            "output": "45\n"
        },
        {
            "input": "6\n6 3 3 4 5 6\n",
            "output": "3\n"
        },
        {
            "input": "5\n5 4 6 10 15\n",
            "output": "5\n"
        },
        {
            "input": "1\n4\n",
            "output": "4\n"
        },
        {
            "input": "5\n4 4 6 10 15\n",
            "output": "2\n"
        },
        {
            "input": "1\n8\n",
            "output": "8\n"
        },
        {
            "input": "2\n2 17\n",
            "output": "17\n"
        },
        {
            "input": "1\n6\n",
            "output": "6\n"
        },
        {
            "input": "1\n11\n",
            "output": "11\n"
        },
        {
            "input": "5\n15 4 6 1 23\n",
            "output": "1\n"
        },
        {
            "input": "1\n12\n",
            "output": "12\n"
        },
        {
            "input": "1\n23\n",
            "output": "23\n"
        },
        {
            "input": "1\n21\n",
            "output": "21\n"
        },
        {
            "input": "2\n1 13\n",
            "output": "13\n"
        },
        {
            "input": "1\n10\n",
            "output": "10\n"
        },
        {
            "input": "1\n19\n",
            "output": "19\n"
        },
        {
            "input": "2\n2 20\n",
            "output": "20\n"
        },
        {
            "input": "1\n18\n",
            "output": "18\n"
        },
        {
            "input": "1\n15\n",
            "output": "15\n"
        },
        {
            "input": "2\n2 9\n",
            "output": "9\n"
        },
        {
            "input": "6\n6 3 3 4 7 6\n",
            "output": "3\n"
        },
        {
            "input": "6\n6 3 3 4 7 4\n",
            "output": "3\n"
        },
        {
            "input": "5\n4 4 6 10 23\n",
            "output": "2\n"
        },
        {
            "input": "1\n5\n",
            "output": "5\n"
        },
        {
            "input": "6\n6 3 3 2 7 6\n",
            "output": "3\n"
        },
        {
            "input": "5\n8 4 6 10 23\n",
            "output": "2\n"
        },
        {
            "input": "6\n6 3 3 2 6 6\n",
            "output": "6\n"
        },
        {
            "input": "5\n8 4 6 1 23\n",
            "output": "2\n"
        },
        {
            "input": "6\n6 3 6 2 6 6\n",
            "output": "6\n"
        },
        {
            "input": "6\n6 3 7 2 6 6\n",
            "output": "6\n"
        },
        {
            "input": "5\n15 4 6 1 37\n",
            "output": "1\n"
        },
        {
            "input": "6\n6 3 7 2 2 6\n",
            "output": "3\n"
        },
        {
            "input": "5\n15 4 4 1 37\n",
            "output": "1\n"
        },
        {
            "input": "1\n2\n",
            "output": "2\n"
        },
        {
            "input": "6\n6 1 7 2 2 6\n",
            "output": "2\n"
        },
        {
            "input": "5\n23 4 4 1 37\n",
            "output": "1\n"
        },
        {
            "input": "6\n6 1 2 2 2 6\n",
            "output": "2\n"
        },
        {
            "input": "5\n38 4 4 1 37\n",
            "output": "2\n"
        },
        {
            "input": "6\n6 1 2 4 2 6\n",
            "output": "2\n"
        },
        {
            "input": "5\n62 4 4 1 37\n",
            "output": "2\n"
        },
        {
            "input": "5\n62 4 4 2 37\n",
            "output": "2\n"
        },
        {
            "input": "5\n62 2 4 1 37\n",
            "output": "2\n"
        },
        {
            "input": "5\n28 2 4 1 37\n",
            "output": "2\n"
        },
        {
            "input": "5\n28 3 4 1 37\n",
            "output": "1\n"
        },
        {
            "input": "5\n28 3 4 1 8\n",
            "output": "4\n"
        },
        {
            "input": "5\n28 2 4 1 8\n",
            "output": "4\n"
        },
        {
            "input": "5\n28 2 2 1 8\n",
            "output": "2\n"
        },
        {
            "input": "5\n28 2 2 1 6\n",
            "output": "2\n"
        },
        {
            "input": "6\n6 2 3 4 5 7\n",
            "output": "2\n"
        },
        {
            "input": "5\n5 5 6 8 15\n",
            "output": "5\n"
        },
        {
            "input": "1\n17\n",
            "output": "17\n"
        },
        {
            "input": "2\n2 6\n",
            "output": "6\n"
        },
        {
            "input": "5\n5 8 6 10 15\n",
            "output": "5\n"
        },
        {
            "input": "6\n6 3 5 4 7 6\n",
            "output": "3\n"
        },
        {
            "input": "5\n4 4 6 2 15\n",
            "output": "2\n"
        },
        {
            "input": "6\n6 3 6 4 7 4\n",
            "output": "3\n"
        },
        {
            "input": "5\n4 4 9 10 23\n",
            "output": "2\n"
        },
        {
            "input": "6\n6 3 3 2 7 11\n",
            "output": "3\n"
        },
        {
            "input": "5\n8 4 12 10 23\n",
            "output": "4\n"
        },
        {
            "input": "6\n6 3 3 2 6 3\n",
            "output": "3\n"
        },
        {
            "input": "5\n8 4 6 1 28\n",
            "output": "4\n"
        },
        {
            "input": "6\n6 3 6 2 2 6\n",
            "output": "6\n"
        },
        {
            "input": "5\n15 5 6 1 23\n",
            "output": "1\n"
        },
        {
            "input": "6\n6 4 7 2 2 6\n",
            "output": "2\n"
        },
        {
            "input": "6\n6 2 7 2 2 6\n",
            "output": "2\n"
        },
        {
            "input": "5\n23 4 4 2 37\n",
            "output": "2\n"
        },
        {
            "input": "6\n6 1 2 1 2 6\n",
            "output": "2\n"
        },
        {
            "input": "5\n38 3 4 1 37\n",
            "output": "1\n"
        },
        {
            "input": "6\n6 1 2 4 1 6\n",
            "output": "2\n"
        },
        {
            "input": "5\n19 4 4 1 37\n",
            "output": "1\n"
        },
        {
            "input": "5\n62 4 4 3 37\n",
            "output": "2\n"
        },
        {
            "input": "5\n28 2 1 1 37\n",
            "output": "1\n"
        },
        {
            "input": "5\n28 3 4 2 37\n",
            "output": "2\n"
        },
        {
            "input": "5\n28 1 4 1 8\n",
            "output": "4\n"
        },
        {
            "input": "5\n28 2 4 1 5\n",
            "output": "2\n"
        },
        {
            "input": "5\n28 1 2 1 6\n",
            "output": "2\n"
        },
        {
            "input": "1\n13\n",
            "output": "13\n"
        },
        {
            "input": "6\n6 2 1 4 5 7\n",
            "output": "2\n"
        },
        {
            "input": "5\n5 3 6 8 15\n",
            "output": "3\n"
        },
        {
            "input": "2\n2 2\n",
            "output": "2\n"
        },
        {
            "input": "5\n5 2 6 10 15\n",
            "output": "5\n"
        },
        {
            "input": "5\n4 4 6 2 12\n",
            "output": "4\n"
        },
        {
            "input": "6\n6 3 6 4 2 4\n",
            "output": "3\n"
        },
        {
            "input": "5\n5 4 9 10 23\n",
            "output": "1\n"
        },
        {
            "input": "6\n6 3 3 2 5 11\n",
            "output": "3\n"
        },
        {
            "input": "5\n8 4 12 19 23\n",
            "output": "4\n"
        },
        {
            "input": "6\n6 3 3 1 6 3\n",
            "output": "3\n"
        },
        {
            "input": "5\n8 4 6 1 48\n",
            "output": "4\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e6 + 10;\nlong long a[MAXN], d[MAXN], cnt[MAXN], ans, n, siz;\nvoid cut(long long x) {\n  siz = 0;\n  for (long long i = 1; i * i <= x; i++) {\n    if (x % i == 0) {\n      d[++siz] = i;\n      if (x != i * i) d[++siz] = x / i;\n    }\n  }\n  memset(cnt, 0, sizeof(cnt));\n}\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long random(long long x, long long y) {\n  return (long long)rand() * rand() % (y - x + 1) + x;\n}\nsigned main() {\n  srand(time(NULL));\n  scanf(\"%I64d\", &n);\n  for (long long i = 1; i <= n; i++) scanf(\"%I64d\", &a[i]);\n  for (long long T = 1; T <= 10; T++) {\n    long long x = a[random(1, n)];\n    cut(x);\n    sort(d + 1, d + siz + 1);\n    for (long long i = 1; i <= n; i++) {\n      long long pos = lower_bound(d + 1, d + siz + 1, gcd(x, a[i])) - d;\n      cnt[pos]++;\n    }\n    for (long long i = 1; i <= siz; i++)\n      for (long long j = i + 1; j <= siz; j++)\n        if (d[j] % d[i] == 0) cnt[i] += cnt[j];\n    for (long long i = siz; i >= 1; i--) {\n      if (cnt[i] * 2 >= n) {\n        ans = max(ans, d[i]);\n        break;\n      }\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1000005], b[1000005];\nint n, tot, cnt[1000005];\nlong long gcd(long long x, long long y) { return y == 0 ? x : gcd(y, x % y); }\nint main() {\n  long long ans = 1;\n  srand(time(NULL));\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%I64d\", &a[i]);\n  }\n  for (int step = 0; step < 10; step++) {\n    long long val = a[(rand() << 15 | rand()) % n];\n    tot = 0;\n    for (long long i = 1; i * i <= val; i++) {\n      if (val % i == 0) {\n        b[tot++] = i;\n        if (i != val / i) {\n          b[tot++] = val / i;\n        }\n      }\n    }\n    sort(b, b + tot);\n    fill(cnt, cnt + tot, 0);\n    for (int i = 0; i < n; i++) {\n      cnt[lower_bound(b, b + tot, gcd(a[i], val)) - b]++;\n    }\n    for (int i = tot - 1; i >= 0; i--) {\n      if (b[i] <= ans) break;\n      int sum = 0;\n      for (int j = i; j < tot; j++) {\n        if (b[j] % b[i] == 0) sum = sum + cnt[j];\n      }\n      if (sum * 2 >= n) {\n        ans = b[i];\n      }\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  for (; ch < '0' || ch > '9'; ch = getchar())\n    if (ch == '-') f = -1;\n  for (; ch >= '0' && ch <= '9'; ch = getchar())\n    x = (x << 1) + (x << 3) + ch - 48;\n  return x * f;\n}\ninline long long gcd(long long x, long long y) {\n  return (!y) ? x : gcd(y, x % y);\n}\nlong long n, a[1000005], g[1000005], p[10000005], cnt[10000005], ans = 1;\nbool vis[1000005];\ninline void solve(long long x) {\n  p[0] = 0;\n  for (long long i = 1; i * i <= a[x]; i++)\n    if (a[x] % i == 0) {\n      p[++p[0]] = i;\n      if (i * i != a[x]) p[++p[0]] = a[x] / i;\n    }\n  for (long long i = 1; i <= p[0]; i++) cnt[i] = 0;\n  sort(p + 1, p + p[0] + 1);\n  for (long long i = 1; i <= n; i++)\n    ++cnt[lower_bound(p + 1, p + p[0] + 1, gcd(a[i], a[x])) - p];\n  for (long long i = 1; i <= p[0] - 1; i++)\n    for (long long j = i + 1; j <= p[0]; j++)\n      if (p[j] % p[i] == 0) cnt[i] += cnt[j];\n  for (long long i = 1; i <= p[0]; i++)\n    if (cnt[i] * 2 >= n) ans = max(ans, p[i]);\n}\nsigned main() {\n  srand(time(NULL));\n  n = read();\n  for (long long i = 1; i <= n; i++) a[i] = read();\n  for (long long i = 1; i <= min(n, 10ll); i++) {\n    long long m = ((rand() << 15) + rand()) % n + 1;\n    while (vis[m]) m = ((rand() << 15) + rand()) % n + 1;\n    vis[m] = 1;\n    solve(m);\n  }\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000005;\nconst int T = 11;\nlong long a[N];\nlong long gcd(long long a, long long b) {\n  if (b > a) swap(a, b);\n  return b ? gcd(b, a % b) : a;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  mt19937 mt_rand(time(NULL));\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  long long ans = 1;\n  for (int i = 0; i < T; i++) {\n    int idx = mt_rand() % n, sum = 0;\n    vector<long long> div0, div1;\n    for (int i = 1; i <= sqrt(a[idx]); i++) {\n      if (a[idx] % i == 0) {\n        div0.push_back(i);\n        if (a[idx] / i != i) div1.push_back(a[idx] / i);\n      }\n    }\n    reverse(div1.begin(), div1.end());\n    div0.insert(div0.end(), div1.begin(), div1.end());\n    vector<long long> cnt(div0.size());\n    for (int i = 0; i < n; i++) {\n      int id = lower_bound(div0.begin(), div0.end(), gcd(a[i], a[idx])) -\n               div0.begin();\n      cnt[id]++;\n    }\n    for (int i = div0.size() - 1; i >= 0; i--) {\n      long long sum = cnt[i];\n      for (int j = i + 1; j < div0.size(); j++) {\n        if (div0[j] % div0[i] == 0) sum += cnt[j];\n      }\n      if (sum >= (n + 1) / 2) {\n        ans = max(ans, div0[i]);\n        break;\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int maxFactors = (1 << 14), timeLimit = 3505;\n\n\tprivate void solve() throws IOException {\n\t\tlong start = System.currentTimeMillis();\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tHashMap<Long, Integer> fastFactorsCounters = new HashMap<>();\n\t\twhile (!isOver(start)) {\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = base / i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\t++factorsCounters[fastFactorsCounters.get(current)];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate boolean isOver(long start) {\n\t\tlong current = System.currentTimeMillis();\n\t\treturn (current - start) >= timeLimit;\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e6 + 5;\nlong long a[N], s[N], n, ans, b[N], top;\ninline long long gcd(const long long &x, const long long &y) {\n  return x ? gcd(y % x, x) : y;\n}\nsigned main() {\n  scanf(\"%lld\", &n);\n  for (long long i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  for (long long I = 1; I <= 10; I++) {\n    long long x = a[rand() % n * rand() % n + 1];\n    top = 0;\n    for (long long i = 1; i * i <= x; i++)\n      if (x % i == 0) {\n        s[++top] = i;\n        if (i * i != x) s[++top] = x / i;\n      }\n    for (long long i = 1; i <= top; i++) b[i] = 0;\n    sort(s + 1, s + top + 1);\n    static long long now;\n    for (long long i = 1; i <= n; i++) {\n      now = lower_bound(s + 1, s + top + 1, gcd(a[i], x)) - s;\n      b[now]++;\n    }\n    for (long long i = 1; i <= top; i++)\n      for (long long j = i + 1; j <= top; j++)\n        if (s[j] % s[i] == 0) b[i] += b[j];\n    for (long long i = 1; i <= top; i++)\n      if (b[i] << 1 >= n) ans = max(ans, s[i]);\n  }\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Random;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n    static final int BUBEN = 100;\n    static final double BUBEN3 = 1e-9;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        double[] pr = new double[BUBEN + 1];\n        pr[0] = 1.0;\n        for (int i = 0; i < BUBEN; ++i) {\n            for (int j = BUBEN; j >= 1; --j) {\n                pr[j] += pr[j - 1] * 0.5;\n                pr[j - 1] *= 0.5;\n            }\n        }\n        int BUBEN2 = 0;\n        double sum = 0;\n        while (sum + pr[BUBEN2] < BUBEN3) {\n            sum += pr[BUBEN2];\n            ++BUBEN2;\n        }\n        int n = in.nextInt();\n        long[] a = new long[n];\n        for (int i = 0; i < n; ++i) a[i] = in.nextLong();\n        boolean[] ispr = new boolean[1000000];\n        Arrays.fill(ispr, true);\n        ispr[0] = ispr[1] = false;\n        int cntpr = 0;\n        for (int i = 2; i < ispr.length; ++i)\n            if (ispr[i]) {\n                ++cntpr;\n                for (int j = i * 2; j < ispr.length; j += i)\n                    ispr[j] = false;\n            }\n        long[] primes = new long[cntpr];\n        cntpr = 0;\n        for (int i = 2; i < ispr.length; ++i)\n            if (ispr[i])\n                primes[cntpr++] = i;\n        long[] divisors = new long[50 * BUBEN];\n        int pos = 0;\n        Random random = new Random(547315431513L + System.currentTimeMillis());\n        for (int i = 0; i < BUBEN; ++i) {\n            long x = a[random.nextInt(n)];\n            for (long p : primes) {\n                if (x % p == 0) {\n                    long pw = 0;\n                    while (x % p == 0) {\n                        ++pw;\n                        x /= p;\n                        divisors[pos++] = p * 100 + pw;\n                    }\n                }\n            }\n            if (x > 1) {\n                divisors[pos++] = x * 100 + 1;\n            }\n        }\n        Arrays.sort(divisors, 0, pos);\n        divisors = Arrays.copyOf(divisors, pos);\n        long[] nicedivisors = new long[divisors.length];\n        int nicecnt = 0;\n        for (int i = 0; i < pos;) {\n            int j = i;\n            while (j < pos && divisors[j] == divisors[i]) ++j;\n            int cnt = j - i;\n            long cur = divisors[i];\n            if (cnt >= BUBEN2) {\n                if (nicecnt > 0 && nicedivisors[nicecnt - 1] / 100 == cur / 100)\n                    nicedivisors[nicecnt - 1] = cur;\n                else\n                    nicedivisors[nicecnt++] = cur;\n            }\n            i = j;\n        }\n        nicedivisors = Arrays.copyOf(nicedivisors, nicecnt);\n        long[] arr = new long[n];\n        pos = 0;\n        for (long x : a) {\n            long y = 1;\n            for (long pair : nicedivisors) {\n                long p = pair / 100;\n                long maxpw = pair % 100;\n                long pw = 0;\n                while (x % p == 0 && pw < maxpw) {\n                    x /= p;\n                    y *= p;\n                    ++pw;\n                }\n            }\n            arr[pos++] = y;\n        }\n        if (pos != n) throw new RuntimeException();\n        for (int i = 0; i < nicedivisors.length; ++i)\n            nicedivisors[i] /= 100;\n        Arrays.sort(arr);\n        long[] narr = new long[n];\n        long[] ncnt = new long[n];\n        pos = 0;\n        for (int i = 0; i < n;) {\n            int j = i;\n            while (j < n && arr[j] == arr[i]) ++j;\n            narr[pos] = arr[i];\n            ncnt[pos] = j - i;\n            i = j;\n            ++pos;\n        }\n        narr = Arrays.copyOf(narr, pos);\n        ncnt = Arrays.copyOf(ncnt, pos);\n        int half = (n + 1) / 2;\n        long res = rec(narr, ncnt, nicedivisors, 0, 1, half);\n        out.println(res);\n    }\n\n    private long rec(long[] narr, long[] ncnt, long[] nicedivisors, int at, long prod, int half) {\n        long got = 0;\n        for (int i = 0; i < narr.length; ++i)\n            if (narr[i] % prod == 0) got += ncnt[i];\n        if (got < half)\n            return 0;\n        long max = ((long) 1.1e12) / prod;\n        long res  = prod;\n        for (int next = at; next < nicedivisors.length && nicedivisors[next] <= max; ++next) {\n            res = Math.max(res, rec(narr, ncnt, nicedivisors, next, prod * nicedivisors[next], half));\n        }\n        return res;\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    }\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (!b) return a;\n  return gcd(b, a % b);\n}\nlong long sol, V, pula[1000100], x, dej[14], b[1000100], c[1000100], a[1000100];\nint n, t, K, fr[1000100], r, pick;\nint main() {\n  srand(time(0));\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", &a[i]);\n    b[i] = a[i];\n  }\n  r = n;\n  sol = 1;\n  for (int kkt = 1; kkt <= 6; ++kkt) {\n    t = 0;\n    K = 0;\n    if (!r) break;\n    int p = rand() % r + 1;\n    x = b[p];\n    V = b[p];\n    int oldr = r;\n    r = 0;\n    for (int i = 1; i <= oldr; ++i)\n      if (b[i] != x) c[++r] = b[i];\n    for (int i = 1; i <= r; ++i) b[i] = c[i];\n    int lim = 1 << 20;\n    for (int i = 1; i <= lim; ++i) {\n      if (1LL * i * i > x) break;\n      if (x % i == 0) {\n        pula[++t] = x / i;\n        pula[++t] = i;\n      }\n    }\n    if ((long long)sqrt(x) * (long long)sqrt(x) == x) --t;\n    for (int i = 1; i <= t; ++i) fr[i] = 0;\n    sort(pula + 1, pula + t + 1);\n    for (int i = 1; i <= n; ++i) {\n      x = gcd(V, a[i]);\n      int st = 1;\n      int dr = t;\n      while (st <= dr) {\n        int mij = (st + dr) >> 1;\n        if (pula[mij] == x) {\n          ++fr[mij];\n          break;\n        } else if (pula[mij] > x)\n          dr = mij - 1;\n        else\n          st = mij + 1;\n      }\n    }\n    for (int i = 1; i <= t; ++i)\n      for (int j = i + 1; j <= t; ++j) {\n        if (pula[j] % pula[i] == 0) fr[i] += fr[j];\n      }\n    for (int i = t; i >= 1; --i)\n      if (fr[i] * 2 >= n) {\n        if (pula[i] > sol) sol = pula[i];\n        break;\n      }\n  }\n  cout << sol;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a[1000020], b[1000020];\nlong long ans;\nlong long san[1000020];\nint cnt, c[1000020], d[1000020];\nset<long long> s;\nlong long gcd(long long a, long long b) {\n  while (a && b && (a >= b ? a %= b : b %= a))\n    ;\n  return a + b;\n}\nint haxi(long long x) { return lower_bound(san + 1, san + cnt + 1, x) - san; }\nvoid calc(int x) {\n  cnt = 0;\n  for (int i = 1; i <= n; ++i) {\n    b[i] = gcd(a[i], a[x]);\n  }\n  for (int i = 1; 1LL * i * i <= a[x]; ++i) {\n    if (a[x] % i) continue;\n    san[++cnt] = i;\n    if (1LL * i * i != a[x]) san[++cnt] = a[x] / i;\n  }\n  sort(san + 1, san + cnt + 1);\n  cnt = unique(san + 1, san + cnt + 1) - san - 1;\n  for (int i = 1; i <= cnt; ++i) c[i] = d[i] = 0;\n  for (int i = 1; i <= n; ++i) c[haxi(b[i])]++;\n  for (int i = 1; i <= cnt; ++i) {\n    if (san[i] <= ans) continue;\n    for (int j = i; j <= cnt; ++j) {\n      if (san[j] % san[i] == 0) d[i] += c[j];\n    }\n  }\n  for (int i = 1; i <= cnt; ++i) {\n    if (d[i] * 2 >= n) ans = max(ans, san[i]);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%I64d\", &a[i]);\n  ans = 1;\n  srand(233);\n  for (int x = 1, cnt = 0; x <= 12 && cnt <= 1000020; ++x, ++cnt) {\n    int v = 1LL * rand() * rand() % n + 1;\n    if (s.count(a[v])) {\n      --x;\n      continue;\n    }\n    s.insert(a[v]);\n    calc(v);\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O500\")\n#pragma comment(linker, \"/STACK:1677777216\")\n#pragma warning(default : 4)\nusing namespace std;\nconst double eps = 1e-12;\nconst int oo = 0x3F3F3F3F;\nconst long long ooLL = 0x3F3F3F3F3F3F3F3FLL;\nconst int MOD = 1000000007;\ntemplate <typename T>\nT sqr(T x) {\n  return x * x;\n}\ntemplate <typename T>\nvoid debpr(const T &);\ntemplate <typename T1, typename T2>\nvoid debpr(const pair<T1, T2> &);\ntemplate <typename T1, typename T2>\nvoid debpr(const vector<T1, T2> &);\ntemplate <typename T>\nvoid debpr(const set<T> &);\ntemplate <typename T1, typename T2>\nvoid debpr(const map<T1, T2> &);\ntemplate <typename T>\nvoid prcont(T be, T en, const string &st, const string &fi, const string &mi) {\n  debpr(st);\n  bool ft = 0;\n  while (be != en) {\n    if (ft) debpr(mi);\n    ft = 1;\n    debpr(*be);\n    ++be;\n  }\n  debpr(fi);\n}\ntemplate <typename T>\nvoid debpr(const T &a) {}\ntemplate <typename T1, typename T2>\nvoid debpr(const pair<T1, T2> &p) {\n  debpr(\"(\");\n  debpr(p.first);\n  debpr(\", \");\n  debpr(p.second);\n  debpr(\")\");\n}\ntemplate <typename T1, typename T2>\nvoid debpr(const vector<T1, T2> &a) {\n  prcont(a.begin(), a.end(), \"[\", \"]\", \", \");\n}\ntemplate <typename T>\nvoid debpr(const set<T> &a) {\n  prcont(a.begin(), a.end(), \"{\", \"}\", \", \");\n}\ntemplate <typename T1, typename T2>\nvoid debpr(const map<T1, T2> &a) {\n  prcont(a.begin(), a.end(), \"{\", \"}\", \", \");\n}\nvoid deb(){};\ntemplate <typename T1>\nvoid deb(const T1 &t1) {\n  debpr(t1);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2>\nvoid deb(const T1 &t1, const T2 &t2) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2, typename T3>\nvoid deb(const T1 &t1, const T2 &t2, const T3 &t3) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr(' ');\n  debpr(t3);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid deb(const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr(' ');\n  debpr(t3);\n  debpr(' ');\n  debpr(t4);\n  debpr('\\n');\n}\nconst double PI = acos(-1.);\nlong long Round(double x) { return x < 0 ? x - .5 : x + .5; }\ntemplate <typename T>\nvoid ass(bool v, const T &x, string m = \"Fail\") {\n  if (!v) {\n    deb(m);\n    deb(x);\n    throw;\n  }\n}\nint main() {\n  void run();\n  run();\n  return 0;\n}\nlong long a[1 << 20];\nint n;\nlong long gcd(long long a, long long b) {\n  long long t;\n  while (a) b %= a, t = a, a = b, b = t;\n  return b;\n}\nlong long mrand() {\n  long long rs = 0;\n  for (int i = (0), _b(60); i < _b; ++i)\n    if (rand() % 2) rs += 1LL << i;\n  return rs;\n}\nvoid run() {\n  scanf(\"%d\", &n);\n  for (int i = (0), _b(n); i < _b; ++i) scanf(\"%lld\", &a[i]);\n  long long rs = 1;\n  srand(4);\n  for (int it = (0), _b(12); it < _b; ++it) {\n    long long t = a[mrand() % n];\n    unordered_map<long long, int> m;\n    m.reserve(1 << 15);\n    for (int i = (0), _b(n); i < _b; ++i) ++m[gcd(a[i], t)];\n    vector<pair<long long, long long> > v((m).begin(), (m).end());\n    for (int i = (0), _b(v.size()); i < _b; ++i) {\n      int z = 0;\n      for (int j = (0), _b(v.size()); j < _b; ++j)\n        if (v[j].first % v[i].first == 0) z += v[j].second;\n      if (z >= (n + 1) / 2) rs = max(rs, v[i].first);\n    }\n  }\n  cout << rs << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.HashSet;\nimport java.util.OptionalLong;\nimport java.io.OutputStreamWriter;\nimport java.io.OutputStream;\nimport java.util.stream.LongStream;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.stream.Stream;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DGhd solver = new DGhd();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DGhd {\n        OrderedDivisorIterator visitor = new OrderedDivisorIterator(true);\n        DivisionPrefixSum ps = new DivisionPrefixSum(0, Long::sum);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            long[] a = in.rl(n);\n            if (n <= 2) {\n                long max = Arrays.stream(a).max().orElse(-1);\n                out.println(max);\n                return;\n            }\n\n            long ans = 0;\n            long end = System.currentTimeMillis() + 3500;\n            while (System.currentTimeMillis() < end) {\n                long x = RandomWrapper.INSTANCE.range(a);\n                long cand = search((n + 1) / 2, a, x);\n                ans = Math.max(ans, cand);\n            }\n\n            out.println(ans);\n        }\n\n        public long search(int atLeast, long[] a, long g) {\n            LongFactorization factorization = new LongFactorization(g);\n            visitor.init(factorization);\n            ps.init(factorization);\n            for (long x : a) {\n                ps.add(g / GCDs.gcd(g, x), 1);\n            }\n            while (visitor.hasNext()) {\n                long x = visitor.next();\n                if (ps.prefixSum(x) >= atLeast) {\n                    return g / x;\n                }\n            }\n            return 1;\n        }\n\n    }\n\n    static interface LongFunction {\n        long apply(long x);\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\\n');\n        }\n\n        public FastOutput flush() {\n            try {\n//            boolean success = false;\n//            if (stringBuilderValueField != null) {\n//                try {\n//                    char[] value = (char[]) stringBuilderValueField.get(cache);\n//                    os.write(value, 0, cache.length());\n//                    success = true;\n//                } catch (Exception e) {\n//                }\n//            }\n//            if (!success) {\n                os.append(cache);\n//            }\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class RandomWrapper {\n        private Random random;\n        public static final RandomWrapper INSTANCE = new RandomWrapper();\n\n        public RandomWrapper() {\n            this(new Random());\n        }\n\n        public RandomWrapper(Random random) {\n            this.random = random;\n        }\n\n        public RandomWrapper(long seed) {\n            this(new Random(seed));\n        }\n\n        public int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n        public long nextLong(long n) {\n            return Math.round(random.nextDouble() * (n - 1));\n        }\n\n        public long range(long... x) {\n            return x[nextInt(0, x.length - 1)];\n        }\n\n    }\n\n    static class LongHashSet {\n        private int now;\n        private int[] slot;\n        private int[] version;\n        private int[] next;\n        private long[] keys;\n        private int alloc;\n        private boolean[] removed;\n        private int mask;\n        private int size;\n        private boolean rehash;\n        private Hasher hasher = new Hasher();\n\n        public LongHashSet(int cap, boolean rehash) {\n            now = 1;\n            this.mask = (1 << (32 - Integer.numberOfLeadingZeros(cap - 1))) - 1;\n            this.rehash = rehash;\n            slot = new int[mask + 1];\n            version = new int[slot.length + 1];\n            next = new int[cap + 1];\n            keys = new long[cap + 1];\n            removed = new boolean[cap + 1];\n        }\n\n        private void access(int i) {\n            if (version[i] != now) {\n                version[i] = now;\n                slot[i] = 0;\n            }\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            keys = Arrays.copyOf(keys, newSize);\n            removed = Arrays.copyOf(removed, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n            removed[alloc] = false;\n            size++;\n        }\n\n        private int hash(long x) {\n            return hasher.hash(x);\n        }\n\n        public void add(long x) {\n            int h = hash(x);\n            int s = h & mask;\n            access(s);\n            if (slot[s] == 0) {\n                alloc();\n                slot[s] = alloc;\n                keys[alloc] = x;\n                return;\n            } else {\n                int index = findIndexOrLastEntry(s, x);\n                if (keys[index] != x) {\n                    alloc();\n                    next[index] = alloc;\n                    keys[alloc] = x;\n                }\n            }\n            if (rehash && size >= slot.length) {\n                rehash();\n            }\n        }\n\n        private void rehash() {\n            int[] newSlots = new int[Math.max(16, slot.length * 2)];\n            int[] newVersions = new int[newSlots.length];\n            int newMask = newSlots.length - 1;\n            for (int i = 0; i < slot.length; i++) {\n                access(i);\n                if (slot[i] == 0) {\n                    continue;\n                }\n                int head = slot[i];\n                while (head != 0) {\n                    int n = next[head];\n                    int s = hash(keys[head]) & newMask;\n                    next[head] = newSlots[s];\n                    newSlots[s] = head;\n                    head = n;\n                }\n            }\n            this.slot = newSlots;\n            this.version = newVersions;\n            now = 0;\n            this.mask = newMask;\n        }\n\n        public boolean contain(long x) {\n            int h = hash(x);\n            int s = h & mask;\n            access(s);\n            if (slot[s] == 0) {\n                return false;\n            }\n            return keys[findIndexOrLastEntry(s, x)] == x;\n        }\n\n        private int findIndexOrLastEntry(int s, long x) {\n            int iter = slot[s];\n            while (keys[iter] != x) {\n                if (next[iter] != 0) {\n                    iter = next[iter];\n                } else {\n                    return iter;\n                }\n            }\n            return iter;\n        }\n\n        public void clear() {\n            alloc = 0;\n            size = 0;\n            now++;\n        }\n\n        public LongIterator iterator() {\n            return new LongIterator() {\n                int index = 1;\n\n\n                public boolean hasNext() {\n                    while (index <= alloc && removed[index]) {\n                        index++;\n                    }\n                    return index <= alloc;\n                }\n\n\n                public long next() {\n                    if (!hasNext()) {\n                        throw new IllegalStateException();\n                    }\n                    return keys[index++];\n                }\n            };\n        }\n\n        public String toString() {\n            LongIterator iterator = iterator();\n            StringBuilder builder = new StringBuilder(\"{\");\n            while (iterator.hasNext()) {\n                builder.append(iterator.next()).append(',');\n            }\n            if (builder.charAt(builder.length() - 1) == ',') {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append('}');\n            return builder.toString();\n        }\n\n    }\n\n    static class LongModular implements ILongModular {\n        final long m;\n\n        public long getMod() {\n            return m;\n        }\n\n        public LongModular(long m) {\n            this.m = m;\n        }\n\n        public long mul(long a, long b) {\n            if (b == 0) {\n                return 0;\n            }\n            long ans = mul(a, b >> 1) << 1;\n            if (ans >= m) {\n                ans -= m;\n            }\n            ans += a * (b & 1);\n            if (ans >= m) {\n                ans -= m;\n            }\n            return ans;\n        }\n\n    }\n\n    static class Bits {\n        private Bits() {\n        }\n\n        public static long tailMask(int n) {\n            if (n == 0) {\n                return 0;\n            }\n            return -1L << (64 - n);\n        }\n\n    }\n\n    static interface ILongModular {\n        long getMod();\n\n        default long plus(long a, long b) {\n            return DigitUtils.modplus(a, b, getMod());\n        }\n\n        long mul(long a, long b);\n\n        static ILongModular getInstance(long mod) {\n            if (mod <= Integer.MAX_VALUE) {\n                return new SmallLongModular(mod);\n            }\n            if (mod <= (1L << 50)) {\n                return new LongModularDanger(mod);\n            }\n            if (mod == (1L << 61) - 1) {\n                return LongModular2305843009213693951.getInstance();\n            }\n            return new LongModular(mod);//new BigLongModular(mod);//new LongModular(mod);\n        }\n\n    }\n\n    static class LongMillerRabin {\n        static ILongModular mod;\n        static LongPower power;\n\n        public static boolean mr(long n, int s) {\n            if (n <= 1) {\n                return false;\n            }\n            if (n == 2) {\n                return true;\n            }\n            if (n % 2 == 0) {\n                return false;\n            }\n            long m = n - 1;\n            while (m % 2 == 0) {\n                m /= 2;\n            }\n            mod = ILongModular.getInstance(n);\n            power = new LongPower(mod);\n            for (int i = 0; i < s; i++) {\n                long x = RandomWrapper.INSTANCE.nextLong(n - 2) + 2;\n                if (!mr0(x, n, m)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private static boolean mr0(long x, long n, long m) {\n            return test(power.pow(x, m), m, n);\n        }\n\n        private static boolean test(long y, long exp, long n) {\n            long y2 = mod.mul(y, y);\n            if (!(exp == n - 1 || test(y2, exp * 2, n))) {\n                return false;\n            }\n            if (exp != n - 1 && y2 != 1) {\n                return true;\n            }\n            if (y != 1 && y != n - 1) {\n                return false;\n            }\n            return true;\n        }\n\n    }\n\n    static interface LongIterator {\n        boolean hasNext();\n\n        long next();\n\n    }\n\n    static class OrderedDivisorIterator implements LongIterator {\n        LongFactorization factorization;\n        LongPriorityQueue pq = new LongPriorityQueue((int) 2e5, LongComparator.REVERSE_ORDER);\n        LongHashSet set = new LongHashSet((int) 2e5, false);\n        boolean inc;\n\n        public OrderedDivisorIterator(boolean inc) {\n            this.inc = inc;\n        }\n\n        public void init(LongFactorization factorization) {\n            this.factorization = factorization;\n            set.clear();\n            pq.clear();\n            pq.add(factorization.g);\n        }\n\n        public boolean hasNext() {\n            return !pq.isEmpty();\n        }\n\n        public long next() {\n            long head = pq.pop();\n            for (long p : factorization.primes) {\n                long cand = head / p;\n                if (cand * p != head || set.contain(cand)) {\n                    continue;\n                }\n                set.add(cand);\n                pq.add(cand);\n            }\n            return inc ? factorization.g / head : head;\n        }\n\n    }\n\n    static class LongModular2305843009213693951 implements ILongModular {\n        private static long mod = 2305843009213693951L;\n        private static final LongModular2305843009213693951 INSTANCE = new LongModular2305843009213693951();\n        private static long mask = (1L << 32) - 1;\n\n        private LongModular2305843009213693951() {\n        }\n\n        public static final LongModular2305843009213693951 getInstance() {\n            return INSTANCE;\n        }\n\n        public long getMod() {\n            return mod;\n        }\n\n        public long mul(long a, long b) {\n            long l1 = a & mask;\n            long h1 = (a >> 32) & mask;\n            long l2 = b & mask;\n            long h2 = (b >> 32) & mask;\n            long l = l1 * l2;\n            long m = l1 * h2 + l2 * h1;\n            long h = h1 * h2;\n            long ret = (l & mod) + (l >>> 61) + (h << 3) + (m >>> 29) + ((m << 35) >>> 3) + 1;\n            ret = (ret & mod) + (ret >>> 61);\n            ret = (ret & mod) + (ret >>> 61);\n            return ret - 1;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static long round(double x) {\n            if (x >= 0) {\n                return (long) (x + 0.5);\n            } else {\n                return (long) (x - 0.5);\n            }\n        }\n\n        public static long modplus(long a, long b, long mod) {\n            long ans = a + b;\n            if (ans >= mod) {\n                ans -= mod;\n            }\n            return ans;\n        }\n\n        public static long mod(long x, long mod) {\n            if (x < -mod || x >= mod) {\n                x %= mod;\n            }\n            if (x < 0) {\n                x += mod;\n            }\n            return x;\n        }\n\n        public static long modmul(long a, long b, long mod) {\n            long k = DigitUtils.round((double) a / mod * b);\n            return DigitUtils.mod(a * b - k * mod, mod);\n        }\n\n    }\n\n    static interface LongBinaryFunction {\n        long apply(long a, long b);\n\n    }\n\n    static interface LongComparator {\n        public static final LongComparator REVERSE_ORDER = (a, b) -> Long.compare(b, a);\n\n        public int compare(long a, long b);\n\n    }\n\n    static class SmallLongModular implements ILongModular {\n        long mod;\n\n        public SmallLongModular(long mod) {\n            this.mod = mod;\n        }\n\n        public long getMod() {\n            return mod;\n        }\n\n        public long mul(long a, long b) {\n            return a * b % mod;\n        }\n\n    }\n\n    static class LongFactorization {\n        public long g;\n        public long[] primes;\n        long numberOfFactors = -1;\n\n        public LongFactorization(long g) {\n            init(g);\n        }\n\n        public void init(long g) {\n            assert 0 < g && g <= 1e18;\n            this.g = g;\n            primes = LongPollardRho.findAllFactors(g).stream().mapToLong(Long::valueOf).toArray();\n            numberOfFactors = -1;\n        }\n\n        public String toString() {\n            return g + \"=>\" + Arrays.toString(primes);\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void swap(long[] data, int i, int j) {\n            long tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n\n    }\n\n    static class Hasher {\n        private long time = System.nanoTime() + System.currentTimeMillis() * 31L;\n\n        public int shuffle(long z) {\n            z += time;\n            z = (z ^ (z >>> 33)) * 0x62a9d9ed799705f5L;\n            return (int) (((z ^ (z >>> 28)) * 0xcb24d0a5c88c35b3L) >>> 32);\n        }\n\n        public int hash(long x) {\n            return shuffle(x);\n        }\n\n    }\n\n    static class GCDs {\n        private GCDs() {\n        }\n\n        public static long gcd(long a, long b) {\n            return a >= b ? gcd0(a, b) : gcd0(b, a);\n        }\n\n        private static long gcd0(long a, long b) {\n            return b == 0 ? a : gcd0(b, a % b);\n        }\n\n    }\n\n    static interface LongEntryIterator {\n        boolean hasNext();\n\n        void next();\n\n        long getEntryKey();\n\n        long getEntryValue();\n\n    }\n\n    static class LongPriorityQueue implements Cloneable {\n        private long[] data;\n        private LongComparator comparator;\n        private int size;\n\n        public LongPriorityQueue(int n, LongComparator comparator) {\n            this.data = new long[n + 1];\n            this.comparator = comparator;\n        }\n\n        public LongPriorityQueue(int n, LongComparator comparator, LongFunction generator) {\n            this.data = new long[n + 1];\n            this.comparator = comparator;\n\n            for (int i = 1; i <= n; i++) {\n                data[i] = generator.apply(i - 1);\n            }\n            size = n;\n            for (int i = n; i >= 1; i--) {\n                shiftDown(i);\n            }\n        }\n\n        private int left(int i) {\n            return i << 1;\n        }\n\n        private int right(int i) {\n            return (i << 1) | 1;\n        }\n\n        private int parent(int i) {\n            return i >> 1;\n        }\n\n        public void add(long x) {\n            data[++size] = x;\n            shiftUp(size);\n        }\n\n        private void shiftUp(int index) {\n            while (index != 1) {\n                int pid = parent(index);\n                if (comparator.compare(data[pid], data[index]) <= 0) {\n                    break;\n                }\n                SequenceUtils.swap(data, index, pid);\n                index = pid;\n            }\n        }\n\n        private void shiftDown(int index) {\n            while (true) {\n                int lid = left(index);\n                int rid = right(index);\n                if (lid > size) {\n                    break;\n                }\n                int challenger = lid;\n                if (rid <= size && comparator.compare(data[rid], data[lid]) < 0) {\n                    challenger = rid;\n                }\n                if (comparator.compare(data[challenger], data[index]) >= 0) {\n                    break;\n                }\n                SequenceUtils.swap(data, index, challenger);\n                index = challenger;\n            }\n        }\n\n        public long pop() {\n            long ans = data[1];\n            SequenceUtils.swap(data, 1, size);\n            size--;\n            shiftDown(1);\n            return ans;\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public boolean isEmpty() {\n            return size == 0;\n        }\n\n        public LongPriorityQueue clone() {\n            try {\n                LongPriorityQueue c = (LongPriorityQueue) super.clone();\n                c.data = data.clone();\n                return c;\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            LongPriorityQueue queue = clone();\n            while (!queue.isEmpty()) {\n                builder.append(queue.pop()).append(',');\n            }\n            if (builder.length() > 0) {\n                builder.setLength(builder.length() - 1);\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class LongPollardRho {\n        static long[] smallPrimes = new long[]{2, 3, 5, 7, 11, 13, 17, 19};\n\n        public static long findFactor(long n) {\n            if (n == 1) {\n                return 1;\n            }\n            if (LongMillerRabin.mr(n, 10)) {\n                return n;\n            }\n            while (true) {\n                long f = rho(n);\n                if (f != n) {\n                    return f;\n                }\n            }\n        }\n\n        public static Set<Long> findAllFactors(long n) {\n            if (n == 0) {\n                throw new IllegalArgumentException();\n            }\n\n            Set<Long> set = new HashSet<>();\n            for (long p : smallPrimes) {\n                if (n % p != 0) {\n                    continue;\n                }\n                set.add(p);\n                while (n % p == 0) {\n                    n /= p;\n                }\n            }\n            findAllFactors(set, n);\n            return set;\n        }\n\n        private static void findAllFactors(Set<Long> set, long n) {\n            if (n == 1) {\n                return;\n            }\n            long f = findFactor(n);\n            if (f == n) {\n                set.add(f);\n                return;\n            }\n            long otherPart = n / f;\n//        long g = GCDs.gcd(f, otherPart);\n//        while (g != 1) {\n//            otherPart /= g;\n//            g = GCDs.gcd(f, otherPart);\n//        }\n            findAllFactors(set, f);\n            findAllFactors(set, otherPart);\n        }\n\n        private static long rho(long n) {\n            if (n % 2 == 0) {\n                return 2;\n            }\n            if (n % 3 == 0) {\n                return 3;\n            }\n            ILongModular modular = ILongModular.getInstance(n);\n            long x = 0, y = x, t, q = 1, c = RandomWrapper.INSTANCE.nextLong(n - 1);\n            for (int k = 2; ; k <<= 1, y = x, q = 1) {\n                for (int i = 1; i <= k; ++i) {\n                    x = modular.plus(modular.mul(x, x), c);\n                    q = modular.mul(q, Math.abs(x - y));\n                    if ((i & 127) == 0) {\n                        t = GCDs.gcd(q, n);\n                        if (t > 1) {\n                            return t;\n                        }\n                    }\n                }\n                if ((t = GCDs.gcd(q, n)) > 1) {\n                    return t;\n                }\n            }\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(long[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readLong();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public long[] rl(int n) {\n            long[] ans = new long[n];\n            populate(ans);\n            return ans;\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class DivisionPrefixSum {\n        LongFactorization factorization;\n        LongHashMap values;\n        LongHashMap ps;\n        LongBinaryFunction merger;\n        long identity;\n        long[] primes;\n        boolean dirty = false;\n\n        public DivisionPrefixSum(long identity, LongBinaryFunction merger) {\n            values = new LongHashMap((int) 2e5, false);\n            ps = new LongHashMap((int) 2e6, false);\n            this.merger = merger;\n            this.identity = identity;\n        }\n\n        public void init(LongFactorization factorization) {\n            this.factorization = factorization;\n            this.primes = factorization.primes;\n            ps.clear();\n            values.clear();\n            dirty = false;\n        }\n\n        public void add(long x, long mod) {\n            assert factorization.g % x == 0;\n            values.modify(x, mod);\n            dirty = true;\n        }\n\n        private void build() {\n            if (dirty) {\n                ps.clear();\n                dirty = false;\n            }\n        }\n\n        public long prefixSum(long x) {\n            build();\n            return get0(mask(0, x));\n        }\n\n        private long mask(long head, long body) {\n            return (head << 60) | body;\n        }\n\n        private long get0(long x) {\n            long ans = ps.getOrDefault(x, Long.MIN_VALUE);\n            if (ans == Long.MIN_VALUE) {\n                int head = (int) (x >>> 60);\n                long body = x & ~Bits.tailMask(4);\n                ans = identity;\n                if (head >= primes.length) {\n                    ans = values.getOrDefault(body, identity);\n                } else {\n                    if (body % primes[head] == 0) {\n                        ans = merger.apply(ans, get0(mask(head, body / primes[head])));\n                    }\n                    ans = merger.apply(ans, get0(mask(head + 1, body)));\n                }\n                ps.put(x, ans);\n            }\n            return ans;\n        }\n\n    }\n\n    static class LongHashMap {\n        private int now;\n        private int[] slot;\n        private int[] version;\n        private int[] next;\n        private long[] keys;\n        private long[] values;\n        private int alloc;\n        private boolean[] removed;\n        private int mask;\n        private int size;\n        private boolean rehash;\n        private Hasher hasher = new Hasher();\n\n        public LongHashMap(int cap, boolean rehash) {\n            now = 1;\n            this.mask = (1 << (32 - Integer.numberOfLeadingZeros(cap - 1))) - 1;\n            slot = new int[mask + 1];\n            version = new int[slot.length];\n            next = new int[cap + 1];\n            keys = new long[cap + 1];\n            values = new long[cap + 1];\n            removed = new boolean[cap + 1];\n            this.rehash = rehash;\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            keys = Arrays.copyOf(keys, newSize);\n            values = Arrays.copyOf(values, newSize);\n            removed = Arrays.copyOf(removed, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n            removed[alloc] = false;\n            size++;\n        }\n\n        private void rehash() {\n            int[] newSlots = new int[Math.max(16, slot.length * 2)];\n            int[] newVersions = new int[newSlots.length];\n            int newMask = newSlots.length - 1;\n            for (int i = 0; i < slot.length; i++) {\n                access(i);\n                if (slot[i] == 0) {\n                    continue;\n                }\n                int head = slot[i];\n                while (head != 0) {\n                    int n = next[head];\n                    int s = hash(keys[head]) & newMask;\n                    next[head] = newSlots[s];\n                    newSlots[s] = head;\n                    head = n;\n                }\n            }\n            this.slot = newSlots;\n            this.version = newVersions;\n            now = 0;\n            this.mask = newMask;\n        }\n\n        private int hash(long x) {\n            return hasher.hash(x);\n        }\n\n        public void put(long x, long y) {\n            put(x, y, true);\n        }\n\n        public void modify(long x, long dy) {\n            int h = hash(x);\n            int s = h & mask;\n            access(s);\n            if (slot[s] == 0) {\n                alloc();\n                slot[s] = alloc;\n                keys[alloc] = x;\n                values[alloc] = dy;\n            } else {\n                int index = findIndexOrLastEntry(s, x);\n                if (keys[index] != x) {\n                    alloc();\n                    next[index] = alloc;\n                    keys[alloc] = x;\n                    values[alloc] = dy;\n                } else {\n                    values[index] += dy;\n                }\n            }\n            if (rehash && size >= slot.length) {\n                rehash();\n            }\n        }\n\n        public void put(long x, long y, boolean cover) {\n            int h = hash(x);\n            int s = h & mask;\n            access(s);\n            if (slot[s] == 0) {\n                alloc();\n                slot[s] = alloc;\n                keys[alloc] = x;\n                values[alloc] = y;\n            } else {\n                int index = findIndexOrLastEntry(s, x);\n                if (keys[index] != x) {\n                    alloc();\n                    next[index] = alloc;\n                    keys[alloc] = x;\n                    values[alloc] = y;\n                } else if (cover) {\n                    values[index] = y;\n                }\n            }\n            if (rehash && size >= slot.length) {\n                rehash();\n            }\n        }\n\n        public long getOrDefault(long x, long def) {\n            int h = hash(x);\n            int s = h & mask;\n            access(s);\n            if (slot[s] == 0) {\n                return def;\n            }\n            int index = findIndexOrLastEntry(s, x);\n            return keys[index] == x ? values[index] : def;\n        }\n\n        private int findIndexOrLastEntry(int s, long x) {\n            int iter = slot[s];\n            while (keys[iter] != x) {\n                if (next[iter] != 0) {\n                    iter = next[iter];\n                } else {\n                    return iter;\n                }\n            }\n            return iter;\n        }\n\n        public void clear() {\n            alloc = 0;\n            size = 0;\n            now++;\n        }\n\n        private void access(int i) {\n            if (version[i] != now) {\n                version[i] = now;\n                slot[i] = 0;\n            }\n        }\n\n        public LongEntryIterator iterator() {\n            return new LongEntryIterator() {\n                int index = 1;\n                int readIndex = -1;\n\n\n                public boolean hasNext() {\n                    while (index <= alloc && removed[index]) {\n                        index++;\n                    }\n                    return index <= alloc;\n                }\n\n\n                public long getEntryKey() {\n                    return keys[readIndex];\n                }\n\n\n                public long getEntryValue() {\n                    return values[readIndex];\n                }\n\n\n                public void next() {\n                    if (!hasNext()) {\n                        throw new IllegalStateException();\n                    }\n                    readIndex = index;\n                    index++;\n                }\n            };\n        }\n\n        public String toString() {\n            LongEntryIterator iterator = iterator();\n            StringBuilder builder = new StringBuilder(\"{\");\n            while (iterator.hasNext()) {\n                iterator.next();\n                builder.append(iterator.getEntryKey()).append(\"->\").append(iterator.getEntryValue()).append(',');\n            }\n            if (builder.charAt(builder.length() - 1) == ',') {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append('}');\n            return builder.toString();\n        }\n\n    }\n\n    static class LongPower {\n        final ILongModular modular;\n\n        public LongPower(ILongModular modular) {\n            this.modular = modular;\n        }\n\n        public long pow(long x, long n) {\n            if (n == 0) {\n                return 1;\n            }\n            long r = pow(x, n >> 1);\n            r = modular.mul(r, r);\n            if ((n & 1) == 1) {\n                r = modular.mul(r, x);\n            }\n            return r;\n        }\n\n    }\n\n    static class LongModularDanger implements ILongModular {\n        final long m;\n\n        public long getMod() {\n            return m;\n        }\n\n        public LongModularDanger(long m) {\n            this.m = m;\n        }\n\n        public long mul(long a, long b) {\n            return DigitUtils.modmul(a, b, m);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nint n;\nlong long a[N];\nint c[N], tot = 0;\nlong long p[N];\nint sum[N], id[N];\nlong long work(long long x) {\n  tot = 0;\n  int all = 1;\n  for (long long i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      p[++tot] = i;\n      c[tot] = 0;\n      while (x % i == 0) x /= i, c[tot]++;\n      all = all * (c[tot] + 1);\n    }\n  }\n  if (x != 1) p[++tot] = x, c[tot] = 1, all *= 2;\n  for (int i = 0; i < all; i++) sum[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    long long no = a[i];\n    int pos = 0;\n    for (int j = tot; j >= 1; j--) {\n      int cnt = 0;\n      while (no % p[j] == 0) cnt++, no /= p[j];\n      cnt = min(cnt, c[j]);\n      pos = pos * (c[j] + 1) + cnt;\n    }\n    sum[pos]++;\n  }\n  for (int i = 1; i <= tot; i++) {\n    int le = 1;\n    for (int j = 1; j < i; j++) le *= (c[j] + 1);\n    for (int j = all - 1; j >= 0; j--) {\n      int d = j / le;\n      if (d % (c[i] + 1) == c[i]) continue;\n      sum[j] += sum[j + le];\n    }\n  }\n  long long mx = 0;\n  for (int i = 0; i < all; i++) {\n    if (sum[i] < (n + 1) / 2) continue;\n    int no = i;\n    long long pro = 1;\n    for (int j = 1; j <= tot; j++) {\n      for (int k = 1; k <= no % (c[j] + 1); k++) pro = pro * p[j];\n      no /= (c[j] + 1);\n    }\n    mx = max(mx, pro);\n  }\n  return mx;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld\", &a[i]);\n    id[i] = i;\n  }\n  random_shuffle(id + 1, id + n + 1);\n  random_shuffle(id + 1, id + n + 1);\n  random_shuffle(id + 1, id + n + 1);\n  long long mx = 0;\n  for (int amo = 1; amo <= min(n, 10); amo++) {\n    int p = id[amo];\n    mx = max(mx, work(a[p]));\n  }\n  printf(\"%lld\\n\", mx);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 7;\nconst int inf = 0x3f3f3f3f;\nconst double PI = acos(-1.0);\nint T, n;\nlong long a[maxn], ans;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long factor[maxn], tot, cnt[maxn];\nvoid solve() {\n  long long x = a[(1LL * rand() * 1314 + rand()) % n + 1];\n  tot = 0;\n  for (long long i = 1; i * i <= x; i++) {\n    if (x % i == 0) {\n      factor[++tot] = i;\n      if (i * i != x) factor[++tot] = x / i;\n    }\n  }\n  sort(factor + 1, factor + tot + 1);\n  for (int i = 1; i <= tot; i++) cnt[i] = 0;\n  for (int i = 1; i <= n; i++)\n    cnt[lower_bound(factor + 1, factor + tot + 1, gcd(x, a[i])) - factor]++;\n  for (int i = 1; i <= tot; i++)\n    for (int j = i + 1; j <= tot; j++)\n      if (factor[j] % factor[i] == 0) cnt[i] += cnt[j];\n  for (int i = 1; i <= tot; i++)\n    if (cnt[i] * 2 >= n) ans = max(ans, factor[i]);\n}\nint main() {\n  srand(time(NULL));\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  for (int i = 1; i <= 10; i++) solve();\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int buben = 7, maxFactors = (1 << 14);\n\n\tprivate void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tfor (int it = 0; it < buben; it++) {\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = base / i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\t++factorsCounters[Arrays.binarySearch(factorsArr, 0,\n\t\t\t\t\t\tfactorsCount, current)];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int buben = 7, maxFactors = (1 << 14);\n\n\tprivate void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tHashMap<Long, Integer> fastFactorsCounters = new HashMap<>();\n\t\tfor (int it = 0; it < buben; it++) {\n\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = base / i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\t++factorsCounters[fastFactorsCounters.get(current)];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long SIZE = 1e6 + 5;\nlong long n;\nlong long a[SIZE];\nnamespace ae86 {\nconst long long bufl = 1 << 15;\nchar buf[bufl], *s = buf, *t = buf;\ninline long long fetch() {\n  if (s == t) {\n    t = (s = buf) + fread(buf, 1, bufl, stdin);\n    if (s == t) return EOF;\n  }\n  return *s++;\n}\ninline long long read() {\n  long long a = 0, b = 1, c = fetch();\n  while (!isdigit(c)) b ^= c == '-', c = fetch();\n  while (isdigit(c)) a = a * 10 + c - 48, c = fetch();\n  return b ? a : -a;\n}\n}  // namespace ae86\nusing ae86::read;\ninline long long gcd(long long a, long long b) {\n  return (!b) ? a : gcd(b, a % b);\n}\nsigned main() {\n  n = read();\n  long long ans = 1;\n  for (long long i = 1; i <= n; ++i) a[i] = read();\n  if (n == 999999 && a[1] == 1000000000000 && a[2] == 1000000000000 &&\n      a[3] == 1000000000000 && a[4] == 1000000000000) {\n    puts(\"999999999999\");\n    return 0;\n  }\n  for (register long long r = 1; r <= 10; ++r) {\n    long long rnd = (rand() * SIZE + rand()) % n + 1;\n    std::map<long long, long long> vis;\n    for (long long i = 1; i <= n; ++i) {\n      long long g = gcd(a[rnd], a[i]);\n      if (!vis.count(g))\n        vis[g] = 1;\n      else\n        ++vis[g];\n    }\n    auto it = vis.end();\n    do {\n      --it;\n      if ((*it).first <= ans) continue;\n      long long cnt = 0;\n      for (auto i = it; i != vis.end() && (cnt << 1) < n; ++i) {\n        if (!((*i).first % (*it).first)) cnt += (*i).second;\n      }\n      if ((cnt << 1) >= n) ans = (*it).first;\n    } while (it != vis.begin());\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nnamespace CE_WA_TLE = std;\ntemplate <class T>\nT readll(void) {\n  T x = 0, w = 1;\n  char c = getchar();\n  for (; c < '0' || c > '9'; (c - '-') || (w = -w), c = 1, c = getchar())\n    ;\n  for (; !(c < '0' || c > '9');\n       (x = (x << 1) + (x << 3) + (c ^ 48)), c = 1, c = getchar())\n    ;\n  return x * w;\n}\nlong long top;\nnamespace random_number {\nunsigned long long seed1, seed2;\nvoid srandnum(unsigned long long c, unsigned long long b) {\n  seed1 = c + b;\n  seed2 = b * c % 100000000007;\n}\nunsigned long long randnum() {\n  seed1 ^= seed2 << 13;\n  seed2 ^= seed1 >> 10;\n  seed1 ^= seed2 << 5;\n  seed2 ^= seed1 << 13;\n  seed2 ^= seed1 << 5;\n  seed1 = ~seed1;\n  seed2 = ~seed2;\n  seed1 ^= seed2 ^= seed1 ^= seed2;\n  return seed1;\n}\n}  // namespace random_number\nusing namespace random_number;\nlong long gcd(long long a, long long b) {\n  if (b)\n    while (b ^= a ^= b ^= a %= b)\n      ;\n  return a;\n}\nlong long a[1111111], b[1111111], c[1111111];\nnamespace cwt {\nlong long n, ans = 0;\ninline void works(long long u) {\n  long long top = 1;\n  for (long long i = 1; i <= n; i++) {\n    b[i] = gcd(a[u], a[i]);\n    c[i] = 0;\n  }\n  CE_WA_TLE::sort(b + 1, b + n + 1);\n  for (long long i = 1; i <= n; i++) {\n    if (b[i] - b[top]) b[++top] = b[i];\n    c[top]++;\n  }\n  long long max = 1;\n  for (long long i = 1; i <= top; i++) {\n    long long sum = 0;\n    for (long long j = i; j <= top; j++) {\n      if (!(b[j] % b[i])) sum += c[j];\n    }\n    if (sum >= ((n + 1) >> 1)) max = b[i];\n  }\n  if (ans < max) ans = max;\n}\ninline void work(void) {\n  n = readll<long long>(), ans = 1;\n  srandnum(time(0) + n * n / 2 + 13 * n + 273, time(0) + (n << 4) + n - 233);\n  srandnum(randnum() * 7 - 2, randnum() * 5 + 21);\n  for (long long i = 1; i <= n; i++) {\n    a[i] = readll<long long>();\n  }\n  srandnum(randnum() * 7 + a[1] + a[(n + 1) / 2],\n           randnum() * 5 + a[n] + a[(n + 1) / 2]);\n  for (long long cs = 0; cs <= 11; cs++)\n    works((randnum() + 23 + randnum()) % n + 1);\n  printf(\"%I64d\\n\", ans);\n}\n}  // namespace cwt\nsigned main() {\n  cwt::work();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DGhd solver = new DGhd();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DGhd {\n        int n;\n        long[] a;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long start = System.nanoTime();\n            long end = (long) (start + 3.8 * 1e9);\n            n = in.nextInt();\n            a = in.readLongArray(n);\n\n            Counter<Long> all = new Counter<>();\n            for (long x : a) {\n                all.incr(x);\n            }\n\n            long answer = 1;\n            HashSet<Long> seen = new HashSet<>();\n            long mid = System.nanoTime();\n            for (int iteration = 0; iteration < 200 && (iteration < 5 || mid + (System.nanoTime() - mid) * (1.0 + iteration) / iteration < end); iteration++) {\n                if (seen.size() == all.distinct())\n                    break;\n                long x;\n                do {\n                    x = a[(int) (Math.random() * n)];\n                } while (seen.contains(x));\n                seen.add(x);\n\n                Counter<Long> gcds = new Counter<>();\n                for (Map.Entry<Long, Integer> e : all.count.entrySet()) {\n                    gcds.add(NumberTheory.gcd(x, e.getKey()), e.getValue());\n                }\n\n                long[] g = new long[gcds.distinct()];\n                int index = 0;\n                for (long i : gcds.count.keySet()) {\n                    g[index++] = i;\n                }\n                Util.safeSort(g);\n//            Util.reverse(g);\n\n//            System.out.println(\"x = \" + x);\n//            System.out.println(\"gcds.count = \" + gcds.count);\n                for (int i = 0; i < g.length; i++) {\n                    int count = 0;\n\n                    for (int j = i; j < g.length; j++) {\n                        if (g[j] % g[i] == 0)\n                            count += gcds.get(g[j]);\n                    }\n\n                    if (count * 2 >= n)\n                        answer = Math.max(answer, g[i]);\n                }\n//            System.out.println(\"gcds.count = \" + gcds.count);\n//            System.out.println();\n            }\n\n            out.println(answer);\n        }\n\n    }\n\n    static class InputReader {\n        public final BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public long[] readLongArray(int n) {\n            long[] x = new long[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextLong();\n            }\n            return x;\n        }\n\n    }\n\n    static class Counter<T> {\n        public final HashMap<T, Integer> count = new HashMap<>();\n\n        public Counter() {\n        }\n\n        public Counter(T[] elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public Counter(Iterable<T> elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public void incr(T key) {\n            count.merge(key, 1, Integer::sum);\n        }\n\n        public void add(T key, int add) {\n            count.compute(key, (k, v) -> v == null ? add : (v + add == 0 ? null : v + add));\n        }\n\n        public int get(T key) {\n            return count.getOrDefault(key, 0);\n        }\n\n        public int distinct() {\n            return count.size();\n        }\n\n    }\n\n    static class Util {\n        public static void safeSort(long[] x) {\n            shuffle(x);\n            Arrays.sort(x);\n        }\n\n        public static void shuffle(long[] x) {\n            Random r = new Random();\n\n            for (int i = 0; i <= x.length - 2; i++) {\n                int j = i + r.nextInt(x.length - i);\n                swap(x, i, j);\n            }\n        }\n\n        public static void swap(long[] x, int i, int j) {\n            long t = x[i];\n            x[i] = x[j];\n            x[j] = t;\n        }\n\n        private Util() {\n        }\n\n    }\n\n    static class NumberTheory {\n        public static long gcd(long a, long b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            long c;\n            while (a != 0) {\n                c = a;\n                a = b % a;\n                b = c;\n            }\n            return b;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class R213qD {\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        \n        int n = in.nextInt();\n        long a[] = new long[n];\n        for (int i = 0; i < n; i++)\n            a[i] = in.nextLong();\n        \n        long ans = 1;\n        int half = (n + 1) / 2;\n        \n        HashSet<Long> done = new HashSet<Long>();\n        \n        for (int i = 0; i < 6; i++) {\n            int r = new Random().nextInt(n);\n            if(done.contains(a[r]))\n                continue;\n            done.add(a[r]);\n            TreeMap<Long , Integer> value = new TreeMap<>();\n            for (long j = 1; j * j <= a[r]; j++) {\n                if (a[r] % j == 0) {\n                    value.put(j, 0);\n                    value.put(a[r] / j, 0);\n                }\n            }\n            long div[] = new long[value.size()];\n            int ptr = 0;\n            for (long d : value.keySet()) {\n                value.put(d, ptr);\n                div[ptr++] = d;\n            }\n            int cnt[] = new int[ptr];\n            for (int j = 0; j < n; j++) {\n                long g = gcd(a[j], a[r]);\n                cnt[value.get(g)]++;\n            }\n            for (int x = 0; x < ptr; x++) {\n                for (int y = x + 1; y < ptr; y++) {\n                    if(div[y] % div[x] == 0)\n                        cnt[x] += cnt[y];\n                }\n                if(cnt[x] >= half)\n                    ans = Math.max(ans, div[x]);\n            }   \n        }\n        \n        w.println(ans);\n        w.close();\n    }\n\n    public static long gcd(long a, long b) {\n        while (b != 0) {\n            long t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n    \n    static class InputReader {\n\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public String readString() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing llint = long long;\nconst int MAXN = 1 << 20;\nint n;\nllint arr[MAXN];\nvector<llint> divs;\nint cnt[MAXN];\nllint gcd(llint a, llint b) {\n  llint tmp;\n  while (b) {\n    tmp = b;\n    b = a % b;\n    a = tmp;\n  }\n  return a;\n}\nllint calc(llint x) {\n  int i, j;\n  llint d;\n  divs.clear();\n  for (d = 1; d * d <= x; ++d)\n    if (x % d == 0) {\n      cnt[divs.size()] = 0;\n      divs.push_back(d);\n    }\n  for (i = divs.size() - 1 - (divs.back() * divs.back() == x); i >= 0; --i) {\n    cnt[divs.size()] = 0;\n    divs.push_back(x / divs[i]);\n  }\n  for (i = 0; i < n; ++i)\n    ++cnt[distance(divs.begin(),\n                   lower_bound(divs.begin(), divs.end(), gcd(arr[i], x)))];\n  for (i = divs.size() - 1; i >= 0; --i) {\n    int num = 0;\n    for (j = i; num * 2 < n && j < divs.size(); ++j)\n      if (divs[j] % divs[i] == 0) num += cnt[j];\n    if (num * 2 >= n) return divs[i];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  srand(234509876);\n  int i;\n  llint sol = 0;\n  cin >> n;\n  for (i = 0; i < n; ++i) cin >> arr[i];\n  random_shuffle(arr, arr + n);\n  for (i = 0; i < 11; ++i) sol = max(sol, calc(arr[i % n]));\n  cout << sol << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long power(long long a, long long b) {\n  long long result = 1;\n  while (b > 0) {\n    if (b % 2 == 1) {\n      result *= a;\n    }\n    a *= a;\n    b /= 2;\n  }\n  return result;\n}\nlong long gcd(long long x, long long y) {\n  long long r;\n  while (y != 0 && (r = x % y) != 0) {\n    x = y;\n    y = r;\n  }\n  return y == 0 ? x : y;\n}\nlong long countSetBits(long long x) {\n  long long Count = 0;\n  while (x > 0) {\n    if (x & 1) Count++;\n    x = x >> 1;\n  }\n  return Count;\n}\nbool isPerfectSquare(long long n) {\n  long long sr = sqrt(n);\n  if (sr * sr == n)\n    return true;\n  else\n    return false;\n}\nlong long mod(long long x, long long M) { return ((x % M + M) % M); }\nlong long add(long long a, long long b, long long M) {\n  return mod(mod(a, M) + mod(b, M), M);\n}\nlong long mul(long long a, long long b, long long M) {\n  return mod(mod(a, M) * mod(b, M), M);\n}\nlong long powerM(long long a, long long b, long long M) {\n  long long res = 1ll;\n  while (b) {\n    if (b % 2ll == 1ll) {\n      res = mul(a, res, M);\n    }\n    a = mul(a, a, M);\n    b /= 2ll;\n  }\n  return res;\n}\nlong long mod_inv(long long a, long long m) {\n  long long g = m, r = a, x = 0, y = 1;\n  while (r != 0) {\n    long long q = g / r;\n    g %= r;\n    swap(g, r);\n    x -= q * y;\n    swap(x, y);\n  }\n  return mod(x, m);\n}\nlong long nCr(long long n, long long k) {\n  if (n < k) return 0;\n  if (k == 0) return 1;\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res *= (n - i);\n    res /= (i + 1);\n  }\n  return res;\n}\nlong long modInverse(long long n, long long M) { return powerM(n, M - 2, M); }\nlong long nCrM(long long n, long long r, long long M) {\n  if (n < r) return 0;\n  if (r == 0) return 1;\n  vector<long long> fact(n + 1);\n  fact[0] = 1;\n  for (long long i = 1; i <= n; i++) {\n    fact[i] = mul(fact[i - 1], i, M);\n  }\n  return mul(mul(fact[n], modInverse(fact[r], M), M),\n             modInverse(fact[n - r], M), M);\n}\nmt19937 rng(\n    (unsigned int)chrono::steady_clock::now().time_since_epoch().count());\nvector<long long> gcg(1000007);\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> v(n);\n  long long ans = 1;\n  for (auto& w : v) cin >> w;\n  for (long long i = 0; i < 11; i++) {\n    long long op = rng() % n;\n    long long cc = v[op];\n    vector<long long> facto;\n    for (long long j = 1; j <= sqrt(cc); j++) {\n      if (cc % j == 0) {\n        if (j * j != cc) {\n          facto.push_back(cc / j);\n        }\n        facto.push_back(j);\n      }\n    }\n    sort(facto.begin(), facto.end());\n    for (long long j = 0; j < n; j++) {\n      gcg[lower_bound(facto.begin(), facto.end(), gcd(cc, v[j])) -\n          facto.begin()]++;\n    }\n    long long np = facto.size();\n    for (long long k = 0; k < np; k++) {\n      for (long long j = k + 1; j < np; j++) {\n        if (facto[j] % facto[k] == 0) {\n          gcg[k] += gcg[j];\n        }\n      }\n      if (2 * gcg[k] >= n && facto[k] > ans) {\n        ans = facto[k];\n      }\n    }\n    gcg.assign(1000007, 0ll);\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cout << fixed << setprecision(20);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint K = 10;\nint n, nd, occ[1123456];\nlong long a[1123456], d[1123456];\nint myrand(void) { return ((long long)rand() * rand()) % n; }\nvoid div(long long numb) {\n  nd = 0;\n  for (long long i = 1; i * i <= numb; i++)\n    if (numb % i == 0) {\n      d[nd++] = i;\n      if (numb / i != i) d[nd++] = numb / i;\n    }\n}\nlong long euclid(long long a, long long b) {\n  if (b == 0) return a;\n  return euclid(b, a % b);\n}\nint main(void) {\n  int i, r;\n  long long ans = 0;\n  scanf(\"%d\", &n);\n  srand(time(NULL));\n  for (i = 0; i < n; i++) scanf(\"%I64d\", &a[i]);\n  while (K--) {\n    r = myrand();\n    div(a[r]);\n    sort(d, d + nd);\n    for (i = 0; i < nd; i++) occ[i] = 0;\n    for (i = 0; i < n; i++) {\n      int pos = lower_bound(d, d + nd, euclid(a[r], a[i])) - d;\n      occ[pos]++;\n    }\n    for (i = 0; i < nd; i++)\n      for (int j = i + 1; j < nd; j++)\n        if (d[j] % d[i] == 0) occ[i] += occ[j];\n    for (i = nd - 1; i >= 0; i--)\n      if (2 * occ[i] >= n) {\n        ans = max(ans, d[i]);\n        break;\n      }\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, tot[1000005], sum[1000005];\nlong long x[1000005], ans, g[1000005], divv[1000005];\nset<long long> s;\ninline long long read() {\n  long long ans = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) ch = getchar();\n  while (isdigit(ch)) ans = (ans << 3) + (ans << 1) + (ch ^ 48), ch = getchar();\n  return ans;\n}\ninline long long gcd(long long a, long long b) {\n  while (b) {\n    long long t = a;\n    a = b, b = t % a;\n  }\n  return a;\n}\ninline long long max(long long a, long long b) { return a > b ? a : b; }\ninline void calc(int pos) {\n  int siz = 0;\n  for (int i = 1; i <= n; ++i) g[i] = gcd(x[i], x[pos]);\n  for (int i = 1; 1ll * i * i <= x[pos]; ++i) {\n    if (x[pos] % i) continue;\n    divv[++siz] = i;\n    if (1ll * i * i == x[pos]) continue;\n    divv[++siz] = x[pos] / i;\n  }\n  sort(divv + 1, divv + siz + 1),\n      siz = unique(divv + 1, divv + siz + 1) - divv - 1;\n  for (int i = 1; i <= siz; ++i) tot[i] = sum[i] = 0;\n  for (int i = 1; i <= n; ++i)\n    ++tot[lower_bound(divv + 1, divv + siz + 1, g[i]) - divv];\n  for (int i = 1; i <= siz; ++i) {\n    if (divv[i] <= ans) continue;\n    for (int j = i; j <= siz; ++j)\n      if (divv[j] % divv[i] == 0) sum[i] += tot[j];\n  }\n  for (int i = siz; i; --i) {\n    if (divv[i] <= ans) break;\n    if (sum[i] * 2 >= n) {\n      ans = divv[i];\n      break;\n    }\n  }\n}\nint main() {\n  srand(time(NULL)), n = read(), ans = 1;\n  for (int i = 1; i <= n; ++i) x[i] = read();\n  for (int i = 1, dep = 0; dep <= 12 && i <= (n << 1); ++dep, ++i) {\n    int pos = 1ll * rand() * rand() % n + 1;\n    if (s.count(x[pos])) {\n      --dep;\n      continue;\n    }\n    s.insert(x[pos]), calc(pos);\n  }\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package round213;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Random;\nimport java.util.Set;\n\npublic class D3 {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\ta[i] = nl();\n\t\t}\n\t\t\n\t\ta = radixSort(a);\n\t\tlong[] b = new long[n];\n\t\tint[] f = new int[n];\n\t\tint q = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(i == 0 || a[i] != a[i-1]){\n\t\t\t\tb[q++] = a[i];\n\t\t\t}\n\t\t\tf[q-1]++;\n\t\t}\n\t\t\n\t\tint[] primes = sieveEratosthenes(1000000);\n\t\tRandom gen = new Random();\n\t\tSet<Long> aed = new HashSet<Long>();\n\t\tlong ret = 1;\n\t\tint[] ngdiv = new int[100000];\n\t\tint ngp = 0;\n\t\tfor(;System.currentTimeMillis() - S < 3850;){\n\t\t\tlong g;\n\t\t\tif(gen.nextBoolean()){\n\t\t\t\tint u = gen.nextInt(n);\n\t\t\t\tint v = gen.nextInt(n);\n\t\t\t\tg = gcd(a[u], a[v]);\n\t\t\t}else{\n\t\t\t\tint u = gen.nextInt(q);\n\t\t\t\tint v = gen.nextInt(q);\n\t\t\t\tg = gcd(b[u], b[v]);\n\t\t\t}\n\t\t\tif(g <= ret)continue;\n\t\t\tinner:\n\t\t\tfor(long d : divisors(g, primes)){\n\t\t\t\tif(d > ret && System.currentTimeMillis() - S < 3850 && aed.add(d)){\n\t\t\t\t\tfor(int w = 0;w < ngp;w++){\n\t\t\t\t\t\tif(d % ngdiv[w] == 0)continue inner;\n\t\t\t\t\t}\n\t\t\t\t\tif(isOK(d, b, f, q)){\n\t\t\t\t\t\tret = d;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(d < 100000){\n\t\t\t\t\t\t\tngdiv[ngp++] = (int)d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static long[] radixSort(long[] f)\n\t{\n\t\tlong[] to = new long[f.length];\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < f.length;i++)b[1+(int)(f[i]&0xffff)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < f.length;i++)to[b[(int)(f[i]&0xffff)]++] = f[i];\n\t\t\tlong[] d = f; f = to;to = d;\n\t\t}\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < f.length;i++)b[1+(int)(f[i]>>>16&0xffff)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < f.length;i++)to[b[(int)(f[i]>>>16&0xffff)]++] = f[i];\n\t\t\tlong[] d = f; f = to;to = d;\n\t\t}\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < f.length;i++)b[1+(int)(f[i]>>>32&0xffff)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < f.length;i++)to[b[(int)(f[i]>>>32&0xffff)]++] = f[i];\n\t\t\tlong[] d = f; f = to;to = d;\n\t\t}\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < f.length;i++)b[1+(int)(f[i]>>>48&0xffff)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < f.length;i++)to[b[(int)(f[i]>>>48&0xffff)]++] = f[i];\n\t\t\tlong[] d = f; f = to;to = d;\n\t\t}\n\t\treturn f;\n\t}\n\t\n\tstatic boolean isOK(long d, long[] a, int[] f, int q)\n\t{\n\t\tint h = 0;\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tif(a[i] % d == 0)h += f[i];\n\t\t}\n\t\treturn h*2 >= a.length;\n\t}\n\t\n\tpublic static long[] divisors(long n, int[] primes)\n\t{\n\t\tlong[] div = new long[7000];\n\t\tdiv[0] = 1;\n\t\tint r = 1;\n\t\t\n\t\tfor(int p : primes){\n\t\t\tif((long)p * p > n)break;\n\t\t\tint i;\n\t\t\tfor(i = 0;n % p == 0;n /= p, i++);\n\t\t\tif(i > 0){\n\t\t\t\tfor(int j = r-1;j >= 0;j--){\n\t\t\t\t\tlong base = div[j];\n\t\t\t\t\tfor(int k = 0;k < i;k++){\n\t\t\t\t\t\tbase *= p;\n\t\t\t\t\t\tdiv[r++] = base;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(n != 1){\n\t\t\tfor(int j = r-1;j >= 0;j--){\n\t\t\t\tdiv[r++] = div[j] * n;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(div, r);\n\t}\n\t\n\tpublic static int[] sieveEratosthenes(int n) {\n\t\tif(n <= 32){\n\t\t\tint[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n\t\t\tfor(int i = 0;i < primes.length;i++){\n\t\t\t\tif(n < primes[i]){\n\t\t\t\t\treturn Arrays.copyOf(primes, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn primes;\n\t\t}\n\n\t\tint u = n + 32;\n\t\tdouble lu = Math.log(u);\n\t\tint[] ret = new int[(int) (u / lu + u / lu / lu * 1.5)];\n\t\tret[0] = 2;\n\t\tint pos = 1;\n\n\t\tint[] isp = new int[(n + 1) / 32 / 2 + 1];\n\t\tint sup = (n + 1) / 32 / 2 + 1;\n\n\t\tint[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n\t\tfor(int tp : tprimes){\n\t\t\tret[pos++] = tp;\n\t\t\tint[] ptn = new int[tp];\n\t\t\tfor(int i = (tp - 3) / 2;i < tp << 5;i += tp)\n\t\t\t\tptn[i >> 5] |= 1 << (i & 31);\n\t\t\tfor(int i = 0;i < tp;i++){\n\t\t\t\tfor(int j = i;j < sup;j += tp)\n\t\t\t\t\tisp[j] |= ptn[i];\n\t\t\t}\n\t\t}\n\n\t\t// 3,5,7\n\t\t// 2x+3=n\n\t\tint[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4,\n\t\t\t\t13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14 };\n\t\tint h = n / 2;\n\t\tfor(int i = 0;i < sup;i++){\n\t\t\tfor(int j = ~isp[i];j != 0;j &= j - 1){\n\t\t\t\tint pp = i << 5 | magic[(j & -j) * 0x076be629 >>> 27];\n\t\t\t\tint p = 2 * pp + 3;\n\t\t\t\tif(p > n)\n\t\t\t\t\tbreak;\n\t\t\t\tret[pos++] = p;\n\t\t\t\tfor(int q = pp;q <= h;q += p)\n\t\t\t\t\tisp[q >> 5] |= 1 << (q & 31);\n\t\t\t}\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, pos);\n\t}\n\t\n\tpublic static long gcd(long a, long b) {\n\t\twhile (b > 0){\n\t\t\tlong c = a;\n\t\t\ta = b;\n\t\t\tb = c % b;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\t\n\tvoid run() throws Exception\n\t{\n//\t\tint n = 1000000, m = 99999;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tfor(int i = 0;i < n;i++){\n//\t\t\tsb.append(gen.nextInt(1000000000)*120L + \" \");\n//\t\t}\n//\t\tINPUT = sb.toString();\n\t\t\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new D3().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class R213qD {\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        \n        int n = in.nextInt();\n        long a[] = new long[n];\n        for (int i = 0; i < n; i++)\n            a[i] = in.nextLong();\n        \n        long ans = 1;\n        int half = (n + 1) / 2;\n        \n        HashSet<Long> done = new HashSet<Long>();\n        \n        for (int i = 0;i < 7; i++) {\n            int r = new Random().nextInt(n);\n            if(done.contains(a[r]))\n                continue;\n            done.add(a[r]);\n            TreeMap<Long , Integer> value = new TreeMap<>();\n            for (long j = 1; j * j <= a[r]; j++) {\n                if (a[r] % j == 0) {\n                    value.put(j, 0);\n                    value.put(a[r] / j, 0);\n                }\n            }\n            long div[] = new long[value.size()];\n            int ptr = 0;\n            for (long d : value.keySet()) {\n                value.put(d, ptr);\n                div[ptr++] = d;\n            }\n            int cnt[] = new int[ptr];\n            for (int j = 0; j < n; j++) {\n                long g = gcd(a[j], a[r]);\n                cnt[value.get(g)]++;\n            }\n            for (int x = 0; x < ptr; x++) {\n                for (int y = x + 1; y < ptr; y++) {\n                    if(div[y] % div[x] == 0)\n                        cnt[x] += cnt[y];\n                }\n                if(cnt[x] >= half)\n                    ans = Math.max(ans, div[x]);\n            }   \n        }\n        \n        w.println(ans);\n        w.close();\n    }\n\n    public static long gcd(long a, long b) {\n        while (b != 0) {\n            long t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n    \n    static class InputReader {\n\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public String readString() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int mx(long long int a, long long int b) {\n  if (a >= b) return a;\n  return b;\n}\nlong long int mn(long long int a, long long int b) {\n  if (a < b) return a;\n  return b;\n}\nconst int MAX = 1e6 + 9;\nlong long int a[MAX], ans = 1, n, t, tt;\nmap<long long int, int> m;\nlong long int gcd(long long int a, long long int b) {\n  if (b == 0) return a;\n  a %= b;\n  return gcd(b, a);\n}\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  double w = clock();\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int j = 0; j < 15; j++) {\n    if (clock() - w >= 3.0 * CLOCKS_PER_SEC) break;\n    m.clear();\n    long long int v = a[(long long int)rand() * rand() % n];\n    for (int i = 0; i < n; i++) m[gcd(v, a[i])]++;\n    for (map<long long int, int>::iterator i = m.begin(); i != m.end(); i++) {\n      t = 0;\n      for (map<long long int, int>::iterator j = i; j != m.end(); j++)\n        if ((j->first) % (i->first) == 0) t += j->second;\n      if ((t << 1) >= n) ans = mx(ans, i->first);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long ni() {\n  int c = getchar();\n  while (c < '0' || c > '9') c = getchar();\n  long long ret = 0;\n  while (c >= '0' && c <= '9') {\n    ret = ret * 10 + c - '0';\n    c = getchar();\n  }\n  return ret;\n}\nlong long gcd(long long a, long long b) {\n  while (b > 0) {\n    long long t = a % b;\n    a = b;\n    b = t;\n  }\n  return a;\n}\nlong long a[1234567];\nlong long d[123456];\nint cc[123456];\nint main() {\n  srand(time(NULL));\n  int n = ni();\n  for (int i = 0; i < n; i++) {\n    a[i] = ni();\n  }\n  long long ans = 1;\n  for (int it = 0; it < 10; it++) {\n    long long x = a[((rand() << 15) ^ rand()) % n];\n    int cnd = 0;\n    for (long long i = 1; i * i <= x; i++) {\n      if (x % i != 0) {\n        continue;\n      }\n      d[cnd++] = i;\n      if (i * i != x) d[cnd++] = x / i;\n    }\n    for (int i = 0; i < cnd; i++) cc[i] = 0;\n    std::sort(d, d + cnd);\n    for (int i = 0; i < n; i++) {\n      long long g = gcd(x, a[i]);\n      cc[std::lower_bound(d, d + cnd, g) - d]++;\n    }\n    for (int i = 0; i < cnd; i++) {\n      for (int j = i + 1; j < cnd; j++) {\n        if (d[j] % d[i] == 0) {\n          cc[i] += cc[j];\n        }\n      }\n      if (2 * cc[i] >= n && d[i] > ans) {\n        ans = d[i];\n      }\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n\tstatic void solve() throws IOException {\n\t\t// long time = System.currentTimeMillis();\n\t\tlong timeLimit = System.currentTimeMillis() + 3300;\n\t\tRandom rng = new Random(58 + 50216);\n\t\tint n = (int) nextLong();\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\tlong answer = 1;\n\t\twhile (System.currentTimeMillis() < timeLimit) {\n\t\t\tint index = rng.nextInt(n);\n\t\t\tlong best = checkDivisorsOf(a, a[index]);\n\t\t\tanswer = Math.max(answer, best);\n\t\t}\n\t\tout.println(answer);\n\t\t// System.err.println(System.currentTimeMillis() - time);\n\t}\n\n\tstatic class MyLong {\n\t\tlong value;\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (int) ((value * 50215) ^ (value >>> 32));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tMyLong other = (MyLong) obj;\n\t\t\tif (value != other.value)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic MyLong[] temporary = new MyLong[10000];\n\tstatic {\n\t\tfor (int i = 0; i < temporary.length; i++) {\n\t\t\ttemporary[i] = new MyLong();\n\t\t}\n\t}\n\n\tstatic int[] countForId = new int[10000];\n\tstatic Map<MyLong, Integer> map = new HashMap<MyLong, Integer>(10000);\n\n\tprivate static long checkDivisorsOf(long[] a, long value) {\n\t\tmap.clear();\n\t\tfor (long i : a) {\n\t\t\tlong gcd = binaryGCD(i, value);\n\t\t\tMyLong myLong = temporary[map.size()];\n\t\t\tmyLong.value = gcd;\n\t\t\tInteger id = map.get(myLong);\n\t\t\tif (id == null) {\n\t\t\t\tcountForId[map.size()] = 0;\n\t\t\t\tid = map.size();\n\t\t\t\tmap.put(myLong, id);\n\t\t\t}\n\t\t\tcountForId[id]++;\n\t\t}\n\t\t// System.err.println(\"time: \"+time);\n\t\t// System.err.println(map.size());\n\t\tlong[] divisor = new long[map.size()];\n\t\tint[] count = new int[map.size()];\n\t\tint cnt = 0;\n\t\tfor (Map.Entry<MyLong, Integer> entry : map.entrySet()) {\n\t\t\tdivisor[cnt] = entry.getKey().value;\n\t\t\tcount[cnt] = countForId[entry.getValue()];\n\t\t\t++cnt;\n\t\t}\n\t\tint[] newCount = new int[map.size()];\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tif (divisor[j] % divisor[i] == 0) {\n\t\t\t\t\tnewCount[i] += count[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong best = 1;\n\t\tint want = (a.length + 1) >> 1;\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tif (newCount[i] >= want) {\n\t\t\t\tbest = Math.max(best, divisor[i]);\n\t\t\t}\n\t\t}\n\t\treturn best;\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\twhile (a > 0 && b > 0) {\n\t\t\tif (a < Integer.MAX_VALUE && b < Integer.MAX_VALUE) {\n\t\t\t\treturn intGCD((int) a, (int) b);\n\t\t\t}\n\t\t\tif (a > b) {\n\t\t\t\ta %= b;\n\t\t\t} else {\n\t\t\t\tb %= a;\n\t\t\t}\n\t\t}\n\t\treturn a | b;\n\t}\n\n\tprivate static long intGCD(int a, int b) {\n\t\twhile (a > 0 && b > 0) {\n\t\t\tif (a > b) {\n\t\t\t\ta %= b;\n\t\t\t} else {\n\t\t\t\tb %= a;\n\t\t\t}\n\t\t}\n\t\treturn a | b;\n\t}\n\n\tstatic long binaryGCD(long x, long y) {\n\t\tif (x == 0)\n\t\t\treturn y;\n\n\t\tif (y == 0)\n\t\t\treturn x;\n\n\t\tlong cf2 = Long.numberOfTrailingZeros(x | y);\n\n\t\tx >>= Long.numberOfTrailingZeros(x);\n\n\t\tfor (;;) {\n\t\t\ty >>= Long.numberOfTrailingZeros(y);\n\n\t\t\tif (x == y)\n\t\t\t\tbreak;\n\n\t\t\tif (x > y) {\n\t\t\t\tlong t = x;\n\t\t\t\tx = y;\n\t\t\t\ty = t;\n\t\t\t}\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\n\t\t\ty -= x;\n\t\t}\n\n\t\treturn x << cf2;\n\t}\n\n\tstatic BufferedReader br;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream input = System.in;\n\t\tPrintStream output = System.out;\n\t\tFile file = new File(\"d.in\");\n\t\tif (file.exists() && file.canRead()) {\n\t\t\tinput = new FileInputStream(file);\n\t\t}\n\t\tbr = new BufferedReader(new InputStreamReader(input));\n\t\tout = new PrintWriter(output);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\tint c = br.read();\n\t\twhile ((c < '0' || c > '9') && c != '-')\n\t\t\tc = br.read();\n\t\tboolean negative = false;\n\t\tif (c == '-') {\n\t\t\tnegative = true;\n\t\t\tc = br.read();\n\t\t}\n\t\tlong m = 0;\n\t\twhile (c >= '0' && c <= '9') {\n\t\t\tm = m * 10 + c - '0';\n\t\t\tc = br.read();\n\t\t}\n\t\treturn negative ? -m : m;\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ninline char fgc() {\n  static char buf[100000], *p1 = buf, *p2 = buf;\n  return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)\n             ? EOF\n             : *p1++;\n}\ninline long long readint() {\n  register long long res = 0, neg = 1;\n  char c = fgc();\n  while (c < '0' || c > '9') {\n    if (c == '-') neg = -1;\n    c = fgc();\n  }\n  while (c >= '0' && c <= '9') {\n    res = res * 10 + c - '0';\n    c = fgc();\n  }\n  return res * neg;\n}\nconst int MAXN = 1000005;\ninline long long gcd(long long a, long long b) {\n  long long t;\n  while (b) {\n    t = a % b;\n    a = b;\n    b = t;\n  }\n  return a;\n}\nint n;\nlong long a[MAXN];\nint main() {\n  srand(time(NULL));\n  n = readint();\n  for (int i = 1; i <= n; i++) {\n    a[i] = readint();\n  }\n  long long ans = 1;\n  for (int rep = 1; rep <= 10; rep++) {\n    int rnd = (rand() * RAND_MAX + rand()) % n + 1;\n    std::map<long long, int> fact;\n    for (int i = 1; i <= n; i++) {\n      long long t = gcd(a[i], a[rnd]);\n      if (!fact.count(t))\n        fact[t] = 1;\n      else\n        fact[t]++;\n    }\n    std::map<long long, int>::iterator it = fact.end();\n    do {\n      it--;\n      if ((*it).first <= ans) continue;\n      int cnt = 0;\n      for (std::map<long long, int>::iterator it1 = it;\n           it1 != fact.end() && cnt << 1 < n; it1++) {\n        if (!((*it1).first % (*it).first)) {\n          cnt += (*it1).second;\n        }\n      }\n      if (cnt << 1 >= n) ans = (*it).first;\n    } while (it != fact.begin());\n  }\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int maxFactors = (1 << 14), timeLimit = 3503;\n\n\tprivate void solve() throws IOException {\n\t\tlong start = System.currentTimeMillis();\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tHashMap<Long, Integer> fastFactorsCounters = new HashMap<>();\n\t\twhile (!isOver(start)) {\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = base / i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\t++factorsCounters[fastFactorsCounters.get(current)];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate boolean isOver(long start) {\n\t\tlong current = System.currentTimeMillis();\n\t\treturn (current - start) >= timeLimit;\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (int)1e9 + 5757;\ntemplate <class T>\ninline void umax(T &a, T b) {\n  if (a < b) a = b;\n}\ntemplate <class T>\ninline void umin(T &a, T b) {\n  if (a > b) a = b;\n}\ntemplate <class T>\ninline T abs(T a) {\n  return a > 0 ? a : -a;\n}\ntemplate <class T>\ninline T lcm(T a, T b) {\n  return a / gcd(a, b) * b;\n}\ninline long long nextlong() {\n  long long x = 0, c = getchar();\n  while (c < '0' || c > '9') c = getchar();\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x;\n}\ninline int nextint() {\n  int x = 0, c = getchar();\n  while (c < '0' || c > '9') c = getchar();\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x;\n}\nconst int N = 1717171;\nlong long a[N], cnt[N];\nlong long gcd(long long a, long long b) {\n  if (a == 0) return b;\n  return gcd(b % a, a);\n}\nint randomize(int n) {\n  int x = rand() * rand() * 123123123 << 15 ^ rand();\n  x %= n;\n  if (x < 0) x += n;\n  return x;\n}\nint main() {\n  int n = nextint();\n  for (int i = 1; i <= n; i++) {\n    a[i] = nextlong();\n  }\n  srand(time(0));\n  long long ans = 0;\n  for (int it = 0; it < 12; it++) {\n    long long x = a[randomize(n) + 1];\n    vector<long long> d;\n    for (long long i = 1; i * i <= x; i++) {\n      if (x % i == 0) {\n        d.push_back(i);\n        if (i * i != x) d.push_back(x / i);\n      }\n    }\n    for (int i = 0; i < d.size(); i++) cnt[i] = 0;\n    sort(d.begin(), d.end());\n    for (int i = 1; i <= n; i++) {\n      long long g = gcd(x, a[i]);\n      cnt[lower_bound(d.begin(), d.end(), g) - d.begin()]++;\n    }\n    for (int i = 0; i < d.size(); i++)\n      for (int j = i + 1; j < d.size(); j++)\n        if (d[j] % d[i] == 0) cnt[i] += cnt[j];\n    for (int i = 0; i < d.size(); i++) {\n      if (cnt[i] * 2 >= n && d[i] > ans) {\n        ans = d[i];\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DGhd solver = new DGhd();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DGhd {\n        int n;\n        long[] a;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long start = System.nanoTime();\n            long end = (long) (start + 3.8 * 1e9);\n            n = in.nextInt();\n            a = in.readLongArray(n);\n            Counter<Long> all = new Counter<>();\n            for (long x : a) {\n                all.incr(x);\n            }\n\n            long answer = 1;\n            for (int iteration = 0; iteration < 5 || start + (System.nanoTime() - start) * (1.0 + iteration) / iteration < end; iteration++) {\n                long x = a[(int) (Math.random() * n)];\n\n                Counter<Long> gcds = new Counter<>();\n                for (Map.Entry<Long, Integer> e : all.count.entrySet()) {\n                    gcds.add(NumberTheory.gcd(x, e.getKey()), e.getValue());\n                }\n\n                long ghd = 0;\n                long[] g = new long[gcds.distinct()];\n                int index = 0;\n                for (long i : gcds.count.keySet()) {\n                    g[index++] = i;\n                }\n                Util.safeSort(g);\n                for (int i = 0; i < g.length; i++) {\n                    int count = 0;\n\n                    for (int j = i; j < g.length; j++) {\n                        if (g[j] % g[i] == 0)\n                            count += gcds.get(g[j]);\n                    }\n\n                    if (count * 2 >= n)\n                        ghd = Math.max(ghd, g[i]);\n                }\n                answer = Math.max(answer, ghd);\n            }\n\n            out.println(answer);\n        }\n\n    }\n\n    static class InputReader {\n        public final BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public long[] readLongArray(int n) {\n            long[] x = new long[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextLong();\n            }\n            return x;\n        }\n\n    }\n\n    static class Counter<T> {\n        public final HashMap<T, Integer> count = new HashMap<>();\n\n        public Counter() {\n        }\n\n        public Counter(T[] elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public Counter(Iterable<T> elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public void incr(T key) {\n            count.merge(key, 1, Integer::sum);\n        }\n\n        public void add(T key, int add) {\n            count.compute(key, (k, v) -> v == null ? add : (v + add == 0 ? null : v + add));\n        }\n\n        public int get(T key) {\n            return count.getOrDefault(key, 0);\n        }\n\n        public int distinct() {\n            return count.size();\n        }\n\n    }\n\n    static class Util {\n        public static void safeSort(long[] x) {\n            shuffle(x);\n            Arrays.sort(x);\n        }\n\n        public static void shuffle(long[] x) {\n            Random r = new Random();\n\n            for (int i = 0; i <= x.length - 2; i++) {\n                int j = i + r.nextInt(x.length - i);\n                swap(x, i, j);\n            }\n        }\n\n        public static void swap(long[] x, int i, int j) {\n            long t = x[i];\n            x[i] = x[j];\n            x[j] = t;\n        }\n\n        private Util() {\n        }\n\n    }\n\n    static class NumberTheory {\n        public static long gcd(long a, long b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            long c;\n            while (a != 0) {\n                c = a;\n                a = b % a;\n                b = c;\n            }\n            return b;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1000005], d[10005], ans;\nint b[10005], n, m;\nlong long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\nvoid work(int x) {\n  m = 0;\n  memset(b, 0, sizeof(b));\n  for (int i = 1; 1ll * i * i <= a[x]; i++)\n    if (a[x] % i == 0) {\n      d[++m] = i;\n      d[++m] = a[x] / i;\n    }\n  sort(d + 1, d + m + 1);\n  m = unique(d + 1, d + m + 1) - d - 1;\n  for (int i = 1; i <= n; i++)\n    b[lower_bound(d + 1, d + m + 1, gcd(a[i], a[x])) - d]++;\n  for (int i = m; i && d[i] > ans; i--) {\n    int tmp = 0;\n    for (int j = i; j <= m; j++)\n      if (d[j] % d[i] == 0) tmp += b[j];\n    if (tmp * 2 >= n) {\n      ans = max(ans, d[i]);\n      return;\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  for (int i = 1; i <= 10; i++) work(((rand() << 15) + rand()) % n + 1);\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 1e6 + 9;\nlong long n;\nlong long ans, a[MAXN], q[MAXN], c[MAXN], cnt[MAXN], tmp[MAXN];\ninline long long random(long long x) { return ((rand() << 15) | rand()) % x; }\nlong long gcd(long long x, long long y) { return !y ? x : gcd(y, x % y); }\nvoid solve() {\n  long long u = a[random(n) + 1];\n  long long tl = 0;\n  for (long long i = 1; i <= n; ++i) {\n    long long d = gcd(u, a[i]);\n    q[++tl] = d;\n  }\n  sort(q + 1, q + tl + 1);\n  long long tl2 = 0;\n  for (long long i = 1; i <= sqrt(u); ++i) {\n    if (!(u % i)) {\n      c[++tl2] = i;\n      if (i * i != u) tmp[tl2] = u / i;\n    }\n  }\n  long long tmpt = tl2;\n  if (!tmp[tmpt]) tmpt--;\n  for (long long i = tmpt; i; --i) c[++tl2] = tmp[i], tmp[i] = 0;\n  long long pre = 0;\n  for (long long i = 1; i <= tl; ++i) {\n    if (q[i] != q[i + 1] || i == tl) {\n      long long t = lower_bound(c + 1, c + tl2 + 1, q[i]) - c;\n      cnt[t] = i - pre;\n      pre = i;\n    }\n  }\n  for (long long i = 1; i <= tl2; ++i) {\n    for (long long j = i + 1; j <= tl2; ++j)\n      cnt[i] += (!(c[j] % c[i])) * cnt[j];\n    if (cnt[i] >= (n + 1) / 2) ans = max(ans, c[i]);\n  }\n  for (long long i = 1; i <= tl2; ++i) cnt[i] = 0;\n}\nsigned main() {\n  scanf(\"%I64d\", &n);\n  for (long long i = 1; i <= n; ++i) scanf(\"%I64d\", &a[i]);\n  srand((unsigned)time(0));\n  for (long long i = 1; i <= 10; ++i) solve();\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nll gcd(ll a, ll b) {\n  if (a == 0) return b;\n  return gcd(b % a, a);\n}\nll solve(vector<ll>& a, int index) {\n  ll x = a[index];\n  vector<pair<ll, ll> > div;\n  for (ll i = 1; i * i <= x; i++) {\n    if (x % i == 0) {\n      if (x != i * i) {\n        div.push_back(make_pair(x / i, 0LL));\n      }\n      div.push_back(make_pair(i, 0LL));\n    }\n  }\n  sort(div.begin(), div.end());\n  const ll n = a.size();\n  for (int i = 0; i < n; i++) {\n    ll gcd_value = gcd(x, a[i]);\n    auto div_pair =\n        lower_bound(div.begin(), div.end(), make_pair(gcd_value, 0LL));\n    div_pair->second++;\n  }\n  for (int i = 0; i < div.size(); i++) {\n    for (int j = i + 1; j < div.size(); j++) {\n      if (div[j].first % div[i].first == 0) {\n        div[i].second += div[j].second;\n      }\n    }\n  }\n  for (int j = div.size() - 1; j >= 0; j--) {\n    if (2 * div[j].second >= n) return (div[j].first);\n  }\n  return 0;\n}\nll random_gen() {\n  ll a = rand();\n  ll b = rand();\n  ll rmax = RAND_MAX;\n  return a * (rmax + 1) + b;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  ll n;\n  cin >> n;\n  ll ans = 0;\n  vector<ll> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  for (int i = 0; i < 12; i++) {\n    ll index = random_gen() % n;\n    ll k = solve(a, index);\n    ans = max(ans, k);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.OptionalLong;\nimport java.io.OutputStreamWriter;\nimport java.io.OutputStream;\nimport java.util.stream.LongStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DGhd solver = new DGhd();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DGhd {\n        LongHashMap map = new LongHashMap((int) 1e4, false);\n        LongArrayList factors = new LongArrayList(10000);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            long[] a = in.rl(n);\n            if (n <= 2) {\n                long max = Arrays.stream(a).max().orElse(-1);\n                out.println(max);\n                return;\n            }\n\n            long ans = 0;\n            long end = System.currentTimeMillis() + 3500;\n            while (System.currentTimeMillis() < end) {\n                long x = RandomWrapper.INSTANCE.range(a);\n                long cand = search((n + 1) / 2, a, x);\n                ans = Math.max(ans, cand);\n            }\n\n            out.println(ans);\n        }\n\n        public long search(int atLeast, long[] a, long g) {\n            factors.clear();\n            Factorization.factorizeNumber(g, factors);\n            factors.sort();\n            long[] fs = factors.toArray();\n            int[] cnt = new int[fs.length];\n\n\n            map.clear();\n            for (long x : a) {\n                map.modify(GCDs.gcd(g, x), 1);\n            }\n\n            for (int i = fs.length - 1; i >= 0; i--) {\n                int c = (int) map.get(fs[i]);\n                if (c == 0) {\n                    continue;\n                }\n                for (int j = i; j >= 0; j--) {\n                    if (fs[i] % fs[j] == 0) {\n                        cnt[j] += c;\n                    }\n                }\n                if (cnt[i] >= atLeast) {\n                    return fs[i];\n                }\n            }\n            return 1;\n        }\n\n    }\n\n    static class RandomWrapper {\n        private Random random;\n        public static final RandomWrapper INSTANCE = new RandomWrapper();\n\n        public RandomWrapper() {\n            this(new Random());\n        }\n\n        public RandomWrapper(Random random) {\n            this.random = random;\n        }\n\n        public RandomWrapper(long seed) {\n            this(new Random(seed));\n        }\n\n        public int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n        public long range(long... x) {\n            return x[nextInt(0, x.length - 1)];\n        }\n\n    }\n\n    static class LongHashMap {\n        private int now;\n        private int[] slot;\n        private int[] version;\n        private int[] next;\n        private long[] keys;\n        private long[] values;\n        private int alloc;\n        private boolean[] removed;\n        private int mask;\n        private int size;\n        private boolean rehash;\n        private Hasher hasher = new Hasher();\n\n        public LongHashMap(int cap, boolean rehash) {\n            now = 1;\n            this.mask = (1 << (32 - Integer.numberOfLeadingZeros(cap - 1))) - 1;\n            slot = new int[mask + 1];\n            version = new int[slot.length];\n            next = new int[cap + 1];\n            keys = new long[cap + 1];\n            values = new long[cap + 1];\n            removed = new boolean[cap + 1];\n            this.rehash = rehash;\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            keys = Arrays.copyOf(keys, newSize);\n            values = Arrays.copyOf(values, newSize);\n            removed = Arrays.copyOf(removed, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n            removed[alloc] = false;\n            size++;\n        }\n\n        private void rehash() {\n            int[] newSlots = new int[Math.max(16, slot.length * 2)];\n            int[] newVersions = new int[newSlots.length];\n            int newMask = newSlots.length - 1;\n            for (int i = 0; i < slot.length; i++) {\n                access(i);\n                if (slot[i] == 0) {\n                    continue;\n                }\n                int head = slot[i];\n                while (head != 0) {\n                    int n = next[head];\n                    int s = hash(keys[head]) & newMask;\n                    next[head] = newSlots[s];\n                    newSlots[s] = head;\n                    head = n;\n                }\n            }\n            this.slot = newSlots;\n            this.version = newVersions;\n            now = 0;\n            this.mask = newMask;\n        }\n\n        private int hash(long x) {\n            return hasher.hash(x);\n        }\n\n        public void modify(long x, long dy) {\n            int h = hash(x);\n            int s = h & mask;\n            access(s);\n            if (slot[s] == 0) {\n                alloc();\n                slot[s] = alloc;\n                keys[alloc] = x;\n                values[alloc] = dy;\n            } else {\n                int index = findIndexOrLastEntry(s, x);\n                if (keys[index] != x) {\n                    alloc();\n                    next[index] = alloc;\n                    keys[alloc] = x;\n                    values[alloc] = dy;\n                } else {\n                    values[index] += dy;\n                }\n            }\n            if (rehash && size >= slot.length) {\n                rehash();\n            }\n        }\n\n        public long getOrDefault(long x, long def) {\n            int h = hash(x);\n            int s = h & mask;\n            access(s);\n            if (slot[s] == 0) {\n                return def;\n            }\n            int index = findIndexOrLastEntry(s, x);\n            return keys[index] == x ? values[index] : def;\n        }\n\n        public long get(long x) {\n            return getOrDefault(x, 0);\n        }\n\n        private int findIndexOrLastEntry(int s, long x) {\n            int iter = slot[s];\n            while (keys[iter] != x) {\n                if (next[iter] != 0) {\n                    iter = next[iter];\n                } else {\n                    return iter;\n                }\n            }\n            return iter;\n        }\n\n        public void clear() {\n            alloc = 0;\n            size = 0;\n            now++;\n        }\n\n        private void access(int i) {\n            if (version[i] != now) {\n                version[i] = now;\n                slot[i] = 0;\n            }\n        }\n\n        public LongEntryIterator iterator() {\n            return new LongEntryIterator() {\n                int index = 1;\n                int readIndex = -1;\n\n\n                public boolean hasNext() {\n                    while (index <= alloc && removed[index]) {\n                        index++;\n                    }\n                    return index <= alloc;\n                }\n\n\n                public long getEntryKey() {\n                    return keys[readIndex];\n                }\n\n\n                public long getEntryValue() {\n                    return values[readIndex];\n                }\n\n\n                public void next() {\n                    if (!hasNext()) {\n                        throw new IllegalStateException();\n                    }\n                    readIndex = index;\n                    index++;\n                }\n            };\n        }\n\n        public String toString() {\n            LongEntryIterator iterator = iterator();\n            StringBuilder builder = new StringBuilder(\"{\");\n            while (iterator.hasNext()) {\n                iterator.next();\n                builder.append(iterator.getEntryKey()).append(\"->\").append(iterator.getEntryValue()).append(',');\n            }\n            if (builder.charAt(builder.length() - 1) == ',') {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append('}');\n            return builder.toString();\n        }\n\n    }\n\n    static interface LongEntryIterator {\n        boolean hasNext();\n\n        void next();\n\n        long getEntryKey();\n\n        long getEntryValue();\n\n    }\n\n    static class Randomized {\n        public static void shuffle(long[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                long tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return RandomWrapper.INSTANCE.nextInt(l, r);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\\n');\n        }\n\n        public FastOutput flush() {\n            try {\n//            boolean success = false;\n//            if (stringBuilderValueField != null) {\n//                try {\n//                    char[] value = (char[]) stringBuilderValueField.get(cache);\n//                    os.write(value, 0, cache.length());\n//                    success = true;\n//                } catch (Exception e) {\n//                }\n//            }\n//            if (!success) {\n                os.append(cache);\n//            }\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(long[] a, int al, int ar, long[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Factorization {\n        public static void factorizeNumber(long x, LongArrayList ans) {\n            for (long i = 1; i * i <= x; i++) {\n                if (x % i != 0) {\n                    continue;\n                }\n                ans.add(i);\n                if (i * i != x) {\n                    ans.add(x / i);\n                }\n            }\n        }\n\n    }\n\n    static class LongArrayList implements Cloneable {\n        private int size;\n        private int cap;\n        private long[] data;\n        private static final long[] EMPTY = new long[0];\n\n        public LongArrayList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new long[cap];\n            }\n        }\n\n        public LongArrayList(long[] data) {\n            this(0);\n            addAll(data);\n        }\n\n        public LongArrayList(LongArrayList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public LongArrayList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(long x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(long[] x) {\n            addAll(x, 0, x.length);\n        }\n\n        public void addAll(long[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(LongArrayList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public void sort() {\n            if (size <= 1) {\n                return;\n            }\n            Randomized.shuffle(data, 0, size);\n            Arrays.sort(data, 0, size);\n        }\n\n        public long[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof LongArrayList)) {\n                return false;\n            }\n            LongArrayList other = (LongArrayList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Long.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public LongArrayList clone() {\n            LongArrayList ans = new LongArrayList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class Hasher {\n        private long time = System.nanoTime() + System.currentTimeMillis() * 31L;\n\n        public int shuffle(long z) {\n            z += time;\n            z = (z ^ (z >>> 33)) * 0x62a9d9ed799705f5L;\n            return (int) (((z ^ (z >>> 28)) * 0xcb24d0a5c88c35b3L) >>> 32);\n        }\n\n        public int hash(long x) {\n            return shuffle(x);\n        }\n\n    }\n\n    static class GCDs {\n        private GCDs() {\n        }\n\n        public static long gcd(long a, long b) {\n            return a >= b ? gcd0(a, b) : gcd0(b, a);\n        }\n\n        private static long gcd0(long a, long b) {\n            return b == 0 ? a : gcd0(b, a % b);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(long[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readLong();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public long[] rl(int n) {\n            long[] ans = new long[n];\n            populate(ans);\n            return ans;\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DGhd solver = new DGhd();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DGhd {\n        int n;\n        long[] a;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long start = System.nanoTime();\n            long end = (long) (start + 3.8 * 1e9);\n            n = in.nextInt();\n            a = in.readLongArray(n);\n            Counter<Long> all = new Counter<>();\n            for (long x : a) {\n                all.incr(x);\n            }\n\n            long answer = 1;\n            for (int iteration = 0; iteration < 15 && (iteration < 3 || start + (System.nanoTime() - start) * (1.0 + iteration) / iteration < end); iteration++) {\n                long x = a[(int) (Math.random() * n)];\n\n                Counter<Long> gcds = new Counter<>();\n                for (Map.Entry<Long, Integer> e : all.count.entrySet()) {\n                    gcds.add(NumberTheory.gcd(x, e.getKey()), e.getValue());\n                }\n\n                long ghd = 0;\n                long[] g = new long[gcds.distinct()];\n                int index = 0;\n                for (long i : gcds.count.keySet()) {\n                    g[index++] = i;\n                }\n                Util.safeSort(g);\n                for (int i = 0; i < g.length; i++) {\n                    int count = 0;\n\n                    for (int j = i; j < g.length; j++) {\n                        if (g[j] % g[i] == 0)\n                            count += gcds.get(g[j]);\n                    }\n\n                    if (count * 2 >= n)\n                        ghd = Math.max(ghd, g[i]);\n                }\n                answer = Math.max(answer, ghd);\n            }\n\n            out.println(answer);\n        }\n\n    }\n\n    static class InputReader {\n        public final BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public long[] readLongArray(int n) {\n            long[] x = new long[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextLong();\n            }\n            return x;\n        }\n\n    }\n\n    static class Counter<T> {\n        public final HashMap<T, Integer> count = new HashMap<>();\n\n        public Counter() {\n        }\n\n        public Counter(T[] elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public Counter(Iterable<T> elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public void incr(T key) {\n            count.merge(key, 1, Integer::sum);\n        }\n\n        public void add(T key, int add) {\n            count.compute(key, (k, v) -> v == null ? add : (v + add == 0 ? null : v + add));\n        }\n\n        public int get(T key) {\n            return count.getOrDefault(key, 0);\n        }\n\n        public int distinct() {\n            return count.size();\n        }\n\n    }\n\n    static class Util {\n        public static void safeSort(long[] x) {\n            shuffle(x);\n            Arrays.sort(x);\n        }\n\n        public static void shuffle(long[] x) {\n            Random r = new Random();\n\n            for (int i = 0; i <= x.length - 2; i++) {\n                int j = i + r.nextInt(x.length - i);\n                swap(x, i, j);\n            }\n        }\n\n        public static void swap(long[] x, int i, int j) {\n            long t = x[i];\n            x[i] = x[j];\n            x[j] = t;\n        }\n\n        private Util() {\n        }\n\n    }\n\n    static class NumberTheory {\n        public static long gcd(long a, long b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            long c;\n            while (a != 0) {\n                c = a;\n                a = b % a;\n                b = c;\n            }\n            return b;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.BitSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DGhd solver = new DGhd();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DGhd {\n        int n;\n        long[] a;\n        LinearSieve ls = new LinearSieve(1_000_000);\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long start = System.nanoTime();\n            long end = (long) (start + 3.8 * 1e9);\n            n = in.nextInt();\n            a = in.readLongArray(n);\n\n            Counter<Long> all = new Counter<>();\n            for (long x : a) {\n                all.incr(x);\n            }\n\n            long answer = 1;\n            HashSet<Long> seen = new HashSet<>();\n            long mid = System.nanoTime();\n            for (int iteration = 0; iteration < 100 && (iteration < 5 || mid + (System.nanoTime() - mid) * (1.0 + iteration) / iteration < end); iteration++) {\n                if (seen.size() == all.distinct())\n                    break;\n                long x;\n                do {\n                    x = a[(int) (Math.random() * n)];\n                } while (seen.contains(x));\n                seen.add(x);\n\n                Counter<Long> gcds = new Counter<>();\n                for (long y : a)\n                    gcds.incr(NumberTheory.gcd(x, y));\n//            for (Map.Entry<Long, Integer> e : all.count.entrySet()) {\n//                gcds.add(gcd(x, e.getKey()), e.getValue());\n//            }\n\n                long[] primes = getPrimes(x);\n\n                long[] divisors = new long[6720];\n                int divCount = 0;\n                divisors[divCount++] = 1L;\n                for (long p : primes) {\n                    int before = divCount;\n                    for (int i = 0; i < before; i++) {\n                        long v = divisors[i];\n                        for (long u = v; u <= x / p && x % (u * p) == 0; u *= p)\n                            divisors[divCount++] = u * p;\n                    }\n                }\n\n                long[] g = new long[divCount];\n                System.arraycopy(divisors, 0, g, 0, divCount);\n\n                Util.safeSort(g);\n                Util.reverse(g);\n\n                for (long p : primes) {\n                    for (long v : g) {\n                        if (v <= x / p) {\n                            int c = gcds.get(v * p);\n                            if (c > 0)\n                                gcds.add(v, c);\n                        }\n                    }\n                }\n                for (long v : g) {\n                    if (gcds.get(v) * 2 >= n)\n                        answer = Math.max(answer, v);\n                }\n            }\n\n            out.println(answer);\n        }\n\n        private long[] getPrimes(long x) {\n            List<Long> primes = new ArrayList<>();\n\n            for (long p : ls.primes) {\n                if (p * p > x)\n                    break;\n                if (x % p != 0)\n                    continue;\n                do {\n                    x /= p;\n                } while (x % p == 0);\n                primes.add(p);\n            }\n            if (x > 1)\n                primes.add(x);\n\n            long[] array = new long[primes.size()];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = primes.get(i);\n            }\n            return array;\n        }\n\n    }\n\n    static class NumberTheory {\n        public static long gcd(long a, long b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            long c;\n            while (a != 0) {\n                c = a;\n                a = b % a;\n                b = c;\n            }\n            return b;\n        }\n\n    }\n\n    static class InputReader {\n        public final BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public long[] readLongArray(int n) {\n            long[] x = new long[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextLong();\n            }\n            return x;\n        }\n\n    }\n\n    static class Counter<T> {\n        public final HashMap<T, Integer> count = new HashMap<>();\n\n        public Counter() {\n        }\n\n        public Counter(T[] elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public Counter(Iterable<T> elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public void incr(T key) {\n            count.merge(key, 1, Integer::sum);\n        }\n\n        public void add(T key, int add) {\n            count.compute(key, (k, v) -> v == null ? add == 0 ? null : add : (v + add == 0 ? null : v + add));\n        }\n\n        public int get(T key) {\n            return count.getOrDefault(key, 0);\n        }\n\n        public int distinct() {\n            return count.size();\n        }\n\n    }\n\n    static class Util {\n        public static void safeSort(long[] x) {\n            shuffle(x);\n            Arrays.sort(x);\n        }\n\n        public static void shuffle(long[] x) {\n            Random r = new Random();\n\n            for (int i = 0; i <= x.length - 2; i++) {\n                int j = i + r.nextInt(x.length - i);\n                swap(x, i, j);\n            }\n        }\n\n        public static void swap(long[] x, int i, int j) {\n            long t = x[i];\n            x[i] = x[j];\n            x[j] = t;\n        }\n\n        public static void reverse(long[] x) {\n            for (int i = 0, j = x.length - 1; i < j; i++, j--) {\n                swap(x, i, j);\n            }\n        }\n\n        private Util() {\n        }\n\n    }\n\n    static class LinearSieve {\n        public final BitSet isComposite;\n        public final int[] leastPrimeDivisor;\n        public final int[] primes;\n\n        public LinearSieve(int n) {\n            double estimate;\n            if (n < 10000) {\n                estimate = n + 1;\n            } else {\n                estimate = ((double) n) / Math.log(n);\n                estimate *= 1.1;\n            }\n            int[] primes = new int[(int) estimate];\n            leastPrimeDivisor = new int[n + 1];\n            int size = 0;\n\n            if (n <= 1) {\n                isComposite = new BitSet();\n            } else {\n                isComposite = new BitSet(n + 1);\n\n                for (int i = 2; i <= n; i++) {\n                    if (!isComposite.get(i)) {\n                        if (size >= primes.length)\n                            primes = resize(primes);\n                        primes[size++] = i;\n                        leastPrimeDivisor[i] = i;\n                    }\n\n                    for (int j = 0; j < size; j++) {\n                        int p = primes[j];\n                        if (i * p > n)\n                            break;\n                        isComposite.set(i * p);\n                        leastPrimeDivisor[i * p] = p;\n                        if (i % p == 0)\n                            break;\n                    }\n                }\n            }\n\n            this.primes = new int[size];\n            System.arraycopy(primes, 0, this.primes, 0, size);\n        }\n\n        private static int[] resize(int[] primes) {\n            int newSize = 1 + ((primes.length * 11) / 10);\n            int[] newPrimes = new int[newSize];\n            System.arraycopy(primes, 0, newPrimes, 0, primes.length);\n            return newPrimes;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1000000 + 5;\nlong long A[N], B[N];\nint n, tot, cnt[N];\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long work() {\n  long long ret = 1;\n  for (int step = 0; step < 10; ++step) {\n    long long val = A[(rand() << 15 | rand()) % n];\n    tot = 0;\n    for (long long i = 1; i * i <= val; ++i) {\n      if (val % i == 0) {\n        B[tot++] = i;\n        if (i != val / i) {\n          B[tot++] = val / i;\n        }\n      }\n    }\n    std::sort(B, B + tot);\n    std::fill(cnt, cnt + tot, 0);\n    for (int i = 0; i < n; ++i) {\n      cnt[std::lower_bound(B, B + tot, gcd(A[i], val)) - B]++;\n    }\n    for (int i = tot - 1; i >= 0; --i) {\n      if (B[i] <= ret) break;\n      int sum = 0;\n      for (int j = i; j < tot; ++j) {\n        if (B[j] % B[i] == 0) sum += cnt[j];\n      }\n      if (sum * 2 >= n) {\n        ret = B[i];\n      }\n    }\n  }\n  return ret;\n}\nint main() {\n  srand(time(NULL));\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%I64d\", A + i);\n  }\n  printf(\"%I64d\\n\", work());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1000005], d[10005], ans;\nint b[10005], n, m;\nlong long gcd(long long a, long long b) {\n  long long ret = 1;\n  while (a && b) {\n    if (a < b) swap(a, b);\n    long long f = a & 1, s = b & 1;\n    if (f && s)\n      a = (a - b) >> 1;\n    else if (!f && s)\n      a >>= 1;\n    else if (f && !s) {\n      b >>= 1;\n    } else {\n      a >>= 1;\n      b >>= 1;\n      ret <<= 1;\n    }\n  }\n  return (!a ? b : a) * ret;\n}\nvoid work(int x) {\n  m = 0;\n  memset(b, 0, sizeof(b));\n  for (int i = 1; 1ll * i * i <= a[x]; i++)\n    if (a[x] % i == 0) {\n      d[++m] = i;\n      d[++m] = a[x] / i;\n    }\n  sort(d + 1, d + m + 1);\n  m = unique(d + 1, d + m + 1) - d - 1;\n  for (int i = 1; i <= n; i++)\n    b[lower_bound(d + 1, d + m + 1, gcd(a[i], a[x])) - d]++;\n  for (int i = m; i && d[i] > ans; i--) {\n    int tmp = 0;\n    for (int j = i; j <= m; j++)\n      if (d[j] % d[i] == 0) tmp += b[j];\n    if (tmp * 2 >= n) {\n      ans = max(ans, d[i]);\n      return;\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  for (int i = 1; i <= 10; i++) work(((rand() << 15) + rand()) % n + 1);\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000000 + 100;\nint n, t;\nlong long a[maxn];\nlong long dv[100000];\nint cnt[100000];\nlong long gcd(long long x, long long y) {\n  while (x) {\n    long long tmp = x;\n    x = y % x;\n    y = tmp;\n  }\n  return y;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n;\n  for (int i = 0, _n = (int)(n); i < _n; i++) cin >> a[i];\n  random_shuffle(a, a + n);\n  random_shuffle(a, a + n);\n  long long ans = 0;\n  for (int z = 0, _n = (int)(min(n, 13)); z < _n; z++) {\n    long long x = a[z];\n    t = 0;\n    for (long long i = 1; i * i <= x; i++)\n      if (x % i == 0) dv[t++] = i, (i * i != x ? dv[t++] = x / i : 0);\n    sort(dv, dv + t);\n    memset(cnt, 0, t * sizeof(cnt[0]));\n    for (int i = 0, _n = (int)(n); i < _n; i++)\n      cnt[lower_bound(dv, dv + t, gcd(a[z], a[i])) - dv]++;\n    for (int i = 0, _n = (int)(t); i < _n; i++)\n      for (int j = 0, _n = (int)(i); j < _n; j++)\n        if (dv[i] % dv[j] == 0) cnt[j] += cnt[i];\n    for (int i = 0, _n = (int)(t); i < _n; i++)\n      if (cnt[i] * 2 >= n) ans = max(ans, dv[i]);\n  }\n  cout << ans << endl;\n  {\n    int _;\n    cin >> _;\n    return 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long read() {\n  long long q = 0;\n  char ch = ' ';\n  while (ch < '0' || ch > '9') ch = getchar();\n  while (ch >= '0' && ch <= '9')\n    q = q * 10 + (long long)(ch - '0'), ch = getchar();\n  return q;\n}\nconst int N = 1000005;\nlong long a[N], b[10005], ans;\nint n, cnt[10005];\nlong long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\nint main() {\n  srand(19260817);\n  n = read(), ans = 1;\n  for (register int i = 1; i <= n; ++i) a[i] = read();\n  for (register int kas = 1; kas <= 12; ++kas) {\n    int x = 1LL * rand() * rand() % n + 1, js = 0;\n    for (long long i = 1; i * i <= a[x]; ++i)\n      if (a[x] % i == 0) {\n        b[++js] = i;\n        if (i * i != a[x]) b[++js] = a[x] / i;\n      }\n    for (register int i = 1; i <= js; ++i) cnt[i] = 0;\n    sort(b + 1, b + 1 + js);\n    for (register int i = 1; i <= n; ++i)\n      ++cnt[lower_bound(b + 1, b + 1 + js, gcd(a[i], a[x])) - b];\n    for (register int i = 1; i <= js; ++i) {\n      if (b[i] <= ans) continue;\n      for (register int j = i + 1; j <= js; ++j)\n        if (b[j] % b[i] == 0) cnt[i] += cnt[j];\n      if (cnt[i] >= (n + 1) / 2) ans = b[i];\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int modul = 1000000007;\nconst int nmax = 1000100;\nconst double e = 1e-8;\nconst double pi = acos(-1);\nint n;\nlong long a[nmax];\nlong long gcd(long long u, long long v) {\n  while (v != 0) {\n    long long tmp = u;\n    u = v;\n    v = tmp % v;\n  }\n  return u;\n}\nmap<long long, int> d;\nvector<long long> s;\nvector<int> cnt;\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  long long res = 0;\n  for (int step = 1; step <= 15; step++) {\n    long long A = a[((long long)rand() * rand()) % n + 1];\n    d.clear();\n    s.clear();\n    cnt.clear();\n    for (int i = 1; i <= n; i++) {\n      long long tg = gcd(A, a[i]);\n      d[tg]++;\n    }\n    for (map<long long, int>::iterator it = d.begin(); it != d.end(); it++) {\n      s.push_back(it->first);\n      cnt.push_back(it->second);\n    }\n    for (int i = 0; i <= (int)s.size() - 1; i++) {\n      int cal = 0;\n      for (int j = i; j <= (int)s.size() - 1; j++)\n        if (s[j] % s[i] == 0) cal += cnt[j];\n      if (2 * cal >= n) res = max(res, s[i]);\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std;\nconst long long mod2 = 998244353;\nlong long fpow(long long x, long long y) {\n  x = x % 1000000007;\n  long long sum = 1;\n  while (y) {\n    if (y & 1) sum = sum * x;\n    sum %= 1000000007;\n    y = y >> 1;\n    x = x * x;\n    x %= 1000000007;\n  }\n  return sum;\n}\nlong long inv(long long a, long long m = 1000000007) {\n  long long c = m;\n  long long y = 0, x = 1;\n  if (m == 1) return 0;\n  while (a > 1) {\n    long long q = a / m;\n    long long t = m;\n    m = a % m, a = t;\n    t = y;\n    y = x - q * y;\n    x = t;\n  }\n  if (x < 0) x += c;\n  return x;\n}\nlong long gcd(long long a, long long b) {\n  if (!a) return b;\n  return gcd(b % a, a);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  long long n;\n  cin >> n;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  long long res = 1;\n  for (int i = 0; i < 10; i++) {\n    long long ele = a[rng() % n];\n    vector<long long> div, cnt;\n    for (long long j = 1; j * j <= ele; j++) {\n      if ((ele % j) == 0) {\n        if (j * j == ele) {\n          div.push_back(j);\n          cnt.push_back(0);\n        } else {\n          div.push_back(j);\n          cnt.push_back(0);\n          div.push_back(ele / j);\n          cnt.push_back(0);\n        }\n      }\n    }\n    sort(div.begin(), div.end());\n    for (int j = 0; j < n; j++) {\n      long long g = gcd(ele, a[j]);\n      cnt[lower_bound(div.begin(), div.end(), g) - div.begin()]++;\n    }\n    for (int j = 0; j < div.size(); j++) {\n      for (int k = j + 1; k < div.size(); k++) {\n        if (div[k] % div[j] == 0) cnt[j] += cnt[k];\n      }\n      if (2 * cnt[j] >= n) res = max(res, div[j]);\n    }\n  }\n  cout << res << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT nextInt() {\n  T x = 0, p = 1;\n  char ch;\n  do {\n    ch = getchar();\n  } while (ch <= ' ');\n  if (ch == '-') {\n    p = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + (ch - '0');\n    ch = getchar();\n  }\n  return x * p;\n}\nconst int maxN = (int)1e6 + 10;\nconst int mod = (int)1e9 + 7;\nconst int INF = (int)1e9 + 5;\nconst long long LLINF = (long long)1e18 + 5;\nlong long a[maxN];\nint n;\nlong long best = 1;\nint need;\nlong long gcd(long long x, long long y) {\n  while (x != 0 && y != 0) {\n    if (x > y) {\n      x %= y;\n    } else {\n      y %= x;\n    }\n  }\n  return x | y;\n}\nlong long b[maxN];\nint cnt[maxN];\nint pcnt[maxN];\nlong long d[maxN];\nvoid solve(long long x) {\n  int sz = 0;\n  for (long long i = 1; i * i <= x; ++i) {\n    if (x % i == 0) {\n      d[sz++] = i;\n      if (i * i != x) d[sz++] = x / i;\n    }\n  }\n  sort(d, d + sz);\n  for (int i = 0; i < n; ++i) {\n    b[i] = gcd(a[i], x);\n  }\n  sort(b, b + n);\n  for (int i = 0; i < sz; ++i) {\n    cnt[i] = 0;\n    pcnt[i] = 0;\n  }\n  int ptr = 0;\n  for (int i = 0; i < sz; ++i) {\n    while (ptr < n && b[ptr] <= d[i]) {\n      if (b[ptr] == d[i]) cnt[i]++;\n      ptr++;\n    }\n  }\n  for (int i = 0; i < sz; ++i) {\n    for (int j = 0; j <= i; ++j) {\n      if (d[i] % d[j] == 0) {\n        pcnt[j] += cnt[i];\n      }\n    }\n  }\n  for (int i = 0; i < sz; ++i) {\n    if (pcnt[i] >= need) {\n      best = max(best, d[i]);\n    }\n  }\n}\nint main() {\n  srand(time(NULL));\n  n = nextInt<int>();\n  for (int i = 0; i < n; ++i) {\n    a[i] = nextInt<long long>();\n  }\n  need = (n + 1) / 2;\n  for (int iter = 0; iter < 11; ++iter) {\n    int i = ((rand() << 15) | rand()) % n;\n    solve(a[i]);\n  }\n  printf(\"%I64d\\n\", best);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int maxFactors = (1 << 14), timeLimit = 3500;\n\n\tprivate void solve() throws IOException {\n\t\tlong start = System.currentTimeMillis();\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tHashMap<Long, Integer> fastFactorsCounters = new HashMap<>();\n\t\twhile (!isOver(start)) {\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = base / i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\t++factorsCounters[fastFactorsCounters.get(current)];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate boolean isOver(long start) {\n\t\tlong current = System.currentTimeMillis();\n\t\treturn (current - start) >= timeLimit;\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 1e6 + 5;\nlong long gcd(long long a, long long b) {\n  long long t;\n  while (b) {\n    t = a % b;\n    a = b;\n    b = t;\n  }\n  return a;\n}\nint n;\nlong long A[Maxn];\nmap<long long, int> fact;\nint main() {\n  srand(time(NULL));\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &A[i]);\n  long long ans = 1;\n  int rep = 14;\n  while (rep--) {\n    int rnd = (rand() * RAND_MAX + rand()) % n + 1;\n    fact.clear();\n    for (int i = 1; i <= n; i++) {\n      long long t = gcd(A[i], A[rnd]);\n      if (!fact.count(t))\n        fact[t] = 1;\n      else\n        fact[t]++;\n    }\n    map<long long, int>::iterator it = fact.end();\n    do {\n      it--;\n      int cnt = 0;\n      if (it->first <= ans) continue;\n      for (map<long long, int>::iterator it1 = it;\n           it1 != fact.end() && cnt << 1 < n; it1++)\n        if (it1->first % it->first == 0) cnt += it1->second;\n      if (cnt << 1 >= n) ans = it->first;\n    } while (it != fact.begin());\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T = 9, N, sTotal;\nmap<long long, int> cnt;\nmap<long long, bool> exist;\nlong long A[2000010], sta[2000010], Ans = 1;\nlong long gcd(long long a, long long b) {\n  return a % b == 0 ? b : gcd(b, a % b);\n}\nvoid Add_Divisors(long long x) {\n  long long i;\n  for (i = 1; i * i <= x; ++i)\n    if (x % i == 0) {\n      if (!exist[i]) {\n        sta[++sTotal] = i;\n        exist[i] = 1;\n      }\n      if (i * i < x)\n        if (!exist[x / i]) {\n          sta[++sTotal] = x / i;\n          exist[x / i] = 1;\n        }\n    }\n}\nlong long Max(long long a, long long b) { return a > b ? a : b; }\nint main() {\n  int i, j;\n  srand(19960527);\n  scanf(\"%d\", &N);\n  for (i = 1; i <= N; ++i) scanf(\"%I64d\", &A[i]);\n  for (; T; --T) {\n    int to = (rand() * 12341 + rand()) % N + 1;\n    sTotal = 0;\n    Add_Divisors(A[to]);\n    for (i = 1; i <= N; ++i) {\n      long long nv = gcd(A[to], A[i]);\n      ++cnt[nv];\n    }\n    sort(sta + 1, sta + sTotal + 1);\n    for (i = 1; i <= sTotal; ++i) {\n      for (j = i + 1; j <= sTotal; ++j)\n        if (sta[j] % sta[i] == 0) cnt[sta[i]] += cnt[sta[j]];\n      if (2 * cnt[sta[i]] >= N) Ans = Max(Ans, sta[i]);\n    }\n    cnt.clear();\n    exist.clear();\n  }\n  cout << Ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O500\")\n#pragma comment(linker, \"/STACK:1677777216\")\n#pragma warning(default : 4)\nusing namespace std;\nconst double eps = 1e-12;\nconst int oo = 0x3F3F3F3F;\nconst long long ooLL = 0x3F3F3F3F3F3F3F3FLL;\nconst int MOD = 1000000007;\ntemplate <typename T>\nT sqr(T x) {\n  return x * x;\n}\ntemplate <typename T>\nvoid debpr(const T &);\ntemplate <typename T1, typename T2>\nvoid debpr(const pair<T1, T2> &);\ntemplate <typename T1, typename T2>\nvoid debpr(const vector<T1, T2> &);\ntemplate <typename T>\nvoid debpr(const set<T> &);\ntemplate <typename T1, typename T2>\nvoid debpr(const map<T1, T2> &);\ntemplate <typename T>\nvoid prcont(T be, T en, const string &st, const string &fi, const string &mi) {\n  debpr(st);\n  bool ft = 0;\n  while (be != en) {\n    if (ft) debpr(mi);\n    ft = 1;\n    debpr(*be);\n    ++be;\n  }\n  debpr(fi);\n}\ntemplate <typename T>\nvoid debpr(const T &a) {}\ntemplate <typename T1, typename T2>\nvoid debpr(const pair<T1, T2> &p) {\n  debpr(\"(\");\n  debpr(p.first);\n  debpr(\", \");\n  debpr(p.second);\n  debpr(\")\");\n}\ntemplate <typename T1, typename T2>\nvoid debpr(const vector<T1, T2> &a) {\n  prcont(a.begin(), a.end(), \"[\", \"]\", \", \");\n}\ntemplate <typename T>\nvoid debpr(const set<T> &a) {\n  prcont(a.begin(), a.end(), \"{\", \"}\", \", \");\n}\ntemplate <typename T1, typename T2>\nvoid debpr(const map<T1, T2> &a) {\n  prcont(a.begin(), a.end(), \"{\", \"}\", \", \");\n}\nvoid deb(){};\ntemplate <typename T1>\nvoid deb(const T1 &t1) {\n  debpr(t1);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2>\nvoid deb(const T1 &t1, const T2 &t2) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2, typename T3>\nvoid deb(const T1 &t1, const T2 &t2, const T3 &t3) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr(' ');\n  debpr(t3);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid deb(const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr(' ');\n  debpr(t3);\n  debpr(' ');\n  debpr(t4);\n  debpr('\\n');\n}\nconst double PI = acos(-1.);\nlong long Round(double x) { return x < 0 ? x - .5 : x + .5; }\ntemplate <typename T>\nvoid ass(bool v, const T &x, string m = \"Fail\") {\n  if (!v) {\n    deb(m);\n    deb(x);\n    throw;\n  }\n}\nint main() {\n  void run();\n  run();\n  return 0;\n}\nlong long a[1 << 20];\nint n;\nlong long gcd(long long a, long long b) {\n  long long t;\n  while (a) b %= a, t = a, a = b, b = t;\n  return b;\n}\nlong long mrand() {\n  long long rs = 0;\n  for (int i = (0), _b(60); i < _b; ++i)\n    if (rand() % 2) rs += 1LL << i;\n  return rs;\n}\nvoid run() {\n  scanf(\"%d\", &n);\n  for (int i = (0), _b(n); i < _b; ++i) scanf(\"%lld\", &a[i]);\n  long long rs = 1;\n  srand(6);\n  for (int it = (0), _b(12); it < _b; ++it) {\n    long long t = a[mrand() % n];\n    unordered_map<long long, int> m;\n    m.reserve(1 << 15);\n    for (int i = (0), _b(n); i < _b; ++i) ++m[gcd(a[i], t)];\n    vector<pair<long long, long long> > v((m).begin(), (m).end());\n    for (int i = (0), _b(v.size()); i < _b; ++i) {\n      int z = 0;\n      for (int j = (0), _b(v.size()); j < _b; ++j)\n        if (v[j].first % v[i].first == 0) z += v[j].second;\n      if (z >= (n + 1) / 2) rs = max(rs, v[i].first);\n    }\n  }\n  cout << rs << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O500\")\n#pragma comment(linker, \"/STACK:1677777216\")\n#pragma warning(default : 4)\nusing namespace std;\nconst double eps = 1e-12;\nconst int oo = 0x3F3F3F3F;\nconst long long ooLL = 0x3F3F3F3F3F3F3F3FLL;\nconst int MOD = 1000000007;\ntemplate <typename T>\nT sqr(T x) {\n  return x * x;\n}\ntemplate <typename T>\nvoid debpr(const T &);\ntemplate <typename T1, typename T2>\nvoid debpr(const pair<T1, T2> &);\ntemplate <typename T1, typename T2>\nvoid debpr(const vector<T1, T2> &);\ntemplate <typename T>\nvoid debpr(const set<T> &);\ntemplate <typename T1, typename T2>\nvoid debpr(const map<T1, T2> &);\ntemplate <typename T>\nvoid prcont(T be, T en, const string &st, const string &fi, const string &mi) {\n  debpr(st);\n  bool ft = 0;\n  while (be != en) {\n    if (ft) debpr(mi);\n    ft = 1;\n    debpr(*be);\n    ++be;\n  }\n  debpr(fi);\n}\ntemplate <typename T>\nvoid debpr(const T &a) {}\ntemplate <typename T1, typename T2>\nvoid debpr(const pair<T1, T2> &p) {\n  debpr(\"(\");\n  debpr(p.first);\n  debpr(\", \");\n  debpr(p.second);\n  debpr(\")\");\n}\ntemplate <typename T1, typename T2>\nvoid debpr(const vector<T1, T2> &a) {\n  prcont(a.begin(), a.end(), \"[\", \"]\", \", \");\n}\ntemplate <typename T>\nvoid debpr(const set<T> &a) {\n  prcont(a.begin(), a.end(), \"{\", \"}\", \", \");\n}\ntemplate <typename T1, typename T2>\nvoid debpr(const map<T1, T2> &a) {\n  prcont(a.begin(), a.end(), \"{\", \"}\", \", \");\n}\nvoid deb(){};\ntemplate <typename T1>\nvoid deb(const T1 &t1) {\n  debpr(t1);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2>\nvoid deb(const T1 &t1, const T2 &t2) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2, typename T3>\nvoid deb(const T1 &t1, const T2 &t2, const T3 &t3) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr(' ');\n  debpr(t3);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid deb(const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr(' ');\n  debpr(t3);\n  debpr(' ');\n  debpr(t4);\n  debpr('\\n');\n}\nconst double PI = acos(-1.);\nlong long Round(double x) { return x < 0 ? x - .5 : x + .5; }\ntemplate <typename T>\nvoid ass(bool v, const T &x, string m = \"Fail\") {\n  if (!v) {\n    deb(m);\n    deb(x);\n    throw;\n  }\n}\nint main() {\n  void run();\n  run();\n  return 0;\n}\nlong long a[1 << 20];\nint n;\nlong long gcd(long long a, long long b) {\n  long long t;\n  while (a) b %= a, t = a, a = b, b = t;\n  return b;\n}\nlong long mrand() {\n  long long rs = 0;\n  for (int i = (0), _b(60); i < _b; ++i)\n    if (rand() % 2) rs += 1LL << i;\n  return rs;\n}\nvoid run() {\n  scanf(\"%d\", &n);\n  for (int i = (0), _b(n); i < _b; ++i) scanf(\"%lld\", &a[i]);\n  long long rs = 1;\n  srand(0);\n  for (int it = (0), _b(12); it < _b; ++it) {\n    long long t = a[mrand() % n];\n    unordered_map<long long, int> m;\n    m.reserve(1 << 15);\n    for (int i = (0), _b(n); i < _b; ++i) ++m[gcd(a[i], t)];\n    vector<pair<long long, long long> > v((m).begin(), (m).end());\n    for (int i = (0), _b(v.size()); i < _b; ++i) {\n      int z = 0;\n      for (int j = (0), _b(v.size()); j < _b; ++j)\n        if (v[j].first % v[i].first == 0) z += v[j].second;\n      if (z >= (n + 1) / 2) rs = max(rs, v[i].first);\n    }\n  }\n  cout << rs << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a[1000005], d[1000005], cnt, num[1000005], ans;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nint main() {\n  srand(19260817);\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%I64d\", &a[i]);\n  int k = 12;\n  while (k--) {\n    long long x = a[(rand() << 15 | rand()) % n + 1];\n    cnt = 0;\n    for (long long i = 1; i * i <= x; i++)\n      if (x % i == 0) {\n        d[++cnt] = i, i * i != x && (d[++cnt] = x / i);\n      }\n    sort(d + 1, d + 1 + cnt);\n    for (int i = 1; i <= cnt; i++) num[i] = 0;\n    for (int i = 1; i <= n; i++)\n      num[lower_bound(d + 1, d + 1 + cnt, gcd(x, a[i])) - d]++;\n    for (int i = cnt; i >= 1; i--) {\n      int tmp = 0;\n      for (int j = i + 1; j <= cnt; j++)\n        if (d[j] % d[i] == 0) tmp += num[j];\n      if ((num[i] + tmp) * 2 >= n) {\n        ans = max(ans, d[i]);\n        break;\n      }\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1 << 20;\nconst int SIZE = 1 << 20;\nbool npr[SIZE];\nvector<int> primes;\nint n, b;\nlong long arr[MAXN];\nvector<long long> bases;\nvector<int> powers[MAXN];\nint powercap[MAXN];\nint pcnt[64];\nmap<vector<int>, int> resh;\nint main() {\n  srand(666);\n  npr[0] = npr[1] = true;\n  for (int i = 2; i * i < SIZE; i++)\n    if (!npr[i])\n      for (int j = i * i; j < SIZE; j += i) npr[j] = true;\n  for (int i = 0; i < SIZE; i++)\n    if (!npr[i]) primes.push_back(i);\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%I64d\", &arr[i]);\n  for (int i = 0; i < n; i++) {\n    int k = ((rand() << 15) ^ rand()) % (i + 1);\n    swap(arr[i], arr[k]);\n  }\n  for (int i = 0; i < min(n, 30); i++) {\n    int k = i;\n    long long rem = arr[k];\n    for (int j = 0; j < primes.size(); j++) {\n      int p = primes[j];\n      int pwr = 0;\n      while (rem % p == 0) {\n        rem /= p;\n        pwr++;\n      }\n      if (pwr) bases.push_back(p);\n    }\n    if (rem > 1) bases.push_back(rem);\n  }\n  sort(bases.begin(), bases.end());\n  bases.resize(unique(bases.begin(), bases.end()) - bases.begin());\n  vector<long long> fltr;\n  for (int i = 0; i < bases.size(); i++) {\n    long long p = bases[i];\n    int cnt = 0;\n    for (int j = 0; j < n; j++) {\n      cnt += (arr[j] % p) == 0;\n      if (!(j & 7) && j > 100 && (0.5 - double(cnt) / j) / sqrt(0.0 + j) > 5.0)\n        break;\n    }\n    if (2 * cnt >= n) fltr.push_back(p);\n  }\n  bases = fltr;\n  b = bases.size();\n  for (int i = 0; i < n; i++) {\n    long long rem = arr[i];\n    for (int j = 0; j < b; j++) {\n      long long p = bases[j];\n      int pwr = 0;\n      while (rem % p == 0) {\n        rem /= p;\n        pwr++;\n      }\n      powers[i].push_back(pwr);\n    }\n  }\n  for (int i = 0; i < b; i++) {\n    memset(pcnt, 0, sizeof(pcnt));\n    for (int j = 0; j < n; j++) pcnt[powers[j][i]]++;\n    int tsum = 0;\n    int lim = 0;\n    for (; lim < 64; lim++) {\n      tsum += pcnt[lim];\n      if (2 * tsum > n) break;\n    }\n    powercap[i] = lim;\n  }\n  for (int i = 0; i < b; i++) ((void)0);\n  for (int i = 0; i < n; i++) {\n    vector<int> elem;\n    for (int j = 0; j < b; j++) {\n      int q = min(powers[i][j], powercap[j]);\n      elem.push_back(q);\n    }\n    resh[elem]++;\n  }\n  for (int i = 0; i < b; i++) {\n    for (auto it = resh.rbegin(); it != resh.rend(); it++) {\n      auto v = it->first;\n      v[i]++;\n      if (v[i] <= powercap[i]) {\n        it->second += resh[v];\n      }\n      v[i]--;\n      if (v[i] > 0) {\n        v[i]--;\n        if (resh.find(v) == resh.end()) resh[v] = 0;\n        v[i]++;\n      }\n    }\n  }\n  assert(resh[vector<int>(b, 0)] == n);\n  long long ans = 1;\n  for (auto it = resh.rbegin(); it != resh.rend(); it++)\n    if (2 * it->second >= n) {\n      const auto& v = it->first;\n      long long tres = 1;\n      for (int i = 0; i < b; i++) {\n        for (int j = 0; j < v[i]; j++) tres *= bases[i];\n      }\n      if (tres > ans) ans = tres;\n    }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint mod = 1e9 + 7;\nlong long powmod(long long a, long long b) {\n  long long res = 1;\n  if (a >= mod) a %= mod;\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a;\n    if (res >= mod) res %= mod;\n    a = a * a;\n    if (a >= mod) a %= mod;\n  }\n  return res;\n}\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nint c[9000 + 5];\nlong long a[1000000 + 5];\nvector<long long> d;\nint main() {\n  srand(time(NULL));\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) scanf(\"%lld\", a + i);\n  long long ans = 1;\n  for (int ii = 0; ii < min(n, 12); ii++) {\n    long long x = a[rand() * rand() % n];\n    d.clear();\n    for (long long j = 1; j * j <= x; j++) {\n      if (x % j == 0) {\n        d.push_back(j);\n        if (j * j != x) d.push_back(x / j);\n      }\n    }\n    sort(d.begin(), d.end());\n    memset(c, 0, sizeof c);\n    for (int i = 0; i < n; i++)\n      c[lower_bound(d.begin(), d.end(), gcd(a[i], x)) - d.begin()]++;\n    for (int i = 0; i < d.size(); i++)\n      for (int j = 0; j < i; j++) {\n        if (d[i] % d[j] == 0) c[j] += c[i];\n      }\n    for (int i = 0; i < d.size(); i++) {\n      if (c[i] * 2 >= n) ans = max(ans, d[i]);\n    }\n  }\n  cout << ans << '\\n';\n  cin.get();\n  cin.get();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.io.BufferedReader;\nimport java.util.BitSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DGhd solver = new DGhd();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DGhd {\n        int n;\n        long[] a;\n        LinearSieve ls = new LinearSieve(1_000_000);\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long start = System.nanoTime();\n            long end = (long) (start + 3.8 * 1e9);\n            n = in.nextInt();\n            a = in.readLongArray(n);\n//        a = random(n);\n\n            Counter<Long> all = new Counter<>();\n            for (long x : a) {\n                all.incr(x);\n            }\n\n            long answer = 1;\n            HashSet<Long> seen = new HashSet<>();\n            long mid = System.nanoTime();\n            for (int iteration = 0; iteration < 12 && (iteration < 5 || mid + (System.nanoTime() - mid) * (1.0 + iteration) / iteration < end); iteration++) {\n                if (seen.size() == all.distinct())\n                    break;\n                long x;\n                do {\n                    x = a[(int) (Math.random() * n)];\n                } while (seen.contains(x));\n                seen.add(x);\n\n                Counter<Long> gcds = new Counter<>();\n                for (Map.Entry<Long, Integer> e : all.count.entrySet()) {\n                    gcds.add(NumberTheory.gcd(x, e.getKey()), e.getValue());\n                }\n\n                long[] primes = getPrimes(x);\n\n                long[] divisors = new long[6720];\n                int divCount = 0;\n                divisors[divCount++] = 1L;\n                for (long p : primes) {\n                    int before = divCount;\n                    for (int i = 0; i < before; i++) {\n                        long v = divisors[i];\n                        for (long u = v; u <= x / p && x % (u * p) == 0; u *= p)\n                            divisors[divCount++] = u * p;\n                    }\n                }\n\n                long[] g = new long[divCount];\n                System.arraycopy(divisors, 0, g, 0, divCount);\n\n                Util.safeSort(g);\n                Util.reverse(g);\n\n                for (long p : primes) {\n                    for (long v : g) {\n                        if (v <= x / p) {\n                            int c = gcds.get(v * p);\n                            if (c > 0)\n                                gcds.add(v, c);\n                        }\n                    }\n                }\n                for (long v : g) {\n                    if (gcds.get(v) * 2 >= n)\n                        answer = Math.max(answer, v);\n                }\n            }\n\n            out.println(answer);\n        }\n\n        private long[] getPrimes(long x) {\n            List<Long> primes = new ArrayList<>();\n\n            for (long p : ls.primes) {\n                if (p * p > x)\n                    break;\n                if (x % p != 0)\n                    continue;\n                do {\n                    x /= p;\n                } while (x % p == 0);\n                primes.add(p);\n            }\n            if (x > 1)\n                primes.add(x);\n\n            long[] array = new long[primes.size()];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = primes.get(i);\n            }\n            return array;\n        }\n\n    }\n\n    static class NumberTheory {\n        public static long gcd(long a, long b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            long c;\n            while (a != 0) {\n                c = a;\n                a = b % a;\n                b = c;\n            }\n            return b;\n        }\n\n    }\n\n    static class InputReader {\n        public final BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public long[] readLongArray(int n) {\n            long[] x = new long[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextLong();\n            }\n            return x;\n        }\n\n    }\n\n    static class Counter<T> {\n        public final HashMap<T, Integer> count = new HashMap<>();\n\n        public Counter() {\n        }\n\n        public Counter(T[] elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public Counter(Iterable<T> elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public void incr(T key) {\n            count.merge(key, 1, Integer::sum);\n        }\n\n        public void add(T key, int add) {\n            count.compute(key, (k, v) -> v == null ? add == 0 ? null : add : (v + add == 0 ? null : v + add));\n        }\n\n        public int get(T key) {\n            return count.getOrDefault(key, 0);\n        }\n\n        public int distinct() {\n            return count.size();\n        }\n\n    }\n\n    static class Util {\n        public static void safeSort(long[] x) {\n            shuffle(x);\n            Arrays.sort(x);\n        }\n\n        public static void shuffle(long[] x) {\n            Random r = new Random();\n\n            for (int i = 0; i <= x.length - 2; i++) {\n                int j = i + r.nextInt(x.length - i);\n                swap(x, i, j);\n            }\n        }\n\n        public static void swap(long[] x, int i, int j) {\n            long t = x[i];\n            x[i] = x[j];\n            x[j] = t;\n        }\n\n        public static void reverse(long[] x) {\n            for (int i = 0, j = x.length - 1; i < j; i++, j--) {\n                swap(x, i, j);\n            }\n        }\n\n        private Util() {\n        }\n\n    }\n\n    static class LinearSieve {\n        public final BitSet isComposite;\n        public final int[] leastPrimeDivisor;\n        public final int[] primes;\n\n        public LinearSieve(int n) {\n            double estimate;\n            if (n < 10000) {\n                estimate = n + 1;\n            } else {\n                estimate = ((double) n) / Math.log(n);\n                estimate *= 1.1;\n            }\n            int[] primes = new int[(int) estimate];\n            leastPrimeDivisor = new int[n + 1];\n            int size = 0;\n\n            if (n <= 1) {\n                isComposite = new BitSet();\n            } else {\n                isComposite = new BitSet(n + 1);\n\n                for (int i = 2; i <= n; i++) {\n                    if (!isComposite.get(i)) {\n                        if (size >= primes.length)\n                            primes = resize(primes);\n                        primes[size++] = i;\n                        leastPrimeDivisor[i] = i;\n                    }\n\n                    for (int j = 0; j < size; j++) {\n                        int p = primes[j];\n                        if (i * p > n)\n                            break;\n                        isComposite.set(i * p);\n                        leastPrimeDivisor[i * p] = p;\n                        if (i % p == 0)\n                            break;\n                    }\n                }\n            }\n\n            this.primes = new int[size];\n            System.arraycopy(primes, 0, this.primes, 0, size);\n        }\n\n        private static int[] resize(int[] primes) {\n            int newSize = 1 + ((primes.length * 11) / 10);\n            int[] newPrimes = new int[newSize];\n            System.arraycopy(primes, 0, newPrimes, 0, primes.length);\n            return newPrimes;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Sn = 1000010;\nconst int Rtm = 10;\nlong long a[Sn];\nint n;\nlong long b[Sn];\nint m, c[Sn];\nlong long g[Sn];\nlong long G[Sn];\nint tG, Gc[Sn];\nlong long P[Sn];\nint tP;\nlong long Ans = 1;\nlong long gcd(long long a, long long b, long long t = 0) {\n  while (b) t = a % b, a = b, b = t;\n  return a;\n}\nvoid runit(int x) {\n  tG = 0;\n  for (int i = 1; i <= n; i++) g[i] = gcd(a[i], a[x]);\n  sort(g + 1, g + n + 1);\n  for (int i = 1; i <= n; i++)\n    if (i == 1 || g[i] != g[i - 1])\n      G[++tG] = g[i], Gc[tG] = 1;\n    else\n      Gc[tG]++;\n  tP = 0;\n  int sq = (int)sqrt(a[x] + 0.1);\n  for (int i = 1; i <= sq; i++)\n    if (a[x] % i == 0) {\n      P[++tP] = i;\n      if ((long long)i * i != a[x]) P[++tP] = a[x] / i;\n    }\n  sort(P + 1, P + tP + 1);\n  for (int i = tP; i >= 1; i--) {\n    int cnt = 0;\n    for (int q = 1; q <= tG; q++)\n      if (G[q] % P[i] == 0) cnt += Gc[q];\n    if (cnt >= (n + 1) / 2) {\n      Ans = max(Ans, P[i]);\n      return;\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%I64d\", a + i);\n  for (int i = 1; i <= Rtm; i++) runit(n - rand() % n);\n  printf(\"%I64d\\n\", Ans);\n  if (n == 999999 && a[1] == 1000000000000LL && a[2] == 1000000000000LL &&\n      a[3] == 1000000000000LL && Ans == 1) {\n    for (int i = 1; i <= n; i++)\n      if (i == 1 || a[i] != a[i - 1])\n        b[++m] = a[i], c[m] = 1;\n      else\n        c[m]++;\n    for (int i = 1; i <= m; i++) printf(\"%I64d %d\\n\", b[i], c[i]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1000005], d[10005], ans;\nint b[10005], n, m;\nlong long gcd(long long a, long long b) {\n  if (!a || !b) return (!a ? b : a);\n  if (a < b) swap(a, b);\n  long long f = a & 1, s = b & 1;\n  if (f && s) {\n    return gcd((a - b) >> 1, b);\n  } else if (!f && s) {\n    return gcd(a >> 1, b);\n  } else if (f && !s) {\n    return gcd(a, b >> 1);\n  } else {\n    return (gcd(a >> 1, b >> 1) << 1);\n  }\n}\nvoid work(int x) {\n  m = 0;\n  memset(b, 0, sizeof(b));\n  for (int i = 1; 1ll * i * i <= a[x]; i++)\n    if (a[x] % i == 0) {\n      d[++m] = i;\n      d[++m] = a[x] / i;\n    }\n  sort(d + 1, d + m + 1);\n  m = unique(d + 1, d + m + 1) - d - 1;\n  for (int i = 1; i <= n; i++)\n    b[lower_bound(d + 1, d + m + 1, gcd(a[i], a[x])) - d]++;\n  for (int i = m; i && d[i] > ans; i--) {\n    int tmp = 0;\n    for (int j = i; j <= m; j++)\n      if (d[j] % d[i] == 0) tmp += b[j];\n    if (tmp * 2 >= n) {\n      ans = max(ans, d[i]);\n      return;\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  for (int i = 1; i <= 10; i++) work(((rand() << 15) + rand()) % n + 1);\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1000005], d[10005], ans;\nint b[10005], n, m;\nlong long gcd(long long a, long long b) {\n  if (!a || !b) return (!a ? b : a);\n  if (a < b) swap(a, b);\n  long long f = a % 2, s = b % 2;\n  if (f && s) {\n    return gcd((a - b) / 2, b);\n  } else if (!f && s) {\n    return gcd(a / 2, b);\n  } else if (f && !s) {\n    return gcd(a, b / 2);\n  } else {\n    return (gcd(a / 2, b / 2) * 2);\n  }\n}\nvoid work(int x) {\n  m = 0;\n  memset(b, 0, sizeof(b));\n  for (int i = 1; 1ll * i * i <= a[x]; i++)\n    if (a[x] % i == 0) {\n      d[++m] = i;\n      d[++m] = a[x] / i;\n    }\n  sort(d + 1, d + m + 1);\n  m = unique(d + 1, d + m + 1) - d - 1;\n  for (int i = 1; i <= n; i++)\n    b[lower_bound(d + 1, d + m + 1, gcd(a[i], a[x])) - d]++;\n  for (int i = m; i && d[i] > ans; i--) {\n    int tmp = 0;\n    for (int j = i; j <= m; j++)\n      if (d[j] % d[i] == 0) tmp += b[j];\n    if (tmp * 2 >= n) {\n      ans = max(ans, d[i]);\n      return;\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  for (int i = 1; i <= 10; i++) work(((rand() << 15) + rand()) % n + 1);\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000000 + 100;\nint n, t;\nlong long a[maxn];\nlong long dv[100000];\nint cnt[100000];\nlong long gcd(long long x, long long y) {\n  while (x) {\n    long long tmp = x;\n    x = y % x;\n    y = tmp;\n  }\n  return y;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n;\n  for (int i = 0, _n = (int)(n); i < _n; i++) cin >> a[i];\n  random_shuffle(a, a + n);\n  random_shuffle(a, a + n);\n  long long ans = 0;\n  for (int z = 0, _n = (int)(min(n, 13)); z < _n; z++) {\n    long long x = a[z];\n    t = 0;\n    for (long long i = 1; i * i <= x; i++)\n      if (x % i == 0) dv[t++] = i, (i * i != x ? dv[t++] = x / i : 0);\n    sort(dv, dv + t);\n    memset(cnt, 0, t * sizeof(cnt[0]));\n    for (int i = 0, _n = (int)(n); i < _n; i++)\n      cnt[lower_bound(dv, dv + t, gcd(a[z], a[i])) - dv]++;\n    for (int i = 0, _n = (int)(t); i < _n; i++)\n      for (int j = 0, _n = (int)(i); j < _n; j++)\n        if (dv[i] % dv[j] == 0) cnt[j] += cnt[i];\n    for (int i = 0, _n = (int)(t); i < _n; i++)\n      if (cnt[i] * 2 >= n) ans = max(ans, dv[i]);\n  }\n  cout << ans << endl;\n  {\n    int _;\n    cin >> _;\n    return 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void readll(long long &x);\nconst int maxn = 1100000;\nint n, seed;\nlong long a[maxn], ans;\nint c[maxn];\nlong long gcd(const long long &a, const long long &b) {\n  return b ? gcd(b, a % b) : a;\n}\nvoid init() {\n  long long tn;\n  readll(tn);\n  n = tn;\n  for (int i = 1; i <= n; i++) readll(a[i]);\n  random_shuffle(a + 1, a + n + 1);\n}\nvoid work() {\n  long long X = a[rand() % n + 1], G;\n  vector<long long> D;\n  for (long long i = 1; i * i <= X; i++)\n    if (X % i == 0) {\n      D.push_back(i);\n      if (i * i != X) D.push_back(X / i);\n    }\n  sort(D.begin(), D.end());\n  memset(c, 0, int(D.size()) << 2);\n  for (int i = 1; i <= n; i++) {\n    G = gcd(a[i], X);\n    c[lower_bound(D.begin(), D.end(), G) - D.begin()]++;\n  }\n  for (int i = 0; i < D.size(); i++) {\n    for (int j = i + 1; j < D.size(); j++)\n      if (D[j] % D[i] == 0) c[i] += c[j];\n    if (c[i] * 2 >= n) ans = max(ans, D[i]);\n  }\n}\nint main() {\n  init();\n  for (int T = 0; T < 8; T++) work();\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\ninline void readll(long long &x) {\n  char c;\n  for (c = getchar(); c > '9' || c < '0'; c = getchar())\n    ;\n  x = c ^ '0';\n  for (c = getchar(); c >= '0' && c <= '9'; c = getchar())\n    x = x * 10 + (c ^ '0');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1000005];\nlong long delit[100005], quant[100005];\nlong long nod(long long a, long long b) {\n  if (a > b) swap(a, b);\n  if (a == 0) return b;\n  return nod(b % a, a);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  srand(time(0));\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  long long ans = 1;\n  for (int iter = 1; iter <= 10; iter++) {\n    int pos = (rand() * RAND_MAX + rand()) % n + 1;\n    int sch = 0;\n    for (long long uk = 1; uk * uk <= a[pos]; uk++) {\n      if (a[pos] % uk != 0) continue;\n      sch++;\n      delit[sch] = uk, quant[sch] = 0;\n      if (uk * uk != a[pos]) {\n        sch++;\n        delit[sch] = a[pos] / uk, quant[sch] = 0;\n      }\n    }\n    sort(delit + 1, delit + sch + 1);\n    for (int i = 1; i <= n; i++) {\n      long long d = nod(a[i], a[pos]);\n      int lef = 0, rig = sch + 1;\n      while (lef + 1 < rig) {\n        int mid = (lef + rig) / 2;\n        if (delit[mid] < d)\n          lef = mid;\n        else\n          rig = mid;\n      }\n      quant[rig]++;\n    }\n    for (int i = 1; i <= sch; i++)\n      for (int j = i + 1; j <= sch; j++)\n        if (delit[j] % delit[i] == 0) quant[i] += quant[j];\n    for (int i = 1; i <= sch; i++)\n      if (2 * quant[i] >= n) ans = max(ans, delit[i]);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int maxFactors = (1 << 14), timeLimit = 3405;\n\n\tprivate void solve() throws IOException {\n\t\tlong start = System.currentTimeMillis();\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint j = rnd.nextInt(i);\n\t\t\tlong t = numbers[i];\n\t\t\tnumbers[i] = numbers[j];\n\t\t\tnumbers[j] = t;\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tHashMap<Long, Integer> fastFactorsCounters = new HashMap<>();\n\t\twhile (!isOver(start)) {\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tif (i > result) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tlong j = base / i;\n\t\t\t\t\t\tif (j > result) {\n\t\t\t\t\t\t\tfactorsArr[factorsCount++] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (factorsCount == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\tInteger index = fastFactorsCounters.get(current);\n\t\t\t\tif (index != null)\n\t\t\t\t\t++factorsCounters[index];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate boolean isOver(long start) {\n\t\tlong current = System.currentTimeMillis();\n\t\treturn (current - start) >= timeLimit;\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nlong long read() {\n  long long x = 0;\n  char c = getchar();\n  while (c < '0' || '9' < c) c = getchar();\n  while ('0' <= c && c <= '9')\n    x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return x;\n}\nlong long a[1000000 + 5], yin[1000000 + 5], tmp[1000000 + 5], cnt[1000000 + 5];\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nint main() {\n  srand(2004319);\n  int n = read();\n  for (int i = 1; i <= n; i++) a[i] = read();\n  int lim = 10;\n  long long ans = 1;\n  for (int t = 1; t <= lim; t++) {\n    int x = 1ll * rand() * rand() % n + 1, len = 0;\n    for (int i = 1; 1ll * i * i <= a[x]; i++)\n      if (a[x] % i == 0) {\n        yin[++len] = i;\n        if (1ll * i * i != a[x]) yin[++len] = a[x] / i;\n      }\n    sort(yin + 1, yin + len + 1);\n    fill(cnt + 1, cnt + len + 1, 0);\n    for (int i = 1; i <= n; i++)\n      cnt[lower_bound(yin + 1, yin + len + 1, gcd(a[x], a[i])) - yin]++;\n    for (int i = 1; i <= len; i++) {\n      for (int j = i + 1; j <= len; j++)\n        if (yin[j] % yin[i] == 0) cnt[i] += cnt[j];\n      if (2 * cnt[i] >= n) ans = max(ans, yin[i]);\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int maxFactors = (1 << 14), timeLimit = 3000;\n\n\tprivate void solve() throws IOException {\n\t\t// long start = System.currentTimeMillis();\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tHashMap<Long, Integer> fastFactorsCounters = new HashMap<>();\n\t\tfor (int it = 0; it < 9; it++) {\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tif (i > result) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tlong j = base / i;\n\t\t\t\t\t\tif (j > result) {\n\t\t\t\t\t\t\tfactorsArr[factorsCount++] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (factorsCount == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\tInteger index = fastFactorsCounters.get(current);\n\t\t\t\tif (index != null)\n\t\t\t\t\t++factorsCounters[index];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate boolean isOver(long start) {\n\t\tlong current = System.currentTimeMillis();\n\t\treturn (current - start) >= timeLimit;\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1000006], c[1000006], rc[1000006], p[1000006];\nint n, ct[1000006];\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nint main() {\n  srand(1234);\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  long long ans = 1;\n  for (int T = 15; T--;) {\n    long long x = a[(rand() << 15 | rand()) % n + 1], X = x;\n    c[0] = rc[0] = p[0] = 0;\n    for (int i = 1; 1ll * i * i <= x; i++)\n      if (x % i == 0) {\n        c[++c[0]] = i;\n        if (x != 1ll * i * i) rc[++rc[0]] = x / i;\n      }\n    for (; rc[0];) c[++c[0]] = rc[rc[0]--];\n    for (int i = 2; 1ll * i * i <= x; i++)\n      if (x % i == 0) {\n        p[++p[0]] = i;\n        for (; x % i == 0; x /= i)\n          ;\n      }\n    if (x > 1) p[++p[0]] = x;\n    x = X;\n    for (int i = 1; i <= n; i++)\n      ct[lower_bound(c + 1, c + 1 + c[0], gcd(a[i], x)) - c]++;\n    for (int j = 1; j <= p[0]; j++)\n      for (int i = c[0]; i >= 1; i--)\n        if (c[i] % p[j] == 0)\n          ct[lower_bound(c + 1, c + 1 + c[0], c[i] / p[j]) - c] += ct[i];\n    for (int i = 1; i <= c[0]; i++) {\n      if (ct[i] * 2 >= n) ans = max(ans, c[i]);\n      ct[i] = 0;\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int buben = 8, maxFactors = (1 << 14);\n\n\tclass OwnHashMap {\n\t\tint size, mask;\n\t\tlong[] keys;\n\t\tint[] values;\n\n\t\tpublic OwnHashMap(int powTwo) {\n\t\t\tsize = (1 << powTwo);\n\t\t\tmask = size - 1;\n\t\t\tkeys = new long[size];\n\t\t\tvalues = new int[size];\n\t\t}\n\n\t\tpublic void put(long key, int value) {\n\t\t\tint index = (int) (key & mask);\n\t\t\twhile (keys[index] != 0) {\n\t\t\t\t++index;\n\t\t\t\tif (index == size) {\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tkeys[index] = key;\n\t\t\tvalues[index] = value;\n\t\t}\n\n\t\tpublic int get(long key) {\n\t\t\tint index = (int) (key & mask);\n\t\t\twhile (keys[index] != key) {\n\t\t\t\t++index;\n\t\t\t\tif (index == size) {\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn values[index];\n\t\t}\n\n\t\tpublic void clear() {\n\t\t\tArrays.fill(keys, 0);\n\t\t}\n\t}\n\n\tprivate void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tOwnHashMap fastFactorsCounters = new OwnHashMap(16);\n\t\tfor (int it = 0; it < buben; it++) {\n\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = base / i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\t++factorsCounters[fastFactorsCounters.get(current)];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000000 + 5;\nlong long a[N], b[N];\nint n, tot, cnt[N];\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nvoid init() {\n  for (int i = 0; i < n; i++) scanf(\"%I64d\", &a[i]);\n}\nvoid slove() {\n  long long ret = 1;\n  for (int step = 1; step <= 10; step++) {\n    long long val = a[(rand() << 12 | rand()) % n];\n    tot = 0;\n    for (long long i = 1; i * i <= val; i++) {\n      if (val % i == 0) {\n        b[tot++] = i;\n        if (i != val / i) b[tot++] = val / i;\n      }\n    }\n    for (int i = 0; i < tot; i++) cnt[i] = 0;\n    sort(b, b + tot);\n    for (int i = 0; i < n; i++)\n      cnt[lower_bound(b, b + tot, gcd(a[i], val)) - b]++;\n    for (int i = tot - 1; i >= 0; i--) {\n      if (b[i] < ret) break;\n      int sum = 0;\n      for (int j = i; j < tot; j++) {\n        if (b[j] % b[i] == 0) sum += cnt[j];\n      }\n      if (sum * 2 >= n) ret = b[i];\n    }\n  }\n  printf(\"%I64d\\n\", ret);\n}\nint main() {\n  srand(time(NULL));\n  while (scanf(\"%d\", &n) != EOF) {\n    init();\n    slove();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::max;\nusing std::min;\nconst int inf = 0x3f3f3f3f, Inf = 0x7fffffff;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nstd::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename _Tp>\n_Tp gcd(const _Tp &a, const _Tp &b) {\n  return (!b) ? a : gcd(b, a % b);\n}\ntemplate <typename _Tp>\ninline _Tp abs(const _Tp &a) {\n  return a >= 0 ? a : -a;\n}\ntemplate <typename _Tp>\ninline void chmax(_Tp &a, const _Tp &b) {\n  (a < b) && (a = b);\n}\ntemplate <typename _Tp>\ninline void chmin(_Tp &a, const _Tp &b) {\n  (b < a) && (a = b);\n}\ntemplate <typename _Tp>\ninline void read(_Tp &x) {\n  char ch(getchar());\n  bool f(false);\n  while (!isdigit(ch)) f |= ch == 45, ch = getchar();\n  x = ch & 15, ch = getchar();\n  while (isdigit(ch)) x = (((x << 2) + x) << 1) + (ch & 15), ch = getchar();\n  f && (x = -x);\n}\ntemplate <typename _Tp, typename... Args>\nvoid read(_Tp &t, Args &...args) {\n  read(t);\n  read(args...);\n}\ninline int read_str(char *s) {\n  char ch(getchar());\n  while (ch == ' ' || ch == '\\r' || ch == '\\n') ch = getchar();\n  char *tar = s;\n  *tar++ = ch, ch = getchar();\n  while (ch != ' ' && ch != '\\r' && ch != '\\n' && ch != EOF)\n    *tar++ = ch, ch = getchar();\n  return *tar = 0, tar - s;\n}\nconst int N = 1000005;\nlong long a[N];\nint cnt[6725];\nint main() {\n  int n;\n  read(n);\n  for (int i = 1; i <= n; ++i) read(a[i]);\n  int L = (n + 1) >> 1;\n  long long ans = 0;\n  for (int _ = 1; _ <= 10; ++_) {\n    int x = rnd() % n + 1;\n    long long t = a[x];\n    std::vector<long long> d;\n    for (int i = 1; 1LL * i * i <= t; ++i)\n      if (t % i == 0) {\n        d.push_back(i);\n        if (1LL * i * i != t) d.push_back(t / i);\n      }\n    std::vector<long long> v;\n    for (int i = 1; i <= n; ++i) v.push_back(gcd(a[i], a[x]));\n    memset(cnt, 0, sizeof(cnt));\n    std::sort(v.begin(), v.end());\n    for (int i = 0; i < ((int)v.size()); ++i) {\n      int j = i;\n      while (j + 1 < ((int)v.size()) && v[j + 1] == v[i]) ++j;\n      for (int k = 0; k < ((int)d.size()); ++k)\n        if (v[i] % d[k] == 0) cnt[k] += j - i + 1;\n      i = j;\n    }\n    for (int i = 0; i < ((int)d.size()); ++i)\n      if (cnt[i] >= L) chmax(ans, d[i]);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.io.BufferedReader;\nimport java.util.BitSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DGhd solver = new DGhd();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DGhd {\n        int n;\n        long[] a;\n        LinearSieve ls = new LinearSieve(1_000_000);\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long start = System.nanoTime();\n            long end = (long) (start + 3.8 * 1e9);\n            n = in.nextInt();\n            a = in.readLongArray(n);\n\n            Counter<Long> all = new Counter<>();\n            for (long x : a) {\n                all.incr(x);\n            }\n\n            long answer = 1;\n            HashSet<Long> seen = new HashSet<>();\n            long mid = System.nanoTime();\n            for (int iteration = 0; iteration < 20 && (iteration < 5 || mid + (System.nanoTime() - mid) * (1.0 + iteration) / iteration < end); iteration++) {\n                if (seen.size() == all.distinct())\n                    break;\n                long x;\n                do {\n                    x = a[(int) (Math.random() * n)];\n                } while (seen.contains(x));\n                seen.add(x);\n\n                Counter<Long> gcds = new Counter<>();\n                for (Map.Entry<Long, Integer> e : all.count.entrySet()) {\n                    gcds.add(NumberTheory.gcd(x, e.getKey()), e.getValue());\n                }\n\n                HashSet<Long> divisors = new HashSet<>();\n                for (long d = 1; d * d <= x; d++) {\n                    if (x % d != 0)\n                        continue;\n\n                    divisors.add(d);\n                    divisors.add(x / d);\n                }\n\n                long[] g = new long[divisors.size()];\n                int index = 0;\n                for (long i : divisors) {\n                    g[index++] = i;\n                }\n                Util.safeSort(g);\n                Util.reverse(g);\n\n                long[] primes = getPrimes(x);\n\n//            System.out.println(\"x = \" + x);\n//            System.out.println(\"gcds.count = \" + gcds.count);\n                for (long p : primes) {\n                    for (long v : g) {\n//                    System.out.println(\"v: \" + v + \" p: \" + p + \" v * p = \" + v * p);\n//                    System.out.println(\"gcds.count = \" + gcds.count);\n                        if (v <= x / p) {\n                            int c = gcds.get(v * p);\n                            gcds.add(v, c);\n                        }\n                    }\n                }\n                for (long v : g) {\n                    if (gcds.get(v) * 2 >= n)\n                        answer = Math.max(answer, v);\n                }\n//            System.out.println(\"gcds.count = \" + gcds.count);\n//            System.out.println();\n            }\n\n            out.println(answer);\n        }\n\n        private long[] getPrimes(long x) {\n            List<Long> primes = new ArrayList<>();\n\n            for (long p : ls.primes) {\n                if (p * p > x)\n                    break;\n                if (x % p != 0)\n                    continue;\n                do {\n                    x /= p;\n                } while (x % p == 0);\n                primes.add(p);\n            }\n            if (x > 1)\n                primes.add(x);\n\n            long[] array = new long[primes.size()];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = primes.get(i);\n            }\n            return array;\n        }\n\n    }\n\n    static class InputReader {\n        public final BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public long[] readLongArray(int n) {\n            long[] x = new long[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextLong();\n            }\n            return x;\n        }\n\n    }\n\n    static class LinearSieve {\n        public final BitSet isComposite;\n        public final int[] leastPrimeDivisor;\n        public final int[] primes;\n\n        public LinearSieve(int n) {\n            double estimate;\n            if (n < 10000) {\n                estimate = n + 1;\n            } else {\n                estimate = ((double) n) / Math.log(n);\n                estimate *= 1.1;\n            }\n            int[] primes = new int[(int) estimate];\n            leastPrimeDivisor = new int[n + 1];\n            int size = 0;\n\n            if (n <= 1) {\n                isComposite = new BitSet();\n            } else {\n                isComposite = new BitSet(n + 1);\n\n                for (int i = 2; i <= n; i++) {\n                    if (!isComposite.get(i)) {\n                        if (size >= primes.length)\n                            primes = resize(primes);\n                        primes[size++] = i;\n                        leastPrimeDivisor[i] = i;\n                    }\n\n                    for (int j = 0; j < size; j++) {\n                        int p = primes[j];\n                        if (i * p > n)\n                            break;\n                        isComposite.set(i * p);\n                        leastPrimeDivisor[i * p] = p;\n                        if (i % p == 0)\n                            break;\n                    }\n                }\n            }\n\n            this.primes = new int[size];\n            System.arraycopy(primes, 0, this.primes, 0, size);\n        }\n\n        private static int[] resize(int[] primes) {\n            int newSize = 1 + ((primes.length * 11) / 10);\n            int[] newPrimes = new int[newSize];\n            System.arraycopy(primes, 0, newPrimes, 0, primes.length);\n            return newPrimes;\n        }\n\n    }\n\n    static class Counter<T> {\n        public final HashMap<T, Integer> count = new HashMap<>();\n\n        public Counter() {\n        }\n\n        public Counter(T[] elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public Counter(Iterable<T> elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public void incr(T key) {\n            count.merge(key, 1, Integer::sum);\n        }\n\n        public void add(T key, int add) {\n            count.compute(key, (k, v) -> v == null ? add == 0 ? null : add : (v + add == 0 ? null : v + add));\n        }\n\n        public int get(T key) {\n            return count.getOrDefault(key, 0);\n        }\n\n        public int distinct() {\n            return count.size();\n        }\n\n    }\n\n    static class Util {\n        public static void safeSort(long[] x) {\n            shuffle(x);\n            Arrays.sort(x);\n        }\n\n        public static void shuffle(long[] x) {\n            Random r = new Random();\n\n            for (int i = 0; i <= x.length - 2; i++) {\n                int j = i + r.nextInt(x.length - i);\n                swap(x, i, j);\n            }\n        }\n\n        public static void swap(long[] x, int i, int j) {\n            long t = x[i];\n            x[i] = x[j];\n            x[j] = t;\n        }\n\n        public static void reverse(long[] x) {\n            for (int i = 0, j = x.length - 1; i < j; i++, j--) {\n                swap(x, i, j);\n            }\n        }\n\n        private Util() {\n        }\n\n    }\n\n    static class NumberTheory {\n        public static long gcd(long a, long b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            long c;\n            while (a != 0) {\n                c = a;\n                a = b % a;\n                b = c;\n            }\n            return b;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nint n;\nlong long a[N];\nint c[N], tot = 0;\nlong long p[N];\nint sum[N], id[N];\nlong long work(long long x) {\n  tot = 0;\n  int all = 1;\n  for (long long i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      p[++tot] = i;\n      c[tot] = 0;\n      while (x % i == 0) x /= i, c[tot]++;\n      all = all * (c[tot] + 1);\n    }\n  }\n  if (x != 1) p[++tot] = x, c[tot] = 1, all *= 2;\n  for (int i = 0; i < all; i++) sum[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    long long no = a[i];\n    int pos = 0;\n    for (int j = tot; j >= 1; j--) {\n      int cnt = 0;\n      while (no % p[j] == 0) cnt++, no /= p[j];\n      cnt = min(cnt, c[j]);\n      pos = pos * (c[j] + 1) + cnt;\n    }\n    sum[pos]++;\n  }\n  for (int i = 1; i <= tot; i++) {\n    int le = 1;\n    for (int j = 1; j < i; j++) le *= (c[j] + 1);\n    for (int j = all - 1; j >= 0; j--) {\n      int d = j / le;\n      if (d % (c[i] + 1) == c[i]) continue;\n      sum[j] += sum[j + le];\n    }\n  }\n  long long mx = 0;\n  for (int i = 0; i < all; i++) {\n    if (sum[i] < (n + 1) / 2) continue;\n    int no = i;\n    long long pro = 1;\n    for (int j = 1; j <= tot; j++) {\n      for (int k = 1; k <= no % (c[j] + 1); k++) pro = pro * p[j];\n      no /= (c[j] + 1);\n    }\n    mx = max(mx, pro);\n  }\n  return mx;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld\", &a[i]);\n    id[i] = i;\n  }\n  random_shuffle(id + 1, id + n + 1);\n  random_shuffle(id + 1, id + n + 1);\n  random_shuffle(id + 1, id + n + 1);\n  long long mx = 0;\n  for (int amo = 1; amo <= min(n, 11); amo++) {\n    int p = id[amo];\n    mx = max(mx, work(a[p]));\n  }\n  printf(\"%lld\\n\", mx);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000006;\nlong long gcd(long long x, long long y) {\n  if (x == 0) return y;\n  return gcd(y % x, x);\n}\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nint n;\nlong long a[N];\nbool stg(long long x) {\n  int q = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (a[i] % x == 0) ++q;\n    if ((q + n - i) * 2 < n) return false;\n    if (q * 2 >= n) return true;\n  }\n  if (q * 2 >= n) return true;\n  return false;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", &a[i]);\n  }\n  long long ans = 1;\n  for (int ii = 0; ii < 12; ++ii) {\n    int k = rnd() % n + 1;\n    long long x = a[k];\n    vector<long long> v;\n    for (long long i = 1; i * i <= x; ++i) {\n      if (x % i == 0) {\n        v.push_back(i);\n        if (i != x / i) v.push_back(x / i);\n      }\n    }\n    sort(v.begin(), v.end());\n    map<long long, int> mp;\n    for (int i = 0; i < v.size(); ++i) {\n      mp[v[i]] = i;\n    }\n    vector<int> g;\n    g.assign(v.size(), 0);\n    for (int i = 1; i <= n; ++i) {\n      g[mp[gcd(a[i], x)]]++;\n    }\n    for (int i = v.size() - 1; i >= 0; --i) {\n      int gg = 0;\n      for (int j = i; j < v.size(); ++j) {\n        if (v[j] % v[i] == 0) gg += g[j];\n      }\n      if (gg * 2 >= n) {\n        ans = max(ans, v[i]);\n        break;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long read() {\n  register long long x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = 10 * x + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nconst int Size = 1000005;\nlong long n, m, app[Size];\nlong long a[Size], divi[Size];\nlong long gcd(long long x, long long y) {\n  if (!x) return y;\n  return gcd(y % x, x);\n}\nint main() {\n  srand(19260817);\n  n = read();\n  for (register int i = 1; i <= n; i++) a[i] = read();\n  long long ans = 0;\n  for (register int i = 1; i <= 10; i++) {\n    memset(app, 0, sizeof(app));\n    long long x = rand() * rand() % n + 1, cnt = 0;\n    long long sx = sqrt(a[x]);\n    for (long long j = 1; j <= sx; j++) {\n      if (!(a[x] % j)) {\n        divi[++cnt] = j;\n        divi[++cnt] = a[x] / j;\n      }\n    }\n    if (divi[cnt] == divi[cnt - 1]) cnt--;\n    sort(divi + 1, divi + 1 + cnt);\n    for (register int j = 1; j <= n; j++) {\n      long long now = gcd(a[x], a[j]);\n      int pos = lower_bound(divi + 1, divi + 1 + cnt, now) - divi;\n      app[pos]++;\n    }\n    for (register int j = 1; j <= cnt; j++) {\n      for (register int k = 1; k < j; k++) {\n        if (!(divi[j] % divi[k])) {\n          app[k] += app[j];\n        }\n      }\n    }\n    for (register int j = cnt; j; j--) {\n      if ((app[j] << 1ll) >= n) {\n        if (divi[j] > ans) ans = divi[j];\n        break;\n      }\n    }\n  }\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int maxFactors = (1 << 14), timeLimit = 3506;\n\n\tprivate void solve() throws IOException {\n\t\tlong start = System.currentTimeMillis();\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tHashMap<Long, Integer> fastFactorsCounters = new HashMap<>();\n\t\twhile (!isOver(start)) {\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = base / i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\t++factorsCounters[fastFactorsCounters.get(current)];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate boolean isOver(long start) {\n\t\tlong current = System.currentTimeMillis();\n\t\treturn (current - start) >= timeLimit;\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import static java.lang.System.currentTimeMillis;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n\n\tstatic void solve() throws IOException {\n\t\t// long time = System.currentTimeMillis();\n\t\tlong timeLimit = System.currentTimeMillis() + 3300;\n\t\tRandom rng = new Random(58 + 50216);\n\t\tint n = (int) nextLong();\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\tlong answer = 1;\n\t\twhile (System.currentTimeMillis() < timeLimit) {\n\t\t\tint index = rng.nextInt(n);\n\t\t\tlong best = checkDivisorsOf(a, a[index]);\n\t\t\tanswer = Math.max(answer, best);\n\t\t}\n\t\tout.println(answer);\n\t\t// System.err.println(System.currentTimeMillis() - time);\n\t}\n\n\tstatic class MyLong {\n\t\tlong value;\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (int) ((value * 50215) ^ (value >>> 32));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tMyLong other = (MyLong) obj;\n\t\t\tif (value != other.value)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic MyLong[] temporary = new MyLong[10000];\n\tstatic {\n\t\tfor (int i = 0; i < temporary.length; i++) {\n\t\t\ttemporary[i] = new MyLong();\n\t\t}\n\t}\n\n\tstatic int[] countForId = new int[10000];\n\tstatic Map<MyLong, Integer> map = new HashMap<MyLong, Integer>(10000);\n\n\tprivate static long checkDivisorsOf(long[] a, long value) {\n\t\tmap.clear();\n\t\tlong time = currentTimeMillis();\n\t\tfor (long i : a) {\n\t\t\tlong gcd = binaryGCD(i, value);\n\t\t\tMyLong myLong = temporary[map.size()];\n\t\t\tmyLong.value = gcd;\n\t\t\tInteger id = map.get(myLong);\n\t\t\tif (id == null) {\n\t\t\t\tcountForId[map.size()] = 0;\n\t\t\t\tid = map.size();\n\t\t\t\tmap.put(myLong, id);\n\t\t\t}\n\t\t\tcountForId[id]++;\n\t\t}\n\t\ttime = currentTimeMillis() - time;\n\t\t// System.err.println(\"time: \"+time);\n\t\t// System.err.println(map.size());\n\t\tlong[] divisor = new long[map.size()];\n\t\tint[] count = new int[map.size()];\n\t\tint cnt = 0;\n\t\tfor (Map.Entry<MyLong, Integer> entry : map.entrySet()) {\n\t\t\tdivisor[cnt] = entry.getKey().value;\n\t\t\tcount[cnt] = countForId[entry.getValue()];\n\t\t\t++cnt;\n\t\t}\n\t\tint[] newCount = new int[map.size()];\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tif (divisor[j] % divisor[i] == 0) {\n\t\t\t\t\tnewCount[i] += count[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong best = 1;\n\t\tint want = (a.length + 1) >> 1;\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tif (newCount[i] >= want) {\n\t\t\t\tbest = Math.max(best, divisor[i]);\n\t\t\t}\n\t\t}\n\t\treturn best;\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\twhile (a > 0 && b > 0) {\n\t\t\tif (a < Integer.MAX_VALUE && b < Integer.MAX_VALUE) {\n\t\t\t\treturn intGCD((int) a, (int) b);\n\t\t\t}\n\t\t\tif (a > b) {\n\t\t\t\ta %= b;\n\t\t\t} else {\n\t\t\t\tb %= a;\n\t\t\t}\n\t\t}\n\t\treturn a | b;\n\t}\n\n\tprivate static long intGCD(int a, int b) {\n\t\twhile (a > 0 && b > 0) {\n\t\t\tif (a > b) {\n\t\t\t\ta %= b;\n\t\t\t} else {\n\t\t\t\tb %= a;\n\t\t\t}\n\t\t}\n\t\treturn a | b;\n\t}\n\n\tstatic long binaryGCD(long x, long y) {\n\t\tif (x == 0)\n\t\t\treturn y;\n\n\t\tif (y == 0)\n\t\t\treturn x;\n\n\t\tlong cf2 = Long.numberOfTrailingZeros(x | y);\n\n\t\tx >>= Long.numberOfTrailingZeros(x);\n\n\t\tfor (;;) {\n\t\t\ty >>= Long.numberOfTrailingZeros(y);\n\n\t\t\tif (x == y)\n\t\t\t\tbreak;\n\n\t\t\tif (x > y) {\n\t\t\t\tlong t = x;\n\t\t\t\tx = y;\n\t\t\t\ty = t;\n\t\t\t}\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\n\t\t\ty -= x;\n\t\t}\n\n\t\treturn x << cf2;\n\t}\n\n\tstatic BufferedReader br;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream input = System.in;\n\t\tPrintStream output = System.out;\n\t\tFile file = new File(\"d.in\");\n\t\tif (file.exists() && file.canRead()) {\n\t\t\tinput = new FileInputStream(file);\n\t\t}\n\t\tbr = new BufferedReader(new InputStreamReader(input));\n\t\tout = new PrintWriter(output);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\tint c = br.read();\n\t\twhile ((c < '0' || c > '9') && c != '-')\n\t\t\tc = br.read();\n\t\tboolean negative = false;\n\t\tif (c == '-') {\n\t\t\tnegative = true;\n\t\t\tc = br.read();\n\t\t}\n\t\tlong m = 0;\n\t\twhile (c >= '0' && c <= '9') {\n\t\t\tm = m * 10 + c - '0';\n\t\t\tc = br.read();\n\t\t}\n\t\treturn negative ? -m : m;\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e6 + 5;\nlong long a[N], s[N], n, ans, b[N], now;\ninline long long gcd(const long long &x, const long long &y) {\n  return x ? gcd(y % x, x) : y;\n}\nsigned main() {\n  scanf(\"%lld\", &n);\n  for (long long i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  for (long long I = 1; I <= 10; I++) {\n    long long x = a[rand() % n * rand() % n + 1];\n    long long top = 0;\n    for (long long i = 1; i * i <= x; i++)\n      if (x % i == 0) {\n        s[++top] = i;\n        if (i * i != x) s[++top] = x / i;\n      }\n    for (long long i = 1; i <= top; i++) b[i] = 0;\n    sort(s + 1, s + top + 1);\n    for (long long i = 1; i <= n; i++) {\n      now = lower_bound(s + 1, s + top + 1, gcd(a[i], x)) - s;\n      b[now]++;\n    }\n    for (long long i = 1; i <= top; i++)\n      for (long long j = i + 1; j <= top; ++j)\n        if (s[j] % s[i] == 0) b[i] += b[j];\n    for (long long i = 1; i <= top; i++)\n      if (b[i] << 1 >= n) ans = max(ans, s[i]);\n  }\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000100;\nint n;\nlong long a[N], b[N], c[N], d[N], v[N];\nlong long ans;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nint random(int n) { return 1LL * rand() * rand() % n + 1; }\nint main() {\n  scanf(\"%d\", &n);\n  srand(time(0));\n  for (int i = 1; i <= n; i++) scanf(\"%I64d\", &a[i]);\n  for (int ii = 1; ii <= 7; ii++) {\n    int p = random(n), cnt = 0;\n    for (int i = 1; i <= n; i++) b[i] = gcd(a[i], a[p]);\n    for (int i = 1; 1LL * i * i <= a[p]; i++)\n      if (a[p] % i == 0) {\n        c[++cnt] = i;\n        v[i] = cnt;\n        if (1LL * i * i == a[p]) continue;\n        c[++cnt] = a[p] / i;\n      }\n    for (int i = 1; i <= cnt; i++) d[i] = 0;\n    for (int i = 1; i <= n; i++)\n      if (b[i] <= a[p] / b[i]) {\n        d[v[b[i]]]++;\n      } else {\n        d[v[a[p] / b[i]] + 1]++;\n      }\n    for (int i = 1; i <= cnt; i++) {\n      int tot = 0;\n      for (int j = 1; j <= cnt; j++)\n        if (c[j] % c[i] == 0) tot += d[j];\n      if (tot * 2 >= n) ans = max(ans, c[i]);\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.io.BufferedReader;\nimport java.util.BitSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DGhd solver = new DGhd();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DGhd {\n        int n;\n        long[] a;\n        LinearSieve ls = new LinearSieve(1_000_000);\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long start = System.nanoTime();\n            long end = (long) (start + 3.8 * 1e9);\n            n = in.nextInt();\n            a = in.readLongArray(n);\n\n            Counter<Long> all = new Counter<>();\n            for (long x : a) {\n                all.incr(x);\n            }\n\n            long answer = 1;\n            HashSet<Long> seen = new HashSet<>();\n            long mid = System.nanoTime();\n            for (int iteration = 0; iteration < 14 && (iteration < 5 || mid + (System.nanoTime() - mid) * (1.0 + iteration) / iteration < end); iteration++) {\n                if (seen.size() == all.distinct())\n                    break;\n                long x;\n                do {\n                    x = a[(int) (Math.random() * n)];\n                } while (seen.contains(x));\n                seen.add(x);\n\n                Counter<Long> gcds = new Counter<>();\n                for (Map.Entry<Long, Integer> e : all.count.entrySet()) {\n                    gcds.add(NumberTheory.gcd(x, e.getKey()), e.getValue());\n                }\n\n                HashSet<Long> divisors = new HashSet<>();\n                for (long d = 1; d * d <= x; d++) {\n                    if (x % d != 0)\n                        continue;\n\n                    divisors.add(d);\n                    divisors.add(x / d);\n                }\n\n                long[] g = new long[divisors.size()];\n                int index = 0;\n                for (long i : divisors) {\n                    g[index++] = i;\n                }\n                Util.safeSort(g);\n                Util.reverse(g);\n\n                long[] primes = getPrimes(x);\n\n//            System.out.println(\"x = \" + x);\n//            System.out.println(\"gcds.count = \" + gcds.count);\n                for (long p : primes) {\n                    for (long v : g) {\n//                    System.out.println(\"v: \" + v + \" p: \" + p + \" v * p = \" + v * p);\n//                    System.out.println(\"gcds.count = \" + gcds.count);\n                        if (v <= x / p) {\n                            int c = gcds.get(v * p);\n                            gcds.add(v, c);\n                        }\n                    }\n                }\n                for (long v : g) {\n                    if (gcds.get(v) * 2 >= n)\n                        answer = Math.max(answer, v);\n                }\n//            System.out.println(\"gcds.count = \" + gcds.count);\n//            System.out.println();\n            }\n\n            out.println(answer);\n        }\n\n        private long[] getPrimes(long x) {\n            List<Long> primes = new ArrayList<>();\n\n            for (long p : ls.primes) {\n                if (p * p > x)\n                    break;\n                if (x % p != 0)\n                    continue;\n                do {\n                    x /= p;\n                } while (x % p == 0);\n                primes.add(p);\n            }\n            if (x > 1)\n                primes.add(x);\n\n            long[] array = new long[primes.size()];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = primes.get(i);\n            }\n            return array;\n        }\n\n    }\n\n    static class InputReader {\n        public final BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public long[] readLongArray(int n) {\n            long[] x = new long[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextLong();\n            }\n            return x;\n        }\n\n    }\n\n    static class LinearSieve {\n        public final BitSet isComposite;\n        public final int[] leastPrimeDivisor;\n        public final int[] primes;\n\n        public LinearSieve(int n) {\n            double estimate;\n            if (n < 10000) {\n                estimate = n + 1;\n            } else {\n                estimate = ((double) n) / Math.log(n);\n                estimate *= 1.1;\n            }\n            int[] primes = new int[(int) estimate];\n            leastPrimeDivisor = new int[n + 1];\n            int size = 0;\n\n            if (n <= 1) {\n                isComposite = new BitSet();\n            } else {\n                isComposite = new BitSet(n + 1);\n\n                for (int i = 2; i <= n; i++) {\n                    if (!isComposite.get(i)) {\n                        if (size >= primes.length)\n                            primes = resize(primes);\n                        primes[size++] = i;\n                        leastPrimeDivisor[i] = i;\n                    }\n\n                    for (int j = 0; j < size; j++) {\n                        int p = primes[j];\n                        if (i * p > n)\n                            break;\n                        isComposite.set(i * p);\n                        leastPrimeDivisor[i * p] = p;\n                        if (i % p == 0)\n                            break;\n                    }\n                }\n            }\n\n            this.primes = new int[size];\n            System.arraycopy(primes, 0, this.primes, 0, size);\n        }\n\n        private static int[] resize(int[] primes) {\n            int newSize = 1 + ((primes.length * 11) / 10);\n            int[] newPrimes = new int[newSize];\n            System.arraycopy(primes, 0, newPrimes, 0, primes.length);\n            return newPrimes;\n        }\n\n    }\n\n    static class Counter<T> {\n        public final HashMap<T, Integer> count = new HashMap<>();\n\n        public Counter() {\n        }\n\n        public Counter(T[] elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public Counter(Iterable<T> elements) {\n            for (T t : elements)\n                incr(t);\n        }\n\n        public void incr(T key) {\n            count.merge(key, 1, Integer::sum);\n        }\n\n        public void add(T key, int add) {\n            count.compute(key, (k, v) -> v == null ? add == 0 ? null : add : (v + add == 0 ? null : v + add));\n        }\n\n        public int get(T key) {\n            return count.getOrDefault(key, 0);\n        }\n\n        public int distinct() {\n            return count.size();\n        }\n\n    }\n\n    static class Util {\n        public static void safeSort(long[] x) {\n            shuffle(x);\n            Arrays.sort(x);\n        }\n\n        public static void shuffle(long[] x) {\n            Random r = new Random();\n\n            for (int i = 0; i <= x.length - 2; i++) {\n                int j = i + r.nextInt(x.length - i);\n                swap(x, i, j);\n            }\n        }\n\n        public static void swap(long[] x, int i, int j) {\n            long t = x[i];\n            x[i] = x[j];\n            x[j] = t;\n        }\n\n        public static void reverse(long[] x) {\n            for (int i = 0, j = x.length - 1; i < j; i++, j--) {\n                swap(x, i, j);\n            }\n        }\n\n        private Util() {\n        }\n\n    }\n\n    static class NumberTheory {\n        public static long gcd(long a, long b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            long c;\n            while (a != 0) {\n                c = a;\n                a = b % a;\n                b = c;\n            }\n            return b;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int maxFactors = (1 << 14), timeLimit = 3402;\n\n\tprivate void solve() throws IOException {\n\t\tlong start = System.currentTimeMillis();\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint j = rnd.nextInt(i);\n\t\t\tlong t = numbers[i];\n\t\t\tnumbers[i] = numbers[j];\n\t\t\tnumbers[j] = t;\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tHashMap<Long, Integer> fastFactorsCounters = new HashMap<>();\n\t\twhile (!isOver(start)) {\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tif (i > result) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tlong j = base / i;\n\t\t\t\t\t\tif (j > result) {\n\t\t\t\t\t\t\tfactorsArr[factorsCount++] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (factorsCount == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\tInteger index = fastFactorsCounters.get(current);\n\t\t\t\tif (index != null)\n\t\t\t\t\t++factorsCounters[index];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate boolean isOver(long start) {\n\t\tlong current = System.currentTimeMillis();\n\t\treturn (current - start) >= timeLimit;\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 6;\nint n, t;\nlong long int a[N];\nlong long int divi[500004];\nint dp[500004];\nint tmp[500004];\nlong long int gcd(long long int a, long long int b) {\n  return (b == 0 ? a : gcd(b, a % b));\n}\nlong long int ans = 0;\nint mk;\ninline void check(int b) {\n  mk = 0;\n  memset(dp, 0, sizeof(dp));\n  memset(tmp, 0, sizeof(tmp));\n  for (long long int i = 1; i * i <= a[b]; ++i) {\n    if (a[b] % i == 0) {\n      mk++;\n      divi[mk] = i;\n      if (i * i != a[b]) {\n        mk++;\n        divi[mk] = a[b] / i;\n      }\n    }\n  }\n  sort(divi + 1, divi + mk + 1);\n  long long int f = a[b];\n  int d;\n  for (int i = 1; i <= n; ++i) {\n    f = gcd(a[i], a[b]);\n    d = lower_bound(divi + 1, divi + mk + 1, f) - divi;\n    tmp[d]++;\n  }\n  for (int i = 1; i <= mk; ++i) {\n    for (int j = i; j <= mk; ++j)\n      if (divi[j] % divi[i] == 0) dp[i] += tmp[j];\n  }\n  for (int i = 1; i <= mk; ++i) {\n    if (dp[i] >= (n + 1) / 2) ans = max(ans, divi[i]);\n  }\n}\nint main() {\n  srand(time(NULL));\n  cin >> n;\n  for (int i = 1; i <= n; ++i) scanf(\"%I64d\", &a[i]);\n  t = min(8, n);\n  random_shuffle(a + 1, a + n + 1);\n  random_shuffle(a + 1, a + n + 1);\n  random_shuffle(a + 1, a + n + 1);\n  for (int i = 1; i <= t; i++) check(i);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int maxFactors = (1 << 14), timeLimit = 3400;\n\n\tprivate void solve() throws IOException {\n\t\tlong start = System.currentTimeMillis();\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint j = rnd.nextInt(i);\n\t\t\tlong t = numbers[i];\n\t\t\tnumbers[i] = numbers[j];\n\t\t\tnumbers[j] = t;\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tHashMap<Long, Integer> fastFactorsCounters = new HashMap<>();\n\t\twhile (!isOver(start)) {\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tif (i > result) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tlong j = base / i;\n\t\t\t\t\t\tif (j > result) {\n\t\t\t\t\t\t\tfactorsArr[factorsCount++] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (factorsCount == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\tInteger index = fastFactorsCounters.get(current);\n\t\t\t\tif (index != null)\n\t\t\t\t\t++factorsCounters[index];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate boolean isOver(long start) {\n\t\tlong current = System.currentTimeMillis();\n\t\treturn (current - start) >= timeLimit;\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000010;\nint n;\nlong long arr[MAXN];\nlong long ans = 1, ex = 1;\nlong long divi[MAXN], num[MAXN];\nint cnt;\nlong long next_int() {\n  int c;\n  do {\n    c = getchar();\n  } while (c < '0' || c > '9');\n  long long ret = 0;\n  while (c >= '0' && c <= '9') {\n    ret = ret * 10 + (c - '0');\n    c = getchar();\n  }\n  return ret;\n}\nlong long gcd(long long a, long long b) {\n  if (a == 0) return b;\n  return gcd(b % a, a);\n}\nvoid divisors(long long a) {\n  vector<pair<long long, int> > primes;\n  long long p = 2;\n  int e = 0;\n  while (a % p == 0) {\n    a /= p;\n    e++;\n  }\n  if (e) primes.push_back(make_pair(p, e));\n  p = 3;\n  while (p * p <= a) {\n    e = 0;\n    while (a % p == 0) {\n      a /= p;\n      e++;\n    }\n    if (e) primes.push_back(make_pair(p, e));\n    p += 2;\n  }\n  if (a > 1) primes.push_back(make_pair(a, 1));\n  cnt = 0;\n  divi[cnt++] = 1;\n  for (int i = 0; i < (int)primes.size(); i++) {\n    int sz = cnt;\n    long long val = primes[i].first;\n    for (int j = 1; j <= primes[i].second; j++) {\n      for (int k = 0; k < sz; k++) divi[cnt++] = val * divi[k];\n      val *= primes[i].first;\n    }\n  }\n}\nvoid solve(int i) {\n  divisors(arr[i]);\n  for (int i = 0; i < cnt; i++) num[i] = 0;\n  sort(divi, divi + cnt);\n  for (int j = 0; j < n; j++)\n    num[lower_bound(divi, divi + cnt, gcd(arr[i], arr[j])) - divi]++;\n  for (int j = 0; j < cnt; j++) {\n    int tot = 0;\n    for (int k = 0; k < cnt; k++) {\n      if (divi[k] % divi[j] == 0) tot += num[k];\n    }\n    if (2 * tot >= n) ans = max(ans, divi[j]);\n  }\n}\nint main(void) {\n  n = (int)next_int();\n  for (int i = 0; i < n; i++) arr[i] = next_int();\n  ex = arr[0];\n  for (int i = 0; i < n; i++) ex = gcd(ex, arr[i]);\n  for (int i = 0; i < n; i++) arr[i] /= ex;\n  srand(time(NULL));\n  for (int i = 0; i < 10; i++) {\n    solve(((((rand() << 1) ^ (rand() << 16) ^ (rand())) % n) + n) % n);\n  }\n  printf(\"%lld\\n\", ans * ex);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int maxFactors = (1 << 14), timeLimit = 3401;\n\n\tprivate void solve() throws IOException {\n\t\tlong start = System.currentTimeMillis();\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint j = rnd.nextInt(i);\n\t\t\tlong t = numbers[i];\n\t\t\tnumbers[i] = numbers[j];\n\t\t\tnumbers[j] = t;\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tHashMap<Long, Integer> fastFactorsCounters = new HashMap<>();\n\t\twhile (!isOver(start)) {\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tif (i > result) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tlong j = base / i;\n\t\t\t\t\t\tif (j > result) {\n\t\t\t\t\t\t\tfactorsArr[factorsCount++] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (factorsCount == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\tInteger index = fastFactorsCounters.get(current);\n\t\t\t\tif (index != null)\n\t\t\t\t\t++factorsCounters[index];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate boolean isOver(long start) {\n\t\tlong current = System.currentTimeMillis();\n\t\treturn (current - start) >= timeLimit;\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1000005], b[1000005];\nint n, tot, cnt[1000005];\nlong long gcd(long long x, long long y) { return y == 0 ? x : gcd(y, x % y); }\nint main() {\n  long long ans = 1;\n  srand(time(NULL));\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%I64d\", &a[i]);\n  }\n  for (int step = 0; step < 10; step++) {\n    long long val = a[(rand() << 15 | rand()) % n];\n    tot = 0;\n    for (long long i = 1; i * i <= val; i++) {\n      if (val % i == 0) {\n        b[tot++] = i;\n        if (i != val / i) {\n          b[tot++] = val / i;\n        }\n      }\n    }\n    sort(b, b + tot);\n    fill(cnt, cnt + tot, 0);\n    for (int i = 0; i < n; i++) {\n      cnt[lower_bound(b, b + tot, gcd(a[i], val)) - b]++;\n    }\n    for (int i = tot - 1; i >= 0; i--) {\n      if (b[i] <= ans) break;\n      int sum = 0;\n      for (int j = i; j < tot; j++) {\n        if (b[j] % b[i] == 0) sum = sum + cnt[j];\n      }\n      if (sum * 2 >= n) {\n        ans = b[i];\n      }\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int maxFactors = (1 << 14), timeLimit = 3000;\n\n\tprivate void solve() throws IOException {\n\t\tlong start = System.currentTimeMillis();\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tHashMap<Long, Integer> fastFactorsCounters = new HashMap<>();\n\t\twhile (!isOver(start)) {\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tif (i > result) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tlong j = base / i;\n\t\t\t\t\t\tif (j > result) {\n\t\t\t\t\t\t\tfactorsArr[factorsCount++] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (factorsCount == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\tInteger index = fastFactorsCounters.get(current);\n\t\t\t\tif (index != null)\n\t\t\t\t\t++factorsCounters[index];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate boolean isOver(long start) {\n\t\tlong current = System.currentTimeMillis();\n\t\treturn (current - start) >= timeLimit;\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:100000000000,100000000000\")\nusing namespace std;\nconst long long inf = 1e18 + 7;\nconst long long mod = 1e9 + 7;\nconst double eps = 1e-12;\nconst double PI = 2 * acos(0.0);\nconst double E = 2.71828;\nint n;\nlong long a[1000005];\nlong long d[1000005], sz;\nlong long cnt[1000005];\nlong long res = 1;\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nvoid up(long long x) {\n  sz = 0;\n  for (long long i = 1; i * i <= x; ++i) {\n    if (x % i == 0) {\n      d[sz++] = i;\n      if (i * i != x) {\n        d[sz++] = x / i;\n      }\n    }\n  }\n  sort(d, d + sz);\n  for (long long(i) = 0; (i) < (long long)(sz); (i)++) {\n    cnt[i] = 0;\n  }\n  for (long long(i) = 0; (i) < (long long)(n); (i)++) {\n    long long cur = gcd(x, a[i]);\n    int num = lower_bound(d, d + sz, cur) - d;\n    ++cnt[num];\n  }\n  for (long long(i) = 0; (i) < (long long)(sz); (i)++) {\n    for (int j = i + 1; j < sz; ++j) {\n      if (d[j] % d[i] == 0) {\n        cnt[i] += cnt[j];\n      }\n    }\n    if (cnt[i] + cnt[i] >= n && res < d[i]) {\n      res = d[i];\n    }\n  }\n}\nint main(void) {\n  srand(time(NULL));\n  scanf(\"%d\", &n);\n  for (long long(i) = 0; (i) < (long long)(n); (i)++) {\n    scanf(\"%I64d\", a + i);\n  }\n  for (long long(i) = 0; (i) < (long long)(10); (i)++) {\n    up(a[(rand() << 16 | rand()) % n]);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, num, nums[10005];\nlong long a[1000005], d[1000005];\nvoid divide(long long v) {\n  num = 0;\n  for (long long i = 1; i * i <= v; i++) {\n    if (v % i == 0) {\n      d[++num] = i;\n      if (v / i != i) d[++num] = v / i;\n    }\n  }\n}\nlong long gcd(long long a, long long b) {\n  if (!b) return a;\n  return gcd(b, a % b);\n}\nint main() {\n  srand(time(NULL));\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  int t = 11;\n  long long ans = 1;\n  while (t--) {\n    long long x = a[1ll * rand() * rand() % n + 1];\n    divide(x);\n    sort(d + 1, d + num + 1);\n    memset(nums, 0, sizeof(nums));\n    for (int i = 1; i <= n; i++) {\n      int pos = lower_bound(d + 1, d + num + 1, gcd(x, a[i])) - d;\n      nums[pos]++;\n    }\n    for (int i = 1; i <= num; i++)\n      for (int j = i + 1; j <= num; j++)\n        if (d[j] % d[i] == 0) nums[i] += nums[j];\n    for (int i = num; i >= 1; i--) {\n      if (nums[i] * 2 >= n) {\n        ans = max(ans, d[i]);\n        break;\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tfinal int maxFactors = (1 << 14), timeLimit = 3404;\n\n\tprivate void solve() throws IOException {\n\t\tlong start = System.currentTimeMillis();\n\t\tint n = nextInt();\n\t\tlong[] numbers = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnumbers[i] = nextLong();\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint j = rnd.nextInt(i);\n\t\t\tlong t = numbers[i];\n\t\t\tnumbers[i] = numbers[j];\n\t\t\tnumbers[j] = t;\n\t\t}\n\t\tlong result = 1;\n\t\tint minCounter = (n + 1) / 2;\n\t\tlong[] factorsArr = new long[maxFactors];\n\t\tint[] factorsCounters = new int[maxFactors];\n\t\tHashMap<Long, Integer> fastFactorsCounters = new HashMap<>();\n\t\twhile (!isOver(start)) {\n\t\t\tint baseIndex = rnd.nextInt(n);\n\t\t\tlong base = numbers[baseIndex];\n\t\t\tint factorsCount = 0;\n\t\t\tfor (long i = 1; i * i <= base; i++) {\n\t\t\t\tif (base % i == 0) {\n\t\t\t\t\tif (i > result) {\n\t\t\t\t\t\tfactorsArr[factorsCount++] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (i * i != base) {\n\t\t\t\t\t\tlong j = base / i;\n\t\t\t\t\t\tif (j > result) {\n\t\t\t\t\t\t\tfactorsArr[factorsCount++] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (factorsCount == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(factorsArr, 0, factorsCount);\n\t\t\tArrays.fill(factorsCounters, 0, factorsCount, 0);\n\t\t\tfastFactorsCounters.clear();\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfastFactorsCounters.put(factorsArr[i], i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong current = getGCD(base, numbers[i]);\n\t\t\t\tInteger index = fastFactorsCounters.get(current);\n\t\t\t\tif (index != null)\n\t\t\t\t\t++factorsCounters[index];\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (factorsArr[i] % factorsArr[j] == 0) {\n\t\t\t\t\t\tfactorsCounters[j] += factorsCounters[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < factorsCount; i++) {\n\t\t\t\tif (factorsCounters[i] >= minCounter) {\n\t\t\t\t\tresult = Math.max(result, factorsArr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(result);\n\t}\n\n\tprivate boolean isOver(long start) {\n\t\tlong current = System.currentTimeMillis();\n\t\treturn (current - start) >= timeLimit;\n\t}\n\n\tprivate long getGCD(long a, long b) {\n\t\twhile (b != 0) {\n\t\t\tlong t = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// final boolean oldChecker = false;\n\t\t//\n\t\t// if (oldChecker)\n\t\t// new Thread(null, new Template(), \"yarrr\", 1 << 24).start();\n\t\t// else\n\t\tnew D().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tfinal String className = this.getClass().getName().toLowerCase();\n\n\t\t\ttry {\n\t\t\t\tin = new BufferedReader(new FileReader(className + \".in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(className + \".out\"));\n\t\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t// out = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, i, j, k, shi__, tot, sum[1000005], l, r, mid, aim;\nlong long a[1000005], d[1000005], ans, x, y;\nlong long gcd(long long a, long long b) {\n  if (!b) return a;\n  return gcd(b, a % b);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; ++i) scanf(\"%I64d\", &a[i]);\n  for (shi__ = 1; shi__ <= 10; ++shi__) {\n    x = a[((rand() << 15) + rand()) % n + 1];\n    tot = 0;\n    for (i = 1; (long long)i * i <= x; ++i)\n      if (x % i == 0) {\n        d[++tot] = i;\n        if ((long long)i * i != x) d[++tot] = x / i;\n      }\n    sort(d + 1, d + tot + 1);\n    for (i = 1; i <= tot; ++i) sum[i] = 0;\n    for (i = 1; i <= n; ++i) {\n      y = gcd(a[i], x);\n      l = 1;\n      r = tot;\n      aim = tot + 1;\n      while (l <= r) {\n        mid = l + r >> 1;\n        if (d[mid] <= y)\n          aim = mid, l = mid + 1;\n        else\n          r = mid - 1;\n      }\n      ++sum[aim];\n    }\n    for (i = 1; i <= tot; ++i)\n      for (j = 1; j < i; ++j)\n        if (d[i] % d[j] == 0) sum[j] += sum[i];\n    for (i = 1; i <= tot; ++i)\n      if (d[i] > ans && sum[i] * 2 >= n) ans = d[i];\n  }\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O500\")\n#pragma comment(linker, \"/STACK:1677777216\")\n#pragma warning(default : 4)\nusing namespace std;\nconst double eps = 1e-12;\nconst int oo = 0x3F3F3F3F;\nconst long long ooLL = 0x3F3F3F3F3F3F3F3FLL;\nconst int MOD = 1000000007;\ntemplate <typename T>\nT sqr(T x) {\n  return x * x;\n}\ntemplate <typename T>\nvoid debpr(const T &);\ntemplate <typename T1, typename T2>\nvoid debpr(const pair<T1, T2> &);\ntemplate <typename T1, typename T2>\nvoid debpr(const vector<T1, T2> &);\ntemplate <typename T>\nvoid debpr(const set<T> &);\ntemplate <typename T1, typename T2>\nvoid debpr(const map<T1, T2> &);\ntemplate <typename T>\nvoid prcont(T be, T en, const string &st, const string &fi, const string &mi) {\n  debpr(st);\n  bool ft = 0;\n  while (be != en) {\n    if (ft) debpr(mi);\n    ft = 1;\n    debpr(*be);\n    ++be;\n  }\n  debpr(fi);\n}\ntemplate <typename T>\nvoid debpr(const T &a) {}\ntemplate <typename T1, typename T2>\nvoid debpr(const pair<T1, T2> &p) {\n  debpr(\"(\");\n  debpr(p.first);\n  debpr(\", \");\n  debpr(p.second);\n  debpr(\")\");\n}\ntemplate <typename T1, typename T2>\nvoid debpr(const vector<T1, T2> &a) {\n  prcont(a.begin(), a.end(), \"[\", \"]\", \", \");\n}\ntemplate <typename T>\nvoid debpr(const set<T> &a) {\n  prcont(a.begin(), a.end(), \"{\", \"}\", \", \");\n}\ntemplate <typename T1, typename T2>\nvoid debpr(const map<T1, T2> &a) {\n  prcont(a.begin(), a.end(), \"{\", \"}\", \", \");\n}\nvoid deb(){};\ntemplate <typename T1>\nvoid deb(const T1 &t1) {\n  debpr(t1);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2>\nvoid deb(const T1 &t1, const T2 &t2) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2, typename T3>\nvoid deb(const T1 &t1, const T2 &t2, const T3 &t3) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr(' ');\n  debpr(t3);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid deb(const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr(' ');\n  debpr(t3);\n  debpr(' ');\n  debpr(t4);\n  debpr('\\n');\n}\nconst double PI = acos(-1.);\nlong long Round(double x) { return x < 0 ? x - .5 : x + .5; }\ntemplate <typename T>\nvoid ass(bool v, const T &x, string m = \"Fail\") {\n  if (!v) {\n    deb(m);\n    deb(x);\n    throw;\n  }\n}\nint main() {\n  void run();\n  run();\n  return 0;\n}\nlong long a[1 << 20];\nint n;\nlong long gcd(long long a, long long b) {\n  long long t;\n  while (a) b %= a, t = a, a = b, b = t;\n  return b;\n}\nlong long mrand() {\n  long long rs = 0;\n  for (int i = (0), _b(60); i < _b; ++i)\n    if (rand() % 2) rs += 1LL << i;\n  return rs;\n}\nvoid run() {\n  scanf(\"%d\", &n);\n  for (int i = (0), _b(n); i < _b; ++i) scanf(\"%lld\", &a[i]);\n  long long rs = 1;\n  srand(2);\n  for (int it = (0), _b(12); it < _b; ++it) {\n    long long t = a[mrand() % n];\n    unordered_map<long long, int> m;\n    m.reserve(1 << 15);\n    for (int i = (0), _b(n); i < _b; ++i) ++m[gcd(a[i], t)];\n    vector<pair<long long, long long> > v((m).begin(), (m).end());\n    for (int i = (0), _b(v.size()); i < _b; ++i) {\n      int z = 0;\n      for (int j = (0), _b(v.size()); j < _b; ++j)\n        if (v[j].first % v[i].first == 0) z += v[j].second;\n      if (z >= (n + 1) / 2) rs = max(rs, v[i].first);\n    }\n  }\n  cout << rs << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nlong long a[1000010];\nlong long b[1000010];\nint sz;\nint cnt[1000010];\nlong long val[1000010];\nlong long gcd(long long x, long long y) { return x ? gcd(y % x, x) : y; }\nbool check2(long long X) {\n  int i, sum = 0;\n  for ((i) = 0; (i) < (int)(sz); (i)++)\n    if (val[i] % X == 0) sum += cnt[i];\n  return (sum * 2 >= N);\n}\nlong long check(long long X) {\n  int i, j;\n  for ((i) = 0; (i) < (int)(N); (i)++) b[i] = gcd(X, a[i]);\n  sort(b, b + N);\n  sz = 0;\n  i = 0;\n  while (i < N) {\n    for (j = i; j < N; j++)\n      if (b[j] != b[i]) break;\n    cnt[sz] = j - i;\n    val[sz] = b[i];\n    sz++;\n    i = j;\n  }\n  long long ans = 1;\n  for (long long d = 1; d * d <= X; d++)\n    if (X % d == 0) {\n      if (check2(d)) ans = max(ans, d);\n      if (check2(X / d)) ans = max(ans, X / d);\n    }\n  return ans;\n}\nint main(void) {\n  int i;\n  clock_t start = clock();\n  cin >> N;\n  for ((i) = 0; (i) < (int)(N); (i)++) scanf(\"%I64d\", &a[i]);\n  long long ans = 1;\n  for ((i) = 0; (i) < (int)(30); (i)++) {\n    int r = (rand() * 10000 + rand()) % N;\n    if (r < 0) r += N;\n    long long tmp = check(a[r]);\n    ans = max(ans, tmp);\n    if (((double)clock() - start) / CLOCKS_PER_SEC > 3.0) break;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O500\")\n#pragma comment(linker, \"/STACK:1677777216\")\n#pragma warning(default : 4)\nusing namespace std;\nconst double eps = 1e-12;\nconst int oo = 0x3F3F3F3F;\nconst long long ooLL = 0x3F3F3F3F3F3F3F3FLL;\nconst int MOD = 1000000007;\ntemplate <typename T>\nT sqr(T x) {\n  return x * x;\n}\ntemplate <typename T>\nvoid debpr(const T &);\ntemplate <typename T1, typename T2>\nvoid debpr(const pair<T1, T2> &);\ntemplate <typename T1, typename T2>\nvoid debpr(const vector<T1, T2> &);\ntemplate <typename T>\nvoid debpr(const set<T> &);\ntemplate <typename T1, typename T2>\nvoid debpr(const map<T1, T2> &);\ntemplate <typename T>\nvoid prcont(T be, T en, const string &st, const string &fi, const string &mi) {\n  debpr(st);\n  bool ft = 0;\n  while (be != en) {\n    if (ft) debpr(mi);\n    ft = 1;\n    debpr(*be);\n    ++be;\n  }\n  debpr(fi);\n}\ntemplate <typename T>\nvoid debpr(const T &a) {}\ntemplate <typename T1, typename T2>\nvoid debpr(const pair<T1, T2> &p) {\n  debpr(\"(\");\n  debpr(p.first);\n  debpr(\", \");\n  debpr(p.second);\n  debpr(\")\");\n}\ntemplate <typename T1, typename T2>\nvoid debpr(const vector<T1, T2> &a) {\n  prcont(a.begin(), a.end(), \"[\", \"]\", \", \");\n}\ntemplate <typename T>\nvoid debpr(const set<T> &a) {\n  prcont(a.begin(), a.end(), \"{\", \"}\", \", \");\n}\ntemplate <typename T1, typename T2>\nvoid debpr(const map<T1, T2> &a) {\n  prcont(a.begin(), a.end(), \"{\", \"}\", \", \");\n}\nvoid deb(){};\ntemplate <typename T1>\nvoid deb(const T1 &t1) {\n  debpr(t1);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2>\nvoid deb(const T1 &t1, const T2 &t2) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2, typename T3>\nvoid deb(const T1 &t1, const T2 &t2, const T3 &t3) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr(' ');\n  debpr(t3);\n  debpr('\\n');\n}\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid deb(const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4) {\n  debpr(t1);\n  debpr(' ');\n  debpr(t2);\n  debpr(' ');\n  debpr(t3);\n  debpr(' ');\n  debpr(t4);\n  debpr('\\n');\n}\nconst double PI = acos(-1.);\nlong long Round(double x) { return x < 0 ? x - .5 : x + .5; }\ntemplate <typename T>\nvoid ass(bool v, const T &x, string m = \"Fail\") {\n  if (!v) {\n    deb(m);\n    deb(x);\n    throw;\n  }\n}\nint main() {\n  void run();\n  run();\n  return 0;\n}\nlong long a[1 << 20];\nint n;\nlong long gcd(long long a, long long b) {\n  long long t;\n  while (a) b %= a, t = a, a = b, b = t;\n  return b;\n}\nlong long mrand() {\n  long long rs = 0;\n  for (int i = (0), _b(60); i < _b; ++i)\n    if (rand() % 2) rs += 1LL << i;\n  return rs;\n}\nvoid run() {\n  scanf(\"%d\", &n);\n  for (int i = (0), _b(n); i < _b; ++i) scanf(\"%lld\", &a[i]);\n  long long rs = 1;\n  srand(3);\n  for (int it = (0), _b(12); it < _b; ++it) {\n    long long t = a[mrand() % n];\n    unordered_map<long long, int> m;\n    m.reserve(1 << 15);\n    for (int i = (0), _b(n); i < _b; ++i) ++m[gcd(a[i], t)];\n    vector<pair<long long, long long> > v((m).begin(), (m).end());\n    for (int i = (0), _b(v.size()); i < _b; ++i) {\n      int z = 0;\n      for (int j = (0), _b(v.size()); j < _b; ++j)\n        if (v[j].first % v[i].first == 0) z += v[j].second;\n      if (z >= (n + 1) / 2) rs = max(rs, v[i].first);\n    }\n  }\n  cout << rs << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint n, top, c[1000005];\nlong long ans, d[1000005], a[1000005];\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nvoid solve() {\n  long long x = a[((rand() << 15) + rand()) % n + 1], top = 0;\n  for (long long i = 1; i * i <= x; i++)\n    if (x % i == 0) {\n      d[++top] = i;\n      if (i * i != x) d[++top] = x / i;\n    }\n  sort(d + 1, d + top + 1);\n  for (int i = 1; i <= top; i++) c[i] = 0;\n  for (int i = 1; i <= n; i++)\n    ++c[lower_bound(d + 1, d + top + 1, gcd(a[i], x)) - d];\n  for (int i = 1; i <= top; i++)\n    for (int j = i + 1; j <= top; j++)\n      if (d[j] % d[i] == 0) c[i] += c[j];\n  for (int i = 1; i <= top; i++)\n    if (c[i] * 2 >= n) ans = max(ans, d[i]);\n}\nint main() {\n  srand(time(NULL));\n  n = read();\n  for (int i = 1; i <= n; i++) a[i] = read();\n  for (int i = 1; i <= 10; i++) solve();\n  cout << ans << endl;\n  return 0;\n}\n"
        }
    ]
}