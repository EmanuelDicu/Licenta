{
    "name": "1562_E. Rescue Niwen!",
    "source": "CODEFORCES",
    "description": "Morning desert sun horizon\n\nRise above the sands of time...\n\nFates Warning, \"Exodus\"\n\nAfter crossing the Windswept Wastes, Ori has finally reached the Windtorn Ruins to find the Heart of the Forest! However, the ancient repository containing this priceless Willow light did not want to open!\n\nOri was taken aback, but the Voice of the Forest explained to him that the cunning Gorleks had decided to add protection to the repository.\n\nThe Gorleks were very fond of the \"string expansion\" operation. They were also very fond of increasing subsequences.\n\nSuppose a string s_1s_2s_3 \u2026 s_n is given. Then its \"expansion\" is defined as the sequence of strings s_1, s_1 s_2, ..., s_1 s_2 \u2026 s_n, s_2, s_2 s_3, ..., s_2 s_3 \u2026 s_n, s_3, s_3 s_4, ..., s_{n-1} s_n, s_n. For example, the \"expansion\" the string 'abcd' will be the following sequence of strings: 'a', 'ab', 'abc', 'abcd', 'b', 'bc', 'bcd', 'c', 'cd', 'd'. \n\nTo open the ancient repository, Ori must find the size of the largest increasing subsequence of the \"expansion\" of the string s. Here, strings are compared lexicographically.\n\nHelp Ori with this task!\n\nA string a is lexicographically smaller than a string b if and only if one of the following holds:\n\n  * a is a prefix of b, but a \u2260 b;\n  * in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\n\nInput\n\nEach test contains multiple test cases.\n\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\n\nThe first line of each test case contains one positive integer n (1 \u2264 n \u2264 5000) \u2014 length of the string.\n\nThe second line of each test case contains a non-empty string of length n, which consists of lowercase latin letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\n\nOutput\n\nFor every test case print one non-negative integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ncba\n6\nsparky\n\n\nOutput\n\n\n9\n17\n12\n29\n14\n3\n9\n\nNote\n\nIn first test case the \"expansion\" of the string is: 'a', 'ac', 'acb', 'acba', 'acbac', 'c', 'cb', 'cba', 'cbac', 'b', 'ba', 'bac', 'a', 'ac', 'c'. The answer can be, for example, 'a', 'ac', 'acb', 'acba', 'acbac', 'b', 'ba', 'bac', 'c'.",
    "difficulty": "E",
    "tags": [
        "dp",
        "greedy",
        "string suffix structures",
        "strings"
    ],
    "rating": 2500,
    "public_test": [
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ncba\n6\nsparky\n",
            "output": "9\n17\n12\n29\n14\n3\n9\n"
        }
    ],
    "generated_test": [
        {
            "input": "1\n10\ngepardotpp\n",
            "output": "27\n"
        },
        {
            "input": "7\n1\na\n2\naa\n2\nab\n2\nba\n2\nbc\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n3\n351\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n12\n29\n14\n3\n9\n"
        },
        {
            "input": "1\n10\npptodrapeg\n",
            "output": "26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabd\n6\nsparky\n",
            "output": "9\n17\n12\n29\n14\n6\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaaacd\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n12\n29\n12\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nab\n2\nba\n2\nbc\n26\nabcdeqghijklmnopfrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n3\n320\n26\n"
        },
        {
            "input": "7\n1\na\n2\naa\n2\nab\n2\nba\n2\nbb\n26\nabcdefghijklmnopqrstuvwxzz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n2\n350\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ndba\n6\nsparky\n",
            "output": "9\n21\n12\n29\n14\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabd\n6\nsparky\n",
            "output": "9\n21\n12\n29\n14\n6\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\nccbaaadd\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n12\n29\n11\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nab\n2\nab\n2\nbc\n26\nabcdeqghijklmnopfrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n3\n3\n320\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\ncadabacaba\n8\nccbaaadd\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n12\n19\n11\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nab\n2\nba\n2\nbc\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n3\n296\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\ncadabacaba\n8\ncabcaadd\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n12\n19\n20\n3\n9\n"
        },
        {
            "input": "1\n10\npotodrapeg\n",
            "output": "18\n"
        },
        {
            "input": "1\n10\negpardotpp\n",
            "output": "36\n"
        },
        {
            "input": "7\n1\na\n2\nab\n2\nab\n2\nba\n2\nbc\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n3\n3\n2\n3\n351\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacababba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaaacd\n3\ndba\n6\nsparky\n",
            "output": "9\n15\n12\n29\n12\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabd\n6\nsparky\n",
            "output": "9\n22\n12\n29\n14\n6\n9\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nab\n2\nba\n2\ncb\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n2\n296\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\ncadabaaabc\n8\ncabcaadd\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n12\n18\n20\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\nab\n2\nba\n2\nbd\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqhonmlkjipgfedcba\n",
            "output": "1\n2\n3\n2\n3\n296\n39\n"
        },
        {
            "input": "7\n1\na\n2\nab\n2\nbb\n2\nba\n2\nbc\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n3\n2\n2\n3\n351\n26\n"
        },
        {
            "input": "7\n5\ncbaca\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabc\n6\nspbrky\n",
            "output": "6\n17\n12\n29\n14\n6\n9\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nbb\n2\nba\n2\nbc\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n2\n2\n3\n351\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nbac\n6\nsparky\n",
            "output": "9\n22\n12\n29\n14\n4\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nbac\n6\nykraps\n",
            "output": "9\n22\n12\n29\n14\n4\n10\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ncba\n6\nsparky\n",
            "output": "9\n22\n12\n29\n14\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ncba\n6\nykraps\n",
            "output": "9\n22\n12\n29\n14\n3\n10\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbabacd\n3\ncba\n6\nykraps\n",
            "output": "9\n22\n12\n29\n12\n3\n10\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbabacd\n3\ncba\n6\nykrspa\n",
            "output": "9\n22\n12\n29\n12\n3\n12\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabbabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbabacd\n3\ncba\n6\nykrspa\n",
            "output": "9\n18\n12\n29\n12\n3\n12\n"
        },
        {
            "input": "7\n5\nacbad\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ndba\n6\nsparky\n",
            "output": "10\n17\n12\n29\n14\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ndba\n6\nykqaps\n",
            "output": "9\n17\n12\n29\n14\n3\n10\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabdd\n3\ncab\n6\nsparky\n",
            "output": "9\n17\n12\n29\n13\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\naaacabbdac\n8\ndcbaabcd\n3\ndba\n6\nsparky\n",
            "output": "9\n21\n12\n35\n14\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\nccbaaadd\n3\ndba\n6\nsparky\n",
            "output": "9\n21\n12\n29\n11\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaba\n10\ncadabacaba\n8\nccbaaadd\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n32\n19\n11\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\naa\n2\nba\n2\nbd\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n2\n2\n3\n296\n26\n"
        },
        {
            "input": "7\n1\na\n2\nab\n2\nab\n2\nba\n2\nbc\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n3\n3\n2\n3\n296\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaaacd\n3\ndba\n6\nykqaps\n",
            "output": "9\n17\n12\n29\n12\n3\n10\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabadba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaaacd\n3\ndaa\n6\nsparky\n",
            "output": "9\n18\n12\n29\n12\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaba\n10\ncdaabacaba\n8\nccbaaadd\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n32\n24\n11\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\nba\n2\nba\n2\nad\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqhonmlkjipgfedcba\n",
            "output": "1\n2\n2\n2\n3\n296\n39\n"
        },
        {
            "input": "1\n10\nppotdsaoeg\n",
            "output": "17\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\nbb\n2\nba\n2\nbc\n26\nzyxwvutsrqponmlkjihgfedcba\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n2\n2\n3\n26\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\nabacabadab\n8\nbcbaadcd\n3\nabc\n6\nsparky\n",
            "output": "9\n21\n12\n29\n18\n6\n9\n"
        },
        {
            "input": "7\n5\nacbbc\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\nccbaaadd\n3\ndba\n6\nsqarky\n",
            "output": "10\n21\n12\n29\n11\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\nba\n2\nab\n2\nad\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqhonmlkjipgfedcba\n",
            "output": "1\n2\n2\n3\n3\n296\n39\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\nba\n2\nab\n2\nad\n26\nzyxwvitsrfponmlkjuhgqedcba\n26\nzyxwvutsrqhonmlkjipgfedcba\n",
            "output": "1\n2\n2\n3\n3\n50\n39\n"
        },
        {
            "input": "1\n10\ngtpardoeop\n",
            "output": "24\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaabaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ncba\n6\nsparky\n",
            "output": "9\n17\n44\n29\n14\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\naa\n2\nab\n2\nab\n2\nbc\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n3\n3\n351\n26\n"
        },
        {
            "input": "1\n10\nptpodrapeg\n",
            "output": "19\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\ncadabacaba\n8\ndcbaaacd\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n12\n19\n12\n3\n9\n"
        },
        {
            "input": "1\n10\nootpdrapeg\n",
            "output": "30\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabacb\n12\naaaaaaabaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabd\n6\nsparky\n",
            "output": "9\n22\n47\n29\n14\n6\n9\n"
        },
        {
            "input": "1\n10\ngppbsdotep\n",
            "output": "28\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\ncadabaaabc\n8\ncabbaadd\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n12\n18\n15\n3\n9\n"
        },
        {
            "input": "7\n5\ncbaca\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\naac\n6\nspbrky\n",
            "output": "6\n17\n12\n29\n14\n5\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\naacabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ncba\n6\nykraps\n",
            "output": "9\n21\n12\n29\n14\n3\n10\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabbabacb\n12\naaaaaaabaaaa\n10\nabacabadac\n8\ndcbabacd\n3\ncba\n6\nykrspa\n",
            "output": "9\n18\n47\n29\n12\n3\n12\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabc\n6\nsrapky\n",
            "output": "9\n21\n12\n29\n14\n6\n8\n"
        },
        {
            "input": "7\n5\nacbac\n8\naacabbca\n12\naaaaaaaaaaaa\n10\naaacabbdac\n8\ndcbaabcd\n3\ndba\n6\nsparky\n",
            "output": "9\n22\n12\n35\n14\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\nab\n2\nab\n2\nba\n2\nbc\n26\nabcdeqghujklmnopfrstivwxyz\n26\nabcdefghijklmnopqrstuvwxyz\n",
            "output": "1\n3\n3\n2\n3\n296\n351\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\nab\n2\nba\n2\nad\n26\nabcdeqghujklmnopfrstivwxyz\n26\nabcdefgpijklmnohqrstuvwxyz\n",
            "output": "1\n2\n3\n2\n3\n296\n321\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaaacd\n3\nabd\n6\nykqaps\n",
            "output": "9\n17\n12\n29\n12\n6\n10\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\nbcbaaadd\n3\ndba\n6\nsqarky\n",
            "output": "9\n21\n12\n29\n17\n3\n9\n"
        },
        {
            "input": "1\n10\nqdsophapeq\n",
            "output": "23\n"
        },
        {
            "input": "7\n1\na\n2\nac\n2\nba\n2\nab\n2\nad\n26\nzyxwvitsrfponmlkjuhgqedcba\n26\nzyxwvutsrqhonmlkjipgfedcba\n",
            "output": "1\n3\n2\n3\n3\n50\n39\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\ncadabacaba\n8\ndcbaaacd\n3\nabd\n6\nsparky\n",
            "output": "9\n17\n12\n19\n12\n6\n9\n"
        },
        {
            "input": "7\n1\nb\n2\nba\n2\nab\n2\nba\n2\ncb\n26\nzyxwvitsrfponmlkjuhgqedcba\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n2\n50\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\naacabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabc\n6\nykraps\n",
            "output": "9\n21\n12\n29\n14\n6\n10\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabbbbacb\n12\naaaaaaabaaaa\n10\nabacabadac\n8\ndcbabacd\n3\ncba\n6\nykrspa\n",
            "output": "9\n17\n47\n29\n12\n3\n12\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nab\n2\nba\n2\nbc\n26\nabcdeqghujklmnopfrstivwxyz\n26\nabcdefghijklmnopqrstuvwxyz\n",
            "output": "1\n2\n3\n2\n3\n296\n351\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nba\n2\nba\n2\nbc\n26\nabcdeqghujklmnopfrstivwxyz\n26\nabcdefghijklmnopqrstuvwxyz\n",
            "output": "1\n2\n2\n2\n3\n296\n351\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\ncadacacaba\n8\ndcbaaacd\n3\nabd\n6\nspbrky\n",
            "output": "9\n17\n12\n18\n12\n6\n9\n"
        },
        {
            "input": "1\n10\nqetodsbpqg\n",
            "output": "21\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nab\n2\nba\n2\nbc\n26\nabcdefghijklmnopqrstuvwxyz\n26\nabcdefghijklmnopqrstuvwxyz\n",
            "output": "1\n2\n3\n2\n3\n351\n351\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaba\n10\nabacabadac\n8\ndcbaabcd\n3\ncab\n6\nsparky\n",
            "output": "9\n17\n32\n29\n14\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\nab\n2\nab\n2\nba\n2\nbc\n26\nabcdeqghijklmnopfrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n3\n3\n2\n3\n320\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcc\n3\nabc\n6\nsparky\n",
            "output": "9\n17\n12\n29\n13\n6\n9\n"
        },
        {
            "input": "7\n1\na\n2\nab\n2\nab\n2\nab\n2\nbc\n26\nabcdeqghijklmnopfrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n3\n3\n3\n3\n320\n26\n"
        },
        {
            "input": "7\n1\na\n2\naa\n2\nab\n2\nba\n2\nca\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n2\n351\n26\n"
        },
        {
            "input": "7\n5\ncabca\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabacac\n8\ndcbaabcd\n3\nabc\n6\nspbrky\n",
            "output": "9\n17\n12\n27\n14\n6\n9\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nba\n2\nba\n2\ncb\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n2\n2\n2\n296\n26\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\nab\n2\nba\n2\nbd\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwhutsrqvonmlkjipgfedcba\n",
            "output": "1\n2\n3\n2\n3\n296\n59\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabbabacc\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabc\n6\nsparky\n",
            "output": "9\n18\n12\n29\n14\n6\n9\n"
        },
        {
            "input": "7\n1\na\n2\nab\n2\nbb\n2\nba\n2\ncb\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n3\n2\n2\n2\n351\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbbaacd\n3\ncba\n6\nykraps\n",
            "output": "9\n22\n12\n29\n9\n3\n10\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabdd\n3\ncab\n6\nykraps\n",
            "output": "9\n17\n12\n29\n13\n3\n10\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\naaacabbdac\n8\ndcbaabcd\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n12\n35\n14\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\ncadbbaaabc\n8\ncabcaadd\n3\nabd\n6\nsparky\n",
            "output": "9\n17\n12\n18\n20\n6\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\nccbaaacd\n3\ndba\n6\nsqarky\n",
            "output": "9\n21\n12\n29\n12\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaba\n10\ncdaabacaba\n8\nccbdaaad\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n32\n24\n13\n3\n9\n"
        },
        {
            "input": "7\n5\ncabca\n8\nabcabbcb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcc\n3\ncba\n6\nsparky\n",
            "output": "9\n22\n12\n29\n13\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\nabacabadab\n8\nbcbaadcd\n3\nabc\n6\nkparsy\n",
            "output": "9\n21\n12\n29\n18\n6\n17\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\nba\n2\nba\n2\nad\n26\nzyxwvitsrfponmlkjuhgqedcba\n26\nzyxwvutsrqhonmlkjipgfedcba\n",
            "output": "1\n2\n2\n2\n3\n50\n39\n"
        },
        {
            "input": "1\n10\ngdpartoeop\n",
            "output": "29\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\ncadabacaba\n8\ndcbaaacd\n3\ndba\n6\nsparky\n",
            "output": "9\n21\n12\n19\n12\n3\n9\n"
        },
        {
            "input": "7\n5\ncbaca\n8\nababacca\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\naac\n6\nspbrky\n",
            "output": "6\n21\n12\n29\n14\n5\n9\n"
        },
        {
            "input": "7\n1\na\n2\nac\n2\nba\n2\nab\n2\nad\n26\nzyxwvitsrfponmlkjchgqeduba\n26\nzyxwvutsrqhonmlkjipgfedcba\n",
            "output": "1\n3\n2\n3\n3\n46\n39\n"
        },
        {
            "input": "7\n1\nb\n2\nba\n2\nab\n2\nab\n2\ncb\n26\nzyxwvitsrfponmlkjuhgqedcba\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n3\n2\n50\n26\n"
        },
        {
            "input": "7\n1\na\n2\naa\n2\nba\n2\nba\n2\ndb\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihffedcba\n",
            "output": "1\n2\n2\n2\n2\n351\n26\n"
        },
        {
            "input": "1\n10\nagperdoptp\n",
            "output": "35\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nab\n2\nba\n2\nbc\n26\nabcdeqghujklmnopfrstivwxyz\n26\nabcdefghijklmnopqrstvvwxyz\n",
            "output": "1\n2\n3\n2\n3\n296\n350\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naabaaaaaaaba\n10\ncdaabacaba\n8\nccbaaadd\n3\ndba\n6\npsarkx\n",
            "output": "9\n17\n32\n24\n11\n3\n12\n"
        },
        {
            "input": "7\n1\nb\n2\nba\n2\nab\n2\nba\n2\ncb\n26\nzyxwvitsrfponnlkjuhgqedcba\n26\nabcdefghijklmnopqrstuvwxyz\n",
            "output": "1\n2\n3\n2\n2\n50\n351\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nba\n2\nba\n2\ncc\n26\nabcdeqghujklmnopfrstivwxyz\n26\nabcdefghijklmnopqrstuvwxyz\n",
            "output": "1\n2\n2\n2\n2\n296\n351\n"
        },
        {
            "input": "1\n10\ngeoardptpp\n",
            "output": "27\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nab\n2\nba\n2\nbc\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n3\n351\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ndba\n6\nspaqky\n",
            "output": "9\n17\n12\n29\n14\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ncab\n6\nsparky\n",
            "output": "9\n17\n12\n29\n14\n3\n9\n"
        },
        {
            "input": "1\n10\ngdpardotop\n",
            "output": "27\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabc\n6\nsparky\n",
            "output": "9\n17\n12\n29\n14\n6\n9\n"
        },
        {
            "input": "1\n10\ngepasdotpp\n",
            "output": "27\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabc\n6\nspbrky\n",
            "output": "9\n17\n12\n29\n14\n6\n9\n"
        },
        {
            "input": "1\n10\npptodsapeg\n",
            "output": "26\n"
        },
        {
            "input": "1\n10\npptodsbpeg\n",
            "output": "26\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nab\n2\nba\n2\nbd\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n3\n296\n26\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\nab\n2\nba\n2\nbd\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n3\n296\n26\n"
        },
        {
            "input": "7\n1\na\n2\naa\n2\nab\n2\nba\n2\nab\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n3\n351\n26\n"
        },
        {
            "input": "7\n1\na\n2\naa\n2\nab\n2\nba\n2\nac\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n3\n351\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ndba\n6\nsparkx\n",
            "output": "9\n17\n12\n29\n14\n3\n9\n"
        },
        {
            "input": "1\n10\nppsodrapeg\n",
            "output": "26\n"
        },
        {
            "input": "1\n10\ngeoasdotpp\n",
            "output": "27\n"
        },
        {
            "input": "7\n5\ncabca\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabc\n6\nspbrky\n",
            "output": "9\n17\n12\n29\n14\n6\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\ncadabacaba\n8\nccbaaadd\n3\ndba\n6\nsparkx\n",
            "output": "9\n17\n12\n19\n11\n3\n9\n"
        },
        {
            "input": "1\n10\ngepbsdotpp\n",
            "output": "27\n"
        },
        {
            "input": "7\n1\na\n2\naa\n2\nab\n2\nba\n2\nab\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjifghedcba\n",
            "output": "1\n2\n3\n2\n3\n351\n26\n"
        },
        {
            "input": "1\n10\npptodsaoeg\n",
            "output": "26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabc\n6\nsparky\n",
            "output": "9\n22\n12\n29\n14\n6\n9\n"
        },
        {
            "input": "7\n1\na\n2\naa\n2\nab\n2\nba\n2\nbd\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n3\n351\n26\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nab\n2\nba\n2\nac\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n3\n351\n26\n"
        },
        {
            "input": "1\n10\noptodrapeg\n",
            "output": "27\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaaacd\n3\ndaa\n6\nsparky\n",
            "output": "9\n17\n12\n29\n12\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabc\n6\nsparky\n",
            "output": "9\n21\n12\n29\n14\n6\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\ncadabacaba\n8\ncabcaadd\n3\ndba\n6\nsparly\n",
            "output": "9\n17\n12\n19\n20\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\naa\n2\nab\n2\nba\n2\nab\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkiihgfedcba\n",
            "output": "1\n2\n3\n2\n3\n351\n26\n"
        },
        {
            "input": "1\n10\npptodrapge\n",
            "output": "26\n"
        },
        {
            "input": "7\n1\na\n2\nab\n2\nab\n2\nba\n2\nac\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n3\n3\n2\n3\n351\n26\n"
        },
        {
            "input": "1\n10\nppsodgaper\n",
            "output": "26\n"
        },
        {
            "input": "1\n10\ngeoasodtpp\n",
            "output": "27\n"
        },
        {
            "input": "1\n10\nqptodsbpeg\n",
            "output": "18\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\ncadbbaaabc\n8\ncabcaadd\n3\ndba\n6\nsparky\n",
            "output": "9\n17\n12\n18\n20\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\nab\n2\nba\n2\nad\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqhonmlkjipgfedcba\n",
            "output": "1\n2\n3\n2\n3\n296\n39\n"
        },
        {
            "input": "1\n10\npptodsaodg\n",
            "output": "26\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\nbb\n2\nba\n2\nbc\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n2\n2\n3\n351\n26\n"
        },
        {
            "input": "7\n5\ncabca\n8\nabcabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ncba\n6\nsparky\n",
            "output": "9\n22\n12\n29\n14\n3\n9\n"
        },
        {
            "input": "1\n10\noptpdraoeg\n",
            "output": "27\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\nabacabadab\n8\ndcbaabcd\n3\nabc\n6\nsparky\n",
            "output": "9\n21\n12\n29\n14\n6\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabaca\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\nccbaaadd\n3\ndba\n6\nsqarky\n",
            "output": "9\n21\n12\n29\n11\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\nab\n2\nab\n2\nba\n2\nac\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgefdcba\n",
            "output": "1\n3\n3\n2\n3\n351\n26\n"
        },
        {
            "input": "1\n10\nqpsodgaper\n",
            "output": "18\n"
        },
        {
            "input": "1\n10\nqptodscpeg\n",
            "output": "18\n"
        },
        {
            "input": "7\n5\ncabca\n8\nabcabbcb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ncba\n6\nsparky\n",
            "output": "9\n22\n12\n29\n14\n3\n9\n"
        },
        {
            "input": "1\n10\ngeoardptpo\n",
            "output": "27\n"
        },
        {
            "input": "1\n10\nqpsodgapeq\n",
            "output": "18\n"
        },
        {
            "input": "1\n10\nqptocsdpeg\n",
            "output": "18\n"
        },
        {
            "input": "1\n10\nqpsodhapeq\n",
            "output": "18\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ndba\n6\nspasky\n",
            "output": "9\n17\n12\n29\n14\n3\n9\n"
        },
        {
            "input": "7\n5\nbcaac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ndba\n6\nspaqky\n",
            "output": "9\n17\n12\n29\n14\n3\n9\n"
        },
        {
            "input": "1\n10\ngdparcotop\n",
            "output": "27\n"
        },
        {
            "input": "7\n5\nacbab\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\nabc\n6\nsparky\n",
            "output": "9\n17\n12\n29\n14\n6\n9\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nac\n2\nba\n2\nbd\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n3\n296\n26\n"
        },
        {
            "input": "1\n10\npotodsapeg\n",
            "output": "18\n"
        },
        {
            "input": "7\n1\nb\n2\nba\n2\nab\n2\nba\n2\ncb\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n2\n296\n26\n"
        },
        {
            "input": "7\n5\nacbac\n8\nabcabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ncab\n6\nykraps\n",
            "output": "9\n22\n12\n29\n14\n3\n10\n"
        },
        {
            "input": "7\n1\na\n2\naa\n2\nba\n2\nba\n2\nbd\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n2\n2\n3\n351\n26\n"
        },
        {
            "input": "1\n10\ngepardotpo\n",
            "output": "27\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabaabc\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaaacd\n3\ndaa\n6\nsparky\n",
            "output": "9\n15\n12\n29\n12\n3\n9\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\naa\n2\nba\n2\nbd\n26\nabcdeqghuiklmnopfrstivwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n2\n2\n3\n296\n26\n"
        },
        {
            "input": "1\n10\nptpodrapge\n",
            "output": "19\n"
        },
        {
            "input": "1\n10\npptdosaoeg\n",
            "output": "26\n"
        },
        {
            "input": "1\n10\nqpuodsbpeg\n",
            "output": "18\n"
        },
        {
            "input": "1\n10\npptodsdoag\n",
            "output": "26\n"
        },
        {
            "input": "7\n5\ncabca\n8\nabcabacb\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ncba\n6\nykraps\n",
            "output": "9\n22\n12\n29\n14\n3\n10\n"
        },
        {
            "input": "7\n5\nbcbac\n8\nacabadba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaaacd\n3\ndaa\n6\nsparky\n",
            "output": "9\n18\n12\n29\n12\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaba\n10\ncdaabacaba\n8\nccbaaadd\n3\ndba\n6\nsparkx\n",
            "output": "9\n17\n32\n24\n11\n3\n9\n"
        },
        {
            "input": "1\n10\nqprodgaper\n",
            "output": "18\n"
        },
        {
            "input": "1\n10\nqptodscpdg\n",
            "output": "18\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\nba\n2\nac\n2\nad\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqhonmlkjipgfedcba\n",
            "output": "1\n2\n2\n3\n3\n296\n39\n"
        },
        {
            "input": "1\n10\ngtpardofop\n",
            "output": "24\n"
        },
        {
            "input": "7\n1\na\n2\nba\n2\nca\n2\nba\n2\nbd\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n2\n2\n3\n296\n26\n"
        },
        {
            "input": "1\n10\nootpdrapef\n",
            "output": "30\n"
        },
        {
            "input": "1\n10\ngqpbsdotep\n",
            "output": "28\n"
        },
        {
            "input": "7\n1\na\n2\naa\n2\nba\n2\nba\n2\nbd\n26\nabcdefghijklmnopqrstuvwxyz\n26\nzyxwvutsrqponmlkjihffedcba\n",
            "output": "1\n2\n2\n2\n3\n351\n26\n"
        },
        {
            "input": "1\n10\nptpodrepga\n",
            "output": "19\n"
        },
        {
            "input": "1\n10\nppadostoeg\n",
            "output": "30\n"
        },
        {
            "input": "7\n5\ncabcb\n8\nacabadba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaaacd\n3\ndaa\n6\nsparky\n",
            "output": "9\n18\n12\n29\n12\n3\n9\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naabaaaaaaaba\n10\ncdaabacaba\n8\nccbaaadd\n3\ndba\n6\nsparkx\n",
            "output": "9\n17\n32\n24\n11\n3\n9\n"
        },
        {
            "input": "1\n10\nqprodgapdr\n",
            "output": "18\n"
        },
        {
            "input": "7\n1\na\n2\nca\n2\naa\n2\nac\n2\nad\n26\nabcdeqghujklmnopfrstivwxyz\n26\nzyxwvutsrqhonmlkjipgfedcba\n",
            "output": "1\n2\n2\n3\n3\n296\n39\n"
        },
        {
            "input": "1\n10\nqepahposdq\n",
            "output": "24\n"
        },
        {
            "input": "1\n10\ngtpaqdofop\n",
            "output": "24\n"
        },
        {
            "input": "7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\ncadabacaba\n8\ndcbaaacd\n3\nabd\n6\nspbrky\n",
            "output": "9\n17\n12\n19\n12\n6\n9\n"
        },
        {
            "input": "1\n10\nooapdrtpef\n",
            "output": "26\n"
        },
        {
            "input": "7\n1\nb\n2\nba\n2\nab\n2\nba\n2\ncb\n26\nzyxwvitsrfponnlkjuhgqedcba\n26\nzyxwvutsrqponmlkjihgfedcba\n",
            "output": "1\n2\n3\n2\n2\n50\n26\n"
        },
        {
            "input": "1\n10\ngqpbsdoteq\n",
            "output": "28\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e3 + 9;\nconst int Log2 = 23;\nconst int inf = 1e9 + 7;\nvector<int> g[N];\nstring s;\nint T, n, lcp[N][N], dp[N][N];\nvoid Repack() {\n  for (int i = 1; i <= n; i++) lcp[i][n + 1] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) dp[i][j] = 0;\n  for (int i = 1; i <= n; i++) dp[1][i] = i;\n}\nvoid out() {\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) cout << dp[i][j] << \" \";\n    cout << \"\\n\";\n  }\n  exit(0);\n}\nint main() {\n  ios_base::sync_with_stdio(NULL);\n  cin.tie(0);\n  cout.tie(0);\n  if (fopen(\"tst\"\n            \".INP\",\n            \"r\")) {\n    freopen(\n        \"tst\"\n        \".INP\",\n        \"r\", stdin);\n  }\n  cin >> T;\n  while (T--) {\n    cin >> n >> s;\n    s = \" \" + s;\n    Repack();\n    for (int i = n; i > 0; i--) {\n      for (int j = i - 1; j > 0; j--) {\n        if (s[j] != s[i])\n          lcp[j][i] = 1;\n        else\n          lcp[j][i] = lcp[j + 1][i + 1] + 1;\n      }\n    }\n    for (int i = 2; i <= n; i++) {\n      int mn = n + 1;\n      for (int j = 1; j <= n; j++) g[j].clear();\n      for (int j = i - 1; j > 0; j--) {\n        mn = min(mn, lcp[j][i]);\n        g[lcp[j][i]].push_back(j);\n      }\n      for (int j = i; j <= n; j++) dp[i][j] = max(dp[i][j], dp[i][j - 1] + 1);\n      for (int val = 1; val <= n; val++) {\n        for (auto prv : g[val]) {\n          dp[i][i + val - 1] = max(dp[i][i + val - 1], dp[i][i + val - 2] + 1);\n          if (s[i + val - 1] > s[prv + val - 1])\n            dp[i][i + val - 1] = max(dp[i][i + val - 1], dp[prv][n] + 1);\n        }\n      }\n      for (int j = i; j <= n; j++) dp[i][j] = max(dp[i][j], dp[i][j - 1] + 1);\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n      for (int j = 1; j <= n; j++) ans = max(ans, dp[i][j]);\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint t, n, i, j, c[5005][5005], l[5005], a;\nchar s[5005];\nint main() {\n  cin >> t;\n  while (t--) {\n    cin >> n >> s;\n    for (i = n; ~i; --i)\n      for (j = n; ~j; --j) c[i][j] = 0;\n    for (i = n - 1; ~i; --i) {\n      l[i] = 0;\n      for (j = n - 1; ~j; --j)\n        if (s[i] == s[j]) c[i][j] = c[i + 1][j + 1] + 1;\n    }\n    for (a = i = 0; i < n; ++i) {\n      for (j = 0; j < n; ++j)\n        if (l[j] - c[i][j] > l[i] && s[j + c[i][j]] < s[i + c[i][j]])\n          l[i] = l[j] - c[i][j];\n      if ((l[i] += n - i) > a) a = l[i];\n    }\n    cout << a << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INF64 = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\ntypedef std::priority_queue<int, vector<int>, greater<int>> small_pq;\ntypedef std::priority_queue<int, vector<int>, less<int>> big_pq;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() {}\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  if (sizeof...(T) > 0) cerr << \" ,\";\n  dbg_out(T...);\n}\nvoid dbg_name(const string &s) {\n  string ss = s;\n  replace(ss.begin(), ss.end(), ',', ' ');\n  cerr << \"  ( \" << ss << \" )  \";\n}\ntemplate <typename T>\ninline void setmin(T &a, const T &b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\ninline void setmax(T &a, const T &b) {\n  if (b > a) a = b;\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nunordered_map<long long, int, custom_hash> safe_map;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::steady_clock::now().time_since_epoch().count());\nconst int MOD = 998244353;\nint mul(int x, int y) { return 1ll * x * y % MOD; }\nint add(int x, int y) { return ((x + y) % MOD + MOD) % MOD; }\nint sub(int x, int y) { return ((x - y) % MOD + MOD) % MOD; }\nint qpow(int a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = mul(ans, a);\n    a = mul(a, a);\n    b /= 2;\n  }\n  return ans;\n}\nconst int N = 1e4 + 5;\nnamespace Suffix {\nint sa[N], rk[N * 2], oldrk[N * 2], cnt[N], id[N];\nint ht[N];\nbool cmp(int x, int y, int w) {\n  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\nvoid build_sa(const string &s) {\n  int n = s.size();\n  fill(rk + 1, rk + 1 + 2 * n, 0);\n  fill(oldrk + 1, oldrk + 1 + 2 * n, 0);\n  for (int(i) = int(1); int(i) <= int(n); i++) rk[i] = s[i - 1];\n  int m = 150;\n  fill(cnt, cnt + m + 1, 0);\n  for (int(i) = int(1); int(i) <= int(n); i++) cnt[rk[i]]++;\n  for (int(i) = int(1); int(i) <= int(m); i++) cnt[i] += cnt[i - 1];\n  for (int(i) = int(n); int(i) >= int(1); i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    int p = 0;\n    for (int(i) = int(n); int(i) >= int(n - w + 1); i--) id[++p] = i;\n    for (int(i) = int(1); int(i) <= int(n); i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    fill(cnt, cnt + m + 1, 0);\n    for (int(i) = int(1); int(i) <= int(n); i++) cnt[rk[id[i]]]++;\n    for (int(i) = int(1); int(i) <= int(m); i++) cnt[i] += cnt[i - 1];\n    for (int(i) = int(n); int(i) >= int(1); i--) sa[cnt[rk[id[i]]]--] = id[i];\n    swap(rk, oldrk);\n    p = 0;\n    for (int(i) = int(1); int(i) <= int(n); i++)\n      rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n    if (p == n) break;\n    m = p;\n  }\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (k) k--;\n    while ((i + k <= n) && s[i + k - 1] == s[sa[rk[i] - 1] + k - 1]) k++;\n    ht[rk[i]] = k;\n  }\n}\n}  // namespace Suffix\nconst int M = 14;\nchar s[N];\nint dp[N];\nint f[N][M];\nint calc(int i, int j) {\n  int s = log2(j - i + 1);\n  return min(f[i][s], f[j - (1 << s) + 1][s]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  using namespace Suffix;\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    string s;\n    cin >> n >> s;\n    Suffix::build_sa(s);\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      f[i][0] = Suffix::ht[i];\n    }\n    for (int(i) = int(1); int(i) <= int(M - 1); i++) {\n      for (int(j) = int(1); int(j) <= int(n); j++) {\n        f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n    int ans = 0;\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      dp[i] = n - i + 1;\n      for (int(j) = int(1); int(j) <= int(i - 1); j++) {\n        if (Suffix::rk[i] > Suffix::rk[j])\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - calc(rk[j] + 1, rk[i]));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n    fill(dp + 1, dp + 1 + n, 0);\n    for (int(i) = int(0); int(i) <= int(M - 1); i++)\n      for (int(j) = int(1); int(j) <= int(n); j++) f[j][i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nclass static_rmq {\n  using F = function<T(T, T)>;\n  vector<vector<T>> b;\n  F f;\n\n public:\n  static_rmq() {}\n  static_rmq(const vector<T> &v, F _f) : f(_f) {\n    int n = v.size();\n    int m = 32 - __builtin_clz(n);\n    b = vector<vector<T>>(n, vector<T>(m));\n    for (int i = 0; i < n; ++i) {\n      b[i][0] = v[i];\n    }\n    for (int j = 1; j < m; ++j) {\n      for (int i = 0; i < n - (1 << j) + 1; ++i) {\n        b[i][j] = f(b[i][j - 1], b[i + (1 << (j - 1))][j - 1]);\n      }\n    }\n  }\n  T query(int l, int r) {\n    if (l > r) {\n      return numeric_limits<T>::max();\n    }\n    int x = floor(log2(r - l + 1));\n    return f(b[l][x], b[r - (1 << x) + 1][x]);\n  }\n  T operator[](int i) { return b[i][0]; }\n};\nstruct suffix_array {\n  vector<int> sa;\n  string s;\n  int n;\n  suffix_array() {}\n  suffix_array(const string &_s) : s(_s), n(_s.size()), sa(_s.size()) {\n    iota(sa.begin(), sa.end(), 0);\n    sort(sa.begin(), sa.end(),\n         [&](int i, int j) { return s[i] == s[j] ? i > j : s[i] < s[j]; });\n    vector<int> rnk(n);\n    vector<int> c(s.begin(), s.end());\n    vector<int> cnt(n);\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; ++i) {\n        if (i == 0 || c[sa[i - 1]] != c[sa[i]]) {\n          rnk[sa[i]] = i;\n        } else {\n          if (sa[i - 1] + k >= n || c[sa[i - 1] + k / 2] != c[sa[i] + k / 2]) {\n            rnk[sa[i]] = i;\n          } else {\n            rnk[sa[i]] = rnk[sa[i - 1]];\n          }\n        }\n      }\n      iota(cnt.begin(), cnt.end(), 0);\n      copy(sa.begin(), sa.end(), c.begin());\n      for (int i = 0; i < n; ++i) {\n        int j = c[i] - k;\n        if (j >= 0) {\n          sa[cnt[rnk[j]]++] = j;\n        }\n      }\n      swap(rnk, c);\n    }\n  }\n  int size() { return n; }\n  int operator[](int i) { return sa[i]; }\n};\nstruct longest_common_prefix {\n  vector<int> rnk;\n  vector<int> lcp;\n  suffix_array sa;\n  static_rmq<int> st;\n  int n;\n  longest_common_prefix(const suffix_array &_sa) : sa(_sa) {\n    n = sa.size();\n    rnk.resize(n);\n    lcp.resize(n - 1);\n    for (int i = 0; i < n; ++i) {\n      rnk[sa[i]] = i;\n    }\n    int h = 0;\n    for (int i = 0; i < n; ++i) {\n      if (rnk[i] + 1 < n) {\n        int j = sa[rnk[i] + 1];\n        while (max(i, j) + h < n && sa.s[i + h] == sa.s[j + h]) {\n          h++;\n        }\n        lcp[rnk[i]] = h;\n        if (h > 0) {\n          h--;\n        }\n      }\n    }\n    st = static_rmq<int>(lcp, [&](int i, int j) { return min(i, j); });\n  }\n  int operator[](int i) { return lcp[i]; }\n  int getlcp(int l, int r) {\n    if (l == r) {\n      return n - l;\n    }\n    l = rnk[l];\n    r = rnk[r];\n    if (l > r) {\n      swap(l, r);\n    }\n    return st.query(l, r - 1);\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    suffix_array sa(s);\n    longest_common_prefix lcp(sa);\n    vector<int> dp(n);\n    for (int i = 0; i < n; ++i) {\n      dp[i] = n - i;\n      for (int j = 0; j < i; ++j) {\n        int l = lcp.getlcp(i, j);\n        if (i + l < n && s[j + l] < s[i + l]) {\n          dp[i] = max(dp[i], dp[j] + (n - l - i));\n        }\n      }\n    }\n    cout << *max_element(dp.begin(), dp.end()) << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nvoid setIO() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n}\nconst long long N = 3e5 + 3;\nconst long long M = 5e2 + 5;\nconst long long inf = 9e17;\nconst long long mod = 1e9 + 7;\nlong long xyz = 1;\nlong long n, q;\nlong long dp[N];\nlong long zed[N];\nvoid fun(string s) {\n  long long n = (long long)s.length();\n  for (long long i = 1, l = 0, r = 0; i < n; i++) {\n    zed[i] = 0;\n    if (i <= r) zed[i] = min(r - i + 1, zed[i - l]);\n    while (i + zed[i] < n && s[zed[i]] == s[i + zed[i]]) ++zed[i];\n    if (i + zed[i] - 1 > r) l = i, r = i + zed[i] - 1;\n  }\n}\nvoid run() {\n  cin >> n;\n  string str;\n  cin >> str;\n  for (long long i = 0; i < n; i++) dp[i] = n - i;\n  for (long long i = 0; i < n; i++) {\n    fun(str.substr(i));\n    for (long long j = 1; j + i < n; j++) {\n      long long k = i + j;\n      if (zed[j] + k < n && str[k + zed[j]] > str[i + zed[j]]) {\n        ((dp[k]) = max(dp[i] + (n - k) - zed[j], dp[k]));\n      }\n    }\n  }\n  long long ans = 0;\n  for (long long i = 0; i < n; i++) ((ans) = max(dp[i], ans));\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  setIO();\n  cin >> xyz;\n  while (xyz--) run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while ((c < '0' || c > '9') && (c != '-')) c = getchar();\n  if (c == '-') f = -1, c = getchar();\n  while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n  return x * f;\n}\nconst int N = 5010;\nint n, lcp[N][N], dp[N];\nchar s[N];\ninline void solve() {\n  n = read(), scanf(\"%s\", s + 1);\n  for (register int i = (n); i >= (1); i--)\n    for (register int j = (n); j >= (1); j--)\n      if (s[i] == s[j])\n        lcp[i][j] = lcp[i + 1][j + 1] + 1;\n      else\n        lcp[i][j] = 0;\n  int ans = 0;\n  for (register int i = (1); i <= (n); i++) {\n    dp[i] = n - i + 1;\n    for (register int j = (1); j < (i); j++) {\n      int l = lcp[i][j];\n      if (i + l > n) continue;\n      if (s[i + l] < s[j + l]) continue;\n      dp[i] = max(dp[i], dp[j] + n - (i + l) + 1);\n    }\n    ans = max(ans, dp[i]);\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  int T = read();\n  while (T--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nchar s[5010];\nint lcp[5010][5010], f[5010];\nint max(int a, int b) { return a > b ? a : b; }\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i <= n; i++) {\n      f[i] = 0;\n      for (int j = 0; j <= n; j++) lcp[i][j] = 0;\n    }\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; i++) lcp[i][i] = n - i + 1;\n    for (int i = n; i >= 1; i--) {\n      for (int j = n; j >= 1; j--) {\n        if (i == j) continue;\n        if (s[i] == s[j]) {\n          lcp[i][j] = lcp[i + 1][j + 1] + 1;\n        }\n      }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      f[i] = n - i + 1;\n      for (int j = 1; j < i; j++) {\n        if (s[i + lcp[i][j]] > s[j + lcp[i][j]]) {\n          f[i] = max(f[i], f[j] + n - i - lcp[i][j] + 1);\n        }\n      }\n      ans = max(ans, f[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint32_t n;\nstd::string str;\nint32_t *suf_array, *inverse_suf_array;\nvoid radix_sort(int32_t* classes) {\n  int32_t m = str.size();\n  int32_t* counters = new int32_t[m];\n  for (int32_t i = 0; i < m; i++) counters[i] = 0;\n  for (int32_t i = 0; i < m; i++) counters[classes[i]]++;\n  int32_t last = 0;\n  for (int32_t i = 0; i < m; i++) {\n    int32_t new_last = last + counters[i];\n    counters[i] = last;\n    last = new_last;\n  }\n  int32_t* res = new int32_t[m];\n  for (int32_t i = 0; i < m; i++) {\n    res[counters[classes[suf_array[i]]]++] = suf_array[i];\n  }\n  for (int32_t i = 0; i < m; i++) {\n    suf_array[i] = res[i];\n  }\n  delete[] res;\n  delete[] counters;\n}\nvoid build_suf_array() {\n  str.push_back('a' - 1);\n  int32_t m = str.size();\n  suf_array = new int32_t[m];\n  int32_t* classes = new int32_t[str.size()];\n  int32_t counters[30];\n  for (int32_t i = 0; i < 30; i++) counters[i] = 0;\n  for (int32_t i = 0; i < m; i++) counters[str[i] - 'a' + 1]++;\n  int32_t starts[30];\n  starts[0] = 0;\n  for (int32_t i = 1; i < 30; i++) starts[i] = starts[i - 1] + counters[i - 1];\n  int32_t* first_symbols = new int32_t[m];\n  for (int32_t i = 0; i < m; i++) first_symbols[starts[str[i] - 'a' + 1]++] = i;\n  classes[first_symbols[0]] = 0;\n  int32_t remains = counters[0] - 1, char_passed = 1;\n  for (int32_t i = 1; i < m; i++)\n    if (remains == 0) {\n      classes[first_symbols[i]] = classes[first_symbols[i - 1]] + 1;\n      remains = counters[char_passed++] - 1;\n      while (remains < 0) remains = counters[char_passed++] - 1;\n    } else {\n      classes[first_symbols[i]] = classes[first_symbols[i - 1]];\n      remains--;\n    }\n  for (int32_t i = 0; i < m; i++) suf_array[i] = first_symbols[i];\n  int32_t length = 1;\n  int32_t* new_classes = new int32_t[m];\n  while (classes[m - 1] < str.size() - 1 && length < m) {\n    for (int32_t i = 0; i < m; i++) {\n      suf_array[i] = (suf_array[i] - length + m) % m;\n    }\n    radix_sort(classes);\n    new_classes[suf_array[0]] = 0;\n    for (int32_t i = 1; i < m; i++) {\n      std::pair<int32_t, int32_t> prev = {\n          classes[suf_array[i - 1]], classes[(suf_array[i - 1] + length) % m]};\n      std::pair<int32_t, int32_t> cur = {classes[suf_array[i]],\n                                         classes[(suf_array[i] + length) % m]};\n      if (prev == cur)\n        new_classes[suf_array[i]] = new_classes[suf_array[i - 1]];\n      else\n        new_classes[suf_array[i]] = new_classes[suf_array[i - 1]] + 1;\n    }\n    int32_t* tmp = classes;\n    classes = new_classes;\n    new_classes = tmp;\n    length *= 2;\n  }\n  inverse_suf_array = new int32_t[m];\n  for (int32_t i = 0; i < m; i++) inverse_suf_array[suf_array[i]] = i;\n}\nvoid solve() {\n  std::cin >> n;\n  std::cin >> str;\n  build_suf_array();\n  int32_t* lcp = new int32_t[str.size()];\n  int32_t last = 0;\n  for (int32_t i = 0; i < str.size() - 1; i++) {\n    lcp[inverse_suf_array[i] - 1] = last;\n    while (i + lcp[inverse_suf_array[i] - 1] < str.size() &&\n           str[i + lcp[inverse_suf_array[i] - 1]] ==\n               str[suf_array[inverse_suf_array[i] - 1] +\n                   lcp[inverse_suf_array[i] - 1]])\n      lcp[inverse_suf_array[i] - 1]++;\n    last = std::max(0, lcp[inverse_suf_array[i] - 1] - 1);\n  }\n  int32_t** lcp_real = new int32_t*[n + 1];\n  for (int32_t i = 0; i < n + 1; i++) {\n    lcp_real[i] = new int32_t[n + 1];\n    lcp_real[i][i] = INT32_MAX;\n    for (int32_t j = i + 1; j < n + 1; j++)\n      lcp_real[i][j] = std::min(lcp_real[i][j - 1], lcp[j - 1]);\n  }\n  int32_t* rev_suf_array = new int32_t[n];\n  for (int32_t i = 1; i <= n; i++) rev_suf_array[suf_array[i]] = i - 1;\n  int32_t* dp = new int32_t[n];\n  dp[0] = n;\n  for (int32_t i = 1; i < n; i++) {\n    dp[i] = n - i;\n    for (int32_t j = 0; j < i; j++)\n      if (rev_suf_array[j] < rev_suf_array[i])\n        dp[i] = std::max(\n            dp[i], dp[j] + n - i -\n                       lcp_real[inverse_suf_array[j]][inverse_suf_array[i]]);\n  }\n  int32_t answer = 0;\n  for (int32_t i = 0; i < n; i++) answer = std::max(answer, dp[i]);\n  std::cout << answer << \"\\n\";\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  int32_t num_tests;\n  std::cin >> num_tests;\n  for (int32_t t = 0; t < num_tests; t++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nconst int MX = 5005;\nconst long long MOD = 1000000007;\nint lcp[MX][MX];\nint dp[MX];\nvoid solve() {\n  int n;\n  string s;\n  cin >> n;\n  for (int i = 1; i <= n + 1; i++) {\n    for (int j = 1; j <= n + 1; j++) lcp[i][j] = 0;\n  }\n  cin >> s;\n  s = \"$\" + s;\n  for (int i = 1; i <= n; i++) lcp[i][i] = n - i + 1;\n  for (int i = n; i >= 1; i--) {\n    for (int j = n; j > i; j--) {\n      lcp[i][j] = (s[i] == s[j]) ? 1 + lcp[i + 1][j + 1] : 0;\n    }\n  }\n  int sol = 0;\n  for (int i = n; i >= 1; i--) {\n    dp[i] = n - i + 1;\n    for (int j = i + 1; j <= n; j++) {\n      int x = lcp[i][j];\n      if (j + x <= n && s[i + x] < s[j + x]) {\n        dp[i] = max(dp[i], dp[j] + n - i + 1 - x);\n      }\n    }\n    sol = max(sol, dp[i]);\n  }\n  cout << sol << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k, t, n, m, it, siz[5050], cur, res, it2;\nchar s0[5050];\nstring sb[5050];\nstruct trie {\n  int mp[30];\n  int f1, f2, len, fa;\n} s[20050];\nvoid build(int id, int dep, int l, int r) {\n  if (l == r) {\n    s[id].len += (siz[l] - dep + 2);\n    return;\n  }\n  int x[30], i, y[30], j, k = 0;\n  memset(x, 1, sizeof(x));\n  memset(y, 0, sizeof(y));\n  s[id].len++;\n  memset(s[id].mp, 0, sizeof(s[id].mp));\n  for (j = l; j <= r; j++) {\n    if (siz[j] >= dep) {\n      x[sb[j][dep] - 'a' + 1] = min(x[sb[j][dep] - 'a' + 1], j);\n      y[sb[j][dep] - 'a' + 1] = max(y[sb[j][dep] - 'a' + 1], j);\n    }\n  }\n  for (i = 1; i <= 26; i++) {\n    k += (y[i] > 0);\n  }\n  if ((dep == 1) || k > 1) {\n    for (i = 1; i <= 26; i++) {\n      if (y[i]) {\n        s[id].mp[i] = ++it;\n        s[it].fa = id;\n        build(it, dep + 1, x[i], y[i]);\n      }\n    }\n    return;\n  }\n  if (k == 1) {\n    for (i = 1; i <= 26; i++) {\n      if (y[i]) {\n        build(id, dep + 1, x[i], y[i]);\n        return;\n      }\n    }\n  }\n}\nvoid dfs(int cur, int dep, int ans) {\n  int i, j, k, f = s[cur].fa, nmsl = dep + s[cur].len;\n  for (i = 1; i < s0[dep]; i++) {\n    if (s[f].mp[i]) {\n      ans = max(ans, s[s[f].mp[i]].f2);\n    }\n  }\n  ans += min(s[cur].len, n - dep + 1);\n  ans = max(ans, s[cur].f1);\n  s[cur].f1 = ans;\n  s[cur].f2 = max(s[cur].f2, ans);\n  if (nmsl <= n) {\n    dfs(s[cur].mp[s0[nmsl]], nmsl, ans);\n    s[cur].f2 = max(s[cur].f2, s[s[cur].mp[s0[nmsl]]].f2);\n  }\n  res = max(res, ans);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> t;\n  while (t--) {\n    it = 0;\n    s[0].f1 = s[0].f2 = 0;\n    res = 0;\n    cin >> n >> s0 + 1;\n    if (n == 1) {\n      cout << 1 << '\\n';\n      continue;\n    }\n    for (i = 1; i <= n; i++) {\n      sb[i].clear();\n      sb[i] += \"0\";\n      for (j = i; j <= n; j++) {\n        sb[i] += s0[j];\n      }\n    }\n    sort(sb + 1, sb + n + 1);\n    for (i = 1; i <= n; i++) {\n      siz[i] = sb[i].size() - 1;\n    }\n    build(0, 1, 1, n);\n    for (i = 1; i <= n; i++) {\n      s0[i] -= 'a' - 1;\n    }\n    for (i = 1; i <= n; i++) {\n      it2 = i;\n      dfs(s[0].mp[s0[i]], i, 0);\n    }\n    cout << res << '\\n';\n    memset(s, 0, sizeof(s[0]) * it + 500);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7, siz = 1e6 + 5;\nlong long t, n, m, k, a[siz], dp[5002][5002], dp2[5002];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    string s;\n    cin >> s;\n    s = \"0\" + s;\n    for (long long i = 1; i <= n + 1; i++)\n      for (long long j = i + 1; j <= n + 1; j++) dp[i][j] = 0;\n    for (long long i = n; i >= 1; i--) {\n      for (long long j = i - 1; j >= 1; j--) {\n        if (s[i] == s[j]) {\n          dp[j][i] = 1 + dp[j + 1][i + 1];\n        }\n      }\n    }\n    long long ans = 0;\n    for (long long i = 1; i <= n; i++) {\n      dp2[i] = n - i + 1;\n      for (long long j = 1; j < i; j++) {\n        if (s[i] > s[j])\n          dp2[i] = max(dp2[j] + n - i + 1, dp2[i]);\n        else if (s[i] == s[j]) {\n          if (s[i + dp[j][i]] > s[j + dp[j][i]]) {\n            dp2[i] = max(dp2[i], dp2[j] + n - (i + dp[j][i]) + 1);\n          }\n        }\n      }\n      ans = max(ans, dp2[i]);\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e3 + 5;\nconst int p = 998244353;\nint read() {\n  int s = 0;\n  char c = getchar(), lc = '+';\n  while (c < '0' || '9' < c) lc = c, c = getchar();\n  while ('0' <= c && c <= '9') s = s * 10 + c - '0', c = getchar();\n  return lc == '-' ? -s : s;\n}\nvoid write(int x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x < 10)\n    putchar(x + '0');\n  else\n    write(x / 10), putchar(x % 10 + '0');\n}\nvoid print(int x, char c = '\\n') {\n  write(x);\n  putchar(c);\n}\ninline void up(int &x, int y) { x = max(x, y); }\nchar a[N];\nint dp[N][N], lcp[N][N], n;\nsigned main(signed Goodbye, char *Wangang[]) {\n  (void)Goodbye, (void)Wangang;\n  int T = read();\n  while (T--) {\n    n = read();\n    scanf(\"%s\", a + 1);\n    for (int i = n; i >= 1; i--)\n      for (int j = n; j >= 1; j--)\n        lcp[i][j] = a[i] == a[j] ? lcp[i + 1][j + 1] + 1 : 0;\n    for (int i = 1; i <= n; i++)\n      for (int j = 0; i + j <= n; j++) dp[i][j] = 1;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j < i; j++)\n        if (i + lcp[i][j] <= n && a[i + lcp[i][j]] > a[j + lcp[i][j]])\n          up(dp[i][lcp[i][j]], dp[j][n - j] + 1);\n      for (int j = 1; i + j <= n; j++) up(dp[i][j], dp[i][j - 1] + 1);\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n      for (int j = 0; i + j <= n; j++) up(ans, dp[i][j]);\n    print(ans);\n    for (int i = 1; i <= n; i++)\n      for (int j = 1; j <= n; j++) lcp[i][j] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solution solver = new Solution();\n        boolean multipleTC = true;\n        int testCount = multipleTC ? Integer.parseInt(in.next()) : 1;\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(in, out, i);\n        out.close();\n\n    }\n\n    static class Solution {\n        PrintWriter out;\n        InputReader in;\n\n        public void solve(InputReader in, PrintWriter out, int test) {\n            this.out = out;\n            this.in = in;\n\n            int n = ni();\n            String s = n();\n\n            Pair[] suffixes = new Pair[n];\n            for(int i = 0; i < n; i++)\n                suffixes[i] = new Pair(s.substring(i), i);\n            Arrays.sort(suffixes, com);\n            int[] lcp = new int[n];\n            for(int i = 0; i < n - 1; i++) {\n                int ptr1 = suffixes[i].ind, ptr2 = suffixes[i + 1].ind;\n                while(ptr1 < n && ptr2 < n && s.charAt(ptr1) == s.charAt(ptr2)) {\n                    ptr1++;\n                    ptr2++;\n                }\n                lcp[i] = ptr1 - suffixes[i].ind;\n            }\n\n            int[][] mat = new int[n][n];\n            int[] ptr = new int[n];\n            int done = 0;\n            for(int i = 0; i < n; i++) {\n                for(int k = ptr[i]; k < n - suffixes[i].ind; k++) {\n                    int currLengthPrefix = k + 1;\n                    int j = i;\n                    mat[suffixes[i].ind][suffixes[i].ind + k] = done;\n                    while (j < n - 1 && lcp[j] >= currLengthPrefix) {\n                        j++;\n                        mat[suffixes[j].ind][suffixes[j].ind + k] = done;\n                        ptr[j]++;\n                    }\n                    done++;\n                }\n            }\n\n            int[] tail = new int[(n * (n + 1)) >> 1];\n            int length = 1; // always points empty slot in tail\n            tail[0] = mat[0][0];\n            for(int i = 0; i < n; i++) {\n                for(int j = i; j < n; j++) {\n                    if (mat[i][j] > tail[length - 1]) {\n                        tail[length++] = mat[i][j];\n                    }\n                    else {\n                        int idx = Arrays.binarySearch(\n                            tail, 0, length - 1, mat[i][j]);\n                        if (idx < 0)\n                            idx = -1 * idx - 1;\n                        tail[idx] = mat[i][j];\n                    }\n                }\n            }\n            pn(length);\n        }\n\n        final static Comparator<Pair> com = (o1, o2) -> {\n            if(!o1.equals(o2))\n                return o1.s.compareTo(o2.s);\n            return Integer.compare(o1.ind, o2.ind);\n        };\n\n\n        String n() {\n            return in.next();\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n        void pn(String sz) {\n            out.println(sz);\n        }\n\n        void pn(double dx) {\n            out.println(dx);\n        }\n\n        class Pair {\n            String s;\n            int ind;\n            Pair(String s, int ind) {\n                this.s = s;\n                this.ind = ind;\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 2e18 + 100;\nconst int maxn = 1e6 + 100;\nint a[maxn], b[maxn];\nchar s[maxn];\nint f[5010][5010];\nint dp[maxn];\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    memset(dp, 0, sizeof(int) * (n + 10));\n    cin >> (s + 1);\n    for (int i = n; i >= 1; i--) {\n      for (int j = n; j >= 1; j--) {\n        f[i][j] = 0;\n      }\n    }\n    for (int i = n; i >= 1; i--) {\n      for (int j = n; j >= 1; j--) {\n        if (s[i] == s[j]) {\n          f[i][j] = f[i + 1][j + 1] + 1;\n        } else\n          f[i][j] = 0;\n      }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      dp[i] = n - i + 1;\n      for (int j = 1; j < i; j++) {\n        if (s[i + f[i][j]] > s[j + f[i][j]]) {\n          dp[i] = max(dp[i], dp[j] + n - i + 1 - f[i][j]);\n        }\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n% : pragma GCC optimize(3) % : pragma GCC optimize(\"Ofast\") %\n    : pragma GCC optimize(\"inline\") % : pragma GCC optimize(\"-fgcse\") %\n    : pragma GCC optimize(\"-fgcse-lm\") % : pragma GCC optimize(\"-fipa-sra\") %\n    : pragma GCC optimize(\"-ftree-pre\") % : pragma GCC optimize(\"-ftree-vrp\") %\n    : pragma GCC optimize(\"-fpeephole2\") %\n    : pragma GCC optimize(\"-ffast-math\") %\n    : pragma GCC optimize(\"-fsched-spec\") %\n    : pragma GCC optimize(\"unroll-loops\") %\n    : pragma GCC optimize(\"-falign-jumps\") %\n    : pragma GCC optimize(\"-falign-loops\") %\n    : pragma GCC optimize(\"-falign-labels\") %\n    : pragma GCC optimize(\"-fdevirtualize\") %\n    : pragma GCC optimize(\"-fcaller-saves\") %\n    : pragma GCC optimize(\"-fcrossjumping\") %\n    : pragma GCC optimize(\"-fthread-jumps\") %\n    : pragma GCC optimize(\"-funroll-loops\") %\n    : pragma GCC optimize(\"-fwhole-program\") %\n    : pragma GCC optimize(\"-freorder-blocks\") %\n    : pragma GCC optimize(\"-fschedule-insns\") %\n    : pragma GCC optimize(\"inline-functions\") %\n    : pragma GCC optimize(\"-ftree-tail-merge\") %\n    : pragma GCC optimize(\"-fschedule-insns2\") %\n    : pragma GCC optimize(\"-fstrict-aliasing\") %\n    : pragma GCC optimize(\"-fstrict-overflow\") %\n    : pragma GCC optimize(\"-falign-functions\") %\n    : pragma GCC optimize(\"-fcse-skip-blocks\") %\n    : pragma GCC optimize(\"-fcse-follow-jumps\") %\n    : pragma GCC optimize(\"-fsched-interblock\") %\n    : pragma GCC optimize(\"-fpartial-inlining\") %\n    : pragma GCC optimize(\"no-stack-protector\") %\n    : pragma GCC optimize(\"-freorder-functions\") %\n    : pragma GCC optimize(\"-findirect-inlining\") %\n    : pragma GCC optimize(\"-fhoist-adjacent-loads\") %\n    : pragma GCC optimize(\"-frerun-cse-after-loop\") %\n    : pragma GCC optimize(\"inline-small-functions\") %\n    : pragma GCC optimize(\"-finline-small-functions\") %\n    : pragma GCC optimize(\"-ftree-switch-conversion\") %\n    : pragma GCC optimize(\"-foptimize-sibling-calls\") %\n    : pragma GCC optimize(\"-fexpensive-optimizations\") %\n    : pragma GCC optimize(\"-funsafe-loop-optimizations\") %\n    : pragma GCC optimize(\"inline-functions-called-once\") %\n    : pragma GCC optimize(\"-fdelete-null-pointer-checks\") using namespace std;\nconst int N = 5005;\nconst long long P = 998244353LL;\nconst int inf = 0x3f3f3f3f;\nint T, n, lcp[N][N];\nint sa[N], rk[N], oldrk[N << 1], id[N], px[N], cnt[N], ht[N];\nchar str[N];\ninline bool cmp(int x, int y, int w) {\n  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\ninline void saInit() {\n  memset(cnt, 0, sizeof(cnt));\n  int m = 200, p;\n  for (int i = 1; i <= n; i++) ++cnt[rk[i] = str[i]];\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1, m = p) {\n    p = 0;\n    for (int i = n; i > n - w; i--) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 1; i <= n; i++) ++cnt[px[i] = rk[id[i]]];\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[px[i]]--] = id[i];\n    memcpy(oldrk, rk, sizeof(rk));\n    p = 0;\n    for (int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n  }\n  for (int i = 1; i <= n; i++) rk[sa[i]] = i;\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (k) --k;\n    for (; str[i + k] == str[sa[rk[i] - 1] + k]; ++k)\n      ;\n    ht[rk[i]] = k;\n  }\n}\ninline void lcpInit() {\n  for (int j = 1; j <= n; j++) {\n    lcp[j][j] = n - sa[j] + 1;\n    for (int i = j - 1; i >= 1; i--) {\n      lcp[i][j] = min(lcp[i + 1][j], ht[i + 1]);\n      lcp[j][i] = lcp[i][j];\n    }\n  }\n}\ninline bool seqCmp(pair<int, int> u, pair<int, int> v) {\n  int a = u.first, b = u.second, c = v.first, d = v.second;\n  int t = lcp[rk[a]][rk[c]];\n  if (t >= b - a + 1 || t >= d - c + 1)\n    return b - a < d - c;\n  else\n    return rk[a] < rk[c];\n}\nint main() {\n  scanf(\"%d\", &T);\n  for (; T--;) {\n    scanf(\"%d\", &n);\n    scanf(\"%s\", str + 1);\n    saInit();\n    lcpInit();\n    vector<pair<int, int> > f;\n    for (int i = 1; i <= n; i++) {\n      for (int j = i; j <= n; j++) {\n        pair<int, int> cur = pair<int, int>(i, j);\n        if (!f.empty()) {\n          if (!seqCmp(cur, f.back()))\n            f.emplace_back(pair<int, int>(i, j));\n          else {\n            int p = lower_bound(f.begin(), f.end(), cur, seqCmp) - f.begin();\n            f[p] = pair<int, int>(i, j);\n          }\n        } else\n          f.emplace_back(pair<int, int>(i, j));\n      }\n    }\n    printf(\"%d\\n\", f.size());\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int w = 0, flg = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') {\n      flg = -1;\n    }\n    ch = getchar();\n  }\n  while (ch <= '9' && ch >= '0') {\n    w = w * 10 + ch - '0', ch = getchar();\n  }\n  return w * flg;\n}\nint T;\nint n, del[5010][5010], dp[5010], ans;\nchar s[5010];\nvoid solve() {\n  for (int i = (1); i <= (n); i++) {\n    dp[i] = 0;\n    for (int j = (1); j <= (i - 1); j++) del[i][j] = 0;\n  }\n  n = read(), ans = 0;\n  scanf(\"%s\", s + 1);\n  for (int i = (n); i >= (1); i--) {\n    dp[i] = max(dp[i], n - i + 1);\n    ans = max(ans, dp[i]);\n    for (int j = (i - 1); j >= (1); j--) {\n      if (s[i] > s[j]) {\n        del[i][j] = n - j + 1;\n        dp[j] = max(dp[j], dp[i] + del[i][j]);\n      } else if (s[i] == s[j]) {\n        del[i][j] = del[i + 1][j + 1];\n        if (del[i + 1][j + 1]) dp[j] = max(dp[j], dp[i] + del[i][j]);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  T = read();\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solution solver = new Solution();\n        boolean multipleTC = true;\n        int testCount = multipleTC ? Integer.parseInt(in.next()) : 1;\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(in, out, i);\n        out.close();\n\n    }\n\n    static class Solution {\n        PrintWriter out;\n        InputReader in;\n\n        //https://www.geeksforgeeks.org/suffix-array-set-2-a-nlognlogn-algorithm/\n\n        public static class Suffix implements Comparable<Suffix> {\n            int index;\n            int rank;\n            int next;\n            public Suffix(int ind, int r, int nr) {\n                index = ind;\n                rank = r;\n                next = nr;\n            }\n            public int compareTo(Suffix s)\n            {\n                if (rank != s.rank) return Integer.compare(rank, s.rank);\n                return Integer.compare(next, s.next);\n            }\n        }\n\n        public static int[] suffixArray(String s) {\n            int n = s.length();\n            Suffix[] su = new Suffix[n];\n            for (int i = 0; i < n; i++) {\n                su[i] = new Suffix(i, s.charAt(i) - '$', 0);\n            }\n            for (int i = 0; i < n; i++)\n                su[i].next = (i + 1 < n ? su[i + 1].rank : -1);\n\n            Arrays.sort(su);\n            int[] ind = new int[n];\n\n            for (int length = 4; length < 2 * n; length <<= 1) {\n\n                int rank = 0, prev = su[0].rank;\n                su[0].rank = rank;\n                ind[su[0].index] = 0;\n                for (int i = 1; i < n; i++)\n                {\n                    if (su[i].rank == prev &&\n                        su[i].next == su[i - 1].next)\n                    {\n                        prev = su[i].rank;\n                        su[i].rank = rank;\n                    }\n                    else\n                    {\n                        // Otherwise increment rank and assign\n                        prev = su[i].rank;\n                        su[i].rank = ++rank;\n                    }\n                    ind[su[i].index] = i;\n                }\n\n                // Assign next rank to every suffix\n                for (int i = 0; i < n; i++)\n                {\n                    int nextP = su[i].index + length / 2;\n                    su[i].next = nextP < n ?\n                        su[ind[nextP]].rank : -1;\n                }\n\n                // Sort the suffixes according\n                // to first k characters\n                Arrays.sort(su);\n            }\n\n            // Store indexes of all sorted\n            // suffixes in the suffix array\n            int[] suf = new int[n];\n\n            for (int i = 0; i < n; i++)\n                suf[i] = su[i].index;\n\n            // Return the suffix array\n            return suf;\n        }\n\n        public void solve(InputReader in, PrintWriter out, int test) {\n            this.out = out;\n            this.in = in;\n\n            int n = ni();\n            String s = n();\n\n            int[] suff_arr = suffixArray(s);\n\n            Pair[] suffixes = new Pair[n];\n            for(int i = 0; i < n; i++)\n                suffixes[i] = new Pair(\"\", suff_arr[i]);\n            int[] lcp = new int[n];\n            for(int i = 0; i < n - 1; i++) {\n                int ptr1 = suffixes[i].ind, ptr2 = suffixes[i + 1].ind;\n                while(ptr1 < n && ptr2 < n && s.charAt(ptr1) == s.charAt(ptr2)) {\n                    ptr1++;\n                    ptr2++;\n                }\n                lcp[i] = ptr1 - suffixes[i].ind;\n            }\n            //pn(Arrays.toString(lcp));\n\n            int[][] mat = new int[n][n];\n            int[] ptr = new int[n];\n            int done = 0;\n            int op = 0;\n            for(int i = 0; i < n; i++) {\n                op++;\n                for(int k = ptr[i]; k < n - suffixes[i].ind; k++) {\n                    op++;\n                    int currLengthPrefix = k + 1;\n                    int j = i;\n                    //pn(s.substring(suffixes[i].ind, suffixes[i].ind + k + 1) + \" \" + done);\n                    mat[suffixes[i].ind][suffixes[i].ind + k] = done;\n                    while (j < n - 1 && lcp[j] >= currLengthPrefix) {\n                        op++;\n                        j++;\n                        mat[suffixes[j].ind][suffixes[j].ind + k] = done;\n                        ptr[j]++;\n                    }\n                    done++;\n                }\n            }\n\n            // TreeMap<Integer, Integer> map = new TreeMap<>();\n            // int ans = 1;\n            // for(int i = 0; i < n; i++) {\n            //     for(int j = i; j < n; j++) {\n            //         if(map.lowerKey(mat[i][j]) != null) {\n            //             int x = map.get(map.lowerKey(mat[i][j]));\n            //             map.put(mat[i][j], x + 1);\n            //             ans = Math.max(x + 1, ans);\n            //         }\n            //         else\n            //             map.put(mat[i][j], 1);\n            //     }\n            // }\n            int[] pos = new int[(n * (n + 1)) >> 1];\n            int x = 0;\n            for(int i = 0; i < n; i++) {\n                for(int j = i; j < n; j++)\n                    pos[x++] = mat[i][j];\n            }\n            pn(LongestIncreasingSubsequenceLength(pos));\n        }\n\n        int LongestIncreasingSubsequenceLength(int v[])\n        {\n            if (v.length == 0) // boundary case\n                return 0;\n\n            int[] tail = new int[v.length];\n            int length = 1; // always points empty slot in tail\n            tail[0] = v[0];\n\n            for (int i = 1; i < v.length; i++) {\n\n                if (v[i] > tail[length - 1]) {\n                    // v[i] extends the largest subsequence\n                    tail[length++] = v[i];\n                }\n                else {\n                    // v[i] will extend a subsequence and\n                    // discard older subsequence\n\n                    // find the largest value just smaller than\n                    // v[i] in tail\n\n                    // to find that value do binary search for\n                    // the v[i] in the range from begin to 0 +\n                    // length\n                    int idx = Arrays.binarySearch(\n                        tail, 0, length - 1, v[i]);\n\n                    // binarySearch in java returns negative\n                    // value if searched element is not found in\n                    // array\n\n                    // this negative value stores the\n                    // appropriate place where the element is\n                    // supposed to be stored\n                    if (idx < 0)\n                        idx = -1 * idx - 1;\n\n                    // replacing the existing subsequene with\n                    // new end value\n                    tail[idx] = v[i];\n                }\n            }\n            return length;\n        }\n\n        int CeilIndex(int[] A, int l, int r, int key) {\n            while (r - l > 1) {\n                int m = l + (r - l) / 2;\n                if (A[m] >= key)\n                    r = m;\n                else\n                    l = m;\n            }\n            return r;\n        }\n        int LongestIncreasingSubsequenceLength(int[] A, int size) {\n            int[] tailTable = new int[size];\n            int len;\n            tailTable[0] = A[0];\n            len = 1;\n            out.print(len + \" \");\n            for (int i = 1; i < size; i++) {\n                if (A[i] < tailTable[0])\n                    tailTable[0] = A[i];\n                else if (A[i] > tailTable[len - 1])\n                    tailTable[len++] = A[i];\n                else\n                    tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i];\n                out.print(len + \" \");\n            }\n            pn(\"\");\n            return len;\n        }\n\n        final static Comparator<Pair> com = (o1, o2) -> {\n            if(!o1.equals(o2))\n                return o1.s.compareTo(o2.s);\n            return Integer.compare(o1.ind, o2.ind);\n        };\n\n\n        String n() {\n            return in.next();\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n        void pn(String sz) {\n            out.println(sz);\n        }\n\n        void pn(double dx) {\n            out.println(dx);\n        }\n\n        class Pair {\n            String s;\n            int ind;\n            Pair(String s, int ind) {\n                this.s = s;\n                this.ind = ind;\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long read() {\n  char c;\n  long long w = 1;\n  while ((c = getchar()) > '9' || c < '0')\n    if (c == '-') w = -1;\n  long long ans = c - '0';\n  while ((c = getchar()) >= '0' && c <= '9')\n    ans = (ans << 1) + (ans << 3) + c - '0';\n  return ans * w;\n}\nconst int xx = 5005;\nchar s[xx];\nint T;\nvector<pair<int, int> > v[xx];\nint rk[xx], sa[xx], t[xx], old[xx << 1], id[xx], h[xx], mn[xx][14], lg[xx], p,\n    n, m;\nvoid pre() {\n  n = strlen(s + 1);\n  m = 500;\n  memset(sa, 0, sizeof(sa));\n  memset(t, 0, sizeof(t));\n  memset(old, 0, sizeof(old));\n  for (int i = 1; i <= n; i++) t[rk[i] = s[i]]++;\n  for (int i = 1; i <= m; i++) t[i] += t[i - 1];\n  for (int i = 1; i <= n; i++) sa[t[rk[i]]--] = i;\n  for (int l = 1; l <= n; l <<= 1, m = p) {\n    p = 0;\n    for (int i = n - l + 1; i <= n; i++) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > l) id[++p] = sa[i] - l;\n    for (int i = 1; i <= m; i++) t[i] = 0;\n    for (int i = 1; i <= n; i++) t[rk[i]]++;\n    for (int i = 1; i <= m; i++) t[i] += t[i - 1];\n    for (int i = n; i >= 1; i--) sa[t[rk[id[i]]]--] = id[i];\n    for (int i = 1; i <= n; i++) old[i] = rk[i];\n    p = 0;\n    for (int i = 1; i <= n; i++)\n      rk[sa[i]] =\n          (old[sa[i]] == old[sa[i - 1]] && old[sa[i] + l] == old[sa[i - 1] + l])\n              ? p\n              : ++p;\n    if (p == n) break;\n  }\n  p = 0;\n  memset(mn, 0x3f, sizeof(mn));\n  for (int i = 1; i <= n; i++) {\n    if (p) p--;\n    while (s[i + p] == s[sa[rk[i] - 1] + p]) p++;\n    h[rk[i]] = p;\n    mn[rk[i]][0] = p;\n  }\n  for (int j = 1; j <= 13; j++) {\n    for (int i = 1; i <= n; i++) {\n      if (i + (1 << j - 1) <= n)\n        mn[i][j] = min(mn[i][j - 1], mn[i + (1 << j - 1)][j - 1]);\n      else\n        mn[i][j] = mn[i][j - 1];\n    }\n  }\n}\nint lcp(int a, int b) {\n  if (a == b) return n - sa[a] + 1;\n  if (a > b) swap(a, b);\n  a++;\n  int k = lg[b - a + 1];\n  return min(mn[a][k], mn[b - (1 << k) + 1][k]);\n}\nint f[xx][xx];\nint main() {\n  lg[0] = -1;\n  for (int i = 1; i < xx; i++) lg[i] = lg[i - 1] + (i == (i & -i));\n  int T = read();\n  while (T--) {\n    n = read();\n    scanf(\"%s\", s + 1);\n    pre();\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n      for (int j = 1; j <= n - sa[i] + 1; j++) f[i][j] = 0;\n    for (int i = 1; i <= n; i++) {\n      int now = 1, len = 0, res = 0, p = rk[i];\n      for (int j = 1; j <= n - i + 1; j++) {\n        while (lcp(p, now) < j) res = max(res, f[now][n - sa[now] + 1]), now++;\n        res = max(res, f[p][j - 1]);\n        f[p][j] = res + 1;\n      }\n    }\n    for (int i = 1; i <= n; i++) ans = max(ans, f[i][n - sa[i] + 1]);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nusing v2d = vector<vector<T> >;\ntemplate <class T>\nbool uin(T &a, T b) {\n  return a > b ? (a = b, true) : false;\n}\ntemplate <class T>\nbool uax(T &a, T b) {\n  return a < b ? (a = b, true) : false;\n}\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\nconst int maxN = 5e3 + 10;\nint n, dp[maxN], lcp[maxN][maxN];\nchar s[maxN];\nvoid solve() {\n  cin >> n >> (s + 1);\n  for (int i = 1; i <= (int)(n); ++i) {\n    lcp[n + 1][i] = 0;\n  }\n  for (int i = n; i; i--) {\n    for (int j = 1; j <= (int)(i - 1); ++j) {\n      lcp[i][j] = 0;\n      if (s[i] == s[j]) {\n        lcp[i][j] = lcp[i + 1][j + 1] + 1;\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= (int)(n); ++i) {\n    dp[i] = n - i + 1;\n    for (int j = 1; j <= (int)(i - 1); ++j) {\n      int c = lcp[i][j];\n      if (i + c <= n) {\n        if (s[i + c] > s[j + c]) {\n          uax(dp[i], dp[j] + n - i - c + 1);\n        }\n      }\n    }\n    uax(ans, dp[i]);\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T = 1;\n  cin >> T;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\nusing namespace std;\nconst long long inf = (1ll << 60);\nconst long long iinf = 2147483647;\nconst long long mod = 1e9 + 7;\nconst long long maxn = 8000;\nconst double PI = acos(-1);\nlong long pw(long long x, long long p) {\n  long long ret = 1;\n  while (p > 0) {\n    if (p & 1) {\n      ret *= x;\n      ret %= mod;\n    }\n    x *= x;\n    x %= mod;\n    p >>= 1;\n  }\n  return ret;\n}\nlong long inv(long long a) { return pw(a, mod - 2); }\nlong long cp[5005][5005];\nbool leq[5005][5005];\nlong long dp[5005];\nsigned main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    string second;\n    cin >> second;\n    for (long long i = (0); i < (n + 2); i++)\n      for (long long j = (0); j < (n + 2); j++) cp[i][j] = 0, leq[i][j] = 1;\n    for (long long i = n - 1; i >= 0; --i) {\n      for (long long j = n - 1; j >= 0; --j) {\n        if (second[i] == second[j]) {\n          cp[i][j] = cp[i + 1][j + 1] + 1;\n          leq[i][j] = leq[i + 1][j + 1];\n        } else {\n          cp[i][j] = 0;\n          leq[i][j] = second[i] < second[j];\n        }\n      }\n    };\n    ;\n    long long ret = 0;\n    for (long long i = 1; i <= n; ++i) {\n      dp[i] = 0;\n      for (long long j = 0; j < i; ++j) {\n        if (j == 0 || leq[j - 1][i - 1])\n          dp[i] =\n              max(dp[i], n - i + 1 + dp[j] - (j == 0 ? 0 : cp[i - 1][j - 1]));\n      }\n      ret = max(ret, dp[i]);\n      ;\n      ;\n    }\n    cout << ret << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconst int INF = 1e9;\nconst int NEGINF = 0xC0C0C0C0;\nconst int NULO = -1;\nconst double EPS = 1e-10;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e17;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\nvector<int> sort_cyclic_shifts(string const &s) {\n  int n = s.size();\n  const int alphabet = 256;\n  vector<int> p(n), c(n), cnt(max(alphabet, n), 0);\n  for (int i = 0; i < n; i++) {\n    cnt[s[i]]++;\n  }\n  for (int i = 1; i < alphabet; i++) {\n    cnt[i] += cnt[i - 1];\n  }\n  for (int i = 0; i < n; i++) {\n    p[--cnt[s[i]]] = i;\n  }\n  c[p[0]] = 0;\n  int classes = 1;\n  for (int i = 1; i < n; i++) {\n    if (s[p[i]] != s[p[i - 1]]) {\n      classes++;\n    }\n    c[p[i]] = classes - 1;\n  }\n  vector<int> pn(n), cn(n);\n  for (int h = 0; (1 << h) < n; ++h) {\n    for (int i = 0; i < n; i++) {\n      pn[i] = p[i] - (1 << h);\n      if (pn[i] < 0) {\n        pn[i] += n;\n      }\n    }\n    fill(cnt.begin(), cnt.begin() + classes, 0);\n    for (int i = 0; i < n; i++) {\n      cnt[c[pn[i]]]++;\n    }\n    for (int i = 1; i < classes; i++) {\n      cnt[i] += cnt[i - 1];\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      p[--cnt[c[pn[i]]]] = pn[i];\n    }\n    cn[p[0]] = 0;\n    classes = 1;\n    for (int i = 1; i < n; i++) {\n      pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\n      pair<int, int> prev = {c[p[i - 1]], c[(p[i - 1] + (1 << h)) % n]};\n      if (cur != prev) {\n        ++classes;\n      }\n      cn[p[i]] = classes - 1;\n    }\n    c.swap(cn);\n  }\n  return p;\n}\nvector<int> suffix_array_construction(string s) {\n  s += \"$\";\n  vector<int> sorted_shifts = sort_cyclic_shifts(s);\n  sorted_shifts.erase(sorted_shifts.begin());\n  return sorted_shifts;\n}\nvector<int> lcp_construction(string const &s, vector<int> const &p) {\n  int n = s.size();\n  vector<int> rank(n, 0);\n  for (int i = 0; i < n; i++) {\n    rank[p[i]] = i;\n  }\n  int k = 0;\n  vector<int> lcp(n - 1, 0);\n  for (int i = 0; i < n; i++) {\n    if (rank[i] == n - 1) {\n      k = 0;\n      continue;\n    }\n    int j = p[rank[i] + 1];\n    while (i + k < n && j + k < n && s[i + k] == s[j + k]) {\n      k++;\n    }\n    lcp[rank[i]] = k;\n    if (k) {\n      k--;\n    }\n  }\n  return lcp;\n}\nconst int maxn = 5e3 + 10;\nll dp[maxn];\nvector<int> p;\nvector<int> lcp;\nint n;\nll solve(int i) {\n  int l = 1e9;\n  ll &ans = dp[i];\n  if (ans != -1) {\n    return ans;\n  }\n  ans = 0;\n  for (int j = i + 1; j < n; j++) {\n    l = min(l, lcp[j - 1]);\n    if (p[j] > p[i]) {\n      ans = max(ans, solve(j) + (n - p[j] - l));\n    }\n  }\n  return ans;\n}\nvoid solveTestCase() {\n  cin >> n;\n  string s;\n  cin >> s;\n  p = suffix_array_construction(s);\n  lcp = lcp_construction(s, p);\n  memset(dp, -1, sizeof(dp));\n  ll ans = 0;\n  for (int i = 0; i < n; i++) {\n    ans = max(ans, n - p[i] + solve(i));\n  }\n  cout << ans << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int test = 1;\n  cin >> test;\n  while (test--) {\n    solveTestCase();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint const N = 10010;\nusing namespace std;\nint arr[3][10010], cnt[10010], mc[256], h[10010], *sa, *ta, *r, *tr, sz;\nvoid sa_init(char *str, int len) {\n  sa = arr[0], ta = arr[1], r = arr[2], sz = 0;\n  for (int i = 0; i < len; i++) ta[i] = str[i];\n  sort(ta, ta + len);\n  for (int i = 1; i <= len; i++) {\n    if (ta[i] != ta[i - 1] || i == len) cnt[mc[ta[i - 1]] = sz++] = i;\n  }\n  for (int i = len - 1; i >= 0; i--) sa[--cnt[r[i] = mc[str[i]]]] = i;\n  for (int k = 1; k < len && r[sa[len - 1]] < len - 1; k <<= 1) {\n    for (int i = 0; i < len; i++) cnt[r[sa[i]]] = i + 1;\n    for (int i = len - 1; i >= 0; i--) {\n      if (sa[i] >= k) ta[--cnt[r[sa[i] - k]]] = sa[i] - k;\n    }\n    for (int i = len - k; i < len; i++) ta[--cnt[r[i]]] = i;\n    tr = sa, sa = ta, tr[sa[0]] = 0;\n    for (int i = 1; i < len; i++) {\n      tr[sa[i]] =\n          tr[sa[i - 1]] + (r[sa[i]] != r[sa[i - 1]] || sa[i - 1] + k >= len ||\n                           r[sa[i] + k] != r[sa[i - 1] + k]);\n    }\n    ta = r, r = tr;\n  }\n}\nvoid h_init(char *str, int len) {\n  for (int i = 0, d = 0, j; i < len; i++) {\n    if (str[i] == '#' || r[i] == len - 1)\n      h[r[i]] = d = 0;\n    else {\n      if (d) d--;\n      j = sa[r[i] + 1];\n      while (str[i + d] != '#' && str[j + d] != '#' && str[i + d] == str[j + d])\n        d++;\n      h[r[i]] = d;\n    }\n  }\n}\nchar str[10010];\nint f[N];\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\" %s\", str);\n    sa_init(str, n);\n    h_init(str, n);\n    memset(f, (0), sizeof f);\n    for (int i = 0; i < (n); ++i) {\n      int t = sa[i], w = n - t;\n      int th = 0x3f3f3f3f;\n      int mx = w;\n      for (int j = i - 1; j >= 0; --j) {\n        th = min(th, h[j]);\n        if (sa[j] < sa[i]) {\n          mx = max(mx, w - th + f[j]);\n        }\n      }\n      f[i] = mx;\n    }\n    int ans = 0;\n    for (int i = 0; i < (n); ++i) ans = max(ans, f[i]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e3 + 10;\nconst int mod = 1e9 + 7;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 1) + (x << 3) + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nint T, n, g[maxn][maxn], f[maxn], ans;\nchar s[maxn];\nint main() {\n  T = read();\n  while (T--) {\n    n = read();\n    ans = 0;\n    scanf(\"%s\", s + 1);\n    for (int i = n + 1; i >= 1; i--)\n      for (int j = n + 1; j >= 1; j--)\n        if (s[i] == s[j])\n          g[i][j] = 1 + g[i + 1][j + 1];\n        else\n          g[i][j] = 0;\n    for (int i = 1; i <= n; i++) {\n      f[i] = n - i + 1;\n      for (int j = 1; j < i; j++)\n        if (s[i + g[i][j]] > s[j + g[i][j]])\n          f[i] = max(f[i], f[j] + n - i - g[i][j] + 1);\n      ans = max(ans, f[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\npair<long long int, long long int> operator+(\n    pair<long long int, long long int> a,\n    pair<long long int, long long int> b) {\n  return {a.first + b.first, (a.second + b.second) % 1000000321};\n}\npair<long long int, long long int> operator*(\n    pair<long long int, long long int> a,\n    pair<long long int, long long int> b) {\n  return {a.first * b.first, (a.second * b.second) % 1000000321};\n}\npair<long long int, long long int> operator-(\n    pair<long long int, long long int> a,\n    pair<long long int, long long int> b) {\n  return {a.first - b.first, (a.second + 1000000321 - b.second) % 1000000321};\n}\nmt19937 gen(__builtin_ia32_rdtsc());\nuniform_int_distribution<long long int> dist(256, 1000000321 - 1);\nstring s;\npair<long long int, long long int> p[5010], h[5010];\nlong long int n, suff[5010];\nlong long int lcp(long long int i, long long int j, long long int l,\n                  long long int r) {\n  if (l == r) return l;\n  long long int m = (l + r + 1) / 2;\n  return ((h[(i) + (m)] - h[i] * p[m]) == (h[(j) + (m)] - h[j] * p[m]))\n             ? lcp(i, j, m, r)\n             : lcp(i, j, l, m - 1);\n}\nbool lexLess(long long int i, long long int lI, long long int j,\n             long long int lJ) {\n  if (((h[(i) + (min(lI, lJ))] - h[i] * p[min(lI, lJ)]) ==\n       (h[(j) + (min(lI, lJ))] - h[j] * p[min(lI, lJ)])))\n    return lI < lJ;\n  long long int m = lcp(i, j, 0, min(lI, lJ) - 1);\n  return s[i + m] < s[j + m];\n}\nlong long int bt[5010], rmq[5010][13];\nlong long int f(long long int a, long long int b) { return min(a, b); }\nlong long int query(long long int l, long long int r) {\n  return f(rmq[l][bt[r - l]], rmq[r - (1 << bt[r - l])][bt[r - l]]);\n}\nlong long int dp[5010], id[5010];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  for (long long int j = 0; j < (13); ++j)\n    for (long long int i = (1 << j); i < (min(5010, 1 << (j + 1))); ++i)\n      bt[i] = j;\n  long long int tc;\n  cin >> tc;\n  while (tc--) {\n    cin >> n >> s;\n    p[0] = {1, 1}, p[1] = {dist(gen) | 1, dist(gen)};\n    for (long long int i = 1; i < (s.size() + 1); ++i)\n      p[i] = p[i - 1] * p[1],\n      h[i] = h[i - 1] * p[1] +\n             pair<long long int, long long int>{s[i - 1], s[i - 1]};\n    iota(suff, suff + n, 0);\n    sort(suff, suff + n, [](long long int i, long long int j) {\n      return lexLess(i, n - i, j, n - j);\n    });\n    for (long long int i = 0; i < (n); ++i) id[suff[i]] = i;\n    for (long long int i = 0; i < (n - 1); ++i)\n      rmq[i][0] =\n          lcp(suff[i], suff[i + 1], 0, min(n - suff[i], n - suff[i + 1]));\n    for (long long int j = 1; j < (13); ++j)\n      for (long long int i = 0; i < (n - 1); ++i) {\n        long long int i2 = i + (1 << (j - 1));\n        if (i2 < n)\n          rmq[i][j] = f(rmq[i][j - 1], rmq[i2][j - 1]);\n        else\n          rmq[i][j] = rmq[i][j - 1];\n      }\n    for (long long int i = n - 1; i > (-1); --i) {\n      dp[i] = n - i;\n      for (long long int j = i + 1; j < (n); ++j)\n        if (id[j] > id[i])\n          dp[i] = max(dp[i], dp[j] + n - i - query(id[i], id[j]));\n    }\n    cout << *max_element(dp, dp + n) << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5005;\nint lcp[N][N];\nint dp[N];\nchar c[N];\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%s\", c + 1);\n    for (int i = n; i >= 1; i--) {\n      for (int j = n; j >= 1; j--) {\n        if (c[i] == c[j]) {\n          lcp[i][j] = lcp[i + 1][j + 1] + 1;\n        } else {\n          lcp[i][j] = 0;\n        }\n      }\n    }\n    for (int i = 1; i <= n; i++) {\n      dp[i] = n - i + 1;\n      for (int j = 1; j < i; j++) {\n        if (c[i + lcp[i][j]] > c[j + lcp[i][j]])\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - lcp[i][j]);\n      }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      ans = max(ans, dp[i]);\n    }\n    printf(\"%d\\n\", ans);\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= n; j++) {\n        lcp[i][j] = 0;\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long func(string &s, long long i, long long j) {\n  long long ind = 0;\n  if (ind < 0) ind = 0;\n  while (j + ind < s.length()) {\n    if (s[i + ind] > s[j + ind]) return 1000000007;\n    if (s[i + ind] < s[j + ind])\n      return ind;\n    else\n      ind++;\n  }\n  return 1000000007;\n}\nvoid solve() {\n  long long n;\n  string s;\n  cin >> n;\n  cin >> s;\n  long long arr[n + 1][n + 1];\n  for (long long i = 1; i < n + 1; i++) {\n    if (s[i - 1] == s[n - 1])\n      arr[i][n] = 1;\n    else\n      arr[i][n] = 0;\n  }\n  for (long long i = n - 2; i >= 1; i--) {\n    for (long long j = i + 1; j < n; j++) {\n      if (s[i - 1] == s[j - 1])\n        arr[i][j] = 1 + arr[i + 1][j + 1];\n      else\n        arr[i][j] = 0;\n    }\n  }\n  long long dp[n + 1];\n  for (long long i = 0; i < n + 1; i++) dp[i] = 0;\n  dp[n] = 1;\n  for (long long i = n - 1; i >= 1; i--) {\n    long long t = 0;\n    for (long long j = i + 1; j <= n; j++) {\n      long long x = arr[i][j];\n      if (j - 1 + x >= n) continue;\n      bool y = s[i - 1 + x] > s[j - 1 + x];\n      if (!y) t = max(t, dp[j] - x);\n    }\n    dp[i] = n - i + 1 + t;\n  }\n  sort(dp, dp + n + 1);\n  cout << dp[n] << endl;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long T = 1;\n  cin >> T;\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing int16 = short int;\nconst int N = 10005;\nint16 lcp[N][N];\nint dp[N];\nbool is_greater(const std::string& s, int x, int y) {\n  if (lcp[x][y] == static_cast<int>(s.size()) - x) {\n    return false;\n  }\n  return s[x + lcp[x][y]] > s[y + lcp[x][y]];\n}\nint get_score(const std::string& s, int x, int y) {\n  if (is_greater(s, x, y)) {\n    return dp[y] + static_cast<int>(s.size()) - x - lcp[x][y];\n  }\n  return 0;\n}\nint main() {\n  int t;\n  std::cin >> t;\n  while (t--) {\n    int n;\n    std::cin >> n;\n    std::string s;\n    std::cin >> s;\n    for (int i = 0; i <= n; ++i) {\n      for (int j = 0; j <= n; ++j) lcp[i][j] = 0;\n    }\n    for (int i = n - 1; ~i; --i) {\n      for (int j = n - 1; ~j; --j) {\n        if (i == j) {\n          lcp[i][j] = n - i;\n        } else if (s[i] != s[j]) {\n          lcp[i][j] = 0;\n        } else {\n          lcp[i][j] = lcp[i + 1][j + 1] + 1;\n        }\n      }\n    }\n    int ans = n;\n    dp[0] = n;\n    for (int i = 1; i < n; ++i) {\n      dp[i] = n - i;\n      for (int j = 0; j < i; ++j) {\n        dp[i] = std::max(dp[i], get_score(s, i, j));\n      }\n      ans = std::max(ans, dp[i]);\n    }\n    std::cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\nstream Butter!\neggyHide eggyVengeance\nI need U\nxiao rerun when\n */\nimport static java.lang.Math.*;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class x1562E\n{\n    public static void main(String hi[]) throws Exception\n    {\n        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(infile.readLine());\n        int T = Integer.parseInt(st.nextToken());\n        StringBuilder sb = new StringBuilder();\n        while(T-->0)\n        {\n            st = new StringTokenizer(infile.readLine());\n            int N = Integer.parseInt(st.nextToken());\n            char[] arr = infile.readLine().trim().toCharArray();\n            int[][] prefix = new int[N][N];\n            prefix[N-1][N-1] = 1;\n            for(int a=N-1; a >= 0; a--)\n                for(int b=N-1; b >= 0; b--)\n                    if(arr[a] == arr[b])\n                    {\n                        prefix[a][b] = 1;\n                        if(max(a, b)+1 < N)\n                            prefix[a][b] += prefix[a+1][b+1];\n                    }\n            int[] dp = new int[N];\n            for(int i=0; i < N; i++)\n            {\n                dp[i] = N-i;\n                for(int j=0; j < i; j++)\n                {\n                    int len = prefix[i][j];\n                    if(i+len < N && arr[j+len] < arr[i+len])\n                        dp[i] = max(dp[i], dp[j]+N-(i+len));\n                }\n            }\n            int res = 0;\n            for(int x: dp)\n                res = max(res, x);\n            sb.append(res+\"\\n\");\n        }\n        System.out.print(sb);\n    }\n}\n/*\nadcefb\n\ndcef, dcefb, efb,\n */"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err(istream_iterator<string> it) {}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n  cerr << ' ' << *it << \" = \" << a;\n  err(++it, args...);\n}\ninline void op() { cout << '\\n'; }\ntemplate <typename T, typename... Types>\ninline void op(T var1, Types... var2) {\n  cout << var1 << ' ';\n  op(var2...);\n}\ninline void ip() {}\ntemplate <typename T, typename... Types>\ninline void ip(T& var1, Types&... var2) {\n  cin >> var1;\n  ip(var2...);\n}\ntemplate <typename T, typename U>\ninline void min_self(T& x, U y) {\n  if (y < x) x = y;\n}\ntemplate <typename T, typename U>\ninline void max_self(T& x, U y) {\n  if (x < y) x = y;\n}\ntemplate <class T1, class T2>\nostream& operator<<(ostream& out, pair<T1, T2> pair) {\n  return out << \"(\" << pair.first << \", \" << pair.second << \")\";\n}\ntemplate <class T>\nostream& operator<<(ostream& out, vector<T> vec) {\n  out << \"(\";\n  for (auto& v : vec) out << v << ' ';\n  return out << \")\";\n}\ntemplate <class T>\nostream& operator<<(ostream& out, set<T> vec) {\n  out << \"(\";\n  for (auto& v : vec) out << v << \", \";\n  return out << \")\";\n}\ntemplate <class L, class R>\nostream& operator<<(ostream& out, map<L, R> vec) {\n  out << \"(\";\n  for (auto& v : vec) out << \"[\" << v.first << \", \" << v.second << \"]\";\n  return out << \")\";\n}\ntemplate <class A, class B>\nistream& operator>>(istream& in, pair<A, B>& a) {\n  return in >> a.first >> a.second;\n}\ntemplate <class A>\nistream& operator>>(istream& in, vector<A>& a) {\n  for (A& i : a) in >> i;\n  return in;\n}\ntemplate <class Container>\nvoid split(const std::string& str, Container& cont, char delim = ',') {\n  stringstream ss(str);\n  string token;\n  while (std::getline(ss, token, delim)) {\n    cont.push_back(token);\n  }\n}\nlong long px[4] = {-1, 0, 1, 0};\nlong long py[4] = {0, -1, 0, 1};\nconst long long bigmod = 9999999999971LL;\nstruct edge {\n  long long u, v, wt;\n  edge(long long a = 0, long long b = 0, long long c = 0) : u(a), v(b), wt(c) {}\n  bool operator<(edge const& other) { return wt < other.wt; }\n  friend istream& operator>>(istream& in, edge& x) {\n    return in >> x.u >> x.v >> x.wt;\n  }\n  friend ostream& operator<<(ostream& out, const edge& x) {\n    return out << \"(\" << x.u << \", \" << x.v << \", \" << x.wt << \")\";\n  }\n};\nvoid abcd() {\n  long long n;\n  ip(n);\n  string ori;\n  ip(ori);\n  string s = ori;\n  reverse(s.begin(), s.end());\n  long long g[n][n];\n  memset(g, 0, sizeof(g));\n  for (long long i = 0; i <= n - 1; i++) {\n    for (long long j = i + 1; j <= n - 1; j++) {\n      g[i][j] = j + 1;\n      if (s[i] == s[j]) {\n        if (i) g[i][j] = g[i - 1][j - 1] + 1;\n      } else if (s[i] > s[j])\n        g[i][j] = 1;\n      else\n        g[i][j] = INT_MIN;\n    }\n  }\n  vector<long long> dp(n);\n  long long res = 0;\n  for (long long i = 0; i <= n - 1; i++) {\n    long long x = dp[i] = i + 1;\n    for (long long j = 0; j <= i - 1; j++) {\n      if (g[j][i] > 0) {\n        long long rem = g[j][i] - 1;\n        max_self(dp[i], dp[j] + x - rem);\n      }\n    }\n    max_self(res, dp[i]);\n  }\n  op(res);\n  return;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    abcd();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class T>\ninline T max(const T &x, const T &y) {\n  return x > y ? x : y;\n}\ntemplate <class T>\ninline T min(const T &x, const T &y) {\n  return x < y ? x : y;\n}\ntemplate <class T>\ninline bool chkmax(T &x, const T &y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <class T>\ninline bool chkmin(T &x, const T &y) {\n  return x > y ? x = y, true : false;\n}\ninline long long read() {\n  register long long x = 0, v = 1;\n  register char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') v = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * v;\n}\nconst long long MAXN = 10000;\nlong long n, ans, dp[MAXN | 1], minn[20][MAXN | 1], lg[MAXN | 1];\nchar str[MAXN + 5];\ninline long long calc(long long l, long long r) {\n  return 1ll * (l + r) * (r - l + 1) / 2;\n}\nnamespace SA {\nlong long tax[MAXN | 1], rnk[MAXN | 1], tp[MAXN | 1], sa[MAXN | 1],\n    height[MAXN | 1];\nvoid clear() {\n  memset(tax, 0, sizeof(tax));\n  memset(rnk, 0, sizeof(rnk));\n  memset(tp, 0, sizeof(tp));\n  memset(sa, 0, sizeof(sa));\n  memset(height, 0, sizeof(height));\n}\nvoid Q_sort(long long lim) {\n  for (long long i = 1; i <= lim; ++i) tax[i] = 0;\n  for (long long i = 1; i <= n; ++i) ++tax[rnk[i]];\n  for (long long i = 1; i <= lim; ++i) tax[i] += tax[i - 1];\n  for (long long i = n; i >= 1; --i) sa[tax[rnk[tp[i]]]--] = tp[i];\n}\nvoid get_SA() {\n  long long m = 75;\n  for (long long i = 1; i <= n; ++i) {\n    rnk[i] = str[i] - 'a' + 1;\n    tp[i] = i;\n  }\n  Q_sort(m);\n  for (long long w = 1, p = 0; p < n; m = p, w <<= 1) {\n    p = 0;\n    for (long long i = 1; i <= w; ++i) tp[++p] = n - i + 1;\n    for (long long i = 1; i <= n; ++i)\n      if (sa[i] > w) tp[++p] = sa[i] - w;\n    Q_sort(m);\n    std::swap(rnk, tp);\n    rnk[sa[1]] = p = 1;\n    for (long long i = 2; i <= n; ++i)\n      rnk[sa[i]] =\n          (tp[sa[i - 1]] == tp[sa[i]] && tp[sa[i - 1] + w] == tp[sa[i] + w])\n              ? p\n              : ++p;\n  }\n}\nvoid get_HE() {\n  for (long long i = 1; i <= n; ++i) {\n    long long j = height[rnk[i - 1]];\n    if (j) --j;\n    while (str[sa[rnk[i] - 1] + j] == str[i + j]) ++j;\n    height[rnk[i]] = j;\n  }\n  lg[1] = 0;\n  for (long long i = 2; i <= n; ++i) lg[i] = lg[i >> 1] + 1;\n  for (long long i = 1; i <= n; ++i) minn[0][i] = height[i];\n  for (long long i = 1; i < 20; ++i) {\n    for (long long j = 1; j + (1 << i) - 1 <= n; ++j) {\n      minn[i][j] = min(minn[i - 1][j], minn[i - 1][j + (1 << i - 1)]);\n    }\n  }\n}\nlong long query(long long l, long long r) {\n  long long len = lg[r - l + 1];\n  return min(minn[len][l], minn[len][r - (1 << len) + 1]);\n}\n}  // namespace SA\nusing namespace SA;\nsigned main() {\n  long long cases = read();\n  while (cases--) {\n    n = read();\n    scanf(\"%s\", str + 1);\n    clear();\n    get_SA();\n    get_HE();\n    memset(dp, 0, sizeof(dp));\n    dp[1] = n;\n    ans = n;\n    for (long long i = 2; i <= n; ++i) {\n      dp[i] = (n - i + 1);\n      for (long long j = 1; j < i; ++j) {\n        if (rnk[j] > rnk[i]) continue;\n        long long tmp = (n - i + 1) - query(rnk[j] + 1, rnk[i]);\n        chkmax(dp[i], dp[j] + tmp);\n      }\n      chkmax(ans, dp[i]);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int N = 5011;\nint n, lcp[N][N];\nstring s;\nstruct Seg {\n  int l, r;\n  bool operator<(const Seg& o) const {\n    int x = lcp[l][o.l];\n    if (r < l + x || o.r < o.l + x) return r - l < o.r - o.l;\n    return s[l + x] < s[o.l + x];\n  }\n};\nvoid work() {\n  cin >> n >> s;\n  if (n < 0) {\n    n = 4000;\n    s = \"\";\n    for (int i = 0; i < n; ++i) s += 'a' + rand() % 26;\n  }\n  for (int i = 0; i <= n; ++i)\n    for (int j = 0; j <= n; ++j) lcp[i][j] = 0;\n  for (int i = n - 1; i >= 0; --i)\n    for (int j = 0; j < n; ++j)\n      lcp[i][j] = (s[i] == s[j]) ? lcp[i + 1][j + 1] + 1 : 0;\n  vector<Seg> f;\n  for (int i = 0; i < n; ++i) {\n    Seg mx{i, n};\n    int ir = lower_bound(f.begin(), f.end(), mx) - f.begin();\n    if (ir == f.size()) {\n      f.push_back(mx);\n    } else {\n      f[ir] = mx;\n    }\n    int il = 0;\n    for (int j = i; j < n; ++j) {\n      Seg cur{i, j};\n      if (il < ir)\n        il = lower_bound(f.begin() + il, f.begin() + ir, cur) - f.begin();\n      if (il == f.size())\n        f.push_back(cur);\n      else\n        f[il] = cur;\n      ++il;\n    }\n  }\n  cout << f.size() << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int tc = 1;\n  cin >> tc;\n  while (tc--) work();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = 1e9;\nconst long long N = 400007;\nconst long long mod = 1e9 + 7;\nconst double eps = 1e-6;\nconst double pi = acos(-1.0);\ninline long long read() {\n  long long s = 0, w = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n  return s * w;\n}\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long ksm(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = res * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return res;\n}\nlong long fa[N];\nlong long find(long long x) { return x == fa[x] ? x : (fa[x] = find(fa[x])); }\nlong long merge(long long x, long long y) {\n  long long xx = find(x), yy = find(y);\n  if (xx == yy) return 0;\n  fa[xx] = yy;\n  return 1;\n}\nlong long prime[5000007], sz;\nbitset<10000007> vis;\nvoid get_prime() {\n  vis[1] = 1;\n  for (long long i = (2); i <= (10000006); ++i) {\n    if (!vis[i]) prime[++sz] = i;\n    for (long long j = (1); j <= (sz); ++j) {\n      if (i * prime[j] > 10000006) break;\n      vis[i * prime[j]] = 1;\n      if (i % prime[j] == 0) break;\n    }\n  }\n}\nlong long T, n, m;\nchar s[N];\nlong long g[5007][5007];\nlong long dp[N];\nvoid solve() {\n  n = read();\n  scanf(\"%s\", s + 1);\n  for (long long i = (1); i <= (n + 1); ++i)\n    for (long long j = (1); j <= (n + 1); ++j) g[i][j] = 0;\n  for (long long i = (1); i <= (n); ++i) dp[i] = n - i + 1;\n  for (long long i = (n); i >= (1); --i)\n    for (long long j = (n); j >= (1); --j) {\n      if (s[i] == s[j])\n        g[i][j] = g[i + 1][j + 1] + 1;\n      else\n        g[i][j] = 0;\n    }\n  for (long long i = (1); i <= (n); ++i)\n    for (long long j = (1); j <= (i - 1); ++j) {\n      if (i + g[i][j] <= n and s[i + g[i][j]] > s[j + g[i][j]])\n        dp[i] = max(dp[i], dp[j] + n - i - g[i][j] + 1);\n    }\n  printf(\"%lld\\n\", *max_element(dp + 1, dp + 1 + n));\n}\nsigned main() {\n  T = read();\n  while (T--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\nusing namespace std;\ninline long long read() {\n  long long x = 0, w = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') w = -1;\n    c = getchar();\n  }\n  while (c <= '9' && c >= '0') {\n    x = (x << 1) + (x << 3) + c - '0';\n    c = getchar();\n  }\n  return w == 1 ? x : -x;\n}\nunsigned long long h[1000005], b[1000005];\nlong long dp[1000005], n;\nchar s[1000005];\ninline unsigned long long gh(int l, int r) {\n  return h[r] - h[l - 1] * b[r - l + 1];\n}\ninline void write(long long x) {\n  if (x < 0) {\n    putchar('-');\n    return write(-x);\n  }\n  if (x >= 10) write(x / 10);\n  putchar(x % 10 + '0');\n}\ninline int lcp(int x, int y) {\n  int l = 0, r = n - y + 1, tmp = 0;\n  while (l <= r) {\n    int mid = (l + r) >> 1;\n    if (gh(x, x + mid - 1) == gh(y, y + mid - 1))\n      tmp = mid, l = mid + 1;\n    else\n      r = mid - 1;\n  }\n  return tmp;\n}\nint main() {\n  b[0] = 1;\n  for (int i = 1; i <= 1000005 - 5; i++) b[i] = b[i - 1] * 233;\n  int T = read();\n  while (T--) {\n    n = read();\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; i++)\n      h[i] = h[i - 1] * 233 + s[i], dp[i] = n - i + 1;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= i - 1; j++) {\n        int tmp = lcp(i, j);\n        if (j + tmp + 1 > n) continue;\n        if (s[j + tmp] < s[i + tmp])\n          dp[i] = max(dp[i], dp[j] + n - i - tmp + 1);\n      }\n    }\n    long long ans = 0;\n    for (int i = 1; i <= n; i++) ans = max(ans, dp[i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int mod = 1e9 + 7;\nconst long long int MAX_SIZE = 1000005;\nconst long long int MAXN = 100000;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long int T;\n  cin >> T;\n  while (T--) {\n    long long int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<long long int> ans(n);\n    vector<vector<long long int>> pf(n + 1, vector<long long int>(n + 1, 0));\n    for (long long int j = n - 1; j >= 1; j--) {\n      for (long long int i = j - 1; i >= 0; i--) {\n        if (s[i] == s[j]) {\n          pf[i][j] = pf[i + 1][j + 1] + 1;\n          pf[j][i] = pf[j + 1][i + 1] + 1;\n        }\n      }\n    }\n    ans[0] = n;\n    for (long long int i = 1; i < n; i++) {\n      ans[i] = n - i;\n      for (long long int j = 0; j < i; j++) {\n        if (s[j] < s[i]) {\n          ans[i] = max(ans[i], n - i + ans[j]);\n        } else if (s[i] == s[j]) {\n          if (i + pf[i][j] < n && s[j + pf[i][j]] < s[i + pf[i][j]]) {\n            ans[i] = max(ans[i], n - i - pf[i][j] + ans[j]);\n          }\n        }\n      }\n    }\n    long long int m = ans[0];\n    for (long long int i = 1; i < n; i++) {\n      m = max(m, ans[i]);\n    }\n    cout << m << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INF64 = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\ntypedef std::priority_queue<int, vector<int>, greater<int>> small_pq;\ntypedef std::priority_queue<int, vector<int>, less<int>> big_pq;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() {}\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  if (sizeof...(T) > 0) cerr << \" ,\";\n  dbg_out(T...);\n}\nvoid dbg_name(const string &s) {\n  string ss = s;\n  replace(ss.begin(), ss.end(), ',', ' ');\n  cerr << \"  ( \" << ss << \" )  \";\n}\ntemplate <typename T>\ninline void setmin(T &a, const T &b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\ninline void setmax(T &a, const T &b) {\n  if (b > a) a = b;\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nunordered_map<long long, int, custom_hash> safe_map;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::steady_clock::now().time_since_epoch().count());\nconst int MOD = 998244353;\nint mul(int x, int y) { return 1ll * x * y % MOD; }\nint add(int x, int y) { return ((x + y) % MOD + MOD) % MOD; }\nint sub(int x, int y) { return ((x - y) % MOD + MOD) % MOD; }\nint qpow(int a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = mul(ans, a);\n    a = mul(a, a);\n    b /= 2;\n  }\n  return ans;\n}\nconst int N = 1e4 + 5;\nnamespace Suffix {\nint sa[N], rk[N * 2], oldrk[N * 2], cnt[N * 2], id[N], px[N * 2];\nint ht[N];\nbool cmp(int x, int y, int w) {\n  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\nvoid suffix_array(char *s) {\n  memset(cnt, 0, sizeof(cnt));\n  memset(rk, 0, sizeof(rk));\n  int n = strlen(s + 1);\n  for (int i = 1; i <= n; i++) rk[i] = s[i];\n  int m = 300;\n  for (int i = 1; i <= n; i++) cnt[rk[i]]++;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    int p = 0;\n    for (int i = n; i > n - w; i--) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 1; i <= n; i++) cnt[px[i] = rk[id[i]]]++;\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[px[i]]--] = id[i];\n    memcpy(oldrk, rk, sizeof(rk));\n    p = 0;\n    for (int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n    m = p;\n  }\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (k) k--;\n    while ((i + k <= n) && s[i + k] == s[sa[rk[i] - 1] + k]) k++;\n    ht[rk[i]] = k;\n  }\n}\n}  // namespace Suffix\nconst int M = 14;\nchar s[N];\nint dp[N];\nint f[N][M];\nint calc(int i, int j) {\n  int s = log2(j - i + 1);\n  return min(f[i][s], f[j - (1 << s) + 1][s]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  using namespace Suffix;\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d %s\", &n, s + 1);\n    Suffix::suffix_array(s);\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      f[i][0] = Suffix::ht[i];\n    }\n    for (int(i) = int(1); int(i) <= int(M - 1); i++) {\n      for (int(j) = int(1); int(j) <= int(n); j++) {\n        f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n    int ans = 0;\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      dp[i] = n - i + 1;\n      for (int(j) = int(1); int(j) <= int(i - 1); j++) {\n        if (Suffix::rk[i] > Suffix::rk[j])\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - calc(rk[j] + 1, rk[i]));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n    fill(dp + 1, dp + 1 + n, 0);\n    for (int(i) = int(0); int(i) <= int(M - 1); i++)\n      for (int(j) = int(1); int(j) <= int(n); j++) f[j][i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e4 + 100;\nstruct Suffix_Array {\n  int n, m, sa[N], rk[N << 1], oldrk[N << 1];\n  int id[N], cnt[N], rkid[N], height[N];\n  bool cmp(int x, int y, int w) {\n    return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n  }\n  void init() {\n    for (int i = 0; i <= m + 1; i++)\n      height[i] = id[i] = cnt[i] = rkid[i] = sa[i] = 0;\n    for (int i = 0; i <= 2 * m + 2; i++) rk[i] = oldrk[i] = 0;\n  }\n  void solve(char *s) {\n    n = strlen(s + 1);\n    m = max(n, 256);\n    init();\n    for (int i = 1; i <= n; i++) ++cnt[rk[i] = s[i]];\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i > 0; i--) sa[cnt[rk[i]]--] = i;\n    for (int w = 1, p; w < n; w <<= 1) {\n      p = 0;\n      for (int i = n; i > n - w; i--) id[++p] = i;\n      for (int i = 1; i <= n; ++i)\n        if (sa[i] > w) id[++p] = sa[i] - w;\n      memset(cnt, 0, sizeof(int) * (m + 1));\n      for (int i = 1; i <= n; i++) ++cnt[rkid[i] = rk[id[i]]];\n      for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n      for (int i = n; i >= 1; --i) sa[cnt[rkid[i]]--] = id[i];\n      swap(rk, oldrk);\n      m = 0;\n      for (int i = 1; i <= n; i++)\n        rk[sa[i]] = (m += (cmp(sa[i], sa[i - 1], w) ^ 1));\n    }\n    return;\n  }\n  void GetHeight(char *s) {\n    for (int i = 1, k = 0; i <= n; ++i) {\n      if (rk[i] == 1)\n        k = 0;\n      else {\n        if (k > 0) k--;\n        int j = sa[rk[i] - 1];\n        while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) {\n          ++k;\n        }\n      }\n      height[rk[i]] = k;\n    }\n  }\n} w;\nchar s[N];\nstruct LCP {\n  static const int logn = 21;\n  static const int maxn = 2000001;\n  int f[maxn][logn + 1], Logn[maxn + 1];\n  int *height;\n  int *rk;\n  int n;\n  void init(Suffix_Array &o) {\n    height = o.height;\n    rk = o.rk;\n    n = o.n;\n  }\n  void pre_lcp() {\n    Logn[1] = 0;\n    Logn[2] = 1;\n    for (int i = 3; i < maxn; i++) {\n      Logn[i] = Logn[i / 2] + 1;\n    }\n    for (int j = 1; j <= logn; j++)\n      for (int i = 1; i + (1 << j) - 1 <= n; i++) f[i][j] = 0x3f3f3f3f;\n    for (int i = 1; i <= n; i++) f[i][0] = height[i];\n    for (int j = 1; j <= logn; j++)\n      for (int i = 1; i + (1 << j) - 1 <= n; i++)\n        f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n  }\n  int lcp(int l, int r) {\n    if (l == r) return n - l + 1;\n    l = rk[l];\n    r = rk[r];\n    if (l > r) swap(l, r);\n    l++;\n    int x = Logn[r - l + 1];\n    return min(f[l][x], f[r - (1 << x) + 1][x]);\n  }\n} t;\nint f[N], top = 0;\nvoid solve() {\n  int n;\n  scanf(\"%d %s\", &n, s + 1);\n  w.solve(s);\n  w.GetHeight(s);\n  t.init(w);\n  t.pre_lcp();\n  int *a = w.rk;\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int tmp = 0;\n    for (int j = 1; j < i; j++) {\n      if (a[i] > a[j]) tmp = max(tmp, f[j] + n - i + 1 - t.lcp(i, j));\n    }\n    f[i] = max(tmp, n - i + 1);\n    ans = max(f[i], ans);\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  int T;\n  cin >> T;\n  while (T--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  debug_out(T...);\n}\nconst int N = 5010, P1 = 131, mod1 = 1e9 + 9;\null h1[N], px1[N];\nll d[N];\nchar s[N];\ninline bool eql(int l, int r, int a, int b) {\n  return h1[r] - h1[l - 1] * px1[(r - l + 1)] ==\n         h1[b] - h1[a - 1] * px1[(b - a + 1)];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    int n;\n    cin >> n >> s;\n    px1[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      d[i] = n - i + 1;\n      h1[i] = (h1[i - 1] * P1 + s[i - 1]);\n      px1[i] = px1[i - 1] * P1;\n    }\n    ll res = 0;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j < i; j++) {\n        if (s[i - 1] > s[j - 1]) {\n          d[i] = max(d[i], d[j] + n - i + 1);\n        } else if (s[i - 1] == s[j - 1]) {\n          int l = 1, r = n - i + 1;\n          while (l < r) {\n            int mid = (l + r + 1) >> 1;\n            if (eql(i, i + mid - 1, j, j + mid - 1))\n              l = mid;\n            else\n              r = mid - 1;\n          }\n          if (s[i + r - 1] > s[j + r - 1])\n            d[i] = max(d[i], d[j] + n - i + 1 - r);\n        }\n      }\n      res = max(res, d[i]);\n    }\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int N=5005,lcp[][]=new int[N][N],dp[]=new int[N];\n        int t=Integer.parseInt(bu.readLine());\n\n        while(t-->0)\n        {\n            int n=Integer.parseInt(bu.readLine());\n            int i,j;\n            char s[]=bu.readLine().toCharArray();\n\n            for(i=n;i>0;i--)\n            for(j=n;j>0;j--)\n            if(s[i-1]==s[j-1])\n            {\n                if(i+1<=n && j+1<=n) lcp[i][j]=lcp[i+1][j+1]+1;\n                else lcp[i][j]=1;\n            }\n            else lcp[i][j]=0;\n\n            int ans=0,l;\n            for(i=1;i<=n;i++)\n            {\n                dp[i]=n-i+1;\n                for(j=1;j<=i;j++)\n                {\n                    l=lcp[i][j];\n                    if(i+l>n) continue;\n                    if(s[i+l-1]<s[j+l-1]) continue;\n                    dp[i]=Math.max(dp[i],dp[j]+n-(i+l)+1);\n                }\n                ans=Math.max(ans,dp[i]);\n            }\n            sb.append(ans+\"\\n\");\n        }\n        System.out.print(sb);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = (x << 1) + (x << 3) + (ch ^ 48);\n    ch = getchar();\n  }\n  return x * f;\n}\ninline void print(int x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) print(x / 10);\n  putchar(x % 10 ^ 48);\n}\nstring a;\nint t, n, b[5005], f[5005], g[5005][5010], tmp, tmp1, gac[5005], y[5005],\n    h[5005], sb[5005], maxn;\ninline void work() {\n  memset(h, 0, sizeof(h));\n  int dgfuygf = 0;\n  for (register int i = 1; i <= tmp; ++i) {\n    h[gac[i]]++;\n  }\n  int jdvbie = 0;\n  for (register int i = 1; i <= tmp1; ++i) {\n    h[i] += h[i - 1];\n  }\n  int wgdubyxy = 0;\n  for (register int i = tmp; i >= 1; --i) {\n    y[h[gac[sb[i]]]--] = sb[i];\n  }\n}\ninline void workall() {\n  tmp1 = 75;\n  for (register int i = 1; i <= tmp; ++i) {\n    gac[i] = a[i - 1] - '0' + 1;\n    sb[i] = i;\n  }\n  work();\n  for (register int yy = 1, tt = 0; tt < tmp; tmp1 = tt, yy *= 2) {\n    tt = 0;\n    for (register int i = 1; i <= yy; ++i) {\n      tt++;\n      sb[tt] = tmp - yy + i;\n    }\n    for (register int i = 1; i <= tmp; ++i) {\n      if (y[i] > yy) {\n        tt++;\n        sb[tt] = y[i] - yy;\n      }\n    }\n    work();\n    swap(sb, gac);\n    gac[y[1]] = 1;\n    tt = 1;\n    for (register int i = 2; i <= tmp; ++i) {\n      if (sb[y[i - 1]] == sb[y[i]] && sb[y[i - 1] + yy] == sb[y[i] + yy]) {\n        gac[y[i]] = tt;\n      } else {\n        tt++;\n        gac[y[i]] = tt;\n      }\n    }\n  }\n}\nvoid clean() {\n  memset(f, 0, sizeof(f));\n  memset(b, 0, sizeof(b));\n  memset(g, 0, sizeof(f));\n  memset(y, 0, sizeof(y));\n  memset(gac, 0, sizeof(gac));\n  memset(h, 0, sizeof(h));\n  memset(sb, 0, sizeof(sb));\n}\nvoid workalltime() {\n  clean();\n  int mans = 0;\n  n = read();\n  cin >> a;\n  tmp = n;\n  workall();\n  for (int i = 0; i < n; i++) b[y[i + 1] - 1] = i;\n  for (register int i = n - 1; i >= 0; i--) {\n    for (register int j = n - 1; j >= 0; j--) {\n      if (a[i] != a[j])\n        g[i][j] = 0;\n      else\n        g[i][j] = g[i + 1][j + 1] + 1;\n    }\n  }\n  maxn = n;\n  f[0] = n;\n  for (register int i = 1; i < n; ++i) {\n    f[i] = n - i;\n    for (register int j = 0; j < i; ++j) {\n      if (b[i] > b[j]) {\n        if (f[i] < f[j] + n - i - g[i][j]) {\n          f[i] = f[j] + n - i - g[i][j];\n        }\n      }\n    }\n    if (f[i] > maxn) {\n      maxn = f[i];\n    }\n  }\n  print(maxn), puts(\"\");\n  int ende = 0;\n  return;\n}\nint main() {\n  cin >> t;\n  while (t--) {\n    workalltime();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NR = 5005;\nvoid Min(int& x, int y) { x = min(x, y); }\nvoid Max(int& x, int y) { x = max(x, y); }\nint read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = (x << 3) + (x << 1) + (ch ^ 48);\n    ch = getchar();\n  }\n  return x * f;\n}\nint n, m;\nchar s[NR << 1];\nint sa[NR << 1], id[NR << 1];\nint rk[NR << 1], lark[NR << 1];\nint cnt[NR];\nint h[NR << 1];\nint dp[NR << 1];\nint mn[NR][NR];\nvoid work() {\n  memset(s, 0, sizeof(s));\n  memset(sa, 0, sizeof(sa));\n  memset(rk, 0, sizeof(rk));\n  n = read(), scanf(\"%s\", s + 1);\n  m = max(n, 300);\n  memset(cnt, 0, sizeof(cnt));\n  for (int i = 1; i <= n; i++) cnt[rk[i] = s[i]]++;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    memset(cnt, 0, sizeof(cnt));\n    int p = 0;\n    for (int i = n - w + 1; i <= n; i++) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    for (int i = 1; i <= n; i++) cnt[rk[id[i]]]++;\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[rk[id[i]]]--] = id[i];\n    memcpy(lark, rk, sizeof(lark));\n    rk[sa[1]] = m = 1;\n    for (int i = 2; i <= n; i++) {\n      if (lark[sa[i]] == lark[sa[i - 1]] &&\n          lark[sa[i] + w] == lark[sa[i - 1] + w])\n        rk[sa[i]] = m;\n      else\n        rk[sa[i]] = ++m;\n    }\n  }\n  memset(h, 0, sizeof(h));\n  int lcp = 0;\n  for (int i = 1; i <= n; i++) {\n    if (lcp) lcp--;\n    while (s[i + lcp] == s[sa[rk[i] - 1] + lcp]) lcp++;\n    h[rk[i]] = lcp;\n  }\n  for (int i = 1; i <= n; i++) {\n    mn[i][i] = h[i];\n    for (int j = i + 1; j <= n; j++) mn[i][j] = min(mn[i][j - 1], h[j]);\n  }\n  int ans = 0;\n  memset(dp, 0, sizeof(dp));\n  for (int i = 1; i <= n; i++) {\n    int len = dp[i] = n - i + 1;\n    for (int j = 1; j < i; j++) {\n      if (rk[i] < rk[j]) continue;\n      dp[i] = max(dp[i], dp[j] + len - mn[rk[j] + 1][rk[i]]);\n    }\n    ans = max(ans, dp[i]);\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) mn[i][j] = 0;\n}\nint main() {\n  int T = read();\n  while (T--) work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INF64 = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\ntypedef std::priority_queue<int, vector<int>, greater<int>> small_pq;\ntypedef std::priority_queue<int, vector<int>, less<int>> big_pq;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() {}\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  if (sizeof...(T) > 0) cerr << \" ,\";\n  dbg_out(T...);\n}\nvoid dbg_name(const string &s) {\n  string ss = s;\n  replace(ss.begin(), ss.end(), ',', ' ');\n  cerr << \"  ( \" << ss << \" )  \";\n}\ntemplate <typename T>\ninline void setmin(T &a, const T &b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\ninline void setmax(T &a, const T &b) {\n  if (b > a) a = b;\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nunordered_map<long long, int, custom_hash> safe_map;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::steady_clock::now().time_since_epoch().count());\nconst int MOD = 998244353;\nint mul(int x, int y) { return 1ll * x * y % MOD; }\nint add(int x, int y) { return ((x + y) % MOD + MOD) % MOD; }\nint sub(int x, int y) { return ((x - y) % MOD + MOD) % MOD; }\nint qpow(int a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = mul(ans, a);\n    a = mul(a, a);\n    b /= 2;\n  }\n  return ans;\n}\nconst int N = 1e4 + 5;\nnamespace Suffix {\nint sa[N], rk[N * 2], oldrk[N * 2], cnt[N], id[N], px[N * 2];\nint ht[N];\nbool cmp(int x, int y, int w) {\n  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\nvoid suffix_array(const string &s) {\n  int n = s.size();\n  fill(rk + 1, rk + 1 + 2 * n, 0);\n  for (int i = 1; i <= n; i++) rk[i] = s[i - 1];\n  int m = 150;\n  fill(cnt, cnt + m + 1, 0);\n  for (int i = 1; i <= n; i++) cnt[rk[i]]++;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    int p = 0;\n    for (int i = n; i > n - w; i--) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    fill(cnt, cnt + m + 1, 0);\n    for (int i = 1; i <= n; i++) cnt[px[i] = rk[id[i]]]++;\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[px[i]]--] = id[i];\n    copy(rk + 1, rk + 1 + 2 * n, oldrk + 1);\n    p = 0;\n    for (int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n    m = p;\n  }\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (k) k--;\n    while ((i + k <= n) && s[i + k - 1] == s[sa[rk[i] - 1] + k - 1]) k++;\n    ht[rk[i]] = k;\n  }\n}\n}  // namespace Suffix\nconst int M = 14;\nchar s[N];\nint dp[N];\nint f[N][M];\nint calc(int i, int j) {\n  int s = log2(j - i + 1);\n  return min(f[i][s], f[j - (1 << s) + 1][s]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  using namespace Suffix;\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    string s;\n    cin >> n >> s;\n    Suffix::suffix_array(s);\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      f[i][0] = Suffix::ht[i];\n    }\n    for (int(i) = int(1); int(i) <= int(M - 1); i++) {\n      for (int(j) = int(1); int(j) <= int(n); j++) {\n        f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n    int ans = 0;\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      dp[i] = n - i + 1;\n      for (int(j) = int(1); int(j) <= int(i - 1); j++) {\n        if (Suffix::rk[i] > Suffix::rk[j])\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - calc(rk[j] + 1, rk[i]));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n    fill(dp + 1, dp + 1 + n, 0);\n    for (int(i) = int(0); int(i) <= int(M - 1); i++)\n      for (int(j) = int(1); int(j) <= int(n); j++) f[j][i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INF64 = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\ntypedef std::priority_queue<int, vector<int>, greater<int>> small_pq;\ntypedef std::priority_queue<int, vector<int>, less<int>> big_pq;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() {}\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  if (sizeof...(T) > 0) cerr << \" ,\";\n  dbg_out(T...);\n}\nvoid dbg_name(const string &s) {\n  string ss = s;\n  replace(ss.begin(), ss.end(), ',', ' ');\n  cerr << \"  ( \" << ss << \" )  \";\n}\ntemplate <typename T>\ninline void setmin(T &a, const T &b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\ninline void setmax(T &a, const T &b) {\n  if (b > a) a = b;\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nunordered_map<long long, int, custom_hash> safe_map;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::steady_clock::now().time_since_epoch().count());\nconst int MOD = 998244353;\nint mul(int x, int y) { return 1ll * x * y % MOD; }\nint add(int x, int y) { return ((x + y) % MOD + MOD) % MOD; }\nint sub(int x, int y) { return ((x - y) % MOD + MOD) % MOD; }\nint qpow(int a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = mul(ans, a);\n    a = mul(a, a);\n    b /= 2;\n  }\n  return ans;\n}\nconst int N = 1e4 + 5;\nnamespace Suffix {\nint sa[N], rk[N * 2], oldrk[N * 2], cnt[N * 2], id[N], px[N * 2];\nint ht[N];\nbool cmp(int x, int y, int w) {\n  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\nvoid suffix_array(char *s) {\n  memset(cnt, 0, sizeof(cnt));\n  memset(rk, 0, sizeof(rk));\n  memset(oldrk, 0, sizeof(oldrk));\n  memset(sa, 0, sizeof(sa));\n  int n = strlen(s + 1);\n  for (int i = 1; i <= n; i++) rk[i] = s[i];\n  int m = 300;\n  for (int i = 1; i <= n; i++) cnt[rk[i]]++;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    int p = 0;\n    for (int i = n; i > n - w; i--) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 1; i <= n; i++) cnt[px[i] = rk[id[i]]]++;\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[px[i]]--] = id[i];\n    memcpy(oldrk, rk, sizeof(rk));\n    p = 0;\n    for (int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n    m = p;\n  }\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (k) k--;\n    while ((i + k <= n) && s[i + k] == s[sa[rk[i] - 1] + k]) k++;\n    ht[rk[i]] = k;\n  }\n}\n}  // namespace Suffix\nconst int M = 14;\nchar s[N];\nint dp[N];\nint f[N][M];\nint calc(int i, int j) {\n  int s = log2(j - i + 1);\n  return min(f[i][s], f[j - (1 << s) + 1][s]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  using namespace Suffix;\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d %s\", &n, s + 1);\n    Suffix::suffix_array(s);\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      f[i][0] = Suffix::ht[i];\n    }\n    for (int(i) = int(1); int(i) <= int(M - 1); i++) {\n      for (int(j) = int(1); int(j) <= int(n); j++) {\n        f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n    int ans = 0;\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      dp[i] = n - i + 1;\n      for (int(j) = int(1); int(j) <= int(i - 1); j++) {\n        if (Suffix::rk[i] > Suffix::rk[j])\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - calc(rk[j] + 1, rk[i]));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n    fill(dp + 1, dp + 1 + n, 0);\n    for (int(i) = int(0); int(i) <= int(M - 1); i++)\n      for (int(j) = int(1); int(j) <= int(n); j++) f[j][i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()[:-1]\n    lcp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if s[i] == s[j]: lcp[i][j] = lcp[i + 1][j + 1] + 1\n\n    def cal(x, y):\n        t = lcp[x][y]\n        if y + t >= n: return -1\n        xc, yc = s[x + t], s[y + t]\n        if xc > yc: return -1\n        return t\n\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = n - i\n        for j in range(i):\n            x = cal(j, i)\n            if x != -1:\n                dp[i] = max(dp[i], dp[j] + n - i - x)\n    print(max(dp))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize \"Ofast\"\nusing namespace std;\nconst long long BIG_INF = 1e18;\nconst int N = 1e6 + 7;\nconst int T = 1 << 20;\ntemplate <class T, class G>\nostream &operator<<(ostream &os, const pair<T, G> &para) {\n  os << para.first << ' ' << para.second;\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n  for (const T &el : vec) os << el << ' ';\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &vec) {\n  for (const T &el : vec) os << el << ' ';\n  return os;\n}\ntemplate <class T>\nistream &operator>>(istream &is, vector<T> &vec) {\n  for (T &el : vec) is >> el;\n  return is;\n}\ntemplate <class T, class G>\nistream &operator>>(istream &os, pair<T, G> &para) {\n  os >> para.first >> para.second;\n  return os;\n}\ntemplate <class T>\nvoid setmax(T &a, T b) {\n  a = (a >= b ? a : b);\n}\ntemplate <class T>\nvoid setmin(T &a, T b) {\n  a = (a <= b ? a : b);\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nstd::vector<int> zet(const std::string &w) {\n  int n = (int)w.size();\n  std::vector<int> p(n);\n  int j = 0;\n  for (int i = 1; i < n; ++i) {\n    p[i] = std::max(std::min(p[j] + j - i, p[i - j]), 0);\n    while (p[i] + i < n && w[p[i]] == w[p[i] + i]) p[j = i]++;\n  }\n  return p;\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  string second;\n  cin >> second;\n  vector<vector<int> > zzz;\n  vector<int> dp(n);\n  for (int i = 0; i < n; i++) {\n    string temp = second.substr(i);\n    zzz.push_back(zet(temp));\n    int dl_suf = n - i;\n    dp[i] = dl_suf;\n    for (int j = 0; j < i; j++) {\n      int dl_wsp = zzz[j][i - j];\n      if (dl_wsp < dl_suf and second[j + dl_wsp] < second[i + dl_wsp])\n        setmax(dp[i], dp[j] + dl_suf - dl_wsp);\n    }\n  }\n  int ans = 0;\n  for (auto &u : dp) setmax(ans, u);\n  cout << ans << '\\n';\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int test = 1;\n  cin >> test;\n  for (int i = 1; i <= test; i++) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int w = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' or ch > '9') {\n    if (ch == '-') f = -f;\n    ch = getchar();\n  }\n  while (ch >= '0' and ch <= '9') w = w * 10 + ch - '0', ch = getchar();\n  return w * f;\n}\nconst int maxn = 5005;\nint lcp[maxn][maxn], T, f[maxn], N;\nchar str[maxn];\nint main() {\n  T = read();\n  while (T--) {\n    N = read();\n    scanf(\"%s\", str + 1);\n    for (int i = 0; i <= N; i++)\n      for (int j = 0; j <= N; j++) lcp[i][j] = 0;\n    for (int i = N; i >= 1; i--) {\n      f[i] = 0;\n      for (int j = N; j >= 1; j--)\n        if (str[i] == str[j]) lcp[i][j] = lcp[i + 1][j + 1] + 1;\n    }\n    int ans = 0;\n    for (int i = 1; i <= N; i++) {\n      for (int j = 1; j <= N; j++) {\n        if (f[j] - lcp[i][j] > f[i] and str[j + lcp[i][j]] < str[i + lcp[i][j]])\n          f[i] = f[j] - lcp[i][j];\n      }\n      f[i] += N - i + 1;\n      ans = max(ans, f[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\", \"no-stack-protector\", \"unroll-loops\")\nusing namespace std;\nconst int N = 5005;\nchar a[N];\nint tax[N], rk[N], sa[N], tp[N], f[N], height[N], n, m;\nvoid Sort() {\n  for (int i = 0; i <= m; i++) tax[i] = 0;\n  for (int i = 1; i <= n; i++) tax[rk[i]]++;\n  for (int i = 1; i <= m; i++) tax[i] += tax[i - 1];\n  for (int i = n; i >= 1; i--) sa[tax[rk[tp[i]]]--] = tp[i];\n}\nvoid build_SA() {\n  m = 127;\n  for (int i = 1; i <= n; i++) rk[i] = a[i], tp[i] = i;\n  Sort();\n  for (int w = 1, p = 0; p < n; w <<= 1) {\n    p = 0;\n    for (int i = n - w + 1; i <= n; i++) tp[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) tp[++p] = sa[i] - w;\n    Sort();\n    for (int i = 1; i <= n; i++) swap(tp[i], rk[i]);\n    rk[sa[1]] = p = 1;\n    for (int i = 2; i <= n; i++)\n      rk[sa[i]] =\n          (tp[sa[i]] == tp[sa[i - 1]] && tp[sa[i] + w] == tp[sa[i - 1] + w])\n              ? p\n              : ++p;\n    m = p;\n  }\n}\nvoid get_Height() {\n  int h = 0;\n  for (int i = 1; i <= n; i++) {\n    if (rk[i] == 1)\n      h = 0;\n    else {\n      int k = sa[rk[i] - 1];\n      if (--h < 0) h = 0;\n      while (a[i + h] == a[k + h]) h++;\n    }\n    height[rk[i]] = h;\n  }\n}\nint LCP[N][N];\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d\", &n);\n    scanf(\"%s\", a + 1);\n    build_SA(), get_Height();\n    for (int i = 1; i < n; i++) {\n      LCP[i][i + 1] = height[i + 1];\n      for (int j = i + 2; j <= n; j++)\n        LCP[i][j] = min(LCP[i][j - 1], height[j]);\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      f[i] = n - i + 1;\n      for (int j = 1; j < i; j++)\n        if (rk[i] > rk[j])\n          f[i] = max(f[i], f[j] + n - i + 1 - LCP[rk[j]][rk[i]]);\n      ans = max(ans, f[i]);\n    }\n    printf(\"%d\\n\", ans);\n    for (int i = 0; i <= n; i++)\n      tax[i] = rk[i] = sa[i] = tp[i] = a[i] = f[i] = height[i] = 0;\n    for (int i = 1; i <= n; i++)\n      for (int j = i + 1; j <= n; j++) LCP[i][j] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5000 + 5;\nint f[N][N], dp[N];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    s = ' ' + s;\n    f[n + 1][n + 1] = f[n][n + 1] = f[n + 1][n] = 0;\n    for (int i = n; i >= 1; i--) {\n      for (int j = n; j >= 1; j--) {\n        if (s[i] == s[j])\n          f[i][j] = f[i + 1][j + 1] + 1;\n        else\n          f[i][j] = 0;\n      }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      dp[i] = n - i + 1;\n      for (int j = 1; j < i; j++) {\n        int len = f[i][j];\n        if (i + len - 1 <= n && s[i + len] >= s[j + len])\n          dp[i] = max(dp[i], dp[j] + n - i + 1 - len);\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INFi = 1e9 + 5;\nconst int md = 998244353;\nconst long long INF = 2e18;\nconst int maxN = 5e5 + 1;\ndouble getTime() { return clock() / (double)CLOCKS_PER_SEC; }\nvector<int> Zfunc(string &s) {\n  int n = s.size();\n  vector<int> z(n);\n  int l = 0, r = 0;\n  for (int i = 1; i < n; ++i) {\n    if (i < r) {\n      z[i] = min(r - i, z[i - l]);\n    }\n    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;\n    if (i + z[i] > r) {\n      r = i + z[i];\n      l = i;\n    }\n  }\n  return z;\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  vector<vector<int>> dp(n, vector<int>(n, 0));\n  for (int i = 0; i < (n); ++i) {\n    string w = s.substr(i) + \"$\" + s;\n    auto z = Zfunc(w);\n    int start = n - i + 1;\n    int R = 0;\n    dp[i][0] = 1;\n    for (int j = 0; j < (i); ++j) {\n      int len = z[start + j];\n      while (R < len) {\n        dp[i][R] = max(dp[i][R], dp[j][R]);\n        R++;\n      }\n      if (i + len < n && j + len < n && s[i + len] > s[j + len]) {\n        dp[i][len] = max(dp[i][len], dp[j][n - j - 1] + 1);\n      }\n    }\n    for (int j = 1; i + j < n; ++j) dp[i][j] = max(dp[i][j], dp[i][j - 1] + 1);\n  }\n  int mx = 0;\n  for (int i = 0; i < (n); ++i)\n    for (int j = 0; j < (n); ++j) mx = max(mx, dp[i][j]);\n  cout << mx << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int tests = 1;\n  cin >> tests;\n  for (int _ = 0; _ < (tests); ++_) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T, N;\nstruct SuffixArray {\n  vector<int> a;\n  string s;\n  SuffixArray(const string& _s) : s(_s + '\\0') {\n    int N = s.size();\n    vector<pair<int, int>> b(N);\n    a.resize(N);\n    for (int i = 0; i < N; i++) {\n      b[i].first = s[i];\n      b[i].second = i;\n    }\n    int q = 8;\n    while ((1 << q) < N) q++;\n    for (int moc = 0;; moc++) {\n      sort(b.begin(), b.end());\n      a[b[0].second] = 0;\n      for (int i = 1; i < N; i++) {\n        a[b[i].second] = a[b[i - 1].second] + (b[i - 1].first != b[i].first);\n      }\n      if ((1 << moc) >= N) break;\n      for (int i = 0; i < N; i++) {\n        b[i].first = a[i] << q;\n        if (i + (1 << moc) < N) b[i].first += a[i + (1 << moc)];\n        b[i].second = i;\n      }\n    }\n    for (int i = 0; i < a.size(); i++) a[i] = b[i].second;\n  }\n  vector<int> lcp() {\n    int n = a.size(), h = 0;\n    vector<int> inv(n), res(n);\n    for (int i = 0; i < n; i++) inv[a[i]] = i;\n    for (int i = 0; i < n; i++)\n      if (inv[i] > 0) {\n        int p0 = a[inv[i] - 1];\n        while (s[i + h] == s[p0 + h]) h++;\n        res[inv[i]] = h;\n        if (h > 0) h--;\n      }\n    return res;\n  }\n};\nint dp[5005];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> T;\n  while (T--) {\n    cin >> N;\n    string s;\n    cin >> s;\n    SuffixArray sa = SuffixArray(s);\n    auto lcparray = sa.lcp();\n    for (int i = 1; i <= N; i++) {\n      dp[i] = N - sa.a[i];\n      int k = INT_MAX;\n      for (int j = i - 1; j; j--) {\n        k = min(k, lcparray[j + 1]);\n        if (sa.a[j] < sa.a[i]) {\n          dp[i] = max(dp[i], dp[j] + N - sa.a[i] - k);\n        }\n      }\n    }\n    cout << *(max_element(dp + 1, dp + 1 + N)) << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint lcp[5042][5042], dp[5042];\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    for (int i = 0; i <= n; i++) lcp[i][n] = 0;\n    for (int i = n - 1; i >= 0; i--)\n      for (int j = i; j >= 0; j--)\n        if (s[i] == s[j])\n          lcp[j][i] = 1 + lcp[j + 1][i + 1];\n        else\n          lcp[j][i] = 0;\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n      int il = n - i;\n      dp[i] = il;\n      for (int j = 0; j < i; j++) {\n        int lp = lcp[j][i];\n        char sjlp = s[j + lp];\n        if (i + lp == n) continue;\n        char silp = s[i + lp];\n        if (sjlp < silp) dp[i] = max(dp[i], il - lp + dp[j]);\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nconst int Mod = 1000000007;\nconst int maxN = 5e3 + 2;\nint tt, n;\nstring s;\nint nxt[maxN][maxN];\nll dp[maxN];\nvoid Init() {\n  cin >> tt;\n  while (tt--) {\n    cin >> n >> s;\n    s += \"A\";\n    for (int i = n; i >= 0; --i) {\n      for (int j = i - 1; j >= 0; --j) {\n        if (s[i] == s[j]) {\n          nxt[j][i] = nxt[j + 1][i + 1] + 1;\n        } else\n          nxt[j][i] = 0;\n      }\n    }\n    for (int i = 0; i < n; ++i) {\n      dp[i] = ((dp[i] > n - i) ? dp[i] : n - i);\n      for (int j = 0; j < i; ++j) {\n        if (s[i + nxt[j][i]] > s[j + nxt[j][i]])\n          dp[i] =\n              ((dp[i] > dp[j] + n - nxt[j][i] - i) ? dp[i]\n                                                   : dp[j] + n - nxt[j][i] - i);\n      }\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n      ans = ((ans > dp[i]) ? ans : dp[i]);\n      dp[i] = 0;\n    }\n    cout << ans << \"\\n\";\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  Init();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5e3 + 4;\nconst int Base = 127, MOD = 998244353;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) (ch == '-') && (f = -f), ch = getchar();\n  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n  return x * f;\n}\ntemplate <typename Type>\ninline void chkmax(Type &a, const Type &b) {\n  if (a < b) a = b;\n}\nint n, m, dp[MAXN];\nchar ch[MAXN];\nint sa[MAXN], rk[MAXN];\nint tp[MAXN], bucket[MAXN];\nint height[MAXN];\nint table[MAXN][20], lg[MAXN];\ninline void Radixsort() {\n  for (int i = 0; i <= m; ++i) bucket[i] = 0;\n  for (int i = 1; i <= n; ++i) ++bucket[rk[i]];\n  for (int i = 1; i <= m; ++i) bucket[i] += bucket[i - 1];\n  for (int i = n; i >= 0; --i) sa[bucket[rk[tp[i]]]--] = tp[i];\n}\ninline void Suffixsort() {\n  int i, j, k;\n  m = 127;\n  for (i = 1; i <= n; ++i) rk[i] = ch[i], tp[i] = i;\n  Radixsort();\n  for (k = 1; k <= n; k <<= 1) {\n    j = 0;\n    for (i = 1; i <= k; ++i) tp[++j] = n - k + i;\n    for (i = 1; i <= n; ++i)\n      if (sa[i] > k) tp[++j] = sa[i] - k;\n    Radixsort();\n    memcpy(tp, rk, sizeof(int) * (n + 1));\n    rk[sa[1]] = j = 1;\n    for (i = 2; i <= n; ++i)\n      rk[sa[i]] =\n          (tp[sa[i]] == tp[sa[i - 1]] && tp[sa[i] + k] == tp[sa[i - 1] + k])\n              ? j\n              : ++j;\n    if (j == n) break;\n    m = j;\n  }\n  for (i = 1, k = 0; i <= n; ++i) {\n    k -= (bool)k;\n    j = sa[rk[i] - 1];\n    while (ch[i + k] == ch[j + k]) ++k;\n    height[rk[i]] = k;\n  }\n  for (lg[0] = -1, i = 1; i <= n; ++i)\n    lg[i] = lg[i >> 1] + 1, table[i][0] = height[i];\n  for (j = 1; j <= lg[n]; ++j)\n    for (i = 1; i + (1 << j) - 1 <= n; ++i)\n      table[i][j] = min(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);\n}\ninline int lcp(int l, int r) {\n  l = rk[l];\n  r = rk[r];\n  if (l == r) return m - sa[l] + 1;\n  if (l > r) swap(l, r);\n  ++l;\n  int x = lg[r - l + 1];\n  return min(table[l][x], table[r - (1 << x) + 1][x]);\n}\ninline void solve() {\n  int i, j;\n  n = read();\n  scanf(\"%s\", ch + 1);\n  Suffixsort();\n  for (i = 1; i <= n; ++i) dp[i] = 0;\n  dp[1] = n;\n  for (i = 2; i <= n; ++i) {\n    dp[i] = n - i + 1;\n    for (j = 1; j < i; ++j) {\n      int l = lcp(i, j);\n      if (ch[i + l] < ch[j + l]) continue;\n      chkmax(dp[i], dp[j] + n - (i + l) + 1);\n    }\n  }\n  int ans = 0;\n  for (i = 1; i <= n; ++i) chkmax(ans, dp[i]);\n  printf(\"%d\\n\", ans);\n  memset(sa + 1, 0, sizeof(int) * n);\n  memset(rk + 1, 0, sizeof(int) * n);\n  memset(tp + 1, 0, sizeof(int) * n);\n  memset(height + 1, 0, sizeof(int) * n);\n}\nint main() {\n  for (int T = read(); T; --T) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k, t, n, m, it, siz[5050], cur, res, it2;\nchar s0[5050];\nstring sb[5050];\nstruct trie {\n  int mp[30];\n  int f1, f2, len, fa;\n} s[10050];\nvoid build(int id, int dep, int l, int r) {\n  if (l == r) {\n    s[id].len += (siz[l] - dep + 2);\n    return;\n  }\n  int x[30], i, y[30], j, k = 0;\n  memset(x, 1, sizeof(x));\n  memset(y, 0, sizeof(y));\n  s[id].len++;\n  memset(s[id].mp, 0, sizeof(s[id].mp));\n  for (j = l; j <= r; j++) {\n    if (siz[j] >= dep) {\n      x[sb[j][dep] - 'a' + 1] = min(x[sb[j][dep] - 'a' + 1], j);\n      y[sb[j][dep] - 'a' + 1] = max(y[sb[j][dep] - 'a' + 1], j);\n    }\n  }\n  for (i = 1; i <= 26; i++) {\n    k += (y[i] > 0);\n  }\n  if ((dep == 1) || k > 1) {\n    for (i = 1; i <= 26; i++) {\n      if (y[i]) {\n        s[id].mp[i] = ++it;\n        s[it].fa = id;\n        build(it, dep + 1, x[i], y[i]);\n      }\n    }\n    return;\n  }\n  if (k == 1) {\n    for (i = 1; i <= 26; i++) {\n      if (y[i]) {\n        build(id, dep + 1, x[i], y[i]);\n        return;\n      }\n    }\n  }\n}\nvoid dfs(int cur, int dep, int ans) {\n  int i, j, k, f = s[cur].fa, nmsl = dep + s[cur].len;\n  for (i = 1; i < s0[dep]; i++) {\n    if (s[f].mp[i]) {\n      ans = max(ans, s[s[f].mp[i]].f2);\n    }\n  }\n  ans += min(s[cur].len, n - dep + 1);\n  ans = max(ans, s[cur].f1);\n  s[cur].f1 = ans;\n  s[cur].f2 = max(s[cur].f2, ans);\n  if (nmsl <= n) {\n    dfs(s[cur].mp[s0[nmsl]], nmsl, ans);\n    s[cur].f2 = max(s[cur].f2, s[s[cur].mp[s0[nmsl]]].f2);\n  }\n  res = max(res, ans);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> t;\n  while (t--) {\n    it = 0;\n    s[0].f1 = s[0].f2 = 0;\n    res = 0;\n    cin >> n >> s0 + 1;\n    if (n == 1) {\n      cout << 1 << '\\n';\n      continue;\n    }\n    for (i = 1; i <= n; i++) {\n      sb[i].clear();\n      sb[i] += \"0\";\n      for (j = i; j <= n; j++) {\n        sb[i] += s0[j];\n      }\n    }\n    sort(sb + 1, sb + n + 1);\n    for (i = 1; i <= n; i++) {\n      siz[i] = sb[i].size() - 1;\n    }\n    build(0, 1, 1, n);\n    for (i = 1; i <= n; i++) {\n      s0[i] -= 'a' - 1;\n    }\n    for (i = 1; i <= n; i++) {\n      it2 = i;\n      dfs(s[0].mp[s0[i]], i, 0);\n    }\n    cout << res << '\\n';\n    memset(s, 0, sizeof(s[0]) * it + 500);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5005;\nint t, n, ans;\nint dp[N], lcp[N][N];\nchar s[N];\nint main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    scanf(\"%s\", s + 1);\n    ans = 0;\n    for (int i = 1; i <= n; ++i)\n      for (int j = 1; j <= n; ++j) lcp[i][j] = 0;\n    for (int i = n; i; --i)\n      for (int j = i + 1; j <= n; ++j)\n        if (s[i] == s[j]) lcp[i][j] = lcp[i + 1][j + 1] + 1;\n    for (int i = 1; i <= n; ++i) {\n      dp[i] = n - i + 1;\n      for (int j = 1; j < i; ++j) {\n        int k = lcp[j][i];\n        if (s[j + k] < s[i + k]) dp[i] = max(dp[i], dp[j] + n - i - k + 1);\n      }\n    }\n    for (int i = 1; i <= n; ++i) ans = max(ans, dp[i]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5005;\nchar s[N];\nint n, f[N], ans, a[N];\nunsigned int bas2[N], bas[N], base, base2, ha[N], Ha[N];\ninline void init() {\n  scanf(\"%d\", &n);\n  base = 31;\n  base2 = 79;\n  scanf(\"%s\", s + 1);\n  for (int i = 1; i <= n; i++) a[i] = s[i] - 'a';\n  bas[0] = 1;\n  bas2[0] = 1;\n  for (int i = 1; i <= n; i++)\n    bas[i] = bas[i - 1] * base, bas2[i] = bas2[i - 1] * base2;\n  for (int i = 1; i <= n; i++)\n    ha[i] = ha[i - 1] * base + a[i], Ha[i] = Ha[i - 1] * base2 + a[i];\n}\ninline int judge(int x, int y) {\n  if (a[x] > a[y]) return 1;\n  if (a[x] < a[y]) return 0;\n  int l = 1, r = n - x + 1;\n  while (l < r) {\n    int mid = (l + r + 1) >> 1;\n    unsigned int ha1, ha2, ha3, ha4;\n    ha1 = ha[x + mid - 1] - ha[x - 1] * bas[mid];\n    ha2 = ha[y + mid - 1] - ha[y - 1] * bas[mid];\n    ha3 = Ha[x + mid - 1] - Ha[x - 1] * bas2[mid];\n    ha4 = Ha[y + mid - 1] - Ha[y - 1] * bas2[mid];\n    if (ha1 == ha2 && ha3 == ha4)\n      l = mid;\n    else\n      r = mid - 1;\n  }\n  if (r == n - x + 1) {\n    return 0;\n  } else {\n    if (a[x + l] > a[y + l])\n      return l;\n    else\n      return 0;\n  }\n}\ninline void solve() {\n  ans = 0;\n  for (int i = 1; i <= n; i++) {\n    f[i] = n - i + 1;\n    for (int j = 1; j < i; j++) {\n      int t;\n      if (t = judge(i, j)) {\n        if (a[i] != a[j]) t--;\n        f[i] = max(f[i], f[j] + n - i + 1 - t);\n      }\n    }\n    ans = max(ans, f[i]);\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    init();\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 5e3 + 14;\nint t, n, lcp[MAX_N][MAX_N], dp[MAX_N];\nstring s;\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  cin >> t;\n  while (t--) {\n    cin >> n >> s;\n    for (int i = n - 1; i >= 0; --i)\n      for (int j = 0; j < n; ++j)\n        lcp[i][j] = (s[i] == s[j]) * (1 + lcp[i + 1][j + 1]);\n    for (int i = 0; i < n; ++i) {\n      dp[i] = n - i;\n      for (int j = 0; j < i; ++j)\n        if (s[j + lcp[i][j]] < s[i + lcp[i][j]])\n          dp[i] = max(dp[i], dp[j] + n - i - lcp[i][j]);\n    }\n    cout << *max_element(dp, dp + n) << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5000 + 5;\nint q = 0, n = 0, dp[N] = {}, d[N] = {}, p[N] = {}, lcp[N][N] = {};\nstring s = \"\";\nvector<string> v;\nbool cmp(string s1, string s2) {\n  for (int i = 0; i < min(s1.length(), s2.length()); i++)\n    if (s1[i] != s2[i]) return s1[i] < s2[i];\n  return s1.length() < s2.length();\n}\nvoid init() {\n  v.clear();\n  for (int i = 0; i < n; i++) v.push_back(s.substr(i, n - i));\n  sort(v.begin(), v.end(), cmp);\n  for (int i = 0; i < n; i++) d[n - v[i].length()] = i;\n  for (int i = 0; i < n - 1; i++) {\n    int x = v[i].length();\n    for (int j = 0; j < v[i].length(); j++)\n      if (v[i + 1][j] > v[i][j]) {\n        x = j;\n        break;\n      }\n    p[i] = x;\n  }\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++) lcp[i][j] = 1e9;\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++) lcp[i][j] = min(lcp[i][j - 1], p[j - 1]);\n  for (int i = 0; i <= n; i++) dp[i] = n - i;\n}\nvoid solve() {\n  cin >> n >> s;\n  init();\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++)\n      dp[j] = max(dp[j], dp[i] + n - j - lcp[d[i]][d[j]]);\n  int ans = 0;\n  for (int i = 0; i < n; i++) ans = max(ans, dp[i]);\n  cout << ans << endl;\n}\nint main() {\n  cin >> q;\n  for (int i = 0; i < q; i++) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    int dp[n];\n    fill(dp, dp + n, 0);\n    int ans = 0;\n    for (int i = n - 1; i >= 0; i--) {\n      int z[n];\n      fill(z, z + n, 0);\n      for (int j = i + 1, l = i, r = i; j < n; j++) {\n        if (j + z[j - l + i] < r) {\n          z[j] = z[j - l + i];\n        } else {\n          l = j;\n          r = max(r, j);\n          while (r < n && s[r - l + i] == s[r]) {\n            r++;\n          }\n          z[j] = r - l;\n        }\n        if (j + z[j] < n && s[j + z[j]] > s[i + z[j]]) {\n          dp[i] = max(dp[i], dp[j] + (n - j - z[j]));\n        }\n      }\n      ans = max(ans, dp[i] + (n - i));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nchar s[5009];\nint t1[5009], t2[5009], sa[5009], c[5009];\nint rnk[5009], h[5009];\nint lcp[5009][5009];\nint f[5009][5009];\nvoid geth() {\n  for (int i = 1; i <= n; i++) rnk[sa[i]] = i;\n  int p = 0;\n  for (int i = 1; i <= n; i++) {\n    if (p) p--;\n    int np = sa[rnk[i] - 1];\n    while (s[i + p] == s[np + p]) p++;\n    h[rnk[i]] = p;\n  }\n}\nvoid init() {\n  for (int i = 1; i <= n; i++) {\n    int l = n - sa[i] + 1;\n    lcp[i][i] = l;\n    for (int j = i + 1; j <= n; j++) {\n      l = min(l, h[j]);\n      lcp[i][j] = lcp[j][i] = l;\n    }\n  }\n}\nvoid getsa() {\n  int *x = t1, *y = t2;\n  int m = 26;\n  memset(c, 0, (m + 1) << 2);\n  for (int i = 1; i <= n; i++) c[x[i] = s[i]]++;\n  x[n + 1] = y[n + 1] = 0;\n  for (int i = 1; i <= m; i++) c[i] += c[i - 1];\n  for (int i = 1; i <= n; i++) sa[c[x[i]]--] = i;\n  for (int k = 1; k <= n; k <<= 1) {\n    int p = 0;\n    for (int i = n - k + 1; i <= n; i++) y[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] >= k + 1) y[++p] = sa[i] - k;\n    memset(c, 0, (m + 1) << 2);\n    for (int i = 1; i <= n; i++) c[x[i]]++;\n    for (int i = 1; i <= m; i++) c[i] += c[i - 1];\n    for (int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i];\n    p = 0;\n    for (int i = 1; i <= n; i++)\n      y[sa[i]] = x[sa[i]] == x[sa[i - 1]] && x[sa[i] + k] == x[sa[i - 1] + k]\n                     ? p\n                     : ++p;\n    swap(x, y);\n    m = p;\n    if (m >= n) break;\n  }\n}\nint main() {\n  int ttt;\n  scanf(\"%d\", &ttt);\n  while (ttt--) {\n    scanf(\"%d\", &n);\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; i++) s[i] -= 'a' - 1;\n    getsa();\n    geth();\n    init();\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      int p = rnk[i];\n      int lp = 1, cp = i - 1;\n      for (int j = i; j <= n; j++) {\n        if (j > i)\n          f[i][j] = f[i][j - 1] + 1;\n        else\n          f[i][j] = 1;\n        int l = j - i + 1;\n        while (lp < p && lcp[lp][p] < l) {\n          if (sa[lp] < i) f[i][j] = max(f[i][j], f[sa[lp]][n] + 1);\n          lp++;\n        }\n        while (cp > 0 && lcp[p][rnk[cp]] < l - 1) cp--;\n        if (cp > 0 && l > 1) f[i][j] = max(f[i][j], f[cp][cp + l - 2] + 1);\n        ans = max(ans, f[i][j]);\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid setIO(string name) {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  freopen((name + \".in\").c_str(), \"r\", stdin);\n  freopen((name + \".out\").c_str(), \"w\", stdout);\n}\ntemplate <typename T>\nvoid PVecPrint(vector<T> &v) {\n  for (int i = 0; i < (int)v.size(); i++)\n    cout << v[i].first << \",\" << v[i].second << ' ';\n  cout << '\\n';\n}\ntemplate <class T>\nvoid VecPrint(vector<T> &v) {\n  for (int i = 0; i < v.size(); i++) cout << v[i] << ' ';\n  cout << '\\n';\n}\nstring s;\nvector<long long int> hashv;\nint n, p = 31;\nvector<int> dp;\nvector<long long int> ppow(5010);\nint lcp[5010][5010];\ninline long long getHash(int l, int r) {\n  if (l == 0) return hashv[r];\n  long long int t = (hashv[r] - hashv[l - 1]) % 998244353;\n  return (t + 998244353) % 998244353;\n}\ninline int compare(int id1, int id2, int len) {\n  long long int h1 = getHash(id1, id1 + len - 1);\n  long long int h2 = getHash(id2, id2 + len - 1);\n  int d = abs(id1 - id2);\n  if (id2 > id1)\n    h1 = h1 * ppow[d] % 998244353;\n  else\n    h2 = h2 * ppow[d] % 998244353;\n  return h1 == h2;\n}\nvoid calcHash() {\n  hashv.resize(n);\n  long long int h = 0;\n  long long int pw = 1;\n  for (int i = 0; i < n; i++) {\n    h = (h + pw * (s[i] - 'a' + 1)) % 998244353;\n    hashv[i] = h;\n    pw = pw * p % 998244353;\n  }\n}\nint getCommon(int id1, int id2) {\n  int l = 1, r = n - id2;\n  int ans;\n  for (int i = 0; i < 20; i++) {\n    if (l == r) {\n      ans = l;\n      break;\n    }\n    if (r == l + 1) {\n      if (compare(id1, id2, r))\n        ans = r;\n      else\n        ans = l;\n      break;\n    }\n    int mid = (l + r) / 2;\n    if (compare(id1, id2, mid))\n      l = mid;\n    else\n      r = mid - 1;\n  }\n  return ans;\n}\nvoid solve() {\n  for (int i = n - 1; i > -1; i--) {\n    for (int j = i; j < n; j++) {\n      if (i == j) {\n        lcp[i][j] = n - i;\n        continue;\n      }\n      if (s[i] != s[j]) {\n        lcp[i][j] = 0;\n        continue;\n      }\n      if (j == n - 1) {\n        lcp[i][j] = 1;\n        continue;\n      }\n      lcp[i][j] = 1 + lcp[i + 1][j + 1];\n    }\n  }\n  dp.clear();\n  dp.resize(n, 0);\n  dp[n - 1] = 1;\n  for (int i = n - 2; i > -1; i--) {\n    int ans = n - i;\n    vector<int> vis(26, 0);\n    for (int j = i + 1; j < n; j++) {\n      if (s[i] != s[j]) {\n        if (s[i] < s[j]) ans = max(ans, n - i + dp[j]);\n      } else {\n        int len = lcp[i][j];\n        if (len != n - j) {\n          if (s[i + len] < s[j + len]) ans = max(ans, n - i + dp[j] - len);\n        }\n      }\n    }\n    dp[i] = ans;\n  }\n  int ans = 0;\n  for (auto &num : dp) {\n    ans = max(ans, num);\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  ppow[0] = 1;\n  for (int i = 1; i < 5010; i++) ppow[i] = ppow[i - 1] * p % 998244353;\n  int te;\n  cin >> te;\n  while (te--) {\n    cin >> n;\n    cin >> s;\n    calcHash();\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = 1e15;\nconst long long N = 5e3 + 5;\nstring s;\nlong long n, Next[N][N], Dp[N];\nvoid Input() {\n  cin >> n >> s;\n  s = ' ' + s;\n}\nvoid Solve() {\n  long long Res = 0;\n  for (long long i = n; i >= 1; --i) {\n    for (long long j = n; j > i; --j) {\n      if (s[i] != s[j])\n        Next[i][j] = 0;\n      else\n        Next[i][j] = Next[i + 1][j + 1] + 1;\n    }\n  }\n  for (long long i = 1; i <= n; ++i) {\n    Dp[i] = n - i + 1;\n    for (long long j = i - 1; j >= 1; --j) {\n      if (i + Next[j][i] > n) continue;\n      long long Pos = i + Next[j][i];\n      char C1 = s[i + Next[j][i]], C2 = s[j + Next[j][i]];\n      if (C1 > C2) {\n        Dp[i] = max(Dp[i], Dp[j] + n - Pos + 1);\n      }\n    }\n    Res = max(Res, Dp[i]);\n  }\n  cout << Res << '\\n';\n}\nint main() {\n  if (fopen(\"trash.inp\", \"r\"))\n    freopen(\"trash.inp\", \"r\", stdin), freopen(\"trash.out\", \"w\", stdout);\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int Test;\n  cin >> Test;\n  while (Test--) {\n    Input();\n    Solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double pi = acos((long double)-1);\nint in(int &a, int &b, int &c, int &d) {\n  return scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n}\nint in(int &a, int &b, int &c) { return scanf(\"%d%d%d\", &a, &b, &c); }\nint in(int &a, int &b) { return scanf(\"%d%d\", &a, &b); }\nint in(long long &a, long long &b) { return scanf(\"%lld%lld\", &a, &b); }\nint in(long long &a, long long &b, long long &c, long long &d) {\n  return scanf(\"%lld%lld%lld%lld\", &a, &b, &c, &d);\n}\nint in(long long &a, long long &b, long long &c) {\n  return scanf(\"%lld%lld%lld\", &a, &b, &c);\n}\nint in(long long &a) { return scanf(\"%lld\", &a); }\nint in(int &a) { return scanf(\"%d\", &a); }\nint in(char *s) { return scanf(\"%s\", s); }\nint in(char &c) { return scanf(\"%c\", &c); }\nvoid out(int a, bool ln) { printf(\"%d%c\", a, \" \\n\"[ln]); }\nvoid out(long long a, bool ln) { printf(\"%lld%c\", a, \" \\n\"[ln]); }\nvoid out(double a, int digit, bool ln) {\n  printf(\"%.*f%c\", digit, a, \" \\n\"[ln]);\n}\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 3e5 + 5;\nconst int maxm = 1e6 + 5;\nconst long long mod = 1e9 + 7;\nchar s[maxn];\nlong long dp[maxn], lcp[5005][5005], n;\nvoid init() {\n  for (int i = 1; i <= n + 1; ++i) {\n    for (int j = i; j <= n + 1; ++j) {\n      lcp[i][j] = 0;\n    }\n  }\n  for (int i = n; i >= 1; --i) {\n    for (int j = n; j >= i; --j) {\n      if (s[i] == s[j]) lcp[i][j] = lcp[i + 1][j + 1] + 1;\n    }\n  }\n}\nbool larger(int x, int y) {\n  int num = lcp[y][x];\n  return (num != n - x + 1 && s[x + num] > s[y + num]);\n}\nint main() {\n  int TT;\n  scanf(\"%d\", &TT);\n  for (int TTT = 1; TTT <= TT; TTT++) {\n    in(n);\n    scanf(\"%s\", s + 1);\n    init();\n    long long ans = 0;\n    for (int i = 1; i <= n; ++i) {\n      dp[i] = n - i + 1;\n      for (int j = 1; j < i; ++j) {\n        int num = lcp[j][i];\n        if (larger(i, j)) dp[i] = max(dp[i], dp[j] + n - i + 1 - num);\n      }\n      ans = max(ans, dp[i]);\n    }\n    out(ans, 1);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 1000005;\nconst long long SQRTN = 1003;\nconst long long LOGN = 22;\nconst double PI = acos(-1);\nconst long long INF = 1e16;\nconst long long MOD = 1000000007;\nconst long long FMOD = 998244353;\nconst double eps = 1e-9;\nmt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT gcd(T a, T b) {\n  return (b ? __gcd(a, b) : a);\n}\ntemplate <typename T>\nT lcm(T a, T b) {\n  return (a * (b / gcd(a, b)));\n}\nlong long add(long long a, long long b, long long c = MOD) {\n  long long res = a + b;\n  return (res >= c ? res - c : res);\n}\nlong long mod_neg(long long a, long long b, long long c = MOD) {\n  long long res;\n  if (abs(a - b) < c)\n    res = a - b;\n  else\n    res = (a - b) % c;\n  return (res < 0 ? res + c : res);\n}\nlong long mul(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return (res >= c ? res % c : res);\n}\nlong long muln(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return ((res % c) + c) % c;\n}\nlong long mulmod(long long a, long long b, long long m = MOD) {\n  long long q = (long long)(((long double)a * (long double)b) / (long double)m);\n  long long r = a * b - q * m;\n  if (r > m) r %= m;\n  if (r < 0) r += m;\n  return r;\n}\ntemplate <typename T>\nT expo(T e, T n) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = x * p;\n    p = p * p;\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT power(T e, T n, T m = MOD) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = mul(x, p, m);\n    p = mul(p, p, m);\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT extended_euclid(T a, T b, T& x, T& y) {\n  T xx = 0, yy = 1;\n  y = 0;\n  x = 1;\n  while (b) {\n    T q = a / b, t = b;\n    b = a % b;\n    a = t;\n    t = xx;\n    xx = x - q * xx;\n    x = t;\n    t = yy;\n    yy = y - q * yy;\n    y = t;\n  }\n  return a;\n}\ntemplate <typename T>\nT mod_inverse(T a, T n = MOD) {\n  T x, y, z = 0;\n  T d = extended_euclid(a, n, x, y);\n  return (d > 1 ? -1 : mod_neg(x, z, n));\n}\nconst long long FACSZ = 1;\nlong long fact[FACSZ], ifact[FACSZ];\nvoid precom(long long c = MOD) {\n  fact[0] = 1;\n  for (long long i = 1; i < FACSZ; i++) fact[i] = mul(fact[i - 1], i, c);\n  ifact[FACSZ - 1] = mod_inverse(fact[FACSZ - 1], c);\n  for (long long i = FACSZ - 1 - 1; i >= 0; i--) {\n    ifact[i] = mul(i + 1, ifact[i + 1], c);\n  }\n}\nlong long ncr(long long n, long long r, long long c = MOD) {\n  if (r > n) return 0;\n  return mul(mul(ifact[r], ifact[n - r], c), fact[n], c);\n}\nvoid solvethetestcase();\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  for (long long testcase = 1; testcase < t + 1; testcase++) {\n    solvethetestcase();\n  }\n}\nlong long n;\nstring s;\nlong long dp[5005], common[5005][5005];\nvoid solvethetestcase() {\n  cin >> n >> s;\n  dp[0] = 0;\n  long long ans = 0;\n  for (long long i = 0; i < n + 2; i++)\n    for (long long j = 0; j < n + 2; j++) common[i][j] = 0;\n  for (long long i = n; i >= 1; i--) {\n    for (long long j = i + 1; j < n + 1; j++) {\n      if (s[i - 1] == s[j - 1])\n        common[i][j] = 1 + common[i + 1][j + 1];\n      else\n        common[i][j] = 0;\n    }\n  }\n  for (long long i = 1; i < n + 1; i++) {\n    dp[i] = n - i + 1;\n    for (long long j = 1; j < i; j++) {\n      long long c = common[j][i];\n      if (i + c <= n and s[i + c - 1] > s[j + c - 1])\n        dp[i] = max(dp[i], dp[j] + n + 1 - i - c);\n    }\n    ans = max(ans, dp[i]);\n  }\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int nax = 5010;\nint n;\nchar s[5010];\nint lcp[nax][nax];\nint dp[nax];\nint main() {\n  cin.tie(0)->sync_with_stdio(false);\n  int T;\n  cin >> T;\n  while (T--) {\n    cin >> n >> s + 1;\n    for (int i = 1; i <= n + 1; ++i)\n      for (int j = 1; j <= n + 1; ++j) lcp[i][j] = 0;\n    for (int i = n - 1; i >= 1; --i) {\n      for (int j = n; j > i; --j) {\n        if (s[i] == s[j]) lcp[i][j] = 1 + lcp[i + 1][j + 1];\n      }\n    }\n    for (int i = 1; i <= n; ++i) {\n      dp[i] = 0;\n      for (int j = 1; j < i; ++j) {\n        if (s[i + lcp[j][i]] > s[j + lcp[j][i]]) {\n          dp[i] = max(dp[i], dp[j] - (lcp[j][i]));\n        }\n      }\n      dp[i] += n - i + 1;\n    }\n    cout << *max_element(dp + 1, dp + 1 + n) << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int MAXN = 5e3 + 5;\nconst int inf = 0x3f3f3f3f;\nlong long dp[MAXN];\nint f[MAXN][MAXN];\nchar s[MAXN];\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    cin >> s + 1;\n    for (int i = 1; i <= n + 1; i++) {\n      for (int j = 1; j <= n + 1; j++) {\n        f[i][j] = 0;\n      }\n    }\n    for (int i = n; i >= 1; i--) {\n      for (int j = n; j >= 1; j--) {\n        if (s[i] == s[j])\n          f[i][j] = f[i + 1][j + 1] + 1;\n        else\n          f[i][j] = 0;\n      }\n    }\n    long long ans = 0;\n    for (int i = 1; i <= n; i++) {\n      dp[i] = n - i + 1;\n      for (int j = 1; j < i; j++) {\n        int c = f[i][j];\n        if (s[i + c] > s[j + c]) {\n          dp[i] = max(dp[i], dp[j] + n - i + 1 - c);\n        }\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  debug_out(T...);\n}\nconst int N = 5010, P1 = 131;\null h1[N], px1[N];\nll d[N];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    int n;\n    string s;\n    cin >> n >> s;\n    px1[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      d[i] = n - i + 1;\n      h1[i] = (h1[i - 1] * P1 + s[i - 1]);\n      px1[i] = px1[i - 1] * P1;\n    }\n    ll res = 0;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j < i; j++) {\n        if (s[i - 1] > s[j - 1]) {\n          d[i] = max(d[i], d[j] + n - i + 1);\n        } else if (s[i - 1] == s[j - 1]) {\n          int l = 1, r = n - i + 1;\n          while (l < r) {\n            int mid = (l + r + 1) >> 1;\n            if (h1[i + mid - 1] - h1[i - 1] * px1[mid] ==\n                h1[j + mid - 1] - h1[j - 1] * px1[mid])\n              l = mid;\n            else\n              r = mid - 1;\n          }\n          if (s[i + r - 1] > s[j + r - 1])\n            d[i] = max(d[i], d[j] + n - i + 1 - r);\n        }\n      }\n      res = max(res, d[i]);\n    }\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long n = 0, f = 1, ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    n = n * 10 + ch - '0';\n    ch = getchar();\n  }\n  return n * f;\n}\nlong long lcp[5005][5005];\nchar str[200005];\nlong long dp[5005];\nsigned main() {\n  long long t, n, ans;\n  t = read();\n  for (long long greg = 1; greg <= t; greg++) {\n    n = read();\n    scanf(\"%s\", str + 1);\n    str[n + 1] = 0;\n    for (long long i = n; i >= 1; i--) {\n      for (long long j = n; j >= 1; j--) {\n        if (str[i] != str[j])\n          lcp[i][j] = 0;\n        else if (i == n || j == n)\n          lcp[i][j] = 1;\n        else\n          lcp[i][j] = lcp[i + 1][j + 1] + 1;\n      }\n    }\n    for (long long i = 1; i <= n; i++) dp[i] = n - i + 1;\n    for (long long i = 2; i <= n; i++) {\n      for (long long j = 1; j <= i - 1; j++) {\n        if (str[i + lcp[i][j]] > str[j + lcp[i][j]])\n          dp[i] = max(dp[i], dp[j] + n - i + 1 - lcp[i][j]);\n      }\n    }\n    ans = 0;\n    for (long long i = 1; i <= n; i++) ans = max(ans, dp[i]);\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long conv(char c) { return c - 'a'; }\nvector<long long> get_sa(const char *s, long long n) {\n  vector<long long> sa(n);\n  long long m = 26;\n  vector<long long> cnt(max(n, m)), x(n), y(n);\n  for (long long i = 0; i < (long long)(n); ++i) cnt[x[i] = conv(s[i])]++;\n  for (long long i = 0; i < (long long)(m - 1); ++i) cnt[i + 1] += cnt[i];\n  for (long long i = n - 1; i >= 0; --i) sa[--cnt[x[i]]] = i;\n  for (long long len = 1, p = 0; p + 1 < n; len <<= 1, m = p + 1) {\n    p = 0;\n    for (long long i = n - len; i < n; ++i) y[p++] = i;\n    for (long long i = 0; i < (long long)(n); ++i)\n      if (sa[i] >= len) y[p++] = sa[i] - len;\n    for (long long i = 0; i < (long long)(m); ++i) cnt[i] = 0;\n    for (long long i = 0; i < (long long)(n); ++i) cnt[x[i]]++;\n    for (long long i = 0; i < (long long)(m - 1); ++i) cnt[i + 1] += cnt[i];\n    for (long long i = n - 1; i >= 0; --i) sa[--cnt[x[y[i]]]] = y[i];\n    y = x;\n    p = 0;\n    x[sa[0]] = 0;\n    for (long long i = 0; i < (long long)(n - 1); ++i)\n      x[sa[i + 1]] = sa[i] + len < n && sa[i + 1] + len < n &&\n                             y[sa[i]] == y[sa[i + 1]] &&\n                             y[sa[i] + len] == y[sa[i + 1] + len]\n                         ? p\n                         : ++p;\n  }\n  return sa;\n}\nvector<long long> get_lcp(const char *s, long long n, vector<long long> &sa) {\n  vector<long long> lcp(n), rank(n);\n  for (long long i = 0; i < (long long)(n); ++i) rank[sa[i]] = i;\n  long long k = 0, j;\n  for (long long i = 0; i < n; lcp[rank[i++]] = k) {\n    if (rank[i] - 1 >= 0)\n      for (k ? k-- : 0, j = sa[rank[i] - 1]; s[i + k] == s[j + k]; ++k)\n        ;\n  }\n  return lcp;\n}\nchar S[5050];\nlong long dp[5050];\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  long long n;\n  cin >> n;\n  cin >> S;\n  vector<long long> sa = get_sa(S, n);\n  vector<long long> lcp = get_lcp(S, n, sa);\n  for (long long i = 0; i < n; ++i) {\n    dp[i] = n - sa[i];\n    long long commonbaby = 1e9;\n    for (long long j = i - 1; j >= 0; --j) {\n      commonbaby = min(commonbaby, lcp[j + 1]);\n      if (sa[j] < sa[i]) {\n        dp[i] = max(dp[i], dp[j] + n - sa[i] - commonbaby);\n      }\n    }\n  }\n  cout << *max_element(dp, dp + n) << '\\n';\n}\nsigned main(void) {\n  cin.tie(0)->sync_with_stdio(false);\n  long long T;\n  cin >> T;\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint t, n, ans, lcp[5009][5009], dp[5009];\nchar s[5009];\nint main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    scanf(\"%s\", s + 1);\n    ans = 0;\n    for (int i = n; i >= 1; i--)\n      for (int j = n; j >= 1; j--)\n        lcp[i][j] = (s[i] == s[j]) ? (lcp[i + 1][j + 1] + 1) : 0;\n    for (int i = 1; i <= n; i++) {\n      dp[i] = n + 1 - i;\n      for (int j = 1; j < i; j++) {\n        int len = lcp[i][j];\n        if (s[j + len] < s[i + len])\n          dp[i] = max(dp[i], dp[j] + n + 1 - (i + len));\n      }\n      ans = max(ans, dp[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nconst long long mod = 1e9 + 7;\ninline long long gcd(long long a, long long b) {\n  return !b ? a : gcd(b, a % b);\n}\ninline long long q_pow(long long a, long long x = mod - 2) {\n  long long ans = 1, tmp = a;\n  while (x) {\n    if (x & 1) (ans *= tmp) %= mod;\n    (tmp *= tmp) %= mod;\n    x >>= 1;\n  }\n  return ans;\n}\ntemplate <typename T>\ninline void re(T &N) {\n  int f = 1;\n  char c;\n  while ((c = getchar()) < '0' || c > '9')\n    if (c == '-') f = -1;\n  N = c - '0';\n  while ((c = getchar()) >= '0' && c <= '9') N = N * 10 + c - '0';\n  N *= f;\n}\ntemplate <class T, class... T_>\ninline void re(T &x, T_ &...y) {\n  re(x), re(y...);\n}\nint m, n, t = 1, st, en;\nchar s[N];\nint dp[N], in[N], col[N];\nvector<int> v[N];\nint lcp[5050][5050];\nint main() {\n  re(t);\n  while (t--) {\n    re(n);\n    scanf(\"%s\", s);\n    for (int i = 0; i < n; i++) in[i] = s[i];\n    for (int i = 0; i <= n; i++) lcp[i][n] = lcp[n][i] = 0;\n    for (int i = n - 1; i >= 0; i--)\n      for (int j = n - 1; j >= 0; j--)\n        lcp[i][j] = s[i] == s[j] ? lcp[i + 1][j + 1] + 1 : 0;\n    for (int i = 0; i < 26; i++) v[i].clear(), col[i] = 0;\n    for (int i = 0; i < n; i++) dp[i] = 0;\n    for (int i = 0; i < n; i++) {\n      int now = s[i] - 'a';\n      dp[i] = n - i;\n      for (int j : v[now]) {\n        int l = lcp[i][j];\n        if (i + l >= n) continue;\n        if (s[i + l] < s[j + l]) continue;\n        dp[i] = max(dp[i], dp[j] + n - i - l);\n      }\n      v[now].push_back(i);\n      for (int j = 0; j < now; j++)\n        if (dp[i] <= col[j] + n - i) dp[i] = col[j] + n - i;\n      col[now] = max(col[now], dp[i]);\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) ans = max(ans, dp[i]);\n    printf(\"%d\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int nax = 5005;\nint n;\nint dp[nax][nax];\nchar s[nax];\nint lcp[nax][nax];\nvector<int> eq[nax];\nvoid solve() {\n  cin >> n;\n  string x;\n  cin >> x;\n  for (int i = 0; i < n; i++) s[i + 1] = x[i];\n  for (int i = 1; i <= n; i++) dp[1][i] = i;\n  for (int i = 0; i <= n + 1; i++) {\n    for (int j = 0; j <= n + 1; j++) lcp[i][j] = 0;\n  }\n  for (int i = n; i >= 1; i--) {\n    for (int j = n; j >= 1; j--) {\n      if (i == j) continue;\n      lcp[i][j] = (s[i] == s[j] ? lcp[i + 1][j + 1] + 1 : 0);\n    }\n  }\n  for (int i = 2; i <= n; i++) {\n    int maxi = 0;\n    for (int j = 1; j < i; j++) {\n      if (s[j] < s[i]) maxi = max(maxi, dp[j][n + 1 - j]);\n    }\n    dp[i][1] = maxi + 1;\n    for (int i = 0; i <= n; i++) eq[i].clear();\n    for (int j = 1; j < i; j++) {\n      int len = lcp[i][j];\n      eq[len].push_back(j);\n    }\n    for (int j = 2; j <= n + 1 - i; j++) {\n      dp[i][j] = dp[i][j - 1] + 1;\n      for (int pre : eq[j]) {\n        dp[i][j] = max(dp[i][j], dp[pre][j]);\n      }\n      for (int pre : eq[j - 1]) {\n        if (s[pre + j - 1] < s[i + j - 1])\n          dp[i][j] = max(dp[i][j], dp[pre][n + 1 - pre] + 1);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n + 1 - i; j++) ans = max(ans, dp[i][j]);\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int power(long long int x, long long int y, long long int m) {\n  if (y == 0) return 1;\n  long long int p = power(x, y / 2, m) % m;\n  p = (p * p) % m;\n  return (y % 2 == 0) ? p : (x * p) % m;\n}\nvector<long long int> Fac(1, 1), Mod_Inv(1, 1);\nint Last_Index = 0;\nlong long int nCr(long long int n, long long int r, long long int m) {\n  if (n < 0 || r < 0) return 0;\n  if (r > n) return 0;\n  if (n > Last_Index) {\n    for (long long int i = Last_Index + 1; i <= n; ++i) {\n      Fac.push_back(Fac[i - 1] * i);\n      Fac[i] %= m;\n      Mod_Inv.push_back(power(Fac[i], m - 2, m));\n    }\n    Last_Index = n;\n  }\n  return (((Fac[n] * Mod_Inv[r]) % m) * Mod_Inv[n - r]) % m;\n}\nlong long int gcd(long long int a, long long int b) {\n  return (b ? gcd(b, a % b) : a);\n}\nint Google_Test;\nvoid cal(vector<long long int> &v, string &s, long long int n,\n         long long int st) {\n  vector<long long int> dp(n);\n  dp[st] = n - st;\n  long long int L, R;\n  L = R = st;\n  for (long long int i = st + 1; i < n; ++i) {\n    if (i > R) {\n      L = R = i;\n      while (R < n && s[R] == s[R - L + st]) ++R;\n      dp[i] = R - L;\n      if (R < n) {\n        if (s[R] > s[st + R - L]) v[i] = n - R;\n      }\n      R--;\n    } else {\n      long long int k = i - L + st;\n      if (i + dp[k] <= R) {\n        dp[i] = dp[k];\n        if (v[k] != -1) v[i] = v[k] - i + k;\n      } else {\n        L = i;\n        R++;\n        while (R < n && s[R - L + st] == s[R]) R++;\n        dp[i] = R - L;\n        if (R < n) {\n          if (s[R] > s[st + R - L]) v[i] = n - R;\n        }\n        R--;\n      }\n    }\n  }\n}\nvoid solve() {\n  long long int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  vector<vector<long long int>> pre(n, vector<long long int>(n, -1));\n  for (long long int i = 0; i < n; ++i) cal(pre[i], s, n, i);\n  vector<long long int> dp(n);\n  long long int ans = 0;\n  for (long long int i = 0; i < n; ++i) {\n    dp[i] = n - i;\n    for (long long int j = 0; j < i; ++j) {\n      if (pre[j][i] != -1) dp[i] = max(dp[i], dp[j] + pre[j][i]);\n    }\n    ans = max(ans, dp[i]);\n  }\n  cout << ans << '\\n';\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T, n, f[10010], ans, l, r, mid;\nstring s;\nunsigned long long hs[5005][5005];\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d\", &n);\n    cin >> s;\n    s.insert(0, \" \");\n    s += \"a\";\n    for (int i = 1; i <= n; i++) {\n      f[i] = n + 1 - i;\n    }\n    for (int i = 1; i <= n; i++) {\n      for (int j = i; j <= n; j++) hs[i][j] = hs[i][j - 1] * 133 + (s[j] - '0');\n    }\n    for (int i = 1; i <= n; i++)\n      for (int j = 1; j < i; j++) {\n        if (s[i] > s[j])\n          f[i] = max(f[i], f[j] + n + 1 - i);\n        else if (s[i] == s[j]) {\n          l = 1;\n          r = n - i + 1;\n          while (l < r) {\n            mid = l + r + 1 >> 1;\n            if (hs[i][i + mid - 1] == hs[j][j + mid - 1])\n              l = mid;\n            else\n              r = mid - 1;\n          }\n          if (s[i + l] > s[j + l]) f[i] = max(f[i], f[j] + n + 1 - i - l);\n        }\n      }\n    ans = 0;\n    for (int i = 1; i <= n; i++) ans = max(ans, f[i]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<vector<int>> lcp(n, vector<int>(n));\n    for (int i = n - 1; i >= 0; --i) {\n      for (int j = n - 1; j >= 0; --j) {\n        lcp[i][j] =\n            (s[i] == s[j]\n                 ? ((i < n - 1 && j < n - 1) ? lcp[i + 1][j + 1] : 0) + 1\n                 : 0);\n      }\n    }\n    vector<int> dp(n);\n    for (int i = 0; i < n; ++i) {\n      dp[i] = n - i;\n      for (int j = 0; j < i; ++j) {\n        if (i + lcp[i][j] < n && s[j + lcp[i][j]] < s[i + lcp[i][j]]) {\n          dp[i] = max(dp[i], dp[j] + (n - lcp[j][i] - i));\n        }\n      }\n    }\n    cout << *max_element(dp.begin(), dp.end()) << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  debug_out(T...);\n}\nconst int N = 10010;\nchar s[N];\nint x[N], y[N], sa[N], height[N], rk[N], c[N];\nint n, m;\nvoid get_sa() {\n  for (int i = 1; i <= n; ++i) ++c[x[i] = s[i]];\n  for (int i = 1; i <= m; ++i) c[i] += c[i - 1];\n  for (int i = n; i >= 1; --i) sa[c[x[i]]--] = i;\n  for (int k = 1; k <= n; k <<= 1) {\n    int num = 0;\n    for (int i = n - k + 1; i <= n; ++i) y[++num] = i;\n    for (int i = 1; i <= n; ++i)\n      if (sa[i] > k) y[++num] = sa[i] - k;\n    for (int i = 1; i <= m; ++i) c[i] = 0;\n    for (int i = 1; i <= n; ++i) ++c[x[i]];\n    for (int i = 1; i <= m; ++i) c[i] += c[i - 1];\n    for (int i = n; i >= 1; --i) sa[c[x[y[i]]]--] = y[i], y[i] = 0;\n    swap(x, y), num = 1, x[sa[1]] = 1;\n    for (int i = 2; i <= n; ++i)\n      x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k])\n                     ? num\n                     : ++num;\n    if (num == n) break;\n    m = num;\n  }\n}\nvoid get_height() {\n  for (int i = 1; i <= n; ++i) rk[sa[i]] = i;\n  for (int i = 1, k = 0; i <= n; ++i) {\n    if (rk[i] == 1) continue;\n    if (k) --k;\n    int j = sa[rk[i] - 1];\n    while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) ++k;\n    height[rk[i]] = k;\n  }\n}\nll d[N];\nint f[N][20], loog[N];\nvoid init() {\n  for (int j = 0; 1 << j <= n; j++) {\n    for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n      if (!j)\n        f[i][j] = height[i];\n      else\n        f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n    }\n  }\n  loog[1] = 0;\n  for (int i = 2; i <= n; i++) loog[i] = loog[i / 2] + 1;\n}\nint query(int l, int r) {\n  int len = r - l + 1, k = loog[len];\n  return min(f[l][k], f[r - (1 << k) + 1][k]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    cin >> n >> (s + 1);\n    m = 300;\n    for (int i = 0; i <= max(m, 2 * n); i++) x[i] = y[i] = c[i] = 0;\n    for (int i = 1; i <= n; i++) d[i] = n - i + 1;\n    get_sa();\n    get_height();\n    init();\n    ll res = 0;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j < i; j++) {\n        int l = rk[i], r = rk[j];\n        if (l > r) swap(l, r);\n        int len = query(l + 1, r);\n        if (len != n - i + 1 && s[i + len] > s[j + len])\n          d[i] = max(d[i], d[j] + n - i + 1 - len);\n      }\n      res = max(res, d[i]);\n    }\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &x) {\n  x = 0;\n  char c = getchar(), f = 0;\n  for (; c < 48 || c > 57; c = getchar())\n    if (!(c ^ 45)) f = 1;\n  for (; c >= 48 && c <= 57; c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);\n  f ? x = -x : x;\n}\ntemplate <typename T, typename... L>\ninline void read(T &x, L &...l) {\n  read(x), read(l...);\n}\nstruct node {\n  string s;\n  int vl;\n  char operator<(node b) const { return s < b.s; }\n};\nconst int N = 5005;\nint n, lp[N][N], dp[N];\nchar ch[N];\ninline void solve() {\n  read(n), scanf(\"%s\", ch + 1);\n  for (int i = 1; i <= n; i++) dp[i] = n - i + 1;\n  for (int i = 1; i <= n; i++) lp[n][i] = lp[i][n] = (ch[n] == ch[i]);\n  for (int i = n - 1; i; i--)\n    for (int j = n - 1; j; j--)\n      if (ch[i] == ch[j])\n        lp[i][j] = lp[i + 1][j + 1] + 1;\n      else\n        lp[i][j] = 0;\n  for (int i = 2; i <= n; i++)\n    for (int j = 1; j < i; j++) {\n      int l = lp[i][j];\n      if (ch[j + l] > ch[i + l]) continue;\n      dp[i] = max(dp[j] + n - i + 1 - l, dp[i]);\n    }\n  int mx = 0;\n  for (int i = 1; i <= n; i++) mx = max(mx, dp[i]);\n  printf(\"%d\\n\", mx);\n}\nint main() {\n  int Ca;\n  for (read(Ca); Ca--;) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e3 + 5, mod = 1e9 + 7;\nint t, p[N][N], dp[N];\nint main() {\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    string second;\n    cin >> second;\n    second = '$' + second + '$';\n    for (int i = n; i >= 1; i--) {\n      for (int j = n; j >= 1; j--) {\n        if (j == i)\n          p[i][j] = n - i + 1;\n        else if (second[j] == second[i])\n          p[i][j] = 1 + p[i + 1][j + 1];\n        else\n          p[i][j] = 0;\n      }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      dp[i] = n - i + 1;\n      for (int j = 1; j < i; j++) {\n        if (second[i + p[i][j]] > second[j + p[i][j]])\n          dp[i] = max(dp[i], dp[j] + n - i + 1 - p[i][j]);\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INF64 = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\ntypedef std::priority_queue<int, vector<int>, greater<int>> small_pq;\ntypedef std::priority_queue<int, vector<int>, less<int>> big_pq;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() {}\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  if (sizeof...(T) > 0) cerr << \" ,\";\n  dbg_out(T...);\n}\nvoid dbg_name(const string &s) {\n  string ss = s;\n  replace(ss.begin(), ss.end(), ',', ' ');\n  cerr << \"  ( \" << ss << \" )  \";\n}\ntemplate <typename T>\ninline void setmin(T &a, const T &b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\ninline void setmax(T &a, const T &b) {\n  if (b > a) a = b;\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nunordered_map<long long, int, custom_hash> safe_map;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::steady_clock::now().time_since_epoch().count());\nconst int MOD = 998244353;\nint mul(int x, int y) { return 1ll * x * y % MOD; }\nint add(int x, int y) { return ((x + y) % MOD + MOD) % MOD; }\nint sub(int x, int y) { return ((x - y) % MOD + MOD) % MOD; }\nint qpow(int a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = mul(ans, a);\n    a = mul(a, a);\n    b /= 2;\n  }\n  return ans;\n}\nconst int N = 1e4 + 5;\nnamespace Suffix {\nint sa[N], rk[N * 2], oldrk[N * 2], cnt[N * 2], id[N], px[N * 2];\nint ht[N];\nbool cmp(int x, int y, int w) {\n  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\nvoid suffix_array(char *s) {\n  memset(cnt, 0, sizeof(cnt));\n  memset(rk, 0, sizeof(rk));\n  int n = strlen(s + 1);\n  for (int i = 1; i <= n; i++) rk[i] = s[i];\n  int m = 300;\n  for (int i = 1; i <= n; i++) cnt[rk[i]]++;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    int p = 0;\n    for (int i = n; i > n - w; i--) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    fill(cnt, cnt + m + 1, 0);\n    for (int i = 1; i <= n; i++) cnt[px[i] = rk[id[i]]]++;\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[px[i]]--] = id[i];\n    memcpy(oldrk, rk, sizeof(rk));\n    p = 0;\n    for (int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n    m = p;\n  }\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (k) k--;\n    while ((i + k <= n) && s[i + k] == s[sa[rk[i] - 1] + k]) k++;\n    ht[rk[i]] = k;\n  }\n}\n}  // namespace Suffix\nconst int M = 14;\nchar s[N];\nint dp[N];\nint f[N][M];\nint calc(int i, int j) {\n  int s = log2(j - i + 1);\n  return min(f[i][s], f[j - (1 << s) + 1][s]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  using namespace Suffix;\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d %s\", &n, s + 1);\n    Suffix::suffix_array(s);\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      f[i][0] = Suffix::ht[i];\n    }\n    for (int(i) = int(1); int(i) <= int(M - 1); i++) {\n      for (int(j) = int(1); int(j) <= int(n); j++) {\n        f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n    int ans = 0;\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      dp[i] = n - i + 1;\n      for (int(j) = int(1); int(j) <= int(i - 1); j++) {\n        if (Suffix::rk[i] > Suffix::rk[j])\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - calc(rk[j] + 1, rk[i]));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n    fill(dp + 1, dp + 1 + n, 0);\n    for (int(i) = int(0); int(i) <= int(M - 1); i++)\n      for (int(j) = int(1); int(j) <= int(n); j++) f[j][i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5010;\nint T, n, ans, f[MAXN];\nchar s[MAXN];\nstruct SA {\n  int sa[MAXN], rk[MAXN * 2], oldrk[MAXN * 2], cnt[MAXN], tmp[MAXN];\n  int lcp[MAXN][MAXN], height[MAXN];\n  void build(char* s, int n) {\n    for (int i = (0); i <= (n * 2 + 5); i++) {\n      rk[i] = oldrk[i] = 0;\n    }\n    int m = max(n, 150);\n    for (int i = (0); i <= (m); i++) cnt[i] = 0;\n    for (int i = (1); i <= (n); i++) rk[i] = s[i];\n    for (int i = (1); i <= (n); i++) cnt[rk[i]]++;\n    for (int i = (1); i <= (m); i++) cnt[i] += cnt[i - 1];\n    for (int i = (n); i >= (1); i--) sa[cnt[rk[i]]--] = i;\n    for (int w = 1; w < n; w <<= 1) {\n      int p = 0;\n      for (int i = (n - w + 1); i <= (n); i++) tmp[++p] = i;\n      for (int i = (1); i <= (n); i++)\n        if (sa[i] > w) tmp[++p] = sa[i] - w;\n      for (int i = (0); i <= (m); i++) cnt[i] = 0;\n      for (int i = (1); i <= (n); i++) cnt[rk[tmp[i]]]++;\n      for (int i = (1); i <= (m); i++) cnt[i] += cnt[i - 1];\n      for (int i = (n); i >= (1); i--) sa[cnt[rk[tmp[i]]]--] = tmp[i];\n      for (int i = (1); i <= (n); i++) oldrk[i] = rk[i];\n      rk[sa[1]] = 1;\n      for (int i = (2); i <= (n); i++) {\n        rk[sa[i]] = rk[sa[i - 1]];\n        if (oldrk[sa[i]] != oldrk[sa[i - 1]] ||\n            oldrk[sa[i] + w] != oldrk[sa[i - 1] + w])\n          rk[sa[i]]++;\n      }\n    }\n    int j = 0;\n    for (int i = (1); i <= (n); i++) {\n      if (j) j--;\n      while (s[i + j] == s[sa[rk[i] - 1] + j]) j++;\n      height[rk[i]] = j;\n    }\n    for (int i = (1); i <= (n); i++) {\n      lcp[i][i] = (n - sa[i] + 1);\n      for (int j = (i + 1); j <= (n); j++) {\n        lcp[i][j] = min(lcp[i][j - 1], height[j]);\n      }\n    }\n  }\n  int query(int L, int R) {\n    L = rk[L];\n    R = rk[R];\n    if (L > R) swap(L, R);\n    return lcp[L][R];\n  }\n} sa;\nvoid solve() {\n  scanf(\"%d%s\", &n, s + 1);\n  sa.build(s, n);\n  ans = 0;\n  for (int i = (1); i <= (n); i++) {\n    f[i] = n - i + 1;\n    for (int j = (1); j <= (i - 1); j++) {\n      int len = sa.query(i, j);\n      if (i + len - 1 == n || s[i + len] < s[j + len]) continue;\n      f[i] = max(f[i], f[j] + (n - i + 1 - len));\n    }\n    ans = max(ans, f[i]);\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e3 + 5;\nconst int p = 998244353;\nint read() {\n  int s = 0;\n  char c = getchar(), lc = '+';\n  while (c < '0' || '9' < c) lc = c, c = getchar();\n  while ('0' <= c && c <= '9') s = s * 10 + c - '0', c = getchar();\n  return lc == '-' ? -s : s;\n}\nvoid write(int x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x < 10)\n    putchar(x + '0');\n  else\n    write(x / 10), putchar(x % 10 + '0');\n}\nvoid print(int x, char c = '\\n') {\n  write(x);\n  putchar(c);\n}\ninline void up(int &x, int y) { x = max(x, y); }\nint n;\nchar a[N];\nmap<int, int> mx[N];\nint dp[N][N], lcp[N][N];\nsigned main(signed Goodbye, char *Wangang[]) {\n  (void)Goodbye, (void)Wangang;\n  int T = read();\n  while (T--) {\n    n = read();\n    scanf(\"%s\", a + 1);\n    for (int i = n; i >= 1; i--)\n      for (int j = n; j >= 1; j--)\n        lcp[i][j] = a[i] == a[j] ? lcp[i + 1][j + 1] + 1 : 0;\n    for (int i = 1; i <= n; i++)\n      for (int j = 0; i + j <= n; j++) dp[i][j] = 1;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j < i; j++)\n        if (i + lcp[i][j] <= n && a[i + lcp[i][j]] > a[j + lcp[i][j]])\n          up(dp[i][lcp[i][j]], dp[j][n - j] + 1);\n      for (int j = 1; i + j <= n; j++) up(dp[i][j], dp[i][j - 1] + 1);\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n      for (int j = 0; i + j <= n; j++) up(ans, dp[i][j]);\n    print(ans);\n    for (int i = 1; i <= n; i++)\n      for (int j = 1; j <= n; j++) lcp[i][j] = 0;\n    for (int i = 0; i < n; i++) mx[i].clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1000000007;\nconst int maxn = 5010;\nint main() {\n  int t, n;\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    static char s[maxn];\n    scanf(\"%s\", s);\n    static int lcp[maxn][maxn];\n    for (int i = 0; i <= n; ++i) {\n      lcp[0][n] = lcp[n][0] = 0;\n    }\n    int ans = 0;\n    static int dp[maxn];\n    for (int i = n - 1; i >= 0; --i) {\n      dp[i] = n - i;\n      for (int j = i + 1; j < n; ++j) {\n        lcp[i][j] = (s[i] == s[j] ? lcp[i + 1][j + 1] + 1 : 0);\n        int len = lcp[i][j];\n        if (len != n - j && s[i + len] < s[j + len]) {\n          dp[i] = max(dp[i], dp[j] + (n - i) - len);\n        }\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INF64 = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\ntypedef std::priority_queue<int, vector<int>, greater<int>> small_pq;\ntypedef std::priority_queue<int, vector<int>, less<int>> big_pq;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() {}\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  if (sizeof...(T) > 0) cerr << \" ,\";\n  dbg_out(T...);\n}\nvoid dbg_name(const string &s) {\n  string ss = s;\n  replace(ss.begin(), ss.end(), ',', ' ');\n  cerr << \"  ( \" << ss << \" )  \";\n}\ntemplate <typename T>\ninline void setmin(T &a, const T &b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\ninline void setmax(T &a, const T &b) {\n  if (b > a) a = b;\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nunordered_map<long long, int, custom_hash> safe_map;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::steady_clock::now().time_since_epoch().count());\nconst int MOD = 998244353;\nint mul(int x, int y) { return 1ll * x * y % MOD; }\nint add(int x, int y) { return ((x + y) % MOD + MOD) % MOD; }\nint sub(int x, int y) { return ((x - y) % MOD + MOD) % MOD; }\nint qpow(int a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = mul(ans, a);\n    a = mul(a, a);\n    b /= 2;\n  }\n  return ans;\n}\nconst int N = 1e4 + 5;\nnamespace Suffix {\nint sa[N], rk[N * 2], oldrk[N * 2], cnt[N * 2], id[N], px[N * 2];\nint ht[N];\nbool cmp(int x, int y, int w) {\n  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\nvoid suffix_array(const string &s) {\n  int n = s.size();\n  fill(rk + 1, rk + 1 + 2 * n, 0);\n  for (int i = 1; i <= n; i++) rk[i] = s[i - 1];\n  int m = 150;\n  fill(cnt, cnt + m + 1, 0);\n  for (int i = 1; i <= n; i++) cnt[rk[i]]++;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    int p = 0;\n    for (int i = n; i > n - w; i--) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    fill(cnt, cnt + m + 1, 0);\n    for (int i = 1; i <= n; i++) cnt[px[i] = rk[id[i]]]++;\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[px[i]]--] = id[i];\n    copy(rk + 1, rk + 1 + 2 * n, oldrk + 1);\n    p = 0;\n    for (int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n    m = p;\n  }\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (k) k--;\n    while ((i + k <= n) && s[i + k - 1] == s[sa[rk[i] - 1] + k - 1]) k++;\n    ht[rk[i]] = k;\n  }\n}\n}  // namespace Suffix\nconst int M = 14;\nchar s[N];\nint dp[N];\nint f[N][M];\nint calc(int i, int j) {\n  int s = log2(j - i + 1);\n  return min(f[i][s], f[j - (1 << s) + 1][s]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  using namespace Suffix;\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    string s;\n    cin >> n >> s;\n    Suffix::suffix_array(s);\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      f[i][0] = Suffix::ht[i];\n    }\n    for (int(i) = int(1); int(i) <= int(M - 1); i++) {\n      for (int(j) = int(1); int(j) <= int(n); j++) {\n        f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n    int ans = 0;\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      dp[i] = n - i + 1;\n      for (int(j) = int(1); int(j) <= int(i - 1); j++) {\n        if (Suffix::rk[i] > Suffix::rk[j])\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - calc(rk[j] + 1, rk[i]));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n    fill(dp + 1, dp + 1 + n, 0);\n    for (int(i) = int(0); int(i) <= int(M - 1); i++)\n      for (int(j) = int(1); int(j) <= int(n); j++) f[j][i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INF64 = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\ntypedef std::priority_queue<int, vector<int>, greater<int>> small_pq;\ntypedef std::priority_queue<int, vector<int>, less<int>> big_pq;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() {}\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  if (sizeof...(T) > 0) cerr << \" ,\";\n  dbg_out(T...);\n}\nvoid dbg_name(const string &s) {\n  string ss = s;\n  replace(ss.begin(), ss.end(), ',', ' ');\n  cerr << \"  ( \" << ss << \" )  \";\n}\ntemplate <typename T>\ninline void setmin(T &a, const T &b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\ninline void setmax(T &a, const T &b) {\n  if (b > a) a = b;\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nunordered_map<long long, int, custom_hash> safe_map;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::steady_clock::now().time_since_epoch().count());\nconst int MOD = 998244353;\nint mul(int x, int y) { return 1ll * x * y % MOD; }\nint add(int x, int y) { return ((x + y) % MOD + MOD) % MOD; }\nint sub(int x, int y) { return ((x - y) % MOD + MOD) % MOD; }\nint qpow(int a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = mul(ans, a);\n    a = mul(a, a);\n    b /= 2;\n  }\n  return ans;\n}\nconst int N = 1e4 + 5;\nnamespace Suffix {\nint sa[N], rk[N * 2], oldrk[N * 2], cnt[N * 2], id[N], px[N * 2];\nint ht[N];\nbool cmp(int x, int y, int w) {\n  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\nvoid suffix_array(char *s) {\n  int n = strlen(s + 1);\n  fill(rk + 1, rk + 1 + 2 * n, 0);\n  for (int i = 1; i <= n; i++) rk[i] = s[i];\n  int m = 150;\n  fill(cnt, cnt + m + 1, 0);\n  for (int i = 1; i <= n; i++) cnt[rk[i]]++;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    int p = 0;\n    for (int i = n; i > n - w; i--) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    fill(cnt, cnt + m + 1, 0);\n    for (int i = 1; i <= n; i++) cnt[px[i] = rk[id[i]]]++;\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[px[i]]--] = id[i];\n    copy(rk + 1, rk + 1 + 2 * n, oldrk + 1);\n    p = 0;\n    for (int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n    m = p;\n  }\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (k) k--;\n    while ((i + k <= n) && s[i + k] == s[sa[rk[i] - 1] + k]) k++;\n    ht[rk[i]] = k;\n  }\n}\n}  // namespace Suffix\nconst int M = 14;\nchar s[N];\nint dp[N];\nint f[N][M];\nint calc(int i, int j) {\n  int s = log2(j - i + 1);\n  return min(f[i][s], f[j - (1 << s) + 1][s]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  using namespace Suffix;\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d %s\", &n, s + 1);\n    Suffix::suffix_array(s);\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      f[i][0] = Suffix::ht[i];\n    }\n    for (int(i) = int(1); int(i) <= int(M - 1); i++) {\n      for (int(j) = int(1); int(j) <= int(n); j++) {\n        f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n    int ans = 0;\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      dp[i] = n - i + 1;\n      for (int(j) = int(1); int(j) <= int(i - 1); j++) {\n        if (Suffix::rk[i] > Suffix::rk[j])\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - calc(rk[j] + 1, rk[i]));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n    fill(dp + 1, dp + 1 + n, 0);\n    for (int(i) = int(0); int(i) <= int(M - 1); i++)\n      for (int(j) = int(1); int(j) <= int(n); j++) f[j][i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, i, j, k;\nstring s;\nint d, sa[5141], pos[5141], temp[5141], lcp[5141];\nbool cmp(int i, int j) {\n  if (pos[i] != pos[j]) return pos[i] < pos[j];\n  i += d;\n  j += d;\n  return (i < n && j < n) ? (pos[i] < pos[j]) : (i > j);\n}\nint main() {\n  iostream::sync_with_stdio(0);\n  cin.tie(0);\n  for (cin >> m; m--;) {\n    cin >> n >> s;\n    vector<int> dp(n);\n    for (i = 0; i < n; ++i) {\n      sa[i] = i;\n      pos[i] = s[i];\n    }\n    for (d = 1;; d *= 2) {\n      sort(sa, sa + n, cmp);\n      memset(temp, 0, sizeof(temp));\n      for (i = 0; i < n - 1; ++i) {\n        temp[i + 1] = temp[i] + cmp(sa[i], sa[i + 1]);\n      }\n      for (i = 0; i < n; ++i) {\n        pos[sa[i]] = temp[i];\n      }\n      if (temp[n - 1] == n - 1) break;\n    }\n    for (i = k = 0; i < n; ++i, k = max(k - 1, 0)) {\n      if (pos[i] == n - 1) continue;\n      for (j = sa[pos[i] + 1]; s[i + k] == s[j + k]; ++k)\n        ;\n      lcp[pos[i]] = k;\n    }\n    k = 0;\n    for (i = 0; i < s.size(); ++i) {\n      int temp = 0, l = INT_MAX;\n      for (j = pos[i]; j--;) {\n        l = min(l, lcp[j]);\n        if (sa[j] < i) {\n          temp = max(dp[sa[j]] - l, temp);\n        }\n      }\n      k = max(k, dp[i] = temp + s.size() - i);\n    }\n    cout << k << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T, n, ans, LCP[5005][5005], dp[5005][5005];\nvector<int> vc[5005];\nchar a[5005];\nvoid slv() {\n  scanf(\"%d %s\", &n, a + 1);\n  ans = 0;\n  for (int i = n, t; i; --i)\n    for (int j = n; j > i; --j) {\n      t = i < n && j < n ? LCP[i + 1][j + 1] : 0;\n      LCP[i][j] = a[i] == a[j] ? t + 1 : 0;\n    }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0; j <= n - i + 1; ++j) vc[j].clear();\n    for (int j = 1; j < i; ++j) vc[LCP[j][i]].push_back(j);\n    for (int j = 1; j <= n - i + 1; ++j) {\n      dp[i][j] = dp[i][j - 1] + 1;\n      for (auto k : vc[j - 1])\n        if (a[i + j - 1] > a[k + j - 1])\n          dp[i][j] = max(dp[i][j], dp[k][n - k + 1] + 1);\n      ans = max(ans, dp[i][j]);\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) slv();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5005, oo = 1e9 + 10;\nint lcp[N][N], dp[N];\nvoid solve() {\n  int n;\n  string s;\n  cin >> n >> s;\n  s = \"#\" + s;\n  for (int i = 0; i <= n + 1; ++i) {\n    for (int j = 0; j <= n + 1; ++j) {\n      lcp[i][j] = 0;\n    }\n  }\n  for (int L = n; L >= 1; --L) {\n    for (int R = L; R <= n; ++R) {\n      if (s[L] == s[R]) {\n        lcp[L][R] = lcp[L + 1][R + 1] + 1;\n      } else {\n        lcp[L][R] = 0;\n      }\n    }\n  }\n  auto is_less = [&](int i, int j) -> bool {\n    assert(i < j);\n    int at_i = i + lcp[i][j];\n    int at_j = j + lcp[i][j];\n    if (at_j == n + 1) {\n      return false;\n    }\n    return s[at_i] < s[at_j];\n  };\n  for (int i = 1; i <= n; ++i) {\n    dp[i] = n - i + 1;\n  }\n  for (int i = 2; i <= n; ++i) {\n    for (int j = 1; j < i; ++j) {\n      if (is_less(j, i)) {\n        dp[i] = max(dp[i], dp[j] + (n - i + 1 - lcp[j][i]));\n      }\n    }\n  }\n  int best = 0;\n  for (int i = 1; i <= n; ++i) {\n    best = max(best, dp[i]);\n  }\n  cout << best << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int T = 1;\n  cin >> T;\n  while (T--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Div737 {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n//        Scanner sc = new Scanner(new FileReader(\"intervals.in\"));\n        PrintWriter pw = new PrintWriter(System.out);\n        int tc = sc.nextInt();\n        while (tc-- > 0) {\n            int n = sc.nextInt();\n            char[] s = (sc.next() + \"$\").toCharArray();\n            suffixArrayIterative suf = new suffixArrayIterative(s);\n            int[] order = suf.saArr();\n            int[] lcp = suf.lcpArr();\n            int[][] min = new int[n + 1][n + 1];\n//\n//            for (int[] x : min)\n//                Arrays.fill(x, n);\n//            System.err.println(Arrays.toString(order) + \" suf\");\n//            System.err.println(Arrays.toString(lcp) + \" lcp\");\n            int[] dp = new int[n + 1];\n            for (int i = 1; i < order.length; i++) {\n                int curmin = n + 1;\n                for (int j = i + 1; j < order.length; j++) {\n                    curmin = Math.min(curmin, lcp[j]);\n                    min[i][j] = curmin;\n                    min[j][i] = curmin;\n\n                }\n            }\n            int ans = 0;\n            for (int i = order.length - 1; i > 0; i--) {\n                int cur = order[i];\n                dp[i] = n - cur;\n                for (int j = i + 1; j <= n; j++) {\n                    if (cur < order[j]) {\n                        dp[i] = Math.max(dp[i], n - cur + dp[j] - min[i][j]);\n                    }\n                }\n                ans = Math.max(ans, dp[i]);\n            }\n            pw.println(ans);\n        }\n\n\n        pw.flush();\n    }\n\n    static class suffixArrayIterative {\n        int[][] arrs;\n        char[] in;\n        int n;\n\n        public suffixArrayIterative(char[] in) {//has a terminating character (e.g. '$')\n            this.n = in.length;//O(n*log(n))\n            this.in = in;\n            int k = 0;\n            while ((1 << k) < n) {\n                k++;\n            }\n            arrs = solve();\n        }\n\n        int[] saArr() {\n            return arrs[0];\n        }\n\n        int[] cArr() {\n            return arrs[1];\n        }\n\n        int[][] solve() {\n            int n = in.length;//O(n*log(n))\n            int[][] a = new int[n][2];\n            for (int i = 0; i < in.length; i++) {\n                a[i] = new int[]{in[i] - 'a', i};\n            }\n            Arrays.sort(a, (x, y) -> x[0] - y[0]);\n            int[] sa = new int[n], c = new int[n];\n            for (int i = 0; i < n; i++) {\n                sa[i] = a[i][1];\n            }\n            c[a[0][1]] = 0;\n            for (int i = 1; i < n; i++) {\n                c[a[i][1]] = (a[i][0] == a[i - 1][0]) ? c[a[i - 1][1]] : c[a[i - 1][1]] + 1;\n            }\n            int k = 0;\n            while ((1 << k) < n) {\n                for (int i = 0; i < n; i++) {\n                    sa[i] = (sa[i] + n - (1 << k)) % n;\n                }\n                sa = countingSort(sa, c);\n\n                int[] newc = new int[n];\n                newc[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    int[] curPair = new int[]{c[sa[i]], c[(sa[i] + (1 << k)) % n]};\n                    int[] prevPair = new int[]{c[sa[i - 1]], c[(sa[i - 1] + (1 << k)) % n]};\n                    newc[sa[i]] = (compare(prevPair, curPair) == 0) ? newc[sa[i - 1]] : (newc[sa[i - 1]] + 1);\n                }\n                c = newc;\n                k++;\n            }\n            return new int[][]{sa, c};\n        }\n\n        int compare(int[] x, int[] y) {\n            return x[0] != y[0] ? x[0] - y[0] : x[1] - y[1];\n        }\n\n        int[] countingSort(int[] sa, int[] c) {\n            int n = sa.length;\n            int[] cnt = new int[n];\n            for (int i : sa) {\n                cnt[c[i]]++;\n            }\n            int[] pointers = new int[n];\n            pointers[0] = 0;\n            for (int i = 1; i < n; i++) {\n                pointers[i] = pointers[i - 1] + cnt[i - 1];\n            }\n            int[] newSa = new int[n];\n            for (int i : sa) {\n                newSa[pointers[c[i]]++] = i;\n            }\n            return newSa;\n        }\n\n        int[] lcpArr() {\n            int[] sa = saArr();\n            int[] c = cArr();\n            int[] lcp = new int[n];\n            int k = 0;\n            for (int i = 0; i < n - 1; i++) {\n                int cur = i, prev = sa[c[i] - 1];\n                while (in[cur + k] == in[prev + k]) k++;\n                lcp[c[i]] = k;\n                k = Math.max(k - 1, 0);\n            }\n            return lcp;\n        }\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int[] nextIntArr(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring int_to_string(long long n) {\n  string s = \"\";\n  while (n) {\n    long long now = n % 10;\n    s += now + '0';\n    n /= 10;\n  }\n  reverse(s.begin(), s.end());\n  return s;\n}\nlong long string_to_int(string s) {\n  long long n = 0;\n  for (int i = 0; i < (int)(s.size()); i++) {\n    n *= 10;\n    n += s[i] - '0';\n  }\n  return n;\n}\nvoid chmax(int &a, int b) { a = max(a, b); }\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int month[2][12] = {{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},\n                          {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}};\nint lcp[5050][5050];\nint dp[5050];\nint n;\nstring s;\nbool check(int x, int y) {\n  if (lcp[x][y] == n - x + 1) {\n    return 0;\n  }\n  return s[x + lcp[x][y] - 1] > s[y + lcp[x][y] - 1];\n}\nint doit(int x, int y) {\n  if (!check(x, y)) {\n    return -1e9;\n  }\n  return n - x + 1 - lcp[x][y];\n}\nvoid solve() {\n  cin >> n;\n  cin >> s;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      lcp[i][j] = 0;\n    }\n  }\n  for (int i = n; i >= 1; i--) {\n    for (int j = n; j >= 1; j--) {\n      if (i == j) {\n        lcp[i][j] = n - i + 1;\n      } else {\n        if (s[i - 1] == s[j - 1]) {\n          lcp[i][j] = lcp[i + 1][j + 1] + 1;\n        }\n      }\n    }\n  }\n  int ans = n;\n  for (int i = 1; i <= n; i++) {\n    dp[i] = n - i + 1;\n    for (int j = 1; j <= i - 1; j++) {\n      chmax(dp[i], dp[j] + doit(i, j));\n    }\n    ans = max(ans, dp[i]);\n  }\n  cout << ans << endl;\n}\nsigned main() {\n  std::ios::sync_with_stdio(false);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long T, n, dp[5005];\nlong long f[20][5005], LOG[5005];\nstring s;\nlong long bk[5005], rk[5005], tp[5005], sa[5005], hei[5005], M;\nvoid init_st() {\n  LOG[0] = -1;\n  f[0][0] = 0;\n  for (long long i = 1; i < 5005; i++) LOG[i] = LOG[i >> 1] + 1, f[0][i] = 0;\n  for (long long i = 1; i <= n; i++) f[0][i] = hei[i];\n  for (long long i = 1; i <= 18; i++) {\n    for (long long j = 1; j <= n; j++) {\n      if (j + (1ll << (i - 1)) > n) break;\n      f[i][j] = min(f[i - 1][j], f[i - 1][j + (1ll << (i - 1))]);\n    }\n  }\n}\nlong long rmq(long long x, long long y) {\n  if (x > y) swap(x, y);\n  long long k = LOG[y - x + 1];\n  return min(f[k][x], f[k][y - (1ll << k) + 1]);\n}\nvoid sort_sa() {\n  for (long long i = 0; i <= M; i++) bk[i] = 0;\n  for (long long i = 1; i <= n; i++) bk[rk[tp[i]]]++;\n  for (long long i = 1; i <= M; i++) bk[i] += bk[i - 1];\n  for (long long i = n; i >= 1; i--) sa[bk[rk[tp[i]]]--] = tp[i];\n}\nvoid get_sa() {\n  for (long long i = 1; i <= n; i++) {\n    rk[i] = s[i];\n    tp[i] = i;\n  }\n  M = 195;\n  sort_sa();\n  for (long long w = 1; w <= n; w <<= 1) {\n    long long cnt = 0;\n    for (long long i = n - w + 1; i <= n; i++) tp[++cnt] = i;\n    for (long long i = 1; i <= n; i++)\n      if (sa[i] - w > 0) tp[++cnt] = sa[i] - w;\n    sort_sa();\n    swap(rk, tp);\n    cnt = 0;\n    rk[sa[0]] = 0;\n    for (long long i = 1; i <= n; i++)\n      rk[sa[i]] =\n          (tp[sa[i]] == tp[sa[i - 1]] && tp[sa[i] + w] == tp[sa[i - 1] + w])\n              ? cnt\n              : ++cnt;\n    M = cnt + 1;\n  }\n  long long k = 0;\n  for (long long j, i = 1; i <= n; i++) {\n    if (k) k--;\n    j = sa[rk[i] - 1];\n    while (s[i + k] == s[j + k]) k++;\n    hei[rk[i]] = k;\n  }\n  init_st();\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> T;\n  while (T--) {\n    cin >> n;\n    cin >> s;\n    s = ' ' + s;\n    get_sa();\n    s += '0';\n    dp[0] = 0;\n    for (long long i = 1; i <= n; i++) {\n      dp[i] = n - i + 1;\n      for (long long pre, j = 1; j < i; j++) {\n        pre = rmq(min(rk[i], rk[j]) + 1, max(rk[i], rk[j]));\n        if (s[i + pre] > s[j + pre]) {\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - pre);\n        }\n      }\n    }\n    long long ans = 0;\n    for (long long i = 1; i <= n; i++) ans = max(ans, dp[i]);\n    cout << ans << '\\n';\n    for (long long i = 1; i <= n; i++)\n      dp[i] = sa[i] = rk[i] = tp[i] = hei[i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long t, n;\nstring s;\nint32_t main() {\n  cin >> t;\n  while (t--) {\n    cin >> n >> s;\n    vector<string> v;\n    for (long long i = 0; i < n; ++i) v.push_back(s.substr(i, n - i));\n    sort(v.begin(), v.end());\n    vector<long long> dp(n, 0);\n    long long res = 0;\n    for (long long i = n - 1; i >= 0; --i) {\n      long long l = 0;\n      for (long long j = n - 1; j > i; --j) {\n        while (l < v[j].size() && l < v[i].size() && v[i][l] == v[j][l]) l++;\n        if (v[j].size() < v[i].size()) {\n          dp[i] = max(dp[i], dp[j] + (long long)v[j].size() - l);\n        }\n      }\n      res = max(res, dp[i] + (long long)v[i].size());\n    }\n    cout << res << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INF64 = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\ntypedef std::priority_queue<int, vector<int>, greater<int>> small_pq;\ntypedef std::priority_queue<int, vector<int>, less<int>> big_pq;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() {}\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  if (sizeof...(T) > 0) cerr << \" ,\";\n  dbg_out(T...);\n}\nvoid dbg_name(const string &s) {\n  string ss = s;\n  replace(ss.begin(), ss.end(), ',', ' ');\n  cerr << \"  ( \" << ss << \" )  \";\n}\ntemplate <typename T>\ninline void setmin(T &a, const T &b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\ninline void setmax(T &a, const T &b) {\n  if (b > a) a = b;\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nunordered_map<long long, int, custom_hash> safe_map;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::steady_clock::now().time_since_epoch().count());\nconst int MOD = 998244353;\nint mul(int x, int y) { return 1ll * x * y % MOD; }\nint add(int x, int y) { return ((x + y) % MOD + MOD) % MOD; }\nint sub(int x, int y) { return ((x - y) % MOD + MOD) % MOD; }\nint qpow(int a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = mul(ans, a);\n    a = mul(a, a);\n    b /= 2;\n  }\n  return ans;\n}\nconst int N = 1e4 + 5;\nnamespace Suffix {\nint sa[N], rk[N * 2], oldrk[N * 2], cnt[N * 2], id[N], px[N * 2];\nint ht[N];\nbool cmp(int x, int y, int w) {\n  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\nvoid suffix_array(char *s) {\n  memset(rk, 0, sizeof(rk));\n  int n = strlen(s + 1);\n  for (int i = 1; i <= n; i++) rk[i] = s[i];\n  int m = 150;\n  fill(cnt, cnt + m + 1, 0);\n  for (int i = 1; i <= n; i++) cnt[rk[i]]++;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    int p = 0;\n    for (int i = n; i > n - w; i--) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    fill(cnt, cnt + m + 1, 0);\n    for (int i = 1; i <= n; i++) cnt[px[i] = rk[id[i]]]++;\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[px[i]]--] = id[i];\n    copy(rk + 1, rk + 1 + 2 * n, oldrk + 1);\n    p = 0;\n    for (int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n    m = p;\n  }\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (k) k--;\n    while ((i + k <= n) && s[i + k] == s[sa[rk[i] - 1] + k]) k++;\n    ht[rk[i]] = k;\n  }\n}\n}  // namespace Suffix\nconst int M = 14;\nchar s[N];\nint dp[N];\nint f[N][M];\nint calc(int i, int j) {\n  int s = log2(j - i + 1);\n  return min(f[i][s], f[j - (1 << s) + 1][s]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  using namespace Suffix;\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d %s\", &n, s + 1);\n    Suffix::suffix_array(s);\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      f[i][0] = Suffix::ht[i];\n    }\n    for (int(i) = int(1); int(i) <= int(M - 1); i++) {\n      for (int(j) = int(1); int(j) <= int(n); j++) {\n        f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n    int ans = 0;\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      dp[i] = n - i + 1;\n      for (int(j) = int(1); int(j) <= int(i - 1); j++) {\n        if (Suffix::rk[i] > Suffix::rk[j])\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - calc(rk[j] + 1, rk[i]));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n    fill(dp + 1, dp + 1 + n, 0);\n    for (int(i) = int(0); int(i) <= int(M - 1); i++)\n      for (int(j) = int(1); int(j) <= int(n); j++) f[j][i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ch[20005][26], len[20005], fa[20005];\nbool tg[20005];\nint tot = 1;\nint las = 1;\nvoid insert(int x) {\n  int np = ++tot;\n  len[np] = len[las] + 1;\n  int p = las;\n  las = np;\n  for (; p && !ch[p][x]; p = fa[p]) ch[p][x] = np;\n  if (!p) {\n    fa[np] = 1;\n    return;\n  }\n  int q = ch[p][x];\n  if (len[q] == len[p] + 1) {\n    fa[np] = q;\n    return;\n  }\n  int nq = ++tot;\n  memcpy(ch[nq], ch[q], sizeof(ch[q]));\n  fa[nq] = fa[q];\n  len[nq] = len[p] + 1;\n  fa[q] = fa[np] = nq;\n  for (; p && ch[p][x] == q; p = fa[p]) ch[p][x] = nq;\n  return;\n}\nlong long ans = 0;\nint llen;\nint rk[5005], f[5005];\nint rkk;\nint val[5005];\nint n;\nbool ins[5005];\nvector<int> cur;\nvoid dfs(int x, int ll) {\n  if (llen && tg[x]) {\n    for (int i = llen + 1; i <= n + 1; i++)\n      if (rk[i]) f[llen] = max(f[llen], f[i] + llen - val[i]);\n    cur.push_back(llen);\n    rk[llen] = ++rkk, val[llen] = llen;\n  }\n  vector<int> tmp;\n  swap(tmp, cur);\n  for (int i = 0; i <= 25; i++) {\n    int to = ch[x][i];\n    if (!to) continue;\n    llen++;\n    dfs(to, ll + 1);\n    for (int i = 0; i < cur.size(); i++) tmp.push_back(cur[i]);\n    cur.clear();\n    llen--;\n  }\n  swap(tmp, cur);\n  for (int i = 0; i < cur.size(); i++) val[cur[i]]--;\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    cur.clear();\n    rkk = 0;\n    las = tot = 1;\n    int ans = 0;\n    scanf(\"%d\", &n);\n    string s;\n    cin >> s;\n    for (int i = 0; i < s.size(); i++) insert(s[i] - 'a');\n    for (int i = las; i; i = fa[i]) tg[i] = 1;\n    rk[n + 1] = 1;\n    f[n + 1] = 0;\n    dfs(1, 0);\n    for (int i = n; i >= 1; i--) {\n      ans = max(ans, f[i]);\n      f[i] = 0;\n      rk[i] = 0;\n      val[i] = 0;\n    }\n    printf(\"%d\\n\", ans);\n    for (int ii = 1; ii <= tot; ii++)\n      for (int i = 0; i <= 25; i++)\n        ch[ii][i] = 0, len[ii] = 0, fa[ii] = 0, tg[ii] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 4500000000000000000;\nlong long dx[4] = {-1, 1, 0, 0};\nlong long dy[4] = {0, 0, -1, 1};\nconst long long MOD = 998244353;\nvoid radixsort(vector<long long>& p, vector<long long>& c) {\n  long long n = p.size();\n  vector<long long> p_new(n), cnt(n + 1);\n  for (long long x : c) cnt[x + 1]++;\n  for (long long i = 1; i < n; ++i) cnt[i] += cnt[i - 1];\n  for (long long x : p) p_new[cnt[c[x]]++] = x;\n  p = p_new;\n}\nstruct segtree {\n  long long size;\n  vector<long long> nums;\n  void init(long long n) {\n    size = 1;\n    while (size < n) size *= 2;\n    nums.resize(size * 2);\n  }\n  void set(long long idx, long long val) {\n    for (nums[idx += size] = val; idx > 1; idx /= 2) {\n      nums[idx / 2] = min(nums[idx], nums[idx ^ 1]);\n    }\n  }\n  long long read(long long l, long long r) {\n    long long ret = INF;\n    for (l += size, r += size; l < r; l /= 2, r /= 2) {\n      if (l % 2) ret = min(ret, nums[l++]);\n      if (r % 2) ret = min(ret, nums[--r]);\n    }\n    return ret;\n  }\n};\nsigned main(void) {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    string s;\n    cin >> s;\n    s += \"$\";\n    n++;\n    vector<long long> p(n), c(n);\n    vector<pair<char, long long>> a(n);\n    for (long long i = 0; i < n; i++) {\n      a[i] = {s[i], i};\n    }\n    sort(a.begin(), a.end());\n    for (long long i = 0; i < n; i++) {\n      p[i] = a[i].second;\n    }\n    c[p[0]] = 0;\n    for (long long i = 1; i < n; i++) {\n      if (a[i].first == a[i - 1].first)\n        c[p[i]] = c[p[i - 1]];\n      else\n        c[p[i]] = c[p[i - 1]] + 1;\n    }\n    long long k = 0;\n    while ((1 << k) < n) {\n      for (long long i = 0; i < n; i++) {\n        p[i] = (p[i] - (1 << k) + n) % n;\n      }\n      radixsort(p, c);\n      vector<long long> newc(n);\n      newc[p[0]] = 0;\n      for (long long i = 1; i < n; i++) {\n        pair<long long, long long> prev = {c[p[i - 1]],\n                                           c[(p[i - 1] + (1 << k)) % n]};\n        pair<long long, long long> now = {c[p[i]], c[(p[i] + (1 << k)) % n]};\n        if (now == prev)\n          newc[p[i]] = newc[p[i - 1]];\n        else\n          newc[p[i]] = newc[p[i - 1]] + 1;\n      }\n      c = newc;\n      k++;\n    }\n    vector<long long> lcp(n);\n    k = 0;\n    for (long long i = 0; i < n - 1; i++) {\n      long long pi = c[i];\n      long long j = p[pi - 1];\n      while (s[i + k] == s[j + k]) {\n        k++;\n      }\n      lcp[pi] = k;\n      k = max(k - 1, 0ll);\n    }\n    segtree seg;\n    seg.init(n);\n    for (long long i = 1; i < n; i++) {\n      seg.set(i - 1, lcp[i]);\n    }\n    n--;\n    vector<long long> dp(n);\n    for (long long i = n - 1; i >= 0; i--) {\n      dp[i] = n - i;\n      for (long long j = i + 1; j < n; j++) {\n        if (s[j] == s[i]) {\n          if (c[i] < c[j]) {\n            dp[i] = max(dp[i], dp[j] + n - i - seg.read(c[i], c[j]));\n          }\n        }\n        if (s[j] > s[i]) dp[i] = max(n - i + dp[j], dp[i]);\n      }\n    }\n    long long ans = -1;\n    for (long long a : dp) ans = max(ans, a);\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5000 + 5;\nint q = 0, n = 0, dp[N] = {}, d[N] = {}, t[2 * N] = {};\nstring s = \"\";\nvector<string> v;\nvoid build() {\n  for (int x = n - 1; x; x--) t[x] = min(t[x << 1], t[x << 1 | 1]);\n}\nint query(int l, int r) {\n  int res = 1e9;\n  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n    if (l & 1) res = min(res, t[l++]);\n    if (r & 1) res = min(res, t[--r]);\n  }\n  return res;\n}\nbool cmp(string s1, string s2) {\n  for (int i = 0; i < min(s1.length(), s2.length()); i++)\n    if (s1[i] != s2[i]) return s1[i] < s2[i];\n  return s1.length() < s2.length();\n}\nvoid init() {\n  v.clear();\n  for (int i = 0; i < n; i++) v.push_back(s.substr(i, n - i));\n  sort(v.begin(), v.end(), cmp);\n  for (int i = 0; i < n; i++) d[n - v[i].length()] = i;\n  for (int i = 0; i < n - 1; i++) {\n    int x = v[i].length();\n    for (int j = 0; j < v[i].length(); j++)\n      if (v[i + 1][j] > v[i][j]) {\n        x = j;\n        break;\n      }\n    t[n + i] = x;\n  }\n  t[n + n - 1] = 1e9;\n  build();\n  for (int i = 0; i <= n; i++) dp[i] = n - i;\n}\nvoid solve() {\n  cin >> n >> s;\n  init();\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++) {\n      int x = query(d[i], d[j]);\n      dp[j] = max(dp[j], dp[i] + n - j - x);\n    }\n  int ans = 0;\n  for (int i = 0; i < n; i++) ans = max(ans, dp[i]);\n  cout << ans << endl;\n}\nint main() {\n  cin >> q;\n  for (int i = 0; i < q; i++) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int w = 0, flg = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') {\n      flg = -1;\n    }\n    ch = getchar();\n  }\n  while (ch <= '9' && ch >= '0') {\n    w = w * 10 + ch - '0', ch = getchar();\n  }\n  return w * flg;\n}\nint T;\nint n, m = 'z' + 10, num, sa[5010], c[5010], x[5010], y[5010], dp[5010],\n       del[5010][5010], id[5010];\nchar s[5010];\nvoid suffix_sort() {\n  for (int i = (1); i <= (n); i++) x[i] = s[i], c[x[i]]++;\n  for (int i = (2); i <= (m); i++) c[i] += c[i - 1];\n  for (int i = (n); i >= (1); i--) sa[c[x[i]]--] = i;\n  for (int k = 1; k <= n; k <<= 1) {\n    num = 0;\n    for (int i = (n - k + 1); i <= (n); i++) y[++num] = i;\n    for (int i = (1); i <= (n); i++)\n      if (sa[i] > k) y[++num] = sa[i] - k;\n    for (int i = (1); i <= (m); i++) c[i] = 0;\n    for (int i = (1); i <= (n); i++) c[x[i]]++;\n    for (int i = (2); i <= (m); i++) c[i] += c[i - 1];\n    for (int i = (n); i >= (1); i--) sa[c[x[y[i]]]--] = y[i];\n    for (int i = (1); i <= (n); i++) y[i] = x[i];\n    num = 1, x[sa[1]] = 1;\n    for (int i = (2); i <= (n); i++) {\n      if (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k])\n        x[sa[i]] = num;\n      else\n        x[sa[i]] = ++num;\n    }\n    if (num == n) break;\n    m = num;\n  }\n}\nint ans;\nvoid solve() {\n  n = read();\n  scanf(\"%s\", s + 1);\n  suffix_sort();\n  for (int i = (1); i <= (n); i++) id[sa[i]] = i;\n  for (int i = (n); i >= (1); i--)\n    for (int j = (n); j >= (1); j--)\n      if (s[i] == s[j]) del[i][j] = del[i + 1][j + 1] + 1;\n  for (int i = (1); i <= (n); i++) {\n    dp[i] = n - i + 1;\n    for (int j = (1); j <= (i - 1); j++) {\n      if (id[i] < id[j]) continue;\n      dp[i] = max(dp[i], dp[j] + n - i + 1 - del[i][j]);\n    }\n    ans = max(ans, dp[i]);\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = (0); i <= (5000); i++)\n    sa[i] = c[i] = x[i] = y[i] = dp[i] = id[i] = s[i] = 0;\n  for (int i = (0); i <= (n + 1); i++)\n    for (int j = (0); j <= (n + 1); j++) del[i][j] = 0;\n  num = 0, ans = 0, m = 'z' + 10;\n}\nint main() {\n  T = read();\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"-O3\")\nusing namespace std;\nconst long long mod = 998244353;\nstruct suff_array {\n  string s;\n  char extra;\n  int n;\n  int *p, *c, *lcp, *logs, *le, *ri, *par;\n  vector<vector<int>> st, invlcp;\n  vector<set<int>> se;\n  int tot;\n  int fin(int i) {\n    if (par[i] != i) {\n      par[i] = fin(par[i]);\n    }\n    return par[i];\n  }\n  suff_array() {}\n  suff_array(string _s, char _c) : s(_s), extra(_c) {\n    s += extra;\n    n = s.size();\n    p = c = lcp = logs = NULL;\n  }\n  void build(const string &_s, char &_c) {\n    s = _s;\n    s += _c;\n    n = s.size();\n    p = c = lcp = logs = le = ri = NULL;\n  }\n  void init() {\n    p = new int[n + 1];\n    c = new int[n + 1];\n    int cnt[256];\n    fill(cnt, cnt + 256, 0);\n    for (int i = 0; i < n; i++) {\n      cnt[s[i]]++;\n    }\n    for (int i = 1; i < 256; i++) {\n      cnt[i] += cnt[i - 1];\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      p[--cnt[s[i]]] = i;\n    }\n    int cr = 0;\n    int lst = s[p[0]];\n    c[p[0]] = 0;\n    for (int i = 1; i < n; i++) {\n      if (s[p[i]] > lst) {\n        cr++;\n        lst = s[p[i]];\n      }\n      c[p[i]] = cr;\n    }\n    tot = cr + 1;\n  }\n  void get_array() {\n    init();\n    int lgn = log2(n);\n    int *cnew;\n    cnew = new int[n + 1];\n    int *pn;\n    pn = new int[n + 1];\n    int *cnt;\n    cnt = new int[n + 1];\n    for (int k = 0; k <= lgn; k++) {\n      fill(cnt, cnt + tot, 0);\n      for (int i = 0; i < n; i++) {\n        pn[i] = p[i] - (1 << k);\n        if (pn[i] < 0) pn[i] += n;\n      }\n      for (int i = 0; i < n; i++) {\n        cnt[c[i]]++;\n      }\n      for (int i = 1; i < tot; i++) {\n        cnt[i] += cnt[i - 1];\n      }\n      for (int i = n - 1; i >= 0; i--) {\n        p[--cnt[c[pn[i]]]] = pn[i];\n      }\n      int cr = 0;\n      pair<int, int> lst = make_pair(c[p[0]], c[(p[0] + (1 << k)) % n]);\n      cnew[p[0]] = 0;\n      for (int i = 1; i < n; i++) {\n        pair<int, int> pr = make_pair(c[p[i]], c[(p[i] + (1 << k)) % n]);\n        if (pr > lst) {\n          cr++;\n          lst = pr;\n        }\n        cnew[p[i]] = cr;\n      }\n      tot = cr + 1;\n      swap(c, cnew);\n    }\n  }\n  void get_lcp() {\n    if (p == NULL) get_array();\n    lcp = new int[n];\n    int k = 0, a, b;\n    for (int i = 0; i < n - 1; i++) {\n      a = c[i];\n      b = c[i] - 1;\n      while (s[i + k] == s[p[b] + k]) {\n        k++;\n      }\n      lcp[b] = k;\n      if (k > 0) k--;\n    }\n    lcp[n - 1] = 0;\n  }\n  void get_invlcp() {\n    if (lcp == NULL) get_lcp();\n    invlcp.assign(n, vector<int>(0));\n    for (int i = n - 1; i >= 0; i--) {\n      invlcp[lcp[i]].push_back(i);\n    }\n  }\n  void ini_se() {\n    par = new int[n + 1];\n    iota(par, par + n + 1, 0);\n    if (p == NULL) get_array();\n    se.resize(n);\n    for (int i = 0; i < n; i++) {\n      se[i].insert(p[i]);\n    }\n  }\n  int join(int i) {\n    int j = i + 1;\n    i = fin(i);\n    j = fin(j);\n    if (se[i].size() > se[j].size()) swap(i, j);\n    par[i] = j;\n    int ans = 1e9;\n    for (auto &x : se[i]) {\n      auto it = se[j].lower_bound(x);\n      if (it != se[j].end()) ans = min(ans, (*it) - x);\n      if (it != se[j].begin()) {\n        it--;\n        ans = min(ans, x - (*it));\n      }\n    }\n    for (auto &x : se[i]) {\n      se[j].insert(x);\n    }\n    se[i].clear();\n    return ans;\n  }\n  void get_logs() {\n    logs = new int[n + 1];\n    fill(logs, logs + n + 1, 0);\n    for (int i = 2; i <= n; i++) {\n      logs[i] = logs[i / 2] + 1;\n    }\n  }\n  void get_st() {\n    if (lcp == NULL) get_lcp();\n    if (logs == NULL) get_logs();\n    st.assign(n, vector<int>(logs[n] + 1));\n    for (int i = 0; i < n - 1; i++) {\n      st[i][0] = lcp[i];\n    }\n    st[n - 1][0] = 0;\n    for (int j = 1; j <= logs[n]; j++) {\n      for (int i = 0; i + (1 << j) <= n; i++) {\n        st[i][j] = min(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);\n      }\n    }\n  }\n  int Lcp(int i, int j) {\n    if (i == j) return n - 1 - i;\n    int l = c[i], r = c[j];\n    if (l > r) swap(l, r);\n    r--;\n    int po = logs[r - l + 1];\n    int mn = min(st[l][po], st[r + 1 - (1 << po)][po]);\n    return mn;\n  }\n  bool comp(const pair<int, int> &i, const pair<int, int> &j) {\n    int z = Lcp(i.first - 1, j.first - 1), len1 = i.second - i.first + 1,\n        len2 = j.second - j.first + 1;\n    if (z >= min(len1, len2)) {\n      return (len1 < len2) || (len1 == len2 && i < j);\n    }\n    return s[i.first + z - 1] < s[j.first + z - 1];\n  }\n};\nint n;\nstring s;\nvoid solve() {\n  cin >> n >> s;\n  suff_array fo(s, '$');\n  fo.get_st();\n  vector<long long> dp(n, 0);\n  int z;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    dp[i] = n - i;\n    for (int j = 0; j < i; j++) {\n      if (fo.c[j] > fo.c[i]) continue;\n      z = fo.Lcp(i, j);\n      dp[i] = max(dp[i], dp[j] + n - z - i);\n    }\n    ans = max(ans, dp[i]);\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << ' ' << H;\n  dbg_out(T...);\n}\nusing ll = long long;\nusing ull = unsigned long long;\nmt19937 rng(\n    (unsigned int)chrono::steady_clock::now().time_since_epoch().count());\nconst int mod = 1e9 + 7;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 1e5 + 10;\nconst int maxbit = 20;\nstruct SuffixArray {\n  int sa[maxn], rank[maxn], ws[maxn], wv[maxn], wa[maxn], wb[maxn],\n      height[maxn], st[maxbit][maxn], N;\n  bool cmp(int *r, int a, int b, int l) {\n    return r[a] == r[b] and r[a + l] == r[b + l];\n  }\n  void build(int *r, int n, int m) {\n    N = n;\n    n++;\n    int i, j, k = 0, p, *x = wa, *y = wb, *t;\n    for (i = 0; i < m; i++) ws[i] = 0;\n    for (i = 0; i < n; i++) ws[x[i] = r[i]]++;\n    for (i = 1; i < m; i++) ws[i] += ws[i - 1];\n    for (i = n - 1; i >= 0; i--) sa[--ws[x[i]]] = i;\n    for (p = j = 1; p < n; j <<= 1, m = p) {\n      for (p = 0, i = n - j; i < n; i++) y[p++] = i;\n      for (i = 0; i < n; i++)\n        if (sa[i] >= j) y[p++] = sa[i] - j;\n      for (i = 0; i < n; i++) wv[i] = x[y[i]];\n      for (i = 0; i < m; i++) ws[i] = 0;\n      for (i = 0; i < n; i++) ws[wv[i]]++;\n      for (i = 1; i < m; i++) ws[i] += ws[i - 1];\n      for (i = n - 1; i >= 0; i--) sa[--ws[wv[i]]] = y[i];\n      for (t = x, x = y, y = t, p = 1, i = 1, x[sa[0]] = 0; i < n; i++)\n        x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n    }\n    for (i = 0; i < n; i++) rank[sa[i]] = i;\n    for (i = 0; i < n - 1; height[rank[i++]] = k)\n      for (k ? k-- : 0, j = sa[rank[i] - 1]; r[i + k] == r[j + k]; k++)\n        ;\n  }\n  void build_st() {\n    int i, k;\n    for (i = 1; i <= N; i++) st[0][i] = height[i];\n    for (k = 1; k <= maxbit; k++)\n      for (i = 1; i + (1 << k) - 1 <= N; i++)\n        st[k][i] = min(st[k - 1][i], st[k - 1][i + (1 << k - 1)]);\n  }\n  int lcp(int x, int y) {\n    int l = rank[x], r = rank[y];\n    if (l > r) swap(l, r);\n    if (l == r) return N - sa[l];\n    int t = log2(r - l);\n    return min(st[t][l + 1], st[t][r - (1 << t) + 1]);\n  }\n} SA;\nint t[maxn];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int _;\n  cin >> _;\n  while (_--) {\n    int n;\n    cin >> n;\n    for (int i = int(0); i <= (int)(n - 1); i++) {\n      char c;\n      cin >> c;\n      t[i] = c;\n    }\n    t[n] = 0;\n    SA.build(t, n, 200);\n    SA.build_st();\n    vector<int> dp(n + 1);\n    int ans = 0;\n    for (int i = int(1); i <= (int)(n); i++) {\n      dp[i] = n - i + 1;\n      for (int j = int(1); j <= (int)(i - 1); j++) {\n        if (SA.rank[j - 1] > SA.rank[i - 1]) continue;\n        dp[i] = max(dp[i], dp[j] + n - i + 1 - SA.lcp(i - 1, j - 1));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll maxn = 5e3 + 10;\nll dp[maxn];\nll lcp[maxn][maxn];\nll n;\nchar s[maxn];\nsigned main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  ll t;\n  cin >> t;\n  while (t--) {\n    memset(dp, 0, sizeof dp);\n    cin >> n >> (s + 1);\n    for (ll i = n; i >= 1; --i) {\n      for (ll j = n; j >= 1; --j) {\n        lcp[i][j] = (s[i] == s[j] ? 1 + lcp[i + 1][j + 1] : 0);\n      }\n    }\n    dp[1] = n;\n    ll res = n;\n    for (ll i = 2; i <= n; ++i) {\n      dp[i] = n - i + 1;\n      for (ll j = 1; j < i; ++j) {\n        if (i + lcp[i][j] > n || s[j + lcp[j][i]] > s[i + lcp[j][i]])\n          continue;\n        else\n          dp[i] = max(dp[i], dp[j] + (n - i + 1 - lcp[j][i]));\n      }\n      res = max(res, dp[i]);\n    }\n    cout << res << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INF64 = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\ntypedef std::priority_queue<int, vector<int>, greater<int>> small_pq;\ntypedef std::priority_queue<int, vector<int>, less<int>> big_pq;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() {}\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  if (sizeof...(T) > 0) cerr << \" ,\";\n  dbg_out(T...);\n}\nvoid dbg_name(const string &s) {\n  string ss = s;\n  replace(ss.begin(), ss.end(), ',', ' ');\n  cerr << \"  ( \" << ss << \" )  \";\n}\ntemplate <typename T>\ninline void setmin(T &a, const T &b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\ninline void setmax(T &a, const T &b) {\n  if (b > a) a = b;\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nunordered_map<long long, int, custom_hash> safe_map;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::steady_clock::now().time_since_epoch().count());\nconst int MOD = 998244353;\nint mul(int x, int y) { return 1ll * x * y % MOD; }\nint add(int x, int y) { return ((x + y) % MOD + MOD) % MOD; }\nint sub(int x, int y) { return ((x - y) % MOD + MOD) % MOD; }\nint qpow(int a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = mul(ans, a);\n    a = mul(a, a);\n    b /= 2;\n  }\n  return ans;\n}\nconst int N = 1e4 + 5;\nnamespace Suffix {\nint sa[N], rk[N * 2], oldrk[N * 2], cnt[N * 2], id[N], px[N * 2];\nint ht[N];\nbool cmp(int x, int y, int w) {\n  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\nvoid suffix_array(char *s) {\n  memset(cnt, 0, sizeof(cnt));\n  memset(rk, 0, sizeof(rk));\n  int n = strlen(s + 1);\n  for (int i = 1; i <= n; i++) rk[i] = s[i];\n  int m = 300;\n  for (int i = 1; i <= n; i++) cnt[rk[i]]++;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    int p = 0;\n    for (int i = n; i > n - w; i--) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 1; i <= n; i++) cnt[px[i] = rk[id[i]]]++;\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[px[i]]--] = id[i];\n    memcpy(oldrk, rk, sizeof(rk));\n    p = 0;\n    for (int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n    m = p;\n  }\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (k) k--;\n    while ((i + k <= n) && s[i + k] == s[sa[rk[i] - 1] + k]) k++;\n    ht[rk[i]] = k;\n  }\n}\n}  // namespace Suffix\nconst int M = 14;\nchar s[N];\nint dp[N];\nint f[N][M];\nint calc(int i, int j) {\n  int s = log2(j - i + 1);\n  return min(f[i][s], f[j - (1 << s) + 1][s]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  using namespace Suffix;\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d %s\", &n, s + 1);\n    Suffix::suffix_array(s);\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      f[i][0] = Suffix::ht[i];\n    }\n    for (int(i) = int(1); int(i) <= int(M - 1); i++) {\n      for (int(j) = int(1); int(j) <= int(n); j++) {\n        f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n    int ans = 0;\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      dp[i] = n - i + 1;\n      for (int(j) = int(1); int(j) <= int(i - 1); j++) {\n        if (Suffix::rk[i] > Suffix::rk[j])\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - calc(rk[j] + 1, rk[i]));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n    fill(dp + 1, dp + 1 + n, 0);\n    for (int(i) = int(0); int(i) <= int(M - 1); i++)\n      for (int(j) = int(1); int(j) <= int(n); j++) f[j][i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solution solver = new Solution();\n        boolean multipleTC = true;\n        int testCount = multipleTC ? Integer.parseInt(in.next()) : 1;\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(in, out, i);\n        out.close();\n\n    }\n\n    static class Solution {\n        PrintWriter out;\n        InputReader in;\n\n        //https://www.geeksforgeeks.org/suffix-array-set-2-a-nlognlogn-algorithm/\n\n        public static class Suffix implements Comparable<Suffix> {\n            int index;\n            int rank;\n            int next;\n            public Suffix(int ind, int r, int nr) {\n                index = ind;\n                rank = r;\n                next = nr;\n            }\n            public int compareTo(Suffix s)\n            {\n                if (rank != s.rank) return Integer.compare(rank, s.rank);\n                return Integer.compare(next, s.next);\n            }\n        }\n\n        public static int[] suffixArray(String s) {\n            int n = s.length();\n            Suffix[] su = new Suffix[n];\n            for (int i = 0; i < n; i++) {\n                su[i] = new Suffix(i, s.charAt(i) - '$', 0);\n            }\n            for (int i = 0; i < n; i++)\n                su[i].next = (i + 1 < n ? su[i + 1].rank : -1);\n\n            Arrays.sort(su);\n            int[] ind = new int[n];\n\n            for (int length = 4; length < 2 * n; length <<= 1) {\n\n                int rank = 0, prev = su[0].rank;\n                su[0].rank = rank;\n                ind[su[0].index] = 0;\n                for (int i = 1; i < n; i++)\n                {\n                    if (su[i].rank == prev &&\n                        su[i].next == su[i - 1].next)\n                    {\n                        prev = su[i].rank;\n                        su[i].rank = rank;\n                    }\n                    else\n                    {\n                        // Otherwise increment rank and assign\n                        prev = su[i].rank;\n                        su[i].rank = ++rank;\n                    }\n                    ind[su[i].index] = i;\n                }\n\n                // Assign next rank to every suffix\n                for (int i = 0; i < n; i++)\n                {\n                    int nextP = su[i].index + length / 2;\n                    su[i].next = nextP < n ?\n                        su[ind[nextP]].rank : -1;\n                }\n\n                // Sort the suffixes according\n                // to first k characters\n                Arrays.sort(su);\n            }\n\n            // Store indexes of all sorted\n            // suffixes in the suffix array\n            int[] suf = new int[n];\n\n            for (int i = 0; i < n; i++)\n                suf[i] = su[i].index;\n\n            // Return the suffix array\n            return suf;\n        }\n\n        public void solve(InputReader in, PrintWriter out, int test) {\n            this.out = out;\n            this.in = in;\n\n            int n = ni();\n            String s = n();\n\n            int[] suff_arr = suffixArray(s);\n\n            Pair[] suffixes = new Pair[n];\n            for(int i = 0; i < n; i++)\n                suffixes[i] = new Pair(\"\", suff_arr[i]);\n            int[] lcp = new int[n];\n            for(int i = 0; i < n - 1; i++) {\n                int ptr1 = suffixes[i].ind, ptr2 = suffixes[i + 1].ind;\n                while(ptr1 < n && ptr2 < n && s.charAt(ptr1) == s.charAt(ptr2)) {\n                    ptr1++;\n                    ptr2++;\n                }\n                lcp[i] = ptr1 - suffixes[i].ind;\n            }\n\n            int[][] mat = new int[n][n];\n            int[] ptr = new int[n];\n            int done = 0;\n            for(int i = 0; i < n; i++) {\n                for(int k = ptr[i]; k < n - suffixes[i].ind; k++) {\n                    int currLengthPrefix = k + 1;\n                    int j = i;\n                    mat[suffixes[i].ind][suffixes[i].ind + k] = done;\n                    while (j < n - 1 && lcp[j] >= currLengthPrefix) {\n                        j++;\n                        mat[suffixes[j].ind][suffixes[j].ind + k] = done;\n                        ptr[j]++;\n                    }\n                    done++;\n                }\n            }\n\n            int[] tail = new int[(n * (n + 1)) >> 1];\n            int length = 1; // always points empty slot in tail\n            tail[0] = mat[0][0];\n            for(int i = 0; i < n; i++) {\n                for(int j = i; j < n; j++) {\n                    if (mat[i][j] > tail[length - 1]) {\n                        tail[length++] = mat[i][j];\n                    }\n                    else {\n                        int idx = Arrays.binarySearch(\n                            tail, 0, length - 1, mat[i][j]);\n                        if (idx < 0)\n                            idx = -1 * idx - 1;\n                        tail[idx] = mat[i][j];\n                    }\n                }\n            }\n            pn(length);\n        }\n\n        final static Comparator<Pair> com = (o1, o2) -> {\n            if(!o1.equals(o2))\n                return o1.s.compareTo(o2.s);\n            return Integer.compare(o1.ind, o2.ind);\n        };\n\n\n        String n() {\n            return in.next();\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n        void pn(String sz) {\n            out.println(sz);\n        }\n\n        void pn(double dx) {\n            out.println(dx);\n        }\n\n        class Pair {\n            String s;\n            int ind;\n            Pair(String s, int ind) {\n                this.s = s;\n                this.ind = ind;\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint t, n, ans, lcp[5009][5009], dp[5009];\nchar a[5009];\nint main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    scanf(\"%s\", a + 1);\n    ans = 0;\n    for (int i = n; i >= 1; i--)\n      for (int j = n; j >= 1; j--)\n        lcp[i][j] = (a[i] == a[j]) ? (lcp[i + 1][j + 1] + 1) : 0;\n    for (int i = 1; i <= n; i++) {\n      dp[i] = n + 1 - i;\n      for (int j = 1; j < i; j++) {\n        int len = lcp[i][j];\n        if (a[j + len] < a[i + len])\n          dp[i] = max(dp[i], dp[j] + n + 1 - (i + len));\n      }\n      ans = max(ans, dp[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k, t, n, m, it, siz[5050], cur, res, it2;\nchar s0[5050];\nstring sb[5050];\nstruct trie {\n  int mp[30];\n  int f1, f2, len, fa;\n} s[10050];\nvoid build(int id, int dep, int l, int r) {\n  if (l == r) {\n    s[id].len += (siz[l] - dep + 2);\n    return;\n  }\n  int x[30], i, y[30], j, k = 0;\n  memset(x, 1, sizeof(x));\n  memset(y, 0, sizeof(y));\n  s[id].len++;\n  memset(s[id].mp, 0, sizeof(s[id].mp));\n  for (j = l; j <= r; j++) {\n    if (siz[j] >= dep) {\n      x[sb[j][dep] - 'a' + 1] = min(x[sb[j][dep] - 'a' + 1], j);\n      y[sb[j][dep] - 'a' + 1] = max(y[sb[j][dep] - 'a' + 1], j);\n    }\n  }\n  for (i = 1; i <= 26; i++) {\n    k += (y[i] > 0);\n  }\n  if ((dep == 1) || k > 1) {\n    for (i = 1; i <= 26; i++) {\n      if (y[i]) {\n        s[id].mp[i] = ++it;\n        s[it].fa = id;\n        build(it, dep + 1, x[i], y[i]);\n      }\n    }\n    return;\n  }\n  if (k == 1) {\n    for (i = 1; i <= 26; i++) {\n      if (y[i]) {\n        build(id, dep + 1, x[i], y[i]);\n        return;\n      }\n    }\n  }\n}\nvoid dfs(int cur, int dep, int ans) {\n  int i, j, k, f = s[cur].fa, nmsl = dep + s[cur].len;\n  for (i = 1; i < s0[dep]; i++) {\n    if (s[f].mp[i]) {\n      ans = max(ans, s[s[f].mp[i]].f2);\n    }\n  }\n  ans += min(s[cur].len, n - dep + 1);\n  ans = max(ans, s[cur].f1);\n  s[cur].f1 = ans;\n  s[cur].f2 = max(s[cur].f2, ans);\n  if (nmsl <= n) {\n    dfs(s[cur].mp[s0[nmsl]], nmsl, ans);\n    s[cur].f2 = max(s[cur].f2, s[s[cur].mp[s0[nmsl]]].f2);\n  }\n  res = max(res, ans);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> t;\n  while (t--) {\n    it = 0;\n    s[0].f1 = s[0].f2 = 0;\n    res = 0;\n    cin >> n >> s0 + 1;\n    if (n == 1) {\n      cout << 1 << '\\n';\n      continue;\n    }\n    for (i = 1; i <= n; i++) {\n      sb[i].clear();\n      sb[i] += \"0\";\n      for (j = i; j <= n; j++) {\n        sb[i] += s0[j];\n      }\n    }\n    sort(sb + 1, sb + n + 1);\n    for (i = 1; i <= n; i++) {\n      siz[i] = sb[i].size() - 1;\n    }\n    build(0, 1, 1, n);\n    for (i = 1; i <= n; i++) {\n      s0[i] -= 'a' - 1;\n    }\n    for (i = 1; i <= n; i++) {\n      it2 = i;\n      dfs(s[0].mp[s0[i]], i, 0);\n    }\n    cout << res << '\\n';\n    memset(s, 0, sizeof(s[0]) * it + 500);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5000 + 100;\nconst long double pi = acos(-1.0);\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while ((ch < '0') || (ch > '9')) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while ((ch >= '0') && (ch <= '9')) {\n    x = x * 10 + (ch - '0');\n    ch = getchar();\n  }\n  return x * f;\n}\ninline long long readll() {\n  long long x = 0;\n  int f = 1;\n  char ch = getchar();\n  while ((ch < '0') || (ch > '9')) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while ((ch >= '0') && (ch <= '9')) {\n    x = x * 10 + (ch - '0');\n    ch = getchar();\n  }\n  return x * f;\n}\nint n, f[N], lcp[N][N], a[N], pos[N];\nchar s[N];\nint main() {\n  int T = read();\n  while (T--) {\n    n = read();\n    scanf(\"%s\", s + 1);\n    for (register int i = 1; i <= n; i++)\n      for (register int j = 1; j <= n; j++) lcp[i][j] = 0;\n    for (register int i = n - 1; i >= 1; i--) {\n      lcp[i][n] = (s[i] == s[n]);\n      for (register int j = n - 1; j >= i + 1; j--) {\n        if (s[i] == s[j]) lcp[i][j] = lcp[i + 1][j + 1] + 1;\n      }\n    }\n    for (register int i = 1; i <= n; i++) a[i] = n - i + 1;\n    f[0] = 0;\n    for (register int i = 1; i <= n; i++) {\n      f[i] = n - i + 1;\n      for (register int j = 1; j <= i - 1; j++) {\n        int l = lcp[j][i];\n        if (i + l > n) continue;\n        if (s[i + l] > s[j + l]) f[i] = max(f[i], f[j] + a[i] - l);\n      }\n    }\n    int ans = 0;\n    for (register int i = 1; i <= n; i++) ans = max(ans, f[i]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\n/*\n1\n5\nacbac\n\n1\n3\nabc\n\n1\n10\nabacabadac\n1\n8\nacabacba\n */\npublic class E2 {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs=new FastScanner();\n\t\tint T=fs.nextInt();\n\t\tfor (int tt=0; tt<T; tt++) {\n\t\t\tint n=fs.nextInt();\n\t\t\tchar[] line=(fs.next()).toCharArray();\n\t\t\tint[][] valueOfSubstring=new int[n][n];\n\t\t\tfor (int i=0; i<n; i++)\n\t\t\t\t Arrays.fill(valueOfSubstring[i], -1);\n\t\t\tint curInd=0;\n\t\t\tint[] sa=suffixArray(line);\n\t\t\tint[] indexOf=new int[n];\n\t\t\tfor (int i=0; i<n; i++) indexOf[sa[i]]=i;\n\t\t\tint[] lcp=lcp(sa, line);\n\t\t\tint[] stk=new int[n+1];\n\t\t\tArrays.fill(stk, -2);\n\n\t\t\tint[][] lcp2=new int[n][n];\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tint ans=n-sa[i];\n\t\t\t\tlcp2[sa[i]][sa[i]]=ans;\n\t\t\t\tfor (int j=i+1; j<n; j++) {\n\t\t\t\t\tans=Math.min(ans, lcp[j-1]);\n\t\t\t\t\tlcp2[sa[i]][sa[j]]=ans;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tint[] dp=new int[n];//if we build off the prefix starting here\n\t\t\tfor (int start=n-1; start>=0; start--) {\n\t\t\t\t//build off any later prefix, but only if it's also after us in the SA\n\t\t\t\tint maxTransition=n-start;\n\t\t\t\tfor (int to=start+1; to<n; to++) {\n\t\t\t\t\tif (indexOf[to]>indexOf[start]) {\n\t\t\t\t\t\tint lcpToLose=lcp2[start][to];\n\t\t\t\t\t\tint getFromMe=n-start;\n\t\t\t\t\t\tint getFromHim=dp[to];\n//\t\t\t\t\t\tSystem.out.println(\"Considering \"+start+\" \"+to+\" with \"+lcpToLose+\" \"+getFromMe+\" \"+getFromHim);\n\t\t\t\t\t\tmaxTransition=Math.max(maxTransition, getFromMe+getFromHim-lcpToLose);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[start]=maxTransition;//TODO;\n\t\t\t\tans=Math.max(ans, dp[start]);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n//\tstatic int lis(int[] a) {\n//\t\tint n=a.length;\n//\t\tTreeMap<Integer, Integer> map=new TreeMap<>();\n//\t\tint ans=0;\n//\t\tfor (int i:a) {\n//\t\t\tMap.Entry<Integer, Integer> buildOff = map.lowerEntry(i);\n//\t\t\tint fromVal=buildOff==null?0:buildOff.getValue();\n//\t\t\tint myVal=fromVal+1;\n//\t\t\twhile (true) {\n//\t\t\t\tMap.Entry<Integer, Integer> bigger= map.ceilingEntry(i);\n//\t\t\t\tif (bigger!=null && bigger.getValue()<=myVal) map.remove(bigger.getKey());\n//\t\t\t\telse break;\n//\t\t\t}\n//\t\t\tmap.put(i, myVal);\n//\t\t\tans=Math.max(ans, myVal);\n//\t\t}\n//\t\treturn ans;\n//\t}\n\t\n\t// sort suffixes of S in O(n*log(n))\n\tstatic int[] suffixArray(char[] S) {\n\t\tint n=S.length;\n\t\tInteger[] order=new Integer[n];\n\t\tfor (int i=0; i<n; i++)\n\t\t\torder[i]=n-1-i;\n\n\t\t// stable sort of characters //%\n\t\tArrays.sort(order, (a, b)->Character.compare(S[a], S[b]));\n\n\t\tint[] sa=new int[n];\n\t\tint[] classes=new int[n];\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tsa[i]=order[i];\n\t\t\tclasses[i]=S[i];\n\t\t}\n\t\t// sa[i] - suffix on i'th position after sorting by first len characters //%\n\t\t// classes[i] - equivalence class of the i'th suffix after sorting by first len\n\t\t// characters //%\n\n\t\tfor (int len=1; len<n; len*=2) {\n\t\t\tint[] c=classes.clone();\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\t// condition sa[i - 1] + len < n simulates 0-symbol at the end of the string //%\n\t\t\t\t// a separate class is created for each suffix followed by simulated 0-symbol\n\t\t\t\t// //%\n\t\t\t\tclasses[sa[i]]=i>0&&c[sa[i-1]]==c[sa[i]]&&sa[i-1]+len<n&&c[sa[i-1]+len/2]==c[sa[i]+len/2]\n\t\t\t\t\t\t?classes[sa[i-1]]\n\t\t\t\t\t\t:i;\n\t\t\t}\n\t\t\t// Suffixes are already sorted by first len characters //%\n\t\t\t// Now sort suffixes by first len * 2 characters //%\n\t\t\tint[] cnt=new int[n];\n\t\t\tfor (int i=0; i<n; i++)\n\t\t\t\tcnt[i]=i;\n\t\t\tint[] s=sa.clone();\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\t// s[i] - order of suffixes sorted by first len characters //%\n\t\t\t\t// (s[i] - len) - order of suffixes sorted only by second len characters //%\n\t\t\t\tint s1=s[i]-len;\n\t\t\t\t// sort only suffixes of length > len, others are already sorted //%\n\t\t\t\tif (s1>=0)\n\t\t\t\t\tsa[cnt[classes[s1]]++]=s1;\n\t\t\t}\n\t\t}\n\t\treturn sa;\n\t}\n\n\t// longest common prefixes array in O(n)\n\tstatic int[] lcp(int[] sa, char[] s) {\n\t\tint n=sa.length;\n\t\tint[] rank=new int[n];\n\t\tfor (int i=0; i<n; i++)\n\t\t\trank[sa[i]]=i;\n\t\tint[] lcp=new int[n-1];\n\t\tfor (int i=0, h=0; i<n; i++) {\n\t\t\tif (rank[i]<n-1) {\n\t\t\t\tfor (int j=sa[rank[i]+1]; Math.max(i, j)+h<s.length&&s[i+h]==s[j+h]; ++h)\n\t\t\t\t\t;\n\t\t\t\tlcp[rank[i]]=h;\n\t\t\t\tif (h>0)\n\t\t\t\t\t--h;\n\t\t\t}\n\t\t}\n\t\treturn lcp;\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\n\t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e3 + 10;\nconst double PI = acos(-1.0);\nint lcp[N][N];\nchar s[N];\nint dp[N];\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  int n;\n  scanf(\"%d%s\", &n, s + 1);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      lcp[i][j] = 0;\n    }\n  }\n  for (int i = n; i >= 1; i--) {\n    for (int j = i - 1; j >= 1; j--) {\n      if (s[i] != s[j])\n        lcp[i][j] = 0;\n      else\n        lcp[i][j] = lcp[i + 1][j + 1] + (s[i] == s[j]);\n    }\n  }\n  int res = 0;\n  for (int i = 1; i <= n; i++) {\n    dp[i] = n - i + 1;\n    for (int j = 1; j < i; j++) {\n      int len = lcp[i][j];\n      if (s[i + len] > s[j + len]) {\n        dp[i] = max(dp[i], dp[j] + n - (i + len) + 1);\n      }\n    }\n    res = max(res, dp[i]);\n  }\n  printf(\"%d\\n\", res);\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\ndef SA_IS(a):\n    a += [0]\n    k = max(a) + 1\n    n = len(a)\n    \n    def induce_l(sa, a, n, k, stype):\n        bucket = get_buckets(a, k, 1)\n        for i in range(n):\n            j = sa[i] - 1\n            if j >= 0 and (not stype[j]):\n                sa[bucket[a[j]]] = j\n                bucket[a[j]] += 1\n    \n    def induce_s(sa, a, n, k, stype):\n        bucket = get_buckets(a, k, 0)\n        for i in range(n)[::-1]:\n            j = sa[i] - 1\n            if j >= 0 and stype[j]:\n                bucket[a[j]] -= 1\n                sa[bucket[a[j]]] = j\n    \n    def get_buckets(a, k, start = 0):\n        bucket = [0] * k\n        for item in a:\n            bucket[item] += 1\n        s = 0\n        for i in range(k):\n            s += bucket[i]\n            bucket[i] = s - (bucket[i] if start else 0)\n        return bucket\n    \n    def set_lms(a, n, k, default_order):\n        bucket = get_buckets(a, k)\n        sa = [-1] * n\n        for i in default_order[::-1]:\n            bucket[a[i]] -= 1\n            sa[bucket[a[i]]] = i\n        return sa\n    \n    def induce(a, n, k, stype, default_order):\n        sa = set_lms(a, n, k, default_order)\n        induce_l(sa, a, n, k, stype)\n        induce_s(sa, a, n, k, stype)\n        return sa\n    \n    def rename_LMS_substring(sa, a, n, stype, LMS, l):\n        sa = [_s for _s in sa if LMS[_s]]\n        tmp = [-1] * (n//2) + [0]\n        dupl = 0\n        for _ in range(1, l):\n            i, j = sa[_-1], sa[_]\n            for ii in range(n):\n                if a[i+ii] != a[j+ii] or stype[i+ii] != stype[j+ii]:\n                    break\n                if ii and (LMS[i+ii] or LMS[j+ii]):\n                    dupl += 1\n                    break\n            tmp[j//2] = _ - dupl\n        tmp = [t for t in tmp if t >= 0]\n        return tmp, dupl\n    \n    def calc(a, n, k):\n        stype = [1] * n\n        for i in range(n-1)[::-1]:\n            if a[i] > a[i+1] or (a[i] == a[i+1] and stype[i+1] == 0):\n                stype[i] = 0\n        \n        LMS = [1 if stype[i] and not stype[i-1] else 0 for i in range(n-1)] + [1]\n        l = sum(LMS)\n        lms = [i for i in range(n) if LMS[i]]\n        sa = induce(a, n, k, stype, lms)\n        renamed_LMS, dupl = rename_LMS_substring(sa, a, n, stype, LMS, l)\n        \n        if dupl:\n            sub_sa = calc(renamed_LMS, l, l - dupl)\n        else:\n            sub_sa = [0] * l\n            for i in range(l):\n                sub_sa[renamed_LMS[i]] = i\n        \n        lms = [lms[sub_sa[i]] for i in range(l)]\n        sa = induce(a, n, k, stype, lms)\n        return sa\n    \n    sa = calc(a, n, k)\n    return sa\n\n# Longest Common Prefix\n# (\u6587\u5b57\u5217s, \u6587\u5b57\u5217\u9577n, Suffix Array)\u3092\u5f15\u6570\u3068\u3057\u3066\u4e0e\u3048\u308b\ndef LCP(s, n, sa):\n    lcp = [-1]*(n+1)\n    rank = [0]*(n+1)\n    for i in range(n+1): rank[sa[i]] = i\n\n    h = 0\n    lcp[0] = 0\n    for i in range(n):\n        j = sa[rank[i] - 1]\n        if h > 0: h -= 1\n        while j+h < n and i+h < n and s[j+h]==s[i+h]:\n            h += 1\n        lcp[rank[i] - 1] = h\n    return lcp\n    \ndef main():\n    n = int(input())\n    S = [ord(a) - 96 for a in input().strip()]\n    SA = SA_IS(S)\n    lcp = LCP(S, n, SA)\n    dp = [0] * n\n    for i in range(1, n + 1):\n        pos = SA[i]\n        plus = n - pos\n        min_ = 10 ** 10\n        for j in range(i - 1, 0, -1):\n            p2 = SA[j]\n            min_ = min(min_, lcp[j])\n            if p2 < pos:\n                dp[pos] = max(dp[pos], dp[p2] - min_)\n        dp[pos] += plus\n    print(max(dp))\n    \n    \nfor _ in range(int(input())):\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5005;\nint c[N][N], f[N];\nchar a[N];\nvoid solve() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n  for (int i = 1; i <= n + 1; ++i)\n    for (int j = 1; j <= n + 1; ++j) c[i][j] = 0;\n  for (int i = n; i >= 1; --i)\n    for (int j = n; j >= 1; --j)\n      if (a[i] == a[j]) c[i][j] = c[i + 1][j + 1] + 1;\n  for (int i = 1; i <= n; ++i) {\n    f[i] = 0;\n    for (int j = 1; j < i; ++j)\n      if (a[j + c[i][j]] < a[i + c[i][j]]) f[i] = max(f[i], f[j] - c[i][j]);\n    f[i] += n - i + 1;\n  }\n  cout << *max_element(f + 1, f + n + 1) << \"\\n\";\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T = 1;\n  cin >> T;\n  while (T--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid chkMax(T &x, T y) {\n  if (y > x) x = y;\n}\ntemplate <typename T>\nvoid chkMin(T &x, T y) {\n  if (y < x) x = y;\n}\ntemplate <typename T>\nvoid inline read(T &x) {\n  int f = 1;\n  x = 0;\n  char s = getchar();\n  while (s < '0' || s > '9') {\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while (s <= '9' && s >= '0') x = x * 10 + (s ^ 48), s = getchar();\n  x *= f;\n}\nconst int N = 5005;\nint n, f[N][N], t, g[N];\nchar s[N];\nstruct E {\n  int l, r;\n};\nbool operator<(const E &a, const E &b) {\n  int t = f[a.l][b.l];\n  int l1 = a.r - a.l + 1, l2 = b.r - b.l + 1;\n  if (t + 1 <= min(l1, l2)) {\n    return s[a.l + t] < s[b.l + t];\n  } else {\n    return l1 < l2;\n  }\n}\nbool operator==(const E &a, const E &b) {\n  int l1 = a.r - a.l + 1, l2 = b.r - b.l + 1;\n  if (l1 != l2) return 0;\n  return f[a.l][b.l] >= l1;\n}\nint main() {\n  int T;\n  read(T);\n  while (T--) {\n    read(n);\n    t = 0;\n    scanf(\"%s\", s + 1);\n    for (int i = n; i; i--) {\n      for (int j = n; j; j--) {\n        if (s[i] == s[j]) f[i][j] = f[i + 1][j + 1] + 1;\n      }\n    }\n    int ans = 0;\n    for (int i = n; i; i--) {\n      g[i] = 0;\n      E u = (E){i, n};\n      for (int j = i + 1; j <= n; j++) {\n        E v = (E){j, n};\n        if (u < v) {\n          int t = f[i][j];\n          chkMax(g[i], g[j] + n - j + 1 - t);\n        }\n      }\n      chkMax(ans, g[i] + n - i + 1);\n    }\n    printf(\"%d\\n\", ans);\n    for (int i = 1; i <= n; i++)\n      for (int j = 1; j <= n; j++) f[i][j] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5e3 + 5;\nconst int MAXM = MAXN * MAXN;\nstruct BIT {\n  int tree[MAXM], n;\n  inline void clear(int _n) {\n    n = _n;\n    memset(tree, 0, (n + 1) << 2);\n  }\n  inline void update(int x, int k) {\n    while (x <= n) tree[x] = max(tree[x], k), x += ((x) & -(x));\n  }\n  inline int query(int x) {\n    int res = 0;\n    while (x) res = max(res, tree[x]), x ^= ((x) & -(x));\n    return res;\n  }\n} tree;\nchar s[MAXN];\nint lcp[MAXN][MAXN];\ninline bool cmp(const pair<int, int> &p, const pair<int, int> &q) {\n  int len = lcp[p.first][q.first];\n  int x = p.first + len;\n  int y = q.first + len;\n  if (x <= p.second && y <= q.second) return s[x] < s[y];\n  return p.second - p.first < q.second - q.first;\n}\nint dp[MAXN];\nvoid solve(void) {\n  int n;\n  scanf(\"%d%s\", &n, s + 1);\n  for (int i = n + 1; i >= 1; --i)\n    for (int j = n + 1; j >= 1; --j) {\n      if (i > n || j > n) {\n        lcp[i][j] = 0;\n        continue;\n      }\n      if (s[i] == s[j])\n        lcp[i][j] = lcp[i + 1][j + 1] + 1;\n      else\n        lcp[i][j] = 0;\n    }\n  dp[0] = 0;\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    dp[i] = n - i + 1;\n    for (int j = 1; j < i; ++j) {\n      int len = lcp[i][j];\n      if (s[i + len] > s[j + len])\n        dp[i] = max(dp[i], dp[j] + n - (i + len) + 1);\n    }\n    ans = max(ans, dp[i]);\n  }\n  printf(\"%d\\n\", ans);\n}\nint main(void) {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e3 + 10;\nint dp1[N][N], dp2[N];\nvoid solve() {\n  int n, ans = 0;\n  cin >> n;\n  string a;\n  cin >> a;\n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = n - 1; j >= 0; j--) {\n      dp1[i][j] = 0;\n      if (a[i] == a[j]) dp1[i][j] = dp1[i + 1][j + 1] + 1;\n    }\n  }\n  dp2[0] = n;\n  ans = n;\n  for (int i = 1; i < n; i++) {\n    dp2[i] = n - i;\n    for (int j = 0; j < i; j++) {\n      if (a[i] > a[j])\n        dp2[i] = max(dp2[i], dp2[j] + (n - i));\n      else if (a[i] == a[j])\n        if (i + dp1[i][j] < n)\n          if (a[i + dp1[i][j]] > a[j + dp1[i][j]])\n            dp2[i] = max(dp2[i], (dp2[j]) + ((n - i) - (dp1[i][j])));\n    }\n    ans = max(dp2[i], ans);\n  }\n  cout << ans << \"\\n\";\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  unsigned long long test_case;\n  cin >> test_case;\n  while (test_case--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nbool chkmax(T &x, T y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <typename T>\nbool chkmin(T &x, T y) {\n  return x > y ? x = y, true : false;\n}\nconst double PI = 3.14159265358979323846;\nconst double eps = 1e-10;\nconst long long N = 5010;\nlong long n, a[N], f[N], lcp[N][N];\nchar s[N];\nlong long dfs(long long i, long long j) {\n  if (i == j) return lcp[i][j] = n - i + 1;\n  if (i == n || j == n) return lcp[i][j] = s[i] == s[j];\n  if (lcp[i][j] != -1) return lcp[i][j];\n  if (s[i] == s[j])\n    return lcp[i][j] = dfs(i + 1, j + 1) + 1;\n  else\n    return lcp[i][j] = 0;\n}\nvoid solve() {\n  cin >> n >> s + 1;\n  for (decay<decltype(n + 2)>::type i = (0), _i = (n + 2); i < _i; ++i) {\n    for (decay<decltype(n + 2)>::type j = (0), _j = (n + 2); j < _j; ++j) {\n      lcp[i][j] = -1;\n    }\n  }\n  long long ans = n;\n  for (decay<decltype(n + 1)>::type i = (1), _i = (n + 1); i < _i; ++i) {\n    a[i] = n - i + 1;\n  }\n  f[1] = n;\n  for (long long i = 2; i <= n; i++) {\n    f[i] = a[i];\n    for (long long j = 1; j < i; j++) {\n      if (s[j] < s[i])\n        chkmax(f[i], f[j] + a[i]);\n      else if (s[i] == s[j]) {\n        long long len = dfs(i, j);\n        if (s[j + len] < s[i + len]) {\n          chkmax(f[i], f[j] + a[i] - len);\n        }\n      }\n    }\n    chkmax(ans, f[i]);\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class CF1562E extends PrintWriter {\n\tCF1562E() { super(System.out); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1562E o = new CF1562E(); o.main(); o.flush();\n\t}\n\n\tvoid main() {\n\t\tint t = sc.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tbyte[] cc = (sc.next() + \" \").getBytes();\n\t\t\tcc[n] = 0;\n\t\t\tint[][] pp = new int[n + 1][n + 1];\n\t\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t\tif (cc[i] == cc[j])\n\t\t\t\t\t\tpp[i][j] = pp[i + 1][j + 1] + 1;\n\t\t\tint[][] dp = new int[n][n + 1];\n\t\t\tint ans = 0;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tint p = pp[i][j];\n\t\t\t\t\tif (cc[i + p] < cc[j + p])\n\t\t\t\t\t\tdp[i][p] = Math.max(dp[i][p], n - i - p + dp[j][p]);\n\t\t\t\t}\n\t\t\t\tfor (int p = 1; i + p < n; p++)\n\t\t\t\t\tdp[i][p] = Math.max(dp[i][p], dp[i][p - 1] - 1);\n\t\t\t\tfor (int p = n - i - 1; p >= 0; p--)\n\t\t\t\t\tdp[i][p] = Math.max(dp[i][p], dp[i][p + 1] + 1);\n\t\t\t\tans = Math.max(ans, dp[i][0]);\n\t\t\t}\n\t\t\tprintln(ans);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int MOD = 998244353;\nconstexpr double EPS = 1e-8;\nlong long int N, M, K, T, H, W, L, R;\nclass SuffixArray {\n  string s;\n  vector<int> nx;\n  int length = 1;\n  int n;\n\n public:\n  vector<int> ret;\n  vector<int> id;\n  vector<int> lcp;\n  SuffixArray(string ss) {\n    s = ss;\n    n = s.size();\n    id.resize(n);\n    nx.resize(n);\n    ret.resize(n);\n    lcp.resize(n);\n    for (int i = 0; i < n; i++) {\n      ret[i] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      id[i] = s[i];\n    }\n    while (length < n) {\n      auto comp = [&](int a, int b) {\n        if (id[a] != id[b]) return id[a] < id[b];\n        int l = -1, r = -1;\n        if (a + length < n) l = id[a + length];\n        if (b + length < n) r = id[b + length];\n        return l < r;\n      };\n      sort(ret.begin(), ret.end(), comp);\n      nx[ret[0]] = 0;\n      for (int i = 1; i < n; i++) {\n        nx[ret[i]] = nx[ret[i - 1]] + comp(ret[i - 1], ret[i]);\n      }\n      id = nx;\n      length <<= 1;\n    }\n    for (int i = 0; i < n; i++) {\n      int nx = id[i];\n      if (nx + 1 == n) continue;\n      nx = ret[nx + 1];\n      int idx = i;\n      if (i && lcp[id[i - 1]]) {\n        lcp[id[i]] = lcp[id[i - 1]] - 1;\n        nx += lcp[id[i]];\n        idx += lcp[id[i]];\n      }\n      while (nx < n && i < n && s[idx] == s[nx]) {\n        lcp[id[i]]++;\n        nx++;\n        idx++;\n      }\n    }\n  }\n};\nvoid Solve() {\n  cin >> N;\n  string s;\n  cin >> s;\n  if (N == 1) {\n    cout << 1 << endl;\n    return;\n  }\n  SuffixArray sa(s);\n  vector<vector<int>> box(N + 1, vector<int>(N + 1, -1));\n  vector<int> dp(N + 1);\n  for (int i = 0; i < N - 1; i++) {\n    int mx = N - sa.ret[i];\n    for (int j = i + 1; j < N; j++) {\n      mx = min(mx, sa.lcp[j - 1]);\n      box[sa.ret[j]][sa.ret[i]] = mx;\n    }\n  }\n  dp[0] = N;\n  for (int i = 1; i < N; i++) {\n    dp[i] = N - i;\n    for (int j = 0; j < i; j++) {\n      if (box[i][j] == -1) continue;\n      dp[i] = max(dp[i], dp[j] + (int)N - i - box[i][j]);\n    }\n  }\n  cout << *max_element(dp.begin(), dp.end()) << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> T;\n  while (T--) {\n    Solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5010;\nint t, n, ans;\nint f[N], g[N][N];\nchar str[N];\nint main() {\n  scanf(\"%d\", &t);\n  for (int i = 1; i <= t; i++) {\n    scanf(\"%d\", &n);\n    scanf(\"%s\", str + 1);\n    for (int j = n - 1; j >= 1; j--) g[n][j] = (str[n] == str[j]);\n    for (int j = n - 1; j >= 1; j--)\n      for (int k = j - 1; k >= 1; k--) {\n        if (str[j] == str[k])\n          g[j][k] = g[j + 1][k + 1] + 1;\n        else\n          g[j][k] = 0;\n      }\n    f[1] = ans = n;\n    for (int j = 2; j <= n; j++) {\n      f[j] = n - j + 1;\n      for (int k = 1; k < j; k++) {\n        if (j + g[j][k] > n + 1) continue;\n        if (str[j + g[j][k]] > str[k + g[j][k]])\n          f[j] = max(f[j], f[k] + n - j - g[j][k] + 1);\n      }\n      ans = max(ans, f[j]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass rmq_sa {\n  vector<int> v;\n  vector<vector<int>> b;\n  int f(int i, int j) { return v[i] < v[j] ? i : j; }\n\n public:\n  rmq_sa() {}\n  rmq_sa(vector<int> _v) : v(_v) {\n    int n = v.size();\n    int m = 32 - __builtin_clz(n);\n    b = vector<vector<int>>(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n      b[i][0] = i;\n    }\n    for (int j = 1; j < m; ++j) {\n      for (int i = 0; i < n - (1 << j) + 1; ++i) {\n        b[i][j] = f(b[i][j - 1], b[i + (1 << (j - 1))][j - 1]);\n      }\n    }\n  }\n  int query(int l, int r) {\n    int x = floor(log2(r - l));\n    return f(b[l][x], b[r - (1 << x)][x]);\n  }\n};\nclass suffix_array {\n  vector<int> sa;\n  vector<int> lcp;\n  vector<int> sr;\n  int n;\n  rmq_sa st;\n\n public:\n  suffix_array() {}\n  suffix_array(const vector<int> &a)\n      : n(a.size()), sa(a.size() + 1), lcp(a.size()), sr(a.size() + 1) {\n    sa[0] = n;\n    iota(sa.begin() + 1, sa.end(), 0);\n    sort(sa.begin() + 1, sa.end(), [&](int i, int j) { return a[i] < a[j]; });\n    for (int i = 1; i <= n; ++i) {\n      sr[sa[i]] = i > 1 && a[sa[i]] == a[sa[i - 1]] ? sr[sa[i - 1]] : i;\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      vector<int> t(sa);\n      vector<int> tr(sr);\n      vector<int> p(n + 1);\n      iota(p.begin(), p.end(), 0);\n      for (int i : t) {\n        if (i >= k) {\n          sa[p[sr[i - k]]++] = i - k;\n        }\n      }\n      for (int i = 1; i <= n; ++i) {\n        sr[sa[i]] =\n            tr[sa[i]] == tr[sa[i - 1]] && tr[sa[i] + k] == tr[sa[i - 1] + k]\n                ? sr[sa[i - 1]]\n                : i;\n      }\n    }\n    for (int i = 0, l = 0; i < n; lcp[sr[i++] - 1] = l, l && l--) {\n      for (int j = sa[sr[i] - 1]; j + l < n && a[i + l] == a[j + l]; ++l)\n        ;\n    }\n    st = rmq_sa(lcp);\n  }\n  int getlcp(int i, int j) {\n    if (i == j) {\n      return n - i;\n    }\n    i = sr[i];\n    j = sr[j];\n    if (i > j) {\n      swap(i, j);\n    }\n    return lcp[st.query(i, j)];\n  }\n  int operator[](int i) { return sa[i]; }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n      a[i] = s[i] - 'a';\n    }\n    vector<int> dp(n);\n    suffix_array sa(a);\n    for (int i = 0; i < n; ++i) {\n      dp[i] = n - i;\n      for (int j = 0; j < i; ++j) {\n        int lcp = sa.getlcp(i, j);\n        if (i + lcp < n && s[j + lcp] < s[i + lcp]) {\n          dp[i] = max(dp[i], dp[j] + (n - lcp - i));\n        }\n      }\n    }\n    cout << *max_element(dp.begin(), dp.end()) << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<vector<int>> lcp(n + 1, vector<int>(n + 1, 0));\n  string s;\n  cin >> s;\n  for (int i = n - 1; i >= 0; --i) {\n    for (int j = n - 1; j >= 0; --j) {\n      if (i == n - 1 && j == n - 1) continue;\n      if (s[i] == s[j])\n        lcp[i][j] = lcp[i + 1][j + 1] + 1;\n      else\n        lcp[i][j] = 0;\n    }\n  }\n  vector<int> res(n, 0);\n  res[0] = n;\n  int ans = res[0];\n  for (int i = 1; i < n; ++i) {\n    res[i] = n - i;\n    for (int j = 0; j < i; ++j) {\n      if (i + lcp[i][j] < n && s[i + lcp[i][j]] >= s[j + lcp[i][j]]) {\n        res[i] = max(res[i], res[j] + n - i - lcp[i][j]);\n      }\n    }\n    ans = max(ans, res[i]);\n  }\n  cout << ans << endl;\n  return;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9 + 42;\nvector<int> z_func(string s) {\n  vector<int> z(s.size());\n  z[0] = s.size();\n  int l = 0, r = 1;\n  for (int i = 1; i < s.size(); ++i) {\n    if (i >= r)\n      z[i] = 0;\n    else\n      z[i] = min(r - i, z[i - l]);\n    while (i + z[i] < s.size() && s[i + z[i]] == s[z[i]]) ++z[i];\n    if (i + z[i] > r) {\n      l = i;\n      r = i + z[i];\n    }\n  }\n  return z;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    string s;\n    cin >> n >> s;\n    vector<vector<int>> z(n, vector<int>(n));\n    string s1;\n    for (int i = n - 1; i > -1; --i) {\n      s1 = s[i] + s1;\n      vector<int> zi = z_func(s1);\n      for (int j = i; j < n; ++j) z[i][j] = zi[j - i];\n    }\n    s += 'z' + 1;\n    vector<int> dp(n);\n    for (int i = 0; i < n; ++i) dp[i] = n - i;\n    for (int i = 1; i < n; ++i)\n      for (int j = 0; j < i; ++j)\n        if (s[i + z[j][i]] > s[j + z[j][i]])\n          dp[i] = max(dp[i], dp[j] + n - i - z[j][i]);\n    cout << *max_element(dp.begin(), dp.end()) << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e3 + 5;\nint readint() {\n  int x = 0, f = 1;\n  char s = getchar();\n  while (s < '0' || s > '9') {\n    if (s == '-') f = -1;\n    (s = getchar());\n  }\n  while (s >= '0' && s <= '9') {\n    x = (x << 3) + (x << 1) + (s ^ 48);\n    (s = getchar());\n  }\n  return x * f;\n}\nchar s[maxn];\nint cnt[maxn], maxsize;\nint sa[maxn], rk[maxn];\nint x[maxn << 1], y[maxn << 1];\nint lcp[maxn][maxn];\nint height[maxn];\nint dp[maxn];\nvoid get_sa(int n) {\n  int maxsize = 150;\n  for (int i = 0; i <= maxsize; i++) cnt[i] = 0;\n  for (int i = 0; i <= n * 2 + 5; i++) x[i] = 0, y[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    x[i] = s[i];\n    cnt[x[i]]++;\n  }\n  for (int i = 1; i <= maxsize; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[x[i]]--] = i;\n  for (int k = 1; k <= n; k <<= 1) {\n    int num = 0;\n    for (int i = n - k + 1; i <= n; i++) y[++num] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > k) y[++num] = sa[i] - k;\n    for (int i = 1; i <= maxsize; i++) cnt[i] = 0;\n    for (int i = 1; i <= n; i++) ++cnt[x[i]];\n    for (int i = 1; i <= maxsize; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[x[y[i]]]--] = y[i], y[i] = 0;\n    swap(x, y);\n    x[sa[1]] = 1;\n    num = 1;\n    for (int i = 2; i <= n; i++)\n      x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k])\n                     ? num\n                     : ++num;\n    if (num == n) break;\n    maxsize = num;\n  }\n}\nvoid getheight(int n) {\n  for (int i = 1; i <= n; i++) rk[sa[i]] = i;\n  int k = 0;\n  for (int i = 1; i <= n; i++) {\n    if (rk[i] == 1) continue;\n    if (k) k--;\n    int j = sa[rk[i] - 1];\n    while (i + k <= n && j + k <= n && s[j + k] == s[i + k]) k++;\n    height[rk[i]] = k;\n  }\n}\nvoid getlcp(int n) {\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) lcp[i][j] = 0;\n  for (int i = 1; i <= n; i++) {\n    lcp[i][i] = n - sa[i] + 1;\n    for (int j = i + 1; j <= n; j++) lcp[i][j] = min(lcp[i][j - 1], height[j]);\n  }\n  for (int i = 1; i <= n; i++)\n    for (int j = i - 1; j; j--) lcp[i][j] = lcp[j][i];\n}\nint main() {\n  int t = readint();\n  while (t--) {\n    int n = readint();\n    scanf(\"%s\", s + 1);\n    get_sa(n);\n    getheight(n);\n    getlcp(n);\n    for (int i = 1; i <= n; i++) dp[i] = 0;\n    dp[1] = n;\n    for (int i = 2; i <= n; i++) {\n      dp[i] = n - i + 1;\n      for (int j = 1; j <= i - 1; j++) {\n        if (rk[j] > rk[i] || lcp[rk[i]][rk[j]] == n - i + 1) continue;\n        dp[i] = max(dp[i], dp[j] + n - i + 1 - lcp[rk[i]][rk[j]]);\n      }\n    }\n    int maxx = 0;\n    for (int i = 1; i <= n; i++) {\n      maxx = max(dp[i], maxx);\n    }\n    printf(\"%d\\n\", maxx);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5000 + 9;\nconst int SZ = N * 2;\nconst int sigma = 26;\nchar s[N];\nint cur, rk[N][N];\nint tot, last, nxt[SZ][sigma], len[SZ], link[SZ];\nvector<int> ch[SZ], pos[SZ];\nbool cmp(int u, int v) {\n  return s[pos[u][0] + len[link[u]]] < s[pos[v][0] + len[link[v]]];\n}\ntemplate <int N, int sigma>\nstruct Suffix_Automaton {\n  void init(int n) {\n    tot = last = 0;\n    link[0] = -1;\n    memset(nxt, 0, (n * 2 + 5) * sigma * sizeof(int));\n    for (int i = 0; i < n * 2 + 5; ++i) {\n      ch[i].clear();\n      pos[i].clear();\n    }\n  }\n  void add_char(int c) {\n    int p = last, cur = last = ++tot;\n    len[cur] = len[p] + 1;\n    while (~p && !nxt[p][c]) {\n      nxt[p][c] = cur;\n      p = link[p];\n    }\n    if (p == -1) {\n      link[cur] = 0;\n      return;\n    }\n    int q = nxt[p][c];\n    if (len[q] == len[p] + 1) {\n      link[cur] = q;\n      return;\n    }\n    int _q = ++tot;\n    len[_q] = len[p] + 1;\n    memcpy(nxt[_q], nxt[q], sigma * sizeof(int));\n    link[_q] = link[q];\n    link[q] = link[cur] = _q;\n    while (~p && nxt[p][c] == q) {\n      nxt[p][c] = _q;\n      p = link[p];\n    }\n  }\n  void dfs(int u) {\n    for (int v : ch[u]) {\n      dfs(v);\n      for (int p : pos[v]) pos[u].push_back(p);\n    }\n  }\n  void dfs2(int u) {\n    sort(ch[u].begin(), ch[u].end(), cmp);\n    int s = len[link[u]], t = len[u];\n    for (int p : pos[u]) {\n      for (int d = s; d < t; ++d) {\n        rk[p][p + d] = cur + d - s;\n      }\n    }\n    cur += t - s;\n    for (int v : ch[u]) dfs2(v);\n  }\n  void add_string(char s[], int n) {\n    reverse(s + 1, s + n + 1);\n    for (int i = 1; i <= n; ++i) {\n      add_char(s[i] - 'a');\n      pos[last].push_back(n - i + 1);\n    }\n    for (int i = 1; i <= tot; ++i) {\n      ch[link[i]].push_back(i);\n    }\n    reverse(s + 1, s + n + 1);\n    dfs(0);\n    cur = 1;\n    dfs2(0);\n  }\n};\nSuffix_Automaton<N * 2, 26> sam;\nstruct BIT {\n  int n, maxv[N * N];\n  void init(int _n) {\n    n = _n;\n    memset(maxv, 0, (n + 5) * sizeof(*maxv));\n  }\n  void upd(int p, int k) {\n    for (; p <= n; p += p & -p) maxv[p] = max(maxv[p], k);\n  }\n  int q(int p) {\n    int r = 0;\n    for (; p; p -= p & -p) r = max(r, maxv[p]);\n    return r;\n  }\n} bit;\nvoid solve() {\n  int n;\n  scanf(\"%d\", &n);\n  scanf(\"%s\", s + 1);\n  sam.init(n);\n  sam.add_string(s, n);\n  bit.init(cur);\n  for (int i = 1; i <= n; ++i) {\n    for (int j = i; j <= n; ++j) {\n      int p = rk[i][j];\n      int r = bit.q(p - 1);\n      bit.upd(p, r + 1);\n    }\n  }\n  int ans = bit.q(cur);\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<vector<int>> d(n, vector<int>(n, 0));\n    for (int i = n - 2; i >= 0; i--) {\n      d[i][n - 1] = (s[n - 1] > s[i]);\n      for (int j = n - 2; j > i; j--) {\n        if (s[j] < s[i])\n          d[i][j] = 0;\n        else if (s[j] > s[i])\n          d[i][j] = n - j;\n        else\n          d[i][j] = d[i + 1][j + 1];\n      }\n    }\n    vector<int> dp(n);\n    dp[0] = n;\n    for (int i = 1; i < n; i++) {\n      dp[i] = n - i;\n      for (int j = 0; j < i; j++) {\n        if (d[j][i] > 0) dp[i] = max(dp[i], dp[j] + d[j][i]);\n      }\n    }\n    int res = 0;\n    for (int i = 0; i < n; i++) res = max(res, dp[i]);\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::cerr;\nusing std::cin;\nusing std::max;\nusing std::min;\nint T, n, f[5005][5005], ST[5005][15], Log[5005], ans;\nchar s[5005];\nclass SuffixArray {\n  int cnt, Max, Sum[5005], tp[5005 << 1];\n  void Rsort() {\n    for (int i = 1; i <= Max; i++) Sum[i] = 0;\n    for (int i = 1; i <= n; i++) Sum[Rank[tp[i]]]++;\n    for (int i = 1; i <= Max; i++) Sum[i] += Sum[i - 1];\n    for (int i = n; i; i--) sa[Sum[Rank[tp[i]]]--] = tp[i];\n  }\n\n public:\n  int sa[5005], Rank[5005], h[5005];\n  void build() {\n    for (int i = 1; i <= n; i++) tp[i] = i, Max = max(Max, Rank[i] = s[i]);\n    Rsort();\n    if (n == 1) return;\n    for (int j = 1; cnt < n; Max = cnt, j <<= 1) {\n      cnt = 0;\n      for (int i = n - j + 1; i <= n; i++) tp[++cnt] = i;\n      for (int i = 1; i <= n; i++)\n        if (sa[i] > j) tp[++cnt] = sa[i] - j;\n      Rsort();\n      for (int i = 1; i <= n; i++) std::swap(Rank[i], tp[i]);\n      Rank[sa[cnt = 1]] = 1;\n      for (int i = 2; i <= n; i++) {\n        if (tp[sa[i]] ^ tp[sa[i - 1]] || tp[sa[i] + j] ^ tp[sa[i - 1] + j])\n          cnt++;\n        Rank[sa[i]] = cnt;\n      }\n    }\n    for (int i = 1, tmp = 0; i <= n; i++) {\n      for (tmp ? tmp-- : 0;\n           Rank[i] < n && s[sa[Rank[i] + 1] + tmp] == s[i + tmp]; tmp++)\n        ;\n      h[Rank[i]] = tmp;\n    }\n  }\n  void clear() {\n    for (int i = 1; i <= n; i++) tp[i] = Rank[i] = 0;\n    Max = cnt = 0;\n  }\n} SA;\nint asklcp(int x, int y) {\n  x = SA.Rank[x], y = SA.Rank[y];\n  if (x > y) std::swap(x, y);\n  y--;\n  int t = Log[y - x + 1];\n  return min(ST[x][t], ST[y - (1 << t) + 1][t]);\n}\nvoid clear() {\n  for (int i = 1; i <= n; i++)\n    for (int j = i; j <= n; j++) f[i][j] = 0;\n  ans = 0, SA.clear();\n}\nint main() {\n  for (int i = 2; i <= 5005 - 5; i++) Log[i] = Log[i >> 1] + 1;\n  for (scanf(\"%d\", &T); T--; clear()) {\n    scanf(\"%d%s\", &n, s + 1), SA.build();\n    for (int i = 1; i <= n; i++) ST[i][0] = SA.h[i];\n    for (int j = 1; j < 15; j++)\n      for (int i = 1; i + (1 << j) - 1 <= n; i++)\n        ST[i][j] = min(ST[i][j - 1], ST[i + (1 << j - 1)][j - 1]);\n    for (int i = 1, v, l; i <= n; i++) {\n      v = 0;\n      for (int j = 1; j < i; j++)\n        if (s[j] < s[i]) v = max(v, f[j][n]);\n      for (int j = i; j <= n; j++) f[i][j] = v + j - i + 1;\n      for (int j = 1; j < i; j++)\n        if (s[j] == s[i]) {\n          l = asklcp(j, i);\n          if (i + l <= n && s[i + l] > s[j + l])\n            f[i][i + l] = max(f[i][i + l], f[j][n] + 1);\n        }\n      for (int j = i; j <= n; j++)\n        f[i][j] = max(f[i][j], f[i][j - 1] + 1), ans = max(ans, f[i][j]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar c[5000];\nint match[5000][5000], dp[5000];\nint main() {\n  int test_case = 1;\n  scanf(\"%d\", &test_case);\n  while (test_case--) {\n    int n, ans = 0;\n    scanf(\"%d %s\", &n, &c);\n    n = strlen(c);\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < n; j++) match[i][j] = 0;\n    for (int i = n - 1; i >= 0; i--)\n      for (int j = n - 1; j > i; j--)\n        if (c[i] == c[j]) match[i][j] = 1 + match[i + 1][j + 1];\n    for (int i = 0; i < n; i++) {\n      dp[i] = n - i;\n      for (int j = i - 1; j >= 0; j--)\n        if ((i + match[j][i] < n) && c[i + match[j][i]] > c[j + match[j][i]])\n          dp[i] = max(dp[i], dp[j] + n - i - match[j][i]);\n      ans = max(ans, dp[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int kMaxN = 10000 + 5;\nconst int kBase = 131;\nint t;\nint n;\nchar s[kMaxN];\nint dp[kMaxN];\nint rk[kMaxN * 2];\nint oldrk[kMaxN * 2];\nint sa[kMaxN];\nint w;\nunsigned long long base[kMaxN];\nunsigned long long hs[kMaxN];\nunsigned long long Get_hash(int x, int y) {\n  return hs[y] - hs[x - 1] * base[y - x + 1];\n}\nint main() {\n  base[0] = 1;\n  for (int i = 1; i <= kMaxN - 5; i++) {\n    base[i] = kBase * base[i - 1];\n  }\n  cin >> t;\n  while (t--) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n      dp[i] = n - i + 1;\n    }\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; i++) {\n      hs[i] = kBase * hs[i - 1] + s[i];\n    }\n    for (int i = 1; i <= n; i++) {\n      sa[i] = i;\n      rk[i] = s[i];\n    }\n    for (w = 1; w < n; w = w * 2) {\n      sort(sa + 1, sa + n + 1, [](int x, int y) {\n        return rk[x] == rk[y] ? rk[x + w] < rk[y + w] : rk[x] < rk[y];\n      });\n      memcpy(oldrk, rk, sizeof(rk));\n      for (int p = 0, i = 1; i <= n; i++) {\n        if (oldrk[sa[i]] == oldrk[sa[i - 1]] &&\n            oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) {\n          rk[sa[i]] = p;\n        } else {\n          rk[sa[i]] = ++p;\n        }\n      }\n    }\n    for (int i = 2; i <= n; i++) {\n      for (int j = 1; j <= i - 1; j++) {\n        if (s[i] > s[j]) {\n          dp[i] = max(dp[i], dp[j] + n - i + 1);\n        } else if (s[i] == s[j] && rk[i] > rk[j]) {\n          int l = 0, r = n - i;\n          while (l + 1 < r) {\n            int mid = (l + r) / 2;\n            if (Get_hash(i, i + mid) != Get_hash(j, j + mid)) {\n              r = mid;\n            } else {\n              l = mid;\n            }\n          }\n          if (l != n - i) {\n            if (Get_hash(i, i + l + 1) == Get_hash(j, j + l + 1)) {\n              l++;\n            }\n          }\n          dp[i] = max(dp[i], dp[j] + n - i - l);\n        }\n      }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      ans = max(ans, dp[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    int dp[n];\n    fill(dp, dp + n, 0);\n    int ans = 0;\n    for (int i = n - 1; i >= 0; i--) {\n      int z[n];\n      fill(z + i, z + n, 0);\n      for (int j = i + 1, l = i, r = i; j < n; j++) {\n        if (j + z[j - l + i] < r) {\n          z[j] = z[j - l + i];\n        } else {\n          l = j;\n          r = max(r, j);\n          while (r < n && s[r - l + i] == s[r]) {\n            r++;\n          }\n          z[j] = r - l;\n        }\n        if (j + z[j] < n && s[j + z[j]] > s[i + z[j]]) {\n          dp[i] = max(dp[i], dp[j] + (n - j - z[j]));\n        }\n      }\n      ans = max(ans, dp[i] + (n - i));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 5000 + 7;\nint T, n;\nchar s[MAX_N];\nint z[MAX_N][MAX_N];\nint dp[MAX_N];\nvoid getZ(int n, char s[], int z[]) {\n  z[0] = 0;\n  for (int i = 1, k = 0; i < n; ++i) {\n    int x = i - k;\n    z[i] = 0;\n    if (z[x] < z[k] - x) {\n      z[i] = z[x];\n    } else {\n      z[i] = max(0, z[k] - x);\n      while (s[z[i]] == s[i + z[i]]) z[i] += 1;\n      if (k + z[k] < i + z[i]) k = i;\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> T;\n  while (T--) {\n    cin >> n;\n    cin >> (s + 1);\n    for (int i = 1; i <= n; ++i) {\n      dp[i] = 0;\n      getZ(n - i + 1, s + i, z[i] + i);\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 0; j < i; ++j) {\n        if (s[i + z[j][i]] > s[j + z[j][i]]) {\n          dp[i] = max(dp[i], dp[j] + n - i + 1 - z[j][i]);\n        }\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NR = 5005;\nvoid Min(int& x, int y) { x = min(x, y); }\nvoid Max(int& x, int y) { x = max(x, y); }\nint read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = (x << 3) + (x << 1) + (ch ^ 48);\n    ch = getchar();\n  }\n  return x * f;\n}\nint n, m;\nchar s[NR << 1];\nint sa[NR << 1], id[NR << 1];\nint rk[NR << 1], lark[NR << 1];\nint cnt[NR];\nint h[NR << 1];\nint dp[NR << 1];\nint mn[NR][NR];\nvoid work() {\n  memset(s, 0, sizeof(s));\n  memset(sa, 0, sizeof(sa));\n  memset(rk, 0, sizeof(rk));\n  n = read(), scanf(\"%s\", s + 1);\n  m = max(n, 300);\n  memset(cnt, 0, sizeof(cnt));\n  for (int i = 1; i <= n; i++) cnt[rk[i] = s[i]]++;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    memset(cnt, 0, sizeof(cnt));\n    int p = 0;\n    for (int i = n - w + 1; i <= n; i++) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    for (int i = 1; i <= n; i++) cnt[rk[id[i]]]++;\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[rk[id[i]]]--] = id[i];\n    memcpy(lark, rk, sizeof(lark));\n    rk[sa[1]] = m = 1;\n    for (int i = 2; i <= n; i++) {\n      if (lark[sa[i]] == lark[sa[i - 1]] &&\n          lark[sa[i] + w] == lark[sa[i - 1] + w])\n        rk[sa[i]] = m;\n      else\n        rk[sa[i]] = ++m;\n    }\n  }\n  memset(h, 0, sizeof(h));\n  int lcp = 0;\n  for (int i = 1; i <= n; i++) {\n    if (lcp) lcp--;\n    while (s[i + lcp] == s[sa[rk[i] - 1] + lcp]) lcp++;\n    h[rk[i]] = lcp;\n  }\n  for (int i = 1; i <= n; i++) {\n    mn[i][i] = h[i];\n    for (int j = i + 1; j <= n; j++) mn[i][j] = min(mn[i][j - 1], h[j]);\n  }\n  int ans = 0;\n  memset(dp, 0, sizeof(dp));\n  for (int i = 1; i <= n; i++) {\n    int len = dp[i] = n - i + 1;\n    for (int j = 1; j < i; j++) {\n      if (rk[i] < rk[j]) continue;\n      dp[i] = max(dp[i], dp[j] + len - mn[rk[j] + 1][rk[i]]);\n    }\n    ans = max(ans, dp[i]);\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) mn[i][j] = 0;\n}\nint main() {\n  int T = read();\n  while (T--) work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5005;\nint n;\nstring s;\nint f[N], lcp[N][N];\nvoid solve() {\n  cin >> n >> s;\n  s = '#' + s;\n  for (int i = 1; i <= n; ++i) lcp[n + 1][i] = 0;\n  for (int i = n; i; --i) {\n    for (int j = 1; j < i; ++j) {\n      lcp[i][j] = 0;\n      if (s[i] == s[j]) lcp[i][j] = lcp[i + 1][j + 1] + 1;\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    f[i] = n - i + 1;\n    for (int j = 1; j < i; ++j) {\n      int c = lcp[i][j];\n      if (i + c <= n) {\n        if (s[i + c] > s[j + c]) f[i] = max(f[i], f[j] + n - i - c + 1);\n      }\n    }\n    ans = max(ans, f[i]);\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(false);\n  int test_case;\n  cin >> test_case;\n  while (test_case--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ninline char gc() {\n  static const int L = 233333;\n  static char sxd[L], *sss = sxd, *ttt = sxd;\n  if (sss == ttt) {\n    ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n    if (sss == ttt) {\n      return EOF;\n    }\n  }\n  return *sss++;\n}\ntemplate <class T>\ninline bool read(T& x) {\n  x = 0;\n  char c = gc();\n  bool flg = false;\n  for (; !isdigit(c); c = gc()) {\n    if (c == '-') {\n      flg = true;\n    } else if (c == EOF) {\n      return false;\n    }\n  }\n  for (; isdigit(c); c = gc()) {\n    x = (x * 10) + (c ^ 48);\n  }\n  if (flg) {\n    x = -x;\n  }\n  return true;\n}\ntemplate <class T>\ninline void write(T x) {\n  if (x < 0) {\n    x = -x;\n    putchar('-');\n  }\n  if (x > 9) {\n    write(x / 10);\n    x %= 10;\n  }\n  putchar(x | 48);\n}\ntemplate <class T>\ninline void writeln(T x) {\n  write(x);\n  puts(\"\");\n}\ntemplate <class T>\ninline void writesp(T x) {\n  write(x);\n  putchar(' ');\n}\nstd::vector<int> Z_function(std::string s) {\n  int n = s.length();\n  std::vector<int> z(n);\n  z[0] = n;\n  for (int i = 1, l = 0, r = 0; i < n; ++i) {\n    if (i <= r && z[i - l] < r - i + 1) {\n      z[i] = z[i - l];\n    } else {\n      z[i] = std::max(0, r - i + 1);\n      while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n        z[i]++;\n      }\n    }\n    if (i + z[i] - 1 > r) {\n      l = i, r = i + z[i] - 1;\n    }\n  }\n  return z;\n}\nvoid solve() {\n  int n;\n  std::string s;\n  std::cin >> n >> s;\n  std::vector<int> f(n);\n  for (int i = n - 1; ~i; --i) {\n    auto z = Z_function(s.substr(i));\n    f[i] = n - i;\n    for (int j = i + 1; j < n; ++j) {\n      int lcp = z[j - i];\n      if (j + lcp < n && s[i + lcp] < s[j + lcp]) {\n        f[i] = std::max(f[i], f[j] - lcp + n - i);\n      }\n    }\n  }\n  std::cout << *std::max_element(f.begin(), f.end()) << std::endl;\n}\nint main() {\n  int T;\n  std::cin >> T;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e3 + 40;\nint f[maxn][maxn];\nint dp[maxn];\nchar s[maxn];\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%s\", s + 1);\n    f[n][n + 1] = f[n + 1][n] = f[n + 1][n + 1] = 0;\n    for (int i = n; i >= 1; i--)\n      for (int j = n; j >= 1; j--) {\n        if (s[i] == s[j]) {\n          f[i][j] = f[i + 1][j + 1] + 1;\n        } else {\n          f[i][j] = 0;\n        }\n      }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      dp[i] = n - i + 1;\n      for (int j = 1; j < i; j++) {\n        int len = f[i][j];\n        if (i + len - 1 >= n || s[i + len] <= s[j + len]) continue;\n        dp[i] = max(dp[i], dp[j] + n - i + 1 - len);\n      }\n      ans = max(ans, dp[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 5005;\nint n, z[N][N], f[N];\nchar s[N];\nvoid solve() {\n  scanf(\"%d%s\", &n, s + 1);\n  for (int i = (n); i >= (1); i--)\n    for (int j = (n); j >= (i); j--)\n      z[i][j] = s[i] == s[j] ? (j <= n ? z[i + 1][j + 1] + 1 : 1) : 0;\n  int as = 0;\n  memset(f, 0, sizeof f);\n  for (int i = (1); i <= (n); i++)\n    for (int j = (0), je = (i); j < je; j++) {\n      int l = z[j][i];\n      if (i + l <= n && s[i + l] > s[j + l])\n        (as = max(as, (f[i] = max(f[i], f[j] + n - i - l + 1))));\n    }\n  printf(\"%d\\n\", as);\n}\nint main() {\n  int T;\n  for (cin >> T; T--; solve())\n    ;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint t, n;\nchar s[5005];\nint dp[5005];\nint a[5005][5005];\nint ans;\nvoid sol() {\n  cin >> n;\n  scanf(\"%s \", s + 1);\n  ans = n;\n  for (int i = 1; i <= n + 1; ++i)\n    for (int j = i + 1; j <= n + 1; ++j) a[i][j] = 0;\n  s[n + 1] = 'a' - 1;\n  for (int i = n; i >= 1; --i)\n    for (int j = i + 1; j <= n; ++j)\n      if (s[i] != s[j])\n        a[i][j] = 0;\n      else\n        a[i][j] = a[i + 1][j + 1] + 1;\n  dp[1] = n;\n  for (int i = 2; i <= n; ++i) {\n    dp[i] = n - i + 1;\n    for (int j = 1; j < i; ++j) {\n      int k = a[j][i];\n      if (s[i + k] - 'a' > s[j + k] - 'a')\n        dp[i] = max(dp[i], dp[j] + n - i + 1 - k);\n    }\n    ans = max(ans, dp[i]);\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  cin >> t;\n  while (t--) sol();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nstruct SparseTable {\n public:\n  int N;\n  vector<int> compute;\n  vector<vector<T>> tab;\n  T merge(const T& a, const T& b) { return min(a, b); }\n  SparseTable(const vector<T>& values) {\n    int N = values.size();\n    compute.resize(N + 1);\n    for (int i = 2; i <= N; ++i) compute[i] = compute[i / 2] + 1;\n    const int log = 32 - __builtin_clz(N);\n    tab.resize(log);\n    tab[0] = values;\n    for (int j = 1; j < log; ++j) {\n      tab[j].resize(N - (1 << j) + 1);\n      for (int i = 0; i <= N - (1 << j); ++i)\n        tab[j][i] = merge(tab[j - 1][i], tab[j - 1][i + (1 << (j - 1))]);\n    }\n  }\n  T query(int L, int R) {\n    int j = compute[R - L + 1];\n    return merge(tab[j][L], tab[j][R - (1 << j) + 1]);\n  }\n};\nstruct SuffixArray {\n  string S;\n  int N, f0, f1, f2;\n  SparseTable<int>* st;\n  vector<int> p, c, lcp;\n  map<int, int> location;\n  SuffixArray(string s) {\n    S = s;\n    S += \"!\";\n    f0 = f1 = f2 = 0;\n    N = S.size();\n    p.resize(N);\n    c.resize(N);\n    lcp.resize(N);\n    location.clear();\n  }\n  void counting_sort() {\n    vector<int> cnt(N);\n    for (auto it : c) cnt[it] += 1;\n    vector<int> p_new(N);\n    vector<int> pos(N);\n    for (int i = 1; i < N; i++) {\n      pos[i] = pos[i - 1] + cnt[i - 1];\n    }\n    for (auto it : p) {\n      int bucket = c[it];\n      p_new[pos[bucket]] = it;\n      pos[bucket] += 1;\n    }\n    p = p_new;\n  }\n  void build_suffix_array() {\n    f0 = 1;\n    {\n      vector<pair<char, int>> x(N);\n      for (int i = 0; i < N; i++) x[i] = {S[i], i};\n      sort(x.begin(), x.end());\n      for (int i = 0; i < N; i++) p[i] = x[i].second;\n      c[p[0]] = 0;\n      for (int i = 1; i < N; i++) {\n        if (x[i].first == x[i - 1].first)\n          c[p[i]] = c[p[i - 1]];\n        else\n          c[p[i]] = c[p[i - 1]] + 1;\n      }\n    }\n    int k = 0;\n    while ((1 << k) < N) {\n      for (int i = 0; i < N; i++) p[i] = (p[i] - (1 << k) + N) % N;\n      counting_sort();\n      vector<int> c_new(N);\n      c_new[p[0]] = 0;\n      for (int i = 1; i < N; i++) {\n        pair<int, int> prev = {c[p[i - 1]], c[(p[i - 1] + (1 << k)) % N]};\n        pair<int, int> now = {c[p[i]], c[(p[i] + (1 << k)) % N]};\n        if (prev == now)\n          c_new[p[i]] = c_new[p[i - 1]];\n        else\n          c_new[p[i]] = c_new[p[i - 1]] + 1;\n      }\n      c = c_new;\n      k++;\n    }\n  }\n  void build_lcp_array() {\n    f1 = 1;\n    int k = 0;\n    for (int i = 0; i + 1 < N; i++) {\n      int pi = c[i];\n      int j = p[pi - 1];\n      while (S[i + k] == S[j + k]) k++;\n      lcp[pi - 1] = k;\n      k = max(0, k - 1);\n    }\n  }\n  int number_of_different_substrings() {\n    build_suffix_array();\n    build_lcp_array();\n    int ans = 0;\n    for (int i = 0; i + 1 < N; i++) ans += lcp[i];\n    return N * (N - 1) / 2 - ans;\n  }\n  int get_longest_matching_preffix(int i, int j) {\n    if (!f0) {\n      build_suffix_array();\n    }\n    if (!f1) {\n      build_lcp_array();\n    }\n    if (!f2) {\n      st = new SparseTable<int>(lcp);\n      for (int i = 0; i < (int)p.size(); ++i) location[p[i]] = i;\n      f2 = 1;\n    }\n    i = location[i];\n    j = location[j];\n    if (i > j) swap(i, j);\n    --j;\n    return st->query(i, j);\n  }\n  vector<int> get_suffix_array() { return p; }\n  vector<int> get_lcp_array() { return lcp; }\n};\ntemplate <class T>\nostream& operator<<(ostream& stream, const vector<T>& values) {\n  for (T v : values) cout << v << \" \";\n  return stream;\n}\ntemplate <class T>\nvoid print_vector(const vector<T>& values, int from = -1, int to = -1) {\n  if (from < 0) from = 0;\n  if (to < 0) to = int(values.size()) - 1;\n  for (int i = from; i <= to; ++i) cout << values[i] << (i < to ? ' ' : '\\n');\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    int N;\n    cin >> N;\n    string S;\n    cin >> S;\n    SuffixArray SA(S);\n    SA.build_suffix_array();\n    SA.build_lcp_array();\n    vector<int> dp(N);\n    for (int i = 0; i < N; ++i) dp[i] = N - i;\n    for (int i = 1; i < N; ++i) {\n      for (int j = 0; j < i; ++j) {\n        int match = SA.get_longest_matching_preffix(i, j);\n        if (match + i < N && S[i + match] > S[j + match]) {\n          dp[i] = max(dp[i], dp[j] + N - i - match);\n        }\n      }\n    }\n    cout << *max_element(dp.begin(), dp.end()) << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INF64 = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\ntypedef std::priority_queue<int, vector<int>, greater<int>> small_pq;\ntypedef std::priority_queue<int, vector<int>, less<int>> big_pq;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() {}\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  if (sizeof...(T) > 0) cerr << \" ,\";\n  dbg_out(T...);\n}\nvoid dbg_name(const string &s) {\n  string ss = s;\n  replace(ss.begin(), ss.end(), ',', ' ');\n  cerr << \"  ( \" << ss << \" )  \";\n}\ntemplate <typename T>\ninline void setmin(T &a, const T &b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\ninline void setmax(T &a, const T &b) {\n  if (b > a) a = b;\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nunordered_map<long long, int, custom_hash> safe_map;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::steady_clock::now().time_since_epoch().count());\nconst int MOD = 998244353;\nint mul(int x, int y) { return 1ll * x * y % MOD; }\nint add(int x, int y) { return ((x + y) % MOD + MOD) % MOD; }\nint sub(int x, int y) { return ((x - y) % MOD + MOD) % MOD; }\nint qpow(int a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = mul(ans, a);\n    a = mul(a, a);\n    b /= 2;\n  }\n  return ans;\n}\nconst int N = 1e4 + 5;\nnamespace Suffix {\nint sa[N], rk[N * 2], oldrk[N * 2], cnt[N * 2], id[N], px[N * 2];\nint ht[N];\nbool cmp(int x, int y, int w) {\n  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\nvoid suffix_array(char *s) {\n  memset(cnt, 0, sizeof(cnt));\n  memset(rk, 0, sizeof(rk));\n  int n = strlen(s + 1);\n  for (int i = 1; i <= n; i++) rk[i] = s[i];\n  int m = 150;\n  for (int i = 1; i <= n; i++) cnt[rk[i]]++;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    int p = 0;\n    for (int i = n; i > n - w; i--) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    fill(cnt, cnt + m + 1, 0);\n    for (int i = 1; i <= n; i++) cnt[px[i] = rk[id[i]]]++;\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[px[i]]--] = id[i];\n    memcpy(oldrk, rk, sizeof(rk));\n    p = 0;\n    for (int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n    m = p;\n  }\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (k) k--;\n    while ((i + k <= n) && s[i + k] == s[sa[rk[i] - 1] + k]) k++;\n    ht[rk[i]] = k;\n  }\n}\n}  // namespace Suffix\nconst int M = 14;\nchar s[N];\nint dp[N];\nint f[N][M];\nint calc(int i, int j) {\n  int s = log2(j - i + 1);\n  return min(f[i][s], f[j - (1 << s) + 1][s]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  using namespace Suffix;\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d %s\", &n, s + 1);\n    Suffix::suffix_array(s);\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      f[i][0] = Suffix::ht[i];\n    }\n    for (int(i) = int(1); int(i) <= int(M - 1); i++) {\n      for (int(j) = int(1); int(j) <= int(n); j++) {\n        f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n    int ans = 0;\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      dp[i] = n - i + 1;\n      for (int(j) = int(1); int(j) <= int(i - 1); j++) {\n        if (Suffix::rk[i] > Suffix::rk[j])\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - calc(rk[j] + 1, rk[i]));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n    fill(dp + 1, dp + 1 + n, 0);\n    for (int(i) = int(0); int(i) <= int(M - 1); i++)\n      for (int(j) = int(1); int(j) <= int(n); j++) f[j][i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0;\n  char c = getchar();\n  while (!isdigit(c)) c = getchar();\n  while (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n  return x;\n}\nconst int maxn = 5010;\nint n, m;\nchar s[maxn];\nint c[maxn], x[maxn], y[maxn], sa[maxn], rk[maxn], height[maxn];\nvoid get_sa() {\n  for (int i = 1; i <= n; i++) c[x[i] = s[i]]++;\n  for (int i = 2; i <= m; i++) c[i] += c[i - 1];\n  for (int i = n; i; i--) sa[c[x[i]]--] = i;\n  for (int k = 1; k <= n; k <<= 1) {\n    int num = 0;\n    for (int i = n - k + 1; i <= n; i++) y[++num] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > k) y[++num] = sa[i] - k;\n    for (int i = 1; i <= m; i++) c[i] = 0;\n    for (int i = 1; i <= n; i++) c[x[i]]++;\n    for (int i = 2; i <= m; i++) c[i] += c[i - 1];\n    for (int i = n; i; i--) sa[c[x[y[i]]]--] = y[i], y[i] = 0;\n    swap(x, y);\n    x[sa[1]] = 1, num = 1;\n    for (int i = 2; i <= n; i++)\n      x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k])\n                     ? num\n                     : ++num;\n    if (num == n) break;\n    m = num;\n  }\n}\nvoid get_height() {\n  for (int i = 1; i <= n; i++) rk[sa[i]] = i;\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (rk[i] == 1) continue;\n    if (k) k--;\n    int j = sa[rk[i] - 1];\n    while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;\n    height[rk[i]] = k;\n  }\n}\nint f[maxn][20];\nvoid Init_st() {\n  for (int i = 1; i <= n; i++) f[i][0] = height[i];\n  int t = log(n) / log(2) + 1;\n  for (int j = 1; j < t; j++)\n    for (int i = 1; i <= n - (1 << j) + 1; i++)\n      f[i][j] = min(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);\n}\ninline int query_st(int l, int r) {\n  int k = log(r - l + 1) / log(2);\n  return min(f[l][k], f[r - (1 << k) + 1][k]);\n}\ninline int lcp(int x, int y) {\n  if (!x || !y) return 0;\n  if (x == y) return n - x + 1;\n  if (rk[x] > rk[y]) swap(x, y);\n  return query_st(rk[x] + 1, rk[y]);\n}\nint dp[maxn];\nint main() {\n  int T = read();\n  while (T--) {\n    memset(y, 0, sizeof(y));\n    memset(x, 0, sizeof(x));\n    memset(c, 0, sizeof(c));\n    n = read();\n    m = 122;\n    scanf(\"%s\", s + 1);\n    get_sa();\n    get_height();\n    Init_st();\n    for (int i = 1; i <= n; i++) dp[i] = 0;\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 0; j < i; j++) {\n        if (rk[j] > rk[i]) continue;\n        int t = lcp(j, i);\n        dp[i] = max(dp[i], dp[j] + n - i - t + 1);\n      }\n      ans = max(ans, dp[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint t, n, ans, dp[5005], lcp[5005][5005];\nchar s[5005];\nint main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d%s\", &n, s + 1);\n    for (int i = n; i >= 1; --i) {\n      dp[i] = 0;\n      for (int j = n; j >= 1; --j) {\n        if (s[i] == s[j])\n          lcp[i][j] = lcp[i + 1][j + 1] + 1;\n        else\n          lcp[i][j] = 0;\n      }\n    }\n    ans = 0;\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        if (dp[j] - lcp[i][j] > dp[i] && s[j + lcp[i][j]] < s[i + lcp[i][j]])\n          dp[i] = dp[j] - lcp[i][j];\n      }\n      dp[i] += n - i + 1;\n      ans = max(ans, dp[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nvoid checkmax(T &x, T y) {\n  if (x < y) x = y;\n}\ntemplate <typename T>\nvoid checkmin(T &x, T y) {\n  if (x > y) x = y;\n}\nint T, n, m, p, sa[5005], rk[5005], trk[5005], sum[5005], ht[5005],\n    lcp[5005][5005], dp[5005];\nchar s[5005];\nvoid Sort() {\n  for (int i = 1; i <= m; i++) sum[i] = 0;\n  for (int i = 1; i <= n; i++) sum[rk[i]]++;\n  for (int i = 2; i <= m; i++) sum[i] += sum[i - 1];\n  for (int i = n; i >= 1; i--) sa[sum[rk[trk[i]]]--] = trk[i];\n}\nvoid get_SA() {\n  for (int i = 1; i <= n; i++) {\n    rk[i] = s[i];\n    sum[rk[i]]++;\n    trk[i] = i;\n  }\n  Sort();\n  for (int len = 1; len <= n; len <<= 1) {\n    p = 0;\n    for (int i = n - len + 1; i <= n; i++) trk[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > len) trk[++p] = sa[i] - len;\n    Sort();\n    memcpy(trk, rk, sizeof(rk));\n    p = rk[sa[1]] = 1;\n    for (int i = 2; i <= n; i++)\n      rk[sa[i]] = trk[sa[i]] == trk[sa[i - 1]] &&\n                          trk[sa[i] + len] == trk[sa[i - 1] + len]\n                      ? p\n                      : ++p;\n    if (p == n) break;\n    m = p;\n  }\n}\nvoid get_height() {\n  int k = 0;\n  for (int i = 1; i <= n; i++) rk[sa[i]] = i;\n  for (int i = 1; i <= n; i++) {\n    if (rk[i] == 1) continue;\n    if (k) k--;\n    int j = sa[rk[i] - 1];\n    while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;\n    ht[rk[i]] = k;\n  }\n}\nvoid Solve() {\n  std::cin >> n >> (s + 1), m = 200;\n  for (int i = 1; i <= std::max(n, 200); i++)\n    sa[i] = rk[i] = trk[i] = sum[i] = ht[i] = 0;\n  get_SA(), get_height();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) lcp[i][j] = 0;\n  for (int i = 1; i < n; i++) {\n    int min = 0x3f3f3f3f;\n    for (int j = i + 1; j <= n; j++) {\n      checkmin(min, ht[j]);\n      lcp[sa[i]][sa[j]] = lcp[sa[j]][sa[i]] = min;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    dp[i] = n - i + 1;\n    int max = 0;\n    for (int j = 1; j < i; j++) {\n      int x = i + lcp[i][j], y = j + lcp[i][j];\n      if (x <= n && s[x] > s[y]) checkmax(max, dp[j] - lcp[i][j]);\n    }\n    dp[i] += max;\n  }\n  std::cout << *std::max_element(dp + 1, dp + n + 1) << '\\n';\n}\nint main(int argc, char const *argv[]) {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr), std::cout.tie(nullptr);\n  std::cin >> T;\n  while (T--) Solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n;\n  string s;\n  cin >> n;\n  cin >> s;\n  long long arr[n + 1][n + 1];\n  for (long long i = 1; i < n + 1; i++) {\n    if (s[i - 1] == s[n - 1])\n      arr[i][n] = 1;\n    else\n      arr[i][n] = 0;\n  }\n  for (long long i = n - 2; i >= 1; i--) {\n    for (long long j = i + 1; j < n; j++) {\n      if (s[i - 1] == s[j - 1])\n        arr[i][j] = 1 + arr[i + 1][j + 1];\n      else\n        arr[i][j] = 0;\n    }\n  }\n  long long dp[n + 1];\n  for (long long i = 0; i < n + 1; i++) dp[i] = 0;\n  dp[n] = 1;\n  for (long long i = n - 1; i >= 1; i--) {\n    long long t = 0;\n    for (long long j = i + 1; j <= n; j++) {\n      long long x = arr[i][j];\n      if (j - 1 + x >= n) continue;\n      bool y = s[i - 1 + x] > s[j - 1 + x];\n      if (!y) t = max(t, dp[j] - x);\n    }\n    dp[i] = n - i + 1 + t;\n  }\n  sort(dp, dp + n + 1);\n  cout << dp[n] << endl;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long T = 1;\n  cin >> T;\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::cerr;\nusing std::cin;\nusing std::max;\nusing std::min;\nint T, n, f[5005][5005], ST[5005][15], Log[5005], ans;\nchar s[5005];\nclass SuffixArray {\n  int cnt, Max, Sum[5005], tp[5005 << 1];\n  void Rsort() {\n    for (int i = 1; i <= Max; i++) Sum[i] = 0;\n    for (int i = 1; i <= n; i++) Sum[Rank[tp[i]]]++;\n    for (int i = 1; i <= Max; i++) Sum[i] += Sum[i - 1];\n    for (int i = n; i; i--) sa[Sum[Rank[tp[i]]]--] = tp[i];\n  }\n\n public:\n  int sa[5005], Rank[5005], h[5005];\n  void build() {\n    for (int i = 1; i <= n; i++) tp[i] = i, Max = max(Max, Rank[i] = s[i]);\n    Rsort();\n    if (n == 1) return;\n    for (int j = 1; cnt < n; Max = cnt, j <<= 1) {\n      cnt = 0;\n      for (int i = n - j + 1; i <= n; i++) tp[++cnt] = i;\n      for (int i = 1; i <= n; i++)\n        if (sa[i] > j) tp[++cnt] = sa[i] - j;\n      Rsort();\n      for (int i = 1; i <= n; i++) std::swap(Rank[i], tp[i]);\n      Rank[sa[cnt = 1]] = 1;\n      for (int i = 2; i <= n; i++) {\n        if (tp[sa[i]] ^ tp[sa[i - 1]] || tp[sa[i] + j] ^ tp[sa[i - 1] + j])\n          cnt++;\n        Rank[sa[i]] = cnt;\n      }\n    }\n    for (int i = 1, tmp = 0; i <= n; i++) {\n      for (tmp ? tmp-- : 0; s[sa[Rank[i] + 1] + tmp] == s[i + tmp]; tmp++)\n        ;\n      h[Rank[i]] = tmp;\n    }\n  }\n  void clear() {\n    for (int i = 1; i <= n; i++) tp[i] = Rank[i] = sa[i] = h[i] = 0;\n    Max = cnt = 0;\n  }\n} SA;\nint asklcp(int x, int y) {\n  x = SA.Rank[x], y = SA.Rank[y];\n  if (x > y) std::swap(x, y);\n  y--;\n  int t = Log[y - x + 1];\n  return min(ST[x][t], ST[y - (1 << t) + 1][t]);\n}\nvoid clear() {\n  for (int i = 1; i <= n; i++)\n    for (int j = i; j <= n; j++) f[i][j] = 0;\n  ans = 0, SA.clear();\n}\nint main() {\n  for (int i = 2; i <= 5005 - 5; i++) Log[i] = Log[i >> 1] + 1;\n  for (scanf(\"%d\", &T); T--; clear()) {\n    scanf(\"%d%s\", &n, s + 1), SA.build();\n    for (int i = 1; i <= n; i++) ST[i][0] = SA.h[i];\n    for (int j = 1; j < 15; j++)\n      for (int i = 1; i + (1 << j) - 1 <= n; i++)\n        ST[i][j] = min(ST[i][j - 1], ST[i + (1 << j - 1)][j - 1]);\n    for (int i = 1, v, l; i <= n; i++) {\n      v = 0;\n      for (int j = 1; j < i; j++)\n        if (s[j] < s[i]) v = max(v, f[j][n]);\n      for (int j = i; j <= n; j++) f[i][j] = v + j - i + 1;\n      for (int j = 1; j < i; j++)\n        if (s[j] == s[i]) {\n          l = asklcp(j, i);\n          if (i + l <= n && s[i + l] > s[j + l])\n            f[i][i + l] = max(f[i][i + l], f[j][n] + 1);\n        }\n      for (int j = i; j <= n; j++)\n        f[i][j] = max(f[i][j], f[i][j - 1] + 1), ans = max(ans, f[i][j]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INF64 = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\ntypedef std::priority_queue<int, vector<int>, greater<int>> small_pq;\ntypedef std::priority_queue<int, vector<int>, less<int>> big_pq;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() {}\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  if (sizeof...(T) > 0) cerr << \" ,\";\n  dbg_out(T...);\n}\nvoid dbg_name(const string &s) {\n  string ss = s;\n  replace(ss.begin(), ss.end(), ',', ' ');\n  cerr << \"  ( \" << ss << \" )  \";\n}\ntemplate <typename T>\ninline void setmin(T &a, const T &b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\ninline void setmax(T &a, const T &b) {\n  if (b > a) a = b;\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nunordered_map<long long, int, custom_hash> safe_map;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::steady_clock::now().time_since_epoch().count());\nconst int MOD = 998244353;\nint mul(int x, int y) { return 1ll * x * y % MOD; }\nint add(int x, int y) { return ((x + y) % MOD + MOD) % MOD; }\nint sub(int x, int y) { return ((x - y) % MOD + MOD) % MOD; }\nint qpow(int a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = mul(ans, a);\n    a = mul(a, a);\n    b /= 2;\n  }\n  return ans;\n}\nconst int N = 1e4 + 5;\nnamespace Suffix {\nint sa[N], rk[N * 2], oldrk[N * 2], cnt[N * 2], id[N], px[N * 2];\nint ht[N];\nbool cmp(int x, int y, int w) {\n  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\nvoid suffix_array(char *s) {\n  memset(cnt, 0, sizeof(cnt));\n  memset(rk, 0, sizeof(rk));\n  memset(oldrk, 0, sizeof(oldrk));\n  int n = strlen(s + 1);\n  for (int i = 1; i <= n; i++) rk[i] = s[i];\n  int m = 300;\n  for (int i = 1; i <= n; i++) cnt[rk[i]]++;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;\n  for (int w = 1; w < n; w <<= 1) {\n    int p = 0;\n    for (int i = n; i > n - w; i--) id[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > w) id[++p] = sa[i] - w;\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 1; i <= n; i++) cnt[px[i] = rk[id[i]]]++;\n    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; i--) sa[cnt[px[i]]--] = id[i];\n    memcpy(oldrk, rk, sizeof(rk));\n    p = 0;\n    for (int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n    m = p;\n  }\n  for (int i = 1, k = 0; i <= n; i++) {\n    if (k) k--;\n    while ((i + k <= n) && s[i + k] == s[sa[rk[i] - 1] + k]) k++;\n    ht[rk[i]] = k;\n  }\n}\n}  // namespace Suffix\nconst int M = 14;\nchar s[N];\nint dp[N];\nint f[N][M];\nint calc(int i, int j) {\n  int s = log2(j - i + 1);\n  return min(f[i][s], f[j - (1 << s) + 1][s]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  using namespace Suffix;\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d %s\", &n, s + 1);\n    Suffix::suffix_array(s);\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      f[i][0] = Suffix::ht[i];\n    }\n    for (int(i) = int(1); int(i) <= int(M - 1); i++) {\n      for (int(j) = int(1); int(j) <= int(n); j++) {\n        f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n    int ans = 0;\n    for (int(i) = int(1); int(i) <= int(n); i++) {\n      dp[i] = n - i + 1;\n      for (int(j) = int(1); int(j) <= int(i - 1); j++) {\n        if (Suffix::rk[i] > Suffix::rk[j])\n          dp[i] = max(dp[i], dp[j] + (n - i + 1) - calc(rk[j] + 1, rk[i]));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n    fill(dp + 1, dp + 1 + n, 0);\n    for (int(i) = int(0); int(i) <= int(M - 1); i++)\n      for (int(j) = int(1); int(j) <= int(n); j++) f[j][i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input());s = input()[:-1];lcp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if s[i] == s[j]: lcp[i][j] = lcp[i + 1][j + 1] + 1\n    def cal(x, y):\n        t = lcp[x][y]\n        if y + t >= n: return -1\n        xc, yc = s[x + t], s[y + t]\n        if xc > yc: return -1\n        return t\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = n - i\n        for j in range(i):\n            x = cal(j, i)\n            if x != -1:dp[i] = max(dp[i], dp[j] + n - i - x)\n    print(max(dp))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[5010];\nnamespace Sa {\nint n, m = 26;\nint H[5010], rk[5010], rk2[5010], sa[5010], sa2[5010];\nint gg[5010];\nvoid sort() {\n  memset(gg, 0, sizeof(gg));\n  for (int i = 1; i <= n; i++) ++gg[rk[i]];\n  for (int i = 1; i <= m; i++) gg[i] += gg[i - 1];\n  for (int i = n; i >= 1; i--) sa[gg[rk[sa2[i]]]--] = sa2[i];\n}\nvoid HH() {\n  memset(H, 0, sizeof(H));\n  int k = 0;\n  for (int i = 1; i <= n; i++) {\n    if (rk[i] == 1) {\n      k = H[1] = 0;\n      continue;\n    }\n    if (k) --k;\n    int j = sa[rk[i] - 1];\n    while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) ++k;\n    H[rk[i]] = k;\n  }\n}\nvoid SA() {\n  for (int i = 1; i <= n; i++) {\n    rk[i] = s[i] - 'a' + 1;\n    sa2[i] = i;\n  }\n  sort();\n  for (int d = 1; d < n; d <<= 1) {\n    int p = 0;\n    for (int i = n - d + 1; i <= n; i++) sa2[++p] = i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > d) sa2[++p] = sa[i] - d;\n    sort();\n    rk2[sa[1]] = p = 1;\n    for (int i = 2; i <= n; i++) {\n      if (rk[sa[i]] != rk[sa[i - 1]] || rk[sa[i] + d] != rk[sa[i - 1] + d]) ++p;\n      rk2[sa[i]] = p;\n    }\n    for (int i = 1; i <= n; i++) rk[i] = rk2[i];\n    m = p;\n    if (m == n) break;\n  }\n  HH();\n}\n}  // namespace Sa\nusing namespace Sa;\nint lg[5010], mn[5010][30];\nint Min(int l, int r) {\n  int len = (r - l + 1);\n  len = lg[len];\n  return min(mn[l][len], mn[r - (1 << len) + 1][len]);\n}\nint lcp(int x, int y) {\n  x = rk[x];\n  y = rk[y];\n  if (x > y) swap(x, y);\n  return Min(x + 1, y);\n}\nint dp[5010];\nvoid init() {\n  memset(mn, 0, sizeof(mn));\n  memset(dp, 0, sizeof(dp));\n  memset(sa, 0, sizeof(sa));\n  memset(sa2, 0, sizeof(sa2));\n  memset(rk, 0, sizeof(rk));\n  memset(rk2, 0, sizeof(rk2));\n}\nsigned main() {\n  int T;\n  scanf(\"%d\", &T);\n  lg[0] = -1;\n  for (int i = 1; i <= 5000; i++) lg[i] = lg[i >> 1] + 1;\n  int Now = 0;\n  while (T--) {\n    ++Now;\n    init();\n    scanf(\"%d\", &n);\n    m = 26;\n    scanf(\" %s\", s + 1);\n    SA();\n    for (int i = 1; i <= n; i++) mn[i][0] = H[i];\n    for (int L = 1; L <= lg[n]; L++)\n      for (int i = 1; i <= n; i++)\n        mn[i][L] = min(mn[i][L - 1], mn[i + (1 << (L - 1))][L - 1]);\n    dp[1] = n;\n    dp[0] = 0;\n    int mx = n;\n    for (int i = 2; i <= n; i++) {\n      dp[i] = n - i + 1;\n      for (int j = 1; j < i; j++)\n        if (rk[i] > rk[j]) {\n          dp[i] = max(dp[i], dp[j] + n - i + 1 - lcp(i, j));\n        }\n      mx = max(mx, dp[i]);\n    }\n    printf(\"%d\\n\", mx);\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfor _ in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    s = sys.stdin.readline().strip()\n    d = [0] * n\n    l = [0] * (n+1)\n    for i in range(n-1, -1, -1):\n        for j in range(i+1, n):\n            if s[i] < s[j]: d[i] = max(d[i], d[j]) \n            if s[i] == s[j]:\n                l[j] = l[j+1] + 1\n                if j + l[j] < n and s[i+l[j]] < s[j+l[j]]:\n                    d[i] = max(d[i], d[j] - l[j])\n            else:l[j] = 0\n        d[i] += n - i\n    sys.stdout.write(\"%d\\n\" % max(d))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nnamespace atcoder {\nnamespace internal {\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n  int n = int(s.size());\n  std::vector<int> sa(n);\n  std::iota(sa.begin(), sa.end(), 0);\n  std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n    if (l == r) return false;\n    while (l < n && r < n) {\n      if (s[l] != s[r]) return s[l] < s[r];\n      l++;\n      r++;\n    }\n    return l == n;\n  });\n  return sa;\n}\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n  int n = int(s.size());\n  std::vector<int> sa(n), rnk = s, tmp(n);\n  std::iota(sa.begin(), sa.end(), 0);\n  for (int k = 1; k < n; k *= 2) {\n    auto cmp = [&](int x, int y) {\n      if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n      int rx = x + k < n ? rnk[x + k] : -1;\n      int ry = y + k < n ? rnk[y + k] : -1;\n      return rx < ry;\n    };\n    std::sort(sa.begin(), sa.end(), cmp);\n    tmp[sa[0]] = 0;\n    for (int i = 1; i < n; i++) {\n      tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n    }\n    std::swap(tmp, rnk);\n  }\n  return sa;\n}\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n  int n = int(s.size());\n  if (n == 0) return {};\n  if (n == 1) return {0};\n  if (n == 2) {\n    if (s[0] < s[1]) {\n      return {0, 1};\n    } else {\n      return {1, 0};\n    }\n  }\n  if (n < THRESHOLD_NAIVE) {\n    return sa_naive(s);\n  }\n  if (n < THRESHOLD_DOUBLING) {\n    return sa_doubling(s);\n  }\n  std::vector<int> sa(n);\n  std::vector<bool> ls(n);\n  for (int i = n - 2; i >= 0; i--) {\n    ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n  }\n  std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n  for (int i = 0; i < n; i++) {\n    if (!ls[i]) {\n      sum_s[s[i]]++;\n    } else {\n      sum_l[s[i] + 1]++;\n    }\n  }\n  for (int i = 0; i <= upper; i++) {\n    sum_s[i] += sum_l[i];\n    if (i < upper) sum_l[i + 1] += sum_s[i];\n  }\n  auto induce = [&](const std::vector<int>& lms) {\n    std::fill(sa.begin(), sa.end(), -1);\n    std::vector<int> buf(upper + 1);\n    std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n    for (auto d : lms) {\n      if (d == n) continue;\n      sa[buf[s[d]]++] = d;\n    }\n    std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n    sa[buf[s[n - 1]]++] = n - 1;\n    for (int i = 0; i < n; i++) {\n      int v = sa[i];\n      if (v >= 1 && !ls[v - 1]) {\n        sa[buf[s[v - 1]]++] = v - 1;\n      }\n    }\n    std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n    for (int i = n - 1; i >= 0; i--) {\n      int v = sa[i];\n      if (v >= 1 && ls[v - 1]) {\n        sa[--buf[s[v - 1] + 1]] = v - 1;\n      }\n    }\n  };\n  std::vector<int> lms_map(n + 1, -1);\n  int m = 0;\n  for (int i = 1; i < n; i++) {\n    if (!ls[i - 1] && ls[i]) {\n      lms_map[i] = m++;\n    }\n  }\n  std::vector<int> lms;\n  lms.reserve(m);\n  for (int i = 1; i < n; i++) {\n    if (!ls[i - 1] && ls[i]) {\n      lms.push_back(i);\n    }\n  }\n  induce(lms);\n  if (m) {\n    std::vector<int> sorted_lms;\n    sorted_lms.reserve(m);\n    for (int v : sa) {\n      if (lms_map[v] != -1) sorted_lms.push_back(v);\n    }\n    std::vector<int> rec_s(m);\n    int rec_upper = 0;\n    rec_s[lms_map[sorted_lms[0]]] = 0;\n    for (int i = 1; i < m; i++) {\n      int l = sorted_lms[i - 1], r = sorted_lms[i];\n      int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n      int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n      bool same = true;\n      if (end_l - l != end_r - r) {\n        same = false;\n      } else {\n        while (l < end_l) {\n          if (s[l] != s[r]) {\n            break;\n          }\n          l++;\n          r++;\n        }\n        if (l == n || s[l] != s[r]) same = false;\n      }\n      if (!same) rec_upper++;\n      rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n    }\n    auto rec_sa = sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n    for (int i = 0; i < m; i++) {\n      sorted_lms[i] = lms[rec_sa[i]];\n    }\n    induce(sorted_lms);\n  }\n  return sa;\n}\n}  // namespace internal\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n  assert(0 <= upper);\n  for (int d : s) {\n    assert(0 <= d && d <= upper);\n  }\n  auto sa = internal::sa_is(s, upper);\n  return sa;\n}\ntemplate <class T>\nstd::vector<int> suffix_array(const std::vector<T>& s) {\n  int n = int(s.size());\n  std::vector<int> idx(n);\n  iota(idx.begin(), idx.end(), 0);\n  sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n  std::vector<int> s2(n);\n  int now = 0;\n  for (int i = 0; i < n; i++) {\n    if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n    s2[idx[i]] = now;\n  }\n  return internal::sa_is(s2, now);\n}\nstd::vector<int> suffix_array(const std::string& s) {\n  int n = int(s.size());\n  std::vector<int> s2(n);\n  for (int i = 0; i < n; i++) {\n    s2[i] = s[i];\n  }\n  return internal::sa_is(s2, 255);\n}\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n  int n = int(s.size());\n  assert(n >= 1);\n  std::vector<int> rnk(n);\n  for (int i = 0; i < n; i++) {\n    rnk[sa[i]] = i;\n  }\n  std::vector<int> lcp(n - 1);\n  int h = 0;\n  for (int i = 0; i < n; i++) {\n    if (h > 0) h--;\n    if (rnk[i] == 0) continue;\n    int j = sa[rnk[i] - 1];\n    for (; j + h < n && i + h < n; h++) {\n      if (s[j + h] != s[i + h]) break;\n    }\n    lcp[rnk[i] - 1] = h;\n  }\n  return lcp;\n}\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n  int n = int(s.size());\n  std::vector<int> s2(n);\n  for (int i = 0; i < n; i++) {\n    s2[i] = s[i];\n  }\n  return lcp_array(s2, sa);\n}\ntemplate <class T>\nstd::vector<int> z_algorithm(const std::vector<T>& s) {\n  int n = int(s.size());\n  if (n == 0) return {};\n  std::vector<int> z(n);\n  z[0] = 0;\n  for (int i = 1, j = 0; i < n; i++) {\n    int& k = z[i];\n    k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n    while (i + k < n && s[k] == s[i + k]) k++;\n    if (j + z[j] < i + z[i]) j = i;\n  }\n  z[0] = n;\n  return z;\n}\nstd::vector<int> z_algorithm(const std::string& s) {\n  int n = int(s.size());\n  std::vector<int> s2(n);\n  for (int i = 0; i < n; i++) {\n    s2[i] = s[i];\n  }\n  return z_algorithm(s2);\n}\n}  // namespace atcoder\nint hash[5010], DP[5010];\nchar x[5010];\nint check[5010];\nstd::vector<char> V;\nstd::vector<int> SA, LCP;\nint main() {\n  int Case;\n  scanf(\"%d\", &Case);\n  while (Case--) {\n    V.clear();\n    int a;\n    scanf(\"%d\", &a);\n    scanf(\"%s\", x + 1);\n    for (int i = 1; i <= a; i++) V.push_back(x[i]);\n    SA = atcoder::suffix_array<char>(V);\n    LCP = atcoder::lcp_array<char>(V, SA);\n    for (int i = 0; i < SA.size(); i++) hash[SA[i] + 1] = i + 1;\n    for (int i = a; i >= 1; i--) {\n      int S = a - i + 1;\n      DP[i] = S;\n      check[hash[i]] = a;\n      for (int j = hash[i] + 1; j <= a; j++)\n        check[j] = check[j - 1] < LCP[j - 2] ? check[j - 1] : LCP[j - 2];\n      for (int j = i + 1; j <= a; j++) {\n        if (hash[i] < hash[j]) {\n          int t = check[hash[j]];\n          DP[i] = DP[i] > S + DP[j] - t ? DP[i] : S + DP[j] - t;\n        }\n      }\n    }\n    int max = 0;\n    for (int i = 1; i <= a; i++) max = max > DP[i] ? max : DP[i];\n    printf(\"%d\\n\", max);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << H;\n  debug_out(T...);\n}\nconst int N = 5010, P1 = 131, mod1 = 1e9 + 9;\null h1[N], px1[N];\nll d[N];\nchar s[N];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    int n;\n    cin >> n >> s;\n    px1[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      d[i] = n - i + 1;\n      h1[i] = (h1[i - 1] * P1 + s[i - 1]);\n      px1[i] = px1[i - 1] * P1;\n    }\n    ll res = 0;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j < i; j++) {\n        if (s[i - 1] > s[j - 1]) {\n          d[i] = max(d[i], d[j] + n - i + 1);\n        } else if (s[i - 1] == s[j - 1]) {\n          int l = 1, r = n - i + 1;\n          while (l < r) {\n            int mid = (l + r + 1) >> 1;\n            if (h1[i + mid - 1] - h1[i - 1] * px1[mid] ==\n                h1[j + mid - 1] - h1[j - 1] * px1[mid])\n              l = mid;\n            else\n              r = mid - 1;\n          }\n          if (s[i + r - 1] > s[j + r - 1])\n            d[i] = max(d[i], d[j] + n - i + 1 - r);\n        }\n      }\n      res = max(res, d[i]);\n    }\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5000 + 10;\nchar s[N];\nint lcp[N][N], n;\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d%s\", &n, s + 1);\n    for (int i = 0; i <= n + 1; i++)\n      for (int j = 0; j <= n + 1; j++) lcp[i][j] = 0;\n    for (int i = n; i >= 1; i--) {\n      for (int j = n; j >= 1; j--) {\n        lcp[i][j] = ((s[i] == s[j]) ? (lcp[i + 1][j + 1] + 1) : 0);\n      }\n    }\n    auto ok = [&](int i, int j) {\n      if (j + lcp[i][j] == n + 1) return false;\n      return s[i + lcp[i][j]] < s[j + lcp[i][j]];\n    };\n    vector<int> dp(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n      dp[i] = n - i + 1;\n      for (int j = 1; j < i; j++) {\n        if (ok(j, i)) {\n          dp[i] = max(dp[i], dp[j] + n - i + 1 - lcp[j][i]);\n        }\n      }\n    }\n    int ans = *max_element(dp.begin() + 1, dp.end());\n    printf(\"%d\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass rmq_sa {\n  vector<int> v;\n  vector<vector<int>> b;\n  int f(int i, int j) { return v[i] < v[j] ? i : j; }\n\n public:\n  rmq_sa() {}\n  rmq_sa(vector<int> _v) : v(_v) {\n    int n = v.size();\n    int m = 32 - __builtin_clz(n);\n    b = vector<vector<int>>(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n      b[i][0] = i;\n    }\n    for (int j = 1; j < m; ++j) {\n      for (int i = 0; i < n - (1 << j) + 1; ++i) {\n        b[i][j] = f(b[i][j - 1], b[i + (1 << (j - 1))][j - 1]);\n      }\n    }\n  }\n  int query(int l, int r) {\n    int x = floor(log2(r - l));\n    return f(b[l][x], b[r - (1 << x)][x]);\n  }\n};\nclass suffix_array {\n  vector<int> sa;\n  vector<int> lcp_;\n  vector<int> sr;\n  int n;\n  rmq_sa st;\n\n public:\n  suffix_array() {}\n  suffix_array(const vector<int> &a)\n      : n(a.size()), sa(a.size() + 1), lcp_(a.size()), sr(a.size() + 1) {\n    sa[0] = n;\n    iota(sa.begin() + 1, sa.end(), 0);\n    sort(sa.begin() + 1, sa.end(), [&](int i, int j) { return a[i] < a[j]; });\n    for (int i = 1; i <= n; ++i) {\n      sr[sa[i]] = i > 1 && a[sa[i]] == a[sa[i - 1]] ? sr[sa[i - 1]] : i;\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      vector<int> t(sa);\n      vector<int> tr(sr);\n      vector<int> p(n + 1);\n      iota(p.begin(), p.end(), 0);\n      for (int i : t) {\n        if (i >= k) {\n          sa[p[sr[i - k]]++] = i - k;\n        }\n      }\n      for (int i = 1; i <= n; ++i) {\n        sr[sa[i]] =\n            tr[sa[i]] == tr[sa[i - 1]] && tr[sa[i] + k] == tr[sa[i - 1] + k]\n                ? sr[sa[i - 1]]\n                : i;\n      }\n    }\n    for (int i = 0, l = 0; i < n; lcp_[sr[i++] - 1] = l, l && l--) {\n      for (int j = sa[sr[i] - 1]; j + l < n && a[i + l] == a[j + l]; ++l)\n        ;\n    }\n    st = rmq_sa(lcp_);\n  }\n  int lcp(int i, int j) {\n    if (i == j) {\n      return n - i;\n    }\n    i = sr[i];\n    j = sr[j];\n    if (i > j) {\n      swap(i, j);\n    }\n    return lcp_[st.query(i, j)];\n  }\n  int operator[](int i) { return sa[i]; }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n      a[i] = s[i] - 'a';\n    }\n    vector<int> dp(n);\n    suffix_array sa(a);\n    for (int i = 0; i < n; ++i) {\n      dp[i] = n - i;\n      for (int j = 0; j < i; ++j) {\n        int lcp = sa.lcp(i, j);\n        if (i + lcp < n && s[j + lcp] < s[i + lcp]) {\n          dp[i] = max(dp[i], dp[j] + (n - lcp - i));\n        }\n      }\n    }\n    cout << *max_element(dp.begin(), dp.end()) << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::fixed;\nusing std::ios_base;\nusing std::max;\nusing std::min;\nusing std::priority_queue;\nusing std::sort;\nusing std::stack;\nusing std::string;\nusing std::vector;\nshort kmp[10050][10050];\nint dp[10050];\ninline bool compare(int i, int j, const string& s) {\n  if (kmp[i][j] == s.size() - i)\n    return false;\n  else\n    return s[i + kmp[i][j]] > s[j + kmp[i][j]];\n}\ninline int cal(int i, int j, const string& s) {\n  if (compare(i, j, s))\n    return dp[j] + s.size() - i - kmp[i][j];\n  else\n    return 0;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int t;\n  cin >> t;\n  for (; t > 0; t--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    for (int i = 0; i <= n; i++)\n      for (int j = 0; j <= n; j++) kmp[i][j] = 0;\n    for (int i = n - 1; i >= 0; i--) {\n      for (int j = n - 1; j >= 0; j--) {\n        if (i == j)\n          kmp[i][j] = n - i;\n        else {\n          if (s[i] != s[j])\n            kmp[i][j] = 0;\n          else\n            kmp[i][j] = kmp[i + 1][j + 1] + 1;\n        }\n      }\n    }\n    int ans = n;\n    dp[0] = n;\n    for (int i = 1; i < n; i++) {\n      dp[i] = n - i;\n      for (int j = 0; j < i; j++) {\n        dp[i] = max(dp[i], cal(i, j, s));\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f;\nconst long long P = 998244353;\nconst long long N = 5000 + 10;\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long T;\n  cin >> T;\n  while (T--) {\n    long long n;\n    string s;\n    cin >> n >> s;\n    vector<vector<long long> > lcp(n + 1, vector<long long>(n + 1));\n    vector<long long> dp(n + 1);\n    for (long long i = n - 1; i >= 0; i--) {\n      for (long long j = n - 1; j >= 0; j--) {\n        if (i == j)\n          lcp[i][j] = n - i;\n        else if (s[i] != s[j])\n          lcp[i][j] = 0;\n        else\n          lcp[i][j] = lcp[i + 1][j + 1] + 1;\n      }\n    }\n    long long ans = 0;\n    for (long long i = 0; i < n; i++) {\n      dp[i] = n - i;\n      for (long long j = 0; j < i; j++) {\n        if (lcp[i][j] < n - i && s[i + lcp[i][j]] > s[j + lcp[i][j]]) {\n          dp[i] = max(dp[i], dp[j] + n - i - lcp[i][j]);\n        }\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class c>\nstruct rge {\n  c b, e;\n};\ntemplate <class c>\nrge<c> range(c i, c j) {\n  return rge<c>{i, j};\n}\ntemplate <class c>\nauto dud(c* x) -> decltype(cerr << *x, 0);\ntemplate <class c>\nchar dud(...);\nstruct debug {\n  template <class c>\n  debug& operator<<(const c&) {\n    return *this;\n  }\n};\nvector<char*> tokenizer(const char* args) {\n  char* token = new char[111];\n  strcpy(token, args);\n  token = strtok(token, \", \");\n  vector<char*> v({token});\n  while (token = strtok(NULL, \", \")) v.push_back(token);\n  return reverse(v.begin(), v.end()), v;\n}\nvoid debugg(vector<char*> args) { cerr << \"\\b\\b \"; }\ntemplate <typename Head, typename... Tail>\nvoid debugg(vector<char*> args, Head H, Tail... T) {\n  debug() << \" [\" << args.back() << \": \" << H << \"] \";\n  args.pop_back();\n  debugg(args, T...);\n}\nconst int mod = 1e9 + 7;\nconst int MX = 0x3f3f3f3f;\nconst int maxn = 5e3 + 1;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, i, j;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<vector<int> > lcp(n, vector<int>(n));\n    for (i = n - 1; i >= 0; i--) {\n      for (j = n - 1; j >= 0; j--) {\n        if (s[i] == s[j])\n          lcp[i][j] = 1 + (i + 1 < n and j + 1 < n ? lcp[i + 1][j + 1] : 0);\n      }\n    }\n    vector<int> dp(n);\n    dp[0] = n;\n    for (i = 1; i <= n - 1; i++) {\n      dp[i] = n - i;\n      for (j = 0; j <= i - 1; j++) {\n        if (s[j] < s[i])\n          dp[i] = max(dp[i], dp[j] + n - i);\n        else if (s[i] == s[j]) {\n          if (lcp[i][j] + i < n and s[i + lcp[i][j]] > s[j + lcp[i][j]])\n            dp[i] = max(dp[i], dp[j] + n - i - lcp[i][j]);\n        }\n      }\n    }\n    cout << *max_element((dp).begin(), (dp).end()) << \"\\n\";\n  }\n  return 0;\n}\n"
        }
    ]
}