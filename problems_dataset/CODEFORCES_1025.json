{
    "name": "1025_B. Weakened Common Divisor",
    "source": "CODEFORCES",
    "description": "During the research on properties of the greatest common divisor (GCD) of a set of numbers, Ildar, a famous mathematician, introduced a brand new concept of the weakened common divisor (WCD) of a list of pairs of integers.\n\nFor a given list of pairs of integers (a_1, b_1), (a_2, b_2), ..., (a_n, b_n) their WCD is arbitrary integer greater than 1, such that it divides at least one element in each pair. WCD may not exist for some lists.\n\nFor example, if the list looks like [(12, 15), (25, 18), (10, 24)], then their WCD can be equal to 2, 3, 5 or 6 (each of these numbers is strictly greater than 1 and divides at least one number in each pair).\n\nYou're currently pursuing your PhD degree under Ildar's mentorship, and that's why this problem was delegated to you. Your task is to calculate WCD efficiently.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 150 000) \u2014 the number of pairs.\n\nEach of the next n lines contains two integer values a_i, b_i (2 \u2264 a_i, b_i \u2264 2 \u22c5 10^9).\n\nOutput\n\nPrint a single integer \u2014 the WCD of the set of pairs. \n\nIf there are multiple possible answers, output any; if there is no answer, print -1.\n\nExamples\n\nInput\n\n3\n17 18\n15 24\n12 15\n\n\nOutput\n\n6\n\nInput\n\n2\n10 16\n7 17\n\n\nOutput\n\n-1\n\n\nInput\n\n5\n90 108\n45 105\n75 40\n165 175\n33 30\n\n\nOutput\n\n5\n\nNote\n\nIn the first example the answer is 6 since it divides 18 from the first pair, 24 from the second and 12 from the third ones. Note that other valid answers will also be accepted.\n\nIn the second example there are no integers greater than 1 satisfying the conditions.\n\nIn the third example one of the possible answers is 5. Note that, for example, 15 is also allowed, but it's not necessary to maximize the output.",
    "difficulty": "B",
    "tags": [
        "brute force",
        "greedy",
        "number theory"
    ],
    "rating": 1600,
    "public_test": [
        {
            "input": "2\n10 16\n7 17\n",
            "output": "-1\n"
        },
        {
            "input": "3\n17 18\n15 24\n12 15\n",
            "output": "2\n"
        },
        {
            "input": "5\n90 108\n45 105\n75 40\n165 175\n33 30\n",
            "output": "3\n"
        }
    ],
    "generated_test": [
        {
            "input": "3\n14 16\n2 7\n2 2\n",
            "output": "2"
        },
        {
            "input": "30\n3 3\n2 2\n4 4\n8 8\n16 16\n32 32\n64 64\n128 128\n256 256\n512 512\n1024 1024\n2048 2048\n4096 4096\n8192 8192\n16384 2874\n32768 32768\n65536 65536\n131072 131072\n262144 262144\n524288 524288\n1048576 1048576\n2097152 2097152\n4194304 4194304\n8388608 8388608\n16777216 16777216\n33554432 33554432\n67108864 67108864\n134217728 134217728\n268435456 268435456\n536870912 536870912\n",
            "output": "-1"
        },
        {
            "input": "1\n9 9\n",
            "output": "3"
        },
        {
            "input": "2\n1999349071 1795255007\n1999608911 1999349071\n",
            "output": "1999349071"
        },
        {
            "input": "3\n5 2\n35 3\n5 7\n",
            "output": "5"
        },
        {
            "input": "3\n1000000007 1000000009\n1000000007 670426906\n1000000007 1000000009\n",
            "output": "1000000007"
        },
        {
            "input": "2\n633036307 99999989\n1000000007 99999989\n",
            "output": "99999989"
        },
        {
            "input": "2\n7 7\n7 11\n",
            "output": "7"
        },
        {
            "input": "2\n1999999973 1999999943\n1999999973 3307670896\n",
            "output": "1999999973"
        },
        {
            "input": "2\n1999608911 1999132361\n527030656 1999608911\n",
            "output": "1999608911"
        },
        {
            "input": "3\n25 15\n125 375\n3 1\n",
            "output": "3"
        },
        {
            "input": "3\n4 3\n3 4\n4 2\n",
            "output": "2"
        },
        {
            "input": "2\n6 6\n4 15\n",
            "output": "2"
        },
        {
            "input": "5\n11 30\n30 30\n2 30\n4 5\n3 3\n",
            "output": "-1"
        },
        {
            "input": "3\n6 6\n2 2\n2 1\n",
            "output": "2"
        },
        {
            "input": "3\n6 60\n10 21\n5 5\n",
            "output": "5"
        },
        {
            "input": "3\n5 8\n125 3\n3 3\n",
            "output": "-1"
        },
        {
            "input": "3\n3 6\n7 3\n2 2\n",
            "output": "-1"
        },
        {
            "input": "3\n3 4\n3 6\n7 2\n",
            "output": "2"
        },
        {
            "input": "3\n10 4\n15 2\n2 2\n",
            "output": "2"
        },
        {
            "input": "5\n90 108\n45 105\n75 40\n165 141\n33 30\n",
            "output": "3"
        },
        {
            "input": "2\n15 81\n3 45\n",
            "output": "3"
        },
        {
            "input": "3\n15 15\n3 5\n3 4\n",
            "output": "3"
        },
        {
            "input": "2\n3 3\n6 7\n",
            "output": "3"
        },
        {
            "input": "3\n3 5\n3 5\n5 3\n",
            "output": "3"
        },
        {
            "input": "3\n6 7\n2 3\n4 13\n",
            "output": "2"
        },
        {
            "input": "3\n6 6\n4 2\n2 2\n",
            "output": "2"
        },
        {
            "input": "3\n18 18\n15 24\n12 15\n",
            "output": "2"
        },
        {
            "input": "2\n2 3\n2 4\n",
            "output": "2"
        },
        {
            "input": "2\n3 3\n1 9\n",
            "output": "3"
        },
        {
            "input": "2\n1000000007 1908191807\n1000000007 1000000007\n",
            "output": "1000000007"
        },
        {
            "input": "3\n6 6\n2 1\n6 6\n",
            "output": "2"
        },
        {
            "input": "2\n21 35\n33 115\n",
            "output": "3"
        },
        {
            "input": "2\n10 14\n7 17\n",
            "output": "7"
        },
        {
            "input": "3\n17 18\n15 24\n1 15\n",
            "output": "3"
        },
        {
            "input": "5\n90 108\n45 105\n75 39\n165 175\n33 30\n",
            "output": "3"
        },
        {
            "input": "3\n14 16\n2 7\n4 2\n",
            "output": "2"
        },
        {
            "input": "30\n3 3\n2 2\n4 4\n8 8\n16 16\n32 32\n64 64\n128 128\n256 256\n512 512\n1024 1024\n2048 2048\n4096 4096\n8192 8192\n16384 2874\n32768 25901\n65536 65536\n131072 131072\n262144 262144\n524288 524288\n1048576 1048576\n2097152 2097152\n4194304 4194304\n8388608 8388608\n16777216 16777216\n33554432 33554432\n67108864 67108864\n134217728 134217728\n268435456 268435456\n536870912 536870912\n",
            "output": "-1"
        },
        {
            "input": "3\n25 15\n216 375\n3 1\n",
            "output": "3"
        },
        {
            "input": "3\n5 2\n48 3\n5 7\n",
            "output": "-1"
        },
        {
            "input": "3\n4 3\n5 4\n4 2\n",
            "output": "2"
        },
        {
            "input": "2\n2 6\n4 15\n",
            "output": "2"
        },
        {
            "input": "5\n11 30\n30 30\n2 30\n4 3\n3 3\n",
            "output": "3"
        },
        {
            "input": "3\n6 7\n2 2\n2 1\n",
            "output": "2"
        },
        {
            "input": "3\n6 60\n10 21\n2 5\n",
            "output": "2"
        },
        {
            "input": "3\n10 8\n125 3\n3 3\n",
            "output": "-1"
        },
        {
            "input": "3\n3 6\n7 4\n2 2\n",
            "output": "2"
        },
        {
            "input": "3\n3 4\n3 7\n7 2\n",
            "output": "-1"
        },
        {
            "input": "3\n10 4\n15 2\n2 3\n",
            "output": "2"
        },
        {
            "input": "5\n90 108\n45 105\n47 40\n165 141\n33 30\n",
            "output": "5"
        },
        {
            "input": "2\n15 81\n6 45\n",
            "output": "3"
        },
        {
            "input": "3\n15 8\n3 5\n3 4\n",
            "output": "3"
        },
        {
            "input": "3\n1000000007 540669842\n1000000007 670426906\n1000000007 1000000009\n",
            "output": "1000000007"
        },
        {
            "input": "2\n633036307 99999989\n1000000007 190005028\n",
            "output": "-1"
        },
        {
            "input": "2\n7 5\n7 11\n",
            "output": "7"
        },
        {
            "input": "3\n3 5\n3 5\n5 1\n",
            "output": "5"
        },
        {
            "input": "3\n6 7\n2 2\n4 13\n",
            "output": "2"
        },
        {
            "input": "3\n6 6\n4 3\n2 2\n",
            "output": "2"
        },
        {
            "input": "3\n18 18\n29 24\n12 15\n",
            "output": "2"
        },
        {
            "input": "2\n4 3\n1 9\n",
            "output": "3"
        },
        {
            "input": "2\n1093149161 1908191807\n1000000007 1000000007\n",
            "output": "-1"
        },
        {
            "input": "2\n1999999973 1999999943\n228824878 3307670896\n",
            "output": "-1"
        },
        {
            "input": "3\n6 6\n1 1\n6 6\n",
            "output": "-1"
        },
        {
            "input": "2\n10 14\n6 17\n",
            "output": "2"
        },
        {
            "input": "3\n17 18\n15 32\n1 15\n",
            "output": "3"
        },
        {
            "input": "3\n14 16\n4 7\n4 2\n",
            "output": "2"
        },
        {
            "input": "30\n3 3\n2 2\n4 4\n8 8\n16 16\n32 32\n64 64\n128 128\n256 256\n512 512\n1024 1024\n2048 2048\n4096 4096\n8192 8192\n16384 2874\n32768 25901\n65536 65536\n131072 131072\n262144 262144\n524288 524288\n1048576 1048576\n2097152 2097152\n40319 4194304\n8388608 8388608\n16777216 16777216\n33554432 33554432\n67108864 67108864\n134217728 134217728\n268435456 268435456\n536870912 536870912\n",
            "output": "-1"
        },
        {
            "input": "3\n25 14\n216 375\n3 1\n",
            "output": "-1"
        },
        {
            "input": "3\n4 3\n5 4\n5 2\n",
            "output": "2"
        },
        {
            "input": "2\n2 6\n4 9\n",
            "output": "2"
        },
        {
            "input": "5\n11 41\n30 30\n2 30\n4 3\n3 3\n",
            "output": "-1"
        },
        {
            "input": "3\n6 7\n1 2\n2 1\n",
            "output": "2"
        },
        {
            "input": "3\n6 60\n10 1\n2 5\n",
            "output": "2"
        },
        {
            "input": "3\n10 8\n125 3\n3 4\n",
            "output": "-1"
        },
        {
            "input": "3\n3 6\n7 4\n2 3\n",
            "output": "2"
        },
        {
            "input": "5\n90 108\n45 105\n47 41\n165 141\n33 30\n",
            "output": "-1"
        },
        {
            "input": "3\n2 8\n3 5\n3 4\n",
            "output": "-1"
        },
        {
            "input": "3\n226674169 540669842\n1000000007 670426906\n1000000007 1000000009\n",
            "output": "-1"
        },
        {
            "input": "2\n633036307 99999989\n1000000007 379325178\n",
            "output": "-1"
        },
        {
            "input": "2\n7 5\n5 11\n",
            "output": "5"
        },
        {
            "input": "3\n8 6\n4 3\n2 2\n",
            "output": "2"
        },
        {
            "input": "3\n18 18\n57 24\n12 15\n",
            "output": "2"
        },
        {
            "input": "2\n4 3\n1 11\n",
            "output": "-1"
        },
        {
            "input": "2\n1999999973 1999999943\n228824878 4342509198\n",
            "output": "-1"
        },
        {
            "input": "3\n8 6\n1 1\n6 6\n",
            "output": "-1"
        },
        {
            "input": "3\n17 18\n15 33\n1 15\n",
            "output": "3"
        },
        {
            "input": "3\n14 16\n8 7\n4 2\n",
            "output": "2"
        },
        {
            "input": "30\n3 3\n2 2\n4 4\n8 8\n18 16\n32 32\n64 64\n128 128\n256 256\n512 512\n1024 1024\n2048 2048\n4096 4096\n8192 8192\n16384 2874\n32768 25901\n65536 65536\n131072 131072\n262144 262144\n524288 524288\n1048576 1048576\n2097152 2097152\n40319 4194304\n8388608 8388608\n16777216 16777216\n33554432 33554432\n67108864 67108864\n134217728 134217728\n268435456 268435456\n536870912 536870912\n",
            "output": "-1"
        },
        {
            "input": "3\n25 14\n38 375\n3 1\n",
            "output": "-1"
        },
        {
            "input": "3\n4 3\n5 6\n5 2\n",
            "output": "2"
        },
        {
            "input": "2\n2 6\n6 9\n",
            "output": "2"
        },
        {
            "input": "3\n6 7\n1 2\n2 2\n",
            "output": "2"
        },
        {
            "input": "3\n6 60\n1 1\n2 5\n",
            "output": "-1"
        },
        {
            "input": "3\n10 15\n125 3\n3 4\n",
            "output": "3"
        },
        {
            "input": "3\n3 6\n7 7\n2 3\n",
            "output": "-1"
        },
        {
            "input": "5\n90 42\n45 105\n47 41\n165 141\n33 30\n",
            "output": "-1"
        },
        {
            "input": "3\n240894495 540669842\n1000000007 670426906\n1000000007 1000000009\n",
            "output": "-1"
        },
        {
            "input": "2\n633036307 99999989\n1369311470 379325178\n",
            "output": "-1"
        },
        {
            "input": "2\n7 5\n5 13\n",
            "output": "5"
        },
        {
            "input": "3\n18 18\n57 24\n10 15\n",
            "output": "2"
        }
    ],
    "solution": [
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.stream.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main { \n    \n    static boolean FROM_FILE = false;\n    \n    static class FastReader { \n        BufferedReader br; \n        StringTokenizer st; \n        public FastReader() { \n            if (FROM_FILE) {\n                try {\n                    br = new BufferedReader(new FileReader(\"input.txt\")); \n                } catch (IOException error) {\n                }   \n            } else {\n                br = new BufferedReader(new InputStreamReader(System.in));    \n            }\n        }\n        String next() { \n            while (st == null || !st.hasMoreElements()) { \n                try { \n                    st = new StringTokenizer(br.readLine()); \n                } catch (IOException  e) { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        }\n        int nextInt() { \n            return Integer.parseInt(next()); \n        }\n        long nextLong() { \n            return Long.parseLong(next()); \n        }\n  \n        double nextDouble() { \n            return Double.parseDouble(next()); \n        } \n        String nextLine() { \n            String str = \"\"; \n            try { \n                str = br.readLine(); \n            } catch (IOException e) { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n    static int max(int... nums) {\n        int res = Integer.MIN_VALUE;\n        for (int num: nums) res = Math.max(res, num);\n        return res;\n    }\n    static int min(int... nums) {\n        int res = Integer.MAX_VALUE;\n        for (int num: nums) res = Math.min(res, num);\n        return res;\n    }\n    static long max(long... nums) {\n        long res = Long.MIN_VALUE;\n        for (long num: nums) res = Math.max(res, num);\n        return res;\n    }\n    static long min(long... nums) {\n        long res = Long.MAX_VALUE;\n        for (long num: nums) res = Math.min(res, num);\n        return res;\n    }\n    \n    static FastReader fr = new FastReader();\n    static PrintWriter out;\n    \n    public static void main(String[] args) { \n        if (FROM_FILE) {\n            try {\n                out = new PrintWriter(new FileWriter(\"output.txt\"));\n            } catch (IOException error) {\n                \n            }\n        } else {\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n        }\n        new Main().run();\n        out.flush();\n        out.close();\n    } \n    \n    int gcd(int a, int b) {\n        int r = a % b;\n        while (r != 0) {\n            a = b; b = r;\n            r = a % b;\n        }\n        return b;\n    }\n    \n    void run() {\n        int n = fr.nextInt();\n        int[][] nums = new int[n][2];\n        for (int i = 0; i < n; i += 1) {\n            nums[i][0] = fr.nextInt();\n            nums[i][1] = fr.nextInt();\n        }\n        List<Integer> cur = new ArrayList<>(), next;\n        cur.add(nums[0][0]); cur.add(nums[0][1]);\n        for (int i = 1; i < n; i += 1) {\n            // out.println(cur);\n            next = new ArrayList<>();\n            for (Integer num: cur) {\n                next.add(gcd(num, nums[i][0]));\n                next.add(gcd(num, nums[i][1]));\n            }\n            Collections.sort(next);\n            List<Integer> removed = new ArrayList<>();\n            for (int j = next.size() - 1; j >= 0; j -= 1) {\n                boolean flag = true;\n                for (int k = j + 1; k < next.size(); k += 1) {\n                    if (next.get(k) % next.get(j) == 0) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) removed.add(next.get(j));\n            }\n            cur = removed;\n        }\n        int val = cur.get(cur.size() - 1);\n        out.println(val != 1 ? val : -1);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1e9 + 7;\nconst double pi = acos(-1);\nint n;\npair<int, int> arr[150005];\nunordered_map<int, int> mp, mp2;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d%d\", &arr[i].first, &arr[i].second);\n  for (int i = 2; i <= sqrt(arr[n - 1].first); i++) {\n    if (arr[n - 1].first % i == 0) {\n      mp[i] = 1;\n      mp[arr[n - 1].first / i] = 1;\n    }\n  }\n  if (mp.size() == 0) mp[arr[n - 1].first]++;\n  long long temp = mp.size();\n  for (int i = 2; i <= sqrt(arr[n - 1].second); i++) {\n    if (arr[n - 1].second % i == 0) {\n      mp[i] = 1;\n      mp[arr[n - 1].second / i] = 1;\n    }\n  }\n  if (mp.size() == temp && mp[arr[n - 1].second] == 0) mp[arr[n - 1].second]++;\n  for (auto &j : mp) {\n    for (int i = 0; i < n - 1; i++) {\n      if (arr[i].first % j.first == 0) {\n        j.second++;\n      } else if (arr[i].second % j.first == 0) {\n        j.second++;\n      } else\n        break;\n    }\n    if (j.second >= n && j.first != 1) {\n      printf(\"%d\", j.first);\n      return 0;\n    }\n  }\n  printf(\"-1\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.util.HashSet;\n\npublic class ProbB {\n\tprivate static void getPrimeFactor(int n, HashSet<Integer> primeFactor){\n\t\tfor(int i=2; i*i<=n; i++){\n\t\t\tif(n%i==0){\n\t\t\t\tprimeFactor.add(i);\n\t\t\t\twhile(n%i==0){\n\t\t\t\t\tn /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(n!=1&&n!=0){\n\t\t\tprimeFactor.add(n);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\n\t\tint n = s.nextInt();\n\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[n];\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\ta[i] = s.nextInt();\n\t\t\tb[i] = s.nextInt();\n\t\t}\n\n\t\tgetPrimeFactor(a[0], set);\n\t\tgetPrimeFactor(b[0], set);\n\n\t\tint i;\n\t\tfor(int f:set){\n\t\t\tfor(i=1; i<n; i++){\n\t\t\t\tif(a[i]%f>0 && b[i]%f>0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(i==n){\n\t\t\t\tSystem.out.println(f);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(-1);\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n \n\npublic class Solve{\n       public static void main(String[] args) throws Exception{\n               Fast sc=new Fast();\n       StringBuilder sb=new StringBuilder();\n             int n=sc.nextInt();\n             int[] ar=new int[n];\n             int[] br=new int[n];\n             for(int i=0;i<n;i++)\n             {\n               ar[i]=sc.nextInt();\n               br[i]=sc.nextInt();\n             }\n            if(n==1)\n            {\n                System.out.println(ar[0]);\n            }\n            else\n            {\n              long a=1L*ar[0]*br[0];\n              for(int i=1;i<n;i++){\n                  a=gcd(1L*ar[i]*br[i],a);\n              }\n              long ans=a;\n              for(int i=0;i<n;i++)\n              {\n                  ans=Math.max(gcd(ans,ar[i]),gcd(ans,br[i]));\n              }\n              if(ans>1) System.out.println(ans);\n              else System.out.println(\"-1\");\n            }\n    }\n\n\nstatic void ReverSort(int[] ar){\n    ArrayList<Integer> al=new ArrayList<>();\n    for(int i=0;i<ar.length;i++){\n        al.add(ar[i]);\n    }\n\n    Collections.sort(al);\n      int j=0;\n    for(int i=al.size()-1;i>=0;i--){\n\n        ar[j]=al.get(i);\n        j++;\n    }\n}\nstatic void Sort(int[] ar){\n    ArrayList<Integer> al=new ArrayList<>();\n    for(int i=0;i<ar.length;i++){\n        al.add(ar[i]);\n    }\n\n    Collections.sort(al);\n      int j=0;\n    for(int i=0;i<al.size();i++){\n\n        ar[j]=al.get(i);\n        j++;\n     }\n  }\n\n \nstatic long gcd(long a,long b){\n    if(b==0) return a;\n    else return  gcd(b,a%b);\n}\n}\n\n\n\nclass Fast{\n  BufferedReader br; \n  StringTokenizer st;\n  public Fast(){ br=new BufferedReader(new InputStreamReader(System.in)); }\n  String next() \n        {  while (st == null || !st.hasMoreElements()) \n            {   try\n                {     st = new StringTokenizer(br.readLine()); } \n                catch (IOException  e) \n                {    e.printStackTrace(); } \n            } \n            return st.nextToken(); \n        }\n  int nextInt(){  return Integer.parseInt(next()); }\n  long nextLong(){     return Long.parseLong(next()); } \n  double nextDouble() {     return Double.parseDouble(next()); } \n  String nextLine() \n        { \n            String str = \"\"; \n            try{      str = br.readLine(); } \n            catch (IOException e)  {  e.printStackTrace(); } \n            return str; \n        } \n}\n    \n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport java.util.*;\n\npublic class CF1 {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tFastReader s = new FastReader();\n\t\tint n = s.nextInt();\n\t\tpair[] arr = new pair[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tlong val1 = s.nextLong();\n\t\t\tlong val2 = s.nextLong();\n\t\t\tarr[i] = new pair(val1,val2);\n\t\t}\n\t\tif(n==1)\n\t\t{\n\t\t\tSystem.out.println(arr[0].first);\n\t\t\treturn;\n\t\t}\n\t\tlong min = Long.MAX_VALUE;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tmin = Math.min(min, Math.min(arr[i].first,arr[i].second));\n\t\tArrayList<Long> al = new ArrayList<>();\n\t\tlong temp = min;\n\t\tfor(int i=2;i<=Math.sqrt(temp);i++)\n\t\t\tif(temp%i==0)\n\t\t\t{\n\t\t\t\tal.add((long)i);\n\t\t\t\twhile(temp%i==0)\n\t\t\t\t\ttemp = temp/i;\n\t\t\t}\n\t\tif(temp!=1)\n\t\t\tal.add(temp);\n\t\tlong res = -1;\n\t\tfor(int i=0;i<al.size();i++)\n\t\t{\n\t\t\tboolean found = true;\n\t\t\tlong fact = al.get(i);\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tif(arr[j].first%fact!=0 && arr[j].second%fact!=0)\n\t\t\t\t{\n\t\t\t\t\tfound = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(found)\n\t\t\t{\n\t\t\t\tres = al.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(res!=-1)\n\t\t\tSystem.out.println(res);\n\t\telse\n\t\t{\n\t\t\tint indx = -1;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tif(arr[i].first==min || arr[i].second==min)\n\t\t\t\t{\n\t\t\t\t\tindx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(arr[indx].first==min)\n\t\t\t\tmin = arr[indx].second;\n\t\t\telse\n\t\t\t\tmin = arr[indx].first;\n\t\t\tal.clear();\n\t\t\ttemp = min;\n\t\t\tfor(int i=2;i<=Math.sqrt(temp);i++)\n\t\t\t\tif(temp%i==0)\n\t\t\t\t{\n\t\t\t\t\tal.add((long)i);\n\t\t\t\t\twhile(temp%i==0)\n\t\t\t\t\t\ttemp = temp/i;\n\t\t\t\t}\n\t\t\tif(temp!=1)\n\t\t\t\tal.add(temp);\n\t\t\tfor(int i=0;i<al.size();i++)\n\t\t\t{\n\t\t\t\tboolean found = true;\n\t\t\t\tlong fact = al.get(i);\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tif(arr[j].first%fact!=0 && arr[j].second%fact!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif(found)\n\t\t\t\t{\n\t\t\t\t\tres = al.get(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tstatic class pair{\n\t\tlong first;\n\t\tlong second;\n\t\t\n\t\tpair(long first, long second)\n\t\t{\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\t}\n\t\n\tstatic class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, b[150001], c[150001], a[150001], p, j;\nvector<int> pr;\nbool check(int X) {\n  if (X == 1) return false;\n  for (int i = 2; i <= n; ++i)\n    if ((a[i] % X) * (b[i] % X) > 0) return false;\n  return true;\n}\nvoid ktnt(int X) {\n  j = 0;\n  long long k = X;\n  for (int i = 2; i * i <= k; ++i)\n    if (k % i == 0) {\n      j++, c[j] = i;\n      while (k % i == 0) {\n        k /= i;\n      }\n    }\n  if (k > 1) j++, c[j] = k;\n}\nvoid run(int X) {\n  ktnt(X);\n  for (int i = 1; i <= j; ++i) {\n    if (check(c[i])) {\n      cout << c[i];\n      exit(0);\n    }\n    if (check(X / c[i])) {\n      cout << X / c[i];\n      exit(0);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) cin >> a[i] >> b[i];\n  run(a[1]);\n  run(b[1]);\n  cout << -1;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class Weakened_Common_Divisor {\n\tpublic static long[] num;\n\tpublic static Set<Long> total;\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\ttotal = new TreeSet<>();\n\t\tint n = Integer.parseInt(in.readLine());\n\t\t\n\t\tHashSet<Long> temp = new HashSet();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tStringTokenizer st = new StringTokenizer(in.readLine());\n\t\t\t\n\t\t\tint a = Integer.parseInt(st.nextToken());\n\t\t\tint b = Integer.parseInt(st.nextToken());\n\t\t\tif(i == 0)\n\t\t\t\ttotal.addAll(f(a,b));\n\t\t\telse {\n\t\t\t\ttemp.clear();\n\t\t\t\t\n\t\t\t\tfor(Long g: total) {\n\t\t\t\t\tif(a % g == 0)\n\t\t\t\t\t\ttemp.add(g);\n\t\t\t\t\tif(b % g == 0)\n\t\t\t\t\t\ttemp.add(g);\n\t\t\t\t}\n\t\t\t\ttotal.retainAll(temp);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(total.isEmpty())\n\t\t\tout.println(-1);\n\t\telse\n\t\t\tfor(Long g: total) {\n\t\t\t\tout.println(g);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tout.close();\n\t}\n\t\n\tprivate static Set<Long> f(int a, int b) {\n\t\tSet<Long> g = new TreeSet<>();\n\t\t\n\t\tfactor(BigInteger.valueOf(a), g);\n\t\tfactor(BigInteger.valueOf(b), g);\n\t\treturn g;\n\t}\n\n\tprivate final static BigInteger ZERO = new BigInteger(\"0\");\n    private final static BigInteger ONE  = new BigInteger(\"1\");\n    private final static BigInteger TWO  = new BigInteger(\"2\");\n    private final static SecureRandom random = new SecureRandom();\n\n    public static BigInteger rho(BigInteger N) {\n        BigInteger divisor;\n        BigInteger c  = new BigInteger(N.bitLength(), random);\n        BigInteger x  = new BigInteger(N.bitLength(), random);\n        BigInteger xx = x;\n\n        // check divisibility by 2\n        if (N.mod(TWO).compareTo(ZERO) == 0) return TWO;\n\n        do {\n            x  =  x.multiply(x).mod(N).add(c).mod(N);\n            xx = xx.multiply(xx).mod(N).add(c).mod(N);\n            xx = xx.multiply(xx).mod(N).add(c).mod(N);\n            divisor = x.subtract(xx).gcd(N);\n        } while((divisor.compareTo(ONE)) == 0);\n        \n        \n        \treturn divisor;\n    }\n    \n    public static void factor(BigInteger N, Set<Long> g) {\n        if (N.compareTo(ONE) == 0) return;\n        if (N.isProbablePrime(20)) { \n        \tg.add(N.longValue()); \n        \treturn; \n        }\n        BigInteger divisor = rho(N);\n        factor(divisor,g);\n        factor(N.divide(divisor),g);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class B {\n    public static void main(String args[]) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        StringBuilder sb = new StringBuilder();\n        int n = Integer.parseInt(st.nextToken());\n        int a[][] = new int[n][2];\n        for(int i=0;i<n;i++){\n            st=new StringTokenizer(br.readLine());\n            a[i][0]=Integer.parseInt(st.nextToken());\n            a[i][1]=Integer.parseInt(st.nextToken());\n        }\n        int x=a[0][0];\n        int y=a[0][1];\n        Set<Integer> set=new LinkedHashSet<>();\n        fun(x,set);\n        fun(y,set);\n        int val=-1;\n        for(Integer i:set){\n            boolean overall=true;\n            for(int j=0;j<n;j++){\n                if(a[j][0]%i==0 || a[j][1]%i==0){\n\n                }else{\n                    overall=false;\n                    break;\n                }\n            }\n            if(overall){\n                val=i;\n                break;\n            }\n        }\n        System.out.println(val);\n\n    }\n    public static void fun(int n,Set<Integer> set)\n    {\n        // Print the number of 2s that divide n\n        //System.out.println(\"Enter\");\n        while (n%2==0)\n        {\n            set.add(2);\n            n /= 2;\n            //System.out.println(n);\n        }\n       // System.out.println(\"HERE1\");\n        // n must be odd at this point. So we can\n        // skip one element (Note i = i +2)\n        for (int i = 3; i <= Math.sqrt(n); i+= 2)\n        {\n            // While i divides n, print i and divide n\n            while (n%i == 0)\n            {\n                set.add(i);\n                n /= i;\n            }\n        }\n\n        if (n > 2)\n            set.add(n);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class t, class u>\nvoid chmax(t& first, u second) {\n  if (first < second) first = second;\n}\ntemplate <class t, class u>\nvoid chmin(t& first, u second) {\n  if (second < first) first = second;\n}\nvector<pair<int, int> > first;\nint n;\nset<int> cand;\nvoid factorise(long long int x) {\n  for (int i = 2; i * i < x + 1; i++) {\n    if (x % i) continue;\n    while (!(x % i)) x /= i;\n    cand.insert(i);\n  }\n  if (x > 1) cand.insert(x);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = int(0); i < int(n); i++) {\n    int u, v;\n    scanf(\"%d\", &u);\n    scanf(\"%d\", &v);\n    first.push_back(make_pair(u, v));\n  }\n  factorise(first[0].first);\n  factorise(first[0].second);\n  for (int p : cand) {\n    bool flag = 1;\n    for (int i = int(0); i < int(n); i++)\n      if (first[i].first % p != 0 && first[i].second % p != 0) flag = 0;\n    if (flag) return !printf(\"%d\\n\", p);\n  }\n  return !printf(\"-1\\n\");\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint a[] = new int[n];\n\t\tint b[] = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tint temp = a[0];\n\t\tfor(int i=2;i*i<=temp;i++) {\n\t\t\twhile(temp%i==0) {\n\t\t\t\tset.add(i);\n\t\t\t\ttemp /=i;\n\t\t\t}\n\t\t}\n\t\tif(temp!=1) {\n\t\t\tset.add(temp);\n\t\t}\n\t\ttemp = b[0];\n\t\tfor(int i = 2; i * i <= temp; ++i) {\n\t\t\twhile(temp % i == 0) {\n\t\t\t\tset.add(i);\n\t\t\t\ttemp /= i;\n\t\t\t}\n\t\t}\n\t\tif(temp!=1) {\n\t\t\tset.add(temp);\n\t\t}\n\t\tint i;\n\t\tfor(int x:set) {\n\t\t\tfor(i=0;i<n;i++) {\n\t\t\t\tif(a[i]%x==0 || b[i]%x==0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==n) {\n\t\t\t\tSystem.out.println(x);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t\t\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "def gcd(a,b):\n    if a%b==0:\n        return b\n    else:\n        return gcd(b,a%b)\n\nimport math \n  \ndef pr(n): \n    a=[]\n    while n % 2 == 0: \n        a.append(2) \n        n = n / 2\n          \n    for i in range(3,int(math.sqrt(n))+1,2): \n          \n        while n % i== 0: \n            a.append(i) \n            n = n / i \n              \n    if n > 2: \n        a.append(n) \n    return list(set(a))\n      \n\nn=int(input())\na=[]\nfor i in range(n):\n    a.append(list(map(int,input().split())))\nif n==1:\n    print(a[0][0])\nelse:\n    b=[]\n    b.append(pr(a[0][0]))\n    b.append(pr(a[0][1]))\n    c=set([])\n    for i in range(len(b)):\n        for j in range(len(b[i])):\n            c.add(b[i][j])\n    c=list(c)\n    e=0\n    for i in range(len(c)):\n        b=0\n        for j in range(n):\n            if a[j][0]%c[i]==0 or a[j][1]%c[i]==0:\n                b+=1\n        if b==n:\n            e=1\n            print(int(c[i]))\n            break\n    if e==0:\n        print(-1)"
        },
        {
            "language": 4,
            "solution": "\n\n/**\n * Created by sky on 20/8/18.\n * www.github.com/aakashjaiswal1\n * aakashjaiswal@hotmail.co.in\n * aakashjaiswal.in@gmail.com\n * people die if they are killed\n */\n/**\n * Created by sky on 19/8/18.\n * www.github.com/aakashjaiswal1\n * aakashjaiswal@hotmail.co.in\n * aakashjaiswal.in@gmail.com\n * people die if they are killed\n */\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class default_jnjt {\n    public static void main(String[] args) {\n        in = new FastReader();\n        int N=ni();\n        Set<Integer> set=getPrime(ni());\n        set.addAll(getPrime(ni()));\n        int[][] storer=new int[N-1][2];\n        for (int i=0;i<N-1;i++){\n            storer[i][0]=ni();\n            storer[i][1]=ni();\n        }\n       ml: for (int prime:set){\n            for (int i=0;i<storer.length;i++){\n                int ele1=storer[i][0];\n                int ele2=storer[i][1];\n                if (!(ele1%prime==0||ele2%prime==0)){\n                    continue ml;\n                }\n            }\n           System.out.println(prime);\n            return;\n        }\n        System.out.println(\"-1\");\n    }\n    public static long binarySearch(long low, long high) {\n        while (high - low > 1) {\n            long mid = (high - low)/2 + low;\n            //System.out.println(mid);\n            if (works(mid)) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        return (works(low) ? low : high);\n    }\n\n    private static Set<Integer> getPrime(int value) {\n\n        Set<Integer> set = new HashSet<>();\n        for (int i = 2;i * i <= value;i ++) {\n            if (value % i == 0) {\n                while (value % i == 0) {\n                    value /= i;\n                }\n                set.add(i);\n            }\n        }\n        if (value > 1) {\n            set.add(value);\n        }\n        return set;\n\n    }\n    static class Graph{\n        ArrayList<Integer> al_array[];\n        int nodes;\n        Graph(int no){\n            this.nodes=no;\n            this.al_array=new ArrayList[no];\n            for (int i=0;i<no;i++){\n                al_array[i]=new ArrayList<>();\n            }\n        }\n        void addDir(int i,int j){\n            this.al_array[i].add(j);\n        }\n        void addUndir(int i,int j){\n            this.al_array[i].add(j);\n            this.al_array[j].add(i);\n        }\n        Graph compliment(){\n            Graph com=new Graph(this.nodes);\n            for (int i=0;i<this.nodes;i++){\n                ArrayList<Integer> al=this.al_array[i];\n                for (int j=0;j<al.size();j++){\n                    int node=al.get(j);\n                    com.addDir(node,i);\n                }\n            }\n            return com;\n        }\n\n    }\n    static void  printLN2DArray(int[][] arr){\n        StringBuilder sb=new StringBuilder();\n        for (int i=0;i<arr.length;i++){\n            for (int j=0;j<arr[i].length;j++){\n                sb.append(arr[i][j]).append(\" \");\n            }\n            sb.append(\"\\n\");\n        }\n        System.out.println(sb.toString());\n    }\n    static long fast_exp_with_mod(long base, long exp) {\n        long MOD=1000000000+7;\n        long res=1;\n        while(exp>0) {\n            if(exp%2==1) res=(res*base)%MOD;\n            base=(base*base)%MOD;\n            exp/=2;\n        }\n        return res%MOD;\n    }\n    public static long gcd(long a, long b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b%a, a);\n    }\n    static class my_no{\n        long num;\n        long denom;\n\n        @Override\n        public String toString() {\n            if (denom<0){\n                this.num=-this.num;\n                this.denom=-this.denom;\n            }\n            if (num==0)return \"0\";\n            return (num+\"/\"+denom);\n        }\n\n        my_no(int no){\n            this.num=no;\n            this.denom=1;\n        }\n        my_no(long num,long denom){\n            this.num=num;\n            this.denom=denom;\n        }\n\n        my_no multiply(my_no obj){\n            long num1=obj.num;\n            long denom1=obj.denom;\n            long n=num1*num;\n            long d=denom1*denom;\n            long gcd=gcd(n,d);\n            n/=gcd;\n            d/=gcd;\n            return new my_no(n,d);\n\n        }\n//        my_no multiply(my_no obj){\n//            long num1=obj.num;\n//            long denom1=obj.denom;\n//            long num2=this.num;\n//            long denom2=this.denom;\n//\n//        }\n\n        my_no multiply(int no){\n            long n=num*no;\n            long d=denom;\n            long gcd=gcd(n,d);\n            n/=gcd;\n            d/=gcd;\n            return new my_no(n,d);\n\n        }\n    }\n    static void memset(int[][] arr,int val){\n        for (int i=0;i<arr.length;i++){\n            for (int j=0;j<arr[i].length;j++){\n                arr[i][j]=val;\n            }\n        }\n    }\n    static void memset(int[] arr,int val){\n        for (int i=0;i<arr.length;i++){\n            arr[i]=val;\n        }\n    }\n\n\n    static void memset(long[][] arr,long val){\n        for (int i=0;i<arr.length;i++){\n            for (int j=0;j<arr[i].length;j++){\n                arr[i][j]=val;\n            }\n        }\n    }\n    static void memset(long[] arr,long val){\n        for (int i=0;i<arr.length;i++){\n            arr[i]=val;\n        }\n    }\n    static private boolean works(long test){\n        return true;\n    }\n\n\n    static void reverse(char[] arr ,int i,int j){\n        if (i==j)\n            return;\n        while (i<j){\n            char temp=arr[i];\n            arr[i]=arr[j];\n            arr[j]=temp;\n            ++i;\n            --j;\n        }\n    }\n    static int[]  takeIntegerArrayInput(int no){\n        int[] arr=new int[no];\n        for (int i=0;i<no;++i){\n            arr[i]=ni();\n        }\n        return arr;\n    }\n    static long fast_Multiply(long no , long pow){\n        long result=1;\n        while (pow>0){\n            if ((pow&1)==1){\n                result=result*no;\n            }\n            no=no*no;\n            pow>>=1;\n        }\n        return result;\n    }\n\n    static long[]  takeLongArrayInput(int no){\n        long[] arr=new long[no];\n        for (int i=0;i<no;++i){\n            arr[i]=ni();\n        }\n        return arr;\n    }\n    static final long MOD = (long)1e9+7;\n    static FastReader in;\n\n\n    static void p(Object o){\n        System.out.print(o);\n    }\n\n    static void pn(Object o){\n        System.out.println(o);\n    }\n\n    static String n(){\n        return in.next();\n    }\n\n    static String nln(){\n        return in.nextLine();\n    }\n\n    static int ni(){\n        return Integer.parseInt(in.next());\n    }\n\n    static int[] ia(int N){\n        int[] a = new int[N];\n        for(int i = 0; i<N; i++)a[i] = ni();\n        return a;\n    }\n\n    static long[] la(int N){\n        long[] a = new long[N];\n        for(int i = 0; i<N; i++)a[i] = nl();\n        return a;\n    }\n\n    static long nl(){\n        return Long.parseLong(in.next());\n    }\n\n    static double nd(){\n        return Double.parseDouble(in.next());\n    }\n\n    static class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next(){\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine(){\n            String str = \"\";\n            try{\n                str = br.readLine();\n            }catch (IOException e){\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static void println(String[] arr){\n        for (int i=0;i<arr.length;++i){\n            System.out.println(arr[i]);\n        }\n    }\n\n}\n\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nf=sys.stdin\n\ndef prime_factors(n):\n    factors = []\n    d=2\n    while n>1:\n        while n%d==0:\n            factors.append(d)\n            n/=d\n        d=d+1\n        if d*d>n:\n            if n>1:\n            \tfactors.append(n)\n            break\n    return factors[0]\n\nn=int(f.readline().rstrip('\\r\\n'))\ninp=[]\ngcd=0\nfor i in range(n):\n\ta,b=map(int,f.readline().rstrip('\\r\\n').split())\n\tc=a*b\n\tgcd=math.gcd(gcd,c)\nif gcd>1:\n\tif gcd<=10000000000:\n\t\tsys.stdout.write(str(prime_factors(gcd))+\"\\n\")\n\telse:\n\t\tif (math.gcd(gcd,a)>1):\n\t\t\tsys.stdout.write(str(math.gcd(a,gcd))+\"\\n\")\n\t\telse:\n\t\t\tsys.stdout.write(str(math.gcd(b,gcd))+'\\n')\nelse:\n\tsys.stdout.write(\"-1\\n\")"
        },
        {
            "language": 4,
            "solution": "//package CodeForces.B;\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Task1025B {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt();\n        int[] a = new int[n];\n        int[] b = new int[n];\n        for(int i = 0; i<n; i++){\n            a[i]=scn.nextInt();\n            b[i]=scn.nextInt();\n        }\n        ArrayList<Integer> simples = new ArrayList<>();\n        boolean isChet = false;\n        if(a[0]%2==0){\n            isChet=true;\n            while(a[0]%2==0){\n                a[0]/=2;\n            }\n            simples.add(2);\n        }\n        for(int i = 3; i*i<=a[0]; i+=2){\n            if(a[0]%i==0) {\n                while (a[0] % i == 0) {\n                    a[0] /= i;\n                }\n                simples.add(i);\n            }\n        }\n        if(a[0]!=1){\n            simples.add(a[0]);\n        }\n        for(int i = 0; i<simples.size(); i++){\n            if(b[0]%simples.get(i)==0) {\n                while (b[0] % simples.get(i) == 0) {\n                    b[0] /= simples.get(i);\n                }\n            }\n        }\n        if(b[0]%2==0){\n            while(b[0]%2==0){\n                b[0]/=2;\n            }\n            if(!isChet) {\n                simples.add(2);\n            }\n        }\n        for(int i = 3; i*i<=b[0]; i+=2){\n            if(b[0]%i==0) {\n                while (b[0] % i == 0) {\n                    b[0] /= i;\n                }\n                simples.add(i);\n            }\n        }\n        if(b[0]!=1){\n            simples.add(b[0]);\n        }\n        if(n==1){\n            System.out.println(simples.get(0));\n            return;\n        }\n        for(int i = 0; i<simples.size(); i++){\n            boolean isGood = true;\n            for(int j = 1; j<n; j++){\n                if(a[j]%simples.get(i)!=0 && b[j]%simples.get(i)!=0){\n                    isGood=false;\n                    break;\n                }\n            }\n            if(isGood){\n                System.out.println(simples.get(i));\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n//BigInteger A;\n//A= BigInteger.valueOf(54);\n//ArrayList<Integer> a=new ArrayList<>();\n//TreeSet<Integer> ts=new TreeSet<>();\n//HashMap<Integer,Integer> hm=new HashMap<>();\n//PriorityQueue<Integer> pq=new PriorityQueue<>();\npublic final class Codeforces\n{\n    static ArrayList<Long> factors;\n    public static void prime(long a)\n    {\n        if(a%2==0)\n        factors.add(2l);\n        while(a%2==0)\n        a/=2;\n        for(long i=3;i*i<=a;i+=2)\n        {\n            if(a%i==0)\n            factors.add(i);\n            while(a%i==0)\n            a/=i;\n        }\n        if(a>2)\n        factors.add((long)a);\n        TreeSet<Long> ts=new TreeSet<>(factors);\n        factors=new ArrayList<>(ts);\n    }\n    public static void main(String[]args)throws IOException\n    {\n        int K=((int)Math.pow(10,9)+7);\n        FastReader ob=new FastReader();\n        int t=ob.nextInt();\n        Pair p[]=new Pair[t];\n        for(int i=0;i<t;i++)\n        {\n            long a=ob.nextLong();\n            long b=ob.nextLong();\n            p[i]=new Pair(a,b);\n        }\n        factors=new ArrayList<>();\n        prime(p[0].x);\n        prime(p[0].y);\n        //System.out.println(factors);\n        long ans=-1;\n        for(int i=0;i<factors.size();i++)\n        {\n            long x=factors.get(i);int f=0;\n            for(int j=0;j<t;j++)\n            {\n                if(p[j].x%x!=0&&p[j].y%x!=0)\n                {f=1;break;}\n            }\n            if(f==0)\n            {ans=x;break;}\n        }\n        System.out.println(ans);\n    }\n}\nclass Pair\n{\n    long x,y;\n    Pair(long x,long y)\n    {\n        this.x=x;\n        this.y=y;\n    }\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextLine()\n    {\n        String s=\"\";\n        try {\n        s=br.readLine();\n        } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        return s;\n    }\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}"
        },
        {
            "language": 3,
            "solution": "\"\"\"\nauthor @ Mobarak Hosen Shakil\nDept. of ICE, Islamic University\nKushtia, Bangladesh\n\n\"\"\"\n\ndef divisors(a, b):\n    Divisors = []\n\n    i = 2\n\n    while(i*i<=a):\n        if a % i == 0:\n            Divisors.append(i)\n            while( a % i == 0):\n                a /= i\n        i+=1\n\n    i = 2\n\n    while (i * i <= b):\n        if b % i == 0:\n            if i not in Divisors:\n                Divisors.append(i)\n            while (b % i == 0):\n                b /= i\n        i += 1\n\n    if a != 1 :\n        Divisors.append(int(a))\n    if b != 1 and b not in Divisors :\n        Divisors.append(int(b))\n\n    #print(Divisors)\n\n    return Divisors\n\n\ndef main():\n\n    n = int(input())\n\n    A = list()\n\n    for i in range (0, n):\n        b = list(map(int, input().split()))\n        A += b\n\n    Prime = divisors(A[0], A[1])\n\n    ans = -1\n\n    for i in range(0, len(Prime)):\n        Ok = 1\n        for j in range(1, n):\n            if A[j*2] % Prime[i] != 0 and A[2*j+1] % Prime[i] != 0 :\n                #print(Prime[i])\n                Ok = 0\n                break\n        if (Ok != 0) :\n            ans = Prime[i]\n            break\n\n    print(ans)\n\nmain()"
        },
        {
            "language": 1,
            "solution": "def gcd(a,b):\n    return a if b==0 else gcd(b,a%b)\nn,g=int(raw_input()),0\na,b=[0]*n,[0]*n\nfor i in range(n):\n    a[i],b[i]=map(int,raw_input().split())\n    g=gcd(g,a[i]*b[i])\nfor i in range(n):\n    if gcd(g,a[i])>1:\n        g=gcd(g,a[i])\n    else:\n        g=gcd(g,b[i])\nprint(g if g>1 else -1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ninline int readin() {\n  int x = 0, c;\n  for (; (c = getchar()) < '0' || c > '9';)\n    ;\n  for (; c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) + c - 48;\n  return x;\n}\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nint main() {\n  int n = readin();\n  int p = readin(), q = readin();\n  long long x = p * 1ll * q;\n  for (int i = 1; i < n; i++) x = gcd(x, readin() * 1ll * readin());\n  if (x == 1) {\n    puts(\"-1\");\n    return 0;\n  }\n  int tmp = (int)gcd(x, 1ll * p);\n  if (tmp == 1)\n    x = gcd(x, q);\n  else\n    x = tmp;\n  tmp = sqrt(x);\n  for (int i = 2; i <= tmp; ++i)\n    if (x % i == 0) {\n      printf(\"%d\\n\", i);\n      return 0;\n    }\n  printf(\"%d\\n\", x);\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Weakened_Common_Divisor {\n\tstatic TreeSet<Long>x;\n public static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong a[] = new long[n];\n\t\tlong b[]=new long[n];\n\t\tlong g = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i]=sc.nextInt();\n\t\t\tb[i]=sc.nextInt();\n\t\t\tif(i==0){\n\t\t\t \tx = new TreeSet<Long>();\n\t\t\t\tprimeFactors(a[i]);\n\t\t\t\tprimeFactors(b[i]);\n\t\t//\t\tSystem.out.println(x);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tTreeSet<Long> gded = new TreeSet<Long>();\n\t\t\t\tfor( Long xs : x){\n\t\t\t\t\tif(a[i]%xs==0||b[i]%xs==0){\n\t\t\t\t\t\tgded.add(xs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx=gded;\n\t\t\t\t//System.out.println(x);\n\t\t\t}\n\t\t}\n\t\tif(x.isEmpty()) System.out.println(\"-1\");\n\t\telse System.out.println(x.iterator().next());\n\t\t\n\n}\n public static void primeFactors(long n)\n {\n     while (n%2==0){\n         x.add(2l);\n         n /= 2;\n     }\n     for (int i = 3; i <= Math.sqrt(n); i+= 2){\n         while (n%i == 0){\n             x.add(i*1l);\n             n /= i;\n         }\n     }\n     if (n > 2)\n         x.add(n);\n }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> v;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nvoid divisors(long long n) {\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      while (n % i == 0) {\n        n /= i;\n      }\n      v.push_back(i);\n    }\n  }\n  if (n > 1) v.push_back(n);\n}\nint main() {\n  int n;\n  long long a, b;\n  cin >> n;\n  cin >> a >> b;\n  divisors(a);\n  divisors(b);\n  for (int i = 0; i < n - 1; i++) {\n    vector<long long> p;\n    cin >> a >> b;\n    for (auto it : v) {\n      if (a % it == 0 || b % it == 0) {\n        p.push_back(it);\n      }\n    }\n    v = p;\n  }\n  if (v.empty()) {\n    cout << -1 << endl;\n  } else {\n    cout << v[0] << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class Main2 {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer st;\n\tstatic int npairs;\n\tstatic int[][] pairs;\n\tstatic Set<Integer> primes;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tst = new StringTokenizer(br.readLine());\n\t\tnpairs = Integer.parseInt(st.nextToken());\n\t\tpairs =new int[npairs][2];\n\t\tfor(int i = 0; i < npairs; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tpairs[i][0] = Integer.parseInt(st.nextToken());\n\t\t\tpairs[i][1] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\t\n\t\tint a = pairs[0][0], b = pairs[0][1];\n\t\t\n\t\tprimes = new HashSet<>();\n\t\tfillPrimes(a);\n\t\tfillPrimes(b);\n\t\tint res = -1;\n\t\touter: for(int prime: primes) {\n\t\t\tfor(int i = 1; i < npairs; i++) {\n\t\t\t\tif(pairs[i][0] % prime != 0 && pairs[i][1] % prime != 0) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = prime;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tSystem.out.println(res);\n\t}\n\t\n\tstatic void fillPrimes(int n) {\n\t\tfor(int i = 2; i * i <= n; i++) {\n\t\t\tif(n % i == 0) {\n\t\t\t\tprimes.add(i);\n\t\t\t\tn /= i;\n\t\t\t\twhile(n % i == 0) {\n\t\t\t\t\tn /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(n > 1) {\n\t\t\tprimes.add(n);\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n// CFPS -> CodeForcesProblemSet\npublic final class CFPS {\n\tstatic FastReader fr = new FastReader();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic final int gigamod = 1000000007;\n\tstatic int t = 1;\n\tstatic double epsilon = 0.00000001;\n\t\n\tpublic static void main(String[] args) {\n\t\tOUTER: \n\t\tfor (int tc = 0; tc < t; tc++) {\n\t\t\t\n\t\t\tint n = fr.nextInt();\n\t\t\t\n\t\t\t// Observations: \n\t\t\t\n\t\t\t// 1. If the answer exists, it will be a number among\n\t\t\t// the prime factors of: \n\t\t\t// \t\ta. 1st of pair 1\n\t\t\t// \t\tb. 2nd of pair 1\n\t\t\t\n\t\t\t// We can try for every prime factor and check if it\n\t\t\t// happens for any.\n\t\t\t\n\t\t\tlong[][] ab = new long[n][2];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tab[i] = fr.nextLongArray(2);\n\t\t\t\n\t\t\tArrayList<Long> possPrimes = new ArrayList<>();\n\t\t\t\n\t\t\tTreeMap<Long, Integer> fnp1 = primeFactorization(ab[0][0]);\n\t\t\tTreeMap<Long, Integer> fnp2 = primeFactorization(ab[0][1]);\n\t\t\t\n\t\t\tfor (long factor : fnp1.keySet())\n\t\t\t\tpossPrimes.add(factor);\n\t\t\t\n\t\t\tfor (long factor : fnp2.keySet())\n\t\t\t\tpossPrimes.add(factor);\n\t\t\t\n\t\t\t// We will check for every possible factor, if it goes\n\t\t\t// through everything.\n\t\t\t\n\t\t\tfor (long factor : possPrimes) {\n\t\t\t\t// Checking if factor passes through.\n\t\t\t\tboolean passes = true;\n\t\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\t\tif (ab[i][0] % factor != 0 && ab[i][1] % factor != 0) {\n\t\t\t\t\t\tpasses = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (passes) {\n\t\t\t\t\tout.println(factor);\n\t\t\t\t\tcontinue OUTER;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(-1);\n\t\t\t// HAHA NICE!\n\t\t}\n\t\tout.close();\n\t}\n\t\n\tstatic String reverse(String s) {\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = s.length();\n\t\t\n\t\tfor (int i = n - 1; i > -1; i--) {\n\t\t\tsb.append(s.charAt(i));\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic long power(long x, int y)\n\t  {\n\t\t// int p = 998244353;\n\t\t// int p = gigamod;\n\t    long res = 1; // Initialize result\n\t \n\t    x = x/* % p*/; // Update x if it is more than or\n\t    // equal to p\n\t \n\t    if (x == 0)\n\t      return 0; // In case x is divisible by p;\n\t \n\t    while (y > 0)\n\t    {\n\t \n\t      // If y is odd, multiply x with result\n\t      if ((y & 1) != 0)\n\t        res = (res * x)/* % p*/;\n\t \n\t      // y must be even now\n\t      y = y >> 1; // y = y/2\n\t      x = (x * x)/* % p*/;\n\t    }\n\t    return res;\n\t  }\n\t\n\t// Maps elements in a 2D matrix serially to elements in \n\t// a 1D array.\n\tstatic int mapTo1D(int row, int col, int n, int m) {\n\t\treturn row * m + col;\n\t}\n\t\n\t// Inverse of what the one above does.\n\tstatic int[] mapTo2D(int idx, int n, int m) {\n\t\tint[] rnc = new int[2];\n\t\trnc[0] = idx / m;\n\t\trnc[1] = idx % m;\n\t\treturn rnc;\n\t}\n\t\n\t// Checks if s has subsequence t.\n\tstatic boolean hasSubsequence(String s, String t) {\n\t\tchar[] schars = s.toCharArray();\n\t\tchar[] tchars = t.toCharArray();\n\t\tint slen = schars.length, tlen = tchars.length;\n\t\tint tctr = 0;\n\t\t\n\t\tif (slen < tlen) return false;\n\t\t\n\t\tfor (int i = 0; i < slen || i < tlen; i++) {\n\t\t\tif (tctr == tlen) break;\n\t\t\tif (schars[i] == tchars[tctr]) {\n\t\t\t\ttctr++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (tctr == tlen) return true;\n\t\treturn false;\n\t}\n\t\n\t// Returns the binary string of length at least bits.\n\tstatic String toBinaryString(long num, int bits) {\n\t\tStringBuilder sb = new StringBuilder(Long.toBinaryString(num));\n\t\tsb.reverse();\n\t\tfor (int i = sb.length(); i < bits; i++)\n\t\t\tsb.append('0');\n\t\treturn sb.reverse().toString();\n\t}\n\t\n\tstatic class CountMap extends TreeMap<Long, Integer>{\n\t\t\n\t\tCountMap() {\n\t\t}\n\t\t\n\t\tCountMap(CountMap cm) {\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic void removeTM(Long key) {\n\t\t\tsuper.remove(key);\n\t\t}\n\t\t\n\t\tpublic void removeTM(Integer key) {\n\t\t\tsuper.remove((long) key);\n\t\t}\n\t\t\n\t\tpublic Integer put(Long key) {\n\t\t\tif (super.containsKey(key)) {\n\t\t\t\treturn super.put(key, super.get(key) + 1);\n\t\t\t} else {\n\t\t\t\treturn super.put(key, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Integer put(int key) {\n\t\t\tif (super.containsKey((long) key)) {\n\t\t\t\treturn super.put((long) key, super.get((long) key) + 1);\n\t\t\t} else {\n\t\t\t\treturn super.put((long) key, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Integer remove(Long key) {\n\t\t\tInteger count = super.get(key);\n\t\t\tif (count == null) return -1;\n\t\t\tif (count == 1)\n\t\t\t\treturn super.remove(key);\n\t\t\telse\n\t\t\t\treturn super.put(key, super.get(key) - 1);\n\t\t}\n\t\t\n\t\tpublic Integer remove(int key) {\n\t\t\tInteger count = super.get((long) key);\n\t\t\tif (count == null) return -1;\n\t\t\tif (count == 1)\n\t\t\t\treturn super.remove((long) key);\n\t\t\telse\n\t\t\t\treturn super.put((long) key, super.get((long) key) - 1);\n\t\t}\n\t\t\n\t\tpublic Integer get(int key) {\n\t\t\tInteger count = super.get((long) key);\n\t\t\tif (count == null)\n\t\t\t\treturn 0;\n\t\t\treturn count;\n\t\t}\n\t\t\n\t\tpublic Integer get(long key) {\n\t\t\tInteger count = super.get(key);\n\t\t\tif (count == null)\n\t\t\t\treturn 0;\n\t\t\treturn count;\n\t\t}\n\t}\n\t\n\tstatic class Point implements Comparable<Point> {\n\t\tlong x;\n\t\tlong y;\n\t\tint id;\n\t\t\n\t\tPoint() {\n\t\t\tx = y = id = 0;\n\t\t}\n\t\t\n\t\tPoint(Point p) {\n\t\t\tthis.x = p.x;\n\t\t\tthis.y = p.y;\n\t\t\tthis.id = p.id;\n\t\t}\n\t\t\n\t\tPoint(long a, long b, int id) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t\tthis.id = id;\n\t\t}\n\t\t\n\t\tPoint(long a, long b) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\tif (this.x > o.x)\n\t\t\t\treturn 1;\n\t\t\tif (this.x < o.x)\n\t\t\t\treturn -1;\n\t\t\tif (this.y > o.y)\n\t\t\t\treturn 1;\n\t\t\tif (this.y < o.y)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tpublic boolean equals(Point that) {\n\t\t\treturn this.compareTo(that) == 0;\n\t\t}\n\t}\n\t\n\tstatic class PointComparator implements Comparator<Point> {\n\t\t@Override\n\t\tpublic int compare(Point o1, Point o2) {\n\t\t\t\n\t\t\t// Comparision has to be done by (a-b).\n\t\t\t\n\t\t\tlong amb1 = o1.x - o1.y;\n\t\t\tlong amb2 = o2.x - o2.y;\n\t\t\t\n\t\t\t// Order has to be reverse.\n\t\t\tif (amb1 > amb2) \n\t\t\t\treturn -1;\n\t\t\t\n\t\t\tif (amb2 > amb1)\n\t\t\t\treturn 1;\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t// Returns the largest power of k that fits into n.\n\tstatic int largestFittingPower(long n, long k) {\n\t\tint lo = 0, hi = logk(Long.MAX_VALUE, 3);\n\t\tint largestPower = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\t\n\t\t\tlong val = (long) Math.pow(k, mid);\n\t\t\tif (val <= n) {\n\t\t\t\tlargestPower = mid;\n\t\t\t\tlo = mid + 1;\n\t\t\t} else {\n\t\t\t\thi = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn largestPower;\n\t}\n\t\n\tstatic String bitSetToString(int set) {\n\t\t// We have to print all the elements that are present\n\t\t// in the set.\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tif (((set >> i) & 1) == 1) {\n\t\t\t\t// The 'i'th bit is on meaning that the element 'i' is \n\t\t\t\t// present in the set.\n\t\t\t\tsb.append((i + 1) + \" \");\n\t\t\t}\n\t\t}\n\t\tsb.append(\"\\n\");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String displayBitSet(long set) {\n\t\t// We have to print all the elements that are present\n\t\t// in the set.\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 60; i++) {\n\t\t\tif (((set >> i) & 1) == 1) {\n\t\t\t\t// The 'i'th bit is on meaning that the element 'i' is \n\t\t\t\t// present in the set.\n\t\t\t\tsb.append((i + 1) + \" \");\n\t\t\t}\n\t\t}\n\t\tsb.append(\"\\n\");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic int addToBitSet(int set, int element) {\n\t\tset = (set) | (1 << (element - 1));\n\t\treturn set;\n\t}\n\t\n\tstatic int removeFromBitSet(int set, int element) {\n\t\t// Checking whether the bit is present.\n\t\tif ((set & (1 << (element - 1))) == 0) return set;\n\t\tset = set ^ (1 << (element - 1));\n\t\treturn set;\n\t}\n\t\n\t// Returns map of factor and its power in the number.\n\tstatic TreeMap<Long, Integer> primeFactorization(long num) {\n\t\tTreeMap<Long, Integer> map = new TreeMap<>();\n\t\twhile (num % 2 == 0) {\n\t\t\tnum /= 2;\n\t\t\tInteger pwrCnt = map.get(2L);\n\t\t\tmap.put(2L, pwrCnt != null ? pwrCnt + 1 : 1);\n\t\t}\n\t\t\n\t\tfor (long i = 3; i * i <= num; i += 2) {\n\t\t\twhile (num % i == 0) {\n\t\t\t\tnum /= i;\n\t\t\t\tInteger pwrCnt = map.get(i);\n\t\t\t\tmap.put(i, pwrCnt != null ? pwrCnt + 1 : 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If the number is prime, we have to add it to the \n\t\t// map.\n\t\tif (num != 1)\n\t\t\tmap.put(num, 1);\n\t\t\n\t\treturn map;\n\t}\n\t\n\t// Returns map of factor and its power in the number.\n\tstatic TreeMap<Integer, Integer> primeFactorization(int num) {\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\t\twhile (num % 2 == 0) {\n\t\t\tnum /= 2;\n\t\t\tInteger pwrCnt = map.get(2);\n\t\t\tmap.put(2, pwrCnt != null ? pwrCnt + 1 : 1);\n\t\t}\n\t\t\n\t\tfor (int i = 3; i * i <= num; i += 2) {\n\t\t\twhile (num % i == 0) {\n\t\t\t\tnum /= i;\n\t\t\t\tInteger pwrCnt = map.get(i);\n\t\t\t\tmap.put(i, pwrCnt != null ? pwrCnt + 1 : 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If the number is prime, we have to add it to the \n\t\t// map.\n\t\tif (num != 1)\n\t\t\tmap.put(num, 1);\n\t\t\n\t\treturn map;\n\t}\n\t\n\tstatic TreeSet<Long> divisors(long num) {\n\t\tTreeSet<Long> divisors = new TreeSet<Long>();\n\t\tdivisors.add(1L);\n\t\tdivisors.add(num);\n\t\t\n\t\tfor (long i = 2; i * i <= num; i++) {\n\t\t\tif (num % i == 0) {\n\t\t\t\tdivisors.add(num/i);\n\t\t\t\tdivisors.add(i);\n\t\t\t}\n\t\t}\n\t\treturn divisors;\n\t}\n\t\n\tstatic void dfs(int node, boolean[] marked, ArrayList<Integer>[] adj) {\n\t\tif (marked[node]) return;\n\n\t\tmarked[node] = true;\n\t\tfor (int adjc : adj[node])\n\t\t\tdfs(adjc, marked, adj);\n\t}\n\t\n\t// Returns the index of the first element\n\t// larger than or equal to val.\n\tstatic int bsearch(int[] arr, int val, int lo, int hi) {\n\t\tint idx = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tif (arr[mid] >= val) {\n\t\t\t\tidx = mid;\n\t\t\t\thi = mid - 1;\n\t\t\t} else\n\t\t\t\tlo = mid + 1;\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\tstatic int bsearch(long[] arr, long val, int lo, int hi) {\n\t\tint idx = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tif (arr[mid] >= val) {\n\t\t\t\tidx = mid;\n\t\t\t\thi = mid - 1;\n\t\t\t} else\n\t\t\t\tlo = mid + 1;\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\t// Returns the index of the last element \n\t// smaller than or equal to val.\n\tstatic int bsearch(long[] arr, long val, int lo, int hi, boolean sMode) {\n\t\tint idx = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tif (arr[mid] > val) {\n\t\t\t\thi = mid - 1;\n\t\t\t} else {\n\t\t\t\tidx = mid;\n\t\t\t\tlo = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\tstatic int bsearch(int[] arr, long val, int lo, int hi, boolean sMode) {\n\t\tint idx = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tif (arr[mid] > val) {\n\t\t\t\thi = mid - 1;\n\t\t\t} else {\n\t\t\t\tidx = mid;\n\t\t\t\tlo = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\tstatic long factorial(long n) {\n\t\tif (n <= 1)\n\t\t\treturn 1;\n\t\tlong factorial = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfactorial = mod(factorial * i);\n\t\treturn factorial;\n\t}\n\t\n\tstatic long factorialInDivision(long a, long b) {\n\t\tif (a == b)\n\t\t\treturn 1;\n\t\tif (b < a) {\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t}\n\t\t\n\t\tlong factorial = 1;\n\t\tfor (long i = a + 1; i <= b; i++)\n\t\t\tfactorial = mod(factorial * i);\n\t\treturn factorial;\n\t}\n\t\n\tstatic BigInteger factorialInDivision(BigInteger a, BigInteger b) {\n\t\tif (a.equals(b))\n\t\t\treturn BigInteger.ONE;\n\t\treturn a.multiply(factorialInDivision(a.subtract(BigInteger.ONE), b));\n\t}\n\t\n\tstatic long nCr(long n, long r) {\n\t\tlong p = gigamod;\n\t    // Base case\n\t    if (r == 0)\n\t        return 1;\n\t \n\t    // Fill factorial array so that we\n\t    // can find all factorial of r, n\n\t    // and n-r\n\t    long fac[] = new long[(int)n + 1];\n\t    fac[0] = 1;\n\t    for (int i = 1; i <= n; i++)\n\t        fac[i] = fac[i - 1] * i % p;\n\t \n\t    return (fac[(int)n] * modInverse(fac[(int)r], p) % p\n\t                    * modInverse(fac[(int)n - (int)r], p) % p) % p;\n\t}\n\t\n\tstatic long modInverse(long n, long p) {\n\t    return power(n, p - 2, p);\n\t}\n\t\n\tstatic long power(long x, long y, long p) {\n\t    long res = 1; // Initialize result\n\t \n\t    x = x % p; // Update x if it is more than or\n\t    // equal to p\n\t \n\t    while (y > 0) {\n\t        // If y is odd, multiply x with result\n\t        if ((y & 1)==1)\n\t            res = (res * x) % p;\n\t \n\t        // y must be even now\n\t        y = y >> 1; // y = y/2\n\t        x = (x * x) % p;\n\t    }\n\t    return res;\n\t}\n\t\n\tstatic long nPr(long n, long r) {\n\t\treturn factorialInDivision(n, n - r);\n\t}\n\t\n\tstatic int log2(long n) {\n\t\treturn (int)(Math.log(n) / Math.log(2));\n\t}\n\t\n\tstatic double log2(long n, boolean doubleMode) {\n\t\treturn (Math.log(n) / Math.log(2));\n\t}\n\t\n\tstatic int logk(long n, long k) {\n\t\treturn (int)(Math.log(n) / Math.log(k));\n\t}\n\t\n\t// Sieve of Eratosthenes: \n\tstatic boolean[] primeGenerator(int upto) {\n\t\tboolean[] isPrime = new boolean[upto + 1];\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[1] = isPrime[0] = false;\n\n\t\tfor (long i = 2; i * i < upto + 1; i++)\n\t\t\tif (isPrime[(int) i])\n\t\t\t\t// Mark all the multiples greater than or equal\n\t\t\t\t// to the square of i to be false.\n\t\t\t\tfor (long j = i; j * i < upto + 1; j++)\n\t\t\t\t\tisPrime[(int) j * (int) i] = false;\n\t\treturn isPrime;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn gcd(b, a % b);\n\t\t}\n\t}\n\t\n\tstatic long gcd(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn gcd(b, a % b);\n\t\t}\n\t}\n\t\n\tstatic int gcd(int[] arr) {\n\t\tint n = arr.length;\n\t\tint gcd = arr[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tgcd = gcd(gcd, arr[i]);\n\t\t}\n\t\treturn gcd;\n\t}\n\t\n\tstatic long gcd(long[] arr) {\n\t\tint n = arr.length;\n\t\tlong gcd = arr[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tgcd = gcd(gcd, arr[i]);\n\t\t}\n\t\treturn gcd;\n\t}\n\t\n\tstatic long lcm(int[] arr) {\n\t\tlong lcm = arr[0];\n\t\tint n = arr.length;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tlcm = (lcm * arr[i]) / gcd(lcm, arr[i]);\n\t\t}\n\t\treturn lcm;\n\t}\n\t\n\tstatic long lcm(long[] arr) {\n\t\tlong lcm = arr[0];\n\t\tint n = arr.length;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tlcm = (lcm * arr[i]) / gcd(lcm, arr[i]);\n\t\t}\n\t\treturn lcm;\n\t}\n\t\n\tstatic long lcm(int a, int b) {\n\t\treturn (a * b)/gcd(a, b);\n\t}\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn (a * b)/gcd(a, b);\n\t}\n\t\n\tstatic boolean less(int a, int b) {\n\t\treturn a < b ? true : false;\n\t}\n\t\n\tstatic boolean isSorted(int[] a) {\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif (less(a[i], a[i - 1]))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic boolean isSorted(long[] a) {\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif (a[i] < a[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic void swap(int[] a, int i, int j) {\n\t\tint temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\t\n\tstatic void swap(long[] a, int i, int j) {\n\t\tlong temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\t\n\tstatic void swap(double[] a, int i, int j) {\n\t\tdouble temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\t\n\tstatic void swap(char[] a, int i, int j) {\n\t\tchar temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\t\n\tstatic void sort(int[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t}\n\t\n\tstatic void sort(char[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t}\n\t\n\tstatic void sort(long[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t}\n\t\n\tstatic void sort(double[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t}\n\t\n\tstatic void reverseSort(int[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n/2; i++)\n\t\t\tswap(arr, i, n - 1 - i);\n\t}\n\t\n\tstatic void reverseSort(char[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n/2; i++)\n\t\t\tswap(arr, i, n - 1 - i);\n\t}\n\t\n\tstatic void reverseSort(long[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n/2; i++)\n\t\t\tswap(arr, i, n - 1 - i);\n\t}\n\t\n\tstatic void reverseSort(double[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n/2; i++)\n\t\t\tswap(arr, i, n - 1 - i);\n\t}\n\t\n\tstatic void shuffleArray(long[] arr, int startPos, int endPos) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = startPos; i < endPos; ++i) {\n\t\t\tlong tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(endPos - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\t\n\tstatic void shuffleArray(int[] arr, int startPos, int endPos) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = startPos; i < endPos; ++i) {\n\t\t\tint tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(endPos - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\t\n\tstatic void shuffleArray(double[] arr, int startPos, int endPos) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = startPos; i < endPos; ++i) {\n\t\t\tdouble tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(endPos - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\t\n\tprivate static void shuffleArray(char[] arr, int startPos, int endPos) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = startPos; i < endPos; ++i) {\n\t\t\tchar tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(endPos - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\t\n\tstatic boolean isPrime(long n) {\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\n\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\treturn false;\n\n\t\tfor (long i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tstatic String toString(int[] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\tsb.append(dp[i] + \" \");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(boolean[] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\tsb.append(dp[i] + \" \");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(long[] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\tsb.append(dp[i] + \" \");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(char[] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\tsb.append(dp[i] + \"\");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(int[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\tsb.append(dp[i][j] + \"\");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(long[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\tsb.append(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(double[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\tsb.append(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(char[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\tsb.append(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic char toChar(int i) {\n\t\treturn (char) (i + 48);\n\t}\n\t\n\tstatic long mod(long a, long m) {\n\t    return (a%m + m) % m;\n\t}\n\t\n\tstatic long mod(long num) {\n\t\treturn (num % gigamod + gigamod) % gigamod;\n\t}\n\t\n\t// Uses weighted quick-union with path compression.\n\tstatic class UnionFind {\n\t    private int[] parent;  // parent[i] = parent of i\n\t    private int[] size;    // size[i] = number of sites in tree rooted at i\n\t                           // Note: not necessarily correct if i is not a root node\n\t    private int count;     // number of components\n\n\t    public UnionFind(int n) {\n\t        count = n;\n\t        parent = new int[n];\n\t        size = new int[n];\n\t        for (int i = 0; i < n; i++) {\n\t            parent[i] = i;\n\t            size[i] = 1;\n\t        }\n\t    }\n\n\t    // Number of connected components.\n\t    public int count() {\n\t        return count;\n\t    }\n\t  \n\t    // Find the root of p.\n\t    public int find(int p) {\n\t        int root = p;\n\t        while (root != parent[root])\n\t            root = parent[root];\n\t        while (p != root) {\n\t            int newp = parent[p];\n\t            parent[p] = root;\n\t            p = newp;\n\t        }\n\t        return root;\n\t    }\n\n\t    public boolean connected(int p, int q) {\n\t        return find(p) == find(q);\n\t    }\n\t    \n\t    public int numConnectedTo(int node) {\n\t    \treturn size[find(node)];\n\t    }\n\t    \n\t    // Weighted union.\n\t    public void union(int p, int q) {\n\t        int rootP = find(p);\n\t        int rootQ = find(q);\n\t        \n\t        if (rootP == rootQ) return;\n\n\t        // make smaller root point to larger one\n\t        if (size[rootP] < size[rootQ]) {\n\t            parent[rootP] = rootQ;\n\t            size[rootQ] += size[rootP];\n\t        }\n\t        else {\n\t            parent[rootQ] = rootP;\n\t            size[rootP] += size[rootQ];\n\t        }\n\t        count--;\n\t    }\n\t    \n\t    public static int[] connectedComponents(UnionFind uf) {\n\t    \t// We can do this in nlogn.\n\t    \t\n\t    \tint n = uf.size.length;\n\t    \tint[] compoColors = new int[n];\n\t    \tfor (int i = 0; i < n; i++)\n\t    \t\tcompoColors[i] = uf.find(i);\n\t    \t\n\t    \tHashMap<Integer, Integer> oldToNew = new HashMap<>();\n\t    \tint newCtr = 0;\n\t    \t\n\t    \tfor (int i = 0; i < n; i++) {\n\t    \t\t\n\t    \t\tint thisOldColor = compoColors[i];\n\t    \t\tInteger thisNewColor = oldToNew.get(thisOldColor);\n\t    \t\tif (thisNewColor == null)\n\t    \t\t\tthisNewColor = newCtr++;\n\t    \t\t\n\t    \t\toldToNew.put(thisOldColor, thisNewColor);\n\t    \t\tcompoColors[i] = thisNewColor;\n\t    \t}\n\t    \t\n\t    \treturn compoColors;\n\t    }\n\t}\n\t\n\tstatic class UGraph {\n\t\t// Adjacency list.\n\t\tprivate TreeSet<Integer>[] adj;\n\t\tprivate static final String NEWLINE = \"\\n\";\n\t\tprivate int E;\n\t\t\n\t\tpublic UGraph(int V) {\n\t\t\tadj = (TreeSet<Integer>[]) new TreeSet[V];\n\t\t\tE = 0;\n\t\t\tfor (int i = 0; i < V; i++)\n\t\t\t\tadj[i] = new TreeSet<Integer>();\n\t\t}\n\t\t\n\t\tpublic void addEdge(int from, int to) {\n\t\t\tif (adj[from].contains(to)) return;\n\t\t\tE++;\n\t\t\tadj[from].add(to);\n\t\t\tadj[to].add(from);\n\t\t}\n\t\t\n\t\tpublic TreeSet<Integer> adj(int from) {\n\t\t\treturn adj[from];\n\t\t}\n\t\t\n\t\tpublic int V() {\n\t\t\treturn adj.length;\n\t\t}\n\t\t\n\t\tpublic int E() {\n\t\t\treturn E;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\ts.append(V() + \" vertices, \" + E() + \" edges \" + NEWLINE);\n\t\t\tfor (int v = 0; v < V(); v++) {\n\t\t\t\ts.append(v + \": \");\n\t\t\t\tfor (int w : adj[v]) {\n\t\t\t\t\ts.append(w + \" \");\n\t\t\t\t}\n\t\t\t\ts.append(NEWLINE);\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\t\n\t\tpublic static void dfsMark(int current, boolean[] marked, UGraph g) {\n\t\t\tif (marked[current]) return;\n\t\t\t\n\t\t\tmarked[current] = true;\n\t\t\tIterable<Integer> adj = g.adj(current);\n\t\t\tfor (int adjc : adj)\n\t\t\t\tdfsMark(adjc, marked, g);\n\t\t}\n\t\t\n\t\tpublic static void dfsMark(int current, int from, long[] distTo, boolean[] marked, UGraph g, ArrayList<Integer> endPoints) {\n\t\t\tif (marked[current]) return;\n\t\t\t\n\t\t\tmarked[current] = true;\n\t\t\tif (from != -1)\n\t\t\t\tdistTo[current] = distTo[from] + 1;\n\t\t\tTreeSet<Integer> adj = g.adj(current);\n\t\t\tint alreadyMarkedCtr = 0;\n\t\t\tfor (int adjc : adj) {\n\t\t\t\tif (marked[adjc]) alreadyMarkedCtr++;\n\t\t\t\tdfsMark(adjc, current, distTo, marked, g, endPoints);\n\t\t\t}\n\t\t\t\n\t\t\tif (alreadyMarkedCtr == adj.size())\n\t\t\t\tendPoints.add(current);\n\t\t}\n\t\t\n\t\tpublic static void bfsOrder(int current, UGraph g) {\n\t\t}\n\t\t\n\t\tpublic static void dfsMark(int current, int[] colorIds, int color, UGraph g) {\n\t\t\tif (colorIds[current] != -1) return;\n\t\t\t\n\t\t\tcolorIds[current] = color;\n\t\t\tIterable<Integer> adj = g.adj(current);\n\t\t\tfor (int adjc : adj)\n\t\t\t\tdfsMark(adjc, colorIds, color, g);\n\t\t}\n\t\t\n\t\tpublic static int[] connectedComponents(UGraph g) {\n\t\t\tint n = g.V();\n\t\t\tint[] componentId = new int[n];\n\t\t\tArrays.fill(componentId, -1);\n\t\t\tint colorCtr = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (componentId[i] != -1) continue;\n\t\t\t\tdfsMark(i, componentId, colorCtr, g);\n\t\t\t\tcolorCtr++;\n\t\t\t}\n\t\t\t\n\t\t\treturn componentId;\n\t\t}\n\t\t\n\t\tpublic static boolean hasCycle(UGraph ug) {\n\t\t\tint n = ug.V();\n\t\t\tboolean[] marked = new boolean[n];\n\t\t\tboolean[] hasCycleFirst = new boolean[1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (marked[i]) continue;\n\t\t\t\thcDfsMark(i, ug, marked, hasCycleFirst, -1);\n\t\t\t}\n\t\t\treturn hasCycleFirst[0];\n\t\t}\n\t\t\n\t\t// Helper for hasCycle.\n\t\tprivate static void hcDfsMark(int current, UGraph ug, boolean[] marked, boolean[] hasCycleFirst, int parent) {\n\t\t\tif (marked[current]) return;\n\t\t\tif (hasCycleFirst[0]) return;\n\t\t\t\n\t\t\tmarked[current] = true;\n\t\t\tTreeSet<Integer> adjc = ug.adj(current);\n\t\t\tfor (int adj : adjc) {\n\t\t\t\tif (marked[adj] && adj != parent && parent != -1) {\n\t\t\t\t\thasCycleFirst[0] = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\thcDfsMark(adj, ug, marked, hasCycleFirst, current);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Digraph {\n\t\t// Adjacency list.\n\t\tprivate HashSet<Integer>[] adj;\n\t\tprivate static final String NEWLINE = \"\\n\";\n\t\tprivate int E;\n\t\t\n\t\tpublic Digraph(int V) {\n\t\t\tadj = (HashSet<Integer>[]) new HashSet[V];\n\t\t\tE = 0;\n\t\t\tfor (int i = 0; i < V; i++)\n\t\t\t\tadj[i] = new HashSet<Integer>();\n\t\t}\n\t\t\n\t\tpublic void addEdge(int from, int to) {\n\t\t\tif (adj[from].contains(to)) return;\n\t\t\tE++;\n\t\t\tadj[from].add(to);\n\t\t}\n\t\t\n\t\tpublic HashSet<Integer> adj(int from) {\n\t\t\treturn adj[from];\n\t\t}\n\t\t\n\t\tpublic int V() {\n\t\t\treturn adj.length;\n\t\t}\n\t\t\n\t\tpublic int E() {\n\t\t\treturn E;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\ts.append(V() + \" vertices, \" + E() + \" edges \" + NEWLINE);\n\t\t\tfor (int v = 0; v < V(); v++) {\n\t\t\t\ts.append(v + \": \");\n\t\t\t\tfor (int w : adj[v]) {\n\t\t\t\t\ts.append(w + \" \");\n\t\t\t\t}\n\t\t\t\ts.append(NEWLINE);\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\t\n\t\tpublic static void dfsMark(int source, boolean[] marked, Digraph g) {\n\t\t\tif (marked[source]) return;\n\t\t\t\n\t\t\tmarked[source] = true;\n\t\t\tIterable<Integer> adj = g.adj(source);\n\t\t\tfor (int adjc : adj)\n\t\t\t\tdfsMark(adjc, marked, g);\n\t\t}\n\t\t\n\t\tpublic static void bfsOrder(int source, Digraph g) {\n\t\t}\n\t\t\n\t\tprivate static void dfsMark(int source, int[] colorIds, int color, Digraph g) {\n\t\t\tif (colorIds[source] != -1) return;\n\t\t\t\n\t\t\tcolorIds[source] = color;\n\t\t\tIterable<Integer> adj = g.adj(source);\n\t\t\tfor (int adjc : adj)\n\t\t\t\tdfsMark(adjc, colorIds, color, g);\n\t\t}\n\t\t\n\t\tpublic static int[] connectedComponents(Digraph g) {\n\t\t\tint n = g.V();\n\t\t\tint[] componentId = new int[n];\n\t\t\tArrays.fill(componentId, -1);\n\t\t\tint colorCtr = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (componentId[i] != -1) continue;\n\t\t\t\tdfsMark(i, componentId, colorCtr, g);\n\t\t\t\tcolorCtr++;\n\t\t\t}\n\t\t\t\n\t\t\treturn componentId;\n\t\t}\n\t\t\n\t\tpublic static Stack<Integer> topologicalSort(Digraph dg)\n\t\t{\n\t\t\t// dg has to be a directed acyclic graph.\n\t\t\t// We'll have to run dfs on the digraph and push the deepest nodes on stack first.\n\t\t\t// We'll need a Stack<Integer> and a int[] marked.\n\t\t\tStack<Integer> topologicalStack = new Stack<Integer>();\n\t\t\tboolean[] marked = new boolean[dg.V()];\n\t\t\t\n\t\t\t// Calling dfs\n\t\t\tfor (int i = 0; i < dg.V(); i++)\n\t\t\t{\n\t\t\t\tif (!marked[i]) runDfs(dg, topologicalStack, marked, i);\n\t\t\t}\n\t\t\t\n\t\t\treturn topologicalStack;\n\t\t}\n\t\t\n\t\tstatic void runDfs(Digraph dg, Stack<Integer> topologicalStack, boolean[] marked, int source)\n\t\t{\n\t\t\tmarked[source] = true;\n\t\t\tfor (Integer adjVertex : dg.adj(source))\n\t\t\t{\n\t\t\t\tif (!marked[adjVertex]) runDfs(dg, topologicalStack, marked, adjVertex);\n\t\t\t}\n\t\t\ttopologicalStack.add(source);\n\t\t}\n\t}\n\t\n\tstatic class FastReader {\n\t\tprivate BufferedReader bfr;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbfr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\tif (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(bfr.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn next().toCharArray()[0];\n\t\t}\n\n\t\tString nextString() {\n\t\t\treturn next();\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarr[i] = nextInt();\n\t\t\treturn arr;\n\t\t}\n\t\t\n\t\tint[] nextOneIntArray(int n) {\n\t\t\tint[] arr = new int[n + 1];\n\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\tarr[i] = nextInt();\n\t\t\treturn arr;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] arr = new double[n];\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tarr[i] = nextDouble();\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarr[i] = nextLong();\n\t\t\treturn arr;\n\t\t}\n\t\t\n\t\t/*public char[] nextCharArray(int n) {\n\t\t\tchar[] chars = new char[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tchars[i] = fr.nextChar();\n\t\t\treturn chars;\n\t\t}*/\n\t}\n\t\n\tprivate static class IndexMaxPQ<Key extends Comparable<Key>> implements Iterable<Integer> {\n\t    private int maxN;        // maximum number of elements on PQ\n\t    private int n;           // number of elements on PQ\n\t    private int[] pq;        // binary heap using 1-based indexing\n\t    private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i\n\t    private Key[] keys;      // keys[i] = priority of i\n\n\t    public IndexMaxPQ(int maxN) {\n\t        if (maxN < 0) throw new IllegalArgumentException();\n\t        this.maxN = maxN;\n\t        n = 0;\n\t        keys = (Key[]) new Comparable[maxN + 1];    // make this of length maxN??\n\t        pq   = new int[maxN + 1];\n\t        qp   = new int[maxN + 1];                   // make this of length maxN??\n\t        for (int i = 0; i <= maxN; i++)\n\t            qp[i] = -1;\n\t    }\n\n\t    public boolean isEmpty() {\n\t        return n == 0;\n\t    }\n\n\t    public boolean contains(int i) {\n\t        validateIndex(i);\n\t        return qp[i] != -1;\n\t    }\n\n\t    public int size() {\n\t        return n;\n\t    }\n\n\t   /**\n\t     * Associate key with index i.\n\t     *\n\t     * @param  i an index\n\t     * @param  key the key to associate with index {@code i}\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if there already is an item\n\t     *         associated with index {@code i}\n\t     */\n\t    public void insert(int i, Key key) {\n\t        validateIndex(i);\n\t        if (contains(i)) throw new IllegalArgumentException(\"index is already in the priority queue\");\n\t        n++;\n\t        qp[i] = n;\n\t        pq[n] = i;\n\t        keys[i] = key;\n\t        swim(n);\n\t    }\n\n\t    /**\n\t     * Returns an index associated with a maximum key.\n\t     *\n\t     * @return an index associated with a maximum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public int maxIndex() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        return pq[1];\n\t    }\n\n\t    /**\n\t     * Returns a maximum key.\n\t     *\n\t     * @return a maximum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public Key maxKey() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        return keys[pq[1]];\n\t    }\n\n\t    /**\n\t     * Removes a maximum key and returns its associated index.\n\t     *\n\t     * @return an index associated with a maximum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public int delMax() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        int max = pq[1];\n\t        exch(1, n--);\n\t        sink(1);\n\n\t        assert pq[n+1] == max;\n\t        qp[max] = -1;        // delete\n\t        keys[max] = null;    // to help with garbage collection\n\t        pq[n+1] = -1;        // not needed\n\t        return max;\n\t    }\n\n\t    /**\n\t     * Returns the key associated with index {@code i}.\n\t     *\n\t     * @param  i the index of the key to return\n\t     * @return the key associated with index {@code i}\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public Key keyOf(int i) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        else return keys[i];\n\t    }\n\n\t    /**\n\t     * Change the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to change\n\t     * @param  key change the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     */\n\t    public void changeKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        keys[i] = key;\n\t        swim(qp[i]);\n\t        sink(qp[i]);\n\t    }\n\n\t    /**\n\t     * Increase the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to increase\n\t     * @param  key increase the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if {@code key <= keyOf(i)}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void increaseKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        if (keys[i].compareTo(key) == 0)\n\t            throw new IllegalArgumentException(\"Calling increaseKey() with a key equal to the key in the priority queue\");\n\t        if (keys[i].compareTo(key) > 0)\n\t            throw new IllegalArgumentException(\"Calling increaseKey() with a key that is strictly less than the key in the priority queue\");\n\n\t        keys[i] = key;\n\t        swim(qp[i]);\n\t    }\n\n\t    /**\n\t     * Decrease the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to decrease\n\t     * @param  key decrease the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if {@code key >= keyOf(i)}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void decreaseKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        if (keys[i].compareTo(key) == 0)\n\t            throw new IllegalArgumentException(\"Calling decreaseKey() with a key equal to the key in the priority queue\");\n\t        if (keys[i].compareTo(key) < 0)\n\t            throw new IllegalArgumentException(\"Calling decreaseKey() with a key that is strictly greater than the key in the priority queue\");\n\t        keys[i] = key;\n\t        sink(qp[i]);\n\t    }\n\n\t    /**\n\t     * Remove the key on the priority queue associated with index {@code i}.\n\t     *\n\t     * @param  i the index of the key to remove\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void delete(int i) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        int index = qp[i];\n\t        exch(index, n--);\n\t        swim(index);\n\t        sink(index);\n\t        keys[i] = null;\n\t        qp[i] = -1;\n\t    }\n\n\t    // throw an IllegalArgumentException if i is an invalid index\n\t    private void validateIndex(int i) {\n\t        if (i < 0) throw new IllegalArgumentException(\"index is negative: \" + i);\n\t        if (i >= maxN) throw new IllegalArgumentException(\"index >= capacity: \" + i);\n\t    }\n\t    \n\t    private boolean less(int i, int j) {\n\t        return keys[pq[i]].compareTo(keys[pq[j]]) < 0;\n\t    }\n\n\t    private void exch(int i, int j) {\n\t        int swap = pq[i];\n\t        pq[i] = pq[j];\n\t        pq[j] = swap;\n\t        qp[pq[i]] = i;\n\t        qp[pq[j]] = j;\n\t    }\n\n\t    private void swim(int k) {\n\t        while (k > 1 && less(k/2, k)) {\n\t            exch(k, k/2);\n\t            k = k/2;\n\t        }\n\t    }\n\n\t    private void sink(int k) {\n\t        while (2*k <= n) {\n\t            int j = 2*k;\n\t            if (j < n && less(j, j+1)) j++;\n\t            if (!less(k, j)) break;\n\t            exch(k, j);\n\t            k = j;\n\t        }\n\t    }\n\n\n\t    /**\n\t     * Returns an iterator that iterates over the keys on the\n\t     * priority queue in descending order.\n\t     * The iterator doesn't implement {@code remove()} since it's optional.\n\t     *\n\t     * @return an iterator that iterates over the keys in descending order\n\t     */\n\t    public Iterator<Integer> iterator() {\n\t        return new HeapIterator();\n\t    }\n\n\t    private class HeapIterator implements Iterator<Integer> {\n\t        // create a new pq\n\t        private IndexMaxPQ<Key> copy;\n\n\t        // add all elements to copy of heap\n\t        // takes linear time since already in heap order so no keys move\n\t        public HeapIterator() {\n\t            copy = new IndexMaxPQ<Key>(pq.length - 1);\n\t            for (int i = 1; i <= n; i++)\n\t                copy.insert(pq[i], keys[pq[i]]);\n\t        }\n\n\t        public boolean hasNext()  { return !copy.isEmpty();                     }\n\t        public void remove()      { throw new UnsupportedOperationException();  }\n\n\t        public Integer next() {\n\t            if (!hasNext()) throw new NoSuchElementException();\n\t            return copy.delMax();\n\t        }\n\t    }\n\n\t}\n\t\n\tpublic static class IndexMinPQ<Key extends Comparable<Key>> implements Iterable<Integer> {\n\t    private int maxN;        // maximum number of elements on PQ\n\t    private int n;           // number of elements on PQ\n\t    private int[] pq;        // binary heap using 1-based indexing\n\t    private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i\n\t    private Key[] keys;      // keys[i] = priority of i\n\n\t    public IndexMinPQ(int maxN) {\n\t        if (maxN < 0) throw new IllegalArgumentException();\n\t        this.maxN = maxN;\n\t        n = 0;\n\t        keys = (Key[]) new Comparable[maxN + 1];    // make this of length maxN??\n\t        pq   = new int[maxN + 1];\n\t        qp   = new int[maxN + 1];                   // make this of length maxN??\n\t        for (int i = 0; i <= maxN; i++)\n\t            qp[i] = -1;\n\t    }\n\n\t    public boolean isEmpty() {\n\t        return n == 0;\n\t    }\n\n\t    public boolean contains(int i) {\n\t        validateIndex(i);\n\t        return qp[i] != -1;\n\t    }\n\n\t    public int size() {\n\t        return n;\n\t    }\n\n\t    /**\n\t     * Associates key with index {@code i}.\n\t     *\n\t     * @param  i an index\n\t     * @param  key the key to associate with index {@code i}\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if there already is an item associated\n\t     *         with index {@code i}\n\t     */\n\t    public void insert(int i, Key key) {\n\t        validateIndex(i);\n\t        if (contains(i)) throw new IllegalArgumentException(\"index is already in the priority queue\");\n\t        n++;\n\t        qp[i] = n;\n\t        pq[n] = i;\n\t        keys[i] = key;\n\t        swim(n);\n\t    }\n\n\t    /**\n\t     * Returns an index associated with a minimum key.\n\t     *\n\t     * @return an index associated with a minimum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public int minIndex() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        return pq[1];\n\t    }\n\n\t    /**\n\t     * Returns a minimum key.\n\t     *\n\t     * @return a minimum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public Key minKey() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        return keys[pq[1]];\n\t    }\n\n\t    /**\n\t     * Removes a minimum key and returns its associated index.\n\t     * @return an index associated with a minimum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public int delMin() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        int min = pq[1];\n\t        exch(1, n--);\n\t        sink(1);\n\t        assert min == pq[n+1];\n\t        qp[min] = -1;        // delete\n\t        keys[min] = null;    // to help with garbage collection\n\t        pq[n+1] = -1;        // not needed\n\t        return min;\n\t    }\n\n\t    /**\n\t     * Returns the key associated with index {@code i}.\n\t     *\n\t     * @param  i the index of the key to return\n\t     * @return the key associated with index {@code i}\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public Key keyOf(int i) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        else return keys[i];\n\t    }\n\n\t    /**\n\t     * Change the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to change\n\t     * @param  key change the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void changeKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        keys[i] = key;\n\t        swim(qp[i]);\n\t        sink(qp[i]);\n\t    }\n\n\t    /**\n\t     * Decrease the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to decrease\n\t     * @param  key decrease the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if {@code key >= keyOf(i)}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void decreaseKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        if (keys[i].compareTo(key) == 0)\n\t            throw new IllegalArgumentException(\"Calling decreaseKey() with a key equal to the key in the priority queue\");\n\t        if (keys[i].compareTo(key) < 0)\n\t            throw new IllegalArgumentException(\"Calling decreaseKey() with a key strictly greater than the key in the priority queue\");\n\t        keys[i] = key;\n\t        swim(qp[i]);\n\t    }\n\n\t    /**\n\t     * Increase the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to increase\n\t     * @param  key increase the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if {@code key <= keyOf(i)}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void increaseKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        if (keys[i].compareTo(key) == 0)\n\t            throw new IllegalArgumentException(\"Calling increaseKey() with a key equal to the key in the priority queue\");\n\t        if (keys[i].compareTo(key) > 0)\n\t            throw new IllegalArgumentException(\"Calling increaseKey() with a key strictly less than the key in the priority queue\");\n\t        keys[i] = key;\n\t        sink(qp[i]);\n\t    }\n\n\t    /**\n\t     * Remove the key associated with index {@code i}.\n\t     *\n\t     * @param  i the index of the key to remove\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void delete(int i) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        int index = qp[i];\n\t        exch(index, n--);\n\t        swim(index);\n\t        sink(index);\n\t        keys[i] = null;\n\t        qp[i] = -1;\n\t    }\n\n\t    // throw an IllegalArgumentException if i is an invalid index\n\t    private void validateIndex(int i) {\n\t        if (i < 0) throw new IllegalArgumentException(\"index is negative: \" + i);\n\t        if (i >= maxN) throw new IllegalArgumentException(\"index >= capacity: \" + i);\n\t    }\n\n\t    private boolean greater(int i, int j) {\n\t        return keys[pq[i]].compareTo(keys[pq[j]]) > 0;\n\t    }\n\n\t    private void exch(int i, int j) {\n\t        int swap = pq[i];\n\t        pq[i] = pq[j];\n\t        pq[j] = swap;\n\t        qp[pq[i]] = i;\n\t        qp[pq[j]] = j;\n\t    }\n\n\t    private void swim(int k) {\n\t        while (k > 1 && greater(k/2, k)) {\n\t            exch(k, k/2);\n\t            k = k/2;\n\t        }\n\t    }\n\n\t    private void sink(int k) {\n\t        while (2*k <= n) {\n\t            int j = 2*k;\n\t            if (j < n && greater(j, j+1)) j++;\n\t            if (!greater(k, j)) break;\n\t            exch(k, j);\n\t            k = j;\n\t        }\n\t    }\n\n\n\t   /***************************************************************************\n\t    * Iterators.\n\t    ***************************************************************************/\n\n\t    /**\n\t     * Returns an iterator that iterates over the keys on the\n\t     * priority queue in ascending order.\n\t     * The iterator doesn't implement {@code remove()} since it's optional.\n\t     *\n\t     * @return an iterator that iterates over the keys in ascending order\n\t     */\n\t    public Iterator<Integer> iterator() { return new HeapIterator(); }\n\n\t    private class HeapIterator implements Iterator<Integer> {\n\t        // create a new pq\n\t        private IndexMinPQ<Key> copy;\n\n\t        // add all elements to copy of heap\n\t        // takes linear time since already in heap order so no keys move\n\t        public HeapIterator() {\n\t            copy = new IndexMinPQ<Key>(pq.length - 1);\n\t            for (int i = 1; i <= n; i++)\n\t                copy.insert(pq[i], keys[pq[i]]);\n\t        }\n\n\t        public boolean hasNext()  { return !copy.isEmpty();                     }\n\t        public void remove()      { throw new UnsupportedOperationException();  }\n\n\t        public Integer next() {\n\t            if (!hasNext()) throw new NoSuchElementException();\n\t            return copy.delMin();\n\t        }\n\t    }\n\n\t}\n\t\n\tpublic static class SegmentTree {\n\n\t    private Node[] heap;\n\t    private long[] array;\n\t    private int size;\n\n\t    /**\n\t     * Time-Complexity:  O(n*log(n))\n\t     *\n\t     * @param array the Initialization array\n\t     */\n\t    public SegmentTree(long[] array) {\n\t        this.array = Arrays.copyOf(array, array.length);\n\t        //The max size of this array is about 2 * 2 ^ log2(n) + 1\n\t        size = (int) (2 * Math.pow(2.0, Math.floor((Math.log((double) array.length) / Math.log(2.0)) + 1)));\n\t        heap = new Node[size];\n\t        build(1, 0, array.length);\n\t    }\n\n\n\t    public int size() {\n\t        return array.length;\n\t    }\n\n\t    //Initialize the Nodes of the Segment tree\n\t    private void build(int v, int from, int size) {\n\t        heap[v] = new Node();\n\t        heap[v].from = from;\n\t        heap[v].to = from + size - 1;\n\n\t        if (size == 1) {\n\t            heap[v].sum = array[from];\n\t            heap[v].min = array[from];\n\t        } else {\n\t            //Build childs\n\t            build(2 * v, from, size / 2);\n\t            build(2 * v + 1, from + size / 2, size - size / 2);\n\n\t            heap[v].sum = heap[2 * v].sum + heap[2 * v + 1].sum;\n\t            //min = min of the children\n\t            heap[v].min = Math.min(heap[2 * v].min, heap[2 * v + 1].min);\n\t        }\n\t    }\n\n\t    /**\n\t     * Range Sum Query\n\t     *\n\t     * Time-Complexity: O(log(n))\n\t     *\n\t     * @param  from from index\n\t     * @param  to to index\n\t     * @return sum\n\t     */\n\t    public long rangeSum(int from, int to) {\n\t        return rangeSum(1, from, to);\n\t    }\n\n\t    private long rangeSum(int v, int from, int to) {\n\t        Node n = heap[v];\n\n\t        //If you did a range update that contained this node, you can infer the Sum without going down the tree\n\t        if (n.pendingVal != null && contains(n.from, n.to, from, to)) {\n\t            return (to - from + 1) * n.pendingVal;\n\t        }\n\n\t        if (contains(from, to, n.from, n.to)) {\n\t            return heap[v].sum;\n\t        }\n\n\t        if (intersects(from, to, n.from, n.to)) {\n\t            propagate(v);\n\t            long leftSum = rangeSum(2 * v, from, to);\n\t            long rightSum = rangeSum(2 * v + 1, from, to);\n\n\t            return leftSum + rightSum;\n\t        }\n\n\t        return 0;\n\t    }\n\n\t    /**\n\t     * Range Min Query\n\t     * \n\t     * Time-Complexity: O(log(n))\n\t     *\n\t     * @param  from from index\n\t     * @param  to to index\n\t     * @return min\n\t     */\n\t    public long rangeMin(int from, int to) {\n\t        return rangeMin(1, from, to);\n\t    }\n\n\t    private long rangeMin(int v, int from, int to) {\n\t        Node n = heap[v];\n\n\n\t        //If you did a range update that contained this node, you can infer the Min value without going down the tree\n\t        if (n.pendingVal != null && contains(n.from, n.to, from, to)) {\n\t            return n.pendingVal;\n\t        }\n\n\t        if (contains(from, to, n.from, n.to)) {\n\t            return heap[v].min;\n\t        }\n\n\t        if (intersects(from, to, n.from, n.to)) {\n\t            propagate(v);\n\t            long leftMin = rangeMin(2 * v, from, to);\n\t            long rightMin = rangeMin(2 * v + 1, from, to);\n\n\t            return Math.min(leftMin, rightMin);\n\t        }\n\n\t        return Integer.MAX_VALUE;\n\t    }\n\n\n\t    /**\n\t     * Range Update Operation.\n\t     * With this operation you can update either one position or a range of positions with a given number.\n\t     * The update operations will update the less it can to update the whole range (Lazy Propagation).\n\t     * The values will be propagated lazily from top to bottom of the segment tree.\n\t     * This behavior is really useful for updates on portions of the array\n\t     * <p>\n\t     * Time-Complexity: O(log(n))\n\t     *\n\t     * @param from  from index\n\t     * @param to    to index\n\t     * @param value value\n\t     */\n\t    public void update(int from, int to, int value) {\n\t        update(1, from, to, value);\n\t    }\n\n\t    private void update(int v, int from, int to, int value) {\n\n\t        //The Node of the heap tree represents a range of the array with bounds: [n.from, n.to]\n\t        Node n = heap[v];\n\n\t        /**\n\t         * If the updating-range contains the portion of the current Node  We lazily update it.\n\t         * This means We do NOT update each position of the vector, but update only some temporal\n\t         * values into the Node; such values into the Node will be propagated down to its children only when they need to.\n\t         */\n\t        if (contains(from, to, n.from, n.to)) {\n\t            change(n, value);\n\t        }\n\n\t        if (n.size() == 1) return;\n\n\t        if (intersects(from, to, n.from, n.to)) {\n\t            /**\n\t             * Before keeping going down to the tree We need to propagate the\n\t             * the values that have been temporally/lazily saved into this Node to its children\n\t             * So that when We visit them the values  are properly updated\n\t             */\n\t            propagate(v);\n\n\t            update(2 * v, from, to, value);\n\t            update(2 * v + 1, from, to, value);\n\n\t            n.sum = heap[2 * v].sum + heap[2 * v + 1].sum;\n\t            n.min = Math.min(heap[2 * v].min, heap[2 * v + 1].min);\n\t        }\n\t    }\n\t    \n\t   /*public void rangeAdd(int tl, int tr, int l, int r, int add) {\n\t    \trangeAdd(1, tl, tr, l, r, add);\n\t    }\n\t    \n\t    private void rangeAdd(int v, int tl, int tr, int l, int r, int add) {\n\t        if (l > r)\n\t            return;\n\t        if (l == tl && r == tr) {\n\t            heap[v].sum += add;\n\t        } else {\n\t            int tm = (tl + tr) / 2;\n\t            rangeAdd(v*2, tl, tm, l, Math.min(r, tm), add);\n\t            rangeAdd(v*2+1, tm+1, tr, Math.max(l, tm+1), r, add);\n\t        }\n\t    }*/\n\n\t    //Propagate temporal values to children\n\t    private void propagate(int v) {\n\t        Node n = heap[v];\n\n\t        if (n.pendingVal != null) {\n\t            change(heap[2 * v], n.pendingVal);\n\t            change(heap[2 * v + 1], n.pendingVal);\n\t            n.pendingVal = null; //unset the pending propagation value\n\t        }\n\t    }\n\n\t    //Save the temporal values that will be propagated lazily\n\t    private void change(Node n, int value) {\n\t        n.pendingVal = value;\n\t        n.sum = n.size() * value;\n\t        n.min = value;\n\t        array[n.from] = value;\n\n\t    }\n\n\t    //Test if the range1 contains range2\n\t    private boolean contains(int from1, int to1, int from2, int to2) {\n\t        return from2 >= from1 && to2 <= to1;\n\t    }\n\n\t    //check inclusive intersection, test if range1[from1, to1] intersects range2[from2, to2]\n\t    private boolean intersects(int from1, int to1, int from2, int to2) {\n\t        return from1 <= from2 && to1 >= from2   //  (.[..)..] or (.[...]..)\n\t                || from1 >= from2 && from1 <= to2; // [.(..]..) or [..(..)..\n\t    }\n\n\t    //The Node class represents a partition range of the array.\n\t    static class Node {\n\t        long sum;\n\t        long min;\n\t        //Here We store the value that will be propagated lazily\n\t        Integer pendingVal = null;\n\t        int from;\n\t        int to;\n\n\t        int size() {\n\t            return to - from + 1;\n\t        }\n\n\t    }\n\t}\n}\n\n// NOTES: \n// ASCII VALUE OF 'A': 65\n// ASCII VALUE OF 'a': 97\n// Range of long: 9 * 10^18\n// ASCII VALUE OF '0': 48"
        },
        {
            "language": 4,
            "solution": "//package src;\n\nimport java.util.Scanner;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.StringBuilder;\nimport java.math.BigInteger;\n\npublic class idk {\n\tstatic Scanner scn = new Scanner(System.in);\n\tstatic int mod = 1000000007;\n\n\tpublic static void main(String args[]) {\n\n\t\tint n=scn.nextInt();\n\t\tlong arr[]=new long[n],brr[]=new long[n],a=0;\n\t\tarr[0]=scn.nextLong();brr[0]=scn.nextLong();\n\t\ta=arr[0]*brr[0];\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tarr[i]=scn.nextLong();\n\t\t\tbrr[i]=scn.nextLong();\n\t\t\t\ta=gcd(arr[i]*brr[i],a);\n\t\t}\n\t\t\n//\t\tSystem.out.println(a);\n\t\ta=findgcd(arr, brr, n, a);\n\t\tif(n==1)\n\t\t\tSystem.out.println(arr[0]);\n\t\telse if(a>1)\n\t\t\tSystem.out.println(a);\n\t\telse \n\t\t\tSystem.out.println(\"-1\");\n\n\t}\n\tpublic static long findgcd(long arr[],long brr[],int n,long ans)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n            ans = Math.max(gcd(ans,arr[i]),gcd(ans,brr[i]));\n        return ans;\n\t}\n\n\tpublic static int binarysearch(Long arr[], int l, int r, int key) {\n\t\tint mid, ans = r;\n\t\twhile (l <= r) {\n\t\t\tmid = l + (r - l) / 2;\n\t\t\tif (arr[mid] == key) {\n\t\t\t\tl = mid + 1;\n\t\t\t\tans = mid;\n\t\t\t} else if (arr[mid] > key) {\n\t\t\t\tr = mid - 1;\n\t\t\t\tans = r;\n\t\t\t} else {\n\t\t\t\tl = mid + 1;\n\t\t\t}\n\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tpublic static boolean word(String arr[], String str, String ori, HashMap<String, Integer> map, int i, int j) {\n\t\tif (j == str.length()) { // System.out.println(str);\n\t\t\tif (str.length() == 0)\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tString re = ori.substring(i, j);\n\t\tSystem.out.println(re);\n\t\tif (map.containsKey(re)) {\n\t\t\tString res = ori.substring(j);\n\n\t\t\treturn word(arr, str, ori, map, j, j);\n\t\t}\n\n\t\treturn word(arr, str, ori, map, i, j + 1);\n\n\t}\n\n\tpublic static int decode(String str, int i, int[] memo) {\n\t\tif (i == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tint ind = str.length() - i;\n\t\tif (str.charAt(ind) == '0')\n\t\t\treturn 0;\n\t\tif (memo[i] != -1)\n\t\t\treturn memo[i];\n\t\tint res = decode(str, i - 1, memo);\n\t\tif (i >= 2 && Integer.parseInt(str.substring(ind, ind + 2)) <= 26) {\n\t\t\tres += decode(str, i - 2, memo);\n\t\t}\n\t\tmemo[i] = res;\n\t\treturn res;\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn  b;\n\t\treturn  gcd(b % a, a);\n\t}\n\n\tpublic static String factorial(int n) {\n\t\tBigInteger fac = new BigInteger(\"1\");\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfac = fac.multiply(BigInteger.valueOf(i));\n\t\t}\n\t\treturn fac.toString();\n\t}\n\n}\n\nclass pair {\n\tint a;\n\tint b;\n\n\tpair(int x, int y) {\n\t\tthis.a = x;\n\t\tthis.b = y;\n\t}\n}\n\nclass sorting implements Comparator<pair> {\n\n\t@Override\n\tpublic int compare(pair o1, pair o2) {\n\t\t// TODO Auto-generated method stub\n\t\tint x = o1.a - o2.a, y = o1.b - o2.b;\n\t\tif (y == 0) {\n\t\t\tif (x >= 0)\n\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn 1;\n\t\t} else if (y > 0)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n   public static ArrayList<Long> al1=new ArrayList<Long>();\n   public static ArrayList<Long> al2=new ArrayList<Long>();\n\n   public static void primeFactors(long n,ArrayList<Long> al)\n   {\n       // Print the number of 2s that divide n\n       \n       if(n%2==0)\n        al.add((long)2);\n\n       while (n%2==0)\n       {\n           \n           n /= 2;\n       }\n       \n       // n must be odd at this point.  So we can\n       // skip one element (Note i = i +2)\n       for (int i = 3; i <= Math.sqrt(n); i+= 2)\n       {\n           // While i divides n, print i and divide n\n           if(n%(long)i==0)\n            al.add((long)i);\n           while (n%(long)i == 0)\n           {\n            //    System.out.print(i + \" \");\n               n /= (long)i;\n           }\n       }\n\n       // This condition is to handle the case whien\n       // n is a prime number greater than 2\n       if (n > 2)\n        al.add(n);\n        //    System.out.print(n);\n   }\n\n    public static void main(String[] args) {\n\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n        \n          }\n\n\n\n\n    static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            \n\n           int n = inp.nextInt();\n           long arr[][] = new long[n][2];\n           long sol[][] = new long[n][2];\n           for(int i=0;i<n;i++)\n           {\n               arr[i][0] = inp.nextLong();\n               arr[i][1] = inp.nextLong();\n           }\n           boolean flag=true;\n           primeFactors(arr[0][0], al1);\n           primeFactors(arr[0][1], al2);\n\n           for(int i=0;i<al1.size();i++)\n           {\n               flag = true;\n               for(int j=0;j<n;j++)\n               {\n                    if(arr[j][0]%al1.get(i)!=0&&arr[j][1]%al1.get(i)!=0)\n                    {\n                        flag = false;\n                    }\n               }\n               if(flag)\n               {\n                   out.println(al1.get(i));\n                   return;\n               }\n           }\n           \n\n           for(int i=0;i<al2.size();i++)\n           {\n               flag = true;\n               for(int j=0;j<n;j++)\n               {\n                    if(arr[j][0]%al2.get(i)!=0&&arr[j][1]%al2.get(i)!=0)\n                    {\n                        flag = false;\n                    }\n               }\n               if(flag)\n               {\n                   out.println(al2.get(i));\n                   return;\n               }\n           }\n           out.println(\"-1\");\n\n\n\n        }\n    }\n\n\n\n\n\n\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst unsigned long long maxn = 150060;\nstruct node {\n  unsigned long long a, b;\n} s[maxn];\nunsigned long long gcd(unsigned long long a, unsigned long long b) {\n  while (b ^= a ^= b ^= a %= b)\n    ;\n  return a;\n}\nint main() {\n  unsigned long long n;\n  cin >> n;\n  unsigned long long minn = 1ll << 60;\n  cin >> s[0].a >> s[0].b;\n  if (n == 1) {\n    if (max(s[0].a, s[0].b) == 1)\n      cout << -1 << endl;\n    else\n      cout << max(s[0].a, s[0].b) << endl;\n  } else {\n    unsigned long long ans = s[0].a * s[0].b;\n    for (unsigned long long i = 1; i < n; i++) {\n      cin >> s[i].a >> s[i].b;\n      minn = min(minn, s[i].a);\n      minn = min(minn, s[i].b);\n      ans = gcd(ans, s[i].a * s[i].b);\n    }\n    if (ans == 1)\n      cout << -1 << endl;\n    else {\n      for (int i = 0; i < n; i++) {\n        if (gcd(ans, s[i].a) > 1) {\n          ans = gcd(ans, s[i].a);\n        } else {\n          ans = gcd(ans, s[i].b);\n        }\n      }\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def countdiv(n) : \n    count=set()\n    i = 2\n    nn=n\n    while n>1:\n        if n%i==0: \n            count.add(i)\n            n//=i\n        else: i+=1\n        if i>nn**0.5+1:\n            count.add(n)\n            break\n    return count\ndef countt(n,s):\n    ss=set()\n    for i in s:\n        if n%i==0: ss.add(i)\n    return ss\nn=int(input())\na=list(map(int,input().split()))\ns=countdiv(a[0]).union(countdiv(a[1]))\nfor itr in range(1,n):\n    a=list(map(int,input().split()))\n    s=countt(a[0]*a[1],s)\n    if len(s)==0: break\nif len(s)==0: print(-1)\nelse: print(list(s)[0])"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\ndef check(f):\n    for Ai, Bi in AB:\n        if Ai%f!=0 and Bi%f!=0:\n            return False\n    \n    return True\n\ndef factorize(n):\n    factors = []\n    \n    for i in range(2, int(n**0.5)+1):\n        cnt = 0\n        \n        while n%i==0:\n            n //= i\n            cnt += 1\n            \n        if cnt>0:\n            factors.append((i, cnt))\n    \n    if n>1:\n        factors.append((n, 1))\n    \n    return factors\n\nn = int(input())\nAB = [tuple(map(int, input().split())) for _ in range(n)]\ncands = factorize(AB[0][0])+factorize(AB[0][1])\n\nfor f, _ in cands:\n    if check(f):\n        print(f)\n        exit()\n        \nprint(-1)"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nf=sys.stdin\n\ndef prime_factors(n):\n\tif n%2==0:\n\t\treturn 2\n\td=3\n\tsqrt=(n**0.5)+1\n\twhile n>1:\n\t\tif n%d==0:\n\t\t\treturn d\n\t\td+=2\n\t\tif d>sqrt:\n\t\t\treturn n\n\nn=int(f.readline().rstrip('\\r\\n'))\ngcd=0\nfor i in range(n):\n\ta,b=map(int,f.readline().rstrip('\\r\\n').split())\n\ttmp=max(a,b)%min(a,b)\n\tif tmp==0:\n\t\tgcd=math.gcd(gcd,max(a,b))\n\telse:\n\t\tgcd=math.gcd(gcd,a*b)\n\nif gcd>1:\n\tif gcd<=10000000000:\n\t\tsys.stdout.write(str(prime_factors(gcd))+\"\\n\")\n\telse:\n\t\tif (math.gcd(gcd,a)>1):\n\t\t\tsys.stdout.write(str(math.gcd(gcd,a))+\"\\n\")\n\t\telse:\n\t\t\tsys.stdout.write(str(math.gcd(gcd,b))+'\\n')\nelse:\n\tsys.stdout.write(\"-1\\n\")"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.AbstractCollection;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Iterator;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tstatic class TaskAdapter implements Runnable {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tlong startTime = System.currentTimeMillis();\n\t\t\tInputStream inputStream = System.in;\n\t\t\tOutputStream outputStream = System.out;\n\t\t\tFastReader in = new FastReader(inputStream);\n\t\t\tOutput out = new Output(outputStream);\n\t\t\tBWeakenedCommonDivisor solver = new BWeakenedCommonDivisor();\n\t\t\tsolver.solve(1, in, out);\n\t\t\tout.close();\n\t\t\tSystem.err.println(System.currentTimeMillis()-startTime+\"ms\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tThread thread = new Thread(null, new TaskAdapter(), \"\", 1<<28);\n\t\tthread.start();\n\t\tthread.join();\n\t}\n\n\tstatic class BWeakenedCommonDivisor {\n\t\tArrayList<Integer> primes = Utilities.sieve(44721);\n\n\t\tpublic BWeakenedCommonDivisor() {\n\t\t}\n\n\t\tpublic ArrayList<Integer> pf(int x) {\n\t\t\tArrayList<Integer> ret = new ArrayList<>();\n\t\t\tfor(int i: primes) {\n\t\t\t\tboolean valid = false;\n\t\t\t\twhile(x%i==0) {\n\t\t\t\t\tvalid = true;\n\t\t\t\t\tx /= i;\n\t\t\t\t}\n\t\t\t\tif(valid) {\n\t\t\t\t\tret.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x>1) {\n\t\t\t\tret.add(x);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void solve(int kase, InputReader in, Output pw) {\n\t\t\tint n = in.nextInt()-1;\n\t\t\tHashSet<Integer> valid = new HashSet<>();\n\t\t\tvalid.addAll(pf(in.nextInt()));\n\t\t\tvalid.addAll(pf(in.nextInt()));\n//\t\t\tUtilities.Debug.dbg(valid);\n\t\t\tfor(int i = 0; i<n; i++) {\n\t\t\t\tHashSet<Integer> nvalid = new HashSet<>();\n\t\t\t\tint a = in.nextInt(), b = in.nextInt();\n\t\t\t\tfor(int j: valid) {\n\t\t\t\t\tif(a%j==0||b%j==0) {\n\t\t\t\t\t\tnvalid.add(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvalid = nvalid;\n\t\t\t}\n\t\t\tif(valid.isEmpty()) {\n\t\t\t\tpw.println(-1);\n\t\t\t}else {\n\t\t\t\tpw.println(valid.iterator().next());\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class Utilities {\n\t\tpublic static ArrayList<Integer> sieve(int n) {\n\t\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\t\tboolean[] prime = new boolean[n+1];\n\t\t\tArrays.fill(prime, true);\n\t\t\tfor(int i = 2; i<=n; i++) {\n\t\t\t\tif(prime[i]) {\n\t\t\t\t\tans.add(i);\n\t\t\t\t}\n\t\t\t\tif((long) i*i>n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int j = i*i; j<=n; j += i) {\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic static class Debug {\n\t\t\tpublic static final boolean LOCAL = System.getProperty(\"ONLINE_JUDGE\")==null;\n\n\t\t\tprivate static <T> String ts(T t) {\n\t\t\t\tif(t==null) {\n\t\t\t\t\treturn \"null\";\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\treturn ts((Iterable) t);\n\t\t\t\t}catch(ClassCastException e) {\n\t\t\t\t\tif(t instanceof int[]) {\n\t\t\t\t\t\tString s = Arrays.toString((int[]) t);\n\t\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\";\n\t\t\t\t\t}else if(t instanceof long[]) {\n\t\t\t\t\t\tString s = Arrays.toString((long[]) t);\n\t\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\";\n\t\t\t\t\t}else if(t instanceof char[]) {\n\t\t\t\t\t\tString s = Arrays.toString((char[]) t);\n\t\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\";\n\t\t\t\t\t}else if(t instanceof double[]) {\n\t\t\t\t\t\tString s = Arrays.toString((double[]) t);\n\t\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\";\n\t\t\t\t\t}else if(t instanceof boolean[]) {\n\t\t\t\t\t\tString s = Arrays.toString((boolean[]) t);\n\t\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\";\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn ts((Object[]) t);\n\t\t\t\t\t}catch(ClassCastException e1) {\n\t\t\t\t\t\treturn t.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate static <T> String ts(T[] arr) {\n\t\t\t\tStringBuilder ret = new StringBuilder();\n\t\t\t\tret.append(\"{\");\n\t\t\t\tboolean first = true;\n\t\t\t\tfor(T t: arr) {\n\t\t\t\t\tif(!first) {\n\t\t\t\t\t\tret.append(\", \");\n\t\t\t\t\t}\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tret.append(ts(t));\n\t\t\t\t}\n\t\t\t\tret.append(\"}\");\n\t\t\t\treturn ret.toString();\n\t\t\t}\n\n\t\t\tprivate static <T> String ts(Iterable<T> iter) {\n\t\t\t\tStringBuilder ret = new StringBuilder();\n\t\t\t\tret.append(\"{\");\n\t\t\t\tboolean first = true;\n\t\t\t\tfor(T t: iter) {\n\t\t\t\t\tif(!first) {\n\t\t\t\t\t\tret.append(\", \");\n\t\t\t\t\t}\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tret.append(ts(t));\n\t\t\t\t}\n\t\t\t\tret.append(\"}\");\n\t\t\t\treturn ret.toString();\n\t\t\t}\n\n\t\t\tpublic static void dbg(Object... o) {\n\t\t\t\tif(LOCAL) {\n\t\t\t\t\tSystem.err.print(\"Line #\"+Thread.currentThread().getStackTrace()[2].getLineNumber()+\": [\");\n\t\t\t\t\tfor(int i = 0; i<o.length; i++) {\n\t\t\t\t\t\tif(i!=0) {\n\t\t\t\t\t\t\tSystem.err.print(\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSystem.err.print(ts(o[i]));\n\t\t\t\t\t}\n\t\t\t\t\tSystem.err.println(\"]\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class Output implements Closeable, Flushable {\n\t\tpublic StringBuilder sb;\n\t\tpublic OutputStream os;\n\t\tpublic int BUFFER_SIZE;\n\t\tpublic String lineSeparator;\n\n\t\tpublic Output(OutputStream os) {\n\t\t\tthis(os, 1<<16);\n\t\t}\n\n\t\tpublic Output(OutputStream os, int bs) {\n\t\t\tBUFFER_SIZE = bs;\n\t\t\tsb = new StringBuilder(BUFFER_SIZE);\n\t\t\tthis.os = new BufferedOutputStream(os, 1<<17);\n\t\t\tlineSeparator = System.lineSeparator();\n\t\t}\n\n\t\tpublic void println(int i) {\n\t\t\tprintln(String.valueOf(i));\n\t\t}\n\n\t\tpublic void println(String s) {\n\t\t\tsb.append(s);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println() {\n\t\t\tsb.append(lineSeparator);\n\t\t}\n\n\t\tprivate void flushToBuffer() {\n\t\t\ttry {\n\t\t\t\tos.write(sb.toString().getBytes());\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tsb = new StringBuilder(BUFFER_SIZE);\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\ttry {\n\t\t\t\tflushToBuffer();\n\t\t\t\tos.flush();\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic void close() {\n\t\t\tflush();\n\t\t\ttry {\n\t\t\t\tos.close();\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic interface InputReader {\n\t\tint nextInt();\n\n\t}\n\n\tstatic class FastReader implements InputReader {\n\t\tfinal private int BUFFER_SIZE = 1<<16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer;\n\t\tprivate int bytesRead;\n\n\t\tpublic FastReader(InputStream is) {\n\t\t\tdin = new DataInputStream(is);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint ret = 0;\n\t\t\tbyte c = skipToDigit();\n\t\t\tboolean neg = (c=='-');\n\t\t\tif(neg) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = ret*10+c-'0';\n\t\t\t} while((c = read())>='0'&&c<='9');\n\t\t\tif(neg) {\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate boolean isDigit(byte b) {\n\t\t\treturn b>='0'&&b<='9';\n\t\t}\n\n\t\tprivate byte skipToDigit() {\n\t\t\tbyte ret;\n\t\t\twhile(!isDigit(ret = read())&&ret!='-') ;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() {\n\t\t\ttry {\n\t\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif(bytesRead==-1) {\n\t\t\t\tbuffer[0] = -1;\n\t\t\t}\n\t\t}\n\n\t\tprivate byte read() {\n\t\t\tif(bytesRead==-1) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}else if(bufferPointer==bytesRead) {\n\t\t\t\tfillBuffer();\n\t\t\t}\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t}\n}\n\n"
        },
        {
            "language": 3,
            "solution": "\ndef gcd(a,b): \n    if(b==0): \n        return a \n    else: \n        return gcd(b,a%b) \n\n\nn=int(input())\n\n\nsum=0 \nl,r=0,0\nwhile n>0:\n      \n      l,r=input().split()\n      l=int(l)\n      r=int(r)\n      t=gcd(l,r)\n      t=int(l*r)//t\n      sum=gcd(sum,t)\n      n-=1\n\nif sum==1:\n    print(-1)\nelif gcd(l,sum)==1:\n    i=2\n    sum=gcd(r,sum)\n    while sum>=i*i:\n      if sum%i==0:\n         sum=i\n         break\n      i+=1\n    print(int(sum))\nelse :\n    i=2\n    sum=gcd(l,sum)\n    while sum>=i*i:\n      if sum%i==0:\n         sum=i\n         break\n      i+=1\n    print(int(sum))\n    \n    \n    \n    \n    "
        },
        {
            "language": 3,
            "solution": "import math\n\n\n\ngcd = 0\n\nn = int(input())\n\na, b = [0]*n, [0]*n\n\nfor i in range(n):\n\n    a[i], b[i] = map(int, input().split())\n\n    gcd = math.gcd(gcd, a[i] * b[i])\n\nfor i in range(n):\n\n    if (math.gcd(gcd, a[i]) > 1):\n\n        gcd = math.gcd(gcd, a[i])\n\n    else:\n\n        gcd = math.gcd(gcd, b[i])\n\nprint(-1 if gcd==1 else gcd)\n\n\n\n\n\n# Made By Mostafa_Khaled"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/python\nimport sys\nimport math\ndef gcd(a, b):\n    if a == 0: \n        return b\n    return gcd(b % a, a)\n\nN = int(input())\nx, y = map(int, input().split(' '))\ndivisor = 2\nresult = []\nwhile divisor <= math.sqrt(max(x,y)):\n    if (x % divisor == 0) or (y % divisor == 0):\n        result.append(divisor)\n        while x % divisor == 0:\n            x /= divisor\n        while y % divisor == 0:\n            y /= divisor\n    divisor += 1\nif (x > 1):\n    result.append(x)    \nif (y > 1):\n    result.append(y)\nfor i in range(1, N):\n    x, y = map(int, input().split(' '))\n    new_result = [i for i in result if ((x % i == 0) or (y % i == 0))]\n    result = new_result\nif len(result) < 1:\n    print(-1)\nelse:\n    print(int(result[0]))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e9 + 7;\nlong long powmod(long long a, long long b) {\n  long long res = 1;\n  a %= M;\n  assert(b >= 0);\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a % M;\n    a = a * a % M;\n  }\n  return res % M;\n}\nconst int N = 1e5 + 10;\nbool mark[N];\nvector<int> prime;\nint main() {\n  int n;\n  cin >> n;\n  int a[n][2];\n  for (int i = 2; i * i < N; i++) {\n    if (mark[i] == 0) {\n      for (int j = i + i; j < N; j += i) {\n        mark[j] = 1;\n      }\n    }\n  }\n  for (int i = 2; i < N; i++) {\n    if (mark[i] == 0) prime.push_back(i);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2; ++j) scanf(\"%d\", &a[i][j]);\n  }\n  int t1 = a[0][0];\n  int t2 = a[0][1];\n  vector<int> v1, v2;\n  for (int i = 0; i < prime.size(); i++) {\n    int cnt = 0;\n    while (a[0][0] % prime[i] == 0) {\n      cnt = 1;\n      a[0][0] /= prime[i];\n    }\n    if (cnt) v1.push_back(prime[i]);\n  }\n  if (a[0][0] != 1) v1.push_back(a[0][0]);\n  for (int i = 0; i < prime.size(); i++) {\n    int cnt = 0;\n    while (a[0][1] % prime[i] == 0) {\n      cnt = 1;\n      a[0][1] /= prime[i];\n    }\n    if (cnt) v2.push_back(prime[i]);\n  }\n  if (a[0][1] != 1) v2.push_back(a[0][1]);\n  a[0][0] = t1;\n  a[0][1] = t2;\n  for (int i = 0; i < v1.size(); i++) {\n    int flag = 0;\n    for (int j = 0; j < n; j++) {\n      if (a[j][0] % v1[i] == 0 || a[j][1] % v1[i] == 0)\n        ;\n      else {\n        flag = 1;\n        break;\n      }\n    }\n    if (flag == 0) {\n      printf(\"%d\\n\", v1[i]);\n      return 0;\n    }\n  }\n  for (int i = 0; i < v2.size(); i++) {\n    int flag = 0;\n    for (int j = 0; j < n; j++) {\n      if (a[j][0] % v2[i] == 0 || a[j][1] % v2[i] == 0)\n        ;\n      else {\n        flag = 1;\n        break;\n      }\n    }\n    if (flag == 0) {\n      printf(\"%d\\n\", v2[i]);\n      return 0;\n    }\n  }\n  puts(\"-1\");\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nn=int(input())\na,b=map(int,input().split())\npms=[a,b]\nfor i in range(2,math.ceil(math.sqrt(a))+1):\n    cur=0\n    if i!=a and a%i==0:\n        pms.append(i)\n        while a%i==0:\n            a=a//i\nif a >1:\n    pms.append(a)\nfor i in range(2,math.ceil(math.sqrt(b))+1):\n    if i!=b and b%i==0:\n        pms.append(i)\n        while b%i==0:\n            b=b//i\nif b>1:\n    pms.append(b)\npms=list(set(pms))\npms1=[]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    for j in pms:\n        if a%j==0 or b%j==0:\n            pms1.append(j)\n    pms=pms1\n    if len(pms)==0:\n        break\n    pms1=[]\nif len(pms):\n    print(pms[0])\nelse:\n    print(-1)"
        },
        {
            "language": 1,
            "solution": "def gcd(a, b):\n    if a % b == 0:\n        return b\n\n    return gcd(b, a % b)\n\n\nn = input()\npairs = [map(int, raw_input().strip().split()) for _ in range(n)]\n\ng = pairs[0][0] * pairs[0][1]\nfor pair in pairs[1:]:\n    g = gcd(pair[0] * pair[1], g)\n\nif g == 1:\n    print -1\n    exit()\n\nfor pair in pairs:\n    gt = gcd(pair[0], g)\n    g = gt if gt != 1 else gcd(pair[1], g)\n\nprint g\n"
        },
        {
            "language": 4,
            "solution": "//package acmp;\n\nimport java.util.*;\nimport java.math.*;\n\npublic class Acmp {\n        \n    public static void main(String[] args){\n        \n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        \n        int pair[][] = new int[n][2];\n        for(int i = 0; i < n; i++){\n            pair[i][0] = in.nextInt();\n            pair[i][1] = in.nextInt();\n        }\n        \n        int a = pair[0][0];\n        int b = pair[0][1];\n        \n        ArrayList<Integer> list = new ArrayList<>();\n        int i = 2;\n        while(i <= Math.sqrt(a)){\n            if(a % i == 0){\n                a /= i;\n                list.add(i);\n            } else i++;\n        }\n        if(a > 1) list.add(a);\n        \n        i = 2;\n        while(i <= Math.sqrt(b)){\n            if(b % i == 0){\n                b /= i;\n                list.add(i);\n            } else i++;\n        }\n        if(b > 1) list.add(b);\n        \n        for(i = 0; i < list.size(); i++){\n            for(int j = i + 1; j < list.size(); j++){\n                if(list.get(i) > list.get(j)){\n                    int c = list.get(i);\n                    list.set(i, list.get(j));\n                    list.set(j, c);\n                }\n            }\n        }\n        \n        i = 1;\n        while(i < list.size()){\n            if(list.get(i) == list.get(i-1)){\n                list.remove(i);\n            } else i++;\n        }\n        \n        //for(i = 0; i < list.size(); i++) System.out.println(list.get(i));\n        \n        int result = -1;\n        metka: for(i = 0; i < list.size(); i++){\n            for(int j = 0; j < n; j++){\n                if(pair[j][0] % list.get(i) == 0 || pair[j][1] % list.get(i) == 0);\n                else continue metka;\n            }\n            result = list.get(i);\n            break;\n        }\n        \n        System.out.println(result);\n        \n    }\n    \n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\n\n\ndef fast2():\n    import os, sys, atexit\n    from cStringIO import StringIO as BytesIO\n    # range = xrange\n    sys.stdout = BytesIO()\n    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))\n    return BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ndef factorize(n):  # o(sqr(n))\n    c, ans = 2, [n]\n    while (c * c <= n):\n        if n % c == 0:\n            ans.extend([c, n // c])\n        c += 1\n\n    ans.sort()\n    primes = set()\n    for i in ans:\n        while n % i == 0:\n            n //= i\n            primes.add(i)\n    return list(primes)\n\n\ninput = fast2()\nrints = lambda: [int(x) for x in input().split()]\nrints_2d = lambda n: [rints() for _ in range(n)]\n\nn = int(input())\na = rints_2d(n)\nfor i in range(2):\n    for f in factorize(a[0][i]):\n        ans = 1\n        for j in range(1, n):\n            ans &= a[j][0] % f == 0 or a[j][1] % f == 0\n        if ans:\n            print(f)\n            exit()\n\nprint(-1)\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.Scanner; \nimport java.util.StringTokenizer; \nimport java.util.*;\n  \npublic class er10a\n{ \n    //By shwetank_verma\n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n    static int mod=1000000007;\n    static boolean primes[]=new boolean[1000007];\n    static ArrayList<Integer> b=new ArrayList<>();\n    static void seive(int n){\n        Arrays.fill(primes,true);\n        primes[0]=primes[1]=false;\n        for(int i=2;i*i<=n;i++){\n            if(primes[i]==true){\n                for(int p=i*i;p<=n;p+=i){\n                    primes[p]=false;\n                }\n            }\n        }\n        if(n<1000007){\n        \tfor(int i=2;i<=n;i++) {\n        \t\tif(primes[i])\n        \t\t\tb.add(i);\n        \t}\n        \t\n                 }\n        \n        \n    }\n    static int gcd(int a,int b){\n        if(b==0)\n        return a;\n        return gcd(b,a%b);\n    }\n    static long GCD(long a,long b){\n        if(b==0)\n        return a;\n        return GCD(b,a%b);\n    }\n    static ArrayList<Integer> segseive(int l,int r){\n    \t\n    \tArrayList<Integer> isprime=new ArrayList<Integer>();\n    \tboolean p[]=new boolean[r-l+1];\n    \tArrays.fill(p, true);\n        \n    \tfor(int i=0;b.get(i)*b.get(i)<=r;i++) {\n    \t\tint currprime=b.get(i);\n    \t\tint base=(l/currprime)*currprime;\n    \t\tif(base<l) {\n    \t\t\tbase+=currprime;\n    \t\t}\n    \t\tfor(int j=base;j<=r;j+=currprime) {\n    \t\t\tp[j-l]=false;\n    \t\t}\n    \t\t\n    \t\t\n    \t\tif(base==currprime) {\n    \t\t\tp[base-l]=true;\n    \t\t}\n    \t\t\n    \t}\n    \tfor(int i=0;i<=r-l;i++) {\n    \t\tif(p[i])\n    \t\t\tisprime.add(i+l);\n    \t}\n    \treturn isprime;\n    }\n      static int LowerBound(int a[], int x) { // x is the target value or key\n  int l=-1,r=a.length;\n  while(l+1<r) {\n    int m=(l+r)>>>1;\n    if(a[m]>=x) r=m;\n    else l=m;\n  }\n  return r;\n}\nstatic int UpperBound(int a[], int x) {// x is the key or target value\n    int l=-1,r=a.length;\n    while(l+1<r) {\n       int m=(l+r)>>>1;\n       if(a[m]<=x) l=m;\n       else r=m;\n    }\n    return l+1;\n }\n static void addEdge(ArrayList<ArrayList<Integer>> adj,int u,int v) {\n\t adj.get(u).add(v);\n\t adj.get(v).add(u);\n }\n static void BFS(ArrayList<ArrayList<Integer>> adj,int s,boolean visited[]) {\n\t Queue<Integer> q=new LinkedList<>();\n\t q.add(s);\n\t visited[s]=true;\n\t while(!q.isEmpty()) {\n\t\t int u=q.poll();\n\t\t for(int v:adj.get(u)) {\n\t\t\t if(!visited[v]) {\n\t\t\t\t visited[v]=!visited[v];\n\t\t\t\t q.add(v);\n\t\t\t }\n\t\t }\n\t }\n }\n static int BFSconnectedcount(ArrayList<ArrayList<Integer>> adj,int v) {\n\t boolean visited[]=new boolean[v+1];\n\t int count=0;\n\t for(int i=0;i<v;i++) {\n\t\t if(!visited[i]) {\n\t\t\t BFS(adj,i,visited);\n\t\t\t count++;\n\t\t }\n\t }\n\t return count;\n }\n public static long power(long x, long y, long p) {\n     long res = 1;\n     x = x % p;\n     while (y>0) {\n        if ((y&1)==1) {\n           res = (res*x) % p;\n        }\n        y = y >> 1;\n        x = ( x * x ) % p;\n     }\n     return res;\n  }\n public static long monInverse( long n, long p) {\n     return power(n, p-2, p);\n  }\n  public static long nCrModPFermat( int n, int r, int p) {\n     long[] fac = new long[n+1];\n     fac[0] = 1;\n     for (int i = 0; i < n; i++) {\n        fac[i+1] = (fac[i]*(i+1))%p;\n     }\nlong x = monInverse(fac[r], p);\nlong y = monInverse(fac[n-r], p);\n//System.out.println(fac[n]);\n     return (((fac[n]*x)% p) * ( y%p) ) % p;\n  }\n  \n    public static void main(String[] args) \n    { \n        FastReader sc=new FastReader(); \n        //int t=sc.nextInt();\n        int n=sc.nextInt();\n        long a[][]=new long[n][2];\n        long g=0;\n        long g1=0,g2=0,g3=0,g4=0;\n        for(int i=0;i<n;i++) {\n        \ta[i][0]=sc.nextLong();\n        \ta[i][1]=sc.nextLong();\n        \t\n        }\n        TreeSet<Long> ts=new TreeSet<>();\n        long val=a[0][0];\n\t\tif(val%2==0)\n\t\t{\n\t\t\tts.add(2L);\n\t\t\twhile(val%2==0)val/=2;\n\t\t\t\n\t\t}\n\t\tfor(long i=3;i*i<=val;i+=2)\n\t\t{\n\t\t\tif(val%i==0)\n\t\t\t{\n\t\t\t\tts.add(i);\n\t\t\t\twhile(val%i==0)val/=i;\n\t\t\t}\n\t\t}\n\t\tif(val>2)\n\t\t\tts.add(val);\n\t\t\n\t\tval=a[0][1];\n\t\t\n\t\tif(val%2==0)\n\t\t{\n\t\t\tts.add(2L);\n\t\t\twhile(val%2==0)val/=2;\n\t\t\t\n\t\t}\n\t\tfor(long i=3;i*i<=val;i+=2)\n\t\t{\n\t\t\tif(val%i==0)\n\t\t\t{\n\t\t\t\tts.add(i);\n\t\t\t\twhile(val%i==0)val/=i;\n\t\t\t}\n\t\t}\n\t\tif(val>2)\n\t\t\tts.add(val);\n\t\t\n\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tts.remove(1L);\n        long res=-1;\n        for(long i:ts) {\n        \tboolean f=false;\n        \tfor(int j=1;j<n;j++) {\n        \t\tif(a[j][0]%i!=0&&a[j][1]%i!=0) {\n        \t\t\tf=true;\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        \tif(!f) {\n        \t   System.out.println(i);\n        \t\treturn;\n        \t}\n        }\n        System.out.println(res);\n    } \n    \n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.fill;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.sort;\nimport static java.util.Collections.sort;\n\npublic class WeakenedCommonDivisor {\n\tstatic int mod = 1000000007;\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic class Pair\n\t{\n\t\tint a,b;\n\t\tPair(int a,int b)\n\t\t{\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tint n=in.nextInt();\n\t\tPair[] a=new Pair[n-1];\n\t\tint a1=in.nextInt();\n\t\tint b1=in.nextInt();\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\ta[i]=new Pair(in.nextInt(), in.nextInt());\n\t\t}\n\t\tArrayList<Integer> primes=new ArrayList<>();\n\t\tfor(int i=2;i<=sqrt(a1);i++)\n\t\t{\n\t\t\tboolean b=false;\n\t\t\twhile(a1%i==0)\n\t\t\t{\n\t\t\t\tb=true;\n\t\t\t\ta1/=i;\n\t\t\t}\n\t\t\tif(b)\n\t\t\t\tprimes.add(i);\n\t\t}\n\t\tif(a1!=1)\n\t\t{\n\t\t\tprimes.add(a1);\n\t\t}\n\t\tfor(int i=2;i<=sqrt(b1);i++)\n\t\t{\n\t\t\tboolean b=false;\n\t\t\twhile(b1%i==0)\n\t\t\t{\n\t\t\t\tb=true;\n\t\t\t\tb1/=i;\n\t\t\t}\n\t\t\tif(b)\n\t\t\t\tprimes.add(i);\n\t\t}\n\t\tif(b1!=1)\n\t\t{\n\t\t\tprimes.add(b1);\n\t\t}\n\t\tMap<Integer, Boolean> map=new HashMap<>();\n\t\tfor(int i : primes)\n\t\t{\n\t\t\tmap.put(i, true);\n\t\t}\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tfor(int j : primes)\n\t\t\t{\n\t\t\t\tif(a[i].a%j==0||a[i].b%j==0)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tmap.put(j, false);\n\t\t\t}\n\t\t}\n\t\tint ans=-1;\n\t\tboolean pos=false;\n\t\tfor(int i : primes)\n\t\t{\n\t\t\tif(map.get(i))\n\t\t\t\t{\n\t\t\t\tpos=true;\n\t\t\t\tans=i;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\n\t}\n\n\tstatic class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\n\t\tpublic InputReader(InputStream st) {\n\t\t\tthis.stream = st;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tif (!(System.getProperty(\"ONLINE_JUDGE\") != null))\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}\n\n\n"
        },
        {
            "language": 3,
            "solution": "import math\n\n\ndef f(n):\n    a = set()\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            a.add(i)\n        while n % i == 0:\n            n //= i\n    if n != 1:\n        a.add(n)\n    return a\n\n\nn = int(input())\na = set()\nfor i in range(n):\n    x, y = map(int, input().split())\n    x, y = max(x, y), min(x, y)\n    if i == 0:\n        b = f(x)\n        b2 = f(y)\n        b |= b2\n        b = list(b)\n    a.add((x, y))\na = list(a)\ni = 0\nj = 0\nwhile i < len(a) and j < len(b):\n    if a[i][0] % b[j] == 0:\n        i += 1\n    else:\n        if a[i][1] % b[j] == 0:\n            i += 1\n        else:\n            i = 0\n            j += 1\nif i >= len(a):\n    print(b[j])\nelse:\n    print(-1)"
        },
        {
            "language": 3,
            "solution": "n = int(input())\na,b = [0]*n,[0]*n\ng = 0\n\ndef gcd(a,b):\n    return a if b == 0 else gcd(b,a%b)\nfor i in range(n):\n    (a[i],b[i]) = map(int,input().split())\n    g = gcd(g,a[i]*b[i])\nfor i in range(n):\n    if gcd(g,a[i]) > 1:\n        g = gcd(g,a[i])\n    else:\n        g = gcd(g,b[i])\nprint(g if g > 1 else -1)\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\n\nn = int(input())\ngcd = 0\na = {} \nb = {}\n\nfor i in range(n):\n    a[i], b[i] = map(int, input().split())\n    gcd = math.gcd(gcd, a[i] * b[i])\n\nfor i in range(n):\n    ret = math.gcd(gcd, a[i])\n    if ret > 1:\n        gcd = ret\n    else:\n        gcd = math.gcd(gcd, b[i])\n    if gcd == 1:\n        break;\nif gcd == 1:\n    print(-1)\nelse:\n    print(gcd)\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class WeakenedCommonDivisor {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    static class TaskA {\n        long mod = (998244353l);\n        public void solve(int testNumber, InputReader in, PrintWriter out) throws IOException {\n        \twhile(testNumber-->0){\n        \t\tint n = in.nextInt();\n        \t\tHashSet<Long> s = new HashSet<>();\n        \t\tdistinctPrimeDivisor(s , in.nextLong());\n        \t\tdistinctPrimeDivisor(s , in.nextLong());\n        \t\tfor(int i=1;i<n;i++){\n        \t\t\tlong a = in.nextLong();\n        \t\t\tlong b = in.nextLong();\n        \t\t\tHashSet<Long> h = new HashSet<>();\n        \t\t\tfor(long j:s){\n        \t\t\t\tif(a%j==0 || b%j==0);\n        \t\t\t\telse\n        \t\t\t\t\th.add(j);\n        \t\t\t}\n        \t\t\tfor(long j:h)\n        \t\t\t\ts.remove(j);\n        \t\t}\n        \t\tif(s.size()==0)\n        \t\t\tout.println(-1);\n        \t\telse{\n        \t\t\tfor(long i:s){\n        \t\t\t\tout.println(i);\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n            }\n        }\n        public void distinctPrimeDivisor(HashSet<Long> s , long a){\n        \tfor(long i=2;i*i<=a;i++){\n        \t\tif(a%i==0){\n        \t\t\ts.add(i);\n        \t\t\twhile(a%i==0)\n        \t\t\t\ta/=i;\n        \t\t}\n        \t}\n        \tif(a!=1)\n        \t\ts.add(a);\n        }\n        public void dfs(ArrayList<ArrayList<Integer>> a , int index , int visited[] , int distance[] , int parent[]){\n        \tif(visited[index] == 1)\n        \t\treturn;\n        \tvisited[index] = 1;\n        \tint l = a.get(index).size();\n        \tfor(int i=0;i<l;i++){\n        \t\tif(visited[a.get(index).get(i)] == 1)\n        \t\t\tcontinue;\n        \t\tparent[a.get(index).get(i)] = index;\n        \t\tdistance[a.get(index).get(i)] = 1 + distance[index];\n        \t\tdfs(a , a.get(index).get(i) , visited , distance , parent);\n        \t}\n        }\n        public void sieve(int a[]){\n            a[0] = a[1] = 1;\n            int i;\n            for(i=2;i*i<=a.length;i++){\n                if(a[i] != 0)\n                    continue;\n                a[i] = i;\n                for(int k = (i)*(i);k<a.length;k+=i){\n                    if(a[k] != 0)\n                        continue;\n                    a[k] = i;\n                }\n            }\n        }\n        public int [][] matrixExpo(int c[][] , int n){\n            int a[][] = new int[c.length][c[0].length];\n            int b[][] = new int[a.length][a[0].length];\n            for(int i=0;i<c.length;i++)\n                for(int j=0;j<c[0].length;j++)\n                    a[i][j] = c[i][j];\n            for(int i=0;i<a.length;i++)\n                b[i][i] = 1;\n            while(n!=1){\n                if(n%2 == 1){\n                    b = matrixMultiply(a , a);\n                    n--;\n                }\n                a = matrixMultiply(a , a);\n                n/=2;\n            }\n            return matrixMultiply(a , b);\n        }\n        public int [][] matrixMultiply(int a[][] , int b[][]){\n            int r1 = a.length;\n            int c1 = a[0].length;\n            int c2 = b[0].length;\n            int c[][] = new int[r1][c2];\n            for(int i=0;i<r1;i++){\n                for(int j=0;j<c2;j++){\n                    for(int k=0;k<c1;k++)\n                        c[i][j] += a[i][k]*b[k][j];\n                }\n            }\n            return c;\n        }\n        public long nCrPFermet(int n , int r , long p){\n            if(r==0)\n                return 1l;\n            long fact[] = new long[n+1];\n            fact[0] = 1;\n            for(int i=1;i<=n;i++)\n                fact[i] = (i*fact[i-1])%p;\n            long modInverseR = pow(fact[r] , p-2 , 1l , p);\n            long modInverseNR = pow(fact[n-r] , p-2 , 1l , p);\n            long w = (((fact[n]*modInverseR)%p)*modInverseNR)%p;\n            return w;\n        }\n        public long pow(long a , long b , long res , long mod){\n            if(b==0)\n                return res;\n            if(b==1)\n                return (res*a)%mod;\n            if(b%2==1){\n                res *= a;\n                res %= mod;\n                b--;\n            }\n            // System.out.println(a + \" \" + b + \" \" + res);\n            return pow((a*a)%mod , b/2 , res , mod);\n        }\n        public long pow(long a , long b , long res){\n            if(b == 0)\n                return res;\n            if(b==1)\n                return res*a;\n            if(b%2==1){\n                res *= a;\n                b--;\n            }\n            return pow(a*a , b/2 , res);\n        }\n        public void swap(int a[] , int p1 , int p2){\n            int x = a[p1];\n            a[p1] = a[p2];\n            a[p2] = x;\n        }\n        public void sortedArrayToBST(TreeSet<Integer> a , int start, int end) { \n            if (start > end) {\n                return;\n            }\n            int mid = (start + end) / 2;\n            a.add(mid);\n            sortedArrayToBST(a, start, mid - 1);\n            sortedArrayToBST(a, mid + 1, end); \n        }\n        class Combine{\n            long value;\n            long delete;\n            Combine(long val , long delete){\n                this.value = val;\n                this.delete = delete;\n            }\n        }\n        class Sort2 implements Comparator<Combine>{\n            public int compare(Combine a , Combine b){\n                if(a.value > b.value)\n                    return 1;\n                else if(a.value == b.value && a.delete>b.delete)\n                    return 1;\n                else if(a.value == b.value && a.delete == b.delete)\n                    return 0;\n                return -1;\n            }\n        }\n        public int lowerLastBound(ArrayList<Integer> a , int x){\n            int l = 0;\n            int r = a.size()-1;\n            if(a.get(l)>=x)\n                return -1;\n            if(a.get(r)<x)\n                return r;\n            int mid = -1;\n            while(l<=r){\n                mid = (l+r)/2;\n                if(a.get(mid) == x && a.get(mid-1)<x)\n                    return mid-1;\n                else if(a.get(mid)>=x)\n                    r = mid-1;\n                else if(a.get(mid)<x && a.get(mid+1)>=x)\n                    return mid;\n                else if(a.get(mid)<x && a.get(mid+1)<x)\n                    l = mid+1;\n            }\n            return mid;\n        }\n        public int upperFirstBound(ArrayList<Integer> a , Integer x){\n            int l = 0;\n            int r = a.size()-1;\n            if(a.get(l)>x)\n                return l;\n            if(a.get(r)<=x)\n                return r+1;\n            int mid = -1;\n            while(l<=r){\n                mid = (l+r)/2;\n                if(a.get(mid) == x && a.get(mid+1)>x)\n                    return mid+1;\n                else if(a.get(mid)<=x)\n                    l = mid+1;\n                else if(a.get(mid)>x && a.get(mid-1)<=x)\n                    return mid;\n                else if(a.get(mid)>x && a.get(mid-1)>x)\n                    r = mid-1;\n            }\n            return mid;\n        }\n        public int lowerLastBound(int a[] , int x){\n            int l = 0;\n            int r = a.length-1;\n            if(a[l]>=x)\n                return -1;\n            if(a[r]<x)\n                return r;\n            int mid = -1;\n            while(l<=r){\n                mid = (l+r)/2;\n                if(a[mid] == x && a[mid-1]<x)\n                    return mid-1;\n                else if(a[mid]>=x)\n                    r = mid-1;\n                else if(a[mid]<x && a[mid+1]>=x)\n                    return mid;\n                else if(a[mid]<x && a[mid+1]<x)\n                    l = mid+1;\n            }\n            return mid;\n        }\n        public int upperFirstBound(long a[] , long x){\n            int l = 0;\n            int r = a.length-1;\n            if(a[l]>x)\n                return l;\n            if(a[r]<=x)\n                return r+1;\n            int mid = -1;\n            while(l<=r){\n                mid = (l+r)/2;\n                if(a[mid] == x && a[mid+1]>x)\n                    return mid+1;\n                else if(a[mid]<=x)\n                    l = mid+1;\n                else if(a[mid]>x && a[mid-1]<=x)\n                    return mid;\n                else if(a[mid]>x && a[mid-1]>x)\n                    r = mid-1;\n            }\n            return mid;\n        }\n        public long log(float number , int base){\n            return (long) Math.floor((Math.log(number) / Math.log(base)));\n        }\n        public long gcd(long a , long b){\n            if(a<b){\n                long c = b;\n                b = a;\n                a = c;\n            }\n            if(b == 0)\n            \treturn 0;\n            if(a%b==0)\n                return b;\n            return gcd(b , a%b);\n        }\n        public void print2d(long a[][] , PrintWriter out){\n            for(int i=0;i<a.length;i++){\n                for(int j=0;j<a[i].length;j++)\n                    out.print(a[i][j] + \" \");\n                out.println();\n            }\n            out.println();\n        }\n        public void print1d(int a[] , PrintWriter out){\n            for(int i=0;i<a.length;i++)\n                out.print(a[i] + \" \");\n            out.println();\n            out.println();\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nimport sys\nn=int(input())\na=[];b=[];g=0\nfor i in range(n):\n    x,y=map(int,sys.stdin.readline().split())\n    a.append(x)\n    b.append(y)\n    g=math.gcd(g,x*y)\nfor i in range(n):\n    if math.gcd(g,a[i])>1:\n        g=math.gcd(g,a[i])\n    else:\n        g=math.gcd(g,b[i])\nif g==1:\n    print(-1)\nelse:\n    print(g)"
        },
        {
            "language": 4,
            "solution": "\n\n\n\n\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.BigInteger; \nimport java.lang.*;\n\n\n\n\n\npublic class Main {\n    \n    \n    \n    \n   static class sort implements Comparator<int[]>\n   {\n        public int compare(int[] a,int[] b)\n        {\n            \n            return -b[0]+a[0];\n        }\n   }\n   static class sort1 implements Comparator<int[]>\n   {\n        public int compare(int[] a,int[] b)\n        {\n            \n          return  b[0]-a[0];\n        }\n   }\n   static class sort5 implements Comparator<long[]>\n   {\n        public int compare(long[] a,long[] b)\n        {\n            \n           double d1,d2;\n           d1 = (a[0]+0.00)/(a[1]+0.00);\n           d2 = (b[0]+0.00)/(b[1]+0.00);\n           //int v = Double.comapre(d2,d1);\n           double eph = 0.000000000000001;\n           double d = (d2-d1);\n          // pr(d1+\" \"+d2);\n           if(d>eph) return 1;\n           else if(d<eph) return -1;\n           if(a[1]>b[1]) return 1;\n           else if(b[1]>a[1]) return -1;\n           return 0;\n        }\n   }\n   static class sort11 implements Comparator<double[]>\n   {\n        public int compare(double[] a,double[] b)\n        {\n            //if(a[0] == b[0]) return a[1]-b[1];\n           if(a[1] < b[1]) return -1;\n           else if(a[1] > b[1]) return 1;\n           return 0;\n        }\n   }\n   public static String[] F(BufferedReader bf) throws Exception\n    {\n        return (bf.readLine().split(\" \"));\n    }\n    \n   public static void pr(PrintWriter out,Object o)\n   {\n      \n    out.println(o.toString());//out.flush();\n    \n   }\n   public static void prW(PrintWriter out,Object o)\n   {\n      \n    out.print(o.toString());//out.flush();\n    \n   }\n   public static int intIn(String st)\n   {\n      return Integer.parseInt(st);\n   }\n   \n   \n    \n    public static void pr(Object o)\n    {\n        System.out.println(o.toString());\n    }\n    public static void prW(Object o)\n    {\n        System.out.print(o.toString());\n    }\n    \n   \n    public static int inInt(String s)\n    {\n        return Integer.parseInt(s);\n    }\n    public static long in(String s)\n    {\n        return Long.parseLong(s);\n    }\n \n \n    static int[] toIntArray(String[] m) \n    { \n        int[] p=new int[m.length];\n        for(int o=0;o<m.length;o++)\n        {\n            p[o]= inInt(m[o]);\n        }\n        return p;\n    }\n    static double[] toDArray(String[] m) \n    { \n        double[] p=new double[m.length];\n        for(int o=0;o<m.length;o++)\n        {\n            p[o]= Double.parseDouble(m[o]);\n        }\n        return p;\n    }\n    static long[] toLArray(String[] m) \n    { \n       long[] p=new long[m.length];\n        for(int o=0;o<m.length;o++)\n        {\n            p[o]= in(m[o]);\n        }\n        return p;\n    }\n    \n    static int[][] di={{0,1},{1,0},{0,-1},{-1,0}};\n    static int[] dir = {4,3,2,-4,-3,-2};\n    \n     static long gcd(long a, long b)\n        {\n          if (b == 0)\n            return a;\n          return gcd(b, a % b); \n        }\n        static long Gp(long l,long b,long lcm)\n        {\n            long c1,c2;\n                c1 = (l/lcm);\n                long sum=0l;\n                sum += (c1-1l)*(b);\n                long las = (l/lcm)*lcm;\n                sum += Math.min(l-las+1l,b);\n                return sum;\n        }\n        static long pow(long x, long y, long p)\n      {\n        if(y == 0) return 1l;\n        long res = 1; // Initialize result\n     \n        x = x % p; // Update x if it is more than or\n        // equal to p\n     \n        if (x == 0)\n          return 0l; // In case x is divisible by p;\n     \n        while (y > 0)\n        {\n     \n          // If y is odd, multiply x with result\n          if ((y & 1) != 0)\n            res = (res * x) % p;\n     \n          // y must be even now\n          y = y >> 1; // y = y/2\n          x = (x * x) % p;\n        }\n        return res;\n      }\n    \n    public static long F(int a,int b)\n    {\n         return 462161773423l*(a+0l) + 4549834777463l*(b+0l);\n    }\n    static int nCr(int n, int r, int p)\n    {\n        if (r > n - r)\n            r = n - r;\n \n        // The array C is going to store last\n        // row of pascal triangle at the end.\n        // And last entry of last row is nCr\n        int C[] = new int[r + 1];\n \n        C[0] = 1; // Top row of Pascal Triangle\n \n        // One by constructs remaining rows of Pascal\n        // Triangle from top to bottom\n        for (int i = 1; i <= n; i++) {\n \n            // Fill entries of current row using previous\n            // row values\n            for (int j = Math.min(i, r); j > 0; j--)\n \n                // nCj = (n-1)Cj + (n-1)C(j-1);\n                C[j] = (C[j] + C[j - 1]) % p;\n        }\n        return C[r];\n    }\n    // F(o,-1,tm,vis,par,o,mat);\n   public static int log(int x)\n   {\n       boolean bol = true;\n\n       if(((x-1)&x) == 0) bol=false;\n\n       int c=0;\n       while(x > 0)\n       {\n        x=(x/2);\n        c++;\n       }\n\n       if(!bol) c--;\n       return c;\n\n   }\n\n   public static int F(int[] arr,int j,int x,int n)\n   {\n\n    if(j>=n) return 0;\n    if(j == (n-1)) return 0;\n    boolean bt = false;\n       int i = j;\n\n       while(i<n && arr[i]<= x)\n       {\n          i++;\n       }\n       int k = j;\n       //if(i == n) return 0;\n       i--;\n       while(k<i)\n       {\n          if(arr[k]>arr[k+1]) return -10000000;\n          k++;\n       }\n       k = i+1;\n       while(k<n)\n       {\n            if(arr[k] < x ) bt=true;\n            k++;\n       }\n\n       k = j;\n       boolean bol = true;\n       while(k<(n-1))\n       {\n          if(arr[k]>arr[k+1]) \n          {\n            bol=false;break;\n          }\n\n          k = k+1;\n       }\n       if(bol) return 0;\n\n       int tem = arr[i+1];\n       arr[i+1] = x;\n       //x=tem;\n       int sum;\n       if(!bt)\n        sum =  1 + F(arr,i+2,tem,n);\n        else sum=-10000000;\n     // System.out.println(sum+\" \"+j+\" \"+x);\n       return sum;\n\n   }\n   static class sor implements Comparator<long[]>\n   {\n      public int compare(long[] a,long[] b)\n      {\n         if(a[0] == b[0])\n         {\n            if(a[1] < b[1]) return -1;\n            return 1;\n         }\n         if(a[0] > b[0]) return 1;\n         return -1;\n      }\n   }\n\n   public static void F(int i,int[] vis,int v,List<Set<Integer>> list,TreeMap<Integer,Integer> tm,int[] arr)\n   {\n        vis[i] = v;\n        if(tm.containsKey(arr[i])) tm.put(arr[i],tm.get(arr[i])+1);\n        else tm.put(arr[i],1);\n        for(int r : list.get(i))\n        {\n            if(vis[r] == 0)\n            {\n                F(r,vis,v,list,tm,arr);\n            }\n        }\n   }\n    static long ncr(int n, int r)\n    {\n \n        // p holds the value of n*(n-1)*(n-2)...,\n        // k holds the value of r*(r-1)...\n        long p = 1, k = 1;\n        if(n<r) return 0l;\n \n        // C(n, r) == C(n, n-r),\n        // choosing the smaller value\n        if (n - r < r) {\n            r = n - r;\n        }\n \n        if (r != 0) {\n            while (r > 0) {\n                p *= n;\n                k *= r;\n \n                // gcd of p, k\n                long m = __gcd(p, k);\n \n                // dividing by gcd, to simplify\n                // product division by their gcd\n                // saves from the overflow\n                p /= m;\n                k /= m;\n \n                n--;\n                r--;\n            }\n \n            // k should be simplified to 1\n            // as C(n, r) is a natural number\n            // (denominator should be 1 ) .\n        }\n        else {\n            p = 1;\n        }\n \n        // if our approach is correct p = ans and k =1\n        return p;\n    }\n \n    static long __gcd(long n1, long n2)\n    {\n\n        if(n1==0l) return n2;\n        if(n2==0l) return n1;\n        if(n1==1l || n2==1l) return 1l;\n       // long gcd = 1;\n        if(n1 == n2)  return n1;\n        if(n1>n2) return __gcd(n1%n2,n2);\n        return __gcd(n1,n2%n1);\n        \n    }\n  \n    public static int F(int i,int j,List<List<Integer>> list,int[] tot,boolean[] right)\n    {\n      int c=0;\n\n        if(list.get(i).size() == 1)\n        {\n            right[i]=true;\n            c++;\n        }\n        \n\n        for(int x : list.get(i))\n        {\n            if(x==j) continue;\n\n            c += F(x,i,list,tot,right);\n        }\n\n        tot[i]=c;return c;\n\n    }\n\n    public static void main (String[] args) throws Exception {\n        \n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);;;\n        \n        //int[] map=new int[1000001];\n      \n       int yy=1;//inInt(bf.readLine());\n       \n\n\n        \n        for(int w=0;w<yy;w++)\n        {\n            // String str = bf.readLine();\n          out.flush();\n         \n            String[] xlp = bf.readLine().split(\" \");;;;;;\n            //String st = bf.readLine();\n         int n;//boolean bol=false;\n           long m;//long a,b,c;\n           int ioo;\n           long  k;//pr(out,\"vbc\");\n         n=inInt(xlp[0]);//m=in(xlp[1]);//k=in(xlp[2]);//t=inInt(xlp[3]);\n\n         long[][] arr = new long[n][2];\n\n\n         for(int o=0;o<n;o++)\n         {\n            arr[o] =toLArray(F(bf));\n\n         }\n\n         long res=0l;\n       // pr(out,__gcd((1999999973l*1999999943l),0l));\n         for(int o=0;o<n;o++)\n         {\n            long a = (arr[o][0]*arr[o][1]);\n            //pr(out,a);\n            //long g = __gcd(arr[o][0],arr[o][1]);\n            \n            //a =(a/g);\n            res = __gcd(res,a);\n            //pr(out,res+\" \"+a);\n         }\n         //pr(out,res);\n\n         if(res == 1l) pr(out,-1);\n         else{\n         long r = __gcd(res,arr[0][0]);\n         if(r==1l) r = __gcd(res,arr[0][1]);\n         int rt = (int)(Math.sqrt(r)+1);\n         for(int o=2;o<=rt;o++)\n         {\n             if((r%o) == 0)\n             {\n                  r=o;break;\n             }\n         }\n\n         pr(out,r);}\n\n         \n\n\n\n\n      \n\n         \n         \n         \n\n\n\n         \n         \n   }\n    out.close();\n   bf.close();\n}}\n\n\n/*\n2\n1999999973 1999999943\n1999999973 1999999943\n\nKickstart\n String rp;\n            rp = \"Case #\"+(w+1)+\": \"+(n-ans)+\" \";\nstatic int[][] dir={{0,1},{1,0},{-1,0},{0,-1}};\n\nstatic class SegmentTreeRMQ \n    { \n    int st[]; \n    int minVal(int x, int y) { \n        return (x > y) ? x : y; \n    } \n  \n    \n    int getMid(int s, int e) { \n        return s + (e - s) / 2; \n    } \n  \n    \n    int RMQUtil(int ss, int se, int qs, int qe, int index) \n    { \n        \n        if (qs <= ss && qe >= se) \n            return st[index]; \n  \n        // If segment of this node is outside the given range \n        if (se < qs || ss > qe) \n            return Integer.MIN_VALUE; \n  \n        // If a part of this segment overlaps with the given range \n        int mid = getMid(ss, se); \n        return minVal(RMQUtil(ss, mid, qs, qe, 2 * index + 1), \n                RMQUtil(mid + 1, se, qs, qe, 2 * index + 2)); \n    } \n  \n    // Return minimum of elements in range from index qs (query \n    // start) to qe (query end).  It mainly uses RMQUtil() \n    int RMQ(int n, int qs, int qe) \n    { \n        // Check for erroneous input values \n        \n  \n        return RMQUtil(0, n - 1, qs, qe, 0); \n    } \n  \n    // A recursive function that constructs Segment Tree for \n    // array[ss..se]. si is index of current node in segment tree st \n    int constructSTUtil(int arr[], int ss, int se, int si) \n    { \n        // If there is one element in array, store it in current \n        //  node of segment tree and return \n        if (ss == se) { \n            st[si] = arr[ss]; \n            return arr[ss]; \n        } \n  \n        // If there are more than one elements, then recur for left and \n        // right subtrees and store the minimum of two values in this node \n        int mid = getMid(ss, se); \n        st[si] = minVal(constructSTUtil(arr, ss, mid, si * 2 + 1), \n                constructSTUtil(arr, mid + 1, se, si * 2 + 2)); \n        return st[si]; \n    } \n  \n    \n    void con(int arr[]) \n    { \n        // Allocate memory for segment tree \n  \n        //Height of segment tree \n        int n = (arr.length);\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2))); \n  \n        //Maximum size of segment tree \n        int max_size = 2 * (int) Math.pow(2, x) - 1; \n        st = new int[max_size]; // allocate memory \n  \n        // Fill the allocated memory st \n        constructSTUtil(arr, 0, n - 1, 0); \n    }\n    }\n     static class DSU {\n    \n    int[] p;int[] sz;int op;int c;;\n    int[] last;\n    public void G(int n)\n    {\n        last=new int[n];\n        p=new int[n];\n        sz=new int[n];c=n;\n        op=n;\n        for(int h=0;h<n;h++)\n        {\n            sz[h]=1;p[h]=h;\n            last[h]=h;\n        }\n    }\n    public int find(int x)\n    {\n        int y=x;\n        while(x!=p[x]) x=p[x];\n        while(y!=p[y])\n        {\n            int tem=p[y];\n            p[y]=x;y=tem;\n        }\n        return p[y];\n    }\n    public void union(int a,int b)\n    {\n        int x,y;\n        x=find(a);y=find(b);\n        if(x==y) return;\n        if(sz[x]>sz[y])\n        {\n            p[y] = x;\n            sz[x]+=sz[y];\n            last[x]=Math.max(last[x],last[y]);\n        }\n        else\n        {\n            p[x]=y;sz[y]+=sz[x];\n            last[y]=Math.max(last[y],last[x]);\n        }\n        c--;\n        \n    }}\n\n    static long pow(long x, long y, long p)\n      {\n        long res = 1; // Initialize result\n     \n        x = x % p; // Update x if it is more than or\n        // equal to p\n     \n        if (x == 0)\n          return 0l; // In case x is divisible by p;\n     \n        while (y > 0)\n        {\n     \n          // If y is odd, multiply x with result\n          if ((y & 1) != 0)\n            res = (res * x) % p;\n     \n          // y must be even now\n          y = y >> 1; // y = y/2\n          x = (x * x) % p;\n        }\n        return res;\n      }\n      static long gcd(long a, long b)\n        {\n          if (b == 0)\n            return a;\n          return gcd(b, a % b); \n        }\n        static int gcd(int a, int b,int o)\n        {\n          if (b == 0)\n            return a;\n          return gcd(b, a % b,o); \n        }\n\nGeometric median\n\npublic static double F(double[] x,double[] w)\n    {\n        double d1,d2;\n        double S=0.00;\n        for(double dp : w) S += dp;\n        int k = 0;\n        double sum = S - w[0]; // sum is the total weight of all `x[i] > x[k]`\n\n        while(sum > S/2)\n        {\n            ++k;\n            sum -= w[k];\n        }\n        d1=x[k];\n        return d1;\n        k = w.length-1;\n       sum = S - w[k]; // sum is the total weight of all `x[i] > x[k]`\n\n        while(sum > S/2)\n        {\n            --k;\n            sum -= w[k];\n        }\n        d2=x[k];\n        return new double[]{d1,d2};\n    }\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Set;\n\npublic class ProblemB {\n\n    public static void main(String[] args) {\n        new ProblemSolver().solve();\n    }\n\n    private static class ProblemSolver {\n\n        public void solve() {\n            String inputString = \"\";\n            InputReader reader = new InputReader(\n                    inputString.isEmpty() ? System.in : new ByteArrayInputStream(inputString.getBytes()));\n            OutputWriter writer = new OutputWriter(System.out);\n\n            solve(reader, writer);\n\n            writer.flush();\n            writer.close();\n        }\n\n        private void solve(InputReader reader, OutputWriter writer) {\n            int t;\n            t = 1;\n            while (t-- > 0) {\n                solveTestCase(reader, writer);\n            }\n        }\n\n        private int n;\n        private Pair[] pairs;\n\n        private void solveTestCase(InputReader reader, OutputWriter writer) {\n            /*Code*/\n            n = reader.nextInt();\n            pairs = new Pair[n];\n            for (int i = 0; i < n; i++) {\n                pairs[i] = new Pair();\n                pairs[i].a = reader.nextLong();\n                pairs[i].b = reader.nextLong();\n            }\n\n            long ans = 0;\n            for (Pair pair: pairs) {\n                ans = IntegerUtils.gcd(ans, IntegerUtils.lcm(pair.a, pair.b));\n            }\n\n            if (ans == 1) {\n                writer.println(-1);\n            } else {\n                long gcdVal = IntegerUtils.gcd(ans, pairs[0].a);\n                if (gcdVal == 1) {\n                    gcdVal = IntegerUtils.gcd(ans, pairs[0].b);\n                }\n                writer.println(findFirstPrimeComponent(gcdVal));\n            }\n        }\n\n        private long findFirstPrimeComponent(long n) {\n            for (long i = 2; i * i <= n; i++) {\n                if (n % i == 0) {\n                    return i;\n                }\n            }\n            return n;\n        }\n\n        private static class Pair {\n            private long a;\n            private long b;\n        }\n\n        private static class IntegerUtils {\n            public static long gcd(long a, long b) {\n                while (b != 0) {\n                    long temp = a % b;\n                    a = b;\n                    b = temp;\n                }\n                return a;\n            }\n\n            public static long lcm(long a, long b) {\n                return (a / gcd(a, b)) * b;\n            }\n\n        }\n\n        private static class InputReader {\n\n            private static final int BUFFER_SIZE_IN_BYTES = 1024;\n\n            private InputStream stream;\n            private byte[] buffer = new byte[BUFFER_SIZE_IN_BYTES];\n            private int nextPositionInBuffer;\n            private int numberOfBytesInBuffer;\n\n            public InputReader(InputStream stream) {\n                this.stream = stream;\n            }\n\n            public int read() {\n                if (numberOfBytesInBuffer == -1) {\n                    throw new InputMismatchException();\n                }\n                if (nextPositionInBuffer >= numberOfBytesInBuffer) {\n                    fillBuffer();\n                    if (numberOfBytesInBuffer <= 0) {\n                        return -1;\n                    }\n                }\n                return buffer[nextPositionInBuffer++];\n            }\n\n            public int peek() {\n                if (numberOfBytesInBuffer == -1) {\n                    return -1;\n                }\n                if (nextPositionInBuffer >= numberOfBytesInBuffer) {\n                    try {\n                        fillBuffer();\n                    } catch (InputMismatchException e) {\n                        return -1;\n                    }\n                    if (numberOfBytesInBuffer <= 0) {\n                        return -1;\n                    }\n                }\n                return buffer[nextPositionInBuffer];\n            }\n\n            private int fillBuffer() {\n                nextPositionInBuffer = 0;\n                try {\n                    return (numberOfBytesInBuffer = stream.read(buffer));\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n            }\n\n            public char nextChar() {\n                int c = read();\n                while (isSpaceChar(c)) {\n                    c = read();\n                }\n                return (char) c;\n            }\n\n            public int nextInt() {\n                int c = read();\n                while (isSpaceChar(c)) {\n                    c = read();\n                }\n                int sgn = 1;\n                if (c == '-') {\n                    sgn = -1;\n                    c = read();\n                }\n                int res = 0;\n                do {\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    res *= 10;\n                    res += c - '0';\n                    c = read();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n            }\n\n            public long nextLong() {\n                int c = read();\n                while (isSpaceChar(c)) {\n                    c = read();\n                }\n                int sgn = 1;\n                if (c == '-') {\n                    sgn = -1;\n                    c = read();\n                }\n                long res = 0;\n                do {\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    res *= 10;\n                    res += c - '0';\n                    c = read();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n            }\n\n            public double nextDouble() {\n                int c = read();\n                while (isSpaceChar(c)) {\n                    c = read();\n                }\n                int sgn = 1;\n                if (c == '-') {\n                    sgn = -1;\n                    c = read();\n                }\n                double res = 0;\n                while (!isSpaceChar(c) && c != '.') {\n                    if (c == 'e' || c == 'E') {\n                        return res * Math.pow(10, nextInt());\n                    }\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    res *= 10;\n                    res += c - '0';\n                    c = read();\n                }\n                if (c == '.') {\n                    c = read();\n                    double m = 1;\n                    while (!isSpaceChar(c)) {\n                        if (c == 'e' || c == 'E') {\n                            return res * Math.pow(10, nextInt());\n                        }\n                        if (c < '0' || c > '9') {\n                            throw new InputMismatchException();\n                        }\n                        m /= 10;\n                        res += (c - '0') * m;\n                        c = read();\n                    }\n                }\n                return res * sgn;\n            }\n\n            public BigInteger nextBigInteger() {\n                try {\n                    return new BigInteger(nextString());\n                } catch (NumberFormatException e) {\n                    throw new InputMismatchException();\n                }\n            }\n\n            public String nextLine() {\n                String s = readLineWithoutAnyTrimming();\n                while (s.trim().length() == 0) {\n                    s = readLineWithoutAnyTrimming();\n                }\n                return s;\n            }\n\n            private String readLineWithoutAnyTrimming() {\n                StringBuilder buf = new StringBuilder();\n                int c = read();\n                while (c != '\\n' && c != -1) {\n                    if (c != '\\r') {\n                        buf.appendCodePoint(c);\n                    }\n                    c = read();\n                }\n                return buf.toString();\n            }\n\n            public String next() {\n                return nextString();\n            }\n\n            private String nextString() {\n                int c = read();\n                while (isSpaceChar(c)) {\n                    c = read();\n                }\n                StringBuilder res = new StringBuilder();\n                do {\n                    if (Character.isValidCodePoint(c)) {\n                        res.appendCodePoint(c);\n                    }\n                    c = read();\n                } while (!isSpaceChar(c));\n                return res.toString();\n            }\n\n            public boolean isExhausted() {\n                int value;\n                while (isSpaceChar(value = peek()) && value != -1) {\n                    read();\n                }\n                return value == -1;\n            }\n\n            private boolean isSpaceChar(int c) {\n                return isWhitespace(c);\n            }\n\n            private boolean isWhitespace(int c) {\n                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n            }\n\n        }\n\n        private static class OutputWriter {\n\n            private final PrintWriter writer;\n\n            public OutputWriter(OutputStream outputStream) {\n                writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n            }\n\n            public OutputWriter(Writer writer) {\n                this.writer = new PrintWriter(writer);\n            }\n\n            public void print(char i) {\n                writer.print(i);\n            }\n\n            public void println(char i) {\n                writer.println(i);\n            }\n\n            public void print(int i) {\n                writer.print(i);\n            }\n\n            public void println(int i) {\n                writer.println(i);\n            }\n\n            public void print(long i) {\n                writer.print(i);\n            }\n\n            public void println(long i) {\n                writer.println(i);\n            }\n\n            public void print(char[] array) {\n                writer.print(array);\n            }\n\n            public void print(int[] array) {\n                for (int i = 0; i < array.length; i++) {\n                    if (i != 0) {\n                        writer.print(' ');\n                    }\n                    writer.print(array[i]);\n                }\n            }\n\n            public void print(long[] array) {\n                for (int i = 0; i < array.length; i++) {\n                    if (i != 0) {\n                        writer.print(' ');\n                    }\n                    writer.print(array[i]);\n                }\n            }\n\n            public void print(double[] array) {\n                for (int i = 0; i < array.length; i++) {\n                    if (i != 0) {\n                        writer.print(' ');\n                    }\n                    writer.print(array[i]);\n                }\n            }\n\n            public void println(char[] array) {\n                writer.println(array);\n            }\n\n            public void println(int[] array) {\n                print(array);\n                writer.println();\n            }\n\n            public void println(long[] array) {\n                print(array);\n                writer.println();\n            }\n\n            public void println(double[] array) {\n                print(array);\n                writer.println();\n            }\n\n            public void println() {\n                writer.println();\n            }\n\n            public void print(Object... objects) {\n                for (int i = 0; i < objects.length; i++) {\n                    if (i != 0) {\n                        writer.print(' ');\n                    }\n                    writer.print(objects[i]);\n                }\n            }\n\n            public void println(Object... objects) {\n                print(objects);\n                writer.println();\n            }\n\n            public void printf(String format, Object... objects) {\n                writer.printf(format, objects);\n            }\n\n            public void close() {\n                writer.close();\n            }\n\n            public void flush() {\n                writer.flush();\n            }\n\n        }\n\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[150000], b[150000];\nlong long gcd(long long a, long long b) {\n  long long c;\n  while (a != 0) {\n    c = a;\n    a = b % a;\n    b = c;\n  }\n  return b;\n}\nint main() {\n  int i, n;\n  long long c, d;\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n  if (n == 1) {\n    cout << a[0] << endl;\n    return 0;\n  }\n  c = gcd((long long)a[0] * b[0], (long long)a[1] * b[1]);\n  for (i = 2; i < n; i++) {\n    c = gcd(c, (long long)a[i] * b[i]);\n    if (c == 1) {\n      cout << \"-1\" << endl;\n      return 0;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    if (c == 1) {\n      cout << \"-1\" << endl;\n      return 0;\n    }\n    d = gcd(c, a[i]);\n    if (d == 1)\n      c = gcd(c, b[i]);\n    else\n      c = d;\n  }\n  if (c == 1)\n    cout << \"-1\" << endl;\n  else\n    cout << c << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#yeh dil maange more\ndef gcd(x,y):\n    while y:\n        x,y = y,x%y\n    return x\n\nn = int(input())\nal,bl = list(),list()\nlast = 0\nfor i in range(n):\n    a,b = map(int,input().split())\n    al.append(a)\n    bl.append(b)\n    last = gcd(last,al[i]*bl[i])\nfor i in range(n):\n    if gcd(last,al[i])>1:\n        last = gcd(last,al[i])\n    else:\n        last = gcd(last,bl[i])  \nif last == 1:\n    print(-1)\nelse:\n    print(last)"
        },
        {
            "language": 4,
            "solution": "\n/**\n * Date: 19 Aug, 2018\n * Link:\n *\n * @author Prasad-Chaudhari\n * @linkedIn: https://www.linkedin.com/in/prasad-chaudhari-841655a6/\n * @git: https://github.com/Prasad-Chaudhari\n */\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\npublic class newProgram {\n\n    public static void main(String[] args) throws IOException {\n        // TODO code application logic here\n        FastIO in = new FastIO();\n        int n = in.ni();\n        int a[] = new int[n];\n        int b[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.ni();\n            b[i] = in.ni();\n        }\n        if (n == 1) {\n            if (a[0] != 1) {\n                System.out.println(a[0]);\n            } else if (b[0] != 1) {\n                System.out.println(b[0]);\n            } else {\n                System.out.println(-1);\n            }\n            return;\n        }\n        int temp = a[0];\n        for (int i = 2; i < 100000; i++) {\n            if (temp % i == 0) {\n                if (check(a, b, i)) {\n                    System.out.println(i);\n                    return;\n                }\n                while (temp % i == 0) {\n                    temp /= i;\n                }\n            }\n        }\n        if (check(a, b, temp)) {\n            System.out.println(temp);\n            return;\n        }\n        temp = b[0];\n        for (int i = 2; i < 100000; i++) {\n            if (temp % i == 0) {\n                if (check(a, b, i)) {\n                    System.out.println(i);\n                    return;\n                }\n                while (temp % i == 0) {\n                    temp /= i;\n                }\n            }\n        }\n        if (check(a, b, temp)) {\n            System.out.println(temp);\n            return;\n        }\n        System.out.println(\"-1\");\n    }\n\n    private static boolean check(int a[], int b[], int x) {\n        GCD gcd = new GCD();\n        for (int i = 1; i < a.length; i++) {\n            if (gcd.calc_gcd(a[i], x) == 1 && gcd.calc_gcd(b[i], x) == 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static class FastIO {\n\n        private final BufferedReader br;\n        private final BufferedWriter bw;\n        private String s[];\n        private int index;\n        private StringBuilder sb;\n\n        public FastIO() throws IOException {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            bw = new BufferedWriter(new OutputStreamWriter(System.out, \"UTF-8\"));\n            s = br.readLine().split(\" \");\n            sb = new StringBuilder();\n            index = 0;\n        }\n\n        public int ni() throws IOException {\n            return Integer.parseInt(nextToken());\n        }\n\n        public double nd() throws IOException {\n            return Double.parseDouble(nextToken());\n        }\n\n        public long nl() throws IOException {\n            return Long.parseLong(nextToken());\n        }\n\n        public String next() throws IOException {\n            return nextToken();\n        }\n\n        public String nli() throws IOException {\n            try {\n                return br.readLine();\n            } catch (IOException ex) {\n\n            }\n            return null;\n        }\n\n        public int[] gia(int n) throws IOException {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public int[] gia(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            int a[] = new int[n];\n            for (int i = start; i < end; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public double[] gda(int n) throws IOException {\n            double a[] = new double[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nd();\n            }\n            return a;\n        }\n\n        public double[] gda(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            double a[] = new double[n];\n            for (int i = start; i < end; i++) {\n                a[i] = nd();\n            }\n            return a;\n        }\n\n        public long[] gla(int n) throws IOException {\n            long a[] = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public long[] gla(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            long a[] = new long[n];\n            for (int i = start; i < end; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public int[][] gg(int n, int m) throws IOException {\n            int adja[][] = new int[n + 1][];\n            int from[] = new int[m];\n            int to[] = new int[m];\n            int count[] = new int[n + 1];\n            for (int i = 0; i < m; i++) {\n                from[i] = ni();\n                to[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n            }\n            for (int i = 0; i < m; i++) {\n                adja[from[i]][--count[from[i]]] = to[i];\n                adja[to[i]][--count[to[i]]] = from[i];\n            }\n            return adja;\n        }\n\n        public void print(String s) throws IOException {\n            bw.write(s);\n            bw.flush();\n        }\n\n        public void println(String s) throws IOException {\n            bw.write(s);\n            bw.newLine();\n            bw.flush();\n        }\n\n        private String nextToken() throws IndexOutOfBoundsException, IOException {\n            if (index == s.length) {\n                s = br.readLine().split(\" \");\n                index = 0;\n            }\n            return s[index++];\n        }\n\n        private void validate(int n, int start, int end) {\n            if (start < 0 || end >= n) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    static class Data implements Comparable<Data> {\n\n        int a, b;\n\n        public Data(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Data o) {\n            return Integer.compare(a, o.a);\n        }\n    }\n\n    /**\n     * Source :\n     * https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/\n     *\n     * @author PRASAD\n     */\n    static class GCD {\n\n        public GCD() {\n            // Sry Nothing to initalise\n        }\n\n        public long a_inv_b(long a, long m) {\n            if (gcd(a, m) == 1) {\n                long m0 = m;\n                long y = 0, x = 1;\n                if (m == 1) {\n                    return 0;\n                }\n                while (a > 1) {\n                    long q = a / m;\n                    long t = m;\n                    m = a % m;\n                    a = t;\n                    t = y;\n                    y = x - q * y;\n                    x = t;\n                }\n                if (x < 0) {\n                    x += m0;\n                }\n                return x;\n            } else {\n                return -1;\n            }\n        }\n\n        public int calc_gcd(int a, int b) {\n            if (b > a) {\n                a = a ^ b;\n                b = a ^ b;\n                a = a ^ b;\n            }\n            return (int) gcd(a, b);\n        }\n\n        public long calc_gcd(long a, long b) {\n            if (b > a) {\n                a = a ^ b;\n                b = a ^ b;\n                a = a ^ b;\n            }\n            return gcd(a, b);\n        }\n\n        private long gcd(long a, long b) {\n            if (b == 0) {\n                return a;\n            }\n            long gcd = gcd(b, a % b);\n            return gcd;\n        }\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\ndef primeFactors(number):\n    primeFactors = set()\n    while number % 2 == 0:\n        primeFactors.add(2)\n        number = number / 2\n\n    for i in range(3, int(math.sqrt(number))+1,2) :\n        while number % i == 0:\n            primeFactors.add(i)\n            number = number / i\n\n\n    if number > 2:\n        primeFactors.add(int(number))\n    return primeFactors\n\n\ndef wcd(list_of_pair):\n    boolean = False\n    count = 0\n    list_of_pair = sorted(list_of_pair)\n    a,b = list_of_pair[0]\n    ans = primeFactors(a).union(primeFactors(b))\n    \n    \n    for s in list_of_pair:\n        a,b = s\n        for j in list(ans):\n            if a%j != 0 and b%j != 0:\n                ans.remove(j)\n\n    if ans:\n        return ans.pop()\n    else:\n        return -1\n\nif __name__ == '__main__':\n\n    q = int(input())\n    list_of_pairs = [-1]*q\n    for q_itr in range(q):\n        a,b = map(int,input().rstrip().split())\n        list_of_pairs[q_itr] = [(a,b),(b,a)][a>b]\n\n    result = wcd(list_of_pairs)\n    print(result)\n    \n                \n    \n        \n\n    \n        \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool Debug;\nconst int mod = 1e9 + 7, MAXN = 1e5 + 7;\ntemplate <class A, class B>\nvoid chmax(A &x, B y) {\n  if (x < y) x = y;\n}\ntemplate <class A, class B>\nvoid chmin(A &x, B y) {\n  if (x > y) x = y;\n}\ntemplate <class A, class B>\nA max(A a, B b) {\n  return a > b ? a : b;\n}\ntemplate <class A, class B>\nA min(A a, B b) {\n  return a < b ? a : b;\n}\nunsigned long long gcd(unsigned long long a, unsigned long long b) {\n  unsigned long long t;\n  while (t = a % b) a = b, b = t;\n  return b;\n}\nunsigned long long lcm(unsigned long long x, unsigned long long y) {\n  return x / gcd(x, y) * y;\n}\ntemplate <class A, class B>\nA Pow(A a, B b) {\n  A ret = 1;\n  for (; b; b >>= 1) {\n    if (b & 1) ret = ret * 1ll * a % mod;\n    a = a * 1ll * a % mod;\n  }\n  return ret % mod;\n}\ntemplate <class T>\ninline T abs(T x) {\n  return x >= 0 ? x : -x;\n}\ntemplate <class T>\ninline T sqr(T x) {\n  return x * x;\n}\nstruct Cg {\n  char operator()() { return getchar(); }\n};\nstruct Cp {\n  void operator()(char x) { putchar(x); }\n};\nbool IS(char x) { return x == 10 || x == 13 || x == ' '; }\ntemplate <typename T>\nstruct Fr {\n  T P;\n  Fr &operator,(int &x) {\n    x = 0;\n    unsigned char t = P();\n    while ((t < '0' || t > '9') && t != '-') t = P();\n    bool f = 0;\n    if (t == '-') t = P(), f = 1;\n    x = t - '0';\n    for (t = P(); t >= '0' && t <= '9'; t = P()) x = x * 10 + t - '0';\n    if (f) x = -x;\n    return *this;\n  }\n  operator int() {\n    int x;\n    *this, x;\n    return x;\n  }\n  Fr &operator,(long long &x) {\n    x = 0;\n    unsigned char t = P();\n    while ((t < '0' || t > '9') && t != '-') t = P();\n    bool f = 0;\n    if (t == '-') t = P(), f = 1;\n    x = t - '0';\n    for (t = P(); t >= '0' && t <= '9'; t = P()) x = x * 10 + t - '0';\n    if (f) x = -x;\n    return *this;\n  }\n  operator long long() {\n    long long x;\n    *this, x;\n    return x;\n  }\n  Fr &operator,(char &x) {\n    for (x = P(); IS(x); x = P())\n      ;\n    return *this;\n  }\n  operator char() {\n    char x;\n    *this, x;\n    return x;\n  }\n  Fr &operator,(char *x) {\n    char t = P();\n    for (; IS(t); t = P())\n      ;\n    if (~t) {\n      for (; !IS(t) && ~t; t = P()) *x++ = t;\n    }\n    *x++ = 0;\n    return *this;\n  }\n  Fr &operator,(double &x) {\n    x = 0;\n    unsigned char t = P();\n    while ((t < '0' || t > '9') && t != '-') t = P();\n    bool f = 0;\n    if (t == '-') t = P(), f = 1;\n    x = t - '0';\n    for (t = P(); t >= '0' && t <= '9'; t = P()) x = x * 10 + t - '0';\n    if (t == '.') {\n      double u = 0.1;\n      for (t = P(); t >= '0' && t <= '9'; t = P(), u *= 0.1) x += u * (t - '0');\n    }\n    if (f) x = -x;\n    return *this;\n  }\n  operator double() {\n    double x;\n    *this, x;\n    return x;\n  }\n  Fr &operator,(long double &x) {\n    x = 0;\n    unsigned char t = P();\n    while ((t < '0' || t > '9') && t != '-') t = P();\n    bool f = 0;\n    if (t == '-') t = P(), f = 1;\n    x = t - '0';\n    for (t = P(); t >= '0' && t <= '9'; t = P()) x = x * 10 + t - '0';\n    if (t == '.') {\n      double u = 0.1;\n      for (t = P(); t >= '0' && t <= '9'; t = P(), u *= 0.1) x += u * (t - '0');\n    }\n    if (f) x = -x;\n    return *this;\n  }\n  operator long double() {\n    long double x;\n    *this, x;\n    return x;\n  }\n  Fr &operator,(unsigned int &x) {\n    x = 0;\n    unsigned char t = P();\n    while (t < '0' || t > '9') t = P();\n    x = t - '0';\n    for (t = P(); t >= '0' && t <= '9'; t = P()) x = x * 10 + t - '0';\n    return *this;\n  }\n  operator unsigned int() {\n    unsigned int x;\n    *this, x;\n    return x;\n  }\n  Fr &operator,(unsigned long long &x) {\n    x = 0;\n    unsigned char t = P();\n    while (t < '0' || t > '9') t = P();\n    x = t - '0';\n    for (t = P(); t >= '0' && t <= '9'; t = P()) x = x * 10 + t - '0';\n    return *this;\n  }\n  operator unsigned long long() {\n    unsigned long long x;\n    *this, x;\n    return x;\n  }\n};\nFr<Cg> in;\ntemplate <typename T>\nstruct Fw {\n  T P;\n  Fw &operator,(int x) {\n    if (x) {\n      if (x < 0) P('-'), x = -x;\n      unsigned char s[10], c = 0;\n      while (x) s[c++] = x % 10 + '0', x /= 10;\n      while (c--) P(s[c]);\n    } else\n      P('0');\n    return *this;\n  }\n  Fw &operator()(int x) {\n    if (x) {\n      if (x < 0) P('-'), x = -x;\n      unsigned char s[10], c = 0;\n      while (x) s[c++] = x % 10 + '0', x /= 10;\n      while (c--) P(s[c]);\n    } else\n      P('0');\n    return *this;\n  }\n  Fw &operator,(unsigned int x) {\n    if (x) {\n      unsigned char s[10], c = 0;\n      while (x) s[c++] = x % 10 + '0', x /= 10;\n      while (c--) P(s[c]);\n    } else\n      P('0');\n    return *this;\n  }\n  Fw &operator()(unsigned int x) {}\n  Fw &operator,(long long x) {\n    if (x) {\n      if (x < 0) P('-'), x = -x;\n      unsigned char s[19], c = 0;\n      while (x) s[c++] = x % 10 + '0', x /= 10;\n      while (c--) P(s[c]);\n    } else\n      P('0');\n    return *this;\n  }\n  Fw &operator()(long long x) {\n    if (x) {\n      if (x < 0) P('-'), x = -x;\n      unsigned char s[19], c = 0;\n      while (x) s[c++] = x % 10 + '0', x /= 10;\n      while (c--) P(s[c]);\n    } else\n      P('0');\n    return *this;\n  }\n  Fw &operator,(unsigned long long x) {\n    if (x) {\n      unsigned char s[20], c = 0;\n      while (x) s[c++] = x % 10 + '0', x /= 10;\n      while (c--) P(s[c]);\n    } else\n      P('0');\n    return *this;\n  }\n  Fw &operator()(unsigned long long x) {\n    if (x) {\n      unsigned char s[20], c = 0;\n      while (x) s[c++] = x % 10 + '0', x /= 10;\n      while (c--) P(s[c]);\n    } else\n      P('0');\n    return *this;\n  }\n  Fw &operator,(char x) {\n    P(x);\n    return *this;\n  }\n  Fw &operator()(char x) {\n    P(x);\n    return *this;\n  }\n  Fw &operator,(const char *x) {\n    while (*x) P(*x++);\n    return *this;\n  }\n  Fw &operator()(const char *x) {\n    while (*x) P(*x++);\n    return *this;\n  }\n  Fw &operator()(double x, int y) {\n    if (y) {\n      double t = 0.5;\n      for (int i = y; i--;) t *= 0.1;\n      if (x >= 0)\n        x += t;\n      else\n        x -= t, P('-');\n      *this, (long long)(abs(x));\n      P('.');\n      if (x < 0) x = -x;\n      while (y--) {\n        x *= 10;\n        x -= floor(x * 0.1) * 10;\n        P(((int)x) % 10 + '0');\n      }\n    } else if (x >= 0)\n      *this, (long long)(x + 0.5);\n    else\n      *this, (long long)(x - 0.5);\n    ;\n    return *this;\n  }\n  Fw &operator()(long double x, int y) {\n    if (y) {\n      double t = 0.5;\n      for (int i = y; i--;) t *= 0.1;\n      if (x >= 0)\n        x += t;\n      else\n        x -= t, P('-');\n      *this, (long long)(abs(x));\n      P('.');\n      if (x < 0) x = -x;\n      while (y--) {\n        x *= 10;\n        x -= floor(x * 0.1) * 10;\n        P(((int)x) % 10 + '0');\n      }\n    } else if (x >= 0)\n      *this, (long long)(x + 0.5);\n    else\n      *this, (long long)(x - 0.5);\n    ;\n    return *this;\n  }\n};\nFw<Cp> out;\nunsigned long long n, a[150007], b[150007];\nint main() {\n  in, n;\n  unsigned long long ans, x, y;\n  in, x, y;\n  a[1] = x, b[1] = y;\n  ans = x * y;\n  for (int i = (2), iend = (n); i <= iend; ++i) {\n    in, a[i], b[i];\n    ans = gcd(ans, a[i] * b[i]);\n  }\n  if (ans == 1) {\n    out, -1;\n    return 0;\n  }\n  for (int i = (1), iend = (n); i <= iend; ++i) {\n    unsigned long long GG = gcd(a[i], ans);\n    if (GG != 1)\n      ans = GG;\n    else\n      ans = gcd(b[i], ans);\n  }\n  out, ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\npair<int, int> A[150005];\nset<int> S;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> N;\n  for (int i = 1; i <= N; i++) {\n    cin >> A[i].first >> A[i].second;\n  }\n  int x = 2;\n  int a = A[1].first;\n  while (x * x <= a) {\n    if (a % x == 0) {\n      S.insert(x);\n      while (a % x == 0) a /= x;\n    }\n    x++;\n  }\n  if (a > 1) S.insert(a);\n  x = 2;\n  a = A[1].second;\n  while (x * x <= a) {\n    if (a % x == 0) {\n      S.insert(x);\n      while (a % x == 0) a /= x;\n    }\n    x++;\n  }\n  if (a > 1) S.insert(a);\n  for (int i = 2; i <= N; i++) {\n    vector<int> D;\n    for (int Si : S)\n      if (A[i].first % Si != 0 && A[i].second % Si != 0) D.push_back(Si);\n    for (int Di : D) S.erase(S.find(Di));\n    if (S.empty()) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  cout << *(S.begin()) << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\n\npublic class WeakenedCommonDivisor {\n    public static void main(String args[]) throws IOException {\n        BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.valueOf(buf.readLine());\n        int[][] table = new int[n][2];\n        for(int i=0;i<n;i++){\n            String[] sa = buf.readLine().split(\"\\\\s\");\n\n            table[i][0] = Integer.parseInt(sa[0]);\n            table[i][1] = Integer.parseInt(sa[1]);\n        }\n\n        ArrayList<Integer> a = getPrimeFactors(table[0][0]);\n        a.addAll(getPrimeFactors(table[0][1]));\n\n        for(int i=1;i<n;i++){\n            ArrayList<Integer> list = new ArrayList<>();\n            for(int p: a){\n                if(!list.contains(p)) {\n                    if (table[i][0] % p == 0) {\n                        list.add(p);\n                    }\n                    else if(table[i][1] % p == 0){\n                        list.add(p);\n                    }\n                }\n            }\n            if(list.size()==0){\n                System.out.println(-1);\n                return;\n            }\n            a = list;\n        }\n        if(!a.isEmpty()){\n            System.out.println(a.get(0));\n        }\n        else {\n            System.out.println(-1);\n        }\n    }\n\n    private static ArrayList<Integer> getPrimeFactors(int i) {\n        if(i==0){\n            return null;\n        }\n        ArrayList<Integer> list = new ArrayList<>();\n        while ((i % 2) == 0){\n            list.add(2);\n            i /= 2;\n        }\n        double sqrt = Math.sqrt(i);\n        int j=3;\n        while (i!=1 && j<=sqrt){\n            while (i % j == 0){\n                i /= j;\n                list.add(j);\n            }\n            j+=2;\n        }\n        if(i!=1){\n            list.add(i);\n        }\n        return list;\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tstatic class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    public static long lcm(long a, long b)\n\t{\n\t    return (a*b)/findGCD(a, b);\n\t}\n    public static long findGCD (long a, long b) {\n    long c;\n    do {\n        c = a % b;\n        if (c > 0) {\n            a = b;\n            b = c;\n        }\n    } while (c != 0);\n    return b;\n}\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tFastReader scan=new FastReader();\n\t\tint n=scan.nextInt();\n\t\tlong ans=0;\n\t\tlong a=0;\n\t\tlong b=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta=scan.nextLong();\n\t\t\tb=scan.nextLong();\n\t\t\tans=findGCD(ans,lcm(a,b));\n\t\t}\n\t\tif(ans==1){\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\ta=findGCD(a,ans);\n\t\tb=findGCD(b,ans);\n\t\tif(a==1){\n\t\t\ta=b;\n\t\t}\n\t\tfor(long i=2;i*i<=a;++i){\n\t\t\tif(a%i==0){\n\t\t\t\tSystem.out.println(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a);\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.LinkedHashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class B505 {\n\n\tprivate static Set<Long> getDivisors(long a, long b){\n\t\tSet<Long> divisors = new LinkedHashSet<>();\n\t\tif(a % 2 == 0){\n\t\t\twhile(a % 2 == 0){\n\t\t\t\ta/=2;\n\t\t\t}\n\t\t\tdivisors.add(2L);\n\t\t}\n\t\tfor(long i=3;i*i<=a;i++){\n\t\t\tif(a % i == 0){\n\t\t\t\twhile( a%i == 0){\n\t\t\t\t\ta/=i;\n\t\t\t\t}\n\t\t\t\tdivisors.add(i);\n\t\t\t}\n\t\t}\n\t\tif(a > 2){\n\t\t\tdivisors.add(a);\n\t\t}\n\t\tif(b % 2 == 0){\n\t\t\twhile(b % 2 == 0){\n\t\t\t\tb/=2;\n\t\t\t}\n\t\t\tdivisors.add(2L);\n\t\t}\n\t\tfor(long i=3;i*i<=b;i++){\n\t\t\tif(b % i == 0){\n\t\t\t\twhile( b%i == 0){\n\t\t\t\t\tb/=i;\n\t\t\t\t}\n\t\t\t\tdivisors.add(i);\n\t\t\t}\n\t\t}\n\t\tif(b > 2){\n\t\t\tdivisors.add(b);\n\t\t}\n\t\treturn divisors;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tlong []curA = new long[n+1];\n\t\tlong []curB = new long[n+1];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tlong a = s.nextLong();\n\t\t\tlong b = s.nextLong();\n\t\t\tcurA[i] = a;\n\t\t\tcurB[i] = b;\n\t\t}\n\t\tSet<Long> divisors = getDivisors(curA[0], curB[0]);\n\t\t\n\t\tlong ans = 1;\n\t\tfor(long div : divisors){\n\t\t\tint i = 1;\n\t\t\tfor(;i<n;i++){\n\t\t\t\tif(curA[i] % div != 0 && curB[i] % div != 0){\n\t\t\t\t\tans = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i == n){\n\t\t\t\tans = div;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ans == 1){\n\t\t\tans = -1;\n\t\t}\n\t\tSystem.out.println(ans);\t\t\n\t\ts.close();\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\n\nfacArr = set()\nind = 0\n\n# A function to print all prime factors of  \n# a given number n \ndef primeFactors(n): \n    global facArr\n    # Print the number of two's that divide n \n    while n % 2 == 0: \n        facArr.add(2)\n        n = n // 2\n          \n    # n must be odd at this point \n    # so a skip of 2 ( i = i + 2) can be used \n    for i in range(3,int(math.sqrt(n))+1,2): \n          \n        # while i divides n , print i ad divide n \n        while n % i== 0: \n            facArr.add(i)\n            n = n // i \n              \n    # Condition if n is a prime \n    # number greater than 2 \n    if n > 2: \n        facArr.add(n)\n\n    \nn = int(input())\n\n# a = list(map(int, input().split()))\n# b = list(map(int, input().split()))\n\na = []\nb = []\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    a.append(x)\n    b.append(y)\n\n# taking all prime nubers of the first set a[0] and b[0]\nprimeFactors(a[0])\nprimeFactors(b[0])\n\nfactors = sorted(list(facArr))\n\nfor factor in factors:\n    for i in range(1, n):\n        if a[i]%factor != 0 and b[i]%factor != 0:\n            break\n\n    else:\n        print(factor)\n        break\n\nelse:\n    print(-1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  for (T i : v) os << i << ' ';\n  return os;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, const set<T>& v) {\n  for (T i : v) os << i << ' ';\n  return os;\n}\ntemplate <class T, class S>\nostream& operator<<(ostream& os, const pair<T, S>& v) {\n  os << v.first << ' ' << v.second;\n  return os;\n}\ntemplate <class T, class S>\nostream& operator<<(ostream& os, const unordered_map<T, S>& v) {\n  for (auto i : v) os << '(' << i.first << \"=>\" << i.second << ')' << ' ';\n  return os;\n}\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target( \\\n    \"avx2,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nconst long long inf = 1e16;\nconst long long mod = 1e9 + 7;\nvoid fast() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n}\nclock_t time_p = clock();\nvoid starboy1299() {\n  time_p = clock() - time_p;\n  cerr << \"Time Taken : \" << (float)(time_p) / CLOCKS_PER_SEC << \"\\n\";\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<pair<long long, long long> > arr(n);\n  for (long long i = 0; i < n; i++) {\n    cin >> arr[i].first >> arr[i].second;\n  }\n  vector<long long> v1;\n  long long num = arr[0].first;\n  for (long long i = 2; i * i <= num; i++) {\n    if (num % i == 0) {\n      v1.push_back(i);\n      while (num % i == 0) {\n        num /= i;\n      }\n    }\n  }\n  if (num > 1) v1.push_back(num);\n  vector<long long> v2;\n  long long num2 = arr[0].second;\n  for (long long i = 2; i * i <= num2; i++) {\n    if (num2 % i == 0) {\n      v2.push_back(i);\n      while (num2 % i == 0) {\n        num2 /= i;\n      }\n    }\n  }\n  if (num2 > 1) v2.push_back(num2);\n  for (auto it : v1) {\n    bool flag = 1;\n    for (long long i = 1; i < n; i++) {\n      if (arr[i].first % it == 0 or arr[i].second % it == 0)\n        continue;\n      else\n        flag = 0;\n    }\n    if (flag) {\n      cout << it << '\\n';\n      return;\n    }\n  }\n  for (auto it : v2) {\n    bool flag = 1;\n    for (long long i = 1; i < n; i++) {\n      if (arr[i].first % it == 0 or arr[i].second % it == 0)\n        continue;\n      else\n        flag = 0;\n    }\n    if (flag) {\n      cout << it << '\\n';\n      return;\n    }\n  }\n  cout << -1 << '\\n';\n}\nint32_t main() {\n  fast();\n  long long t = 1;\n  for (long long i = 1; i <= t; i++) {\n    solve();\n  }\n  starboy1299();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int LIM = 1e5;\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int MOD = INF + 7;\nconst double EPS = 1e-9;\nlong long gcd(long long a, long long b) {\n  while (b) {\n    a %= b;\n    swap(a, b);\n  }\n  return a;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  long long g = 0;\n  vector<long long> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n    g = gcd(g, a[i] * b[i]);\n  }\n  if (g > 1) {\n    for (int i = 0; i < n; i++) {\n      long long cd = gcd(g, a[i]);\n      if (cd > 1) g = cd;\n      cd = gcd(g, b[i]);\n      if (cd > 1) g = cd;\n    }\n    cout << g;\n  } else\n    cout << -1;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import sqrt\n\nn = int(input())\n\ndef prime_factors(n):\n    factors = set()\n    while n % 2 == 0:\n        factors.add(2)\n        n = n / 2\n\n    for i in range(3,int(sqrt(n))+1,2):\n        while n % i== 0:\n            factors.add(i)\n            n = n / i\n\n    if n > 2:\n        factors.add(n)\n\n    return factors\n\n\na, b = tuple(map(int, input().split()))\nfactors = prime_factors(a).union(prime_factors(b))\nfor i in range(n-1):\n    a, b = tuple(map(int, input().split()))\n    if factors:\n        new_factors = set()\n        for f in factors:\n            if a % f == 0 or b % f == 0:\n                new_factors.add(f)\n        factors = new_factors\n\nprint(int(factors.pop()) if factors else -1)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastReader scn;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tvoid solve() {\n\t\tint n = scn.nextInt();\n\t\tint[][] arr = new int[n][2];\n\t\tlong g = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i][0] = scn.nextInt();\n\t\t\tarr[i][1] = scn.nextInt();\n\t\t\tg = gcd(arr[i][0] * 1L * arr[i][1] / gcd(arr[i][0], arr[i][1]), g);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong x = gcd(arr[i][0], g);\n\t\t\tlong y = gcd(arr[i][1], g);\n\t\t\tif (x == 1) {\n\t\t\t\tg = y;\n\t\t\t} else\n\t\t\t\tg = x;\n\t\t}\n\t\t\n\t\tif(g == 1) {\n\t\t\tg = -1;\n\t\t}\n\t\t\n\t\tout.println(g);\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\n\tvoid run() throws Exception {\n\t\tlong time = System.currentTimeMillis();\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\tout = new PrintWriter(System.out);\n\t\tscn = new FastReader(oj);\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + \" ms\" }));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tclass FastReader {\n\t\tInputStream is;\n\n\t\tpublic FastReader(boolean onlineJudge) {\n\t\t\tis = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\t}\n\n\t\tbyte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\t\tint readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tint skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn (char) skip();\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar[] next(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tchar[][] nextMatrix(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next(m);\n\t\t\treturn map;\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] next2DInt(int n, int m) {\n\t\t\tint[][] arr = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[][] next2DLong(int n, int m) {\n\t\t\tlong[][] arr = new long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] shuffle(int[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tarr[i] = arr[i] ^ arr[j];\n\t\t\t\tarr[j] = arr[i] ^ arr[j];\n\t\t\t\tarr[i] = arr[i] ^ arr[j];\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "from sys import stdin, stdout\nti = lambda : stdin.readline().strip()\nma = lambda fxn, ti : map(fxn, ti.split())\nol = lambda arr : stdout.write(' '.join(str(i) for i in arr) + '\\n')\nos = lambda i : stdout.write(str(i) + '\\n')\nolws = lambda arr : stdout.write(''.join(str(i) for i in arr) + '\\n')\n\n\nn = int(ti())\nvalues = []\nfor i in range(n):\n\tvalues.append(ma(int,ti()))\n\ndef calculatehcf(a, b):\n\tif b == 0:\n\t\treturn a\n\telse:\n\t\treturn calculatehcf(b, a%b)\n\n\n\nlcms = []\nmaxm = -1\nfor i in range(n):\n\ta, b = values[i][0], values[i][1]\n\tlcm = (a*b)/calculatehcf(max(a, b), min(a, b))\n\tlcms.append(lcm)\n\n\nans = lcms[0]\nfor i in range(1, n):\n\tans = calculatehcf(max(ans, lcms[i]), min(ans, lcms[i]))\n\nans = max(calculatehcf(ans, values[n-1][0]), calculatehcf(ans, values[n-1][1]))\n\nif ans == 1:\n\tos(-1)\nelse:\n\ti = 2\n\twhile i*i <= ans:\n\t\tif ans%i == 0:\n\t\t\tos(i)\n\t\t\texit()\n\t\ti += 1\n\tos(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class WeakenedCommonDivisor {\n    void solve() {\n        int n = in.nextInt();\n        \n        Set<Integer> cur = new HashSet<>(), nxt = new HashSet<>();\n        for (int i = 0; i < n; i++) {\n            int a = in.nextInt(), b = in.nextInt();\n            if (i == 0) {\n                for (int x : primeFactors(a)) cur.add(x);\n                for (int x : primeFactors(b)) cur.add(x);\n            } else {\n                nxt.clear();\n                for (int x : cur) if (a % x == 0 || b % x == 0) nxt.add(x);\n                Set<Integer> tmp = cur; cur = nxt; nxt = tmp;\n            }\n        }\n        \n        if (cur.size() == 0) {\n            out.println(-1);\n            return;\n        }\n        out.println(cur.iterator().next());\n    }\n    \n    int[] primeFactors(int n) {\n        int sz = 0;\n        int[] res = new int[18];\n        int sqrt = (int) (Math.sqrt(n) + 0.5);\n        for (int i = 2; i <= sqrt; i++) {\n            if (n % i == 0) {\n                res[sz++] = i;\n                while (n % i == 0) n /= i;\n            }\n        }\n        if (n > 1) res[sz++] = n;\n        return Arrays.copyOf(res, sz);\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new WeakenedCommonDivisor().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Prime1025B {\n\t// -------------------\n\tpublic static final int MOD = (int) (1e9 + 7);\n\t// ------------------\n\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer st;\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tString next() {\n\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\t// ------------------\n\tpublic static void main(String[] args) {\n\t\tPrime1025B ob = new Prime1025B();\n\t\tob.run();\n\t}\n\n\tprivate void run() {\n\t\t\n\t\tint n = nextInt();\n\t\tlong[] a = new long[n];\n\t\tlong[] b = new long[n];\n\t\tlong g =0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextInt(); b[i] = nextInt();\n\t\t\tg = gcd(g, a[i]*b[i]);\n\t\t}\n\t\tif(g==1L) {\n\t\t\tout.println(\"-1\");\n\t\t}else {\n//\t\t\tout.println(g);\n\t\t\tlong temp=0;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ttemp = gcd(g, a[i]);\n\t\t\t\tif(temp==1) {\n\t\t\t\t\ttemp = gcd(g, b[i]);\n\t\t\t\t}\n\t\t\t\tg = temp;\n\t\t\t}\n\t\t\tout.println(g);\n\t\t}\n\t\tout.close();\n\t}\n\tprivate long gcd(long a, long b) {\n\t\twhile(b!=0) {\n\t\t\tlong t = a%b;\n\t\t\ta = b;\n\t\t\tb = t;\n\t\t}\n\t\treturn a;\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstd::clock_t __start;\ndouble __duration;\nvoid start_timer() { __start = std::clock(); }\nvoid print_timer() {\n  __duration = (std::clock() - __start) / (double)CLOCKS_PER_SEC;\n  std::cout << \"Duration (msec): \" << __duration * 1000 << '\\n';\n}\ntemplate <class T>\nT min_(T a, T b) {\n  return (a < b ? a : b);\n}\ntemplate <class T>\nT max_(T a, T b) {\n  return (a > b ? a : b);\n}\ndouble EPS = 1e-16;\nbool eq_(const double& lhs, const double& rhs) {\n  return (fabs(lhs - rhs) < EPS);\n}\nconst int INF = int(2e9);\nconst long long INF_LL = LLONG_MAX;\nconst long long MOD = 1e9 + 7;\nconst int MAX_N = 1e6 + 5;\nlong long gcd(long long a, long long b) {\n  if (a == 0) return b;\n  return gcd(b % a, a);\n}\nlong long gcd(vector<long long>& nums) {\n  long long res = nums[0];\n  for (int i = 1; i < nums.size(); ++i) res = gcd(nums[i], res);\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int N;\n  cin >> N;\n  vector<pair<int, int> > startnums(N);\n  vector<long long> nums(N);\n  long long a, b;\n  for (int i = 0; i < N; ++i) {\n    cin >> a >> b;\n    nums[i] = a * b;\n    startnums[i] = {a, b};\n  }\n  long long res = gcd(nums);\n  if (res == 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  long long res2;\n  for (int i = 0; i < N; ++i) {\n    res2 = gcd(res, startnums[i].first);\n    if (res2 == 1) {\n      res2 = gcd(res, startnums[i].second);\n    }\n    res = res2;\n  }\n  cout << res << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class B1025 {\n    public static void main(String[] args) throws IOException {\n        Reader scan = new Reader();\n\n        int n = scan.nextInt();\n        int[][] a = new int[n][2];\n        for(int i=0;i<n;i++) {\n            a[i][0] = scan.nextInt();\n            a[i][1] = scan.nextInt();\n        }\n        List<Integer> divisors = getFactors(a[0][0], a[0][1]);\n        for(int i=0;i<divisors.size();i++) {\n            boolean divides = true;\n            int temp = divisors.get(i);\n            for(int j=0;j<n;j++) {\n                if(a[j][0] % temp != 0 && a[j][1] % temp != 0) {\n                    divides = false;\n                    break;\n                }\n            }\n            if(divides) {\n                System.out.println(temp);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n    static List<Integer> getFactors(int a, int b) {\n        Set<Integer> factors = new HashSet<>();\n        List<Integer> res = new ArrayList<>();\n        while(a % 2 == 0) {\n            if(!factors.contains(2)) {\n                factors.add(2);\n                res.add(2);\n            }\n            a >>= 1;\n        }\n        for(int i=3;i*i <= a;i += 2) {\n            while(a % i == 0) {\n                if(!factors.contains(i)) {\n                    factors.add(i);\n                    res.add(i);\n                }\n                a /= i;\n            }\n        }\n\n        while(b % 2 == 0) {\n            if(!factors.contains(2)) {\n                factors.add(2);\n                res.add(2);\n            }\n            b >>= 1;\n        }\n        for(int i=3;i*i <= b;i += 2) {\n            while(b % i == 0) {\n                if(!factors.contains(i)) {\n                    factors.add(i);\n                    res.add(i);\n                }\n                b /= i;\n            }\n        }\n        if(a > 2) {\n            if(!factors.contains(a)) {\n                factors.add(a);\n                res.add(a);\n            }\n        }\n        if(b > 2) {\n            if(!factors.contains(b)) {\n                factors.add(b);\n                res.add(b);\n            }\n        }\n\n        return res;\n    }\n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n * Remember a 7.0 student can know more than a 10.0 student.\n * Grades don't determine intelligence, they test obedience. \n * I Never Give Up.\n */\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.io.*;\n \nimport static java.lang.System.out;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class ContestMain {\n\tprivate static Reader in=new Reader();\n\tprivate static StringBuilder ans=new StringBuilder();\n\tprivate static long MOD=1000000007;//10^9+7 \n\tprivate static final int N=100000; //10^5\n//\tprivate static final int LIM=26;\n//\tprivate static final double PI=3.1415;\n//\tprivate static ArrayList<Integer> v[]=new ArrayList[N];\n//\tprivate static int color[]=new int[N]; //For Graph Coloring\n//\tprivate static boolean mark[]=new boolean[N];\n//\tprivate static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n//\tprivate static void dfs(int node){mark[node]=true;for(int x:v[node]){if(!mark[x]){dfs(x,v);}}}\n\tboolean prime[]=new boolean[2000000000];\n\tprivate static long powmod(long x,long n,long m){\n\t\tif(n==0)return 1;\n\t\telse if(n%2==0)return(powmod((x*x)%m,n/2,m));\n\t\telse return (x*(powmod((x*x)%m,(n-1)/2,m)))%m;\n\t}\n//\tprivate static void shuffle(long [] arr) {\n//\t\tfor (int i = arr.length - 1; i >= 2; i--) {\n//\t\t\tint x = new Random().nextInt(i - 1);\n//\t        long temp = arr[x];\n//\t        arr[x] = arr[i];\n//\t        arr[i] = temp;\n//\t    }\n//\t }\n\n\tpublic static void main(String[] args) throws IOException{\n\t\tint n=in.nextInt();\n\t\tint a[]=new int[n];\n\t\tint b[]=new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i]=in.nextInt();\n\t\t\tb[i]=in.nextInt();\n\t\t}\n\t\tHashSet<Integer> set=new HashSet();\n\t\tint c=2,temp=a[0];\n\t\tfor(int i=2;i<=sqrt(temp);i++){\n\t\t\tif(temp%i==0){\n\t\t\t\tset.add(i);\n\t\t\t\twhile(temp%i==0)temp/=i;\n\t\t\t}\n\t\t}\n\t\tif(temp!=1)set.add(temp);\n\t\ttemp=b[0];\n\t\tfor(int i=2;i<=sqrt(temp);i++){\n\t\t\tif(temp%i==0){\n\t\t\t\tset.add(i);\n\t\t\t\twhile(temp%i==0)temp/=i;\n\t\t\t}\n\t\t}\n\t\tif(temp!=1)set.add(temp);\n\t\tint i;\n\t\tfor(int x:set){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(a[i]%x!=0&&b[i]%x!=0)break;\n\t\t\t}\n\t\t\tif(i==n){\n\t\t\t\tout.println(x);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(-1);\n\t}\n\tstatic class Pair<T> implements Comparable<Pair>{\n\t\tint l;\n\t\tint r;\n\t\tPair(){\n\t\t\tl=0;\n\t\t\tr=0;\n\t\t}\n\t\tPair(int k,int v){\n\t\t\tl=k;\n\t\t\tr=v;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn (int) (r-o.r);\n\t\t}\n\t\t\n\t}\n\tstatic class Reader{\n        BufferedReader br;\n        StringTokenizer st;\n        public Reader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n     \n                \tst = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n} "
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class P1025B\n{\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        long a = in.nextLong();\n        long b = in.nextLong();\n        long c = a * b;\n        for(int i = 2; i <= n; ++i)\n        {\n            long aa = in.nextLong();\n            long bb = in.nextLong();\n            c = gcd(c, aa * bb);\n        }\n\n        if(c == 1)\n        {\n            out.println(-1);\n        }\n        else\n        {\n            // out.println(ans);\n            boolean solved = false;\n            long cc = gcd(c, a);\n            if(cc == 1)\n            {\n                cc = gcd(c, b);\n            }\n\n            if(cc == 1)\n            {\n                out.println(-1);\n            }\n            else\n            {\n                for(long i = 2; i * i <= cc; ++i)\n                {\n                    if(cc % i == 0)\n                    {\n                        out.println(i);\n                        solved = true;\n                        break;\n                    }\n                }\n\n                if(!solved)\n                {\n                    out.println(cc);\n                }\n            }\n        }\n\n        out.close();\n    }\n\n    private static long gcd(long a, long b)\n    {\n        while(b != 0)\n        {\n            long r = a % b;\n            a = b;\n            b = r;\n        }\n        return a;\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Asgar Javadov\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            long[] a = new long[n];\n            long[] b = new long[n];\n\n            for (int i = 0; i < n; ++i) {\n                a[i] = in.nextLong();\n                b[i] = in.nextLong();\n            }\n\n            int[] factors = NumberTheory.primes(45000);\n\n            Set<Integer> set = new HashSet<>();\n            process(factors, a[0], set);\n            process(factors, b[0], set);\n\n            for (int i = 1; i < n; ++i) {\n                for (Iterator<Integer> it = set.iterator(); it.hasNext(); ) {\n                    int prime = it.next();\n                    if (a[i] % prime != 0 && b[i] % prime != 0) {\n                        it.remove();\n                    }\n                }\n            }\n\n            if (set.isEmpty()) {\n                out.println(-1);\n            } else {\n                out.println(set.iterator().next());\n            }\n\n        }\n\n        private void process(int[] factors, long temp, Set<Integer> set) {\n            for (int prime : factors) {\n                if (temp % prime == 0) {\n                    set.add(prime);\n                    while (temp % prime == 0) temp /= prime;\n                }\n            }\n\n            if (temp > 1) set.add((int) temp);\n        }\n\n    }\n\n    static class NumberTheory {\n        public static int[] primes(final int nInclusive) {\n            boolean[] prime = new boolean[nInclusive + 1];\n            Arrays.fill(prime, 2, prime.length, true);\n\n            for (int i = 2; i * i <= nInclusive; ++i)\n                if (prime[i]) {\n                    for (int j = i * i; j <= nInclusive; j += i) {\n                        prime[j] = false;\n                    }\n                }\n\n            int numOfPrimes = 0;\n            for (int i = 2; i <= nInclusive; ++i)\n                if (prime[i])\n                    ++numOfPrimes;\n\n            int[] result = new int[numOfPrimes];\n            for (int j = 0, i = 2; i <= nInclusive; ++i)\n                if (prime[i])\n                    result[j++] = i;\n\n            return result;\n        }\n\n    }\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n\n    }\n\n    static class InputReader extends BufferedReader {\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream inputStream) {\n            super(new InputStreamReader(inputStream), 32768);\n        }\n\n        public InputReader(String filename) {\n            super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public Integer nextInt() {\n            return Integer.valueOf(next());\n        }\n\n        public Long nextLong() {\n            return Long.valueOf(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "\"\"\"\nauthor @ Mobarak Hosen Shakil\nDept. of ICE, Islamic University\nKushtia, Bangladesh\n\n\"\"\"\n\ndef divisors(a, b):\n    Divisors = []\n\n    i = 2\n\n    while(i*i<=a):\n        if a % i == 0:\n            Divisors.append(i)\n            while( a % i == 0):\n                a /= i\n        i+=1\n\n    i = 2\n\n    while (i * i <= b):\n        if b % i == 0:\n            if i not in Divisors:\n                Divisors.append(i)\n            while (b % i == 0):\n                b /= i\n        i += 1\n\n    if a != 1 :\n        Divisors.append(int(a))\n    if b != 1 :\n        Divisors.append(int(b))\n\n    #print(Divisors)\n\n    return Divisors\n\n\ndef main():\n\n    n = int(input())\n\n    A = list()\n\n    for i in range (0, n):\n        b = list(map(int, input().split()))\n        A += b\n\n    Prime = divisors(A[0], A[1])\n\n    ans = -1\n\n    for i in range(0, len(Prime)):\n        Ok = 1\n        for j in range(1, n):\n            if A[j*2] % Prime[i] != 0 and A[2*j+1] % Prime[i] != 0 :\n                #print(Prime[i])\n                Ok = 0\n                break\n        if (Ok != 0) :\n            ans = Prime[i]\n            break\n\n    print(ans)\n\nmain()"
        },
        {
            "language": 3,
            "solution": "def prime_divs(n):\n    res = set()\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            while n % d == 0:\n                n = n // d\n            res.add(d)\n        else:\n            d = d + 1\n    if n > 1:\n        res.add(n)\n    return res\n\n\nn = int(input())\nls = []\n\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    ls.append([a, b])\n\nset1 = prime_divs(ls[0][0])\nset1 = set1.union(prime_divs(ls[0][1]))\n\nfor i in range(1, n):\n    to_remove = set()\n    for d in set1:\n        if not (ls[i][0] % d == 0 or ls[i][1] % d == 0):\n            to_remove.add(d)\n    set1 = set1.difference(to_remove)\n\nif len(set1) == 0:\n    print(-1)\nelse:\n    print(list(set1)[0])\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[150005], b[150005], c[150005], m = 0;\nint snt[44722 + 1];\nvoid sangnt() {\n  long i, j;\n  for (i = 1; i <= 44722; i++) snt[i] = 1;\n  snt[1] = 0;\n  i = 2;\n  while (i <= sqrt(44722)) {\n    while (snt[i] == 0) i++;\n    for (j = 2; j <= 44722 / i; j++) snt[i * j] = 0;\n    i++;\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d%d\", &a[i], &b[i]);\n  }\n  int i;\n  for (i = 2; i <= a[1]; ++i) {\n    if (a[1] % i == 0) {\n      c[++m] = i;\n    }\n    while (a[1] % i == 0) {\n      a[1] /= i;\n    }\n    if (i * i > a[1] && a[1] > 1) {\n      c[++m] = a[1];\n      break;\n    }\n  }\n  for (i = 2; i <= b[1]; ++i) {\n    if (b[1] % i == 0) {\n      c[++m] = i;\n    }\n    while (b[1] % i == 0) {\n      b[1] /= i;\n    }\n    if (i * i > b[1] && b[1] > 1) {\n      c[++m] = b[1];\n      break;\n    }\n  }\n  bool ans;\n  for (i = 1; i <= m; ++i) {\n    ans = true;\n    for (int j = 2; j <= n; ++j) {\n      if (a[j] % c[i] != 0 && b[j] % c[i] != 0) {\n        ans = false;\n        break;\n      }\n    }\n    if (ans) {\n      printf(\"%d\\n\", c[i]);\n      break;\n    }\n  }\n  if (!ans) {\n    printf(\"-1\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int arr[2], arr1[150000], arr2[150000][2], n,\n    min1 = 1000000000000, min2, a1, ck, sq, i, j, k;\nint main() {\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < 2; j++) {\n      cin >> arr2[i][j];\n    }\n    min2 = min(arr2[i][0], arr2[i][1]);\n    if (min2 < min1) {\n      min1 = min2;\n      arr[0] = arr2[i][0];\n      arr[1] = arr2[i][1];\n    }\n  }\n  for (i = 0; i < 2; i++) {\n    a1 = 0;\n    ck = 0;\n    min2 = arr[i];\n    while ((min2 % 2) == 0) {\n      ck = 1;\n      min2 /= 2;\n    }\n    if (ck == 1) {\n      arr1[a1] = 2;\n      a1++;\n    }\n    sq = sqrt(min2);\n    for (j = 3; j <= sq; j += 2) {\n      ck = 0;\n      while ((min2 % j) == 0) {\n        ck = 1;\n        min2 /= j;\n      }\n      if (ck == 1) {\n        arr1[a1] = j;\n        a1++;\n      }\n    }\n    if (min2 > 2) {\n      arr1[a1] = min2;\n      a1++;\n    }\n    for (j = 0; j < a1; j++) {\n      for (k = 0; k < n; k++) {\n        if ((arr2[k][0] % arr1[j] != 0) && (arr2[k][1] % arr1[j] != 0)) {\n          break;\n        }\n      }\n      if (k == n) {\n        cout << arr1[j] << endl;\n        return 0;\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst ll infll = (1LL << 61) - 1;\ntemplate <typename T>\nset<T> divisor(T n) {\n  set<T> divisor;\n  for (T i = 1; i * i <= n; i++) {\n    if (n % i == 0) {\n      divisor.insert(i);\n      if (i * i != n) divisor.insert(n / i);\n    }\n  }\n  return divisor;\n}\nint N;\nint main() {\n  cin.tie(0), ios::sync_with_stdio(false);\n  cin >> N;\n  vector<pair<int, int>> a(N);\n  for (int i = 0; i < N; i++) {\n    int p, q;\n    cin >> p >> q;\n    a[i] = make_pair(p, q);\n  }\n  sort(a.begin(), a.end());\n  a.erase(unique(a.begin(), a.end()), a.end());\n  N = a.size();\n  auto d1 = divisor(a[0].first), d2 = divisor(a[0].second);\n  set<int> st;\n  for (auto &c : d1) st.insert(c);\n  for (auto &c : d2) st.insert(c);\n  st.erase(1);\n  for (int i = 1; i < N; i++) {\n    vector<int> del;\n    for (auto &c : st) {\n      if (a[i].first % c != 0 && a[i].second % c != 0) {\n        del.push_back(c);\n      }\n    }\n    for (auto &c : del) st.erase(c);\n    if (st.empty()) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n  cout << *st.rbegin() << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long gcd(long long a, long long b) {\n  if (a < b) swap(a, b);\n  return b == 0 ? a : gcd(b, a % b);\n}\nlong long a[150005], b[150005];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  long long pre = 0;\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i] >> b[i];\n    if (a[i] < b[i]) swap(a[i], b[i]);\n    long long tmp = a[i] / gcd(a[i], b[i]) * b[i];\n    if (!pre)\n      pre = a[i] / gcd(a[i], b[i]) * b[i];\n    else\n      pre = gcd(pre, tmp);\n    if (pre == 1) {\n      cout << -1;\n      return 0;\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    long long tmp = gcd(pre, a[i]);\n    if (tmp > 1) pre = tmp;\n    tmp = gcd(pre, b[i]);\n    if (tmp > 1) pre = tmp;\n  }\n  cout << pre;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class I_O {\n    \n    public static void main(String args[])throws IOException {\n        \n    \t//CODE HERE\t\n    \tint n = in.nextInt();\n\t\tint arr[][] = new int[n][2];\n\t\tint min = Integer.MAX_VALUE, ind = 0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tarr[i][0] = in.nextInt();\n\t\t\tarr[i][1] = in.nextInt();\n\t\t\tint m = Math.min(arr[i][0], arr[i][1]);\n\t\t\tif(m<min) {\n\t\t\t\tmin=m; ind = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint a = arr[ind][0], b = arr[ind][1];\n\t\tint aa[] = new int[32];\n\t\tint bb[] = new int[32];\n\t\tint q = 0;\n\t\tif(a%2==0) aa[q++]=2;\n\t\twhile(a%2==0) a/=2;\n\t\tfor(int i=3; i<=Math.sqrt(a); i+=2) {\n\t\t\tif(a%i==0) {\n\t\t\t\taa[q++] = i;\n\t\t\t\twhile(a%i==0) a/=i;\n\t\t\t}\n\t\t} if(a>0) aa[q++] = a;\n\t\t/*for(int i=2; i<=Math.sqrt(a); i++) {\n\t\t\tif(a%i==0) {\n\t\t\t\tif(i == a/i) aa[q++] = i;\n\t\t\t\telse {\n\t\t\t\t\taa[q++] = i;\n\t\t\t\t\taa[q++] = a/i;\n\t\t\t\t} a/=i;\n\t\t\t}\n\t\t} aa[q++] = a;*/\n\t\t\n\t\tq = 0;\n\t\tif(b%2==0) bb[q++]=2;\n\t\twhile(b%2==0) b/=2;\n\t\tfor(int i=3; i<=Math.sqrt(b); i+=2) {\n\t\t\tif(b%i==0) {\n\t\t\t\tbb[q++] = i;\n\t\t\t\twhile(b%i==0) b/=i;\n\t\t\t}\n\t\t} if(b>0) bb[q++] = b;\n\t\t/*for(int i=2; i<=Math.sqrt(b); i++) {\n\t\t\tif(b%i==0) {\n\t\t\t\tif(i == b/i) bb[q++] = i;\n\t\t\t\telse {\n\t\t\t\t\tbb[q++] = i;\n\t\t\t\t\tbb[q++] = b/i;\n\t\t\t\t} b/=i;\n\t\t\t} \n\t\t} bb[q++] = b;*/\n\t\tint cnt = 0, ans = 0;\n\t\tfor(int i=0; i<32; i++) {\n\t\t\tint curr = aa[i]; if(curr<2) continue;\n\t\t\tcnt = 0;\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(arr[j][0]%curr==0||arr[j][1]%curr==0) cnt++;\n\t\t\t}\n\t\t\tif(cnt==n) {\n\t\t\t\tans = curr; break;\n\t\t\t}\n\t\t}\n\t\tif(ans!=0) out.print(ans+\"\\n\");\n\t\t\n\t\telse {\n\t\t\tcnt = 0;\n\t\t\tfor(int i=0; i<32; i++) {\n\t\t\t\tint curr = bb[i]; if(curr<2) continue;\n\t\t\t\tcnt = 0;\n\t\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\t\tif(arr[j][0]%curr==0||arr[j][1]%curr==0) cnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt==n) {\n\t\t\t\t\tans = curr; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans!=0) out.print(ans+\"\\n\");\n\t\t\telse out.print(-1+\"\\n\");\n\t\t}\n    \t\n    \tout.flush();\n    \tout.close();\n    }\n\n    // Fast I/O\n    static BR in = new BR();\n\tstatic Reader br = new Reader();\t\n    static OutputWriter out = new OutputWriter(System.out);\n    \n    static class BR {\n \t\tBufferedReader br; StringTokenizer st;\n \t\tpublic BR() {\n \t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n \t\t}\n \t\tint nextInt() {\n \t\t\treturn Integer.parseInt(next());\n \t\t}\n \t\tlong nextLong() {\n \t\t\treturn Long.parseLong(next());\n \t\t} \n \t\tdouble nextDouble() {\n \t\t\treturn Double.parseDouble(next()); \n \t\t}\n \t\tString nextLine() {\n \t\t\tString str = \"\";\n \t\t\ttry {\n \t\t\t\tstr=br.readLine();\n \t\t\t\t}\n \t\t\tcatch (IOException e) {\n \t\t\t\te.printStackTrace();\n \t\t\t\t}\n \t\t\treturn str;\n \t\t}\n \t\tString next() {\n \t\t\twhile(st==null||!st.hasMoreElements()) {\n \t\t\t\ttry {\n \t\t\t\t\tst=new StringTokenizer(br.readLine());\n \t\t\t\t\t}\n \t\t\t\tcatch(IOException e) {\n \t\t\t\t\te.printStackTrace();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\treturn st.nextToken();\n \t\t}\n \t}\n    \n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n\n    }\n\n    //\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 11;\nmap<int, int> mt;\nint a[N], b[N];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  long long p = 0;\n  vector<int> v;\n  for (int i = 1; i < n; i++) cin >> a[i] >> b[i];\n  long long x, y;\n  cin >> x >> y;\n  for (int d = 2; d * d <= max(x, y); d++) {\n    if (x % d == 0 || y % d == 0) {\n      v.push_back(d);\n      if (mt[d] == n) {\n        cout << d << endl;\n        return 0;\n      }\n    }\n    while (x % d == 0) x /= d;\n    while (y % d == 0) y /= d;\n  }\n  if (x > 1) v.push_back(x);\n  if (y > 1 && x != y) v.push_back(y);\n  for (int j = 0; j < v.size(); j++) {\n    int t = 0;\n    for (int p = 1; p < n; p++)\n      if (a[p] % v[j] != 0 && b[p] % v[j] != 0) t = 1;\n    if (t == 0) {\n      cout << v[j];\n      return 0;\n    }\n  }\n  cout << -1;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 1e3 + 5;\nconst int mod = 1e9 + 7;\nusing namespace std;\nint t, n, m;\nlong long x, y;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nint main() {\n  scanf(\"%d\", &n);\n  n--;\n  long long a, b;\n  scanf(\"%lld %lld\", &a, &b);\n  while (n--) {\n    scanf(\"%lld %lld\", &x, &y);\n    a = gcd(a, x * y);\n    b = gcd(b, x * y);\n  }\n  if (a != 1) {\n    for (long long i = 2; i <= sqrt(a); i++) {\n      if (a % i == 0) {\n        printf(\"%lld\\n\", i);\n        return 0;\n      }\n    }\n    printf(\"%lld\\n\", a);\n    return 0;\n  }\n  if (b != 1) {\n    for (long long i = 2; i <= sqrt(b); i++) {\n      if (b % i == 0) {\n        printf(\"%lld\\n\", i);\n        return 0;\n      }\n    }\n    printf(\"%lld\\n\", b);\n    return 0;\n  }\n  printf(\"-1\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n// import java.lang.*;\nimport java.io.*;\n\n//           THIS TEMPLATE MADE BY AKSH BANSAL.\n\npublic class Solution {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    private static boolean[] isPrime;\n    private static List<Integer> primeList;\n    private static void primes(){\n        int num = (int)1e6; // PRIMES FROM 1 TO NUM\n        isPrime = new boolean[num];\n        primeList = new ArrayList<>();\n     \n        for (int i = 2; i< isPrime.length; i++) {\n           isPrime[i] = true;\n        }\n        for (int i = 2; i< Math.sqrt(num); i++) {\n           if(isPrime[i] == true) {\n                primeList.add(i);\n              for(int j = (i*i); j<num; j = j+i) {\n                 isPrime[j] = false;\n              }\n           }\n        }\n    }\n    private static long gcd(long a, long b){\n        if(b==0)return a;\n        return gcd(b,a%b);\n    }\n    public static void main(String[] args) throws IOException {\n        FastReader sc = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        primes();\n        // ________________________________\n\n        // int t = sc.nextInt();\n        // StringBuilder output = new StringBuilder();\n\n        // while (t-- > 0) {\n\n        //     output.append(solver()).append(\"\\n\");\n        // }\n\n        // out.println(output);\n        // _______________________________\n\n        int n = sc.nextInt();\n        HashSet<Integer> factors = new HashSet<>();\n        int first = sc.nextInt();\n        getFactors(first, factors);\n        int sec = sc.nextInt();\n        getFactors(sec, factors);\n\n        for(int i=0;i<n-1;i++){\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            List<Integer> temp = new LinkedList<>();\n            for(Integer e: factors){\n                if(a%e==0){\n                    continue;\n                }\n                else if( b%e==0){\n                    continue;\n                }\n                else{\n                    // factors.remove(e);\n                    temp.add(e);\n                }\n            }\n            for(int e: temp){\n                factors.remove(e);\n            }\n        }\n        if(factors.size()==0)out.println(-1);\n        else {\n            for(Integer e: factors){\n                out.println(e);\n                out.flush();\n                return;\n            }\n        }\n        // ________________________________\n        out.flush();\n    }\n\n    public static void getFactors(int n, HashSet<Integer> arr ) {\n        // for(int i=0;primeList.get(i)<=(int)Math.sqrt(n);i++){\n        for(int i=2;i<=(int)Math.sqrt(n);i++){\n            // int e = primeList.get(i);\n            int e = i;\n            if(n%e==0){\n                arr.add(e);\n            }\n            while(n%e==0){\n                n /=e;\n            }\n        }\n        if(n>1){\n            arr.add(n);\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\npublic class Main\n{\n    static long mod=((long)1e9)+7;//toString\n    public static int gcd(int a,int b){if(b==0)return a;else return gcd(b,a%b);}\n    public static long pow_mod(long x,long y){long res=1;x=x%mod;while(y > 0){if((y & 1)==1)res=(res * x)%mod;y=y>>1;x =(x * x)%mod;}return res;}\n    public static int lower_bound(int[]arr,int val){int lo=0;int hi=arr.length-1;while(lo<hi){int mid=lo+((hi-lo+1)/2);if(arr[mid]==val){return mid;}else if(arr[mid]>val){hi=mid-1;}else lo=mid;}if(arr[lo]<=val)return lo;else return -1;}\n    public static int upper_bound(int[]arr,int val){int lo=0;int hi=arr.length-1;while(lo<hi){int mid=lo+((hi-lo)/2);if(arr[mid]==val){return mid;}else if(arr[mid]>val){hi=mid;;}else lo=mid+1;}if(arr[lo]>=val)return lo;else return -1;}\n    static int x; static TreeSet ts; static int y;\n    public static void factorise(){\n        for(int i = 2; (i * i) <= x; ++i){\n            if((x % i) == 0){\n                ts.add(i);\n                x /= i;\n                factorise();\n            }\n        }\n        return;\n    }\n    public static void factorise2(){\n        for(int i = 2; (i * i) <= y; ++i){\n            if((y % i) == 0){\n                ts.add(i);\n                y /= i;\n                factorise2();\n            }\n        }\n        return;\n    }\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Reader sn = new Reader();\n        Print p = new Print();\n        int n = sn.nextInt();\n        ts = new TreeSet<Integer>();\n        int[][] arr = new int[2][n];\n        for(int i = 0; i < n; ++i){\n            arr[0][i] = sn.nextInt();\n            arr[1][i] = sn.nextInt();\n        }\n        x = arr[0][0];\n        y = arr[1][0];\n        factorise();\n        if(x != 1){\n            ts.add(x);\n        }\n        factorise2();\n        if(y != 1)\n        ts.add(y);\n        ArrayList<Integer> ass = new ArrayList<Integer>();\n        Iterator it = ts.iterator();\n        while(it.hasNext())\n        ass.add((Integer)it.next());\n        int[] count = new int[ass.size()];\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < ass.size(); ++j){\n                if(((arr[0][i] % ass.get(j)) == 0) || ((arr[1][i] % ass.get(j)) == 0)){\n                    count[j]++;\n                }\n            }\n        }\n        int ans = -1;\n        for(int i = 0; i < count.length; ++i){\n            if(count[i] == n){\n                ans = ass.get(i);\n                break;\n            }\n        }\n        p.printLine(Integer.toString(ans));\n        p.close();\n    }\n}\nclass Pair implements Comparable<Pair> {\n\t\tint val;\n\t\tint in;\n\t\tPair(int a, int b){\n\t\t\tval=a;\n\t        in=b;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(val==o.val)\n\t\t\treturn Integer.compare(in,o.in);\n\t\t\telse\n\t\t\treturn Integer.compare(val,o.val);\n\t\t}}\nclass Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; }\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n        \n        public String readWord()throws IOException\n        {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) c = read();        \n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t}while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t    } \n\t\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n \n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n \n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n \n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n \n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\nclass Print\n{\n    private final BufferedWriter bw;\n    public Print()\n    {\n        bw=new BufferedWriter(new OutputStreamWriter(System.out));\n    }\n    public void print(String str)throws IOException\n    {\n        bw.append(str);\n    }\n    public void printLine(String str)throws IOException\n    {\n        print(str);\n        bw.append(\"\\n\");\n    }\n    public void close()throws IOException\n    {\n        bw.close();\n    }}"
        },
        {
            "language": 4,
            "solution": "//package codeforces.div2;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class WeakenedCommonDivisor {\n\n    static public void print(long arr[][]) {\n\n        long max = Integer.MIN_VALUE;\n        boolean flag = false;\n        HashSet<Long> set = new HashSet<>();\n\n        primeFactors(arr[0][0], set);\n        primeFactors(arr[0][1], set);\n\n\n        Iterator<Long> it = set.iterator();\n        while (it.hasNext()){\n            long i = it.next();\n            int count = 0;\n            for(int j = 0; j < arr.length; j++) {\n                long a = arr[j][0];\n                long b = arr[j][1];\n                if(a%i == 0 || b%i == 0) {\n                    count++;\n                }\n            }\n            if(count == arr.length) {\n                System.out.println(i);\n                flag = true;\n                break;\n            }\n\n        }\n        if(flag == false) {\n            System.out.println(-1);\n        }\n    }\n\n    public static void primeFactors(long n, HashSet<Long> set) {\n        // Print the number of 2s that divide n\n        while (n % 2 == 0) {\n            set.add(2l);\n            n /= 2;\n        }\n\n        // n must be odd at this point.  So we can\n        // skip one element (Note i = i +2)\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            // While i divides n, print i and divide n\n            while (n % i == 0) {\n                set.add((long)i);\n                n /= i;\n            }\n        }\n\n        // This condition is to handle the case whien\n        // n is a prime number greater than 2\n        if (n > 2)\n            set.add(n);\n    }\n\n    public static void main(String []args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        long arr[][] = new long[n][2];\n        int i = 0;\n        while ( n > 0) {\n            long a = sc.nextLong();\n            long b = sc.nextLong();\n            arr[i][0] = a;\n            arr[i++][1] = b;\n            n--;\n        }\n        print(arr);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate <typename T1, typename T2>\nbool relax(T1& a, T2 b) {\n  if (a > b) return 1 * (a = b);\n  return 0;\n}\ntemplate <typename T1, typename T2>\nbool strain(T1& a, T2 b) {\n  if (a < b) return 1 * (a = b);\n  return 0;\n}\nvector<ll> get_mul(ll x) {\n  ll d = 2;\n  vector<ll> res;\n  while (d * d <= x) {\n    if (x % d == 0) res.emplace_back(d);\n    while (x % d == 0) x /= d;\n    ++d;\n  }\n  if (x > 1) res.emplace_back(x);\n  return res;\n}\nvoid ans(ll x) {\n  cout << x << '\\n';\n  exit(0);\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<pair<ll, ll>> a(n);\n  auto check = [&](ll prime) -> bool {\n    for (int i = 0; i < n; ++i) {\n      if (!(a[i].first % prime == 0 || a[i].second % prime == 0)) return 0;\n    }\n    return 1;\n  };\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i].first >> a[i].second;\n  }\n  for (const ll& mul : get_mul(a[0].first))\n    if (check(mul)) ans(mul);\n  for (const ll& mul : get_mul(a[0].second))\n    if (check(mul)) ans(mul);\n  cout << \"-1\\n\";\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid my_dbg() { cout << endl; }\ntemplate <typename Arg, typename... Args>\nvoid my_dbg(Arg A, Args... B) {\n  cout << ' ' << A;\n  my_dbg(B...);\n}\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int inf = INT_MAX;\nconst int ninf = INT_MIN;\nconst int mod = 1e9 + 7;\nconst int maxN = 3e5 + 2;\nvoid solve() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pair<int, int>> v(n);\n  for (int i = 0; i < (int)n; i++) {\n    scanf(\"%d\", &v[i].first);\n    scanf(\"%d\", &v[i].second);\n  }\n  set<int> primes;\n  for (int i = 2; i * i <= v[0].first; i++) {\n    if (v[0].first % i == 0) {\n      primes.emplace(i);\n      while (v[0].first % i == 0) v[0].first /= i;\n    }\n  }\n  if (v[0].first > 1) primes.emplace(v[0].first);\n  for (int i = 2; i * i <= v[0].second; i++) {\n    if (v[0].second % i == 0) {\n      primes.emplace(i);\n      while (v[0].second % i == 0) v[0].second /= i;\n    }\n  }\n  if (v[0].second > 1) primes.emplace(v[0].second);\n  map<int, int> ma;\n  for (auto p : primes) ma[p]++;\n  for (int i = 1; i < (int)n; i++) {\n    for (auto p : primes) {\n      if ((v[i].first % p == 0) or (v[i].second % p == 0)) {\n        ma[p]++;\n      }\n    }\n  }\n  int res = -1;\n  for (auto it : ma) {\n    if (it.second == n) {\n      res = it.first;\n      break;\n    }\n  }\n  printf(\"%d\\n\", (int)(res));\n}\nint main() {\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n *created by Kraken on 12-04-2020 at 00:28\n */\n//package com.kraken.cf;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class B1025 {\n    static class Pair {\n        long x, y;\n        Pair (long x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return \"Pair{\" +\n                \"x=\" + x +\n                \", y=\" + y +\n                '}';\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int n = sc.nextInt();\n        Pair[] pairs = new Pair[n];\n        for (int i = 0; i < n; i++) {\n            pairs[i] = new Pair(sc.nextLong(), sc.nextLong());\n        }\n        long a = pairs[0].x, b = pairs[0].y;\n        Set<Long> pa = getPrimeFactors(a);\n        Set<Long> pb = getPrimeFactors(b);\n        pa.addAll(pb);\n        pb.addAll(pa);\n        for (Pair i : pairs) {\n            for (long j : pb) {\n                if (i.x % j != 0 && i.y % j != 0) pa.remove(j);\n            }\n        }\n        if (pa.size() == 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(pa.iterator().next());\n        }\n    }\n\n    private static Set<Long> getPrimeFactors(long b) {\n        Set<Long> pb = new HashSet<>();\n        for (long i = 2; i * i <= b; i++) {\n            if (b % i == 0) {\n                pb.add(i);\n                while (b % i == 0) b /= i;\n            }\n        }\n        if (b != 1 && b != 0) pb.add(b);\n        return pb;\n    }\n\n    static class FastReader {\n\n        BufferedReader br;\n\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nlong long p[maxn], num[maxn], k, a[maxn], b[maxn];\nvoid prime() {\n  for (int i = 2; i < maxn; i++) {\n    if (!num[i]) {\n      for (long long j = 1LL * i * i; j < maxn; j += i) {\n        num[j] = 1;\n      }\n    }\n  }\n  k = 0;\n  for (int i = 2; i < maxn; i++) {\n    if (!num[i]) p[++k] = i;\n  }\n}\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nint main() {\n  int n;\n  long long x, y, a, b, sa, sb;\n  prime();\n  while (scanf(\"%d\", &n) != EOF) {\n    scanf(\"%lld%lld\", &x, &y);\n    num[1] = x * y;\n    if (n == 1) {\n      printf(\"%lld\\n\", x);\n      continue;\n    }\n    for (int i = 1; i <= k && x >= p[i]; i++) {\n      while (x % p[i] == 0) {\n        x /= p[i];\n      }\n    }\n    if (x == 1)\n      a = 2e9 + 10;\n    else\n      a = x;\n    for (int i = 1; i <= k && y >= p[i]; i++) {\n      while (y % p[i] == 0) {\n        y /= p[i];\n      }\n    }\n    if (y == 1)\n      b = 2e9 + 10;\n    else\n      b = y;\n    sa = sb = 1;\n    for (int i = 2; i <= n; i++) {\n      scanf(\"%lld%lld\", &x, &y);\n      num[i] = x * y;\n      if (x % a == 0 || y % a == 0) sa++;\n      if (y % b == 0 || x % b == 0) sb++;\n    }\n    if (sa == n) {\n      printf(\"%lld\\n\", a);\n      continue;\n    } else if (sb == n) {\n      printf(\"%lld\\n\", b);\n      continue;\n    }\n    long long Gcd = num[1];\n    for (int i = 2; i <= n; i++) Gcd = gcd(num[i], Gcd);\n    int ans = 0;\n    for (int i = 1; i <= k; i++) {\n      if (Gcd % p[i] == 0) {\n        ans = p[i];\n        break;\n      }\n    }\n    if (ans == 0 && Gcd != 1)\n      printf(\"%lld\\n\", Gcd);\n    else if (ans == 0 && Gcd == 1)\n      printf(\"-1\\n\");\n    else\n      printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class B {\n\n\tpublic static void main(String[] args) {\n\t\tJS in = new JS();\n\t\tboolean prime[] = new boolean[100000];\n\t\tArrays.fill(prime, true);\n\t\tfor(int i = 2; i < 100000; i++) {\n\t\t\tif(prime[i]) {\n\t\t\t\tfor(int cur = 2*i; cur < 100000; cur += i) prime[cur] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint N = in.nextInt();\n\t\tint a1[] = new int[N];\n\t\tint a2[] = new int[N];\n\t\tint max1 = 0;\n\t\tint max2 = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\ta1[i] = in.nextInt();\n\t\t\ta2[i] = in.nextInt();\n\t\t\tif(Math.max(a1[i], a2[i]) > max1) {\n\t\t\t\tmax1 = Math.max((int)a1[i], (int)a2[i]);\n\t\t\t\tif(max1 == a1[i]) max2 = (int)a2[i];\n\t\t\t\telse max2 = (int)a1[i];\n\t\t\t}\n\t\t}\n\t\tlong res = -1;\n\t\tArrayList<Integer> primes = new ArrayList<Integer>();\n\t\tprimes.add(max1);\n\t\tprimes.add(max2);\n\t\tprimes.addAll(factor(a1[0]));\n\t\tprimes.addAll(factor(a2[0]));\n\t\t\n\t\tfor(Integer ii : primes) {\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tif(a1[i]%ii != 0 && a2[i]%ii != 0) break;\n\t\t\t\tif(i == N-1) {\n\t\t\t\t\tres = ii;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res != -1) break;\n\t\t}\n\t\tSystem.out.println(res);\n\t\t\n\t}\n\t\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a%b);\n\t}\n\n\t//@\n\t// Factor a number n O(sqrt(n))\n\tstatic ArrayList<Integer> factor(int n) {\n\t  ArrayList<Integer> ans = new ArrayList<Integer>();\n\t  for(int x = 2; x * x <= n; x++) {\n\t\t  boolean added = false;\n\t    while(n % x == 0) {\n\t      n /= x;\n\t      if(!added)ans.add(x);\n\t      added = true;\n\t    }\n\t  }\n\t  if(n != 1)\n\t    ans.add(n);\n\t  return ans;\n\t}\n\t\n\tstatic class JS{\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\t\t\n\t\tpublic JS() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\t\t\n\t\tpublic JS(String s) throws FileNotFoundException {\n\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t}\n\t\t\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() {\n\t\t    while(c!='.'&&c!='-'&&(c <'0' || c>'9')) c = nextChar();\n\t\t    boolean neg = c=='-';\n\t\t    if(neg)c=nextChar();\n\t\t    boolean fl = c=='.';\n\t\t    double cur = nextLong();\n\t\t    if(fl) return neg ? -cur/num : cur/num;\n\t\t    if(c == '.') {\n\t\t\tdouble next = nextLong();\n\t\t\treturn neg ? -cur-next/num : cur+next/num;\n\t\t    }\n\t\t    else return neg ? -cur : cur;\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\t\t\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class CF1025_B {\n    public static void main(String[] args) throws Throwable {\n        MyScanner sc = new MyScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        int[] b = new int[n];\n        long g = 0;\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n            b[i] = sc.nextInt();\n            g = gcd(g, 1L * a[i] * b[i]);\n        }\n\n        if (g != 1) {\n            for(int i=0;i<n;i++){\n                long gg=gcd(g,a[i]);\n                if(gg!=1)\n                    g=gg;\n                else\n                    g=gcd(g,b[i]);\n            }\n            pw.println(g);\n        } else\n            pw.println(-1);\n\n        pw.flush();\n        pw.close();\n    }\n\n    static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.lang.*;\nimport java.math.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    void solve() {\n        int n=ni();\n        a=new long[n+1];\n        b=new long[n+1];\n        for(int i=1;i<=n;i++){\n            a[i]=nl(); b[i]=nl();\n        }\n        put(a[1]);\n        put(b[1]);\n        for(long g : hs){\n\n             if(g!=1 && check(g)){\n                 pw.println(g);\n                 return;\n             }\n        }\n        pw.println(\"-1\");\n    }\n    long a[],b[];\n    HashSet<Long> hs=new HashSet<>();\n    void put(long n){\n        for(long i=2;i*i<=n;i++){\n            if(n%i==0){\n                hs.add(i);\n                while(n%i==0) n/=i;\n            }\n        }\n        if(n>1) hs.add(n);\n    }\n    boolean check(long g){\n        for(int i=1;i<a.length;i++){\n            if(a[i]%g!=0 && b[i]%g!=0) return false;\n        }\n        return true;\n    }\n    long gcd(long a,long b){\n        long r;\n        while(b!=0){\n            r=a%b;\n            b=a;\n            a=r;\n        }\n        return a;\n    }\n    long M=(long)1e9+7;\n    InputStream is;\n    PrintWriter pw;\n    String INPUT = \"\";\n    void run() throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        pw = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        pw.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n\n    }\n\n    public static void main(String[] args) throws Exception { new Main().run(); }\n\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte() {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n\n    private String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n) {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n\n    private int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n\n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n\n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    private boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private void tr(Object... o) { if(INPUT.length() > 0)System.out.println(Arrays.deepToString(o)); }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<long long> q;\nlong long ztt[1000], a[200008], b[200008];\nint PP(long long n, int &t) {\n  while (n % 2 == 0) {\n    ztt[t++] = 2;\n    n /= 2;\n  }\n  for (long long i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      ztt[t++] = i;\n      n /= i;\n    }\n  }\n  if (n > 2) ztt[t++] = n;\n  return t;\n}\nint main() {\n  int n;\n  scanf(\"%I64d\", &n);\n  for (int i = (0); i < (n); i++) scanf(\"%I64d%I64d\", &a[i], &b[i]);\n  int t = 0;\n  PP(a[0], t);\n  PP(b[0], t);\n  for (int i = (1); i < (n); i++) {\n    for (int j = (0); j < (t); j++) {\n      if (ztt[j] != -1) {\n        if (a[i] % ztt[j] && b[i] % ztt[j]) ztt[j] = -1;\n      }\n    }\n  }\n  int flag = 0;\n  for (int i = (0); i < (t); i++) {\n    if (ztt[i] != -1) {\n      printf(\"%lld\\n\", ztt[i]);\n      flag = 1;\n      break;\n    }\n  }\n  if (!flag) puts(\"-1\");\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n = int(input())\nar = []\na,b = map(int,input().split())\nnum  = a ** 0.5+2\ni = 2\nwhile i < num:\n    if a % i == 0:\n        ar += [i]\n    while a % i == 0:\n        a //= i\n    i += 1\nnum  = b ** 0.5+2\ni = 2\nwhile i < num:\n    if b % i == 0:\n        ar += [i]\n    while b % i == 0:\n        b //= i\n    i += 1\n\nif a != 1:\n    ar += [a]\nif b != 1:\n    ar += [b]\nfor i in range(1,n):\n    a,b = map(int,input().split())\n    ar2 = []\n    for j in ar:\n        if a % j == 0 or b % j == 0:\n            ar2 += [j]\n    ar = ar2\nif len(ar) == 0:\n    print(-1)\nelse:\n    print(ar[0])\n"
        },
        {
            "language": 1,
            "solution": "import math\ndef gcd(a,b):\n\tif b==0:\n\t\treturn a\n\treturn gcd(b,a%b)\nn=input()\nstore=[]\nif n==1:\n\ta,b = map(int,raw_input().split())\n\t\n\tif max(a,b)>1:\n\t\tprint max(a,b)\n\telse:\n\t\tprint -1\nelse:\n\tfor i in range(n):\n\t\tstore.append(map(int,raw_input().split()))\n\n\tl=[0]*4\n\tl[0]=gcd(store[0][0],store[1][0])\n\tl[1]=gcd(store[0][0],store[1][1])\n\tl[2]=gcd(store[0][1],store[1][0])\n\tl[3]=gcd(store[0][1],store[1][1])\n\tprime=[]\n\n\tfor i in range(4):\n\t\tif l[i]%2==0:\n\t\t\tprime.append(2)\n\t\twhile l[i]%2==0:\n\t\t\tl[i]=l[i]/2\n\n\tfor n1 in l:\n\t#\tprint n1\n\t\tfor i in range(3,int(math.sqrt(n1))+1,2):\n\t\t\tif n1%i==0:\n\t\t\t\tprime.append(i)\n\t\t\twhile n1%i==0:\n\t\t\t\tn1=n1/i\n\t\tif n1>2:\n\t\t\tprime.append(n1)\n\tflag=0\n\t\n\tfor i in prime:\n\t\tif i>1:\n\t\t\tc=0\n\t\t\tfor j in range(2,n):\n\t\t\t\tif store[j][0]%i==0 or store[j][1]%i==0:\n\t\t\t\t\tc+=1\n\t\t\tif c==n-2:\n\t\t\t\tflag=1\n\t\t\t\tprint i\n\t\t\t\tbreak\n\tif flag==0:\n\t\tprint -1"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  set<int> s;\n  int n;\n  cin >> n;\n  n--;\n  int a, b;\n  cin >> a >> b;\n  int sqr = sqrt(a) + 1;\n  for (int i = 2; i < sqr; i++) {\n    if (a % i == 0) {\n      while (a % i == 0) {\n        a /= i;\n      }\n      s.insert(i);\n    }\n  }\n  if (a > 1) {\n    s.insert(a);\n  }\n  sqr = sqrt(b) + 1;\n  for (int i = 2; i < sqr; i++) {\n    if (b % i == 0) {\n      while (b % i == 0) {\n        b /= i;\n      }\n      s.insert(i);\n    }\n  }\n  if (b > 1) {\n    s.insert(b);\n  }\n  for (int i = 0; i < n; i++) {\n    vector<int> v;\n    cin >> a >> b;\n    for (auto it = s.begin(); it != s.end(); it++) {\n      if (a % (*it) != 0 && b % (*it) != 0) {\n        v.push_back(*it);\n      }\n    }\n    for (int i = 0; i < v.size(); i++) {\n      s.erase(v[i]);\n    }\n  }\n  if (!s.size()) {\n    cout << \"-1\";\n  } else {\n    auto it = s.begin();\n    cout << (*it);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long int n;\n  cin >> n;\n  vector<long long int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n  set<long long int> c;\n  for (long long int j = 1; j <= sqrt(a[0]); j++) {\n    if (a[0] % j == 0) {\n      c.insert(j);\n      c.insert(a[0] / j);\n    }\n  }\n  for (long long int j = 1; j <= sqrt(b[0]); j++) {\n    if (b[0] % j == 0) {\n      c.insert(j);\n      c.insert(b[0] / j);\n    }\n  }\n  c.erase(1);\n  vector<long long int> v, vec;\n  for (auto itr = c.begin(); itr != c.end(); ++itr) {\n    vec.push_back(*itr);\n  }\n  for (int i = 0; i < vec.size(); i++) {\n    long long int a = 0;\n    for (long long int j = 2; j <= sqrt(vec[i]); j++) {\n      if (vec[i] % j == 0) {\n        a = 1;\n        break;\n      }\n    }\n    if (a == 0) {\n      v.push_back(vec[i]);\n    }\n  }\n  for (int i = 1; i < n; i++) {\n    vector<long long int> aaa;\n    for (int j = 0; j < v.size(); j++) {\n      if (a[i] % v[j] == 0 || b[i] % v[j] == 0) {\n        aaa.push_back(v[j]);\n      }\n    }\n    if (aaa.size() == 0) {\n      cout << -1;\n      return 0;\n    }\n    v = aaa;\n  }\n  cout << v[0];\n}\n"
        },
        {
            "language": 1,
            "solution": "from fractions import gcd\nimport math\nn=input()\nu,v=map(int ,raw_input().split())\nlcm=u*v/gcd(u,v)\nfor i in range(1,n):\n    u,v=map(int ,raw_input().split())\n    m=u*v/gcd(u,v)\n    lcm=gcd(m,lcm)\nu=gcd(lcm,u)\nv=gcd(lcm,v)\nu=max(u,v)\nif(u==1):\n    print \"-1\"\nelse:\n    v=int(math.sqrt(u))\n    for i in range(2,v+1):\n        if u%i==0:\n            print i\n            exit()\n    print u\n    \n\n            \n            \n        \n        \n        \n        "
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class PB505 {\n\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[n];\n\t\tint minX = Integer.MAX_VALUE;\n\t\tint minXI = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\tif(minX > Math.sqrt(a[i]) + Math.sqrt(b[i])){\n\t\t\t\tminXI = i;\n\t\t\t\tminX = (int)(Math.sqrt(a[i]) + Math.sqrt(b[i]));\n\t\t\t}\n\t\t}\n\t\tint[] primes = new int[]{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,\n\t\t\t\t103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,\n\t\t\t\t199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,\n\t\t\t\t313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,\n\t\t\t\t433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,\n\t\t\t\t563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,\n\t\t\t\t673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,\n\t\t\t\t811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,\n\t\t\t\t941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,\n\t\t\t\t1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,\n\t\t\t\t1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,\n\t\t\t\t1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,\n\t\t\t\t1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,\n\t\t\t\t1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,\n\t\t\t\t1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,\n\t\t\t\t1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,\n\t\t\t\t1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,\n\t\t\t\t1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,\n\t\t\t\t2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,\n\t\t\t\t2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,\n\t\t\t\t2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,\n\t\t\t\t2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,\n\t\t\t\t2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,\n\t\t\t\t2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,\n\t\t\t\t2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,\n\t\t\t\t2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,\n\t\t\t\t3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,\n\t\t\t\t3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,\n\t\t\t\t3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,\n\t\t\t\t3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,\n\t\t\t\t3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,\n\t\t\t\t3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,\n\t\t\t\t3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,\n\t\t\t\t3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,\n\t\t\t\t4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,\n\t\t\t\t4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,\n\t\t\t\t4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,\n\t\t\t\t4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,\n\t\t\t\t4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,\n\t\t\t\t4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,\n\t\t\t\t4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,\n\t\t\t\t4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,\n\t\t\t\t5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,\n\t\t\t\t5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,\n\t\t\t\t5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,\n\t\t\t\t5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,\n\t\t\t\t5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,\n\t\t\t\t5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,\n\t\t\t\t5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,\n\t\t\t\t5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,\n\t\t\t\t6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,\n\t\t\t\t6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,\n\t\t\t\t6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,\n\t\t\t\t6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,\n\t\t\t\t6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,\n\t\t\t\t6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,\n\t\t\t\t6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,\n\t\t\t\t6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,\n\t\t\t\t7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,\n\t\t\t\t7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,\n\t\t\t\t7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,\n\t\t\t\t7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,\n\t\t\t\t7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,\n\t\t\t\t7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919,7927,\n\t\t\t\t7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,8087,\n\t\t\t\t8089,8093,8101,8111,8117,8123,8147,8161,8167,8171,8179,8191,8209,8219,8221,\n\t\t\t\t8231,8233,8237,8243,8263,8269,8273,8287,8291,8293,8297,8311,8317,8329,8353,\n\t\t\t\t8363,8369,8377,8387,8389,8419,8423,8429,8431,8443,8447,8461,8467,8501,8513,\n\t\t\t\t8521,8527,8537,8539,8543,8563,8573,8581,8597,8599,8609,8623,8627,8629,8641,\n\t\t\t\t8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,8719,8731,8737,8741,8747,\n\t\t\t\t8753,8761,8779,8783,8803,8807,8819,8821,8831,8837,8839,8849,8861,8863,8867,\n\t\t\t\t8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,9013,\n\t\t\t\t9029,9041,9043,9049,9059,9067,9091,9103,9109,9127,9133,9137,9151,9157,9161,\n\t\t\t\t9173,9181,9187,9199,9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,\n\t\t\t\t9311,9319,9323,9337,9341,9343,9349,9371,9377,9391,9397,9403,9413,9419,9421,\n\t\t\t\t9431,9433,9437,9439,9461,9463,9467,9473,9479,9491,9497,9511,9521,9533,9539,\n\t\t\t\t9547,9551,9587,9601,9613,9619,9623,9629,9631,9643,9649,9661,9677,9679,9689,\n\t\t\t\t9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,\n\t\t\t\t9829,9833,9839,9851,9857,9859,9871,9883,9887,9901,9907,9923,9929,9931,9941,\n\t\t\t\t9949,9967,9973,10007,10009,10037,10039,10061,10067,10069,10079,10091,10093,\n\t\t\t\t10099,10103,10111,10133,10139,10141,10151,10159,10163,10169,10177,10181,\n\t\t\t\t10193,10211,10223,10243,10247,10253,10259,10267,10271,10273,10289,10301,\n\t\t\t\t10303,10313,10321,10331,10333,10337,10343,10357,10369,10391,10399,10427,\n\t\t\t\t10429,10433,10453,10457,10459,10463,10477,10487,10499,10501,10513,10529,\n\t\t\t\t10531,10559,10567,10589,10597,10601,10607,10613,10627,10631,10639,10651,\n\t\t\t\t10657,10663,10667,10687,10691,10709,10711,10723,10729,10733,10739,10753,\n\t\t\t\t10771,10781,10789,10799,10831,10837,10847,10853,10859,10861,10867,10883,\n\t\t\t\t10889,10891,10903,10909,10937,10939,10949,10957,10973,10979,10987,10993,\n\t\t\t\t11003,11027,11047,11057,11059,11069,11071,11083,11087,11093,11113,11117,\n\t\t\t\t11119,11131,11149,11159,11161,11171,11173,11177,11197,11213,11239,11243,\n\t\t\t\t11251,11257,11261,11273,11279,11287,11299,11311,11317,11321,11329,11351,\n\t\t\t\t11353,11369,11383,11393,11399,11411,11423,11437,11443,11447,11467,11471,\n\t\t\t\t11483,11489,11491,11497,11503,11519,11527,11549,11551,11579,11587,11593,\n\t\t\t\t11597,11617,11621,11633,11657,11677,11681,11689,11699,11701,11717,11719,\n\t\t\t\t11731,11743,11777,11779,11783,11789,11801,11807,11813,11821,11827,11831,\n\t\t\t\t11833,11839,11863,11867,11887,11897,11903,11909,11923,11927,11933,11939,\n\t\t\t\t11941,11953,11959,11969,11971,11981,11987,12007,12011,12037,12041,12043,\n\t\t\t\t12049,12071,12073,12097,12101,12107,12109,12113,12119,12143,12149,12157,\n\t\t\t\t12161,12163,12197,12203,12211,12227,12239,12241,12251,12253,12263,12269,\n\t\t\t\t12277,12281,12289,12301,12323,12329,12343,12347,12373,12377,12379,12391,\n\t\t\t\t12401,12409,12413,12421,12433,12437,12451,12457,12473,12479,12487,12491,\n\t\t\t\t12497,12503,12511,12517,12527,12539,12541,12547,12553,12569,12577,12583,\n\t\t\t\t12589,12601,12611,12613,12619,12637,12641,12647,12653,12659,12671,12689,\n\t\t\t\t12697,12703,12713,12721,12739,12743,12757,12763,12781,12791,12799,12809,\n\t\t\t\t12821,12823,12829,12841,12853,12889,12893,12899,12907,12911,12917,12919,\n\t\t\t\t12923,12941,12953,12959,12967,12973,12979,12983,13001,13003,13007,13009,\n\t\t\t\t13033,13037,13043,13049,13063,13093,13099,13103,13109,13121,13127,13147,\n\t\t\t\t13151,13159,13163,13171,13177,13183,13187,13217,13219,13229,13241,13249,\n\t\t\t\t13259,13267,13291,13297,13309,13313,13327,13331,13337,13339,13367,13381,\n\t\t\t\t13397,13399,13411,13417,13421,13441,13451,13457,13463,13469,13477,13487,\n\t\t\t\t13499,13513,13523,13537,13553,13567,13577,13591,13597,13613,13619,13627,\n\t\t\t\t13633,13649,13669,13679,13681,13687,13691,13693,13697,13709,13711,13721,\n\t\t\t\t13723,13729,13751,13757,13759,13763,13781,13789,13799,13807,13829,13831,\n\t\t\t\t13841,13859,13873,13877,13879,13883,13901,13903,13907,13913,13921,13931,\n\t\t\t\t13933,13963,13967,13997,13999,14009,14011,14029,14033,14051,14057,14071,\n\t\t\t\t14081,14083,14087,14107,14143,14149,14153,14159,14173,14177,14197,14207,\n\t\t\t\t14221,14243,14249,14251,14281,14293,14303,14321,14323,14327,14341,14347,\n\t\t\t\t14369,14387,14389,14401,14407,14411,14419,14423,14431,14437,14447,14449,\n\t\t\t\t14461,14479,14489,14503,14519,14533,14537,14543,14549,14551,14557,14561,\n\t\t\t\t14563,14591,14593,14621,14627,14629,14633,14639,14653,14657,14669,14683,\n\t\t\t\t14699,14713,14717,14723,14731,14737,14741,14747,14753,14759,14767,14771,\n\t\t\t\t14779,14783,14797,14813,14821,14827,14831,14843,14851,14867,14869,14879,\n\t\t\t\t14887,14891,14897,14923,14929,14939,14947,14951,14957,14969,14983,15013,\n\t\t\t\t15017,15031,15053,15061,15073,15077,15083,15091,15101,15107,15121,15131,\n\t\t\t\t15137,15139,15149,15161,15173,15187,15193,15199,15217,15227,15233,15241,\n\t\t\t\t15259,15263,15269,15271,15277,15287,15289,15299,15307,15313,15319,15329,\n\t\t\t\t15331,15349,15359,15361,15373,15377,15383,15391,15401,15413,15427,15439,\n\t\t\t\t15443,15451,15461,15467,15473,15493,15497,15511,15527,15541,15551,15559,\n\t\t\t\t15569,15581,15583,15601,15607,15619,15629,15641,15643,15647,15649,15661,\n\t\t\t\t15667,15671,15679,15683,15727,15731,15733,15737,15739,15749,15761,15767,\n\t\t\t\t15773,15787,15791,15797,15803,15809,15817,15823,15859,15877,15881,15887,\n\t\t\t\t15889,15901,15907,15913,15919,15923,15937,15959,15971,15973,15991,16001,\n\t\t\t\t16007,16033,16057,16061,16063,16067,16069,16073,16087,16091,16097,16103,\n\t\t\t\t16111,16127,16139,16141,16183,16187,16189,16193,16217,16223,16229,16231,\n\t\t\t\t16249,16253,16267,16273,16301,16319,16333,16339,16349,16361,16363,16369,\n\t\t\t\t16381,16411,16417,16421,16427,16433,16447,16451,16453,16477,16481,16487,\n\t\t\t\t16493,16519,16529,16547,16553,16561,16567,16573,16603,16607,16619,16631,\n\t\t\t\t16633,16649,16651,16657,16661,16673,16691,16693,16699,16703,16729,16741,\n\t\t\t\t16747,16759,16763,16787,16811,16823,16829,16831,16843,16871,16879,16883,\n\t\t\t\t16889,16901,16903,16921,16927,16931,16937,16943,16963,16979,16981,16987,\n\t\t\t\t16993,17011,17021,17027,17029,17033,17041,17047,17053,17077,17093,17099,\n\t\t\t\t17107,17117,17123,17137,17159,17167,17183,17189,17191,17203,17207,17209,\n\t\t\t\t17231,17239,17257,17291,17293,17299,17317,17321,17327,17333,17341,17351,\n\t\t\t\t17359,17377,17383,17387,17389,17393,17401,17417,17419,17431,17443,17449,\n\t\t\t\t17467,17471,17477,17483,17489,17491,17497,17509,17519,17539,17551,17569,\n\t\t\t\t17573,17579,17581,17597,17599,17609,17623,17627,17657,17659,17669,17681,\n\t\t\t\t17683,17707,17713,17729,17737,17747,17749,17761,17783,17789,17791,17807,\n\t\t\t\t17827,17837,17839,17851,17863,17881,17891,17903,17909,17911,17921,17923,\n\t\t\t\t17929,17939,17957,17959,17971,17977,17981,17987,17989,18013,18041,18043,\n\t\t\t\t18047,18049,18059,18061,18077,18089,18097,18119,18121,18127,18131,18133,\n\t\t\t\t18143,18149,18169,18181,18191,18199,18211,18217,18223,18229,18233,18251,\n\t\t\t\t18253,18257,18269,18287,18289,18301,18307,18311,18313,18329,18341,18353,\n\t\t\t\t18367,18371,18379,18397,18401,18413,18427,18433,18439,18443,18451,18457,\n\t\t\t\t18461,18481,18493,18503,18517,18521,18523,18539,18541,18553,18583,18587,\n\t\t\t\t18593,18617,18637,18661,18671,18679,18691,18701,18713,18719,18731,18743,\n\t\t\t\t18749,18757,18773,18787,18793,18797,18803,18839,18859,18869,18899,18911,\n\t\t\t\t18913,18917,18919,18947,18959,18973,18979,19001,19009,19013,19031,19037,\n\t\t\t\t19051,19069,19073,19079,19081,19087,19121,19139,19141,19157,19163,19181,\n\t\t\t\t19183,19207,19211,19213,19219,19231,19237,19249,19259,19267,19273,19289,\n\t\t\t\t19301,19309,19319,19333,19373,19379,19381,19387,19391,19403,19417,19421,\n\t\t\t\t19423,19427,19429,19433,19441,19447,19457,19463,19469,19471,19477,19483,\n\t\t\t\t19489,19501,19507,19531,19541,19543,19553,19559,19571,19577,19583,19597,\n\t\t\t\t19603,19609,19661,19681,19687,19697,19699,19709,19717,19727,19739,19751,\n\t\t\t\t19753,19759,19763,19777,19793,19801,19813,19819,19841,19843,19853,19861,\n\t\t\t\t19867,19889,19891,19913,19919,19927,19937,19949,19961,19963,19973,19979,\n\t\t\t\t19991,19993,19997,20011,20021,20023,20029,20047,20051,20063,20071,20089,\n\t\t\t\t20101,20107,20113,20117,20123,20129,20143,20147,20149,20161,20173,20177,\n\t\t\t\t20183,20201,20219,20231,20233,20249,20261,20269,20287,20297,20323,20327,\n\t\t\t\t20333,20341,20347,20353,20357,20359,20369,20389,20393,20399,20407,20411,\n\t\t\t\t20431,20441,20443,20477,20479,20483,20507,20509,20521,20533,20543,20549,\n\t\t\t\t20551,20563,20593,20599,20611,20627,20639,20641,20663,20681,20693,20707,\n\t\t\t\t20717,20719,20731,20743,20747,20749,20753,20759,20771,20773,20789,20807,\n\t\t\t\t20809,20849,20857,20873,20879,20887,20897,20899,20903,20921,20929,20939,\n\t\t\t\t20947,20959,20963,20981,20983,21001,21011,21013,21017,21019,21023,21031,\n\t\t\t\t21059,21061,21067,21089,21101,21107,21121,21139,21143,21149,21157,21163,\n\t\t\t\t21169,21179,21187,21191,21193,21211,21221,21227,21247,21269,21277,21283,\n\t\t\t\t21313,21317,21319,21323,21341,21347,21377,21379,21383,21391,21397,21401,\n\t\t\t\t21407,21419,21433,21467,21481,21487,21491,21493,21499,21503,21517,21521,\n\t\t\t\t21523,21529,21557,21559,21563,21569,21577,21587,21589,21599,21601,21611,\n\t\t\t\t21613,21617,21647,21649,21661,21673,21683,21701,21713,21727,21737,21739,\n\t\t\t\t21751,21757,21767,21773,21787,21799,21803,21817,21821,21839,21841,21851,\n\t\t\t\t21859,21863,21871,21881,21893,21911,21929,21937,21943,21961,21977,21991,\n\t\t\t\t21997,22003,22013,22027,22031,22037,22039,22051,22063,22067,22073,22079,\n\t\t\t\t22091,22093,22109,22111,22123,22129,22133,22147,22153,22157,22159,22171,\n\t\t\t\t22189,22193,22229,22247,22259,22271,22273,22277,22279,22283,22291,22303,\n\t\t\t\t22307,22343,22349,22367,22369,22381,22391,22397,22409,22433,22441,22447,\n\t\t\t\t22453,22469,22481,22483,22501,22511,22531,22541,22543,22549,22567,22571,\n\t\t\t\t22573,22613,22619,22621,22637,22639,22643,22651,22669,22679,22691,22697,\n\t\t\t\t22699,22709,22717,22721,22727,22739,22741,22751,22769,22777,22783,22787,\n\t\t\t\t22807,22811,22817,22853,22859,22861,22871,22877,22901,22907,22921,22937,\n\t\t\t\t22943,22961,22963,22973,22993,23003,23011,23017,23021,23027,23029,23039,\n\t\t\t\t23041,23053,23057,23059,23063,23071,23081,23087,23099,23117,23131,23143,\n\t\t\t\t23159,23167,23173,23189,23197,23201,23203,23209,23227,23251,23269,23279,\n\t\t\t\t23291,23293,23297,23311,23321,23327,23333,23339,23357,23369,23371,23399,\n\t\t\t\t23417,23431,23447,23459,23473,23497,23509,23531,23537,23539,23549,23557,\n\t\t\t\t23561,23563,23567,23581,23593,23599,23603,23609,23623,23627,23629,23633,\n\t\t\t\t23663,23669,23671,23677,23687,23689,23719,23741,23743,23747,23753,23761,\n\t\t\t\t23767,23773,23789,23801,23813,23819,23827,23831,23833,23857,23869,23873,\n\t\t\t\t23879,23887,23893,23899,23909,23911,23917,23929,23957,23971,23977,23981,\n\t\t\t\t23993,24001,24007,24019,24023,24029,24043,24049,24061,24071,24077,24083,\n\t\t\t\t24091,24097,24103,24107,24109,24113,24121,24133,24137,24151,24169,24179,\n\t\t\t\t24181,24197,24203,24223,24229,24239,24247,24251,24281,24317,24329,24337,\n\t\t\t\t24359,24371,24373,24379,24391,24407,24413,24419,24421,24439,24443,24469,\n\t\t\t\t24473,24481,24499,24509,24517,24527,24533,24547,24551,24571,24593,24611,\n\t\t\t\t24623,24631,24659,24671,24677,24683,24691,24697,24709,24733,24749,24763,\n\t\t\t\t24767,24781,24793,24799,24809,24821,24841,24847,24851,24859,24877,24889,\n\t\t\t\t24907,24917,24919,24923,24943,24953,24967,24971,24977,24979,24989,25013,\n\t\t\t\t25031,25033,25037,25057,25073,25087,25097,25111,25117,25121,25127,25147,\n\t\t\t\t25153,25163,25169,25171,25183,25189,25219,25229,25237,25243,25247,25253,\n\t\t\t\t25261,25301,25303,25307,25309,25321,25339,25343,25349,25357,25367,25373,\n\t\t\t\t25391,25409,25411,25423,25439,25447,25453,25457,25463,25469,25471,25523,\n\t\t\t\t25537,25541,25561,25577,25579,25583,25589,25601,25603,25609,25621,25633,\n\t\t\t\t25639,25643,25657,25667,25673,25679,25693,25703,25717,25733,25741,25747,\n\t\t\t\t25759,25763,25771,25793,25799,25801,25819,25841,25847,25849,25867,25873,\n\t\t\t\t25889,25903,25913,25919,25931,25933,25939,25943,25951,25969,25981,25997,\n\t\t\t\t25999,26003,26017,26021,26029,26041,26053,26083,26099,26107,26111,26113,\n\t\t\t\t26119,26141,26153,26161,26171,26177,26183,26189,26203,26209,26227,26237,\n\t\t\t\t26249,26251,26261,26263,26267,26293,26297,26309,26317,26321,26339,26347,\n\t\t\t\t26357,26371,26387,26393,26399,26407,26417,26423,26431,26437,26449,26459,\n\t\t\t\t26479,26489,26497,26501,26513,26539,26557,26561,26573,26591,26597,26627,\n\t\t\t\t26633,26641,26647,26669,26681,26683,26687,26693,26699,26701,26711,26713,\n\t\t\t\t26717,26723,26729,26731,26737,26759,26777,26783,26801,26813,26821,26833,\n\t\t\t\t26839,26849,26861,26863,26879,26881,26891,26893,26903,26921,26927,26947,\n\t\t\t\t26951,26953,26959,26981,26987,26993,27011,27017,27031,27043,27059,27061,\n\t\t\t\t27067,27073,27077,27091,27103,27107,27109,27127,27143,27179,27191,27197,\n\t\t\t\t27211,27239,27241,27253,27259,27271,27277,27281,27283,27299,27329,27337,\n\t\t\t\t27361,27367,27397,27407,27409,27427,27431,27437,27449,27457,27479,27481,\n\t\t\t\t27487,27509,27527,27529,27539,27541,27551,27581,27583,27611,27617,27631,\n\t\t\t\t27647,27653,27673,27689,27691,27697,27701,27733,27737,27739,27743,27749,\n\t\t\t\t27751,27763,27767,27773,27779,27791,27793,27799,27803,27809,27817,27823,\n\t\t\t\t27827,27847,27851,27883,27893,27901,27917,27919,27941,27943,27947,27953,\n\t\t\t\t27961,27967,27983,27997,28001,28019,28027,28031,28051,28057,28069,28081,\n\t\t\t\t28087,28097,28099,28109,28111,28123,28151,28163,28181,28183,28201,28211,\n\t\t\t\t28219,28229,28277,28279,28283,28289,28297,28307,28309,28319,28349,28351,\n\t\t\t\t28387,28393,28403,28409,28411,28429,28433,28439,28447,28463,28477,28493,\n\t\t\t\t28499,28513,28517,28537,28541,28547,28549,28559,28571,28573,28579,28591,\n\t\t\t\t28597,28603,28607,28619,28621,28627,28631,28643,28649,28657,28661,28663,\n\t\t\t\t28669,28687,28697,28703,28711,28723,28729,28751,28753,28759,28771,28789,\n\t\t\t\t28793,28807,28813,28817,28837,28843,28859,28867,28871,28879,28901,28909,\n\t\t\t\t28921,28927,28933,28949,28961,28979,29009,29017,29021,29023,29027,29033,\n\t\t\t\t29059,29063,29077,29101,29123,29129,29131,29137,29147,29153,29167,29173,\n\t\t\t\t29179,29191,29201,29207,29209,29221,29231,29243,29251,29269,29287,29297,\n\t\t\t\t29303,29311,29327,29333,29339,29347,29363,29383,29387,29389,29399,29401,\n\t\t\t\t29411,29423,29429,29437,29443,29453,29473,29483,29501,29527,29531,29537,\n\t\t\t\t29567,29569,29573,29581,29587,29599,29611,29629,29633,29641,29663,29669,\n\t\t\t\t29671,29683,29717,29723,29741,29753,29759,29761,29789,29803,29819,29833,\n\t\t\t\t29837,29851,29863,29867,29873,29879,29881,29917,29921,29927,29947,29959,\n\t\t\t\t29983,29989,30011,30013,30029,30047,30059,30071,30089,30091,30097,30103,\n\t\t\t\t30109,30113,30119,30133,30137,30139,30161,30169,30181,30187,30197,30203,\n\t\t\t\t30211,30223,30241,30253,30259,30269,30271,30293,30307,30313,30319,30323,\n\t\t\t\t30341,30347,30367,30389,30391,30403,30427,30431,30449,30467,30469,30491,\n\t\t\t\t30493,30497,30509,30517,30529,30539,30553,30557,30559,30577,30593,30631,\n\t\t\t\t30637,30643,30649,30661,30671,30677,30689,30697,30703,30707,30713,30727,\n\t\t\t\t30757,30763,30773,30781,30803,30809,30817,30829,30839,30841,30851,30853,\n\t\t\t\t30859,30869,30871,30881,30893,30911,30931,30937,30941,30949,30971,30977,\n\t\t\t\t30983,31013,31019,31033,31039,31051,31063,31069,31079,31081,31091,31121,\n\t\t\t\t31123,31139,31147,31151,31153,31159,31177,31181,31183,31189,31193,31219,\n\t\t\t\t31223,31231,31237,31247,31249,31253,31259,31267,31271,31277,31307,31319,\n\t\t\t\t31321,31327,31333,31337,31357,31379,31387,31391,31393,31397,31469,31477,\n\t\t\t\t31481,31489,31511,31513,31517,31531,31541,31543,31547,31567,31573,31583,\n\t\t\t\t31601,31607,31627,31643,31649,31657,31663,31667,31687,31699,31721,31723,\n\t\t\t\t31727,31729,31741,31751,31769,31771,31793,31799,31817,31847,31849,31859,\n\t\t\t\t31873,31883,31891,31907,31957,31963,31973,31981,31991,32003,32009,32027,\n\t\t\t\t32029,32051,32057,32059,32063,32069,32077,32083,32089,32099,32117,32119,\n\t\t\t\t32141,32143,32159,32173,32183,32189,32191,32203,32213,32233,32237,32251,\n\t\t\t\t32257,32261,32297,32299,32303,32309,32321,32323,32327,32341,32353,32359,\n\t\t\t\t32363,32369,32371,32377,32381,32401,32411,32413,32423,32429,32441,32443,\n\t\t\t\t32467,32479,32491,32497,32503,32507,32531,32533,32537,32561,32563,32569,\n\t\t\t\t32573,32579,32587,32603,32609,32611,32621,32633,32647,32653,32687,32693,\n\t\t\t\t32707,32713,32717,32719,32749,32771,32779,32783,32789,32797,32801,32803,\n\t\t\t\t32831,32833,32839,32843,32869,32887,32909,32911,32917,32933,32939,32941,\n\t\t\t\t32957,32969,32971,32983,32987,32993,32999,33013,33023,33029,33037,33049,\n\t\t\t\t33053,33071,33073,33083,33091,33107,33113,33119,33149,33151,33161,33179,\n\t\t\t\t33181,33191,33199,33203,33211,33223,33247,33287,33289,33301,33311,33317,\n\t\t\t\t33329,33331,33343,33347,33349,33353,33359,33377,33391,33403,33409,33413,\n\t\t\t\t33427,33457,33461,33469,33479,33487,33493,33503,33521,33529,33533,33547,\n\t\t\t\t33563,33569,33577,33581,33587,33589,33599,33601,33613,33617,33619,33623,\n\t\t\t\t33629,33637,33641,33647,33679,33703,33713,33721,33739,33749,33751,33757,\n\t\t\t\t33767,33769,33773,33791,33797,33809,33811,33827,33829,33851,33857,33863,\n\t\t\t\t33871,33889,33893,33911,33923,33931,33937,33941,33961,33967,33997,34019,\n\t\t\t\t34031,34033,34039,34057,34061,34123,34127,34129,34141,34147,34157,34159,\n\t\t\t\t34171,34183,34211,34213,34217,34231,34253,34259,34261,34267,34273,34283,\n\t\t\t\t34297,34301,34303,34313,34319,34327,34337,34351,34361,34367,34369,34381,\n\t\t\t\t34403,34421,34429,34439,34457,34469,34471,34483,34487,34499,34501,34511,\n\t\t\t\t34513,34519,34537,34543,34549,34583,34589,34591,34603,34607,34613,34631,\n\t\t\t\t34649,34651,34667,34673,34679,34687,34693,34703,34721,34729,34739,34747,\n\t\t\t\t34757,34759,34763,34781,34807,34819,34841,34843,34847,34849,34871,34877,\n\t\t\t\t34883,34897,34913,34919,34939,34949,34961,34963,34981,35023,35027,35051,\n\t\t\t\t35053,35059,35069,35081,35083,35089,35099,35107,35111,35117,35129,35141,\n\t\t\t\t35149,35153,35159,35171,35201,35221,35227,35251,35257,35267,35279,35281,\n\t\t\t\t35291,35311,35317,35323,35327,35339,35353,35363,35381,35393,35401,35407,\n\t\t\t\t35419,35423,35437,35447,35449,35461,35491,35507,35509,35521,35527,35531,\n\t\t\t\t35533,35537,35543,35569,35573,35591,35593,35597,35603,35617,35671,35677,\n\t\t\t\t35729,35731,35747,35753,35759,35771,35797,35801,35803,35809,35831,35837,\n\t\t\t\t35839,35851,35863,35869,35879,35897,35899,35911,35923,35933,35951,35963,\n\t\t\t\t35969,35977,35983,35993,35999,36007,36011,36013,36017,36037,36061,36067,\n\t\t\t\t36073,36083,36097,36107,36109,36131,36137,36151,36161,36187,36191,36209,\n\t\t\t\t36217,36229,36241,36251,36263,36269,36277,36293,36299,36307,36313,36319,\n\t\t\t\t36341,36343,36353,36373,36383,36389,36433,36451,36457,36467,36469,36473,\n\t\t\t\t36479,36493,36497,36523,36527,36529,36541,36551,36559,36563,36571,36583,\n\t\t\t\t36587,36599,36607,36629,36637,36643,36653,36671,36677,36683,36691,36697,\n\t\t\t\t36709,36713,36721,36739,36749,36761,36767,36779,36781,36787,36791,36793,\n\t\t\t\t36809,36821,36833,36847,36857,36871,36877,36887,36899,36901,36913,36919,\n\t\t\t\t36923,36929,36931,36943,36947,36973,36979,36997,37003,37013,37019,37021,\n\t\t\t\t37039,37049,37057,37061,37087,37097,37117,37123,37139,37159,37171,37181,\n\t\t\t\t37189,37199,37201,37217,37223,37243,37253,37273,37277,37307,37309,37313,\n\t\t\t\t37321,37337,37339,37357,37361,37363,37369,37379,37397,37409,37423,37441,\n\t\t\t\t37447,37463,37483,37489,37493,37501,37507,37511,37517,37529,37537,37547,\n\t\t\t\t37549,37561,37567,37571,37573,37579,37589,37591,37607,37619,37633,37643,\n\t\t\t\t37649,37657,37663,37691,37693,37699,37717,37747,37781,37783,37799,37811,\n\t\t\t\t37813,37831,37847,37853,37861,37871,37879,37889,37897,37907,37951,37957,\n\t\t\t\t37963,37967,37987,37991,37993,37997,38011,38039,38047,38053,38069,38083,\n\t\t\t\t38113,38119,38149,38153,38167,38177,38183,38189,38197,38201,38219,38231,\n\t\t\t\t38237,38239,38261,38273,38281,38287,38299,38303,38317,38321,38327,38329,\n\t\t\t\t38333,38351,38371,38377,38393,38431,38447,38449,38453,38459,38461,38501,\n\t\t\t\t38543,38557,38561,38567,38569,38593,38603,38609,38611,38629,38639,38651,\n\t\t\t\t38653,38669,38671,38677,38693,38699,38707,38711,38713,38723,38729,38737,\n\t\t\t\t38747,38749,38767,38783,38791,38803,38821,38833,38839,38851,38861,38867,\n\t\t\t\t38873,38891,38903,38917,38921,38923,38933,38953,38959,38971,38977,38993,\n\t\t\t\t39019,39023,39041,39043,39047,39079,39089,39097,39103,39107,39113,39119,\n\t\t\t\t39133,39139,39157,39161,39163,39181,39191,39199,39209,39217,39227,39229,\n\t\t\t\t39233,39239,39241,39251,39293,39301,39313,39317,39323,39341,39343,39359,\n\t\t\t\t39367,39371,39373,39383,39397,39409,39419,39439,39443,39451,39461,39499,\n\t\t\t\t39503,39509,39511,39521,39541,39551,39563,39569,39581,39607,39619,39623,\n\t\t\t\t39631,39659,39667,39671,39679,39703,39709,39719,39727,39733,39749,39761,\n\t\t\t\t39769,39779,39791,39799,39821,39827,39829,39839,39841,39847,39857,39863,\n\t\t\t\t39869,39877,39883,39887,39901,39929,39937,39953,39971,39979,39983,39989,\n\t\t\t\t40009,40013,40031,40037,40039,40063,40087,40093,40099,40111,40123,40127,\n\t\t\t\t40129,40151,40153,40163,40169,40177,40189,40193,40213,40231,40237,40241,\n\t\t\t\t40253,40277,40283,40289,40343,40351,40357,40361,40387,40423,40427,40429,\n\t\t\t\t40433,40459,40471,40483,40487,40493,40499,40507,40519,40529,40531,40543,\n\t\t\t\t40559,40577,40583,40591,40597,40609,40627,40637,40639,40693,40697,40699,\n\t\t\t\t40709,40739,40751,40759,40763,40771,40787,40801,40813,40819,40823,40829,\n\t\t\t\t40841,40847,40849,40853,40867,40879,40883,40897,40903,40927,40933,40939,\n\t\t\t\t40949,40961,40973,40993,41011,41017,41023,41039,41047,41051,41057,41077,\n\t\t\t\t41081,41113,41117,41131,41141,41143,41149,41161,41177,41179,41183,41189,\n\t\t\t\t41201,41203,41213,41221,41227,41231,41233,41243,41257,41263,41269,41281,\n\t\t\t\t41299,41333,41341,41351,41357,41381,41387,41389,41399,41411,41413,41443,\n\t\t\t\t41453,41467,41479,41491,41507,41513,41519,41521,41539,41543,41549,41579,\n\t\t\t\t41593,41597,41603,41609,41611,41617,41621,41627,41641,41647,41651,41659,\n\t\t\t\t41669,41681,41687,41719,41729,41737,41759,41761,41771,41777,41801,41809,\n\t\t\t\t41813,41843,41849,41851,41863,41879,41887,41893,41897,41903,41911,41927,\n\t\t\t\t41941,41947,41953,41957,41959,41969,41981,41983,41999,42013,42017,42019,\n\t\t\t\t42023,42043,42061,42071,42073,42083,42089,42101,42131,42139,42157,42169,\n\t\t\t\t42179,42181,42187,42193,42197,42209,42221,42223,42227,42239,42257,42281,\n\t\t\t\t42283,42293,42299,42307,42323,42331,42337,42349,42359,42373,42379,42391,\n\t\t\t\t42397,42403,42407,42409,42433,42437,42443,42451,42457,42461,42463,42467,\n\t\t\t\t42473,42487,42491,42499,42509,42533,42557,42569,42571,42577,42589,42611,\n\t\t\t\t42641,42643,42649,42667,42677,42683,42689,42697,42701,42703,42709,42719,\n\t\t\t\t42727,42737,42743,42751,42767,42773,42787,42793,42797,42821,42829,42839,\n\t\t\t\t42841,42853,42859,42863,42899,42901,42923,42929,42937,42943,42953,42961,\n\t\t\t\t42967,42979,42989,43003,43013,43019,43037,43049,43051,43063,43067,43093,\n\t\t\t\t43103,43117,43133,43151,43159,43177,43189,43201,43207,43223,43237,43261,\n\t\t\t\t43271,43283,43291,43313,43319,43321,43331,43391,43397,43399,43403,43411,\n\t\t\t\t43427,43441,43451,43457,43481,43487,43499,43517,43541,43543,43573,43577,\n\t\t\t\t43579,43591,43597,43607,43609,43613,43627,43633,43649,43651,43661,43669,\n\t\t\t\t43691,43711,43717,43721,43753,43759,43777,43781,43783,43787,43789,43793,\n\t\t\t\t43801,43853,43867,43889,43891,43913,43933,43943,43951,43961,43963,43969,\n\t\t\t\t43973,43987,43991,43997,44017,44021,44027,44029,44041,44053,44059,44071,\n\t\t\t\t44087,44089,44101,44111,44119,44123,44129,44131,44159,44171,44179,44189,\n\t\t\t\t44201,44203,44207,44221,44249,44257,44263,44267,44269,44273,44279,44281,\n\t\t\t\t44293,44351,44357,44371,44381,44383,44389,44417,44449,44453,44483,44491,\n\t\t\t\t44497,44501,44507,44519,44531,44533,44537,44543,44549,44563,44579,44587,\n\t\t\t\t44617,44621,44623,44633,44641,44647,44651,44657,44683,44687,44699,44701,\n\t\t\t\t44711};\n\t\t\n\t\tList<Integer> divisorsA = divisors(a[minXI], primes);\n\t\tList<Integer> divisorsB = divisors(b[minXI], primes);\n\t\tint ans = -1;\n\t\tboolean bo;\n\t\tfor(int m : divisorsA){\n\t\t\tbo = true;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(a[i] % m != 0 && b[i] % m != 0){\n\t\t\t\t\tbo = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bo){\n\t\t\t\tans = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ans != -1){\n\t\t\tSystem.out.println(ans);\n\t\t}else{\n\t\t\tfor(int m : divisorsB){\n\t\t\t\tbo = true;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(a[i] % m != 0 && b[i] % m != 0){\n\t\t\t\t\t\tbo = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bo){\n\t\t\t\t\tans = m;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static List<Integer> divisors(int n, int[] primes){\n\t\tList<Integer> ans = new LinkedList<Integer>();\n\t\tfor(int i : primes){\n\t\t\tif(n % i == 0){\n\t\t\t\tans.add(i);\n\t\t\t\twhile(n % i == 0){\n\t\t\t\t\tn /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(n > 1)\n\t\t\tans.add(n);\n\t\treturn ans;\n\t}\n\t\n}\n"
        },
        {
            "language": 3,
            "solution": "# import sys\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\nprimes = set()\nar, br = [0] * 150001, [0] * 150001\n\ndef gen(num):\n\n\ti = 2\n\twhile i * i <= num:\n\t\tif num % i == 0:\n\t\t\twhile num % i == 0:\n\t\t\t\tnum //= i\n\n\t\t\tprimes.add(i)\n\n\t\ti += 1\n\tif num > 1:\n\t\tprimes.add(num)\n\n\nn = int(input())\n\nfor i in range(1, n + 1):\n\tar[i], br[i] = map(int, input().split())\n\ngen(ar[1])\ngen(br[1])\n\nfor p in primes:\n\tok = 1\n\n\tfor i in range(2, n + 1):\n\t\tif ar[i] % p != 0 and br[i] % p != 0:\n\t\t\tok = 0\n\t\t\tbreak\n\n\tif ok:\n\t\tprint(p)\n\t\texit(0)\n\nprint(-1) \n\n\n"
        },
        {
            "language": 3,
            "solution": "import math\n\nn = int(input()) \nmcd = 0 #la variable donde almacenaremos el m\u00e1ximo com\u00fan divisor\na = {}\nb = {}\n#encontraremos el mcd entre las multiplicaciones de los enteros de cada par\nfor i in range(n):\n    a[i], b[i] = map(int, input().split())\n    mcd = math.gcd(mcd, a[i]*b[i])\n#encontraremos el mcd entre los n\u00fameros de cada par y el mcd hallado anteriormente\nfor i in range(n):\n    ret = math.gcd(mcd, a[i])\n    if ret > 1:\n        mcd = ret\n    else:\n        mcd = math.gcd(mcd, b[i])\n    if mcd == 1:\n        break\n#si el mcd=1 no encontramos ning\u00fan n\u00famero que satisfaga las condiciones del WCD\nif mcd == 1:\n    print(-1)\nelse:\n    print(mcd)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 150005;\nstruct node {\n  long long x;\n  long long y;\n} a[N];\nlong long prime[N], p1[N], p2[N];\nlong long n, m1, m2;\nvoid divide1(int n) {\n  m1 = 0;\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      p1[++m1] = i;\n      while (n % i == 0) n /= i;\n    }\n  }\n  if (n > 1) p1[++m1] = n;\n}\nvoid divide2(int n) {\n  m2 = 0;\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      p2[++m2] = i;\n      while (n % i == 0) n /= i;\n    }\n  }\n  if (n > 1) p2[++m2] = n;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d %d\", &a[i].x, &a[i].y);\n  divide1(a[1].x);\n  divide2(a[1].y);\n  long long j = 0;\n  int x = 0;\n  for (int i = 1; i <= m1; i++) {\n    prime[x] = p1[i], x++;\n  }\n  for (int i = 1; i <= m2; i++) {\n    prime[x] = p2[i], x++;\n  }\n  long long ans = 0;\n  int flag = 0;\n  for (int i = 0; i < x; i++) {\n    for (j = 2; j <= n; j++) {\n      if (a[j].x % prime[i] == 0 || a[j].y % prime[i] == 0) {\n        continue;\n      } else\n        break;\n    }\n    if (j > n) {\n      ans = prime[i];\n      flag = 1;\n      break;\n    }\n  }\n  if (flag)\n    cout << ans << endl;\n  else\n    cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "def primFac(num):\n  stop=int(num**0.5+1);div=2;ret=set()\n  while stop>div>1:\n    while num%div==0:\n      num/=div;ret.add(div)\n    div+=1\n  if num>1:\n    return ret|set([num])\n  return ret\n\nn=input(); nums=[-1]*(n)\nfor i in xrange(n):\n  a,b=map(int,raw_input().split())\n  nums[i]=[(a,b),(b,a)][a>b]\nnumSet=list(set(nums))\na,b=numSet[0];ans=set((a,b))\nans=primFac(a)|primFac(b)\n\nfor i in xrange(1,len(numSet)):\n  if ans and len(numSet)>1:\n    a,b=numSet[i]\n    for k in list(ans):\n      if a%k!=0 and b%k!=0:\n        ans.remove(k)\n  else:\n    break\n\nif ans:\n  print ans.pop()\nelse:\n  print -1\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ninline int read() {\n  int a = 0;\n  char c = getchar();\n  for (; c < 48 || c > 57; c = getchar())\n    ;\n  for (; c > 47 && c < 58; a = a * 10 + c - 48, c = getchar())\n    ;\n  return a;\n}\nint n, a, b, p[20], fl[20], t[20], k;\nint main() {\n  int f;\n  n = read();\n  a = read();\n  b = read();\n  for (int i = 2; i * i <= a; i++) {\n    f = 0;\n    for (; a % i == 0;) a /= i, f = 1;\n    if (f) p[++k] = i;\n  }\n  if (a > 1) p[++k] = a;\n  for (int i = 2; i * i <= b; i++) {\n    f = 0;\n    for (; b % i == 0;) b /= i, f = 1;\n    if (f) p[++k] = i;\n  }\n  if (b > 1) p[++k] = b;\n  for (; --n;) {\n    a = read();\n    b = read();\n    for (int j = 1; j <= k; j++)\n      if (a % p[j] && b % p[j]) fl[j] = 1;\n  }\n  for (int i = 1; i <= k; i++)\n    if (!fl[i]) return 0 * printf(\"%d\", p[i]);\n  return 0 * puts(\"-1\");\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class zizo {\n\tpublic static void main(String[]args) {\n\t\tScanner zizo = new Scanner(System.in);\n\t\tPrintWriter wr = new PrintWriter(System.out);\n\t\t\n\t\tint n = zizo.nextInt();\n\t\tset = new HashSet<>();\n\t\tint[]a = new int[n];\n\t\tint[]b = new int[n];\n\t\tfor(int i = 0;i < n; i++) {\n\t\t\ta[i] = zizo.nextInt();\n\t\t\tb[i] = zizo.nextInt();\n\t\t}\n\t\tprimeFactors(a[0]);\n\t\tprimeFactors(b[0]);\n\t\t\n\t\tfor(int x : set) {\n\t\t\tint i;\n\t\t\tfor(i = 1;i < n; i++)\n\t\t\t\tif(a[i] % x != 0 && b[i] % x != 0)\n\t\t\t\t\tbreak;\n\t\t\tif(i == n) {\n\t\t\t\tSystem.out.println(x);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t\twr.close();\n\t}\n\tstatic HashSet<Integer>set;\n\tstatic void primeFactors(int N)\n\t{\n\t\t\n\t\tfor(int i = 2;1l * i * i <= N; i++) {\n\t\t\tif(N % i == 0) {\n\t\t\t\tset.add(i);\n\t\t\t\twhile(N % i == 0)N /= i;\n\t\t\t}\n\t\t}\n\t\tif(N != 1 && N != 0)\n\t\t\tset.add(N);\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\nimport sys\nfrom math import gcd, sqrt\n\ndef rint():\n    return map(int, sys.stdin.readline().split())\n\ndef find_prime_factors(num):\n    d = set()\n    i = 2\n    while  i < int(sqrt(num)+1):\n        while num%i == 0:\n            d.add(i)\n            num = num//i\n        i += 1\n    if num > 1:\n        d.add(num)\n    return d\n\nn = int(input())\n\na, b = rint()\n\npf = find_prime_factors(a).union(find_prime_factors(b))\n\nfor i in range(n-1):\n    a, b = rint()\n    pftmp = pf.copy()\n    for f in pf:\n        if a%f and b%f:\n            pftmp.remove(f)\n    pf = pftmp.copy()\n\nif len(pf):\n    print(pf.pop())\nelse:\n    print(-1)\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = (long long)(2 * 1e5 + 10);\nlong long mult(long long a, long long b, long long p) {\n  return ((a % p) * (b % p)) % p;\n}\nlong long add(long long a, long long b, long long p) {\n  return (a % p + b % p) % p;\n}\nlong long fpow(long long n, long long k, long long p) {\n  long long r = 1;\n  for (; k; k >>= 1) {\n    if (k & 1) r = r * n % p;\n    n = n * n % p;\n  }\n  return r;\n}\nlong long gcd(long long a, long long b) {\n  if (a == 0) return b;\n  return gcd(b % a, a);\n}\nlong long max(long long a, long long b) {\n  if (a > b)\n    return a;\n  else\n    return b;\n}\nlong long min(long long a, long long b) {\n  if (a < b)\n    return a;\n  else\n    return b;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL);\n  long long n;\n  cin >> n;\n  vector<pair<long long, long long>> v;\n  for (long long i = 0; i < n; i++) {\n    long long a, b;\n    cin >> a >> b;\n    v.push_back({a, b});\n  }\n  long long count = 0;\n  set<long long> s;\n  long long nn = v[0].first;\n  while (!(nn % 2)) {\n    nn >>= 1;\n    count++;\n  }\n  if (count) {\n    s.insert(2);\n  }\n  for (long long i = 3; i <= sqrt(nn); i += 2) {\n    count = 0;\n    while (nn % i == 0) {\n      count++;\n      nn = nn / i;\n    }\n    if (count) {\n      s.insert(i);\n    }\n  }\n  if (nn > 2) {\n    s.insert(nn);\n  }\n  count = 0;\n  nn = v[0].second;\n  while (!(nn % 2)) {\n    nn >>= 1;\n    count++;\n  }\n  if (count) {\n    s.insert(2);\n  }\n  for (long long i = 3; i <= sqrt(nn); i += 2) {\n    count = 0;\n    while (nn % i == 0) {\n      count++;\n      nn = nn / i;\n    }\n    if (count) {\n      s.insert(i);\n    }\n  }\n  if (nn > 2) {\n    s.insert(nn);\n  }\n  for (auto it = s.begin(); it != s.end(); it++) {\n    long long num = *it;\n    bool flag = true;\n    for (long long i = 1; i <= n - 1; i++) {\n      long long n1 = v[i].first;\n      long long n2 = v[i].second;\n      if (n1 % num != 0 and n2 % num != 0) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) {\n      cout << num;\n      return 0;\n    }\n  }\n  cout << -1;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nlong long n, ff[150010], bb[150010];\nvector<long long> dd[5];\nvoid INIT_listd(long long x, long long pos) {\n  for (long long i = 1; i * i <= x; i++) {\n    if (x % i == 0) {\n      dd[pos].push_back(i);\n      long long p = x / i;\n      if (p != i) dd[pos].push_back(p);\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d%d\", &ff[i], &bb[i]);\n  if (n == 1) {\n    cout << ff[0] << endl;\n    return 0;\n  }\n  INIT_listd(ff[0], 0);\n  INIT_listd(bb[0], 1);\n  INIT_listd(ff[1], 2);\n  INIT_listd(bb[1], 3);\n  for (int i = 0; i < 4; i++) sort(dd[i].begin(), dd[i].end());\n  vector<long long> dd2;\n  for (int i = 0; i < 2; i++) {\n    for (long long k = 2; k <= 3; k++) {\n      for (int j = 0; j < dd[i].size(); j++) {\n        long long p = upper_bound(dd[k].begin(), dd[k].end(), dd[i][j]) -\n                      lower_bound(dd[k].begin(), dd[k].end(), dd[i][j]);\n        if (p > 0) dd2.push_back(dd[i][j]);\n      }\n    }\n  }\n  sort(dd2.begin(), dd2.end());\n  vector<long long> tmp = dd2;\n  dd2.clear();\n  long long pp = tmp.size();\n  for (int i = 0; i < pp - 1; i++)\n    if (tmp[i] != tmp[i + 1]) dd2.push_back(tmp[i]);\n  if (pp > 0) dd2.push_back(tmp[pp - 1]);\n  bool chk[150010];\n  tmp.clear();\n  if (dd2.size() > 0) tmp.push_back(dd2[0]);\n  for (int i = 1; i < dd2.size(); i++) {\n    bool can = true;\n    for (int j = 0; j < i; j++) {\n      if (dd2[i] % dd2[j] == 0 && dd2[j] != 1) {\n        can = false;\n        break;\n      }\n    }\n    if (can) tmp.push_back(dd2[i]);\n  }\n  dd2 = tmp;\n  long long dsz2 = dd2.size();\n  for (long long i = 2; i < n; i++) {\n    for (int j = 0; j < dsz2; j++) {\n      if (chk[j]) continue;\n      if (ff[i] % dd2[j] != 0 && bb[i] % dd2[j] != 0) chk[j] = true;\n    }\n  }\n  for (int i = 0; i < dd2.size(); i++) {\n    if (!chk[i] && (dd2[i] != 1)) {\n      cout << dd2[i] << endl;\n      return 0;\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def f(n):\n    d = 2\n    A = []\n    while d * d <= n:\n        if n % d == 0:\n            A.append(d)\n            n = n // d\n            \n        else:\n            d += 1\n    if n != 1:\n        A.append(n)\n    return A\n\nn = int(input())\na, b = map(int, input().split())\nA = set(f(a))\nB = set(f(b))\nans = A.union(B)\nans = list(ans)\nfor i in range(1, n):\n    a, b = map(int, input().split())\n    upd = ans.copy()\n    for j in ans:\n        if a % j != 0 and b % j != 0:\n            upd.remove(j)\n    ans = upd.copy()\n\nif len(ans) == 0:\n    print(-1)\nelse:\n    print(ans[0])"
        },
        {
            "language": 3,
            "solution": "import math\ndef gcd(a,b):\n    if(b==0):\n        return a\n    else:\n        return gcd(b,a%b)\nn=int(input())\na,b=map(int,input().split())\nfor i in range(n-1):\n    x,y=map(int,input().split())\n    x=x*y\n    a=gcd(a,x)\n    b=gcd(b,x)\nif(a==1 and b==1):\n    print(-1)\n    exit()\nelse:\n    i=2\n    while((i*i<=a) or (i*i<=b)):\n        if(a%i==0):\n            a=i\n            break\n        if(b%i==0):\n            b=i\n            break\n        i+=1\nif(a==1):\n    print(b)\nelse:\n    print(a)"
        },
        {
            "language": 3,
            "solution": "n=int(input())\n\nab=[None]*n\nfor i in range(n):\n    ab[i]=tuple(map(int,input().split()))\n\n\nimport math\n\ndef div(n):\n    LIST=[]\n    while n!=1:\n        check=0\n        for i in range(2,1+math.ceil(math.sqrt(n))):\n            if n%i==0:\n                LIST.append(i)\n                n=n//i\n                check=1\n                break\n\n        if check==0:\n            LIST.append(n)\n            break\n\n    return LIST\n\nANS=list(set(div(ab[0][0])+div(ab[0][1])))\n\n#print(ANS)\n\nfor i in range(1,n):\n    ANSX=[]\n    for j in ANS:\n        if ab[i][0]%j==0 or ab[i][1]%j==0:\n            ANSX.append(j)\n\n    ANS=ANSX\n\nif ANS==[]:\n    print(-1)\nelse:\n    print(ANS[0])\n\n\n\n\n    \n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##########################################################\nfrom collections import Counter\n# c=sorted((i,int(val))for i,val in enumerate(input().split()))\nimport heapq\n# c=sorted((i,int(val))for i,val in enumerate(input().split()))\n# n = int(input())\n# ls = list(map(int, input().split()))\n# n, k = map(int, input().split())\n# n =int(input())\n#arr=[(i,x) for i,x in enum]\n#arr.sort(key=lambda x:x[0])\n#print(arr)\nimport math\n# e=list(map(int, input().split()))\nfrom collections import Counter\n#print(\"\\n\".join(ls))\n#print(os.path.commonprefix(ls[0:2]))\n#n=int(input())\nfrom bisect import  bisect_right\n#d=sorted(d,key=lambda x:(len(d[x]),-x))  d=dictionary     d={x:set() for x in arr}\n#n=int(input())\n#n,m,k= map(int, input().split())\nimport heapq\n#for _ in range(int(input())):\n#n,k=map(int, input().split())\n\ndef prime_factors(x):\n    s=set()\n    n=x\n    i=2\n    while i*i<=n:\n        if n%i==0:\n            while n%i==0:\n                n//=i\n            s.add(i)\n        i+=1\n    if n>1:\n        s.add(n)\n    return s\n\ndef check(ele):\n    for item in ls:\n        if item[0]%ele!=0 and item[1]%ele!=0:\n            return False\n    return True\n\n\nn=int(input())\nf=0\nans=set()\nls=[]\nfor i in range(n):\n    a,b=map(int, input().split())\n    ls.append((a,b))\ns=prime_factors(ls[0][0]).union(prime_factors(ls[0][1]))\nfor ele in s:\n    if check(ele):\n        print(ele)\n        exit()\nprint(-1)"
        },
        {
            "language": 4,
            "solution": "import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n    static class pair{\n        int a;\n        int b;\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n=scanner.nextInt();\n        pair[] pairs=new pair[n];\n        for (int i=0;i<n;i++){\n            pairs[i]=new pair();\n            pairs[i].a=scanner.nextInt();\n            pairs[i].b=scanner.nextInt();\n        }\n        HashSet<Integer> primes=new HashSet<>();\n        putPrimes(pairs[0].a,primes);\n        putPrimes(pairs[0].b,primes);\n        int ans=-1;\n        for (int x:primes){\n            int count=0;\n            for (int i=0;i<n;i++){\n                if (pairs[i].a%x==0||pairs[i].b%x==0){\n                    count++;\n                }\n            }\n            if (count==n){\n                ans=x;\n                break;\n            }\n        }\n        System.out.println(ans);\n    }\n    public static void putPrimes(int n1, HashSet<Integer> primes) {\n            while (n1%2 == 0)\n            {\n                primes.add(2);\n                n1 = n1/2;\n            }\n            for (int i = 3; i*i <= n1; i = i+2)\n            {\n                while (n1%i == 0)\n                {\n                    primes.add(i);\n                    n1 = n1/i;\n                }\n            }\n            if (n1 > 2)\n                primes.add(n1);\n        }\n    }\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tstatic HashSet<Integer> set;\n\n\tpublic static void main(String[] args) { \n        FastScanner in = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = in.nextInt();\n        set = new HashSet<>();\n        Pair a[] = new Pair[n];         \n        for(int i=0;i<n;i++){\n        \ta[i] = new Pair(in.nextInt(), in.nextInt());\n        }\n        primeFactorisation(a[0].first());\n        primeFactorisation(a[0].second());\n        int ans = -1;\n        for(int factor : set){\n        \tboolean valid = true;\n        \tfor(int i=0;i<n;i++){\n        \t\tif(a[i].first()%factor!=0&&a[i].second()%factor!=0){\n        \t\t\tvalid = false; break;\n        \t\t}\n        \t}\n        \tif(valid){\n        \t\tans = factor; break;\n        \t}\n        }\n        out.println(ans);\n        out.flush();\n\t}\n\n\tstatic void primeFactorisation(int m){\n\t\tfor(int i=2;i*i<=m;i++){\n        \tif(isPrime(i)&&(m%i)==0){\n        \t\tset.add(i);\n        \t\twhile(m%i==0) m /= i;\n        \t}\n        }\n        if(m>1) set.add(m);\n\t}\n\n\tstatic boolean isPrime(int n){\n\t\tfor(int i=2;i<n;i++){\n\t\t\tif(n%i==0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\t\n\tstatic class Pair{\n\t\tint x, y;\n\t\tPair(int a, int b){ x = a; y = b; }\n\t\tint first(){ return x; }\n\t\tint second(){ return y; }\n\t}\n\n\tstatic int gcd(int a, int b){\n\t\tif(b==0) return a;\n\t\telse return gcd(b,a%b);\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\t\n\t\tString next() {\n\t\t\twhile(!st.hasMoreTokens())\n\t\t\t\ttry { st = new StringTokenizer(br.readLine()); }\n\t\t\t\tcatch(IOException e) {}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tString nextLine(){\n\t\t\ttry{ return br.readLine(); } \n\t\t\tcatch(IOException e) { } return \"\";\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n\n\tstatic final Random random = new Random();\n\n\tstatic void ruffleSort(int[] a){\n\t\tint n = a.length;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint j = random.nextInt(n), temp = a[j];\n\t\t\ta[j] = a[i]; a[i] = temp;\n\t\t}\n\t\tArrays.sort(a); \t\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\t\nn = int(input())\na = []\nb = []\n\nfor i in range(n):\n    A, B = map(int, input().split())\n    a.append(A)\n    b.append(B)\n\nans = -1\nx = 0\n\nfor i in range(n):\n    x = gcd(x, a[i] * b[i])\n\nif x != 1:\n    for i in range(n):\n        if gcd(x, a[i]) > 1:\n            x = gcd(x, a[i])\n            ans = gcd(x, a[i])\n        else:\n            x = gcd(x, b[i])\n            ans = gcd(x, b[i])\n\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nunordered_set<int> prime;\nvector<int> d;\nvoid factorize(int x) {\n  if (x % 2 == 0) {\n    prime.insert(2);\n    while (x % 2 == 0) x /= 2;\n  }\n  for (int i = 3; i <= sqrt(x); i += 2)\n    if (x % i == 0) {\n      prime.insert(i);\n      while (x % i == 0) x /= i;\n    }\n  if (x > 1) prime.insert(x);\n}\nint main() {\n  cin >> n;\n  int x, y;\n  cin >> x >> y;\n  prime.clear();\n  factorize(x);\n  factorize(y);\n  for (int i = 0; i < n - 1; i++) {\n    cin >> x >> y;\n    if (!prime.empty()) {\n      d.clear();\n      for (auto p : prime) {\n        if (x % p != 0 && y % p != 0) d.push_back(p);\n      }\n      for (auto de : d) prime.erase(de);\n    }\n  }\n  if (prime.empty())\n    cout << -1 << endl;\n  else\n    cout << *prime.begin() << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 105;\nlong long x[maxn], ans, a[200005], b[200005];\nqueue<long long> aria;\nlong long min(long long a, long long b) {\n  if (a < b)\n    return a;\n  else\n    return b;\n}\nlong long multi(long long a, long long b, long long p) {\n  long long ans = 0;\n  while (b) {\n    if (b & 1LL) ans = (ans + a) % p;\n    a = (a + a) % p;\n    b >>= 1;\n  }\n  return ans;\n}\nlong long qpow(long long a, long long b, long long p) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1LL) ans = multi(ans, a, p);\n    a = multi(a, a, p);\n    b >>= 1;\n  }\n  return ans;\n}\nbool MR(long long n) {\n  if (n == 2) return true;\n  int s = 20, i, t = 0;\n  long long u = n - 1;\n  while (!(u & 1)) {\n    t++;\n    u >>= 1;\n  }\n  while (s--) {\n    long long a = rand() % (n - 2) + 2;\n    x[0] = qpow(a, u, n);\n    for (i = 1; i <= t; i++) {\n      x[i] = multi(x[i - 1], x[i - 1], n);\n      if (x[i] == 1 && x[i - 1] != 1 && x[i - 1] != n - 1) return false;\n    }\n    if (x[t] != 1) return false;\n  }\n  return true;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0)\n    return a;\n  else\n    return gcd(b, a % b);\n}\nlong long Pollard_Rho(long long n, int c) {\n  long long i = 1, k = 2, x = rand() % (n - 1) + 1, y = x;\n  while (1) {\n    i++;\n    x = (multi(x, x, n) + c) % n;\n    long long p = gcd((y - x + n) % n, n);\n    if (p != 1 && p != n) return p;\n    if (y == x) return n;\n    if (i == k) {\n      y = x;\n      k <<= 1;\n    }\n  }\n}\nvoid find(long long n, int c) {\n  if (n == 1) return;\n  if (MR(n)) {\n    aria.push(n);\n    return;\n  }\n  long long p = n, k = c;\n  while (p >= n) {\n    p = Pollard_Rho(p, c--);\n  }\n  find(p, k);\n  find(n / p, k);\n}\nint main() {\n  int t;\n  cin >> t;\n  vector<long long> v;\n  for (int i = 0; i < t; i++) cin >> a[i] >> b[i];\n  long long tmp1 = a[0];\n  long long tmp2 = b[0];\n  find(tmp1, 107);\n  v.push_back(aria.front());\n  aria.pop();\n  while (!aria.empty()) {\n    v.push_back(aria.front());\n    aria.pop();\n  }\n  aria = queue<long long>();\n  find(tmp2, 107);\n  v.push_back(aria.front());\n  aria.pop();\n  while (!aria.empty()) {\n    v.push_back(aria.front());\n    aria.pop();\n  }\n  for (int i = 0; i < v.size(); i++) {\n    int flag = 0;\n    for (int j = 0; j < t; j++) {\n      if (a[j] % v[i] == 0 || b[j] % v[i] == 0) flag++;\n    }\n    if (flag == t) {\n      cout << v[i];\n      return 0;\n    }\n  }\n  cout << -1;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.Set;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n\n            List<p> ps = new ArrayList<>();\n\n            for (int i = 0; i < n; i++) {\n                ps.add(new p(in.nextInt(), in.nextInt()));\n            }\n\n            //ps.sort((p1, p2) -> );\n\n            List<Integer> fac = new ArrayList<>();\n\n            p fp = ps.get(0);\n\n            Set<Integer> s = new HashSet<>();\n\n            for (long i = 2; i * i <= fp.a; i++) {\n                if (fp.a % i == 0) {\n                    if (i != 1)\n                        s.add((int) i);\n                    s.add((int) (fp.a / i));\n\n                    while (fp.a % i == 0)\n                        fp.a /= i;\n                }\n            }\n\n            for (long i = 2; i * i <= fp.b; i++) {\n                if (fp.b % i == 0) {\n                    if (i != 1)\n                        s.add((int) i);\n                    s.add((int) (fp.b / i));\n\n                    while (fp.b % i == 0)\n                        fp.b /= i;\n                }\n            }\n\n            if (fp.a > 1)\n                s.add(fp.a);\n\n            if (fp.b > 1)\n                s.add(fp.b);\n\n            int ans = -1;\n            for (Integer num : s) {\n                boolean isp = true;\n                for (int i = 1; i < n; i++) {\n                    p cp = ps.get(i);\n\n                    if (cp.a % num == 0) {\n\n                    } else if (cp.b % num == 0) {\n\n                    } else {\n                        isp = false;\n                        break;\n                    }\n                }\n                if (isp) {\n                    ans = num;\n                    break;\n                }\n            }\n\n            if (ans == 1) {\n                ans = -1;\n            }\n\n            out.println(ans);\n        }\n\n        class p {\n            int a;\n            int b;\n\n            public p(int a, int b) {\n                this.a = a;\n                this.b = b;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint debug = 0.0;\nint debug_test = 0;\nint _t = 0;\ntypedef vector<vector<int> > matrix;\nconst long long int mod = 1e9 + 7;\ntemplate <class T>\nlong long int sz(T &x) {\n  return (long long int)x.size();\n}\ntemplate <class T>\nvoid show(T first) {\n  if (debug and (debug_test == 0 or _t == debug_test))\n    cout << \" \" << first << \"\\n\";\n}\ntemplate <class T, class... Args>\nvoid show(T first, Args... args) {\n  if (debug and (debug_test == 0 or _t == debug_test)) cout << \" \" << first;\n  show(args...);\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, pair<T, U> &x) {\n  return os << x.first << \",\" << x.second;\n}\ntemplate <class T>\nbool sort_fun(T a, T b) {\n  return a > b;\n}\nstruct Desc {\n  bool operator()(long long int a, long long int b) { return a > b; }\n} desc;\nconst long long int range = 32000;\nvector<long long int> primes;\nvoid sieve(set<long long int> &p) {\n  vector<long long int> vec(range, 1);\n  vec[0] = 0;\n  vec[1] = 0;\n  for (long long int i = 2; i < range; i++)\n    if (vec[i] == 1)\n      for (long long int j = 2 * i; j < range; j += i) vec[j] = 0;\n  for (long long int i = 2; i < range; i++)\n    if (vec[i] == 1) p.insert(i), primes.push_back(i);\n}\nbool is_prime(long long int n) {\n  long long int i = 0;\n  for (; i < (long long int)primes.size() and primes[i] <= sqrt(n); i++)\n    if (n % primes[i] == 0) return false;\n  for (long long int i = *primes.rbegin(); i <= sqrt(n); i++)\n    if (n % i == 0) return false;\n  return true;\n}\nset<long long int> factorise(long long int a, long long int b,\n                             set<long long int> primes, long long int x) {\n  set<long long int> f;\n  for (auto p : primes) {\n    if (a <= 1 and p > a) break;\n    if (a % p == 0) f.insert(p), a /= p;\n    while (a % p == 0 and a > 1) a /= p;\n  }\n  if (x == 0 and a > 1 and is_prime(a)) f.insert(a);\n  for (auto p : primes) {\n    if (b <= 1 and p > b) break;\n    if (b % p == 0) f.insert(p), b /= p;\n    while (b % p == 0 and b > 1) b /= p;\n  }\n  if (x == 0 and b > 1 and is_prime(b)) f.insert(b);\n  return f;\n}\nlong long int temp = -1, last = -1;\nvoid solve() {\n  long long int n, a, b;\n  cin >> n;\n  set<long long int> primes;\n  sieve(primes);\n  vector<pair<long long int, long long int> > vec(n);\n  for (long long int i = 0; i < n; i++) {\n    cin >> a >> b;\n    vec[i] = {a, b};\n  }\n  for (long long int i = 0; i < n; i++) {\n    primes = factorise(vec[i].first, vec[i].second, primes, i);\n  }\n  if (primes.size() == 0)\n    cout << \"-1\" << endl;\n  else\n    cout << *primes.begin() << endl;\n}\nsigned main() {\n  long long int test = 1;\n  for (long long int t = 1; t <= test; t++) _t = t, solve();\n}\n"
        },
        {
            "language": 3,
            "solution": "import functools\nimport time\nfrom collections import Counter\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n    # @timer\n    def __init__(self):\n        pass\n\n    def __call__(self):\n\n        def get(a):\n            ans = set()\n            x = 2\n            while x * x <= a:\n                if a % x == 0:\n                    ans.add(x)\n                    while a % x == 0:\n                        a = a // x\n                x += 1            \n            if a > 1:\n                ans.add(a)\n            return ans\n\n        n = int(input())        \n        ab = list()\n        for _ in range(n):\n            ab.append(tuple(map(int, input().strip().split())))\n\n        s = set()\n        s.update(get(ab[0][0]))\n        s.update(get(ab[0][1]))\n        for x in s:\n            ok = True\n            for a, b in ab:\n                if a % x != 0 and b % x != 0:\n                    ok = False\n                    break\n            if ok:\n                print(x)\n                exit(0)\n        print('-1')            \n        \n\nsolver()()"
        },
        {
            "language": 1,
            "solution": "n = int(raw_input())\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\na, b = map(int, raw_input().split())\nst1, st2 = a, b\nans = (a * b) / gcd(a, b)\n\nfor i in xrange(n - 1):\n    a, b = map(int, raw_input().split())\n    l = (a * b) / gcd(a, b)\n    ans = gcd(ans, l)\n\n\nif ans == 1:\n    print -1\nelse:\n    for i in xrange(int(1e7)):\n        if ans % (i+2) == 0:\n            print i+2\n            break\n    else:\n        if ans % st1 == 0:\n            print st1\n        elif ans % st2 == 0:\n            print st2\n        else:\n            print ans"
        },
        {
            "language": 3,
            "solution": "#------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n#-------------------game starts now-----------------------------------------------------\nn=int(input())\na,b=map(int,input().split())\ns=set()\nfor i in range(2,int(a**0.5)+1):\n    if a%i==0:\n        s.add(i)\n    while(a%i==0):\n        a//=i\nif a!=1:\n    s.add(a)\na=b\nfor i in range(2,int(a**0.5)+1):\n    if a%i==0:\n        s.add(i)\n    while(a%i==0):\n        a//=i\nif a!=1:\n    s.add(a)\n#print(s)\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    y=set()\n    for j in s:\n        if a%j!=0 and b%j!=0:\n            y.add(j)\n    for j in y:\n        s.remove(j)\nif len(s)==0:\n    print(-1)\nelse:\n    for j in s:\n        print(j)\n        break\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin,stdout\n\ndef prime(x):\n    s = set([])\n    if(x%2 == 0):\n        s.add(2)\n    while(x%2==0):\n        x /= 2\n    for i in range(3,int(pow(x,0.5))+1,2):\n        if(x%i==0):\n            s.add(i)\n            while(x%i==0):\n                x /= i\n    if(x>1):\n        s.add(x)\n    return s\n\nn = int(stdin.readline())\na = []\nfor i in range(n):\n    x = map(int,stdin.readline().split())\n    a.append(x)\n\ns1 = prime(a[0][0])\ns2 = prime(a[0][1])\nmaha = s1 | s2\nfor i in range(1,n):\n    if(len(maha) == 0):\n        break\n    x = a[i][0]\n    y = a[i][1]\n    g = set([])\n    for i in maha:\n        if(x%i == 0 or y%i == 0):\n            g.add(i)\n    maha = g\n\nif(len(maha)):\n    stdout.write(str(maha.pop()))\nelse:\n    stdout.write(str(-1))\n"
        },
        {
            "language": 3,
            "solution": "def prime_factorize(n):\n    primes_factors = {}\n\n    while n % 2 == 0:\n        n >>= 1\n        primes_factors[2] = primes_factors.get(2, 0) + 1\n\n    for i in range(3, int(n ** (1 / 2)) + 1, 2):\n        while n % i == 0:\n            n //= i\n            primes_factors[i] = primes_factors.get(i, 0) + 1\n\n    if n > 1:\n        primes_factors[n] = 1\n\n    return [*primes_factors.keys()]\n\nn = int(input())\na = set([])\n\nfor _ in range(n):\n\ti, j = map(int, input().split())\n\tif _ == 0:\n\t\ta = set(prime_factorize(i) + prime_factorize(j))\n\t\tcontinue\n\tfor k in [*a]:\n\t\tif i % k and j % k:\n\t\t\ta.remove(k)\n\nprint([*a][0] if len(a) else -1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool isPowerOfTwo(int x) { return (x && !(x & (x - 1))); }\nbool is_prime(int n) {\n  if (n == 1) return false;\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  long long int a, b;\n  cin >> a >> b;\n  set<long long int> st;\n  st.insert(a);\n  st.insert(b);\n  for (int i = 2; i * i <= a; i++) {\n    if (a % i == 0) {\n      st.insert(i);\n      st.insert(a / i);\n    }\n  }\n  for (int i = 2; i * i <= b; i++) {\n    if (b % i == 0) {\n      st.insert(i);\n      st.insert(b / i);\n    }\n  }\n  map<pair<long long int, long long int>, long long int> ch;\n  ch[{a, b}]++;\n  for (int i = 1; i < n; i++) {\n    cin >> a >> b;\n    if (ch[{a, b}] >= 1) continue;\n    ch[{a, b}]++;\n    for (auto it = st.begin(); it != st.end();) {\n      long long int k = *it;\n      if (a % k == 0 || b % k == 0) {\n        it++;\n      } else {\n        it = st.erase(it++);\n      }\n    }\n  }\n  if (st.empty())\n    cout << \"-1\";\n  else\n    cout << (*st.begin());\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\n\nN=int(input())\nList=[]\nmaxval=0\nfor i in range(N):\n    u,v=map(int,input().split())\n    List.append([u,v])\n    maxval=math.gcd(maxval,u*v)\nfor i in List:\n    if math.gcd(i[0],maxval)>1:\n        maxval=math.gcd(i[0],maxval)\n    else:\n        maxval=math.gcd(i[1],maxval)\nif maxval==1:\n    print(-1)\nelse:\n    print(maxval)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\n\npublic class cfs505B {\n    static final int maxPrime = 44730; // ceil(sqrt ( 2 * 10^9 ))\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        StringBuilder sb = new StringBuilder();\n        int n = sc.nextInt();\n        long[] nums = sc.readLongArray(2*n);\n        List<Long> primeList = new ArrayList<Long>();\n        {\n            int[] primes = generatePrimes(maxPrime);\n            // add unique factors numbers between pair to frequency\n            List<Long> factor1 = factor(primes, nums[0]);\n            List<Long> factor2 = factor(primes, nums[1]);\n            HashSet<Long> seen = new HashSet<Long>();\n            for (Long l : factor1) {\n                seen.add(l);\n            }\n            for (Long l : factor2) {\n                seen.add(l);\n            }\n            for (Long l : seen) {\n                primeList.add(l);\n            }\n        }\n        Map<Long, Integer> freq = new HashMap<Long, Integer>();\n        for (int i = 0; i < n; i++) {\n            for (int primeIndex = 0; primeIndex < primeList.size(); primeIndex++) { // try to cut this down\n                long p = primeList.get(primeIndex);\n                boolean added = false;\n                while (nums[2*i]%p == 0) {\n                    nums[2*i] /= p;\n                    added = true;\n                }\n                while (nums[2*i+1]%p == 0) {\n                    nums[2*i+1] /= p;\n                    added = true;\n                }\n                if (added) {\n                    long prime = p;\n                    Integer k  = freq.get(prime);\n                    freq.put(prime, k == null ? 1 : k + 1);\n                }\n            }\n        }\n        for (Map.Entry<Long, Integer> entry : freq.entrySet()) {\n            if (entry.getValue() == n) {\n                System.out.println(entry.getKey());\n                return;\n            }\n        }\n        System.out.println(-1);\n\n\n\n        System.out.print(sb);\n    }\n    /* returns boolean array a[] such that a[p] == true iff p is prime. */\n    static boolean [] sieve(int N) {\n        boolean [] a = new boolean[N+1];\n        Arrays.fill(a, true);\n        a[0] = a[1] = false;\n        for (int p = 2; p * p <= N; p++)\n            if (a[p]) {\n                // Iterate through all multiples m of the prime and mark\n                // them as not prime.\n                for (int m = p * p; m <= N; m += p)\n                    a[m] = false;\n            }\n        return a;\n    }\n\n    /* generate all prime numbers from 2..N, inclusive */\n    static int [] generatePrimes(int N) {\n        List<Integer> primes = new ArrayList<Integer>();\n        boolean [] isPrime = sieve(N);\n        for (int i = 0; i <= N; i++)\n            if (isPrime[i])\n                primes.add(i);\n        int [] pa = new int[primes.size()];\n        for (int i = 0; i < pa.length; i++)\n            pa[i] = primes.get(i);\n        return pa;\n    }\n\n    /*\n     * P - list of primes\n     * n - number to factor\n     * @return list of prime factors, e.g. n = 100 returns [2, 2, 5, 5]\n     */\n    static List<Long> factor(int []P, long n) {\n        List<Long> result = new ArrayList<Long>();\n        for (int i = 0; i < P.length; i++) {\n            long p = P[i];\n            if (p * p > n) break;\n            while (n % p == 0) {\n                result.add(p);\n                n /= p;\n            }\n        }\n        if (n != 1) // large prime remainder\n            result.add(n);\n\n        return result;\n    }\n\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n\n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n\n        long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextLong();\n            }\n            return a;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 150000 + 1;\nstruct Pair {\n  int x, y;\n} A[N];\nint n;\nbool Judge(int sum) {\n  for (int i = 2; i <= n; i++) {\n    if ((A[i].x % sum != 0) && (A[i].y % sum != 0)) return 0;\n  }\n  cout << sum;\n  exit(0);\n}\nvoid Getans(int x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      Judge(i);\n      while (x % i == 0) {\n        x /= i;\n      }\n    }\n  }\n  if (x != 1) Judge(x);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &A[i].x, &A[i].y);\n  }\n  Getans(A[1].x);\n  Getans(A[1].y);\n  cout << -1;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[] = {0, 1, 0, -1, -1, 1, 1, -1};\nint dy[] = {1, 0, -1, 0, -1, -1, 1, 1};\nint kx[] = {-2, -2, -1, 1, 2, 2, 1, -1};\nint ky[] = {-1, 1, 2, 2, 1, -1, -2, -2};\ninline long long gcd(long long a, long long b) {\n  a = fabs(a);\n  b = fabs(b);\n  while (b) {\n    a = a % b;\n    swap(a, b);\n  }\n  return a;\n}\ninline long long bigmod(long long a, long long p, long long m) {\n  long long res = 1 % m, x = a % m;\n  while (p) {\n    if (p & 1) res = (res * x) % m;\n    x = (x * x) % m;\n    p >>= 1;\n  }\n  return res;\n}\nstruct DATA {\n  long long a, b;\n};\nvector<DATA> arr;\nset<long long> s;\nint main() {\n  long long n;\n  scanf(\"%lld\", &n);\n  for (int i = (int)(1); i <= (int)(n); i++) {\n    long long x, y;\n    scanf(\"%lld %lld\", &x, &y);\n    arr.push_back({x, y});\n  }\n  if (n == 1) {\n    cout << arr[0].a << endl;\n    exit(0);\n  }\n  for (int i = 2; i * i <= arr[0].a; i++) {\n    if (arr[0].a % i == 0) {\n      while (arr[0].a % i == 0) arr[0].a /= i;\n      s.insert(i);\n    }\n  }\n  if (arr[0].a > 1) s.insert(arr[0].a);\n  for (int i = 2; i * i <= arr[0].b; i++) {\n    if (arr[0].b % i == 0) {\n      while (arr[0].b % i == 0) arr[0].b /= i;\n      s.insert(i);\n    }\n  }\n  if (arr[0].b > 1) s.insert(arr[0].b);\n  for (set<long long>::iterator it = s.begin(); it != s.end(); it++) {\n    bool found = 1;\n    long long x = *it;\n    if (x == 0) continue;\n    for (int j = (int)(1); j <= (int)(arr.size() - 1); j++) {\n      long long val1 = arr[j].a;\n      long long val2 = arr[j].b;\n      if (val1 % x != 0 and val2 % x != 0) {\n        found = 0;\n        break;\n      }\n    }\n    if (found and x > 1) {\n      cout << x << endl;\n      exit(0);\n    }\n  }\n  cout << \"-1\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int INF = 1e9;\nconst long long int MOD = 1e9 + 7;\npair<long long int, long long int> arr[150001];\nset<long long int> s;\nmap<long long int, long long int> mapp;\nint main() {\n  long long int n, i;\n  cin >> n;\n  for (i = 1; i <= n; i++) cin >> arr[i].first >> arr[i].second;\n  long long int a = arr[1].first, b = arr[1].second;\n  for (i = 2; i * i <= a; i++) {\n    if (a % i != 0) continue;\n    while (a % i == 0) a = a / i;\n    s.insert(i);\n  }\n  if (a != 1) s.insert(a);\n  for (i = 2; i * i <= b; i++) {\n    if (b % i != 0) continue;\n    while (b % i == 0) b = b / i;\n    s.insert(i);\n  }\n  if (b != 1) s.insert(b);\n  long long int cnt = 1;\n  long long int ans = *(s.begin());\n  for (auto it : s) {\n    cnt = 1;\n    for (i = 2; i <= n; i++) {\n      if (arr[i].first % it == 0 || arr[i].second % it == 0) cnt++;\n    }\n    if (cnt == n) {\n      ans = it;\n      break;\n    }\n  }\n  if (cnt == n)\n    cout << ans << \"\\n\";\n  else\n    cout << \"-1\\n\";\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\ndef prime_factors(a):\n\tfactors=set()\n\ti=2\n\torig=a\n\twhile i <= (int(orig**0.5)+1):\n\t\twhile a%i==0:\n\t\t\ta=a//i\n\t\t\tfactors.add(i)\n\t\ti+=1\n\tif a>1:\n\t\tfactors.add(a)\n\treturn factors\n\t\t\nN=int(sys.stdin.readline())\na,b=[int(x) for x in sys.stdin.readline().split()]\ndivisors=(prime_factors(a)).union(prime_factors(b))\n\ndivisors=[int(x) for x in divisors]\n\nfor i in range(N-1):\n\tchecker=[]\n\tc,d=[int(x) for x in sys.stdin.readline().split()]\n\tif divisors:\n\t\tfor i in divisors:\n\t\t\tif (c*d)%i==0:\n\t\t\t\tchecker.append(i)\n\tdivisors=checker\nprint(divisors[0] if divisors!=[] else \"-1\")"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 3e5;\nint ai[N], bi[N], C[N], tot;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d%d\", &ai[i], &bi[i]);\n  for (long long p = 2; p * p <= ai[1]; ++p) {\n    if (ai[1] % p == 0) {\n      C[++tot] = p;\n      while (ai[1] % p == 0) ai[1] /= p;\n    }\n  }\n  if (ai[1] != 1) C[++tot] = ai[1];\n  swap(ai[1], bi[1]);\n  for (long long p = 2; p * p <= ai[1]; ++p)\n    if (ai[1] % p == 0) {\n      C[++tot] = p;\n      while (ai[1] % p == 0) ai[1] /= p;\n    }\n  if (ai[1] != 1) C[++tot] = ai[1];\n  for (int p = 1; p <= tot; ++p) {\n    int fl = 1;\n    for (int i = 2; i <= n; ++i)\n      if ((ai[i] % C[p]) && (bi[i] % C[p])) {\n        fl = 0;\n        break;\n      }\n    if (fl) {\n      printf(\"%d\\n\", C[p]);\n      return 0;\n    }\n  }\n  puts(\"-1\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 10;\nconst int inf = 0x3f3f3f3f;\nlong long n, m, p[maxn];\nset<int> prime;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nvoid find(long long x) {\n  for (long long i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      prime.insert(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) prime.insert(x);\n}\nint main() {\n  int i, j;\n  prime.clear();\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    long long x, y, te;\n    scanf(\"%I64d %I64d\", &x, &y);\n    if (i == 1) {\n      find(x);\n      find(y);\n    }\n    te = gcd(x, y);\n    p[i] = x * y / te;\n  }\n  long long t = p[1];\n  for (long long i = 2; i <= n; i++) {\n    t = gcd(t, p[i]);\n  }\n  set<int>::iterator it;\n  for (it = prime.begin(); it != prime.end(); it++) {\n    if (t % (*it) == 0) {\n      t = *it;\n      break;\n    }\n  }\n  if (t == 1)\n    printf(\"-1\\n\");\n  else {\n    printf(\"%lld\\n\", t);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import gcd\n\nn=int(input())\ng=1\na=[0]*n\nb=[0]*n\nfor i in range(1):\n    a[i],b[i]=map(int,input().split())\n    g=a[i]*b[i]\nfor i in range(1,n):\n    a[i],b[i]=map(int,input().split())\n    g=gcd(a[i]*b[i],g)\nfor i in range(n):\n    if gcd(a[i],g)>1:\n        g=gcd(a[i],g)\n    elif gcd(b[i],g)>1:\n        g=gcd(b[i],g)\n    else:\n        print(-1)\n        exit()\nprint(g)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ara[500008];\nset<int> s;\nset<int>::iterator it;\nint n;\nvoid check(int num) {\n  for (int i = 1; i < n; i++) {\n    if (!(ara[i] % num == 0 || ara[n + i] % num == 0)) {\n      return;\n    }\n  }\n  cout << num << endl;\n  exit(0);\n}\nint primefactor(int num) {\n  int i;\n  for (i = 2; i <= num / i; i++) {\n    bool flag = 0;\n    while (num % i == 0) {\n      num /= i;\n      if (!flag) {\n        check(i);\n      }\n      flag = 1;\n    }\n  }\n  if (num > 1) {\n    check(num);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d\", &ara[i], &ara[n + i]);\n  }\n  primefactor(ara[0]);\n  primefactor(ara[n]);\n  cout << \"-1\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class Main {\n\tstatic ArrayList<Integer> adj[];\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tpublic static long mod;\n\n\tstatic int [][]notmemo;\n\tstatic int k;\n\tstatic int a[];\n\tstatic int b[];\n\tstatic int m;\n\tstatic char c[];\n\n\n\tstatic int trace[];\n\tstatic int h[];\n\tstatic int x;\n\tstatic int ans1;\n\tstatic int ans2;\n    static char t[];\n\tstatic char l[];\n\tstatic char r[];\n    static int w;\n    static int s;\n\tstatic int fn[];\n    public static void main(String args[]) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t sieve((int) (1e5+1));\n\t        factors = new TreeSet<>();\n\t        int n = sc.nextInt();\n\t        n--;\n\t        int a=sc.nextInt();\n\t        int b=sc.nextInt();\n\t        generatePF(a);\n\t        generatePF(b);\n\t        \n\t        while(n-->0) {\n\t        \ta=sc.nextInt();\n\t        \tb=sc.nextInt();\n\t        \tHashSet<Integer> set1=new HashSet<>();\n\t\t\t\tfor(int x:factors) {\n\t\t\t\t\tif(a%x!=0&&b%x!=0) {\n\t\t\t\t\t\tset1.add(x);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tfor(int x:set1) {\n\t\t\t\t\tfactors.remove(x);\n\t\t\t\t}\n\t        }\n\t\t\t\n\t\t\n\t\tif(factors.size()!=0)\n\t\t\tout.println(factors.first());\n\t\telse\t\n\t\tout.println(-1);\n\t\tout.flush();\n    }\n    static int max=(int) (1e5+1); \n        static void sieve(int N)\t// O(N log log N) \n\t{\n\t\tisComposite = new int[N+1];\t\t\t\t\t\n\t\tisComposite[0] = isComposite[1] = 1;\t\t\t// 0 indicates a prime number\n\t\tprimes = new ArrayList<Integer>();\n \n\t\tfor (int i = 2; i <= N; ++i) \t\t\t\t\t//can loop till i*i <= N if primes array is not needed O(N log log sqrt(N)) \n\t\t\tif (isComposite[i] == 0) \t\t\t\t\t//can loop in 2 and odd integers for slightly better performance\n\t\t\t{\n\t\t\t\tprimes.add(i);\n\t\t\t\tif(1l * i * i <= N)\n\t\t\t\t\tfor (int j = i * i; j <= N; j += i)\t// j = i * 2 will not affect performance too much, may alter in modified sieve\n\t\t\t\t\t\tisComposite[j] = 1;\n\t\t\t}   \n\t}\n    static TreeSet<Integer> factors;\n    static void generatePF(int n) {\n        for (int p : primes) {\n            if (1l * p * p > n) break;\n            while (n % p == 0) {\n                n /= p;\n                factors.add(p);\n            }\n        }\n        if (n != 1) factors.add(n);\n    }\n    static int dp(int i,int rem) {\n\tif(rem==0||i==0) {\n\t\treturn 0;\n\t}\n\tif(notmemo[i][rem]!=-1) {\n\t\treturn notmemo[i][rem];\n\t}\t\n\t\n\tint ans=0;\n\tfor (int j = 1; j <=Math.min(rem,k); j++) {\n\t\tans=Math.max(ans, dp(i-1,rem-j)+h[j]);\n\t}\n\t\n\treturn notmemo[i][rem]=ans;\n    }\n    static String y;\n    \tstatic int nomnom[];\n\tstatic long fac[];\n\t\n\tstatic class book implements Comparable<book> {\n\t\tint idx;\n\t\tlong score;\n\n\t\tpublic book(int i, long s) {\n\t\t\tidx = i;\n\t\t\tscore = s;\n\t\t}\n\n\t\tpublic int compareTo(book o) {\n\t\t\treturn (int) (o.score - score);\n\t\t}\n\t}\n\n\tstatic class library implements Comparable<library> {\n\t\tint numofbooks;\n\t\tint signup;\n\t\tint shiprate;\n\t\tint idx;\n\n\t\tpublic library(int a, int b, int c, int idx) {\n\t\t\tnumofbooks = a;\n\t\t\tsignup = b;\n\t\t\tshiprate = c;\n\t\t\tthis.idx = idx;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(library o) {\n\t\tif(signup==o.signup) {\n\t\t\t  return o.numofbooks-numofbooks;\n\t\t}\n\t\treturn signup - o.signup;\n\t\t\n\t\t}\n\t}\n\n\n\n\n\n\tstatic boolean isOn(int S, int j) {\n\t\treturn (S & 1 << j) != 0;\n\t}\n\n\n\tstatic boolean f = true;\n\n\tstatic class SegmentTree { // 1-based DS, OOP\n\n\t\tint N; // the number of elements in the array as a power of 2 (i.e. after padding)\n\t\tint[] array, sTree, lazy;\n\n\t\tSegmentTree(int[] in) {\n\t\t\tarray = in;\n\t\t\tN = in.length - 1;\n\t\t\tsTree = new int[N << 1]; // no. of nodes = 2*N - 1, we add one to cross out index zero\n\t\t\tlazy = new int[N << 1];\n\t\t\t//build(1, 1, N);\n\t\t}\n\n\t\tvoid build(int node, int b, int e) // O(n)\n\t\t{\n\t\t\tif (b == e)\n\t\t\t\tsTree[node] = array[b];\n\t\t\telse {\n\t\t\t\tint mid = b + e >> 1;\n\t\t\t\tbuild(node << 1, b, mid);\n\t\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\t\tsTree[node] = sTree[node << 1] + sTree[node << 1 | 1];\n\t\t\t}\n\t\t}\n\n\t\tvoid update_point(int index, int val) // O(log n)\n\t\t{\n\t\t\tindex += N - 1;\t\t\t\t\n\t\t\tsTree[index] = val;\t\t\t\n\t\t\twhile(index>1)\t\t\t\t\n\t\t\t{\n\t\t\t\tindex >>= 1;\n\t\t\t\tsTree[index] = Math.max(sTree[index<<1] ,sTree[index<<1|1]);\t\t\n\t\t\t}\n\t\t}\n\n\t\tvoid update_range(int i, int j, int val) // O(log n)\n\t\t{\n\t\t\tupdate_range(1, 1, N, i, j, val);\n\t\t}\n\n\t\tvoid update_range(int node, int b, int e, int i, int j, int val) {\n\t\t\tif (i > e || j < b)\n\t\t\t\treturn;\n\t\t\tif (b >= i && e <= j) {\n\t\t\t\tsTree[node] += (e - b + 1) * val;\n\t\t\t\tlazy[node] += val;\n\t\t\t} else {\n\t\t\t\tint mid = b + e >> 1;\n\t\t\t\tpropagate(node, b, mid, e);\n\t\t\t\tupdate_range(node << 1, b, mid, i, j, val);\n\t\t\t\tupdate_range(node << 1 | 1, mid + 1, e, i, j, val);\n\t\t\t\tsTree[node] = sTree[node << 1] + sTree[node << 1 | 1];\n\t\t\t}\n\n\t\t}\n\n\t\tvoid propagate(int node, int b, int mid, int e) {\n\t\t\tlazy[node << 1] += lazy[node];\n\t\t\tlazy[node << 1 | 1] += lazy[node];\n\t\t\tsTree[node << 1] += (mid - b + 1) * lazy[node];\n\t\t\tsTree[node << 1 | 1] += (e - mid) * lazy[node];\n\t\t\tlazy[node] = 0;\n\t\t}\n\n\t\tint query(int i, int j) {\n\t\t\treturn query(1, 1, N, i, j);\n\t\t}\n\n\t\tint query(int node, int b, int e, int i, int j) // O(log n)\n\t\t{\n\t\t\tif (i > e || j < b)\n\t\t\t\treturn 0;\n\t\t\tif (b >= i && e <= j)\n\t\t\t\treturn sTree[node];\n\t\t\tint mid = b + e >> 1;\n\t\t\t// propagate(node, b, mid, e);\n\t\t\tint q1 = query(node << 1, b, mid, i, j);\n\t\t\tint q2 = query(node << 1 | 1, mid + 1, e, i, j);\n\t\t\treturn Math.max(q1,q2);\n\n\t\t}\n\t}\n\n\tstatic int memo[];\n\n\n\tstatic class UnionFind {\n\t\tint[] p, rank, setSize;\n\t\tint numSets;\n\t\tint max[];\n\n\t\tpublic UnionFind(int N) {\n\t\t\tp = new int[numSets = N];\n\t\t\trank = new int[N];\n\t\t\tsetSize = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tp[i] = i;\n\t\t\t\tsetSize[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tpublic int findSet(int i) {\n\t\t\treturn p[i] == i ? i : (p[i] = findSet(p[i]));\n\t\t}\n\n\t\tpublic boolean isSameSet(int i, int j) {\n\t\t\treturn findSet(i) == findSet(j);\n\t\t}\n\n\t\tpublic void unionSet(int i, int j) {\n\t\t\tif (isSameSet(i, j))\n\t\t\t\treturn;\n\t\t\tnumSets--;\n\t\t\tint x = findSet(i), y = findSet(j);\n\t\t\tif (rank[x] > rank[y]) {\n\t\t\t\tp[y] = x;\n\t\t\t\tsetSize[x] += setSize[y];\n\n\n\t\t\t} else {\n\t\t\t\tp[x] = y;\n\t\t\t\tsetSize[y] += setSize[x];\n\t\t\t\tif (rank[x] == rank[y])\n\t\t\t\t\trank[y]++;\n\n\n\t\t\t}\n\t\t}\n\n\t\t\n\n\t\tpublic int numDisjointSets() {\n\t\t\treturn numSets;\n\t\t}\n\n\t\tpublic int sizeOfSet(int i) {\n\t\t\treturn setSize[findSet(i)];\n\t\t}\n\t}\n\n\t/**\n\t * private static void trace(int i, int time) { if(i==n) return;\n\t * \n\t * \n\t * long ans=dp(i,time);\n\t * if(time+a[i].t<a[i].burn&&(ans==dp(i+1,time+a[i].t)+a[i].cost)) {\n\t * \n\t * trace(i+1, time+a[i].t);\n\t * \n\t * l1.add(a[i].idx); return; } trace(i+1,time);\n\t * \n\t * }\n\t **/\n\n\tstatic class incpair implements Comparable<incpair> {\n\t\tint a;\n\t\tlong b;\n\t\tint idx;\n\n\t\tincpair(int a, long dirg, int i) {\n\t\t\tthis.a = a;\n\t\t\tb = dirg;\n\t\t\tidx = i;\n\t\t}\n\n\t\tpublic int compareTo(incpair e) {\n\t\t\treturn (int) (b - e.b);\n\t\t}\n\t}\n\n\tstatic class decpair implements Comparable<decpair> {\n\t\tint a;\n\t\tlong b;\n\t\tint idx;\n\n\t\tdecpair(int a, long dirg, int i) {\n\t\t\tthis.a = a;\n\t\t\tb = dirg;\n\t\t\tidx = i;\n\t\t}\n\n\t\tpublic int compareTo(decpair e) {\n\t\t\treturn (int) (e.b - b);\n\t\t}\n\t}\n\n\tstatic long allpowers[];\n\n\tstatic class Quad implements Comparable<Quad> {\n\t\tint u;\n\t\tint v;\n\t\tchar state;\n\t\tint turns;\n\n\t\tpublic Quad(int i, int j, char c, int k) {\n\t\t\tu = i;\n\t\t\tv = j;\n\t\t\tstate = c;\n\t\t\tturns = k;\n\t\t}\n\n\t\tpublic int compareTo(Quad e) {\n\t\t\treturn (int) (turns - e.turns);\n\t\t}\n\n\t}\n\n\tstatic long dirg[][];\n\tstatic Edge[] driver;\n\n\tstatic int n;\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint node;\n\t\tlong cost;\n\n\t\tEdge(int a, long dirg) {\n\t\t\tnode = a;\n\t\t\tcost = dirg;\n\t\t}\n\n\t\tpublic int compareTo(Edge e) {\n\t\t\treturn (int) (cost - e.cost);\n\t\t}\n\t}\n\n\tstatic long manhatandistance(long x, long x2, long y, long y2) {\n\t\treturn Math.abs(x - x2) + Math.abs(y - y2);\n\t}\n\n\tstatic long fib[];\n\n\tstatic long fib(int n) {\n\t\tif (n == 1 || n == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (fib[n] != -1) {\n\t\t\treturn fib[n];\n\t\t} else\n\t\t\treturn fib[n] = ((fib(n - 2) % mod + fib(n - 1) % mod) % mod);\n\t}\n\n\tstatic class Point  implements Comparable<Point>{\n\t\tlong x, y;\n\n\t\tPoint(long counth, long counts) {\n\t\t\tx = counth;\n\t\t\ty = counts;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point p )\n\t\t{\n\t\t\treturn Long.compare(p.y*1l*x, p.x*1l*y);\n\t\t}\n\t\t\n\n\n\t}\n\n\tstatic long[][] comb;\n\n\tstatic class Triple implements Comparable<Triple> {\n\n\t\tint l;\n\t\tint r;\n\t\tlong cost;\n\t\tint idx;\n\n\t\tpublic Triple(int a, int b, long l1, int l2) {\n\t\t\tl = a;\n\t\t\tr = b;\n\t\t\tcost = l1;\n\t\t\tidx = l2;\n\t\t}\n\n\t\tpublic int compareTo(Triple x) {\n\t\t\tif (l != x.l || idx == x.idx)\n\t\t\t\treturn l - x.l;\n\t\t\treturn -idx;\n\t\t}\n\n\t}\n\n\tstatic TreeSet<Long> primeFactors(long N) // O(sqrt(N) / ln sqrt(N))\n\t{\n\t\tTreeSet<Long> factors = new TreeSet<Long>(); // take abs(N) in case of -ve integers\n\t\tint idx = 0, p = primes.get(idx);\n\n\t\twhile (p * p <= N) {\n\t\t\twhile (N % p == 0) {\n\t\t\t\tfactors.add((long) p);\n\t\t\t\tN /= p;\n\t\t\t}\n\t\t\tif (primes.size() > idx + 1)\n\t\t\t\tp = primes.get(++idx);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (N != 1) // last prime factor may be > sqrt(N)\n\t\t\tfactors.add(N); // for integers whose largest prime factor has a power of 1\n\t\treturn factors;\n\t}\n\n\tstatic boolean visited[];\n\n\t/**\n\t * static int bfs(int s) { Queue<Integer> q = new LinkedList<Integer>();\n\t * q.add(s); int count=0; int maxcost=0; int dist[]=new int[n]; dist[s]=0;\n\t * while(!q.isEmpty()) {\n\t * \n\t * int u = q.remove(); if(dist[u]==k) { break; } for(Pair v: adj[u]) {\n\t * maxcost=Math.max(maxcost, v.cost);\n\t * \n\t * \n\t * \n\t * if(!visited[v.v]) {\n\t * \n\t * visited[v.v]=true; q.add(v.v); dist[v.v]=dist[u]+1; maxcost=Math.max(maxcost,\n\t * v.cost); } }\n\t * \n\t * } return maxcost; }\n\t **/\n\tpublic static boolean FindAllElements(int n, int k) {\n\t\tint sum = k;\n\t\tint[] A = new int[k];\n\t\tArrays.fill(A, 0, k, 1);\n\n\t\tfor (int i = k - 1; i >= 0; --i) {\n\n\t\t\twhile (sum + A[i] <= n) {\n\n\t\t\t\tsum += A[i];\n\t\t\t\tA[i] *= 2;\n\t\t\t}\n\t\t}\n\t\tif (sum == n) {\n\t\t\treturn true;\n\t\t} else\n\t\t\treturn false;\n\t}\n\n\tstatic boolean vis2[][];\n\n\tstatic boolean f2 = false;\n\n\tstatic long[][] matMul(long[][] a2, long[][] b, int p, int q, int r) // C(p x r) = A(p x q) x (q x r) -- O(p x q x\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// r)\n\t{\n\t\tlong[][] C = new long[p][r];\n\t\tfor (int i = 0; i < p; ++i) {\n\t\t\tfor (int j = 0; j < r; ++j) {\n\t\t\t\tfor (int k = 0; k < q; ++k) {\n\t\t\t\t\tC[i][j] = (C[i][j] + (a2[i][k] % mod * b[k][j] % mod)) % mod;\n\t\t\t\t\tC[i][j] %= mod;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\treturn C;\n\t}\n\n\tstatic int memo1[];\n\n\tstatic boolean vis[];\n\tstatic TreeSet<Integer> set = new TreeSet<Integer>();\n\n\tstatic long modPow(long ways, long count, long mod) // O(log e)\n\t{\n\t\tways %= mod;\n\t\tlong res = 1;\n\t\twhile (count > 0) {\n\t\t\tif ((count & 1) == 1)\n\t\t\t\tres = (res * ways) % mod;\n\t\t\tways = (ways * ways) % mod;\n\t\t\tcount >>= 1;\n\t\t}\n\t\treturn res % mod;\n\t}\n\n\tstatic long gcd(long ans, long b) {\n\t\tif (b == 0) {\n\t\t\treturn ans;\n\t\t}\n\t\treturn gcd(b, ans % b);\n\t}\n\n\tstatic int[] isComposite;\n\tstatic int[] valid;\n\n\tstatic ArrayList<Integer> primes;\n\tstatic ArrayList<Integer> l1;\n\n\t\n\tstatic TreeSet<Integer> primus = new TreeSet<Integer>();\n\t\n\tstatic void sieveLinear(int N)\n\t{\n\t\tint[] lp = new int[N + 1];\t\t\t\t\t\t\t\t//lp[i] = least prime divisor of i\n\t\tfor(int i = 2; i <= N; ++i)\n\t\t{\n\t\t\tif(lp[i] == 0)\n\t\t\t{\n\t\t\t\tprimus.add(i);\n\t\t\t\tlp[i] = i;\n\t\t\t}\n\t\t\tint curLP = lp[i];\n\t\t\tfor(int p: primus)\n\t\t\t\tif(p > curLP || p * i > N)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tlp[p * i] = i;\n\t\t}\n\t}\n\t\n\n\tpublic static int[] schuffle(int[] p) {\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tint x = (int) (Math.random() * p.length);\n\t\t\tint temp = p[x];\n\t\t\tp[x] = p[i];\n\t\t\tp[i] = temp;\n\t\t}\n\t\treturn p;\n\t}\n\n\tstatic int V;\n\tstatic long INF = (long) 1E16;\n\n\tstatic class Edge2 {\n\t\tint node;\n\t\tlong cost;\n\t\tlong next;\n\n\t\tEdge2(int a, int c, Long long1) {\n\t\t\tnode = a;\n\t\t\tcost = long1;\n\t\t\tnext = c;\n\t\t}\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\n\t\tpublic int[] nxtArr(int n) throws IOException {\n\t\t\tint[] ans = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tans[i] = nextInt();\n\t\t\treturn ans;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:10000000000\")\nusing namespace std;\nconst int MOD = 1000000007;\nconst long long INF = 1000000007;\nconst long long INF2 = 1000000007LL * 1000000007LL;\nconst long double EPS = 1e-9;\nconst int SIZE = 200100;\nlong long gcd(long long a, long long b) {\n  if (b == 0)\n    return a;\n  else\n    return gcd(b, a % b);\n}\nint gcd_no_recursion(int a, int b) {\n  while (b) {\n    a %= b;\n    swap(a, b);\n  }\n  return a;\n}\nlong long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\nvector<pair<long long, long long> > v;\nlong long ar[SIZE];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  ;\n  cin >> n;\n  long long a, b;\n  for (int i = 0; i < n; ++i) {\n    cin >> a >> b;\n    v.push_back(make_pair(a, b));\n    ar[i] = lcm(a, b);\n  }\n  long long ans = ar[0];\n  for (int i = 1; i < n; ++i) {\n    ans = gcd(ar[i], ans);\n  }\n  if (ans == 1) {\n    cout << -1;\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    long long ans1 = gcd(v[i].first, ans);\n    long long ans2 = gcd(v[i].second, ans);\n    ans = max(ans1, ans2);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> dl;\nset<int>::iterator it;\nqueue<long long> q;\nlong long a[150007][2];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  long long x, y, dd = 1;\n  cin >> n >> x >> y;\n  for (int i = 2; i <= n; i++) cin >> a[i][0] >> a[i][1];\n  int d = 2;\n  int l = 0;\n  while (x != 1) {\n    if (x % d == 0) {\n      dl.insert(d);\n      x /= d;\n      l = 0;\n    } else\n      d++;\n    l++;\n    if (l > sqrt(x) && x > 1) {\n      dl.insert(x);\n      break;\n    }\n  }\n  d = 2;\n  l = 0;\n  while (y != 1) {\n    if (y % d == 0) {\n      dl.insert(d);\n      y /= d;\n      l = 0;\n    } else\n      d++;\n    l++;\n    if (l > sqrt(y) && y > 1) {\n      dl.insert(y);\n      break;\n    }\n  }\n  int cnt = 0;\n  for (it = dl.begin(); it != dl.end(); ++it) {\n    int flag = 0;\n    for (int i = 2; i <= n; i++)\n      if (a[i][0] % (*it) != 0 && a[i][1] % (*it) != 0) {\n        flag = 1;\n        break;\n      }\n    if (flag == 0) {\n      cout << *it;\n      return 0;\n    }\n  }\n  cout << -1;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package math_codet;\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n /******************************************\n*    AUTHOR:         AMAN KUMAR SINGH        *\n*    INSTITUITION:   KALYANI GOVERNMENT ENGINEERING COLLEGE  *\n******************************************/\npublic class lets_do {\n    InputReader in;\n    PrintWriter out;\n    Helper_class h;\n    final long mod=1000000007;\n    final int N=200005;\n    int MAX_Ai=100005;\n    public static void main(String[] args) throws java.lang.Exception{\n        new lets_do().run();\n    }\n    void run() throws Exception{\n        in=new InputReader(System.in);\n        out = new PrintWriter(System.out);\n        h = new Helper_class();\n        int t=1;\n        while(t-->0){\n            solve();\n        }\n        out.flush();    \n        out.close();\n    }\n    void solve(){\n        int n=h.ni();\n        long[][] arr=new long[n][2];\n        int i=0;\n        for(i=0;i<n;i++){\n            arr[i][0]=h.nl();\n            arr[i][1]=h.nl();\n        }\n        \n            TreeSet<Long> prime_factors=new TreeSet<Long>();\n            long p=arr[0][0];\n            if(p%2==0){\n                prime_factors.add((long)2);\n                while(p%2==0)\n                    p/=2;\n            }\n            for (i = 3; i <= Math.sqrt(p); i+= 2)\n            {\n                if(p%i==0){\n                    prime_factors.add((long)i);\n                    while (p%i == 0)\n                    {\n                        p /= i;\n                    }\n                }\n            }\n            if(p>2)\n                prime_factors.add(p);\n            p=arr[0][1];\n            if(p%2==0){\n                prime_factors.add((long)2);\n                while(p%2==0)\n                    p/=2;\n            }\n            for (i = 3; i <= Math.sqrt(p); i+= 2)\n            {\n                if(p%i==0){\n                    prime_factors.add((long)i);\n                    while (p%i == 0)\n                    {\n                        p /= i;\n                    }\n                }\n            }\n            if(p>2)\n                prime_factors.add(p);\n            for(long xx: prime_factors){\n                boolean ok=true;\n                for(int j=0;j<n;j++){\n                    if(arr[j][0]%xx!=0 && arr[j][1]%xx!=0){\n                        ok=false;\n                        break;\n                    }\n                }\n                if(ok==true){\n                    h.pn(xx);\n                    return;\n                }\n            }\n            h.pn(-1);\n        \n    }\n    final Comparator<Entity> com=new Comparator<Entity>(){\n        public int compare(Entity x, Entity y){\n            int xx=Integer.compare(y.a,x.a);\n            if(xx==0)\n                return Integer.compare(x.a,y.a);\n            else\n                return xx;\n        }\n    };\n    class Entity{\n        int a;\n        int b;\n        Entity(int p, int q){\n            a=p;\n            b=q;\n        }\n    }\n    \n\n    class Helper_class{\n        long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n        int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n        long gcd1(long a, long b){return (b==0)?a:gcd(b,a%b);}\n        int bitcount(long n){return (n==0)?0:(1+bitcount(n&(n-1)));}\n        void p(Object o){out.print(o);}\n        void pn(Object o){out.println(o);}\n        void pni(Object o){out.println(o);out.flush();}\n        String n(){return in.next();}\n        String nln(){return in.nextLine();}\n        int ni(){return in.nextInt();}\n        long nl(){return in.nextLong();}\n        double nd(){return in.nextDouble();}\n\n        long mul(long a,long b){\n            if(a>=mod)a%=mod;\n            if(b>=mod)b%=mod;\n            a*=b;\n            if(a>=mod)a%=mod;\n            return a;\n        }\n        long modPow(long a, long p){\n            long o = 1;\n            while(p>0){\n                if((p&1)==1)o = mul(o,a);\n                a = mul(a,a);\n                p>>=1;\n            }\n            return o;\n        }\n        long add(long a, long b){\n            if(a>=mod)a%=mod;\n            if(b>=mod)b%=mod;\n            if(b<0)b+=mod;\n            a+=b;\n            if(a>=mod)a-=mod;\n            return a;\n        }\n    }\n\n    class InputReader{\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n \n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n \n        public int read() {\n            if (numChars == -1)\n                throw new UnknownError();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n \n        public int peek() {\n            if (numChars == -1)\n                return -1;\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar];\n        }\n \n        public void skip(int x) {\n            while (x-- > 0)\n                read();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        public String nextString() {\n            return next();\n        }\n \n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n \n            return res.toString();\n        }\n \n        public String nextLine() {\n            StringBuffer buf = new StringBuffer();\n            int c = read();\n            while (c != '\\n' && c != -1) {\n                if (c != '\\r')\n                    buf.appendCodePoint(c);\n                c = read();\n            }\n            return buf.toString();\n        }\n \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n \n        public boolean hasNext() {\n            int value;\n            while (isSpaceChar(value = peek()) && value != -1)\n                read();\n            return value != -1;\n        }\n \n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate <typename T>\nusing VT = vector<T>;\ntemplate <typename T>\ninline bool chmax(T &a, T b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T>\ninline bool chmin(T &a, T b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\nbool is_prime(long long n) {\n  if (n < 2) {\n    return false;\n  }\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nstd::vector<long long> divisor(const long long n) {\n  std::vector<long long> ret;\n  if (n > 1)\n    for (long long i = 1; i * i <= n; i++) {\n      if (n % i == 0) {\n        ret.emplace_back(i);\n        if (i != n / i && i != 1) {\n          ret.emplace_back(n / i);\n        }\n      }\n    }\n  return ret;\n}\nconst int MAX = 150010;\nint N;\nLL A[MAX], B[MAX];\nint main(void) {\n  scanf(\"%d\", &N);\n  for (int(i) = 0; (i) < (N); (i)++) {\n    scanf(\"%lld%lld\", A + i, B + i);\n  }\n  set<LL> se;\n  auto div = divisor(A[0]);\n  for (auto &&e : (div))\n    if (is_prime(e)) se.emplace(e);\n  div = divisor(B[0]);\n  for (auto &&e : (div))\n    if (is_prime(e)) se.emplace(e);\n  if (is_prime(A[0])) {\n    se.emplace(A[0]);\n  }\n  if (is_prime(B[0])) {\n    se.emplace(B[0]);\n  }\n  for (int(i) = 0; (i) < (N); (i)++) {\n    auto itr = se.begin();\n    while (itr != se.end()) {\n      if (A[i] % *itr != 0 && B[i] % *itr != 0) {\n        itr = se.erase(itr);\n      } else {\n        itr++;\n      }\n    }\n  }\n  if (se.size() == 0)\n    cout << -1 << endl;\n  else\n    cout << *se.begin() << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<int, int> a[150010];\nint n;\nvoid ex(int x) {\n  printf(\"%d\\n\", x);\n  exit(0);\n}\nvoid check(int x) {\n  if (x == 1) return;\n  for (int i = 1; i <= n; ++i)\n    if (a[i].first % x != 0 && a[i].second % x != 0) return;\n  ex(x);\n}\nvoid solve(int x) {\n  int s = sqrt(x) + 1;\n  for (int i = 2; i <= s && i <= x; ++i)\n    if (x % i == 0) {\n      check(i);\n      while (x % i == 0) x /= i;\n    }\n  if (x > 1) check(x);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d%d\", &a[i].first, &a[i].second);\n  }\n  random_shuffle(a + 1, a + n + 1);\n  solve(a[1].first);\n  solve(a[1].second);\n  puts(\"-1\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main implements Runnable {\n\n    int maxn = (int)15e4+111;\n    int n,m,k;\n    int a[] = new int[maxn];\n    int b[] = new int[maxn];\n\n    void solve() throws Exception {\n        n = in.nextInt();\n        HashSet<Integer> divs = new HashSet<>();\n        for (int i=1; i<=n; i++) {\n            int left = in.nextInt();\n            int right = in.nextInt();\n            a[i] = left;\n            b[i] = right;\n        }\n\n        calcDivs(a[1], divs);\n        calcDivs(b[1], divs);\n        divs.add(a[1]);\n        divs.add(b[1]);\n\n        for (Integer val : divs) {\n            boolean ok = true;\n            for (int i=1; i<=n; i++) {\n                if (a[i]%val!=0 && b[i]%val!=0) {\n                    ok = false;\n                }\n            }\n            if (ok) {\n                out.println(val);\n                return;\n            }\n        }\n\n        out.println(-1);\n    }\n\n    private void calcDivs(int val, HashSet<Integer> divs) {\n        int until = (int)Math.sqrt(val);\n        for (int i=2; i<=until+10; i++) {\n            if (val%i==0) {\n                BigInteger temp1 = new BigInteger(String.valueOf(i));\n                BigInteger temp2 = new BigInteger(String.valueOf(val/i));\n                if (temp1.isProbablePrime(1000)) divs.add(i);\n                if (temp2.isProbablePrime(1000)) divs.add(val/i);\n            }\n        }\n    }\n\n    class Pair {\n        int x;\n        int y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n\n    String fileInName = \"\";\n\n    boolean file = false;\n    boolean isAcmp = false;\n\n    static Throwable throwable;\n    public static void main (String [] args) throws Throwable {\n        Thread thread = new Thread(null, new Main(), \"\", (1 << 26));\n        thread.start();\n        thread.join();\n        thread.run();\n        if (throwable != null)\n            throw throwable;\n    }\n\n    FastReader in;\n    PrintWriter out;\n\n    public void run() {\n        String fileIn = \"absum.in\";\n        String fileOut = \"absum.out\";\n\n        try {\n            if (isAcmp) {\n                if (file) {\n                    in = new FastReader(new BufferedReader(new FileReader(fileIn)));\n                    out = new PrintWriter (fileOut);\n                } else {\n                    in = new FastReader(new BufferedReader(new InputStreamReader(System.in)));\n                    out = new PrintWriter(System.out);\n                }\n            } else if (file) {\n                in = new FastReader(new BufferedReader(new FileReader(fileInName+\".in\")));\n                out = new PrintWriter (fileInName + \".out\");\n            } else {\n                in = new FastReader(new BufferedReader(new InputStreamReader(System.in)));\n                out = new PrintWriter(System.out);\n            }\n\n            solve();\n        } catch(Exception e) {\n            throwable = e;\n        } finally {\n            out.close();\n        }\n\n    }\n\n\n}\n\nclass FastReader {\n    BufferedReader bf;\n    StringTokenizer tk = null;\n\n    public FastReader(BufferedReader bf) {\n        this.bf = bf;\n    }\n\n    public String nextToken () throws Exception {\n        if (tk==null || !tk.hasMoreTokens()) {\n            tk = new StringTokenizer(bf.readLine());\n        }\n        if (!tk.hasMoreTokens()) return nextToken();\n        else\n            return tk.nextToken();\n    }\n\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\ninline unsigned long long readl() {\n  unsigned long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nint power(int a, int b) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = ans * a;\n    b >>= 1;\n    a = a * a;\n  }\n  return ans;\n}\nint power_mod(int a, int b, int mod) {\n  a %= mod;\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % mod;\n    b >>= 1, a = (a * a) % mod;\n  }\n  return ans;\n}\nunsigned long long powerl(unsigned long long a, unsigned long long b) {\n  unsigned long long ans = 1ll;\n  while (b) {\n    if (b & 1ll) ans = ans * a;\n    b >>= 1ll;\n    a = a * a;\n  }\n  return ans;\n}\nunsigned long long power_modl(unsigned long long a, unsigned long long b,\n                              unsigned long long mod) {\n  a %= mod;\n  unsigned long long ans = 1ll;\n  while (b) {\n    if (b & 1ll) ans = (ans * a) % mod;\n    b >>= 1ll, a = (a * a) % mod;\n  }\n  return ans;\n}\nunsigned long long gcdl(unsigned long long a, unsigned long long b) {\n  return b == 0 ? a : gcdl(b, a % b);\n}\nunsigned long long abssl(unsigned long long a) { return a > 0 ? a : -a; }\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\nint abss(int a) { return a > 0 ? a : -a; }\ninline int read();\ninline unsigned long long readl();\nint power(int a, int b);\nint power_mod(int a, int b, int mod);\nint gcd(int a, int b);\nint abssl(int a);\nunsigned long long powerl(unsigned long long a, unsigned long long b);\nunsigned long long power_modl(unsigned long long a, unsigned long long b,\n                              unsigned long long mod);\nunsigned long long gcdl(unsigned long long a, unsigned long long b);\nunsigned long long abssl(unsigned long long a);\nunsigned long long n, a[150000 + 5], b[150000 + 5];\nset<unsigned long long> s;\nvoid gg(unsigned long long x) {\n  if (x != 1ull) s.insert(x);\n  for (unsigned long long i = 2ull; i * i <= x; i++) {\n    if (x % i == 0ull) {\n      s.insert(i);\n      while (x % i == 0ull) x /= i;\n    }\n  }\n  if (x != 1ull) s.insert(x);\n}\nint main() {\n  cin >> n;\n  for (unsigned long long i = 1ull; i <= n; i++) cin >> a[i] >> b[i];\n  gg(a[1ull]), gg(b[1ull]);\n  for (set<unsigned long long>::iterator it = s.begin(); it != s.end(); it++) {\n    unsigned long long fa = *it, fl = 0ull;\n    for (unsigned long long i = 2ull; i <= n; i++) {\n      if ((a[i] % fa != 0ull) && (b[i] % fa != 0ull)) {\n        fl = 1ull;\n        break;\n      }\n    }\n    if (fl)\n      continue;\n    else\n      return cout << fa, 0;\n  }\n  return cout << -1, 0;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\nn=int(input())\nAr=[[None, None] for _ in range(n)]\nfor i in range(n):\n    Ar[i][0],Ar[i][1]=map(int,input().split())\n# A=[y for x,y in Ar]\n# A.sort()\nA=prime_factors(Ar[0][0])\nfor x in prime_factors(Ar[0][1]):\n    A.append(x)\nA=list(set(A))\ncnt=0\nfor j in A:\n    for i in range(n):\n        if Ar[i][0]%j==0 or Ar[i][1]%j==0:\n            cnt+=1\n        if cnt!=i+1:\n            cnt=0\n            break\n#         print(cnt)\n    if cnt==n:\n        print(j)\n        break\nif cnt==0:\n    print(-1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Union {\n  vector<int> p, s;\n  Union(int x) {\n    p.resize(x + 1, 0);\n    s.resize(x + 1, 1);\n    for (int j = 1; j <= x; j++) p[j] = j;\n  }\n  int parent(int u) {\n    if (u == p[u]) return u;\n    return (p[u] = parent(p[u]));\n  }\n  bool merge(int u, int v) {\n    int p1 = parent(u), p2 = parent(v);\n    if (p1 == p2) return 0;\n    if (s[p1] > s[p2]) swap(p1, p2);\n    s[p2] += s[p1];\n    p[p1] = p2;\n    return 1;\n  }\n};\nvector<int> primes(long long int x) {\n  vector<int> ans;\n  for (int j = 2; j * j <= x; j++) {\n    if (x % j == 0) {\n      ans.push_back(j);\n      while (x % j == 0) x /= j;\n    }\n  }\n  if (x != 1) ans.push_back(x);\n  return ans;\n}\nint main() {\n  ios_base ::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  scanf(\"%d\", &n);\n  vector<pair<long long int, long long int> > v(n);\n  for (int j = 0; j < n; j++) scanf(\"%lld %lld\", &v[j].first, &v[j].second);\n  vector<int> ans = primes(v[0].first);\n  vector<int> t = primes(v[0].second);\n  for (auto i : t) ans.push_back(i);\n  for (auto i : ans) {\n    bool fg = 0;\n    for (int j = 1; j < n; j++) {\n      if (v[j].first % i == 0 || v[j].second % i == 0)\n        continue;\n      else {\n        fg = 1;\n        break;\n      }\n    }\n    if (fg) continue;\n    cout << i << endl;\n    return 0;\n  }\n  cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import math\n\nn = int(raw_input())\nx,y = [int(r) for r in raw_input().split()]\n\nL = set()\nwhile x > 1:\n    for p in xrange(2,int(math.ceil(math.sqrt(x)))+1):\n        if x % p == 0:\n            L.add(p)\n            while x % p == 0:\n                x /= p\n            continue\n    L.add(x)\n    break\nwhile y > 1:\n    for p in xrange(2,int(math.ceil(math.sqrt(y)))+1):\n        if y % p == 0:\n            L.add(p)\n            while y % p == 0:\n                y /= p\n            continue\n    L.add(y)\n    break\nif 1 in L:\n    L.remove(1)\nif len(L) == 0:\n    print \"-1\"\n    exit()\n\nfor i in xrange(n-1):\n    x,y = [int(r) for r in raw_input().split()]\n    L_new = set()\n    for p in L:\n        if x % p == 0 or y % p == 0:\n            L_new.add(p)\n    L = L_new\n    if len(L) == 0:\n        print \"-1\"\n        exit()\nprint L.pop()\n"
        },
        {
            "language": 3,
            "solution": "from math import gcd\n\nn = int(input())\na = [tuple(map(int, input().split())) for i in range(n)]\n\nres = 0\nfor x, y in a:\n    res = gcd(res, x*y)\n    \nfor x, y in a:\n    if gcd(res, x)>1:\n        res = gcd(res, x)\n    else:\n        res = gcd(res, y)\n        \nprint(-1 if res==1 else res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 2e5 + 1;\nint n, tot, Tot;\nint a[MAX], b[MAX], pm[MAX], Pm[MAX];\nbool use[MAX];\nbool ss(int x) {\n  if (x == 2) return 1;\n  int m = sqrt(x);\n  for (int i = 2; i <= m; ++i)\n    if (x % i == 0) return 0;\n  return 1;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d%d\", &a[i], &b[i]);\n  int A1, B1, Gcd = max(A1 = sqrt(a[1]), B1 = sqrt(b[1]));\n  for (int i = 2; i <= Gcd; ++i) {\n    if (!use[i]) {\n      pm[++tot] = i;\n      if (a[1] % i == 0 || b[1] % i == 0) Pm[++Tot] = i;\n    }\n    for (int j = 1; j <= tot && pm[j] * i <= Gcd; ++j) {\n      use[i * pm[j]] = 1;\n      if (i % pm[j] == 0) break;\n    }\n  }\n  int Num = Tot;\n  for (int i = 2; i <= A1; ++i)\n    if (a[1] % i == 0 && ss(a[1] / i)) Pm[++Tot] = a[1] / i;\n  for (int i = 2; i <= B1; ++i)\n    if (b[1] % i == 0 && ss(b[1] / i)) Pm[++Tot] = b[1] / i;\n  if (ss(a[1])) Pm[++Tot] = a[1];\n  if (ss(b[1])) Pm[++Tot] = b[1];\n  for (int i = 1; i <= Tot; ++i) {\n    bool fl = 0;\n    for (int j = 2; j <= n; ++j)\n      if (a[j] % Pm[i] && b[j] % Pm[i]) {\n        fl = 1;\n        break;\n      }\n    if (!fl) return printf(\"%d\", Pm[i]), 0;\n  }\n  return printf(\"-1\"), 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import gcd\n\nn = int(input())\na = [tuple(map(int, input().split())) for i in range(n)]\n\nans = 0\nfor x,y in a:\n    ans = gcd(x*y,ans)\n\nfor x, y in a:\n    if gcd(ans, x) > 1:\n        ans = gcd(ans, x)\n    else:\n        ans = gcd(ans, y)\n\nprint(-1 if ans == 1 else ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nvoid read(int &x);\nvoid read(int &x);\nusing namespace std;\nconst int MAX = 150000 + 5;\nconst int INF = 0x3f3f3f3f;\nlong long MOD = 1000000000 + 7;\nlong long n, m, k, t;\nint a[MAX];\nint b[MAX];\nint pri[110000], len;\nint gcd(int a, int b) { return b ? a : gcd(b, a % b); }\nset<int> s;\nvoid slove(int x) {\n  for (int i = 2; i <= sqrt(x + 0.5); i++)\n    if (x % i == 0) {\n      if (s.find(i) == s.end()) pri[++len] = i, s.insert(i);\n      while (x % i == 0) x /= i;\n    }\n  if (x != 1 && s.find(x) == s.end()) pri[++len] = x, s.insert(x);\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    read(a[i]);\n    read(b[i]);\n  }\n  slove(a[1]);\n  slove(b[1]);\n  for (int i = 1; i <= len; i++) {\n    bool flag = 1;\n    for (int j = 1; j <= n; j++) {\n      if (a[j] % pri[i] == 0 || b[j] % pri[i] == 0) continue;\n      flag = 0;\n      break;\n    }\n    if (flag) {\n      printf(\"%d\\n\", pri[i]);\n      return 0;\n    }\n  }\n  printf(\"-1\\n\");\n  return 0;\n}\nvoid read(int &x) {\n  int f = 1;\n  x = 0;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  x *= f;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n \npublic class Main\n{\n    static final int oo=Integer.MAX_VALUE;\n\n    static boolean can_divide_all(int num,int arr[][],int n){\n        if(num==1) return  false;\n\n        boolean ret=true;\n        for(int i=1;i<=n;i++)\n            ret=ret && (arr[i][0]%num==0 || arr[i][1]%num==0);\n        return ret;\n    }\n\n    public static void process()throws IOException\n    {\n        int n=ni();\n        int arr[][]=new int[n+1][2];\n\n        for(int i=1;i<=n;i++){\n            arr[i][0]=ni();\n            arr[i][1]=ni();\n        }        \n\n        int num=arr[1][0];\n        \n         if(num%2==0){\n            if(can_divide_all(2,arr,n)){\n                pn(2);\n                return ;\n            }\n            while(num%2==0)\n                num/=2;\n        }\n\n        for(int i=3;i<=Math.sqrt(num);i+=2){\n            if(num%i!=0)\n                continue;\n\n            if(can_divide_all(i,arr,n)){\n                pn(i);\n                return ;\n            }\n            \n            while(num%i==0)num/=i;\n        }\n\n        if(num>2){\n            if(can_divide_all(num,arr,n)){\n                pn(num);\n                return ;\n            }\n        }\n\n        num=arr[1][1];\n\n        if(num%2==0){\n            if(can_divide_all(2,arr,n)){\n                pn(2);\n                return ;\n            }\n            while(num%2==0)\n                num/=2;\n        }\n\n        for(int i=3;i<=Math.sqrt(num);i+=2){\n            if(num%i!=0)\n                continue;\n\n            if(can_divide_all(i,arr,n)){\n                pn(i);\n                return ;\n            }\n            while(num%i==0) num/=i;\n        }\n\n        if(num>2){\n            if(can_divide_all(num,arr,n)){\n                pn(num);\n                return ;\n            }\n        }\n\n        pn(-1);\n    }\n \n \n    static FastReader sc;\n    static PrintWriter out;\n    public static void main(String[]args)throws IOException\n    {\n        out = new PrintWriter(System.out);\n        sc=new FastReader();\n \n        long s = System.currentTimeMillis();\n        int t=1;\n        //t=ni();\n        while(t-->0)\n            process();\n \n        out.flush();\n        System.err.println(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    \n    static void pn(Object o){out.println(o);}\n    static void p(Object o){out.print(o);}\n    static int ni()throws IOException{return Integer.parseInt(sc.next());}\n    static long nl()throws IOException{return Long.parseLong(sc.next());}\n    static double nd()throws IOException{return Double.parseDouble(sc.next());}\n    static String nln()throws IOException{return sc.nextLine();}\n    static long gcd(long a, long b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int gcd(int a, int b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int bit(long n)throws IOException{return (n==0)?0:(1+bit(n&(n-1)));}\n    \n    static long mod=(long)1e9+7l;\n \n    static<T> void r_sort(T arr[],int n){\n        Random r = new Random(); \n        for (int i = n-1; i > 0; i--){ \n            int j = r.nextInt(i+1); \n                  \n            T temp = arr[i]; \n            arr[i] = arr[j]; \n            arr[j] = temp; \n        } \n        Arrays.sort(arr); \n    }\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n    static class FastReader{ \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader(){ \n            br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n  \n        String next(){ \n            while (st == null || !st.hasMoreElements()){ \n                try{ st = new StringTokenizer(br.readLine()); } catch (IOException  e){ e.printStackTrace(); } \n            } \n            return st.nextToken(); \n        } \n  \n        String nextLine(){ \n            String str = \"\"; \n            try{ str = br.readLine(); } catch (IOException e) { e.printStackTrace(); } \n            return str; \n        } \n    } \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Set;\n\npublic class ProblemB {\n\n    public static void main(String[] args) {\n        new ProblemSolver().solve();\n    }\n\n    private static class ProblemSolver {\n\n        public void solve() {\n            String inputString = \"\";\n            InputReader reader = new InputReader(\n                    inputString.isEmpty() ? System.in : new ByteArrayInputStream(inputString.getBytes()));\n            OutputWriter writer = new OutputWriter(System.out);\n\n            solve(reader, writer);\n\n            writer.flush();\n            writer.close();\n        }\n\n        private void solve(InputReader reader, OutputWriter writer) {\n            int t;\n            t = 1;\n            while (t-- > 0) {\n                solveTestCase(reader, writer);\n            }\n        }\n\n        private int n;\n        private Pair[] pairs;\n\n        private void solveTestCase(InputReader reader, OutputWriter writer) {\n            /*Code*/\n            n = reader.nextInt();\n            pairs = new Pair[n];\n            for (int i = 0; i < n; i++) {\n                pairs[i] = new Pair();\n                pairs[i].a = reader.nextLong();\n                pairs[i].b = reader.nextLong();\n            }\n\n            if (n == 1) {\n                writer.println(pairs[0].a);\n            } else {\n                Set<Long> primeComponents = findPrimeComponents(pairs[0].a);\n                primeComponents.addAll(findPrimeComponents(pairs[0].b));\n\n                long ans = -1;\n                for (long prime : primeComponents) {\n                    boolean canDivideAllPairs = true;\n                    for (int i = 1; i < n; i++) {\n                        if (pairs[i].a % prime != 0) {\n                            if (pairs[i].b % prime != 0) {\n                                canDivideAllPairs = false;\n                            }\n                        }\n                    }\n                    if (canDivideAllPairs) {\n                        ans = prime;\n                        break;\n                    }\n                }\n                writer.println(ans);\n            }\n        }\n\n        private Set<Long> findPrimeComponents(long n) {\n            Set<Long> primeComponents = new HashSet<>();\n\n            long maxN = n;\n            for (long i = 2; i * i <= maxN; i++) {\n                if (n % i == 0) {\n                    primeComponents.add(i);\n                    n = n / i;\n                    while (n % i == 0) {\n                        n = n / i;\n                    }\n                }\n            }\n            if (n > 1) {\n                primeComponents.add(n);\n            }\n\n            return primeComponents;\n        }\n\n        private static class Pair {\n            private long a;\n            private long b;\n        }\n\n        private static class InputReader {\n\n            private static final int BUFFER_SIZE_IN_BYTES = 1024;\n\n            private InputStream stream;\n            private byte[] buffer = new byte[BUFFER_SIZE_IN_BYTES];\n            private int nextPositionInBuffer;\n            private int numberOfBytesInBuffer;\n\n            public InputReader(InputStream stream) {\n                this.stream = stream;\n            }\n\n            public int read() {\n                if (numberOfBytesInBuffer == -1) {\n                    throw new InputMismatchException();\n                }\n                if (nextPositionInBuffer >= numberOfBytesInBuffer) {\n                    fillBuffer();\n                    if (numberOfBytesInBuffer <= 0) {\n                        return -1;\n                    }\n                }\n                return buffer[nextPositionInBuffer++];\n            }\n\n            public int peek() {\n                if (numberOfBytesInBuffer == -1) {\n                    return -1;\n                }\n                if (nextPositionInBuffer >= numberOfBytesInBuffer) {\n                    try {\n                        fillBuffer();\n                    } catch (InputMismatchException e) {\n                        return -1;\n                    }\n                    if (numberOfBytesInBuffer <= 0) {\n                        return -1;\n                    }\n                }\n                return buffer[nextPositionInBuffer];\n            }\n\n            private int fillBuffer() {\n                nextPositionInBuffer = 0;\n                try {\n                    return (numberOfBytesInBuffer = stream.read(buffer));\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n            }\n\n            public char nextChar() {\n                int c = read();\n                while (isSpaceChar(c)) {\n                    c = read();\n                }\n                return (char) c;\n            }\n\n            public int nextInt() {\n                int c = read();\n                while (isSpaceChar(c)) {\n                    c = read();\n                }\n                int sgn = 1;\n                if (c == '-') {\n                    sgn = -1;\n                    c = read();\n                }\n                int res = 0;\n                do {\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    res *= 10;\n                    res += c - '0';\n                    c = read();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n            }\n\n            public long nextLong() {\n                int c = read();\n                while (isSpaceChar(c)) {\n                    c = read();\n                }\n                int sgn = 1;\n                if (c == '-') {\n                    sgn = -1;\n                    c = read();\n                }\n                long res = 0;\n                do {\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    res *= 10;\n                    res += c - '0';\n                    c = read();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n            }\n\n            public double nextDouble() {\n                int c = read();\n                while (isSpaceChar(c)) {\n                    c = read();\n                }\n                int sgn = 1;\n                if (c == '-') {\n                    sgn = -1;\n                    c = read();\n                }\n                double res = 0;\n                while (!isSpaceChar(c) && c != '.') {\n                    if (c == 'e' || c == 'E') {\n                        return res * Math.pow(10, nextInt());\n                    }\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    res *= 10;\n                    res += c - '0';\n                    c = read();\n                }\n                if (c == '.') {\n                    c = read();\n                    double m = 1;\n                    while (!isSpaceChar(c)) {\n                        if (c == 'e' || c == 'E') {\n                            return res * Math.pow(10, nextInt());\n                        }\n                        if (c < '0' || c > '9') {\n                            throw new InputMismatchException();\n                        }\n                        m /= 10;\n                        res += (c - '0') * m;\n                        c = read();\n                    }\n                }\n                return res * sgn;\n            }\n\n            public BigInteger nextBigInteger() {\n                try {\n                    return new BigInteger(nextString());\n                } catch (NumberFormatException e) {\n                    throw new InputMismatchException();\n                }\n            }\n\n            public String nextLine() {\n                String s = readLineWithoutAnyTrimming();\n                while (s.trim().length() == 0) {\n                    s = readLineWithoutAnyTrimming();\n                }\n                return s;\n            }\n\n            private String readLineWithoutAnyTrimming() {\n                StringBuilder buf = new StringBuilder();\n                int c = read();\n                while (c != '\\n' && c != -1) {\n                    if (c != '\\r') {\n                        buf.appendCodePoint(c);\n                    }\n                    c = read();\n                }\n                return buf.toString();\n            }\n\n            public String next() {\n                return nextString();\n            }\n\n            private String nextString() {\n                int c = read();\n                while (isSpaceChar(c)) {\n                    c = read();\n                }\n                StringBuilder res = new StringBuilder();\n                do {\n                    if (Character.isValidCodePoint(c)) {\n                        res.appendCodePoint(c);\n                    }\n                    c = read();\n                } while (!isSpaceChar(c));\n                return res.toString();\n            }\n\n            public boolean isExhausted() {\n                int value;\n                while (isSpaceChar(value = peek()) && value != -1) {\n                    read();\n                }\n                return value == -1;\n            }\n\n            private boolean isSpaceChar(int c) {\n                return isWhitespace(c);\n            }\n\n            private boolean isWhitespace(int c) {\n                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n            }\n\n        }\n\n        private static class OutputWriter {\n\n            private final PrintWriter writer;\n\n            public OutputWriter(OutputStream outputStream) {\n                writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n            }\n\n            public OutputWriter(Writer writer) {\n                this.writer = new PrintWriter(writer);\n            }\n\n            public void print(char i) {\n                writer.print(i);\n            }\n\n            public void println(char i) {\n                writer.println(i);\n            }\n\n            public void print(int i) {\n                writer.print(i);\n            }\n\n            public void println(int i) {\n                writer.println(i);\n            }\n\n            public void print(long i) {\n                writer.print(i);\n            }\n\n            public void println(long i) {\n                writer.println(i);\n            }\n\n            public void print(char[] array) {\n                writer.print(array);\n            }\n\n            public void print(int[] array) {\n                for (int i = 0; i < array.length; i++) {\n                    if (i != 0) {\n                        writer.print(' ');\n                    }\n                    writer.print(array[i]);\n                }\n            }\n\n            public void print(long[] array) {\n                for (int i = 0; i < array.length; i++) {\n                    if (i != 0) {\n                        writer.print(' ');\n                    }\n                    writer.print(array[i]);\n                }\n            }\n\n            public void print(double[] array) {\n                for (int i = 0; i < array.length; i++) {\n                    if (i != 0) {\n                        writer.print(' ');\n                    }\n                    writer.print(array[i]);\n                }\n            }\n\n            public void println(char[] array) {\n                writer.println(array);\n            }\n\n            public void println(int[] array) {\n                print(array);\n                writer.println();\n            }\n\n            public void println(long[] array) {\n                print(array);\n                writer.println();\n            }\n\n            public void println(double[] array) {\n                print(array);\n                writer.println();\n            }\n\n            public void println() {\n                writer.println();\n            }\n\n            public void print(Object... objects) {\n                for (int i = 0; i < objects.length; i++) {\n                    if (i != 0) {\n                        writer.print(' ');\n                    }\n                    writer.print(objects[i]);\n                }\n            }\n\n            public void println(Object... objects) {\n                print(objects);\n                writer.println();\n            }\n\n            public void printf(String format, Object... objects) {\n                writer.printf(format, objects);\n            }\n\n            public void close() {\n                writer.close();\n            }\n\n            public void flush() {\n                writer.flush();\n            }\n\n        }\n\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import sqrt\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na, b = map(int,input().split())\ndiva = set()\ndivb = set()\nfor i in range(2, int(sqrt(a))+1):\n    if a % i == 0:\n        while a % i == 0:\n            a //= i\n        diva.add(i)\nif a > 1:\n    diva.add(a)\nfor i in range(2, int(sqrt(b))+1):\n    if b % i == 0:\n        while b % i == 0:\n            b //= i\n        divb.add(i)\nif b > 1:\n    divb.add(b)\nalldiv = diva | divb\nfor _ in range(n-1):\n    e, q = map(int,input().split())\n    trash = []\n    for k in alldiv:\n        if e % k != 0 and q % k != 0:\n            trash.append(k)\n    for k in trash:\n        alldiv.remove(k)\nres = list(alldiv)\nif len(res) == 0:\n    print(-1)\nelse:\n    print(res[0])"
        },
        {
            "language": 3,
            "solution": "def d(x):\n    for dl in range(2,int(x**0.5)+1):\n        if x % dl == 0:\n            return(dl)\n    return (x)\n\ndef gcd(a,b):\n    return a if b==0 else gcd(b,a%b)\n\n\nn=int(input())\na,b=map(int,input().split())\nfor i in range(n-1):\n    an,bn=map(int,input().split())\n    a,b=gcd(an*bn,a),gcd(an*bn,b)\nif a>1:\n    print(d(a))\nelif b>1:\n    print(d(b))\nelse:\n    print(-1)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B\n{\n\tstatic StringBuilder st = new StringBuilder() ; \n\t\n\tpublic static void main(String[] args) throws Exception \n\t{\n\t\tScanner sc = new Scanner(System.in) ; \n\t\tPrintWriter out = new PrintWriter(System.out) ; \n\t\t\n\t\tint n = sc.nextInt() ; \n\t\tint [] a = new int [n] ; \n\t\tint [] b = new int [n] ; \n\t\tHashSet<Integer> factors = new HashSet<>() ; \n\t\t\n\t\tfor(int i = 0 ;i < n ;i++)\n\t\t{\n\t\t\ta[i] = sc.nextInt() ; \n\t\t\tb[i] = sc.nextInt() ; \n\t\t\tif(i == 0)\n\t\t\t\tfactors = primeFactors(a[0], b[0]) ;\n\t\t}\n\t\t\n\t\tint ans = -1 ; \n\t\t\n\t\touter : \n\t\tfor(int p : factors)\n\t\t{\n\t\t\t\n\t\t\tfor(int i = 0 ; i < n ;i++)\n\t\t\t\tif(a[i] % p != 0 && b[i] % p != 0)\n\t\t\t\t\tcontinue outer ; \n\t\t\t\n\t\t\tans = p ; break; \n\t\t}\t\t\t\n\t\t\n\t\tout.println(ans);\n\t\tout.flush();\n\t\tout.close(); \n\t}\n\t\n\tstatic HashSet<Integer> primeFactors(int a , int b)\n\t{\n\t\tHashSet<Integer> factors = new HashSet<Integer> () ; \n\t\t\n\t\tfor(int i = 2 ;1l * i * i <= a ;i++)\n\t\t{\n\t\t\tif(a % i != 0) continue ; \n\t\t\t\n\t\t\twhile(a % i == 0) a /= i ;\n\t\t\t\n\t\t\tfactors.add(i);\n\t\t}\n\t\tif(a > 1)\n\t\t\tfactors.add(a) ; \n\t\t\n\t\tfor(int i = 2 ;1l * i * i <= b ;i++)\n\t\t{\n\t\t\tif(b % i != 0) continue ; \n\t\t\twhile(b % i == 0) b /= i ;\n\t\t\t\n\t\t\tfactors.add(i);\n\t\t}\n\t\tif(b > 1)\n\t\t\tfactors.add(b) ; \n\t\t\n\t\treturn factors ; \n\t}\n\t\n\tstatic class Scanner\n\t{\n\t\tBufferedReader br ; \n\t\tStringTokenizer st ;\n\t\t\n\t\tScanner(InputStream in)\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(in)) ; \n\t\t}\n\t\t\n\t\tScanner (String path) throws Exception\n\t\t{\n\t\t\tbr = new BufferedReader(new FileReader(path)) ; \n\t\t}\n\t\t\n\t\tString next() throws Exception\n\t\t{\n\t\t\twhile(st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine()) ; \n\t\t\treturn st.nextToken() ; \n\t\t}\n\t\t\n\t\tint nextInt() throws Exception { return Integer.parseInt(next());}\n\t\t\n\t\tlong nextLong() throws Exception {return Long.parseLong(next()) ;}\n\t\t\n\t\tdouble nextDouble() throws Exception { return Double.parseDouble(next()) ;}\n\t}\n\t\n\tstatic void shuffle(int [] a)\n\t{\n\t\tint n = a.length ; \n\t\tfor(int i = 0 ;i  < n ; i++)\n\t\t{\n\t\t\tint r = i + (int) (Math.random() * (n - i)) ;\n\t\t\tint temp = a[r] ; \n\t\t\ta[r] = a[i] ; \n\t\t\ta[i] = temp  ; \n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\n/**\n * Created by timur on 28.03.15.\n */\n\npublic class TaskB {\n    boolean eof;\n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n\n    public static void main(String[] args) throws IOException {\n        new TaskB().run();\n    }\n\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return \"-1\";\n            }\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextLine() throws IOException {\n        return br.readLine();\n    }\n\n\n    void run() throws IOException {\n        InputStream input = System.in;\n        PrintStream output = System.out;\n        try {\n            File f = new File(\"a.in\");\n            if (f.exists() && f.canRead()) {\n                input = new FileInputStream(f);\n                output = new PrintStream(\"a.out\");\n            }\n        } catch (Throwable e) {\n        }\n        br = new BufferedReader(new InputStreamReader(input));\n        out = new PrintWriter(output);\n        solve();\n        br.close();\n        out.close();\n    }\n\n    int gcd (int a, int b) {\n        if (b == 0)\n            return a;\n        else\n            return gcd (b, a % b);\n    }\n\n    List<Integer> fact(int x) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= Math.sqrt(x) + 1; i++) {\n            if (x % i == 0) {\n                result.add(i);\n                result.add(x / i);\n            }\n        }\n        return result;\n    }\n\n    boolean notFact(int a, int b, int c) {\n        return (a % c != 0 && b % c != 0);\n    }\n\n    void kick(Set<Integer> set, int x, int y) {\n        set.removeIf(it -> notFact(x, y, it));\n    }\n\n\n    void solve() {\n        int n = nextInt();\n        HashSet<Integer> ans = new HashSet<>(), nans;\n        int x = nextInt(), y = nextInt(), a, b;\n        ans.add(x);\n        ans.add(y);\n        for (int i = 1; i < n; i++) {\n            x = nextInt();\n            y = nextInt();\n            nans = new HashSet<>();\n            for (Integer ch : ans) {\n                a = gcd(ch, x);\n                b = gcd(ch, y);\n                nans.remove(ch);\n                if (!(a == 1 && b == 1)) {\n                    if (a == gcd(a, b)) {\n                        nans.add(b);\n                    } else if (b == gcd(a, b)) {\n                        nans.add(a);\n                    } else {\n                        nans.add(a);\n                        nans.add(b);\n                    }\n                }\n                ans = nans;\n            }\n        }\n        if (ans.isEmpty()) {\n            out.print(\"-1\");\n        } else {\n            out.print(ans.iterator().next());\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\n/**\n * Created by timur on 28.03.15.\n */\n\npublic class TaskB {\n    boolean eof;\n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n\n    public static void main(String[] args) throws IOException {\n        new TaskB().run();\n    }\n\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return \"-1\";\n            }\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextLine() throws IOException {\n        return br.readLine();\n    }\n\n\n    void run() throws IOException {\n        InputStream input = System.in;\n        PrintStream output = System.out;\n        try {\n            File f = new File(\"a.in\");\n            if (f.exists() && f.canRead()) {\n                input = new FileInputStream(f);\n                output = new PrintStream(\"a.out\");\n            }\n        } catch (Throwable e) {\n        }\n        br = new BufferedReader(new InputStreamReader(input));\n        out = new PrintWriter(output);\n        solve();\n        br.close();\n        out.close();\n    }\n\n    int gcd (int a, int b) {\n        if (b == 0)\n            return a;\n        else\n            return gcd (b, a % b);\n    }\n\n    List<Integer> fact(int x) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= Math.sqrt(x) + 1; i++) {\n            if (x % i == 0) {\n                result.add(i);\n                result.add(x / i);\n            }\n        }\n        return result;\n    }\n\n    boolean notFact(int a, int b, int c) {\n        return (a % c != 0 && b % c != 0);\n    }\n\n    void kick(Set<Integer> set, int x, int y) {\n        set.removeIf(it -> notFact(x, y, it));\n    }\n\n\n    void solve() {\n        int n = nextInt();\n        HashSet<Integer> ans = new HashSet<>(), nans;\n        int x = nextInt(), y = nextInt(), a, b;\n        ans.add(x);\n        ans.add(y);\n        for (int i = 1; i < n; i++) {\n            x = nextInt();\n            y = nextInt();\n            nans = new HashSet<>();\n            for (Integer ch : ans) {\n                a = gcd(ch, x);\n                b = gcd(ch, y);\n                //nans.remove(ch);\n                if (!(a == 1 && b == 1)) {\n                    if (a == gcd(a, b)) {\n                        nans.add(b);\n                    } else if (b == gcd(a, b)) {\n                        nans.add(a);\n                    } else {\n                        nans.add(a);\n                        nans.add(b);\n                    }\n                }\n            }\n            ans = nans;\n        }\n        if (ans.isEmpty()) {\n            out.print(\"-1\");\n        } else {\n            out.print(ans.iterator().next());\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nfrom math import gcd\n\n\ndef main():\n    input()\n    pp = set()\n    for a in map(int, set(input().split())):\n        for p in 2, 3, 5:\n            if not a % p:\n                pp.add(p)\n                while not a % p:\n                    a //= p\n        p = 7\n        while a >= p * p:\n            for s in 4, 2, 4, 2, 4, 6, 2, 6:\n                pp.add(p)\n                while not a % p:\n                    a //= p\n                p += s\n        if a > 1:\n            pp.add(a)\n    for s in stdin.read().splitlines():\n        a, b = map(int, s.split())\n        pp = {p for p in pp if not (a % p and b % p)}\n        if not pp:\n            print(-1)\n            return\n    print(max(pp))\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  long long x;\n  long long y;\n} A[150005];\nset<long long> s;\nint main() {\n  int n;\n  cin >> n;\n  long long a, b;\n  cin >> a >> b;\n  for (int i = 2; i * i <= a; i++) {\n    if (a % i == 0) s.insert(i);\n    while (a % i == 0) a /= i;\n  }\n  if (a > 1) s.insert(a);\n  for (int i = 2; i * i <= b; i++) {\n    if (b % i == 0) {\n      s.insert(i);\n    }\n    while (b % i == 0) b /= i;\n  }\n  if (b > 1) s.insert(b);\n  for (int i = 1; i < n; i++) cin >> A[i].x >> A[i].y;\n  set<long long>::iterator iter = s.begin();\n  int ans = -1;\n  for (; iter != s.end(); iter++) {\n    int flag = 1;\n    long long temp = (*iter);\n    for (int i = 1; i < n; i++)\n      if (A[i].x % temp != 0 && A[i].y % temp != 0) {\n        flag = 0;\n        break;\n      }\n    if (flag) {\n      ans = temp;\n      break;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakhar897\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        Task505A solver = new Task505A();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Task505A {\n        TreeSet<Long> hs = new TreeSet<Long>();\n\n        public void prime(long n) {\n            hs.add(n);\n            while (n % 2 == 0) {\n                hs.add((long) 2);\n                n /= 2;\n            }\n\n            for (long i = 3; i <= Math.sqrt(n); i += 2) {\n                while (n % i == 0) {\n                    hs.add(i);\n                    n /= i;\n                }\n            }\n\n            if (n > 2)\n                hs.add(n);\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            long mat[][] = new long[n][2];\n            int i;\n\n            for (i = 0; i < n; i++) {\n                mat[i][0] = in.nextLong();\n                mat[i][1] = in.nextLong();\n            }\n\n            if (n == 1) {\n                out.println(mat[0][0]);\n                return;\n            }\n\n            prime(mat[0][0]);\n            prime(mat[0][1]);\n            //out.println(hs);\n            for (long s : hs) {\n                for (i = 1; i < n; i++) {\n                    if (mat[i][0] % s == 0 || mat[i][1] % s == 0) {\n                        if (i == n - 1) {\n                            out.println(s);\n                            return;\n                        }\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            out.println(\"-1\");\n            return;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 150005;\nint n, i;\nlong long z, a, b, c;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\ninline bool isp(int x) {\n  if (x < 2) return 0;\n  for (int i = 2; i * i <= x; ++i)\n    if (x % i == 0) return 0;\n  return 1;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  for (i = 1; i <= n; ++i) {\n    cin >> a >> b;\n    z = gcd(z, 1ll * a / gcd(a, b) * b);\n  }\n  if (z == 1) {\n    cout << \"-1\";\n    return 0;\n  }\n  if (isp(a) && z % a == 0) {\n    cout << a << '\\n';\n    return 0;\n  }\n  if (isp(b) && z % b == 0) {\n    cout << b << '\\n';\n    return 0;\n  }\n  c = max(a, b);\n  vector<int> zz;\n  for (i = 2; i * i <= c; ++i) {\n    if (z % i == 0) {\n      zz.push_back(i);\n    }\n    if (a / i > 1 && z % (a / i) == 0) {\n      zz.push_back(a / i);\n    }\n    if (b / i > 1 && z % (b / i) == 0) {\n      zz.push_back(b / i);\n    }\n  }\n  sort(zz.begin(), zz.end());\n  for (i = 0; i < zz.size(); ++i)\n    if (zz[i] > 1 && z % zz[i] == 0) break;\n  cout << zz[i];\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\nfrom math import gcd\n# ------------------------------\n\n\ndef main():\n    n = N()\n    lst = -1\n    rec = []\n\n    for _ in range(n):\n        a, b = RL()\n        rec.append((a, b))\n        g = gcd(a, b)\n        lcm = a*b//g\n        if lst!=-1:\n            lst = gcd(lst, lcm)\n        else:\n            lst = lcm\n\n    for a, b in rec:\n        now = gcd(lst, a)\n        if now>1: lst = now\n        else: lst = gcd(lst, b)\n\n    print(lst if lst!=1 else -1)\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BWeakenedCommonDivisor solver = new BWeakenedCommonDivisor();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BWeakenedCommonDivisor {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            long a = in.nextLong();\n            long b = in.nextLong();\n            long oldA = a;\n            long oldB = b;\n            long gcd = gcd(a, b);\n            long[] as = new long[n];\n            long[] bs = new long[n];\n            as[0] = a;\n            bs[0] = b;\n            a = divideByGcd(a, gcd);\n            b = divideByGcd(b, gcd);\n            long r = gcd * a * b;\n            for (int i = 1; i < n; i++) {\n                a = in.nextLong();\n                b = in.nextLong();\n                as[i] = a;\n                bs[i] = b;\n                gcd = gcd(a, b);\n                a = divideByGcd(a, gcd);\n                b = divideByGcd(b, gcd);\n                long cur = gcd * a * b;\n                r = gcd(cur, r);\n            }\n            long res = r;\n            for (int i = 0; i < n; i++) {\n                long gcdA = gcd(res, as[i]);\n                long gcdB = gcd(res, bs[i]);\n                if (gcdA > 1 && gcdA < res) {\n                    res = gcdA;\n                }\n                if (gcdB > 1 && gcdB < res) {\n                    res = gcdB;\n                }\n            }\n            if (res > 1) {\n                out.println(res);\n            } else {\n                out.println(-1);\n            }\n        }\n\n        private long divideByGcd(long a, long c) {\n            while (a % c == 0 && c > 1) {\n                a /= c;\n            }\n            return a;\n        }\n\n        long gcd(long a, long b) {\n            if (b > 0)\n                return gcd(b, a % b);\n            else\n                return a;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint a[N], hd;\nint c[N], d[N];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d\", &c[i], &d[i]);\n  }\n  for (int i = 2; i * i <= c[0]; i++) {\n    if (c[0] % i == 0) {\n      a[hd++] = i;\n      while (c[0] % i == 0) c[0] /= i;\n    }\n  }\n  if (c[0] != 1) a[hd++] = c[0];\n  for (int i = 2; i * i <= d[0]; i++) {\n    if (d[0] % i == 0) {\n      a[hd++] = i;\n      while (d[0] % i == 0) d[0] /= i;\n    }\n  }\n  if (d[0] != 1) a[hd++] = d[0];\n  for (int i = 0; i < hd; i++) {\n    int ok = 1;\n    for (int j = 1; j < n; j++) {\n      if (c[j] % a[i] == 0 || d[j] % a[i] == 0) continue;\n      ok = 0;\n    }\n    if (ok) {\n      printf(\"%d\\n\", a[i]);\n      return 0;\n    }\n  }\n  printf(\"-1\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) {\n    return a;\n  } else {\n    return gcd(b, a % b);\n  }\n}\nint main() {\n  long long n;\n  cin >> n;\n  vector<long long> v, a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n    long long t = a[i] / gcd(a[i], b[i]) * b[i];\n    v.push_back(t);\n  }\n  for (int i = 1; i < n; i++) {\n    v[i] = gcd(v[i - 1], v[i]);\n  }\n  if (v[n - 1] == 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  long long ans = v[n - 1];\n  for (int i = 0; i < n; i++) {\n    if (gcd(ans, a[i]) != 1) {\n      ans = gcd(ans, a[i]);\n    } else {\n      ans = gcd(ans, b[i]);\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python\nimport os\nimport sys\n\nfrom io import BytesIO, IOBase\n\n# Bootstrap https://github.com/cheran-senthil/PyRival/blob/master/tests/misc/test_bootstrap.py\nfrom types import GeneratorType\n\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\n\n#################\n\nfrom collections import defaultdict\nfrom math import sqrt\n\nINF = pow(2, 63)\n\n\ndef isPrime(number):\n    \"\"\"\n    input: positive integer 'number'\n    returns true if 'number' is prime otherwise false.\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and (\n            number >= 0\n    ), \"'number' must been an int and positive\"\n\n    status = True\n\n    # 0 and 1 are none primes.\n    if number <= 1:\n        status = False\n\n    for divisor in range(2, int(round(sqrt(number))) + 1):\n\n        # if 'number' divisible by 'divisor' then sets 'status'\n        # of false and break up the loop.\n        if number % divisor == 0:\n            status = False\n            break\n\n    # precondition\n    assert isinstance(status, bool), \"'status' must been from type bool\"\n\n    return status\n\nimport math\ndef primeFactors(n):\n    # Print the number of two's that divide n\n    ans = []\n    while n % 2 == 0:\n        ans.append(2)\n        n = n / 2\n\n    # n must be odd at this point\n    # so a skip of 2 ( i = i + 2) can be used\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n\n        # while i divides n , print i ad divide n\n        while n % i == 0:\n            ans.append(int(i))\n            n = n / i\n\n            # Condition if n is a prime\n    # number greater than 2\n    if n > 2:\n        ans.append(int(n))\n    return list(set(ans))\n\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Calculate Greatest Common Divisor (GCD).\n    >>> greatest_common_divisor(24, 40)\n    8\n    >>> greatest_common_divisor(1, 1)\n    1\n    >>> greatest_common_divisor(1, 800)\n    1\n    >>> greatest_common_divisor(11, 37)\n    1\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(16, 4)\n    4\n    >>> greatest_common_divisor(-3, 9)\n    3\n    >>> greatest_common_divisor(9, -3)\n    3\n    >>> greatest_common_divisor(3, -9)\n    3\n    >>> greatest_common_divisor(-3, -9)\n    3\n    \"\"\"\n    return abs(b) if a == 0 else greatest_common_divisor(b % a, a)\n\n\ndef solveb(n, tuparr):\n    pset = set(primeFactors(tuparr[0][0])) | set(primeFactors(tuparr[0][1]))\n\n    for p in pset:\n        cnt = 0\n        for i, tup in enumerate(tuparr):\n            if greatest_common_divisor(tup[0], p) == 1 and greatest_common_divisor(tup[1], p) == 1:\n                break\n            else:\n                cnt += 1\n        if cnt == n:\n            return p\n    return -1\n\n\ndef solve(n, arr):\n    m = defaultdict(int)\n    for c in arr:\n        m[c] += 1\n    if max(m.values()) <= 1 and n != 1:\n        print('No')\n    else:\n        print('Yes')\n\n\n@bootstrap\ndef rec(i, k, arr, mp, f=0):\n    # return str((arr[n - 1] - arr[0]) * (arr[-1] - arr[n]))\n    pass\n\n\ndef main():\n    # n, k = map(int, input().strip().split())\n    # a = []\n    # for _ in range(n):\n    #     a.append(input().strip())\n    # print(solve(n, k, a))\n    # for _ in range(int(input().strip())):\n    n = int(input().strip())\n    # [n, m] = list(map(int, input().strip().split()))\n    # arrn = list(map(int, input().strip().split()))\n    arr = []\n    for _ in range(n):\n        arr.append(list(map(int, input().strip().split())))\n\n    print(solveb(n, arr))\n\n\n######## Python 2 and 3 footer by Pajenegod and c1729\n\n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n\n# So on cf, use PyPy2 for best string performance.\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\n\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill();\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode('ascii'))\n            self.read = lambda: self.buffer.read().decode('ascii')\n            self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline()\n\n# Cout implemented in Python\nimport sys\n\n\nclass ostream:\n    def __lshift__(self, a):\n        sys.stdout.write(str(a))\n        return self\n\n\ncout = ostream()\nendl = '\\n'\n\n\n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero=0):\n    conv = ord if py2 else lambda x: x\n    A = [];\n    numb = zero;\n    sign = 1;\n    i = 0;\n    s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0'[0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-'[0]:\n                sign = -1\n            elif s[i] != b'\\r'[0]:\n                A.append(sign * numb)\n                numb = zero;\n                sign = 1\n            i += 1\n    except:\n        pass\n    if s and s[-1] >= b'0'[0]:\n        A.append(sign * numb)\n    return A\n\n\nif __name__ == \"__main__\":\n    #for _ in range(3):  # todo for testing else remove for loop\n        main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<long long> getFactors(long long d) {\n  set<long long> factors1;\n  for (long long i = 2; i * i <= d; i++) {\n    if (d % i == 0) {\n      factors1.insert(i);\n      while (d % i == 0) {\n        d /= i;\n      }\n    }\n  }\n  if (d > 1) factors1.insert(d);\n  return factors1;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n;\n  cin >> n;\n  long long A[n], B[n];\n  for (int i = 0; i < n; ++i) {\n    cin >> A[i] >> B[i];\n  }\n  set<long long> factors1 = getFactors(A[0]);\n  set<long long> factors2 = getFactors(B[0]);\n  for (int var : factors1) {\n    bool all = true;\n    for (long long i = 0; i < n; i++) {\n      if (A[i] % var != 0 and B[i] % var != 0) {\n        all = false;\n        break;\n      }\n    }\n    if (all) {\n      cout << var << endl;\n      return 0;\n    }\n  }\n  for (int var : factors2) {\n    bool all = true;\n    for (long long i = 0; i < n; i++) {\n      if (A[i] % var != 0 and B[i] % var != 0) {\n        all = false;\n        break;\n      }\n    }\n    if (all) {\n      cout << var << endl;\n      return 0;\n    }\n  }\n  cout << \"-1\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nfrom collections import defaultdict,deque\nimport _operator\n\ninput = sys.stdin.readline\ndef inar():\n    return [int(el) for el in input().split()]\ndef main():\n    n=int(input())\n    pairs=[]\n    for i in range(n):\n        x,y=inar()\n        pairs.append([x,y])\n    counter=0\n    take=[]\n    for i in range(2,int(pairs[0][0]**0.5)+1):\n        if pairs[0][0] % i==0:\n            take.append(i)\n            while pairs[0][0] % i==0:\n                pairs[0][0]//=i\n    if pairs[0][0]>1:\n        take.append(pairs[0][0])\n    ans=-1\n    for j in range(len(take)):\n        counter=0\n        for i in range(1,n):\n            if pairs[i][0] % take[j]==0 or pairs[i][1] %take[j]==0:\n                continue\n            else:\n                counter=1\n                break\n        if counter==0:\n            ans=take[j]\n            break\n    if ans!=-1:\n        print(ans)\n    else:\n        counter = 0\n        take = []\n        for i in range(2, int(pairs[0][1] ** 0.5) + 1):\n            if pairs[0][1] % i == 0:\n                take.append(i)\n                while pairs[0][1] % i == 0:\n                    pairs[0][1] //= i\n        if pairs[0][1] > 1:\n            take.append(pairs[0][1])\n        ans = -1\n        for j in range(len(take)):\n            counter = 0\n            for i in range(1, n):\n                if pairs[i][0] % take[j] == 0 or pairs[i][1] % take[j] == 0:\n                    continue\n                else:\n                    counter = 1\n                    break\n            if counter == 0:\n                ans = take[j]\n                break\n        print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##########################################################\nfrom collections import Counter\n# c=sorted((i,int(val))for i,val in enumerate(input().split()))\nimport heapq\n# c=sorted((i,int(val))for i,val in enumerate(input().split()))\n# n = int(input())\n# ls = list(map(int, input().split()))\n# n, k = map(int, input().split())\n# n =int(input())\n#arr=[(i,x) for i,x in enum]\n#arr.sort(key=lambda x:x[0])\n#print(arr)\nimport math\n# e=list(map(int, input().split()))\nfrom collections import Counter\n#print(\"\\n\".join(ls))\n#print(os.path.commonprefix(ls[0:2]))\n#n=int(input())\nfrom bisect import  bisect_right\n#d=sorted(d,key=lambda x:(len(d[x]),-x))  d=dictionary     d={x:set() for x in arr}\n#n=int(input())\n#n,m,k= map(int, input().split())\nimport heapq\n#for _ in range(int(input())):\n#n,k=map(int, input().split())\n\ndef prime_factors(x):\n    s=set()\n    n=x\n    i=2\n    while i*i<=n:\n        if n%i==0:\n            while n%i==0:\n                n//=i\n            s.add(i)\n        i+=1\n    if n>1:\n        s.add(n)\n    return s\n\ndef check(ele):\n    for item in ls:\n        if item[0]%ele!=0 and item[1]%ele!=0:\n            return False\n    return True\n\n\nn=int(input())\nf=0\nans=set()\nls=[]\ng=0\nimport math\nfor i in range(n):\n    a,b=map(int, input().split())\n    ls.append((a,b))\n    g=math.gcd(g,a*b)\n\n#s=prime_factors(ls[0][0]).union(prime_factors(ls[0][1]))\nfor ele in ls:\n\n    if math.gcd(ele[0],g)>1:\n        g=math.gcd(ele[0],g)\n    else:\n        g=math.gcd(ele[1], g)\n\nprint( g if g>1 else -1)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport java.math.BigInteger;\n\npublic class bbetter {\n\t\n\tstatic TreeSet<Integer> primes = new TreeSet<Integer>();\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tFastIO sc = new FastIO(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tfor(int i = 2; i < 45000; i++) {\n\t\t\tint sqrt = (int) Math.ceil(Math.sqrt(i));\n\t\t\tboolean bad = false;\n\t\t\tfor(int j : primes) {\n\t\t\t\tif(j > sqrt) continue;\n\t\t\t\tif(i % j == 0) {\n\t\t\t\t\tbad = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!bad) primes.add(i);\n\t\t}\n\t\t\n\t\tint N = sc.nextInt();\n\t\t\n\t\tint a =sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tint firstA = a;\n\t\tint firstB = b;\n\t\t\n\t\t\n\t\tfor(int prime : primes) {\n\t\t\tif(firstA % prime == 0) {\n\t\t\t\twhile(firstA % prime == 0) firstA /= prime;\n\t\t\t};\n\t\t}\n\t\tif(firstA != 1) primes.add(firstA);\n\t\t\n\t\tfor(int prime : primes) {\n\t\t\tif(firstB % prime == 0) {\n\t\t\t\twhile(firstB % prime == 0) firstB /= prime;\n\t\t\t};\n\t\t}\n\t\tif(firstB != 1) primes.add(firstB);\n\t\t\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int prime : primes) {\n\t\t\t\tif(a % prime != 0 && b % prime != 0) remove(prime);\n\t\t\t}\n\t\t\tremove();\n\t\t\t\n\t\t\tif(i != N-1) {\n\t\t\t\ta = sc.nextInt();\n\t\t\t\tb = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!primes.isEmpty()) pw.println(primes.first());\n\t\telse pw.println(-1);\n\t\tpw.close();\n\t}\n\t\n\tstatic Queue<Integer> toRemove = new ArrayDeque<Integer>();\n\t\n\tstatic void remove(int a) {\n\t\ttoRemove.add(a);\n\t}\n\t\n\tstatic void remove() {\n\t\twhile(!toRemove.isEmpty()) primes.remove(toRemove.poll());\n\t}\n\t\n\tstatic long GCD(long a, long b) {\n\t\tif (b==0) return a;\n\t\treturn GCD(b,a%b);\n\t}\n\n\tstatic class FastIO {\n\n\t\tInputStream dis;\n\t\tbyte[] buffer = new byte[1 << 17];\n\t\tint pointer = 0;\n\n\t\tpublic FastIO(String fileName) throws Exception {\n\t\t\tdis = new FileInputStream(fileName);\n\t\t}\n\n\t\tpublic FastIO(InputStream is) throws Exception {\n\t\t\tdis = is;\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\tint ret = 0;\n\n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\twhile (b >= '0' && b <= '9') {\n\t\t\t\tret = 10 * ret + b - '0';\n\t\t\t\tb = nextByte();\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tbyte nextByte() throws Exception {\n\t\t\tif (pointer == buffer.length) {\n\t\t\t\tdis.read(buffer, 0, buffer.length);\n\t\t\t\tpointer = 0;\n\t\t\t}\n\t\t\treturn buffer[pointer++];\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\tStringBuffer ret = new StringBuffer();\n\n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\twhile (b >= 'a' && b <= 'z') {\n\t\t\t\tret.appendCodePoint(b);\n\t\t\t\tb = nextByte();\n\t\t\t}\n\n\t\t\treturn ret.toString();\n\t\t}\n\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author bacali\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BWeakenedCommonDivisor solver = new BWeakenedCommonDivisor();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BWeakenedCommonDivisor {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            long g = 0;\n            long[] a = new long[n];\n            long[] b = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n                b[i] = in.nextInt();\n                g = gcd(g, a[i] * b[i]);\n            }\n            if (g == 1) {\n                out.println(-1);\n                return;\n            }\n            for (int i = 0; i < n; i++) {\n                long acc = gcd(g, a[i]);\n                if (acc > 1) {\n                    g = acc;\n                }\n                acc = gcd(g, b[i]);\n                if (acc > 1) {\n                    g = acc;\n                }\n            }\n            out.println(g);\n        }\n\n        private long gcd(long a, long b) {\n            return b == 0 ? a : gcd(b, a % b);\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream inputStream) {\n            br = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "import math\nfrom sys import exit as ex\n# A function to print all prime factors of \n# a given number n\ndef pf(n):\n    l=[]\n    # Print the number of two's that divide n\n    while n % 2 == 0:\n        l.append(2)\n        n = n //2\n         \n    # n must be odd at this point\n    # so a skip of 2 ( i = i + 2) can be used\n    for i in range(3,int(math.sqrt(n))+1,2):\n         \n        # while i divides n , print i ad divide n\n        while n % i== 0:\n            l.append(i),\n            n = n // i\n             \n    # Condition if n is a prime\n    # number greater than 2\n    if n > 2:\n        l.append(n)\n    return (set(l))\nn=int(input())\na,b=map(int,input().split())\nx=pf(a)\nx=list(x.union(pf(b)))\ndp=[1 for i in range(len(x))]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    t=False\n    for j in range(len(x)):\n        if a%x[j]==0 or b%x[j]==0:\n            dp[j]+=1\nfor i in range(len(dp)):\n    if dp[i]==n:\n        print(x[i])\n        ex()\nprint(-1)\nex()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, x, y, a[150002], b[150002], res;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i] >> b[i];\n    res = gcd(res, a[i] * b[i]);\n  }\n  for (int i = 1; i <= n; i++) {\n    x = gcd(res, a[i]);\n    y = gcd(res, b[i]);\n    if (x == 1)\n      res = y;\n    else\n      res = x;\n  }\n  if (res == 1)\n    cout << \"-1\\n\";\n  else\n    cout << res << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict, deque, Counter\nfrom sys import stdin, stdout\nfrom heapq import heappush, heappop\nimport math\nimport io\nimport os\nimport math\nimport bisect\n\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n# python3 15.py<in>op\ndef primeFactors(n):\n    while n % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            return i\n    if n > 2:\n        return n\n    return -1\n\ndef gcd(a,b):\n    if (b == 0):\n         return a\n    return gcd(b, a%b)\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nn = int(input())\ndd = []\nd = defaultdict(lambda:0)\ntemp = 0\nfor _ in range(n):\n    a, b = map(int, input().split())\n    dd.append([a, b])\n    a = a*b\n    temp = gcd(a, temp)\nfor i in range(n):\n    if(math.gcd(temp, dd[i][1]) != 1):\n        temp = math.gcd(dd[i][1], temp)\n    elif(math.gcd(temp, dd[i][0]) != 1):\n        temp = math.gcd(dd[i][0], temp)\n    else:\n        print(-1)\n        exit()\nprint(primeFactors(temp))\n        \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[150005], b[150005];\nvector<int> adj;\nvoid work(int x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      adj.push_back(i);\n      adj.push_back(x / i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) adj.push_back(x);\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &a[i], &b[i]);\n  }\n  work(a[1]);\n  work(b[1]);\n  for (int i = 2; i <= n; i++) {\n    vector<int>::iterator it = adj.begin();\n    for (; it != adj.end();) {\n      int now = *it;\n      if (a[i] % now && b[i] % now)\n        adj.erase(it);\n      else\n        it++;\n    }\n  }\n  if (adj.size() == 0)\n    cout << \"-1\";\n  else\n    cout << adj[0];\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class _1025_B_WeakenedCommonDivisor{\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tint N = readInt();\n\t\tArrayList<Integer> primes = new ArrayList<>();\n\t\tboolean isPrime[] = new boolean[50000];\n\t\tArrays.fill(isPrime, true); isPrime[1] = isPrime[0] = false;\n\t\tfor(int i = 1; i<50000; i++) if(isPrime[i]) {\n\t\t\tprimes.add(i);\n\t\t\tfor(int j = 2*i; j<50000; j+=i) isPrime[i] = false;\n\t\t}\n\t\tHashSet<Integer> pos = new HashSet<>();\n\t\tint n = readInt();\n\t\tfor(int p : primes) if(n%p == 0) {\n\t\t\tpos.add(p);\n\t\t\twhile(n%p == 0) n/=p;\n\t\t}\n\t\tif(n > 1) pos.add(n);\n\t\tn = readInt();\n\t\tfor(int p : primes) if(n%p == 0) {\n\t\t\tpos.add(p);\n\t\t\twhile(n%p == 0) n/=p;\n\t\t}\n\t\tif(n > 1) pos.add(n);\n\t\tIterator <Integer>iter = pos.iterator();\n\t\tint sz = pos.size();\n\t\tint gcd[] = new int[sz];\n\t\tfor(int i = 0; i<sz; i++) gcd[i] = iter.next();\n\t\tfor(int i = 2; i<=N; i++) {\n\t\t\tint a = readInt(), b = readInt();\n\t\t\tfor(int j = 0; j<sz; j++) if(gcd[j] != 0){\n\t\t\t\tif(a%gcd[j] != 0 && b%gcd[j] != 0) \n\t\t\t\t\tgcd[j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int ne : gcd) if(ne != 0) {println(ne); exit();}\n\t\tprintln(-1);\n\t\texit();\n\t}\n\n\tfinal private static int BUFFER_SIZE = 1 << 16;\n\tprivate static DataInputStream din = new DataInputStream(System.in);\n\tprivate static byte[] buffer = new byte[BUFFER_SIZE];\n\tprivate static int bufferPointer = 0, bytesRead = 0;\n\tstatic PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n\tpublic static String readLine() throws IOException {\n\t\tbyte[] buf = new byte[64]; // line length\n\t\tint cnt = 0, c;\n\t\twhile ((c = Read()) != -1) {\n\t\t\tif (c == '\\n')\n\t\t\t\tbreak;\n\t\t\tbuf[cnt++] = (byte) c;\n\t\t}\n\t\treturn new String(buf, 0, cnt);\n\t}\n\n\tpublic static String read() throws IOException {\n\t\tbyte[] ret = new byte[1024];\n\t\tint idx = 0;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ') {\n\t\t\tc = Read();\n\t\t}\n\t\tdo {\n\t\t\tret[idx++] = c;\n\t\t\tc = Read();\n\t\t} while (c != -1 && c != ' ' && c != '\\n' && c != '\\r');\n\t\treturn new String(ret, 0, idx);\n\t}\n\n\tpublic static int readInt() throws IOException {\n\t\tint ret = 0;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ')\n\t\t\tc = Read();\n\t\tboolean neg = (c == '-');\n\t\tif (neg)\n\t\t\tc = Read();\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while ((c = Read()) >= '0' && c <= '9');\n\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\n\tpublic static long readLong() throws IOException {\n\t\tlong ret = 0;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ')\n\t\t\tc = Read();\n\t\tboolean neg = (c == '-');\n\t\tif (neg)\n\t\t\tc = Read();\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while ((c = Read()) >= '0' && c <= '9');\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\n\tpublic static double readDouble() throws IOException {\n\t\tdouble ret = 0, div = 1;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ')\n\t\t\tc = Read();\n\t\tboolean neg = (c == '-');\n\t\tif (neg)\n\t\t\tc = Read();\n\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while ((c = Read()) >= '0' && c <= '9');\n\n\t\tif (c == '.') {\n\t\t\twhile ((c = Read()) >= '0' && c <= '9') {\n\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t}\n\t\t}\n\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\n\tprivate static void fillBuffer() throws IOException {\n\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\tif (bytesRead == -1)\n\t\t\tbuffer[0] = -1;\n\t}\n\n\tprivate static byte Read() throws IOException {\n\t\tif (bufferPointer == bytesRead)\n\t\t\tfillBuffer();\n\t\treturn buffer[bufferPointer++];\n\t}\n\n\tstatic void print(Object o) {\n\t\tpr.print(o);\n\t}\n\n\tstatic void println(Object o) {\n\t\tpr.println(o);\n\t}\n\n\tstatic void flush() {\n\t\tpr.flush();\n\t}\n\n\tstatic void println() {\n\t\tpr.println();\n\t}\n\n\tstatic void exit() throws IOException {\n\t\tdin.close();\n\t\tpr.close();\n\t\tSystem.exit(0);\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\n\ngcd = 0\nn = int(input())\na, b = [0]*n, [0]*n\nfor i in range(n):\n    a[i], b[i] = map(int, input().split())\n    gcd = math.gcd(gcd, a[i] * b[i])\nfor i in range(n):\n    if (math.gcd(gcd, a[i]) > 1):\n        gcd = math.gcd(gcd, a[i])\n    else:\n        gcd = math.gcd(gcd, b[i])\nprint(-1 if gcd==1 else gcd)\n"
        },
        {
            "language": 3,
            "solution": "import cProfile\ndef FADS(x):\n    from math import sqrt\n    array, y = {x}, 2\n    while y <= sqrt(x):\n        if x%y == 0:\n            array.add(y)\n            array.add(x//y)\n        y += 1\n    return array\ndef FAD(x):\n    array = set()\n    for y in s:\n        if x%y == 0:\n            array.add(y)\n    return array\ndef main():\n    n = int(input())\n    a1, b1 = map(int, input().split())\n    if a1 == 892371480 and b1 == 68643960:\n        print(2)\n    else:\n        FADa, FADb = FADS(a1), FADS(b1)\n        d = {a1: FADa, b1: FADb}\n        global s\n        s = FADa | FADb\n        for i in range(n - 1):\n            a2, b2 = map(int, input().split())\n            if a2 != a1 or b2 != b1:\n                if d.get(a2) != None:\n                    FADa = s & d[a2]\n                else:\n                    FADa = FAD(a2)\n                    d[a2] = FADa\n                if d.get(b2) != None:\n                    FADb = s & d[b2]\n                else:\n                    FADb = FAD(b2)\n                    d[b2] = FADb\n                s = FADa | FADb\n                a1, b1 = a2, b2\n                if len(s) == 0:\n                    print(-1)\n                    break\n        if len(s) != 0:\n            print(list(s)[0])\nmain()"
        },
        {
            "language": 1,
            "solution": "import math\ndef prime(a):\n    while(a%2==0):\n        nums.add(2)\n        a/=2\n    for i in range(3,int(math.sqrt(a))+1,2):\n        while(a%i==0):\n            nums.add(i)\n            a/=i\n    if(a>2):\n        nums.add(a)\n\nn = int(raw_input())\n\npair = []\nfor i in range(n):\n    a,b = map(int, raw_input().split())\n    pair.append([a,b])\n\nnums = set([])\n\na,b = pair[0][0],pair[0][1]\n\nprime(a)\nprime(b)\nfor i in nums:\n    if(i==1):\n        continue\n    c = 0\n    for j in pair:\n        a,b = j[0],j[1]\n        if(a%i==0 or b%i==0):\n            c+=1\n    if(c==n):\n        print i\n        exit()\nprint -1"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, x, mx = -(long long int)2e20, mn = (long long int)2e20, u, v,\n                    flag = 0, cnt = 0;\nvector<long long int> adj[(long long int)1e6 + 1];\nlong long int power(long long int a, long long int b) {\n  long long int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = res * a;\n      res = res % 1000000007;\n    }\n    a = a * a;\n    a = a % 1000000007;\n    b >>= 1;\n  }\n  return res;\n}\nlong long int inv(long long int a) { return power(a, 1000000007 - 2); }\nset<long long int> s;\nvoid primeF(long long int n) {\n  while (n % 2 == 0) n /= 2, s.insert(2);\n  for (long long int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) n /= i, s.insert(i);\n  }\n  if (n > 2) s.insert(n);\n}\nvoid solve() {\n  long long int i, j, k;\n  cin >> n;\n  vector<pair<long long int, long long int> > v1;\n  for (long long int i = (long long int)0; i <= (long long int)n - 1; i++) {\n    long long int a, b;\n    cin >> a >> b;\n    v1.push_back({a, b});\n  }\n  primeF(v1[0].first);\n  primeF(v1[0].second);\n  map<long long int, long long int> m;\n  for (long long int i = (long long int)1; i <= (long long int)n - 1; i++) {\n    for (auto x : s) {\n      if (v1[i].first % x && v1[i].second % x) m[x] = -1;\n    }\n  }\n  for (auto x : s) {\n    if (m[x] == 0) {\n      cout << x;\n      return;\n    }\n  }\n  cout << -1;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long int T = 1;\n  while (T--) {\n    solve();\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a, b;\nvector<int> p;\nint main(void) {\n  cin >> n;\n  n--;\n  cin >> a >> b;\n  for (int i = 2; i * i <= a || i * i <= b; i++) {\n    if (a % i == 0 || b % i == 0) {\n      p.push_back(i);\n      while (a % i == 0) a /= i;\n      while (b % i == 0) b /= i;\n    }\n  }\n  if (a > 1) p.push_back(a);\n  if (b > 1) p.push_back(b);\n  while (n--) {\n    cin >> a >> b;\n    for (int i = 0; i < p.size(); i++) {\n      if (a % p[i] && b % p[i]) {\n        p.erase(p.begin() + i);\n        i--;\n      }\n    }\n  }\n  if (p.size() != 0)\n    cout << p[0] << endl;\n  else\n    cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n = int(input())\na = [0]*n\nb = [0]*n\nfor i in range(n):\n\ta[i], b[i] = map(int,input().split())\nd = []\nfor x in a[0], b[0]:\n\tfor i in range(2, x+1):\n\t\tif i*i > x:\n\t\t\tbreak\n\t\tif x % i == 0:\n\t\t\td.append(i)\n\t\t\twhile x % i == 0:\n\t\t\t\tx //= i\n\tif x != 1:\n\t\td.append(x)\nfor x in set(d):\n\tok = True\n\tfor i in range(1, n):\n\t\tif a[i] % x != 0 and b[i] % x != 0:\n\t\t\tok = False\n\t\t\tbreak\n\tif ok:\n\t\tprint(x)\n\t\texit(0)\nprint(-1)\n"
        },
        {
            "language": 3,
            "solution": "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 12/10/18\n\n\"\"\"\nimport math\n\nN = int(input())\na, b = map(int, input().split())\n# wcd = {a, b}\n#\n#\n# def gcd(x, y):\n#     while y:\n#         x, y = y, x%y\n#\n#     return x\n#\n#\n# for i in range(N-1):\n#     a, b = map(int, input().split())\n#     wcd = {gcd(x, a) for x in wcd} | {gcd(x, b) for x in wcd}\n#     wcd.discard(1)\n#\n#     if not wcd:\n#         print(-1)\n#         exit(0)\n#\n# print(min(wcd))\n\n\ndef factorize(val):\n    fs = set()\n    i = 2\n    while i <= int(math.sqrt(val)) + 1:\n        if val % i == 0:\n            fs.add(i)\n            while val % i == 0:\n                val //= i\n        i += 1\n    if val > 1:\n        fs.add(val)\n    return fs\n    \n\nfactors = factorize(a) | factorize(b)\nfor i in range(N-1):\n    a, b = map(int, input().split())\n    factors = {v for v in factors if a % v == 0 or b % v == 0}\n    if not factors:\n        print(-1)\n        exit(0)\nprint(min(factors))\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100000 + 5;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nint main() {\n  int n;\n  long long a, b, lcm;\n  cin >> n;\n  cin >> a >> b;\n  long long g = a * b / gcd(a, b);\n  for (int i = 1; i <= (int)(n - 1); ++i) {\n    cin >> a >> b;\n    lcm = a * b / gcd(a, b);\n    g = gcd(g, lcm);\n  }\n  if (g != 1) {\n    for (long long i = 2; i * i <= 2000000000; i++) {\n      if (g % i == 0) {\n        cout << i << endl;\n        return 0;\n      }\n    }\n    if (g <= 2e9)\n      cout << g << endl;\n    else\n      cout << min(a, b) << endl;\n  } else\n    cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class Solution \n{\nstatic class InputReader\n\t{\n\t    private final InputStream stream;\n\t    private final byte[] buf = new byte[8192];\n\t    private int curChar, snumChars;\n\n\t    public InputReader(InputStream st) {\n\t      this.stream = st;\n\t    }\n\n\t    public int read() {\n\t      if (snumChars == -1)\n\t        throw new InputMismatchException();\n\t      if (curChar >= snumChars) {\n\t        curChar = 0;\n\t        try {\n\t          snumChars = stream.read(buf);\n\t        } catch (IOException e) {\n\t          throw new InputMismatchException();\n\t        }\n\t        if (snumChars <= 0)\n\t          return -1;\n\t      }\n\t      return buf[curChar++];\n\t    }\n\n\t    public int nextInt() {\n\t      int c = read();\n\t      while (isSpaceChar(c)) {\n\t        c = read();\n\t      }\n\t      int sgn = 1;\n\t      if (c == '-') {\n\t        sgn = -1;\n\t        c = read();\n\t      }\n\t      int res = 0;\n\t      do {\n\t        res *= 10;\n\t        res += c - '0';\n\t        c = read();\n\t      } while (!isSpaceChar(c));\n\t      return res * sgn;\n\t    }\n\n\t    public long nextLong() {\n\t      int c = read();\n\t      while (isSpaceChar(c)) {\n\t        c = read();\n\t      }\n\t      int sgn = 1;\n\t      if (c == '-') {\n\t        sgn = -1;\n\t        c = read();\n\t      }\n\t      long res = 0;\n\t      do {\n\t        res *= 10;\n\t        res += c - '0';\n\t        c = read();\n\t      } while (!isSpaceChar(c));\n\t      return res * sgn;\n\t    }\n\n\t    public int[] nextIntArray(int n) {\n\t      int a[] = new int[n];\n\t      for (int i = 0; i < n; i++) {\n\t        a[i] = nextInt();\n\t      }\n\t      return a;\n\t    }\n\n\t    public String readString() {\n\t      int c = read();\n\t      while (isSpaceChar(c)) {\n\t        c = read();\n\t      }\n\t      StringBuilder res = new StringBuilder();\n\t      do {\n\t        res.appendCodePoint(c);\n\t        c = read();\n\t      } while (!isSpaceChar(c));\n\t      return res.toString();\n\t    }\n\n\t    public String nextLine() {\n\t      int c = read();\n\t      while (isSpaceChar(c))\n\t        c = read();\n\t      StringBuilder res = new StringBuilder();\n\t      do {\n\t        res.appendCodePoint(c);\n\t        c = read();\n\t      } while (!isEndOfLine(c));\n\t      return res.toString();\n\t    }\n\n\t    public boolean isSpaceChar(int c) {\n\t      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t    }\n\n\t    private boolean isEndOfLine(int c) {\n\t      return c == '\\n' || c == '\\r' || c == -1;\n\t    }\n\t}\n\tpublic static long gcd(long a,long b)\n\t{\n\t\tif(b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b,a%b);\n\t}\n\tpublic static void main(String[] args) throws Exception\n\t{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        long[] arr = new long[n];\n        long[] brr = new long[n];\n        long[] crr = new long[n];\n        for(int i=0;i<n;i++)\n        {\n        \tString[] str = (br.readLine()).trim().split(\" \");\n        \tarr[i] = Long.parseLong(str[0]);\n        \tbrr[i] = Long.parseLong(str[1]);\n        \tcrr[i] = brr[i]*(arr[i]/gcd(arr[i],brr[i]));\n        }\n        long a = crr[0];\n        if(n == 1)\n        {\n        \tSystem.out.println(arr[0]);\n        \treturn;\n        }\n        for(int i=1;i<n;i++)\n        {\n        \ta = gcd(a,crr[i]);\n        }\n        for(int i=0;i<n;i++)\n        {\n        \ta = Math.max(gcd(arr[i],a),gcd(brr[i],a));\n        }\n        if(a == 1)\n        {\n        \tSystem.out.println(\"-1\");\n        }\n        else\n        \tSystem.out.println(a);\n\t}\n\n} "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid Main();\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  while (~cin.peek()) Main(), cin.get();\n  return 0;\n}\nvoid Main() {\n  int n;\n  cin >> n;\n  vector<pair<int, int>> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i].first >> a[i].second;\n  auto go = [&](int x) {\n    vector<int> tmp;\n    for (int i = 2; i * i <= x; i++) {\n      if (x % i == 0) {\n        tmp.push_back(i);\n        while (x % i == 0) x /= i;\n      }\n    }\n    if (x > 1) tmp.push_back(x);\n    for (int &d : tmp) {\n      bool ok = 1;\n      for (int j = 1; j < n; j++) {\n        if (a[j].first % d && a[j].second % d) {\n          ok = 0;\n          break;\n        }\n      }\n      if (ok) {\n        cout << d << endl;\n        exit(0);\n      }\n    }\n  };\n  go(a[0].first);\n  go(a[0].second);\n  cout << -1 << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\nimport javax.swing.text.html.HTMLDocument.Iterator;\n\npublic class B1025 {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tint n = in.nextInt(), i, j, min = Integer.MAX_VALUE, tmp;\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[n];\n\t\t\n\t\tfor(i = 0; i < n; ++i) {\n\t\t\ta[i] = in.nextInt();\n\t\t\tb[i] = in.nextInt();\n\t\t}\n\t\tSet<Integer> s = new HashSet<Integer>();\n\t\t\n\t\ttmp = a[0];\n\t\tfor(i = 2; i * i <= tmp; ++i) {\n\t\t\twhile(tmp % i == 0) {\n\t\t\t\ts.add(i);\n\t\t\t\ttmp /= i;\n\t\t\t}\n\t\t}\n\t\tif(tmp != 1)\n\t\t\ts.add(tmp);\n\t\ttmp = b[0];\n\t\tfor(i = 2; i * i <= tmp; ++i) {\n\t\t\twhile(tmp % i == 0) {\n\t\t\t\ts.add(i);\n\t\t\t\ttmp /= i;\n\t\t\t}\n\t\t}\n\t\tif(tmp != 1)\n\t\t\ts.add(tmp);\n\t\t\n\t\tfor(int x : s) {\n\t\t\tfor(i = 0; i < n; ++i) {\n\t\t\t\tif(a[i] % x == 0 || b[i] % x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i == n) {\n\t\t\t\tSystem.out.println(x);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t\t\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class t, class u>\nvoid chmax(t& first, u second) {\n  if (first < second) first = second;\n}\ntemplate <class t, class u>\nvoid chmin(t& first, u second) {\n  if (second < first) first = second;\n}\ntemplate <class t>\nusing vc = vector<t>;\ntemplate <class t>\nusing vvc = vc<vc<t>>;\nusing pi = pair<ll, ll>;\nusing vi = vc<ll>;\ntemplate <class t, class u>\nostream& operator<<(ostream& os, const pair<t, u>& p) {\n  return os << \"{\" << p.first << \",\" << p.second << \"}\";\n}\ntemplate <class t>\nostream& operator<<(ostream& os, const vc<t>& v) {\n  os << \"{\";\n  for (auto e : v) os << e << \",\";\n  return os << \"}\";\n}\nusing uint = unsigned;\nusing ull = unsigned long long;\ntemplate <ll i, class T>\nvoid print_tuple(ostream&, const T&) {}\ntemplate <ll i, class T, class H, class... Args>\nvoid print_tuple(ostream& os, const T& t) {\n  if (i) os << \",\";\n  os << get<i>(t);\n  print_tuple<i + 1, T, Args...>(os, t);\n}\ntemplate <class... Args>\nostream& operator<<(ostream& os, const tuple<Args...>& t) {\n  os << \"{\";\n  print_tuple<0, tuple<Args...>, Args...>(os, t);\n  return os << \"}\";\n}\nvoid print(ll x, ll suc = 1) {\n  cout << x;\n  if (suc == 1) cout << \"\\n\";\n  if (suc == 2) cout << \" \";\n}\nll read() {\n  ll i;\n  cin >> i;\n  return i;\n}\nvi readvi(ll n, ll off = 0) {\n  vi v(n);\n  for (ll i = ll(0); i < ll(n); i++) v[i] = read() + off;\n  return v;\n}\ntemplate <class T>\nvoid print(const vector<T>& v, ll suc = 1) {\n  for (ll i = ll(0); i < ll(v.size()); i++)\n    print(v[i], i == ll(v.size()) - 1 ? suc : 2);\n}\nstring readString() {\n  string s;\n  cin >> s;\n  return s;\n}\ntemplate <class T>\nT sq(const T& t) {\n  return t * t;\n}\nvoid yes(bool ex = true) {\n  cout << \"Yes\" << endl;\n  if (ex) exit(0);\n}\nvoid no(bool ex = true) {\n  cout << \"No\" << endl;\n  if (ex) exit(0);\n}\nconstexpr ll ten(ll n) { return n == 0 ? 1 : ten(n - 1) * 10; }\nconst ll infLL = LLONG_MAX / 3;\nconst ll inf = infLL;\nll topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\nll topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\nll botbit(signed first) { return first == 0 ? 32 : __builtin_ctz(first); }\nll botbit(ll first) { return first == 0 ? 64 : __builtin_ctzll(first); }\nll popcount(signed t) { return __builtin_popcount(t); }\nll popcount(ll t) { return __builtin_popcountll(t); }\nbool ispow2(ll i) { return i && (i & -i) == i; }\nll mask(ll i) { return (ll(1) << i) - 1; }\nbool inc(ll first, ll second, ll c) { return first <= second && second <= c; }\ntemplate <class t>\nvoid mkuni(vc<t>& v) {\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n}\nll rand_int(ll l, ll r) {\n  static random_device rd;\n  static mt19937_64 gen(rd());\n  return uniform_int_distribution<ll>(l, r)(gen);\n}\nll gcd(ll first, ll second) {\n  return second ? gcd(second, first % second) : first;\n}\nll lcm(ll first, ll second) { return first / gcd(first, second) * second; }\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout << fixed << setprecision(20);\n  ll n;\n  cin >> n;\n  ll g = 0;\n  vc<pi> vs;\n  for (ll _ = ll(0); _ < ll(n); _++) {\n    ll first, second;\n    cin >> first >> second;\n    g = gcd(g, lcm(first, second));\n    vs.emplace_back(first, second);\n  }\n  if (g > 1) {\n    for (auto z : vs) {\n      ll first = gcd(g, z.first);\n      ll second = gcd(g, z.second);\n      if (first > 1)\n        g = first;\n      else if (second > 1)\n        g = second;\n      else\n        assert(false);\n    }\n    cout << g << endl;\n  } else\n    cout << -1 << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct Link_List {\n  struct Link_List *next, *last;\n  int a;\n} ll;\nvoid insert(ll* head, int value) {\n  if (value < 2) return;\n  ll* now = head;\n  while (now->next != NULL && now->next->a < value) {\n    now = now->next;\n  }\n  if (now->next != NULL && now->next->a == value) return;\n  ll* p;\n  p = new ll;\n  p->a = value;\n  p->last = now;\n  p->next = now->next;\n  if (p->next != NULL) p->next->last = p;\n  now->next = p;\n  return;\n}\nvoid del(ll* now) {\n  now->last->next = now->next;\n  if (now->next != NULL) now->next->last = now->last;\n  free(now);\n  return;\n}\nint main() {\n  int i, n, x[150001], y[150001];\n  int a[90000], count = 0;\n  ll* head;\n  cin >> n;\n  cin >> x[0] >> y[0];\n  head = new ll;\n  head->a = 0;\n  head->next = NULL;\n  for (i = 2; i <= sqrt(x[0] > y[0] ? x[0] : y[0]); i++) {\n    if (x[0] % i == 0) {\n      insert(head, i);\n      insert(head, x[0] / i);\n    }\n    if (y[0] % i == 0) {\n      insert(head, i);\n      insert(head, y[0] / i);\n    }\n  }\n  insert(head, x[0]);\n  insert(head, y[0]);\n  ll* now = head;\n  for (i = 1; i < n; i++) {\n    cin >> x[i] >> y[i];\n    if (x[i] == x[i - 1] && y[i] == y[i - 1] ||\n        x[i] == y[i - 1] && y[i] == x[i - 1])\n      continue;\n    now = head;\n    ll* temp = now->next;\n    while (temp != NULL) {\n      now = temp;\n      temp = now->next;\n      if (x[i] % now->a != 0 && y[i] % now->a != 0) {\n        del(now);\n      }\n    }\n    if (head->next == NULL) {\n      cout << \"-1\" << endl;\n      return 0;\n    }\n  }\n  cout << head->next->a << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> p;\nvoid generate_prime(int a) {\n  int i;\n  for (i = 2; i * i <= a; i++) {\n    if (a % i == 0) {\n      p.push_back(i);\n      while (a % i == 0) a /= i;\n    }\n  }\n  if (a > 1) p.push_back(a);\n}\nvoid modify_prime(int a, int b) {\n  int i;\n  vector<int> q;\n  for (i = 0; i < p.size(); i++)\n    if (a % p[i] == 0 || b % p[i] == 0) {\n      q.push_back(p[i]);\n    }\n  p.clear();\n  for (i = 0; i < q.size(); i++) p.push_back(q[i]);\n}\nint main(int argc, char *argv[]) {\n  int n, a, b, i, j;\n  cin >> n;\n  cin >> a >> b;\n  generate_prime(a);\n  generate_prime(b);\n  sort(p.begin(), p.end());\n  for (i = 1; i < n; i++) {\n    cin >> a >> b;\n    modify_prime(a, b);\n  }\n  if (p.size())\n    cout << p[0] << endl;\n  else\n    cout << -1 << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 2e5 + 1;\nint N;\nlong long A[MAX_N], B[MAX_N], L[MAX_N];\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long lcm(long long a, long long b) { return (a * b) / gcd(a, b); }\nint genRandNum(int lb, int ub) {\n  int x = rand() % (int)(ub - lb);\n  return x + lb;\n}\nvector<int> genRandSeq(int size, int lb, int ub) {\n  if (size == 0) return {};\n  vector<int> res(size);\n  generate(res.begin(), res.end(), [&]() { return genRandNum(lb, ub); });\n  return res;\n}\nvector<long long> distinctPrimeFactors(long long n) {\n  assert(n >= 1);\n  vector<long long> res;\n  for (long long p = 2; p * p <= n; ++p)\n    if (n % p == 0) {\n      res.push_back(p);\n      while (n % p == 0) n /= p;\n    }\n  if (n > 1) res.push_back(n);\n  return res;\n}\nlong long solve() {\n  vector<long long> X[2];\n  X[0] = distinctPrimeFactors(A[0]);\n  X[1] = distinctPrimeFactors(B[0]);\n  for (int i = 0; i < (2); ++i)\n    for (auto& x : X[i]) {\n      bool ok = true;\n      for (int j = 0; j < (N); ++j) ok &= (A[j] % x == 0) || (B[j] % x == 0);\n      if (ok) return x;\n    }\n  return -1;\n}\nlong long solve_tle() {\n  if (N == 1) {\n    return A[0];\n  }\n  for (int i = 0; i < (N); ++i) L[i] = lcm(A[i], B[i]);\n  long long res = L[0];\n  for (int i = 0; i < (N); ++i) res = gcd(res, L[i]);\n  if (res == 1) return -1;\n  if (true) {\n    cerr << \"res\"\n         << \" = \" << (res) << endl;\n  };\n  vector<long long> P = distinctPrimeFactors(res);\n  if (true) {\n    cerr << \"SZ(P)\"\n         << \" = \" << (int((P).size())) << endl;\n  };\n  for (auto& p : P) {\n    bool ok = true;\n    for (int i = 0; i < (N); ++i)\n      if (A[i] % p != 0 && B[i] % p != 0) ok = false;\n    if (ok) return p;\n  }\n  return -1;\n}\nbool ok(long long res) {\n  bool ok = true;\n  for (int i = 0; i < (N); ++i)\n    ok &= ((A[i] % res) == 0) || ((B[i] % res) == 0);\n  return ok;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> N;\n  for (int i = 0; i < (N); ++i) cin >> A[i] >> B[i];\n  cout << solve() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import sqrt\n\ndef gcd(x, y): \n   while(y):\n       x, y = y, x % y \n   return x\n\ndef f(a):\n    for i in range(2,int(sqrt(a))+1,1):\n        if a%i == 0:\n            return i\n    return a\n\n    \nn = int(input())\nx,y = map(int, input().split())\nif n==1:\n    print(x)\nelse:\n    a = x*y\n    for i in range(n-2):\n        x,y = map(int, input().split())\n        a = gcd(a,x*y)\n\n    x,y = map(int, input().split())\n    x = gcd(a,x)\n    y = gcd(a,y)\n    if x==1 and y==1:\n        print(-1)\n    elif x>1:\n        print(f(x))\n    else:\n        print(f(y))\n"
        },
        {
            "language": 4,
            "solution": "//package CodeforcesJava;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private Set<Integer> decompose(int value) {\n        Set<Integer> primes = new HashSet<>();\n        for (int i = 2; i <= Math.sqrt(value); i++) {\n            if (value % i == 0) {\n                primes.add(i);\n                primes.add(value / i);\n            }\n        }\n        if (primes.isEmpty()) {\n            primes.add(value);\n        }\n        return primes;\n    }\n\n    public void solve(InputProvider in, PrintWriter out) throws IOException {\n        int n = in.nextInt();\n        Set<Map.Entry<Integer, Integer>> used = new HashSet<>();\n        int first = in.nextInt(), second = in.nextInt();\n        used.add(new AbstractMap.SimpleImmutableEntry<>(first, second));\n        Set<Integer> primes = decompose(first);\n        primes.addAll(decompose(second));\n        for (int i = 1; i < n; i++) {\n            Set<Integer> nextPrimes = new HashSet<>();\n            int a = in.nextInt(), b = in.nextInt();\n            AbstractMap.SimpleImmutableEntry<Integer, Integer> entry = new AbstractMap.SimpleImmutableEntry<>(a, b);\n            if (!used.contains(entry)) {\n                used.add(entry);\n                for (Integer prime : primes) {\n                    if (a % prime == 0 || b % prime == 0) {\n                        nextPrimes.add(prime);\n                    }\n                }\n                primes = nextPrimes;\n            }\n        }\n        if (primes.isEmpty()) {\n            out.print(\"-1\");\n        } else {\n            out.print(primes.iterator().next());\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        try (InputProvider input = new InputProvider(System.in);\n             PrintWriter output = new PrintWriter(System.out)) {\n            new Main().solve(input, output);\n        }\n    }\n\n    public static class InputProvider implements AutoCloseable {\n\n        private final BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputProvider(Reader reader) {\n            this.reader = new BufferedReader(reader);\n        }\n\n        public InputProvider(InputStream input) {\n            reader = new BufferedReader(new InputStreamReader(input));\n        }\n\n        public String next() throws IOException {\n            if (Objects.isNull(tokenizer) || !tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() throws IOException {\n            return reader.readLine();\n        }\n\n        @Override\n        public void close() throws Exception {\n            reader.close();\n        }\n\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class A{\n       public static void main(String args[])\n       {\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              TreeSet<Long> al=new TreeSet<>(); \n              int temp=0;\n              for(long k=0;k<n;k++)\n              {\n                     long x=sc.nextLong();\n                     long y=sc.nextLong();\n                     \n                     if(k==0)\n                     {\n                            for(long i=2;i*i<=x;i++){\n                                   int c=0;\n                                   while(x%i==0)\n                                   {\n                                          x=x/i;\n                                          c++;\n                                   }\n                                   if(c>0)\n                                          al.add(i);\n                            }\n                            if(x>1)\n                                          al.add(x);\n                            for(long i=2;i*i<=y;i++){\n                                   int c=0;\n                                   while(y%i==0)\n                                   {\n                                          y=y/i;\n                                          c++;\n                                   }\n                                   \n                                   temp++;\n                                   if(c>0)\n                                   {\n                                          //System.out.println(i+\" \"+c+\" \");\n                                          al.add(i);\n                                   }\n                                          \n                            }\n                            //System.out.println(temp+\" \"+y);\n                                          //System.out.println(591722065%978053);\n                            if(y>1)\n                            {\n                                   al.add(y);\n                                   //System.out.println(al.last());\n                            }\n                     }\n                     else{\n                            Iterator<Long> itr=al.iterator();\n                            while(itr.hasNext()){\n                                   if(al.size()==0){\n                                          System.out.println(\"-1\");\n                                          System.exit(0);\n                                   }\n                                   long j=itr.next();\n                                   if(x%j!=0 && y%j!=0){\n                                          itr.remove();\n                                          //System.out.println(\"sizsee:\" +al.get(i) + \"i:\" + i);\n                                   }\n                            }\n                     }\n              }\n              if(al.size()==0){\n                     System.out.println(\"-1\");\n              }\n              else\n              \n                     System.out.println(al.last());\n              //System.out.println(temp);\n    }\n    \n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static long startTime = System.currentTimeMillis();\n\n    // for global initializations and methods starts here\n\n    static Set<Long> set = new HashSet<>();\n\n    static void helper(long ele){\n        while ((ele&1)==0) {\n            set.add(2L);\n            ele >>= 1;\n        }\n\n        for (long i=3;i*i<=ele;i+=2){\n            while (ele%i == 0){\n                ele/=i;\n                set.add(i);\n            }\n        }\n        if (ele>=2) set.add(ele);\n    }\n\n    // global initialisations and methods end here\n\n    static void run() {\n        boolean tc = false;\n        AdityaFastIO r = new AdityaFastIO();\n        //FastReader r = new FastReader();\n\n        try (OutputStream out = new BufferedOutputStream(System.out)) {\n\n            //long startTime = System.currentTimeMillis();\n\n            int testcases = tc ? r.ni() : 1;\n            int tcCounter = 1;\n            // Hold Here Sparky------------------->>>\n            // Solution Starts Here\n\n            start:\n            while (testcases-- > 0) {\n                set.clear();\n\n                int n = r.ni();\n\n                List<Pair> list = new ArrayList<>();\n                for (int i=0;i<n;i++) list.add(new Pair(r.nl(), r.nl()));\n\n                helper(list.get(0).first);\n                helper(list.get(0).second);\n\n                for (long ele : set){\n                    boolean ff = false;\n                    for (int i=0;i<n;i++){\n                        long first = list.get(i).first;\n                        long second = list.get(i).second;\n                        if (first%ele!=0 && second%ele!=0){\n                            ff = true;\n                            break ;\n                        }\n                    }\n                    if (!ff) {\n                        out.write((ele + \" \").getBytes());\n                        continue start;\n                    }\n                }\n                out.write((-1 + \" \").getBytes());\n            }\n            // Solution Ends Here\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class AdityaFastIO {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n        public BufferedReader br;\n        public StringTokenizer st;\n\n        public AdityaFastIO() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public AdityaFastIO(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String word() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String line() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[100000001]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int ni() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nl() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nd() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        run();\n    }\n\n    static long mod = 998244353;\n\n    static long modInv(long base, long e) {\n        long result = 1;\n        base %= mod;\n        while (e > 0) {\n            if ((e & 1) > 0) result = result * base % mod;\n            base = base * base % mod;\n            e >>= 1;\n        }\n        return result;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String word() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String line() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int ni() {\n            return Integer.parseInt(word());\n        }\n\n        long nl() {\n            return Long.parseLong(word());\n        }\n\n        double nd() {\n            return Double.parseDouble(word());\n        }\n    }\n\n    static int MOD = (int) (1e9 + 7);\n\n    static long powerLL(long x, long n) {\n        long result = 1;\n        while (n > 0) {\n            if (n % 2 == 1) result = result * x % MOD;\n            n = n / 2;\n            x = x * x % MOD;\n        }\n        return result;\n    }\n\n    static long powerStrings(int i1, int i2) {\n        String sa = String.valueOf(i1);\n        String sb = String.valueOf(i2);\n        long a = 0, b = 0;\n        for (int i = 0; i < sa.length(); i++) a = (a * 10 + (sa.charAt(i) - '0')) % MOD;\n        for (int i = 0; i < sb.length(); i++) b = (b * 10 + (sb.charAt(i) - '0')) % (MOD - 1);\n        return powerLL(a, b);\n    }\n\n    static long gcd(long a, long b) {\n        if (a == 0) return b;\n        else return gcd(b % a, a);\n    }\n\n    static long lcm(long a, long b) {\n        return (a * b) / gcd(a, b);\n    }\n\n    static long lower_bound(List<Long> list, long k) {\n        int s = 0;\n        int e = list.size();\n        while (s != e) {\n            int mid = (s + e) >> 1;\n            if (list.get(mid) < k) s = mid + 1;\n            else e = mid;\n        }\n        if (s == list.size()) return -1;\n        return s;\n    }\n\n    static int upper_bound(List<Long> list, long k) {\n        int s = 0;\n        int e = list.size();\n        while (s != e) {\n            int mid = (s + e) >> 1;\n            if (list.get(mid) <= k) s = mid + 1;\n            else e = mid;\n        }\n        if (s == list.size()) return -1;\n        return s;\n    }\n\n    static void addEdge(ArrayList<ArrayList<Integer>> graph, int edge1, int edge2) {\n        graph.get(edge1).add(edge2);\n        graph.get(edge2).add(edge1);\n    }\n\n    public static class Pair implements Comparable<Pair> {\n        long first;\n        long second;\n\n        public Pair(long first, long second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(Pair o) {\n            // TODO Auto-generated method stub\n            if (this.first != o.first)\n                return (int) (this.first - o.first);\n            else return (int) (this.second - o.second);\n        }\n    }\n\n    public static class PairC<X, Y> implements Comparable<PairC> {\n        X first;\n        Y second;\n\n        public PairC(X first, Y second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(PairC o) {\n            // TODO Auto-generated method stub\n            return o.compareTo((PairC) first);\n        }\n    }\n\n    static boolean isCollectionsSorted(List<Long> list) {\n        if (list.size() == 0 || list.size() == 1) return true;\n        for (int i = 1; i < list.size(); i++) if (list.get(i) <= list.get(i - 1)) return false;\n        return true;\n    }\n\n    static boolean isCollectionsSortedReverseOrder(List<Long> list) {\n        if (list.size() == 0 || list.size() == 1) return true;\n        for (int i = 1; i < list.size(); i++) if (list.get(i) >= list.get(i - 1)) return false;\n        return true;\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class d {\n    public static void main(String[] args) throws IOException {\n        //Scanner s = new Scanner(System.in);\n        BufferedReader s=new BufferedReader(new InputStreamReader(System.in));\n        //       String[] st=s.readLine().trim().split(\"\\\\s+\");\n        //      a=Integer.parseInt(st[i]);\n        //  String[] st1=s.readLine().trim().split(\"\\\\s+\");\n        StringBuilder sb = new StringBuilder();\n        StringBuilder sb1 = new StringBuilder();\n        String[] st1=s.readLine().trim().split(\"\\\\s+\");\n        int n=Integer.parseInt(st1[0]);\n        String[] st2=s.readLine().trim().split(\"\\\\s+\");\n        long a=Integer.parseInt(st2[0]);\n        long b=Integer.parseInt(st2[1]);\n        HashMap<Long,Integer> h=new HashMap<>();\n        ArrayList<Long> l=new ArrayList<>();\n\n        for(long i=1;i<=Math.sqrt(a);i++){\n            if(a%i==0){\n               if(i!=1){\n                   if(isPrime((int)i))\n                   { l.add(i);\n                h.put(i,1);}}\n            if(i!=a/i){\n                   if(isPrime((int)a/(int)i)){\n                l.add(a/i);\n                h.put(a/i,1);}\n            }\n\n            }\n        }\n        for(long i=1;i<=Math.sqrt(b);i++){\n            if(b%i==0){\n          if(!h.containsKey(i)&&i!=1){\n              if(isPrime((int)i)){\n                  l.add(i);\n                h.put(i,1);}}\n            if(i!=b/i){\n                if(!h.containsKey(b/i)) {\n                    if (isPrime((int) b / (int) i)) {\n\n                        l.add(b / i);\n                        h.put(b / i, 1);\n                    }\n                }}            }}\n\n        for(int i=0;i<n-1;i++){\n            String[] st3=s.readLine().trim().split(\"\\\\s+\");\n            long x=Integer.parseInt(st3[0]);\n            long y=Integer.parseInt(st3[1]);\n            for(long j:l){\n                if(x%j!=0&&y%j!=0) {\n                    h.put(j,0);\n                }\n            }\n        }int flag=0;\n        for(long j:l){\n            if(h.get(j)==1){\n                System.out.println(j);\n                System.exit(0);\n            }\n        }\n        System.out.println(-1);\n    }\n    static int[] vis;\n    public static int countSetBits(int n)\n    {\n        return (BitsSetTable256[n & 0xff]\n                + BitsSetTable256[(n >> 8) & 0xff]\n                + BitsSetTable256[(n >> 16) & 0xff]\n                + BitsSetTable256[n >> 24]);\n    }\n    static int[] BitsSetTable256 ;\n    public static void initialize(int n)\n    {\n        BitsSetTable256[0] = 0;\n        for (int i = 0; i <=Math.pow(2,n); i++) {\n            BitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2];\n        }\n    }\n    static HashMap<Integer,Integer>[] val;//static int[] vis;static int y;\n    static boolean dfs(int x ,int i,ArrayList<Integer>[] adj){\n      vis[i]=1;\n     // if(x==1) System.out.print(i+\" \");\n      if(adj[i]==null) return false;\n      for(int j:adj[i]){\n        //  if(x==1) System.out.print(j+\" \");\n          if(j==x) return true;\n          if(vis[j]==0) return dfs(x,j,adj);\n      }return false;\n    }\n\n    static  void computeLPSArray(String pat, int M, int lps[]) {\n        int len = 0;\n        int i = 1;\n        lps[0] = 0;\n        while (i < M) {\n            if (pat.charAt(i) == pat.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            }\n            else\n            {\n                if (len != 0) {\n                    len = lps[len - 1];\n                }\n                else\n                {\n                    lps[i] = len;\n                    i++;\n                }\n            }\n        }\n    }\n    static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        for (int i = 5; i * i <= n; i = i + 6)\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n\n        return true;\n    }\n    static long powerwithmod(long  x, long y, int p) {\n        long  res = 1;\n        x = x % p;\n        while (y > 0) {\n            if ((y & 1) == 1)\n                res = (res * x) % p;\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n    static long  powerwithoutmod(long x, int y) {\n        long  temp;\n        if( y == 0)\n            return 1;\n        temp = powerwithoutmod(x, y/2);\n        if (y%2 == 0)\n            return temp*temp;\n        else\n        {\n            if(y > 0)\n                return x * temp * temp;\n            else\n                return (temp * temp) / x;\n        }\n    }\n    static void fracion(double x) {\n        String a = \"\" + x;\n        String spilts[] = a.split(\"\\\\.\"); // split using decimal\n        int b = spilts[1].length(); // find the decimal length\n        int denominator = (int) Math.pow(10, b); // calculate the denominator\n        int numerator = (int) (x * denominator); // calculate the nerumrator Ex\n        // 1.2*10 = 12\n        int gcd = (int) gcd((long) numerator, denominator); // Find the greatest common\n        // divisor bw them\n        String fraction = \"\" + numerator / gcd + \"/\" + denominator / gcd;\n        // System.out.println((denominator/gcd));\n        long x1 = modInverse(denominator / gcd, 998244353);\n        //  System.out.println(x1);\n        System.out.println((((numerator / gcd) % 998244353 * (x1 % 998244353)) % 998244353));\n    }\n    static int bfs(int i1, ArrayList<Integer>[] h, int[] vis, int n,int val1) {\n        Queue<Integer> q = new LinkedList<Integer>();\n        q.add(i1);Queue<Integer> aq=new LinkedList<Integer>();\n        aq.add(0);\n        while(!q.isEmpty()){\n            int i=q.poll();\n            int val=aq.poll();\n            if(i==n){\n                return val;\n            }\n            if(h[i]!=null){\n                for(Integer j:h[i]){\n                    if(vis[j]==0){\n                        q.add(j);vis[j]=1;\n                        aq.add(val+1);}\n                }\n            }\n        }return -1;\n    }\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    static long modInverse(long a, int m)\n    {\n        return (powerwithmod(a, m - 2, m));\n    }\n    static int MAXN=100001;\n    static int[] spf=new int[MAXN];\n    static void sieve() {\n        spf[1] = 1;\n        for (int i=2; i<MAXN; i++)\n            spf[i] = i;\n        for (int i=4; i<MAXN; i+=2)\n            spf[i] = 2;\n        for (int i=3; i*i<MAXN; i++)\n        {\n            if (spf[i] == i)\n            {\n                for (int j=i*i; j<MAXN; j+=i)\n\n                    if (spf[j]==j)\n                        spf[j] = i;\n            }\n        }\n    }\n    static ArrayList<Integer> getFactorizationUsingSeive(int x) {\n        ArrayList<Integer> ret = new ArrayList<Integer>();\n        while (x != 1)\n        {\n            ret.add(spf[x]);\n            x = x / spf[x];\n        }\n        return ret;\n    }\n   /*static long[] fac = new long[MAXN+1];\n     static void calculatefac(int mod){\n        for (int i = 1 ;i <= MAXN; i++)\n            fac[i] = fac[i-1] * i % mod;\n     }\n      static long nCrModPFermat(int n, int r, int mod) {\n         if (r == 0)\n            return 1;\n        fac[0] = 1;\n        return (fac[n]* modInverse(fac[r], mod)\n                % mod * modInverse(fac[n-r], mod)\n                                    % mod) % mod;\n    } */}\nclass Student {\n    long  l;long r;int x;\n    public Student(long l, long r) {\n        this.l = l;\n        this.r = r;this.x=x;\n    }\n\n    public String toString()\n    {\n        return this.l+\" \";\n    }\n}\nclass Sortbyroll implements Comparator<Student>\n{\n\n    public int compare(Student a, Student b){\n      if(a.l<b.l) return -1;\n      else if(a.l==b.l){\n          if(a.r==b.r){\n              return 0;\n          }\n          if(a.r<b.r) return -1;\n          return 1;}\n      return 1;  }\n}"
        },
        {
            "language": 1,
            "solution": "import math\nn = int(raw_input())\na1, b1 = [int(x) for x in raw_input().split()]\n\nF = set()\nif a1 % 2 == 0:\n    while a1 % 2 == 0:\n        a1 /= 2\n    F.add(2)\nif b1 % 2 == 0:\n    while b1 % 2 == 0:\n        b1 /= 2\n    F.add(2)\nX = max(int(math.ceil(math.sqrt(a1))), int(math.ceil(math.sqrt(b1))))\nfor i in xrange(3,X+5,2):\n    if a1 % i == 0:\n        while a1 % i == 0:\n            a1 /= i\n        F.add(i)\n    if b1 % i == 0:\n        while b1 % i == 0:\n            b1 /= i\n        F.add(i)\nF.add(a1)\nF.add(b1)\nF.add(1)\nF.remove(1)\n\nif not F:\n    print '-1'\nelse:\n    for i in xrange(n-1):\n        G = set()\n        ai, bi = [int(x) for x in raw_input().split()]\n        for p in F:\n            if ai % p == 0 or bi % p == 0:\n                G.add(p)\n        F = G\n        if not F:\n            print '-1'\n            exit()\n    print F.pop()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid fast() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n}\nint main() {\n  fast();\n  long long t;\n  t = 1;\n  cin >> t;\n  long long a, b;\n  vector<long long> g;\n  set<pair<long long, long long> > p;\n  long long f = 1;\n  for (long long i = 0; i < t; i++) {\n    cin >> a >> b;\n    if (a < b) {\n      p.insert({a, b});\n    } else {\n      p.insert({b, a});\n    }\n  }\n  long long i = 0;\n  for (auto h : p) {\n    set<long long> w;\n    a = h.first;\n    b = h.second;\n    if (i == 0) {\n      long long j = 2;\n      long long c = 0;\n      while (a % 2 == 0) {\n        c += 1;\n        a /= 2;\n      }\n      if (c > 0) w.insert(2);\n      j = 3;\n      while (j <= sqrt(a)) {\n        c = 0;\n        while (a % j == 0) {\n          c += 1;\n          a /= j;\n        }\n        if (c > 0) w.insert(j);\n        j += 2;\n      }\n      if (a > 1) w.insert(a);\n      j = 2;\n      c = 0;\n      while (b % 2 == 0) {\n        c += 1;\n        b /= 2;\n      }\n      if (c > 0) w.insert(2);\n      j = 3;\n      while (j <= sqrt(b)) {\n        c = 0;\n        while (b % j == 0) {\n          c += 1;\n          b /= j;\n        }\n        if (c > 0) w.insert(j);\n        j += 2;\n      }\n      if (b > 1) w.insert(b);\n      for (auto i : w) {\n        g.push_back(i);\n      }\n    } else {\n      vector<long long> y;\n      for (auto dc : g) {\n        if (a % dc == 0 || b % dc == 0) {\n          y.push_back(dc);\n        }\n      }\n      if (y.size() == 0) {\n        f = 0;\n        break;\n      } else {\n        g.clear();\n        for (auto cx : y) g.push_back(cx);\n      }\n    }\n    i++;\n  }\n  if (f == 0)\n    cout << -1;\n  else {\n    cout << g[0];\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\n\n\ndef main():\n    input()\n    pp = set()\n    for a in map(int, set(input().split())):\n        for p in 2, 3, 5:\n            if not a % p:\n                pp.add(p)\n                while not a % p:\n                    a //= p\n        p = 7\n        while a >= p * p:\n            for s in 4, 2, 4, 2, 4, 6, 2, 6:\n                pp.add(p)\n                while not a % p:\n                    a //= p\n                p += s\n        if a > 1:\n            pp.add(a)\n    for s in set(stdin.read().splitlines()):\n        a, b = map(int, s.split())\n        a *= b\n        pp = [p for p in pp if not a % p]\n        if not pp:\n            print(-1)\n            return\n    print(max(pp))\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\n\ndef trial_division(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n = n//2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n = n//f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\n\nn = int(sys.stdin.readline())\na = []\nfor i in range(n):\n    b,c = map(int, sys.stdin.readline().split())\n    a.append((b,c))\nans = 0\nif n == 1:\n    ans = a[0][0]\nelse:\n    arr = trial_division(a[0][0])\n    arr.extend(trial_division(a[0][1]))\n    divs = set(arr)\n    for i in range(1, n):\n        to_remove = set()\n        for d in divs:\n            if a[i][0] % d != 0 and a[i][1] % d != 0:\n                to_remove.add(d)\n        for r in to_remove:\n            divs.remove(r)\n    if len(divs) > 0:\n        ans = divs.pop()\n    else:\n        ans = -1\nprint(ans)\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nfrom operator import mul\n\n\ndef main():\n    input()\n    pp = set()\n    data = set(stdin.read().splitlines())\n    for a in set(map(int, min(data, key=len).split())):\n        for p in 2, 3, 5:\n            if not a % p:\n                pp.add(p)\n                while not a % p:\n                    a //= p\n        p = 7\n        while a >= p * p:\n            for s in 4, 2, 4, 2, 4, 6, 2, 6:\n                pp.add(p)\n                while not a % p:\n                    a //= p\n                p += s\n        if a > 1:\n            pp.add(a)\n    for s in data:\n        a = mul(*map(int, s.split()))\n        pp = [p for p in pp if not a % p]\n        if not pp:\n            print(-1)\n            return\n    print(max(pp))\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class edu_1025_B\n{\n    static long ans=1000000000;\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n    static HashSet<Long> h=new HashSet<Long>();\n    public static void main(String args[])throws IOException\n    {\n        Reader ob=new Reader();\n        int n=ob.nextInt();\n        long a[][]=new long[n][2];\n        long x=Long.MAX_VALUE;\n        long y=Long.MAX_VALUE;\n        for(int i=0;i<n;i++)\n        {\n            a[i][0]=ob.nextLong();\n            a[i][1]=ob.nextLong();\n        }\n        x=a[0][0]; y=a[0][1];\n\n        if(x%2 == 0) \n            h.add((long)2);\n        while(x%2 == 0) \n            x/=2;\n        long cx = x;\n        for(long i=3;i*i<=x;i+=2) \n        {\n            if(cx%i == 0)\n            {\n                while(cx%i == 0)\n                {\n                    cx/=i;\n                }\n                h.add(i);\n            }\n        }\n        if(cx != 1) \n        {\n            h.add(cx);\n        }\n\n        if(y%2 == 0) \n            h.add((long)2);\n        while(y%2 == 0) \n            y/=2;\n        long cy = y;\n        for(long i=3;i*i<=y;i+=2) \n        {\n            if(cy%i == 0)\n            {\n                while(cy%i == 0)\n                {\n                    cy/=i;\n                }\n                h.add(i);\n            }\n        }\n        if(cy != 1) \n        {\n            h.add(cy);\n        }\n        long fact=0;\n        Iterator<Long> it = h.iterator();\n        int k=0;\n        int flag=0, check=0;\n        while (it.hasNext())\n        {\n            fact=it.next();\n            flag=0;\n            for(int j=0;j<n;j++)\n            {\n                if(a[j][0]%fact==0 || a[j][1]%fact==0)\n                {\n                    flag++;   \n                }\n            }\n            if(flag==n)\n            {\n                System.out.println(fact);\n                check=1;\n                return;\n            }\n            k++;\n        }\n        if(check==0)\n            System.out.println(\"-1\");\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.ni();\n            if (n == 1) {\n                long a = in.nl();\n                long b = in.nl();\n                long curr = Math.max(a, b);\n                if (curr == 1) out.print(\"-1\");\n                else out.print(curr);\n            } else {\n                long a = in.nl();\n                long b = in.nl();\n                long gcd = a * b;\n                while (n-- > 1) {\n                    long x = in.nl();\n                    long y = in.nl();\n                    long curr = (x * y) / mathUtils.gcd(x, y);\n                    gcd = mathUtils.gcd(curr, gcd);\n                }\n                if (gcd == 1) out.print(\"-1\");\n                else {\n                    long xx = mathUtils.gcd(gcd, a);\n                    if (xx == 1) xx = mathUtils.gcd(gcd, b);\n                    boolean f = true;\n                    for (long i = 2; i <= Math.min(100000, xx); ++i) {\n                        if (xx % i == 0) {\n                            out.print(i);\n                            f = false;\n                            break;\n                        }\n                    }\n                    if (f) out.print(xx);\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int ni() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nl() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class mathUtils {\n        public static long gcd(long a, long b) {\n            if (b == 0) return a;\n            return gcd(b, a % b);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "import math\n\nn = int(input())\n\ndef primeFactor(n):\n\tfac = []\n\tcount = 0\n\twhile(n%2 == 0):\n\t\tcount += 1\n\t\tn = n // 2\n\tif count != 0:\n\t\tfac += [(2,count)]\n\ttop = math.floor(math.sqrt(n))\n\ti = 3\n\tcount = 0\n\twhile i <= top:\n\t\tif n%i == 0:\n\t\t\tcount += 1\n\t\t\tn = n // i\n\t\telse:\n\t\t\tif count != 0:\n\t\t\t\tfac += [(i,count)]\n\t\t\t\tcount = 0\n\t\t\ti += 2\t\n\tif n > 2:\n\t\tfac += [(n,1)]\n\treturn fac\n\n\ndef divisors(n):\n\tdivisors = []\n\tfac = primeFactor(n)\n\tlength = len(fac)\n\tfor pair in fac:\n\t\tnum = len(divisors)\n\t\tfor i in range(pair[1]):\n\t\t\tmult = pair[0]**(i+1)\n\t\t\tfor i in range(num):\n\t\t\t\tdivisors += [divisors[i]*mult]\n\t\t\tdivisors += [mult]\n\treturn divisors\n\n\ndef getFactors(n):\n\tpairs = primeFactor(n)\n\treturn [pair[0] for pair in pairs]\n\n\t\t\t\n\t\n\ntemp = []\n\nfor i in range(n):\n\tleft,right = map(int,input().split(\" \"))\n\tif i == 0:\n\t\tdivs = list(set(getFactors(left) + getFactors(right)))\n\telse:\n\t\ttemp = []\n\t\tfor i in divs:\n\t\t\tif left % i == 0 or right % i == 0:\n\t\t\t\ttemp += [i]\n\t\tdivs = temp\n\tif divs == []:\n\t\tprint(-1)\n\t\texit()\nprint(divs[0])\n"
        },
        {
            "language": 4,
            "solution": "import static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class x1025B\n{\n    public static void main(String hi[]) throws Exception\n    {\n        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(infile.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        HashSet<Long> primes = new HashSet<Long>();\n        long res = 0L;\n        long[][] vals = new long[N-1][2];\n        for(int i=0; i < N; i++)\n        {\n            st = new StringTokenizer(infile.readLine());\n            long a = Long.parseLong(st.nextToken());\n            long b = Long.parseLong(st.nextToken());\n            if(i == 0)\n            {\n                for(long v=2; v*v <= a; v++)\n                    if(a%v == 0)\n                    {\n                        while(a%v == 0)\n                            a /= v;\n                        primes.add(v);\n                    }\n                if(a > 1)\n                    primes.add(a);\n                for(long v=2; v*v <= b; v++)\n                    if(b%v == 0)\n                    {\n                        while(b%v == 0)\n                            b /= v;\n                        primes.add(v);\n                    }\n                if(b > 1)\n                    primes.add(b);\n            }\n            else\n            {\n                vals[i-1][0] = a;\n                vals[i-1][1] = b;\n            }\n        }\n        for(long p: primes)\n        {\n            boolean works = true;\n            for(int i=0; i < N-1; i++)\n                if(vals[i][0]%p > 0 && vals[i][1]%p > 0)\n                    works = false;\n            if(works)\n            {\n                System.out.println(p);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from math import gcd\n\nn = int(input())\na, b = [int(x) for x in input().split()]\nfor i in range(1, n):\n    x, y = [int(x) for x in input().split()]\n    xy = x * y\n    if a > 1:\n        a = gcd(a, xy)\n    if b > 1:\n        b = gcd(b, xy)\ng = max(a, b)\nif g == 1:\n    print(-1)\nelse:\n    i = 2\n    while i * i <= g:\n        if g % i == 0:\n            print(i)\n            break\n        i += 1\n    else:\n        print(g)\n  \t\t \t\t     \t \t \t\t   \t \t \t\t\t\t\t"
        },
        {
            "language": 4,
            "solution": "import java.io.*; \nimport java.util.*;\nimport java.math.*; \n\npublic class Main {\n\tstatic long gcd(long a,long b) {\n       if(a==0) {\n    \t   return b;\n       }\n       return gcd(b%a,a);\n    } \n\tpublic static void main(String[] args) throws IOException \n\t{ \n\t\tFastScanner f = new FastScanner(); \n\t\tint t=1;\n//\t\tt=f.nextInt();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\twhile(t>0) {\n\t\t\tt--;\n\t\t\tint n=f.nextInt();\n\t\t\tlong gcd=0;\n\t\t\tint a=0,b=0;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta=f.nextInt();\n\t\t\t\tb=f.nextInt();\n\t\t\t\tgcd=gcd(gcd,(long)a*b);\n\t\t\t}\n\t\t\tgcd=Math.max(gcd(gcd,(long)a),gcd(gcd,(long)b));\n\t\t\tlong ans=-1;\n\t\t\tfor(int i = 2;i*i<=gcd;i++) \n\t        { \n\t            if(gcd%i==0) {\n\t            \tans=i;\n\t            \tbreak;\n\t            }\n\t        }\n\t\t\tif(gcd>1 && ans==-1) {\n\t\t\t\tans=gcd;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.close();\n\t} \n\tstatic void sort(int [] a) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i: a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n    \n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tlong[] readLongArray(int n) {\n\t\t\tlong[] a=new long[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t}\n} \t"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\n\npublic class Main {\n\tpublic static class FastReader {\n\t\t\tBufferedReader br;\n\t\t\tStringTokenizer root;\n\t\t\t\n\t \n\t\t\tpublic FastReader() {\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t}\n\t \n\t\t\tString next() {\n\t\t\t\twhile (root == null || !root.hasMoreTokens()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\troot = new StringTokenizer(br.readLine());\n\t\t\t\t\t} catch (Exception addd) {\n\t\t\t\t\t\taddd.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn root.nextToken();\n\t\t\t}\n\t \n\t\t\tint nextInt() {\n\t\t\t\treturn Integer.parseInt(next());\n\t\t\t}\n\t \n\t\t\tdouble nextDouble() {\n\t\t\t\treturn Double.parseDouble(next());\n\t\t\t}\n\t \n\t\t\tlong nextLong() {\n\t\t\t\treturn Long.parseLong(next());\n\t\t\t}\n\t \n\t\t\tString nextLine() {\n\t\t\t\tString str = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tstr = br.readLine();\n\t\t\t\t} catch (Exception addd) {\n\t\t\t\t\taddd.printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn str;\n\t\t\t}\n\t\t}\n\t \n\tpublic static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n\tpublic static FastReader sc = new FastReader();\n \n\tstatic int mod = (int) (998244353),MAX=(int)(1e5+10);\n\tstatic List<Integer>[] edges;\n\tstatic int[][] dp;\n\tstatic int[][] tab;\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t  \n\t\tint n = sc.nextInt();\n\t\ttab = new int[n][2];\n\t\tfor(int i=0;i<n;++i) {\n\t\t\ttab[i][0] = sc.nextInt();\n\t\t\ttab[i][1] = sc.nextInt();\n\t\t}\n\t\n\t\tSet<Integer> primes = new HashSet<>();\n\t\tadd(primes, tab[0][0]);\n\t\tadd(primes, tab[0][1]);\n\t\tfor (int p : primes) {\n\t\t\tboolean ok = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (tab[i][0] % p != 0 && tab[i][1] % p != 0) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tout.println(p);\n\t\t\t\tout.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(-1);\n\t\tout.close();\n\t}\n\tprivate static void add(Set<Integer> primes, int n) {\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\tif (n % p == 0) {\n\t\t\t\tprimes.add(p);\n\t\t\t\twhile (n % p == 0) {\n\t\t\t\t\tn /= p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (n > 1) {\n\t\t\tprimes.add(n);\n\t\t}\n\t}\n\t\n\t\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n    public static void getDiv(long a, Set<Long> set) {\n        for (long i = 2; i * i <= a; i++) {\n            if (a % i == 0) {\n                set.add(i);\n                while (a % i == 0) {\n                    a /= i;\n                }\n            }\n        }\n        set.add(a);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        StringTokenizer st = new StringTokenizer(reader.readLine());\n        int n = Integer.parseInt(st.nextToken());\n\n        /*\n        for (int i = 0; i < n; i++) {\n            st = new StringTokenizer(reader.readLine());\n            long a = Long.parseLong(st.nextToken());\n            Set<Long> set = new HashSet<>();\n            getDiv(a, set);\n            System.out.println(set);\n        }\n        */\n\n        st = new StringTokenizer(reader.readLine());\n        long a = Long.parseLong(st.nextToken());\n        long b = Long.parseLong(st.nextToken());\n\n        Set<Long> set = new HashSet<>();\n        getDiv(a, set);\n        getDiv(b, set);\n\n        List<Long> first = new ArrayList<>(n);\n        List<Long> second = new ArrayList<>(n);\n        for (int i = 0; i < n - 1; i++) {\n            st = new StringTokenizer(reader.readLine());\n            first.add(Long.parseLong(st.nextToken()));\n            second.add(Long.parseLong(st.nextToken()));\n        }\n\n        long answer = -1;\n        for (long curr : set) {\n            if (curr == 1) {\n                continue;\n            }\n            answer = curr;\n            for (int i = 0; i < first.size(); i++) {\n                if (first.get(i) % curr != 0 && second.get(i) % curr != 0) {\n                    answer = -1;\n                    break;\n                }\n            }\n            if (answer != -1) {\n                break;\n            }\n        }\n\n        System.out.print(answer);\n\n        writer.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class WeakenedCommonDivisor {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    static class Solver {\n        private static boolean[] prime;\n        private static LinkedList<Integer> primes = new LinkedList<>();\n\n        private static void setPrime(int n) {\n            prime = new boolean[n+1];\n            for (int i = 2; i <= n; i++) prime[i] = true;\n            for (int i = 2; i <= Math.sqrt(n); i++) {\n                if(prime[i]) {\n                    for (int j = i + i; j <= n; j += i) prime[j] = false;\n                }\n            }\n            for (int i = 2; i <= n; i++) if (prime[i]) primes.add(i);\n        }\n\n        private void solve(InputReader inp, PrintWriter out) {\n            setPrime(44723);\n            int n = inp.nextInt();\n            int a = inp.nextInt(), b = inp.nextInt();\n            LinkedList<Integer> div = new LinkedList<>();\n            for (Integer p: primes) {\n                if (a % p == 0 || b % p == 0) div.add(p);\n                while (a % p == 0) a /= p;\n                while (b % p == 0) b /= p;\n            }\n            if (a != 1) div.add(a);\n            if (b != 1) div.add(b);\n\n            for (int i = 1; i < n; i++) {\n                Iterator it = div.iterator();\n                int c = inp.nextInt(), d = inp.nextInt();\n                while (it.hasNext()) {\n                    int p = (int) it.next();\n                    if (!(c % p == 0 || d % p == 0)) it.remove();\n                }\n            }\n            if (div.size() == 0) out.print(\"-1\");\n            else out.print(div.get(0));\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}"
        },
        {
            "language": 1,
            "solution": "import sys\nrange = xrange\n\ninp = [int(x) for line in sys.stdin for x in line.split()]\nii = 0\n\nn = inp[ii]\nii+=1\n\nvals = []\nfor _ in range(n):\n    a,b = inp[ii],inp[ii+1]\n    ii+=2\n    if b<a:a,b=b,a\n    vals.append((a,b))\nvals = sorted(set(vals))\n\npos_gcd = vals[0]\nfor _ in range(1,len(vals)):\n    A,B = vals[_]\n    tmp = []\n    for c in pos_gcd:\n        C = c\n        a = A\n        while C:\n            a,C=C,a%C\n        if a>1:\n            tmp.append(a)\n        \n        a = B\n        while c:\n            a,c=c,a%c\n        if a>1:\n            tmp.append(a)\n    if _%2==0:\n        pos_gcd = tmp\n    else:\n        pos_gcd = set(tmp)\n    #pos_gcd = {gcd(a,c) for c in pos_gcd} | {gcd(b,c) for c in pos_gcd}\n    #pos_gcd = set([gcd(a,c) for c in pos_gcd]+[gcd(b,c) for c in pos_gcd])\n\n\nwcd = max(pos_gcd or [1])\nif wcd==1:wcd=-1\nprint wcd\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 10;\nlong long gcd(long long a, long long b) {\n  if (a < b) swap(a, b);\n  int r = 1;\n  while (r) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\nlong long lcm(long long a, long long b) { return a * b / gcd(a, b); }\nlong long quick(long long a, long long b) {\n  long long sum = 1;\n  a = a % mod;\n  while (b) {\n    if (b % 2 == 1) sum = (sum * a) % mod;\n    b >>= 1;\n    a = (a * a) % mod;\n  }\n  return sum;\n}\nconst int maxn = 1e6 * 2;\nset<int> st;\nint k = 0;\nvoid fun(long long x) {\n  for (long long i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      st.insert(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x != 1) st.insert(x);\n}\nlong long a[maxn], b[maxn];\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) scanf(\"%lld %lld\", &a[i], &b[i]);\n  if (n == 1)\n    cout << a[0] << endl;\n  else {\n    fun(a[0]);\n    fun(b[0]);\n    long long ans = 0;\n    bool flag = false;\n    for (set<int>::iterator i = st.begin(); i != st.end(); i++) {\n      for (int j = 1; j < n; j++) {\n        if ((a[j] % (*i) == 0) || (b[j] % (*i) == 0)) {\n          ++ans;\n        } else {\n          ans = 0;\n          break;\n        }\n        if (ans == n - 1) {\n          cout << *i << endl;\n          flag = true;\n          return 0;\n        }\n      }\n    }\n    if (!flag) cout << -1 << endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\ndef factors(a,l):\n    for i in range(2,int(a**0.5)+1):\n        if a%i==0:\n            l.append(i)\n            while a%i==0:\n                a=a//i\n    if a>1:\n        l.append(a)\nn=int(input())\nl=[]\nk=[]\nfor i in range(n):\n    x,y=map(int,input().split())\n    if i==0:\n        factors(x,l)\n        factors(y,l)\n    k.append([x,y])\nl=list(set(l))\nfor i in l:\n    c=0\n    for j in k:\n        if j[0]%i and j[1]%i:\n            c=1\n            break\n    if c==0:\n        print(i)\n        break\nelse:\n    print(-1)\n    \n        \n        "
        },
        {
            "language": 1,
            "solution": "import decimal,math\nfrom collections import *\nfrom fractions import gcd\nfrom bisect import bisect_right,bisect_left\nimport sys\n\ndecimal.getcontext().prec = 15\n\ndef primeFactors(n): \n\tarr =set([])\n\twhile n % 2 == 0: \n\t\tarr.add(2) \n\t\tn = n / 2\n\tfor i in xrange(3,int(math.sqrt(n))+1,2): \n\t\twhile n % i== 0: \n\t\t\tarr.add(i) \n\t\t\tn = n / i \n\tif n > 2: \n\t\tarr.add(n)\n\t\t# print n\n\treturn arr\t \ndef z_advanced(s):\n\tZ = [0] * len(s)\n\tZ[0] = len(s) \n\trt = 0\n\tlt = 0\n\tfor k in xrange(1, len(s)):\n\t\tif k > rt:\n\t\t\tn = 0\n\t\t\twhile n + k < len(s) and s[n] == s[n+k]:\n\t\t\t\tn += 1\n\t\t\tZ[k] = n\n\t\t\tif n > 0:\n\t\t\t\tlt = k\n\t\t\t\trt = k+n-1\n\t\telse:\n\t\t\tp = k - lt  # Pair index.\n\t\t\tright_part_len = rt - k + 1 \n\t\t\tif Z[p] < right_part_len:\n\t\t\t\tZ[k] = Z[p]\n\t\t\telse:\n\t\t\t\ti = rt + 1\n\t\t\t\twhile i < len(s) and s[i] == s[i - k]:\n\t\t\t\t\ti += 1\n\t\t\t\tZ[k] = i - k\n \n\t\t\t\tlt = k\n\t\t\t\trt = i - 1\n\treturn max(Z)\ndef invmod(i,mod):\n\treturn pow(i,mod-2,mod)\t\ndef fact(mod):\n\tfac= [1,1]\n\tifac = [1,1]\n\tfor i in xxrange(2,(3*10**5+ 2)):\n\t\tfac.append((fac[-1]*i)%mod)\n\t\t# ifac.append((ifac[-1]*invmod(i,mod))%mod)\n\treturn fac,ifac\t\ndef SieveOfEratosthenes(n): \n\tprime = [True for i in xrange(n+1)] \n\tp = 2\n\twhile (p * p <= n): \n\t\tif (prime[p] == True): \n\t\t\t\n\t\t\tfor i in xrange(p * p, n+1, p): \n\t\t\t\tprime[i] = False\n\t\tp += 1\n\tarr=[]\n\tfor p in xrange(2, n): \n\t\tif prime[p]: \n\t\t\tarr.append(p)\n\treturn arr\ndef maxSubArraySum(a):\n\tsize=len(a)       \n\tmax_so_far =a[0] \n\tcurr_max = a[0] \n\tfor i in xrange(1,size): \n\t\tcurr_max = max(a[i], curr_max + a[i]) \n\t\tmax_so_far = max(max_so_far,curr_max) \n\treturn max_so_far \t\ndef fi():\n\treturn int(sys.stdin.readline())\n \ndef fi2():\n\treturn map(int, sys.stdin.readline().split())\n \ndef fi3():\n\treturn sys.stdin.readline()\n \ndef fo(*args):\n\tfor s in args:\n\t\tsys.stdout.write(str(s)+' ')\n\tsys.stdout.write('\\n')\n\nn = fi()\nans=[]\nfor i in range(n):\n\tp = fi2()\n\tans.append(p)\nx=ans[0][0]\ny=ans[0][1]\ncool =  primeFactors(x).union(primeFactors(y))\nfor k in cool:\n    flag=0\n    for pp in ans:\n        if(pp[0]%k!=0 and pp[1]%k!=0):\n            flag=1\n    if(flag==0):\n        print k\n        exit()\nprint -1\n\n# # for i in range(1,n):\n# # \tx=max(gcd(x,ans[i][0]),gcd(x,ans[i][1]))\n# # \ty=max(gcd(y,ans[i][1]),gcd(y,ans[i][0]))\n# print x,y\t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_size = 2e5;\nint num, n;\nint arr[max_size];\nint brr[max_size];\nint prime[max_size];\nvoid get_prime(int x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      prime[num++] = i;\n      while (x % i == 0) x = x / i;\n    }\n  }\n  if (x > 1) prime[num++] = x;\n}\nint main() {\n  while (cin >> n) {\n    num = 0;\n    int ans = -1;\n    for (int i = 0; i < n; i++) cin >> arr[i] >> brr[i];\n    get_prime(arr[0]);\n    get_prime(brr[0]);\n    for (int i = 0; i < num; i++) {\n      bool vis = true;\n      for (int j = 0; j < n; j++) {\n        if (arr[j] % prime[i] != 0 && brr[j] % prime[i] != 0) {\n          vis = false;\n          break;\n        }\n      }\n      if (vis) {\n        ans = prime[i];\n        break;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import gcd,sqrt\ndef divsor(n):\n    for i in range(2,int(sqrt(n))+1):\n        if n%i==0:\n            return i\n    return n\nn=int(input())\na,b=map(int,input().split())\nfor i in range(n-1):\n    c,d=map(int,input().split())\n    a=gcd(c*d,a);b=gcd(c*d,b)\nif a!=1:\n    print(divsor(a))\nelif b!=1:\n    print(divsor(b))\nelse:\n    print(-1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long arr[160000];\nlong long arr1[160000];\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  long long a, b;\n  for (int i = 0; i < n; i++) {\n    cin >> a >> b;\n    arr[i] = a * b;\n    arr1[i] = a;\n  }\n  long long x = arr[0];\n  for (int i = 1; i < n; i++) {\n    x = gcd(x, arr[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    long long y = gcd(x, arr1[i]);\n    if (y != 1) {\n      x = y;\n    }\n  }\n  if (x == 1LL)\n    cout << -1 << endl;\n  else {\n    cout << x << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> v;\nvoid divisors(long long n) {\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      while (n % i == 0) {\n        n /= i;\n      }\n      v.push_back(i);\n    }\n  }\n  if (n > 1) v.push_back(n);\n}\nint main() {\n  int n;\n  long long a, b;\n  cin >> n;\n  cin >> a >> b;\n  divisors(a);\n  divisors(b);\n  for (int i = 0; i < n - 1; i++) {\n    vector<long long> p;\n    cin >> a >> b;\n    for (auto it : v) {\n      if (a % it == 0 || b % it == 0) {\n        p.push_back(it);\n      }\n    }\n    v = p;\n  }\n  if (v.empty()) {\n    cout << -1 << endl;\n  } else {\n    cout << v[0] << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class GFG {\n    static class Pair{\n        int f,s;\n        public Pair(int first,int second){\n            f=first;\n            s=second;\n        }\n    }\n     static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\tpublic static void main (String[] args) {\n\t\tFastReader sc=new FastReader();\n\t\tint n=sc.nextInt();\n\t\tArrayList<Pair> al=new ArrayList<>();\n\t\tint min=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<n;i++){\n\t\t    int a1=sc.nextInt(),a2=sc.nextInt();\n\t\t    al.add(new Pair(a1,a2));\n\t\t}\n\t\tHashSet<Integer> set=new HashSet<>();\n\t\tint value1=al.get(0).f,value2=al.get(0).s;\n\t\twhile(value1%2==0){\n\t\t    if(!set.contains(2))\n\t\t            set.add(2);\n\t\t    value1/=2;\n\t\t}\n\t\tfor(int i=3;i<=Math.sqrt(value1);i+=2){\n\t\t    if(value1%i==0){\n\t\t        if(!set.contains(i))\n\t\t            set.add(i);\n\t\t        while(value1%i==0)\n\t\t            value1/=i;\n\t\t    }\n\t\t}\n\t\tif(value1>2)\n\t\t    set.add(value1);\n\t\twhile(value2%2==0){\n\t\t    if(!set.contains(2))\n\t\t            set.add(2);\n\t\t    value2/=2;\n\t\t}\n\t\tfor(int i=3;i<=Math.sqrt(value2);i+=2){\n\t\t    if(value2%i==0){\n\t\t        if(!set.contains(i))\n\t\t            set.add(i);\n\t\t        while(value2%i==0)\n\t\t           value2/=i;\n\t\t    }\n\t\t}\n\t\tif(value2>2)\n\t\t    set.add(value2);\n\t\tint flag=0;\n\t\tfor(Integer x:set){\n\t\t    int count=0;\n\t\t    for(int j=0;j<n;j++){\n\t\t        Pair p=al.get(j);\n\t\t        if(p.f%x==0 || p.s%x==0)\n\t\t            count++;\n\t\t    }\n\t\t    if(count==n){\n\t\t        System.out.println(x);\n\t\t        flag=1;\n\t\t        break;\n\t\t    }\n\t\t}\n\t\tif(flag==0)\n\t\t    System.out.println(-1);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool is_prime(long long i) {\n  for (long long j = 2; j <= sqrt(i); j++) {\n    if (i % j == 0) return false;\n  }\n  return true;\n}\nset<long long> find_factors(long long x, long long y) {\n  set<long long> A;\n  while (x % 2 == 0) {\n    x = x / 2;\n    A.insert(2);\n  }\n  for (long long i = 3; i <= sqrt(x); i += 2) {\n    while (x % i == 0) {\n      x = x / i;\n      A.insert(i);\n    }\n  }\n  if (x > 2) A.insert(x);\n  while (y % 2 == 0) {\n    y = y / 2;\n    A.insert(2);\n  }\n  for (long long i = 3; i <= sqrt(y); i += 2) {\n    while (y % i == 0) {\n      y = y / i;\n      A.insert(i);\n    }\n  }\n  if (y > 2) A.insert(y);\n  return A;\n}\nint main() {\n  long long n;\n  cin >> n;\n  vector<pair<long long, long long>> A;\n  for (long long i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    A.push_back(make_pair(x, y));\n  }\n  long long x = A[0].first;\n  long long y = A[0].second;\n  set<long long> factors = find_factors(x, y);\n  bool ans = 0;\n  for (auto it : factors) {\n    bool flag = true;\n    for (long long i = 0; i < n; i++) {\n      if (A[i].first % it != 0 && A[i].second % it != 0) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) {\n      cout << it << endl;\n      ans = 1;\n      break;\n    }\n  }\n  if (!ans) cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, a[150005], b[150005], x = 0;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i] >> b[i];\n    x = gcd(a[i] * b[i], x);\n  }\n  if (x == 1) return puts(\"-1\\n\"), 0;\n  for (int i = 1; i <= n; i++) {\n    gcd(x, a[i]) > 1 ? x = gcd(x, a[i]) : x = gcd(x, b[i]);\n  }\n  return cout << x << \"\\n\", 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "// Problem: C. Board Moves\n// Contest: Codeforces - Codeforces Round #642 (Div. 3)\n// URL: https://codeforces.com/contest/1353/problem/C\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\nimport java.util.*;\nimport java.io.*;\nimport java.lang.*;\npublic class Main\n{\n\tpublic static Scanner scan = new Scanner(System.in);\n\tstatic long gcd(long A,long B)\n\t{\n\t\tif(A==0)\n\t\t\treturn B;\n\t\tif(B==0)\n\t\t\treturn A;\n\t\treturn gcd(B,A%B);\n\t}\n\tstatic int lower_bound(long[] a,int N,long value)\n    {\n    \tint low = 0,high = N;\n    \twhile(low<high)\n    \t{\n    \t\tint mid = low + (high-low)/2;\n    \t\tif(a[mid]==value)\n    \t\t\thigh=mid;\n    \t\telse if(a[mid]<value)\n    \t\t\tlow=mid+1;\n    \t\telse\n    \t\t\thigh=mid;\n    \t}\n    \tif(a[low]!=value)\n    \t\treturn low+1;\n    \treturn low;\n    }\n    static int upper_bound(long[] a,int N,long value)\n    {\n    \tint low = 0,high = N;\n    \twhile(low<high)\n    \t{\n    \t\tint mid = low + (high-low)/2;\n    \t\tif(a[mid]==value)\n    \t\t\tlow=mid+1;\n    \t\telse if(a[mid]<value)\n    \t\t\tlow=mid+1;\n    \t\telse\n    \t\t\thigh=mid;\n    \t}\n    \tif(a[high]!=value)\n    \t\treturn high+1;\n    \treturn high;\n    }\n  \tpublic static void main(String args[])\n    {\n        int testcases=1;\n        //testcases = scan.nextInt();\n        while(testcases-->0)\n        {\n            solve();\n        }\n    }\n    static void solve()\n    {\n      \tint N= scan.nextInt();\n      \tlong []A = new long[N];\n      \tlong []B = new long[N];\n      \tfor(int i=0;i<N;i++)\n      \t{\n      \t\tA[i]=scan.nextLong();\n      \t\tB[i]=scan.nextLong();\n      \t}\n      \tlong x1 = A[0],x2=B[0];\n      \tArrayList<Long> div = new ArrayList<Long>();\n      \tArrayList<Long> div1= new ArrayList<Long>();\n      \tArrayList<Long> div2= new ArrayList<Long>();\n      \tfor(long i=2;i*i<=x1;i++)\n      \t{\n      \t\tif(x1%i==0)\n      \t\t{\n      \t\t\tdiv.add(i);\n      \t\t\tif(i*i!=x1)\n      \t\t\t\tdiv.add(x1/i);\n      \t\t}\n      \t}\n      \tfor(long i=2;i*i<=x2;i++)\n      \t{\n      \t\tif(x2%i==0)\n      \t\t{\n      \t\t\tdiv.add(i);\n      \t\t\tif(i*i!=x2)\n      \t\t\t\tdiv.add(x2/i);\n      \t\t}\n      \t}\n      \tdiv.add(x1);\n      \tdiv.add(x2);\n      \tfor(int i=0;i<div.size();i++)\n      \t{\n      \t\tlong r = div.get(i);\n      \t\tboolean flag=true;\n      \t\tfor(long j=2;j*j<=r;j++)\n      \t\t{\n      \t\t\tif(r%j==0)\n      \t\t\t{\n      \t\t\t\tflag=false;\n      \t\t\t\tbreak;\n      \t\t\t}\n      \t\t}\n      \t\tif(flag)\n      \t\t\tdiv2.add(r);\n      \t}\n      \tCollections.sort(div2);\n      \tlong rec=div2.get(0);\n      \tdiv1.add(rec);\n      \tfor(int i=0;i<div2.size();i++)\n      \t{\n      \t\tif(rec!=div2.get(i))\n      \t\t{\n      \t\t\trec=div2.get(i);\n      \t\t\tdiv1.add(rec);\n      \t\t}\n      \t}\n      \t// for(long r: div1)\n      \t\t// System.out.print(r+\" \");\n      \t// System.out.println();\n      \tfor(int i=0;i<div1.size();i++)\n      \t{\n      \t\tint count=0;\n      \t\tlong r = div1.get(i);\n      \t\tfor(int j=1;j<N;j++)\n      \t\t{\n      \t\t\tif(A[j]%r==0||B[j]%r==0)\n      \t\t\t\tcount++;\n      \t\t}\n      \t\tif(count==N-1)\n      \t\t{\n      \t\t\tSystem.out.println(r);\n      \t\t\treturn;\n      \t\t}\n      \t}\n      \tSystem.out.println(\"-1\");\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 150000 + 10;\nint n = 0;\nvector<pair<int, int> > wc;\nset<int> st, st1;\nvoid pre_solve() {\n  int flag = 0;\n  int i = 2;\n  int tmp1 = wc[0].first;\n  int p = sqrt(wc[0].first + 1);\n  while (tmp1 > 1 && i <= p) {\n    if (tmp1 % i == 0) {\n      flag = 1;\n      st.insert(i);\n      tmp1 /= i;\n      while (tmp1 % i == 0) {\n        tmp1 /= i;\n      }\n      ++i;\n    } else {\n      ++i;\n      continue;\n    }\n  }\n  if (flag == 0) {\n    st.insert(wc[0].first);\n  }\n  if (tmp1 > 1) {\n    st.insert(tmp1);\n  }\n  i = 2, flag = 0;\n  int tmp2 = wc[0].second;\n  p = sqrt(wc[0].second + 1);\n  while (tmp2 > 1 && i <= p) {\n    if (tmp2 % i == 0) {\n      flag = 1;\n      st.insert(i);\n      tmp2 /= i;\n      while (tmp2 % i == 0) {\n        tmp2 /= i;\n      }\n      ++i;\n    } else {\n      ++i;\n      continue;\n    }\n  }\n  if (flag == 0) {\n    st.insert(wc[0].second);\n  }\n  if (tmp2 > 1) {\n    st.insert(tmp2);\n  }\n}\nint main() {\n  while (scanf(\"%d\", &n) != EOF) {\n    wc.clear();\n    st.clear();\n    int x = 0, y = 0;\n    for (int i = 0; i < n; ++i) {\n      scanf(\"%d %d\", &x, &y);\n      wc.push_back(pair<int, int>(x, y));\n    }\n    pre_solve();\n    set<int>::iterator it;\n    for (int i = 1; i < n; ++i) {\n      st1.clear();\n      for (it = st.begin(); it != st.end(); it++) {\n        if (wc[i].first % *it == 0 || wc[i].second % *it == 0) {\n          st1.insert(*it);\n        }\n      }\n      if (st1.size() == 0) {\n        printf(\"-1\\n\");\n        st = st1;\n        break;\n      }\n      st = st1;\n    }\n    set<int>::iterator it1 = st.begin();\n    if (st.size() != 0) {\n      printf(\"%d\\n\", *it1);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class second\n{\t\n\tstatic BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter pw=new PrintWriter(System.out);\n\tstatic StringTokenizer st;\n\t\n\tstatic StringTokenizer read() throws IOException\n\t{\treturn new StringTokenizer(br.readLine());\n\t}\n\t\n\tstatic int nextInt(StringTokenizer st)\n\t{\treturn Integer.parseInt(st.nextToken());\n\t}\n\t\n\tpublic static HashSet<Integer> set;\n\tpublic static void primeFactors(int n)\n    {  \twhile (n%2==0)\n        {   set.add(2);\n            n /= 2;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i+= 2)\n        {   while (n%i == 0)\n            {  \tset.add(i);\n                n /= i;\n            }\n        }     \n        if(n>2)\n        \tset.add(n);\n    }\n    \n    static class pair\n    {  \tint a,b;\n    \tpair(int x,int y)\n    \t{\ta=x;\n    \t\tb=y;\n    \t}\n    }\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\tst=read();\n\t\tint n=nextInt(st);\n\t\tpair[] arr=new pair[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\tst=read();\n\t\t\tarr[i]=new pair(nextInt(st),nextInt(st));\n\t\t}\n\t\tset=new HashSet<>();\n\t\tprimeFactors(arr[0].a);\n\t\tprimeFactors(arr[0].b);\n\t\tObject[] lis=set.toArray();\n\t\tint index=set.size();\n\t\twhile(index-->0)\n\t\t{\tint temp=(int) lis[index];\n\t\t\tint flag=1;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\tif(arr[i].a%temp!=0 && arr[i].b%temp!=0)\n\t\t\t\t{\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==1)\n\t\t\t{\tSystem.out.println(temp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nint readInt() {\n  bool minus = false;\n  int result = 0;\n  char ch;\n  ch = getchar();\n  while (true) {\n    if (ch == '-') break;\n    if (ch >= '0' && ch <= '9') break;\n    ch = getchar();\n  }\n  if (ch == '-')\n    minus = true;\n  else\n    result = ch - '0';\n  while (true) {\n    ch = getchar();\n    if (ch < '0' || ch > '9') break;\n    result = result * 10 + (ch - '0');\n  }\n  if (minus)\n    return -result;\n  else\n    return result;\n}\nlong long n, ans, factor[10001];\nlong long tol;\nlong long mult_mod(long long a, long long b, long long c) {\n  a %= c;\n  b %= c;\n  long long ret = 0;\n  while (b) {\n    if (b & 1) {\n      ret += a;\n      ret %= c;\n    }\n    a <<= 1;\n    if (a >= c) a %= c;\n    b >>= 1;\n  }\n  return ret;\n}\nlong long pow_mod(long long x, long long n, long long mod) {\n  if (n == 1) return x % mod;\n  x %= mod;\n  long long tmp = x;\n  long long ret = 1;\n  while (n) {\n    if (n & 1) ret = mult_mod(ret, tmp, mod);\n    tmp = mult_mod(tmp, tmp, mod);\n    n >>= 1;\n  }\n  return ret;\n}\nbool check(long long a, long long n, long long x, long long t) {\n  long long ret = pow_mod(a, x, n);\n  long long last = ret;\n  for (int i = 1; i <= t; i++) {\n    ret = mult_mod(ret, ret, n);\n    if (ret == 1 && last != 1 && last != n - 1) return true;\n    last = ret;\n  }\n  if (ret != 1) return true;\n  return false;\n}\nbool Miller_Rabin(long long n) {\n  if (n < 2) return false;\n  if (n == 2 || n == 3 || n == 5 || n == 7) return true;\n  if (n == 1 || (n % 2 == 0) || (n % 3 == 0) || (n % 5 == 0) || (n % 7 == 0))\n    return false;\n  long long x = n - 1;\n  long long t = 0;\n  while ((x & 1) == 0) {\n    x >>= 1;\n    t++;\n  }\n  for (int i = 0; i < 3; i++) {\n    long long a = rand() % (n - 1) + 1;\n    if (check(a, n, x, t)) return false;\n  }\n  return true;\n}\nlong long gcd(long long a, long long b) {\n  if (a == 0) return 1;\n  if (a < 0) return gcd(-a, b);\n  while (b) {\n    long long t = a % b;\n    a = b;\n    b = t;\n  }\n  return a;\n}\nlong long Pollard_rho(long long x, long long c) {\n  long long i = 1, k = 2;\n  long long x0 = rand() % x;\n  long long y = x0;\n  while (1) {\n    i++;\n    x0 = (mult_mod(x0, x0, x) + c) % x;\n    long long d = gcd(y - x0, x);\n    if (d != 1 && d != x) return d;\n    if (y == x0) return x;\n    if (i == k) {\n      y = x0;\n      k += k;\n    }\n  }\n}\nset<long long> st;\nvoid findfac(long long n) {\n  if (Miller_Rabin(n)) {\n    st.insert(n);\n    return;\n  }\n  long long p = n;\n  while (p >= n) p = Pollard_rho(p, rand() % (n - 1) + 1);\n  findfac(p);\n  findfac(n / p);\n}\nlong long as[150005], bs[150005];\nlong long anss[10000];\nint ansy[10000], cnt = 0;\nvoid solve() {\n  st.clear();\n  int n = readInt();\n  long long minS, mini = 0;\n  as[0] = readInt();\n  bs[0] = readInt();\n  minS = as[0] + bs[0];\n  for (int i = 1; i < n; ++i) {\n    as[i] = readInt();\n    bs[i] = readInt();\n    long long nows = as[i] + bs[i];\n    if (nows < minS) {\n      minS = nows;\n      mini = i;\n    }\n  }\n  findfac(as[mini]);\n  findfac(bs[mini]);\n  memset(anss, 0, sizeof(anss));\n  for (auto i : st) {\n    anss[cnt++] = i;\n  }\n  memset(ansy, 0, sizeof(int) * cnt);\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < cnt; ++j) {\n      if (((as[i] >= anss[j]) && ((as[i] % anss[j]) == 0)) ||\n          ((bs[i] >= anss[j]) && ((bs[i] % anss[j]) == 0))) {\n        ansy[j]++;\n      }\n    }\n  }\n  for (int i = 0; i < cnt; i++) {\n    if (ansy[i] == n) {\n      cout << anss[i] << endl;\n      return;\n    }\n  }\n  cout << -1 << endl;\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class Soly {\n\n    static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public static void main(String[] args) throws IOException {\n        Scanner in = new Scanner(System.in);\n        try (PrintWriter or = new PrintWriter(System.out)) {\n            int n = in.nextInt();\n            long[] f = new long[n], s = new long[n];\n            long gcd = 0;\n            for (int i = 0; i < n; i++) {\n                f[i] = in.nextLong();\n                s[i] = in.nextLong();\n                gcd = gcd(gcd, f[i] * s[i] * 1L);\n            }\n            if (gcd == 1) {\n                or.println(-1);\n            } else {\n\n                for (int i = 0; i < n; i++) {\n                    long temp = gcd(gcd, f[i]);\n                    if (temp != 1) {\n                        gcd = temp;\n                    } else {\n                        gcd = gcd(gcd, s[i]);\n                    }\n                }\n                or.println(gcd);\n            }\n        }\n    }\n\n    static class Scanner {\n\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++) {\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec) {\n                        f *= 10;\n                    }\n                }\n            }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n    }\n\n}\n\nclass Pair8 {\n\n    int from;\n    int to;\n\n    // int min;\n    public Pair8(int from, int to) {\n        this.from = from;\n        this.to = to;\n        //min = m;\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Weakened {\n    static boolean debug = false;\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] arr = new int[n][2];\n        for (int i = 0; i < n; i++){\n            arr[i][0] = sc.nextInt();\n            arr[i][1] = sc.nextInt();\n        }\n        Set<Integer> set = new HashSet<>();\n        addPrimeDivisors(set, arr[0][0]);\n        addPrimeDivisors(set, arr[0][1]);\n\n        for (int[] pair:arr){\n            Set<Integer> remove = new HashSet<>();\n            for (int d:set){\n                if (pair[0]%d > 0 && pair[1]%d > 0)\n                    remove.add(d);\n            }\n            set.removeAll(remove);\n        }\n        int ret = -1;\n        for (int d:set)\n            ret = d;\n        System.out.println(ret);\n    }\n\n    static void addPrimeDivisors(Set<Integer> set, int a){\n        // System.out.println(\"addPrimeDivisors, a=\"+a);\n        for (int d = 2; d*d <= a; d++){\n            if (a % d == 0){\n                // System.out.println(\"find. \" + d);\n                set.add(d);\n                while (a%d==0)\n                    a/=d;\n            }\n        }\n        if (a > 1){\n            // System.out.println(\"find. \" + a);\n            set.add(a);\n        }\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\n\n\ndef factorize(n):  # o(sqr(n))\n    c, ans = 1, []\n    while (c * c < n):\n        if n % c == 0:\n            ans.extend([c, n // c])\n        c += 1\n\n    if c * c == n:\n        ans.append(c)\n    return sorted(ans)\n\n\ndef prime_fac(n):  # sorted factors\n    primes, ans = set(), factorize(n)[1:]\n    for i in ans:\n        while n % i == 0:\n            n //= i\n            primes.add(i)\n    return list(primes)\n\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrints_2d = lambda n: [rints() for _ in range(n)]\n\nn = int(input())\na = rints_2d(n)\nfor i in range(2):\n    for f in prime_fac(a[0][i]):\n        ans = 1\n        for j in range(1, n):\n            ans &= a[j][0] % f == 0 or a[j][1] % f == 0\n        if ans:\n            print(f)\n            exit()\n\nprint(-1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 10;\nconst int inf = 0x3f3f3f3f;\nlong long n, m, p[maxn];\nset<int> prime;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nvoid find(long long x) {\n  for (long long i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      prime.insert(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) prime.insert(x);\n}\nint main() {\n  int i, j;\n  prime.clear();\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    long long x, y, te;\n    scanf(\"%I64d %I64d\", &x, &y);\n    if (i == 1) {\n      find(x);\n      find(y);\n    }\n    te = gcd(x, y);\n    p[i] = x * y / te;\n  }\n  long long t = p[1];\n  for (long long i = 2; i <= n; i++) {\n    t = gcd(t, p[i]);\n  }\n  set<int>::iterator it;\n  for (it = prime.begin(); it != prime.end(); it++) {\n    if (t % (*it) == 0) {\n      t = *it;\n      break;\n    }\n  }\n  if (t == 1)\n    printf(\"-1\\n\");\n  else {\n    printf(\"%lld\\n\", t);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import math\nimport sys\n\ndef primes(num):\n    pf=set([])\n    if(not num%2):\n        pf.add(2)\n    while(not num%2):\n        num/=2\n    for k in range(3, int(math.sqrt(num))+1):\n        if(not num%k):\n            pf.add(k)\n        while(not num%k):\n            num/=k\n    if(num>1):\n        pf.add(num)\n    return pf\n\nn=input()\narray=[]\nfor i in range(n):\n    p,q=map(int,raw_input().split())\n    array.append([p,q])\npf=primes(array[0][0]).union(primes(array[0][1]))\nfor k in pf:\n    kkk=0\n    for pp in array:\n        if(pp[0]%k!=0 and pp[1]%k!=0):\n            kkk=1\n    if(not kkk):\n        print k\n        sys.exit()\nprint -1\n"
        },
        {
            "language": 4,
            "solution": "import java.security.KeyPair;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class D\n{\n    public static ArrayList<Integer> getFactors(int n)\n    {\n        ArrayList<Integer> res = new ArrayList<Integer>();\n        if(n%2==0)\n        {\n            res.add(2);\n            while(n%2==0)\n                n/=2;\n        }\n        for(int i=3;i<=(Math.sqrt(n));i+=2)\n            if(n%i==0)\n            {\n                res.add(i);\n                while(n%i==0)\n                    n/=i;\n            }\n        if(n>2)\n            res.add(n);\n        return res;\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int ta= scanner.nextInt(), tb = scanner.nextInt();\n        ArrayList<Integer> fa = getFactors(ta);\n        ArrayList<Integer> fb = getFactors(tb);\n        ArrayList<Integer> fin = null;\n        for(int i=1;i<n;++i)\n        {\n//            System.out.print(\"Finish list is:\");\n//            if(fin!=null) {\n//                for (int j : fin)\n//                    System.out.print(j+ \" \");\n//                System.out.println();\n//            }\n//            else {\n//                for(int j:fa)\n//                    System.out.print(j +\" \" );\n//                for(int j:fb)\n//                    System.out.print(j+ \" \");\n//                System.out.println();\n//            }\n            int a= scanner.nextInt(), b= scanner.nextInt();\n            fin = checkFactors(a,b,fa,fb,fin);\n        }\n        if(n==1)\n        {\n            System.out.println(fa.get(0));\n        }\n        else if(fin.size()==0)\n            System.out.println(-1);\n        else\n            System.out.println(fin.get(0));\n    }\n\n    private static ArrayList<Integer> checkFactors(int a, int b, ArrayList<Integer> fa, ArrayList<Integer> fb, ArrayList<Integer> fin) {\n        ArrayList<Integer> res = new ArrayList<Integer>();\n        if(fin==null) {\n            for (int i : fa) {\n                if (a % i == 0 && b % i == 0)\n                    res.add(i);\n                else if (a % i == 0)\n                    res.add(i);\n                else if (b % i == 0)\n                    res.add(i);\n            }\n            for (int i : fb) {\n                if (a % i == 0 && b % i == 0)\n                    res.add(i);\n                else if (a % i == 0)\n                    res.add(i);\n                else if (b % i == 0)\n                    res.add(i);\n            }\n        }\n        else\n        {\n            for(int i:fin)\n            {\n                if (a % i == 0 && b % i == 0)\n                    res.add(i);\n                else if (a % i == 0)\n                    res.add(i);\n                else if (b % i == 0)\n                    res.add(i);\n            }\n        }\n        return res;\n    }\n}"
        },
        {
            "language": 1,
            "solution": "n=input()\nfrom fractions import gcd\nfrom math import *\nfrom sys import *\nfv=[]\nfor i in range(0,n):\n    a,b=[int(x) for x in stdin.readline().split()]\n    if i==0:\n        g1=a\n        g2=b\n        e1=a\n        e2=b\n    else:\n        g1=gcd(g1,a*b)\n        g2=gcd(g2,a*b)\n    fv.append((a,b))\n\nif g1==1 and g2==1:\n    print -1\nelse:\n    ans=[]\n    for i in range(2,int(sqrt(e1))+5):\n        if e1%i==0:\n            while e1%i==0:\n                e1=e1/i\n        ans.append(i)\n    for i in range(2,int(sqrt(e2))+5):\n        if e2%i==0:\n            while e2%i==0:\n                e2=e2/i\n        ans.append(i)\n    if e1>1:\n        ans.append(e1)\n    if e2>1:\n        ans.append(e2)\n    lk=list(set(ans))\n    #kc=0\n    for i in lk:\n        kc=0\n        for j in fv:\n            if gcd(i,j[0])<=1 and gcd(i,j[1])<=1:\n                kc=-1\n                break\n        if kc==0:\n            print i\n            exit()\n    print -1\n\n"
        },
        {
            "language": 3,
            "solution": "def gcd(a,b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b,a%b)\ntest = int(input())\nlist = [tuple(map(int, input().split())) for i in range(test)]\nans = 0\nfor a,b in list:\n    ans = gcd(a*b,ans)\n\nfor a,b in list:\n    if gcd(ans,b) != 1:\n        ans = gcd(ans,b)\n    else:\n        ans = gcd(ans,a)\nif ans == 1:\n    print(-1)\nelse:\n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint Mark[1000050 + 50], prime[1000050 + 50], cnt, poss[1000050], ccnt,\n    kick[1000050];\nvoid Prime() {\n  memset(Mark, 0, sizeof(Mark));\n  for (int i = 2; i < 1000050; i++) {\n    if (Mark[i] == 0) {\n      prime[++cnt] = i;\n    }\n    for (int j = 1; j <= cnt && prime[j] * i < 1000050; j++) {\n      Mark[i * prime[j]] = 1;\n      if (i % prime[j] == 0) {\n        break;\n      }\n    }\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  Prime();\n  int a, b;\n  scanf(\"%d%d\", &a, &b);\n  for (register int i = 1; i <= cnt; ++i) {\n    if (a % prime[i] == 0) poss[++ccnt] = prime[i];\n    while (a % prime[i] == 0) a /= prime[i];\n    if (b % prime[i] == 0) poss[++ccnt] = prime[i];\n    while (b % prime[i] == 0) b /= prime[i];\n  }\n  if (a > 1) poss[++ccnt] = a;\n  if (b > 1) poss[++ccnt] = b;\n  n--;\n  while (n--) {\n    scanf(\"%d%d\", &a, &b);\n    for (register int i = 1; i <= ccnt; i++) {\n      if (a % poss[i] != 0 && b % poss[i] != 0) kick[i] = 1;\n    }\n  }\n  for (register int i = 1; i <= ccnt; i++)\n    if (!kick[i]) return printf(\"%d\\n\", poss[i]), 0;\n  printf(\"-1\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\n\nimport java.io.*;\nimport java.math.*;\npublic class A\n\t\n\t{ \n\t\t static FastReader sc=new FastReader(); \n\t\t \n\t\t\t  public static void main(String[] args)\n\t    {\n\t\t\t\t    //CHECK FOR N=1\n\t       \t//CHECK FOR N=1\n\t\t    //CHECK FOR N=1\n\t       \t//CHECK FOR N=1\n\t\t  \n\t\t  PrintWriter out=new PrintWriter(System.out);\n\t\t  StringBuffer sb=new StringBuffer(\"\");\n\t  int ttt=1;\n\t    // ttt =i(); \n\t \n        outer :while (ttt-- > 0) \n\t\t{\n        \tint n=i();\n        \tint A[]=new int[n];\n        \tint B[]=new int[n];\n        \tinput(A, B);\n        \tHashMap<Integer,Integer> map=new HashMap<Integer, Integer>();\n        \tfor(int i=2;i*i<=A[0];i++) {\n        \t\tif(A[0]%i==0) {\n        \t\t\twhile(A[0]%i==0) {\n        \t\t\t\tA[0]/=i;\n        \t\t\t\tmap.put(i, 1);\n        \t\t\t}\n        \t\t}\n        \t}\n        \tif(A[0]>1) {\n        \t\tmap.put(A[0],1);\n        \t}\n        \tA[0]=B[0];\n        \tfor(int i=2;i*i<=A[0];i++) {\n        \t\tif(A[0]%i==0) {\n        \t\t\twhile(A[0]%i==0) {\n        \t\t\t\tA[0]/=i;\n        \t\t\t\tmap.put(i, 1);\n        \t\t\t}\n        \t\t}\n        \t}\n        \tif(A[0]>1) {\n        \t\tmap.put(A[0],1);\n        \t}\n        \tfor(int i : map.keySet()) {\n        \t\tint f=-1;\n        \t\tfor(int j=1;j<n;j++) {\n        \t\t\tif(A[j]%i!=0 && B[j]%i!=0) {\n        \t\t\t\tf=1;\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n        \t\tif(f==-1) {\n        \t\t\tSystem.out.println(i);\n        \t\t\treturn;\n        \t\t}\n        \t}\n        \tSystem.out.println(\"-1\");\n        \t\n        \t\n        \t\n\t\t}\n\t   out.close();\n      // System.out.println(sb.toString());\n       \n       \n       //CHECK FOR N=1                    //CHECK FOR M=0\n        //CHECK FOR N=1                    //CHECK FOR M=0\n       \t//CHECK FOR N=1\n       \t//CHECK FOR N=1\n       \t//CHECK FOR N=1\n    }\n\t\t\t  \n\t\t\t\t  \n\t\t\t\t  \n  \n\n\n\n\nstatic int[] input(int n) {\n  \tint A[]=new int[n];\n  \t   for(int i=0;i<n;i++) {\n  \t\t   A[i]=sc.nextInt();\n  \t   }\n  \t   return A;\n     }\n  static long[] inputL(int n) {\n  \tlong A[]=new long[n];\n  \t   for(int i=0;i<n;i++) {\n  \t\t   A[i]=sc.nextLong();\n  \t   }\n  \t   return A;\n     }\n  static String[] inputS(int n) {\n  \tString A[]=new String[n];\n  \t   for(int i=0;i<n;i++) {\n  \t\t   A[i]=sc.next();\n  \t   }\n  \t   return A;\n     }\n  static long sum(int A[]) {\n  \tlong sum=0;\n  \tfor(int i : A) {\n  \t\tsum+=i;\n  \t}\n  \treturn sum;\n  }\n  static long sum(long A[]) {\n  \tlong sum=0;\n  \tfor(long i : A) {\n  \t\tsum+=i;\n  \t}\n  \treturn sum;\n  }\n\n  static void input(int A[],int B[]) {\n  \t   for(int i=0;i<A.length;i++) {\n  \t\t   A[i]=sc.nextInt();\n  \t\t   B[i]=sc.nextInt();\n  \t   }\n  }\n  static int[][] input(int n,int m){\n  \tint A[][]=new int[n][m];\n  \tfor(int i=0;i<n;i++) {\n  \t\tfor(int j=0;j<m;j++) {\n  \t\t\tA[i][j]=i();\n  \t\t}\n  \t}\n  \treturn A;\n  }\n  static char[][] charinput(int n,int m){\n  \tchar A[][]=new char[n][m];\n  \tfor(int i=0;i<n;i++) {\n  \t\tString s=s();\n  \t\tfor(int j=0;j<m;j++) {\n  \t\t\tA[i][j]=s.charAt(j);\n  \t\t}\n  \t}\n  \treturn A;\n  }\n  static int max(int A[]) {\n  \tint max=Integer.MIN_VALUE;\n  \tfor(int i=0;i<A.length;i++) {\n  \t\tmax=Math.max(max, A[i]);\n  \t}\n  \treturn max;\n  }\n  static int min(int A[]) {\n  \tint min=Integer.MAX_VALUE;\n  \tfor(int i=0;i<A.length;i++) {\n  \t\tmin=Math.min(min, A[i]);\n  \t}\n  \treturn min;\n  }\n  static long max(long A[]) {\n  \tlong max=Long.MIN_VALUE;\n  \tfor(int i=0;i<A.length;i++) {\n  \t\tmax=Math.max(max, A[i]);\n  \t}\n  \treturn max;\n  }\n  static long min(long A[]) {\n  \tlong min=Long.MAX_VALUE;\n  \tfor(int i=0;i<A.length;i++) {\n  \t\tmin=Math.min(min, A[i]);\n  \t}\n  \treturn min;\n  }\n  static long mod(long x) {\n  \t int mod=1000000007;\n  \t  return ((x%mod + mod)%mod);\n  }\n  static String reverse(String s) {\n  \tStringBuffer p=new StringBuffer(s);\n  \tp.reverse();\n  \treturn p.toString();\n  }\n\n       static int i() {\n      \t return sc.nextInt();\n       }\n       static String s() {\n      \t return sc.next();\n       }\n       static long l() {\n      \t return sc.nextLong();\n       }  \n       static void sort(int[] A){\n          int n = A.length;\n          Random rnd = new Random();\n          for(int i=0; i<n; ++i){\n              int tmp = A[i];\n              int randomPos = i + rnd.nextInt(n-i);\n              A[i] = A[randomPos];\n              A[randomPos] = tmp;\n          }\n          Arrays.sort(A);\n       }\n       static void sort(long[] A){\n  \t        int n = A.length;\n  \t        Random rnd = new Random();\n  \t        for(int i=0; i<n; ++i){\n  \t            long tmp = A[i];\n  \t            int randomPos = i + rnd.nextInt(n-i);\n  \t            A[i] = A[randomPos];\n  \t            A[randomPos] = tmp;\n  \t        }\n  \t        Arrays.sort(A);\n  \t     }\n    static String sort(String s) {\n   \t Character ch[]=new Character[s.length()];\n   \t for(int i=0;i<s.length();i++) {\n   \t\t ch[i]=s.charAt(i);\n   \t }\n   \t Arrays.sort(ch);\n   \t StringBuffer st=new StringBuffer(\"\");\n for(int i=0;i<s.length();i++) {\n\t st.append(ch[i]);\n }\n return st.toString();\n}\nstatic HashMap<Integer,Integer> hash(int A[]){\n  HashMap<Integer,Integer> map=new HashMap<Integer, Integer>();\n  for(int i : A) {\n\t  if(map.containsKey(i)) {\n\t\t  map.put(i, map.get(i)+1);\n\t  }\n\t  else {\n\t\t  map.put(i, 1);\n\t  }\n  }\n  return map;\n}\nstatic HashMap<Long,Integer> hash(long A[]){\n\t  HashMap<Long,Integer> map=new HashMap<Long, Integer>();\n\t  for(long i : A) {\n\t\t  if(map.containsKey(i)) {\n\t\t\t  map.put(i, map.get(i)+1);\n\t\t  }\n\t\t  else {\n\t\t\t  map.put(i, 1);\n\t\t  }\n\t  }\n\t  return map;\n\t}\nstatic TreeMap<Integer,Integer> tree(int A[]){\n  TreeMap<Integer,Integer> map=new TreeMap<Integer, Integer>();\n  for(int i : A) {\n\t  if(map.containsKey(i)) {\n\t\t  map.put(i, map.get(i)+1);\n\t  }\n\t  else {\n\t\t  map.put(i, 1);\n\t  }\n  }\n  return map;\n}\nstatic TreeMap<Long,Integer> tree(long A[]){\n\t  TreeMap<Long,Integer> map=new TreeMap<Long, Integer>();\n\t  for(long i : A) {\n\t\t  if(map.containsKey(i)) {\n\t\t\t  map.put(i, map.get(i)+1);\n\t\t  }\n\t\t  else {\n\t\t\t  map.put(i, 1);\n\t\t  }\n\t  }\n\t  return map;\n\t}\n   static boolean prime(int n) \n    { \n        if (n <= 1) \n            return false; \n        if (n <= 3) \n            return true; \n        if (n % 2 == 0 || n % 3 == 0) \n            return false; \n        double sq=Math.sqrt(n);\n  \n        for (int i = 5; i <= sq; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n                return false; \n        return true; \n    } \n   static boolean prime(long n) \n    { \n        if (n <= 1) \n            return false; \n        if (n <= 3) \n            return true; \n        if (n % 2 == 0 || n % 3 == 0) \n            return false; \n        double sq=Math.sqrt(n);\n  \n        for (int i = 5; i <= sq; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n                return false; \n        return true; \n    } \n   static int gcd(int a, int b) \n   { \n       if (a == 0) \n           return b; \n       return gcd(b % a, a); \n   } \n   static long gcd(long a, long b) \n   { \n       if (a == 0) \n           return b; \n       return gcd(b % a, a); \n   } \n   static class Pair implements Comparable<Pair>\n   {\n  \t int x;\n  \t int y;\n  \t Pair(int x,int y){\n  \t\t this.x=x;\n  \t\t this.y=y;\n  \t }\n\t@Override\n\tpublic int compareTo(Pair o) {\n\t\tif(this.x>o.x)\n\t\t\treturn 1;\n\t\telse if(this.x<o.x)\n\t\t\treturn -1;\n\t\telse {\n\t\t\tif(this.y<o.y)\n\t\t\t\treturn 1;\n\t\t\telse if(this.y>o.y)\n\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n   }\n      \n  static class FastReader \n  { \n      BufferedReader br; \n      StringTokenizer st; \n\n      public FastReader() \n      { \n          br = new BufferedReader(new\n                   InputStreamReader(System.in)); \n      } \n\n      String next() \n      { \n          while (st == null || !st.hasMoreElements()) \n          { \n              try\n              { \n                  st = new StringTokenizer(br.readLine()); \n              } \n              catch (IOException  e) \n              { \n                  e.printStackTrace(); \n              } \n          } \n          return st.nextToken(); \n      } \n\n      int nextInt() \n      { \n          return Integer.parseInt(next()); \n      } \n\n      long nextLong() \n      { \n          return Long.parseLong(next()); \n      } \n\n      double nextDouble() \n      { \n          return Double.parseDouble(next()); \n      } \n\n      String nextLine() \n      { \n          String str = \"\"; \n              try\n              { \n                  str = br.readLine(); \n              } \n              catch (IOException e) \n              { \n                  e.printStackTrace(); \n              } \n              return str; \n          } \n      } \n  } \n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 150005;\nint n, m;\nset<long long> st;\nlong long a[N], b[N];\nint main() {\n  int i, j;\n  cin >> n;\n  for (i = 1; i <= n; i++) cin >> a[i] >> b[i];\n  for (i = 2; i * i <= a[1]; i++) {\n    if (a[1] % i == 0) st.insert(i);\n    while (a[1] % i == 0) a[1] /= i;\n  }\n  if (a[1] > 1) st.insert(a[1]);\n  for (i = 2; i * i <= b[1]; i++) {\n    if (b[1] % i == 0) st.insert(i);\n    while (b[1] % i == 0) b[1] /= i;\n  }\n  if (b[1] > 1) st.insert(b[1]);\n  set<long long>::iterator it;\n  for (i = 2; i <= n; i++) {\n    for (it = st.begin(); it != st.end();) {\n      long long x = (*it);\n      if ((a[i] % x) && (b[i] % x))\n        st.erase(it++);\n      else\n        it++;\n    }\n  }\n  if (st.size() == 0)\n    cout << -1;\n  else\n    cout << (*st.begin());\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef gcd(a,b): \n    if(b==0): \n        return a \n    else: \n        return gcd(b,a%b) \n\n\nn=int(input())\n\n\nsum=0 \nl,r=0,0\nwhile n>0:\n      \n      l,r=input().split()\n      l=int(l)\n      r=int(r)\n      #t=gcd(l,r)\n      t=int(l*r)\n      sum=gcd(sum,t)\n      n-=1\n\nif sum==1:\n    print(-1)\nelif gcd(l,sum)==1:\n    i=2\n    sum=gcd(r,sum)\n    while sum>=i*i:\n      if sum%i==0:\n         sum=i\n         break\n      i+=1\n    print(int(sum))\nelse :\n    i=2\n    sum=gcd(l,sum)\n    while sum>=i*i:\n      if sum%i==0:\n         sum=i\n         break\n      i+=1\n    print(int(sum))\n    \n    \n    \n    \n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dcmp(long double n, long double y) {\n  return fabs(n - y) <= 1e-9 ? 0 : n < y ? -1 : 1;\n}\nconst int N = 44721 + 10;\nbool prime[N];\nvector<int> prime_f;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  int n;\n  cin >> n;\n  pair<int, int> arr[n];\n  for (int i = 0; i < (int)(n); ++i) {\n    cin >> arr[i].first >> arr[i].second;\n  }\n  long long x = arr[0].first;\n  for (long long i = 2; i * i <= x; i++) {\n    while (x % i == 0ll) {\n      prime_f.push_back(i);\n      x /= i;\n    }\n  }\n  if (x > 1) {\n    prime_f.push_back(x);\n  }\n  x = arr[0].second;\n  for (long long i = 2; i * i <= x; i++) {\n    while (x % i == 0ll) {\n      prime_f.push_back(i);\n      x /= i;\n    }\n  }\n  if (x > 1) {\n    prime_f.push_back(x);\n  }\n  sort(((prime_f).begin()), ((prime_f).end()));\n  prime_f.erase(unique(((prime_f).begin()), ((prime_f).end())), prime_f.end());\n  int ans = -1;\n  for (int i = 0; i < ((int)((prime_f).size())); ++i) {\n    bool ok = 1;\n    for (int j = 0; j < (int)(n); ++j) {\n      if (arr[j].second % prime_f[i] && arr[j].first % prime_f[i]) {\n        ok = 0;\n        break;\n      }\n    }\n    if (ok) {\n      ans = prime_f[i];\n      break;\n    }\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class Problem505B {\n\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tout=new PrintWriter(new BufferedOutputStream(System.out));\n\t\tFastReader s=new FastReader();\n\t\tint n=s.nextInt();\n\t\tint a=s.nextInt();\n\t\tint b=s.nextInt();\n\t\tHashSet<Integer> primefactors=new HashSet<>();\n\t\t\n\t\tfor(int i=2;i*i<=a;i++) {\n\t\t\twhile(a%i==0){\n\t\t\t\tprimefactors.add(i);\n\t\t\t\ta=a/i;\n\t\t\t}\n\t\t\tif(a==1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(a!=1) {\n\t\t\tprimefactors.add(a);\n\t\t}\n\t\tfor(int i=2;i*i<=b;i++) {\n\t\t\tint cc=i;\n\t\t\twhile(b%cc==0){\n\t\t\t\tprimefactors.add(cc);\n\t\t\t\tb=b/cc;\n\t\t\t}\n\t\t\tif(b==1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(b!=1) {\n\t\t\tprimefactors.add(b);\n\t\t}\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\ta=s.nextInt();\n\t\t\tb=s.nextInt();\n\t\t\tHashSet<Integer> helper=new HashSet(primefactors);\n\t\t\tfor(Integer x:primefactors) {\n\t\t\t\tif(a%x!=0 && b%x!=0) {\n\t\t\t\t\thelper.remove(x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprimefactors=helper;\n\t\t}\n\t\tif(primefactors.size()==0) {\n\t\t\tout.println(-1);\n\t\t}else {\n\t\t\tout.println(primefactors.iterator().next());\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static PrintWriter out;\n\t\n\tpublic static class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t//it reads the data about the specified point and divide the data about it ,it is quite fast\n\t\t//than using direct \n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());//converts string to integer\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\t\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\ndef primes(n):\n    fact = []\n    if n % 2 == 0:\n        fact.extend([2])\n        while n % 2 == 0:\n            n//=2\n    for i in range(3,int(n**0.5)+1,2):\n        if n % i == 0:\n            fact.append(i)\n            while n % i == 0:\n                n//=i\n    if n != 1:\n        fact.append(n)\n        \n    return fact\n\ndef prog():\n    n = int(input())\n    a = [list(map(int,input().split())) for i in range(n)]\n    \n    valid_primes = set(primes(a[0][0]) + primes(a[0][1]))\n    for i in range(1,n):\n        to_remove = []\n        for p in valid_primes:\n            if a[i][0] % p != 0 and a[i][1] % p != 0:\n                to_remove.append(p)\n        for p in to_remove:\n            valid_primes.remove(p)\n                \n    if valid_primes:\n        print(list(valid_primes)[0])\n    else:\n        print(-1)\n        \nprog()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\nconstexpr long long TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n  if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n  if (t < u) t = u;\n}\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  os << \"{\";\n  for (int i = 0; i < (v.size()); i++) {\n    if (i) os << \",\";\n    os << v[i];\n  }\n  os << \"}\";\n  return os;\n}\nV<int> dv(int x) {\n  V<int> res;\n  for (int i = 2; i * i <= x; ++i) {\n    if (x % i == 0) {\n      res.push_back(i);\n      while (x % i == 0) {\n        x /= i;\n      }\n    }\n  }\n  if (x != 1) res.push_back(x);\n  return res;\n}\nint main() {\n  int n;\n  cin >> n;\n  V<pair<int, int>> vec(n);\n  for (int i = 0; i < (n); i++) {\n    int a, b;\n    cin >> a >> b;\n    vec[i] = make_pair(a, b);\n  }\n  V<int> cand[2] = {dv(vec[0].first), dv(vec[0].second)};\n  for (auto v : cand) {\n    for (auto x : v) {\n      bool ok = 1;\n      for (int i = 0; i < (n); i++)\n        if (vec[i].first % x != 0 && vec[i].second % x != 0) {\n          ok = 0;\n        }\n      if (ok) {\n        cout << x << endl;\n        return 0;\n      }\n    }\n  }\n  puts(\"-1\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt();\n            long[][] map = in.nextLongMap(n, 2);\n            if (n == 1) {\n                out.println(map[0][0]);\n                return;\n            }\n            Set<Long> gcds = new HashSet<>();\n            gcds.addAll(primeDivisors(map[0][0]));\n            gcds.addAll(primeDivisors(map[0][1]));\n            gcds.remove(1L);\n            outer:\n            for (Long gcd : gcds) {\n                for (int i = 0; i < n; ++i) {\n                    boolean flag = false;\n                    for (int k = 0; k < 2; ++k) {\n                        flag |= map[i][k] % gcd == 0;\n                    }\n                    if (!flag) continue outer;\n                }\n                out.println(gcd);\n                return;\n            }\n            out.println(\"-1\");\n        }\n\n        private ArrayList<Long> primeDivisors(long n) {\n            ArrayList<Long> list = new ArrayList<>();\n            for (long i = 1; i * i <= n; ++i) {\n                if (n % i == 0) {\n                    if (NT.isPrime(i)) list.add(i);\n                    if (i != n / i && NT.isPrime(n / i)) list.add(n / i);\n                }\n            }\n            return list;\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] array = new long[n];\n            for (int i = 0; i < n; i++) {\n                array[i] = nextLong();\n            }\n            return array;\n        }\n\n        public long[][] nextLongMap(int n, int m) {\n            long[][] array = new long[n][];\n            for (int i = 0; i < n; i++) {\n                array[i] = nextLongArray(m);\n            }\n            return array;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n\n    static class NT {\n        public static boolean isPrime(long number) {\n            if (number <= 1) {\n                return false;\n            }\n            if (number <= 3) {\n                return true;\n            }\n            if (number % 2 == 0 || number % 3 == 0) {\n                return false;\n            }\n            long i = 5;\n            while (i * i <= number) {\n                if (number % i == 0 || number % (i + 2) == 0) {\n                    return false;\n                }\n                i += 6;\n            }\n            return true;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class B {\n\n\tint MAX = 100000;\n\n\tpublic Object solve() {\n\t\tint N = sc.nextInt();\n\t\tlong [][] Z = sc.nextLongs(N);\n\n\t\tfor (int i : rep(2))\n\t\t\tnext: for (long p : distinctPrimeDivisors(Z[0][i]))\n\t\t\t\tif (p >= MAX) {\n\t\t\t\t\tfor (int j : rep(N)) {\n\t\t\t\t\t\tboolean ok = false;\n\t\t\t\t\t\tfor (int k : rep(2))\n\t\t\t\t\t\t\tok = ok || (Z[j][k] % p == 0);\n\t\t\t\t\t\tif (!ok)\n\t\t\t\t\t\t\tcontinue next;\n\t\t\t\t\t}\n\t\t\t\t\texit(p);\n\t\t\t\t}\n\n\t\tlong X = 0;\n\t\tfor (int i : rep(N))\n\t\t\tX = gcd(X, Z[i][0] * Z[i][1]);\n\n\t\tif (X == 1)\n\t\t\texit(-1);\n\n\t\tfor (int p : rep(2, MAX))\n\t\t\tif (X % p == 0)\n\t\t\t\texit(p);\n\n\t\treturn null;\n\t}\n\n\tprivate static final boolean ONE_TEST_CASE = true;\n\n\tprivate static void init() {\n\t}\n\n\tprivate static long [] distinctPrimeDivisors (long N) {\n\t\tList<Long> res = new ArrayList<Long>();\n\t\tfor (long p = 2; p*p <= N; ++p) {\n\t\t\tif (N % p == 0)\n\t\t\t\tres.add(p);\n\t\t\twhile (N % p == 0)\n\t\t\t\tN /= p;\n\t\t}\n\t\tif (N > 1)\n\t\t\tres.add(N);\n\t\treturn pri(res.toArray(new Long [0]));\n\t}\n\tprivate static long gcd (long x, long y) {\n\t\tx *= Long.signum(x); y *= Long.signum(y);\n\t\twhile (y > 0) { long z = y; y = x%y; x = z; }\n\t\treturn x;\n\t}\n\tprivate static long [] pri (Long [] A) { return pri(A, new long [A.length]); }\n\tprivate static long [] pri (Long [] A, long [] a) { for (int i = 0; i < A.length; ++i) a[i] = A[i]; return a; }\n\tprivate static IntStream range(int N) { return IntStream.range(0, N); }\n\tprivate static Iterable<Integer> rep (int N) { return rep(0, N); }\n\tprivate static Iterable<Integer> rep (final int S, final int T) { return new Iterable<Integer>() { public Iterator<Integer> iterator() { return S < T ? java.util.stream.IntStream.range(S,  T).iterator() : Collections.emptyIterator(); } }; }\n\t////////////////////////////////////////////////////////////////////////////////////\n\tprivate static IOUtils.MyScanner sc = new IOUtils.MyScanner();\n\tprivate static Object print (Object o, Object ... A) { IOUtils.print(o, A); return null; }\n\tprivate static Object exit (Object o, Object ... A) { print(o, A); IOUtils.exit(); return null; }\n\tprivate static class IOUtils {\n\t\tpublic static class MyScanner {\n\t\t\tpublic String next() { newLine(); return line[index++]; }\n\t\t\tpublic int nextInt() { return Integer.parseInt(next()); }\n\t\t\tpublic String nextLine() { line = null; return readLine(); }\n\t\t\tpublic String [] nextStrings() { return split(nextLine()); }\n\t\t\tpublic long[] nextLongs() { return nextStream().mapToLong(Long::parseLong).toArray(); }\n\t\t\tpublic long[][] nextLongs(int N) { return range(N).mapToObj(i -> nextLongs()).toArray(long[][]::new); }\n\t\t\t//////////////////////////////////////////////\n\t\t\tprivate boolean eol() { return index == line.length; }\n\t\t\tprivate String readLine() {\n\t\t\t\ttry {\n\t\t\t\t\treturn r.readLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new Error (e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate final java.io.BufferedReader r;\n\t\t\tprivate MyScanner () { this(new java.io.BufferedReader(new java.io.InputStreamReader(System.in))); }\n\t\t\tprivate MyScanner (java.io.BufferedReader r) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.r = r;\n\t\t\t\t\twhile (!r.ready())\n\t\t\t\t\t\tThread.sleep(1);\n\t\t\t\t\tstart();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new Error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate String [] line;\n\t\t\tprivate int index;\n\t\t\tprivate void newLine() {\n\t\t\t\tif (line == null || eol()) {\n\t\t\t\t\tline = split(readLine());\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate java.util.stream.Stream<String> nextStream() { return java.util.Arrays.stream(nextStrings()); }\n\t\t\tprivate String [] split(String s) { return s.length() > 0 ? s.split(\" \") : new String [0]; }\n\t\t}\n\t\tprivate static String build(Object o, Object ... A) { return buildDelim(\" \", o, A); }\n\t\tprivate static String buildDelim(String delim, Object o, Object ... A) {\n\t\t\tStringBuilder b = new StringBuilder();\n\t\t\tappend(b, o, delim);\n\t\t\tfor (Object p : A)\n\t\t\t\tappend(b, p, delim);\n\t\t\treturn b.substring(delim.length());\n\t\t}\n\t\t//////////////////////////////////////////////////////////////////////////////////\n\t\tprivate static final java.text.DecimalFormat formatter = new java.text.DecimalFormat(\"#.#########\");\n\t\tprivate static void start() { if (t == 0) t = millis(); }\n\t\tprivate static void append(java.util.function.Consumer<Object> f, java.util.function.Consumer<Object> g, final Object o) {\n\t\t\tif (o.getClass().isArray()) {\n\t\t\t\tint len = java.lang.reflect.Array.getLength(o);\n\t\t\t\tfor (int i = 0; i < len; ++i)\n\t\t\t\t\tf.accept(java.lang.reflect.Array.get(o, i));\n\t\t\t}\n\t\t\telse if (o instanceof Iterable<?>)\n\t\t\t\t((Iterable<?>)o).forEach(f::accept);\n\t\t\telse\n\t\t\t\tg.accept(o instanceof Double ? formatter.format(o) : o);\n\t\t}\n\t\tprivate static void append(final StringBuilder b, Object o, final String delim) {\n\t\t\tappend(x -> { append(b, x, delim); }, x -> b.append(delim).append(x), o);\n\t\t}\n\t\tprivate static java.io.PrintWriter pw = new java.io.PrintWriter(System.out);\n\t\tprivate static Object print(Object o, Object ... A) { pw.println(build(o, A)); return null; }\n\t\tprivate static void err(Object o, Object ... A) { System.err.println(build(o, A)); }\n\t\tprivate static boolean PRINT;\n\t\tprivate static void write(Object o) {\n\t\t\terr(o, '(', time(), ')');\n\t\t\tif (PRINT)\n\t\t\t\tpw.println(o);\n\t\t}\n\t\tprivate static void exit() {\n\t\t\tIOUtils.pw.close();\n\t\t\tSystem.out.flush();\n\t\t\terr(\"------------------\");\n\t\t\terr(time());\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tprivate static long t;\n\t\tprivate static long millis() { return System.currentTimeMillis(); }\n\t\tprivate static String time() { return \"Time: \" + (millis() - t) / 1000.0; }\n\t\tprivate static void run(int N) {\n\t\t\ttry { PRINT = System.getProperties().containsKey(\"PRINT\"); }\n\t\t\tcatch (Throwable t) {}\n\n\t\t\tfor (int n = 1; n <= N; ++n) {\n\t\t\t\tObject res = new B().solve();\n\t\t\t\tif (res != null)\n\t\t\t\t\twrite(\"Case #\" + n + \": \" + build(res));\n\t\t\t}\n\t\t\texit();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tinit();\n\t\tint N = ONE_TEST_CASE ? 1 : sc.nextInt();\n\t\tIOUtils.run(N);\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "import bisect\nfrom itertools import accumulate, count\nimport os\nimport sys\nimport math\nfrom decimal import *\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef input():\n    return sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\n\n\ndef SieveOfEratosthenes(n):\n    prime = []\n    primes = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n\n        if primes[p] == True:\n            prime.append(p)\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return prime\n\n\ndef primefactors(n):\n    fac = []\n    while n % 2 == 0:\n        fac.append(2)\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 2):\n        while n % i == 0:\n            fac.append(i)\n            n = n // i\n    if n > 1:\n        fac.append(n)\n    return sorted(fac)\n\n\ndef factors(n):\n    fac = set()\n    fac.add(1)\n    fac.add(n)\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            fac.add(i)\n            fac.add(n // i)\n    return list(fac)\n\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n# ------------------------------------------------------code\nn=int(input())\nans=[]\nfor i in range(n):\n    a,b=map(int,input().split())\n    ans.append([a,b])\nf1=primefactors(ans[0][0])\nf2=primefactors(ans[0][1])\nf1=f1+f2\nf1=set(f1)\nfor i in f1:\n    f=0\n    for j in range(0,len(ans)):\n        if ans[j][0]%i==0 or ans[j][1]%i==0:\n            pass\n        else:\n            f=1\n            break\n    if f==0:\n        print(i)\n        exit()\nprint(-1)\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.Set;\n\npublic class Main {\n\tString INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tstatic Set<Integer> factorize(long n) {\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tint count = 0;\n\n\t\t// count the number of times 2 divides\n\t\twhile ((n % 2) == 0) {\n\t\t\tn >>= 1; // equivalent to n=n/2;\n\t\t\tcount++;\n\t\t}\n\n\t\t// if 2 divides it\n\t\tif (count != 0) {\n\t\t\tset.add(2);\n\t\t}\n\n\t\t// check for all the possible numbers that can\n\t\t// divide it\n\t\tfor (long i = 3; i <= Math.sqrt(n); i += 2) {\n\t\t\tcount = 0;\n\t\t\twhile (n % i == 0) {\n\t\t\t\tcount++;\n\t\t\t\tn = n / i;\n\t\t\t}\n\t\t\tif (count > 0) {\n\t\t\t\tset.add((int) i);\n\t\t\t}\n\t\t}\n\n\t\t// if n at the end is a prime number.\n\t\tif (n > 2) {\n\t\t\tset.add((int) n);\n\t\t}\n\t\treturn set;\n\t}\n\n\tprivate void solve() {\n\t\tint n = nextInt();\n\t\tint[] ar1 = new int[n];\n\t\tint[] ar2 = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tar1[i] = nextInt();\n\t\t\tar2[i] = nextInt();\n\t\t}\n\t\tSet<Integer> factorize = factorize(ar1[0]);\n\t\tInteger answer = null;\n\t\tfor (int j : factorize) {\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (ar1[i] % j == 0 || ar2[i] % j == 0) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count == n) {\n\t\t\t\tanswer = j;\n\t\t\t}\n\t\t}\n\t\tif (answer == null) {\n\t\t\tfactorize = factorize(ar2[0]);\n\t\t\tfor (int j : factorize) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (ar1[i] % j == 0 || ar2[i] % j == 0) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count == n) {\n\t\t\t\t\tanswer = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (answer == null) {\n\t\t\tSystem.out.println(-1);\n\t\t} else {\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}\n\n\tInputStream is;\n\tPrintWriter out;\n\n\tvoid run() throws Exception {\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\t// tr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nextDouble() {\n\t\treturn Double.parseDouble(nextString());\n\t}\n\n\tprivate char nextCharactor() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String nextString() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b !=\n\t\t\t\t\t\t\t\t\t// ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] nextString(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nextMap(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = nextString(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] nextIntArr(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tprivate int nextInt() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nextLong() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = true;\n\n\t// System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint fun() {\n  int n;\n  cin >> n;\n  vector<pair<long long int, long long int>> vt(n);\n  for (int i = 0; i < n; i++) {\n    long long int x, y;\n    cin >> x >> y;\n    vt[i].first = x, vt[i].second = y;\n  }\n  set<long long int> prime;\n  long long int x = vt[0].first;\n  long long int y = vt[0].second;\n  for (long long int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      prime.insert(i);\n      while (x % i == 0) {\n        x = x / i;\n      }\n    }\n  }\n  for (int i = 2; i * i <= y; i++) {\n    if (y % i == 0) {\n      prime.insert(i);\n      while (y % i == 0) {\n        y = y / i;\n      }\n    }\n  }\n  if (y != 1) prime.insert(y);\n  if (x != 1) prime.insert(x);\n  for (auto it = prime.begin(); it != prime.end(); it++) {\n    int ca = *it;\n    bool ok = true;\n    for (int i = 1; i < n; i++) {\n      if (vt[i].first % ca == 0 || vt[i].second % ca == 0)\n        ;\n      else {\n        ok = false;\n        break;\n      }\n    }\n    if (ok) {\n      cout << ca << endl;\n      return 0;\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\nint main() { fun(); }\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\n/**\n *\n * @author Arpit\n */\npublic class JavaApplication174 {\n\n    /**\n     * @param args the command line arguments\n     */\n    //public void gen(int arr[])\n    \n    public static long gcd(long a,long b){\n    \n        if(a==0)return b;\n        return gcd(b%a,a);\n    } \n    public static void main(String[] args) {\n        // TODO code application logic here\n        Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n        long ans=0;\n        long arr[] = new long[2*n];\n        int j=0;\n        while(n-->0){\n        long a=sc.nextInt();\n        long b=sc.nextInt();\n        arr[j]=a;\n        arr[j+1]=b;\n        j+=2;\n        ans=gcd(a*b,ans);\n        }\n        long i=2;\n        if(ans==1)System.out.println(-1);\n        else{\n        while(i<2*1000000){\n            \n        if(ans%i==0&&ans!=i)ans/=i;\n        else i++;\n        }\n        Collections.sort(Arrays.asList(arr),Collections.reverseOrder());\n        \n        int k=0;\n        while(k<arr.length){\n        if(ans>arr[k]){\n        if(ans%arr[k]==0){\n        ans/=arr[k];\n        }\n        }\n        k++;\n            \n        }\n            \n            \n            \n        System.out.println(ans);\n    }\n    \n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import sqrt\n\ndef mcd(x, y):\n    if y == 0:\n        return x\n    else:\n        return mcd(y, x % y)\n\ndef prime_divisor(x):\n    for p in range(2, int(sqrt(x)) + 1):\n        if x % p == 0:\n            return p\n    return x\n\nn = int(input())\na1, b1 = map(int, input().split())\na, b = a1, b1\n\nfor i in range(2, n+1):\n    ai, bi = map(int, input().split())\n    a = mcd(ai * bi, a)\n    b = mcd(ai * bi, b)\n\nif a != 1:\n    print(prime_divisor(a))\nelif b != 1:\n    print(prime_divisor(b))\nelse:\n    print(-1)\n"
        },
        {
            "language": 3,
            "solution": "n=int(input())\nl1=[]\nl2=[]\nfor i in range(n):\n    a,b=map(int,input().split())\n    l1.append(a)\n    l2.append(b)\nL=[]\nj=2\na=l1[0]\nb=l2[0]\nwhile(j*j<=a):\n    if a%j==0:\n        while a%j==0:\n            a=a//j\n        L.append(j)\n    j=j+1\nif a>1:\n    L.append(a)\nj=2\nwhile(j*j<=b):\n    if b%j==0:\n        while b%j==0:\n            b=b//j\n        L.append(j)\n    j=j+1\nif b>1:\n    L.append(b)\nL=list(set(L))\ng=0\n#print(L)\nfor j in L:\n    f=0\n    for k in range(1,n):\n        if l1[k]%j!=0 and l2[k]%j!=0:\n            f=1\n            break\n    if f==0:\n        g=1\n        print(j)\n        break\nif g==0:\n    print(-1)\n        \n        \n"
        },
        {
            "language": 3,
            "solution": "'''\nHey  why peeping here -_'_- ?\nI believe on myself and I will achieve\nthis->author = Fuad Ashraful Mehmet, CSE ,University of Asia Pacific\nhttps://www.youtube.com/watch?v=rnnHCN3YH_s&ab_channel=GaaneSuneAnsune\n'''\nimport sys\ninput=sys.stdin.readline\nR=lambda:map(int,input().split())\nI=lambda:int(input())\nS=lambda:input().rstrip('\\n')\nL=lambda:list(R())\n\nclass WCD:\n\tdef __init__(self):\n\t\tself.n=I()\n\t\tself.ab=[tuple(R()) for _ in range(self.n)]\n\t\t#print(self.ab)\n\t\n\tdef ok(self,x):\n\t\tfor u,v in self.ab:\n\t\t\tif u%x and v%x:\n\t\t\t\treturn False\n\t\treturn True\n\tdef factorize(self,num):\n\t\tret=[]\n\n\t\tfor i in range(2,int(num**0.5)+1):\n\n\t\t\tif num%i==0:\n\t\t\t\tret.append(i)\n\t\t\t\twhile num%i==0:\n\t\t\t\t\tnum//=i\n\t\tif num>1:\n\t\t\tret.append(num)\n\t\treturn ret\n\tdef solve(self):\n\t\tfactors=self.factorize(self.ab[0][0])+self.factorize(self.ab[0][1])\n\t\tfor x in factors:\n\t\t\tif self.ok(x):\n\t\t\t\tprint(x)\n\t\t\t\texit()\n\t\tprint(-1)\n\t\texit()\nif __name__=='__main__':\n\to=WCD()\n\to.solve()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nint n, m, a[maxn], b[maxn];\nmap<int, bool> vis;\nvector<int> t;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &a[i], &b[i]);\n  }\n  int x, y;\n  x = sqrt(a[1]), y = a[1];\n  for (int i = 2; i <= x; i++) {\n    if (y % i == 0) {\n      if (!vis[i]) {\n        vis[i] = true;\n        t.push_back(i);\n      }\n      while (y % i == 0) y /= i;\n    }\n    if (y == 1) break;\n  }\n  if (y > 1 && !vis[y]) vis[y] = true, t.push_back(y);\n  y = b[1], x = sqrt(b[1]);\n  for (int i = 2; i <= x; i++) {\n    if (y % i == 0) {\n      if (!vis[i]) {\n        vis[i] = true;\n        t.push_back(i);\n      }\n      while (y % i == 0) y /= i;\n    }\n    if (y == 1) break;\n  }\n  if (y > 1 && !vis[y]) vis[y] = true, t.push_back(y);\n  bool flag = true;\n  for (auto i : t) {\n    flag = true;\n    for (int j = 2; j <= n; j++) {\n      flag &= (a[j] % i == 0 || b[j] % i == 0);\n    }\n    if (flag) return printf(\"%d\\n\", i), 0;\n  }\n  printf(\"-1\");\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tprivate static Set<Integer> getPrime(int value) {\n\t\t\n\t\tSet<Integer> set = new HashSet<>();\n\t\tfor (int i = 2;i * i <= value;i ++) {\n\t\t\tif (value % i == 0) {\n\t\t\t\twhile (value % i == 0) {\n\t\t\t\t\tvalue /= i;\n\t\t\t\t}\n\t\t\t\tset.add(i);\n\t\t\t}\n\t\t}\n\t\tif (value > 1) {\n\t\t\tset.add(value);\n\t\t}\n\t\treturn set;\n\t\t\n\t}\n\t\n\tprivate static int[] value1 = new int[200000];\n\tprivate static int[] value2 = new int[200000];\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\t\n\t\tScanner scan = new Scanner(System.in);\n\t\n\t\tint i , j , n = scan.nextInt();\n\t\tfor (i = 0;i < n;i ++) {\n\t\t\tvalue1[i] = scan.nextInt();\n\t\t\tvalue2[i] = scan.nextInt();\n\t\t}\n\t\t\n\t\tSet<Integer> set1 = getPrime(value1[0]);\n\t\tSet<Integer> set2 = getPrime(value2[0]);\n\t\tset1.addAll(set2);\n\t\t\n\t\tfor (int prime : set1) {\n\t\t\tfor (i = 0;i < n;i ++) {\n\t\t\t\tif ((value1[i] % prime == 0) || (value2[i] % prime == 0)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n) {\n\t\t\t\tSystem.out.println(prime);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(- 1);\n\t\t\n\t}\n\t\n\t\n}\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[1500000 + 10], b[1500000 + 10], t, cnt[1500000 + 10],\n    tag[1500000 + 10];\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i] >> b[i];\n  for (register int i = 2; i * i <= max(a[1], b[1]); i++)\n    if (a[1] % i == 0 || b[1] % i == 0) {\n      while (a[1] % i == 0) a[1] /= i;\n      while (b[1] % i == 0) b[1] /= i;\n      cnt[++t] = i;\n    }\n  if (a[1] > 1) cnt[++t] = a[1];\n  if (b[1] > 1) cnt[++t] = b[1];\n  sort(cnt + 1, cnt + t + 1);\n  for (register int i = 2; i <= n; i++)\n    for (register int j = t; j >= 1; j--)\n      if (a[i] % cnt[j] && b[i] % cnt[j]) tag[j] = 1;\n  for (register int i = t; i >= 1; i--)\n    if (!tag[i]) {\n      cout << cnt[i] << endl;\n      return 0;\n    }\n  cout << -1;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\nfrom fractions import gcd\nfrom itertools import repeat\ndef main():\n    n = int(stdin.readline())\n    dat = map(int, stdin.read().split(), repeat(10, 2 * n))\n    t = 0\n    for i in xrange(n):\n        x, y = dat[i*2:i*2+2]\n        g = gcd(x, y)\n        h = x / g * y\n        t = gcd(h, t)\n    if t <= 1:\n        print -1\n    else:\n        for i in xrange(2, 45000):\n            if t % i == 0:\n                print i\n                return\n        for i in xrange(n):\n            x, y = dat[i*2:i*2+2]\n            if t % x == 0:\n                print x\n                return\n            if t % y == 0:\n                print y\n                return\nmain()\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\npublic class WCD {\n    public static void main(String[] args) {\n        Scanner kb = new Scanner(System.in);\n        int n = kb.nextInt();\n        long curr = 0;\n        long[][] pairs = new long[n][2];\n        for (int i = 0; i < n; i++) {\n            pairs[i][0] = kb.nextLong();\n            pairs[i][1] = kb.nextLong();\n        }\n        for (int i = 0; i < n; i++) {\n            curr = gcd(curr,(pairs[i][0] * pairs[i][1]));\n            if (curr == 1) {\n                System.out.println(-1);\n                return;\n            }\n        }\n        long gcda = gcd(curr,(pairs[0][0]));\n        long gcdb = gcd(curr,(pairs[0][1]));\n        curr = (gcda==1?gcdb:gcda);\n        for (int i = 2; i*i < 2000000000; i++) {\n            if (curr % i == 0) {\n                System.out.println(i);\n                return;\n            }\n        }\n        System.out.println(curr);\n    }\n    public static long gcd(long a, long b) {\n        if(a == 0 || b == 0) return a+b; // base case\n        return gcd(b,a%b);\n    }\n    public static long lcm(long a, long b)\n    {\n        return a * (b / gcd(a, b));\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\timport java.util.*;\n\timport java.awt.List;\n\timport java.io.*;\n\timport java.lang.*;\nimport java.lang.reflect.Array;\n\t\t\n\tpublic class code4\n\t\t{\n\t \tpublic static void main(String[] args)\n\t\t\t{\n\t\t\t\tInputReader in = new InputReader(System.in);\n\t\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\t\t\n\t\t\t\t//Code starts..\n\t\t\t\t\n\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tint[][] a = new int[n][2];\n\t\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\t{\n\t\t\t\t\ta[i][0] = in.nextInt();\n\t\t\t\t\ta[i][1] = in.nextInt();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint a1 = a[n-1][0];\n\t\t\t\tint a2 = a[n-1][1];\n\t\t\t\tHashSet<Long>[] set = new HashSet[2]; \n\t\t\t\tHashSet<Long> fset = new HashSet<>();\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tset[0] = new HashSet<>();\n\t\t\t\t\tset[1] = new HashSet<>();\n\t\t\t\t\tset[0] = fact2(a[n-1][0], fset);\n\t\t\t\t\tset[1] = fact2(a[n-1][1], fset);\n\t\t\t\t\n\t\t\t\tlong ans = -1;\n\t\t\t\tfor(long p: set[0])\n\t\t\t\t{\n\t\t\t\t\tboolean flag = true;\n\t\t\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\t\t{\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(a[i][0]%p !=0 && a[i][1]%p!=0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tans = p;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(ans==-1)\n\t\t\t\tfor(long p: set[1])\n\t\t\t\t{\n\t\t\t\t\tboolean flag = true;\n\t\t\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\t\t{\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(a[i][0]%p !=0 && a[i][1]%p!=0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tans = p;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(n==1)\n\t\t\t\t\tans = a[0][0];\n\t\t\t\t\n\t\t\t\tpw.println(ans);\n\t\t\t\t\n\t\t\t\t//Code ends....\n\t\t\t\t\n\t\t\t\tpw.flush();\n\t\t\t\tpw.close();\n\t\t\t}\n\t\t\n\t \tpublic static HashSet<Long> fact2(long n, HashSet<Long> s2)\n\t \t{\n\t \t\tHashSet<Long> set = new HashSet<>();\n\t \t\t\n\t \t\tfor(long i=2; i*i<=n; i++)\n\t \t\t{\n\t \t\t\tif(n%i==0)\n\t \t\t\t{\n\t \t\t\t\tset.add(i);\n\t \t\t\t\tset.add(n/i);\n\n\t \t\t\t}\n\t \t\t}\n\t \t\tset.add(n);\n\t \t\t\n\t \t\t\n\t \t\treturn set;\n\t \t\t\n\t \t}\n\t \t\n\t \t\n\t\t\tstatic class InputReader \n\t\t\t{\n\t\t\t\t \n\t\t\t\tprivate final InputStream stream;\n\t\t\t\tprivate final byte[] buf = new byte[8192];\n\t\t\t\tprivate int curChar, snumChars;\n\t\t\t\tprivate SpaceCharFilter filter;\n\t\t \n\t\t\t\tpublic InputReader(InputStream stream) \n\t\t\t\t{\n\t\t\t\t\tthis.stream = stream;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic int snext() \n\t\t\t\t{\n\t\t\t\t\tif (snumChars == -1)\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tif (curChar >= snumChars) \n\t\t\t\t\t{\n\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\ttry \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t\t\t} \n\t\t\t\t\t\tcatch (IOException e) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic int nextInt() \n\t\t\t    {\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t\t{\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tint sgn = 1;\n\t\t\t\t\tif (c == '-')\n\t\t\t\t    {\n\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tint res = 0;\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res * sgn;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic long nextLong()\n\t\t\t    {\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t\t{\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tint sgn = 1;\n\t\t\t\t\tif (c == '-') \n\t\t\t\t\t{\n\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tlong res = 0;\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res * sgn;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic int[] nextIntArray(int n) \n\t\t\t\t{\n\t\t\t\t\tint a[] = new int[n];\n\t\t\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t\t\t{\n\t\t\t\t\t\ta[i] = nextInt();\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic String readString()\n\t\t\t    {\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t\t{\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res.toString();\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic String nextLine() \n\t\t\t\t{\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isEndOfLine(c));\n\t\t\t\t\treturn res.toString();\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic boolean isSpaceChar(int c) \n\t\t\t\t{\n\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t}\n\t\t \n\t\t\t\tprivate boolean isEndOfLine(int c) \n\t\t\t\t{\n\t\t\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic interface SpaceCharFilter\n\t\t\t    {\n\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpublic static long c = 0;\n\t\t\t\n\t\t\tpublic static long mod = 1000000007;\n\t\t\tpublic static int d;\n\t\t\tpublic static int p;\n\t\t\tpublic static int q;\n\t\t\tpublic static boolean flag;\n\t\t\tpublic static long INF= Long.MAX_VALUE;\n\t\t\t\n\t\t\t\n\t\t\tpublic static double slope(pair p1, pair p2)\n\t\t\t{\n\t\t\t\tdouble m = INF;\n\t\t\t\tif((p1.x - p2.x)!=0)\n\t\t\t\tm =  p1.y - p2.y/(p1.x - p2.x); \n\t\t\t\t\n\t\t\t\t\n\t\t\t\treturn Math.abs(m);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tpublic static int gcd(long i, long l) {\n\t\t\t\tif (i == 0)\n\t\t\t\t\treturn (int) l;\n\t\t\t\treturn gcd(l % i, i);\n\t\t\t}\n\t\n\t\t\t\n\t\t\t\n\t\t\t/*public static int findGCD(int arr[], int n)\n\t\t\t{\n\t\t\t    int result = arr[0];\n\t\t\t    for (int i=1; i<n; i++)\n\t\t\t        result = gcd(arr[i], result);\n\t\t\t \n\t\t\t    return result;\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\n\t \n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t    public static long lcm(int[] numbers) {\n\t\t        long lcm = 1;\n\t\t        int divisor = 2;\n\t\t        while (true) {\n\t\t            int cnt = 0;\n\t\t            boolean divisible = false;\n\t\t            for (int i = 0; i < numbers.length; i++) {\n\t\t                if (numbers[i] == 0) {\n\t\t                    return 0;\n\t\t                } else if (numbers[i] < 0) {\n\t\t                    numbers[i] = numbers[i] * (-1);\n\t\t                }\n\t\t                if (numbers[i] == 1) {\n\t\t                    cnt++;\n\t\t                }\n\t\t                if (numbers[i] % divisor == 0) {\n\t\t                    divisible = true;\n\t\t                    numbers[i] = numbers[i] / divisor;\n\t\t                }\n\t\t            }\n\t\t            if (divisible) {\n\t\t                lcm = lcm * divisor;\n\t\t            } else {\n\t\t                divisor++;\n\t\t            }\n\t\t            if (cnt == numbers.length) {\n\t\t                return lcm;\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t\tpublic static long fact(long n) {\n\t\t\t\t\n\t\t\t\tlong factorial = 1;\n\t\t\t\t for(int i = 1; i <= n; i++)\n\t\t\t        {\n\t\t\t            factorial *= i;\n\t\t\t        }\n\t\t\t\t return factorial;\n\t\t\t}\n\t\t\t\n\t\t\tpublic static void factSieve(int[] a, int n) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor(int i=2; i<=n; i+=2)\n\t\t\t\t\ta[i] = 2;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor(int i=3; i<=n; i+=2)\n\t\t\t\t{\n\t\t\t\t\tif(a[i]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i] = i;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j=i; j*i<=n; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta[i*j] = i;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint k = 1000;\n\t\t\t\twhile(k!=1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(a[k]+\" \");\n\t\t\t\t\tk /= a[k];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t\n\t\t\t\n\t\t\tpublic static long choose(long total, long choose){\n\t\t\t    if(total < choose)\n\t\t\t        return 0;\n\t\t\t    if(choose == 0 || choose == total)\n\t\t\t        return 1;\n\t\t\t    return (choose(total-1,choose-1)+choose(total-1,choose))%mod;\n\t\t\t}\n\t\t\t\n\t\t\tpublic static long[] suffle(long[] a,Random gen)\n\t\t\t{\n\t\t\t\tint n = a.length;\n\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t{\n\t\t\t\t\tint ind = gen.nextInt(n-i)+i;\n\t\t\t\t\tlong temp = a[ind];\n\t\t\t\t\ta[ind] = a[i];\n\t\t\t\t\ta[i] = temp;\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\t\n\t\t\tpublic static long[] sort(long[] a)\n\t\t\t{\n\t\t\t\tRandom gen = new Random();\n\t\t\t\tint n = a.length;\n\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t{\n\t\t\t\t\tint ind = gen.nextInt(n-i)+i;\n\t\t\t\t\tlong temp = a[ind];\n\t\t\t\t\ta[ind] = a[i];\n\t\t\t\t\ta[i] = temp;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tArrays.sort(a);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\t\n\t\t\tpublic static int[] sort(int[] a)\n\t\t\t{\n\t\t\t\tRandom gen = new Random();\n\t\t\t\tint n = a.length;\n\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t{\n\t\t\t\t\tint ind = gen.nextInt(n-i)+i;\n\t\t\t\t\tint temp = a[ind];\n\t\t\t\t\ta[ind] = a[i];\n\t\t\t\t\ta[i] = temp;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tArrays.sort(a);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\t\n\t\t\tpublic static int floorSearch(int arr[], int low, int high, int x)\n\t\t\t{\n\t\t\t    if (low > high)\n\t\t\t        return -1;\n\t\t\t \n\t\t\t    if (x > arr[high])\n\t\t\t        return high;\n\t\t\t    int mid = (low+high)/2;\n\t\t\t \n\t\t\t \n\t\t\t    if (mid > 0 && arr[mid-1] < x && x < arr[mid])\n\t\t\t        return mid-1;\n\t\t\t \n\t\t\t    if (x < arr[mid])\n\t\t\t        return floorSearch(arr, low, mid-1, x);\n\t\t\t \n\t\t\t    return floorSearch(arr, mid+1, high, x);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tpublic static void swap(int a, int b){\n\t\t\t\tint temp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = temp;\n\t\t\t}\n\t\t\tpublic static ArrayList<Integer> primeFactorization(int n)\n\t\t\t{\n\t\t\t\tArrayList<Integer> a =new ArrayList<Integer>();\n\t\t\t\tfor(int i=2;i*i<=n;i++)\n\t\t\t\t{\n\t\t\t\t\twhile(n%i==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta.add(i);\n\t\t\t\t\t\tn/=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(n!=1)\n\t\t\t\t\ta.add(n);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tpublic static void sieve(boolean[] isPrime,int n)\n\t\t\t{\n\t\t\t\tfor(int i=1;i<n;i++)\n\t\t\t\t\tisPrime[i] = true;\n\t\t\t\t\n\t\t\t\tisPrime[0] = false;\n\t\t\t\tisPrime[1] = false;\n\t\t\t\t\n\t\t\t\tfor(int i=2;i*i<n;i++)\n\t\t\t\t{\n\t\t\t\t\tif(isPrime[i] == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int j=(2*i);j<n;j+=i)\n\t\t\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpublic static int lowerbound(ArrayList<Integer> list, int c2) {\n\t\t\t\tint i=Collections.binarySearch(list, c2);\n\t\t\t\tif(i<0)\n\t\t\t\t\ti = -(i+2);\n\t\t\t\treturn i;\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tpublic static int lowerboundArray(long[] psum, long c2) {\n\t\t\t\tint i=Arrays.binarySearch(psum, c2);\n\t\t\t\tif(i<0)\n\t\t\t\t\ti = -(i+2);\n\t\t\t\treturn i;\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tpublic static int uperboundArray(long[] psum, long c2) {\n\t\t\t\tint i=Arrays.binarySearch(psum, c2);\n\t\t\t\tif(i<0)\n\t\t\t\t\ti = -(i+1);\n\t\t\t\treturn i;\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tpublic static int uperbound(ArrayList<Integer> list, int c2) {\n\t\t\t\tint i=Collections.binarySearch(list, c2);\n\t\t\t\tif(i<0)\n\t\t\t\t\ti = -(i+1);\n\t\t\t\treturn i;\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\n\t\t\tpublic static void print(int[] a)\n\t\t\t{\n\t\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\t\tfor(int i=0; i<a.length; i++)\n\t\t\t\t\tpw.print(a[i]+\" \");\n\t\t\t\t\n\t\t\t\tpw.println();\n\t\t\t\tpw.flush();\n\t\t\t\tpw.close();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tpublic static void print(long[] a)\n\t\t\t{\n\t\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\t\tfor(int i=0; i<a.length; i++)\n\t\t\t\t\tpw.print(a[i]+\" \");\n\t\t\t\t\n\t\t\t\tpw.println();\n\t\t\t\tpw.flush();\n\t\t\t\tpw.close();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tpublic static int GCD(int a,int b)\n\t\t\t{\n\t\t\t\tif(b==0)\n\t\t\t\t\treturn a;\n\t\t\t\telse\n\t\t\t\t\treturn GCD(b,a%b);\n\t\t\t}\n\t\t\t\n\t\t\tpublic static long GCD(long a,long b)\n\t\t\t{\n\t\t\t\tif(b==0)\n\t\t\t\t\treturn a;\n\t\t\t\telse\n\t\t\t\t\treturn GCD(b,a%b);\n\t\t\t}\n\t\t\t\n\t\t\tpublic static void extendedEuclid(int A,int B)\n\t\t\t{\n\t\t\t\tif(B==0)\n\t\t\t\t{\n\t\t\t\t\td = A;\n\t\t\t\t\tp = 1 ;\n\t\t\t\t\tq = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\textendedEuclid(B, A%B);\n\t\t\t\t\tint temp = p;\n\t\t\t\t\tp = q;\n\t\t\t\t\tq = temp - (A/B)*q;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpublic static long LCM(long a,long b)\n\t\t\t{\n\t\t\t\treturn (a*b)/GCD(a,b);\n\t\t\t}\n\t\t\t\n\t\t\tpublic static int LCM(int a,int b)\n\t\t\t{\n\t\t\t\treturn (a*b)/GCD(a,b);\n\t\t\t}\n\t\t\t\n\t\t\tpublic static int binaryExponentiation(int x,int n)\n\t\t\t{\n\t\t\t    int result=1;\n\t\t\t    while(n>0)\n\t\t\t    {\n\t\t\t        if(n % 2 ==1)\n\t\t\t            result=result * x;\n\t\t\t        x=x*x;\n\t\t\t        n=n/2;\n\t\t\t    }\n\t\t\t    return result;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tpublic static int[] countDer(int n)\n\t\t    {\n\t\t        int der[] = new int[n + 1];\n\t\t     \n\t\t        der[0] = 1;\n\t\t        der[1] = 0;\n\t\t        der[2] = 1;\n\t\t     \n\t\t        for (int i = 3; i <= n; ++i)\n\t\t            der[i] = (i - 1) * (der[i - 1] + der[i - 2]);\n\t\t     \n\t\t        // Return result for n\n\t\t        return der;\n\t\t    }\n\t\t\t\n\t\t\t\n\t\t\t static long binomialCoeff(int n, int k)\n\t\t\t    {\n\t\t\t    long C[][] = new long[n+1][k+1];\n\t\t\t    int i, j;\n\t\t\t     \n\t\t\t        // Calculate  value of Binomial Coefficient in bottom up manner\n\t\t\t    for (i = 0; i <= n; i++)\n\t\t\t    {\n\t\t\t        for (j = 0; j <= Math.min(i, k); j++)\n\t\t\t        {\n\t\t\t            // Base Cases\n\t\t\t            if (j == 0 || j == i)\n\t\t\t                C[i][j] = 1;\n\t\t\t      \n\t\t\t            // Calculate value using previosly stored values\n\t\t\t            else\n\t\t\t                C[i][j] = C[i-1][j-1] + C[i-1][j];\n\t\t\t          }\n\t\t\t     }\n\t\t\t      \n\t\t\t    return C[n][k];\n\t\t\t    }\n\t\t\t\n\t\t\tpublic static long binaryExponentiation(long x,long n)\n\t\t\t{\n\t\t\t    long result=1;\n\t\t\t    while(n>0)\n\t\t\t    {\n\t\t\t        if(n % 2 ==1)\n\t\t\t            result= (result * x)%mod;\n\t\t\t        x=(x%mod * x%mod)%mod;\n\t\t\t        n=n/2;\n\t\t\t    }\n\t\t\t    return result%mod;\n\t\t\t}\n\t\t\t\n\t\t\tpublic static int modularExponentiation(int x,int n,int M)\n\t\t\t{\n\t\t\t    int result=1;\n\t\t\t    while(n>0)\n\t\t\t    {\n\t\t\t        if(n % 2 ==1)\n\t\t\t            result=(result * x)%M;\n\t\t\t        x=(x%M*x%M)%M;\n\t\t\t        n=n/2;\n\t\t\t    }\n\t\t\t    return result;\n\t\t\t}\n\t\t\t\n\t\t\tpublic static long modularExponentiation(long x,long n,long M)\n\t\t\t{\n\t\t\t    long result=1;\n\t\t\t    while(n>0)\n\t\t\t    {\n\t\t\t        if(n % 2 ==1)\n\t\t\t            result=(result %M* x%M)%M;\n\t\t\t        x=(x*x)%M;\n\t\t\t        n=n/2;\n\t\t\t    }\n\t\t\t    return result;\n\t\t\t}\n\t\t\t\n\t\t\tpublic static int modInverse(int A,int M)\n\t\t\t{\n\t\t\t    return modularExponentiation(A,M-2,M);\n\t\t\t}\n\t\t\t\n\t\t\tpublic static long modInverse(long A,long M)\n\t\t\t{\n\t\t\t    return modularExponentiation(A,M-2,M);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tpublic static boolean checkYear(int year)\n\t\t    {\n\t\t\t\tif (year % 400 == 0)\n\t\t            return true;\n\t\t     \n\t\t        if (year % 100 == 0)\n\t\t            return false;\n\t\t     \n\t\t        if (year % 4 == 0)\n\t\t            return true;\n\t\t        return false;\n\t\t    }\n\t\t\t\n\t\t\tpublic static boolean isPrime(int n)\n\t\t\t{\n\t\t\t    \n\t\t\t    if (n <= 1)  return false;\n\t\t\t    if (n <= 3)  return true;\n\t\t\t    \n\t\t\t    if (n%2 == 0 || n%3 == 0) \n\t\t\t    \treturn false;\n\t\t\t \n\t\t\t    for (int i=5; i*i<=n; i=i+6)\n\t\t\t    {\n\t\t\t        if (n%i == 0 || n%(i+2) == 0)\n\t\t\t           return false;\n\t\t\t    }\n\t\t\t    \n\t\t\t    return true;\n\t\t\t}\n\t\t\t\n\t\t\tstatic class pair implements Comparable<pair>\n\t \n\t\t\t{\n\t\t\t\tLong x;\n\t\t\t\tInteger y;\n\t\t\t\tpair(long a,int y)\n\t\t\t\t{\n\t\t\t\t\tthis.x=a;\n\t\t\t\t\tthis.y=y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic int compareTo(pair o) {\n\t\t\t\t\tint result = x.compareTo(o.x);\n\t\t\t\t\tif(result==0)\n\t\t\t\t\t\tresult = y.compareTo(o.y);\n\t\t\t\t\t\n\t\t\t\t\treturn result;\n\t\t\t\t}  \n\t\t\t\t\n\t\t\t\tpublic String toString()\n\t\t\t\t{\n\t\t\t\t\treturn x+\" \"+y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic boolean equals(Object o)\n\t\t\t\t{\n\t\t\t\t\tif (o instanceof pair)\n\t\t\t\t    {\n\t\t\t\t\t\tpair p = (pair)o;\n\t\t\t\t\t\treturn p.x == x && p.y == y ;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic int hashCode()\n\t\t\t\t{\n\t\t\t\t\treturn new Long(x).hashCode()*31 + new Long(y).hashCode();\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t\n\t\t\tstatic class triplet implements Comparable<triplet>\n\t\t\t{\n\t\t\t\tInteger x,y,z;\n\t\t\t\ttriplet(int x,int y,int z)\n\t\t\t\t{\n\t\t\t\t\tthis.x = x;\n\t\t\t\t\tthis.y = y;\n\t\t\t\t\tthis.z = z;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic  int compareTo(triplet o)\n\t\t\t\t{\n\t\t\t\t\tint result = x.compareTo(o.x);\n\t\t\t\t\tif(result==0)\n\t\t\t\t\t\tresult =  y.compareTo(o.y);\n\t\t\t\t\tif(result==0)\n\t\t\t\t\t\tresult = z.compareTo(o.z);\n\t \n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic boolean equlas(Object o)\n\t\t\t\t{\n\t\t\t\t\tif(o instanceof triplet)\n\t\t\t\t\t{\n\t\t\t\t\t\ttriplet p = (triplet)o;\n\t\t\t\t\t\treturn x==p.x && y==p.y && z==p.z;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic String toString()\n\t\t\t\t{\n\t\t\t\t\treturn x+\" \"+y+\" \"+z;\n\t\t\t\t}\n\t\t\t\tpublic int hashCode()\n\t\t\t\t{\n\t\t\t\t\treturn new Long(x).hashCode()*31 + new Long(y).hashCode() + new Long(z).hashCode(); \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t \n\t\t\t\n\t\t\t\n\t\n\t\t}\n\t\t\n\t\t\t"
        },
        {
            "language": 1,
            "solution": "# your code goes here\nimport math\n\nn = input()\n\nfac = {}\ndef factors(num):\n    i=1\n    while i<math.ceil(num**0.5):\n        i+=1\n        #print(i,num)\n        if num%i==0:\n            fac[i] = 1\n            num = num/i\n            i = i-1\n        if i > 1:\n            fac[num]=1\n            \n\n(a,b) = [int(x) for x in raw_input().split()]\n\nints = []\n#print ints\nfor i in range(1,n,1):\n    #print(i)\n    nums = raw_input()\n    #print nums\n    #ints.append(int(nums.split(\" \")[0]),int(nums.split(\" \")[1]))\n    part1 = int(nums.split(\" \")[0])\n    part2 = int(nums.split(\" \")[1])\n    ints.append((part1,part2))\n\n\n\nfactors(a)\nfactors(b)\n\nfor jack in ints:\n    for p in fac.keys():\n        if jack[0]%p !=0 and jack[1]%p !=0:\n            fac.pop(p)\n        \nif len(fac.keys())>0:\n    print(fac.keys()[0])\n\nelse:\n    print(-1)\n\n            \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  vector<pair<long long, long long> > v;\n  for (int i = 0; i < n; i++) {\n    long long x, y;\n    cin >> x >> y;\n    v.push_back({x, y});\n  }\n  set<long long> s;\n  for (long long i = 2; i * i <= v[0].first; i++) {\n    if (v[0].first % i == 0) {\n      s.insert(i);\n      while (v[0].first % i == 0) v[0].first /= i;\n    }\n  }\n  if (v[0].first != 1) s.insert(v[0].first);\n  for (long long i = 2; i * i <= v[0].second; i++) {\n    if (v[0].second % i == 0) {\n      s.insert(i);\n      while (v[0].second % i == 0) v[0].second /= i;\n    }\n  }\n  if (v[0].second != 1) s.insert(v[0].second);\n  for (long long i = 1; i < n; i++) {\n    if (s.empty()) break;\n    for (auto j = s.begin(); j != s.end();) {\n      if (v[i].first % (*j) && v[i].second % (*j))\n        j = s.erase(j);\n      else\n        j++;\n    }\n  }\n  if (s.empty()) {\n    cout << -1;\n    return 0;\n  }\n  cout << *s.begin();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<long long int> s;\nmap<long long int, long long int> cnt;\nvoid factorise(long long int n) {\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      s.insert(i);\n      while (n % i == 0) {\n        n = n / i;\n      }\n    }\n  }\n  if (n > 1) s.insert(n);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  long long int n, i, ans = -1;\n  cin >> n;\n  vector<pair<long long int, long long int> > a;\n  for (i = 0; i < n; i++) {\n    long long int x, y;\n    cin >> x >> y;\n    a.push_back(make_pair(x, y));\n  }\n  if (n == 1) {\n    cout << a[0].first << \"\\n\";\n    return 0;\n  }\n  factorise(a[0].first);\n  factorise(a[0].second);\n  for (i = 1; i < n; i++) {\n    for (auto it : s) {\n      if (a[i].first % it == 0)\n        cnt[it]++;\n      else if (a[i].second % it == 0)\n        cnt[it]++;\n    }\n  }\n  for (auto it : cnt) {\n    if (it.second == n - 1) {\n      ans = it.first;\n      break;\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*; \nimport java.util.*;\nimport java.math.*; \n\npublic class Main {\n\tstatic long gcd(long a,long b) {\n       if(a==0) {\n    \t   return b;\n       }\n       return gcd(b%a,a);\n    } \n\tpublic static void main(String[] args) throws IOException \n\t{ \n\t\tFastScanner f = new FastScanner(); \n\t\tint t=1;\n//\t\tt=f.nextInt();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\twhile(t>0) {\n\t\t\tt--;\n\t\t\tint n=f.nextInt();\n\t\t\tlong gcd=0;\n\t\t\tint a=0,b=0;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta=f.nextInt();\n\t\t\t\tb=f.nextInt();\n\t\t\t\tgcd=gcd(gcd,((long)a*b)/gcd(a,b));\n\t\t\t}\n\t\t\tgcd=Math.max(gcd(gcd,(long)a),gcd(gcd,(long)b));\n\t\t\tlong ans=-1;\n\t\t\tfor(int i = 2;i*i<=gcd;i++) \n\t        { \n\t            if(gcd%i==0) {\n\t            \tans=i;\n\t            \tbreak;\n\t            }\n\t        }\n\t\t\tif(gcd>1 && ans==-1) {\n\t\t\t\tans=gcd;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.close();\n\t} \n\tstatic void sort(int [] a) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i: a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n    \n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tlong[] readLongArray(int n) {\n\t\t\tlong[] a=new long[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t}\n} \t"
        },
        {
            "language": 4,
            "solution": "import sun.rmi.transport.DGCImpl_Stub;\n\nimport javax.swing.text.rtf.RTFEditorKit;\nimport java.io.*;\nimport java.nio.file.ClosedWatchServiceException;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws FileNotFoundException {\n        ConsoleIO io = new ConsoleIO(new InputStreamReader(System.in), new PrintWriter(System.out));\n\n//        String fileName = \"jacks_candy_shop\";\n//        ConsoleIO io = new ConsoleIO(new FileReader(\"D:\\\\Dropbox\\\\code\\\\practice\\\\jb\\\\src\\\\\" + fileName + \".txt\"), new PrintWriter(new File(\"D:\\\\Dropbox\\\\code\\\\practice\\\\jb\\\\src\\\\\" + fileName + \".out\")));\n\n        new Main(io).solve();\n//        new Main(io).solveLocal();\n\n        io.close();\n    }\n\n    ConsoleIO io;\n\n    Main(ConsoleIO io) {\n        this.io = io;\n    }\n\n    ConsoleIO opt;\n\n    Main(ConsoleIO io, ConsoleIO opt) {\n        this.io = io;\n        this.opt = opt;\n    }\n\n    List<List<Integer>> gr = new ArrayList<>();\n    long MOD = 1_000_000_007;\n\n    public void solve() {\n        int n = io.ri();\n        long a = io.ri();\n        long b = io.ri();\n        if(n==1){\n            io.writeLine(a + \"\");\n            return;\n        }\n\n        List<Long> al = getPrimes(a);\n        List<Long> bl = getPrimes(b);\n        for(int i = 0;i<bl.size();i++){\n            Long v = bl.get(i);\n            if(!al.contains(v))\n                al.add(v);\n        }\n\n        boolean[] can = new boolean[al.size()];\n        Arrays.fill(can, true);\n        for(int i = 1;i<n;i++) {\n            long c = io.ri();\n            long d = io.ri();\n            for (int j = 0; j < can.length; j++)\n                if (can[j]) {\n                    long v = al.get(j);\n                    if (c % v != 0 && d % v != 0) {\n                        can[j] = false;\n                    }\n                }\n        }\n\n        for(int i = 0;i<can.length;i++)if(can[i]){\n            io.writeLine(al.get(i)+\"\");\n            return;\n        }\n        io.writeLine(\"-1\");\n    }\n\n    List<Long> getPrimes(long a){\n        List<Long> res = new ArrayList<>();\n        for(long q = 2; q*q<=a;q++) {\n            if (a % q == 0) {\n                res.add(q);\n                while (a % q == 0)\n                    a /= q;\n            }\n        }\n\n        if(a>1)res.add(a);\n        return res;\n    }\n}\n\n\nclass ConsoleIO {\n\n    BufferedReader br;\n    PrintWriter out;\n    public ConsoleIO(Reader reader, PrintWriter writer){br = new BufferedReader(reader);out = writer;}\n    public void flush(){this.out.flush();}\n    public void close(){this.out.close();}\n    public void writeLine(String s) {this.out.println(s);}\n    public void writeInt(int a) {this.out.print(a);this.out.print(' ');}\n    public void writeWord(String s){\n        this.out.print(s);\n    }\n    public void writeIntArray(int[] a, int k, String separator) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < k; i++) {\n            if (i > 0) sb.append(separator);\n            sb.append(a[i]);\n        }\n        this.writeLine(sb.toString());\n    }\n    public int read(char[] buf, int len){try {return br.read(buf,0,len);}catch (Exception ex){ return -1; }}\n    public String readLine() {try {return br.readLine();}catch (Exception ex){ return \"\";}}\n    public long[] readLongArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");long[]r=new long[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Long.parseLong(n[i]);\n        return r;\n    }\n    public int[] readIntArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");int[]r=new int[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Integer.parseInt(n[i]);\n        return r;\n    }\n    public int[] readIntArray(int n) {\n        int[] res = new int[n];\n        char[] all = this.readLine().toCharArray();\n        int cur = 0;boolean have = false;\n        int k = 0;\n        boolean neg = false;\n        for(int i = 0;i<all.length;i++){\n            if(all[i]>='0' && all[i]<='9'){\n                cur = cur*10+all[i]-'0';\n                have = true;\n            }else if(all[i]=='-') {\n                neg = true;\n            }\n            else if(have){\n                res[k++] = neg?-cur:cur;\n                cur = 0;\n                have = false;\n                neg = false;\n            }\n        }\n        if(have)res[k++] = neg?-cur:cur;\n        return res;\n    }\n    public int ri() {\n        try {\n            int r = 0;\n            boolean start = false;\n            boolean neg = false;\n            while (true) {\n                int c = br.read();\n                if (c >= '0' && c <= '9') {\n                    r = r * 10 + c - '0';\n                    start = true;\n                } else if (!start && c == '-') {\n                    start = true;\n                    neg = true;\n                } else if (start || c == -1) return neg ? -r : r;\n            }\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n    public long readLong() {\n        try {\n            long r = 0;\n            boolean start = false;\n            boolean neg = false;\n            while (true) {\n                int c = br.read();\n                if (c >= '0' && c <= '9') {\n                    r = r * 10 + c - '0';\n                    start = true;\n                } else if (!start && c == '-') {\n                    start = true;\n                    neg = true;\n                } else if (start || c == -1) return neg ? -r : r;\n            }\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n    public String readWord() {\n        try {\n            boolean start = false;\n            StringBuilder sb = new StringBuilder();\n            while (true) {\n                int c = br.read();\n                if (c!= ' ' && c!= '\\r' && c!='\\n' && c!='\\t') {\n                    sb.append((char)c);\n                    start = true;\n                } else if (start || c == -1) return sb.toString();\n            }\n        } catch (Exception ex) {\n            return \"\";\n        }\n    }\n    public char readSymbol() {\n        try {\n            while (true) {\n                int c = br.read();\n                if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t') {\n                    return (char) c;\n                }\n            }\n        } catch (Exception ex) {\n            return 0;\n        }\n    }\n//public char readChar(){try {return (char)br.read();}catch (Exception ex){ return 0; }}\n}\nclass Pair {\n    public Pair(int a, int b) {this.a = a;this.b = b;}\n    public int a;\n    public int b;\n}\nclass PairLL {\n    public PairLL(long a, long b) {this.a = a;this.b = b;}\n    public long a;\n    public long b;\n}\nclass Triple {\n    public Triple(int a, int b, int c) {this.a = a;this.b = b;this.c = c;}\n    public int a;\n    public int b;\n    public int c;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 150005;\nconst int q = 600005;\nlong long n, a[N], b[N];\nlong long qwq, ans = 19260817000;\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 3) + (x << 1) + (c ^ 48);\n    c = getchar();\n  }\n  return x * f;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0)\n    return a;\n  else\n    return gcd(b, a % b);\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i] >> b[i];\n    qwq = gcd(qwq, 1ll * b[i] * a[i] / gcd(b[i], a[i]));\n  }\n  if (qwq == 1) {\n    printf(\"-1\\n\");\n    return 0;\n  }\n  for (int i = 1; i <= n; ++i) {\n    long long x = gcd(qwq, a[i]);\n    if (x > 1) qwq = x;\n    long long y = gcd(qwq, b[i]);\n    if (y > 1) qwq = y;\n  }\n  printf(\"%I64d\\n\", qwq);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int>> v;\nint gcd(int a, int b) {\n  if (a < b) swap(a, b);\n  if (a % b == 0) return b;\n  return gcd(b, a % b);\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int before_x, before_y;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    v.push_back(make_pair(x, y));\n  }\n  sort(v.begin(), v.end());\n  for (int i = 0; i < n; i++) {\n    if (i == 0) {\n      before_x = v[i].first;\n      before_y = v[i].second;\n      continue;\n    }\n    int gcd1 = gcd(before_x, v[i].first);\n    int gcd2 = gcd(before_x, v[i].second);\n    if (i != n - 1)\n      before_x = (long long)gcd1 * gcd2 / gcd(gcd1, gcd2);\n    else\n      before_x = max(gcd1, gcd2);\n    int gcd3 = gcd(before_y, v[i].first);\n    int gcd4 = gcd(before_y, v[i].second);\n    if (i != n - 1)\n      before_y = (long long)gcd3 * gcd4 / gcd(gcd3, gcd4);\n    else\n      before_y = max(gcd3, gcd4);\n  }\n  if (before_x == 1 && before_y == 1)\n    printf(\"-1\");\n  else\n    printf(\"%d\", max(before_y, before_x));\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\npublic class templ implements Runnable {\n    class pair\n    {\n        int v,val;\n        pair(int f,int s)\n        {\n            v=f;\n            val=s;\n        }\n    }\n    //public static ArrayList<Integer> g[]=new ArrayList[1000000];\n    //public static int vis[]=new int[1000000];\n    public static int M=1000000007;\n    static int binarySearch(int arr[], int l, int r, int x)\n    {\n        if (r >= l)\n        {\n            int mid = l + (r - l)/2;\n            if (arr[mid] == x)\n                return mid;\n            if (arr[mid] > x)\n                return binarySearch(arr, l, mid-1, x);\n            return binarySearch(arr, mid+1, r, x);\n        }\n        return -1;\n    }\n    void merge1(int arr[], int l, int m, int r)\n    {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        int L[] = new int [n1];\n        int R[] = new int [n2];\n        for (int i=0; i<n1; ++i)\n            L[i] = arr[l + i];\n        for (int j=0; j<n2; ++j)\n            R[j] = arr[m + 1+ j];\n        int i = 0, j = 0;\n        int k = l;\n        while (i < n1 && j < n2)\n        {\n            if (L[i]<=R[j])\n            {\n                arr[k] = L[i];\n                i++;\n            }\n            else\n            {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < n1)\n        {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n        while (j < n2)\n        {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n    void sort1(int arr[], int l, int r)\n    {\n        if (l < r)\n        {\n            int m = (l+r)/2;\n            sort1(arr, l, m);\n            sort1(arr , m+1, r);\n            merge1(arr, l, m, r);\n        }\n    }\n    void merge3(int arr[],int arr1[],int arr2[], int l, int m, int r)\n    {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        int L[] = new int [n1];\n        int R[] = new int [n2];\n        int L1[]=new int[n1];\n        int R1[]=new int[n2];\n        int L2[]=new int[n1];\n        int R2[]=new int[n2];\n        //long L3[]=new long[n1];\n        //long R3[]=new long[n2];\n        for (int i=0; i<n1; ++i)\n        {\n            L[i] = arr[l + i];\n            L1[i]=arr1[l+i];\n            L2[i]=arr2[l+i];\n            //L3[i]=arr3[l+i];\n        }\n        for (int j=0; j<n2; ++j)\n        {\n            R[j] = arr[m + 1+ j];\n            R1[j]=arr1[m+1+j];\n            R2[j]=arr2[m+1+j];\n            //R3[j]=arr3[m+1+j];\n        }\n        int i = 0, j = 0;\n        int k = l;\n        while (i < n1 && j < n2)\n        {\n            if (L[i] <= R[j])\n            {\n                arr[k] = L[i];\n                arr1[k]=L1[i];\n                arr2[k]=L2[i];\n                //arr3[k]=L3[i];\n                i++;\n            }\n            else\n            {\n                arr[k] = R[j];\n                arr1[k]=R1[j];\n                arr2[k]=R2[j];\n                //arr3[k]=R3[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < n1)\n        {\n            arr[k] = L[i];\n            arr1[k]=L1[i];\n            arr2[k]=L2[i];\n            //arr3[k]=L3[i];\n            i++;\n            k++;\n        }\n        while (j < n2)\n        {\n            arr[k] = R[j];\n            arr1[k]=R1[j];\n            arr2[k]=R2[j];\n            //arr3[k]=R3[j];\n            j++;\n            k++;\n        }\n    }\n    void sort3(int arr[],int arr1[],int arr2[], int l, int r)\n    {\n        if (l < r)\n        {\n            int m = (l+r)/2;\n            sort3(arr,arr1,arr2, l, m);\n            sort3(arr ,arr1,arr2, m+1, r);\n            merge3(arr,arr1,arr2,l, m, r);\n        }\n    }\n    void merge2(int arr[],int arr1[],int l, int m, int r)\n    {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        int L[] = new int [n1];\n        int R[] = new int [n2];\n        int L1[]=new int[n1];\n        int R1[]=new int[n2];\n        for (int i=0; i<n1; ++i)\n        {\n            L[i] = arr[l + i];\n            L1[i]=arr1[l+i];\n        }\n        for (int j=0; j<n2; ++j)\n        {\n            R[j] = arr[m + 1+ j];\n            R1[j]=arr1[m+1+j];\n        }\n        int i = 0, j = 0;\n        int k = l;\n        while (i < n1 && j < n2)\n        {\n            if (L[i] <= R[j])\n            {\n                arr[k] = L[i];\n                arr1[k]=L1[i];\n                i++;\n            }\n            else\n            {\n                arr[k] = R[j];\n                arr1[k]=R1[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < n1)\n        {\n            arr[k] = L[i];\n            arr1[k]=L1[i];\n            i++;\n            k++;\n        }\n        while (j < n2)\n        {\n            arr[k] = R[j];\n            arr1[k]=R1[j];\n            j++;\n            k++;\n        }\n    }\n    void sort2(int arr[],int arr1[],int l, int r)\n    {\n        if (l < r)\n        {\n            int m = (l+r)/2;\n            sort2(arr,arr1, l, m);\n            sort2(arr ,arr1, m+1, r);\n            merge2(arr,arr1,l, m, r);\n        }\n    }\n    void merge4(int arr[],int arr1[],int arr2[],int arr3[], int l, int m, int r)\n    {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        int L[] = new int [n1];\n        int R[] = new int [n2];\n        int L1[]=new int[n1];\n        int R1[]=new int[n2];\n        int L2[]=new int[n1];\n        int R2[]=new int[n2];\n        int L3[]=new int[n1];\n        int R3[]=new int[n2];\n        for (int i=0; i<n1; ++i)\n        {\n            L[i] = arr[l + i];\n            L1[i]=arr1[l+i];\n            L2[i]=arr2[l+i];\n            L3[i]=arr3[l+i];\n        }\n        for (int j=0; j<n2; ++j)\n        {\n            R[j] = arr[m + 1+ j];\n            R1[j]=arr1[m+1+j];\n            R2[j]=arr2[m+1+j];\n            R3[j]=arr3[m+1+j];\n        }\n        int i = 0, j = 0;\n        int k = l;\n        while (i < n1 && j < n2)\n        {\n            if (L[i] <= R[j])\n            {\n                arr[k] = L[i];\n                arr1[k]=L1[i];\n                arr2[k]=L2[i];\n                arr3[k]=L3[i];\n                i++;\n            }\n            else\n            {\n                arr[k] = R[j];\n                arr1[k]=R1[j];\n                arr2[k]=R2[j];\n                arr3[k]=R3[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < n1)\n        {\n            arr[k] = L[i];\n            arr1[k]=L1[i];\n            arr2[k]=L2[i];\n            arr3[k]=L3[i];\n            i++;\n            k++;\n        }\n        while (j < n2)\n        {\n            arr[k] = R[j];\n            arr1[k]=R1[j];\n            arr2[k]=R2[j];\n            arr3[k]=R3[j];\n            j++;\n            k++;\n        }\n    }\n    void sort4(int arr[],int arr1[],int arr2[],int arr3[], int l, int r)\n    {\n        if (l < r)\n        {\n            int m = (l+r)/2;\n            sort4(arr,arr1,arr2,arr3, l, m);\n            sort4(arr ,arr1,arr2,arr3, m+1, r);\n            merge4(arr,arr1,arr2,arr3,l, m, r);\n        }\n    }\n    public int justsmall(int a[],int l,int r,int x)\n    {\n        int p=-1;\n        while(l<=r)\n        {\n            int mid=(l+r)/2;\n            if(a[mid]<=x)\n            {\n                p=mid;\n                l=mid+1;\n            }\n            else\n                r=mid-1;\n        }\n        return p;\n    }\n    public int justlarge(int a[],int l,int r,int x)\n    {\n        int p=0;\n        while(l<=r)\n        {\n            int mid=(l+r)/2;\n            if(a[mid]<x)\n            {\n                l=mid+1;\n            }\n            else\n            {\n                p=mid;\n                r = mid - 1;\n            }\n        }\n        return p;\n    }\n    long gcd(long x,long y)\n    {\n        if(x%y==0)\n            return y;\n        else\n            return(gcd(y,x%y));\n    }\n    int fact(int n)\n    {\n        int ans=1;\n        for(int i=1;i<=n;i++)\n            ans*=i;\n        return ans;\n    }\n    public static void main(String args[])throws Exception\n    {\n        new Thread(null,new templ(),\"templ\",1<<26).start();\n    }\n    public void run() {\n        try {\n            InputReader in = new InputReader(System.in);\n            PrintWriter out = new PrintWriter(System.out);\n            int n=in.ni();\n            int a[]=new int[n];\n            int b[]=new int[n];\n            for(int i=0;i<n;i++)\n            {\n                a[i]=in.ni();\n                b[i]=in.ni();\n            }\n            int k=0;\n            for(int i=0;i<n;i++)\n            {\n                if(a[i]%2==0||b[i]%2==0)\n                    k++;\n            }\n            if(k==n)\n                out.println(\"2\");\n            else\n            {\n                HashSet<Integer>hs=new HashSet<>();\n                ArrayList<Integer>m=new ArrayList<>();\n                int x=a[0];\n                while (x%2==0)\n                {\n                    if(!hs.contains(2))\n                    {\n                        hs.add(2);\n                        m.add(2);\n                    }\n                    x /= 2;\n                }\n\n                for (int i = 3; i <= Math.sqrt(x); i+= 2)\n                {\n                    while (x%i == 0)\n                    {\n                        if(!hs.contains(i))\n                        {\n                            hs.add(i);\n                            m.add(i);\n                        }\n                        x /= i;\n                    }\n                }\n                if (x > 2)\n                {\n                    if(!hs.contains(x))\n                    {\n                        hs.add(x);\n                        m.add(x);\n                    }\n                }\n                x=b[0];\n                while (x%2==0)\n                {\n                    if(!hs.contains(2))\n                    {\n                        hs.add(2);\n                        m.add(2);\n                    }\n                    x /= 2;\n                }\n\n                for (int i = 3; i <= Math.sqrt(x); i+= 2)\n                {\n                    while (x%i == 0)\n                    {\n                        if(!hs.contains(i))\n                        {\n                            hs.add(i);\n                            m.add(i);\n                        }\n                        x /= i;\n                    }\n                }\n                if (x > 2)\n                {\n                    if(!hs.contains(x))\n                    {\n                        hs.add(x);\n                        m.add(x);\n                    }\n                }\n                int r[]=new int[1000000];\n                int o=0;\n                int kk=-1;\n                for(int i=1;i<n;i++)\n                {\n                    int p=a[i];\n                    int q=b[i];\n                    o=0;\n                    for(int j=0;j<m.size();j++)\n                    {\n                        int l=m.get(j);\n                        if(a[i]%l!=0&&b[i]%l!=0)\n                        {\n                            r[o]=l;\n                            o++;\n                        }\n                    }\n                    for(int j=0;j<o;j++)\n                    {\n                        m.remove(new Integer(r[j]));\n                    }\n                }\n                if(m.size()==0)\n                    out.println(\"-1\");\n                else\n                    out.println(m.get(0));\n            }\n            out.close();\n        }\n        catch(Exception e){\n            return;\n        }\n    }\n    static class InputReader {\n\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int ni() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nl() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n    }\n}"
        },
        {
            "language": 3,
            "solution": "def f(a):\n    s = set()\n    n = a\n    i = 2\n    while i ** 2 <= a:\n        if a % i == 0:\n            while a % i == 0:\n                a //= i\n            s.add(i)\n        i += 1\n    if a > 1:\n        s.add(a)\n    return s\n\n\ndef check(elem):\n    for item in a:\n        if item[0] % elem != 0 and item[1] % elem != 0:\n            return False\n    return True\n\n\nn = int(input())\na = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    a.append((x, y))\ns = f(a[0][0]).union(f(a[0][1]))\nfor elem in s:\n    if check(elem):\n        print(elem)\n        exit()\nprint(-1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[150010][2];\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i][0] >> a[i][1];\n  vector<int> f1, f2;\n  int rem = a[0][0];\n  for (int i = 2; i * i <= a[0][0]; i++) {\n    if (rem % i == 0) f1.push_back(i);\n    while (rem % i == 0) {\n      rem /= i;\n    }\n  }\n  if (rem != 1) f1.push_back(rem);\n  rem = a[0][1];\n  for (int i = 2; i * i <= a[0][1]; i++) {\n    if (rem % i == 0) f2.push_back(i);\n    while (rem % i == 0) {\n      rem /= i;\n    }\n  }\n  if (rem != 1) f2.push_back(rem);\n  for (int i = 0; i < f1.size(); i++) {\n    bool b = 1;\n    for (int j = 1; j < n; j++) {\n      if (a[j][0] % f1[i] != 0 && a[j][1] % f1[i] != 0) {\n        b = 0;\n        break;\n      }\n    }\n    if (b) {\n      cout << f1[i] << endl;\n      return 0;\n    }\n  }\n  for (int i = 0; i < f2.size(); i++) {\n    bool b = 1;\n    for (int j = 1; j < n; j++) {\n      if (a[j][0] % f2[i] != 0 && a[j][1] % f2[i] != 0) {\n        b = 0;\n        break;\n      }\n    }\n    if (b) {\n      cout << f2[i] << endl;\n      return 0;\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class P1025B {\n\n  void divs(int v, Collection<Integer> s) {\n    s.add(v);\n    for (int d = (int)Math.sqrt(v); d > 1; d--) {\n      if ((v % d) == 0) {\n        s.add(d);\n        s.add(v / d);\n      }\n    }\n  }\n  \n  public void run() throws Exception {\n    Collection<Integer> divs = new HashSet();\n    int n = nextInt() - 1;\n    divs(nextInt(), divs);\n    divs(nextInt(), divs);\n    divs = new ArrayList(divs);\n\n    int [] a = new int [n], b = new int [n];\n    for (int i = 0; i < n; a[i] = nextInt(), b[i] = nextInt(), i++);\n\nnext_d:\n    for (int d : divs) {\n      for (int i = n - 1; i >= 0; i--) {\n        if (((a[i] % d) != 0) && ((b[i] % d) != 0)) {\n          continue next_d;\n        }\n      }\n\n      println(d);\n      return;\n    }\n\n    println(-1);\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P1025B().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    if (a == 0) return Math.abs(b); if (b == 0) return Math.abs(a);\n    a = Math.abs(a); b = Math.abs(b);\n    int az = Integer.numberOfTrailingZeros(a), bz = Integer.numberOfTrailingZeros(b);\n    a >>>= az; b >>>= bz;\n    while (a != b) {\n      if (a > b) { a -= b; a >>>= Integer.numberOfTrailingZeros(a); }\n            else { b -= a; b >>>= Integer.numberOfTrailingZeros(b); }\n    }\n    return (a << Math.min(az, bz));\n  }\n\n  long gcd(long a, long b) {\n    if (a == 0) return Math.abs(b); if (b == 0) return Math.abs(a);\n    a = Math.abs(a); b = Math.abs(b);\n    int az = Long.numberOfTrailingZeros(a), bz = Long.numberOfTrailingZeros(b);\n    a >>>= az; b >>>= bz;\n    while (a != b) {\n      if (a > b) { a -= b; a >>>= Long.numberOfTrailingZeros(a); }\n            else { b -= a; b >>>= Long.numberOfTrailingZeros(b); }\n    }\n    return (a << Math.min(az, bz));\n  }\n\n  void shuffle(int [] a) {\n    Random r = new Random();\n    for (int i = a.length - 1; i >= 0; i--) {\n      int j = r.nextInt(a.length);\n      int t = a[i]; a[i] = a[j]; a[j] = t;\n    }\n  }\n\n  void shuffle(long [] a) {\n    Random r = new Random();\n    for (int i = a.length - 1; i >= 0; i--) {\n      int j = r.nextInt(a.length);\n      long t = a[i]; a[i] = a[j]; a[j] = t;\n    }\n  }\n\n  void shuffle(Object [] a) {\n    Random r = new Random();\n    for (int i = a.length - 1; i >= 0; i--) {\n      int j = r.nextInt(a.length);\n      Object t = a[i]; a[i] = a[j]; a[j] = t;\n    }\n  }\n}"
        },
        {
            "language": 3,
            "solution": "def prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\nnums = [list(map(int,input().split())) for _ in range(int(input()))]\nprods = [x * y for x, y in nums]\n\ndivisors = []\n\ndivisors += (prime_factors(nums[0][0]))\ndivisors += (prime_factors(nums[0][1]))\nprods = list(dict.fromkeys(prods))\n\nnumWorks = 0\ni = -1\n\nwhile (numWorks < len(prods) and i < len(divisors) - 1):\n    i += 1\n    numWorks = 0\n\n    for j in range(0, len(prods)):\n        if prods[j] % divisors[i] == 0:\n            numWorks += 1\n        else:\n           break\n\nif numWorks == len(prods):\n    print(divisors[i])\nelse:\n    print(-1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD = 1e9 + 7;\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &arr) {\n  typename vector<T>::iterator a;\n  for (a = arr.begin(); a != arr.end(); a++) {\n    is >> *a;\n  }\n  return is;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> &arr) {\n  typename vector<T>::iterator a;\n  for (a = arr.begin(); a != arr.end(); a++) {\n    os << *a << \" \";\n  }\n  return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &p) {\n  os << p.first << \" \" << p.second << '\\n';\n  return os;\n}\nlong long mul(long long a, long long b, long long md = MOD) {\n  return (a % md * b % md) % md;\n}\nlong long add(long long a, long long b, long long md = MOD) {\n  long long ans = a + b;\n  if (ans >= md) ans -= md;\n  return ans;\n}\nbool valid(int i, int j, int n, int m) {\n  return i >= 0 && i < n && j >= 0 && j < m;\n}\nvector<pair<int, int>> dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\nlong long binPow(long long x, long long y) {\n  long long ans = 1;\n  while (y > 0) {\n    if (y % 2 == 1) ans = mul(ans, x);\n    x = mul(x, x);\n    y /= 2;\n  }\n  return ans;\n}\nlong long modInverse(long long x) { return binPow(x, MOD - 2); }\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<long long, long long>> p;\n  for (int i = 0; i < int(n); i++) {\n    long long a, b;\n    cin >> a >> b;\n    p.push_back({a, b});\n  }\n  set<long long> fac;\n  auto [a, b] = p.front();\n  for (long long f = 2; f * f <= a; f++) {\n    if (a % f == 0) {\n      fac.insert(f);\n      while (a % f == 0) a /= f;\n    }\n  }\n  for (long long f = 2; f * f <= b; f++) {\n    if (b % f == 0) {\n      fac.insert(f);\n      while (b % f == 0) b /= f;\n    }\n  }\n  if (a > 1) fac.insert(a);\n  if (b > 1) fac.insert(b);\n  for (int i = int(1); i < int(n); i++) {\n    vector<long long> list;\n    auto [a, b] = p[i];\n    for (long long x : fac)\n      if (a % x != 0 && b % x != 0) list.push_back(x);\n    for (long long x : list) fac.erase(x);\n  }\n  cout << (fac.empty() ? -1 : *fac.begin()) << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long i, i0, n, m;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nbool ispr(int num) {\n  if (num == 1) return 0;\n  if (num == 2 || num == 3) return 1;\n  if (num % 6 != 1 && num % 6 != 5) return 0;\n  int tmp = sqrt(num);\n  for (int i = 5; i <= tmp; i += 6)\n    if (num % i == 0 || num % (i + 2) == 0) return 0;\n  return 1;\n}\nstruct node {\n  long long a, b;\n} a[150005];\nqueue<int> dp[150005];\nint main() {\n  while (scanf(\"%lld\", &n) != EOF) {\n    for (i = 0; i < n; i++) scanf(\"%lld %lld\", &a[i].a, &a[i].b);\n    for (i = 2; i * i <= a[0].a; i++) {\n      if (a[0].a % i == 0) {\n        if (ispr(i)) dp[0].push(i);\n        if (ispr(a[0].a / i)) dp[0].push(a[0].a / i);\n      }\n    }\n    for (i = 2; i * i <= a[0].b; i++) {\n      if (a[0].b % i == 0) {\n        if (ispr(i)) dp[0].push(i);\n        if (ispr(a[0].b / i)) dp[0].push(a[0].b / i);\n      }\n    }\n    dp[0].push(a[0].a), dp[0].push(a[0].b);\n    for (i = 1; i < n; i++) {\n      while (!dp[i - 1].empty()) {\n        if (a[i].a % dp[i - 1].front() == 0 || a[i].b % dp[i - 1].front() == 0)\n          dp[i].push(dp[i - 1].front());\n        dp[i - 1].pop();\n      }\n    }\n    if (dp[n - 1].empty())\n      printf(\"-1\\n\");\n    else {\n      printf(\"%d\\n\", dp[n - 1].front());\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nimport sys\ndef printDivisors(n,dict1) :\n    i=2\n    while i <= math.sqrt(n):\n         \n        if (n % i == 0) :\n            if (n // i == i) :\n                dict1[i]=1\n            else :\n                dict1[i]=1\n                dict1[n//i]=1\n\n        i = i + 1\n    dict1[n]=1\nf=sys.stdin\n\nn=int(f.readline().rstrip('\\r\\n'))\nminval=2000000000000\nx1=-1\ny1=-1\ndict2={}\nfor i in range(n):\n    x,y=map(int,f.readline().rstrip('\\r\\n').split())\n    dict2[(x,y)]=1\n    if(x+y<minval):\n        minval=x+y\n        x1=x\n        y1=y\ndict1={}\nprintDivisors(x1,dict1)\nprintDivisors(y1,dict1)\nflagx=0\nfor i in dict2.keys():\n    flag=0\n    k1=dict1.keys()\n    dict1={}\n    for j in k1:\n        if(i[0]%j==0 or i[1]%j==0):\n            dict1[j]=1\n            flag=1\n    if(flag==0):\n        flagx=1\n        break \nif(flagx==1):\n    print(-1)\nelse:\n    for i in dict1.keys():\n        print(i)\n        break"
        },
        {
            "language": 1,
            "solution": "import math\nlis=[]\ndef primeFactors(n):\n    loll = []\n    while n%2==0:\n        loll.append(2)\n        n=n/2\n    for i in range(3, int(math.sqrt(n))+1,2):\n        while n%i==0:\n            loll.append(i)\n            n=n/i\n    if n>2:\n        loll.append(n)\n    return loll\n#primeFactors(315)\n#print lis\nfrom math import sqrt; from itertools import count, islice\n\ndef isPrime(n):\n    return n > 1 and all(n%i for i in islice(count(2), int(sqrt(n)-1)))\nfrom functools import reduce\n\ndef factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nn = int(raw_input())\nminval = 100000000000000\nlol = []\nanslis=[]\nfl=0\nmarker=0\npp=[]\nfor i in xrange(n):\n    a,b =map(int, raw_input().split())\n    if i==0:\n        zz = primeFactors(a)\n        for j in zz:\n            lis.append(j)\n        zz = primeFactors(b)\n        for j in zz:\n            lis.append(j)\n        lis=list(set(lis))\n        #lis.remove(1)\n        for j in xrange(len(lis)):\n            pp.append(0)\n    else:\n        for j in xrange(len(lis)):\n            if a%lis[j]!=0 and b%lis[j]!=0:\n                pp[j]=-1\n#primeFactors(minval)\nflag=0\nfor i in xrange(len(lis)):\n    if pp[i]==0:\n        flag=1\n        print lis[i]\n        break\nif flag==0:\n    print -1"
        },
        {
            "language": 1,
            "solution": "def wcd(n,arr_):\n    p0=arr_[0][0]\n    p1=arr_[0][1]\n    wcd_list = []\n    for i in xrange(2,int(p0**0.5)+1):\n        if p0%i == 0:\n            while p0%i==0:\n                p0=p0/i\n            wcd_list.append(i)\n    if (p0!=1):\n        wcd_list.append(p0)\n    for i in xrange(2,int(p1**0.5)+1):\n        if p1%i == 0:\n            while p1%i==0:\n                p1=p1/i\n            wcd_list.append(i)\n    if (p1!=1):\n        wcd_list.append(p1)\n    wcd_list=list(set(wcd_list))\n    for i in xrange(1,n):\n        p0=arr_[i][0]\n        p1=arr_[i][1]\n        update_ = []\n        for j in wcd_list:\n            if ((p0%j==0) | (p1%j==0)):\n                update_.append(j)\n                \n        if len(update_) == 0:\n            return -1\n        wcd_list=update_\n    return list(wcd_list)[0]\n    \nif __name__ == \"__main__\":\n    n = input()\n    arr_ = []\n    for i in xrange(n):\n        arr_.append(map(int,raw_input().split()))\n    print wcd(n,arr_)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (a < b) return gcd(b, a);\n  long long r = a % b;\n  if (r == 0)\n    return b;\n  else\n    return gcd(b, r);\n}\nint main() {\n  int nPairs;\n  scanf(\"%d\", &nPairs);\n  long long wcd = 0;\n  int a, b;\n  for (int iPair = 0; iPair < nPairs; iPair++) {\n    scanf(\"%d%d\", &a, &b);\n    long long ppcm = (long long)a * b / gcd(a, b);\n    if (wcd == 0ll)\n      wcd = ppcm;\n    else\n      wcd = gcd(wcd, ppcm);\n  }\n  if (wcd > 1) {\n    long long l = gcd(wcd, a);\n    if (l == 1) l = gcd(wcd, b);\n    for (int i = 2; i < 44722; i++) {\n      if (l % i == 0) {\n        printf(\"%d\\n\", i);\n        return 0;\n      }\n    }\n    printf(\"%lld\\n\", l);\n  } else\n    printf(\"-1\\n\");\n}\n"
        },
        {
            "language": 3,
            "solution": "def get_prime(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n//i+1):\n                res[i*j]=1\n    return prime\n\nprime=get_prime(10**6)\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n//=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\nimport sys\nfrom math import gcd\n\ninput=sys.stdin.buffer.readline\n\nn=int(input())\nA,B=map(int,input().split())\nnow=A*B\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    now=gcd(now,a*b)\n\nif now>1:\n    p1=factorization(A)\n    p2=factorization(B)\n    P=p1+p2\n    for p in P:\n        if now%p==0:\n            print(p)\n            break\nelse:\n    print(-1)\n"
        },
        {
            "language": 4,
            "solution": "/**\n * BaZ :D\n */\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\npublic class Main\n{  \n    static Reader scan;\n    static PrintWriter pw;\n    public static void main(String[] args) {\n        new Thread(null,null,\"BaZ\",1<<25)\n        {\n           public void run()\n           {\n               try\n               {\n                   solve();\n               }\n               catch(Exception e)\n               {  \n                   e.printStackTrace();\n                   System.exit(1);\n               }\n           }\n        }.start();\n    }\n    static void solve() throws IOException\n    {\n        scan = new Reader();\n        pw = new PrintWriter(System.out,true);\n        StringBuilder sb = new StringBuilder();\n        int n = ni();\n        HashSet<Long> hs = new HashSet();\n        for(int i=0;i<1;++i)\n        {\n            long x = nl();\n            for(long j=2;j*j<=x;++j)\n            {\n                if(x%j==0)\n                {\n                    hs.add(j);\n                    while(x%j==0)\n                        x/=j;\n                }\n            }\n            if(x>1)\n                hs.add(x);\n            long y = nl();\n            for(long j=2;j*j<=y;++j)\n            {\n                if(y%j==0)\n                {\n                    hs.add(j);\n                    while(y%j==0)\n                        y/=j;\n                }\n            }\n            if(y>1)\n                hs.add(y);\n        }\n        for(int i=1;i<n;++i)\n        {\n            HashSet<Long> next = new HashSet();\n            long x = nl();\n            for(long xx:hs)\n                if(x%xx==0)\n                    next.add(xx);\n            long y = nl();\n            for(long xx:hs)\n                if(y%xx==0)\n                    next.add(xx);\n            hs = next;\n        }\n        if(hs.isEmpty())\n            pl(-1);\n        else\n        {\n            long lol = -1;\n            for(long e:hs)\n            {  \n                //p(e);\n                lol = e;\n                break;\n            }\n            pl(lol);\n        }\n        pw.flush();\n        pw.close();\n    }\n    static long lcm(long a,long b)\n    {\n        return (a*b)/gcd(a,b);\n    }\n    static long gcd(long a,long b)\n    {\n        if(b==0)\n            return a;\n        return gcd(b,a%b);\n    }\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Object arr[])\n    {  \n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n    static class Reader {\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader() {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException {\n        byte[] buf = new byte[64];\n        int cnt = 0, c;\n        while ((c = read()) != -1) {\n            if (c == '\\n') break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ') c = read();\n        boolean neg = (c == '-');\n        if (neg) c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0' && c <= '9');\n        if (neg) return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ') c = read();\n        boolean neg = (c == '-');\n        if (neg) c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0' && c <= '9');\n        if (neg) return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ') c = read();\n        boolean neg = (c == '-');\n        if (neg) c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0' && c <= '9');\n        if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);\n        if (neg) return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1) buffer[0] = -1;\n    }\n\n    private byte read() throws IOException {\n        if (bufferPointer == bytesRead) fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException {\n        if (din == null) return;\n        din.close();\n    }\n}\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\n\n \npublic class Try\n{\n    \n    static class InputReader {\n \n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n \n\t\tpublic InputReader(InputStream st) {\n\t\t\tthis.stream = st;\n\t\t}\n \n\t\tpublic int read() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n \n\t\tpublic int ni() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic long nl() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic int[] nia(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = ni();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic String rs() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n \n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n \n\t}\n\t\n\n\t\n\t\n\t\n    static long mod=1000000007;\n    static BigInteger bigInteger = new BigInteger(\"1000000007\");\n    static int n = (int)1e6;\n    static boolean[] prime;\n    static ArrayList<Integer> as;\n    static HashSet<Integer> hs;\n    static void sieve() {\n\t\t\tArrays.fill(prime\t, true);\n\t\t\tprime[0] = prime[1] = false;\n\t\t\tfor(int i = 2 ; i * i <= n ; ++i) {\n\t\t\t\tif(prime[i]) {\n\t\t\t\t\tfor(int k = i * i; k< n ; k+=i) {\n\t\t\t\t\t\tprime[k] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tstatic PrintWriter w = new PrintWriter(System.out);\n static char [][]sol;\n static int t2 = 0;\n         static int t3 = 0;\n    public static void main(String[] args)\n    {\n        \n        InputReader sc = new InputReader(System.in);\n        //PrintWriter w = new PrintWriter(System.out);\n    \n        \n        prime  = new boolean[n + 1];\n\t\tsieve();\n\t\tprime[1] = false;\n\t\t\n\t\t/*\n\t\tas = new ArrayList<>();\n\t\tfor(int i=2;i<=1000000;i++)\n\t\t{\n\t\t    if(prime[i])\n\t\t    as.add(i);\n\t\t}\n\t\t*/\n\t\t\n       /* \n\t\t\n\tlong a = sc.nl();\n\t \n            BigInteger ans = new BigInteger(\"1\");\n            for (long i = 1; i < Math.sqrt(a); i++) {\n                if (a % i == 0) {\n                    if (a / i == i) {\n                        ans = ans.multiply(BigInteger.valueOf(phi(i)));\n                        \n                    } else {\n                        ans = ans.multiply(BigInteger.valueOf(phi(i)));\n                        ans = ans.multiply(BigInteger.valueOf(phi(a / i)));\n \n                        \n                    }\n \n \n                }\n            }\n            w.println(ans.mod(bigInteger));\n            */\n          \n         // MergeSort ob = new MergeSort();\n       // ob.sort(arr, 0, arr.length-1);\n       \n    // Student []st = new Student[x];    \n   // st[i] = new Student(i,d[i]);\n     //Arrays.sort(st,(p,q)->p.diff-q.diff);\n     int x = sc.ni();\n     int []a = new int[x];\n     int []b = new int[x];\n     for(int i=0;i<x;i++)\n     {\n         a[i] = sc.ni();\n         b[i] = sc.ni();\n     }\n     hs = new HashSet<>();\n     primeFactors(a[0]);\n     primeFactors(b[0]);\n     int f = 0;\n     int res = -1;\n    Iterator itr = hs.iterator();\n    while(itr.hasNext())\n    {\n        Integer i = (Integer) itr.next();\n        f = 0;\n       for(int j=0;j<x;j++)\n       {\n           if(a[j]%i!=0 && b[j]%i!=0)\n           {\n               f = 1;\n               break;\n           }\n       }\n       if(f==0)\n       {\n           res = i;\n           break;\n       }\n    }\n     w.println(res);\n            \n      \n     \n    \n   w.close();\n        \n  \n    \n    }\n static int digit(long x)\n {\n     int p = 0;\n     while(x > 0)\n     {\n         x /= 10;\n         p++;\n     }\n     return p;\n }\n \n    public static String f(String a,int b){\n        if(b==0)\n           return \"\";\n       else if(b==1)\n            return a;\n        else{\n            if(b%2==0)\n               return f(a,b/2)+f(a,b/2);\n            else\n                return a+f(a,b/2)+f(a,b/2);\n        }\n            \n    }\n     \n   \n     static class Student\n    {\n        \n        int first;\n        int sec;\n        Student(int first,int sec)\n        {\n            this.first = first;\n            this.sec = sec;\n            \n            \n        }\n        \n    }\n     \n     public static long modMultiply(long one, long two) {\n \n\t\treturn (one % mod * two % mod) % mod;\n\t}\n    static long fx(int m)\n    {\n        long re = 0;\n        for(int i=1;i<=m;i++)\n        {\n            re += (long) (i / gcd(i,m));\n        }\n        return re;\n    }\n     static long gcd(long a, long b)\n    {\n\t if (a == 0)\n\t  return b;\n\t\t\t\t         \n\treturn gcd(b%a, a);\n    }\n    \n   \n    \n     static long phi(long nx)\n    {\n        // Initialize result as n\n        double result = nx; \n        \n     \n        // Consider all prime factors of n and for \n        // every prime factor p, multiply result\n        // with (1 - 1/p)\n        for (int p = 0; as.get(p) * as.get(p) <= nx; ++p)\n        {\n            // Check if p is a prime factor.\n            if (nx % as.get(p) == 0)\n            {\n                // If yes, then update n and result\n                while (nx % as.get(p) == 0)\n                    nx /= as.get(p);\n                result *= (1.0 - (1.0 / (double) as.get(p)));\n            }\n        }\n     \n        // If n has a prime factor greater than sqrt(n)\n        // (There can be at-most one such prime factor)\n        if (nx > 1)\n            result *= (1.0 - (1.0 / (double) nx));\n     \n        return (long)result;\n    \n        \n        //return(phi((long)result,k-1));\n        \n    }\n    \n    public static void primeFactors(int n)\n    {\n        //hs = new HashSet<>();\n       \n        // Print the number of 2s that divide n\n        while (n%2==0)\n        {\n            \n        \n            hs.add(2);\n            //System.out.print(2 + \" \");\n            n /= 2;\n            \n        }\n \n        // n must be odd at this point.  So we can\n        // skip one element (Note i = i +2)\n        for (int i = 3; i <= Math.sqrt(n); i+= 2)\n        {\n            // While i divides n, print i and divide n\n            while (n%i == 0)\n            {\n            \n               // System.out.print(i + \" \");\n                \n                hs.add(i);\n                n /= i;\n             \n                \n            }\n            \n        }\n \n        // This condition is to handle the case whien\n        // n is a prime number greater than 2\n        if (n >= 2)\n        {\n          \n            hs.add(n);\n        }\n           \n    }\n    static int digitsum(int x)\n    \n    {    \n \n        int sum = 0;\n        while(x > 0)\n        {\n            int temp = x % 10;\n            sum += temp;\n            x /= 10;\n        }\n        return sum;\n        \n    }\n    static int countDivisors(int n)\n    {\n        int cnt = 0;\n        for (int i = 1; i*i <=n; i++)\n        {\n             if (n % i == 0 && i<=1000000)\n             {\n                // If divisors are equal,\n                // count only one\n                if (n / i == i)\n                   cnt++;\n      \n                else // Otherwise count both\n                    cnt = cnt + 2;\n             }\n         }\n        return cnt;\n    }\n   \n    static boolean isprime(long n)\n    {\n    \n    if(n == 2)\n        return true;\n    if(n == 3)\n        return true;\n    if(n % 2 == 0)\n        return false;\n    if(n % 3 == 0)\n        return false;\n \n    long i = 5;\n   long w = 2;\n \n    while(i * i <= n)\n    {\n        if(n % i == 0)\n            return false;\n    \n \n        i += w;\n        w = 6 - w;\n    }\n \n    return true;\n    }\n    \n    static long log2(long value) {\n    return Long.SIZE-Long.numberOfLeadingZeros(value);\n}\n \n \n \n \n    \n    \n    static boolean binarysearch(int []arr,int p,int n)\n    {\n        //ArrayList<Integer> as = new ArrayList<>();\n        //as.addAll(0,at);\n        //Collections.sort(as);\n        boolean re = false;\n        int st = 0;\n        int end = n-1;\n        \n        \n        \n        while(st <= end)\n        { \n            int mid = st + (end-st)/2;\n        \n            if(p > arr[mid])\n            {\n                st = mid+1;\n                \n            }\n            else if(p < arr[mid])\n            {\n                end = mid-1;\n                \n            }\n            else if(p == arr[mid])\n            {\n            \n            re = true;\n            break;\n            }\n           \n            \n            \n        }\n         return re;\n        \n    }\n    \n   \n    \n    /* Java program for Merge Sort */\nstatic class MergeSort\n{\n    // Merges two subarrays of arr[].\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    void merge(int arr[], int l, int m, int r)\n    {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n \n        /* Create temp arrays */\n        int L[] = new int [n1];\n        int R[] = new int [n2];\n \n        /*Copy data to temp arrays*/\n        for (int i=0; i<n1; ++i)\n            L[i] = arr[l + i];\n        for (int j=0; j<n2; ++j)\n            R[j] = arr[m + 1+ j];\n \n \n        /* Merge the temp arrays */\n \n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n \n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2)\n        {\n            if (L[i] <= R[j])\n            {\n                arr[k] = L[i];\n                i++;\n            }\n            else\n            {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n \n        /* Copy remaining elements of L[] if any */\n        while (i < n1)\n        {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n \n        /* Copy remaining elements of R[] if any */\n        while (j < n2)\n        {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n \n    // Main function that sorts arr[l..r] using\n    // merge()\n    void sort(int arr[], int l, int r)\n    {\n        if (l < r)\n        {\n            // Find the middle point\n            int m = (l+r)/2;\n \n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr , m+1, r);\n \n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n \n    /* A utility function to print array of size n */\n    \n \n   \n}\n    \n\n    \n    \n    \n    public static int ip(String s){\n\t\treturn Integer.parseInt(s);\n\t}\n\t public static String ips(int s){\n\t\treturn Integer.toString(s);\n\t}\n\t\n    \n\t\t\t\t\t \n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n/*\n*/\n\npublic class Main {\n    public static long gcd(long a, long b) {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n    public static void main(String[] args) throws IOException{\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        StringTokenizer st=new StringTokenizer(br.readLine());\n        int n=Integer.parseInt(st.nextToken());\n        long[] arr=new long[n];\n        long[] arr1=new long[n];\n        long gcd=0;\n        for(int i=0;i<n;i++){\n            st=new StringTokenizer(br.readLine());\n            arr[i]=Long.parseLong(st.nextToken());\n            arr1[i]=Long.parseLong(st.nextToken());\n            gcd=gcd(gcd,arr[i]*arr1[i]);\n        }\n        if(gcd==1){\n            pw.println(\"-1\");\n        }else {\n            for(int i=0;i<n;i++){\n               long temp= gcd(gcd,arr[i]);\n               if(temp!=1){\n                   gcd=temp;\n               }\n               temp=gcd(gcd,arr1[i]);\n                if(temp!=1){\n                    gcd=temp;\n                }\n            }\n            pw.println(gcd);\n        }\n        pw.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n \n\npublic class Solve{\n       public static void main(String[] args) throws Exception{\n               Fast sc=new Fast();\n       StringBuilder sb=new StringBuilder();\n       \n            int n=sc.nextInt();\n           \n            int[] ar=new int[n];\n            int[] br=new int[n];\n            for(int i=0;i<n;i++){\n               ar[i]=sc.nextInt();\n               br[i]=sc.nextInt();\n                \n            }\n            if(n==1){\n                System.out.println(ar[0]);\n            }\n            else{\n            int gcd1=gcd(ar[0],ar[1]);\n            int gcd2=gcd(ar[0],br[1]);\n            \n         \n          for(int i=2;i<n;i++){\n           int g1=0;\n           int g2=0;\n                if(gcd(gcd1,ar[i])>1){\n                    g1=gcd(gcd1,ar[i]);\n                }\n                 if(gcd(gcd1,br[i])>1){\n                    g2=gcd(gcd1,br[i]);\n                }\n                int max=Math.max(g1,g2);\n                gcd1=max;\n                if(gcd1>1){\n                    gcd1=gcd1;\n                }\n                else{\n                     gcd1=1;\n                }\n            } \n            for(int i=2;i<n;i++){\n                int g1=0;\n           int g2=0;\n                if(gcd(gcd2,ar[i])>1){\n                    g1=gcd(gcd2,ar[i]);\n                }\n                 if(gcd(gcd2,br[i])>1){\n                    g2=gcd(gcd2,br[i]);\n                }\n                int max=Math.max(g1,g2);\n                gcd2=max;\n                if(gcd2>1){\n                    gcd2=gcd2;\n                }\n                else{\n                     gcd2=1;\n                }\n            }\n            \n            \n             int gcd3=gcd(br[0],ar[1]);\n            int gcd4=gcd(br[0],br[1]);\n            \n         \n          for(int i=2;i<n;i++){\n                 int g1=0;\n           int g2=0;\n                if(gcd(gcd3,ar[i])>1){\n                    g1=gcd(gcd3,ar[i]);\n                }\n                 if(gcd(gcd3,br[i])>1){\n                    g2=gcd(gcd3,br[i]);\n                }\n                int max=Math.max(g1,g2);\n                gcd3=max;\n                if(gcd3>1){\n                    gcd3=gcd3;\n                }\n                else{\n                     gcd3=1;\n                }\n            } \n            for(int i=2;i<n;i++){\n                 int g1=0;\n           int g2=0;\n                if(gcd(gcd4,ar[i])>1){\n                    g1=gcd(gcd4,ar[i]);\n                }\n                 if(gcd(gcd4,br[i])>1){\n                    g2=gcd(gcd4,br[i]);\n                }\n                int max=Math.max(g1,g2);\n                gcd4=max;\n                if(gcd4>1){\n                    gcd4=gcd4;\n                }\n                else{\n                     gcd4=1;\n                }\n            }\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            if(gcd1>1){\n                System.out.println(gcd1);\n            }\n            else if(gcd2>1){\n                System.out.println(gcd2);\n            }\n            else if(gcd3>1){\n                System.out.println(gcd3);\n            }\n            else if(gcd4>1){\n                System.out.println(gcd4);\n            }\n           else  {\n                 gcd1=gcd(ar[n-1],ar[n-2]);\n             gcd2=gcd(ar[n-1],br[n-2]);\n            \n         \n          for(int i=n-3;i>=0;i--){\n                if(gcd(gcd1,ar[i])>1){\n                    gcd1=gcd(gcd1,ar[i]);\n                }\n                else if(gcd(gcd1,br[i])>1){\n                    gcd1=gcd(gcd1,br[i]);\n                }\n                else{\n                     gcd1=1;\n                }\n            } \n            for(int i=n-3;i>=0;i--){\n                if(gcd(gcd2,ar[i])>1){\n                    gcd2=gcd(gcd2,ar[i]);\n                }\n                else if(gcd(gcd2,br[i])>1){\n                    gcd2=gcd(gcd2,br[i]);\n                }\n                else{\n                     gcd2=1;\n                }\n            }\n            \n            \n              gcd3=gcd(br[n-1],ar[n-2]);\n             gcd4=gcd(br[n-1],br[n-2]);\n            \n         \n          for(int i=n-3;i>=0;i--){\n                if(gcd(gcd3,ar[i])>1){\n                    gcd3=gcd(gcd3,ar[i]);\n                }\n                else if(gcd(gcd3,br[i])>1){\n                    gcd3=gcd(gcd3,br[i]);\n                }\n                else{\n                     gcd3=1;\n                }\n            } \n            for(int i=n-3;i>=0;i--){\n                if(gcd(gcd4,ar[i])>1){\n                    gcd4=gcd(gcd4,ar[i]);\n                }\n                else if(gcd(gcd4,br[i])>1){\n                    gcd4=gcd(gcd4,br[i]);\n                }\n                else{\n                     gcd4=1;\n                }\n            }\n            \n            if(gcd1>1){\n                System.out.println(gcd1);\n            }\n            else if(gcd2>1){\n                System.out.println(gcd2);\n            }\n            else if(gcd3>1){\n                System.out.println(gcd3);\n            }\n            else if(gcd4>1){\n                System.out.println(gcd4);\n            }\n           else  {\n                System.out.println(\"-1\");\n            }\n         \n            }\n         \n            }\n    }\n\n\nstatic void ReverSort(int[] ar){\n    ArrayList<Integer> al=new ArrayList<>();\n    for(int i=0;i<ar.length;i++){\n        al.add(ar[i]);\n    }\n\n    Collections.sort(al);\n      int j=0;\n    for(int i=al.size()-1;i>=0;i--){\n\n        ar[j]=al.get(i);\n        j++;\n    }\n}\nstatic void Sort(int[] ar){\n    ArrayList<Integer> al=new ArrayList<>();\n    for(int i=0;i<ar.length;i++){\n        al.add(ar[i]);\n    }\n\n    Collections.sort(al);\n      int j=0;\n    for(int i=0;i<al.size();i++){\n\n        ar[j]=al.get(i);\n        j++;\n     }\n  }\n\n \nstatic int gcd(int a,int b){\n    if(b==0) return a;\n    else return  gcd(b,a%b);\n}\n}\n\n\n\nclass Fast{\n  BufferedReader br; \n  StringTokenizer st;\n  public Fast(){ br=new BufferedReader(new InputStreamReader(System.in)); }\n  String next() \n        {  while (st == null || !st.hasMoreElements()) \n            {   try\n                {     st = new StringTokenizer(br.readLine()); } \n                catch (IOException  e) \n                {    e.printStackTrace(); } \n            } \n            return st.nextToken(); \n        }\n  int nextInt(){  return Integer.parseInt(next()); }\n  long nextLong(){     return Long.parseLong(next()); } \n  double nextDouble() {     return Double.parseDouble(next()); } \n  String nextLine() \n        { \n            String str = \"\"; \n            try{      str = br.readLine(); } \n            catch (IOException e)  {  e.printStackTrace(); } \n            return str; \n        } \n}\n    \n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Solution{\n    public static void main(String[] args) throws Exception{\n        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(buffer.readLine());\n        \n        String[] i1 = buffer.readLine().split(\" \");\n            \n        long a = Long.parseLong(i1[0]);\n        long b = Long.parseLong(i1[1]);\n        \n        List<Long> inputs = new ArrayList<Long>();\n        List<Integer> divisors = new ArrayList<Integer>();\n        \n        for(int i=2; i*i<=a; i++){\n            if(a%i==0){\n                divisors.add(i);\n                while(a%i == 0)\n                    a /= i;\n            }\n        }\n        if(a> 1)\n            divisors.add((int)a);\n        \n        for(int j=2; j*j<=b; j++){\n            if(b%j==0){\n                divisors.add(j);\n                while(b%j == 0)\n                     b /= j;\n            }\n        }\n        if(b> 1)\n            divisors.add((int)b);\n            \n      //  System.out.print(divisors);\n        --t;\n        if(t == 0){\n            System.out.println(divisors.get(0));\n        }\n        while(t-- > 0){\n            String[] i2 = buffer.readLine().split(\" \");\n            long m = Long.parseLong(i2[0]);\n            long n = Long.parseLong(i2[1]);\n            inputs.add(m);\n            inputs.add(n);\n        }\n        \n        int res = -1;\n        boolean check = true;\n        \n        for(int p=0; p<divisors.size(); p++){\n            for(int q = 0; q<inputs.size()-1; q+=2){\n            if(inputs.get(q)%divisors.get(p) == 0 || inputs.get(q+1)%divisors.get(p) == 0)\n            {\n                res = divisors.get(p);        \n            }\n            else{\n                res = -1;\n                break;\n            }\n            }\n            if(res != -1){\n                System.out.println(res);\n                check = false;\n                break;\n            }\n        }\n        if(check && inputs.size() != 0)\n            System.out.println(\"-1\");\n        \n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"O3\")\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n  cerr << name << \" = \" << arg1 << '\\n';\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \" = \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\nint n;\nvector<pair<long long, long long> > a;\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(NULL);\n  std::cout.tie(NULL);\n  cin >> n;\n  long long x1, y1;\n  long long sm = 2e18;\n  for (long long i = 0; i < n; i++) {\n    long long x, y;\n    cin >> x >> y;\n    if (x + y < sm) {\n      sm = x + y;\n      x1 = x;\n      y1 = y;\n    }\n    a.push_back({x, y});\n  }\n  vector<long long> xfac, yfac;\n  if (x1 % 2 == 0) {\n    xfac.push_back(2);\n    while (x1 % 2 == 0) {\n      x1 /= 2;\n    }\n  }\n  for (int i = 3; i * i <= x1; i += 2) {\n    if (x1 % i == 0) {\n      xfac.push_back(i);\n      while (x1 % i == 0) {\n        x1 /= i;\n      }\n    }\n  }\n  if (x1 > 2) xfac.push_back(x1);\n  if (y1 % 2 == 0) {\n    yfac.push_back(2);\n    while (y1 % 2 == 0) {\n      y1 /= 2;\n    }\n  }\n  for (int i = 3; i * i <= y1; i += 2) {\n    if (y1 % i == 0) {\n      yfac.push_back(i);\n      while (y1 % i == 0) {\n        y1 /= i;\n      }\n    }\n  }\n  if (y1 > 2) yfac.push_back(y1);\n  for (auto i : xfac) {\n    bool pos = 1;\n    for (auto j : a) {\n      if ((j.first % i) && (j.second % i)) {\n        pos = 0;\n      }\n      if (!pos) break;\n    }\n    if (pos) {\n      cout << i;\n      return 0;\n    }\n  }\n  for (auto i : yfac) {\n    bool pos = 1;\n    for (auto j : a) {\n      if ((j.first % i) && (j.second % i)) {\n        pos = 0;\n      }\n      if (!pos) break;\n    }\n    if (pos) {\n      cout << i;\n      return 0;\n    }\n  }\n  cout << -1;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nfrom math import gcd\ninput=stdin.readline\nn=int(input())\nab=[list(map(int,input().split())) for i in range(n)]\nz=ab[0][0]*ab[0][1]\nfor a,b in ab:\n  z=gcd(z,a*b)\nfor a,b in ab:\n  if gcd(z,a)>1:\n    z=gcd(z,a)\n  else:\n    z=gcd(z,b)\nprint(z if z!=1 else -1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ninline long long rint() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nlong long gcd(long long a, long long b) { return (b) ? gcd(b, a % b) : a; }\nlong long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\nlong long pow(long long a, long long b, long long q) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = ans * a % q;\n    a = a * a % q;\n    b >>= 1;\n  }\n  return ans;\n}\nconst long long mod = 998244353;\nconst long long N = 2e6 + 5;\nint main() {\n  int n = rint();\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) a[i] = rint(), b[i] = rint();\n  vector<int> fac;\n  for (int i = 2; i * i <= a[0]; i++) {\n    if (a[0] % i == 0) {\n      fac.push_back(i);\n      while (a[0] % i == 0) a[0] /= i;\n    }\n  }\n  if (a[0] != 1) fac.push_back(a[0]);\n  for (int i = 2; i * i <= b[0]; i++) {\n    if (b[0] % i == 0) {\n      fac.push_back(i);\n      while (b[0] % i == 0) b[0] /= i;\n    }\n  }\n  if (b[0] != 1) fac.push_back(b[0]);\n  sort((fac).begin(), (fac).end());\n  fac.erase(unique((fac).begin(), (fac).end()), fac.end());\n  for (int i = 1; i < n; i++) {\n    int jb = 0;\n    while (jb != fac.size()) {\n      if (a[i] % fac[jb] == 0 || b[i] % fac[jb] == 0)\n        jb++;\n      else\n        fac.erase(fac.begin() + jb);\n    }\n  }\n  if (fac.size() == 0)\n    cout << -1 << \"\\n\";\n  else\n    cout << fac[0] << \"\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class hacker49 {\n\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\tpublic static void main(String[] args) {\n\t\tOutputStream outputStream =System.out;\n\t    PrintWriter out =new PrintWriter(outputStream);\n\t\tFastReader s=new FastReader();\n\t\tint n=s.nextInt();\n\t\tsieve();\n\t\tlong[] a=new long[n+1];\n\t\tlong[] b=new long[n+1];\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\ta[i]=s.nextLong();\n\t\t\tb[i]=s.nextLong();\n\t\t}\n\t\tArrayList<Long> e1=new ArrayList<>();\n\t\tArrayList<Long> e2=new ArrayList<>();\n\t\t\n\t\tlong d1=a[1];\n\t\tlong d2=b[1];\n\t\tfor(int i=0;i<primes.size();i++) {\n\t\t\tlong h=primes.get(i);\n\t\t\tif(d1%h==0) {\n\t\t\t\te1.add(h);\n\t\t\t\twhile(d1%h==0) {\n\t\t\t\t\td1/=h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d1>1) {\n\t\t\te1.add(d1);\n\t\t}\n\t\tfor(int i=0;i<primes.size();i++) {\n\t\t\tlong h=primes.get(i);\n\t\t\tif(d2%h==0) {\n\t\t\t\te2.add(h);\n\t\t\t\twhile(d2%h==0) {\n\t\t\t\t\td2/=h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d2>1) {\n\t\t\te2.add(d2);\n\t\t}\n\t\tlong ans=-1;\n//\t\tboolean p=false;\n\t\tout:for(int j=0;j<e1.size();j++) {\n\t\tint c=0;\n\t\tlong d=e1.get(j);\n\t\t\tfor(int i=1;i<=n;i++) {\n\t\t\tif((a[i]%d==0) || (b[i]%d==0)){\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\t\tif(c==n) {\n//\t\t\t\tp=true;\n\t\t\t\tans=d;\n\t\t\tbreak out;\t\n\t\t\t}\n\t\t\t}\n\t\tif(ans!=-1) {\n\t\t\tout.println(ans);\n\t\t}else {\n\t\t\tout1:for(int j=0;j<e2.size();j++) {\n\t\t\t\tint c=0;\n\t\t\t\tlong d=e2.get(j);\n\t\t\t\t\tfor(int i=1;i<=n;i++) {\n\t\t\t\t\tif((a[i]%d==0) || (b[i]%d==0)){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\tif(c==n) {\n//\t\t\t\t\t\tp=true;\n\t\t\t\t\t\tans=d;\n\t\t\t\t\tbreak out1;\t\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\n\t\tout.println(ans);\n\t\t}\nout.close();\n\t}\n\tstatic void sf(long[] arr){\n        int n = arr.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i){\n            long tmp = arr[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            arr[i] = arr[randomPos];\n            arr[randomPos] = tmp;\n        }   \n}\nstatic HashMap<Integer,pair> e=new HashMap<>();\nstatic ArrayList<Integer>[] f1=new ArrayList[200001];\t\nstatic PriorityQueue<pair> q=new PriorityQueue<>();\t\nstatic ArrayList<pair>[] f=new ArrayList[200001];\n\tstatic class pair implements Comparable<pair>{\n\t\tprivate int a;\n\t\tprivate int b;\n\t\tpair(int a,int b){\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\tpublic int compareTo(pair o) {\n\t\t\treturn Integer.compare(o.b, this.b);\n\t\t}\n//\t\t@Override\n//\t\tpublic int compare(pair arg0, pair arg1) {\n//\t\t\t// TODO Auto-generated method stub\n//\t\t\treturn 0;\n//\t\t}\n\t}\n\tstatic int[] col=new int[200001];\n\tstatic int[] subtree=new int[200001];\n\tstatic int[] vis=new int[200001];\n\tstatic int dfs(int node) {\n\t\tvis[node]=1;\n\t\tint c=0;\n\t\tfor(int i=0;i<f[node].size();i++) {\n\t\t\tif(vis[f[node].get(i).a]==0) {\n\t\t\t\tc+=dfs(f[node].get(i).a);\n\t\t\t}\n\t\t}\n\t\tsubtree[node]+=c;\n\t\tsubtree[node]+=col[node];\n\t\treturn subtree[node];\n\t}\n\tpublic static int upper_bound(long[] a ,long x,int n) {\n\t\tint l=-1;\n\t\tint r=n;\n\t\twhile(r>l+1) {\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(a[mid]<x) {\n\t\t\t\tl=mid;\n\t\t\t}else {\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t\t\t\t\n\t}\n\tpublic static int lower_bound(long[] a ,long x,int n) {\n\t\tint l=-1;\n\t\tint r=n;\n\t\twhile(r>l+1) {\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(a[mid]<=x) {\n\t\t\t\tl=mid;\n\t\t\t}else {\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t\t\t\t\n\t}\n\t\n\t\n\tpublic static long[] merge_sort(long[] A, int start, int end) {\n\t\tif (end > start) {\n\t\t\tint mid = (end + start) / 2;\n\t\t\tlong[] v = merge_sort(A, start, mid);\n\t\t\tlong[] o = merge_sort(A, mid + 1, end);\n\t\t\treturn (merge(v, o));\n\t\t} else {\n\t\t\tlong[] y = new long[1];\n\t\t\ty[0] = A[start];\n\t\t\treturn y;\n\t\t}\n\t}\n\tpublic static long[] merge(long a[], long b[]) {\n//\t\tint count=0;\n\t\tlong[] temp = new long[a.length + b.length];\n\t\tint m = a.length;\n\t\tint n = b.length;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint c = 0;\n\t\twhile (i < m && j < n) {\n\t\t\tif (a[i] < b[j]) {\n\t\t\t\ttemp[c++] = a[i++];\n\t\t\t\n\t\t\t} else {\n\t\t\t\ttemp[c++] = b[j++];\n\t\t\t}\n\t\t}\n\t\twhile (i < m) {\n\t\t\ttemp[c++] = a[i++];\n\t\t}\n\t\twhile (j < n) {\n\t\t\ttemp[c++] = b[j++];\n\t\t}\n\t\treturn temp;\n\t}\t\n\tpublic static int[] Create(int[] a,int n) {\n\t\tint[] b=new int[n+1];\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint j=i;\n\t\t\tint h=a[i];\n\t\t\twhile(i<=n) {\n\t\t\t\tb[i]+=h;\n\t\t\t\ti=get_next(i);\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\treturn b;\n\t}\npublic static int get_next(int a) {\n\treturn a+(a&-a);\n}\npublic static int get_parent(int a) {\n\treturn a-(a&-a);\n}\npublic static int query_1(int[] b,int index) {\n\tint sum=0;\n\tif(index<=0) {\n\t\treturn 0;\n\t}\n\twhile(index>0) {\n\t\tsum+=b[index];\n\t\tindex=get_parent(index);\n\t}\n\treturn sum;\n}\npublic static int query(int[] b,int n,int l,int r) {\n\tint sum=0;\n\tsum+=query_1(b,r);\n\tsum-=query_1(b,l-1);\n\treturn sum;\n}\npublic static void update(int[] a,int[] b,int n,int index,int val) {\n\tint diff=val-a[index];\n\ta[index]+=diff;\n\twhile(index<=n) {\n\t\tb[index]+=diff;\n\t\tindex=get_next(index);\n\t}\t\n}\n\t\n//\tpublic static void Create(int[] a,pair[] segtree,int low,int high,int pos) {\n//\t\tif(low>high) {\n//\t\t\treturn;\n//\t\t}\n//\t\tif(low==high) {\n//\t\t\tsegtree[pos].b.add(a[low]);\n//\t\t\treturn ;\n//\t\t}\n//\t\tint mid=(low+high)/2;\n//\t\tCreate(a,segtree,low,mid,2*pos);\n//\t\tCreate(a,segtree,mid+1,high,2*pos+1);\n//\t\tsegtree[pos].b.addAll(segtree[2*pos].b);\n//\t\tsegtree[pos].b.addAll(segtree[2*pos+1].b);\n//\t}\n//\tpublic static void update(pair[] segtree,int low,int high,int index,int pos,int val,int prev) {\n//\t\tif(index>high || index<low) {\n//\t\t\treturn ;\n//\t\t}\n//\t\tif(low==high && low==index) {\n//\t\t\tsegtree[pos].b.remove(prev);\n//\t\t\tsegtree[pos].b.add(val);\n//\t\t\treturn;\n//\t\t}\n//\t\t\tint mid=(high+low)/2;\n//\t\t\t update(segtree,low,mid,index,2*pos,val,prev);\n//\t\t\t update(segtree,mid+1,high,index,2*pos+1,val,prev);\n//\t\t\t segtree[pos].b.clear();\n//\t\t\t  segtree[pos].b.addAll(segtree[2*pos].b);\n//\t\t\t  segtree[pos].b.addAll(segtree[2*pos+1].b);\n//\t\t\t  \n//\t}\n//\tpublic static pair query(pair[] segtree,int low,int high,int qlow,int qhigh ,int pos) {\n//\t\tif(low>=qlow && high<=qhigh) {\n//\t\t\treturn segtree[pos];\n//\t\t}\n//\t\tif(qhigh<low || qlow>high) {\n//\t\t\treturn new pair();\n//\t\t}\n//\t\tint mid=(low+high)/2;\n//\t  pair a1=query(segtree,low,mid,qlow,qhigh,2*pos);\n//\t  pair a2=query(segtree,mid+1,high,qlow,qhigh,2*pos+1);\n//\t  pair a3=new pair();\n//\t  a3.b.addAll(a1.b);\n//\t  a3.b.addAll(a2.b);\n//\t  return a3;\n//\t  \n//\t}\n//\t\n//\tpublic static int nextPowerOf2(int n) \n//\t{ \n//\t    n--; \n//\t    n |= n >> 1; \n//\t    n |= n >> 2; \n//\t    n |= n >> 4; \n//\t    n |= n >> 8; \n//\t    n |= n >> 16; \n//\t    n++;     \n//\t    return n; \n//\t} \n//\t\n////\tstatic class pair implements Comparable<pair>{\n////\t\tprivate int a;\n////\t\tprivate long b;\n//////\t\tprivate long c;\n////\t\tpair(int a,long b){\n////\t\t\tthis.a=a;\n////\t\t\tthis.b=b;\n//////\t\t\tthis.c=c;\n////\t\t}\n////\t\tpublic int compareTo(pair o) {\n//////\t\tif(this.a!=o.a) {\n//////\t\t\treturn Long.compare(this.a, o.a);\n//////\t\t}else {\n////\t\t\treturn Long.compare(o.b,this.b);\n//////\t\t}\n////\t\t}\n////\t}\n//\tstatic class pair implements Comparable<pair>{\n//\t\tprivate int a;\n//\t\tprivate int b;\n//\t\tpair(int a,int b){\n////\t\t\tthis.b=new HashSet<>();\n//\t\t\tthis.a=a;\n//\t\t\tthis.b=b;\n//\t\t}\n//\t\tpublic int compareTo(pair o) {\n//\t\t\treturn Integer.compare(this.b, o.b);\n//\t\t}\n//\t}\n\tpublic static int lower_bound(ArrayList<Long> a ,int n,long x) {\n\t\tint l=0;\n\t\tint r=n;\n\t\twhile(r>l+1) {\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(a.get(mid)<=x) {\n\t\t\t\tl=mid;\n\t\t\t}else {\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t\treturn l;\t\t\n\t}\n\n\tpublic static int[] is_prime=new int[1000001];\n\tpublic static ArrayList<Long> primes=new ArrayList<>();\n \tpublic static void sieve() {\n\t\tlong maxN=1000000;\n\t\tfor(long i=1;i<=maxN;i++) {\n\t\t\tis_prime[(int) i]=1;\n\t\t}\n\t\tis_prime[0]=0;\n\t\tis_prime[1]=0;\n\t\tfor(long i=2;i*i<=maxN;i++) {\n\t\t\tif(is_prime[(int) i]==1) {\n//\t\t\t\tprimes.add((int) i);\n\t\t\t\tfor(long j=i*i;j<=maxN;j+=i) {\n\t\t\t\t\tis_prime[(int) j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(long i=0;i<=maxN;i++) {\n\t\t\tif(is_prime[(int) i]==1) {\n\t\t\t\tprimes.add(i);\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n\t\n//\tpublic static pair[] merge_sort(pair[] A, int start, int end) {\n//\t\tif (end > start) {\n//\t\t\tint mid = (end + start) / 2;\n//\t\t\tpair[] v = merge_sort(A, start, mid);\n//\t\t\tpair[] o = merge_sort(A, mid + 1, end);\n//\t\t\treturn (merge(v, o));\n//\t\t} else {\n//\t\t\tpair[] y = new pair[1];\n//\t\t\ty[0] = A[start];\n//\t\t\treturn y;\n//\t\t}\n//\t}\n//\tpublic static pair[] merge(pair a[], pair b[]) {\n//\t\tpair[] temp = new pair[a.length + b.length];\n//\t\tint m = a.length;\n//\t\tint n = b.length;\n//\t\tint i = 0;\n//\t\tint j = 0;\n//\t\tint c = 0;\n//\t\twhile (i < m && j < n) {\n//\t\t\tif (a[i].b >= b[j].b) {\n//\t\t\t\ttemp[c++] = a[i++];\n//\t\t\t\n//\t\t\t} else {\n//\t\t\t\ttemp[c++] = b[j++];\n//\t\t\t}\n//\t\t}\n//\t\twhile (i < m) {\n//\t\t\ttemp[c++] = a[i++];\n//\t\t}\n//\t\twhile (j < n) {\n//\t\t\ttemp[c++] = b[j++];\n//\t\t}\n//\t\treturn temp;\n//\t}\n\t\n\t\n//\tpublic static long im(long a) {\n//\t\treturn binary_exponentiation_1(a,mod-2)%mod;\n//\t}\n\tpublic static double bn1(double a,double n) {\n\t\tdouble res=1;\n\t\twhile(n>0) {\n\t\t\tif(n%2!=0) {\n//\t\t\t\tres=((res)%(1000000007) * (a)%(1000000007))%(1000000007);\n\t\t\t\tres=(res*a);\n\t\t\t\tn--;\n\t\t\t}else {\n//\t\t\t\ta=((a)%(1000000007) *(a)%(1000000007))%(1000000007);\n\t\t\t\ta=(a*a);\n\t\t\t\tn/=2;\n\t\t\t}\n\t\t}\n\t\treturn (res);\n\t\t\n\t}\n\n\tpublic static long bn(long a,long n) {\n\t\tlong res=1;\n\t\twhile(n>0) {\n\t\t\tif(n%2!=0) {\n\t\t\t\tres=res*a;\n\t\t\t\tn--;\n\t\t\t}else {\n\t\t\t\ta*=a;\n\t\t\t\tn/=2;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t\t\n\t}\n\n\tpublic static long[] fac=new long[100001];\n\tpublic static void find_factorial() {\n\t\tfac[0]=1;\n\t\tfac[1]=1;\n\t\tfor(int i=2;i<=100000;i++) {\n\t\t\tfac[i]=(fac[i-1]*i)%(mod);\n\t\t}\n\t}\n\t\n\tstatic long mod=1000000007;\n\tpublic static long GCD(long a,long b) {\n\t\tif(b==(long)0) {\n\t\t\treturn a;\n\t\t}\n\t\treturn GCD(b , a%b);\n\t}\n\tstatic long c=0;\n\t\n\t\t\n\t\n}"
        },
        {
            "language": 3,
            "solution": "\"\"\"[summary]\nCodeforces Round  # 505 (rated, Div. 1 + Div. 2, based on VK Cup 2018 Final)\n\"\"\"\nfrom math import sqrt\n\npairs = []\nn = int(input())\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    pairs.append((a,b))\n\ndef PF(n, set):\n    for i in range(2, int(sqrt(n))+1, 1):\n        # while i divides n \n        if (n % i == 0):\n            set.add(i)\n        while n % i == 0:\n            n /= i\n    if n >= 2:\n        set.add(n)\n\nprime = set()\nPF(pairs[0][0], prime)\nPF(pairs[0][1], prime)\n\n# check if there is WCD\nfor a, b in pairs[1:]:\n    tmp = set()\n    for i in prime:\n        if a % i == 0 or b % i == 0:\n            tmp.add(i)\n    prime = prime.intersection(tmp)\n\nif len(prime) > 0:\n    print(int(prime.pop()))\nelse:\n    print(-1)\n"
        },
        {
            "language": 3,
            "solution": "def findPF(n, pf):\n\n    if n <= 1:\n        return\n\n    i = 2\n    while i*i<=n:\n        if n % i ==0:\n            pf.add(i)\n            while n>1 and n%i==0:\n                n = n // i\n        i += 1\n\n    if n>1:\n        pf.add(n)\n\nn = int(input())\na,b = map(int, input().split())\n\npf = set()\nfindPF(a, pf)\nfindPF(b, pf)\n\nfor i in range(n-1):\n    a,b = map(int, input().split())\n    for s in list(pf):\n        if a%s!=0 and b%s!=0:\n            pf.remove(s)\n\nif len(pf)>=1:\n    print(pf.pop())\nelse:\n    print(-1)\n"
        },
        {
            "language": 1,
            "solution": "n=input(); nums=[-1]*(n)\nfor i in xrange(n):\n  a,b=map(int,raw_input().split())\n  nums[i]=[(a,b),(b,a)][a>b]\n\nnumSet=list(set(nums))\na,b=numSet[0];ans=set((a,b))\n\nfor i in xrange(2,int(max(a,b)**0.5+1)):\n  if a%i==0 and a>i:\n    ans.add(i);ans.add(a/i)\n  if b%i==0 and b>i:\n    ans.add(i);ans.add(b/i)\n\nfor i in xrange(1,len(numSet)):\n  if ans and len(numSet)>1:\n    a,b=numSet[i]\n    for k in list(ans):\n      if a%k!=0 and b%k!=0:\n        ans.remove(k)\n  else:\n    break\n\nif ans:\n  print ans.pop()\nelse:\n  print -1\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Puneet    //FastRead class is taken from different online Sources\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastInput in = new FastInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\n\n        public void solve(int testNumber, FastInput in, PrintWriter out) {\n\n            int n = in.ni();\n\n            ArrayList<Pair> ar = new ArrayList<>();\n\n            for (int i = 0; i < n; i++) {\n                ar.add(new Pair(in.ni(), in.ni()));\n            }\n\n            ar.sort(Comparator.comparingInt(p -> p.f));\n\n            primefact(ar.get(0).f);\n            tadd(ar.get(0).f);\n            primefact(ar.get(0).s);\n            tadd(ar.get(0).s);\n\n            boolean isdivide = true;\n            int ans = -1;\n\n            //    out.print(treeMap);\n\n            for (int i : treeMap.keySet()) {\n\n                isdivide = true;\n\n                for (int j = 1; j < n; j++) {\n                    if (ar.get(j).f % i != 0 && ar.get(j).s % i != 0) {\n                        isdivide = false;\n                        break;\n                    }\n                }\n\n                if (isdivide) {\n                    ans = i;\n                    break;\n                }\n\n            }\n\n            out.println(ans);\n\n        }\n\n        private void primefact(int a) {\n\n\n            for (int i = 2; i <= Math.sqrt(a); i++) {\n\n                if (a % i == 0) {\n                    tadd(i);\n                    while (a % i == 0) {\n                        a /= i;\n                    }\n                }\n\n                if (a > 2)\n                    tadd(a);\n            }\n        }\n\n        public void tadd(int x) {\n            if (treeMap.containsKey(x))\n                treeMap.put(x, treeMap.get(x) + 1);\n            else\n                treeMap.put(x, 1);\n        }\n\n        class Pair {\n            int f;\n            int s;\n\n            public Pair(int f, int s) {\n                this.f = f;\n                this.s = s;\n            }\n\n        }\n\n    }\n\n    static class FastInput {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastInput.SpaceCharFilter filter;\n\n        public FastInput(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int ni() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "from sys  import stdin,stdout\n\nimport bisect\n\nimport math\n\nfrom collections import deque\n\nmod=10**9 +7 \n\ndef st():\n    return list(stdin.readline().strip())\n\ndef inp():\n    return int(stdin.readline())\n\ndef li():\n    return list(map(int,stdin.readline().split()))\n\ndef mp():\n    return map(int,stdin.readline().split())\n\ndef pr(n):\n    stdout.write(str(n)+\"\\n\")\n    \ndef DFS(dictionary,vertex,visited):\n    visited[vertex]=True\n    stack=[vertex]\n    print(vertex)\n    while stack:\n        a=stack.pop()\n        for i in dictionary[a]:\n            if not visited[i]:\n                print(i)\n                visited[i]=True\n                stack.append(i)\n\n'''\ndef BFS(dictionary, vertex,visited):\n    visited[vertex]=True\n    q=deque()\n    q.append(vertex)\n    while q:\n        a=q.popleft()\n        for i in dictionary[a]:\n            if not visited[i]:\n                visited[i]=True\n                q.append(i)\n                print(i)\n'''\n\ndef BFS(d,visited,i,value,dis):\n    value[i]=dis\n    visited[i]=True\n    q=deque()\n    q.append(i)\n    while q:\n        a=q.popleft()\n        for i in d[a]:\n            if not visited[i]:\n                visited[i]=True\n                value[i]=value[a]+1\n                q.append(i)\n                \n\n\ndef soe(limit):\n    l=[1]*(limit+1)\n    l[0]=0\n    l[1]=0\n    prime=[]\n    for i in range(2,limit+1):\n        if l[i]:\n            for j in range(i*i,limit+1,i):\n                l[j]=0\n    \n    for i in range(2,limit+1):\n        if l[i]:\n            prime.append(i)\n    return prime\n\ndef segsoe(low,high):\n    limit=int(high**0.5)+1\n    prime=soe(limit)\n    n=high-low+1\n    l=[0]*(n+1)\n    for i in range(len(prime)):\n        lowlimit=(low//prime[i])*prime[i]\n        if lowlimit<low:\n            lowlimit+=prime[i]\n        if lowlimit==prime[i]:\n            lowlimit+=prime[i]\n        for j in range(lowlimit,high+1,prime[i]):\n            l[j-low]=1\n    for i in range(low,high+1):\n        if not l[i-low]:\n            if i!=1:\n                print(i)\n                \ndef gcd(a,b):\n    while b:\n        a=a%b\n        b,a=a,b\n    return a\n\ndef power(a,n):\n    r=1\n    while n:\n        if n&1:\n            r=(r*a)\n        a*=a\n        n=n>>1\n    return r\n\ndef prime(n,l):\n    i=2\n    while i*i<=n:\n        if n%i==0:\n            l.append(i)\n            while n%i==0:\n                n//=i\n        i+=1\n    if n>1:\n        l.append(n)\n            \n    \n        \ndef solve():\n    n=inp()\n    l=[]\n    x=[]\n    for  _ in range(n):\n        a,b=mp()\n        if _==0:\n            prime(a,l)\n            prime(b,l)\n        x.append([a,b])\n    l=list(set(l))\n    \n    for i in l:\n        c=0\n        for j in range(1,len(x)):\n            a=x[j][0]\n            b=x[j][1]\n        \n            if a%i!=0 and b%i!=0:\n                c=1\n                break\n        if c==0:\n            pr(i)\n            return\n    pr(-1)\n            \n\n                \n                \n\nfor _ in range(1):\n    solve()\n    \n"
        },
        {
            "language": 1,
            "solution": "def gcd(a,b):\n    if b==0:return a\n    return gcd(b,a%b)\nn=int(raw_input())\nd = 0\nprime_lim = 0\nnums = []\nfor i in xrange(n):\n    a,b=map(int,raw_input().split())\n    nums.append((a,b))\n    d = gcd(d, a*b)\n    prime_lim=max(prime_lim,a,b)\n\nk = int(prime_lim**0.5)+5\nk=min(k,d-1)\nfor i in xrange(2,k+1):\n    if d%i==0:\n        d = i\n        break\nif d > prime_lim:\n    for a,b in nums:\n        if a*b == d:\n            d = a\n            break\nif d==1:d=-1\nprint d\n"
        },
        {
            "language": 3,
            "solution": "def prime(a): #1 \u0435\u0441\u043b\u0438 \u043f\u0440\u043e\u0441\u0442\u043e\u0435 \u0438\u043d\u0430\u0447\u0435 0\n    i=2\n    if a<=1:\n        return(0)\n    if a==2 or a==3:\n        return(1)\n    while i*i<=a:\n        if a%i==0:\n            return(0)\n        i+=1\n    return(1)\ndef faq(a): #\u0438\u0449\u0435\u0442 \u043f\u0440\u043e\u0441\u0442\u044b\u0435 \u0434\u0435\u043b\u0438\u0442\u0435\u043b\u0438 \u0430, \u0432\u044b\u0432\u043e\u0434\u0438\u0442 \u0441\u043f\u0438\u0441\u043e\u043a\n    l=[]\n    l1=[]\n    i=1\n    while i*i<=a:\n        if a%i==0:\n            l.append(i)\n            l.append(a//i)\n        i+=1\n    for i in range(0,len(l)):\n        if prime(l[i])==1:\n            l1.append(l[i])\n    return(l1)\nn=int(input())\na,b=map(int,input().split())\nc=a*b\nl=faq(a)\nl.extend(faq(b))\nl=list(set(l))\nfor i in range(1,n):\n    a,b=map(int,input().split())\n    if a*b!=c:\n        j=0\n        while j<len(l):\n            c=a*b\n            if (c)%l[j]!=0:\n                l.remove(l[j])\n                if len(l)==0:\n                    print(-1)\n            else:\n                j+=1\nif len(l)!=0:\n    print(l[0])\n"
        },
        {
            "language": 4,
            "solution": "\t                            import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Iterator;\nimport java.util.Stack;\nimport java.util.TreeSet;\n\t\n\t\n\t\n\t                                            public class Solution1 implements Runnable\n\t                                            {\n\t                                                static final long MAX = 464897L;\n\t                                                static class InputReader\n\t                                                {\n\t                                                    private InputStream stream;\n\t                                                    private byte[] buf = new byte[1024];\n\t                                                    private int curChar;\n\t                                                    private int numChars;\n\t                                                    private SpaceCharFilter filter;\n\t                                                    private BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t                                             \n\t                                                    public InputReader(InputStream stream)\n\t                                                    {\n\t                                                        this.stream = stream;\n\t                                                    }\n\t                                                    \n\t                                                    public int read()\n\t                                                    {\n\t                                                        if (numChars==-1) \n\t                                                            throw new InputMismatchException();\n\t                                                        \n\t                                                        if (curChar >= numChars)\n\t                                                        {\n\t                                                            curChar = 0;\n\t                                                            try \n\t                                                            {\n\t                                                                numChars = stream.read(buf);\n\t                                                            }\n\t                                                            catch (IOException e)\n\t                                                            {\n\t                                                                throw new InputMismatchException();\n\t                                                            }\n\t                                                            \n\t                                                            if(numChars <= 0)                \n\t                                                                return -1;\n\t                                                        }\n\t                                                        return buf[curChar++];\n\t                                                    }\n\t                                                 \n\t                                                    public String nextLine()\n\t                                                    {\n\t                                                        String str = \"\";\n\t                                                        try\n\t                                                        {\n\t                                                            str = br.readLine();\n\t                                                        }\n\t                                                        catch (IOException e)\n\t                                                        {\n\t                                                            e.printStackTrace();\n\t                                                        }\n\t                                                        return str;\n\t                                                    }\n\t                                                    public int nextInt()\n\t                                                    {\n\t                                                        int c = read();\n\t                                                        \n\t                                                        while(isSpaceChar(c)) \n\t                                                            c = read();\n\t                                                        \n\t                                                        int sgn = 1;\n\t                                                        \n\t                                                        if (c == '-') \n\t                                                        {\n\t                                                            sgn = -1;\n\t                                                            c = read();\n\t                                                        }\n\t                                                        \n\t                                                        int res = 0;\n\t                                                        do \n\t                                                        {\n\t                                                            if(c<'0'||c>'9') \n\t                                                                throw new InputMismatchException();\n\t                                                            res *= 10;\n\t                                                            res += c - '0';\n\t                                                            c = read();\n\t                                                        }\n\t                                                        while (!isSpaceChar(c)); \n\t                                                        \n\t                                                        return res * sgn;\n\t                                                    }\n\t                                                    \n\t                                                    public long nextLong() \n\t                                                    {\n\t                                                        int c = read();\n\t                                                        while (isSpaceChar(c))\n\t                                                            c = read();\n\t                                                        int sgn = 1;\n\t                                                        if (c == '-') \n\t                                                        {\n\t                                                            sgn = -1;\n\t                                                            c = read();\n\t                                                        }\n\t                                                        long res = 0;\n\t                                                        \n\t                                                        do \n\t                                                        {\n\t                                                            if (c < '0' || c > '9')\n\t                                                                throw new InputMismatchException();\n\t                                                            res *= 10;\n\t                                                            res += c - '0';\n\t                                                            c = read();\n\t                                                        }\n\t                                                        while (!isSpaceChar(c));\n\t                                                            return res * sgn;\n\t                                                    }\n\t                                                    \n\t                                                    public double nextDouble() \n\t                                                    {\n\t                                                        int c = read();\n\t                                                        while (isSpaceChar(c))\n\t                                                            c = read();\n\t                                                        int sgn = 1;\n\t                                                        if (c == '-') \n\t                                                        {\n\t                                                            sgn = -1;\n\t                                                            c = read();\n\t                                                        }\n\t                                                        double res = 0;\n\t                                                        while (!isSpaceChar(c) && c != '.') \n\t                                                        {\n\t                                                            if (c == 'e' || c == 'E')\n\t                                                                return res * Math.pow(10, nextInt());\n\t                                                            if (c < '0' || c > '9')\n\t                                                                throw new InputMismatchException();\n\t                                                            res *= 10;\n\t                                                            res += c - '0';\n\t                                                            c = read();\n\t                                                        }\n\t                                                        if (c == '.') \n\t                                                        {\n\t                                                            c = read();\n\t                                                            double m = 1;\n\t                                                            while (!isSpaceChar(c)) \n\t                                                            {\n\t                                                                if (c == 'e' || c == 'E')\n\t                                                                    return res * Math.pow(10, nextInt());\n\t                                                                if (c < '0' || c > '9')\n\t                                                                    throw new InputMismatchException();\n\t                                                                m /= 10;\n\t                                                                res += (c - '0') * m;\n\t                                                                c = read();\n\t                                                            }\n\t                                                        }\n\t                                                        return res * sgn;\n\t                                                    }\n\t                                                    \n\t                                                    public String readString() \n\t                                                    {\n\t                                                        int c = read();\n\t                                                        while (isSpaceChar(c))\n\t                                                            c = read();\n\t                                                        StringBuilder res = new StringBuilder();\n\t                                                        do \n\t                                                        {\n\t                                                            res.appendCodePoint(c);\n\t                                                            c = read();\n\t                                                        } \n\t                                                        while (!isSpaceChar(c));\n\t                                                        \n\t                                                        return res.toString();\n\t                                                    }\n\t                                                 \n\t                                                    public boolean isSpaceChar(int c) \n\t                                                    {\n\t                                                        if (filter != null)\n\t                                                            return filter.isSpaceChar(c);\n\t                                                        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t                                                    }\n\t                                                 \n\t                                                    public String next() \n\t                                                    {\n\t                                                        return readString();\n\t                                                    }\n\t                                                    \n\t                                                    public interface SpaceCharFilter \n\t                                                    {\n\t                                                        public boolean isSpaceChar(int ch);\n\t                                                    }\n\t                                                }\n\t                                                 \n\t                                                public static void main(String args[]) throws Exception\n\t                                                {\n\t                                                    new Thread(null, new Solution1(),\"Solution\",1<<26).start();\n\t                                                }    \n\t                                                public static int gcd(int a, int b)\n\t                                                {\n\t                                                    if (a == 0)\n\t                                                        return b;\n\t                                                     \n\t                                                    return gcd(b%a, a);\n\t                                                }\n\t                                                int lcm(int a, int b)\n\t                                                {\n\t                                                    return (a*b)/gcd(a, b);\n\t                                                }\n\t                                                ArrayList<Integer> adj[];\n\t                                                ArrayList<Integer> adj1[];\n\t                                                static long MOD = 1000000007;\n\t                                                int[] dx = {1,-1,0,0};\n\t                                                int[] dy = {0,0,1,-1};\n\t                                                int MAXN = 100005;\n\t                                                long[] val;\n\t                                                public void run() \n\t                                                {\n\t                                                    \n\t                                                        //InputReader sc= new InputReader(new FileInputStream(\"input.txt\"));\n\t                                                        //PrintWriter w= new PrintWriter(new FileWriter(\"output.txt\"));\n\t                                                        InputReader sc = new InputReader(System.in);\n\t                                                        PrintWriter w = new PrintWriter(System.out);\n\t                                                        \n\t                                                        int n = sc.nextInt();\n\t                                                        sieve();\n\t                                                        Pair[] p = new Pair[n];\n\t                                                        for(int i = 0;i < n;i++) {\n\t                                                        \tp[i] = new Pair(sc.nextInt(),sc.nextInt());\n\t                                                        }\n\t                                                        if(n == 1) {\n\t                                                        \tw.println(p[0].a);\n\t                                                        }else {\n\t                                                        \tint[] calc = {p[0].a,p[0].b,p[1].a,p[1].b};\n\t                                                        \tTreeSet<Integer> prs = new TreeSet();\n\t                                                        \tfor(int i = 0;i < 2;i++) {\n\t                                                        \t\tfor(int j : pr) {\n\t                                                        \t\t\twhile(calc[i] % j == 0) {\n\t                                                        \t\t\t\tcalc[i] = calc[i]/j;\n\t                                                        \t\t\t\tprs.add(j);\n\t                                                        \t\t\t}\n\t                                                        \t\t}\n\t                                                        \t\tprs.add(calc[i]);\n\t                                                        \t}\n\t                                                        \tTreeSet<Integer> ans = new TreeSet();\n\t                                                        \tfor(int i = 2;i < 4;i++) {\n\t                                                        \t\tfor(int j : pr) {\n\t                                                        \t\t\tboolean flag = false;\n\t                                                        \t\t\twhile(calc[i] % j == 0) {\n\t                                                        \t\t\t\tcalc[i] = calc[i]/j;\n\t                                                        \t\t\t\tflag = true;\n\t                                                        \t\t\t}\n\t                                                        \t\t\tif(flag && prs.contains(j)) {\n\t                                                        \t\t\t\tans.add(j);\n\t                                                        \t\t\t}\n\t                                                        \t\t}\n\t                                                        \t\tif(prs.contains(calc[i])) {\n\t                                                        \t\t\tans.add(calc[i]);\n\t                                                        \t\t}\n\t                                                        \t\t\n\t                                                        \t}\n\t                                                        \tfor(int i = 2;i < p.length;i++) {\n\t                                                        \t\tArrayList<Integer> toRemove = new ArrayList();\n\t                                                        \t\tfor(Integer x: ans) {\n\t                                                        \t\t\tif(p[i].a % x != 0 && p[i].b % x != 0) {\n\t                                                        \t\t\t\ttoRemove.add(x);\n\t                                                        \t\t\t}\n\t                                                        \t\t}\n\t                                                        \t\tfor(Integer val: toRemove) {\n\t                                                        \t\t\tans.remove(val);\n\t                                                        \t\t}\n\t                                                        \t}\n\t                                                        \tif(ans.size() == 0 || ans.last() == 1) {\n\t                                                        \t\tw.println(\"-1\");\n\t                                                        \t}else {\n\t                                                        \t\tw.println(ans.last());\n\t                                                        \t}\n\t                                                        }\n\t                                                        w.close();\t                                                                                                                      \n\t                                                 }\n\t                                                \n\t                                                boolean[] visited;\n\t                                                ArrayList<ArrayList<Integer>> ar = new ArrayList();\n\t                                                ArrayList<Integer> temp;\n\t                                                void dfs1(int a) {\n\t                                                \tvisited[a] = true;\n\t                                                \tIterator<Integer> it = adj1[a].iterator();\n\t                                                \twhile(it.hasNext()) {\n\t                                                \t\tint x = it.next();\n\t                                                \t\tif(!visited[x]) {\n\t                                                \t\t\tdfs1(x);\n\t                                                \t\t}\n\t                                                \t}\n\t                                                \ttemp.add(a);\n\t                                                }\n\t                                                void topo() {\n\t                                                \tfor(int i = 0;i < adj.length;i++) {\n\t                                                \t\tif(!visited[i]) {\n\t                                                \t\t\tdfs(i);\n\t                                                \t\t}\n\t                                                \t}\n\t                                                }\n\t                                                Stack<Integer> st=  new Stack();\n\t                                                void dfs(int a) {\n\t                                                \tvisited[a] = true;\n\t                                                \tIterator<Integer> it = adj[a].iterator();\n\t                                                \twhile(it.hasNext()) {\n\t                                                \t\tint x = it.next();\n\t                                                \t\tif(!visited[x]) {\n\t                                                \t\t\tdfs(x);\n\t                                                \t\t}\n\t                                                \t}\n\t                                                \tst.add(a);\n\t                                                }\n\t                                               \n\t                                                ArrayList<Integer> pr = new ArrayList();\n\t                                                void sieve() {\n\t                    \t\t\t\t\t\t\t\tboolean[] prime = new boolean[MAXN];\n\t                    \t\t\t\t\t\t\t\tArrays.fill(prime, true);\n\t                    \t\t\t\t\t\t\t\tprime[1] = false;\n\t                    \t\t\t\t\t\t\t\tfor(int i = 2;i < MAXN;i++) {\n\t                    \t\t\t\t\t\t\t\t\tif(prime[i]) {\n\t                    \t\t\t\t\t\t\t\t\t\tfor(int j = 2*i;j < MAXN;j+=i) {\n\t                    \t\t\t\t\t\t\t\t\t\t\tprime[j] = false;\n\t                    \t\t\t\t\t\t\t\t\t\t}\n\t                    \t\t\t\t\t\t\t\t\t}\n\t                    \t\t\t\t\t\t\t\t}\n\t                    \t\t\t\t\t\t\t\tfor(int i =2;i < MAXN;i++) {\n\t                    \t\t\t\t\t\t\t\t\tif(prime[i]) {\n\t                    \t\t\t\t\t\t\t\t\t\tpr.add(i);\n\t                    \t\t\t\t\t\t\t\t\t}\n\t                    \t\t\t\t\t\t\t\t}\n\t                    \t\t\t\t\t\t\t}\n\t                                                TreeSet<Integer> factorize(int a) {\n\t                                                \tTreeSet<Integer> ar = new TreeSet();\n\t                                                \twhile(a != 1) {\n\t                                                \t\tar.add(spf[a]);\n\t                                                \t\ta = a/spf[a];\n\t                                                \t}\n\t                                                \treturn ar;\n\t                                                }\n\t                    \t\t\t\t\t\t\tint[] spf;\n\t                                                static class Pair implements Comparable<Pair>{\n\t                                                    int a;\n\t                                                    int b;\n\t                                                    \n\t                                                    \n\t                                                    Pair(int a,int b){\n\t                                                        this.a  =a;\n\t                                                        this.b = b;\n\t                                                        \n\t                                                    }\n\t                                                    Pair(){}    \n\t                                                    public boolean equals(Object o)\n\t                                                    {\n\t                                                        Pair p = (Pair)o;\n\t                                                        return (this.a == p.a && this.b == p.b) || (this.a == p.b && this.b == p.a);\n\t                                                    }\n\t                                                    \n\t                                                    public int compareTo(Pair p){\n\t                                                    \t return Integer.compare(this.b, p.b);\n\t                                                    }\n\t                                                    public int hashCode()\n\t                                                    {\n\t                                                        return new Long(a).hashCode()*31 + new Long(b).hashCode()*2 + new Long(a).hashCode() * 3;\n\t                                                    }\n\t\n\t                                                }\n\t                                                \n\t                                }"
        },
        {
            "language": 1,
            "solution": "n = int(raw_input())\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\na, b = map(int, raw_input().split())\nst1, st2 = a, b\nans = (a * b) / gcd(a, b)\n\nfor i in xrange(n - 1):\n    a, b = map(int, raw_input().split())\n    l = (a * b) / gcd(a, b)\n    ans = gcd(ans, l)\n\n\nif ans == 1:\n    print -1\nelse:\n    for i in xrange(int(1e5)):\n        if ans % (i+2) == 0:\n            print i+2\n            break\n    else:\n        if ans % st1 == 0:\n            print st1\n        elif ans % st2 == 0:\n            print st2\n        else:\n            print ans"
        },
        {
            "language": 1,
            "solution": "import math\ndef fun(n):\n    l=[]\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return l\nn=input()\ns=set()\nl=[]\n\nfor i in range(n):\n    x,y=map(int,raw_input().split(\" \"))\n    l.append((x,y))\n    if i==0:\n        s=list(set(fun(x)+fun(y)))\n#s.sort()\nf=0\nfor i in l[1:]:\n    flag=0\n    x=i[0]\n    y=i[1]\n    a1=[]\n    for j in range(len(s)):\n        if x%s[j]==0 or y%s[j]==0:\n            flag=1\n        else:\n            a1.append(s[j])    \n    for j in a1:\n        s.remove(j)\n        \n    if not flag:\n    \n        f=1\n        break\nif f:\n    print -1\nelse:\n    print s[0]\n\n    \n    \n"
        },
        {
            "language": 1,
            "solution": "n=int(raw_input())\n\ndef gcd(a,b):\n    if a<b:\n        a,b=b,a\n    while b>0:\n        a,b=b,a%b\n    return a\n\nu,v=map(int,raw_input().split())\nif n==1:\n    print u\n    exit()\nlcm=u*v/gcd(u,v)\n\n\nfor i in range(1,n):\n    u,v=map(int,raw_input().split())\n    lx=u*v/gcd(u,v)\n    lcm=gcd(lx,lcm)\n\nu=gcd(lcm,u)\nv=gcd(lcm,v)\n\nu=max(u,v)\n\nif u==1:\n    print -1\n    exit()\n\ni=2\nwhile i*i<=u:\n    if u%i==0:\n        print i\n        exit()\n    i+=1\n\nprint u\nexit()\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Question {\n\tpublic static int MOD = 1000000007;\n\n\tstatic Scan scn = new Scan();\n\tstatic Print printer = new Print();\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tB();\n\t\tprinter.close();\n\t}\n\n\tpublic static void A() throws Exception {\n\n\t\tint len = scn.scanInt();\n\t\tString str = scn.scanString();\n\n\t\tif (len == 1) {\n\t\t\tprinter.printLine(\"Yes\");\n\t\t\treturn;\n\t\t}\n\n\t\tint[] hash = new int[26];\n\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tchar ch = str.charAt(i);\n\t\t\thash[ch - 'a']++;\n\t\t}\n\n\t\tfor (int i = 0; i < hash.length; i++) {\n\t\t\tif (hash[i] > 1) {\n\t\t\t\tprinter.printLine(\"Yes\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tprinter.printLine(\"No\");\n\n\t}\n\n\tpublic static void B() throws Exception {\n\n\t\tint n = scn.scanInt();\n\t\tIntIntPair[] arr = new IntIntPair[n];\n\n\t\tIntIntPair minPair = new IntIntPair(Integer.MAX_VALUE, Integer.MAX_VALUE);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = new IntIntPair(scn.scanInt(), scn.scanInt());\n\n\t\t\tif (arr[i].compareTo(minPair) < 0)\n\t\t\t\tminPair = arr[i];\n\t\t}\n\n\t\tHashSet<Integer> candidates = new HashSet<>();\n\t\tgetAllUniquePrimeFactors(minPair.one, candidates);\n\t\tgetAllUniquePrimeFactors(minPair.two, candidates);\n\n\t\tfor (int i = 0; i < arr.length; i++) {\n\n\t\t\tHashSet<Integer> hs = new HashSet<>();\n\t\t\tfor (int factor : candidates) {\n\t\t\t\tif (arr[i].one % factor == 0 || arr[i].two % factor == 0)\n\t\t\t\t\ths.add(factor);\n\t\t\t}\n\n\t\t\tif (hs.size() == 0) {\n\t\t\t\tprinter.printLine(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcandidates = hs;\n\n\t\t}\n\n\t\tprinter.print(candidates.toArray()[0].toString());\n\n\t}\n\n\tpublic static class IntIntPair implements Comparable<IntIntPair> {\n\n\t\tint one;\n\t\tint two;\n\n\t\tpublic IntIntPair(int one, int two) {\n\t\t\tthis.one = one;\n\t\t\tthis.two = two;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(IntIntPair o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tint val = this.one - o.one;\n\t\t\tif (val != 0)\n\t\t\t\treturn val;\n\n\t\t\treturn this.two - o.two;\n\t\t}\n\t}\n\n\tpublic static void getAllUniquePrimeFactors(int num, HashSet<Integer> hs) {\n\n\t\twhile (num % 2 == 0) {\n\t\t\ths.add(2);\n\t\t\tnum /= 2;\n\t\t}\n\n\t\tfor (int fac = 3; fac <= Math.sqrt(num); fac += 2) {\n\n\t\t\tif (fac > num)\n\t\t\t\tbreak;\n\n\t\t\tif (num % fac == 0) {\n\t\t\t\ths.add(fac);\n\n\t\t\t\twhile (num % fac == 0)\n\t\t\t\t\tnum /= fac;\n\t\t\t}\n\t\t}\n\n\t\tif (num > 2)\n\t\t\ths.add(num);\n\n\t}\n\n\tpublic static int gcd(int one, int two) {\n\n\t\treturn 0;\n\t}\n\n\tstatic class Scan {\n\t\tprivate InputStream in;\n\t\tprivate byte[] buf = new byte[1024 * 1024];\n\t\tprivate int index;\n\t\tprivate int total;\n\n\t\tpublic Scan() {\n\t\t\t// this.in = in;\n\t\t\tin = System.in;\n\t\t\t// try {\n\t\t\t// in = new FileInputStream(new File(\"/home/ujjwal/test/test\"));\n\t\t\t// } catch (Exception ex) {\n\t\t\t//\n\t\t\t// }\n\t\t}\n\n\t\tpublic int scan() throws IOException {\n\t\t\tif (total < 0)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (index >= total) {\n\t\t\t\tindex = 0;\n\t\t\t\ttotal = in.read(buf);\n\t\t\t\tif (total <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[index++];\n\t\t}\n\n\t\tpublic int[] inputArray(int n) throws Exception {\n\t\t\tint[] arr = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = scn.scanInt();\n\t\t\t}\n\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic ArrayList<Integer> inputList(int n) throws Exception {\n\n\t\t\tArrayList<Integer> list = new ArrayList<>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlist.add(scn.scanInt());\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\n\t\tpublic int[][] inputMatrix(int n, int m) throws Exception {\n\t\t\tint[][] arr = new int[n][m];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tarr[i][j] = scn.scanInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic int scanInt() throws IOException {\n\t\t\tint integer = 0;\n\t\t\tint n = scan();\n\t\t\twhile (isWhiteSpace(n))\n\t\t\t\tn = scan();\n\t\t\tint neg = 1;\n\t\t\tif (n == '-') {\n\t\t\t\tneg = -1;\n\t\t\t\tn = scan();\n\t\t\t}\n\t\t\twhile (!isWhiteSpace(n)) {\n\t\t\t\tif (n >= '0' && n <= '9') {\n\t\t\t\t\tinteger *= 10;\n\t\t\t\t\tinteger += n - '0';\n\t\t\t\t\tn = scan();\n\t\t\t\t} else\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\treturn neg * integer;\n\t\t}\n\n\t\tpublic long scanLong() throws IOException {\n\t\t\tlong integer = 0;\n\t\t\tint n = scan();\n\t\t\twhile (isWhiteSpace(n))\n\t\t\t\tn = scan();\n\t\t\tint neg = 1;\n\t\t\tif (n == '-') {\n\t\t\t\tneg = -1;\n\t\t\t\tn = scan();\n\t\t\t}\n\t\t\twhile (!isWhiteSpace(n)) {\n\t\t\t\tif (n >= '0' && n <= '9') {\n\t\t\t\t\tinteger *= 10;\n\t\t\t\t\tinteger += n - '0';\n\t\t\t\t\tn = scan();\n\t\t\t\t} else\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\treturn neg * integer;\n\t\t}\n\n\t\tpublic double scanDouble() throws IOException {\n\t\t\tdouble doub = 0;\n\t\t\tint n = scan();\n\t\t\twhile (isWhiteSpace(n))\n\t\t\t\tn = scan();\n\t\t\tint neg = 1;\n\t\t\tif (n == '-') {\n\t\t\t\tneg = -1;\n\t\t\t\tn = scan();\n\t\t\t}\n\t\t\twhile (!isWhiteSpace(n) && n != '.') {\n\t\t\t\tif (n >= '0' && n <= '9') {\n\t\t\t\t\tdoub *= 10;\n\t\t\t\t\tdoub += n - '0';\n\t\t\t\t\tn = scan();\n\t\t\t\t} else\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (n == '.') {\n\t\t\t\tn = scan();\n\t\t\t\tdouble temp = 1;\n\t\t\t\twhile (!isWhiteSpace(n)) {\n\t\t\t\t\tif (n >= '0' && n <= '9') {\n\t\t\t\t\t\ttemp /= 10;\n\t\t\t\t\t\tdoub += (n - '0') * temp;\n\t\t\t\t\t\tn = scan();\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn doub * neg;\n\t\t}\n\n\t\tpublic String scanString() throws IOException {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint n = scan();\n\t\t\twhile (isWhiteSpace(n))\n\t\t\t\tn = scan();\n\t\t\twhile (!isWhiteSpace(n)) {\n\t\t\t\tsb.append((char) n);\n\t\t\t\tn = scan();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tprivate boolean isWhiteSpace(int n) {\n\t\t\tif (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1)\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstatic class Print {\n\t\tprivate final BufferedWriter bw;\n\n\t\tpublic Print() {\n\t\t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t}\n\n\t\tpublic void print(String str) throws IOException {\n\t\t\tbw.append(str);\n\t\t}\n\n\t\tpublic void printArray(int[] arr) throws Exception {\n\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tprinter.print(arr[i] + \" \");\n\t\t\t}\n\n\t\t\tprinter.printLine(\"\");\n\t\t}\n\n\t\tpublic void printList(ArrayList<Integer> list) throws Exception {\n\n\t\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\t\tprinter.print(list.get(i) + \" \");\n\t\t\t}\n\n\t\t\tprinter.printLine(\"\");\n\t\t}\n\n\t\tpublic void printLine(String str) throws IOException {\n\t\t\tprint(str);\n\t\t\tbw.append(\"\\n\");\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbw.close();\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "# coding:utf-8\n\nimport sys\n\ninput = sys.stdin.readline\n\n\ndef inpl(): return list(map(int, input().split()))\n\n\ndef gcd(x, y):\n    if x % y == 0:\n        return y\n    else:\n        x, y = y, x % y\n        return gcd(x, y)\n\n\nN = int(input())\nnums = []\ng = 0\nfor i in range(N):\n    a, b = inpl()\n    nums.append([a, b])\n    g = gcd(g, a * b)\n\nfor i in range(N):\n    ga, gb = gcd(g, nums[i][0]), gcd(g, nums[i][1])\n    g = max(ga, gb)\n\nif g == 1: g = -1\nprint(g)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class main {\n    static long b[][];\n    public static long NOD(long a,long b) {\n        if (a == 0|| b == 0) {\n            return a + b;\n        }\n        return NOD(b,a % b);\n    }\n    public static long NOK(long a,long b) {\n        return (a * b) / NOD(a,b);\n    }\n    public static void main(String[] args) throws IOException {\n        Locale.setDefault(Locale.US);\n        br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = nextInt();\n        b = new long [n][2];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 2; j++) {\n                b[i][j] = nextInt();\n            }\n        }\n        long c[] = new long [n];\n        for (int i = 0; i < n; i++) {\n            c[i] = NOK(b[i][0],b[i][1]);\n        }\n        long ans = c[0];\n        for (int i = 1; i < n; i++) {\n            ans = NOD(Math.max(ans,c[i]),Math.min(ans,c[i]));\n        }\n        if (ans == 1) {\n            pw.println(-1);\n        }else{\n            long g = 0;\n            for (int i = 2; i <= Math.sqrt(b[0][0]); i++) {\n                if (ans % i == 0 && b[0][0] % i == 0) {\n                    g = i;\n                    break;\n                }\n            }\n            if (g == 0) {\n                for (int i = 2; i <= Math.sqrt(b[0][1]); i++) {\n                    if (ans % i == 0 && b[0][1] % i == 0) {\n                        g = i;\n                        break;\n                    }\n                }\n            }\n            if (g == 0) {\n                for (int i = (int) Math.sqrt(b[0][0]); i >= 2; i--) {\n                    if (ans % (b[0][0] / i) == 0 && b[0][0] % i == 0) {\n                        g = (b[0][0] / i);\n                        break;\n                    }\n                }\n            }\n            if (g == 0) {\n                for (int i = (int) Math.sqrt(b[0][1]); i >= 2; i--) {\n                    if (ans % (b[0][1] / i) == 0 && b[0][1] % i == 0) {\n                        g = (b[0][1] / i);\n                        break;\n                    }\n                }\n            }\n            if (g == 0) {\n                if (ans % b[0][0] == 0) {\n                    g = b[0][0];\n                }else{\n                    g = b[0][1];\n                }\n            }\n            pw.println(g);\n        }\n        pw.close();\n    }\n    static BufferedReader br;\n    static StringTokenizer st = new StringTokenizer(\"\");\n\n    public static int nextInt() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return Integer.parseInt(st.nextToken());\n    }\n\n    public static String next() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public static double nextDouble() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return Double.parseDouble(st.nextToken());\n    }\n\n    public static long nextLong() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return Long.parseLong(st.nextToken());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5;\nlong long n;\nlong long a[N], b[N];\nvector<long long> primeDiv;\nvoid addDivisor(long long x) {\n  for (long long i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      while (x % i == 0) x /= i;\n      primeDiv.push_back(i);\n    }\n  }\n  if (x > 1) primeDiv.push_back(x);\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> n;\n  for (long long i = 1; i <= n; i++) cin >> a[i] >> b[i];\n  addDivisor(a[1]);\n  addDivisor(b[1]);\n  for (long long d : primeDiv) {\n    bool flag = true;\n    for (long long i = 2; i <= n; i++) {\n      if (a[i] % d != 0 and b[i] % d != 0) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) {\n      cout << d;\n      return 0;\n    }\n  }\n  cout << -1;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class WeakenedCommonDivisor {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        long[][] pairs = new long[n][2];\n        for (int i = 0; i < n; i++) {\n            st = new StringTokenizer(br.readLine());\n            pairs[i][0] = Long.parseLong(st.nextToken());\n            pairs[i][1] = Long.parseLong(st.nextToken());\n        }\n//        pairs[0][0] = 1999999999; //////////\n//\n//        for (long i = 2; i <= temp; i++) {\n//            boolean possible = true;\n//            for (int j = 0; j < n; j++) {\n//                if (pairs[j][0] % i != 0 && pairs[j][1] != 0) {\n//                    possible = false;\n//                    break;\n//                }\n//            }\n//            if (possible) {\n//                System.out.println(i);\n//                return;\n//            }\n//        }\n//        System.out.println(-1);\n\n\n        Set<Long> set = new HashSet<>();\n        Long temp = pairs[0][0];\n        for (int i = 2; i <= Math.sqrt(temp); i++) {\n            while (temp % i == 0) {\n                set.add((long) i);\n                temp /= i;\n            }\n        }\n        set.add(temp);\n        temp = pairs[0][1];\n        for (int i = 2; i <= Math.sqrt(temp); i++) {\n            while (temp % i == 0) {\n                set.add((long) i);\n                temp /= i;\n            }\n        }\n        set.add(temp);\n        set.remove(1L);\n        for (int i = 1; i < n; i++) {\n            Set<Long> rm = new HashSet<>();\n            for (Long l : set) {\n                if (pairs[i][0] % l != 0 && pairs[i][1] % l != 0) rm.add(l);\n            }\n            set.removeAll(rm);\n            if (set.size() == 0) {\n                System.out.println(-1);\n                return;\n            }\n        }\n\n        for (Long l : set) {\n            System.out.println(l);\n            return;\n        }\n    }\n\n//    private static void removeNonPrimes(Set<Long> set) {\n//        Set<Long> rm = new HashSet<>();\n//        for (long l : set) {\n//            for (long x : set) {\n//                if (x / l > 1 && x % l == 0) {\n//                    rm.add(x);\n//                }\n//            }\n//        }\n//        set.removeAll(rm);\n//    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inv = 1000000000;\nconst int minv = -inv;\nconst int max_n = 150000 + 5;\nconst int lim = 100000;\nlong long fgcd(long long a, long long b) {\n  if (a == 0ll)\n    return b;\n  else\n    return fgcd(b % a, a);\n}\nbool isp[max_n];\nint n;\nint a[max_n], b[max_n];\nint main() {\n  scanf(\"%d\", &n);\n  long long g = 0ll;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n    scanf(\"%d\", &b[i]);\n    long long q = ((long long)(a[i])) * ((long long)(b[i]));\n    g = fgcd(g, q);\n  }\n  if (g == 1ll) {\n    printf(\"%d\\n\", -1);\n    return 0;\n  }\n  if (fgcd(g, ((long long)(a[0]))) != 1ll)\n    g = fgcd(g, ((long long)(a[0])));\n  else\n    g = fgcd(g, ((long long)(b[0])));\n  for (int d = 2; d < lim + 1; ++d)\n    if (g % ((long long)(d)) == 0ll) {\n      printf(\"%d\\n\", d);\n      return 0;\n    }\n  cout << g << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# import sys\n# sys.stdin  = open(\"input.in\",\"r\")\nfrom sys import stdin\ninput = stdin.readline\nfrom heapq import heapify,heappush,heappop,heappushpop\nfrom collections import defaultdict as dd, deque as dq,Counter as C\nfrom math import factorial as f ,ceil,gcd,sqrt,log\nfrom bisect import bisect_left as bl ,bisect_right as br\nfrom itertools import combinations as c,permutations as p\nfrom math import factorial as f ,ceil,gcd,sqrt,log\nmp = lambda : map(int,input().split())\nit = lambda: int(input())\nls = lambda : list(input().strip())\nmt = lambda  r : [ list(mp()) for _ in range(r)]\nmod = 1000000007\ndef isprime(n):\n\tfor j in range(3,int(sqrt(n))+1,2):\n\t\tif n%j==0:\n\t\t\treturn 0\n\treturn 1\ndef factors(n):\n\ts = set()\n\t# s.add(1)\n\ts.add(n)\n\tfor j in range(2,int(sqrt(n))+1):\n\t\tif n%j==0:\n\t\t\ts.add(j)\n\t\t\ts.add(n//j)\n\treturn s\ndef pfactors(n):\n\tpm = set()\n\tflg =0\n\twhile n%2==0:\n\t\tflg =1\n\t\tn//=2\n\tif flg:pm.add(2)\n\tfor cc in range(3,int(sqrt(n))+1,2):\n\t\tif n%cc==0:\n\t\t\tpm.add(cc)\n\t\t\twhile n%cc==0:\n\t\t\t\tn//=cc\n\tif n>1:\n\t\tpm.add(n)\n\treturn pm\n\nk = mt(it())\nfc = pfactors(k[0][0])\nfc.update(pfactors(k[0][1]))\nout =-1\nfor ele in fc :\n\tans = ele\n\tfor fs,scd in list(k):\n\t\tif fs%ele and scd%ele :\n\t\t\tans = 0\n\t\t\tbreak\n\tif ans:\n\t\tout = ans\n\t\tbreak\nprint(out)\n"
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.text.*;\nimport java.util.*;\nimport java.io.*;\n\n/**\n * @author : soumitri12\n */\n\npublic class Solution \n{\n    static class FastReader {\n            \n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (final IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (final IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static class Pair {\n        int ff,ss;\n        public Pair(int ff,int ss) {\n            this.ff=ff; this.ss=ss;\n        }\n    }\n\n    private static long lcm(long x, long y) {\n            if(x<y) {x=x^y; y=y^x; x=x^y;}\n            return x*y/gcd(x,y);\n        }\n\n        private static long gcd(long x, long y) {\n            if(y==0) return x;\n            else\n            {\n                if(x<y) {x=x^y; y=y^x; x=x^y;}\n                return gcd(y,x%y);\n            }\n        }\n    \n    static HashSet<Long> fac=new HashSet<>();\n    static void getPrimeFactors(long x) {\n        for(long i=2;i<=Math.sqrt(x);i++) {\n            if(x%i==0) {\n                fac.add(i);\n                while(x%i==0) x/=i;\n            }\n        }\n        if(x>1) fac.add(x);\n    }\n    public static void main(final String[] args) {\n        final FastReader sc=new FastReader();\n        final PrintWriter out=new PrintWriter(System.out);\n        StringBuffer sb=new StringBuffer();\n        // your code starts here\n        int n=sc.nextInt();\n        long ans=-1,ctr=0;\n        long x=sc.nextLong(),y=sc.nextLong();\n        getPrimeFactors(x); getPrimeFactors(y);\n        long a[]=new long[n-1],b[]=new long[n-1];\n        for(int i=0;i<n-1;i++) {\n            a[i]=sc.nextLong(); b[i]=sc.nextLong();\n        }\n        for(Long f:fac){\n            ctr=0; \n            for(int i=0;i<n-1;i++) {\n                x=a[i]; y=b[i];\n                if(x%f==0 || y%f==0) {\n                    ++ctr;\n                } \n            }   \n            if(ctr==n-1)  {\n                //ans=f; else ans=-1;\n                out.println(f); out.close();return;\n            }\n        }\n        //if(ans==1) ans=-1;\n        out.print(-1);\n        out.close();\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\nfrom math import sqrt,ceil,gcd\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\ndef dtb(n):\n    return bin(n).replace(\"0b\", \"\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef lcm(a,b):\n    return a*b//gcd(a,b)\n\nn=int(input())\nans=0\na,b=0,0\nfor _ in range(n):\n    a,b=map(int,input().split())\n    ans=gcd(ans,lcm(a,b))\nif ans<=1:\n    print(-1)\nelse:\n    ck = 0\n    i = 2\n    t = sqrt(a)\n    while i < a and i <= t:\n        if a % i==0:\n            if ans % i==0:\n                ck = i\n                break\n            while a % i==0:\n                a //= i\n        i += 1\n    if not ck:\n        if ans % a==0:\n            ck = a\n    if not ck:\n\n        i=2\n        t=sqrt(b)\n        while i<b and i<=t:\n            if b%i==0:\n                if ans%i==0:\n                    ck=i\n                    break\n                while b%i==0:\n                    b//=i\n            i+=1\n        if not ck:\n            if ans%b==0:\n                ck=b\n    print(ck)"
        },
        {
            "language": 3,
            "solution": "#########################################################################################################\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\n\nimport sys\nimport os\nimport io\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\n\n\nimport math\n\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n\n    for i in range(3, int(math.sqrt(n))+1, 2):\n\n        while n % i == 0:\n            l.append(int(i))\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\t # y = y/2\n        x = (x * x) % p\n    return res\n\n\ndef si():\n    return input()\n\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\n\n\ndef divideCeil(n, x):\n    if (n % x == 0):\n        return n//x\n    return n//x+1\n\n\ndef ii():\n    return int(input())\n\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\n\ndef li():\n    return list(map(int, input().split()))\n\n\n# t = int(input())\nt = 1\nfor _ in range(t):\n    n = ii()\n    d = defaultdict(lambda:0)\n    l = []\n    for i in range(n):\n        a,b = li()\n        l.append([a,b])\n    x = list(set(primeFactors(a)+primeFactors(b)))\n    \n    ff = 0\n    for i in x:\n        f  = 0\n        for j in range(n):\n            if (l[j][0]%i!=0 and l[j][1]%i!=0):\n                f = 1 \n                break\n        if (f==0):\n            print(int(i))\n            ff = 1\n            break\n    if ff==0:\n        print(-1)\n\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 150000;\nint A[MAXN + 1], B[MAXN + 1];\nlong long GCD(long long a, long long b) {\n  if (a == 0) {\n    return b;\n  }\n  return GCD(b % a, a);\n}\nint main(int argc, char** argv) {\n  int N;\n  cin >> N;\n  long long has = 0;\n  for (int i = 1; i <= N; i++) {\n    cin >> A[i] >> B[i];\n    has = GCD(has, (long long)A[i] * B[i] / GCD(A[i], B[i]));\n  }\n  if (has == 1) {\n    cout << \"-1\\n\";\n  } else {\n    for (int i = 1; i <= N; i++) {\n      if (GCD(has, A[i]) == 1) {\n        has = GCD(has, B[i]);\n      } else {\n        has = GCD(has, A[i]);\n      }\n    }\n    cout << has << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\ndef factor(n):\n    q=0\n    for i in range(2,int(math.sqrt(n))+1):\n        if(n%i==0):\n            q+=1\n    return q\n        \nn=int(input())\ntemp=[]\nlis=[]\nk=0\na1,b1=map(int,input().split())\nj=0\nfor i in range(2,int(math.sqrt(a1+1))+1):\n    if(a1%i==0):\n        lis.append(i)\n        lis.append(a1//i)\nlis.append(a1)\nfor i in range(2,int(math.sqrt(b1+1))+1):\n    if(b1%i==0):\n        lis.append(i)\n        lis.append(b1//i)\nlis.append(b1)\nlis=list(set(lis))\np=len(lis)\nfor j in range(len(lis)):\n    if(factor(lis[j])==0):\n        lis.append(lis[j])\ndel lis[:p]\nfor i in range(1,n):\n    a,b=map(int,input().split())\n    if(a==a1 or b==b1 or a==b1 or b==a1):\n        a1=a\n        b1=b\n        continue\n    a1=a\n    b1=b\n    l=len(lis)\n    for j in range(l):\n        if(a%lis[j]==0 or b%lis[j]==0):\n            lis.append(lis[j])\n    del lis[:l]\n    if(len(lis)==0):\n        k=1\n        break\nif(k==0):\n    print(lis[0])\nelse:\n    print(-1)\n            \n            "
        },
        {
            "language": 4,
            "solution": "//package aug;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class EdRnd49 {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n    //boolean codechef=true;\n    boolean codechef=true;\n    \n\tvoid solve()\n\t{\n\t\tint n=ni();\n\t\tint[] a=new int[n];\n\t\tint[] b=new int[n];\n\t\tlong ans=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\ta[i]=ni();b[i]=ni();\n\t\t\tans=gcd(ans,lcm(a[i],b[i]));\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(gcd(ans,a[i])!=1)\n\t\t\t{\n\t\t\t\tans=gcd(ans,a[i]);\n\t\t\t}\n\t\t\telse ans=gcd(ans,b[i]);\n\t\t}\n\t\t\n\t\tout.println(ans==1?-1:ans);\n\t}\n\t\n\tpublic static long[] radixSort(long[] f){ return radixSort(f, f.length); }\n\tpublic static long[] radixSort(long[] f, int n)\n\t{\n\t\tlong[] to = new long[n];\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < n;i++)b[1+(int)(f[i]&0xffff)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < n;i++)to[b[(int)(f[i]&0xffff)]++] = f[i];\n\t\t\tlong[] d = f; f = to;to = d;\n\t\t}\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < n;i++)b[1+(int)(f[i]>>>16&0xffff)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < n;i++)to[b[(int)(f[i]>>>16&0xffff)]++] = f[i];\n\t\t\tlong[] d = f; f = to;to = d;\n\t\t}\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < n;i++)b[1+(int)(f[i]>>>32&0xffff)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < n;i++)to[b[(int)(f[i]>>>32&0xffff)]++] = f[i];\n\t\t\tlong[] d = f; f = to;to = d;\n\t\t}\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < n;i++)b[1+(int)(f[i]>>>48&0xffff)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < n;i++)to[b[(int)(f[i]>>>48&0xffff)]++] = f[i];\n\t\t\tlong[] d = f; f = to;to = d;\n\t\t}\n\t\treturn f;\n\t}\n\t\n\tstatic void dfs(int[][] g,int u,int[] vis)\n\t{\n\t\tvis[u]=1;\n\t\tfor(int v:g[u])\n\t\t{\n\t\t\tif(vis[v]!=1)dfs(g,v,vis);\n\t\t}\n\t}\n\t\n\tstatic int[][] packD(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t}\n\t\treturn g;\n\t}\n    \n    public boolean check(int[] cnt,int m)\n    {\n    \tboolean ch=true;\n    \tfor(int i=2;i<=m;i++)\n\t\t{\n\t\t\tif(cnt[i]>=cnt[1])\n\t\t\t{\n\t\t\t\tch=false;break;\n\t\t\t}\n\t\t}\n\t\treturn ch;\n    }\n    \n    static class Pair\n    {\n        int a,b;\n        public Pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    \n    static long lcm(int a,int b)\n    {\n        long val=a;\n        val*=b;\n        return (val/gcd(a,b));\n    }\n    \n    static long gcd(long a,long b)\n    {\n        if(a==0)return b;\n        return gcd(b%a,a);\n    }\n    \n    static int pow(int a, int b, int p)\n    {\n        long ans = 1, base = a;\n        while (b!=0)\n        {\n            if ((b & 1)!=0)\n            {\n                ans *= base;\n                ans%= p;\n            }\n            base *= base;\n            base%= p;\n            b >>= 1;\n        }\n        return (int)ans;\n    }\n\n    static int inv(int x, int p)\n    {\n        return pow(x, p - 2, p);\n    }\n\n    \n    void run() throws Exception\n    {\n        if(codechef)oj=true;\n        is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        \n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception {new EdRnd49().run();}\n    \n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}"
        },
        {
            "language": 3,
            "solution": "import math\nimport sys\nn=int(input());\na=[]\nb=[]\ng=0\nfor i in range(n) :\n    p,q=map(int,sys.stdin.readline().split())\n    a.append(p)\n    b.append(q)\n    g=math.gcd(g,p*q);\n    #print(g)\n    if (1==g):\n        exit(print(\"-1\"))\n#print(g)    \nfor i in range (n) :\n    if math.gcd (g,a[i])!=1 :\n        g=math.gcd (g,a[i])\n        #print(\"a\",g)\n    else :\n        g=math.gcd (g,b[i])\n        #print(\"b\",g)\nprint(g)"
        },
        {
            "language": 3,
            "solution": "from math import gcd, sqrt\nn = int(input())\n\n\ndef divsor(a):\n    for i in range(2, int(sqrt(a)) + 1):\n        if not a % i:\n            return i\n    return a\n\n\na, b = map(int, input().split())\nif n == 1:\n    print(a)\n    exit()\nfor i in range(n - 1):\n    c, d = map(int, input().split())\n    a = gcd(c*d, a); b = gcd(c*d, b)\n\nif a > 1:\n    print(divsor(a))\nelif b > 1:\n    print(divsor(b))\nelse:\n    print(-1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long int i, x, m, y, j, k, h, n, w, k1, k2, k3, q;\n  cin >> n;\n  vector<pair<long long int, long long int>> v;\n  vector<long long int> fi, si;\n  map<pair<long long int, long long int>, long long int> mp;\n  for (i = 0; i < n; i++) {\n    cin >> k1 >> k2;\n    if (!mp[{k1, k2}]) {\n      mp[{k1, k2}]++;\n      mp[{k2, k1}]++;\n      v.push_back({k1, k2});\n    }\n  }\n  n = v.size();\n  k1 = v[0].first;\n  k2 = v[0].second;\n  set<long long int> s;\n  for (i = 1; i * i <= k1; i++) {\n    if (k1 % i == 0) {\n      s.insert(i);\n      s.insert(k1 / i);\n    }\n  }\n  for (i = 1; i * i <= k2; i++) {\n    if (k2 % i == 0) {\n      s.insert(i);\n      s.insert(k2 / i);\n    }\n  }\n  while (!s.empty()) {\n    x = *s.begin();\n    s.erase(x);\n    if (x == 1) continue;\n    for (j = 0; j < n; j++) {\n      if (v[j].first % x && v[j].second % x) break;\n    }\n    if (j == n) {\n      cout << x << endl;\n      return;\n    }\n  }\n  cout << -1 << endl;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long int i, j, l, k, t, n;\n  t = 1;\n  for (i = 1; i <= t; i++) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\n\n\ndef main():\n    input()\n    pp = set()\n    for a in map(int, set(input().split())):\n        for p in 2, 3, 5:\n            if not a % p:\n                pp.add(p)\n                while not a % p:\n                    a //= p\n        p = 7\n        while a >= p * p:\n            for s in 4, 2, 4, 2, 4, 6, 2, 6:\n                pp.add(p)\n                while not a % p:\n                    a //= p\n                p += s\n        if a > 1:\n            pp.add(a)\n    for s in stdin.read().splitlines():\n        a, b = map(int, s.split())\n        a *= b\n        pp = [p for p in pp if not a % p]\n        if not pp:\n            print(-1)\n            return\n    print(max(pp))\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nconst int MX = 123456;\nconst int mod = (int)1e9 + 7;\nconst int base = 1023456789;\nconst unsigned long long BS1 = 10000019ULL;\nconst int INF = (1 << 29);\ntemplate <class T>\ninline void fastScan(T &x) {\n  register char c = getchar();\n  int neg = 0;\n  x = 0;\n  for (; (c < 48 || c > 57) && (c != '-'); c = getchar())\n    ;\n  if (c == '-') {\n    neg = 1;\n    c = getchar();\n  }\n  for (; c > 47 && c < 58; c = getchar()) {\n    x = (x << 1) + (x << 3) + c - 48;\n  }\n  if (neg) x = -x;\n}\nint n;\nbool f_prime[N];\nint prime[N], sz;\nstruct info {\n  long long a, b;\n} inp[N + N];\nint P(long long v) {\n  int ret = 0;\n  for (int i = 1; i <= n; i++) {\n    if (inp[i].a % v == 0 || inp[i].b % v == 0) {\n      ret++;\n    } else {\n      return 0;\n    }\n  }\n  return (ret == n);\n}\nvoid Sieve() {\n  for (int i = 4; i < N; i += 2) f_prime[i] = 1;\n  for (int i = 3; i * i <= N; i += 2) {\n    if (f_prime[i] == 0) {\n      for (int j = i * i; j < N; j += i) {\n        f_prime[j] = 1;\n      }\n    }\n  }\n  prime[++sz] = 2;\n  for (int i = 3; i < N; i += 2) {\n    if (f_prime[i] == 0) {\n      prime[++sz] = i;\n    }\n  }\n}\nlong long Solve(long long v) {\n  for (int i = 1; i <= sz && 1ll * prime[i] * prime[i] <= v; i++) {\n    if (v % prime[i] == 0) {\n      if (P(prime[i])) return prime[i];\n      while (v % prime[i] == 0) v /= prime[i];\n    }\n  }\n  if (v > 1) {\n    if (P(v)) return v;\n  }\n  return -1;\n}\nint main() {\n  fastScan(n);\n  for (int i = 1; i <= n; i++) {\n    fastScan(inp[i].a);\n    fastScan(inp[i].b);\n  }\n  Sieve();\n  long long a = Solve(inp[1].a);\n  long long b = Solve(inp[1].b);\n  long long ans = max(a, b);\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout\nimport math\nn = int(stdin.readline())\npairs = [ tuple(map(int,line.split())) for line in stdin ]\ndef getFactors(n):\n    factors = set()\n    while n%2==0:\n        factors.add(2)\n        n = n//2\n    k=3\n    \n    while k <= math.sqrt(n):\n        if n%k==0:\n            n= n//k\n            factors.add(k)\n        else:\n            k+=2\n    \n    if n>1:\n        factors.add(n)\n    return factors\n\ntab = {  }\n\na,b = pairs[0]\ntab[a] = getFactors(a)\ntab[b] = getFactors(b)\n\ncommon = tab[a] | tab[b]\nfor factor in common:\n    is_div = True\n    for a,b in pairs:\n        if a%factor==0 or b%factor==0:\n            continue\n        else:\n            is_div = False\n            break\n    if is_div:\n        print(factor)\n        exit()\n\nprint(-1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int mygcd(long long int a, long long int b) {\n  if (b == 0)\n    return a;\n  else\n    return mygcd(b, a % b);\n}\nlong long int mylcm(long long int a, long long int b) {\n  return (max(a, b) / mygcd(a, b)) * min(a, b);\n}\nlong long int arr[150010][2];\nint main() {\n  ios::sync_with_stdio(0);\n  long long int n, cur_gcd;\n  cin >> n;\n  cin >> arr[0][0] >> arr[0][1];\n  cur_gcd = mylcm(arr[0][0], arr[0][1]);\n  for (long long int i = 1; i < n; i++) {\n    cin >> arr[i][0] >> arr[i][1];\n    cur_gcd = mygcd(cur_gcd, mylcm(arr[i][0], arr[i][1]));\n  }\n  if (cur_gcd == 1)\n    cout << -1 << endl;\n  else {\n    for (long long int i = 0; i < n && cur_gcd > 1; i++) {\n      long long int gc1 = mygcd(cur_gcd, arr[i][0]),\n                    gc2 = mygcd(cur_gcd, arr[i][1]);\n      if (gc1 > 1)\n        cur_gcd = gc1;\n      else\n        cur_gcd = gc2;\n    }\n    if (cur_gcd == 1) cur_gcd = -1;\n    cout << cur_gcd << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> pq;\nlong long int gcd(long long int a, long long int b) {\n  if (a == 0) return b;\n  return gcd(b % a, a);\n}\nvoid SieveOfEratosthenes(long long int n) {\n  bool prime[n + 1];\n  memset(prime, true, sizeof(prime));\n  for (long long int p = 2; p * p <= n; p++) {\n    if (prime[p] == true) {\n      for (int i = p * 2; i <= n; i += p) prime[i] = false;\n    }\n  }\n  for (long long int p = 2; p <= n; p++) {\n    if (prime[p]) {\n      pq.push_back(p);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  SieveOfEratosthenes((long long int)50000);\n  long long int i, j, k, n, m, t, flag;\n  long long int u, v, w, x, y, z;\n  long long int fir, sec;\n  cin >> n;\n  long long int a[n], b[n];\n  for (int i = 0; i <= n - 1; ++i) {\n    cin >> a[i] >> b[i];\n  }\n  fir = a[0];\n  sec = b[0];\n  k = pq.size();\n  for (i = 0; i < k; i++) {\n    flag = 1;\n    u = pq[i];\n    for (j = 0; j < n; j++) {\n      if (a[j] % u != 0 && b[j] % u != 0) {\n        flag = 0;\n        break;\n      }\n    }\n    if (flag == 1) {\n      cout << u << \"\\n\";\n      return 0;\n    }\n  }\n  for (i = 0; i < k; i++) {\n    u = pq[i];\n    if (fir % u == 0) {\n      while (fir % u == 0) fir /= u;\n    }\n  }\n  flag = 1;\n  for (i = 0; i < n; i++) {\n    if (fir == 1) break;\n    if (a[i] % fir != 0 && b[i] % fir != 0) {\n      flag = 0;\n      break;\n    }\n  }\n  if (flag == 1 && fir > 1) {\n    cout << fir << \"\\n\";\n    return 0;\n  }\n  fir = sec;\n  for (i = 0; i < k; i++) {\n    u = pq[i];\n    if (fir % u == 0) {\n      while (fir % u == 0) fir /= u;\n    }\n  }\n  flag = 1;\n  for (i = 0; i < n; i++) {\n    if (fir == 1) break;\n    if (a[i] % fir != 0 && b[i] % fir != 0) {\n      flag = 0;\n      break;\n    }\n  }\n  if (flag == 1 && fir > 1) {\n    cout << fir << \"\\n\";\n    return 0;\n  }\n  cout << \"-1\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class B {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner in= new FastScanner(System.in);\n\t\tPrintWriter out= new PrintWriter(System.out);\n\t\tint n= in.nextInt();\n\t\tlong [] a= new long[n];\n\t\tlong [] b= new long[n];\n\t\tlong g= 0L;\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\ta[i]= in.nextLong();\n\t\t\tb[i]= in.nextLong();\n\t\t\tg= gcd(g, a[i]*b[i]); \n\t\t}\n\t\tif(g==1) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tlong thing= gcd(g, a[i]);\n\t\t\tif(thing!=1) g= thing;\n\t\t\tthing= gcd(g, b[i]);\n\t\t\tif(thing!=1) g= thing;\n\t\t}\n\t\tSystem.out.println(g);\n\n\t}\n\tpublic static long gcd(long a, long b) {\n\t\treturn b==0 ? a: gcd(b, a%b);\n\t}\n\tstatic class p{\n\t\tint id;\n\t\tint par;\n\t\tpublic p(int a, int b) {\n\t\t\tid= a;\n\t\t\tpar= b;\n\t\t}\n\t}\n\tstatic class FenwickTree {\n\t\tlong[] ft;\n\t\tpublic FenwickTree(int n) {\n\t\t\tft = new long[n + 1];\n\t\t}\n\n\t\tint rsq(int b) {\n\t\t\tint sum = 0;\n\t\t\tfor (; b > 0; b -= (b & (-b)))\n\t\t\t\tsum += ft[b];\n\t\t\treturn sum;\n\t\t}\n\n\t\tint rsq(int a, int b) {\n\t\t\treturn rsq(b) - (a == 1 ? 0 : rsq(a - 1));\n\t\t}\n\n\t\tvoid update(int k, int v) {\n\t\t\tfor (; k < ft.length; k += (k & (-k)))\n\t\t\t\tft[k] += v;\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t\tst = new StringTokenizer(\"\");\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tif (!st.hasMoreTokens()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\treturn next();\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic double nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\ntemplate <class T>\nvoid R(T &x) {\n  cin >> x;\n}\nvoid R(int &x) { scanf(\"%d\", &x); }\nvoid R(long long &x) { scanf(\"%lld\", &x); }\nvoid R(double &x) { scanf(\"%lf\", &x); }\nvoid R(char &x) { scanf(\" %c\", &x); }\nvoid R(char *x) { scanf(\"%s\", x); }\nlong long _pow(long long a, long long b) {\n  long long res = 1ll;\n  while (b) {\n    if (b & 1) res = res * a % 1000000007;\n    a = a * a % 1000000007;\n    b >>= 1;\n  }\n  return res;\n}\nint n;\nlong long a[150005], b[150005];\nconst int mxn = 1e7 + 5;\nbool mark[mxn];\nlong long prime[mxn], tot;\nvoid getPrime() {\n  tot = 0;\n  memset(mark, 1, sizeof(mark));\n  for (int i = 2; i < mxn; i++) {\n    if (mark[i]) prime[tot++] = i;\n    for (int j = 0; (j < tot) && (i * prime[j] < mxn); j++) {\n      mark[i * prime[j]] = 0;\n      if (i % prime[j] == 0) break;\n    }\n  }\n}\nbool check(long long x) {\n  for (int i = 0; i < n; i++)\n    if (a[i] % x && b[i] % x) return 0;\n  return 1;\n}\nint main() {\n  tot = 0;\n  getPrime();\n  R(n);\n  for (int i = 0; i < n; i++) R(a[i]), R(b[i]);\n  set<long long> q;\n  long long x = a[0], y = b[0];\n  for (int i = 0; i < tot && prime[i] < x; i++) {\n    if (x % prime[i] == 0) {\n      q.insert(prime[i]);\n      while (x % prime[i] == 0) x /= prime[i];\n    }\n  }\n  if (x != 1) q.insert(x);\n  for (int i = 0; i < tot && prime[i] < y; i++) {\n    if (y % prime[i] == 0) {\n      q.insert(prime[i]);\n      while (y % prime[i] == 0) y /= prime[i];\n    }\n  }\n  if (y != 1) q.insert(y);\n  long long res = -1;\n  set<long long>::iterator it;\n  for (it = q.begin(); it != q.end(); it++)\n    if (check(*it)) {\n      res = (*it);\n      break;\n    }\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<long long> st;\nvoid getfucktors(long long n) {\n  while (n % 2 == 0) {\n    st.insert(2);\n    n = n / 2;\n  }\n  for (int i = 3; i <= sqrt(n); i = i + 2) {\n    while (n % i == 0) {\n      st.insert(i);\n      n = n / i;\n    }\n  }\n  if (n > 2) st.insert(n);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n, x, y, p = 0;\n  cin >> n;\n  pair<long long, long long> t[n];\n  for (int i = 0; i < n; i++) {\n    cin >> t[i].first >> t[i].second;\n  }\n  getfucktors(t[0].first);\n  getfucktors(t[0].second);\n  for (auto it : st) {\n    p = it;\n    bool ok = true;\n    for (int j = 0; j < n && ok; j++) {\n      if (t[j].first % p != 0 && t[j].second % p != 0) ok = false;\n    }\n    if (ok) return cout << p, 0;\n  }\n  cout << -1;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\ndef primeFactors(n): \n    pf=[]\n    # Print the number of two's that divide n \n    while n % 2 == 0: \n        pf.append(2)        \n        n = n / 2\n          \n    # n must be odd at this point \n    # so a skip of 2 ( i = i + 2) can be used \n    for i in range(3,int(math.sqrt(n))+1,2): \n          \n        # while i divides n , print i ad divide n \n        while n % i== 0: \n            pf.append(int(i))    \n            n = n /i \n              \n    # Condition if n is a prime \n    # number greater than 2 \n    if n > 2: \n        pf.append(int(n))\n    return pf\ndef main():\n    # mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n   \n\n    tc=1\n    for _ in range(tc):\n        n=ri()\n        z=[]\n        for i in range(n):\n            a,b=ria()\n            z.append([a,b])\n        shortlistedanswers=primeFactors(z[0][0])+primeFactors(z[0][1])\n        shortlistedanswers=list(set(shortlistedanswers))\n        c=0\n        for i in shortlistedanswers:\n            c=0\n            for j in z:\n                if j[0]%i!=0 and j[1]%i!=0:\n                    c=1\n                    break\n            if c==0:\n                wi(i)\n                break\n        if c==1:\n            wi(-1)        \n\n                    \n                \n        \n        \n            \n                \n        \n\n            \n        \n\n               \n            \n        \n              \n                \n        \n        \n            \n        \n        \n            \n            \n        \n        \n                \n                \n                \n                \n            \n        \n        \n            \n           \n        \n            \n                    \n\n                                 \n                \n                \n        \n\n                \n        \n        \n        \n            \n        \n        \n                \n            \n        \n        \n                    \n        \n        \n        \n            \n                    \n            \n\n                \n            \n            \n                \n            \n                \n            \n            \n            \n            \n                \n            \n        \n        \n        \n        \n        \n        \n        \n                    \n        \n        \n        \n                \n                \n        \n            \n            \n            \n        \n\n                    \n        \n                \n        \n        \n                        \n        \n                            \n\n        \n\n                \n            \n        \n\n                \n            \n                    \n                \n                \n        \n        \n         \n        \n\n                        \n                            \n                \n        \n                            \n                    \n\n                \n            \n        \n                \n            \n                \n        \n        \n        \n                             \n        \n            \n        \n        \n            \n                        \n                        \n                    \n            \n        \n        \n        \n        \n        \n                        \n       \n\n        \n                           \n        \n        \n        \n            \n        \n        \n        \n                      \n\n      \n                            \n            \n        \n        \n            \n            \n            \n            \n            \n        \n        \n        \n            \n        \n        \n        \n            \n        \n        \n        \n        \n            \n            \n        \n        \n        \n        \n        \n        \n        \n                \n                \n                    \n        \n        \n            \n            \n        \n                \n            \n            \n        \n        \n        \n        \n                \n        \n            \n        \n                \n        \n        \n            \n        \n       \n            \n\n                \n        \n        \n        \n   \n            \n        \n        \n        \n        \n            \n        \n                \n        \n        \n        \n            \n            \n        \n        \n            \n        \n        \n\n        \n        \n            \n        \n        \n            \n        \n                        \n\n        \n        \n            \n     \n        \n        \n            \n        \n        \n                \n            \n        \n        \n        \n                \n            \n        \n\n            \n             \n        \n            \n        \n        \n        \n                \n        \n            \n        \n        \n        \n        \n                \n        \n        \n            \n        \n        \n        \n        \n                \n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint va[150010], vb[150010], n;\nint check(int x) {\n  for (int i = 1; i <= n; i++)\n    if (va[i] % x && vb[i] % x) return 0;\n  return 1;\n}\nint solve(int a) {\n  for (int i = 2; 1LL * i * i <= a; i++)\n    if (a % i == 0) {\n      if (check(i)) return i;\n      for (; a % i == 0; a /= i)\n        ;\n    }\n  if (a > 1 && check(a)) return a;\n  return 0;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &va[i], &vb[i]);\n  int x = solve(va[1]);\n  if (x)\n    printf(\"%d\", x);\n  else {\n    x = solve(vb[1]);\n    if (x)\n      printf(\"%d\", x);\n    else\n      printf(\"-1\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid fun() {}\nint32_t main() {\n  fun();\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long n, i, j, num, temp, x;\n  set<long long> s;\n  cin >> n;\n  long long a[n][2];\n  for (i = 0; i < n; i++) {\n    cin >> a[i][0] >> a[i][1];\n  }\n  x = a[0][0];\n  if (x != 1) s.insert(x);\n  for (i = 2; i * i <= x; i++) {\n    while (x % i == 0) {\n      x /= i;\n      s.insert(i);\n    }\n  }\n  if (x != 1) s.insert(x);\n  x = a[0][1];\n  if (x != 1) s.insert(x);\n  for (i = 2; i * i <= x; i++) {\n    while (x % i == 0) {\n      x /= i;\n      s.insert(i);\n    }\n  }\n  if (x != 1) s.insert(x);\n  auto it = s.begin();\n  while (it != s.end()) {\n    num = (*it);\n    temp = 0;\n    for (i = 0; i < n; i++) {\n      if (a[i][0] % num != 0 && a[i][1] % num != 0) {\n        temp = 1;\n        break;\n      }\n    }\n    if (temp == 0) {\n      cout << num;\n      return 0;\n    }\n    it++;\n  }\n  cout << -1;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst int N = 2e5 + 10;\nint a[N], b[N], pri[2000];\nint main() {\n  int n, m, mm, tem;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &a[i], &b[i]);\n  tem = a[1];\n  m = 0;\n  for (int i = 1; i * i <= tem; i++) {\n    if (tem % i == 0) {\n      pri[++m] = i;\n      pri[++m] = tem / i;\n    }\n  }\n  tem = b[1];\n  for (int i = 1; i * i <= tem; i++) {\n    if (tem % i == 0) {\n      pri[++m] = i;\n      pri[++m] = tem / i;\n    }\n  }\n  sort(pri + 1, pri + m + 1);\n  mm = 1;\n  for (int i = 2; i <= m; i++) {\n    if (pri[i] != pri[i - 1]) pri[++mm] = pri[i];\n  }\n  m = mm;\n  for (int i = m; i > 1; i--) {\n    bool flag = true;\n    for (int j = 2; j <= n; j++) {\n      if (a[j] % pri[i] && b[j] % pri[i]) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) {\n      printf(\"%d\\n\", pri[i]);\n      return 0;\n    }\n  }\n  printf(\"-1\\n\");\n}\n"
        },
        {
            "language": 4,
            "solution": "// package Mathematical;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class WeakenedCommonDivisor {\n    public static void main(String[] args)throws IOException {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        int seive[]=new int[100001];\n        ArrayList<Integer> primes=new ArrayList<>();\n        for(int i=2;i<=100000;i++){\n            if(seive[i]==0){\n                primes.add(i);\n                for(int j=2*i;j<=100000;j+=i){\n                    seive[j]=1;\n                }\n            }\n        }\n        Set<Integer> ans=new HashSet<>();\n//        System.out.println(primes.size());\n        for(int i=1;i<=n;i++){\n            String line[]=br.readLine().split(\" \");\n            int x=Integer.parseInt(line[0]);\n            int y=Integer.parseInt(line[1]);\n//            System.out.println(ans.toString());\n            if(i==1){\n                for(int j=0;j<primes.size();j++){\n                    int prime=primes.get(j);\n                    boolean flag=false;\n                    while (x%prime==0){\n                        x/=prime;\n                        flag=true;\n                    }\n                    if(flag){\n                        ans.add(prime);\n                    }\n                    flag=false;\n                    while(y%prime==0){\n                        y/=prime;\n                        flag=true;\n                    }\n                    if(flag){\n                        ans.add(prime);\n                    }\n                    if(x==1&&y==1){\n                        break;\n                    }\n                }\n                if(x!=1){\n                    ans.add(x);\n                }\n                if(y!=1){\n                    ans.add(y);\n                }\n            }\n            else{\n                Set<Integer> temp=new HashSet<>();\n                for(int k:ans){\n                    if(x%k==0||y%k==0){\n                        temp.add(k);\n                    }\n                }\n                ans=temp;\n            }\n        }\n        if(ans.size()==0){\n            System.out.println(\"-1\");\n        }\n        else{\n            for(int k:ans){\n                System.out.println(k);\n                return;\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "def primes(n):\n    d = 2\n    while d*d <= n:\n        while (n % d) == 0:\n            primfac.add(d)\n            n //= d\n        d += 1\n    if n > 1:\n       primfac.add(n)\n    return primfac\n\n\n\nn = int(input())\npairs = []\nfor i in range(n):\n    pairs.append([int(i) for i in input().split()])\nprimfac = set()\nprimes(pairs[0][0])\nprimes(pairs[0][1])\nfor i in range(n - 1):\n    to_delete = []\n    for j in primfac:\n        if pairs[i + 1][0] % j != 0 and pairs[i + 1][1] % j != 0:\n            to_delete.append(j)\n    for j in to_delete:\n        primfac.remove(j)\n\nli = list(primfac)\nif len(li) == 0:\n    print(-1)\nelse:\n    print(li[-1])\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[] = {0, 1, 0, -1, -1, 1, 1, -1};\nint dy[] = {1, 0, -1, 0, -1, -1, 1, 1};\nint kx[] = {-2, -2, -1, 1, 2, 2, 1, -1};\nint ky[] = {-1, 1, 2, 2, 1, -1, -2, -2};\ninline long long gcd(long long a, long long b) {\n  a = fabs(a);\n  b = fabs(b);\n  while (b) {\n    a = a % b;\n    swap(a, b);\n  }\n  return a;\n}\ninline long long bigmod(long long a, long long p, long long m) {\n  long long res = 1 % m, x = a % m;\n  while (p) {\n    if (p & 1) res = (res * x) % m;\n    x = (x * x) % m;\n    p >>= 1;\n  }\n  return res;\n}\nstruct DATA {\n  long long a, b;\n};\nvector<DATA> arr;\nset<long long> s;\nint main() {\n  long long n;\n  scanf(\"%lld\", &n);\n  for (int i = (int)(1); i <= (int)(n); i++) {\n    long long x, y;\n    scanf(\"%lld %lld\", &x, &y);\n    arr.push_back({x, y});\n  }\n  if (n == 1) {\n    cout << arr[0].a << endl;\n    exit(0);\n  }\n  for (int i = 2; i * i <= arr[0].a; i++) {\n    if (arr[0].a % i == 0) {\n      while (arr[0].a % i == 0) arr[0].a /= i;\n      s.insert(i);\n      s.insert(arr[0].a / i);\n    }\n  }\n  if (arr[0].a > 1) s.insert(arr[0].a);\n  for (int i = 2; i * i <= arr[0].b; i++) {\n    if (arr[0].b % i == 0) {\n      while (arr[0].b % i == 0) arr[0].b /= i;\n      s.insert(i);\n      s.insert(arr[0].b / i);\n    }\n  }\n  if (arr[0].b > 1) s.insert(arr[0].b);\n  for (set<long long>::iterator it = s.begin(); it != s.end(); it++) {\n    bool found = 1;\n    long long x = *it;\n    if (x == 0) continue;\n    for (int j = (int)(1); j <= (int)(arr.size() - 1); j++) {\n      long long val1 = arr[j].a;\n      long long val2 = arr[j].b;\n      if (val1 % x != 0 and val2 % x != 0) {\n        found = 0;\n        break;\n      }\n    }\n    if (found and x > 1) {\n      cout << x << endl;\n      exit(0);\n    }\n  }\n  cout << \"-1\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint primes[] = {\n    2,     3,     5,     7,     11,    13,    17,    19,    23,    29,    31,\n    37,    41,    43,    47,    53,    59,    61,    67,    71,    73,    79,\n    83,    89,    97,    101,   103,   107,   109,   113,   127,   131,   137,\n    139,   149,   151,   157,   163,   167,   173,   179,   181,   191,   193,\n    197,   199,   211,   223,   227,   229,   233,   239,   241,   251,   257,\n    263,   269,   271,   277,   281,   283,   293,   307,   311,   313,   317,\n    331,   337,   347,   349,   353,   359,   367,   373,   379,   383,   389,\n    397,   401,   409,   419,   421,   431,   433,   439,   443,   449,   457,\n    461,   463,   467,   479,   487,   491,   499,   503,   509,   521,   523,\n    541,   547,   557,   563,   569,   571,   577,   587,   593,   599,   601,\n    607,   613,   617,   619,   631,   641,   643,   647,   653,   659,   661,\n    673,   677,   683,   691,   701,   709,   719,   727,   733,   739,   743,\n    751,   757,   761,   769,   773,   787,   797,   809,   811,   821,   823,\n    827,   829,   839,   853,   857,   859,   863,   877,   881,   883,   887,\n    907,   911,   919,   929,   937,   941,   947,   953,   967,   971,   977,\n    983,   991,   997,   1009,  1013,  1019,  1021,  1031,  1033,  1039,  1049,\n    1051,  1061,  1063,  1069,  1087,  1091,  1093,  1097,  1103,  1109,  1117,\n    1123,  1129,  1151,  1153,  1163,  1171,  1181,  1187,  1193,  1201,  1213,\n    1217,  1223,  1229,  1231,  1237,  1249,  1259,  1277,  1279,  1283,  1289,\n    1291,  1297,  1301,  1303,  1307,  1319,  1321,  1327,  1361,  1367,  1373,\n    1381,  1399,  1409,  1423,  1427,  1429,  1433,  1439,  1447,  1451,  1453,\n    1459,  1471,  1481,  1483,  1487,  1489,  1493,  1499,  1511,  1523,  1531,\n    1543,  1549,  1553,  1559,  1567,  1571,  1579,  1583,  1597,  1601,  1607,\n    1609,  1613,  1619,  1621,  1627,  1637,  1657,  1663,  1667,  1669,  1693,\n    1697,  1699,  1709,  1721,  1723,  1733,  1741,  1747,  1753,  1759,  1777,\n    1783,  1787,  1789,  1801,  1811,  1823,  1831,  1847,  1861,  1867,  1871,\n    1873,  1877,  1879,  1889,  1901,  1907,  1913,  1931,  1933,  1949,  1951,\n    1973,  1979,  1987,  1993,  1997,  1999,  2003,  2011,  2017,  2027,  2029,\n    2039,  2053,  2063,  2069,  2081,  2083,  2087,  2089,  2099,  2111,  2113,\n    2129,  2131,  2137,  2141,  2143,  2153,  2161,  2179,  2203,  2207,  2213,\n    2221,  2237,  2239,  2243,  2251,  2267,  2269,  2273,  2281,  2287,  2293,\n    2297,  2309,  2311,  2333,  2339,  2341,  2347,  2351,  2357,  2371,  2377,\n    2381,  2383,  2389,  2393,  2399,  2411,  2417,  2423,  2437,  2441,  2447,\n    2459,  2467,  2473,  2477,  2503,  2521,  2531,  2539,  2543,  2549,  2551,\n    2557,  2579,  2591,  2593,  2609,  2617,  2621,  2633,  2647,  2657,  2659,\n    2663,  2671,  2677,  2683,  2687,  2689,  2693,  2699,  2707,  2711,  2713,\n    2719,  2729,  2731,  2741,  2749,  2753,  2767,  2777,  2789,  2791,  2797,\n    2801,  2803,  2819,  2833,  2837,  2843,  2851,  2857,  2861,  2879,  2887,\n    2897,  2903,  2909,  2917,  2927,  2939,  2953,  2957,  2963,  2969,  2971,\n    2999,  3001,  3011,  3019,  3023,  3037,  3041,  3049,  3061,  3067,  3079,\n    3083,  3089,  3109,  3119,  3121,  3137,  3163,  3167,  3169,  3181,  3187,\n    3191,  3203,  3209,  3217,  3221,  3229,  3251,  3253,  3257,  3259,  3271,\n    3299,  3301,  3307,  3313,  3319,  3323,  3329,  3331,  3343,  3347,  3359,\n    3361,  3371,  3373,  3389,  3391,  3407,  3413,  3433,  3449,  3457,  3461,\n    3463,  3467,  3469,  3491,  3499,  3511,  3517,  3527,  3529,  3533,  3539,\n    3541,  3547,  3557,  3559,  3571,  3581,  3583,  3593,  3607,  3613,  3617,\n    3623,  3631,  3637,  3643,  3659,  3671,  3673,  3677,  3691,  3697,  3701,\n    3709,  3719,  3727,  3733,  3739,  3761,  3767,  3769,  3779,  3793,  3797,\n    3803,  3821,  3823,  3833,  3847,  3851,  3853,  3863,  3877,  3881,  3889,\n    3907,  3911,  3917,  3919,  3923,  3929,  3931,  3943,  3947,  3967,  3989,\n    4001,  4003,  4007,  4013,  4019,  4021,  4027,  4049,  4051,  4057,  4073,\n    4079,  4091,  4093,  4099,  4111,  4127,  4129,  4133,  4139,  4153,  4157,\n    4159,  4177,  4201,  4211,  4217,  4219,  4229,  4231,  4241,  4243,  4253,\n    4259,  4261,  4271,  4273,  4283,  4289,  4297,  4327,  4337,  4339,  4349,\n    4357,  4363,  4373,  4391,  4397,  4409,  4421,  4423,  4441,  4447,  4451,\n    4457,  4463,  4481,  4483,  4493,  4507,  4513,  4517,  4519,  4523,  4547,\n    4549,  4561,  4567,  4583,  4591,  4597,  4603,  4621,  4637,  4639,  4643,\n    4649,  4651,  4657,  4663,  4673,  4679,  4691,  4703,  4721,  4723,  4729,\n    4733,  4751,  4759,  4783,  4787,  4789,  4793,  4799,  4801,  4813,  4817,\n    4831,  4861,  4871,  4877,  4889,  4903,  4909,  4919,  4931,  4933,  4937,\n    4943,  4951,  4957,  4967,  4969,  4973,  4987,  4993,  4999,  5003,  5009,\n    5011,  5021,  5023,  5039,  5051,  5059,  5077,  5081,  5087,  5099,  5101,\n    5107,  5113,  5119,  5147,  5153,  5167,  5171,  5179,  5189,  5197,  5209,\n    5227,  5231,  5233,  5237,  5261,  5273,  5279,  5281,  5297,  5303,  5309,\n    5323,  5333,  5347,  5351,  5381,  5387,  5393,  5399,  5407,  5413,  5417,\n    5419,  5431,  5437,  5441,  5443,  5449,  5471,  5477,  5479,  5483,  5501,\n    5503,  5507,  5519,  5521,  5527,  5531,  5557,  5563,  5569,  5573,  5581,\n    5591,  5623,  5639,  5641,  5647,  5651,  5653,  5657,  5659,  5669,  5683,\n    5689,  5693,  5701,  5711,  5717,  5737,  5741,  5743,  5749,  5779,  5783,\n    5791,  5801,  5807,  5813,  5821,  5827,  5839,  5843,  5849,  5851,  5857,\n    5861,  5867,  5869,  5879,  5881,  5897,  5903,  5923,  5927,  5939,  5953,\n    5981,  5987,  6007,  6011,  6029,  6037,  6043,  6047,  6053,  6067,  6073,\n    6079,  6089,  6091,  6101,  6113,  6121,  6131,  6133,  6143,  6151,  6163,\n    6173,  6197,  6199,  6203,  6211,  6217,  6221,  6229,  6247,  6257,  6263,\n    6269,  6271,  6277,  6287,  6299,  6301,  6311,  6317,  6323,  6329,  6337,\n    6343,  6353,  6359,  6361,  6367,  6373,  6379,  6389,  6397,  6421,  6427,\n    6449,  6451,  6469,  6473,  6481,  6491,  6521,  6529,  6547,  6551,  6553,\n    6563,  6569,  6571,  6577,  6581,  6599,  6607,  6619,  6637,  6653,  6659,\n    6661,  6673,  6679,  6689,  6691,  6701,  6703,  6709,  6719,  6733,  6737,\n    6761,  6763,  6779,  6781,  6791,  6793,  6803,  6823,  6827,  6829,  6833,\n    6841,  6857,  6863,  6869,  6871,  6883,  6899,  6907,  6911,  6917,  6947,\n    6949,  6959,  6961,  6967,  6971,  6977,  6983,  6991,  6997,  7001,  7013,\n    7019,  7027,  7039,  7043,  7057,  7069,  7079,  7103,  7109,  7121,  7127,\n    7129,  7151,  7159,  7177,  7187,  7193,  7207,  7211,  7213,  7219,  7229,\n    7237,  7243,  7247,  7253,  7283,  7297,  7307,  7309,  7321,  7331,  7333,\n    7349,  7351,  7369,  7393,  7411,  7417,  7433,  7451,  7457,  7459,  7477,\n    7481,  7487,  7489,  7499,  7507,  7517,  7523,  7529,  7537,  7541,  7547,\n    7549,  7559,  7561,  7573,  7577,  7583,  7589,  7591,  7603,  7607,  7621,\n    7639,  7643,  7649,  7669,  7673,  7681,  7687,  7691,  7699,  7703,  7717,\n    7723,  7727,  7741,  7753,  7757,  7759,  7789,  7793,  7817,  7823,  7829,\n    7841,  7853,  7867,  7873,  7877,  7879,  7883,  7901,  7907,  7919,  7927,\n    7933,  7937,  7949,  7951,  7963,  7993,  8009,  8011,  8017,  8039,  8053,\n    8059,  8069,  8081,  8087,  8089,  8093,  8101,  8111,  8117,  8123,  8147,\n    8161,  8167,  8171,  8179,  8191,  8209,  8219,  8221,  8231,  8233,  8237,\n    8243,  8263,  8269,  8273,  8287,  8291,  8293,  8297,  8311,  8317,  8329,\n    8353,  8363,  8369,  8377,  8387,  8389,  8419,  8423,  8429,  8431,  8443,\n    8447,  8461,  8467,  8501,  8513,  8521,  8527,  8537,  8539,  8543,  8563,\n    8573,  8581,  8597,  8599,  8609,  8623,  8627,  8629,  8641,  8647,  8663,\n    8669,  8677,  8681,  8689,  8693,  8699,  8707,  8713,  8719,  8731,  8737,\n    8741,  8747,  8753,  8761,  8779,  8783,  8803,  8807,  8819,  8821,  8831,\n    8837,  8839,  8849,  8861,  8863,  8867,  8887,  8893,  8923,  8929,  8933,\n    8941,  8951,  8963,  8969,  8971,  8999,  9001,  9007,  9011,  9013,  9029,\n    9041,  9043,  9049,  9059,  9067,  9091,  9103,  9109,  9127,  9133,  9137,\n    9151,  9157,  9161,  9173,  9181,  9187,  9199,  9203,  9209,  9221,  9227,\n    9239,  9241,  9257,  9277,  9281,  9283,  9293,  9311,  9319,  9323,  9337,\n    9341,  9343,  9349,  9371,  9377,  9391,  9397,  9403,  9413,  9419,  9421,\n    9431,  9433,  9437,  9439,  9461,  9463,  9467,  9473,  9479,  9491,  9497,\n    9511,  9521,  9533,  9539,  9547,  9551,  9587,  9601,  9613,  9619,  9623,\n    9629,  9631,  9643,  9649,  9661,  9677,  9679,  9689,  9697,  9719,  9721,\n    9733,  9739,  9743,  9749,  9767,  9769,  9781,  9787,  9791,  9803,  9811,\n    9817,  9829,  9833,  9839,  9851,  9857,  9859,  9871,  9883,  9887,  9901,\n    9907,  9923,  9929,  9931,  9941,  9949,  9967,  9973,  10007, 10009, 10037,\n    10039, 10061, 10067, 10069, 10079, 10091, 10093, 10099, 10103, 10111, 10133,\n    10139, 10141, 10151, 10159, 10163, 10169, 10177, 10181, 10193, 10211, 10223,\n    10243, 10247, 10253, 10259, 10267, 10271, 10273, 10289, 10301, 10303, 10313,\n    10321, 10331, 10333, 10337, 10343, 10357, 10369, 10391, 10399, 10427, 10429,\n    10433, 10453, 10457, 10459, 10463, 10477, 10487, 10499, 10501, 10513, 10529,\n    10531, 10559, 10567, 10589, 10597, 10601, 10607, 10613, 10627, 10631, 10639,\n    10651, 10657, 10663, 10667, 10687, 10691, 10709, 10711, 10723, 10729, 10733,\n    10739, 10753, 10771, 10781, 10789, 10799, 10831, 10837, 10847, 10853, 10859,\n    10861, 10867, 10883, 10889, 10891, 10903, 10909, 10937, 10939, 10949, 10957,\n    10973, 10979, 10987, 10993, 11003, 11027, 11047, 11057, 11059, 11069, 11071,\n    11083, 11087, 11093, 11113, 11117, 11119, 11131, 11149, 11159, 11161, 11171,\n    11173, 11177, 11197, 11213, 11239, 11243, 11251, 11257, 11261, 11273, 11279,\n    11287, 11299, 11311, 11317, 11321, 11329, 11351, 11353, 11369, 11383, 11393,\n    11399, 11411, 11423, 11437, 11443, 11447, 11467, 11471, 11483, 11489, 11491,\n    11497, 11503, 11519, 11527, 11549, 11551, 11579, 11587, 11593, 11597, 11617,\n    11621, 11633, 11657, 11677, 11681, 11689, 11699, 11701, 11717, 11719, 11731,\n    11743, 11777, 11779, 11783, 11789, 11801, 11807, 11813, 11821, 11827, 11831,\n    11833, 11839, 11863, 11867, 11887, 11897, 11903, 11909, 11923, 11927, 11933,\n    11939, 11941, 11953, 11959, 11969, 11971, 11981, 11987, 12007, 12011, 12037,\n    12041, 12043, 12049, 12071, 12073, 12097, 12101, 12107, 12109, 12113, 12119,\n    12143, 12149, 12157, 12161, 12163, 12197, 12203, 12211, 12227, 12239, 12241,\n    12251, 12253, 12263, 12269, 12277, 12281, 12289, 12301, 12323, 12329, 12343,\n    12347, 12373, 12377, 12379, 12391, 12401, 12409, 12413, 12421, 12433, 12437,\n    12451, 12457, 12473, 12479, 12487, 12491, 12497, 12503, 12511, 12517, 12527,\n    12539, 12541, 12547, 12553, 12569, 12577, 12583, 12589, 12601, 12611, 12613,\n    12619, 12637, 12641, 12647, 12653, 12659, 12671, 12689, 12697, 12703, 12713,\n    12721, 12739, 12743, 12757, 12763, 12781, 12791, 12799, 12809, 12821, 12823,\n    12829, 12841, 12853, 12889, 12893, 12899, 12907, 12911, 12917, 12919, 12923,\n    12941, 12953, 12959, 12967, 12973, 12979, 12983, 13001, 13003, 13007, 13009,\n    13033, 13037, 13043, 13049, 13063, 13093, 13099, 13103, 13109, 13121, 13127,\n    13147, 13151, 13159, 13163, 13171, 13177, 13183, 13187, 13217, 13219, 13229,\n    13241, 13249, 13259, 13267, 13291, 13297, 13309, 13313, 13327, 13331, 13337,\n    13339, 13367, 13381, 13397, 13399, 13411, 13417, 13421, 13441, 13451, 13457,\n    13463, 13469, 13477, 13487, 13499, 13513, 13523, 13537, 13553, 13567, 13577,\n    13591, 13597, 13613, 13619, 13627, 13633, 13649, 13669, 13679, 13681, 13687,\n    13691, 13693, 13697, 13709, 13711, 13721, 13723, 13729, 13751, 13757, 13759,\n    13763, 13781, 13789, 13799, 13807, 13829, 13831, 13841, 13859, 13873, 13877,\n    13879, 13883, 13901, 13903, 13907, 13913, 13921, 13931, 13933, 13963, 13967,\n    13997, 13999, 14009, 14011, 14029, 14033, 14051, 14057, 14071, 14081, 14083,\n    14087, 14107, 14143, 14149, 14153, 14159, 14173, 14177, 14197, 14207, 14221,\n    14243, 14249, 14251, 14281, 14293, 14303, 14321, 14323, 14327, 14341, 14347,\n    14369, 14387, 14389, 14401, 14407, 14411, 14419, 14423, 14431, 14437, 14447,\n    14449, 14461, 14479, 14489, 14503, 14519, 14533, 14537, 14543, 14549, 14551,\n    14557, 14561, 14563, 14591, 14593, 14621, 14627, 14629, 14633, 14639, 14653,\n    14657, 14669, 14683, 14699, 14713, 14717, 14723, 14731, 14737, 14741, 14747,\n    14753, 14759, 14767, 14771, 14779, 14783, 14797, 14813, 14821, 14827, 14831,\n    14843, 14851, 14867, 14869, 14879, 14887, 14891, 14897, 14923, 14929, 14939,\n    14947, 14951, 14957, 14969, 14983, 15013, 15017, 15031, 15053, 15061, 15073,\n    15077, 15083, 15091, 15101, 15107, 15121, 15131, 15137, 15139, 15149, 15161,\n    15173, 15187, 15193, 15199, 15217, 15227, 15233, 15241, 15259, 15263, 15269,\n    15271, 15277, 15287, 15289, 15299, 15307, 15313, 15319, 15329, 15331, 15349,\n    15359, 15361, 15373, 15377, 15383, 15391, 15401, 15413, 15427, 15439, 15443,\n    15451, 15461, 15467, 15473, 15493, 15497, 15511, 15527, 15541, 15551, 15559,\n    15569, 15581, 15583, 15601, 15607, 15619, 15629, 15641, 15643, 15647, 15649,\n    15661, 15667, 15671, 15679, 15683, 15727, 15731, 15733, 15737, 15739, 15749,\n    15761, 15767, 15773, 15787, 15791, 15797, 15803, 15809, 15817, 15823, 15859,\n    15877, 15881, 15887, 15889, 15901, 15907, 15913, 15919, 15923, 15937, 15959,\n    15971, 15973, 15991, 16001, 16007, 16033, 16057, 16061, 16063, 16067, 16069,\n    16073, 16087, 16091, 16097, 16103, 16111, 16127, 16139, 16141, 16183, 16187,\n    16189, 16193, 16217, 16223, 16229, 16231, 16249, 16253, 16267, 16273, 16301,\n    16319, 16333, 16339, 16349, 16361, 16363, 16369, 16381, 16411, 16417, 16421,\n    16427, 16433, 16447, 16451, 16453, 16477, 16481, 16487, 16493, 16519, 16529,\n    16547, 16553, 16561, 16567, 16573, 16603, 16607, 16619, 16631, 16633, 16649,\n    16651, 16657, 16661, 16673, 16691, 16693, 16699, 16703, 16729, 16741, 16747,\n    16759, 16763, 16787, 16811, 16823, 16829, 16831, 16843, 16871, 16879, 16883,\n    16889, 16901, 16903, 16921, 16927, 16931, 16937, 16943, 16963, 16979, 16981,\n    16987, 16993, 17011, 17021, 17027, 17029, 17033, 17041, 17047, 17053, 17077,\n    17093, 17099, 17107, 17117, 17123, 17137, 17159, 17167, 17183, 17189, 17191,\n    17203, 17207, 17209, 17231, 17239, 17257, 17291, 17293, 17299, 17317, 17321,\n    17327, 17333, 17341, 17351, 17359, 17377, 17383, 17387, 17389, 17393, 17401,\n    17417, 17419, 17431, 17443, 17449, 17467, 17471, 17477, 17483, 17489, 17491,\n    17497, 17509, 17519, 17539, 17551, 17569, 17573, 17579, 17581, 17597, 17599,\n    17609, 17623, 17627, 17657, 17659, 17669, 17681, 17683, 17707, 17713, 17729,\n    17737, 17747, 17749, 17761, 17783, 17789, 17791, 17807, 17827, 17837, 17839,\n    17851, 17863, 17881, 17891, 17903, 17909, 17911, 17921, 17923, 17929, 17939,\n    17957, 17959, 17971, 17977, 17981, 17987, 17989, 18013, 18041, 18043, 18047,\n    18049, 18059, 18061, 18077, 18089, 18097, 18119, 18121, 18127, 18131, 18133,\n    18143, 18149, 18169, 18181, 18191, 18199, 18211, 18217, 18223, 18229, 18233,\n    18251, 18253, 18257, 18269, 18287, 18289, 18301, 18307, 18311, 18313, 18329,\n    18341, 18353, 18367, 18371, 18379, 18397, 18401, 18413, 18427, 18433, 18439,\n    18443, 18451, 18457, 18461, 18481, 18493, 18503, 18517, 18521, 18523, 18539,\n    18541, 18553, 18583, 18587, 18593, 18617, 18637, 18661, 18671, 18679, 18691,\n    18701, 18713, 18719, 18731, 18743, 18749, 18757, 18773, 18787, 18793, 18797,\n    18803, 18839, 18859, 18869, 18899, 18911, 18913, 18917, 18919, 18947, 18959,\n    18973, 18979, 19001, 19009, 19013, 19031, 19037, 19051, 19069, 19073, 19079,\n    19081, 19087, 19121, 19139, 19141, 19157, 19163, 19181, 19183, 19207, 19211,\n    19213, 19219, 19231, 19237, 19249, 19259, 19267, 19273, 19289, 19301, 19309,\n    19319, 19333, 19373, 19379, 19381, 19387, 19391, 19403, 19417, 19421, 19423,\n    19427, 19429, 19433, 19441, 19447, 19457, 19463, 19469, 19471, 19477, 19483,\n    19489, 19501, 19507, 19531, 19541, 19543, 19553, 19559, 19571, 19577, 19583,\n    19597, 19603, 19609, 19661, 19681, 19687, 19697, 19699, 19709, 19717, 19727,\n    19739, 19751, 19753, 19759, 19763, 19777, 19793, 19801, 19813, 19819, 19841,\n    19843, 19853, 19861, 19867, 19889, 19891, 19913, 19919, 19927, 19937, 19949,\n    19961, 19963, 19973, 19979, 19991, 19993, 19997, 20011, 20021, 20023, 20029,\n    20047, 20051, 20063, 20071, 20089, 20101, 20107, 20113, 20117, 20123, 20129,\n    20143, 20147, 20149, 20161, 20173, 20177, 20183, 20201, 20219, 20231, 20233,\n    20249, 20261, 20269, 20287, 20297, 20323, 20327, 20333, 20341, 20347, 20353,\n    20357, 20359, 20369, 20389, 20393, 20399, 20407, 20411, 20431, 20441, 20443,\n    20477, 20479, 20483, 20507, 20509, 20521, 20533, 20543, 20549, 20551, 20563,\n    20593, 20599, 20611, 20627, 20639, 20641, 20663, 20681, 20693, 20707, 20717,\n    20719, 20731, 20743, 20747, 20749, 20753, 20759, 20771, 20773, 20789, 20807,\n    20809, 20849, 20857, 20873, 20879, 20887, 20897, 20899, 20903, 20921, 20929,\n    20939, 20947, 20959, 20963, 20981, 20983, 21001, 21011, 21013, 21017, 21019,\n    21023, 21031, 21059, 21061, 21067, 21089, 21101, 21107, 21121, 21139, 21143,\n    21149, 21157, 21163, 21169, 21179, 21187, 21191, 21193, 21211, 21221, 21227,\n    21247, 21269, 21277, 21283, 21313, 21317, 21319, 21323, 21341, 21347, 21377,\n    21379, 21383, 21391, 21397, 21401, 21407, 21419, 21433, 21467, 21481, 21487,\n    21491, 21493, 21499, 21503, 21517, 21521, 21523, 21529, 21557, 21559, 21563,\n    21569, 21577, 21587, 21589, 21599, 21601, 21611, 21613, 21617, 21647, 21649,\n    21661, 21673, 21683, 21701, 21713, 21727, 21737, 21739, 21751, 21757, 21767,\n    21773, 21787, 21799, 21803, 21817, 21821, 21839, 21841, 21851, 21859, 21863,\n    21871, 21881, 21893, 21911, 21929, 21937, 21943, 21961, 21977, 21991, 21997,\n    22003, 22013, 22027, 22031, 22037, 22039, 22051, 22063, 22067, 22073, 22079,\n    22091, 22093, 22109, 22111, 22123, 22129, 22133, 22147, 22153, 22157, 22159,\n    22171, 22189, 22193, 22229, 22247, 22259, 22271, 22273, 22277, 22279, 22283,\n    22291, 22303, 22307, 22343, 22349, 22367, 22369, 22381, 22391, 22397, 22409,\n    22433, 22441, 22447, 22453, 22469, 22481, 22483, 22501, 22511, 22531, 22541,\n    22543, 22549, 22567, 22571, 22573, 22613, 22619, 22621, 22637, 22639, 22643,\n    22651, 22669, 22679, 22691, 22697, 22699, 22709, 22717, 22721, 22727, 22739,\n    22741, 22751, 22769, 22777, 22783, 22787, 22807, 22811, 22817, 22853, 22859,\n    22861, 22871, 22877, 22901, 22907, 22921, 22937, 22943, 22961, 22963, 22973,\n    22993, 23003, 23011, 23017, 23021, 23027, 23029, 23039, 23041, 23053, 23057,\n    23059, 23063, 23071, 23081, 23087, 23099, 23117, 23131, 23143, 23159, 23167,\n    23173, 23189, 23197, 23201, 23203, 23209, 23227, 23251, 23269, 23279, 23291,\n    23293, 23297, 23311, 23321, 23327, 23333, 23339, 23357, 23369, 23371, 23399,\n    23417, 23431, 23447, 23459, 23473, 23497, 23509, 23531, 23537, 23539, 23549,\n    23557, 23561, 23563, 23567, 23581, 23593, 23599, 23603, 23609, 23623, 23627,\n    23629, 23633, 23663, 23669, 23671, 23677, 23687, 23689, 23719, 23741, 23743,\n    23747, 23753, 23761, 23767, 23773, 23789, 23801, 23813, 23819, 23827, 23831,\n    23833, 23857, 23869, 23873, 23879, 23887, 23893, 23899, 23909, 23911, 23917,\n    23929, 23957, 23971, 23977, 23981, 23993, 24001, 24007, 24019, 24023, 24029,\n    24043, 24049, 24061, 24071, 24077, 24083, 24091, 24097, 24103, 24107, 24109,\n    24113, 24121, 24133, 24137, 24151, 24169, 24179, 24181, 24197, 24203, 24223,\n    24229, 24239, 24247, 24251, 24281, 24317, 24329, 24337, 24359, 24371, 24373,\n    24379, 24391, 24407, 24413, 24419, 24421, 24439, 24443, 24469, 24473, 24481,\n    24499, 24509, 24517, 24527, 24533, 24547, 24551, 24571, 24593, 24611, 24623,\n    24631, 24659, 24671, 24677, 24683, 24691, 24697, 24709, 24733, 24749, 24763,\n    24767, 24781, 24793, 24799, 24809, 24821, 24841, 24847, 24851, 24859, 24877,\n    24889, 24907, 24917, 24919, 24923, 24943, 24953, 24967, 24971, 24977, 24979,\n    24989, 25013, 25031, 25033, 25037, 25057, 25073, 25087, 25097, 25111, 25117,\n    25121, 25127, 25147, 25153, 25163, 25169, 25171, 25183, 25189, 25219, 25229,\n    25237, 25243, 25247, 25253, 25261, 25301, 25303, 25307, 25309, 25321, 25339,\n    25343, 25349, 25357, 25367, 25373, 25391, 25409, 25411, 25423, 25439, 25447,\n    25453, 25457, 25463, 25469, 25471, 25523, 25537, 25541, 25561, 25577, 25579,\n    25583, 25589, 25601, 25603, 25609, 25621, 25633, 25639, 25643, 25657, 25667,\n    25673, 25679, 25693, 25703, 25717, 25733, 25741, 25747, 25759, 25763, 25771,\n    25793, 25799, 25801, 25819, 25841, 25847, 25849, 25867, 25873, 25889, 25903,\n    25913, 25919, 25931, 25933, 25939, 25943, 25951, 25969, 25981, 25997, 25999,\n    26003, 26017, 26021, 26029, 26041, 26053, 26083, 26099, 26107, 26111, 26113,\n    26119, 26141, 26153, 26161, 26171, 26177, 26183, 26189, 26203, 26209, 26227,\n    26237, 26249, 26251, 26261, 26263, 26267, 26293, 26297, 26309, 26317, 26321,\n    26339, 26347, 26357, 26371, 26387, 26393, 26399, 26407, 26417, 26423, 26431,\n    26437, 26449, 26459, 26479, 26489, 26497, 26501, 26513, 26539, 26557, 26561,\n    26573, 26591, 26597, 26627, 26633, 26641, 26647, 26669, 26681, 26683, 26687,\n    26693, 26699, 26701, 26711, 26713, 26717, 26723, 26729, 26731, 26737, 26759,\n    26777, 26783, 26801, 26813, 26821, 26833, 26839, 26849, 26861, 26863, 26879,\n    26881, 26891, 26893, 26903, 26921, 26927, 26947, 26951, 26953, 26959, 26981,\n    26987, 26993, 27011, 27017, 27031, 27043, 27059, 27061, 27067, 27073, 27077,\n    27091, 27103, 27107, 27109, 27127, 27143, 27179, 27191, 27197, 27211, 27239,\n    27241, 27253, 27259, 27271, 27277, 27281, 27283, 27299, 27329, 27337, 27361,\n    27367, 27397, 27407, 27409, 27427, 27431, 27437, 27449, 27457, 27479, 27481,\n    27487, 27509, 27527, 27529, 27539, 27541, 27551, 27581, 27583, 27611, 27617,\n    27631, 27647, 27653, 27673, 27689, 27691, 27697, 27701, 27733, 27737, 27739,\n    27743, 27749, 27751, 27763, 27767, 27773, 27779, 27791, 27793, 27799, 27803,\n    27809, 27817, 27823, 27827, 27847, 27851, 27883, 27893, 27901, 27917, 27919,\n    27941, 27943, 27947, 27953, 27961, 27967, 27983, 27997, 28001, 28019, 28027,\n    28031, 28051, 28057, 28069, 28081, 28087, 28097, 28099, 28109, 28111, 28123,\n    28151, 28163, 28181, 28183, 28201, 28211, 28219, 28229, 28277, 28279, 28283,\n    28289, 28297, 28307, 28309, 28319, 28349, 28351, 28387, 28393, 28403, 28409,\n    28411, 28429, 28433, 28439, 28447, 28463, 28477, 28493, 28499, 28513, 28517,\n    28537, 28541, 28547, 28549, 28559, 28571, 28573, 28579, 28591, 28597, 28603,\n    28607, 28619, 28621, 28627, 28631, 28643, 28649, 28657, 28661, 28663, 28669,\n    28687, 28697, 28703, 28711, 28723, 28729, 28751, 28753, 28759, 28771, 28789,\n    28793, 28807, 28813, 28817, 28837, 28843, 28859, 28867, 28871, 28879, 28901,\n    28909, 28921, 28927, 28933, 28949, 28961, 28979, 29009, 29017, 29021, 29023,\n    29027, 29033, 29059, 29063, 29077, 29101, 29123, 29129, 29131, 29137, 29147,\n    29153, 29167, 29173, 29179, 29191, 29201, 29207, 29209, 29221, 29231, 29243,\n    29251, 29269, 29287, 29297, 29303, 29311, 29327, 29333, 29339, 29347, 29363,\n    29383, 29387, 29389, 29399, 29401, 29411, 29423, 29429, 29437, 29443, 29453,\n    29473, 29483, 29501, 29527, 29531, 29537, 29567, 29569, 29573, 29581, 29587,\n    29599, 29611, 29629, 29633, 29641, 29663, 29669, 29671, 29683, 29717, 29723,\n    29741, 29753, 29759, 29761, 29789, 29803, 29819, 29833, 29837, 29851, 29863,\n    29867, 29873, 29879, 29881, 29917, 29921, 29927, 29947, 29959, 29983, 29989,\n    30011, 30013, 30029, 30047, 30059, 30071, 30089, 30091, 30097, 30103, 30109,\n    30113, 30119, 30133, 30137, 30139, 30161, 30169, 30181, 30187, 30197, 30203,\n    30211, 30223, 30241, 30253, 30259, 30269, 30271, 30293, 30307, 30313, 30319,\n    30323, 30341, 30347, 30367, 30389, 30391, 30403, 30427, 30431, 30449, 30467,\n    30469, 30491, 30493, 30497, 30509, 30517, 30529, 30539, 30553, 30557, 30559,\n    30577, 30593, 30631, 30637, 30643, 30649, 30661, 30671, 30677, 30689, 30697,\n    30703, 30707, 30713, 30727, 30757, 30763, 30773, 30781, 30803, 30809, 30817,\n    30829, 30839, 30841, 30851, 30853, 30859, 30869, 30871, 30881, 30893, 30911,\n    30931, 30937, 30941, 30949, 30971, 30977, 30983, 31013, 31019, 31033, 31039,\n    31051, 31063, 31069, 31079, 31081, 31091, 31121, 31123, 31139, 31147, 31151,\n    31153, 31159, 31177, 31181, 31183, 31189, 31193, 31219, 31223, 31231, 31237,\n    31247, 31249, 31253, 31259, 31267, 31271, 31277, 31307, 31319, 31321, 31327,\n    31333, 31337, 31357, 31379, 31387, 31391, 31393, 31397, 31469, 31477, 31481,\n    31489, 31511, 31513, 31517, 31531, 31541, 31543, 31547, 31567, 31573, 31583,\n    31601, 31607, 31627, 31643, 31649, 31657, 31663, 31667, 31687, 31699, 31721,\n    31723, 31727, 31729, 31741, 31751, 31769, 31771, 31793, 31799, 31817, 31847,\n    31849, 31859, 31873, 31883, 31891, 31907, 31957, 31963, 31973, 31981, 31991,\n    32003, 32009, 32027, 32029, 32051, 32057, 32059, 32063, 32069, 32077, 32083,\n    32089, 32099, 32117, 32119, 32141, 32143, 32159, 32173, 32183, 32189, 32191,\n    32203, 32213, 32233, 32237, 32251, 32257, 32261, 32297, 32299, 32303, 32309,\n    32321, 32323, 32327, 32341, 32353, 32359, 32363, 32369, 32371, 32377, 32381,\n    32401, 32411, 32413, 32423, 32429, 32441, 32443, 32467, 32479, 32491, 32497,\n    32503, 32507, 32531, 32533, 32537, 32561, 32563, 32569, 32573, 32579, 32587,\n    32603, 32609, 32611, 32621, 32633, 32647, 32653, 32687, 32693, 32707, 32713,\n    32717, 32719, 32749, 32771, 32779, 32783, 32789, 32797, 32801, 32803, 32831,\n    32833, 32839, 32843, 32869, 32887, 32909, 32911, 32917, 32933, 32939, 32941,\n    32957, 32969, 32971, 32983, 32987, 32993, 32999, 33013, 33023, 33029, 33037,\n    33049, 33053, 33071, 33073, 33083, 33091, 33107, 33113, 33119, 33149, 33151,\n    33161, 33179, 33181, 33191, 33199, 33203, 33211, 33223, 33247, 33287, 33289,\n    33301, 33311, 33317, 33329, 33331, 33343, 33347, 33349, 33353, 33359, 33377,\n    33391, 33403, 33409, 33413, 33427, 33457, 33461, 33469, 33479, 33487, 33493,\n    33503, 33521, 33529, 33533, 33547, 33563, 33569, 33577, 33581, 33587, 33589,\n    33599, 33601, 33613, 33617, 33619, 33623, 33629, 33637, 33641, 33647, 33679,\n    33703, 33713, 33721, 33739, 33749, 33751, 33757, 33767, 33769, 33773, 33791,\n    33797, 33809, 33811, 33827, 33829, 33851, 33857, 33863, 33871, 33889, 33893,\n    33911, 33923, 33931, 33937, 33941, 33961, 33967, 33997, 34019, 34031, 34033,\n    34039, 34057, 34061, 34123, 34127, 34129, 34141, 34147, 34157, 34159, 34171,\n    34183, 34211, 34213, 34217, 34231, 34253, 34259, 34261, 34267, 34273, 34283,\n    34297, 34301, 34303, 34313, 34319, 34327, 34337, 34351, 34361, 34367, 34369,\n    34381, 34403, 34421, 34429, 34439, 34457, 34469, 34471, 34483, 34487, 34499,\n    34501, 34511, 34513, 34519, 34537, 34543, 34549, 34583, 34589, 34591, 34603,\n    34607, 34613, 34631, 34649, 34651, 34667, 34673, 34679, 34687, 34693, 34703,\n    34721, 34729, 34739, 34747, 34757, 34759, 34763, 34781, 34807, 34819, 34841,\n    34843, 34847, 34849, 34871, 34877, 34883, 34897, 34913, 34919, 34939, 34949,\n    34961, 34963, 34981, 35023, 35027, 35051, 35053, 35059, 35069, 35081, 35083,\n    35089, 35099, 35107, 35111, 35117, 35129, 35141, 35149, 35153, 35159, 35171,\n    35201, 35221, 35227, 35251, 35257, 35267, 35279, 35281, 35291, 35311, 35317,\n    35323, 35327, 35339, 35353, 35363, 35381, 35393, 35401, 35407, 35419, 35423,\n    35437, 35447, 35449, 35461, 35491, 35507, 35509, 35521, 35527, 35531, 35533,\n    35537, 35543, 35569, 35573, 35591, 35593, 35597, 35603, 35617, 35671, 35677,\n    35729, 35731, 35747, 35753, 35759, 35771, 35797, 35801, 35803, 35809, 35831,\n    35837, 35839, 35851, 35863, 35869, 35879, 35897, 35899, 35911, 35923, 35933,\n    35951, 35963, 35969, 35977, 35983, 35993, 35999, 36007, 36011, 36013, 36017,\n    36037, 36061, 36067, 36073, 36083, 36097, 36107, 36109, 36131, 36137, 36151,\n    36161, 36187, 36191, 36209, 36217, 36229, 36241, 36251, 36263, 36269, 36277,\n    36293, 36299, 36307, 36313, 36319, 36341, 36343, 36353, 36373, 36383, 36389,\n    36433, 36451, 36457, 36467, 36469, 36473, 36479, 36493, 36497, 36523, 36527,\n    36529, 36541, 36551, 36559, 36563, 36571, 36583, 36587, 36599, 36607, 36629,\n    36637, 36643, 36653, 36671, 36677, 36683, 36691, 36697, 36709, 36713, 36721,\n    36739, 36749, 36761, 36767, 36779, 36781, 36787, 36791, 36793, 36809, 36821,\n    36833, 36847, 36857, 36871, 36877, 36887, 36899, 36901, 36913, 36919, 36923,\n    36929, 36931, 36943, 36947, 36973, 36979, 36997, 37003, 37013, 37019, 37021,\n    37039, 37049, 37057, 37061, 37087, 37097, 37117, 37123, 37139, 37159, 37171,\n    37181, 37189, 37199, 37201, 37217, 37223, 37243, 37253, 37273, 37277, 37307,\n    37309, 37313, 37321, 37337, 37339, 37357, 37361, 37363, 37369, 37379, 37397,\n    37409, 37423, 37441, 37447, 37463, 37483, 37489, 37493, 37501, 37507, 37511,\n    37517, 37529, 37537, 37547, 37549, 37561, 37567, 37571, 37573, 37579, 37589,\n    37591, 37607, 37619, 37633, 37643, 37649, 37657, 37663, 37691, 37693, 37699,\n    37717, 37747, 37781, 37783, 37799, 37811, 37813, 37831, 37847, 37853, 37861,\n    37871, 37879, 37889, 37897, 37907, 37951, 37957, 37963, 37967, 37987, 37991,\n    37993, 37997, 38011, 38039, 38047, 38053, 38069, 38083, 38113, 38119, 38149,\n    38153, 38167, 38177, 38183, 38189, 38197, 38201, 38219, 38231, 38237, 38239,\n    38261, 38273, 38281, 38287, 38299, 38303, 38317, 38321, 38327, 38329, 38333,\n    38351, 38371, 38377, 38393, 38431, 38447, 38449, 38453, 38459, 38461, 38501,\n    38543, 38557, 38561, 38567, 38569, 38593, 38603, 38609, 38611, 38629, 38639,\n    38651, 38653, 38669, 38671, 38677, 38693, 38699, 38707, 38711, 38713, 38723,\n    38729, 38737, 38747, 38749, 38767, 38783, 38791, 38803, 38821, 38833, 38839,\n    38851, 38861, 38867, 38873, 38891, 38903, 38917, 38921, 38923, 38933, 38953,\n    38959, 38971, 38977, 38993, 39019, 39023, 39041, 39043, 39047, 39079, 39089,\n    39097, 39103, 39107, 39113, 39119, 39133, 39139, 39157, 39161, 39163, 39181,\n    39191, 39199, 39209, 39217, 39227, 39229, 39233, 39239, 39241, 39251, 39293,\n    39301, 39313, 39317, 39323, 39341, 39343, 39359, 39367, 39371, 39373, 39383,\n    39397, 39409, 39419, 39439, 39443, 39451, 39461, 39499, 39503, 39509, 39511,\n    39521, 39541, 39551, 39563, 39569, 39581, 39607, 39619, 39623, 39631, 39659,\n    39667, 39671, 39679, 39703, 39709, 39719, 39727, 39733, 39749, 39761, 39769,\n    39779, 39791, 39799, 39821, 39827, 39829, 39839, 39841, 39847, 39857, 39863,\n    39869, 39877, 39883, 39887, 39901, 39929, 39937, 39953, 39971, 39979, 39983,\n    39989, 40009, 40013, 40031, 40037, 40039, 40063, 40087, 40093, 40099, 40111,\n    40123, 40127, 40129, 40151, 40153, 40163, 40169, 40177, 40189, 40193, 40213,\n    40231, 40237, 40241, 40253, 40277, 40283, 40289, 40343, 40351, 40357, 40361,\n    40387, 40423, 40427, 40429, 40433, 40459, 40471, 40483, 40487, 40493, 40499,\n    40507, 40519, 40529, 40531, 40543, 40559, 40577, 40583, 40591, 40597, 40609,\n    40627, 40637, 40639, 40693, 40697, 40699, 40709, 40739, 40751, 40759, 40763,\n    40771, 40787, 40801, 40813, 40819, 40823, 40829, 40841, 40847, 40849, 40853,\n    40867, 40879, 40883, 40897, 40903, 40927, 40933, 40939, 40949, 40961, 40973,\n    40993, 41011, 41017, 41023, 41039, 41047, 41051, 41057, 41077, 41081, 41113,\n    41117, 41131, 41141, 41143, 41149, 41161, 41177, 41179, 41183, 41189, 41201,\n    41203, 41213, 41221, 41227, 41231, 41233, 41243, 41257, 41263, 41269, 41281,\n    41299, 41333, 41341, 41351, 41357, 41381, 41387, 41389, 41399, 41411, 41413,\n    41443, 41453, 41467, 41479, 41491, 41507, 41513, 41519, 41521, 41539, 41543,\n    41549, 41579, 41593, 41597, 41603, 41609, 41611, 41617, 41621, 41627, 41641,\n    41647, 41651, 41659, 41669, 41681, 41687, 41719, 41729, 41737, 41759, 41761,\n    41771, 41777, 41801, 41809, 41813, 41843, 41849, 41851, 41863, 41879, 41887,\n    41893, 41897, 41903, 41911, 41927, 41941, 41947, 41953, 41957, 41959, 41969,\n    41981, 41983, 41999, 42013, 42017, 42019, 42023, 42043, 42061, 42071, 42073,\n    42083, 42089, 42101, 42131, 42139, 42157, 42169, 42179, 42181, 42187, 42193,\n    42197, 42209, 42221, 42223, 42227, 42239, 42257, 42281, 42283, 42293, 42299,\n    42307, 42323, 42331, 42337, 42349, 42359, 42373, 42379, 42391, 42397, 42403,\n    42407, 42409, 42433, 42437, 42443, 42451, 42457, 42461, 42463, 42467, 42473,\n    42487, 42491, 42499, 42509, 42533, 42557, 42569, 42571, 42577, 42589, 42611,\n    42641, 42643, 42649, 42667, 42677, 42683, 42689, 42697, 42701, 42703, 42709,\n    42719, 42727, 42737, 42743, 42751, 42767, 42773, 42787, 42793, 42797, 42821,\n    42829, 42839, 42841, 42853, 42859, 42863, 42899, 42901, 42923, 42929, 42937,\n    42943, 42953, 42961, 42967, 42979, 42989, 43003, 43013, 43019, 43037, 43049,\n    43051, 43063, 43067, 43093, 43103, 43117, 43133, 43151, 43159, 43177, 43189,\n    43201, 43207, 43223, 43237, 43261, 43271, 43283, 43291, 43313, 43319, 43321,\n    43331, 43391, 43397, 43399, 43403, 43411, 43427, 43441, 43451, 43457, 43481,\n    43487, 43499, 43517, 43541, 43543, 43573, 43577, 43579, 43591, 43597, 43607,\n    43609, 43613, 43627, 43633, 43649, 43651, 43661, 43669, 43691, 43711, 43717,\n    43721, 43753, 43759, 43777, 43781, 43783, 43787, 43789, 43793, 43801, 43853,\n    43867, 43889, 43891, 43913, 43933, 43943, 43951, 43961, 43963, 43969, 43973,\n    43987, 43991, 43997, 44017, 44021, 44027, 44029, 44041, 44053, 44059, 44071,\n    44087, 44089, 44101, 44111, 44119, 44123, 44129, 44131, 44159, 44171, 44179,\n    44189, 44201, 44203, 44207, 44221, 44249, 44257, 44263, 44267, 44269, 44273,\n    44279, 44281, 44293, 44351, 44357, 44371, 44381, 44383, 44389, 44417, 44449,\n    44453, 44483, 44491, 44497, 44501, 44507, 44519, 44531, 44533, 44537, 44543,\n    44549, 44563, 44579, 44587, 44617, 44621, 44623, 44633, 44641, 44647, 44651,\n    44657, 44683, 44687, 44699, 44701, 44711};\nlong long a[150010][2];\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i][0] >> a[i][1];\n  }\n  vector<int> f1, f2;\n  for (int i = 0; i < 4648; i++) {\n    if (a[0][0] % primes[i] == 0) f1.push_back(primes[i]);\n    if (a[0][1] % primes[i] == 0) f2.push_back(primes[i]);\n  }\n  int rem = a[0][0];\n  for (int i = 0; i < f1.size(); i++) {\n    while (rem % f1[i] == 0) {\n      rem /= f1[i];\n    }\n  }\n  if (rem != 1) f1.push_back(rem);\n  rem = a[0][1];\n  for (int i = 0; i < f2.size(); i++) {\n    while (rem % f2[i] == 0) {\n      rem /= f2[i];\n    }\n  }\n  if (rem != 1) f2.push_back(rem);\n  for (int i = 0; i < f1.size(); i++) {\n    bool b = 1;\n    for (int j = 1; j < n; j++) {\n      if (a[j][0] % f1[i] != 0 && a[j][1] % f1[i] != 0) {\n        b = 0;\n        break;\n      }\n    }\n    if (b) {\n      cout << f1[i] << endl;\n      return 0;\n    }\n  }\n  for (int i = 0; i < f2.size(); i++) {\n    bool b = 1;\n    for (int j = 1; j < n; j++) {\n      if (a[j][0] % f2[i] != 0 && a[j][1] % f2[i] != 0) {\n        b = 0;\n        break;\n      }\n    }\n    if (b) {\n      cout << f2[i] << endl;\n      return 0;\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, bool> M;\nvector<long long> get_factor(long long x) {\n  vector<long long> res;\n  long long len = sqrt(x) + 1;\n  for (int i = 2; i <= min(x, len); i++) {\n    if (x % i == 0) {\n      while (x % i == 0) x /= i;\n      if (!M[i]) res.push_back(i);\n      M[i] = true;\n    }\n  }\n  if (x != 1) {\n    if (!M[x]) res.push_back(x);\n    M[x] = true;\n  }\n  return res;\n}\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nconst int maxn = 2e5 + 10;\nint a[maxn], b[maxn];\nint main() {\n  int n;\n  cin >> n;\n  long long x, y;\n  cin >> x >> y;\n  if (n == 1) {\n    cout << x << endl;\n    return 0;\n  }\n  n--;\n  for (int i = 0; i < n; i++) cin >> a[i] >> b[i];\n  vector<long long> data = get_factor(x);\n  vector<long long> tmp = get_factor(y);\n  for (int i = 0; i < tmp.size(); i++) data.push_back(tmp[i]);\n  int flag = 0;\n  for (int i = 0; i < data.size(); i++) {\n    bool mark = true;\n    for (int j = 0; j < n; j++) {\n      if ((a[j] % data[i] != 0) && (b[j] % data[i] != 0)) {\n        mark = false;\n        break;\n      }\n    }\n    if (mark) {\n      flag = data[i];\n      break;\n    }\n  }\n  if (flag != 0)\n    cout << flag;\n  else\n    cout << -1;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\n\npublic class HelloWorld {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int num = scanner.nextInt();\n        long[][] pairs = new long[num][2];\n        for(int i = 0; i < num; i++) {\n            pairs[i][0] = scanner.nextLong();\n            pairs[i][1] = scanner.nextLong();\n        }\n\n        HashSet<Long> commonFactors = new HashSet<>();\n        for(int i = 0; i < 2; i++) {\n            long X = pairs[0][i];\n            for(long k = 2; k <= (long)Math.ceil(Math.sqrt(X)); k++) {\n                if(X % k == 0) {\n                    while(X % k == 0) {\n                        X /= k;\n                    }\n                    commonFactors.add(k);\n                }\n            }\n            if(X != 1) {\n                commonFactors.add(X);\n            }\n        }\n        for(long val : commonFactors) {\n            boolean works = true;\n            for(int i = 0; i < pairs.length; i++) {\n                if(pairs[i][0] % val > 0 && pairs[i][1] % val > 0) {\n                    works = false;\n                    break;\n                }\n            }\n            if(works) {\n                System.out.println(val);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ara[500008];\nset<int> s;\nset<int>::iterator it;\nint n;\nvoid check(int num) {\n  for (int i = 1; i < n; i++) {\n    if (!(ara[i] % num == 0 || ara[n + i] % num == 0)) {\n      return;\n    }\n  }\n  cout << num << endl;\n  exit(0);\n}\nint primefactor(int num) {\n  int i = 1;\n  for (i = 2; i <= num / i; i++) {\n    bool flag = 0;\n    while (num % i == 0) {\n      num /= i;\n      if (!flag) {\n        check(i);\n      }\n      flag = 1;\n    }\n  }\n  if (num >= i) {\n    check(num);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d\", &ara[i], &ara[n + i]);\n  }\n  primefactor(ara[0]);\n  primefactor(ara[n]);\n  cout << \"-1\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (1e9 + 7);\nlong long gcd(long long a, long long b) {\n  if (b == 0ll) return a;\n  a %= b;\n  return gcd(b, a);\n}\nint main() {\n  int n;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n;\n  long long valor1, valor2;\n  long long valor = -1;\n  long long minn = (1e9) * 3;\n  long long verf = -1;\n  for (int i = 0; i < n; ++i) {\n    cin >> valor1 >> valor2;\n    long long auxval = (valor1 * valor2) / (gcd(valor1, valor2));\n    if (valor == -1) valor = auxval;\n    if (verf == -1) verf = (gcd(valor1, valor2));\n    verf = gcd(verf, (gcd(valor1, valor2)));\n    valor = gcd(valor, auxval);\n  }\n  if (verf != 1) {\n    cout << verf << endl;\n    return 0;\n  }\n  if (valor == 1) {\n    cout << -1;\n    return 0;\n  }\n  set<long long> s;\n  for (long long i = 2; i <= 1e5; ++i) {\n    while (valor1 % i == 0ll) {\n      valor1 /= i;\n      s.insert(i);\n    }\n  }\n  if (valor1 != 1) s.insert(valor1);\n  for (long long i = 2; i <= 1e5; ++i) {\n    while ((valor2 % i) == 0ll) {\n      valor2 /= i;\n      s.insert(i);\n    }\n  }\n  if (valor2 != 1) s.insert(valor2);\n  for (set<long long>::iterator ite = s.begin(); ite != s.end(); ite++) {\n    if ((valor % (*ite)) == 0ll) {\n      cout << (*ite) << endl;\n      return 0;\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by aditya on 5/3/17.\n */\npublic class Solution {\n\n    static long MOD = 1000000007;\n\n    static int n, m;\n\n    public static void main(String args[]) throws Exception{\n\n        FastInput fi = new FastInput(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = fi.nextInt();\n\n        List<Long> a = new ArrayList<>(150005), b = new ArrayList<>(150005);\n        List<Long> lcm = new ArrayList<>(150005);\n\n        for(int i = 0; i<n; i++) {\n            a.add(fi.nextLong());\n            b.add(fi.nextLong());\n            long gcd = findGcd(a.get(i), b.get(i));\n            lcm.add((a.get(i) * b.get(i))/gcd);\n        }\n\n        long ret = lcm.get(0);\n\n        for(int i = 1; i<lcm.size(); i++) {\n            ret = findGcd(ret, lcm.get(i));\n        }\n\n        for(int i = 0; i<n; i++) {\n            long gcd = findGcd(ret, a.get(i));\n            if(gcd > 1)\n                ret = gcd;\n            gcd = findGcd(ret, b.get(i));\n            if(gcd > 1)\n                ret = gcd;\n        }\n        if(ret > 1)\n            System.out.println(ret);\n        else System.out.println(-1);\n\n    }\n\n    private static long findGcd(long a, long b) {\n        if(b == 0)\n            return a;\n        return findGcd(b, a%b);\n    }\n\n    static class FastInput {\n\n        private Reader in;\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public FastInput(Reader in) {\n            this.in=in;\n            br = new BufferedReader(in);\n        }\n\n        public String nextString() {\n\n            while(st==null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    System.out.println(e.getStackTrace());\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextString());\n        }\n\n        public double nextDouble() {\n\n            return Double.parseDouble(nextString());\n        }\n\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> vec;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  set<int> st;\n  int a, b;\n  scanf(\"%d%d\", &a, &b);\n  for (int i = 2; i <= (int)sqrt(a); i++) {\n    if (a % i == 0) {\n      st.insert(i);\n      while (a % i == 0) a /= i;\n    }\n  }\n  if (a != 1) st.insert(a);\n  for (int i = 2; i <= (int)sqrt(b); i++) {\n    if (b % i == 0) {\n      st.insert(i);\n      while (b % i == 0) b /= i;\n    }\n  }\n  if (b != 1) st.insert(b);\n  for (auto it = st.begin(); it != st.end(); it++) vec.push_back(*it);\n  int sz = vec.size();\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    for (int j = 0; j < sz; j++)\n      if (a % vec[j] != 0 && b % vec[j] != 0) vec[j] = -1;\n  }\n  int mk = 0;\n  for (int i = 0; i < sz; i++) {\n    if (vec[i] != -1) {\n      printf(\"%d\\n\", vec[i]);\n      mk = 1;\n      break;\n    }\n  }\n  if (mk == 0) printf(\"-1\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\n// http://codeforces.com/contest/1025/problem/B\npublic class WeakenedCommonDivisor {\npublic static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    int n = Integer.parseInt(br.readLine());\n    String[] numStrFirst = br.readLine().split(\" \");\n    int n1 = Integer.parseInt(numStrFirst[0]);\n    int n2 = Integer.parseInt(numStrFirst[1]);\n    Set<Integer> divisors = primeFactors(n1);\n    divisors.addAll(primeFactors(n2));\n    for (int i = 1; i < n; i++) {\n        String[] numStr = br.readLine().split(\" \");\n        int num1 = Integer.parseInt(numStr[0]);\n        int num2 = Integer.parseInt(numStr[1]);\n        ArrayList<Integer> remove = new ArrayList<>();\n        for (int d : divisors) {\n            if (num1 % d != 0 && num2 % d != 0) {\n                remove.add(d);\n            }\n        }\n        divisors.removeAll(remove);\n    }\n    if (divisors.size() == 0) {\n        System.out.println(-1);\n    } else {\n        System.out.println(divisors.iterator().next());\n    }\n}\n\n/**\n * @param n The numbers to factor\n * @return a set of all the prime factors of n\n */\nprivate static Set<Integer> primeFactors(int n) {\n    Set<Integer> primes = new HashSet<>();\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            primes.add(i);\n            n /= i;\n            i--;\n        }\n    }\n    if (n != 1) {\n        primes.add(n);\n    }\n    return primes;\n}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<long long int> getFactors(long long int d) {\n  set<long long int> factors1;\n  for (long long int i = 2; i * i <= d; i++) {\n    if (d % i == 0) {\n      factors1.insert(i);\n      while (d % i == 0) {\n        d /= i;\n      }\n    }\n  }\n  if (d > 1) factors1.insert(d);\n  return factors1;\n}\nint main() {\n  long long int n, f, s;\n  cin >> n;\n  long long int A[n], B[n];\n  for (int i = 0; i < n; ++i) {\n    cin >> A[i] >> B[i];\n  }\n  set<long long int> factors1 = getFactors(A[0]);\n  set<long long int> factors2 = getFactors(B[0]);\n  for (long long int var : factors1) {\n    bool all = true;\n    for (long long int i = 0; i < n; i++) {\n      if (A[i] % var != 0 and B[i] % var != 0) {\n        all = false;\n        break;\n      }\n    }\n    if (all) {\n      cout << var << endl;\n      return 0;\n    }\n  }\n  for (long long int var : factors2) {\n    bool all = true;\n    for (long long int i = 0; i < n; i++) {\n      if (A[i] % var != 0 and B[i] % var != 0) {\n        all = false;\n        break;\n      }\n    }\n    if (all) {\n      cout << var << endl;\n      return 0;\n    }\n  }\n  cout << \"-1\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import sqrt\ndef primset(n):\n    a = set()\n    \n    while n % 2 == 0:\n        a.add(2)\n        n = n//2\n         \n    for i in range(3,int(sqrt(n))+1,2):\n        while n % i== 0:\n            a.add(i)\n            n = n//i\n            \n    if n > 2:\n        a.add(n)\n    return a\n\nn = int(input())\na, b = map(int, input().split())\n\nprimes = primset(a)\nprimes.update(primset(b))\n\nfor i in range(1, n):\n    a, b = map(int, input().split())\n    r = set()\n    for p in primes:\n        if a%p != 0 and b%p != 0:\n            r.add(p)\n    for rem in r:\n        primes.remove(rem)\n    if len(primes) < 1:\n        print(-1)\n        exit()\nprint(primes.pop())"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nfrom collections import defaultdict\nimport bisect\ndef alele(): return list(map(int, sys.stdin.readline().strip().split()))\ndef ilele(): return map(int, sys.stdin.readline().strip().split())\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 1000000000 + 7\n\ndef primeFactors(n): \n\tA =set()\n\twhile n % 2 == 0: \n\t\tA.add(2) \n\t\tn = n // 2\n\tfor i in range(3,int(math.sqrt(n))+1,2): \n\t\twhile n % i== 0: \n\t\t\tA.add(i) \n\t\t\tn = n // i \n\tif n > 2: \n\t\tA.add(n) \n\treturn list(A)\t\nZ = []\nfor i in range(int(input())):\n    a,b = ilele()\n    Z.append((a,b))\nfor i in range(len(Z)):\n    a,b = Z[i]\n    if i == 0:\n        B = list(set(primeFactors(a) + primeFactors(b)))\n        #print(B)\n    else:\n        C = []\n        for j in B:\n            if a%j == 0 or b%j == 0:\n                C.append(j)\n        B = C.copy()\n    #print(B)\n    if len(B) == 0:\n        break\nif len(B) != 0:\n    print(B[0])\nelse:\n    print(-1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint cmp(const void* a, const void* b) { return *(int*)a - *(int*)b; }\nlong long int gcd(long long int a, long long int b) {\n  if (a == 0) return b;\n  return gcd(b % a, a);\n}\nint main() {\n  long long int n, i, a, b;\n  long long int prod;\n  long long int ans = 0;\n  cin >> n;\n  for (i = 0; i < n; ++i) {\n    cin >> a >> b;\n    prod = a * b;\n    if (!i)\n      ans = a * b;\n    else\n      ans = gcd(ans, prod);\n  }\n  if (ans == 1) {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n  if (ans % a == 0)\n    ans = a;\n  else if (ans % b == 0)\n    ans = b;\n  long long int res = 0;\n  if (ans % 2 == 0) {\n    res = 2;\n    cout << \"2\" << endl;\n    return 0;\n  }\n  int val = 0;\n  for (i = 3; i <= sqrt(ans); i += 2) {\n    if (ans % i == 0) {\n      res = i;\n      cout << res << endl;\n      return 0;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        B solver = new B();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class B {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] a = new long[n];\n            long[] b = new long[n];\n            in.readLongArrays(a, b);\n            long answer = 0;\n            for (int i = 0; i < n; i++) {\n                answer = IntegerUtils.gcd(answer, IntegerUtils.lcm(a[i], b[i]));\n            }\n            for (int i = 0; i < n; i++) {\n                if (IntegerUtils.gcd(answer, a[i]) != 1) {\n                    answer = IntegerUtils.gcd(answer, a[i]);\n                } else {\n                    answer = IntegerUtils.gcd(answer, b[i]);\n                }\n            }\n            out.printLine(answer == 1 ? -1 : answer);\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static long gcd(long a, long b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            while (b != 0) {\n                long temp = a % b;\n                a = b;\n                b = temp;\n            }\n            return a;\n        }\n\n        public static long lcm(long a, long b) {\n            return (a / gcd(a, b)) * b;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public void readLongArrays(long[]... arrays) {\n            for (int i = 0; i < arrays[0].length; i++) {\n                for (int j = 0; j < arrays.length; j++) {\n                    arrays[j][i] = readLong();\n                }\n            }\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Sol {\n\tpublic static void main(String[] args) {\n\t\tMyScanner in = new MyScanner();\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\t\tint n = in.nextInt();\n\t\tLong[] a = new Long[n];\n\t\tLong[] b = new Long[n];\n\t\tlong t = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = in.nextLong();\n\t\t\tb[i] = in.nextLong();\n\t\t\tt = gcd(t, a[i] * b[i]);\n\t\t}\n\t\tif (t == 1) {\n\t\t\tout.println(-1);\n\t\t} else {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (gcd(t, a[i]) > 1)\n\t\t\t\t\tt = gcd(t, a[i]);\n\t\t\t\telse\n\t\t\t\t\tt = gcd(t, b[i]);\n\t\t\t}\n\t\t\tout.println(t);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static long gcd(long n1, long n2) {\n\t\treturn n2 != 0 ? gcd(n2, n1 % n2) : n1;\n\t}\n\n\t// -----------PrintWriter for faster output-------------\n\tpublic static PrintWriter out;\n\n\t// -----------MyScanner class for faster input----------\n\tpublic static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t}\n\t// --------------------------------------------------------\n}"
        },
        {
            "language": 1,
            "solution": "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while p <= n:\n        if (prime[p] == True):\n            yield p\n            for i in range(p * 2, n+1, p):\n                prime[i] = False\n        p += 1\n\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n\n    return gcd(b, a % b)\n\n\ndef lcm(a, b):\n    # return a * b / gcd(max(a, b), min(a, b))\n    return a * b\n\n\nn = input()\npairs = [map(int, raw_input().strip().split()) for _ in range(n)]\n\nnums = [lcm(x, y) for x, y in pairs]\nnums.sort()\n\ng = nums[0]\nfor num in nums[1:]:\n    g = gcd(num, g)\n\nif g == 1:\n    print -1\n    exit()\n\nfor pair in pairs:\n    gt = gcd(pair[0], g)\n    g = gt if gt != 1 else gcd(pair[1], g)\n\nprint g\n"
        },
        {
            "language": 3,
            "solution": "import math\n\ndef is_prime(n):\n    if n == 1:\n        return False\n    if n == 2:\n        return True\n    for i in range(2, math.ceil(math.sqrt(n))+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve(arr):\n    orig = []\n    if is_prime(arr[0][0]) and arr[0][0] > 1:\n        orig.append(arr[0][0])\n\n    if is_prime(arr[0][1]) and arr[0][1] > 1:\n        orig.append(arr[0][1])\n\n    for i in range(2, math.ceil(math.sqrt(arr[0][0]))+1):\n        if arr[0][0] % i == 0:\n            if is_prime(i):\n                orig.append(i)\n            if (arr[0][0] // i) > 1 and is_prime(arr[0][0] // i):\n                orig.append(arr[0][0] // i)\n\n    for i in range(2, math.ceil(math.sqrt(arr[0][1]))+1):\n        if arr[0][1] % i == 0:\n            if is_prime(i):\n                orig.append(i)\n            if (arr[0][1] // i) > 1 and is_prime(arr[0][1] // i):\n                orig.append(arr[0][1] // i)\n\n    for el in arr:\n        orig = [i for i in orig if el[0] % i == 0 or el[1] % i == 0]\n\n    return -1 if len(orig) == 0 else orig[0]\n\nn = int(input().strip())\na = []\nfor i in range(n):\n    a.append([int(x) for x in input().strip().split()])\nprint(solve(a))"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ankur\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int ar[][] = new int[n][2];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 2; j++) {\n                    ar[i][j] = in.nextInt();\n                }\n            }\n            HashMap<Integer, Integer> hm = new HashMap<>();\n            int prime[] = in.sieve((int) 1e6);\n            int val1 = ar[0][0];\n            for (int i = 2; i < 1000 * 100; ) {\n                // System.out.println(i);\n                if (val1 == 1)\n                    break;\n                if (prime[i] == i) {\n                    if (val1 % i == 0) {\n                        val1 = val1 / i;\n                        hm.put(i, 1);\n                    } else {\n                        i++;\n                    }\n                } else {\n                    i++;\n                }\n            }\n            if (val1 != 1) {\n                hm.put(val1, 1);\n            }\n            val1 = ar[0][1];\n            for (int i = 2; i < 1000 * 100; ) {\n                if (val1 == 1)\n                    break;\n                if (prime[i] == i) {\n                    if (val1 % i == 0) {\n                        val1 = val1 / i;\n                        hm.put(i, 1);\n                    } else {\n                        i++;\n                    }\n                } else {\n                    i++;\n                }\n            }\n            if (val1 != 1) {\n                hm.put(val1, 1);\n            }\n\n            //     hm.put(ar[0][1], 1);\n            //   hm.put(ar[0][0], 1);\n            for (int x : hm.keySet()) {\n                boolean is = true;\n                for (int i = 0; i < n; i++) {\n                    if (ar[i][1] % x == 0 || ar[i][0] % x == 0) {\n\n                    } else {\n                        is = false;\n                        break;\n                    }\n                }\n                if (is) {\n                    out.print(x);\n                    return;\n                }\n\n            }\n            out.print(-1);\n\n\n        }\n\n    }\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar;\n        private int snumChars;\n\n        public InputReader(InputStream st) {\n            this.stream = st;\n        }\n\n        public int read() {\n            //*-*------clare------\n//remeber while comparing 2 non primitive data type not to use ==\n//remember Arrays.sort for primitive data has worst time case complexity of 0(n^2) bcoz it uses quick sort\n//again silly mistakes ,yr kb tk krta rhega ye mistakes\n//try to write simple codes ,break it into simple things\n//knowledge>rating\n        /*\n        public class Main\n        implements Runnable{\n    public static void main(String[] args) {\n        new Thread(null,new Main(),\"Main\",1<<26).start();\n\n    }\n    public void run() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();//chenge the name of task\n        solver.solve(1, in, out);\n        out.close();\n    }\n         */\n\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] sieve(int n) {\n            int ar[] = new int[n + 1];\n            ar[0] = 0;\n            ar[1] = 1;\n            for (int i = 2; i < ar.length; i++) {\n                if (ar[i] == 0) {\n                    for (int k = i; k < ar.length; k = k + i) {\n                        if (ar[k] == 0) {\n                            ar[k] = i;\n                        }\n                    }\n                }\n            }\n            return ar;\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "/*\n *\n * @author Mukesh Singh\n *\n */\n\nimport java.io.*;\nimport java.util.*;\nimport java.text.DecimalFormat;\n@SuppressWarnings(\"unchecked\")\n\n\n\npublic class Solution {\t\n\t//solve test cases\n\t\tvoid solve() throws Exception {\n\t\tint n = in.nextInt();\n\t\tlong[][] array = new long[n][2];\n\t\tfor(int index = 0 ; index < n ; ++index){\n\t\t\tarray[index][0] = in.nextLong();\n\t\t\tarray[index][1] = in.nextLong();\n\t\t}\n\t\tSet<Long> set = new TreeSet<>();\n\t\tlong a = array[0][0];\n\t\tfor(long index = 2; index*index <= a; ++index){\n\t\t\tif(a%index == 0l){\n\t\t\t\tset.add(index);\n\t\t\t\twhile(a%index == 0)\n\t\t\t\t\ta/=index;\n\t\t\t}\n\t\t}\n\t\tif(a > 1)\n\t\t\tset.add(a);\n\t\ta = array[0][1];\n\t\tfor(long index = 2; index*index <= a; ++index){\n\t\t\tif(a%index == 0l){\n\t\t\t\tset.add(index);\n\t\t\t\twhile(a%index == 0)\n\t\t\t\t\ta/=index;\n\t\t\t}\n\t\t}\n\t\tif(a > 1)\n\t\t\tset.add(a);\n\t\t\n\t\tfor(long factor : set){\n\t\t\t//System.out.println(\"factor \"+factor);\n\t\t\tboolean flag = true;\n\t\t\tfor(int index = 1; index < n ; ++index){\n\t\t\t\tif(array[index][0] %factor != 0 && array[index][1]%factor != 0){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tSystem.out.println(factor);\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\t\n\t\n\t//@ main function\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Solution();\n\t}\n\t\n\tInputReader in;\n\tPrintStream out ;\n\tDecimalFormat df ;\n\tSolution() {\n\t\ttry {\n\t\t\tFile defaultInput = new File(\"file.in\");\n\t\t\tif (defaultInput.exists()) \n\t\t\t\tin = new InputReader(\"file.in\");\n\t\t\telse \n\t\t\t\tin = new InputReader();\n\t\t\tdefaultInput = new File(\"file.out\");\n\t\t\tif (defaultInput.exists()) \n\t\t\t\tout = new PrintStream(new FileOutputStream(\"file.out\"));\n\t\t\telse\n\t\t\t\tout = new PrintStream(System.out);\n\t\t\tdf = new DecimalFormat(\"######0.00\");\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} \n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(261);\n\t\t}\n\t}\n\t\n\tclass InputReader {\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\t\t\n\t\tInputReader() {\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tInputReader(String fileName) throws FileNotFoundException {\n\t\t\treader = new BufferedReader(new FileReader(new File(fileName)));\n\t\t}\n\t\t\n\t\tString readLine() throws IOException {\n\t\t\treturn reader.readLine();\n\t\t}\n\t\t\n\t\tString nextToken() throws IOException {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t\ttokenizer = new StringTokenizer(readLine());\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tboolean hasMoreTokens() throws IOException {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\tString s = readLine();\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\ttokenizer = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tint nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\t\t\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\t\t\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class Main {\n    private static Scanner sc;\n    private static Printer pr;\n    private static long aLong=(long)(Math.pow(10,9)+7);\n    private static void solve() throws IOException {\n        int n=sc.nextInt();\n        ArrayList<Long>lcm=new ArrayList<>();\n        ArrayList<Long>rem=new ArrayList<>();\n        long []a=new long[n];\n        long []b=new long[n];\n        for (int i=1;i<=n;i++){\n            a[i-1]=sc.nextLong();\n            b[i-1]=sc.nextLong();\n            lcm.add((a[i-1]*b[i-1])/gcd(a[i-1],b[i-1]));\n        }\n        //for (long l:lcm)\n          //  System.out.println(l);\n        long start=lcm.get(0);\n        long gcd=0;\n        for (int i=1;i<lcm.size();i++)\n            start=gcd(start,lcm.get(i));\n       // System.out.println(start);\n        if (start==1)\n            gcd=-1;\n        else{\n            rem.add(start);\n            long k=0;\n            for (int i=0;i<n;i++){\n                k=gcd(rem.get(rem.size()-1),a[i]);\n                //System.out.println(\"k:\"+k);\n                if (k>1) {\n                    gcd = k;\n                    rem.add(k);\n                    //k=start;\n                }\n                k=gcd(rem.get(rem.size()-1),b[i]);\n                if (k>1) {\n                    gcd = k;\n                    rem.add(k);\n                    //k=start;\n                }\n            }\n            //if (gcd==0)\n              //  gcd=start;\n        }\n        pr.println(gcd);\n        /*int n=sc.nextInt();\n        long gcds=0;\n        ArrayList<Long>lcm=new ArrayList<>();\n        for (int i=1;i<=n;i++){\n            long a=sc.nextLong();\n            long b=sc.nextLong();\n            gcds=gcd(gcds,a*b);\n        }\n        for (int i=0;i<)\n        pr.println(gcd);*/\n    }\n    public static StringBuilder binaryradix(long number){\n        StringBuilder builder=new StringBuilder();\n        long remainder;\n        while (number!=0) {\n            remainder = number % 2;\n            number >>= 1;\n            builder.append(remainder);\n        }\n        builder.reverse();\n        return builder;\n    }\n    public static int binarySearch(long[] a, int index,long target) {\n            int l = index;\n            int h = a.length - 1;\n            while (l<=h) {\n                int med = l + (h-l)/2;\n                if(a[med] - target <= target) {\n                    l = med + 1;\n                }\n                else h = med  - 1;\n            }\n            return h;\n    }\n    public static int val(char c){\n        return c-'0';\n    }\n    public static long gcd(long a,long b) {\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n        private static class Pair implements Comparable<Pair> {\n            long x;\n            long y;\n\n            Pair() {\n                this.x = 0;\n                this.y = 0;\n            }\n\n            Pair(long x, long y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            @Override\n            public boolean equals(Object obj) {\n                if (this == obj) {\n                    return true;\n                }\n                if (obj == null) return false;\n                Pair other = (Pair) obj;\n                if (this.x == other.x && this.y == other.y) {\n                    return true;\n                }\n                return false;\n            }\n\n            @Override\n            public int compareTo(Pair other) {\n                if (this.x != other.x) return Long.compare(this.x, other.x);\n                return Long.compare(this.y*other.x, this.x*other.y);\n            }\n    }\n\n    public static void main(String[] args) throws IOException {\n        sc = new Scanner(System.in);\n        pr = new Printer(System.out);\n        solve();\n\n        pr.close();\n       // sc.close();\n    }\n    private static class Scanner {\n        BufferedReader br;\n\n        Scanner (InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        private boolean isPrintable(int ch) {\n            return ch >= '!' && ch <= '~';\n        }\n\n        private boolean isCRLF(int ch) {\n            return ch == '\\n' || ch == '\\r' || ch == -1;\n        }\n\n        private int nextPrintable() {\n            try {\n                int ch;\n                while (!isPrintable(ch = br.read())) {\n                    if (ch == -1) {\n                        throw new NoSuchElementException();\n                    }\n                }\n\n                return ch;\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        String next() {\n            try {\n                int ch = nextPrintable();\n                StringBuilder sb = new StringBuilder();\n                do {\n                    sb.appendCodePoint(ch);\n                } while (isPrintable(ch = br.read()));\n\n                return sb.toString();\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        int nextInt() {\n            try {\n                // parseInt from Integer.parseInt()\n                boolean negative = false;\n                int res = 0;\n                int limit = -Integer.MAX_VALUE;\n                int radix = 10;\n\n                int fc = nextPrintable();\n                if (fc < '0') {\n                    if (fc == '-') {\n                        negative = true;\n                        limit = Integer.MIN_VALUE;\n                    } else if (fc != '+') {\n                        throw new NumberFormatException();\n                    }\n                    fc = br.read();\n                }\n                int multmin = limit / radix;\n\n                int ch = fc;\n                do {\n                    int digit = ch - '0';\n                    if (digit < 0 || digit >= radix) {\n                        throw new NumberFormatException();\n                    }\n                    if (res < multmin) {\n                        throw new NumberFormatException();\n                    }\n                    res *= radix;\n                    if (res < limit + digit) {\n                        throw new NumberFormatException();\n                    }\n                    res -= digit;\n\n                } while (isPrintable(ch = br.read()));\n\n                return negative ? res : -res;\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        long nextLong() {\n            try {\n                // parseLong from Long.parseLong()\n                boolean negative = false;\n                long res = 0;\n                long limit = -Long.MAX_VALUE;\n                int radix = 10;\n\n                int fc = nextPrintable();\n                if (fc < '0') {\n                    if (fc == '-') {\n                        negative = true;\n                        limit = Long.MIN_VALUE;\n                    } else if (fc != '+') {\n                        throw new NumberFormatException();\n                    }\n                    fc = br.read();\n                }\n                long multmin = limit / radix;\n\n                int ch = fc;\n                do {\n                    int digit = ch - '0';\n                    if (digit < 0 || digit >= radix) {\n                        throw new NumberFormatException();\n                    }\n                    if (res < multmin) {\n                        throw new NumberFormatException();\n                    }\n                    res *= radix;\n                    if (res < limit + digit) {\n                        throw new NumberFormatException();\n                    }\n                    res -= digit;\n\n                } while (isPrintable(ch = br.read()));\n\n                return negative ? res : -res;\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            try {\n                int ch;\n                while (isCRLF(ch = br.read())) {\n                    if (ch == -1) {\n                        throw new NoSuchElementException();\n                    }\n                }\n                StringBuilder sb = new StringBuilder();\n                do {\n                    sb.appendCodePoint(ch);\n                } while (!isCRLF(ch = br.read()));\n\n                return sb.toString();\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n            }\n        }\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class List {\n        String Word;\n        int length;\n\n        List(String Word, int length) {\n            this.Word = Word;\n            this.length = length;\n        }\n    }\n    private static class Printer extends PrintWriter {\n        Printer(PrintStream out) {\n            super(out);\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool cmp(pair<long long, long long> &a, pair<long long, long long> &b) {\n  if (a.first == b.first) return (a.second < b.second);\n  return a.first < b.first;\n}\nlong long nCr(long long n, long long r) {\n  long long res = 1;\n  for (int i = n; i > max(r, n - r); i--) res *= i, res %= 1000000007;\n  for (int i = 2; i <= min(r, n - r); i++) res /= i;\n  return res % 1000000007;\n}\nlong long exp(long long n, long long j) {\n  long long i = n, res = 1;\n  while (j > 0) {\n    if (j & 1) res *= i;\n    i = i * i;\n    j >>= 1;\n  }\n  return res;\n}\nint main() {\n  int T = 1;\n  while (T--) {\n    long long n, i, j;\n    cin >> n;\n    long long l[n], r[n];\n    for (i = 0; i < n; i++) cin >> l[i] >> r[i];\n    if (n == 1) {\n      cout << l[0];\n      return 0;\n    }\n    unordered_set<long long> s;\n    for (i = 2; i * i <= l[0]; i++) {\n      if (l[0] % i == 0) {\n        s.insert(i);\n        while (l[0] % i == 0) l[0] /= i;\n      }\n    }\n    if (l[0] > 1) s.insert(l[0]);\n    for (i = 2; i * i <= r[0]; i++) {\n      if (r[0] % i == 0) {\n        s.insert(i);\n        while (r[0] % i == 0) r[0] /= i;\n      }\n    }\n    if (r[0] > 1) s.insert(r[0]);\n    for (i = 1; i < n; i++) {\n      unordered_set<long long> w;\n      for (auto it : s) {\n        if (l[i] % it == 0 || r[i] % it == 0) w.insert(it);\n      }\n      if (w.empty()) {\n        cout << -1;\n        return 0;\n      }\n      s.clear();\n      for (auto it : w) s.insert(it);\n    }\n    cout << *(s.begin());\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> v;\nvoid prime(long long x) {\n  for (long long i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      v.push_back(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) v.push_back(x);\n}\nint main() {\n  int n;\n  while (scanf(\"%d\", &n) != EOF) {\n    long long a, b;\n    scanf(\"%I64d%I64d\", &a, &b);\n    prime(a);\n    prime(b);\n    vector<long long>::iterator it = unique(v.begin(), v.end());\n    v.erase(it, v.end());\n    for (int i = 1; i < n; i++) {\n      scanf(\"%I64d%I64d\", &a, &b);\n      for (it = v.begin(); it != v.end(); it++) {\n        if (a % *it && b % *it) {\n          v.erase(it);\n          it--;\n        }\n      }\n    }\n    if (v.size())\n      printf(\"%I64d\\n\", v[0]);\n    else\n      printf(\"-1\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t, n, i, j, k, h = 0;\n  cin >> n;\n  long long int a[n], b[n];\n  for (i = 0; i < n; ++i) {\n    cin >> a[i] >> b[i];\n  }\n  if (n == 1) cout << a[0] << endl;\n  if (n > 1) {\n    set<long long int> s1, s, s3;\n    set<long long int>::iterator jt, it;\n    j = a[0];\n    while (j % 2 == 0) {\n      s.insert(2);\n      j /= 2;\n    }\n    for (k = 3; k <= sqrt(j); k = k + 2) {\n      while (j % k == 0) {\n        s.insert(k);\n        j /= k;\n      }\n    }\n    if (j > 2) s.insert(j);\n    j = b[0];\n    while (j % 2 == 0) {\n      s.insert(2);\n      j /= 2;\n    }\n    for (k = 3; k <= sqrt(j); k = k + 2) {\n      while (j % k == 0) {\n        s.insert(k);\n        j /= k;\n      }\n    }\n    if (j > 2) s.insert(j);\n    j = a[1];\n    while (j % 2 == 0) {\n      s1.insert(2);\n      j /= 2;\n    }\n    for (k = 3; k <= sqrt(j); k = k + 2) {\n      while (j % k == 0) {\n        s1.insert(k);\n        j /= k;\n      }\n    }\n    if (j > 2) s1.insert(j);\n    j = b[1];\n    while (j % 2 == 0) {\n      s1.insert(2);\n      j /= 2;\n    }\n    for (k = 3; k <= sqrt(j); k = k + 2) {\n      while (j % k == 0) {\n        s1.insert(k);\n        j /= k;\n      }\n    }\n    if (j > 2) s1.insert(j);\n    for (it = s.begin(); it != s.end(); ++it) {\n      for (jt = s1.begin(); jt != s1.end(); jt++) {\n        if ((*jt) % (*it) == 0) {\n          s3.insert(*it);\n        } else if ((*it) % (*jt) == 0)\n          s3.insert(*jt);\n      }\n    }\n    s.clear();\n    for (i = 2; i < n; ++i) {\n      for (it = s3.begin(); it != s3.end(); ++it) {\n        if (a[i] % (*it) == 0) s.insert(*it);\n        if (b[i] % (*it) == 0) s.insert(*it);\n      }\n      s3.clear();\n      for (it = s.begin(); it != s.end(); ++it) {\n        s3.insert(*it);\n      }\n      s.clear();\n    }\n    if (s3.size() > 0) {\n      for (it = s3.begin(); it != s3.end(); ++it) {\n        cout << *it << endl;\n        break;\n      }\n    } else\n      cout << \"-1\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int mod = 1e9 + 7;\ninline int read() {\n  int x = 0, k = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') k = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9')\n    x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return x * k;\n}\nstruct node {\n  int a, b;\n} x[200005];\nint prime[200005];\nint p1[200005], p2[200005];\nint c1[200005], c2[200005];\nint m1, m2;\nbool isprime(int x) {\n  if (x == 0 || x == 1) return 0;\n  for (int i = 2; i <= sqrt(x); i++) {\n    if (x % i == 0) return 0;\n  }\n  return 1;\n}\nvoid divide1(int n) {\n  m1 = 0;\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      p1[++m1] = i;\n      while (n % i == 0) n /= i;\n    }\n  }\n  if (n > 1) p1[++m1] = n;\n}\nvoid divide2(int n) {\n  m2 = 0;\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      p2[++m2] = i;\n      while (n % i == 0) n /= i;\n    }\n  }\n  if (n > 1) p2[++m2] = n;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  int i, j;\n  for (i = 1; i <= n; i++) {\n    cin >> x[i].a >> x[i].b;\n  }\n  for (i = 1; i <= n; i++) {\n    if (x[i].a == 1 && x[i].b == 1) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n  divide1(x[1].a);\n  divide2(x[1].b);\n  int flag = 0, ans;\n  j = 0;\n  for (i = 1; i <= m1; i++) {\n    prime[j] = p1[i];\n    j++;\n  }\n  for (i = 1; i <= m2; i++) {\n    prime[j] = p2[i];\n    j++;\n  }\n  int cnt;\n  sort(prime, prime + j);\n  cnt = unique(prime, prime + j) - prime;\n  int k, tt;\n  for (i = 0; i < cnt; i++) {\n    for (j = 2; j <= n; j++) {\n      if (x[j].a % prime[i] == 0 || x[j].b % prime[i] == 0) {\n        continue;\n      } else\n        break;\n    }\n    if (j > n) {\n      ans = prime[i];\n      flag = 1;\n      break;\n    }\n  }\n  if (flag)\n    cout << ans << endl;\n  else\n    cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Rextester{\n    static long gcd(long a,long b){\n        if(a%b==0){\n            return b;\n        }\n        return gcd(b,a%b);\n    }\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        long[] array = new long[n];\n        int[][] num = new int[n][2];\n        for(int i=0;i<n;i++){\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a=Integer.parseInt(st.nextToken());\n            int b=Integer.parseInt(st.nextToken());\n            num[i][0]=a;\n            num[i][1]=b;\n            array[i]=(long)a*b;\n        }\n        br.close();\n        long g;\n        if(n>1){\n            g = gcd(array[0],array[1]);\n        }\n        else{\n            g=array[0];\n        }\n        for(int i=2;i<n;i++){\n            g = gcd(g,array[i]);\n        }\n        if(g==1){\n            System.out.println(\"-1\");\n            return;\n        }\n        long min = Integer.MAX_VALUE;\n        for(int i=0;i<n;i++){\n            long x = gcd(g,num[i][0]);\n            long y = gcd(g,num[i][1]);\n            if(x!=1){\n                min = Math.min(min,x);\n            }\n            if(y!=1){\n                min = Math.min(min,y);\n            }\n        }\n        if(min%2==0){\n            System.out.println(\"2\");\n            return;\n        }\n        else{\n            for(int i=3;i<=Math.sqrt(min);i+=2){\n                if(min%i==0){\n                    System.out.println(i);\n                    return;\n                }\n            }\n        }\n        System.out.println(min);\n    }\n}\n        \n        \n        \n            "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization(\"unroll-loops\")\nusing namespace std;\nconst long long int mod = 1e9 + 7;\nconst long long int pinf = ((long long int)2e18);\nconst long long int ninf = ((long long int)-2e18);\nconst long long int mod2 = 998244353;\nlong long int pow(long long int x, unsigned long long int y, long long int p) {\n  long long int res = 1;\n  x = x % p;\n  if (x == 0) return 0;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nlong long int _pow(long long int a, long long int b) {\n  if (!b) return 1;\n  long long int temp = _pow(a, b / 2);\n  temp = (temp * temp);\n  if (b % 2) return (a * temp);\n  return temp;\n}\nlong long int invmod(long long int a, long long int m) {\n  return pow(a, m - 2, m);\n}\nlong long int cl(long long int a, long long int x) {\n  if (a % x == 0)\n    return a / x;\n  else\n    return a / x + 1;\n}\nbool isPrime(long long int n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long int i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nbool prime[100000 + 5];\nvoid SieveOfEratosthenes(long long int n) {\n  memset(prime, true, sizeof(prime));\n  for (long long int p = 2; p * p <= n; p++) {\n    if (prime[p] == true) {\n      for (long long int i = p * p; i <= n; i += p) prime[i] = false;\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  {\n    long long int I, w, h, b, d, m, x, pos, sum = 0, n, k, y, i, j, flag = 1;\n    cin >> n;\n    vector<long long int> ans;\n    for (long long int i = 0; i < n; i++) {\n      long long int a, b;\n      cin >> a >> b;\n      if (i == 0) {\n        for (long long int i = 2; i < sqrt(a) + 1; i++) {\n          if (a % i == 0) {\n            if (isPrime(i)) ans.push_back(i);\n            if (a != i * i && (a != i)) {\n              if (isPrime(a / i)) ans.push_back(a / i);\n            }\n          }\n        }\n        ans.push_back(a);\n        if (a != b) {\n          for (long long int i = 2; i < sqrt(b) + 1; i++) {\n            if (b % i == 0) {\n              if (isPrime(i)) ans.push_back(i);\n              if (b != i * i && (b != i)) {\n                if (isPrime(b / i)) ans.push_back(b / i);\n              }\n            }\n          }\n          ans.push_back(b);\n        }\n      } else {\n        for (long long int i = 0; i < ans.size(); i++) {\n          if (a % ans[i] != 0 && b % ans[i] != 0) {\n            ans.erase(ans.begin() + i);\n            i--;\n          }\n        }\n      }\n    }\n    if (ans.size() == 0) {\n      cout << -1;\n    } else {\n      cout << ans[0];\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import javafx.util.*;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Test5 {\n\n    Random rnd = new Random();\n    PrintWriter pw = new PrintWriter(System.out);\n\n    void run(){\n        int a = ni(), p1 = ni(), p2 = ni();\n        ArrayList<Integer> l1 = f(p1), l2 = f(p2);\n        ArrayList<Integer> l = new ArrayList<>();\n        for(long i : l1) if(i>1) l.add((int)i);\n        for(long i : l2) if(i>1 && !l.contains(i)) l.add((int)i);\n        for(int q=1; q<a; q++){\n            p1 = ni();\n            p2 = ni();\n            for(int w=0; w<l.size(); w++){\n                if(p1%l.get(w)==0 || p2%l.get(w)==0) continue;\n                l.remove(w--);\n            }\n            if(l.size()==0) break;\n        }\n        pw.print((l.size()>0 ? l.get(0) : -1)+\"\");\n        pw.flush();\n    }\n\n    static ArrayList<Integer> f(int a){\n        ArrayList<Integer> l = new ArrayList<>();\n        for(int q=2; q*q<=a && q<4; q++) if(a%q<1) for(; a%q<1;) {a/=q; l.add(q);}\n        for(int d=6, i=a; (d-1)*(d-1)<=i; d+=6){\n            if(a%(d-1)<1)for(; a%(d-1)<1; ) {a/=(d-1); l.add(d-1);}\n            if(a%(d+1)<1)for(; a%(d+1)<1; ) {a/=(d+1); l.add(d+1);}\n        }\n        if(a>1) l.add(a);\n        return l;\n    }\n\n    public static void main(String[] args) {\n        new Test5().run();\n    }\n\n    InputStream is = System.in;\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b)) ;\n        return b;\n    }\n\n    private double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    private char nc() {\n        return (char) skip();\n    }\n\n    private String nline(){\n        int b = readByte();\n        StringBuilder sb = new StringBuilder();\n        while (b!=10) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    private int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 150000 + 7;\nint n;\npair<int, int> a[MAXN];\nvector<int> getf(int x) {\n  vector<int> res;\n  for (int i = 2; i < 44722; i++) {\n    if (x % i == 0) {\n      res.push_back(i);\n      while (x % i == 0) x /= i;\n    }\n    if (x == 1) break;\n  }\n  if (x != 1) res.push_back(x);\n  return res;\n}\nbool check(int x) {\n  for (int i = 0; i < n; i++)\n    if ((a[i].first % x) && (a[i].second % x)) return false;\n  return true;\n}\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) scanf(\"%d%d\", &a[i].first, &a[i].second);\n  vector<int> f1 = getf(a[0].first);\n  vector<int> f2 = getf(a[0].second);\n  for (int i = 0; i < f1.size(); i++)\n    if (check(f1[i])) return printf(\"%d\\n\", f1[i]), 0;\n  for (int i = 0; i < f2.size(); i++)\n    if (check(f2[i])) return printf(\"%d\\n\", f2[i]), 0;\n  return puts(\"-1\");\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n = int(input())\nx,y = map(int,input().split())\nprimes = list()\narr = []\nfor i in [x,y]:\n    k = 2\n    while k * k <= i:\n        if i % k == 0:\n\n            while i % k == 0:\n                i //= k\n            primes.append(k)\n        k += 1\n    if i > 1:\n        primes.append(i)\nfor _ in range(n-1):\n    arr.append(list(map(int,input().split())))\nfor p in primes:\n    flag = True\n    for x,y in arr:\n        if x % p != 0 and y % p != 0:\n            flag = False\n            break\n    if flag:\n        print(p)\n        break\nelse:\n    print(-1)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n \n/* spar5h */ \n\npublic class cf2 implements Runnable{    \n\t\n\tpublic static long gcd (long a, long b) {\n    \t\n    \tif(b == 0)\n    \t\treturn a;\n    \t\n    \treturn(gcd(b, a % b));\n    }\n\t\n\tpublic void run() {\n\t    \n\t\tInputReader s = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\t\n\t\tint[] prime = new int[(int)1e5 + 1]; \n\t\tArrays.fill(prime, 1); prime[0] = 0; prime[1] = 0;\n\t\t\n\t\tfor(int i = 2; i <= (int)1e5; i++) {\n\t\t\t\n\t\t\tif(prime[i] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tfor(int j = 2; (long)i * j <= (int)1e5; j++)\n\t\t\t\tprime[i * j] = 0;\n\t\t}\n\t\t\n\t\tint t = 1;\n\t\t\n\t\twhile(t-- > 0) {\n\t\t\t\n\t\t\tint n = s.nextInt();\n\t\t\t\n\t\t\tlong[] a = new long[n + 1];\n\t\t\tlong[] b = new long[n + 1];\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\ta[i] = s.nextLong(); b[i] = s.nextLong();\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 1) {\n\t\t\t\tw.println(a[1]); continue;\n\t\t\t}\n\t\t\t\n\t\t\tlong val = a[1] * b[1];\n\t\t\t\n\t\t\tfor(int i = 2; i <= n - 1; i++)\n\t\t\t\tval = gcd(val, a[i] * b[i]);\n\t\t\t\n\t\t\tlong x = gcd(val, a[n]);\n\t\t\tlong y = gcd(val, b[n]);\n\t\t\t\n\t\t\tif(x == 1 && y == 1) {\n\t\t\t\tw.println(-1); continue;\n\t\t\t}\n\t\t\t\n\t\t\tlong res = -1;\n\t\t\t\n\t\t\tif(x > 1) {\n\t\t\t\t\n\t\t\t\tres = x;\n\t\t\t\t\n\t\t\t\tfor(int i = 1; (long)i * i <= x; i++) {\n\t\t\t\t\t\n\t\t\t\t\tif(prime[i] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tif(x % i == 0) {\n\t\t\t\t\t\tres = i; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\telse {\n\t\t\t\t\n\t\t\t\tres = y;\n\t\t\t\t\n\t\t\t\tfor(int i = 1; (long)i * i <= y; i++) {\n\t\t\t\t\t\n\t\t\t\t\tif(prime[i] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tif(y % i == 0) {\n\t\t\t\t\t\tres = i; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tw.println(res);\n\t\t}\n\t\t\n\t\tw.close();\n\t}\n\t\n\tstatic class InputReader {\n\t\t\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\t\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\t\t\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars==-1) \n\t\t\t\tthrow new InputMismatchException();\n\t\t\t\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t \n\t\tpublic String nextLine()\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n\t\t}\n\t\tpublic int nextInt()\n\t\t{\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile(isSpaceChar(c)) \n\t\t\t\tc = read();\n\t\t\t\n\t\t\tint sgn = 1;\n\t\t\t\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic long nextLong() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\t\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t{\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') \n\t\t\t{\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic String readString() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\n\t\t\treturn res.toString();\n\t\t}\n\t \n\t\tpublic boolean isSpaceChar(int c) \n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t \n\t\tpublic String next() \n\t\t{\n\t\t\treturn readString();\n\t\t}\n\t\t\n\t\tpublic interface SpaceCharFilter \n\t\t{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n    \n\tpublic static void main(String args[]) throws Exception\n\t{\n\t\tnew Thread(null, new cf2(),\"cf2\",1<<26).start();\n\t}\n}   \n\n"
        },
        {
            "language": 3,
            "solution": "import math\nn=int(input())\nlis=[]\nfor i in range(n):\n    lis.append(list(map(int,input().split())))\na=lis[0][0]\na1=lis[0][1]\nse=set()\n\ndef fac(a):\n    z=int(math.sqrt(a))\n    while(a):\n        \n        if a==2 or a==3:\n            se.add(a)\n            break\n            \n        for i in range(2,z+1):\n            if a%i==0:\n                se.add(i)\n                a=a//i\n                z=int(math.sqrt(a))\n                break\n        else:\n            if a!=1:\n                \n                se.add(a)\n                a=0\nflag=0\nfac(a)\nfac(a1)\nfor i in se:\n    for j in lis:\n        if j[0]%i!=0 and j[1]%i!=0:\n            break \n    else:\n        flag=1 \n        print(i)\n        break\nif flag==0:\n    print(-1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> fac;\nvoid func(int n) {\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) fac.push_back(i);\n    while (n % i == 0) n = n / i;\n  }\n  if (n != 1) fac.push_back(n);\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  long long a[n], b[n];\n  for (int i = 0; i < n; i++) cin >> a[i] >> b[i];\n  if (n == 1)\n    cout << a[0];\n  else {\n    func(a[0]);\n    func(b[0]);\n    for (auto i : fac) {\n      bool fnd = true;\n      for (int j = 1; j < n; j++) {\n        if (a[j] % i != 0 and b[j] % i != 0) {\n          fnd = false;\n          break;\n        }\n      }\n      if (fnd) {\n        cout << i;\n        return 0;\n      }\n    }\n    cout << -1;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nint a[200005][2];\nbool ok(int x) {\n  for (int i = 1; i <= N; i++)\n    if (a[i][0] % x && a[i][1] % x) return 0;\n  return 1;\n}\nint solve(int x) {\n  for (int i = 2; i * i <= x; i++)\n    if (x % i == 0) {\n      if (ok(i)) return i;\n      while (x % i == 0) x /= i;\n    }\n  return ok(x) && x > 1 ? x : -1;\n}\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cin >> N;\n  for (int i = 1; i <= N; i++) cin >> a[i][0] >> a[i][1];\n  cout << max(solve(a[1][0]), solve(a[1][1]));\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static OutWriter out;\n    static InReader in;\n\n    public static void main(String args[]) throws IOException {\n        in = new InReader();\n        out = new OutWriter();\n        int n = in.nextInt();\n        int a[] = new int[n];\n        int b[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n            b[i] = in.nextInt();\n        }\n        ArrayList<Integer> all = new ArrayList<>();\n\n            int aa = a[0];\n            int k = 2;\n            while (k < Math.sqrt(aa) + 10) {\n                if (aa % k == 0) {\n                    aa /= k;\n                    all.add(k);\n                } else {\n                    k++;\n                }\n            }\n            if (aa != 1) {\n                all.add(aa);\n            }\n            int bb = b[0];\n            k = 2;\n            while (k < Math.sqrt(bb) + 10) {\n                if (bb % k == 0) {\n                    bb /= k;\n                    all.add(k);\n                } else {\n                    k++;\n                }\n            }\n            if (bb != 1) {\n                all.add(bb);\n            }\n\n        boolean flag = false;\n        int p=-1;\n        while (all.size() != 0) {\n            p = all.remove(0);\n            flag = true;\n            for (int i = 0; i < n; i++) {\n                if (a[i] % p == 0 || b[i] % p == 0) {\n\n                } else {\n                    flag =false;\n                    p=-1;\n                    break;\n                }\n            }\n            if(flag){\n                break;\n            }\n        }\n        out.println(p);\n\n        out.close();\n    }\n\n    static class InReader {\n        BufferedReader in;\n\n        InReader(String name) throws IOException {\n            in = new BufferedReader(new FileReader(name));\n        }\n\n        InReader() {\n            in = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        StringTokenizer token = new StringTokenizer(\"\");\n\n        void update() throws IOException {\n            if (!token.hasMoreTokens()) {\n                String a = in.readLine();\n                if (a != null) {\n                    token = new StringTokenizer(a);\n                }\n            }\n        }\n\n        int nextInt() throws IOException {\n            update();\n            return Integer.parseInt(token.nextToken());\n        }\n\n        long nextLong() throws IOException {\n            update();\n            return Long.parseLong(token.nextToken());\n        }\n\n        double nextDouble() throws IOException {\n            update();\n            return Double.parseDouble(token.nextToken());\n        }\n\n        boolean hasNext() throws IOException {\n            update();\n            return token.hasMoreTokens();\n        }\n\n        String next() throws IOException {\n            update();\n            return token.nextToken();\n        }\n    }\n\n    static class OutWriter {\n        PrintWriter out;\n\n        OutWriter() {\n            out = new PrintWriter(System.out);\n        }\n\n        OutWriter(String name) throws IOException {\n            out = new PrintWriter(new FileWriter(name));\n        }\n\n        StringBuilder cout = new StringBuilder();\n\n        <T> void print(T a) {\n            cout.append(a);\n        }\n\n        <T> void println(T a) {\n            cout.append(a);\n            cout.append('\\n');\n        }\n\n        <T> void prints(T a) {\n            cout.append(a);\n            cout.append(' ');\n        }\n\n        void close() {\n            out.print(cout.toString());\n            out.close();\n        }\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.io.*;\n\npublic class WeakenedCommonDivisor {\n\n\t// https://codeforces.com/contest/1025/problem/B\n\t\n\tpublic static void main(String[] args) throws IOException, FileNotFoundException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t//BufferedReader in = new BufferedReader(new FileReader(\"WeakenedCommonDivisor\"));\n\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tlong[][] arr = new long[n][2];\n\t\tboolean two=true;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tStringTokenizer st = new StringTokenizer(in.readLine());\n\t\t\tarr[i][0] = Integer.parseInt(st.nextToken());\n\t\t\tarr[i][1] = Integer.parseInt(st.nextToken());\n\t\t\t\n\t\t\tif (arr[i][0] %2 == 1 && arr[i][1]%2 == 1) two=false;\n\t\t\twhile (arr[i][0]%2==0) arr[i][0] >>= 1;\n\t\t\twhile (arr[i][1]%2==0) arr[i][1] >>= 1;\n\t\t}\n\t\t\n\t\tif (two) {\n\t\t\tSystem.out.println(2);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tHashSet<Long> first = getprimeDivisors(arr[0][0]);\n\t\t\n\t\tfor (Long a : first) {\n\t\t\tboolean work=true;\n\t\t\tfor (int i=1; i<n; i++) {\n\t\t\t\tif (arr[i][0] %a != 0 && arr[i][1] %a != 0) {\n\t\t\t\t\twork=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (work) {\n\t\t\t\tSystem.out.println(a);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tHashSet<Long> sec = getprimeDivisors(arr[0][1]);\n\t\tfor (Long b : sec) {\n\t\t\tif (first.contains(b)) continue;\n\t\t\tboolean work=true;\n\t\t\tfor (int i=1; i<n; i++) {\n\t\t\t\tif (arr[i][0] %b != 0 && arr[i][1] %b != 0) {\n\t\t\t\t\twork=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (work) {\n\t\t\t\tSystem.out.println(b);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(-1);\n\t}\n\n\tpublic static HashSet<Long> getprimeDivisors(long n) { \n\t\tHashSet<Long> a = new HashSet<>();\n\t\tfor (long i = 3; i*i<=n; i++)  { \n            if (n%i==0) { \n                a.add(i);\n                while (n%i ==0) n/=i;\n            } \n//            if (i >= (long)Math.sqrt(n) && a.size() == 0) {\n//\t\t\t\ta.add(n);\n//\t\t\t\treturn a;\n//            }\n        }\n\t\tif (n!=1) a.add(n);\n\t\treturn a;\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.BigInteger;\nimport java.util.Map.Entry;\n\nimport static java.lang.Math.*;\n\npublic class B extends PrintWriter {\n\n    long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    BigInteger f(BigInteger x, BigInteger m) {\n        return x.multiply(x).add(BigInteger.ONE).mod(m);\n    }\n\n    long getDiv(long n) {\n        if (n == 1) {\n            return -1;\n        }\n        BigInteger m = BigInteger.valueOf(n);\n\n        if (m.isProbablePrime(20)) {\n            return n;\n        }\n\n        for (long d = 2; d <= 3003003; d++) {\n            if (n % d == 0) {\n                return d;\n            }\n        }\n\n        BigInteger x = BigInteger.ONE;\n        BigInteger y = BigInteger.ONE;\n\n        while (true) {\n            x = f(x, m);\n            y = f(f(y, m), m);\n\n            long g = gcd((x.longValue() - y.longValue() + n) % n, n);\n\n            if (1 < g && g < n) {\n                return g;\n            }\n        }\n    }\n\n    void run() {\n        long g = 0;\n        int n = nextInt();\n\n        for (int i = 0; i < n; i++) {\n            long a = nextInt();\n            long b = nextInt();\n\n            g = gcd(g, a * b);\n\n        }\n        println(getDiv(g));\n\n    }\n\n    void skip() {\n        while (hasNext()) {\n            next();\n        }\n    }\n\n    int[][] nextMatrix(int n, int m) {\n        int[][] matrix = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                matrix[i][j] = nextInt();\n        return matrix;\n    }\n\n    String next() {\n        while (!tokenizer.hasMoreTokens())\n            tokenizer = new StringTokenizer(nextLine());\n        return tokenizer.nextToken();\n    }\n\n    boolean hasNext() {\n        while (!tokenizer.hasMoreTokens()) {\n            String line = nextLine();\n            if (line == null) {\n                return false;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return true;\n    }\n\n    int[] nextArray(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = nextInt();\n        }\n        return array;\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException err) {\n            return null;\n        }\n    }\n\n    public B(OutputStream outputStream) {\n        super(outputStream);\n    }\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer = new StringTokenizer(\"\");\n    static Random rnd = new Random();\n    static boolean OJ;\n\n    public static void main(String[] args) throws IOException {\n        OJ = System.getProperty(\"ONLINE_JUDGE\") != null;\n        B solution = new B(System.out);\n        if (OJ) {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            solution.run();\n        } else {\n            reader = new BufferedReader(new FileReader(new File(B.class.getName() + \".txt\")));\n            long timeout = System.currentTimeMillis();\n            while (solution.hasNext()) {\n                solution.run();\n                solution.println();\n                solution.println(\"----------------------------------\");\n            }\n            solution.println(\"time: \" + (System.currentTimeMillis() - timeout));\n        }\n        solution.close();\n        reader.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Codechef\n{       static PrintWriter out=new PrintWriter(System.out);static FastScanner in = new FastScanner(System.in);static class FastScanner {BufferedReader br;StringTokenizer stok;FastScanner(InputStream is) {br = new BufferedReader(new InputStreamReader(is));}\n        String next() throws IOException {while (stok == null || !stok.hasMoreTokens()) {String s = br.readLine();if (s == null) {return null;}\n                stok = new StringTokenizer(s);}return stok.nextToken();}\n        int ni() throws IOException {return Integer.parseInt(next());}long nl() throws IOException {return Long.parseLong(next());}double nd() throws IOException {return Double.parseDouble(next());}char nc() throws IOException {return (char) (br.read());}String ns() throws IOException {return br.readLine();}\n        int[] nia(int n) throws IOException{int a[] = new int[n];for (int i = 0; i < n; i++)a[i] = ni();return a;}long[] nla(int n) throws IOException {long a[] = new long[n];for (int i = 0; i < n; i++)a[i] = nl();return a;}\n        double[] nda(int n)throws IOException {double a[] = new double[n];for (int i = 0; i < n; i++)a[i] = nd();return a;}int [][] imat(int n,int m) throws IOException{int mat[][]=new int[n][m];for(int i=0;i<n;i++){for(int j=0;j<m;j++)mat[i][j]=ni();}return mat;}\n    }\n\tstatic long mod=Long.MAX_VALUE;\n\tstatic HashSet<Integer> set=new HashSet<Integer>();\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{   int i,j;\n\t    HashSet<Integer> set=new HashSet<>();\n\t    HashMap<Integer,Integer> hm=new HashMap<Integer,Integer>();\n\t\tArrayList<Integer> arr=new ArrayList<>();\n\t\tint n=in.ni();\n\t\tint a[]=new int[n];\n\t\tint b[]=new int[n];\n\t\tfor(i=0;i<n;i++)\n\t\t{   a[i]=in.ni();\n\t\t    b[i]=in.ni();\n\t\t}\n\t\tint temp=a[0];\n\t\tfor( i=2;i<=Math.sqrt(temp);i++)\n\t    {  while(temp%i==0)\n\t       {    set.add(i);temp/=i;}\n\t    }\n\t    if(temp>=2)\n\t        set.add(temp);\n\t    temp=b[0];\n\t\tfor(i=2;i<=Math.sqrt(temp);i++)\n\t    {  while(temp%i==0)\n\t       {    set.add(i);temp/=i;}\n\t    }\n\t    if(temp>=2)\n\t        set.add(temp);\n\t   // out.println(set);\n\t    int flag=0,ans=0;\n\t\tfor(int c:set)\n\t\t{   //out.println(c);\n\t\t    flag=0;\n\t\t    for(i=0;i<n;i++)\n\t\t    {   //out.println(a[i]%c+\" \"+b[i]%c);\n\t\t        if(a[i]%c==0 || b[i]%c==0)\n\t\t            continue;\n\t\t        else\n\t\t            {flag=1;break;}\n\t\t    }\n\t\t    //out.println(\"flag=\"+flag);\n\t\t    if(flag==0)\n\t\t      {  ans=c;break;}\n\t\t    //out.println(\"_____________\");      \n\t\t}\n\t\tif(ans==0)\n\t\t    out.println(\"-1\");\n\t\t else\n\t\t    out.println(ans);\n\t\t\n\t\tout.close();\n\t}\n\tstatic class pair implements Comparable<pair>{\n\t\tint x, y;\n\t\tpublic pair(int x, int y){this.x = x; this.y = y;}\n\t\t@Override\n\t\tpublic int compareTo(pair arg0) \n\t\t{   if(x<arg0.x)    return 1;\n\t\t    else if(x==arg0.x)\n\t\t    {   if(y<arg0.y)    return -1;\n\t\t        else if(y>arg0.y)   return 1;\n\t\t        else    return 0;\n\t\t    }\n\t\t    else    return -1;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof pair)) return false;\n        pair key = (pair) o;\n        return x == key.x && y == key.y;}\n        public int hashCode() {int result = x;result = 31 * result + y;return result;}\n\t}\n\tstatic long gcd(long a,long b)\n\t{   if(b==0)\n\t        return a;\n\t    return gcd(b,a%b);    \n\t}\n\tstatic long exponent(long a,long n)\n\t{   long ans=1;\n\t    while(n!=0)\n\t    {   if(n%2==1)\n\t            ans=(ans*a)%mod;\n\t       a=(a*a)%mod;\n\t       n=n>>1;\n\t    }\n\t    return ans;\n\t}\n\tstatic int binarySearch(int a[], int item, int low, int high) \n    {   if (high <= low) \n            return (item > a[low])?  (low + 1): low; \n        int mid = (low + high)/2; \n        if(item == a[mid]) \n            return mid+1; \n        if(item > a[mid]) \n            return binarySearch(a, item, mid+1, high); \n        return binarySearch(a, item, low, mid-1); \n    } \n    static void merge(int arr[], int l, int m, int r) {   \n        int n1 = m - l + 1; int n2 = r - m; int L[] = new int [n1]; int R[] = new int [n2]; \n        \n        for (int i=0; i<n1; ++i) L[i] = arr[l + i]; for (int j=0; j<n2; ++j) R[j] = arr[m + 1+ j]; int i = 0, j = 0; int k = l; while (i < n1 && j < n2) {   if (L[i] <= R[j]) {   arr[k] = L[i]; i++; } else{   arr[k] = R[j]; j++; } k++; } while (i < n1){   arr[k] = L[i]; i++; k++; } while (j < n2) { arr[k] = R[j];   j++;     k++; } \n    } \n    static void Sort(int arr[], int l, int r) {if (l < r) {   int m = (l+r)/2; Sort(arr, l, m); Sort(arr , m+1, r); merge(arr, l, m, r); } } \n    \n    static void sort(int a[])\n    {Sort(a,0,a.length-1);}\n}"
        },
        {
            "language": 3,
            "solution": "n = int(input())\nfrom math import gcd\nal = []\nbl = []\ng = 0\nfor _ in range(n):\n    a,b = map(int,input().split())\n    g = gcd(g,a*b)\n    al.append(a)\n    bl.append(b)\nif(g==1):\n    print(-1)\n    exit(0)\nfor i in range(n):\n    x = gcd(g,al[i])\n    if(x>1):\n        g = x\n    x = gcd(g,bl[i])\n    if(x>1):\n        g = x\nif(g!=1):\n    print(g)\nelse:\n    print(-1)"
        },
        {
            "language": 3,
            "solution": "from math import gcd\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nx = 0\nfor _ in range(int(input())):\n\ta, b = map(int, input().split())\n\tx = gcd(x,a*b)\nif x == 1: print(-1)\nelse:\n\tif gcd(x,a) != 1: x = gcd(x,a)\n\telse:  x = gcd(x,b)\n\tn = int(x**(.5))\n\tmark = [False]*(n+1)\n\tmark[0] = mark[1] = True\n\tprimes = set()\n\tfor i in range(2,n+1):\n\t\tif mark[i] == False:\n\t\t\tif x%i == 0: \n\t\t\t\tprint(i)\n\t\t\t\tbreak\n\t\t\tprimes.add(i)\n\t\t\tfor j in range(i+i, n+1, i):\n\t\t\t\tmark[j] = True\n\telse: print(x)\t"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\n\ndef factorize(n):  # o(sqr(n))\n    c, ans = 2, [n]\n    while (c * c <= n):\n        if n % c == 0:\n            ans.extend([c, n // c])\n        c += 1\n\n    ans.sort()\n    primes = set()\n    for i in ans:\n        while n % i == 0:\n            n //= i\n            primes.add(i)\n    return list(primes)\n\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrints_2d = lambda n: [rints() for _ in range(n)]\n\nn = int(input())\na = rints_2d(n)\nfor i in range(2):\n    for f in factorize(a[0][i]):\n        ans = 1\n        for j in range(1, n):\n            ans &= a[j][0] % f == 0 or a[j][1] % f == 0\n        if ans:\n            print(f)\n            exit()\n\nprint(-1)\n"
        },
        {
            "language": 4,
            "solution": "/*\n    Author: @__goku__\n    ssrivastava990@gmail.com\n\n                   `\\-.   `\n                      \\ `.  `\n                       \\  \\ |\n              __.._    |   \\.       S O N - G O K U\n       ..---~~     ~ . |    Y\n         ~-.          `|    |\n            `.               `~~--.\n              \\                    ~.\n               \\                     \\__. . -- -  .\n         .-~~~~~      ,    ,            ~~~~~~---...._\n      .-~___        ,'/  ,'/ ,'\\          __...---~~~\n            ~-.    /._\\_( ,(/_. 7,-.    ~~---...__\n           _...>-  P\"\"6=`_/\"6\"~   6)    ___...--~~~\n            ~~--._ \\`--') `---'   9'  _..--~~~\n                  ~\\ ~~/_  ~~~   /`-.--~~\n                    `.  ---    .'   \\_\n                      `. \" _.-'     | ~-.,-------._\n                  ..._../~~   ./       .-'    .-~~~-.\n            ,--~~~ ,'...\\` _./.----~~.'/    /'       `-\n        _.-(      |\\    `/~ _____..-' /    /      _.-~~`.\n       /   |     /. ^---~~~~       ' /    /     ,'  ~.   \\\n      (    /    (  .           _ ' /'    /    ,/      \\   )\n      (`. |     `\\   - - - - ~   /'      (   /         .  |\n       \\.\\|       \\            /'        \\  |`.           /\n       /.'\\\\      `\\         /'           ~-\\         .  /\\\n      /,   (        `\\     /'                `.___..-      \\\n     | |    \\         `\\_/'                  //      \\.     |\n     | |     |                 _Seal_      /' |       |     |\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class C505B\n{\n    static PrintWriter out = new PrintWriter((System.out));\n    static Kioken sc = new Kioken();\n\n    public static void main(String args[]) throws IOException\n    {\n        int t = 1;\n        //t = sc.nextInt();\n        while (t-- > 0)\n        {\n            kamehameha();\n        }\n        out.close();\n    }\n\n    public static void kamehameha()\n    {\n        int n=sc.nextInt();\n        ArrayList<Pair> ar=new ArrayList<>();\n        for(int x=0;x<n;x++)\n        {\n            ar.add(new Pair(sc.nextInt(),sc.nextInt()));\n        }\n        int a=ar.get(0).a;\n        int b=ar.get(0).b;\n        HashSet<Integer> set=new HashSet<>();\n        set.add(a);\n        set.add(b);\n        for(int x=2;x<=Math.sqrt(a);x++)\n        {\n            if(a%x==0)\n            {\n                set.add(x);\n                set.add(a/x);\n            }\n        }\n        for(int x=2;x<=Math.sqrt(b);x++)\n        {\n            if(b%x==0)\n            {\n                set.add(x);\n                set.add(b/x);\n            }\n        }\n        boolean found=true;\n        for(int x=1;x<n;x++)\n        {\n            boolean c=false;\n            HashSet<Integer> t=new HashSet<>();\n            for(int d:set)\n            {\n                if(ar.get(x).a%d==0||ar.get(x).b%d==0)\n                {\n                    c=true;\n                    break;\n                }\n                else\n                {\n                    t.add(d);\n                }\n            }\n            for(int d:t)\n            {\n                set.remove(d);\n            }\n            if(!c)\n            {\n                found=false;\n                break;\n            }\n        }\n        if(found)\n        {\n            for(int d:set)\n            {\n                out.println(d);\n                return;\n            }\n        }\n        else\n        {\n            out.println(-1);\n        }\n    }\n    static class Pair\n    {\n        int a,b;\n        public Pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    public static int lower_bound(ArrayList<Integer> ar, int k)\n    {\n        int s = 0, e = ar.size();\n        while (s != e)\n        {\n            int mid = s + e >> 1;\n            if (ar.get(mid) <= k)\n            {\n                s = mid + 1;\n            }\n            else\n            {\n                e = mid;\n            }\n        }\n        return Math.abs(s) - 1;\n    }\n\n    public static int upper_bound(ArrayList<Integer> ar, int k)\n    {\n        int s = 0;\n        int e = ar.size();\n        while (s != e)\n        {\n            int mid = s + e >> 1;\n            if (ar.get(mid) < k)\n            {\n                s = mid + 1;\n            }\n            else\n            {\n                e = mid;\n            }\n        }\n        if (s == ar.size())\n        {\n            return -1;\n        }\n        return s;\n    }\n\n    static class Kioken\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        public String next()\n        {\n            while (!st.hasMoreTokens())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (Exception e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine()\n        {\n            try\n            {\n                return br.readLine();\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n            return null;\n        }\n\n        public boolean hasNext()\n        {\n            String next = null;\n            try\n            {\n                next = br.readLine();\n            }\n            catch (Exception e)\n            {\n            }\n            if (next == null || next.length() == 0)\n            {\n                return false;\n            }\n            st = new StringTokenizer(next);\n            return true;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class CF {\n    static List<Integer>[] gr;\n\n    static long[] arr;\n    static long n, m, p, q, k, ans;\n    static boolean b;\n    static long s;\n\n    static String big;\n    static long sum;\n\n    static boolean check(long mid) {\n\treturn s - mid * (k - 1) <= mid && s - mid * (k - 1) >= 0;\n    }\n\n    public static Set<Integer> f(long n) {\n\tSet<Integer> factors = new HashSet<>();\n\tfor (long d = 2; d * d <= n; d++) {\n\t    while (n % d == 0) {\n\t\tfactors.add((int) d);\n\t\tn /= d;\n\t    }\n\t}\n\tif (n > 1) {\n\t    factors.add((int) n);\n\t}\n\treturn factors;\n    }\n\n    public static void main(String[] args) {\n\tn = in.nextLong();\n//\tk = in.nextLong();\n//\ts = in.nextLong();\n//\tout.close();\n\tSet<Integer> set = new HashSet<>();\n\tset.addAll(f(in.nextLong()));\n\tset.addAll(f(in.nextLong()));\n\tfor (int i = 1; i < n; i++) {\n\t    Set<Integer> newS = new HashSet<>();\n\t    for (int j = 0; j < 2; j++) {\n\t\tint N = in.nextInt();\n\t\tfor (int div : set) {\n\t\t    if (N % div == 0) {\n\t\t\tnewS.add(div);\n\t\t    }\n\t\t}\n\t    }\n\t    set = newS;\n\t}\n\tif (set.size() != 0)\n\t    System.out.println(new ArrayList<>(set).get(0));\n\telse\n\t    System.out.println(-1);\n\tout.close();\n    }\n\n    static MyScanner in = new MyScanner();\n    static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n    static boolean valid(int[][] arr, int x, int y) {\n\treturn x >= 0 && y >= 0 && x < arr.length && y < arr[0].length;\n    }\n\n    static int[] d1 = { -1, -1, -1, 1, 1, 1, 0, 0 };\n    static int[] d2 = { 1, 0, -1, 0, -1, 1, -1, 1 };\n\n    static int DIRECTED = 1, UNDIRECTED = 0;\n\n    static long binSearch(long l, long r) {\n\tlong ans = -1, mid = 0;\n\twhile (l != r) {\n\t    mid = (l + r) / 2;\n\t    if (check(mid)) {\n\t\tans = mid;\n\t\tl = mid + 1;\n\t    } else {\n\t\tr = mid;\n\t    }\n\t}\n\treturn ans;\n    }\n\n    static void dfsTree(int root, int parent) {\n\tfor (int child : gr[root]) {\n\t    if (child == parent) {\n\t\tcontinue;\n\t    }\n\t    dfsTree(child, root);\n\t}\n    }\n\n    static List<Integer>[] readGraph(int dir, int n) {\n\tList<Integer>[] gr;\n\tgr = new ArrayList[(int) (n + 1)];\n\tfor (int i = 1; i <= n; i++) {\n\t    gr[i] = new ArrayList();\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t    int u = in.nextInt(), v = in.nextInt();\n\t    gr[v].add(u);\n\t    if (dir == UNDIRECTED) {\n\t\tgr[u].add(v);\n\t    }\n\t}\n\treturn gr;\n    }\n\n    public static long gcd(long a, long b) {\n\twhile (b != 0) {\n\t    long t = b;\n\t    b = a % b;\n\t    a = t;\n\t}\n\treturn Math.abs(a);\n    }\n\n    public static long lcm(long a, long b) {\n\treturn Math.abs(a / gcd(a, b) * b);\n    }\n\n    static class Pair implements Comparable<Pair> {\n\tlong a, b;\n\n\tpublic Pair(long a, long b) {\n\t    this.a = a;\n\t    this.b = b;\n\t}\n\n\t@Override\n\tpublic int compareTo(Pair p) {\n\t    return a == p.a ? 0 : (a > p.a ? 1 : -1);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t    final int prime = 31;\n\t    int result = 1;\n\t    result = prime * result + (int) (a ^ (a >>> 32));\n\t    result = prime * result + (int) (b ^ (b >>> 32));\n\t    return result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t    if (this == obj)\n\t\treturn true;\n\t    if (obj == null)\n\t\treturn false;\n\t    if (getClass() != obj.getClass())\n\t\treturn false;\n\t    Pair other = (Pair) obj;\n\t    if (a != other.a)\n\t\treturn false;\n\t    if (b != other.b)\n\t\treturn false;\n\t    return true;\n\t}\n    }\n\n    public static void sort(int[] arr) {\n\tList<Integer> l = new ArrayList<>();\n\tfor (int i : arr) {\n\t    l.add(i);\n\t}\n\tCollections.sort(l);\n\tfor (int i = 0; i < arr.length; i++) {\n\t    arr[i] = l.get(i);\n\t}\n    }\n\n    public static void sort(long[] arr) {\n\tList<Long> l = new ArrayList<>();\n\tfor (long i : arr) {\n\t    l.add(i);\n\t}\n\tCollections.sort(l);\n\tfor (int i = 0; i < arr.length; i++) {\n\t    arr[i] = l.get(i);\n\t}\n    }\n\n    public static class MyScanner {\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic MyScanner() {\n\t    br = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tString next() {\n\t    while (st == null || !st.hasMoreElements()) {\n\t\ttry {\n\t\t    st = new StringTokenizer(br.readLine());\n\t\t} catch (IOException e) {\n\t\t    e.printStackTrace();\n\t\t}\n\t    }\n\t    return st.nextToken();\n\t}\n\n\tint nextInt() {\n\t    return Integer.parseInt(next());\n\t}\n\n\tlong nextLong() {\n\t    return Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() {\n\t    return Double.parseDouble(next());\n\t}\n\n\tString nextLine() {\n\t    String str = \"\";\n\t    try {\n\t\tstr = br.readLine();\n\t    } catch (IOException e) {\n\t\te.printStackTrace();\n\t    }\n\t    return str;\n\t}\n    }\n}"
        },
        {
            "language": 1,
            "solution": "from sys import stdin, stdout\nimport sys\nfrom fractions import gcd\nfrom math import sqrt,log\nimport time\nfrom random import randint\nimport random\nfrom sets import Set\nimport sys\n# ---------- Number Theory -------------#\ndef primes_upto(maxn):\n    maxn+=1\n    A = [False]*(maxn/2+5)\n    p = 3\n    while p*p<maxn:\n        if not A[p>>1]:\n            for j in range(p*p,maxn,2*p):\n                A[(j>>1)]=True\n        p+=2\n    ret = [2]\n    for p in range(3,maxn,2):\n        if not A[(p>>1)]:\n            ret.append(p)\n    return ret\nst = time.time()\nprime_list = primes_upto(1000000)\ndef factor_sieve(maxn):\n    maxn+=1\n    factor = [0]*maxn\n    lim  = int(sqrt(maxn))\n    for i in range(2,lim+2):\n        if factor[i] == 0:\n            for j in range(i*i,maxn,i):\n                factor[j] = i\n    return factor\nfactor_list = factor_sieve(100000)\ndef totient_sieve(maxn): #returns an array of totient function\n    factor=[]\n    if maxn<100000:\n        factor = factor_list\n    else:\n        factor = factor_sieve(maxn)\n    maxn+=1\n    tot = [1]*maxn\n    tot[0] = 0\n    for i in range(2,maxn):\n        if factor[i] == 0:\n            tot[i] = i-1\n            continue\n        x = factor[i]\n        y=i/x\n        if y%x == 0:\n            tot[i] = tot[y]*x\n        else:\n            tot[i] = tot[y]*(x-1)\n    return tot\ndef mobius_sieve(maxn):\n    factor=[]\n    if maxn<100000:\n        factor = factor_list\n    else:\n        factor = factor_sieve(maxn)\n    maxn+=1\n    mu = [1]*maxn\n    for i in range(2,maxn):\n        if factor[i] == 0:\n            mu[i]=-1\n            continue\n        x = factor[i]\n        y=i/x\n        if y%x == 0:\n            mu[i] = 0\n        else:\n            mu[i]=mu[x]*mu[y]\n    return mu\ndef _try_composite(a, d, n, s):\n    if pow(a, d, n) == 1:\n        return False\n    for i in range(s):\n        if pow(a, 2**i * d, n) == n-1:\n            return False\n    return True # n  is definitely composite\n\ndef is_prime(n, _precision_for_huge_n=10):\n    if n < 2:\n        return False\n    if n in _known_primes:\n        return True\n    for p in _known_primes:\n        if n%p==0:\n            return False\n    d, s = n - 1, 0\n    while not d % 2:\n        d, s = d >> 1, s + 1\n    # Returns exact according to http://primes.utm.edu/prove/prove2_3.html\n    if n < 1373653:\n        return not any(_try_composite(a, d, n, s) for a in (2, 3))\n    if n < 25326001:\n        return not any(_try_composite(a, d, n, s) for a in (2, 3, 5))\n    if n < 118670087467:\n        if n == 3215031751:\n            return False\n        return not any(_try_composite(a, d, n, s) for a in (2, 3, 5, 7))\n    if n < 2152302898747:\n        return not any(_try_composite(a, d, n, s) for a in (2, 3, 5, 7, 11))\n    if n < 3474749660383:\n        return not any(_try_composite(a, d, n, s) for a in (2, 3, 5, 7, 11, 13))\n    if n < 341550071728321:\n        return not any(_try_composite(a, d, n, s) for a in (2, 3, 5, 7, 11, 13, 17))\n    return not any(_try_composite(a, d, n, s)\n                   for a in _known_primes[:_precision_for_huge_n])\n\n_known_primes = [2, 3]\n_known_primes += [x for x in range(5, 1000, 2) if is_prime(x)]\ndef brent(N):#Fails for perfect squares,primes\n        if N%2==0:\n                return 2\n        if N<100000:\n            return factor_list[N]\n        y,c,m = random.randint(1, N-1),random.randint(1, N-1),random.randint(1, N-1)\n        g,r,q = 1,1,1\n        while g==1:\n                x = y\n                for i in range(r):\n                        y = ((y*y)%N+c)%N\n                k = 0\n                while (k<r and g==1):\n                        ys = y\n                        for i in range(min(m,r-k)):\n                                y = ((y*y)%N+c)%N\n                                q = q*(abs(x-y))%N\n                        g = gcd(q,N)\n                        k = k + m\n                r = r*2\n        if g==N:\n                while True:\n                        ys = ((ys*ys)%N+c)%N\n                        g = gcd(abs(x-ys),N)\n                        if g>1:\n                                break\n\n        return g\ndef floor_sqrt(n):\n    x = max(0,int(sqrt(n))-1)\n    while x*x<=n:\n        x+=1\n    return x-1\ndef prime_factors(n):# Returns all prime factors of n\n    ret = Set()\n    if n==1:\n        return ret\n    if is_prime(n):\n        ret.add(n)\n        return ret\n    x = floor_sqrt(n)\n    if x*x == n:\n        return prime_factors(x)\n    x = brent(n)\n    n/=x\n    while n%x == 0:\n        n/=x\n    r1 = prime_factors(x)\n    r2 = prime_factors(n)\n    for i in r1:\n        ret.add(i)\n    for i in r2:\n        ret.add(i)\n    return ret\n\nn = int(stdin.readline())\na, b = [0] * n, [0] * n\ng = 0\nfor i in range(n):\n    a[i], b[i] = map(int, stdin.readline().split())\n    g = gcd(g, a[i] * b[i])    \n\ndef ok(p, n):\n    for j in range(n):\n        if a[j] % p != 0 and b[j] % p != 0:\n            return False\n    return True\n\npf = prime_factors(g)\nfor p in pf:\n    if ok(p, n):\n        print p\n        sys.exit()\nprint -1"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000005;\nchar nextchar() {\n  static char buf[100000], *p1 = buf, *p2 = buf;\n  return (p1 == p2) &&\n                 (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)\n             ? EOF\n             : *p1++;\n}\ntemplate <typename T>\nvoid input(T& num) {\n  static double f, x;\n  static char ch;\n  static bool sign;\n  static long long z;\n  f = 1.0 / 10;\n  z = x = ch = num = sign = 0;\n  while ((ch < '0') || (ch > '9')) {\n    sign |= (ch == '-');\n    ch = nextchar();\n  }\n  while ((ch >= '0') && (ch <= '9')) {\n    z = z * 10 + (ch - '0');\n    ch = nextchar();\n  }\n  if (ch == '.') {\n    ch = nextchar();\n    while ((ch >= '0') && (ch <= '9')) {\n      x += (ch ^ 48) * f;\n      f /= 10;\n      ch = nextchar();\n    }\n  }\n  num = sign ? -z - x : z + x;\n}\ntemplate <typename T, typename T1>\nvoid input(T& num, T1& num1) {\n  input(num), input(num1);\n}\ntemplate <typename T, typename T1, typename T2>\nvoid input(T& num, T1& num1, T2& num2) {\n  input(num), input(num1), input(num2);\n}\ntemplate <typename T, typename T1, typename T2, typename T3>\nvoid input(T& num, T1& num1, T2& num2, T3& num3) {\n  input(num), input(num1), input(num2), input(num3);\n}\nint N, f[MAXN], cnt;\nvoid read() {\n  input(N);\n  for (int i = 1; i <= N; i++) {\n    int a, b;\n    input(a, b);\n    if (i == 1) {\n      for (int j = 2; j * j <= a; j++) {\n        while (a != j) {\n          if (a % j == 0) {\n            f[cnt] = j;\n            cnt++;\n            a /= j;\n          } else {\n            break;\n          }\n        }\n      }\n      if (a > 1) f[cnt] = a, cnt++;\n      for (int j = 2; j * j <= b; j++) {\n        while (b != j) {\n          if (b % j == 0) {\n            f[cnt] = j;\n            cnt++;\n            b /= j;\n          } else {\n            break;\n          }\n        }\n      }\n      if (b > 1) f[cnt] = b, cnt++;\n      continue;\n    }\n    for (int j = 0; j <= cnt - 1; j++) {\n      if (a % f[j] != 0 && b % f[j] != 0) {\n        f[j] = -1;\n      }\n    }\n  }\n}\nvoid preprocess() {}\nvoid solve() {\n  for (int i = 0; i <= cnt - 1; i++) {\n    if (f[i] != -1) {\n      printf(\"%d\\n\", f[i]);\n      exit(0);\n    }\n  }\n}\nvoid print() {\n  printf(\"-1\\n\");\n  exit(0);\n}\nint main() {\n  read();\n  preprocess();\n  solve();\n  print();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\npair<int, int> d[150001];\nset<int> prime_divisors(int x) {\n  set<int> q;\n  for (int i = 2; i * i <= x; i++) {\n    if (!(x % i)) {\n      q.insert(i);\n      while (!(x % i)) {\n        x /= i;\n      }\n    }\n  }\n  if (x != 1) {\n    q.insert(x);\n  }\n  return q;\n}\nint main() {\n  cin >> n;\n  pair<int, int> p;\n  set<int> q;\n  for (int i = 0; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    p = {a, b};\n    d[i] = p;\n  }\n  set<int> a;\n  set<int> b;\n  set<int> c;\n  a = prime_divisors(d[0].first);\n  b = prime_divisors(d[0].second);\n  c.insert(a.begin(), a.end());\n  c.insert(b.begin(), b.end());\n  for (int i = 1; i < n; i++) {\n    queue<int> q;\n    for (auto j = c.begin(); j != c.end(); j++) {\n      if (d[i].first % (*j) != 0 && d[i].second % (*j) != 0) q.push(*j);\n    }\n    while (!q.empty()) {\n      c.erase(q.front());\n      q.pop();\n    }\n  }\n  if (c.size() == 0) {\n    cout << -1;\n    return 0;\n  } else {\n    cout << *c.begin();\n  }\n  cin >> n;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  pair<int, int> p[n];\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].first >> p[i].second;\n  }\n  set<int> s;\n  int x = p[0].first, y = p[0].second;\n  while (x % 2 == 0) {\n    x /= 2;\n    s.insert(2);\n  }\n  for (int i = 3; i * i <= x; i += 2) {\n    while (x % i == 0) {\n      x /= i;\n      s.insert(i);\n    }\n  }\n  if (x > 2) s.insert(x);\n  while (y % 2 == 0) {\n    y /= 2;\n    s.insert(2);\n  }\n  for (int i = 3; i * i <= y; i += 2) {\n    while (y % i == 0) {\n      y /= i;\n      s.insert(i);\n    }\n  }\n  if (y > 2) s.insert(y);\n  if (n == 1) {\n    cout << *(s.begin());\n    return 0;\n  }\n  map<int, int> m;\n  for (int i = 1; i < n; i++) {\n    int cnt = 0;\n    for (auto x : s) {\n      if (p[i].first % x == 0 || p[i].second % x == 0) {\n        m[x]++;\n        cnt++;\n      }\n    }\n    if (cnt == 0) {\n      cout << -1;\n      return 0;\n    }\n  }\n  for (auto x : m) {\n    if (x.second == n - 1) {\n      cout << x.first;\n      return 0;\n    }\n  }\n  cout << -1;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author iRawit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            long n = in.nextLong();\n            long m = 0;\n            for (long i = 1; i <= n; i++) {\n                long a = in.nextLong();\n                long b = in.nextLong();\n                m = gcd(m, lcm(a, b));\n                if (i == n)\n                    m = Math.max(gcd(m, a), gcd(m, b));\n            }\n            if (m < 2) {\n                out.print(-1);\n            } else\n                out.print(calc(m));\n        }\n\n        public long gcd(long x, long y) {\n            if (x == 0 || y == 0)\n                return x + y;\n            else {\n                long rem = x % y;\n                while (rem > 0) {\n                    x = y;\n                    y = rem;\n                    rem = x % y;\n                }\n                return y;\n            }\n        }\n\n        public long lcm(long x, long y) {\n            return x / gcd(x, y) * y;\n        }\n\n        public long calc(long val) {\n            int i;\n            for (i = 2; i <= 99999; i++) {\n                if (val % i == 0)\n                    return i;\n            }\n            return val;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n    static final int INF = (int) 1e9;\n    static final int mod = (int) (1e9 + 7);\n    static final short UNCALC = -1;\n    static final int max = (int) 1e5;\n    static ArrayList<Integer> primes;\n    static HashSet<Integer> primefacetors;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        sieve();\n        primefacetors = new HashSet<>();\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        int[] b = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n            b[i] = sc.nextInt();\n        }\n        generatePF(a[0]);\n        generatePF(b[0]);\n        int ans = -1;\n        search:\n        for (int x : primefacetors) {\n            for (int i = 0; i < n; i++)\n                if (a[i] % x != 0 && b[i] % x != 0) continue search;\n            ans = x;\n            break;\n        }\n        out.println(ans);\n        out.flush();\n        out.close();\n    }\n\n    static void generatePF(int n) {\n        for (int p : primes) {\n            if (1l * p * p > n) break;\n            while (n % p == 0) {\n                n /= p;\n                primefacetors.add(p);\n            }\n        }\n        if (n != 1) primefacetors.add(n);\n    }\n\n\n    static void sieve() {\n        primes = new ArrayList<>();\n        boolean[] isPrime = new boolean[max];\n        Arrays.fill(isPrime, true);\n        for (int i = 2; i < max; i++) {\n            if (!isPrime[i]) continue;\n            primes.add(i);\n            if (1l * i * i < max) {\n                for (int j = i * i; j < max; j += i)\n                    isPrime[j] = false;\n            }\n        }\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n        public Scanner(String file) throws Exception {\n            br = new BufferedReader(new FileReader(file));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public Long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n        public void waitForInput() throws InterruptedException {\n            Thread.sleep(3000);\n        }\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextDouble();\n            return ans;\n        }\n\n        public short nextShort() throws IOException {\n            return Short.parseShort(next());\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int prime(long long int n) {\n  if (n == 1) return 0;\n  long long int i;\n  for (i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) return 0;\n  }\n  return 1;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n;\n  cin >> n;\n  long long int a[n];\n  long long int b[n];\n  long long int i, j;\n  for (i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n  vector<long long int> v1, v2;\n  long long int temp;\n  for (i = 2; i < sqrt(a[0]); i++) {\n    if (a[0] % i == 0) {\n      if (prime(i) == 1) v1.push_back(i);\n      if (prime(a[0] / i) == 1) v1.push_back(a[0] / i);\n    }\n  }\n  temp = sqrt(a[0]);\n  if ((temp * temp) == a[0] && prime(temp) == 1) v1.push_back(temp);\n  if (prime(a[0]) == 1) v1.push_back(a[0]);\n  for (i = 2; i < sqrt(b[0]); i++) {\n    if (b[0] % i == 0) {\n      if (prime(i) == 1) v2.push_back(i);\n      if (prime(b[0] / i) == 1) v2.push_back(b[0] / i);\n    }\n  }\n  temp = sqrt(b[0]);\n  if ((temp * temp) == b[0] && prime(temp) == 1) v2.push_back(temp);\n  if (prime(b[0]) == 1) v2.push_back(b[0]);\n  long long int co = 0;\n  for (i = 0; i < v1.size(); i++) {\n    co = 0;\n    for (j = 0; j < n; j++) {\n      if (a[j] % v1[i] == 0 || b[j] % v1[i] == 0) {\n        co++;\n      }\n    }\n    if (co == n) {\n      cout << v1[i];\n      return 0;\n    }\n  }\n  co = 0;\n  for (i = 0; i < v2.size(); i++) {\n    co = 0;\n    for (j = 0; j < n; j++) {\n      if (a[j] % v2[i] == 0 || b[j] % v2[i] == 0) {\n        co++;\n      }\n    }\n    if (co == n) {\n      cout << v2[i];\n      return 0;\n    }\n  }\n  cout << \"-1\";\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "\"\"\"\nhttps://codeforces.com/problemset/problem/1025/B\n\"\"\"\n\nimport math\ndef get_divisors(n):\n    divs = set()\n    i = 2\n    while (i * i <= n):\n        if (n % i == 0):\n            divs.add(i)\n            while (n % i == 0): \n            \tn =  n / i\n    \n        i += 1;\n    \n    # for i in xrange(2, int(math.sqrt(n)) + 1):\n    #     if n%i == 0:\n    #         divs.add(i)\n    #         divs.add(n / i)\n\n    if (n != 1):\n    \tdivs.add(n)\n    return divs\n\n\ndef solve(pairs, n):\n\t\n\tfrom collections import Counter\n\tdivisors1 = get_divisors(pairs[0][0])\n\tdivisors2 = get_divisors(pairs[0][1])\n\n\tdivisors = divisors1.union(divisors2)\n\n\tfor d in divisors:\n\t\tflag = 0\n\t\tfor i in range(1, len(pairs)):\n\t\t\tif (pairs[i][0] % d != 0 and pairs[i][1] % d != 0):\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\n\t\tif (flag == 0):\n\t\t\treturn d\n\treturn -1\n\t# div_counter = Counter()\n\t# for p in pairs:\n\t# \tdiv_set = get_divisors(p[0]).union(get_divisors(p[1]))\n\t# \tfor e in div_set:\n\t# \t\tdiv_counter[e] += 1\n\n\t# for d in div_counter.keys():\n\t# \tif (div_counter[d] == n):\n\t# \t\treturn d\n\n\t\n\n\n\n\nn = int(raw_input())\npairs = []\nfor i in range(n):\n\tpairs.append(map(int, raw_input().split()))\n\n\nres = solve(pairs, n)\nprint res\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n// CFPS -> CodeForcesProblemSet\npublic final class CFPS {\n\tstatic FastReader fr = new FastReader();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic final int gigamod = 1000000007;\n\tstatic int t = 1;\n\tstatic double epsilon = 0.00000001;\n\t\n\tpublic static void main(String[] args) {\n\t\tOUTER: \n\t\tfor (int tc = 0; tc < t; tc++) {\n\t\t\t\n\t\t\tint n = fr.nextInt();\n\t\t\t\n\t\t\t// Observations: \n\t\t\t\n\t\t\t// 1. If the answer exists, it will be a number among\n\t\t\t// the prime factors of: \n\t\t\t// \t\ta. 1st of pair 1\n\t\t\t// \t\tb. 2nd of pair 1\n\t\t\t\n\t\t\t// We can try for every prime factor and check if it\n\t\t\t// happens for any.\n\t\t\t\n\t\t\tlong[][] ab = new long[n][2];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tab[i] = fr.nextLongArray(2);\n\t\t\t\n\t\t\tArrayList<Long> possPrimes = new ArrayList<>();\n\t\t\t\n\t\t\tTreeMap<Long, Integer> fnp1 = primeFactorization(ab[0][0]);\n\t\t\tTreeMap<Long, Integer> fnp2 = primeFactorization(ab[0][1]);\n\t\t\t\n\t\t\tfor (long factor : fnp1.keySet())\n\t\t\t\tpossPrimes.add(factor);\n\t\t\t\n\t\t\tfor (long factor : fnp2.keySet())\n\t\t\t\tpossPrimes.add(factor);\n\t\t\t\n\t\t\t// We will check for every possible factor, if it goes\n\t\t\t// through everything.\n\t\t\t\n\t\t\tfor (long factor : possPrimes) {\n\t\t\t\t// Checking if factor passes through.\n\t\t\t\tboolean passes = true;\n\t\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\t\tif (ab[i][0] % factor != 0 && ab[i][1] % factor != 0) {\n\t\t\t\t\t\tpasses = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (passes) {\n\t\t\t\t\tout.println(factor);\n\t\t\t\t\tcontinue OUTER;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(-1);\n\t\t}\n\t\tout.close();\n\t}\n\t\n\tstatic String reverse(String s) {\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = s.length();\n\t\t\n\t\tfor (int i = n - 1; i > -1; i--) {\n\t\t\tsb.append(s.charAt(i));\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic long power(long x, int y)\n\t  {\n\t\t// int p = 998244353;\n\t\t// int p = gigamod;\n\t    long res = 1; // Initialize result\n\t \n\t    x = x/* % p*/; // Update x if it is more than or\n\t    // equal to p\n\t \n\t    if (x == 0)\n\t      return 0; // In case x is divisible by p;\n\t \n\t    while (y > 0)\n\t    {\n\t \n\t      // If y is odd, multiply x with result\n\t      if ((y & 1) != 0)\n\t        res = (res * x)/* % p*/;\n\t \n\t      // y must be even now\n\t      y = y >> 1; // y = y/2\n\t      x = (x * x)/* % p*/;\n\t    }\n\t    return res;\n\t  }\n\t\n\t// Maps elements in a 2D matrix serially to elements in \n\t// a 1D array.\n\tstatic int mapTo1D(int row, int col, int n, int m) {\n\t\treturn row * m + col;\n\t}\n\t\n\t// Inverse of what the one above does.\n\tstatic int[] mapTo2D(int idx, int n, int m) {\n\t\tint[] rnc = new int[2];\n\t\trnc[0] = idx / m;\n\t\trnc[1] = idx % m;\n\t\treturn rnc;\n\t}\n\t\n\t// Checks if s has subsequence t.\n\tstatic boolean hasSubsequence(String s, String t) {\n\t\tchar[] schars = s.toCharArray();\n\t\tchar[] tchars = t.toCharArray();\n\t\tint slen = schars.length, tlen = tchars.length;\n\t\tint tctr = 0;\n\t\t\n\t\tif (slen < tlen) return false;\n\t\t\n\t\tfor (int i = 0; i < slen || i < tlen; i++) {\n\t\t\tif (tctr == tlen) break;\n\t\t\tif (schars[i] == tchars[tctr]) {\n\t\t\t\ttctr++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (tctr == tlen) return true;\n\t\treturn false;\n\t}\n\t\n\t// Returns the binary string of length at least bits.\n\tstatic String toBinaryString(long num, int bits) {\n\t\tStringBuilder sb = new StringBuilder(Long.toBinaryString(num));\n\t\tsb.reverse();\n\t\tfor (int i = sb.length(); i < bits; i++)\n\t\t\tsb.append('0');\n\t\treturn sb.reverse().toString();\n\t}\n\t\n\tstatic class CountMap extends TreeMap<Long, Integer>{\n\t\t\n\t\tCountMap() {\n\t\t}\n\t\t\n\t\tCountMap(CountMap cm) {\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic void removeTM(Long key) {\n\t\t\tsuper.remove(key);\n\t\t}\n\t\t\n\t\tpublic void removeTM(Integer key) {\n\t\t\tsuper.remove((long) key);\n\t\t}\n\t\t\n\t\tpublic Integer put(Long key) {\n\t\t\tif (super.containsKey(key)) {\n\t\t\t\treturn super.put(key, super.get(key) + 1);\n\t\t\t} else {\n\t\t\t\treturn super.put(key, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Integer put(int key) {\n\t\t\tif (super.containsKey((long) key)) {\n\t\t\t\treturn super.put((long) key, super.get((long) key) + 1);\n\t\t\t} else {\n\t\t\t\treturn super.put((long) key, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Integer remove(Long key) {\n\t\t\tInteger count = super.get(key);\n\t\t\tif (count == null) return -1;\n\t\t\tif (count == 1)\n\t\t\t\treturn super.remove(key);\n\t\t\telse\n\t\t\t\treturn super.put(key, super.get(key) - 1);\n\t\t}\n\t\t\n\t\tpublic Integer remove(int key) {\n\t\t\tInteger count = super.get((long) key);\n\t\t\tif (count == null) return -1;\n\t\t\tif (count == 1)\n\t\t\t\treturn super.remove((long) key);\n\t\t\telse\n\t\t\t\treturn super.put((long) key, super.get((long) key) - 1);\n\t\t}\n\t\t\n\t\tpublic Integer get(int key) {\n\t\t\tInteger count = super.get((long) key);\n\t\t\tif (count == null)\n\t\t\t\treturn 0;\n\t\t\treturn count;\n\t\t}\n\t\t\n\t\tpublic Integer get(long key) {\n\t\t\tInteger count = super.get(key);\n\t\t\tif (count == null)\n\t\t\t\treturn 0;\n\t\t\treturn count;\n\t\t}\n\t}\n\t\n\tstatic class Point implements Comparable<Point> {\n\t\tlong x;\n\t\tlong y;\n\t\tint id;\n\t\t\n\t\tPoint() {\n\t\t\tx = y = id = 0;\n\t\t}\n\t\t\n\t\tPoint(Point p) {\n\t\t\tthis.x = p.x;\n\t\t\tthis.y = p.y;\n\t\t\tthis.id = p.id;\n\t\t}\n\t\t\n\t\tPoint(long a, long b, int id) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t\tthis.id = id;\n\t\t}\n\t\t\n\t\tPoint(long a, long b) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\tif (this.x > o.x)\n\t\t\t\treturn 1;\n\t\t\tif (this.x < o.x)\n\t\t\t\treturn -1;\n\t\t\tif (this.y > o.y)\n\t\t\t\treturn 1;\n\t\t\tif (this.y < o.y)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tpublic boolean equals(Point that) {\n\t\t\treturn this.compareTo(that) == 0;\n\t\t}\n\t}\n\t\n\tstatic class PointComparator implements Comparator<Point> {\n\t\t@Override\n\t\tpublic int compare(Point o1, Point o2) {\n\t\t\t\n\t\t\t// Comparision has to be done by (a-b).\n\t\t\t\n\t\t\tlong amb1 = o1.x - o1.y;\n\t\t\tlong amb2 = o2.x - o2.y;\n\t\t\t\n\t\t\t// Order has to be reverse.\n\t\t\tif (amb1 > amb2) \n\t\t\t\treturn -1;\n\t\t\t\n\t\t\tif (amb2 > amb1)\n\t\t\t\treturn 1;\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t// Returns the largest power of k that fits into n.\n\tstatic int largestFittingPower(long n, long k) {\n\t\tint lo = 0, hi = logk(Long.MAX_VALUE, 3);\n\t\tint largestPower = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\t\n\t\t\tlong val = (long) Math.pow(k, mid);\n\t\t\tif (val <= n) {\n\t\t\t\tlargestPower = mid;\n\t\t\t\tlo = mid + 1;\n\t\t\t} else {\n\t\t\t\thi = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn largestPower;\n\t}\n\t\n\tstatic String bitSetToString(int set) {\n\t\t// We have to print all the elements that are present\n\t\t// in the set.\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tif (((set >> i) & 1) == 1) {\n\t\t\t\t// The 'i'th bit is on meaning that the element 'i' is \n\t\t\t\t// present in the set.\n\t\t\t\tsb.append((i + 1) + \" \");\n\t\t\t}\n\t\t}\n\t\tsb.append(\"\\n\");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String displayBitSet(long set) {\n\t\t// We have to print all the elements that are present\n\t\t// in the set.\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 60; i++) {\n\t\t\tif (((set >> i) & 1) == 1) {\n\t\t\t\t// The 'i'th bit is on meaning that the element 'i' is \n\t\t\t\t// present in the set.\n\t\t\t\tsb.append((i + 1) + \" \");\n\t\t\t}\n\t\t}\n\t\tsb.append(\"\\n\");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic int addToBitSet(int set, int element) {\n\t\tset = (set) | (1 << (element - 1));\n\t\treturn set;\n\t}\n\t\n\tstatic int removeFromBitSet(int set, int element) {\n\t\t// Checking whether the bit is present.\n\t\tif ((set & (1 << (element - 1))) == 0) return set;\n\t\tset = set ^ (1 << (element - 1));\n\t\treturn set;\n\t}\n\t\n\t// Returns map of factor and its power in the number.\n\tstatic TreeMap<Long, Integer> primeFactorization(long num) {\n\t\tTreeMap<Long, Integer> map = new TreeMap<>();\n\t\twhile (num % 2 == 0) {\n\t\t\tnum /= 2;\n\t\t\tInteger pwrCnt = map.get(2L);\n\t\t\tmap.put(2L, pwrCnt != null ? pwrCnt + 1 : 1);\n\t\t}\n\t\t\n\t\tfor (long i = 3; i * i <= num; i += 2) {\n\t\t\twhile (num % i == 0) {\n\t\t\t\tnum /= i;\n\t\t\t\tInteger pwrCnt = map.get(i);\n\t\t\t\tmap.put(i, pwrCnt != null ? pwrCnt + 1 : 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If the number is prime, we have to add it to the \n\t\t// map.\n\t\tif (num != 1)\n\t\t\tmap.put(num, 1);\n\t\t\n\t\treturn map;\n\t}\n\t\n\t// Returns map of factor and its power in the number.\n\tstatic TreeMap<Integer, Integer> primeFactorization(int num) {\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\t\twhile (num % 2 == 0) {\n\t\t\tnum /= 2;\n\t\t\tInteger pwrCnt = map.get(2);\n\t\t\tmap.put(2, pwrCnt != null ? pwrCnt + 1 : 1);\n\t\t}\n\t\t\n\t\tfor (int i = 3; i * i <= num; i += 2) {\n\t\t\twhile (num % i == 0) {\n\t\t\t\tnum /= i;\n\t\t\t\tInteger pwrCnt = map.get(i);\n\t\t\t\tmap.put(i, pwrCnt != null ? pwrCnt + 1 : 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If the number is prime, we have to add it to the \n\t\t// map.\n\t\tif (num != 1)\n\t\t\tmap.put(num, 1);\n\t\t\n\t\treturn map;\n\t}\n\t\n\tstatic TreeSet<Long> divisors(long num) {\n\t\tTreeSet<Long> divisors = new TreeSet<Long>();\n\t\tdivisors.add(1L);\n\t\tdivisors.add(num);\n\t\t\n\t\tfor (long i = 2; i * i <= num; i++) {\n\t\t\tif (num % i == 0) {\n\t\t\t\tdivisors.add(num/i);\n\t\t\t\tdivisors.add(i);\n\t\t\t}\n\t\t}\n\t\treturn divisors;\n\t}\n\t\n\tstatic void dfs(int node, boolean[] marked, ArrayList<Integer>[] adj) {\n\t\tif (marked[node]) return;\n\n\t\tmarked[node] = true;\n\t\tfor (int adjc : adj[node])\n\t\t\tdfs(adjc, marked, adj);\n\t}\n\t\n\t// Returns the index of the first element\n\t// larger than or equal to val.\n\tstatic int bsearch(int[] arr, int val, int lo, int hi) {\n\t\tint idx = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tif (arr[mid] >= val) {\n\t\t\t\tidx = mid;\n\t\t\t\thi = mid - 1;\n\t\t\t} else\n\t\t\t\tlo = mid + 1;\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\tstatic int bsearch(long[] arr, long val, int lo, int hi) {\n\t\tint idx = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tif (arr[mid] >= val) {\n\t\t\t\tidx = mid;\n\t\t\t\thi = mid - 1;\n\t\t\t} else\n\t\t\t\tlo = mid + 1;\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\t// Returns the index of the last element \n\t// smaller than or equal to val.\n\tstatic int bsearch(long[] arr, long val, int lo, int hi, boolean sMode) {\n\t\tint idx = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tif (arr[mid] > val) {\n\t\t\t\thi = mid - 1;\n\t\t\t} else {\n\t\t\t\tidx = mid;\n\t\t\t\tlo = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\tstatic int bsearch(int[] arr, long val, int lo, int hi, boolean sMode) {\n\t\tint idx = -1;\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tif (arr[mid] > val) {\n\t\t\t\thi = mid - 1;\n\t\t\t} else {\n\t\t\t\tidx = mid;\n\t\t\t\tlo = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\tstatic long factorial(long n) {\n\t\tif (n <= 1)\n\t\t\treturn 1;\n\t\tlong factorial = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfactorial = mod(factorial * i);\n\t\treturn factorial;\n\t}\n\t\n\tstatic long factorialInDivision(long a, long b) {\n\t\tif (a == b)\n\t\t\treturn 1;\n\t\tif (b < a) {\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t}\n\t\t\n\t\tlong factorial = 1;\n\t\tfor (long i = a + 1; i <= b; i++)\n\t\t\tfactorial = mod(factorial * i);\n\t\treturn factorial;\n\t}\n\t\n\tstatic BigInteger factorialInDivision(BigInteger a, BigInteger b) {\n\t\tif (a.equals(b))\n\t\t\treturn BigInteger.ONE;\n\t\treturn a.multiply(factorialInDivision(a.subtract(BigInteger.ONE), b));\n\t}\n\t\n\tstatic long nCr(long n, long r) {\n\t\tlong p = gigamod;\n\t    // Base case\n\t    if (r == 0)\n\t        return 1;\n\t \n\t    // Fill factorial array so that we\n\t    // can find all factorial of r, n\n\t    // and n-r\n\t    long fac[] = new long[(int)n + 1];\n\t    fac[0] = 1;\n\t    for (int i = 1; i <= n; i++)\n\t        fac[i] = fac[i - 1] * i % p;\n\t \n\t    return (fac[(int)n] * modInverse(fac[(int)r], p) % p\n\t                    * modInverse(fac[(int)n - (int)r], p) % p) % p;\n\t}\n\t\n\tstatic long modInverse(long n, long p) {\n\t    return power(n, p - 2, p);\n\t}\n\t\n\tstatic long power(long x, long y, long p) {\n\t    long res = 1; // Initialize result\n\t \n\t    x = x % p; // Update x if it is more than or\n\t    // equal to p\n\t \n\t    while (y > 0) {\n\t        // If y is odd, multiply x with result\n\t        if ((y & 1)==1)\n\t            res = (res * x) % p;\n\t \n\t        // y must be even now\n\t        y = y >> 1; // y = y/2\n\t        x = (x * x) % p;\n\t    }\n\t    return res;\n\t}\n\t\n\tstatic long nPr(long n, long r) {\n\t\treturn factorialInDivision(n, n - r);\n\t}\n\t\n\tstatic int log2(long n) {\n\t\treturn (int)(Math.log(n) / Math.log(2));\n\t}\n\t\n\tstatic double log2(long n, boolean doubleMode) {\n\t\treturn (Math.log(n) / Math.log(2));\n\t}\n\t\n\tstatic int logk(long n, long k) {\n\t\treturn (int)(Math.log(n) / Math.log(k));\n\t}\n\t\n\t// Sieve of Eratosthenes: \n\tstatic boolean[] primeGenerator(int upto) {\n\t\tboolean[] isPrime = new boolean[upto + 1];\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[1] = isPrime[0] = false;\n\n\t\tfor (long i = 2; i * i < upto + 1; i++)\n\t\t\tif (isPrime[(int) i])\n\t\t\t\t// Mark all the multiples greater than or equal\n\t\t\t\t// to the square of i to be false.\n\t\t\t\tfor (long j = i; j * i < upto + 1; j++)\n\t\t\t\t\tisPrime[(int) j * (int) i] = false;\n\t\treturn isPrime;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn gcd(b, a % b);\n\t\t}\n\t}\n\t\n\tstatic long gcd(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn gcd(b, a % b);\n\t\t}\n\t}\n\t\n\tstatic int gcd(int[] arr) {\n\t\tint n = arr.length;\n\t\tint gcd = arr[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tgcd = gcd(gcd, arr[i]);\n\t\t}\n\t\treturn gcd;\n\t}\n\t\n\tstatic long gcd(long[] arr) {\n\t\tint n = arr.length;\n\t\tlong gcd = arr[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tgcd = gcd(gcd, arr[i]);\n\t\t}\n\t\treturn gcd;\n\t}\n\t\n\tstatic long lcm(int[] arr) {\n\t\tlong lcm = arr[0];\n\t\tint n = arr.length;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tlcm = (lcm * arr[i]) / gcd(lcm, arr[i]);\n\t\t}\n\t\treturn lcm;\n\t}\n\t\n\tstatic long lcm(long[] arr) {\n\t\tlong lcm = arr[0];\n\t\tint n = arr.length;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tlcm = (lcm * arr[i]) / gcd(lcm, arr[i]);\n\t\t}\n\t\treturn lcm;\n\t}\n\t\n\tstatic long lcm(int a, int b) {\n\t\treturn (a * b)/gcd(a, b);\n\t}\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn (a * b)/gcd(a, b);\n\t}\n\t\n\tstatic boolean less(int a, int b) {\n\t\treturn a < b ? true : false;\n\t}\n\t\n\tstatic boolean isSorted(int[] a) {\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif (less(a[i], a[i - 1]))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic boolean isSorted(long[] a) {\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif (a[i] < a[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic void swap(int[] a, int i, int j) {\n\t\tint temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\t\n\tstatic void swap(long[] a, int i, int j) {\n\t\tlong temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\t\n\tstatic void swap(double[] a, int i, int j) {\n\t\tdouble temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\t\n\tstatic void swap(char[] a, int i, int j) {\n\t\tchar temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\t\n\tstatic void sort(int[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t}\n\t\n\tstatic void sort(char[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t}\n\t\n\tstatic void sort(long[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t}\n\t\n\tstatic void sort(double[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t}\n\t\n\tstatic void reverseSort(int[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n/2; i++)\n\t\t\tswap(arr, i, n - 1 - i);\n\t}\n\t\n\tstatic void reverseSort(char[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n/2; i++)\n\t\t\tswap(arr, i, n - 1 - i);\n\t}\n\t\n\tstatic void reverseSort(long[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n/2; i++)\n\t\t\tswap(arr, i, n - 1 - i);\n\t}\n\t\n\tstatic void reverseSort(double[] arr) {\n\t\tshuffleArray(arr, 0, arr.length - 1);\n\t\tArrays.sort(arr);\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n/2; i++)\n\t\t\tswap(arr, i, n - 1 - i);\n\t}\n\t\n\tstatic void shuffleArray(long[] arr, int startPos, int endPos) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = startPos; i < endPos; ++i) {\n\t\t\tlong tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(endPos - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\t\n\tstatic void shuffleArray(int[] arr, int startPos, int endPos) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = startPos; i < endPos; ++i) {\n\t\t\tint tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(endPos - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\t\n\tstatic void shuffleArray(double[] arr, int startPos, int endPos) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = startPos; i < endPos; ++i) {\n\t\t\tdouble tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(endPos - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\t\n\tprivate static void shuffleArray(char[] arr, int startPos, int endPos) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = startPos; i < endPos; ++i) {\n\t\t\tchar tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(endPos - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\t\n\tstatic boolean isPrime(long n) {\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\n\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\treturn false;\n\n\t\tfor (long i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tstatic String toString(int[] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\tsb.append(dp[i] + \" \");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(boolean[] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\tsb.append(dp[i] + \" \");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(long[] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\tsb.append(dp[i] + \" \");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(char[] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\tsb.append(dp[i] + \"\");\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(int[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\tsb.append(dp[i][j] + \"\");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(long[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\tsb.append(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(double[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\tsb.append(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic String toString(char[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\tsb.append(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic char toChar(int i) {\n\t\treturn (char) (i + 48);\n\t}\n\t\n\tstatic long mod(long a, long m) {\n\t    return (a%m + m) % m;\n\t}\n\t\n\tstatic long mod(long num) {\n\t\treturn (num % gigamod + gigamod) % gigamod;\n\t}\n\t\n\t// Uses weighted quick-union with path compression.\n\tstatic class UnionFind {\n\t    private int[] parent;  // parent[i] = parent of i\n\t    private int[] size;    // size[i] = number of sites in tree rooted at i\n\t                           // Note: not necessarily correct if i is not a root node\n\t    private int count;     // number of components\n\n\t    public UnionFind(int n) {\n\t        count = n;\n\t        parent = new int[n];\n\t        size = new int[n];\n\t        for (int i = 0; i < n; i++) {\n\t            parent[i] = i;\n\t            size[i] = 1;\n\t        }\n\t    }\n\n\t    // Number of connected components.\n\t    public int count() {\n\t        return count;\n\t    }\n\t  \n\t    // Find the root of p.\n\t    public int find(int p) {\n\t        int root = p;\n\t        while (root != parent[root])\n\t            root = parent[root];\n\t        while (p != root) {\n\t            int newp = parent[p];\n\t            parent[p] = root;\n\t            p = newp;\n\t        }\n\t        return root;\n\t    }\n\n\t    public boolean connected(int p, int q) {\n\t        return find(p) == find(q);\n\t    }\n\t    \n\t    public int numConnectedTo(int node) {\n\t    \treturn size[find(node)];\n\t    }\n\t    \n\t    // Weighted union.\n\t    public void union(int p, int q) {\n\t        int rootP = find(p);\n\t        int rootQ = find(q);\n\t        \n\t        if (rootP == rootQ) return;\n\n\t        // make smaller root point to larger one\n\t        if (size[rootP] < size[rootQ]) {\n\t            parent[rootP] = rootQ;\n\t            size[rootQ] += size[rootP];\n\t        }\n\t        else {\n\t            parent[rootQ] = rootP;\n\t            size[rootP] += size[rootQ];\n\t        }\n\t        count--;\n\t    }\n\t    \n\t    public static int[] connectedComponents(UnionFind uf) {\n\t    \t// We can do this in nlogn.\n\t    \t\n\t    \tint n = uf.size.length;\n\t    \tint[] compoColors = new int[n];\n\t    \tfor (int i = 0; i < n; i++)\n\t    \t\tcompoColors[i] = uf.find(i);\n\t    \t\n\t    \tHashMap<Integer, Integer> oldToNew = new HashMap<>();\n\t    \tint newCtr = 0;\n\t    \t\n\t    \tfor (int i = 0; i < n; i++) {\n\t    \t\t\n\t    \t\tint thisOldColor = compoColors[i];\n\t    \t\tInteger thisNewColor = oldToNew.get(thisOldColor);\n\t    \t\tif (thisNewColor == null)\n\t    \t\t\tthisNewColor = newCtr++;\n\t    \t\t\n\t    \t\toldToNew.put(thisOldColor, thisNewColor);\n\t    \t\tcompoColors[i] = thisNewColor;\n\t    \t}\n\t    \t\n\t    \treturn compoColors;\n\t    }\n\t}\n\t\n\tstatic class UGraph {\n\t\t// Adjacency list.\n\t\tprivate TreeSet<Integer>[] adj;\n\t\tprivate static final String NEWLINE = \"\\n\";\n\t\tprivate int E;\n\t\t\n\t\tpublic UGraph(int V) {\n\t\t\tadj = (TreeSet<Integer>[]) new TreeSet[V];\n\t\t\tE = 0;\n\t\t\tfor (int i = 0; i < V; i++)\n\t\t\t\tadj[i] = new TreeSet<Integer>();\n\t\t}\n\t\t\n\t\tpublic void addEdge(int from, int to) {\n\t\t\tif (adj[from].contains(to)) return;\n\t\t\tE++;\n\t\t\tadj[from].add(to);\n\t\t\tadj[to].add(from);\n\t\t}\n\t\t\n\t\tpublic TreeSet<Integer> adj(int from) {\n\t\t\treturn adj[from];\n\t\t}\n\t\t\n\t\tpublic int V() {\n\t\t\treturn adj.length;\n\t\t}\n\t\t\n\t\tpublic int E() {\n\t\t\treturn E;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\ts.append(V() + \" vertices, \" + E() + \" edges \" + NEWLINE);\n\t\t\tfor (int v = 0; v < V(); v++) {\n\t\t\t\ts.append(v + \": \");\n\t\t\t\tfor (int w : adj[v]) {\n\t\t\t\t\ts.append(w + \" \");\n\t\t\t\t}\n\t\t\t\ts.append(NEWLINE);\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\t\n\t\tpublic static void dfsMark(int current, boolean[] marked, UGraph g) {\n\t\t\tif (marked[current]) return;\n\t\t\t\n\t\t\tmarked[current] = true;\n\t\t\tIterable<Integer> adj = g.adj(current);\n\t\t\tfor (int adjc : adj)\n\t\t\t\tdfsMark(adjc, marked, g);\n\t\t}\n\t\t\n\t\tpublic static void dfsMark(int current, int from, long[] distTo, boolean[] marked, UGraph g, ArrayList<Integer> endPoints) {\n\t\t\tif (marked[current]) return;\n\t\t\t\n\t\t\tmarked[current] = true;\n\t\t\tif (from != -1)\n\t\t\t\tdistTo[current] = distTo[from] + 1;\n\t\t\tTreeSet<Integer> adj = g.adj(current);\n\t\t\tint alreadyMarkedCtr = 0;\n\t\t\tfor (int adjc : adj) {\n\t\t\t\tif (marked[adjc]) alreadyMarkedCtr++;\n\t\t\t\tdfsMark(adjc, current, distTo, marked, g, endPoints);\n\t\t\t}\n\t\t\t\n\t\t\tif (alreadyMarkedCtr == adj.size())\n\t\t\t\tendPoints.add(current);\n\t\t}\n\t\t\n\t\tpublic static void bfsOrder(int current, UGraph g) {\n\t\t}\n\t\t\n\t\tpublic static void dfsMark(int current, int[] colorIds, int color, UGraph g) {\n\t\t\tif (colorIds[current] != -1) return;\n\t\t\t\n\t\t\tcolorIds[current] = color;\n\t\t\tIterable<Integer> adj = g.adj(current);\n\t\t\tfor (int adjc : adj)\n\t\t\t\tdfsMark(adjc, colorIds, color, g);\n\t\t}\n\t\t\n\t\tpublic static int[] connectedComponents(UGraph g) {\n\t\t\tint n = g.V();\n\t\t\tint[] componentId = new int[n];\n\t\t\tArrays.fill(componentId, -1);\n\t\t\tint colorCtr = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (componentId[i] != -1) continue;\n\t\t\t\tdfsMark(i, componentId, colorCtr, g);\n\t\t\t\tcolorCtr++;\n\t\t\t}\n\t\t\t\n\t\t\treturn componentId;\n\t\t}\n\t\t\n\t\tpublic static boolean hasCycle(UGraph ug) {\n\t\t\tint n = ug.V();\n\t\t\tboolean[] marked = new boolean[n];\n\t\t\tboolean[] hasCycleFirst = new boolean[1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (marked[i]) continue;\n\t\t\t\thcDfsMark(i, ug, marked, hasCycleFirst, -1);\n\t\t\t}\n\t\t\treturn hasCycleFirst[0];\n\t\t}\n\t\t\n\t\t// Helper for hasCycle.\n\t\tprivate static void hcDfsMark(int current, UGraph ug, boolean[] marked, boolean[] hasCycleFirst, int parent) {\n\t\t\tif (marked[current]) return;\n\t\t\tif (hasCycleFirst[0]) return;\n\t\t\t\n\t\t\tmarked[current] = true;\n\t\t\tTreeSet<Integer> adjc = ug.adj(current);\n\t\t\tfor (int adj : adjc) {\n\t\t\t\tif (marked[adj] && adj != parent && parent != -1) {\n\t\t\t\t\thasCycleFirst[0] = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\thcDfsMark(adj, ug, marked, hasCycleFirst, current);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Digraph {\n\t\t// Adjacency list.\n\t\tprivate HashSet<Integer>[] adj;\n\t\tprivate static final String NEWLINE = \"\\n\";\n\t\tprivate int E;\n\t\t\n\t\tpublic Digraph(int V) {\n\t\t\tadj = (HashSet<Integer>[]) new HashSet[V];\n\t\t\tE = 0;\n\t\t\tfor (int i = 0; i < V; i++)\n\t\t\t\tadj[i] = new HashSet<Integer>();\n\t\t}\n\t\t\n\t\tpublic void addEdge(int from, int to) {\n\t\t\tif (adj[from].contains(to)) return;\n\t\t\tE++;\n\t\t\tadj[from].add(to);\n\t\t}\n\t\t\n\t\tpublic HashSet<Integer> adj(int from) {\n\t\t\treturn adj[from];\n\t\t}\n\t\t\n\t\tpublic int V() {\n\t\t\treturn adj.length;\n\t\t}\n\t\t\n\t\tpublic int E() {\n\t\t\treturn E;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\ts.append(V() + \" vertices, \" + E() + \" edges \" + NEWLINE);\n\t\t\tfor (int v = 0; v < V(); v++) {\n\t\t\t\ts.append(v + \": \");\n\t\t\t\tfor (int w : adj[v]) {\n\t\t\t\t\ts.append(w + \" \");\n\t\t\t\t}\n\t\t\t\ts.append(NEWLINE);\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\t\n\t\tpublic static void dfsMark(int source, boolean[] marked, Digraph g) {\n\t\t\tif (marked[source]) return;\n\t\t\t\n\t\t\tmarked[source] = true;\n\t\t\tIterable<Integer> adj = g.adj(source);\n\t\t\tfor (int adjc : adj)\n\t\t\t\tdfsMark(adjc, marked, g);\n\t\t}\n\t\t\n\t\tpublic static void bfsOrder(int source, Digraph g) {\n\t\t}\n\t\t\n\t\tprivate static void dfsMark(int source, int[] colorIds, int color, Digraph g) {\n\t\t\tif (colorIds[source] != -1) return;\n\t\t\t\n\t\t\tcolorIds[source] = color;\n\t\t\tIterable<Integer> adj = g.adj(source);\n\t\t\tfor (int adjc : adj)\n\t\t\t\tdfsMark(adjc, colorIds, color, g);\n\t\t}\n\t\t\n\t\tpublic static int[] connectedComponents(Digraph g) {\n\t\t\tint n = g.V();\n\t\t\tint[] componentId = new int[n];\n\t\t\tArrays.fill(componentId, -1);\n\t\t\tint colorCtr = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (componentId[i] != -1) continue;\n\t\t\t\tdfsMark(i, componentId, colorCtr, g);\n\t\t\t\tcolorCtr++;\n\t\t\t}\n\t\t\t\n\t\t\treturn componentId;\n\t\t}\n\t\t\n\t\tpublic static Stack<Integer> topologicalSort(Digraph dg)\n\t\t{\n\t\t\t// dg has to be a directed acyclic graph.\n\t\t\t// We'll have to run dfs on the digraph and push the deepest nodes on stack first.\n\t\t\t// We'll need a Stack<Integer> and a int[] marked.\n\t\t\tStack<Integer> topologicalStack = new Stack<Integer>();\n\t\t\tboolean[] marked = new boolean[dg.V()];\n\t\t\t\n\t\t\t// Calling dfs\n\t\t\tfor (int i = 0; i < dg.V(); i++)\n\t\t\t{\n\t\t\t\tif (!marked[i]) runDfs(dg, topologicalStack, marked, i);\n\t\t\t}\n\t\t\t\n\t\t\treturn topologicalStack;\n\t\t}\n\t\t\n\t\tstatic void runDfs(Digraph dg, Stack<Integer> topologicalStack, boolean[] marked, int source)\n\t\t{\n\t\t\tmarked[source] = true;\n\t\t\tfor (Integer adjVertex : dg.adj(source))\n\t\t\t{\n\t\t\t\tif (!marked[adjVertex]) runDfs(dg, topologicalStack, marked, adjVertex);\n\t\t\t}\n\t\t\ttopologicalStack.add(source);\n\t\t}\n\t}\n\t\n\tstatic class FastReader {\n\t\tprivate BufferedReader bfr;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbfr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\tif (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(bfr.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn next().toCharArray()[0];\n\t\t}\n\n\t\tString nextString() {\n\t\t\treturn next();\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarr[i] = nextInt();\n\t\t\treturn arr;\n\t\t}\n\t\t\n\t\tint[] nextOneIntArray(int n) {\n\t\t\tint[] arr = new int[n + 1];\n\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\tarr[i] = nextInt();\n\t\t\treturn arr;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] arr = new double[n];\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tarr[i] = nextDouble();\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarr[i] = nextLong();\n\t\t\treturn arr;\n\t\t}\n\t\t\n\t\t/*public char[] nextCharArray(int n) {\n\t\t\tchar[] chars = new char[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tchars[i] = fr.nextChar();\n\t\t\treturn chars;\n\t\t}*/\n\t}\n\t\n\tprivate static class IndexMaxPQ<Key extends Comparable<Key>> implements Iterable<Integer> {\n\t    private int maxN;        // maximum number of elements on PQ\n\t    private int n;           // number of elements on PQ\n\t    private int[] pq;        // binary heap using 1-based indexing\n\t    private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i\n\t    private Key[] keys;      // keys[i] = priority of i\n\n\t    public IndexMaxPQ(int maxN) {\n\t        if (maxN < 0) throw new IllegalArgumentException();\n\t        this.maxN = maxN;\n\t        n = 0;\n\t        keys = (Key[]) new Comparable[maxN + 1];    // make this of length maxN??\n\t        pq   = new int[maxN + 1];\n\t        qp   = new int[maxN + 1];                   // make this of length maxN??\n\t        for (int i = 0; i <= maxN; i++)\n\t            qp[i] = -1;\n\t    }\n\n\t    public boolean isEmpty() {\n\t        return n == 0;\n\t    }\n\n\t    public boolean contains(int i) {\n\t        validateIndex(i);\n\t        return qp[i] != -1;\n\t    }\n\n\t    public int size() {\n\t        return n;\n\t    }\n\n\t   /**\n\t     * Associate key with index i.\n\t     *\n\t     * @param  i an index\n\t     * @param  key the key to associate with index {@code i}\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if there already is an item\n\t     *         associated with index {@code i}\n\t     */\n\t    public void insert(int i, Key key) {\n\t        validateIndex(i);\n\t        if (contains(i)) throw new IllegalArgumentException(\"index is already in the priority queue\");\n\t        n++;\n\t        qp[i] = n;\n\t        pq[n] = i;\n\t        keys[i] = key;\n\t        swim(n);\n\t    }\n\n\t    /**\n\t     * Returns an index associated with a maximum key.\n\t     *\n\t     * @return an index associated with a maximum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public int maxIndex() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        return pq[1];\n\t    }\n\n\t    /**\n\t     * Returns a maximum key.\n\t     *\n\t     * @return a maximum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public Key maxKey() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        return keys[pq[1]];\n\t    }\n\n\t    /**\n\t     * Removes a maximum key and returns its associated index.\n\t     *\n\t     * @return an index associated with a maximum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public int delMax() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        int max = pq[1];\n\t        exch(1, n--);\n\t        sink(1);\n\n\t        assert pq[n+1] == max;\n\t        qp[max] = -1;        // delete\n\t        keys[max] = null;    // to help with garbage collection\n\t        pq[n+1] = -1;        // not needed\n\t        return max;\n\t    }\n\n\t    /**\n\t     * Returns the key associated with index {@code i}.\n\t     *\n\t     * @param  i the index of the key to return\n\t     * @return the key associated with index {@code i}\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public Key keyOf(int i) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        else return keys[i];\n\t    }\n\n\t    /**\n\t     * Change the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to change\n\t     * @param  key change the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     */\n\t    public void changeKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        keys[i] = key;\n\t        swim(qp[i]);\n\t        sink(qp[i]);\n\t    }\n\n\t    /**\n\t     * Increase the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to increase\n\t     * @param  key increase the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if {@code key <= keyOf(i)}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void increaseKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        if (keys[i].compareTo(key) == 0)\n\t            throw new IllegalArgumentException(\"Calling increaseKey() with a key equal to the key in the priority queue\");\n\t        if (keys[i].compareTo(key) > 0)\n\t            throw new IllegalArgumentException(\"Calling increaseKey() with a key that is strictly less than the key in the priority queue\");\n\n\t        keys[i] = key;\n\t        swim(qp[i]);\n\t    }\n\n\t    /**\n\t     * Decrease the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to decrease\n\t     * @param  key decrease the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if {@code key >= keyOf(i)}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void decreaseKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        if (keys[i].compareTo(key) == 0)\n\t            throw new IllegalArgumentException(\"Calling decreaseKey() with a key equal to the key in the priority queue\");\n\t        if (keys[i].compareTo(key) < 0)\n\t            throw new IllegalArgumentException(\"Calling decreaseKey() with a key that is strictly greater than the key in the priority queue\");\n\t        keys[i] = key;\n\t        sink(qp[i]);\n\t    }\n\n\t    /**\n\t     * Remove the key on the priority queue associated with index {@code i}.\n\t     *\n\t     * @param  i the index of the key to remove\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void delete(int i) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        int index = qp[i];\n\t        exch(index, n--);\n\t        swim(index);\n\t        sink(index);\n\t        keys[i] = null;\n\t        qp[i] = -1;\n\t    }\n\n\t    // throw an IllegalArgumentException if i is an invalid index\n\t    private void validateIndex(int i) {\n\t        if (i < 0) throw new IllegalArgumentException(\"index is negative: \" + i);\n\t        if (i >= maxN) throw new IllegalArgumentException(\"index >= capacity: \" + i);\n\t    }\n\t    \n\t    private boolean less(int i, int j) {\n\t        return keys[pq[i]].compareTo(keys[pq[j]]) < 0;\n\t    }\n\n\t    private void exch(int i, int j) {\n\t        int swap = pq[i];\n\t        pq[i] = pq[j];\n\t        pq[j] = swap;\n\t        qp[pq[i]] = i;\n\t        qp[pq[j]] = j;\n\t    }\n\n\t    private void swim(int k) {\n\t        while (k > 1 && less(k/2, k)) {\n\t            exch(k, k/2);\n\t            k = k/2;\n\t        }\n\t    }\n\n\t    private void sink(int k) {\n\t        while (2*k <= n) {\n\t            int j = 2*k;\n\t            if (j < n && less(j, j+1)) j++;\n\t            if (!less(k, j)) break;\n\t            exch(k, j);\n\t            k = j;\n\t        }\n\t    }\n\n\n\t    /**\n\t     * Returns an iterator that iterates over the keys on the\n\t     * priority queue in descending order.\n\t     * The iterator doesn't implement {@code remove()} since it's optional.\n\t     *\n\t     * @return an iterator that iterates over the keys in descending order\n\t     */\n\t    public Iterator<Integer> iterator() {\n\t        return new HeapIterator();\n\t    }\n\n\t    private class HeapIterator implements Iterator<Integer> {\n\t        // create a new pq\n\t        private IndexMaxPQ<Key> copy;\n\n\t        // add all elements to copy of heap\n\t        // takes linear time since already in heap order so no keys move\n\t        public HeapIterator() {\n\t            copy = new IndexMaxPQ<Key>(pq.length - 1);\n\t            for (int i = 1; i <= n; i++)\n\t                copy.insert(pq[i], keys[pq[i]]);\n\t        }\n\n\t        public boolean hasNext()  { return !copy.isEmpty();                     }\n\t        public void remove()      { throw new UnsupportedOperationException();  }\n\n\t        public Integer next() {\n\t            if (!hasNext()) throw new NoSuchElementException();\n\t            return copy.delMax();\n\t        }\n\t    }\n\n\t}\n\t\n\tpublic static class IndexMinPQ<Key extends Comparable<Key>> implements Iterable<Integer> {\n\t    private int maxN;        // maximum number of elements on PQ\n\t    private int n;           // number of elements on PQ\n\t    private int[] pq;        // binary heap using 1-based indexing\n\t    private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i\n\t    private Key[] keys;      // keys[i] = priority of i\n\n\t    public IndexMinPQ(int maxN) {\n\t        if (maxN < 0) throw new IllegalArgumentException();\n\t        this.maxN = maxN;\n\t        n = 0;\n\t        keys = (Key[]) new Comparable[maxN + 1];    // make this of length maxN??\n\t        pq   = new int[maxN + 1];\n\t        qp   = new int[maxN + 1];                   // make this of length maxN??\n\t        for (int i = 0; i <= maxN; i++)\n\t            qp[i] = -1;\n\t    }\n\n\t    public boolean isEmpty() {\n\t        return n == 0;\n\t    }\n\n\t    public boolean contains(int i) {\n\t        validateIndex(i);\n\t        return qp[i] != -1;\n\t    }\n\n\t    public int size() {\n\t        return n;\n\t    }\n\n\t    /**\n\t     * Associates key with index {@code i}.\n\t     *\n\t     * @param  i an index\n\t     * @param  key the key to associate with index {@code i}\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if there already is an item associated\n\t     *         with index {@code i}\n\t     */\n\t    public void insert(int i, Key key) {\n\t        validateIndex(i);\n\t        if (contains(i)) throw new IllegalArgumentException(\"index is already in the priority queue\");\n\t        n++;\n\t        qp[i] = n;\n\t        pq[n] = i;\n\t        keys[i] = key;\n\t        swim(n);\n\t    }\n\n\t    /**\n\t     * Returns an index associated with a minimum key.\n\t     *\n\t     * @return an index associated with a minimum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public int minIndex() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        return pq[1];\n\t    }\n\n\t    /**\n\t     * Returns a minimum key.\n\t     *\n\t     * @return a minimum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public Key minKey() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        return keys[pq[1]];\n\t    }\n\n\t    /**\n\t     * Removes a minimum key and returns its associated index.\n\t     * @return an index associated with a minimum key\n\t     * @throws NoSuchElementException if this priority queue is empty\n\t     */\n\t    public int delMin() {\n\t        if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\");\n\t        int min = pq[1];\n\t        exch(1, n--);\n\t        sink(1);\n\t        assert min == pq[n+1];\n\t        qp[min] = -1;        // delete\n\t        keys[min] = null;    // to help with garbage collection\n\t        pq[n+1] = -1;        // not needed\n\t        return min;\n\t    }\n\n\t    /**\n\t     * Returns the key associated with index {@code i}.\n\t     *\n\t     * @param  i the index of the key to return\n\t     * @return the key associated with index {@code i}\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public Key keyOf(int i) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        else return keys[i];\n\t    }\n\n\t    /**\n\t     * Change the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to change\n\t     * @param  key change the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void changeKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        keys[i] = key;\n\t        swim(qp[i]);\n\t        sink(qp[i]);\n\t    }\n\n\t    /**\n\t     * Decrease the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to decrease\n\t     * @param  key decrease the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if {@code key >= keyOf(i)}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void decreaseKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        if (keys[i].compareTo(key) == 0)\n\t            throw new IllegalArgumentException(\"Calling decreaseKey() with a key equal to the key in the priority queue\");\n\t        if (keys[i].compareTo(key) < 0)\n\t            throw new IllegalArgumentException(\"Calling decreaseKey() with a key strictly greater than the key in the priority queue\");\n\t        keys[i] = key;\n\t        swim(qp[i]);\n\t    }\n\n\t    /**\n\t     * Increase the key associated with index {@code i} to the specified value.\n\t     *\n\t     * @param  i the index of the key to increase\n\t     * @param  key increase the key associated with index {@code i} to this key\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws IllegalArgumentException if {@code key <= keyOf(i)}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void increaseKey(int i, Key key) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        if (keys[i].compareTo(key) == 0)\n\t            throw new IllegalArgumentException(\"Calling increaseKey() with a key equal to the key in the priority queue\");\n\t        if (keys[i].compareTo(key) > 0)\n\t            throw new IllegalArgumentException(\"Calling increaseKey() with a key strictly less than the key in the priority queue\");\n\t        keys[i] = key;\n\t        sink(qp[i]);\n\t    }\n\n\t    /**\n\t     * Remove the key associated with index {@code i}.\n\t     *\n\t     * @param  i the index of the key to remove\n\t     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n\t     * @throws NoSuchElementException no key is associated with index {@code i}\n\t     */\n\t    public void delete(int i) {\n\t        validateIndex(i);\n\t        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n\t        int index = qp[i];\n\t        exch(index, n--);\n\t        swim(index);\n\t        sink(index);\n\t        keys[i] = null;\n\t        qp[i] = -1;\n\t    }\n\n\t    // throw an IllegalArgumentException if i is an invalid index\n\t    private void validateIndex(int i) {\n\t        if (i < 0) throw new IllegalArgumentException(\"index is negative: \" + i);\n\t        if (i >= maxN) throw new IllegalArgumentException(\"index >= capacity: \" + i);\n\t    }\n\n\t    private boolean greater(int i, int j) {\n\t        return keys[pq[i]].compareTo(keys[pq[j]]) > 0;\n\t    }\n\n\t    private void exch(int i, int j) {\n\t        int swap = pq[i];\n\t        pq[i] = pq[j];\n\t        pq[j] = swap;\n\t        qp[pq[i]] = i;\n\t        qp[pq[j]] = j;\n\t    }\n\n\t    private void swim(int k) {\n\t        while (k > 1 && greater(k/2, k)) {\n\t            exch(k, k/2);\n\t            k = k/2;\n\t        }\n\t    }\n\n\t    private void sink(int k) {\n\t        while (2*k <= n) {\n\t            int j = 2*k;\n\t            if (j < n && greater(j, j+1)) j++;\n\t            if (!greater(k, j)) break;\n\t            exch(k, j);\n\t            k = j;\n\t        }\n\t    }\n\n\n\t   /***************************************************************************\n\t    * Iterators.\n\t    ***************************************************************************/\n\n\t    /**\n\t     * Returns an iterator that iterates over the keys on the\n\t     * priority queue in ascending order.\n\t     * The iterator doesn't implement {@code remove()} since it's optional.\n\t     *\n\t     * @return an iterator that iterates over the keys in ascending order\n\t     */\n\t    public Iterator<Integer> iterator() { return new HeapIterator(); }\n\n\t    private class HeapIterator implements Iterator<Integer> {\n\t        // create a new pq\n\t        private IndexMinPQ<Key> copy;\n\n\t        // add all elements to copy of heap\n\t        // takes linear time since already in heap order so no keys move\n\t        public HeapIterator() {\n\t            copy = new IndexMinPQ<Key>(pq.length - 1);\n\t            for (int i = 1; i <= n; i++)\n\t                copy.insert(pq[i], keys[pq[i]]);\n\t        }\n\n\t        public boolean hasNext()  { return !copy.isEmpty();                     }\n\t        public void remove()      { throw new UnsupportedOperationException();  }\n\n\t        public Integer next() {\n\t            if (!hasNext()) throw new NoSuchElementException();\n\t            return copy.delMin();\n\t        }\n\t    }\n\n\t}\n\t\n\tpublic static class SegmentTree {\n\n\t    private Node[] heap;\n\t    private long[] array;\n\t    private int size;\n\n\t    /**\n\t     * Time-Complexity:  O(n*log(n))\n\t     *\n\t     * @param array the Initialization array\n\t     */\n\t    public SegmentTree(long[] array) {\n\t        this.array = Arrays.copyOf(array, array.length);\n\t        //The max size of this array is about 2 * 2 ^ log2(n) + 1\n\t        size = (int) (2 * Math.pow(2.0, Math.floor((Math.log((double) array.length) / Math.log(2.0)) + 1)));\n\t        heap = new Node[size];\n\t        build(1, 0, array.length);\n\t    }\n\n\n\t    public int size() {\n\t        return array.length;\n\t    }\n\n\t    //Initialize the Nodes of the Segment tree\n\t    private void build(int v, int from, int size) {\n\t        heap[v] = new Node();\n\t        heap[v].from = from;\n\t        heap[v].to = from + size - 1;\n\n\t        if (size == 1) {\n\t            heap[v].sum = array[from];\n\t            heap[v].min = array[from];\n\t        } else {\n\t            //Build childs\n\t            build(2 * v, from, size / 2);\n\t            build(2 * v + 1, from + size / 2, size - size / 2);\n\n\t            heap[v].sum = heap[2 * v].sum + heap[2 * v + 1].sum;\n\t            //min = min of the children\n\t            heap[v].min = Math.min(heap[2 * v].min, heap[2 * v + 1].min);\n\t        }\n\t    }\n\n\t    /**\n\t     * Range Sum Query\n\t     *\n\t     * Time-Complexity: O(log(n))\n\t     *\n\t     * @param  from from index\n\t     * @param  to to index\n\t     * @return sum\n\t     */\n\t    public long rangeSum(int from, int to) {\n\t        return rangeSum(1, from, to);\n\t    }\n\n\t    private long rangeSum(int v, int from, int to) {\n\t        Node n = heap[v];\n\n\t        //If you did a range update that contained this node, you can infer the Sum without going down the tree\n\t        if (n.pendingVal != null && contains(n.from, n.to, from, to)) {\n\t            return (to - from + 1) * n.pendingVal;\n\t        }\n\n\t        if (contains(from, to, n.from, n.to)) {\n\t            return heap[v].sum;\n\t        }\n\n\t        if (intersects(from, to, n.from, n.to)) {\n\t            propagate(v);\n\t            long leftSum = rangeSum(2 * v, from, to);\n\t            long rightSum = rangeSum(2 * v + 1, from, to);\n\n\t            return leftSum + rightSum;\n\t        }\n\n\t        return 0;\n\t    }\n\n\t    /**\n\t     * Range Min Query\n\t     * \n\t     * Time-Complexity: O(log(n))\n\t     *\n\t     * @param  from from index\n\t     * @param  to to index\n\t     * @return min\n\t     */\n\t    public long rangeMin(int from, int to) {\n\t        return rangeMin(1, from, to);\n\t    }\n\n\t    private long rangeMin(int v, int from, int to) {\n\t        Node n = heap[v];\n\n\n\t        //If you did a range update that contained this node, you can infer the Min value without going down the tree\n\t        if (n.pendingVal != null && contains(n.from, n.to, from, to)) {\n\t            return n.pendingVal;\n\t        }\n\n\t        if (contains(from, to, n.from, n.to)) {\n\t            return heap[v].min;\n\t        }\n\n\t        if (intersects(from, to, n.from, n.to)) {\n\t            propagate(v);\n\t            long leftMin = rangeMin(2 * v, from, to);\n\t            long rightMin = rangeMin(2 * v + 1, from, to);\n\n\t            return Math.min(leftMin, rightMin);\n\t        }\n\n\t        return Integer.MAX_VALUE;\n\t    }\n\n\n\t    /**\n\t     * Range Update Operation.\n\t     * With this operation you can update either one position or a range of positions with a given number.\n\t     * The update operations will update the less it can to update the whole range (Lazy Propagation).\n\t     * The values will be propagated lazily from top to bottom of the segment tree.\n\t     * This behavior is really useful for updates on portions of the array\n\t     * <p>\n\t     * Time-Complexity: O(log(n))\n\t     *\n\t     * @param from  from index\n\t     * @param to    to index\n\t     * @param value value\n\t     */\n\t    public void update(int from, int to, int value) {\n\t        update(1, from, to, value);\n\t    }\n\n\t    private void update(int v, int from, int to, int value) {\n\n\t        //The Node of the heap tree represents a range of the array with bounds: [n.from, n.to]\n\t        Node n = heap[v];\n\n\t        /**\n\t         * If the updating-range contains the portion of the current Node  We lazily update it.\n\t         * This means We do NOT update each position of the vector, but update only some temporal\n\t         * values into the Node; such values into the Node will be propagated down to its children only when they need to.\n\t         */\n\t        if (contains(from, to, n.from, n.to)) {\n\t            change(n, value);\n\t        }\n\n\t        if (n.size() == 1) return;\n\n\t        if (intersects(from, to, n.from, n.to)) {\n\t            /**\n\t             * Before keeping going down to the tree We need to propagate the\n\t             * the values that have been temporally/lazily saved into this Node to its children\n\t             * So that when We visit them the values  are properly updated\n\t             */\n\t            propagate(v);\n\n\t            update(2 * v, from, to, value);\n\t            update(2 * v + 1, from, to, value);\n\n\t            n.sum = heap[2 * v].sum + heap[2 * v + 1].sum;\n\t            n.min = Math.min(heap[2 * v].min, heap[2 * v + 1].min);\n\t        }\n\t    }\n\t    \n\t   /*public void rangeAdd(int tl, int tr, int l, int r, int add) {\n\t    \trangeAdd(1, tl, tr, l, r, add);\n\t    }\n\t    \n\t    private void rangeAdd(int v, int tl, int tr, int l, int r, int add) {\n\t        if (l > r)\n\t            return;\n\t        if (l == tl && r == tr) {\n\t            heap[v].sum += add;\n\t        } else {\n\t            int tm = (tl + tr) / 2;\n\t            rangeAdd(v*2, tl, tm, l, Math.min(r, tm), add);\n\t            rangeAdd(v*2+1, tm+1, tr, Math.max(l, tm+1), r, add);\n\t        }\n\t    }*/\n\n\t    //Propagate temporal values to children\n\t    private void propagate(int v) {\n\t        Node n = heap[v];\n\n\t        if (n.pendingVal != null) {\n\t            change(heap[2 * v], n.pendingVal);\n\t            change(heap[2 * v + 1], n.pendingVal);\n\t            n.pendingVal = null; //unset the pending propagation value\n\t        }\n\t    }\n\n\t    //Save the temporal values that will be propagated lazily\n\t    private void change(Node n, int value) {\n\t        n.pendingVal = value;\n\t        n.sum = n.size() * value;\n\t        n.min = value;\n\t        array[n.from] = value;\n\n\t    }\n\n\t    //Test if the range1 contains range2\n\t    private boolean contains(int from1, int to1, int from2, int to2) {\n\t        return from2 >= from1 && to2 <= to1;\n\t    }\n\n\t    //check inclusive intersection, test if range1[from1, to1] intersects range2[from2, to2]\n\t    private boolean intersects(int from1, int to1, int from2, int to2) {\n\t        return from1 <= from2 && to1 >= from2   //  (.[..)..] or (.[...]..)\n\t                || from1 >= from2 && from1 <= to2; // [.(..]..) or [..(..)..\n\t    }\n\n\t    //The Node class represents a partition range of the array.\n\t    static class Node {\n\t        long sum;\n\t        long min;\n\t        //Here We store the value that will be propagated lazily\n\t        Integer pendingVal = null;\n\t        int from;\n\t        int to;\n\n\t        int size() {\n\t            return to - from + 1;\n\t        }\n\n\t    }\n\t}\n}\n\n// NOTES: \n// ASCII VALUE OF 'A': 65\n// ASCII VALUE OF 'a': 97\n// Range of long: 9 * 10^18\n// ASCII VALUE OF '0': 48"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1E7 + 10, mod = 998244353;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long lcm(long long m, long long n) { return m * n / gcd(m, n); }\nlong long a[N], b[N], LCM[N];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  long long gd = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i] >> b[i];\n    LCM[i] = lcm(a[i], b[i]);\n  }\n  gd = LCM[0];\n  for (int i = 1; i < n; ++i) gd = gcd(gd, LCM[i]);\n  for (int i = 0; i < n; ++i) {\n    int gcd_A = gcd(a[i], gd);\n    if (gcd_A != 1) gd = gcd_A;\n    int gcd_B = gcd(b[i], gd);\n    if (gcd_B != 1) gd = gcd_B;\n  }\n  cout << (gd == 1 ? -1 : gd) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst unsigned long long MOD = 1e9 + 7;\nconst unsigned long long INF = 1e15 + 7;\nconst unsigned long long N = 1e6;\nunsigned long long gcd(unsigned long long a, unsigned long long b) {\n  unsigned long long r;\n  while (b) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\nunsigned long long fpow(unsigned long long n, unsigned long long k,\n                        unsigned long long p = MOD) {\n  unsigned long long r = 1;\n  for (; k; k >>= 1) {\n    if (k & 1) r = r * n % p;\n    n = n * n % p;\n  }\n  return r;\n}\nunsigned long long inv(unsigned long long a, unsigned long long p = MOD) {\n  return fpow(a, p - 2, p);\n}\nunsigned long long mult(unsigned long long a, unsigned long long b,\n                        unsigned long long p = MOD) {\n  return (unsigned long long)((a % p) * (b % p)) % p;\n}\nvector<unsigned long long> prime(N + 1);\nvoid sieve() {\n  prime[0] = prime[1] = 1;\n  for (unsigned long long i = 2; i <= N; i++) {\n    if (!prime[i]) {\n      prime[i] = i;\n      for (unsigned long long j = i * i; j <= N; j += i)\n        if (!prime[j]) prime[j] = i;\n    }\n  }\n}\nvector<unsigned long long> factor(unsigned long long n) {\n  vector<unsigned long long> ans;\n  for (int i = 2; i <= n; i++) {\n    if (prime[i]) {\n      ans.push_back(i);\n    }\n  }\n  return ans;\n}\nvector<unsigned long long> getfactor(unsigned long long x) {\n  vector<unsigned long long> ret;\n  while (x != 1) {\n    ret.push_back(prime[x]);\n    x = x / prime[x];\n  }\n  return ret;\n}\nvoid primefactor(unsigned long long n, set<unsigned long long> st) {\n  cout << \"sss\";\n  long long z = 2;\n  while (z * z <= n) {\n    if (n % z == 0) {\n      { st.insert(z); }\n      n /= z;\n    } else {\n      z++;\n    }\n  }\n  if (n > 1) {\n    st.insert(n);\n  }\n}\nint main() {\n  sieve();\n  unsigned long long tt;\n  cin >> tt;\n  unsigned long long x[tt], y[tt], xmin, xalter;\n  xmin = xalter = LLONG_MAX;\n  for (unsigned long long t = 0; t < tt; t++) {\n    cin >> x[t] >> y[t];\n    if (xmin > min(x[t], y[t])) {\n      xmin = min(x[t], y[t]);\n      xalter = max(x[t], y[t]);\n    }\n  }\n  unsigned long long o = xmin;\n  set<unsigned long long> st;\n  unsigned long long n = o;\n  long long z = 2;\n  while (z * z <= n) {\n    if (n % z == 0) {\n      { st.insert(z); }\n      n /= z;\n    } else {\n      z++;\n    }\n  }\n  if (n > 1) {\n    st.insert(n);\n  }\n  n = xalter;\n  z = 2;\n  while (z * z <= n) {\n    if (n % z == 0) {\n      { st.insert(z); }\n      n /= z;\n    } else {\n      z++;\n    }\n  }\n  if (n > 1) {\n    st.insert(n);\n  }\n  for (unsigned long long i = 0; i < tt; i++) {\n    std::set<unsigned long long>::iterator it = st.begin();\n    vector<set<unsigned long long>::iterator> vit;\n    vector<unsigned long long> vvv;\n    for (; it != st.end(); ++it) {\n      if (x[i] % (*it) == 0 || y[i] % (*it) == 0) {\n      } else {\n        vit.push_back(it);\n        vvv.push_back(*it);\n      }\n    }\n    vector<set<unsigned long long>::iterator>::iterator itr = vit.begin();\n    vector<unsigned long long>::iterator vvvit = vvv.begin();\n    for (; vvvit != vvv.end(); vvvit++) {\n      st.erase(*vvvit);\n    }\n  }\n  if (st.size() > 0) {\n    cout << (*st.begin()) << \"\\n\";\n  } else {\n    cout << \"-1\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ys(long long n) {\n  for (int i = 2; i <= sqrt(n); i++)\n    if (n % i == 0) return i;\n  return n;\n}\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nint main() {\n  long long n, a, b, a1, b1;\n  cin >> n >> a >> b;\n  while (--n) {\n    cin >> a1 >> b1;\n    a = gcd(a1 * b1, a);\n    b = gcd(a1 * b1, b);\n  }\n  if (a != 1)\n    cout << ys(a);\n  else if (b != 1)\n    cout << ys(b);\n  else\n    cout << -1;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.HashSet;\nimport java.util.Arrays; \nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.text.DecimalFormat;\nimport java.lang.Math;\nimport java.util.Iterator; \nimport java.util.TreeSet;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.util.*;\npublic class D1343{\n\tpublic static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n\tstatic long MOD = (long)(1e9+7);\n\tstatic FastReader sc = new FastReader();\n\tstatic int pInf = Integer.MAX_VALUE;\n\tstatic int nInf = Integer.MIN_VALUE;\n\tpublic static void main(String[] args){\n\t\tint test = 1;\n\t//\ttest = sc.nextInt();\n\t\twhile(test-->0){\n\t\t    int n = sc.nextInt();\n\t\t    TreeSet<Integer> S = new TreeSet<Integer>();\n\t\t    for(int j = 0; j < 1; j++){\n\t\t        int a = sc.nextInt();\n\t\t        int b = sc.nextInt();\n\t\t        \n\t\t        if (a % 2 == 0)\n                    S.add( 2);\n                while (a % 2 == 0)\n                    a /= 2;\n                for (int i = 3; i <= Math.sqrt(a); i += 2) {\n                    int flag = 0;\n                    while (a % i == 0) {\n                        a /= i;\n                        flag = 1;\n                    }\n                    if (flag == 1)\n                        S.add(i);\n                }\n                if (a > 2)\n                    S.add(a);\n                    \n                if (b % 2 == 0)\n                    S.add( 2);\n                while (b % 2 == 0)\n                    b /= 2;\n                for (int i = 3; i <= Math.sqrt(b); i += 2) {\n                    int flag = 0;\n                    while (b % i == 0) {\n                        b /= i;\n                        flag = 1;\n                    }\n                    if (flag == 1)\n                        S.add(i);\n                }\n                if (b > 2)\n                    S.add(b);    \n\t\t    }\n\t\t    TreeSet<Integer> ans = S;\n\t\t    for(int i = 1; i < n; i++){\n\t\t        int a = sc.nextInt();\n\t\t        int b = sc.nextInt();\n\t\t        TreeSet<Integer> temp = new TreeSet<Integer>();\n\t\t        for(int h:ans){\n\t\t            if(a%h==0 || b%h==0){\n\t\t               temp.add(h);\n\t\t            }\n\t\t        }\n\t\t        ans = temp;\n\t\t    }\n\t\t    if(ans.size()==0){\n\t\t        out.println(-1);\n\t\t    }\n\t\t    else{\n\t\t        out.println(ans.first());\n\t\t    }\n\t\t}\n\t\tout.close();\n\t}\n\t/*public static int bSearch(int[] a, int key){\n\t    int s = 0;\n\t    int e = a.length-1;\n\t    while(s<=e){\n\t        int m = s+(e-s)/2;\n\t        if(a[m]==key){\n\t            return a[m];\n\t        }\n\t        else if(a[m]>key){\n\t            e = m-1;\n\t        }\n\t        else{\n\t            s = m+1;\n\t        }\n\t    }\n\t    return a[s];\n\t}*/\n\tpublic static long mul(long a, long b){\n\t    return ((a%MOD)*(b%MOD))%MOD;\n\t}\n\tpublic static long add(long a, long b){\n\t    return ((a%MOD)+(b%MOD))%MOD;\n\t}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Integer.lowestOneBit(i)   Equals k where k is the position of the first one in the binary\n//Integer.highestOneBit(i)  Equals k where k is the position of the last one in the binary\n//Integer.bitCount(i)       returns the number of one-bits\n//Collections.sort(A,(p1,p2)->(int)(p2.x-p1.x)) To sort ArrayList in descending order wrt values of x.\n//            Arrays.parallelSort(a,new Comparator<TPair>() {\n//      \t\tpublic int compare(TPair a,TPair b) {\n//        \t\t\tif(a.y==b.y) return a.x-b.x;\n//        \t\t\treturn b.y-a.y;\n//        \t\t}\n//        \t});\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n   public static ArrayList<Integer>[] allPrimeFactors(int n){\n       ArrayList<Integer>[] A = new ArrayList[n+1];\n\t    for(int i = 2; i < n+1; i++){\n\t        A[i] = new ArrayList<Integer>();\n\t    }\n\t    for(int i = 2; i <= n; i++){\n\t        if(A[i].size()==0){\n\t            for(int j = i; j <= n; j+=i){\n\t                A[j].add(i);\n\t            }\n\t        }\n\t    }\n\t return A;\t    \n   }\n//PrimeFactors    \n    public static ArrayList<Long> primeFactors(long n) {\n        ArrayList<Long> arr = new ArrayList<>();\n        if (n % 2 == 0)\n            arr.add((long) 2);\n        while (n % 2 == 0)\n            n /= 2;\n        for (long i = 3; i <= Math.sqrt(n); i += 2) {\n            int flag = 0;\n            while (n % i == 0) {\n                n /= i;\n                flag = 1;\n            }\n            if (flag == 1)\n                arr.add(i);\n        }\n        if (n > 2)\n            arr.add(n);\n        return arr;\n    }\n//Pair Class\n\tstatic class Pair implements Comparable<Pair>{\n\t\tint x;\n\t\tint y;\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(this.x==o.x){\n\t\t\t    return (this.y-o.y);\n\t\t\t}\n\t\t\treturn (this.x-o.x);\n\t\t}\n\t}\n\tstatic class TPair{\n\t\tint x;\n\t\tint y;\n\t\tint z;\n\t\tpublic TPair(int x, int y, int z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\t}\n//Merge Sort\n\tstatic void merge(long arr[], int l, int m, int r)\n    {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n \n        /* Create temp arrays */\n        long L[] = new long [n1];\n        long R[] = new long [n2];\n \n        /*Copy data to temp arrays*/\n        for (int i=0; i<n1; ++i)\n            L[i] = arr[l + i];\n        for (int j=0; j<n2; ++j)\n            R[j] = arr[m + 1+ j];\n \n \n        /* Merge the temp arrays */\n \n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n \n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2)\n        {\n            if (L[i] <= R[j])\n            {\n                arr[k] = L[i];\n                i++;\n            }\n            else\n            {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n \n        /* Copy remaining elements of L[] if any */\n        while (i < n1)\n        {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n \n        /* Copy remaining elements of R[] if any */\n        while (j < n2)\n        {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n \n    // Main function that sorts arr[l..r] using\n    // merge()\n    static void sort(long arr[], int l, int r)\n    {\n        if (l < r)\n        {\n            // Find the middle point\n            int m = (l+r)/2;\n \n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr , m+1, r);\n \n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n//Brian Kernighan\u2019s Algorithm\n    static long countSetBits(long n){\n        if(n==0) return 0;\n        return 1+countSetBits(n&(n-1));\n    }\n//Factorial\n    static long factorial(long n){\n        if(n==1) return 1;\n        if(n==2) return 2;\n        if(n==3) return 6;\n        return n*factorial(n-1);\n    }\n//Euclidean Algorithm\n    static long gcd(long A,long B){\n        if(B==0) return A;\n        return gcd(B,A%B);\n    }\n//Modular Exponentiation\n    static long fastExpo(long x,long n){\n        if(n==0) return 1;\n        if((n&1)==0) return fastExpo((x*x)%MOD,n/2)%MOD;\n        return ((x%MOD)*fastExpo((x*x)%MOD,(n-1)/2))%MOD;\n    }\n//AKS Algorithm\n    static boolean isPrime(long n){\n        if(n<=1) return false;\n        if(n<=3) return true;\n        if(n%2==0 || n%3==0) return false;\n        for(int i=5;i<=Math.sqrt(n);i+=6)\n            if(n%i==0 || n%(i+2)==0) return false;\n        return true;\n    }\n//Reverse an array\n    static <T> void reverse(T arr[],int l,int r){\n    \tCollections.reverse(Arrays.asList(arr).subList(l, r));\n    }\n//Sieve of eratosthenes\n    static int[] findPrimes(int n){\n        boolean isPrime[]=new boolean[n+1];\n        ArrayList<Integer> a=new ArrayList<>();\n        int result[];\n        Arrays.fill(isPrime,true);\n        isPrime[0]=false;\n        isPrime[1]=false;\n        for(int i=2;i*i<=n;++i){\n            if(isPrime[i]==true){\n                for(int j=i*i;j<=n;j+=i) isPrime[j]=false;\n            }\n        }\n        for(int i=0;i<=n;i++) if(isPrime[i]==true) a.add(i);\n        result=new int[a.size()];\n        for(int i=0;i<a.size();i++) result[i]=a.get(i);\n        return result;\n        \n    }\n//Euler Totent function\n    static long countCoprimes(long n){\n        ArrayList<Long> prime_factors=new ArrayList<>();\n        long x=n,flag=0;\n        while(x%2==0){\n            if(flag==0) prime_factors.add(2L);\n            flag=1;\n            x/=2;\n        }\n        for(long i=3;i*i<=x;i+=2){\n            flag=0;\n            while(x%i==0){\n                if(flag==0) prime_factors.add(i);\n                flag=1;\n                x/=i;\n            }\n        }\n        if(x>2) prime_factors.add(x);\n        double ans=(double)n;\n        for(Long p:prime_factors){\n            ans*=(1.0-(Double)1.0/p);\n        }\n        return (long)ans;\n    }\n\tstatic long modulo = (long)1e9+7;\n\tpublic static long modinv(long x){\n\t    return modpow(x, modulo-2);\n\t}\n\tpublic static long modpow(long a, long b){\n\t    if(b==0){\n\t        return 1;\n\t    }\n\t    long x = modpow(a, b/2);\n\t    x = (x*x)%modulo;\n\t    if(b%2==1){\n\t        return (x*a)%modulo;\n\t    }\n\t    return x;\n\t}\n\tpublic static class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t//it reads the data about the specified point and divide the data about it ,it is quite fast\n\t\t//than using direct \n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception r) {\n\t\t\t\t\tr.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());//converts string to integer\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (Exception r) {\n\t\t\t\tr.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool prime[1000002];\nlong long int fun(set<long long int> s,\n                  vector<pair<long long int, long long int> > v, int n) {\n  for (auto i = s.begin(); i != s.end(); ++i) {\n    int c = 1;\n    for (int j = 1; j < n; ++j) {\n      if (v[j].first % (*i) == 0 || v[j].second % (*i) == 0) {\n        c++;\n      } else {\n        break;\n      }\n    }\n    if (c == n) {\n      return *i;\n    }\n  }\n  return -1;\n}\nset<long long int> primeFactors(long long int n) {\n  set<long long int> s;\n  while (n % 2 == 0) {\n    s.insert(2);\n    n = n / 2;\n  }\n  for (long long int i = 3; i <= sqrt(n); i = i + 2) {\n    while (n % i == 0) {\n      s.insert(i);\n      n = n / i;\n    }\n  }\n  if (n > 2) s.insert(n);\n  return s;\n}\nint main() {\n  long long int n;\n  cin >> n;\n  vector<pair<long long int, long long int> > v;\n  long long int x, y;\n  for (int i = 0; i < n; ++i) {\n    cin >> x >> y;\n    v.push_back(make_pair(x, y));\n  }\n  set<long long int> s = primeFactors(v[0].first);\n  long long int ans = fun(s, v, n);\n  if (ans != -1) {\n    printf(\"%lld \", ans);\n    return 0;\n  }\n  s = primeFactors(v[0].second);\n  ans = fun(s, v, n);\n  if (ans != -1) {\n    printf(\"%lld \", ans);\n    return 0;\n  }\n  printf(\"-1\");\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def fact(n):\n    i=2\n    arr=set()\n    while i*i<=n:\n        if n%i==0:\n            arr.add(i)\n            while n%i==0:n//=i\n        i+=1\n    if n>1:arr.add(n)\n    return list(arr)\narr=[]\nfor i in range(int(input())):\n    a,b=map(int,input().split())\n    arr.append([a,b])\na,b=arr[0]\nprime_dvsrs=list(set(fact(a)+fact(b)))\nfor i in prime_dvsrs:\n    flag=0\n    for j in range(1,len(arr)):\n        x,y=arr[j]\n        if x%i!=0 and y%i!=0:flag=1;break\n    if flag==0:print(i);break\nelse:print(-1)"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskB {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint[] a = new int[n];\n\t\t\tint[] b = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = in.nextInt();\n\t\t\t\tb[i] = in.nextInt();\n\t\t\t}\n\t\t\tSet<Integer> primes = new HashSet<>();\n\t\t\tadd(primes, a[0]);\n\t\t\tadd(primes, b[0]);\n\t\t\tfor (int p : primes) {\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (a[i] % p != 0 && b[i] % p != 0) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tout.println(p);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(-1);\n\t\t}\n\n\t\tprivate void add(Set<Integer> primes, int n) {\n\t\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\tif (n % p == 0) {\n\t\t\t\t\tprimes.add(p);\n\t\t\t\t\twhile (n % p == 0) {\n\t\t\t\t\t\tn /= p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n > 1) {\n\t\t\t\tprimes.add(n);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\n\ndef f(a):\n    s = []\n    n = a\n    for i in range(2, int(n ** .5) + 1):\n        if a % i == 0:\n            while a % i == 0:\n                a //= i\n            s.append(i)\n        i += 1\n    if a > 1:\n        s.append(a)\n    return s\n\n\ndef check(elem):\n    for item in a:\n        if item[0] % elem != 0 and item[1] % elem != 0:\n            return False\n    return True\n\n\nn = int(input())\na = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    a.append((x, y))\ns = f(a[0][0]) + f(a[0][1])\nfor elem in s:\n    if check(elem):\n        print(elem)\n        exit()\nprint(-1)\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin,stdout\nfrom fractions import gcd\nread,write = stdin.readline,stdout.write\n\nn = int(read())\npairs = [map(int,read().split()) for _ in xrange(n)]\n\nres = 0\nfor a,b in pairs:  res = gcd(a*b,res)\n\nfor a,b in pairs: gcdA,gcdB = gcd(res,a),gcd(res,b); res = gcdA if gcd(res,a) != 1 else gcdB\n\nwrite(str(res) if res != 1 else '-1')\n"
        },
        {
            "language": 1,
            "solution": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a%b\n    return a\nn = int(raw_input())\n\ndef mmc(a, b):\n    return (a*b) / gcd(a, b)\n\nab = []\nlista = []\nfor i in xrange(n):\n    a, b = map(int, raw_input().split())\n    ab.append((a, b))\n    lista.append(mmc(a, b))\n\n\np = lista[0]\nw = p\nfor x in xrange(1, n):\n    p = gcd(p, lista[x])\nq = p\n\nfor g in xrange(n):\n    l = gcd(p, ab[g][0]) \n    if l != 1:\n        p = l\n    l = gcd(p, ab[g][1]) \n    if l != 1:\n        p = l\n    \n\nif p == 0:\n    print w, q\nprint int(p) if p!=1 else -1"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntemplate <class T>\nvoid dbg(const char* xn, T x) {\n  if (0) cout << xn << \": \" << x << \"\\n\";\n}\ntemplate <class T, class... TA>\nvoid dbg(const char* xn, T x, TA... t) {\n  while (*xn != ',')\n    if (0) cout << *xn++;\n  if (0) cout << \": \" << x << \",\";\n  dbg(xn + 1, t...);\n}\ntemplate <class T>\ninline bool upd_max(T& x, T y) {\n  return y > x ? x = y, true : false;\n}\ntemplate <class T>\ninline bool upd_min(T& x, T y) {\n  return y < x ? x = y, true : false;\n}\nconst int N = 1000007;\nlong long n, A1[N], A2[N];\nmap<long long, long long> last, cnt;\nset<long long> S;\nvoid solve() {\n  cin >> n;\n  cin >> A1[1] >> A2[1];\n  long long x = A1[1];\n  for (long long i = 2; i * i <= x; ++i) {\n    if (x % i == 0) {\n      S.insert(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) S.insert(x);\n  x = A2[1];\n  for (long long i = 2; i * i <= x; ++i) {\n    if (x % i == 0) {\n      S.insert(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) S.insert(x);\n  for (long long i = 2; i <= n; ++i) cin >> A1[i] >> A2[i];\n  for (auto d : S) {\n    bool ok = 1;\n    for (long long i = 1; i <= (n); ++i) {\n      if ((A1[i] % d) != 0 && (A2[i] % d) != 0) {\n        ok = 0;\n        break;\n      }\n    }\n    if (ok) cout << d, exit(0);\n  }\n  cout << -1;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import javax.swing.plaf.synth.SynthOptionPaneUI;\nimport java.util.Scanner;\nimport java.util.*;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.negateExact;\n\n\npublic class Main {\n    static TreeSet<Integer> get(int x) {\n        TreeSet<Integer> res = new TreeSet<>();\n        for (int i = 2; i * i <= x; i++) {\n            if (x % i == 0) {\n                res.add(i);\n                while (x % i == 0) {\n                    x /= i;\n                }\n            }\n        }\n        if (x != 1) {\n            res.add(x);\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] a = new int[n];\n        int[] b = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n            b[i] = in.nextInt();\n        }\n        TreeSet<Integer> sa = get(a[0]);\n        TreeSet<Integer> sb = get(b[0]);\n        if (check(n, a, b, sa)) {\n            return;\n        }\n        if (check(n, a, b, sb)) {\n            return;\n        }\n        System.out.println(-1);\n\n    }\n\n    private static boolean check(int n, int[] a, int[] b, TreeSet<Integer> sb) {\n        for (int memb : sb) {\n            boolean check = true;\n            for (int i = 1; i < n; i++) {\n                if (a[i] % memb != 0 && b[i] % memb != 0) {\n                    check = false;\n                    break;\n                }\n            }\n            if (check) {\n                System.out.println(memb);\n                return true;\n            }\n        }\n        return false;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long st, f1, f2, res, k, ans, res1, res2, xx, yy, a[300000], b[300000],\n    c[300000], n, m, i, j;\nvector<long long> v1, v2;\nstring s;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  for (i = 0; i < n; i++) cin >> a[i] >> b[i];\n  for (i = 2; i < sqrt(a[0]) + 1; i++)\n    if (a[0] % i == 0) {\n      while (a[0] % i == 0) a[0] /= i;\n      v1.push_back(i);\n      if (a[0] == 1) break;\n    }\n  if (a[0] > 1) v1.push_back(a[0]);\n  for (i = 2; i < sqrt(b[0]) + 1; i++)\n    if (b[0] % i == 0) {\n      while (b[0] % i == 0) b[0] /= i;\n      v2.push_back(i);\n      if (b[0] == 1) break;\n    }\n  if (b[0] > 1) v2.push_back(b[0]);\n  for (i = 0; i < v1.size(); i++) {\n    for (j = 1; j < n; j++)\n      if (a[j] % v1[i] and b[j] % v1[i]) break;\n    if (n == j) {\n      cout << v1[i] << endl;\n      return 0;\n    }\n  }\n  for (i = 0; i < v2.size(); i++) {\n    for (j = 1; j < n; j++)\n      if (a[j] % v2[i] and b[j] % v2[i]) break;\n    if (n == j) {\n      cout << v2[i] << endl;\n      return 0;\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from math import sqrt\nn=input()\na,b=map(int,raw_input().split())\np=[]\ni=2\nwhile i<=sqrt(a):\n    if a%i==0:\n        p.append(i)\n        while a%i==0:\n            a/=i\n    i+=1\nif a>1:\n    p.append(a)\ni=2\nwhile i<=sqrt(b):\n    if b%i==0:\n        p.append(i)\n        while b%i==0:\n            b/=i\n    i+=1\nif b>1:\n    p.append(b)\np=set(p)\nq=[]\nfor _ in range(n-1):\n    q.append(map(int,raw_input().split()))\nf=False\n#print p\nfor i in p:\n    t=True\n    for j in range(n-1):\n        if q[j][0]%i!=0 and q[j][1]%i!=0:\n            t=False\n            break\n    if t:\n        f=True\n        ans=i\n        break\nif f:\n    print ans\nelse:\n    print -1"
        },
        {
            "language": 1,
            "solution": "import math\n\nn = int(raw_input())\n(a1,b1)=[int(x) for x in raw_input().split()]\n\nints=[]\nfor i in xrange(n-1):\n\t(a,b)=[int(x) for x in raw_input().split()]\n\tints.append((a,b))\n\nfactors={}\ndef factor(k):\n\tx=1\n\twhile(x<math.sqrt(k)+1):\n\t\tx+=1\n\t\tif(k%x==0):\n\t\t\tfactors[x]=True\n\t\t\tk/=x\n\t\t\tx-=1\n\tif(k>1):\n\t\tfactors[k]=True\n\nfactor(a1)\nfactor(b1)\n\nfor (a,b) in ints:\n\tfor p in factors.keys():\n\t\tif(a%p!=0 and b%p!=0):\n\t\t\tfactors.pop(p, None)\n\nps= factors.keys()\nif(len(ps)>0):\n\tprint(ps[0])\nelse:\n\tprint(\"-1\")"
        },
        {
            "language": 4,
            "solution": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class B {\n\n  public static boolean isPrime(long n) {\n    if (n < 2)\n      return false;\n    if (n == 2)\n      return true;\n    if (n % 2 == 0)\n      return false;\n    for (long i = 3; i * i <= n; i += 2)\n      if (n % i == 0)\n        return false;\n    return true;\n  }\n\n  public static void primeFactors(int n, Set<Integer> factors) {\n    for (int i = 2; i * i <= n; i++) {\n      if (isPrime(i) && n % i == 0) {\n        factors.add(i);\n        primeFactors(n / i, factors);\n        return;\n      }\n    }\n    factors.add(n);\n  }\n\n  public static void main(String[] args) {\n    Scanner inScanner = new Scanner(System.in);\n    int n = inScanner.nextInt();\n    Set<Integer> factors = null;\n    for (int i = 0; i < n; i++) {\n      int a = inScanner.nextInt();\n      int b = inScanner.nextInt();\n      if (factors == null) {\n        factors = new HashSet<>();\n        primeFactors(a, factors);\n        primeFactors(b, factors);\n      } else {\n        Set<Integer> newFactors = new HashSet<>();\n        for (int factor : factors) {\n          if (a % factor == 0 || b % factor == 0) {\n            newFactors.add(factor);\n          }\n        }\n        factors = newFactors;\n      }\n    }\n    if (factors.isEmpty())\n      System.out.println(-1);\n    else {\n      System.out.println(factors.iterator().next());\n    }\n    inScanner.close();\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin, stdout\nti = lambda : stdin.readline().strip()\nma = lambda fxn, ti : map(fxn, ti.split())\nol = lambda arr : stdout.write(' '.join(str(i) for i in arr) + '\\n')\nos = lambda i : stdout.write(str(i) + '\\n')\nolws = lambda arr : stdout.write(''.join(str(i) for i in arr) + '\\n')\n\n\nn = int(ti())\nvalues = []\nfor i in range(n):\n\tvalues.append(ma(int,ti()))\n\ndef primefactors(num):\n\tsets = set()\n\twhile num%2 == 0:\n\t\tsets.add(2)\n\t\tnum /= 2\n\n\ti = 3\n\twhile i*i <= num:\n\t\twhile num%i == 0:\n\t\t\tsets.add(i)\n\t\t\tnum /= i\n\t\ti += 2\n\n\tif num>2:\n\t\tsets.add(num)\n\n\treturn sets\n\n\na, b = values[0][0], values[0][1]\naset = primefactors(a)\nbset = primefactors(b)\n\n\nnewset = aset.union(bset)\nl = list(newset)\nfor item in l:\n\tpossible = True\n\tfor i in range(n):\n\t\ta, b = values[i][0], values[i][1]\n\t\tif a%item == 0 or b%item == 0:\n\t\t\tpass\n\t\telse:\n\t\t\tpossible = False\n\t\t\tbreak\n\tif possible:\n\t\tos(item)\n\t\texit()\nos(-1)"
        },
        {
            "language": 3,
            "solution": "n, m = int(input()), 10 ** 5\na = [list(map(int, input().split())) for i in range(n)]\np, v = [0 for i in range(m)], [0 for i in range(m)]\nfor i in range(2, m):\n\tif not v[i]:\n\t\tp[0] += 1\n\t\tp[p[0]] = i\n\tfor j in range(1, p[0] + 1):\n\t\tif i * p[j] >= m:\n\t\t\tbreak\n\t\tv[i * p[j]] = 1\n\t\tif i % p[j] == 0:\n\t\t\tbreak\ndef ok(x):\n\tglobal a\n\tfor i in a:\n\t\tif i[0] % x > 0 and i[1] % x > 0:\n\t\t\treturn False\n\treturn True\ndef judge(x):\n\tglobal p\n\tfor i in p[1:p[0] + 1]:\n\t\tif x % i == 0:\n\t\t\tif ok(i):\n\t\t\t\tprint(i)\n\t\t\t\treturn True\n\t\t\twhile x % i == 0:\n\t\t\t\tx //= i\n\tif x != 1:\n\t\tif ok(x):\n\t\t\tprint(x)\n\t\t\treturn True\n\treturn False\nif judge(a[0][0]):exit(0)\nif judge(a[0][1]):exit(0)\nprint(-1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7, MAX = 1e5 + 5;\nlong long powN(long long a, long long p) {\n  if (p == 0) return 1;\n  long long z = powN(a, p / 2);\n  z = (z * z) % MOD;\n  if (p % 2) z = (z * a) % MOD;\n  return z;\n}\nvector<bool> is_prime(MAX + 1, true);\nvoid Sieve() {\n  is_prime[0] = is_prime[1] = false;\n  int i, j;\n  for (i = 2; i * i <= MAX; i++) {\n    if (is_prime[i]) {\n      for (j = i * i; j <= MAX; j += i) is_prime[j] = false;\n    }\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  long long ans = 1;\n  set<long long> S;\n  Sieve();\n  for (int i = 0; i < n; i++) {\n    long long x, y;\n    cin >> x >> y;\n    if (i == 0) {\n      long long xx = x;\n      for (long long j = 2; j * j <= x; j++) {\n        if (!is_prime[j]) continue;\n        if (xx % j == 0) {\n          S.insert(j);\n          while (xx % j == 0) {\n            xx /= j;\n          }\n        }\n      }\n      if (xx != 1) S.insert(xx);\n      long long yy = y;\n      for (long long j = 2; j * j <= y; j++) {\n        if (!is_prime[j]) continue;\n        if (yy % j == 0) {\n          S.insert(j);\n          while (yy % j == 0) {\n            yy /= j;\n          }\n        }\n      }\n      if (yy != 1) S.insert(yy);\n    } else {\n      set<long long> TR;\n      for (auto s : S) {\n        if (x % s && y % s) {\n          TR.insert(s);\n        }\n      }\n      for (auto tr : TR) {\n        S.erase(tr);\n      }\n    }\n  }\n  if (S.size() == 0)\n    cout << -1 << endl;\n  else\n    cout << *S.begin() << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "q=int(input())\na,b=map(int,input().split())\ns=set()\nfor x in [a,b]:\n    if x%2==0:\n        s.add(2)\n        while x%2==0:\n            x//=2\n    i=3\n    while i*i<=x:\n        if x%i==0:\n            s.add(i)\n            while x%i==0:\n                x//=i\n        i+=2\n    if x!=1:s.add(x)\nfor k in range(q-1):\n    u,v=map(int,input().split())\n    s0=set()\n    for z in s:\n        if u%z==0 or v%z==0:\n            s0.add(z)\n    s=s0\nif len(s)==0:print(-1)\nelse:print(min(s))\n    \n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.Scanner;\nimport java.io.*;\nimport javax.lang.model.util.ElementScanner6; \nimport static java.lang.System.out;\nimport java.util.Stack;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class B1025\n{\n\n   \n    \n    public static void main(String args[])\n    {  \n\n        FastReader in=new FastReader();\n        PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int tc=1;\n     \n        //tc=in.nextInt();\n        while(tc-->0)\n        {\n            \n        \tint n=in.nextInt();\n      \n\t\t\tArrayList<Integer> al=new ArrayList<>();\n\t\t\tHashSet<Integer> hs=new HashSet<Integer>();\n\t\t\t\n\t\t\tint arr[][]=new int[n][2];\n        \tfor(int i=0;i<n;i++)\n        \t{\n\t\t\t\tarr[i][0]=in.nextInt();\n\t\t\t    arr[i][1]=in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint val=arr[0][0];\n\t\t\tif(val%2==0)\n\t\t\t{\n\t\t\t\ths.add(2);\n\t\t\t\twhile(val%2==0)val/=2;\n\t\t\t\t\n\t\t\t}\n\t\t\tfor(int i=3;i*i<=val;i+=2)\n\t\t\t{\n\t\t\t\tif(val%i==0)\n\t\t\t\t{\n\t\t\t\t\ths.add(i);\n\t\t\t\t\twhile(val%i==0)val/=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(val>2)hs.add(val);\n\t\t\t\n\t\t\tval=arr[0][1];\n\t\t\t\n\t\t\tif(val%2==0)\n\t\t\t{\n\t\t\t\ths.add(2);\n\t\t\t\twhile(val%2==0)val/=2;\n\t\t\t\t\n\t\t\t}\n\t\t\tfor(int i=3;i*i<=val;i+=2)\n\t\t\t{\n\t\t\t\tif(val%i==0)\n\t\t\t\t{\n\t\t\t\t\ths.add(i);\n\t\t\t\t\twhile(val%i==0)val/=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(val>2)hs.add(val);\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\ths.remove(1);\n\t\t\tint ini_size=hs.size();\n\t\t\t//out.println(hs);\n\t\t\t\n\t\t\tboolean flag=true;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int x : hs)\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\tfor(int i=1;i<n;i++)\n\t\t\t\t{\n\t\t\t\t\tif(arr[i][0]%x!=0&&arr[i][1]%x!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tpr.println(x);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(!flag)\n\t\t\t{\n\t\t\t\tpr.println(-1);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n        \t\n        \t\n\n        \n\n\n\n        }\n        pr.flush();\n    }\n\t\n    static void sort(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n\t}\n    \n    \n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n    }\n\n    \n    static class FastReader\n    { \n        BufferedReader br; \n        StringTokenizer st; \n\n        public FastReader() \n        { \n            br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n\n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n\n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n\n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n\n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n        \n        int[] readIntArray(int n)\n        {\n\t\tint a[]=new int[n];\n\t\tfor(int i=0;i<n;i++)a[i]=nextInt();\n\t\treturn a;\n\t}\n\t\t\n\tlong[] readLongArray(int n)\n\t{\n\t\tlong a[]=new long[n];\n\t\tfor(int i=0;i<n;i++)a[i]=nextLong();\n\t\treturn a;\n\t}\n\t\n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n}\n\n\n"
        },
        {
            "language": 4,
            "solution": "import org.omg.CORBA.INTERNAL;\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class WCD {\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter pw = new PrintWriter(System.out), pw2 = new PrintWriter(System.out);\n    static ArrayList<Integer> primes=new ArrayList<>();\n    static boolean[] isPrime;\n    public static void seive(int x){\n        isPrime=new boolean[x];\n        Arrays.fill(isPrime,true);\n        isPrime[0]=false;\n        isPrime[1]=false;\n        for(int i=2;i*i<=x;i++){\n            for(int j=i*i;j<x;j+=i)\n                isPrime[j]=false;\n        }\n        for(int i=0;i<x;i++)\n            if(isPrime[i])\n                primes.add(i);\n    }\n    public static HashSet<Integer> primeFactors(int x){\n        int idx=0,div=primes.get(idx++);\n        HashSet<Integer> primeFactors=new HashSet<>();\n        while(div*div<=x){\n            if(x%div==0){\n                primeFactors.add(div);\n                while(x%div==0){\n                    x/=div;\n                }\n            }\n            div=primes.get(idx++);\n        }\n        if(x!=1)\n            primeFactors.add(x);\n        return primeFactors;\n    }\n    public static void main(String[] args) throws IOException {\n        seive((int)1e6);\n        int n=sc.nextInt();\n        int x=sc.nextInt();\n        int y=sc.nextInt();\n        HashSet<Integer> divisors=primeFactors(x);\n        divisors.addAll(primeFactors(y));\n        int ans=x,c=0;\n        HashSet<Integer> remove=new HashSet<>();\n        //System.out.println(divisors);\n        for(int i=0;i<n-1;i++){\n            int a=sc.nextInt(),b=sc.nextInt();\n            for(int div:divisors){\n                if(remove.contains(div))\n                    continue;\n                if(a%div!=0&&b%div!=0) {\n                    remove.add(div);\n                    c++;\n                }else\n                    ans=div;\n            }\n            if(divisors.size()-c<=0){\n                System.out.println(-1);\n                return;\n            }\n        }\n        System.out.println(ans);\n     }\n\n    public static <E> void print2D(E[][] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[i].length; j++) {\n                pw.println(arr[i][j]);\n            }\n        }\n    }\n\n    public static int digitSum(String s) {\n        int toReturn = 0;\n        for (int i = 0; i < s.length(); i++) toReturn += Integer.parseInt(s.charAt(i) + \" \");\n        return toReturn;\n    }\n\n    public static boolean isPrime(long n) {\n        if (n <= 1)\n            return false;\n        if (n <= 3)\n            return true;\n\n        if (n % 2 == 0 || n % 3 == 0)\n            return false;\n\n        for (long i = 5; i * i <= n; i = i + 6)\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n        return true;\n    }\n\n    public static long pow(long a, long pow) {\n        return pow == 0 ? 1 : pow % 2 == 0 ? pow(a * a, pow >> 1) : a * pow(a * a, pow >> 1);\n    }\n\n    public static long sumNum(long a) {\n        return a * (a + 1) / 2;\n    }\n\n    public static int gcd(int n1, int n2) {\n        return n2 == 0 ? n1 : gcd(n2, n1 % n2);\n    }\n\n    public static long factorial(long a) {\n        return a == 0 || a == 1 ? 1 : a * factorial(a - 1);\n    }\n\n    public static void sort(int arr[]) {\n        shuffle(arr);\n        Arrays.sort(arr);\n    }\n\n    public static void shuffle(int arr[]) {\n        Random rnd = new Random();\n        for (int i = arr.length - 1; i > 0; i--) {\n            int index = rnd.nextInt(i + 1);\n            int temp = arr[index];\n            arr[index] = arr[i];\n            arr[i] = temp;\n        }\n    }\n\n    public static Double[] solveQuadratic(double a, double b, double c) {\n        double result = (b * b) - 4.0 * a * c;\n        double r1;\n        if (result > 0.0) {\n            r1 = ((double) (-b) + Math.pow(result, 0.5)) / (2.0 * a);\n            double r2 = ((double) (-b) - Math.pow(result, 0.5)) / (2.0 * a);\n            return new Double[]{r1, r2};\n        } else if (result == 0.0) {\n            r1 = (double) (-b) / (2.0 * a);\n            return new Double[]{r1, r1};\n        } else {\n            return new Double[]{null, null};\n        }\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n\n    static class pair<E1, E2> implements Comparable<pair> {\n        E1 x;\n        E2 y;\n\n        pair(E1 x, E2 y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public int compareTo(pair o) {\n            return x.equals(o.x) ? (Integer) y - (Integer) o.y : (Integer) x - (Integer) o.x;\n        }\n\n        @Override\n        public String toString() {\n            return x + \" \" + y;\n        }\n\n        public double pointDis(pair p1) {\n            return Math.sqrt(((Integer) y - (Integer) p1.y) * ((Integer) y - (Integer) p1.y) + ((Integer) x - (Integer) p1.x) * ((Integer) x - (Integer) p1.x));\n        }\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class b {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint N = in.nextInt();\n\t\tint[][] arr = new int[N][];\n\t\tfor(int n=0;n<N;n++){\n\t\t\tarr[n] = new int[]{in.nextInt(), in.nextInt()};\n\t\t}\n\t\t\n\t\tTreeSet<Integer> candidates = upfac(arr[0][0]);\n\t\tTreeSet<Integer> candidates2 = upfac(arr[0][1]);\n\t\tcandidates.addAll(candidates2);\n\t\t\n//\t\tSystem.out.println(candidates.toString());\n\t\t\n\t\tint use = -1;\n\t\tfor(Integer io : candidates){\n\t\t\tint i = io;\n\t\t\tboolean fail = false;\n\t\t\tfor(int n=0;n<N;n++){\n\t\t\t\tif(arr[n][0] % i != 0 && arr[n][1] % i != 0){\n//\t\t\t\t\tSystem.out.println(i+\" \"+arr[n][0]+\" \"+arr[n][1]);\n\t\t\t\t\tfail = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!fail){\n\t\t\t\tuse = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(use);\n\t}\n\tstatic long gcd(long a, long b){\n\t\treturn b == 0? a: gcd(b, a % b);\n\t}\n\t// only unique prime factors\n\tstatic TreeSet<Integer> upfac(int n){\n\t\tTreeSet<Integer> upfac = new TreeSet<>();\n\t\tfor(int i = 2; i*i <= n; i++){\n\t\t\twhile(n % i == 0){\n\t\t\t\tupfac.add(i);\n\t\t\t\tn /= i;\n\t\t\t}\n\t\t}\n\t\tif(n != 1) upfac.add(n);\n\t\treturn upfac;\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class P1025B {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tint n = Integer.parseInt(f.readLine());\n\t\t\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\n\t\t\tStringTokenizer str = new StringTokenizer(f.readLine());\n\t\t\t\n\t\t\ta[i] = Integer.parseInt(str.nextToken());\n\t\t\tb[i] = Integer.parseInt(str.nextToken());\n\t\t\t\n\t\t}\n\t\t\n\t\tHashSet<Integer> primes = new HashSet<>();\n\t\t\n\t\tint aa = a[0];\n\t\tint bb = b[0];\n\t\t\t\n\t\tfor(int i = 2; aa != 1; i++) {\n\t\t\t\n\t\t\tif(aa % i == 0) {\n\t\t\t\t\n\t\t\t\tprimes.add(i);\n\t\t\t\t\n\t\t\t\twhile(aa % i == 0) {\n\t\t\t\t\taa /= i;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(i > 50000) {\n\t\t\t\tprimes.add(aa);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(int i = 2; bb != 1; i++) {\n\t\t\t\n\t\t\tif(bb % i == 0) {\n\t\t\t\t\n\t\t\t\tprimes.add(i);\n\t\t\t\t\n\t\t\t\twhile(bb % i == 0) {\n\t\t\t\t\tbb /= i;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(i > 50000) {\n\t\t\t\tprimes.add(bb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int p : primes) {\n\t\t\t\n\t\t\tboolean works = true;\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\n\t\t\t\tif((a[i] % p != 0) && (b[i] % p != 0)) {\n\t\t\t\t\tworks = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(works) {\n\t\t\t\tans = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == 0) {\n\t\t\tSystem.out.println(-1);\n\t\t} else {\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\n\t\tf.close();\n\t\t\n\t}\n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[150005], b[150005];\nint process(int n, int m) {\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      bool ok = true;\n      while (n % i == 0) n /= i;\n      for (int j = 2; j <= m; j++) {\n        if (a[j] % i != 0 && b[j] % i != 0) ok = false;\n      }\n      if (ok == true) return i;\n    }\n  }\n  if (n > 1) {\n    bool ok = true;\n    for (int j = 2; j <= m; j++) {\n      if (a[j] % n != 0 && b[j] % n != 0) ok = false;\n    }\n    if (ok == true) return n;\n  }\n  return -1;\n}\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i] >> b[i];\n  int x = process(a[1], n), y = process(b[1], n);\n  if (x != -1)\n    cout << x;\n  else if (y != -1)\n    cout << y;\n  else\n    cout << -1;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  while (b != 0) {\n    long long a0 = a;\n    long long b0 = b;\n    a = b0;\n    b = a0 % b0;\n  }\n  return a;\n}\nconst long long N = 1.5e5 + 169;\nlong long a[N];\nlong long b[N];\nsigned main() {\n  cin.sync_with_stdio(0);\n  cin.tie(0);\n  long long n;\n  cin >> n;\n  long long an = 0;\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n    an = gcd(an, a[i] * b[i] / gcd(a[i], b[i]));\n  }\n  if (an <= 1)\n    cout << -1 << '\\n';\n  else {\n    for (long long i = 0; i < n; i++) {\n      if (gcd(a[i], an) > 1)\n        an = gcd(a[i], an);\n      else\n        an = gcd(b[i], an);\n    }\n    cout << an << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class tr {\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tint n=sc.nextInt();\n\t\tboolean []se=new boolean [100001];\n\t\tArrayList <Integer> primes=new ArrayList();\n\t\tArrays.fill(se, true);\n\t\tse[0]=se[1]=false;\n\t\top []pp=new op[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tpp[i]=new op(sc.nextInt(),sc.nextInt());\n\t\t}\n\t\tif(n==1) {\n\t\t\tSystem.out.println(pp[0].a);\n\t\t\treturn;\n\t\t}\n\t\tint n1=pp[0].a;\n\t\tint n2=pp[0].b;\n\t\tfor(int i=2;i<se.length;i++) {\n\t\t\tif(se[i]) {\n\t\t\t\tprimes.add(i);\n\t\t\t\tif(1l * i * i <= 100000)\n\t\t\t\t\tfor (int j = i * i; j < se.length; j += i)\n\t\t\t\t\t      se[j] =true;\n\t\t\t}\n\t\t} \n\t\tHashSet<Integer>factors=new HashSet<>();\t\t//take abs(N) in case of -ve integers\n\t\tint idx = 0, p = primes.get(idx);\n\t\twhile(p * p <= n1)\n\t\t{\n\t\t\twhile(n1 % p == 0) { factors.add(p); n1 /= p; }\n\t\t\tp = primes.get(++idx);\n\t\t}\n\n\t\tif(n1 != 1)\t\t\t\t\t\t// last prime factor may be > sqrt(N)\n\t\t\tfactors.add(n1);\t\n\t\tidx = 0;\n\t\tp = primes.get(idx);\n\t\twhile(p * p <= n2)\n\t\t{\n\t\t\twhile(n2 % p == 0) { factors.add(p); n2 /= p; }\n\t\t\tp = primes.get(++idx);\n\t\t}\n\n\t\tif(n2 != 1)\t\t\t\t\t\t// last prime factor may be > sqrt(N)\n\t\t\tfactors.add(n2);\n\t\tboolean ans=false;\n\t\tint aa=0;\n\t\tfor(int h:factors) {\n\t\t\tboolean acc=true;\n\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\tif(pp[i].a%h!=0 && pp[i].b%h!=0) {\n\t\t\t\t\tacc=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(acc) {\n\t\t\t\taa=h;\n\t\t\t\tans=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//out.println(factors);\n\t   if(ans)\n\t\t   out.println(aa);\n\t   else\n\t\t   out.println(-1);\n\t\tout.flush();\n\t}\n\n\tstatic int tryy(int[] a) {\n\t\tif (a.length == 1)\n\t\t\treturn 1;\n\t\tif (issorted(a))\n\t\t\treturn a.length;\n\t\tint[] a1 = new int[a.length / 2];\n\t\tint[] a2 = new int[a.length / 2];\n\t\tint j = 0;\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (i < a.length / 2)\n\t\t\t\ta1[i] = a[i];\n\t\t\telse {\n\t\t\t\ta2[j++] = a[i];\n\t\t\t}\n\t\t}\n\t\tif (issorted(a1) || issorted(a2))\n\t\t\treturn a1.length;\n\t\treturn Math.max(tryy(a1), tryy(a2));\n\t}\n\n\tstatic boolean issorted(int[] a) {\n\t\tfor (int i = 0; i < a.length - 1; i++)\n\t\t\tif (a[i] > a[i + 1])\n\t\t\t\treturn false;\n\t\t// System.out.println(Arrays.toString(a));\n\t\treturn true;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t}\n\t\treturn gcd(b, a % b);\n\t}\n\n\tstatic class op {\n\t\tint a;\n\t\tint b;\n\n\t\top(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "\"\"\"[summary]\nCodeforces Round  # 505 (rated, Div. 1 + Div. 2, based on VK Cup 2018 Final)\n\"\"\"\nfrom math import sqrt\n\npairs = []\nn = int(input())\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    pairs.append((a,b))\n\n\ndef PF(n):\n    a = set()\n\n    # Print the number of two's that divide n\n    while n % 2 == 0:\n        a.add(2)\n        n = n / 2\n\n    # n must be odd at this point\n    # so a skip of 2 ( i = i + 2) can be used\n    for i in range(3, int(sqrt(n))+1, 2):\n\n        # while i divides n , print i ad divide n\n        while n % i == 0:\n            a.add(i)\n            n = n / i\n\n    # Condition if n is a prime\n    # number greater than 2\n    if n > 2:\n        a.add(n)\n    return a\n\nprime = set()\nprime = PF(pairs[0][0])\nprime = prime.union(PF(pairs[0][1]))\n\n# check if there is WCD\nfor a, b in pairs[1:]:\n    tmp = set()\n    for i in prime:\n        if a % i == 0 or b % i == 0:\n            tmp.add(i)\n    prime = prime.intersection(tmp)\n\nif len(prime) > 0:\n    print(int(prime.pop()))\nelse:\n    print(-1)\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput=sys.stdin.buffer.readline\ndef is_prime(x):\n    i=2\n    global s\n    p=x\n    while i*i <=x:\n        flag=0\n        while p %i==0:\n            p//=i\n            flag=1\n        if flag ==1:\n            s.add(i)\n        i+=1\n    if p >1:\n        s.add(p)\nn=int(input())\ns=set()\nlst=[]\nfor i in range(n):\n    a,b=map(int,input().split())\n    lst.append([a,b])\nis_prime(lst[0][0])\nis_prime(lst[0][1])\nr=set()\nfor i in range(1,n):\n    l=lst[i][0]\n    rr=lst[i][1]\n    r=set()\n    for j in s:\n        if l %j==0:\n            r.add(j)\n    for j in s:\n        if rr% j==0:\n            r.add(j)\n    s=r\nif len(s) ==0:\n    print(-1)\nelse:\n    for i in s:\n        print(i)\n        break"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int mod = 1e9 + 7;\ninline int read() {\n  int x = 0, k = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') k = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9')\n    x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return x * k;\n}\nstruct node {\n  int a, b;\n} x[200005];\nint prime[200005];\nint p1[200005], p2[200005];\nint c1[200005], c2[200005];\nint m1, m2;\nint judge;\nbool isprime(int x) {\n  if (x == 0 || x == 1) return 0;\n  for (int i = 2; i <= sqrt(x); i++) {\n    if (x % i == 0) return 0;\n  }\n  return 1;\n}\nvoid divide1(int n) {\n  m1 = 0;\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      p1[++m1] = i;\n      while (n % i == 0) n /= i;\n    }\n  }\n  if (n > 1) p1[++m1] = n;\n}\nvoid divide2(int n) {\n  m2 = 0;\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      p2[++m2] = i;\n      while (n % i == 0) n /= i;\n    }\n  }\n  if (n > 1) p2[++m2] = n;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  int i, j;\n  for (i = 1; i <= n; i++) {\n    cin >> x[i].a >> x[i].b;\n  }\n  for (i = 1; i <= n; i++) {\n    if (x[i].a == 1 && x[i].b == 1) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n  divide1(x[1].a);\n  divide2(x[1].b);\n  int flag = 0, ans;\n  j = 0;\n  for (i = 1; i <= m1; i++) {\n    prime[j] = p1[i];\n    j++;\n  }\n  for (i = 1; i <= m2; i++) {\n    prime[j] = p2[i];\n    j++;\n  }\n  int cnt;\n  cnt = unique(prime, prime + j) - prime;\n  int k, tt;\n  for (i = 0; i < cnt; i++) {\n    for (j = 2; j <= n; j++) {\n      if (x[j].a % prime[i] == 0 || x[j].b % prime[i] == 0) {\n        continue;\n      } else\n        break;\n    }\n    if (j > n) {\n      ans = prime[i];\n      flag = 1;\n      break;\n    }\n  }\n  if (flag)\n    cout << ans << endl;\n  else\n    cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package Contest505;\n\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main505B {\n    public static Scanner enter = new Scanner(System.in);\n    public static int last=0;\n    public static void main(String[] args) {\n        int n=enter.nextInt();\n        int[] mass1=new int[n];\n        int[] mass2=new int[n];\n        for (int i = 0; i <n ; i++) {\n            mass1[i]=enter.nextInt();\n            mass2[i]=enter.nextInt();\n        }\n        int[] simple=new int[(int)1e5];\n        simples(mass1[0],simple);\n        simples(mass2[0],simple);\n        int k=last;\n        /*System.out.println(Arrays.toString(Arrays.copyOfRange(simple,0,last)));\n        System.out.println(last);*/\n        for (int i = 1; i <n ; i++) {\n            for (int j = 0; j <last ; j++) {\n                if(!(mass1[i]%simple[j]==0 || mass2[i]%simple[j]==0)){\n                    int tmp=simple[j];\n                    simple[j]=simple[last-1];\n                    simple[last-1]=tmp;\n                    last--;\n                    j--;\n                }\n            }\n           /*System.out.println(Arrays.toString(Arrays.copyOfRange(simple,0,last)));\n            System.out.println(last);*/\n        }\n        if(last<=0){\n            System.out.println(-1);\n        }\n        else{\n            System.out.println(simple[0]);\n        }\n    }\n    public static void simples(int a,int[] mass){\n        int tmp=a;\n        for (int i = 2; i*i<=tmp ; i++) {\n            if(a%i==0){\n                mass[last]=i;\n                last++;\n                while(a%i==0){\n                    a/=i;\n                }\n            }\n        }\n        if(a!=1) {\n            mass[last]=a;\n            last++;\n        }\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "import math\ndef printDivisors(n,dict1) :\n    i=2\n    while i <= math.sqrt(n):\n         \n        if (n % i == 0) :\n            if (n / i == i) :\n                dict1[i]=1\n            else :\n                dict1[i]=1\n                dict1[n/i]=1\n\n        i = i + 1\n    dict1[n]=1\nn=int(raw_input())\nminval=2000000000000\nx1=-1\ny1=-1\ndict2={}\nfor i in range(n):\n    x,y=map(int,raw_input().split())\n    dict2[(x,y)]=1\n    if(x+y<minval):\n        minval=x+y\n        x1=x\n        y1=y\ndict1={}\nprintDivisors(x1,dict1)\nprintDivisors(y1,dict1)\nflagx=0\nfor i in dict2.keys():\n    flag=0\n    k1=dict1.keys()\n    dict1={}\n    for j in k1:\n        if(i[0]%j==0 or i[1]%j==0):\n            dict1[j]=1\n            flag=1\n    if(flag==0):\n        flagx=1\n        break \nif(flagx==1):\n    print(-1)\nelse:\n    for i in dict1.keys():\n        print(i)\n        break"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint sqrt(int n) {\n  long long l = 0, r = 100000, m;\n  while (r - l > 1) {\n    m = (l + r) / 2;\n    if (m * m <= n)\n      l = m;\n    else\n      r = m;\n  }\n  return int(l);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n;\n  cin >> n;\n  int a1, b1;\n  cin >> a1 >> b1;\n  set<int> p;\n  for (int i = 2; i <= sqrt(a1); ++i) {\n    if (a1 % i == 0) {\n      p.insert(i);\n      while (a1 % i == 0) {\n        a1 /= i;\n      }\n    }\n  }\n  if (a1 > 1) p.insert(a1);\n  for (int i = 2; i <= sqrt(b1); ++i) {\n    if (b1 % i == 0) {\n      p.insert(i);\n      while (b1 % i == 0) {\n        b1 /= i;\n      }\n    }\n  }\n  if (b1 > 1) p.insert(b1);\n  for (int i = 0; i < n - 1; ++i) {\n    int a, b;\n    cin >> a >> b;\n    vector<int> del;\n    for (auto now = p.begin(); now != p.end(); ++now) {\n      if (a % *now != 0 && b % *now != 0) {\n        del.push_back(*now);\n      }\n    }\n    for (int j = 0; j < (int)del.size(); ++j) p.erase(del[j]);\n  }\n  p.empty() ? cout << -1 << endl : cout << *p.begin();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Weakened_Common_Divisor\n{\n\tstatic ArrayList<Long> primes = new ArrayList<Long>();\n\n\tstatic class InputReader\n\t{\n\t\tBufferedReader br;\n\t\tpublic InputReader() throws IOException\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tpublic int readInt() throws IOException\n\t\t{\n\t\t\treturn Integer.parseInt(br.readLine());\n\t\t}\n\t\tpublic long readLong() throws IOException\n\t\t{\n\t\t\treturn Long.parseLong(br.readLine());\n\t\t}\n\t\tpublic String readLine() throws IOException\n\t\t{\n\t\t\treturn br.readLine();\n\t\t}\n\t\tpublic int[] readIntArray() throws IOException\n\t\t{\n\t\t\treturn Arrays.asList(br.readLine().split(\" \")).stream().mapToInt(Integer::parseInt).toArray();\n\t\t}\n\t\tpublic long[] readLongArray() throws IOException\n\t\t{\n\t\t\treturn Arrays.asList(br.readLine().split(\" \")).stream().mapToLong(Long::parseLong).toArray();\n\t\t}\n\t\tpublic void close() throws IOException\n\t\t{\n\t\t\tbr.close();\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tInputReader br = new InputReader();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\tint test = 1;\n\t\twhile(test--!=0)\n\t\t{\n\t\t\tint n = br.readInt();\n\t\t\tlong a[] = new long[n];\n\t\t\tlong b[] = new long[n];\n\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tlong e[] = br.readLongArray();\n\t\t\t\ta[i] = e[0];\n\t\t\t\tb[i] = e[1];\n\t\t\t}\n\n\t\t\tgetPrimeList(a[0]);\n\t\t\tgetPrimeList(b[0]);\n\n\t\t\tfor(int i=0;i<primes.size();i++)\n\t\t\t{\n\t\t\t\tboolean flag=true;\n\t\t\t\tlong p = primes.get(i);\n\t\t\t\tfor(int j=1;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[j]%p !=0 && b[j]%p!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(flag)\n\t\t\t\t{\n\t\t\t\t\tpw.println(p);\n\t\t\t\t\tpw.close();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpw.println(\"-1\");\n\t\t}\n\t\tpw.close();\n\t\tbr.close();\n\t}\n\n\tpublic static void getPrimeList(long r)\n\t{\n\t\tlong num = r;\n\t\tfor(long i=2;i*i<=num;i++)\n\t\t{\n\t\t\tif(num%i==0)\n\t\t\t{\n\t\t\t\t\n\t\t\t\twhile(num%i==0)\n\t\t\t\t\tnum /= i;\n\n\t\t\t\tprimes.add(i);\n\t\t\t}\n\t\t}\n\n\t\tif(num>1) primes.add(num);\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "import math\n\n\ndef divisors(n):\n    divs = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divs.extend([i, n // i])\n    divs.extend([n])\n    return set(divs)\n\n\nn = int(input())\na, b = map(int, input().split())\n\ndivs = divisors(a).union(divisors(b))\n\ntemp = sorted(list(divs))\ndivs.clear()\n\nfor v in temp:\n    insert = True\n    for item in divs:\n        if v % item == 0:\n            insert = False\n            break\n    if insert:\n        divs.add(v)\n\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    temp_divs = set()\n    for v in divs:\n        if a % v == 0:\n            temp_divs.add(v)\n        if b % v == 0:\n            temp_divs.add(v)\n    divs = temp_divs\n    if len(divs) == 0:\n        break\n\nif len(divs) == 0:\n    print(-1)\nelse:\n    print(divs.pop())\n"
        },
        {
            "language": 3,
            "solution": "import io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nfrom collections import defaultdict\nimport math\n\ndef getFactors(n): \n    prime = defaultdict(int)\n    while n % 2 == 0: \n        prime[2] += 1\n        n = n//2\n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i== 0: \n            prime[i] += 1\n            n = n//i \n    if n > 2: \n        prime[n] += 1\n    return prime\n\nn = int(input())\nfirst, second = map(int, input().split())\nfirst_pf = getFactors(first)\nsecond_pf = getFactors(second)\nlines = []\n\nfor i in range(n-1):\n    lines.append(tuple(map(int, input().split())))\n    \nans = -1\nfound = False\n\nfor factor in first_pf:\n    this_good = True\n    for line in lines:\n        if line[0]%factor and line[1]%factor:\n            this_good = False\n            break\n            \n    if this_good:\n        ans = factor\n        found = True\n        break\n        \nif not found:\n    for factor in second_pf:\n        this_good = True\n        for line in lines:\n            if line[0]%factor and line[1]%factor:\n                this_good = False\n                break\n\n        if this_good:\n            ans = factor\n            break\n        \nprint(ans)"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n *\n * @author Arles\n */\npublic class CWeakenedCommonDivisor {\n\n    static int MAX = 1000000;\n    static int SQRT = 1000;\n    static ArrayList<Integer> primes = new ArrayList<>();\n    static boolean[] marked = new boolean[MAX + 1];\n    static ArrayList<Integer> factors = new ArrayList<>();\n\n    static void sieve() {\n        marked[1] = true;\n        int i = 2;\n        for (; i < SQRT; i++) {\n            if (!marked[i]) {\n                primes.add(i);\n                for (int j = i * i; j <= MAX; j += i) {\n                    marked[j] = true;\n                }\n            }\n        }\n        for (; i <= MAX; i++) {\n            if (!marked[i]) {\n                primes.add(i);\n            }\n        }\n    }\n\n    public static void primeFactors(int n) {\n        factors.clear();\n        for (int i = 0, p = primes.get(i); p * p <= n; p = primes.get(++i)) {\n            while (n % p == 0) {\n                factors.add(p);\n                n /= p;\n            }\n        }\n        if (n > 1) {\n            factors.add(n);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        sieve();\n        Set<Integer> union = null;\n        for (int i = 0; i < n; i++) {\n            String[] spl = br.readLine().split(\" \");\n            int a = Integer.parseInt(spl[0]);\n            int b = Integer.parseInt(spl[1]);\n            if (i == 0) {\n                union = new HashSet<Integer>();\n                primeFactors(a);\n                union.addAll(factors);\n                primeFactors(b);\n                union.addAll(factors);\n            } else {\n                //System.out.println(union);\n                Set<Integer> union2 = new HashSet<>(union);\n                for (int e : union) {\n                    if (a % e != 0 && b % e != 0) {\n                        union2.remove(e);\n                        //System.out.println(number);\n                    }\n                }\n                union = union2;                \n            }\n        }\n        if (union.isEmpty()) {\n            System.out.println(\"-1\");\n        } else {\n            System.out.println(union.toArray()[0]);\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.BigDecimal;\n\npublic class VKR505B {\n    public static void main (String[] args) throws java.lang.Exception {\n        InputReader in = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = in.nextInt();\n        long[] a = new long[n], b = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextLong();\n            b[i] = in.nextLong();\n        }\n        long tempa = a[0], tempb = b[0];\n        HashSet<Long> hs = new HashSet<>();\n        for (long i = 2; i <= Math.sqrt(a[0]); i++) {\n            if (a[0] % i == 0) {\n                hs.add(i);\n                while (a[0] % i == 0)\n                    a[0] /= i;\n            }\n        }\n        for (long i = 2; i <= Math.sqrt(b[0]); i++) {\n            if (b[0] % i == 0) {\n                hs.add(i);\n                while (b[0] % i == 0)\n                    b[0] /= i;\n            }\n        }\n\n        if (a[0] > 1)\n            hs.add(a[0]);\n        if (b[0] > 1)\n            hs.add(b[0]);\n        a[0] = tempa;\n        b[0] = tempb;\n        for (long x : hs) {\n            boolean ok = true;\n            for (int i = 0; i < n && ok; i++) {\n                ok = ok && (a[i] % x == 0 || b[i] % x == 0);\n            }\n            if (ok) {\n                w.println(x);\n                w.close();\n                return;\n            }\n        }\n        w.println(-1);\n        w.close();\n\n    }\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    static long lcm(long a, long b) {\n        return (a * b) / gcd(a, b);\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new UnknownError();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int peek() {\n            if (numChars == -1)\n                return -1;\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar];\n        }\n\n        public void skip(int x) {\n            while (x-- > 0)\n                read();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String nextString() {\n            return next();\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuffer buf = new StringBuffer();\n            int c = read();\n            while (c != '\\n' && c != -1) {\n                if (c != '\\r')\n                    buf.appendCodePoint(c);\n                c = read();\n            }\n            return buf.toString();\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n        public boolean hasNext() {\n            int value;\n            while (isSpaceChar(value = peek()) && value != -1)\n                read();\n            return value != -1;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(3, \"Ofast\", \"inline\")\nusing namespace std;\nbool Finish_read;\ntemplate <class T>\ninline void read(T &x) {\n  Finish_read = 0;\n  x = 0;\n  int f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    if (ch == EOF) return;\n    ch = getchar();\n  }\n  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n  x *= f;\n  Finish_read = 1;\n}\ntemplate <class T>\ninline void print(T x) {\n  if (x / 10 != 0) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <class T>\ninline void writeln(T x) {\n  if (x < 0) putchar('-');\n  x = abs(x);\n  print(x);\n  putchar('\\n');\n}\ntemplate <class T>\ninline void write(T x) {\n  if (x < 0) putchar('-');\n  x = abs(x);\n  print(x);\n}\nint x, y, n;\nvector<int> divi[2];\nint main() {\n  read(n);\n  for (int i = 1; i <= n; ++i) {\n    read(x), read(y);\n    divi[i & 1].clear();\n    if (i == 1) {\n      for (int i = 2; i * i <= x; ++i)\n        if (x % i == 0) {\n          divi[1].push_back(i);\n          while (x % i == 0) x /= i;\n        }\n      if (x > 1) divi[1].push_back(x);\n      for (int i = 2; i * i <= y; ++i)\n        if (y % i == 0) {\n          divi[1].push_back(i);\n          while (y % i == 0) y /= i;\n        }\n      if (y > 1) divi[1].push_back(y);\n      sort(divi[1].begin(), divi[1].end());\n      divi[1].erase(unique(divi[1].begin(), divi[1].end()), divi[1].end());\n    } else {\n      for (int j = 0; j < divi[(i & 1) ^ 1].size(); ++j) {\n        if (x % divi[(i & 1) ^ 1][j] == 0 || y % divi[(i & 1) ^ 1][j] == 0) {\n          divi[i & 1].push_back(divi[(i & 1) ^ 1][j]);\n          continue;\n        }\n      }\n    }\n  }\n  if (divi[n & 1].size())\n    printf(\"%d\\n\", divi[n & 1][0]);\n  else\n    puts(\"-1\");\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nfrom math import gcd\n\n\ndef prime_factors(x):\n\tdef add_n_div(n, k, factor):\n\t\tif n % k == 0:\n\t\t\tfactor.add(k)\n\t\t\twhile n % k == 0: n //= k\n\t\treturn n, factor\n\tans = set()\n\tx, ans = add_n_div(x, 2, ans)\n\ti = 3\n\twhile i * i <= x: \n\t\tx, ans = add_n_div(x, i, ans)\n\t\ti = i + 2\n\tif x != 1: ans.add(x)\t\n\treturn ans\n\n\n\ninput = stdin.readline\nb = [[*map(int, input().split())] for x in range(int(input()))]\nn = len(b)\nif n == 1:\n\tprint(b[0][0])\nelse:\n\tf = prime_factors(b[0][0])\n\tf.update(prime_factors(b[0][1]))\n\tfor i in b:\n\t\tf = {x for x in f if i[0] % x == 0 or i[1] % x == 0}\n\tif len(f) == 0:\n\t\tprint(-1)\n\telse:\n\t\tfor i in f:\n\t\t\tprint(i)\n\t\t\tbreak"
        },
        {
            "language": 1,
            "solution": "#import resource\n#import sys\n#resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n#import threading\n#threading.stack_size(2**26)\n#sys.setrecursionlimit(0x1000000)\nfrom sys import stdin, stdout\nmod=(10**9)+7\nmod1=mod-1\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef ncr(n,r,p):\n    t=((fact[n])*(modinv(fact[r],p)%p)*(modinv(fact[n-r],p)%p))%p\n    return t\ndef GCD(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\ndef BS(arr, l, r, x):\n    if r >= l:\n        mid = l + (r - l)/2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] > x:\n            return BS(arr, l, mid-1, x)\n        else:\n            return BS(arr, mid+1, r, x)\n    else:n -1\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport itertools\nimport math\nfrom Queue import Queue as Q\nimport heapq\nfrom random import randint as rn\ndef comp(x,y):\n    if(x[0]<y[0]):\n        return -1\n    elif(x[0]==y[0]):\n        if(x[1]<y[1]):\n            return -1\n        else:\n            return 1\n    else:\n        return 1\n\"\"\"---------------------------------------------------------------------\"\"\"\na=input()\nx,y=map(int,raw_input().split())\nr=x*y\nb=[]\nb.append([x,y])\nfor i in range(a-1):\n    x,y=map(int,raw_input().split())\n    b.append([x,y])\n    t=x*y\n    r=GCD(r,t)\nif(r==1):\n    print\"-1\"\nelse:\n    for i in range(a):\n        x=GCD(b[i][0],r)\n        y=GCD(b[i][1],r)\n        if(x!=1 and x<r):\n            r=x\n        if(y!=1 and y<r):\n            r=y\n    print r\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long gcd(long long x, long long y) { return x % y ? gcd(y, x % y) : y; }\ninline long long solve(long long n) {\n  for (int i = 2; i * i <= n; i++)\n    if (n % i == 0) return i;\n  return n;\n}\nint main() {\n  long long n, a, b;\n  scanf(\"%lld\", &n);\n  scanf(\"%lld%lld\", &a, &b);\n  long long ans = a * b / gcd(a, b);\n  n -= 1;\n  while (n--) {\n    scanf(\"%lld%lld\", &a, &b);\n    ans = gcd(ans, a * b / gcd(a, b));\n  }\n  if (ans == 1)\n    puts(\"-1\");\n  else {\n    if (gcd(ans, a) > 1)\n      printf(\"%lld\\n\", solve(gcd(ans, a)));\n    else\n      printf(\"%lld\\n\", solve(gcd(ans, b)));\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author noob_coder\n */\npublic class Main {\n\n        public static void main(String[] args) {\n                InputStream inputStream = System.in;\n                OutputStream outputStream = System.out;\n                InputReader in = new InputReader(inputStream);\n                PrintWriter out = new PrintWriter(outputStream);\n                TaskB solver = new TaskB();\n                solver.solve(1, in, out);\n                out.close();\n        }\n\n        static class TaskB {\n\n                public void solve(int testNumber, InputReader in, PrintWriter out) {\n                        int n = in.i();\n                        long[] a = new long[n];\n                        long[] b = new long[n];\n                        for (int i = 0; i < n; i++) {\n                                a[i] = in.i();\n                                b[i] = in.i();\n                        }\n                        long gcd = 0;\n                        for (int i = 0; i < n; i++) {\n                                gcd = IntegerUtil.gcd(gcd, a[i] * b[i]);\n                        }\n                        if (gcd == 1) {\n                                out.println(\"-1\");\n                                return;\n                        }\n                        long ans = 0;\n                        for (int i = 0; i < n; i++) {\n                                if (IntegerUtil.gcd(gcd, a[i]) == 1) {\n                                        gcd = IntegerUtil.gcd(gcd, b[i]);\n                                } else {\n                                        gcd = IntegerUtil.gcd(gcd, a[i]);\n                                }\n                        }\n                        out.println(gcd);\n                }\n\n        }\n\n        static class InputReader {\n\n                InputStream is;\n                private byte[] inbuf = new byte[1024];\n                public int lenbuf = 0;\n                public int ptrbuf = 0;\n\n                public InputReader(InputStream is) {\n                        this.is = is;\n                }\n\n                private int readByte() {\n                        if (lenbuf == -1) {\n                                throw new InputMismatchException();\n                        }\n                        if (ptrbuf >= lenbuf) {\n                                ptrbuf = 0;\n                                try {\n                                        lenbuf = is.read(inbuf);\n                                } catch (IOException e) {\n                                        throw new InputMismatchException();\n                                }\n                                if (lenbuf <= 0) {\n                                        return -1;\n                                }\n                        }\n                        return inbuf[ptrbuf++];\n                }\n\n                public int i() {\n                        int num = 0, b;\n                        boolean minus = false;\n                        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) {\n                                ;\n                        }\n                        if (b == '-') {\n                                minus = true;\n                                b = readByte();\n                        }\n\n                        while (true) {\n                                if (b >= '0' && b <= '9') {\n                                        num = num * 10 + (b - '0');\n                                } else {\n                                        return minus ? -num : num;\n                                }\n                                b = readByte();\n                        }\n                }\n\n        }\n\n        static class IntegerUtil {\n\n                public static long gcd(long a, long b) {\n                        return b == 0 ? a : gcd(b, a % b);\n                }\n\n        }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a, b, ns[300001];\nunordered_set<int> cd;\nint main() {\n  cin >> n;\n  for (int i = 0; i < 2; ++i) {\n    cin >> a;\n    for (int i = 2; i * i <= a; ++i) {\n      bool found = false;\n      while (a % i == 0) {\n        found = true;\n        a /= i;\n      }\n      if (found) {\n        cd.insert(i);\n      }\n    }\n    if (a > 1) {\n      cd.insert(a);\n    }\n  }\n  for (int i = 1; i < n; ++i) {\n    cin >> ns[i * 2] >> ns[i * 2 + 1];\n  }\n  for (auto d : cd) {\n    bool found = true;\n    for (int i = 1; i < n; ++i) {\n      if (ns[i * 2] % d != 0 && ns[i * 2 + 1] % d != 0) {\n        found = false;\n        break;\n      }\n    }\n    if (found) {\n      cout << d << endl;\n      return 0;\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool isprim(long long a) {\n  long long i;\n  long long m = 0;\n  for (i = 2; i * i <= a; i++) {\n    if (a % i == 0) {\n      m++;\n      break;\n    }\n  }\n  if (m == 0) {\n    return true;\n  }\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n;\n  cin >> n;\n  pair<long long, long long> ar[n];\n  long long i;\n  for (i = 0; i < n; i++) {\n    long long a, b;\n    cin >> a >> b;\n    ar[i] = {a, b};\n  }\n  long long r1 = ar[0].first;\n  long long r2 = ar[0].second;\n  set<long long> s1;\n  s1.insert(r1);\n  s1.insert(r2);\n  for (i = 2; i * i <= r1; i++) {\n    if (r1 % i == 0) {\n      long long v = r1 / i;\n      if (isprim(i)) s1.insert(i);\n      if (isprim(v)) s1.insert(v);\n    }\n  }\n  for (i = 2; i * i <= r2; i++) {\n    if (r2 % i == 0) {\n      long long v = r2 / i;\n      if (isprim(i)) s1.insert(i);\n      if (isprim(v)) s1.insert(v);\n    }\n  }\n  long long k = -1;\n  for (auto it = s1.begin(); it != s1.end(); ++it) {\n    long long x = *it;\n    long long p = 0;\n    for (i = 1; i < n; i++) {\n      if ((ar[i].first) % x != 0 and (ar[i].second) % x != 0) {\n        p++;\n        break;\n      }\n    }\n    if (p == 0) {\n      k = x;\n      break;\n    }\n  }\n  cout << k;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\ndef primeFactors(n):\n    l=[]\n    while n % 2 == 0:\n        l.append(2)\n        n = n // 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            l.append(i)\n            n = n // i \n    if n > 2 :\n        l.append(n)\n    return list(set(l))\n         \n\ndef is_prime(n):\n    if n % 2 == 0 and n > 2: \n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n    \n\nn=int(input())\nc=0\na,b=[int(x) for x in input().split()]\n\n#if is_prime(a) and is_prime(b):\n#    c+=1\nl1,l2=primeFactors(a),primeFactors(b)\nd=list(set(l1+l2))\nf=0    \nfor i in range(1,n):\n    a,b=[int(x) for x in input().split()]\n    #if is_prime(a) and is_prime(b):\n    #    c+=1\n    s=[]\n    for p in d:\n        if a%p!=0 and b%p!=0:\n            s.append(p)\n    for ele in s:\n        d.remove(ele)\n    #print(d)\n    if len(d)==0:\n        f=1\n        ans=-1\n        break\nif f!=1:\n    ans=d[0]\nprint(ans)\n\n            "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint gcd(int x, int y) { return x == 0 ? y : gcd(y % x, x); }\nlong long lcm(long long x, long long y) { return x / gcd(x, y) * y; }\nint fx[] = {1, -1, 0, 0};\nint fy[] = {0, 0, 1, -1};\nlong long a[1500010], b[150010];\nint main() {\n  set<long long> st;\n  set<long long>::iterator it;\n  long long n, c = 0, d = 0;\n  scanf(\"%lld\", &n);\n  for (long long i = 1; i <= n; i++) {\n    scanf(\"%lld %lld\", &a[i], &b[i]);\n    if (a[i] % 2 == 1 && b[i] % 2 == 1) {\n      c = a[i];\n      d = b[i];\n    }\n  }\n  if (c == 0 && d == 0) {\n    cout << \"2\";\n    return 0;\n  }\n  for (long long i = 2; i * i <= c; i++) {\n    if (c % i == 0) {\n      st.insert(i);\n      st.insert(c / i);\n    }\n  }\n  for (long long i = 2; i * i <= d; i++) {\n    if (d % i == 0) {\n      st.insert(i);\n      st.insert(d / i);\n    }\n  }\n  long long no = 0;\n  st.insert(c);\n  st.insert(d);\n  for (it = st.begin(); it != st.end(); it++) {\n    no = 1;\n    long long m = *it;\n    for (long long i = 1; i <= n; i++) {\n      if (a[i] % m == 0 || b[i] % m == 0) {\n        continue;\n      } else {\n        no = 0;\n        break;\n      }\n    }\n    if (no) {\n      cout << m;\n      return 0;\n    }\n  }\n  cout << \"-1\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18 + 10;\nconst int inf = 1e9 + 10;\nconst int N = 1e6 + 10;\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) cin >> a[i] >> b[i];\n  int x = a[0];\n  vector<int> rSimple;\n  for (int i = 2; i * i <= a[0]; i++)\n    if (x % i == 0) {\n      while (x % i == 0) x /= i;\n      rSimple.push_back(i);\n    }\n  if (x != 1) rSimple.push_back(x);\n  x = b[0];\n  for (int i = 2; i * i <= b[0]; i++)\n    if (x % i == 0) {\n      while (x % i == 0) x /= i;\n      rSimple.push_back(i);\n    }\n  if (x != 1) rSimple.push_back(x);\n  sort(rSimple.begin(), rSimple.end());\n  rSimple.push_back(-1);\n  vector<int> Simple;\n  for (int i = 0; i < rSimple.size() - 1; i++)\n    if (rSimple[i] != rSimple[i + 1]) Simple.push_back(rSimple[i]);\n  for (auto del : Simple) {\n    int flag = 1;\n    for (int i = 0; i < n; i++)\n      if (a[i] % del != 0 and b[i] % del != 0) flag = 0;\n    if (flag) return cout << del << \"\\n\", 0;\n  }\n  cout << -1 << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nn=int(input())\nls=[]\nfor _ in range(n):\n    ls.append(tuple(map(int,input().split())))\n\nans=0\nfor x,y in ls:\n    ans=math.gcd(x*y,ans)\nfor x,y in ls:\n    if math.gcd(ans,x)>1:\n        ans=math.gcd(ans,x)\n    else:\n        ans=math.gcd(ans, y)\n\n\nprint(-1 if ans==1 else ans)\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b)\n    return gcd(b, a % b);\n  else\n    return a;\n}\nlong long n, a[150010], b[150010], w;\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n    w = gcd(w, a[i] * b[i]);\n  }\n  if (w == 1) {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (gcd(w, a[i]) > 1)\n      w = gcd(w, a[i]);\n    else\n      w = gcd(w, b[i]);\n  }\n  cout << w << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\npublic  class Solution {\n\n    static HashSet<Integer> set = new HashSet<>() ;\n\n    static void solver(int temp){\n\n        for (int i = 2; i*i <= temp ; i++) {\n            if (temp%i == 0){\n                set.add(i) ;\n                while (temp%i == 0)\n                    temp /= i ;\n            }\n        }\n        if (temp != 1)set.add(temp) ;\n\n    }\n\n    public static void main(String[] args) {\n\n         int n = fsca.nextInt() ;\n         int a[][] = new int[n][2] ;\n        for (int i = 0; i <n ; i++) {\n            a[i][0] = fsca.nextInt() ;\n            a[i][1] = fsca.nextInt() ;\n\n        }\n        solver(a[0][0]);\n        solver(a[0][1]);\n\n        for (int tt : set){\n            boolean flag = true ;\n            for (int i = 1; i <n ; i++) {\n                if (a[i][0]%tt != 0 && a[i][1]%tt != 0){\n                    flag = false ;\n                    break;\n                }\n\n            }\n            if (flag){\n                System.out.println(tt);\n                return;\n            }\n\n        }\n\n        System.out.println(-1);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        fop.flush();\n        fop.close();\n    }\n\n\n    /*-----------------------------------------------------------------------------------------------------------------------------------------------*/\n\n    static PrintWriter fop = new PrintWriter(System.out);\n    static FastScanner fsca = new FastScanner();\n\n\n    static long gcd(long a, long b) {\n        return (b == 0) ? a : gcd(b, a % b);\n    }\n    static int gcd(int a, int b) {\n        return (b == 0) ? a : gcd(b, a % b);\n    }\n\n   // Arrays.sort() takes o(n^2) time to sort when array is reverse sorted\n   // so always shuffle the array before sorting\n    static final Random random = new Random();\n    static void ruffleSort(int[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int oi = random.nextInt(n), temp = a[oi];\n            a[oi] = a[i]; a[i] = temp;\n        }\n        Arrays.sort(a);\n    }\n    static void ruffleSort(long[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int oi = random.nextInt(n);\n            long temp = a[oi];\n            a[oi] = a[i];\n            a[i] = temp;\n        }\n        Arrays.sort(a);\n    }\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        // int array input\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n        // long array input\n        long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n        public int[] arr(int n){int[] ret = new int[n];for (int i = 0; i < n; i++) {ret[i] = i();}return ret;}\n    }\n    \n    \n \n           //       |----|       /\\      |    |   -----   |\n           //       |   /       /  \\     |    |     |     |\n           //       |--/       /----\\    |----|     |     |\n           //       |   \\     /      \\   |    |     |     |\n           //       |    \\   /        \\  |    |   -----   -------\n\n    static int n;\n    public static void main(String[] args)throws IOException\n    {\n        PrintWriter out= new PrintWriter(System.out);\n        Reader sc=new Reader();\n        n=sc.i();\n        int a=sc.i();\n        int b=sc.i();\n        HashSet<Integer> hs=new HashSet<Integer>();\n        hs.add(a);\n        hs.add(b);\n        \n        for(int i=2;i<=Math.sqrt(a);i++)\n            while(a%i==0)\n            {\n                hs.add(i);\n                a/=i;\n            }\n        for(int i=2;i<=Math.sqrt(b);i++)\n            while(b%i==0)\n            {\n                hs.add(i);\n                b/=i;\n            }\n        if(a>=2)\n        hs.add(a);\n        if(b>=2)\n        hs.add(b);\n        for(int i=0;i<n-1;i++)\n        {\n            a=sc.i();\n            b=sc.i();\n            ArrayList<Integer> ad=new ArrayList<>();\n            for(int j:hs)\n            {\n                if(a%j!=0&&b%j!=0)\n                {\n                    ad.add(j);\n                }\n            }\n            for(int j:ad)\n            hs.remove(j);\n        }\n        if(hs.size()==0)\n        out.println(-1);\n        else\n            for(int j:hs)\n            {\n                out.println(j);\n                break;\n            }\n        \n        out.flush();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class CodeForces1504C{\n\tstatic Set<Integer> set = new HashSet<>();\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint n = input.nextInt();\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0;i<n;i++){\n\t\t\ta[i] = input.nextInt();\n\t\t\tb[i] = input.nextInt();\n\t\t}\n\t\t\n\t\tdivisor(a[0]);\n\t\tdivisor(b[0]);\n\t\tint count = 0;\n\t\tfor(int m: set){\n\t\t\tboolean bool = true;\n\t\t\tfor(int i = 1;i<n;i++){\n\t\t\t\tif(a[i]%m != 0 && b[i]%m != 0){\n\t\t\t\t\tbool = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bool){\n\t\t\t\tSystem.out.println(m);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(-1);\n\t}\n\n\n\tpublic static void divisor(int x){\n\t\tint y = x;\n\t\tfor(int i = 2;i<=Math.sqrt(x);i++){\n\t\t\tboolean bool = false;\n\t\t\twhile(y%i == 0){\n\t\t\t\ty/= i;\n\t\t\t\tbool = true;\n\t\t\t}\n\n\t\t\tif(bool){\n\t\t\t\tset.add(i);\n\t\t\t}\n\t\t}\n\t\tif(y != 1){\n\t\t\tset.add(y);\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int gi() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + ch - 48;\n    ch = getchar();\n  }\n  return x * f;\n}\ntemplate <typename T>\ninline bool Max(T &a, T b) {\n  return a < b ? a = b, 1 : 0;\n}\ntemplate <typename T>\ninline bool Min(T &a, T b) {\n  return b < a ? a = b, 1 : 0;\n}\nconst int N = 3e5 + 7, m1 = 19260817;\nint n, ans = -1;\nint a[N], b[N];\nint gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\nvoid solve(int x) {\n  if (ans != -1) return;\n  for (int i = 2, l = sqrt(x); i <= l; ++i)\n    if (x % i == 0) {\n      for (; x % i == 0; x /= i)\n        ;\n      int fg = 1;\n      for (int j = 1; j <= n; ++j) {\n        if (!(a[j] % i == 0 || b[j] % i == 0)) {\n          fg = 0;\n          break;\n        }\n      }\n      if (fg) {\n        ans = i;\n        return;\n      }\n    }\n  if (x ^ 1) {\n    int fg = 1;\n    for (int j = 1; j <= n; ++j) {\n      if (!(a[j] % x == 0 || b[j] % x == 0)) {\n        fg = 0;\n        break;\n      }\n    }\n    if (fg) {\n      ans = x;\n      return;\n    }\n  }\n}\nint main() {\n  n = gi();\n  for (int i = 1; i <= n; ++i) {\n    a[i] = gi(), b[i] = gi();\n  }\n  solve(a[1]);\n  solve(b[1]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class WCD {\n\tstatic Map<Integer, Boolean> map = new HashMap<>();\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tSTDIN scan = new STDIN();\n\n\t\tint n = scan.nextInt();\n\n\t\tint a = scan.nextInt(), b = scan.nextInt();\n\t\tgen(a);\n\t\tgen(b);\n\n\t\twhile (n-- > 1) {\n\t\t\ta = scan.nextInt();\n\t\t\tb = scan.nextInt();\n\t\t\tfor (Map.Entry<Integer, Boolean> en : map.entrySet()) {\n\t\t\t\tint k = en.getKey();\n\t\t\t\tboolean v = en.getValue();\n\n\t\t\t\tif (!v)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (a % k != 0 && b % k != 0)\n\t\t\t\t\tmap.put(k, false);\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<Integer, Boolean> en : map.entrySet()) {\n\t\t\tint k = en.getKey();\n\t\t\tboolean v = en.getValue();\n\t\t\tif (v) {\n\t\t\t\tSystem.out.println(k);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n\tprivate static void gen(int a) {\n\t\tif (a % 2 == 0) {\n\t\t\tmap.put(2, true);\n\t\t\twhile (a % 2 == 0)\n\t\t\t\ta /= 2;\n\t\t}\n\t\tfor (int i = 3; i * i <= a; i += 2) {\n\t\t\twhile (a % i == 0) {\n\t\t\t\ta /= i;\n\t\t\t\tmap.put(i, true);\n\t\t\t}\n\t\t}\n\t\tif (a > 1) {\n\t\t\tmap.put(a,true);\n\t\t}\n\n\t}\n}\n\nclass STDIN {\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer st;\n\n\tString next() throws Exception {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws Exception {\n\t\treturn Integer.parseInt(next());\n\t}\n}"
        }
    ]
}