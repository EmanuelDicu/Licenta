{
    "name": "1139_C. Edgy Trees",
    "source": "CODEFORCES",
    "description": "You are given a tree (a connected undirected graph without cycles) of n vertices. Each of the n - 1 edges of the tree is colored in either black or red.\n\nYou are also given an integer k. Consider sequences of k vertices. Let's call a sequence [a_1, a_2, \u2026, a_k] good if it satisfies the following criterion:\n\n  * We will walk a path (possibly visiting same edge/vertex multiple times) on the tree, starting from a_1 and ending at a_k. \n  * Start at a_1, then go to a_2 using the shortest path between a_1 and a_2, then go to a_3 in a similar way, and so on, until you travel the shortest path between a_{k-1} and a_k.\n  * If you walked over at least one black edge during this process, then the sequence is good. \n\n<image>\n\nConsider the tree on the picture. If k=3 then the following sequences are good: [1, 4, 7], [5, 5, 3] and [2, 3, 7]. The following sequences are not good: [1, 4, 6], [5, 5, 5], [3, 7, 3].\n\nThere are n^k sequences of vertices, count how many of them are good. Since this number can be quite large, print it modulo 10^9+7.\n\nInput\n\nThe first line contains two integers n and k (2 \u2264 n \u2264 10^5, 2 \u2264 k \u2264 100), the size of the tree and the length of the vertex sequence.\n\nEach of the next n - 1 lines contains three integers u_i, v_i and x_i (1 \u2264 u_i, v_i \u2264 n, x_i \u2208 \\{0, 1\\}), where u_i and v_i denote the endpoints of the corresponding edge and x_i is the color of this edge (0 denotes red edge and 1 denotes black edge).\n\nOutput\n\nPrint the number of good sequences modulo 10^9 + 7.\n\nExamples\n\nInput\n\n\n4 4\n1 2 1\n2 3 1\n3 4 1\n\n\nOutput\n\n\n252\n\nInput\n\n\n4 6\n1 2 0\n1 3 0\n1 4 0\n\n\nOutput\n\n\n0\n\nInput\n\n\n3 5\n1 2 1\n2 3 0\n\n\nOutput\n\n\n210\n\nNote\n\nIn the first example, all sequences (4^4) of length 4 except the following are good: \n\n  * [1, 1, 1, 1]\n  * [2, 2, 2, 2]\n  * [3, 3, 3, 3]\n  * [4, 4, 4, 4] \n\n\n\nIn the second example, all edges are red, hence there aren't any good sequences.",
    "difficulty": "C",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs",
        "math",
        "trees"
    ],
    "rating": 1500,
    "public_test": [
        {
            "input": "4 4\n1 2 1\n2 3 1\n3 4 1\n",
            "output": "                                                             252\n"
        },
        {
            "input": "4 6\n1 2 0\n1 3 0\n1 4 0\n",
            "output": "                                                               0\n"
        },
        {
            "input": "3 5\n1 2 1\n2 3 0\n",
            "output": "                                                             210\n"
        }
    ],
    "generated_test": [
        {
            "input": "4 25\n2 4 1\n2 3 0\n1 4 0\n",
            "output": "831852467\n"
        },
        {
            "input": "7 12\n4 5 0\n2 7 1\n7 6 1\n1 5 0\n2 3 0\n1 6 0\n",
            "output": "824505797\n"
        },
        {
            "input": "2 1\n1 2 1\n",
            "output": "0\n"
        },
        {
            "input": "4 49\n2 4 1\n2 3 0\n1 4 0\n",
            "output": "595131499\n"
        },
        {
            "input": "4 49\n2 1 1\n2 3 0\n1 4 1\n",
            "output": "544612159\n"
        },
        {
            "input": "7 12\n4 6 0\n3 7 1\n7 6 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "840224227\n"
        },
        {
            "input": "4 49\n2 1 0\n2 3 0\n1 4 1\n",
            "output": "257391393\n"
        },
        {
            "input": "4 19\n2 4 1\n2 3 1\n1 4 0\n",
            "output": "877380736\n"
        },
        {
            "input": "4 6\n1 2 1\n1 3 0\n1 4 0\n",
            "output": "3366\n"
        },
        {
            "input": "3 5\n1 2 1\n2 3 1\n",
            "output": "240\n"
        },
        {
            "input": "4 25\n2 4 1\n2 3 0\n1 3 0\n",
            "output": "610357816\n"
        },
        {
            "input": "3 5\n1 2 0\n2 3 1\n",
            "output": "210\n"
        },
        {
            "input": "7 12\n4 5 0\n2 1 1\n7 6 1\n1 5 1\n2 3 0\n1 6 0\n",
            "output": "841274821\n"
        },
        {
            "input": "7 13\n4 6 0\n5 7 1\n7 6 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "885821088\n"
        },
        {
            "input": "3 10\n1 2 0\n2 3 1\n",
            "output": "58024\n"
        },
        {
            "input": "7 20\n4 5 0\n2 7 1\n7 6 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "226397486\n"
        },
        {
            "input": "19 20\n8 10 1\n17 15 1\n14 5 0\n6 14 0\n7 15 1\n19 8 1\n12 14 0\n2 18 0\n13 3 0\n17 1 1\n4 2 1\n11 3 0\n4 6 0\n6 9 0\n7 11 1\n16 4 1\n5 13 1\n16 19 0\n",
            "output": "929091185\n"
        },
        {
            "input": "2 4\n1 2 1\n2 3 1\n3 4 1\n",
            "output": "14\n"
        },
        {
            "input": "3 4\n1 2 1\n2 3 0\n",
            "output": "64\n"
        },
        {
            "input": "7 12\n4 5 0\n2 7 1\n7 6 1\n1 5 0\n2 3 1\n1 6 0\n",
            "output": "824509891\n"
        },
        {
            "input": "4 6\n1 2 1\n2 3 0\n1 4 0\n",
            "output": "3968\n"
        },
        {
            "input": "7 12\n4 5 0\n2 1 1\n7 6 0\n1 5 1\n2 3 0\n1 6 0\n",
            "output": "840747477\n"
        },
        {
            "input": "2 5\n1 2 1\n2 3 1\n3 4 1\n",
            "output": "30\n"
        },
        {
            "input": "7 12\n4 6 1\n2 7 1\n7 6 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "840751571\n"
        },
        {
            "input": "4 20\n2 4 1\n4 3 1\n1 4 0\n",
            "output": "510571505\n"
        },
        {
            "input": "4 5\n1 2 1\n2 3 0\n1 4 0\n",
            "output": "960\n"
        },
        {
            "input": "7 20\n4 2 0\n2 7 1\n7 6 1\n2 5 1\n2 3 0\n1 6 0\n",
            "output": "251233188\n"
        },
        {
            "input": "4 5\n1 2 1\n2 3 0\n1 4 1\n",
            "output": "990\n"
        },
        {
            "input": "7 20\n4 2 0\n2 7 1\n7 6 1\n2 5 1\n2 3 1\n1 6 0\n",
            "output": "736968991\n"
        },
        {
            "input": "4 36\n2 4 1\n2 3 0\n1 4 0\n",
            "output": "641112499\n"
        },
        {
            "input": "13 3\n9 13 1\n4 3 1\n11 9 0\n8 13 0\n10 9 0\n2 7 0\n4 8 1\n11 5 0\n10 12 0\n12 1 1\n5 7 0\n6 8 1\n",
            "output": "1842\n"
        },
        {
            "input": "3 8\n1 2 1\n2 3 0\n",
            "output": "6304\n"
        },
        {
            "input": "4 42\n2 4 1\n2 3 0\n1 4 0\n",
            "output": "853297555\n"
        },
        {
            "input": "4 67\n2 4 1\n2 3 0\n1 4 0\n",
            "output": "578961544\n"
        },
        {
            "input": "7 19\n4 6 0\n3 7 1\n7 6 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "781057964\n"
        },
        {
            "input": "3 10\n1 2 1\n2 3 1\n",
            "output": "59046\n"
        },
        {
            "input": "3 2\n1 2 0\n1 3 1\n",
            "output": "4\n"
        },
        {
            "input": "19 20\n8 10 1\n17 15 1\n14 5 0\n6 14 0\n7 15 1\n19 8 1\n12 14 0\n2 18 0\n13 3 0\n17 1 1\n4 2 1\n11 3 0\n4 6 0\n6 9 0\n7 11 1\n16 4 0\n5 13 1\n16 19 0\n",
            "output": "808213127\n"
        },
        {
            "input": "7 12\n4 6 1\n2 7 1\n7 6 1\n2 5 0\n2 3 1\n1 6 0\n",
            "output": "841278915\n"
        },
        {
            "input": "4 20\n2 4 1\n4 3 1\n1 4 1\n",
            "output": "511620079\n"
        },
        {
            "input": "4 5\n1 2 0\n2 3 0\n1 4 1\n",
            "output": "780\n"
        },
        {
            "input": "7 20\n4 2 1\n2 7 1\n7 6 1\n2 5 1\n2 3 1\n1 6 0\n",
            "output": "738017565\n"
        },
        {
            "input": "7 34\n4 2 0\n4 7 0\n7 6 1\n2 5 1\n2 3 1\n1 6 0\n",
            "output": "262911102\n"
        },
        {
            "input": "3 15\n1 2 1\n2 3 0\n",
            "output": "14316138\n"
        },
        {
            "input": "4 42\n2 4 1\n2 3 0\n1 3 0\n",
            "output": "366817536\n"
        },
        {
            "input": "7 12\n4 5 0\n2 1 1\n7 6 1\n1 5 0\n2 3 1\n1 6 1\n",
            "output": "840755665\n"
        },
        {
            "input": "7 26\n7 2 0\n4 7 0\n3 6 1\n2 5 1\n2 3 1\n1 6 0\n",
            "output": "459482703\n"
        },
        {
            "input": "3 5\n1 2 0\n2 3 0\n",
            "output": "0\n"
        },
        {
            "input": "7 12\n4 6 0\n2 7 1\n7 6 1\n1 5 0\n2 3 0\n1 6 0\n",
            "output": "824505797\n"
        },
        {
            "input": "4 49\n2 1 1\n2 3 0\n1 4 0\n",
            "output": "595131499\n"
        },
        {
            "input": "7 12\n4 6 0\n3 7 1\n7 6 1\n1 5 0\n2 3 0\n1 6 0\n",
            "output": "824505797\n"
        },
        {
            "input": "2 1\n1 2 0\n",
            "output": "0\n"
        },
        {
            "input": "7 12\n4 5 0\n2 1 1\n7 6 1\n1 5 0\n2 3 0\n1 6 0\n",
            "output": "824505797\n"
        },
        {
            "input": "7 12\n4 6 0\n5 7 1\n7 6 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "840224227\n"
        },
        {
            "input": "7 13\n4 6 0\n5 7 1\n7 6 1\n2 5 0\n2 3 0\n1 4 0\n",
            "output": "885821088\n"
        },
        {
            "input": "3 10\n1 2 0\n1 3 1\n",
            "output": "58024\n"
        },
        {
            "input": "2 39\n2 1 0\n",
            "output": "0\n"
        },
        {
            "input": "7 12\n4 6 0\n2 7 1\n7 6 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "840224227\n"
        },
        {
            "input": "4 19\n2 4 1\n4 3 1\n1 4 0\n",
            "output": "877380736\n"
        },
        {
            "input": "7 12\n4 6 0\n5 7 1\n7 1 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "840224227\n"
        },
        {
            "input": "7 13\n4 6 0\n5 4 1\n7 6 1\n2 5 0\n2 3 0\n1 4 0\n",
            "output": "885821088\n"
        },
        {
            "input": "7 20\n4 2 0\n2 7 1\n7 6 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "226397486\n"
        },
        {
            "input": "2 5\n1 2 1\n2 3 1\n3 1 1\n",
            "output": "30\n"
        },
        {
            "input": "7 12\n4 6 1\n2 7 1\n7 4 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "840751571\n"
        },
        {
            "input": "7 12\n4 6 1\n2 7 0\n7 4 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "824505797\n"
        },
        {
            "input": "7 20\n4 2 0\n4 7 1\n7 6 1\n2 5 1\n2 3 1\n1 6 0\n",
            "output": "736968991\n"
        },
        {
            "input": "7 20\n4 2 0\n4 7 0\n7 6 1\n2 5 1\n2 3 1\n1 6 0\n",
            "output": "251233188\n"
        },
        {
            "input": "7 20\n4 2 0\n4 7 0\n3 6 1\n2 5 1\n2 3 1\n1 6 0\n",
            "output": "251233188\n"
        },
        {
            "input": "3 10\n1 2 0\n2 3 0\n",
            "output": "0\n"
        },
        {
            "input": "4 49\n2 1 0\n2 3 0\n1 4 0\n",
            "output": "0\n"
        },
        {
            "input": "4 25\n3 4 1\n2 3 0\n1 3 0\n",
            "output": "610357816\n"
        },
        {
            "input": "7 12\n4 5 0\n2 1 1\n7 6 1\n1 5 0\n2 3 0\n1 6 1\n",
            "output": "840751571\n"
        },
        {
            "input": "7 12\n4 5 0\n2 7 1\n7 6 1\n1 5 0\n2 3 1\n1 2 0\n",
            "output": "824509891\n"
        },
        {
            "input": "7 12\n4 6 0\n2 7 1\n7 6 1\n2 5 1\n2 3 0\n1 6 0\n",
            "output": "840751571\n"
        },
        {
            "input": "7 20\n4 2 0\n2 7 1\n7 6 1\n3 5 0\n2 3 0\n1 6 0\n",
            "output": "226397486\n"
        },
        {
            "input": "2 5\n1 2 1\n2 0 1\n3 1 1\n",
            "output": "30\n"
        },
        {
            "input": "7 12\n4 6 1\n2 7 1\n7 4 1\n2 5 1\n2 3 0\n1 6 0\n",
            "output": "841278915\n"
        },
        {
            "input": "7 12\n4 6 1\n2 7 0\n7 6 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "824505797\n"
        },
        {
            "input": "7 20\n4 2 0\n4 7 1\n7 6 1\n2 5 1\n2 3 1\n1 7 0\n",
            "output": "736968991\n"
        },
        {
            "input": "7 20\n7 2 0\n4 7 0\n3 6 1\n2 5 1\n2 3 1\n1 6 0\n",
            "output": "251233188\n"
        },
        {
            "input": "19 20\n8 10 1\n17 15 1\n14 5 0\n6 14 0\n7 15 1\n19 8 1\n12 14 0\n2 18 0\n13 3 0\n17 1 1\n4 2 1\n11 3 0\n4 6 0\n6 9 0\n7 11 1\n16 4 0\n5 13 1\n9 19 0\n",
            "output": "808213127\n"
        },
        {
            "input": "7 12\n4 6 1\n2 7 1\n7 6 1\n2 5 0\n2 3 1\n1 2 0\n",
            "output": "840755665\n"
        },
        {
            "input": "2 5\n1 2 1\n2 0 1\n3 2 1\n",
            "output": "30\n"
        },
        {
            "input": "7 12\n4 3 1\n2 7 1\n7 6 1\n2 5 0\n2 3 0\n1 6 0\n",
            "output": "840751571\n"
        },
        {
            "input": "2 5\n1 2 1\n1 0 1\n3 2 1\n",
            "output": "30\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nvector<vector<int> > v(100001);\nvector<int> vis(100001);\nlong long binpow(long long a, long long b) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % mod;\n    a = (a * a) % mod;\n    b >>= 1;\n  }\n  return res % mod;\n}\nint dfs(int src) {\n  stack<int> st;\n  int cnt = 0;\n  st.push(src);\n  vis[src] = 1;\n  cnt++;\n  while (!st.empty()) {\n    int x = st.top();\n    st.pop();\n    if (!vis[x]) {\n      cnt++;\n      vis[x] = 1;\n    }\n    for (int i = 0; i < v[x].size(); i++) {\n      if (vis[v[x][i]] == 0) st.push(v[x][i]);\n    }\n  }\n  return cnt;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, k;\n  cin >> n >> k;\n  fill(vis.begin(), vis.end(), 0);\n  for (int i = 0; i < v.size(); i++) v[i].clear();\n  for (int i = 0; i < n - 1; i++) {\n    int x, y, c;\n    cin >> x >> y >> c;\n    if (c == 0) {\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n  }\n  long long ans = binpow(n, k);\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      ans = (mod + ans - binpow(dfs(i), k)) % mod;\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "kk=lambda:map(int,input().split())\nll=lambda:list(kk())\nn, k = kk()\ndsud = {i:{i} for i in range(n)}\ndsup = {i:i for i in range(n)}\nfor _ in range(n-1):\n\tu, v, xi = kk()\n\tu,v = u-1,v-1\n\tif xi == 0:\n\t\ts1, s2 = dsud[dsup[u]], dsud[dsup[v]]\n\t\tif len(s1) > len(s2):\n\t\t\ts1 |= s2\n\t\t\tdel dsud[dsup[v]]\n\t\t\tfor el in s2:\n\t\t\t\tdsup[el] = dsup[u]\n\t\telse:\n\t\t\ts2 |= s1\n\t\t\tdel dsud[dsup[u]]\n\t\t\tfor el in s1:\n\t\t\t\tdsup[el] = dsup[v]\nval = 0\nfor se in dsud:\n\tval += len(dsud[se])**k\nprint((n**k - val)%(7+10**9))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC target(\"avx2\")\n#pragma GCC optimization(\"unroll-loops\")\n#pragma GCC optimize(\"O2\")\nconstexpr int dx[] = {-1, 0, 1, 0, 1, 1, -1, -1};\nconstexpr int dy[] = {0, -1, 0, 1, 1, -1, 1, -1};\nconstexpr long long INF = 1999999999999999997;\nconstexpr int inf = INT_MAX;\nconstexpr int MAXSIZE = int(1e6) + 5;\nconstexpr auto PI = 3.14159265358979323846L;\nconstexpr auto oo = numeric_limits<int>::max() / 2 - 2;\nconstexpr auto eps = 1e-6;\nconstexpr auto mod = 1000000007;\nconstexpr auto MOD = 1000000007;\nconstexpr auto MOD9 = 1000000009;\nconstexpr auto maxn = 100006;\ntemplate <typename T, size_t N>\nint SIZE(const T (&t)[N]) {\n  return N;\n}\ntemplate <typename T>\nint SIZE(const T &t) {\n  return t.size();\n}\nstring to_string(string s, int x1 = 0, int x2 = 1e9) {\n  return '\"' + ((x1 < s.size()) ? s.substr(x1, x2 - x1 + 1) : \"\") + '\"';\n}\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(char c) { return string({c}); }\ntemplate <size_t N>\nstring to_string(bitset<N> &b, int x1 = 0, int x2 = 1e9) {\n  string t = \"\";\n  for (int __iii__ = min(x1, SIZE(b)), __jjj__ = min(x2, SIZE(b) - 1);\n       __iii__ <= __jjj__; ++__iii__) {\n    t += b[__iii__] + '0';\n  }\n  return '\"' + t + '\"';\n}\ntemplate <typename A, typename... C>\nstring to_string(A(&v), int x1 = 0, int x2 = 1e9, C... coords);\nint l_v_l_v_l = 0, t_a_b_s = 0;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> &p) {\n  l_v_l_v_l++;\n  string res = \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n  l_v_l_v_l--;\n  return res;\n}\ntemplate <typename A, typename... C>\nstring to_string(A(&v), int x1, int x2, C... coords) {\n  int rnk = rank<A>::value;\n  string tab(t_a_b_s, ' ');\n  string res = \"\";\n  bool first = true;\n  if (l_v_l_v_l == 0) res += '\\n';\n  res += tab + \"[\";\n  x1 = min(x1, SIZE(v)), x2 = min(x2, SIZE(v));\n  auto l = begin(v);\n  advance(l, x1);\n  auto r = l;\n  advance(r, (x2 - x1) + (x2 < SIZE(v)));\n  for (auto e = l; e != r; e = next(e)) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    l_v_l_v_l++;\n    if (e != l) {\n      if (rnk > 1) {\n        res += '\\n';\n        t_a_b_s = l_v_l_v_l;\n      };\n    } else {\n      t_a_b_s = 0;\n    }\n    res += to_string(*e, coords...);\n    l_v_l_v_l--;\n  }\n  res += \"]\";\n  if (l_v_l_v_l == 0) res += '\\n';\n  return res;\n}\nvoid dbgs() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgs(Heads H, Tails... T) {\n  cout << to_string(H) << \" | \";\n  dbgs(T...);\n}\nvector<long long> graph[maxn];\nlong long connected_nodes;\nvector<bool> visited(maxn, false);\nvoid dfs(long long src) {\n  visited[src] = true;\n  connected_nodes++;\n  for (auto child : graph[src]) {\n    if (visited[child] == false) {\n      dfs(child);\n    }\n  }\n}\nlong long expo(long long base, long long exponent, long long mod) {\n  long long ans = 1;\n  while (exponent != 0) {\n    if (exponent & 1) ans = (1LL * ans * base) % mod;\n    base = (1LL * base * base) % mod;\n    exponent >>= 1;\n  }\n  return ans % mod;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n, k, u, v, x;\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; i++) {\n    cin >> u >> v >> x;\n    if (x == 0) {\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n  }\n  long long res = expo(n, k, mod);\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      connected_nodes = 0;\n      dfs(i);\n      long long pk = expo(connected_nodes, k, mod);\n      res = (res - pk + mod) % mod;\n    }\n  }\n  cout << res << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e5 + 7;\nlong long MOD = 1000000007;\nstring yes = \"YES\\n\";\nstring no = \"NO\\n\";\nbool visited[MAX];\nlong long n, k;\nlong long pow(long long a, long long b, long long m) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % m;\n    b /= 2;\n    a = (a * a) % m;\n  }\n  return ans;\n}\nvoid dfs(long long i, vector<long long> a[], long long &size) {\n  visited[i] = true;\n  size++;\n  for (auto itr = a[i].begin(); itr != a[i].end(); itr++) {\n    if (!visited[*itr]) dfs(*itr, a, size);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  vector<long long> a[n];\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, v, x;\n    cin >> u >> v >> x;\n    u--;\n    v--;\n    if (!x) {\n      a[u].push_back(v);\n      a[v].push_back(u);\n    }\n  }\n  long long ans = 0;\n  memset(visited, false, sizeof(visited));\n  for (long long i = 0; i < n; i++) {\n    if (!visited[i]) {\n      long long size = 0;\n      dfs(i, a, size);\n      ans += pow(size, k, MOD);\n      ans = ans % MOD;\n    }\n  }\n  ans = (pow(n, k, MOD) - ans) % MOD;\n  if (ans < 0) ans = (MOD + ans) % MOD;\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom collections import Counter as CO\nsys.setrecursionlimit(10**6)\nmod=10**9+7\ninput=sys.stdin.readline\ndef find(parent,x):\n    if(x!=parent[x]):\n        parent[x]=find(parent,parent[x])\n    return parent[x]\ndef union(parent,x,y):\n    parent[x]=find(parent,x)\n    parent[y]=find(parent,y)\n    if(parent[x]==parent[y]):\n        return 1\n    else:\n        if(parent[x]<parent[y]):\n            parent[parent[x]]=parent[y]\n        else:\n            parent[parent[y]]=parent[x]\n            \n        \nn,k=map(int,input().split())\nparent=[0]*n\nfor i in range(n):\n    parent[i]=i\nfor i in range(n-1):\n    a,b,ex=map(int,input().split())\n    a-=1\n    b-=1\n    if(ex==0):\n        union(parent,a,b)\n\nfor i in range(n):\n    parent[i]=find(parent,i)\nans=0\nfreq=dict(CO(parent))\nfor i in freq:\n    ans=(ans+pow(freq[i],k,mod))%mod\nans=pow(n,k,mod)-ans\n#print(freq)\nif(ans<0):\n    ans+=mod\nprint(ans%mod)\n"
        },
        {
            "language": 3,
            "solution": "MOD = 1000000007\nn, k = map(int, input().split())\nch = [set() for _ in range(n + 1)]\nfor _2 in range(n - 1):\n    u, v, x = map(int, input().split())\n    if x == 0:\n        ch[u].add(v)\n        ch[v].add(u)\nres = 0\nroot = [True] * (n + 1)\nfor i in range(1, n + 1):\n    if root[i]:\n        cur = 1\n        stack = [i]\n        while stack:\n            u = stack.pop()\n            for v in ch[u]:\n                ch[v].remove(u)\n                cur += 1\n                root[v] = False\n                stack.append(v)\n        res = (res + pow(cur, k)) % MOD\nres = (MOD + pow(n, k) - res) % MOD\nprint(res)\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\ndef getAndParseInt(num=1):\n    string = (sys.stdin.readline()).strip()\n    if num==1:\n        return int(string)\n    else:\n        return [int(part) for part in string.split()]\n\ndef getAndParseString(num=1,delim=\" \"):\n    string = (sys.stdin.readline()).strip()\n    if num==1:\n        return string\n    else:\n        return [part for part in string.split(delim)]\n\nn,k = getAndParseInt(2)\nadj_list = [[] for i in range(n+1)]\n\nbinary_k = []\ntemp = k\nwhile temp>0:\n    binary_k.append(temp%2)\n    temp=temp//2\n\n\nfor i in range(n-1):\n    u,v,c = getAndParseInt(2)\n    if c!=1:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\nmarked = [0]*(n+1)\nmodulo = 1000000007\n\ndef powerMod(base):\n   maxp = len(binary_k)-1\n   index = 0\n   val = base % modulo\n   ret_val = 1\n   while index<=maxp:\n       if binary_k[index]:\n           ret_val=(ret_val*val) % modulo\n       val = (val * val) % modulo\n       index+=1\n   return ret_val\n\ndef dfs(vertex):\n    stack = [vertex]\n    size = 0\n    while stack:\n        cur = stack.pop()\n        marked[cur]=1\n        size+=1\n        for child in adj_list[cur]:\n            if not marked[child]:\n                stack.append(child)\n    return size\n\ntotal = powerMod(n)\nfor vertex in range(1,n+1):\n    if not marked[vertex]:\n       count =  dfs(vertex)\n       total = (total - powerMod(count))%modulo\n\nprint(total)\n"
        },
        {
            "language": 3,
            "solution": "_MOD = 10 ** 9 + 7\nfrom collections import defaultdict\n\nn, k = map(int, input().split())\ng = defaultdict(dict)\nfor _ in range(n - 1):\n    u, v, x = map(int, input().split())\n    g[u][v] = g[v][u] = x\n\nvisited_vertex = set()\ngroups = []\nfor i in range(1, n + 1):\n    if i in visited_vertex:\n        continue\n    # groups.append(find_group(i, g))\n    s = [i]\n    visited_vertex.add(i)\n    group = {i}\n    while len(s) > 0:\n        e = s.pop()\n        # visited_vertex.add(e)\n        for next in g[e]:\n            if next in visited_vertex or g[e][next] == 1:\n                continue\n            s.append(next)\n            visited_vertex.add(next)\n            group.add(next)\n    groups.append(group)\n\nr = n ** k\nfor group in groups:\n    r -= (len(group) ** k)\nprint(r % _MOD)\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    static int time=0;\n    static int count=0;\n    public static void main(String args[])\n    {\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=1;\n        while(T-->0)\n        {\n            int n=input.nextInt();\n            int k=input.nextInt();\n            ArrayList<Pair> adj[]=new ArrayList[n+1];\n            for(int i=1;i<=n;i++)\n            {\n                adj[i]=new ArrayList<>();\n            }\n            for(int i=0;i<n-1;i++)\n            {\n                int u=input.nextInt();\n                int v=input.nextInt();\n                int x=input.nextInt();\n                adj[u].add(new Pair(v,x));\n                adj[v].add(new Pair(u,x));\n            }\n            ArrayList<Integer> list=dfs(adj);\n            long m=1000000007;\n            long sum=0;\n            long s=0;\n            for(int i=0;i<list.size();i++)\n            {\n                int v=list.get(i);\n                s+=v;\n                long p=power(v,k,m);\n                sum=(sum%m+p%m)%m;\n            }\n            long rem=n-s;\n            sum=(sum%m+rem%m)%m;\n            long total=power(n,k,m);\n            long ans=(total%m-sum%m)%m;\n            if(ans<0)\n            {\n                ans+=m;\n            }\n            out.println(ans);\n        }\n        out.close();\n    }\n    public static long power(long a,long b,long m)\n    {\n        long res=1;\n        while(b>0)\n        {\n            if(b%2!=0)\n            {\n                res=(res%m*a%m)%m;\n            }\n            b=b/2;\n            a=(a%m*a%m)%m;\n        }\n        return res;\n    }\n    public static ArrayList<Integer> dfs(ArrayList<Pair> adj[])\n    {\n        int n=adj.length;\n        Vertex V[]=new Vertex[n];\n        for(int i=1;i<n;i++)\n        {\n            V[i]=new Vertex(i);\n        }\n        ArrayList<Integer> list=new ArrayList<>();\n        for(int i=1;i<n;i++)\n        {\n            if(V[i].color==\"white\")\n            {\n                count=0;\n                dfsVisit(adj,V,i);\n                if(count>1)\n                {\n                    list.add(count);\n                }\n            }\n        }\n        return list;\n    }\n    public static void dfsVisit(ArrayList<Pair> adj[],Vertex V[], int u)\n    {\n        time++;\n        V[u].color=\"gray\";\n        V[u].d=time;\n        count++;\n        for(int i=0;i<adj[u].size();i++)\n        {\n            int v=adj[u].get(i).v;\n            if (V[v].color==\"white\" && adj[u].get(i).x==0)\n            {\n                V[v].parent=V[u];\n                dfsVisit(adj,V,v);\n            }\n        }\n        time++;\n        V[u].f=time;\n        V[u].color=\"black\";\n    }\n    public static class Vertex\n    {\n        int key;\n        int d,f;\n        String color;\n        Vertex parent;\n        Vertex(int key)\n        {\n            this.key=key;\n            this.d=0;\n            this.f=0;\n            this.color=\"white\";\n            this.parent=null;\n        }\n    }\n    static class Pair\n    {\n        int v,x;\n        Pair(int v,int x)\n        {\n            this.v=v;\n            this.x=x;\n        }\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "# Problem: C. Edgy Trees\n# Contest: Codeforces - Codeforces Round #548 (Div. 2)\n# URL: https://codeforces.com/problemset/problem/1139/C\n# Memory Limit: 256 MB\n# Time Limit: 2000 ms\n# \n# KAPOOR'S\n\nfrom sys import stdin, stdout \n\ndef INI():\n\treturn int(stdin.readline())\n\t\ndef INL():\n\treturn [int(_) for _ in stdin.readline().split()]\n\t\ndef INS():\n\treturn stdin.readline()\n\ndef MOD():\n    return pow(10,9)+7\n\t\ndef OPS(ans):\n\tstdout.write(str(ans)+\"\\n\")\n\t\ndef OPL(ans):\n\t[stdout.write(str(_)+\" \") for _ in ans]\n\tstdout.write(\"\\n\")\n\t\nfrom types import GeneratorType\n \n \ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n \n    return wrappedfunc\n    \n    \n\n@bootstrap\ndef dfs(i):\n\tglobal c\n\tc+=1\n\tV[i]=True\n\tfor _ in C[i]:\n\t\tif not V[_]:\n\t\t\tyield dfs(_)\n\tyield\n\n\nif __name__==\"__main__\":\n\tn,k=INL()\n\tV=[False for _ in range(n+1)]\n\tC=dict()\n\t\t\n\tfor _ in range(n-1):\n\t\tu,v,x=INL()\n\t\tif not x:\n\t\t\tif u not in C:\n\t\t\t\tC[u]=[v]\n\t\t\telse:\n\t\t\t\tC[u].append(v)\n\t\t\tif v not in C:\n\t\t\t\tC[v]=[u]\n\t\t\telse:\n\t\t\t\tC[v].append(u)\n\t# print(C)\n\t\n\t\n\tans=0\n\tfor _ in C:\n\t\tglobal c\n\t\tc=0\n\t\tif not V[_]:\n\t\t\tdfs(_)\n\t\t\t# print(c)\n\t\t\t# print(V)\n\t\t\tans+=pow(c,k,MOD())\n\tans+=V[1:].count(False)\n\tOPS((pow(n,k,MOD())-ans%MOD())%MOD())"
        },
        {
            "language": 3,
            "solution": "n,k=map(int,input().split())\ngr=[None]*(n+1)\nvis=[False]*(n+1)\ncnt=0\nmod=1000000007\nfor i in range(n+1):\n         gr[i]=[]\nfor i in range(1,n):\n         x,y,w=map(int,input().split())\n         if(w==0):\n                  gr[x].append(y)\n                  gr[y].append(x)\nans=pow(n,k,mod)\nfor i in range(1,n+1):\n         if(vis[i]==False):\n                  cnt=0\n                  l=[i]\n                  size=1\n                  while(size>0):\n                           i=l[size-1]\n                           vis[i]=True\n                           l.pop()\n                           size-=1\n                           for x in gr[i]:\n                                    if(vis[x]==False):\n                                             l.append(x)\n                                             size+=1\n                           cnt+=1\n                  ans-=pow(cnt,k,mod)\nprint(ans%mod)"
        },
        {
            "language": 3,
            "solution": "import sys\n\nn, k = list(map(int, sys.stdin.readline().split()))\n\nsc = 0\nd = dict()\nlos = []\n\nfor i in range(n-1):\n    u, v, x = list(map(int, sys.stdin.readline().split()))\n    if not x:\n        if not u in d and not v in d:\n            d[u] = sc\n            d[v] = sc\n            los += [set([u, v])]\n            sc += 1\n        elif u in d and not v in d:\n            d[v] = d[u]\n            los[d[u]].add(v)\n        elif not u in d and v in d:\n            d[u] = d[v]\n            los[d[v]].add(u)\n        elif u in d and v in d:\n            stc = d[v]\n            los[d[u]] |= los[d[v]]\n            for j in los[stc]:\n                d[j] = d[u]\n            los[stc] = set()\n\ncolos = []\nfor s in los:\n    if s:\n        colos += [len(s)]\n\nif sum(colos) < n:\n    colos += [1] * (n - sum(colos))\n\ncs = n**k\n\nfor s in colos:\n    cs -= s**k\n\nprint(cs%1000000007)\n"
        },
        {
            "language": 1,
            "solution": "mod = 10**9 + 7\nnk = map(int, raw_input().strip().split())\nn = nk[0]\nk = nk[1]\nparent = [0] * (n+1)\nrank = [0] * (n +1)\nfor i in range(1, n+1):\n    parent[i] = i\n    rank[i] = 1\nfor i in range(n-1):\n  abc = map(int, raw_input().strip().split())\n  if abc[2] == 1:\n      continue\n  def find(node):\n      while(parent[node] != node):\n          parent[node] = parent[parent[node]]\n          node = parent[node]\n      return node\n  ra = find(abc[0])\n  rb = find(abc[1])\n  parent[ra] = parent[rb]\n  rank[rb] += rank[ra]\n\nsum_excluded = 0\nfor i in range(1,n+1):\n  if parent[i] == i:\n    sum_excluded += (rank[i] ** k) % mod\n    sum_excluded %= mod\n\nstart = (n**k) % mod\nprint (start - sum_excluded + mod)%mod \n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "N, K = [int(s) for s in input().split()]\ngraph = [[] for i in range(N)]\nfor _ in range(N-1):\n    a, b, color = [int(s)-1 for s in input().split()]\n    if color == -1:\n        graph[a].append(b)\n        graph[b].append(a)\nvisited = [False] * N\nn_component = []\nfor i in range(N):\n    if not visited[i]:\n        stack = [i]\n        visited[i] = True\n        n = 1\n        while stack:\n            now = stack.pop()\n            for v in graph[now]:\n                if not visited[v]:\n                    stack.append(v)\n                    visited[v] = True\n                    n += 1\n        n_component.append(n)\nseq = N ** K\nfor n in n_component:\n    seq -= n ** K\nprint(seq % (10**9 + 7))\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\nMOD=1000000000+7\n\ndef power(a,b):\n    result = 1\n    while b>0:\n        if b%2==1:\n            result = (result*a)%MOD\n        \n        b=b//2\n        a=(a*a)%MOD\n    return result\n\nn,k = map(int,input().split(\" \"))\nd={}\nd=defaultdict(lambda: [],d)\nfor _ in range(n-1):\n    u,v,x = map(int,input().split(\" \"))\n    if x==0:\n        d[u].append(v)\n        d[v].append(u)\n    \n\nvis=[0]*(n+1)\n\ndef dfs(node):\n    td=[node]\n    ans=0\n    while len(td)!=0:\n        m=td.pop(0)\n        if vis[m]!=0:\n            continue\n        \n        vis[m]=1\n        ans+=1\n        for i in d[m]:\n            td.append(i)\n    \n    return ans\n\nans1=[] \nfor i in range(1,n+1):\n    num = dfs(i)\n    ans1.append(num)\nans2=0\nfor i in ans1:\n    ans2+=power(i,k)\n    \nprint((power(n,k)-ans2)%MOD)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int N = 1e6 + 5;\nlong long int POWER[65];\nlong long int aonb(long long int a, long long int b) {\n  long long int ret = 1;\n  while (b) {\n    if (b & 1) ret *= a;\n    a *= a;\n    if (ret >= MOD) ret %= MOD;\n    if (a >= MOD) a %= MOD;\n    b >>= 1;\n  }\n  return ret;\n}\nvoid precompute() {\n  POWER[0] = 1;\n  for (int i = 1; i < 63; i++) POWER[i] = POWER[i - 1] << 1LL;\n}\nvector<long long int> A[N];\nmap<long long int, bool> visit;\nlong long int len;\nvoid dfs(long long int index) {\n  if (visit[index]) return;\n  len++;\n  visit[index] = true;\n  for (int i = 0; i < A[index].size(); i++) {\n    dfs(A[index][i]);\n  }\n}\nint main() {\n  int n, k;\n  int a, b, c;\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    cin >> a >> b >> c;\n    if (c == 0) {\n      A[a].push_back(b);\n      A[b].push_back(a);\n    }\n  }\n  long long int ans = 1;\n  for (int i = 1; i <= k; i++) {\n    ans = (ans * n) % MOD;\n  }\n  for (int i = 1; i <= n; i++) {\n    len = 0;\n    if (!visit[i]) {\n      dfs(i);\n    }\n    if (len) {\n      long long int curr = 1;\n      for (int i = 1; i <= k; i++) {\n        curr = (curr * len) % MOD;\n      }\n      ans = (MOD + ans - curr) % MOD;\n    }\n  }\n  cout << ans % MOD << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import deque as dq,defaultdict as dd\nmod=1000000007\ndef power(x,y):\n    ans=1\n    while y:\n        if(y%2):\n            ans=((ans%mod)*(x%mod))%mod\n        y=y>>1\n        x=((x%mod)*(x%mod))%mod\n    return ans\nn,k=map(int,input().split())\nd=dd(list)\nfor i in range(n-1):\n    u,v,a=map(int,input().split())\n    if(a==0):\n        d[u].append(v)\n        d[v].append(u)\nvis=[0]*(n+1)\n\ncl=0\nfor i in range(1,n+1):\n    if(vis[i]==0):\n        q=[i]\n        q=dq(q)\n        cou=0\n        while q:\n            cou+=1\n            a=q.pop()\n            vis[a]=1\n            for j in d[a]:\n                if(vis[j]==0):\n                    q.appendleft(j)\n        #print(cou)\n        b=power(cou,k)\n        cl=((cl%mod)+b%mod)%mod\n        \nprint((power(n,k)-cl+1000000007)%mod)"
        },
        {
            "language": 3,
            "solution": "import collections\n\np = 10 ** 9 + 7\n\nn, k = map(int, input().split())\n\n# g: List[List[int]]\ng = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b, x = map(int, input().split())\n    if x != 0:\n        continue\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\nv = [False] * n\n\nbad = 0\n\nfor i in range(n):\n    if v[i]:\n        continue\n\n    d = collections.deque()\n    d.append(i)\n    v[i] = True\n    c = 0\n    while d:\n        i = d.pop()\n        for j in g[i]:\n            if v[j]:\n                continue\n            v[j] = True\n            d.append(j)\n        c += 1\n    bad += pow(c, k, p)\n\nprint((pow(n, k, p) + p - bad) % p)\n"
        },
        {
            "language": 3,
            "solution": " ######      ###      #######    #######    ##      #     #####        ###     ##### \n #     #    #   #          #        #       # #     #    #     #      #   #     ###  \n #     #   #     #        #         #       #  #    #   #       #    #     #    ###  \n ######   #########      #          #       #   #   #   #           #########    #   \n ######   #########     #           #       #    #  #   #           #########    #   \n #     #  #       #    #            #       #     # #   #    ####   #       #    #   \n #     #  #       #   #             #       #      ##   #    #  #   #       #        \n ######   #       #  #######     #######    #       #    #####  #   #       #    #   \n\nfrom __future__ import print_function # for PyPy2\nfrom collections import Counter, OrderedDict\nfrom itertools import permutations as perm\nfrom fractions import Fraction\nfrom collections import deque\nfrom sys import stdin\nfrom bisect import *\nfrom heapq import *\n# from math import *\n\ng   = lambda : stdin.readline().strip()\ngl  = lambda : g().split()\ngil = lambda : [int(var) for var in gl()]\ngfl = lambda : [float(var) for var in gl()]\ngcl = lambda : list(g())\ngbs = lambda : [int(var) for var in g()]\nmod = int(1e9)+7\ninf = float(\"inf\")    \n\n\nn, k = gil()\nadj = [[] for _ in range(n+1)]\n\nfor _ in range(n-1):\n\tx, y, black = gil()\n\tif not black:\n\t\tadj[x].append(y)\n\t\tadj[y].append(x)\n\nans = 0 \nvis = [0]*(n+1)\nfor i in range(1, n+1):\n\tif vis[i]:continue\n\tstack = [i];vis[i] = 1\n\toption = 0\n\twhile stack:\n\t\tp = stack.pop()\n\t\toption += 1\n\t\tfor c in adj[p]:\n\t\t\tif not vis[c]:\n\t\t\t\tstack.append(c);vis[c] = 1\n\n\tans += pow(option, k, mod)\n\tans %= mod\n\nans = pow(n, k, mod) + mod - ans\nans %= mod\n\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/stack:247474112\")\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int mod = 1e9 + 7;\nconst int MAXN = 1e5 + 1;\nint par[MAXN];\nint ran[MAXN];\nvoid init(int n) {\n  for (long long i = 0; i < n; ++i) {\n    par[i] = i;\n    ran[i] = 0;\n  }\n}\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) return;\n  if (ran[x] < ran[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (ran[x] == ran[y]) ran[x]++;\n  }\n}\nbool same(int x, int y) { return find(x) == find(y); }\nlong long quickpow(long long x, long long n) {\n  long long ans = 1ll;\n  while (n) {\n    if (n & 1) {\n      ans *= x;\n      ans %= mod;\n    }\n    x *= x;\n    x %= mod;\n    n >>= 1;\n  }\n  return ans;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  init(n);\n  for (long long i = 0; i < n - 1; ++i) {\n    int x, y, c;\n    cin >> x >> y >> c;\n    if (c == 0) {\n      unite(x - 1, y - 1);\n    }\n  }\n  map<int, long long> cnt;\n  for (long long i = 0; i < n; ++i) {\n    cnt[find(i)]++;\n  }\n  long long ans = 0;\n  for (auto e : cnt) {\n    long long x = e.second;\n    if (x > 1) {\n      ans += quickpow(x, k);\n      ans %= mod;\n    } else {\n      ans++;\n      ans %= mod;\n    }\n  }\n  ans = quickpow(n, k) - ans;\n  ans %= mod;\n  if (ans < 0) ans += mod;\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class vtree {\n\n    static  int mod = 1000000007;\n    static long pow(int n,int k){\n        long ans = 1;\n\n        for(int i=1;i<=k;i++){\n            ans = (ans*n)%mod;\n\n        }\n\n\n        return ans;\n    }\n    public static  void main(String args[]){\n\n        Scanner s= new Scanner(System.in);\n        int n = s.nextInt();\n        int k = s.nextInt();\n        long ans = 0;\n        Dsu dsu = new Dsu(n);\n        for(int i=0;i<n-1;i++){\n            int x  = s.nextInt();\n            int y = s.nextInt();\n            int w = s.nextInt();\n            if(w == 0){\n                dsu.union(x-1,y-1);\n            }\n        }\n\n        int par[] = dsu.par;\n        List<Integer> list = new ArrayList<>();\n        for(int i=0;i<n;i++){\n            if(par[i]==i){\n                list.add(i);\n            }\n        }\n        int size[] = dsu.size;\n        ans = pow(n,k) - n;\n        for(int x:list){\n            int c = 0;\n            c = size[x];\n\n            ans = (ans -  (pow(c,k)-c) + mod)%mod;\n        }\n\n        System.out.println(ans);\n    }\n\n    static class Dsu{\n\n        int n;\n        int par[];\n        int size[];\n\n\n        Dsu(int n){\n            this.n = n;\n            par = new int[n];\n            size = new int[n];\n            Arrays.fill(size,1);\n\n            for(int i=0;i<n;i++){\n\n                par[i] = i;\n            }\n        }\n\n        int  find(int x){\n            if(par[x]==x){\n                return x;\n            }\n            int tem = find(par[x]);\n             par[x] = tem;\n            return tem;\n        }\n        boolean union(int x ,int y){\n            int rootx = find(x);\n            int rooty = find(y);\n\n            if(rootx == rooty){\n                return false;\n            }\n\n            if(size[rootx]>=size[rooty]){\n                par[rooty] = rootx;\n                size[rootx] += size[rooty];\n\n            }\n            else{\n                par[rootx] = rooty;\n                size[rooty] += size[rootx];\n\n            }\n\n          return true;\n        }\n\n\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<long long, long long> visited;\nvector<vector<long long>> graph(100005);\nmap<pair<long long, long long>, long long> color;\nlong long modpow(long long n, long long p) {\n  if (p == 0) {\n    return 1;\n  }\n  if (p % 2 == 0) {\n    return (modpow(n, p / 2) * modpow(n, p / 2)) % 1000000007;\n  }\n  return (n * modpow(n, p - 1)) % 1000000007;\n}\nlong long dfs(long long start) {\n  visited[start]++;\n  long long smallans = 1;\n  for (long long i = 0; i < graph[start].size(); i++) {\n    if (visited.count(graph[start][i])) continue;\n    pair<long long, long long> p = make_pair(start, graph[start][i]);\n    if (color[p] == 1) continue;\n    smallans = smallans + dfs(graph[start][i]);\n  }\n  return smallans;\n}\nint32_t main() {\n  cin.sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long n, k;\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, v, c;\n    cin >> u >> v >> c;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n    color[make_pair(u, v)] = c;\n    color[make_pair(v, u)] = c;\n  }\n  long long x = 0;\n  for (long long i = 1; i <= n; i++) {\n    if (visited.count(i)) continue;\n    long long y = dfs(i);\n    x = x + modpow(y, k);\n    x = x % 1000000007;\n  }\n  long long ans = modpow(n, k);\n  ans = ans - x;\n  if (ans < 0) ans = ans + 1000000007;\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (a % b == 0)\n    return b;\n  else\n    return gcd(b, a % b);\n}\nint sum(long long a) {\n  int sum = 0;\n  while (a > 0) {\n    sum = sum + (a % 10);\n    a = a / 10;\n  }\n  return sum;\n}\nint count_digit(long long n) {\n  int count = 0;\n  while (n > 0) {\n    n = n / 10;\n    count++;\n  }\n  return count;\n}\nint binarySearch(int x, int y, long long z, long long v[]) {\n  int low = x;\n  int high = y;\n  int mid = x + (y - x) / 2;\n  while (low <= high) {\n    if (v[mid] == z) return mid;\n    if (v[mid] < z) return binarySearch(mid + 1, high, z, v);\n    if (v[mid] > z) return binarySearch(low, mid - 1, z, v);\n  }\n  return -1;\n}\nlong long modularExponentiation(long long x, long long n, long long M) {\n  if (n == 0)\n    return 1;\n  else if (n % 2 == 0)\n    return modularExponentiation((x * x) % M, n / 2, M);\n  else\n    return (x * modularExponentiation((x * x) % M, (n - 1) / 2, M)) % M;\n}\nlong long binaryExponentiation(long long x, long long n) {\n  if (n == 0)\n    return 1;\n  else if (n % 2 == 0)\n    return binaryExponentiation(x * x, n / 2);\n  else\n    return x * binaryExponentiation(x * x, (n - 1) / 2);\n}\nint binary(int n) {\n  int c = 0;\n  while (n > 0) {\n    if (n % 2 == 1) {\n      return pow(2, c);\n    }\n    n = n / 2;\n    c++;\n  }\n}\nset<long long> s;\nvoid genrate(long long n, int len, int max) {\n  if (len > max) return;\n  s.insert(n);\n  genrate(n * 10 + 1, len + 1, max);\n  genrate(n * 10 + 0, len + 1, max);\n}\nvector<long long> ans;\nvector<pair<long long, long long> > v[300005];\nbool visited[300005];\nlong long c = 0;\nlong long dfs(int x) {\n  visited[x] = 1;\n  for (int i = 0; i < v[x].size(); i++) {\n    if (v[x][i].second == 0 && visited[v[x][i].first] == 0) {\n      c++;\n      dfs(v[x][i].first);\n    }\n  }\n  return 0;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int tests = 1;\n  while (tests--) {\n    long long n, k;\n    cin >> n >> k;\n    for (int i = 1; i < n; i++) {\n      long long x, y, z;\n      cin >> x >> y >> z;\n      v[x].push_back({y, z});\n      v[y].push_back({x, z});\n    }\n    memset(visited, 0, sizeof(visited));\n    for (int i = 1; i <= n; i++) {\n      if (!visited[i]) {\n        c = 1;\n        dfs(i);\n        ans.push_back(c);\n      }\n    }\n    long long ans1 = modularExponentiation(n, k, 1000000007);\n    for (int i = 0; i < ans.size(); i++) {\n      ans1 = (ans1 - modularExponentiation(ans[i], k, 1000000007));\n      ans1 = ans1 + 1000000007;\n      ans1 = ans1 % 1000000007;\n    }\n    cout << ans1;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split())\n# import math\n\ntr = [[] for i in range(n)]\n\nfor i in range(n - 1):\n    a, b, x = map(int, input().split())\n    if x == 0:\n        tr[a - 1].append(b - 1)\n        tr[b - 1].append(a - 1)\n\nseq = []\nv = [False for i in range(n)]\n\nfor i in range(n):\n    if v[i]:\n        continue\n    m = []\n    s = [i]\n    while s:\n        x = s.pop()\n        m.append(x)\n        v[x] = True\n        for y in tr[x]:\n            if v[y]:\n                continue\n            s.append(y)\n\n    seq.append(len(m))\n\nans = 0\nmod = 10 ** 9 + 7\nfor i in seq:\n    ans = ans + pow(i, k, mod)\nprint((pow(n, k, mod) - ans) % mod)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long par[200000];\nlong long ran[200000];\nlong long cnt[200000];\nvoid init(long long n) {\n  for (long long i = 0; i <= n; i++) {\n    par[i] = i;\n    ran[i] = 0;\n  }\n}\nlong long finds(long long x) {\n  if (par[x] == x)\n    return x;\n  else\n    return par[x] = finds(par[x]);\n}\nvoid unite(long long x, long long y) {\n  x = finds(x);\n  y = finds(y);\n  if (x == y) return;\n  if (ran[x] < ran[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (ran[x] == ran[y]) ran[x]++;\n  }\n}\nlong long quick_mod(long long a, long long n) {\n  long long tmp = a;\n  long long ans = 1;\n  while (n) {\n    if (n % 2 == 1) ans = (tmp * ans) % 1000000007;\n    n /= 2;\n    tmp = (tmp * tmp) % 1000000007;\n  }\n  return ans;\n}\nint main() {\n  long long n, k;\n  scanf(\"%lld%lld\", &n, &k);\n  init(n);\n  for (long long i = 0; i < n - 1; i++) {\n    long long a, b, c;\n    scanf(\"%lld%lld%lld\", &a, &b, &c);\n    if (c == 0) unite(a, b);\n  }\n  for (long long i = 1; i <= n; i++) {\n    finds(i);\n    cnt[par[i]]++;\n  }\n  long long ans = quick_mod(n, k);\n  for (long long i = 1; i <= n; i++) {\n    ans = (ans + 1000000007 - quick_mod(cnt[i], k)) % 1000000007;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "\t/*\t/ \uff8c\uff8c\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u30e0\n\t\t/ )\\\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800  Y\n\t\t(\u2800\u2800| ( \u0361\u00b0 \u035c\u0296 \u0361\u00b0\uff09\u2800\u2312(\u2800 \u30ce\n\t\t(\u2800 \uff89\u2312 Y \u2312\u30fd-\u304f __\uff0f\n\t\t| _\u2800\uff61\u30ce| \u30ce\uff61 |/\n\t\t(\u2800\u30fc '_\u4eba`\u30fc \uff89\n\t\t\u2800|\\ \uffe3 _\u4eba'\u5f61\uff89\n\t\t\u2800 )\\\u2800\u2800 \uff61\u2800\u2800 /\n\t\t\u2800\u2800(\\\u2800 #\u2800 /\n\t\t\u2800/\u2800\u2800\u2800/\u1f63====================D-\n\t\t/\u2800\u2800\u2800/\u2800 \\ \\\u2800\u2800\\\n\t\t( (\u2800)\u2800\u2800\u2800\u2800 ) ).\u2800)\n\t\t(\u2800\u2800)\u2800\u2800\u2800\u2800\u2800( | /\n\t\t|\u2800 /\u2800\u2800\u2800\u2800\u2800\u2800 | /\n\t\t[_] \u2800\u2800\u2800\u2800\u2800[___]                     */\n\t// Main Code at the Bottom\n\timport java.util.*;\n\timport java.lang.*;\n\timport java.io.*;\n\timport java.math.BigInteger; \n\tpublic class Main {\n\t\t//Fast IO class\n\t    static class FastReader {\n\t        BufferedReader br; \n\t        StringTokenizer st; \n\t        public FastReader() {\n\t        \tboolean env=System.getProperty(\"ONLINE_JUDGE\") != null;\n\t        \tif(!env) {\n\t        \t\ttry {\n\t\t\t\t\t\tbr=new BufferedReader(new FileReader(\"src\\\\input.txt\"));\n\t\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t        \t}\n\t        \telse br = new BufferedReader(new InputStreamReader(System.in)); \n\t        } \n\t        String next() {\n\t            while (st == null || !st.hasMoreElements()) {\n\t                try {\n\t                    st = new StringTokenizer(br.readLine()); \n\t                } \n\t                catch (IOException  e) {\n\t                    e.printStackTrace(); \n\t                } \n\t            } \n\t            return st.nextToken(); \n\t        } \n\t        int nextInt() {\n\t            return Integer.parseInt(next()); \n\t        } \n\t        long nextLong() {\n\t            return Long.parseLong(next()); \n\t        } \n\t        double nextDouble() {\n\t            return Double.parseDouble(next()); \n\t        } \n\t        String nextLine() {\n\t            String str = \"\"; \n\t            try {\n\t                str = br.readLine(); \n\t            } \n\t            catch (IOException e) {\n\t                e.printStackTrace(); \n\t            } \n\t            return str; \n\t        } \n\t    }     \n\t    static long MOD=1000000000+7;\n\t    //Euclidean Algorithm\n\t    static long gcd(long A,long B){\n\t    \treturn (B==0)?A:gcd(B,A%B);\n\t    }\n\t    //Modular Exponentiation\n\t    static long fastExpo(long x,long n){\n\t        if(n==0) return 1;\n\t        if((n&1)==0) return fastExpo((x*x)%MOD,n/2)%MOD;\n\t        return ((x%MOD)*fastExpo((x*x)%MOD,(n-1)/2))%MOD;\n\t    }\n\t    //Modular Inverse\n\t    static long inverse(long x) {\n\t    \treturn fastExpo(x,MOD-2);\n\t    }\n\t    //Prime Number Algorithm\n\t    static boolean isPrime(long n){\n\t        if(n<=1) return false;\n\t        if(n<=3) return true;\n\t        if(n%2==0 || n%3==0) return false;\n\t        for(int i=5;i*i<=n;i+=6) if(n%i==0 || n%(i+2)==0) return false;\n\t        return true;\n\t    }\n\t    //Reverse an array\n\t    static void reverse(int arr[],int l,int r){\n\t    \twhile(l<r) {\n\t    \t\tint tmp=arr[l];\n\t    \t\tarr[l++]=arr[r];\n\t    \t\tarr[r--]=tmp;\n\t    \t}\n\t    }\n\t    //Print array\n\t    static void print1d(int arr[]) {\n\t    \tout.println(Arrays.toString(arr));\n\t    }\n\t    static void print2d(long arr[][]) {\n\t    \tfor(long a[]: arr) out.println(Arrays.toString(a));\n\t    }\n\t    // Pair\n\t    static class pair{\n\t    \tint x,y;\n\t    \tpair(int a,int b){\n\t    \t\tthis.x=a;\n\t    \t\tthis.y=b;\n\t    \t}\n\t    \tpublic boolean equals(Object obj) {\n\t    \t\tif(obj == null || obj.getClass()!= this.getClass()) return false;\n\t            pair p = (pair) obj;\n\t            return (this.x==p.x && this.y==p.y);\n\t        }\n\t    \tpublic int hashCode() {\n\t            return Objects.hash(x,y);\n\t        }\n\t    }\n\t    static FastReader sc=new FastReader();\n\t    static PrintWriter out=new PrintWriter(System.out);  \n\t    //Main function(The main code starts from here)\n\t    static int parent[];\n\t    static void init(int n) {\n\t    \tparent=new int[n];\n\t    \tfor(int i=0;i<n;i++) parent[i]=-1;\n\t    }\n\t    static int find(int x) {\n\t    \tif(parent[x]<0) return x;\n\t    \treturn parent[x]=find(parent[x]);\n\t    }\n\t    static void union(int a,int b) {\n\t    \ta=find(a);b=find(b);\n\t    \tif(a!=b) {\n\t    \t\tparent[b]+=parent[a];\n\t    \t\tparent[a]=b;\n\t    \t}\n\t    }\n\t    public static void main (String[] args) throws java.lang.Exception {\n\t    \tint test;\n\t    \ttest=1;\n\t    \t//test=sc.nextInt();\n\t    \twhile(test-->0){\n\t    \t\tint n=sc.nextInt(),k=sc.nextInt();\n\t    \t\tinit(n);\n\t    \t\tfor(int i=0;i<n-1;i++) {\n\t    \t\t\tint src=sc.nextInt()-1,dest=sc.nextInt()-1,color=sc.nextInt();\n\t    \t\t\tif(color==1) continue;\n\t    \t\t\tunion(src,dest);\n\t    \t\t}\n\t    \t\tlong ans=fastExpo(n,k);\n\t    \t\tfor(int i=0;i<n;i++) {\n\t    \t\t\tif(parent[i]>=0) continue;\n\t    \t\t\tint val=-parent[i];\n\t    \t\t\tans=(ans%MOD-fastExpo(val,k)%MOD+MOD)%MOD;\n\t    \t\t}\n\t    \t\tout.println(ans);\n\t    \t}\n\t    \t\n\t        out.flush();\n\t        out.close();\n\t    }\n\t}"
        },
        {
            "language": 1,
            "solution": "import sys\n\nn, k = map(int, raw_input().split())\nf = [i for i in range(n + 1)]\ns = [1 for i in range(n + 1)]\n\ndef parent(x):\n\tif f[x] == x:\n\t\treturn x\n\telse:\n\t\ty = parent(f[x])\n\t\tf[x] = y\n\t\treturn y\n\nsys.setrecursionlimit(10 ** 6)\n\nfor i in range(1, n):\n\tp, q, r = map(int, raw_input().split())\n\tif r == 1:\n\t\tcontinue\n\tp = parent(p)\n\tq = parent(q)\n\tif s[p] < s[q]:\n\t\tp, q = q, p\n\tf[q] = p\n\ts[p] += s[q]\n\nans = pow(n, k, 10 ** 9 + 7)\n\nfor i in range(1, n + 1):\n\tif parent(i) == i:\n\t\tans = ans + 10 ** 9 + 7 - pow(s[i], k, 10 ** 9 + 7)\n\nans %= 10 ** 9 + 7\nprint ans"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst long long mod = 1e9 + 7;\nint n, k;\nvector<vector<int> > v(N + 1);\nbool vis[N];\nlong long ksm(long long x, long long n, long long mod) {\n  long long res = 1;\n  while (n > 0) {\n    if (n & 1) res = res * x % mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\nint main() {\n  int a, b, c, num;\n  long long sum = 0, ans, kk = 0;\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < n - 1; i++) {\n    scanf(\"%d %d %d\", &a, &b, &c);\n    if (c == 0) {\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (v[i].size() != 0) {\n      num = 1;\n      queue<int> q;\n      if (!vis[i]) {\n        q.push(i);\n        vis[i] = true;\n      }\n      while (!q.empty()) {\n        int top = q.front();\n        q.pop();\n        for (int j = 0; j < v[top].size(); j++) {\n          if (!vis[v[top][j]]) {\n            q.push(v[top][j]);\n            vis[v[top][j]] = true;\n            num++;\n          }\n        }\n      }\n      if (num != 1) {\n        sum += ksm(num, k, mod);\n        kk += num;\n        sum %= mod;\n      }\n    }\n  }\n  ans = ksm(n, k, mod) - sum - (n - kk);\n  if (ans < 0) ans = mod + ans;\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport javafx.util.Pair;\n\npublic class Solve5 {\n\n    public static void main(String[] args) throws IOException {\n        PrintWriter pw = new PrintWriter(System.out);\n        new Solve5().solve(pw);\n        pw.flush();\n        pw.close();\n    }\n\n    public void solve(PrintWriter pw) throws IOException {\n        FastReader sc = new FastReader();\n        final int MOD = (int) 1E+9 + 7;\n        int n = sc.nextInt(), k = sc.nextInt();\n        Pair<Pair<Integer, Integer>, Integer>[] edges = new Pair[n];\n        for (int i = 1; i <= n - 1; i++) {\n            edges[i] = new Pair(new Pair(sc.nextInt(), sc.nextInt()), sc.nextInt());\n        }\n        int[] parent = new int[n + 1];\n        int[] size = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n        for (int i = 1; i <= n - 1; i++) {\n            if (edges[i].getValue() == 0) {\n                Pair<Integer, Integer> temp = edges[i].getKey();\n                merge(temp.getKey(), temp.getValue(), parent, size);\n            }\n        }\n        long s = 0;\n        for (int i = 1; i <= n; i++) {\n            if (parent[i] == i) {\n                s += pow(size[i], k, MOD);\n                s %= MOD;\n            }\n        }\n        long ans = pow(n, k, MOD) - s;\n        if(ans<0) ans+=MOD;\n        pw.println(ans);\n    }\n\n    public long pow(long a, int p, int MOD) {\n        int k = p;\n        long ans = 1;\n        while (k > 0) {\n            if ((k & 1) == 1) {\n                ans *= a;\n                ans %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            k >>= 1;\n        }\n        return ans;\n    }\n\n    public int getParent(int x, int[] parent) {\n        if (x == parent[x]) {\n            return x;\n        }\n        return parent[x] = getParent(parent[x], parent);\n    }\n\n    public void merge(int x, int y, int[] parent, int[] size) {\n        x = getParent(x, parent);\n        y = getParent(y, parent);\n        if (size[x] < size[y]) {\n            size[y] += size[x];\n            parent[x] = y;\n        } else {\n            size[x] += size[y];\n            parent[y] = x;\n        }\n    }\n\n    static class FastReader {\n\n        StringTokenizer st;\n        BufferedReader br;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public boolean hasNext() throws IOException {\n            String s = br.readLine();\n            if (s == null || s.isEmpty()) {\n                return false;\n            }\n            st = new StringTokenizer(s);\n            return true;\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s.isEmpty()) {\n                    return null;\n                }\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right \nfrom heapq import heappop,heappush,heapify, nlargest\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n        \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n    \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\nn,k = inpl()\nuf = UnionFind(n)\nfor _ in range(n-1):\n    a,b,c = inpl()\n    if c==0:\n        uf.union(a-1,b-1)\nd = defaultdict(list)\nfor i in range(n):\n    now = uf.find(i)\n    if now < 0: d[i].append(i)\n    else: d[now].append(i)\nsu = 0\nfor key in list(d):\n    m = len(d[key])\n    su += pow(m,k,mod)\nprint((pow(n,k,mod)-su)%mod)"
        },
        {
            "language": 4,
            "solution": "import javax.print.attribute.IntegerSyntax;\nimport java.sql.Array;\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\npublic class MainS {\n    static final long MOD1 = 1_000_000_007, INF = 1_000_000_000_000_000_000L, BASE1 = 47, MOD2 = 1_000_000_007, BASE2 = 31;\n    static final int INf = 1_000_000_000;\n    static FastReader reader;\n    static PrintWriter writer;\n    public static void main(String[] args) {\n        Thread t = new Thread(null, new O(), \"Integer.MAX_VALUE\", 100000000);\n        t.start();\n    }\n    static class O implements Runnable {\n        public void run() {\n            try {\n                magic();\n            }\n            catch (Exception e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n    }\n    public static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n    static int baap[], weight[];\n    static long res;\n    static void magic() throws IOException {\n        reader = new FastReader();\n        writer = new PrintWriter(System.out, true);\n        int n = reader.nextInt(),k = reader.nextInt();\n        init(n);\n        for(int i=1;i<n;++i) {\n            int u = reader.nextInt(), v = reader.nextInt(), type = reader.nextInt();\n            if(type==0) {\n                un(u, v);\n            }\n        }\n        long ans = 0;\n        for(int i=1;i<=n;++i) {\n            if(gr(i)==i) {\n                ans+=modpow(weight[i],k, MOD1);\n                ans%=MOD1;\n            }\n        }\n        writer.println((modpow(n, k, MOD1) - ans + MOD1)%MOD1);\n    }\n    static void init(int n)\n    {\n        baap = new int[n+1];\n        weight = new int[n+1];\n        for(int i=0;i<=n;++i)\n        {\n            baap[i] = i;\n            ++weight[i];\n        }\n    }\n    static int gr(int a)\n    {\n        if(baap[a]==a)\n            return a;\n        return baap[a] = gr(baap[a]);\n    }\n    static boolean un(int a,int b)\n    {\n        int ra = gr(a);\n        int rb = gr(b);\n        if(ra==rb)\n            return false;\n        if(weight[rb]>weight[ra])\n        {\n            weight[rb]+=weight[ra];\n            baap[ra] = rb;\n        }\n        else\n        {\n            weight[ra]+=weight[rb];\n            baap[rb] = ra;\n        }\n        return true;\n    }\n    static long modpow(long x,long y,long mod)\n    {\n        res = 1;\n        while(y>0)\n        {\n            if((y&1)==1)\n                res = (res*x)%mod;\n            y>>=1;\n            x = (x*x)%mod;\n        }\n        return res;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint fa[100005], cnt[100005];\nint getf(int x) { return fa[x] == x ? x : fa[x] = getf(fa[x]); }\nvoid merge(int x, int y) {\n  int a = getf(x);\n  int b = getf(y);\n  if (a != b) {\n    fa[a] = b;\n  }\n}\nlong long qpow(long long x, long long y) {\n  long long res = 1;\n  while (y) {\n    if (y & 1) res = res * x % 1000000007;\n    x = x * x % 1000000007;\n    y >>= 1;\n  }\n  return res;\n}\nint main() {\n  int n, k, x, y, z;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; i++) fa[i] = i;\n  for (int i = 1; i <= n - 1; i++) {\n    scanf(\"%d%d%d\", &x, &y, &z);\n    if (z == 0) merge(x, y);\n  }\n  for (int i = 1; i <= n; i++) {\n    cnt[getf(i)]++;\n  }\n  long long ans = qpow(n, k);\n  for (int i = 1; i <= n; i++) {\n    if (fa[i] == i) {\n      ans = (ans + 1000000007 - qpow(cnt[fa[i]], k)) % 1000000007;\n    }\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\nn, k = list(map(int, sys.stdin.readline().split()))\n\nsc = 0\nd = dict()\nlos = []\n\nfor i in range(n-1):\n    u, v, x = list(map(int, sys.stdin.readline().split()))\n    if not x:\n        if u in d and v in d:\n            stc = d[v]\n            los[d[u]] |= los[d[v]]\n            for j in los[stc]:\n                d[j] = d[u]\n            los[stc] = set()\n        if u not in d and v not in d:\n            d[u] = sc\n            d[v] = sc\n            los += [set([u, v])]\n            sc += 1\n        elif u in d and v not in d:\n            d[v] = d[u]\n            los[d[u]].add(v)\n        else:\n            d[u] = d[v]\n            los[d[v]].add(u)\n\ncolos = []\nfor s in los:\n    if s:\n        colos += [len(s)]\n\nif sum(colos) < n:\n    colos += [1] * (n - sum(colos))\n\ncs = n**k\n\nfor s in colos:\n    cs -= s**k\n\nprint(cs%1000000007)\n"
        },
        {
            "language": 3,
            "solution": "mod=10**9+7\ndef pwmod(a,b,mod):\n    res=1\n    a%=mod\n    while(b):\n        if b&1:\n            res=(res*a)%mod\n        b=b>>1\n        a=(a*a)%mod\n    return res\ndef dfs(v,vis):\n    cnt=1\n    st=[]\n    st.append(v)\n    while(st):\n        x=st.pop()\n        for i in g[x]:\n            if vis[i[0]]==0 and i[1]==0:\n                vis[i[0]]=1\n                cnt+=1\n                st.append(i[0])\n    return cnt\nn,k=map(int,input().split())\ng=[[] for i in range(n)]\nfor i in range(n-1):\n    x,y,z=map(int,input().split())\n    x-=1;y-=1\n    g[x].append([y,z])\n    g[y].append([x,z])\nvis=[0]*n\nres=pwmod(n,k,mod)\nfor i in range(n):\n    if vis[i]==0:\n        vis[i]=1\n        tmp=dfs(i,vis)\n        res=(res%mod-pwmod(tmp,k,mod))%mod\nprint(res)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\n public:\n  static constexpr long long MOD = 1000000007LL;\n  vector<vector<int>> graph;\n  array<bool, 100000> used;\n  void reset() {\n    graph.clear();\n    used.fill(false);\n  }\n  int dfs(int v) {\n    used[v] = true;\n    int count = 1;\n    for (int next : graph[v]) {\n      if (used[next]) continue;\n      count += dfs(next);\n    }\n    return count;\n  }\n  long long binpow(long long a, long long n) {\n    long long res = 1;\n    while (n) {\n      if (n & 1) res = (res * a) % MOD;\n      a = (a * a) % MOD;\n      n >>= 1;\n    }\n    return res;\n  }\n  void solve() {\n    reset();\n    int n, k;\n    cin >> n >> k;\n    graph.resize(n);\n    for (int i = 0; i < n - 1; ++i) {\n      int v, u, b;\n      cin >> v >> u >> b;\n      v--;\n      u--;\n      if (!b) {\n        graph[v].push_back(u);\n        graph[u].push_back(v);\n      }\n    }\n    vector<int> comp_counts;\n    for (int v = 0; v < n; ++v) {\n      if (!used[v]) {\n        comp_counts.push_back(dfs(v));\n      }\n    }\n    long long total = binpow(n, k);\n    long long bad = 0;\n    for (int count : comp_counts) {\n      bad = (bad + binpow(count, k)) % MOD;\n    }\n    long long result = total - bad;\n    if (result < 0) result += MOD;\n    cout << result << endl;\n  }\n};\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  Solution s;\n  int t = 1;\n  while (t--) {\n    s.solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def bfs(start):\n    global count\n    queue = []\n    queue.append(start)\n  # mark the start node as visited\n    visited[start] = True\n    count+=1\n    while queue:\n    # Dequeue the oldest vertex from queue\n        start = queue.pop(0)\n    # Printing the dequeued vertex\n    #print start,\n    # Get all the adjacent vertices of the dequeued vertex\n        for i in range(len(adj[start])):\n            ele = adj[start][i]\n      # Enqueue the vertex if unvisited and mark as visited\n            if not visited[ele]:\n                visited[ele] = True\n                count+=1\n                queue.append(ele)\nn,k=map(int,input().split())\nadj=[[] for i in range(n)]\nfor i in range(n-1):\n    a,b,c=map(int,input().split())\n    if c==0:\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\nvisited=[False]*n\nca=[]\nfor i in range(n):\n    if not(visited[i]):\n        count=0\n        bfs(i)\n        ca.append(count)\nans=0\nmod=(10**9)+7\npa=pow(n,k,mod)\nfor i in ca:\n    ans=(ans+pow(i,k,mod))%mod\nprint((pa-ans)%mod)"
        },
        {
            "language": 4,
            "solution": "//I AM THE CREED\n/* //I AM THE CREED\n/* package codechef; // don't place package name! */\nimport java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.StringTokenizer; \nimport java.util.*;\nimport java.awt.Point;\npublic class Main{\n    static long mod=1000000007;\n    public static void main(String[] args) throws IOException \n    { \n        Scanner input=new Scanner(System.in);\n        while(input.hasNext()){\n            int n=input.nextInt();\n            long k=input.nextLong();\n            ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\n            HashMap<String, Integer> col=new HashMap<>();\n            HashSet<Integer> visited=new HashSet<>();\n            long ways=0;\n            for(int i=0;i<=n;i++){\n                graph.add(new ArrayList<>());\n            }\n            \n            for(int i=0;i<n-1;i++){\n                int u=input.nextInt();\n                int v=input.nextInt();\n                int color=input.nextInt();\n                graph.get(u).add(v);\n                graph.get(v).add(u);\n                col.put(Integer.toString(u)+\",\"+Integer.toString(v), color);\n                col.put(Integer.toString(v)+\",\"+Integer.toString(u), color);\n            }\n            for(int i=1;i<=n;i++){\n                if(visited.contains(i)){\n                    continue;\n                }\n                long vertices=dfs(graph, visited, i, col);\n                ways=(ways+((pow(vertices, k))-vertices+mod)%mod)%mod;\n            }\n            System.out.println((pow((long)(n), k)-ways-n+mod+mod)%mod);\n        }\n        \n    }\n    static long pow(long a, long b){\n        if(b==1){\n            return a%mod;\n        }\n        return (pow(a, b-1)*a)%mod;\n    }\n    static long dfs(ArrayList<ArrayList<Integer>> g, HashSet<Integer> v, int n, HashMap<String, Integer> col){\n        if(v.contains(n)){\n            return (long)(0);\n        }\n        long tot=1;\n        v.add(n);\n        for(int children:g.get(n)){\n            if(col.get(Integer.toString(n)+\",\"+Integer.toString(children))==1){\n                continue;\n            }\n            tot+=dfs(g, v, children, col);\n        }\n        return tot;\n    }\n    //Credits to SecondThread(https://codeforces.com/profile/SecondThread) for this tempelate\n    static void ruffle_sort(long[] a) {\n\t\t// shandom_ruffle\n\t\tRandom r=new Random();\n\t\tint n=a.length;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint oi=r.nextInt(i);\n\t\t\tlong temp=a[i];\n\t\t\ta[i]=a[oi];\n\t\t\ta[oi]=temp;\n\t\t}\n \n\t\t// sort\n\t\tArrays.sort(a);\n\t}\n    //Credits to SecondThread(https://codeforces.com/profile/SecondThread) for this tempelate.\n    static class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n    \n    \n}"
        },
        {
            "language": 3,
            "solution": "\"\"\"This code was written by\nRussell Emerine - linguist,\nmathematician, coder,\nmusician, and metalhead.\"\"\"\nn, k = map(int, input().split())\ndsu = [-1 for i in range(n)]\nfor i in range(n - 1):\n  u, v, x = map(int, input().split())\n  u -= 1; v -= 1;\n  if x == 0:\n    upath, vpath = [], []\n    while dsu[u] >= 0:\n      upath.append(u)\n      u = dsu[u]\n    while dsu[v] >= 0:\n      vpath.append(v)\n      v = dsu[v]\n    if u == v: lol = 0\n    elif -dsu[u] > -dsu[v]:\n      vpath.append(v)\n      dsu[u] += dsu[v]\n      v = u\n    else:\n      upath.append(u)\n      dsu[v] += dsu[u]\n      u = v\n    for x in upath: dsu[x] = u\n    for x in vpath: dsu[x] = v\nsum = n ** k\nfor a in dsu:\n  if a < 0:\n    sum -= (-a) ** k\nprint(sum % 1000000007)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n            new Solve().solve();\n    }\n}\nclass Solve{\n    static ArrayList<Integer>[] graph = new ArrayList[200005];\n    static boolean[] visited = new boolean[200005];\n    static int size=0;\n    static long modl = 1000000007;\n    public void solve(){\n        FastReader in = new FastReader(System.in);\n        FastWriter out = new FastWriter(System.out);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        for(int i=0;i<n+5;i++)\n            graph[i] = new ArrayList<>();\n        for(int i=1;i<n;i++){\n            int u = in.nextInt();\n            int v = in.nextInt();\n            int c = in.nextInt();\n            if(c==0){\n                graph[u].add(v);\n                graph[v].add(u);\n            }\n        }\n        long ans=power(n,k,modl);\n        long sum=0;\n        for(int i=1;i<=n;i++)\n            if(!visited[i]){\n                size=0;\n                dfs(i);\n                sum = (sum + power(size,k,modl) ) % modl;\n            }\n        out.print((ans-sum+modl)%modl);\n    }\n    static public void dfs(int start){\n        size++;\n        visited[start]=true;\n        for(int i:graph[start])\n            if(!visited[i])\n                dfs(i);\n    }\n\n    public long power(long a,long b,long mod){\n        long res=1;\n        while(b>0){\n            if(b%2==1)\n                res=(res*a)%mod;\n            a=(a*a)%mod;\n            b>>=1;\n        }\n        return res;\n    }\n    private static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E') {\n                    return res * Math.pow(10, nextInt());\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E') {\n                        return res * Math.pow(10, nextInt());\n                    }\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return nextString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    private static class FastWriter {\n        private final PrintWriter writer;\n\n        public FastWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public FastWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void printt(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n            writer.flush();\n        }\n\n        public void println(Object... objects) {\n            printt(objects);\n            writer.println();\n            writer.flush();\n        }\n\n        public void print(Object... objects) {\n            printt(objects);\n            writer.flush();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int ch;\nvector<long long int> v[200000];\nbool vis[200000];\nvoid dfs(long long int s) {\n  vis[s] = 1;\n  ch++;\n  for (long long int i = 0; i < v[s].size(); i++) {\n    if (vis[v[s][i]] == false) dfs(v[s][i]);\n  }\n}\nlong long int N = 1000000007;\nlong long int power(long long int x, long long int y) {\n  long long int res = 1;\n  x = x % N;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % N;\n    y = y / 2;\n    x = (x * x) % N;\n  }\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int n, k;\n  cin >> n >> k;\n  for (long long int i = 0; i < n - 1; i++) {\n    long long int x, y, w;\n    cin >> x >> y >> w;\n    x--;\n    y--;\n    if (w == 0) {\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n  }\n  long long int ans = power(n, k);\n  for (long long int i = 0; i < n; i++) {\n    if (vis[i] == false) {\n      ch = 0;\n      dfs(i);\n      ans = (ans % N - power(ch, k) % N + N) % N;\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nimport random\nimport sys\nfrom collections import defaultdict as dd\nmod = 7 + 10 ** 9\ncol = dd(int)\ng = dd(list)\nn, k = [int(i) for i in input().split()]\n\ndef bfs(s):\n    c = 1\n    q = [s]\n    vis[s] = 1\n    while(q):\n        cur = q.pop(-1)\n        for i in g[cur]:\n            if vis[i] == 0:\n                c += 1\n                q.append(i)\n                vis[i] = 1\n    return c\n\n\nfor _ in range(n - 1):\n    u, v, c = [int(i) for i in input().split()]\n    if c == 0:\n        g[u].append(v)\n        g[v].append(u)\nans = pow(n, k, mod)\nvis = [0] * (n + 1)\nfor i in range(1, n + 1):\n    if vis[i] == 0:\n        cn = bfs(i)\n        ans = (ans - pow(cn, k, mod))%mod\nprint(ans % mod)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint pre[100010];\nconst int mod = 1000000007;\nlong long f(long long a, long long n) {\n  long long sum = 1;\n  while (n) {\n    if (n & 1) sum = (sum * a) % mod;\n    a = (a * a) % mod;\n    n >>= 1;\n  }\n  return sum;\n}\nint Find(int x) {\n  if (x == pre[x])\n    return x;\n  else\n    return pre[x] = Find(pre[x]);\n}\nvoid Combine(int x, int y) {\n  int fx = Find(x);\n  int fy = Find(y);\n  pre[fx] = fy;\n}\nint main() {\n  int n, k, u, v, w;\n  long long t[100010];\n  memset(t, 0, sizeof(t));\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 1; i <= n; i++) pre[i] = i;\n  for (int i = 1; i <= n - 1; i++) {\n    scanf(\"%d %d %d\", &u, &v, &w);\n    if (!w) Combine(u, v);\n  }\n  for (int i = 1; i <= n; i++) t[Find(i)]++;\n  long long ans = f(n, k);\n  for (int i = 1; i <= n; i++) {\n    if (t[i]) {\n      ans -= f(t[i], k);\n      ans = (ans + mod) % mod;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Solution\n{\n    static ArrayList<Integer> adj[];\n    static boolean visited[];\n    static int N,K;\n    static int mod=(int)1e9+7;\n    public static void main(String ag[])\n    {\n        Scanner sc=new Scanner(System.in);\n        int i,j,k;\n        N=sc.nextInt();\n        K=sc.nextInt();\n        \n        visited=new boolean[N+1];\n        adj=new ArrayList[N+1];\n        for(i=0;i<=N;i++)\n        adj[i]=new ArrayList<>();\n        \n        for(i=1;i<N;i++)\n        {\n            int a=sc.nextInt();\n            int b=sc.nextInt();\n            int c=sc.nextInt();\n            \n            if(c==0)\n            {\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n        }\n        \n        long total=power(N,K);\n        for(i=1;i<=N;i++)\n        {\n            if(!visited[i])\n            {\n                total=(total%mod-power(DFS(i),K)+mod)%mod;\n            }\n        }\n        System.out.println(total);\n    }\n    public static long power(long a,long b)\n    {\n        long res=1L;\n        while(b>0)\n        {\n            if((b&1)==1)\n            res=(res%mod*a%mod)%mod;\n            a=(a%mod*a%mod)%mod;\n            b=b>>1;\n        }\n        return res;\n    }\n    public static int DFS(int node)\n    {\n        visited[node]=true;\n        int cnt=1;\n        Iterator<Integer> itr=adj[node].iterator();\n        while(itr.hasNext())\n        {\n            int next=itr.next();\n            if(!visited[next])\n            {\n                cnt+=DFS(next);\n            }\n        }\n        return cnt;\n    }\n    \n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class C{\n\t// ------------------------\n\tstatic HashMap<Integer,HashSet<Integer>>tree=new HashMap<Integer,HashSet<Integer>>();\n\tstatic boolean[] used;\n\tstatic final long MOD=1000000007;\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\t\t// ------------------------\n\t\tint n=sc.nextInt(),k=sc.nextInt();\n\t\tfor(int i=0;i<n;i++)\n\t\t\ttree.put(i,new HashSet<Integer>());\n\t\tused=new boolean[n];\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint u=sc.nextInt()-1,v=sc.nextInt()-1,x=sc.nextInt();\n\t\t\tif(x==0){\n\t\t\t\ttree.get(u).add(v);\n\t\t\t\ttree.get(v).add(u);\n\t\t\t}\n\t\t}\n\t\tlong bad=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(!used[i])\n\t\t\t\tbad+=pow(dfs(i),k);\n\t\tlong ans=pow(n,k)-bad;\n\t\twhile(ans<0)\n\t\t\tans+=MOD;\n\t\tSystem.out.println(ans%MOD);\n\t\t// ------------------------\n\t\tout.close();\n\t}\n\t//------------------------\n\tprivate static long pow(long x,long p){\n\t\tif(p==0)\n\t\t\treturn 1;\n\t\tlong a=pow(x,p/2);\n\t\treturn (((a*a)%MOD)*(p%2==1?x:1))%MOD;\n\t}\n\tprivate static long dfs(int i){\n\t\tused[i]=true;\n\t\tint ans=1;\n\t\tfor(int j:tree.get(i))\n\t\t\tif(!used[j])\n\t\t\t\tans+=dfs(j);\n\t\treturn ans;\n\t}\n\tpublic static PrintWriter out;\n\tpublic static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\nn,k=map(int,input().split())\nEDGE=[list(map(int,input().split())) for i in range(n-1)]\nmod=10**9+7\n\nGroup=[i for i in range(n+1)]\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\nfor x,y,c in EDGE:\n    if c==0:\n        Union(x,y)\n\nG=[find(i) for i in range(1,n+1)]\n\nfrom collections import Counter\ncounter=Counter(G)\n\nANS=0\nfor j in counter.values():\n    ANS=(ANS+pow(j,k,mod))%mod\n\nprint((pow(n,k,mod)-ANS)%mod)\n"
        },
        {
            "language": 3,
            "solution": "def get(x, p):\n    v = x\n    while p[v] != v:\n        v = p[v]\n    while x != v:\n        x, p[x] = p[x], v\n    return v\nn, k = map(int, input().split())\np = [0] * n\nsz = [1] * n\nfor i in range(n):\n    p[i] = i\nfor i in range(n-1):\n    x, y, z = map(int, input().split())\n    x-=1\n    y-=1\n    if z == 0:\n        x = get(x, p)\n        y = get(y, p)\n        sz[x] += sz[y]\n        p[y] = x\nmod = 10**9 + 7\nans = pow(n, k, mod) \n\nfor i in range(n):\n    if p[i] == i:\n        ans = (ans - pow(sz[i], k, mod)) % mod\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "from __future__ import division, print_function\nimport sys\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\nimport os, sys, bisect, copy\nfrom collections import defaultdict, Counter, deque\n#from functools import lru_cache   #use @lru_cache(None)\nif os.path.exists('in.txt'): sys.stdin=open('in.txt','r')\nif os.path.exists('out.txt'): sys.stdout=open('out.txt', 'w')\n#\ndef input(): return sys.stdin.readline()\ndef mapi(arg=0): return map(int if arg==0 else str,input().split())\n#------------------------------------------------------------------\n\nn,k = mapi()\n\nsize =[1]*(n+1)\npar = [i for i in range(n+1)]\n\ndef find(x):\n    if par[x]==x:\n        return x\n    par[x] = find(par[x])\n    return par[x]\n\ndef union(a,b):\n    if a==b:\n        return\n    if find(a)==find(b):\n        return\n    a = find(a)\n    b = find(b)\n    if size[a]>size[b]:\n        a,b = b,a\n    size[b]+=size[a]\n    par[a] = b\n\nfor i in range(n-1):\n    a,b,x = mapi()\n    if x==0:\n        union(a,b)\nmod = int(1e9+7)\nres = pow(n,k,mod)\nfor i in range(1,n+1):\n    if find(i)==i:\n        res= (res-pow((size[i]),k,mod)+mod)%mod\n        #res-=pow((size[i]),k,mod)\n        #print(size[i],i)\nprint(res)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class C {\n\n    static long mod = (long) (1e9+7);\n    public static void main(String args[]) throws Exception {\n        int n = scn.nextInt();\n        int k = scn.nextInt();\n        ArrayList<Integer>[] g = new ArrayList[n];\n        for(int i=0; i<n; i++) g[i] = new ArrayList<>();\n        int[] arr = new int[n];\n        Arrays.fill(arr,Integer.MAX_VALUE);\n        for(int i=0; i<n-1; i++){\n            int u = scn.nextInt()-1;\n            int v = scn.nextInt()-1;\n            int w = scn.nextInt();\n            if(w == 1){\n                continue;\n            }\n            g[u].add(v);\n            g[v].add(u);\n        }\n        long ans = modPow(n,k,mod);\n        boolean[] vis= new boolean[n];\n        for(int i=0; i<n; i++){\n            if(!vis[i]){\n                long count = dfs(g,i,vis);\n                long val = modPow(count, k, mod);\n                ans = (ans - val)%mod;\n                ans = (ans+mod)%mod;\n            }\n        }\n        out.println(ans);\n        out.close();\n    }\n\n    private static long dfs(ArrayList<Integer>[] g, int idx, boolean[] vis) {\n        vis[idx] = true;\n        long count = 1;\n        for(int u:g[idx]){\n            if(!vis[u]){\n                count += dfs(g,u,vis);\n            }\n        }\n        return count;\n    }\n\n    static long modPow(long a, long x, long p) {\n        long res = 1;\n        while(x > 0) {\n            if( x % 2 != 0) {\n                res = (res * a) % p;\n            }\n            a = (a * a) % p;\n            x /= 2;\n        }\n        return res;\n    }\n\n    static class Pair {\n        int x, y;\n        Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        @Override\n        public String toString() {\n            return this.x + \" [\" + this.y + \"]\";\n        }\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        public int nextInt() {\n            int c = read();\n\n            while (isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static InputReader scn = new InputReader(System.in);\n    public static PrintWriter out = new PrintWriter(System.out);\n}"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\n\npublic class CF {\n\tprivate static FS sc = new FS();\n\t\n\tprivate static class FS {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\t\t\t\t               \n\t            } catch (IOException e) {}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\t\n\tprivate static class extra {\n\t\t\n\t\tstatic int[] intArr(int size) {\n\t\t\tint[] a = new int[size];\n\t\t\tfor(int i = 0; i < size; i++) a[i] = sc.nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tstatic long[] longArr(int size) {\n\t\t\tlong[] a = new long[size];\n\t\t\tfor(int i = 0; i < size; i++) a[i] = sc.nextLong();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tstatic long intSum(int[] a) {\n\t\t\tlong sum = 0; \n\t\t\tfor(int i = 0; i < a.length; i++) {\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tstatic long longSum(long[] a) {\n\t\t\tlong sum = 0; \n\t\t\tfor(int i = 0; i < a.length; i++) {\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tstatic LinkedList[] graphD(int vertices, int edges) {\n\t\t\tLinkedList<Integer>[] temp = new LinkedList[vertices+1];\n\t\t\tfor(int i = 0; i <= vertices; i++) temp[i] = new LinkedList<>();\n\t\t\tfor(int i = 0; i < edges; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\ttemp[x].add(y);\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n\t\t\n\t\tstatic LinkedList[] graphUD(int vertices, int edges) {\n\t\t\tLinkedList<Integer>[] temp = new LinkedList[vertices+1];\n\t\t\tfor(int i = 0; i <= vertices; i++) temp[i] = new LinkedList<>();\n\t\t\tfor(int i = 0; i < edges; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\ttemp[x].add(y);\n\t\t\t\ttemp[y].add(x);\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n\t\t\n\t\tstatic void printG(LinkedList[] temp) {\n\t\t\tfor(LinkedList<Integer> aa:temp) System.out.println(aa);\n\t\t}\n\t\t\n\t\tstatic long cal(long val, long pow) {\n\t\t\tif(pow == 0) return 1;\n\t\t\tlong res = cal(val, pow/2);\n\t\t\t\n\t\t\tlong ret = (res*res)%mod;\n\t\t\tif(pow%2 == 0) return ret;\n\t\t\treturn (val*ret)%mod;\n\t\t}\n\t\t\n\t\tstatic long gcd(long a, long b) { return b == 0 ? a:gcd(b, a%b); }\n\t\t\n\t}\n\t\n\tstatic int mod = (int) 1e9 + 7;\n\tstatic int max = (int) 1e5 + 5;\n\tstatic LinkedList<Integer>[] temp;\n\tstatic long ans;\n\t\n\tpublic static void main(String[] args) {\n//\t\tint t = sc.nextInt();\n\t\tint t = 1;\n\t\tStringBuilder ret = new StringBuilder();\n\t\twhile(t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\ttemp = new LinkedList[n+1];\n\t\t\tfor(int i = 0; i <= n; i++) temp[i] = new LinkedList<>();\n\t\t\tfor(int i = 1; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint col = sc.nextInt();\n\t\t\t\tif(col == 0) {\n\t\t\t\t\ttemp[a].add(b);\n\t\t\t\t\ttemp[b].add(a);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong fin = 0;\n\t\t\tboolean[] vis = new boolean[n+1];\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\tif(!vis[i]) {\n\t\t\t\t\tans = 0;\n\t\t\t\t\tdfs(i, vis);\n\t\t\t\t\tfin += extra.cal(ans, m);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin %= mod;\n\t\t\tfin = (extra.cal(n, m) - fin + mod)%mod;\n\t\t\tret.append(fin + \"\\n\");\n \t\t}\n\t\tSystem.out.println(ret);\t\n\t}\n\t\n\tstatic void dfs(int s, boolean[] vis) {\n\t\tvis[s] = true;\n\t\tans++;\n\t\tfor(int aa:temp[s]) {\n\t\t\tif(!vis[aa]) dfs(aa, vis);\n\t\t}\n\t}\n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1e9 + 7;\nconst long long mxn = 110000;\nvector<pair<long long, long long>> adj[mxn];\nbool vis[mxn];\nlong long dfs(long long s, long long p) {\n  vis[s] = 1;\n  long long ret = 1;\n  for (auto it : adj[s])\n    if (it.first != p && it.second == 0) ret += dfs(it.first, s);\n  return ret;\n}\nlong long po(long long a, long long y) {\n  long long r = 1;\n  while (y != 0) {\n    if (y & 1) {\n      r *= a;\n      r %= mod;\n    }\n    y /= 2;\n    a *= a;\n    a %= mod;\n  }\n  return r;\n}\nvoid solve() {\n  long long n, k;\n  cin >> n >> k;\n  for (long long i = 0; i < (long long)n - 1; ++i) {\n    long long u, v, w;\n    cin >> u >> v >> w;\n    --u;\n    --v;\n    adj[u].push_back({v, w});\n    adj[v].push_back({u, w});\n  }\n  vector<long long> vt;\n  for (long long i = 0; i < (long long)n; ++i)\n    if (!vis[i]) {\n      long long pk = dfs(i, -1);\n      vt.push_back(pk);\n    }\n  long long res = po(n, k);\n  for (auto it : vt) res -= po(it, k);\n  res %= mod;\n  if (res < 0) res += mod;\n  cout << res << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  srand(time(0));\n  long long t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> graph;\nvector<bool> visited;\nconst int mod = 1000000007;\nlong long myPow(long long x, int p) {\n  long long result = 1;\n  while (true) {\n    if (p & 1) {\n      result = result * x % mod;\n    }\n    if (!p) break;\n    p = p >> 1;\n    x = x * x % mod;\n  }\n  return result;\n}\nvector<int> f(int n) {\n  vector<int> result;\n  for (int i = 0; i < n; i++) {\n    if (!visited[i]) {\n      int cnt = 0;\n      visited[i] = true;\n      queue<int> q;\n      q.push(i);\n      while (!q.empty()) {\n        int t = q.front();\n        q.pop();\n        cnt++;\n        for (int j = 0; j != graph[t].size(); j++) {\n          if (!visited[graph[t][j]]) {\n            visited[graph[t][j]] = true;\n            q.push(graph[t][j]);\n          }\n        }\n      }\n      result.push_back(cnt);\n    }\n  }\n  return result;\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  graph.resize(n);\n  visited.resize(n);\n  for (int i = 0; i < n; i++) {\n    visited[i] = false;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    if (x == 0) {\n      graph[u - 1].push_back(v - 1);\n      graph[v - 1].push_back(u - 1);\n    }\n  }\n  vector<int> v = f(n);\n  long long tmp = 0;\n  for (int i = 0; i != v.size(); i++) {\n    tmp = (tmp + myPow(v[i], k)) % mod;\n  }\n  long long result = myPow(n, k) - tmp;\n  cout << (result + mod) % mod << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n\n\n        List<List<Integer>> graph = new ArrayList<>();\n        for(int i = 0; i<n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for(int i = 0; i<n-1; i++) {\n            int i1 = sc.nextInt();\n            int i2 = sc.nextInt();\n            int c = sc.nextInt();\n            if(c == 0) {\n                graph.get(i1-1).add(i2-1);\n                graph.get(i2-1).add(i1-1);\n            }\n        }\n\n        boolean[] visited = new boolean[n];\n        for(int i = 0; i<n; i++) {\n            visited[i] = false;\n        }\n\n        Long tot_count = power(n, k, 1000000007);\n\n        for(int i = 0; i<n; i++) {\n            int count = 0;\n            if(visited[i] == false) {\n                count = dfs(graph, visited, i);\n            }\n            tot_count -= power(count, k, 1000000007);\n            if(tot_count < 0) {\n                tot_count += 1000000007;\n            }\n        }\n        System.out.println(tot_count % 1000000007);\n\n    }\n\n    private static int dfs(List<List<Integer>> graph, boolean[] visited, int i) {\n\n        int count = 1;\n        visited[i] = true;\n\n        for(int node : graph.get(i)) {\n            if(visited[node] == false) {\n                visited[node] = true;\n                count += dfs(graph, visited, node);\n            }\n        }\n\n        return count;\n    }\n\n    static Long power(int x,  int y, int p)\n    {\n//        System.out.println(x + \" \" + y);\n        Long res = 1L;      // Initialize result\n        x = x % p;  // Update x if it is more than or\n        // equal to p\n\n        while (y > 0)\n        {\n            res = (res*x) % p;\n            if(res < 0) {\n                System.out.println(x + \" \" + y  + \" \" + res);\n            }\n            // y must be even now\n            y = y-1; // y = y/2\n        }\n        return res;\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map.Entry;\n\n\n\npublic class P1139C {\n\n//\tstatic Scanner in;\n\t\n\tstatic int n, k;\n\tstatic HashMap<Integer, ArrayList<Edge>> g;\n\tstatic boolean[] marked;\n\tstatic int[] id;\n\t\n\tpublic static void main(String[] args) {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\tlong mod = (long)1e9+7;\n\t\t\n\t\tn = in.nextInt();\n\t\tk = in.nextInt();\n\n\t\tmarked = new boolean[n];\n\t\tid = new int[n];\n\t\t\n\t\tg = new HashMap<>();\n\t\t\n\t\tfor(int i=0; i<n; i++) g.put(i, new ArrayList<Edge>());\n\t\t\n\t\tint cc=0;\n\t\t\n\t\tfor(int i=0; i<n-1; i++) {\n\t\t\tint u = in.nextInt()-1;\n\t\t\tint v = in.nextInt()-1;\n\t\t\tboolean c = (in.nextInt()==1?true:false);\n\t\t\t\n\t\t\tg.get(u).add(new Edge(v, c));\n\t\t\tg.get(v).add(new Edge(u, c));\n\t\t}\n\t\t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tdfs(i, cc);\n\t\t\t\tcc++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong sum=0;\n\t\t\n\t\tHashMap<Integer, Integer> noOfCC = new HashMap<>();\n\t\t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\ttry {\n\t\t\t\tnoOfCC.put(id[i], noOfCC.get(id[i])+1);\n\t\t\t} catch(Exception e) {\n\t\t\t\tnoOfCC.put(id[i], 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Entry e: noOfCC.entrySet()) {\n\t\t\t\n\t\t\tsum=(sum+power((Integer)e.getValue(), k, (long)1e9+7))%mod;\n\t\t}\n\t\t\n\t\tsum=(power(n, k, (long)1e9+7)-sum+(long)1e9+7)%((long)1e9+7);\n\t\t\n\t\tw.write(\"\"+sum+\"\\n\");\n\t\tw.close();\n\n\t}\n\t\n\tpublic static void dfs(int v, int cc) {\n\t\tmarked[v]=true;\n\t\tid[v]=cc;\n\t\t\n\t\t\n\t\tfor(Edge e: g.get(v)) {\n\t\t\tif (!marked[e.v] && !e.c) {\n\t\t\t\tdfs(e.v, cc);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge{\n\t\tint v;\n\t\tboolean c;\n\t\t\n\t\tpublic Edge(int v, boolean c) {\n\t\t\tthis.v=v;\n\t\t\tthis.c=c;\n\t\t}\n\t\t\n\t}\n\t\n\t static long power(long x, long y, long p) \n\t    { \n\t        // Initialize result \n\t        long res = 1;      \n\t         \n\t        // Update x if it is more   \n\t        // than or equal to p \n\t        x = x % p;  \n\t      \n\t        while (y > 0) \n\t        { \n\t            // If y is odd, multiply x \n\t            // with result \n\t            if((y & 1)==1) \n\t                res = (res * x) % p; \n\t      \n\t            // y must be even now \n\t            // y = y / 2 \n\t            y = y >> 1;  \n\t            x = (x * x) % p;  \n\t        } \n\t        return res; \n\t    } \n\t \n\t static class InputReader {\n\n\t\t\tprivate final InputStream stream;\n\t\t\tprivate final byte[] buf = new byte[8192];\n\t\t\tprivate int curChar, snumChars;\n\n\t\t\tpublic InputReader(InputStream st) {\n\t\t\t\tthis.stream = st;\n\t\t\t}\n\n\t\t\tpublic int read() {\n\t\t\t\tif (snumChars == -1)\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tif (curChar >= snumChars) {\n\t\t\t\t\tcurChar = 0;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t}\n\t\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn buf[curChar++];\n\t\t\t}\n\n\t\t\tpublic int nextInt() {\n\t\t\t\tint c = read();\n\t\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t\tint sgn = 1;\n\t\t\t\tif (c == '-') {\n\t\t\t\t\tsgn = -1;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = read();\n\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t\t}\n\n\t\t\tpublic long nextLong() {\n\t\t\t\tint c = read();\n\t\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t\tint sgn = 1;\n\t\t\t\tif (c == '-') {\n\t\t\t\t\tsgn = -1;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t\tlong res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = read();\n\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t\t}\n\n\t\t\tpublic int[] nextIntArray(int n) {\n\t\t\t\tint a[] = new int[n];\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\ta[i] = nextInt();\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tpublic String readString() {\n\t\t\t\tint c = read();\n\t\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\tc = read();\n\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\treturn res.toString();\n\t\t\t}\n\n\t\t\tpublic String nextLine() {\n\t\t\t\tint c = read();\n\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\tc = read();\n\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\tc = read();\n\t\t\t\t} while (!isEndOfLine(c));\n\t\t\t\treturn res.toString();\n\t\t\t}\n\n\t\t\tpublic boolean isSpaceChar(int c) {\n\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t}\n\n\t\t\tprivate boolean isEndOfLine(int c) {\n\t\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t\t}\n\n\t\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author dmytro.prytula prituladima@gmail.com\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CDerevoIRebra solver = new CDerevoIRebra();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CDerevoIRebra {\n        int n;\n        int k;\n        long ans;\n        long MOD = (long) 1e9 + 7;\n        int[][] tree;\n        Map<Integer, Set<Integer>> g;\n        Set<Integer> used = new HashSet<>();\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.nextInt();\n            k = in.nextInt();\n            tree = new int[n - 1][3];\n            g = new HashMap<>();\n            for (int i = 1; i <= n; i++) {\n                g.put(i, new HashSet<>());//try 1\n            }\n            for (int i = 0; i < n - 1; i++) {\n                tree[i][0] = in.nextInt();\n                tree[i][1] = in.nextInt();\n                tree[i][2] = in.nextInt();\n                if (tree[i][2] == 0) {\n                    g.get(tree[i][0]).add(tree[i][1]);\n                    g.get(tree[i][1]).add(tree[i][0]);\n                }\n            }\n            List<Integer> amounts = new ArrayList<>();\n            for (int i = 0; i < n - 1; i++) {\n//            if (tree[i][2] == 1) {\n                if (!used.contains(tree[i][0]))\n                    amounts.add(dfs(tree[i][0]));\n                if (!used.contains(tree[i][1]))\n                    amounts.add(dfs(tree[i][1]));\n//            }\n            }\n\n//        System.out.println(amounts);\n\n            ans = 0;\n            ans += IntegerUtils.power(n, k, MOD);\n\n            for (Integer integer : amounts) {\n                ans -= IntegerUtils.power(integer, k, MOD);\n                ans = IntegerUtils.trueMod(ans, MOD);\n            }\n\n            out.printLine(ans);\n        }\n\n        private int dfs(int from) {\n            used.add(from);\n            int am = 1;\n            for (int to : g.get(from))\n                if (!used.contains(to)) {\n                    am += dfs(to);\n                }\n            return am;\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static long trueMod(long a, long b) {\n            a %= b;\n            a += b;\n            a %= b;\n            return a;\n        }\n\n        public static long power(long base, long exponent, long mod) {\n            if (base >= mod) {\n                base %= mod;\n            }\n            if (exponent == 0) {\n                return 1 % mod;\n            }\n            long result = power(base, exponent >> 1, mod);\n            result = result * result % mod;\n            if ((exponent & 1) != 0) {\n                result = result * base % mod;\n            }\n            return result;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        private static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\nsys.setrecursionlimit(10 ** 9)\n\n\ndef find(v):\n    if parent[v] == v:\n        return v\n    parent[v] = find(parent[v])\n    return parent[v]\n\n\ndef union(u, v):\n    root_u, root_v = find(u), find(v)\n    if cnt[root_v] > cnt[root_u]:\n        root_u, root_v = root_v, root_u\n    parent[root_v] = root_u\n    cnt[root_u] += cnt[root_v]\n\n\nn, k = map(int, input().split())\nparent = [v for v in range(n + 1)]\ncnt = [1 for _ in range(n + 1)]\nfor _ in range(1, n):\n    u, v, x = map(int, input().split())\n    if x == 1:\n        continue\n    union(u, v)\nmod = 10 ** 9 + 7\nanswer = (n ** k) % mod\nfor v in range(1, n + 1):\n    if parent[v] == v:\n        val = (cnt[v] ** k) % mod\n        answer = (answer - val) % mod\nprint(answer)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> graph[100005];\nbool visited[100005];\nlong long pow1(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % 1000000007;\n    b /= 2;\n    a = (a * a) % 1000000007;\n  }\n  return ans;\n}\nvoid addedge(int u, int v) {\n  graph[u].push_back(v);\n  graph[v].push_back(u);\n}\nvoid dfs(int start, long long &count) {\n  count++;\n  visited[start] = true;\n  for (int i = 0; i < graph[start].size(); i++) {\n    if (!visited[graph[start][i]]) {\n      dfs(graph[start][i], count);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int a, b, p;\n    cin >> a >> b >> p;\n    if (p == 0) {\n      addedge(a - 1, b - 1);\n    }\n  }\n  long long ans = pow1(n, k);\n  for (int i = 0; i < n; i++) {\n    if (visited[i]) {\n      continue;\n    }\n    long long count = 0;\n    dfs(i, count);\n    ans -= pow1(count, k);\n    ans += 1000000007;\n    ans %= 1000000007;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1e5 + 2, p = 1e9 + 7;\nint siz[N], f[N];\nint n, m, x, y, z, i, c;\ninline void read(int &x) {\n  c = getchar();\n  while ((c < 48) || (c > 57)) c = getchar();\n  x = c ^ 48;\n  c = getchar();\n  while ((c >= 48) && (c <= 57)) {\n    x = x * 10 + (c ^ 48);\n    c = getchar();\n  }\n}\nint getf(register int x) {\n  if (f[x] == x) return f[x];\n  f[x] = getf(f[x]);\n  siz[f[x]] += siz[x];\n  siz[x] = 0;\n  return f[x];\n}\ninline int ksm(register int x, register int y) {\n  register int r = 1;\n  while (y) {\n    if (y & 1) r = (long long)r * x % p;\n    x = (long long)x * x % p;\n    y >>= 1;\n  }\n  return r;\n}\nint main() {\n  read(n);\n  read(m);\n  for (i = 1; i <= n; i++) siz[f[i] = i] = 1;\n  for (i = 1; i < n; i++) {\n    read(x);\n    read(y);\n    read(z);\n    if (z == 0) {\n      siz[getf(y)] += siz[getf(x)];\n      siz[f[x]] = 0;\n      f[f[x]] = f[y];\n    }\n  }\n  c = ksm(n, m);\n  for (i = 1; i <= n; i++)\n    if (siz[i]) c = (c - ksm(siz[i], m) + p) % p;\n  printf(\"%d\", c);\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nsys.setrecursionlimit(10 ** 9)\n\nMOD = 10 ** 9 + 7\n\ndef bfs(cur):\n    tot = 1\n    v = [[cur], []]\n    used[cur] = True\n    vi = 0\n    while len(v[vi]):\n        for el in v[vi]:\n            for nx in g[el]: \n                if not used[nx]:\n                    v[not vi].append(nx)\n                    used[nx] = True\n                    tot += 1\n        v[vi] = []\n        vi = not vi\n    return tot\n        \n    \n\nn, k = map(int, input().split())\n#n, k = 10 ** 5, 100\ng = [[] for i in range(n)]\nfor i in range(n - 1):\n    u, v, c = map(int, input().split())\n    #u, v, c = i + 1, i + 2, 0\n    u -= 1; v -= 1\n    if c == 0:\n        g[u].append(v)\n        g[v].append(u)\n\nused = [False] * n\nbad = 0\nfor i in range(n):\n    if not used[i]:\n        cur = bfs(i)\n        bad += cur ** k\ngood = n ** k - bad\n\nprint(good % MOD)\n        \n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author El-Bishoy\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D2C1139 solver = new D2C1139();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D2C1139 {\n        int mod = (int) 1e9 + 7;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt(), k = in.nextInt();\n\n            int nn = n;\n\n\n            GraphUtils.DiGraph diGraph = new GraphUtils.DiGraph(n);\n            while (nn-- > 1) {\n                int u = in.nextInt() - 1, v = in.nextInt() - 1, color = in.nextInt();\n                if (color != 1)\n                    diGraph.addEdge(u, v);\n            }\n\n            int all = MathUtils.Mathematics.pow(n, k, mod);\n            for (int i = 0; i < n; i++) {\n                int cnt = dfs(diGraph, i, -1);\n                all = MathUtils.Mathematics.mod(all - MathUtils.Mathematics.pow(cnt, k, mod), mod);\n\n            }\n\n\n            out.println(all);\n        }\n\n        int dfs(GraphUtils.DiGraph G, int v, int parent) {\n\n            if (G.visited[v]) return 0;\n//        if (parent != -1)\n//            if (from[v][parent] == 1 || from[parent][v] == 1)\n//                return 0;\n\n            G.visited[v] = true;\n            int count = 1;\n            for (int w : G.adj(v)) {\n                count += dfs(G, w, v);\n            }\n\n            return count;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class MathUtils {\n        public static class Mathematics {\n            public static int pow(int x, int n, int mod) {\n                int bit = 31 - Integer.numberOfLeadingZeros(n);\n                long product = 1;\n                for (; bit >= 0; bit--) {\n                    product = product * product % mod;\n                    if (((1 << bit) & n) != 0) {\n                        product = product * x % mod;\n                    }\n                }\n                return (int) product;\n            }\n\n            public static int mod(int x, int mod) {\n                x %= mod;\n                if (x < 0) {\n                    x += mod;\n                }\n                return x;\n            }\n\n        }\n\n    }\n\n    static class GraphUtils {\n        public static class DiGraph {\n            ArrayList<Integer>[] adj;\n            public boolean[] visited;\n\n            public DiGraph(int n) {\n                adj = new ArrayList[n];\n                for (int i = 0; i < n; i++) {\n                    adj[i] = new ArrayList<>();\n                }\n\n                visited = new boolean[n];\n\n            }\n\n            public void addEdge(int v, int w) {\n                adj[v].add(w);\n                adj[w].add(v);\n            }\n\n            public ArrayList<Integer> adj(int v) {\n                return adj[v];\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n\npublic class C{\n\t\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n\tstatic LinkedList<Integer> ar[];\n\tstatic boolean vis[];\n\tstatic long count;\n\tpublic static void dfs(int i)\n\t{\t\n\t\tcount++;\n\t\tvis[i] = true;\n\t\t\n\t\tfor(int n:ar[i])\n\t\t{\n\t\t\tif(!vis[n])\n\t\t\t{\n\t\t\t\tdfs(n);\n\t\t\t}\n\t\t}\n\t}\n\tstatic long prime = (long) (1e9+7);\n\t\n\tstatic long fast_pow(long a, long b) {\n\t\tif(b == 0)\n\t\t\treturn 1L;\n\n\t\tlong val = fast_pow(a, b / 2);\n\n\t\tif(b % 2 == 0)\n\t\t\treturn val * val % prime;\n\t\telse \n\t\t\treturn val * val % prime * a % prime;\n\t}\n\tpublic static void main(String[] args) \n\t{\n\t\tOutputStream outputStream = System.out;\n        FastReader sc = new FastReader();\n        PrintWriter out = new PrintWriter(outputStream);\n     \n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        ar = new LinkedList[n];\n        for(int i = 0; i <= n-1; i++)\n        {\n        \tar[i] = new LinkedList<>();\n        }\n        for(int i = 0; i < n-1; i++)\n        {\n        \tint s = sc.nextInt();\n        \tint e = sc.nextInt();\n        \tint c = sc.nextInt();\n        \tif(c == 1) continue;\n        \t\n        \tar[s-1].add(e-1);\n        \tar[e-1].add(s-1);\n        }\n        \n        vis = new boolean[n];\n        long tCount = 0;\n        Arrays.fill(vis, false);\n        for(int i = 0; i < n; i++)\n        {\n        \tif(!vis[i])\n        \t{\t\n        \t\tcount = 0;\n        \t\tdfs(i);\n        \t\t//out.println(count);\n        \t\tlong count2 = count;\n        \t\tfor(int j = 1; j < k; j++)\n        \t\t{\n        \t\t\t\n        \t\t\tcount = (long)(count2*count)%prime;\n        \t\t}\n        \t\t//out.println(count);\n        \t\ttCount = (tCount+count)%prime;\n        \t}\n        }\n        /*int minus = 0;\n        for(int i = 0; i < n; i++)\n        {\n        \tif(!vis[i])\n        \t{\t\n        \t\tout.println(i);\n        \t\tminus++;\n        \t}\n        }\n        out.println(\"minus \"+minus);\n        out.println(\"tcount \"+tCount);\n        */\n        long ans = n;\n        for(int i = 1; i < k; i++)\n        {\n        \tans = (long)(n*ans)%prime;\n        }\n        \n        //out.println(\"ans \"+ans);\n        //ans = ans-minus;\n        ans = (long)(ans-tCount+prime)%prime;\n        out.println(ans);\n        out.close();\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "def parent(p,x):\n    if p[x]==x:\n        return x\n    p[x]=parent(p,p[x])\n    return p[x]\n\n\nn,m = map(int,input().split())\np = []\nfor i in range(n):\n    p.append(i)\ns = []\nfor i in range(n):\n    s.append(1)\nfor i in range(n-1):\n    a,b,c = map(int,input().split())\n    if c==0:\n        a-=1\n        b-=1\n        pa = parent(p,a)\n        pb = parent(p,b)\n        if pa==pb:\n            continue\n        else:\n            if s[pa]<s[pb]:\n                p[pa]=pb\n                s[pb]+=s[pa]\n            else:\n                p[pb]=pa\n                s[pa]+=s[pb]\ntemp = 0\nfor i in range(n):\n    if parent(p,i)==i:\n        temp+=s[i]**m\n        temp = temp%1000000007\nprint((n**m-temp+1000000007)%1000000007)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class EdgyTrees {\n\t\n\tstatic int MOD = (int)(1e9 + 7);\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(f.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint k = Integer.parseInt(st.nextToken());\n\t\t\n\t\tArrayList<Edge>[] adj = new ArrayList[n];\n\t\t\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\tadj[i] = new ArrayList<Edge>();\n\t\t}\n\t\tfor(int i = 0; i < n-1; i ++) {\n\t\t\tst = new StringTokenizer(f.readLine());\n\t\t\tint x = Integer.parseInt(st.nextToken()) - 1;\n\t\t\tint y = Integer.parseInt(st.nextToken()) - 1;\n\t\t\tint type = Integer.parseInt(st.nextToken());\n\t\t\t\n\t\t\tadj[x].add(new Edge(y,type));\n\t\t\tadj[y].add(new Edge(x,type));\n\t\t}\n\t\t\n\t\tboolean[] vis = new boolean[n];\n\t\t\n\t\tlong ans = 0;\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\tif(vis[i]) continue;\n\t\t\tvis[i] = true;\n\t\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\t\tq.add(i);\n\t\t\tlong count = 1;\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tint x = q.remove();\n\t\t\t\tfor(Edge e: adj[x]) {\n\t\t\t\t\tif(!vis[e.to] && e.type==0) {\n\t\t\t\t\t\tvis[e.to] = true;\n\t\t\t\t\t\tq.add(e.to);\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = (ans + pow(count,k)) % MOD;\n\t\t}\n\t\t\n\t\tSystem.out.println(((pow(n,k) - ans) % MOD + MOD) % MOD);\n\n\t}\n\t\n\tstatic long pow(long n, int k) {\n\t\tif(k == 0) return 1;\n\t\treturn (n * pow(n,k-1)) % MOD;\n\t}\n\t\n\tstatic class Edge{\n\t\tint to;\n\t\tint type;\n\t\tpublic Edge(int to, int type) {\n\t\t\tthis.to= to;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5, inf = 2e9, mod = 1e9 + 7;\nbool visited[N];\nvector<int> adj[N];\nint nodesum, k, cntr;\nlong long fp(long long base, long long exp) {\n  if (exp == 0) return 1;\n  long long ans = fp(base, exp / 2);\n  ans = (ans * ans) % mod;\n  if (exp % 2 != 0) ans = (ans * (base % mod)) % mod;\n  return ans;\n}\nvoid dfs(int node) {\n  if (visited[node]) return;\n  cntr++;\n  visited[node] = true;\n  for (int child : adj[node]) dfs(child);\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n  cin >> nodesum >> k;\n  for (int i = 0; i < nodesum - 1; i++) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    if (!w) adj[u].push_back(v), adj[v].push_back(u);\n  }\n  long long ans = fp(nodesum, k);\n  for (int i = 1; i <= nodesum; i++) {\n    if (!visited[i]) {\n      cntr = 0;\n      dfs(i);\n      ans = (ans - fp(cntr, k) + mod) % mod;\n    }\n  }\n  cout << ans % mod;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v[100005];\nvoid add_graph(int x, int y) {\n  v[x].push_back(y);\n  v[y].push_back(x);\n}\nbool viz[100005];\nint DFS(int i) {\n  viz[i] = true;\n  int rez = 1;\n  for (auto x : v[i])\n    if (!viz[x]) {\n      rez += DFS(x);\n    }\n  return rez;\n}\nlong long rez;\nconst long long mod = 1e9 + 7;\nlong long powMod(long long a, int b) {\n  if (b == 0) return 1;\n  if (b % 2 == 0) return powMod(a * a % mod, b / 2);\n  return a * powMod(a * a % mod, b / 2) % mod;\n}\nint main() {\n  int n, k, x, y, z;\n  cin >> n >> k;\n  for (int i = 1; i < n; ++i) {\n    cin >> x >> y >> z;\n    if (!z) add_graph(x, y);\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (!viz[i]) {\n      rez = (rez + powMod(DFS(i), k)) % mod;\n    }\n  }\n  cout << (powMod(n, k) + mod - rez) % mod;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\nsys.setrecursionlimit(111111) \nINF=99999999999999999999999999999999\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n \n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n \n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n \n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n \n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n \n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n \n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n \n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n \n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n \n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n \n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n \n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n \n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n \n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n \n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n \n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n \n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n \n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n \n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n \n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n \n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n \n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\ndef main():\n\n    mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    \n    ###CODE\n    tc = 1\n    for _ in range(tc):\n        n,k=ria()\n        graph=[[] for i in range(n+1)]\n        visited=[False]*(n+1)\n        \n        for i in range(n-1):\n            a,b,type=ria()\n            if type==0:\n                graph[a].append(b)\n                graph[b].append(a)\n        \n        def dfs(start):\n            stack = [start]\n            cs=0\n            while stack:\n                start = stack[-1]\n\n                # push unvisited children into stack\n                if not visited[start]:\n                    cs+=1\n                    visited[start] = True\n                    for child in graph[start]:\n                        if not visited[child]:\n                            stack.append(child)\n\n                else:\n                    stack.pop()\n            return cs\n            \n        nk=1\n        for i in range(k):\n            nk=(n*nk)%mod\n                \n        for i in range(1,n+1):\n            if not visited[i]:\n                cs=dfs(i)\n                rem=1\n                for i in range(k):\n                    rem=(cs*rem)%mod\n                nk-=rem\n        print(nk%mod)\n                    \n                    \n                \n                \n                    \n                \n        \n        \n            \n                   \n        \n                    \n\n        \n        \n                \n            \n            \n    \n            \n                        \n        \n    \n\n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    \n"
        },
        {
            "language": 3,
            "solution": "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO in pypy =D /pajenegod\n\nclass FastI:\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream, self.bufflines = BytesIO(), 0\n        def read2buffer(stream):\n            curpos,s = stream.tell(), os.read(fd, buffersize + os.fstat(fd).st_size)\n            return [s, stream.seek(0,2), stream.write(s), stream.seek(curpos)][0]\n        self.read2buffer = lambda: read2buffer(self.stream)\n        self.input = lambda: self.readline().rstrip(b'\\r\\n')\n    \n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read()\n\n    def readline(self):\n        while self.bufflines == 0: \n            s = self.read2buffer()\n            self.bufflines += s.count(b'\\n') + (not s)\n        self.bufflines -= 1\n        return self.stream.readline()\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(fd, stream.getvalue()) + stream.truncate(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\n\n\n################################# Testing filo code\n\ndef readLine():\n    return [int(i) for i in input().split()]\n\ndef deg(x, y):\n    if y == 1:\n        return x\n    res = deg(x, y // 2)\n    res *= res\n    res %= md\n    if y % 2 == 1:\n        res *= x\n        res %= md\n    return res\n\ndef dfs(v):\n    Q = [v]\n    used[v] = True\n    c = 0\n    while Q:\n        v = Q.pop()\n        c += 1\n        for to in g[v]:\n            if not used[to]:\n                used[to] = True\n                Q.append(to)\n    return c\n\nn, m = readLine()\ng = [[] for _ in range(n + 1)]\nmd = 1000000007\n\nfor i in range(n - 1):\n    x, y, t = readLine()\n    if t == 0:\n        g[x].append(y)\n        g[y].append(x)\n\nans = deg(n, m)\n\nused = [False]*(n+1)\nfor i in range(1, n + 1):\n    if used[i] == False:\n        b = dfs(i)\n        ans = ans - deg(b, m)\n        if ans < 0:\n            ans += md\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "import itertools\n\nn, k = list(map(int, input().split()))\n\nclass Vert:\n\n    def __init__(self, i):\n        self.redir = False\n        self.graph = {i}\n    \n    def redirect(self, redir_vert):\n        self.redir_vert = redir_vert\n        self.redir = True\n\nforest = [Vert(i) for i in range(0, n)]\n\ndef nedge(edge):\n    return [edge[0]-1, edge[1]-1, edge[2]]\n\nwhile True:\n    try:\n        # [from, to, color]\n        edge = nedge(list(map(int, input().split())))\n        if edge[2] != 1:\n            vert1 = forest[edge[0]]\n            while vert1.redir:\n                vert1 = vert1.redir_vert\n            \n            vert2 = forest[edge[1]]\n            while vert2.redir:\n                vert2 = vert2.redir_vert\n            \n            vert1.graph |= vert2.graph\n            vert2.redirect(vert1)\n    except EOFError:\n        break\n\n\ntotal_seqs = n ** k\n\nfor vert in forest:\n    if not vert.redir:\n        total_seqs -= (len(vert.graph) ** k)\n\nprint(total_seqs % (10 ** 9 + 7))\n"
        },
        {
            "language": 3,
            "solution": "# Edgy Trees\n\nfrom collections import deque\n\ndef bfs(graph, visited, node):\n    size = 0\n    q = deque()\n    q.appendleft(node)\n    while len(q) > 0:\n        n = q.pop()\n        visited[n] = True\n        size += 1\n        for neighbor in graph[n]:\n            if not visited[neighbor]:\n                q.appendleft(neighbor)\n    return size\n\nn, k = map(int, input().split())\ntotal = n ** k\ngraph = [[] for x in range(n)]\n\nfor i in range(n-1):\n    a, b, c = map(int, input().split())\n    if c == 0:\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n\nvisited = [False for x in range(n)]\nfor i in range(n):\n    if not visited[i]:\n        s = bfs(graph, visited, i)\n        total -= s ** k\n\nprint(total % (10**9 + 7))\n"
        },
        {
            "language": 1,
            "solution": "n, k = map(int, raw_input().split())\nl = [[] for i in range(n + 1)]\nfor i in range(n-1):\n\ta, b, c = map(int, raw_input().split())\n\tif c != 1:\n\t\tl[a].append(b)\n\t\tl[b].append(a)\nMOD = 10**9 + 7\nvis = [0]*(n+1)\nans = pow(n, k, MOD)\nans %= MOD\nfor i in range(1, n + 1):\n\tif vis[i] == 0:\n\t\tsz = 0\n\t\tstack = [i]\n\t\twhile len(stack) > 0:\n\t\t\tnode = stack.pop()\n\t\t\tif vis[node]:\n\t\t\t\tcontinue\n\t\t\tvis[node] = 1\n\t\t\tsz += 1\n\t\t\tfor i in l[node]:\n\t\t\t\tif not vis[i]:\n\t\t\t\t\tstack.append(i)\n\t\tans -= pow(sz, k, MOD)\n\t\tans %= MOD\nprint ans%MOD"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int MOD = 1e9 + 7;\nconst int LIM = 1e5 + 10;\ntypedef struct {\n  int a;\n  bool cor;\n} aresta;\nvector<aresta> adj[LIM];\nint root[LIM];\nlong long int size[LIM];\nint find(int a) {\n  if (root[a] == a) return a;\n  return root[a] = find(root[a]);\n}\nvoid join(int a, int b) {\n  if (size[find(a)] > size[find(b)]) swap(a, b);\n  size[find(b)] += size[find(a)];\n  root[find(a)] = find(b);\n}\nlong long int exp(long long int N, long long int e) {\n  long long int res = 1;\n  while (e) {\n    if (e & 1) res = (res * N) % MOD;\n    N = (N * N) % MOD;\n    e >>= 1;\n  }\n  return res;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int N, K;\n  cin >> N >> K;\n  for (int i = 1; i <= N; i++) {\n    root[i] = i;\n    size[i] = 1;\n  }\n  for (int i = 1; i < N; i++) {\n    int a, b;\n    bool c;\n    cin >> a >> b >> c;\n    if (c == 0) join(a, b);\n  }\n  long long int tot = exp(N, K);\n  for (int i = 1; i <= N; i++) {\n    if (root[i] == i) {\n      tot -= exp(size[i], K);\n      if (tot < 0) tot += MOD;\n    }\n  }\n  cout << tot << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int mod = 1e9 + 7;\nlong long int powmod(long long int a, long long int b) {\n  long long int res = 1;\n  a %= mod;\n  assert(b >= 0);\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a % mod;\n    a = a * a % mod;\n  }\n  return res;\n}\nlong long int gcd(long long int a, long long int b) {\n  return b ? gcd(b, a % b) : a;\n}\nmap<long long int, vector<long long int>> graph;\nbool isVisited[1001000] = {false};\nmap<pair<long long int, long long int>, long long int> couleur;\nvector<long long int> res;\nlong long int r = 0;\nvoid dfs(long long int start) {\n  r++;\n  isVisited[start] = true;\n  vector<long long int>::iterator it = graph[start].begin();\n  for (it; it != graph[start].end(); it++) {\n    if (!isVisited[*it]) {\n      dfs(*it);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n, k;\n  long long int ans;\n  cin >> n >> k;\n  for (long long int i = 0; i < n - 1; i++) {\n    long long int a, b, c;\n    cin >> a >> b >> c;\n    if (c == 0) {\n      graph[a].push_back(b);\n      graph[b].push_back(a);\n    }\n  }\n  ans = powmod(n, k);\n  for (long long int i = 1; i <= n; i++) {\n    if (!isVisited[i]) {\n      r = 0;\n      dfs(i);\n      ans = ans - powmod(r, k);\n      while (ans < 0) ans += mod;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\nint calc(int n, int m) {\n  int ret = 1;\n  for (int i = 0; i < m; ++i) ret = 1LL * ret * n % MOD;\n  return ret;\n}\nint dfs(int u, const vector<vector<int> >& sons, vector<bool>& used) {\n  int ret = 1;\n  used[u] = true;\n  for (int v : sons[u])\n    if (v < 0 && !used[-v]) ret += dfs(-v, sons, used);\n  return ret;\n}\nint getRed(int n, int k, const vector<vector<int> >& sons) {\n  vector<bool> used(n + 1, false);\n  int ret = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (used[i]) continue;\n    int cnt = dfs(i, sons, used);\n    ret = (ret + calc(cnt, k)) % MOD;\n  }\n  return ret;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int> > sons(n + 1, vector<int>());\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    if (c == 0) c = -1;\n    sons[u].push_back(v * c);\n    sons[v].push_back(u * c);\n  }\n  int red = getRed(n, k, sons);\n  int all = 1;\n  for (int i = 0; i < k; ++i) all = 1LL * all * n % MOD;\n  cout << ((all - red) % MOD + MOD) % MOD << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e6 + 1;\nconst long long mod = 1e9 + 7;\nlong long power(long long x, long long n) {\n  long long res = 1;\n  x %= mod;\n  while (n) {\n    if (n & 1) res = (res * x) % mod;\n    x = (x * x) % mod;\n    n >>= 1;\n  }\n  return res;\n}\nvector<vector<long long> > g;\nlong long dfs(long long a, vector<long long> &vis) {\n  long long c = 1;\n  vis[a] = 1;\n  for (auto i : g[a]) {\n    if (vis[i] != 1) c += dfs(i, vis);\n  }\n  return c;\n}\nvoid solve() {\n  long long n = 0, a = 0, b = 0, c = 0, k = 0;\n  cin >> n >> k;\n  g = vector<vector<long long> >(n);\n  long long ans = power(n, k);\n  for (long long i = 0; i < n - 1; i++) {\n    cin >> a >> b >> c, --a, --b;\n    if (c == 0) {\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n  }\n  vector<long long> vis(n);\n  for (long long i = 0; i < n; i++) {\n    if (vis[i] == 0) {\n      long long c = dfs(i, vis);\n      ans = (ans - power(c, k) + mod) % mod;\n    }\n  }\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.*;\nimport static java.lang.Math.*;\n\n\npublic class java2 {\n    static void dfs(int u)\n    {\n        check[u]=1;\n        ++cnt;\n        for(int x:vec[u])\n        {\n            if(check[x]==0) dfs(x);\n        }\n    }\n    static long fastPow(long a,long b)\n    {\n        if(b==0) return 1L;\n        long res=fastPow(a,b/2);\n        if(b%2==0) return res*res%mod;\n        else return res*res%mod*a%mod;\n    }\n    static long mod=(long)1e9+7;\n    static ArrayList<Integer> vec[];\n    static int check[];\n    static long cnt=0;\n    public static void main(String[] args) {\n        Scanner r = new Scanner(System.in);\n        int n=r.nextInt();\n        int k=r.nextInt();\n        vec=new ArrayList[n];\n        for(int i=0;i<n;++i) vec[i]=new ArrayList<>();\n        for(int i=0;i<n-1;++i)\n        {\n            int u=r.nextInt()-1;\n            int v=r.nextInt()-1;\n            int x=r.nextInt();\n            if(x==0)\n            {\n                vec[u].add(v);\n                vec[v].add(u);\n            }\n        }\n        long ans=fastPow(n,k);\n        long res=0;\n        check = new int[n];\n        for(int i=0;i<n;++i)\n        {\n            if(check[i]==0)\n            {\n                cnt=0;\n                dfs(i);\n                res+=fastPow(cnt,k);\n            }\n        }\n        res%=mod;\n        ans=(ans-res+mod)%mod;\n        System.out.println(ans);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "// Created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class C\n{\n    private static final long MOD=1000000007;\n    private static int vis[];\n    private static ArrayList<Pair>[] edge;\n    private static ArrayDeque<Integer> DQ;\n    static class Pair\n    {\n        int a,b;\n        Pair(int a, int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n\n    private static long DFS(int i)\n    {\n        int count=1,v,x;\n        vis[i]=1;\n\n        for(Pair obj:edge[i])\n        {\n            v=obj.a;\n            x=obj.b;\n\n            if(vis[v]==0)\n            {\n                if(x==1)\n                    DQ.add(v);\n                else\n                    count+=DFS(v);\n            }\n        }\n\n        return count;\n    }\n\n    private static long pow(long x, long a)\n    {\n            if(a==0)\n                return 1;\n            long ans=pow(x,a/2);\n\n            ans=(ans*ans)%MOD;\n\n            if((a&1)==1)\n                ans=(ans*x)%MOD;\n\n            return ans%MOD;\n    }\n\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N,k,u,v,x;\n        long count=0,tmp,tmp2,total;\n\n        String s[]=br.readLine().trim().split(\" \");\n        N=Integer.parseInt(s[0]);\n        k=Integer.parseInt(s[1]);\n\n        vis=new int[N+1];\n        edge=new ArrayList[N+1];\n        DQ=new ArrayDeque<>();\n        for(i=0;i<=N;i++)\n            edge[i]=new ArrayList<>();\n\n        total=pow(N,k);\n\n        for(i=1;i<=N-1;i++)\n        {\n            s=br.readLine().trim().split(\" \");\n            u=Integer.parseInt(s[0]);\n            v=Integer.parseInt(s[1]);\n            x=Integer.parseInt(s[2]);\n\n            edge[u].add(new Pair(v,x));\n            edge[v].add(new Pair(u,x));\n        }\n\n        DQ.add(1);\n        while(!DQ.isEmpty())\n        {\n            tmp=DFS(DQ.poll());\n            tmp2=pow(tmp,k);\n            count=(count+tmp2)%MOD;\n        }\n\n        total-=count;\n        while(total<0)\n            total+=MOD;\n\n        System.out.println(total);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class C {\n\n   public static final int MOD = (int) 1e9 + 7;\n   public static void main(String[] args) {\n      Scanner sc = new Scanner(System.in);\n      \n      int n = sc.nextInt();\n      int k = sc.nextInt();\n      \n      Node[] graph = new Node[n];\n      for(int i = 0; i < n; i++) {\n         graph[i] = new Node();\n         graph[i].val = i;\n      }\n      \n      for(int i = 0; i < n - 1; i++) {\n         int a = sc.nextInt() - 1;\n         int b = sc.nextInt() - 1;\n         int color = sc.nextInt();\n         \n         Edge uv = new Edge();\n         uv.u = a;\n         uv.v = b;\n         uv.c = color;\n         graph[a].edges.add(uv);\n         \n         Edge vu = new Edge();\n         vu.u = b;\n         vu.v = a;\n         vu.c = color;\n         graph[b].edges.add(vu);\n      }\n      \n      //math.pow(n,k) % mod\n      long ans = n;\n      for(int i = 0; i < k - 1; i++) {\n         ans *= n;\n         ans %= MOD;\n      }\n      \n      //subtract off [x, x, x]...\n      ans -= n;\n      \n      boolean[] vis = new boolean[n];\n      ArrayList<Integer> comp = new ArrayList<Integer>();\n      //group components by edge color\n      for(int i = 0; i < n; i++) {\n         if(!vis[i]) {\n            ArrayList<Node> red = new ArrayList<Node>();\n            Stack<Node> stack = new Stack<Node>();\n            stack.push(graph[i]);\n            while(!stack.isEmpty()) {\n               Node cur = stack.pop();\n               vis[cur.val] = true;\n               for(Edge e : cur.edges) {\n                  if(e.c == 0 && !vis[e.v]) {\n                     red.add(cur);\n                     stack.push(graph[e.v]);\n                  }\n               }\n            }\n            comp.add(red.size());\n         }\n      }\n      \n      for(int i = 0; i < comp.size(); i++) {\n         long subtract = comp.get(i) + 1;\n         for(int j = 0; j < k - 1; j++) {\n            subtract *= (comp.get(i) + 1);\n            subtract %= MOD;\n         }\n         ans -= subtract;\n         ans %= MOD;\n         ans += comp.get(i) + 1;\n         ans %= MOD;\n      }\n      System.out.println((ans % MOD + MOD) % MOD);\n   }\n}\nclass Node {\n   public int val;\n   public ArrayList<Edge> edges = new ArrayList<Edge>();\n}\nclass Edge {\n   public int u;\n   public int v;\n   public int c;\n}"
        },
        {
            "language": 3,
            "solution": "n, k = [int(i) for i in input().split()]\nadj = [[] for i in range(n+1)]\n\nans = 0\n# no of good paths = all paths - non-good paths\n# = all paths - paths where no blacks\n\npar = [i for i in range(n+1)]\n\ndef find(i):\n    global par\n    if par[i] == i:\n        return i\n    par[i] = find(par[i])\n    return par[i]\n\ndef unite(i, j):\n    global par\n    if find(i) < find(j):\n        i, j = j, i\n    par[find(i)] = find(j)\n\nfor i in range(n-1):\n    u, v, c = [int(i) for i in input().split()]\n    adj[u].append((v,c))\n    adj[v].append((u, c))\n    if c==0:\n        unite(u, v)\n\nsz = [0 for i in range(n+1)]\nfor i in range(1, n+1):\n    sz[find(i)] += 1\ngrps = []\nfor i in range(1, n+1):\n    if find(i) == i:\n        grps.append(i)\n        \nmod = 10**9 + 7\nans += pow(n, k, mod) #n**k\n\nfor i in grps:\n    ans -= pow(sz[i], k, mod) #sz[i]**k\n    ans += mod\nprint(ans%mod)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr long long Mod = 1000000007;\nint U[200001], Z[200001];\nint Ufs(int u) { return U[u] == u ? U[u] : U[u] = Ufs(U[u]); }\nlong long Pow(long long A, int B) {\n  long long R = 1;\n  while (B) {\n    if (B & 1) R = R * A % Mod;\n    A = A * A % Mod;\n    B >>= 1;\n  }\n  return R;\n}\nint main() {\n  int N, K;\n  scanf(\"%d%d\", &N, &K);\n  for (int i = 1; i <= N; ++i) {\n    U[i] = i;\n    Z[i] = 1;\n  }\n  for (int i = 1; i < N; ++i) {\n    int a, b, c;\n    scanf(\"%d%d%d\", &a, &b, &c);\n    if (c) continue;\n    auto ua = Ufs(a);\n    auto ub = Ufs(b);\n    if (Z[ua] < Z[ub]) swap(ua, ub);\n    U[ub] = ua;\n    Z[ua] += Z[ub];\n  }\n  long long Ans = Pow(N, K);\n  for (int i = 1; i <= N; ++i)\n    if (Ufs(i) == i) Ans -= Pow(Z[i], K);\n  printf(\"%lld\\n\", (Ans % Mod + Mod) % Mod);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e5 + 5;\nconst int N = 1000005;\nconst int mod = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nconst long long linf = 0x3f3f3f3f3f3f3f3fLL;\nconst int sINF = 0xcfcfcfcf;\nbool isv[M];\nint cnt[M], n, k, id, ans;\nvector<int> g[M];\nvoid dfs(int x, int id) {\n  cnt[id]++;\n  isv[x] = 1;\n  for (int i = 0; i < g[x].size(); i++) {\n    if (!isv[g[x][i]]) {\n      dfs(g[x][i], id);\n    }\n  }\n}\nlong long quickpow(long long x, long long n) {\n  long long ans = 1;\n  while (n) {\n    if (n & 1) {\n      ans = (ans * x) % mod;\n    }\n    x = (x * x) % mod;\n    n >>= 1;\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n; i++) {\n    int u, v, sta;\n    scanf(\"%d%d%d\", &u, &v, &sta);\n    if (!sta) {\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!isv[i]) dfs(i, id++);\n  }\n  ans = quickpow(n, k);\n  for (int i = 0; i < id; i++) {\n    ans = (ans + mod - quickpow(cnt[i], k)) % mod;\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n \npublic class AiseHi {\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n\n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n\n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n\n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n\n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n\n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n\n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n\tstatic FastReader sc = new FastReader();\n\tstatic int mod = (int)(1e9+7);\n\tpublic static void main (String[] args) {\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = 1;\n//    \tt = sc.nextInt();\n    \twhile(t-->0) {\n    \t\tint n = sc.nextInt();\n    \t\tint k = sc.nextInt();\n    \t\tDSU dsu = new DSU(n+1);\n    \t\tArrays.fill(dsu.par, -1);\n    \t\tfor(int i=1;i<n;i++) {\n    \t\t\tint u = sc.nextInt();\n    \t\t\tint v = sc.nextInt();\n    \t\t\tint x = sc.nextInt();\n    \t\t\tif(x == 0) {\n    \t\t\t\tif(dsu.par[u] == -1) dsu.par[u] = u;\n    \t\t\t\tif(dsu.par[v] == -1) dsu.par[v] = v;\n    \t\t\t\tdsu.join(u, v);\n    \t\t\t}\n    \t\t}\n    \t\tlong total = pow(n,k) % mod;\n//    \t\tout.write(total+\"\\n\");\n    \t\tlong bad = 0;\n//    \t\tfor(int i=1;i<=n;i++)\n//    \t\t\tout.write(dsu.par[i]+\" \"+dsu.size[i]+\"\\n\");\n//    \t\tout.write(\"\\n\");\n    \t\tfor(int i=1;i<=n;i++) {\n    \t\t\tif(dsu.par[i] == -1)\n    \t\t\t\tbad = (bad+1)%mod;\n    \t\t\tif(dsu.par[i] == i)\n    \t\t\t\tbad = (bad%mod + pow(dsu.size[i],k)%mod)%mod;\n    \t\t}\n//    \t\tout.write(bad+\"\\n\");\n    \t\ttotal = (total%mod - bad%mod + mod)%mod;\n    \t\tout.write(total+\"\\n\");\n      \t}\n\t\tout.close();\n\t}\n\tprivate static long pow(long i, long x) {\n\t\tlong ans = 1;\n\t\twhile(x>0) {\n\t\t\tif(x%2==0) {\n\t\t\t\ti = (i%mod *i%mod)%mod;\n\t\t\t\tx = x/2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = (ans%mod * i%mod)%mod;\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t\treturn ans%mod;\n\t}\n\tprivate static void swap(int[] a, int i, int j) {\n\t\tint temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\tstatic long lstbt(long val) {\n\t\tlong msk = val & (val-1);\n\t\treturn (long) (Math.log(val^msk)/Math.log(2));\n\t}\n\tprivate static long sqrt(long x) {\n\t\tlong l = 1,h = x;\n\t\tlong ans = 0;\n\t\twhile(l<=h) {\n\t\t\tlong mid = (l+(h-l)/2);\n\t\t\tif(mid>x/mid) h = mid-1;\n\t\t\telse {\n\t\t\t\tans = mid;\n\t\t\t\tl = mid+1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n//\tstatic boolean prime[] = new boolean[10000001];\n//\tstatic void sieve() {\n//\t\tprime[0] = true;\n//\t\tprime[1] = true;\n//\t\tint max = 10000000;\n//\t\tfor(int i=2;i*i<=max;i++) {\n//\t\t\tif(!prime[i]) {\n//\t\t\t\tfor(int j=i*i;j<=max;j+=i)\n//\t\t\t\t\tprime[j] = true;\n//\t\t\t}\n//\t\t}\n//\t}\n}\nclass DSU {\n\tint par[];\n\tint size[];\n\tDSU(int n) {\n\t\tpar = new int[n];\n\t\tsize = new int[n];\n\t\tArrays.fill(size, 1);\n\t\tfor(int i=0;i<n;i++) par[i] = i;\n\t}\n\tint findPar(int x) {\n\t\tif(x == par[x]) return x;\n\t\t\n\t\treturn par[x] = findPar(par[x]);\n\t}\n\tboolean join(int u,int v) {\n\t\tint fu = findPar(u);\n\t\tint fv = findPar(v);\n\t\tif(fu!=fv) {\n\t\t\tif(size[fu]>=size[fv]) {\n\t\t\t\tpar[fv] = fu;\n\t\t\t\tsize[fu] += size[fv];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpar[fu] = fv;\n\t\t\t\tsize[fv] += size[fu];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse \n\t\t\treturn false;\n\t}\n}\nclass pair implements Comparable<pair>{\n\tint a;\n\tlong b;\n\tpair(int a,long b){\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\t@Override\n\tpublic int compareTo(pair o) {\n\t\tif(this.a!=o.a)\n\t\t\treturn (int) (this.a - o.a);\n\t\telse\n\t\t\treturn (int)(this.b - o.b);\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "def powmod(n, k, m):\n\tif n==1:\n\t\treturn 1\n\texpow = n\n\tfor i in range(1, k):\n\t\texpow = (expow*n % m)\n\treturn expow\n\nn, k = (int(x) for x in input().rstrip().split())\nrededges = {i:[] for i in range(1, n+1)}\nfor i in range(n-1):\n\tui, vi, xi = (int(x) for x in input().rstrip().split())\n\tif xi == 0:\n\t\trededges[ui].append(vi)\n\t\trededges[vi].append(ui)\nnotvisited = {i for i in range(1, n+1)}\ncompdims = []\nwhile notvisited:\n\tx = notvisited.pop()\n\ttovisit = rededges[x]\t\n\tcompdim = 1\n\twhile tovisit:\n\t\tcompdim += len(tovisit)\n\t\tnbrs = tovisit[:]\n\t\ttovisit = []\n\t\tfor y in nbrs:\n\t\t\tnotvisited.remove(y)\n\t\t\ttovisit += [z for z in rededges[y] if z in notvisited]\n\tcompdims.append(compdim)\nm = 10**9 + 7\ngoodpaths = powmod(n, k, m)\nfor cd in compdims:\n\tgoodpaths -= powmod(cd, k, m)\ngoodpaths = goodpaths%m\nprint(goodpaths)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint64_t MOD = 1000000007;\nint32_t DFS(int32_t v, vector<vector<int32_t>>& G, vector<bool>& F) {\n  F[v] = true;\n  int32_t answer = 1;\n  for (auto w : G[v]) {\n    if (!F[w]) {\n      answer += DFS(w, G, F);\n    }\n  }\n  return answer;\n}\nint64_t POW(int64_t x, int32_t a) {\n  if (a == 0) {\n    return 0;\n  }\n  if (a == 1) {\n    return x;\n  }\n  if (a % 2 == 1) {\n    return (x * POW(x, a - 1)) % MOD;\n  }\n  int64_t tmp = POW(x, a / 2);\n  return (tmp * tmp) % MOD;\n}\nint main() {\n  int32_t n, k;\n  cin >> n >> k;\n  vector<vector<int32_t>> G(n);\n  for (int32_t _ = 0; _ < n - 1; ++_) {\n    int32_t u, v, x;\n    cin >> u >> v >> x;\n    --u;\n    --v;\n    if (x == 0) {\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n  }\n  vector<bool> F(n, false);\n  int64_t answer = 0;\n  for (int32_t i = 0; i < n; ++i) {\n    if (!F[i]) {\n      int64_t current = static_cast<int64_t>(DFS(i, G, F));\n      answer += POW(current, k);\n      answer %= MOD;\n    }\n  }\n  answer = (MOD + POW(n, k) - answer) % MOD;\n  cout << answer << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "'''input\n3 5\n1 2 1\n2 3 0\n'''\nimport sys\nfrom collections import defaultdict as dd\nfrom itertools import  permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nimport heapq\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\nn,k=ri()\nl=dd(list)\nvis=[0 for i in range(n+1)]\ndef bfs(s):\n    d=[s]\n    sz=1\n    vis[s]=1\n    while d:\n        k=d.pop(0)\n        for i in l[k]:\n            if vis[i]==0:\n                vis[i]=1\n                d.append(i)\n                sz+=1\n    return sz\n\nfor i in range(n-1):\n\tu,v,r=ri()\n\tif r==0:\n\t\tl[u].append(v)\n\t\tl[v].append(u)\n\nans=pow(n,k,mod)\n\nfor i in range(1,n+1):\n\tif vis[i]==0:\n\t\tm=bfs(i)\n\t\tans=(ans-pow(m,k,mod))%mod\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "n,k=map(int,input().split())\ng=[[] for _ in range(n+1)]\n\nfor i in range(n-1):\n    u,v,x=map(int,input().split())\n    if x == 0:\n        g[u].append(v)\n        g[v].append(u)\nMOD=10**9  +7\nvis=[0]*(n+1)\nans=pow(n,k)\nfor i in range(1,n+1):\n    if vis[i]==0:\n        cnt=0\n        stack=[i]\n        while stack:\n            u=stack.pop()\n            if vis[u]:\n                continue\n            vis[u]=1\n            cnt+=1\n            for v in g[u]:\n                if not vis[v]:\n                    stack.append(v)\n        ans-=pow(cnt,k)\nprint(ans % MOD)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int parent[(int)1e5 + 2], size_dsu[(int)1e5 + 2], n, k;\nstring get_string() {\n  string s;\n  getline(cin >> ws, s);\n  return s;\n}\nvoid init_edge(long long int u) {\n  parent[u] = u;\n  size_dsu[u] = 1;\n}\nlong long int find_parent(long long int u) {\n  if (u == parent[u]) {\n    return u;\n  }\n  return parent[u] = find_parent(parent[u]);\n}\nvoid union_dsu(long long int u, long long int v) {\n  u = find_parent(u);\n  v = find_parent(v);\n  if (u != v) {\n    if (size_dsu[u] > size_dsu[v]) {\n      parent[v] = u;\n      size_dsu[u] += size_dsu[v];\n    } else {\n      parent[u] = v;\n      size_dsu[v] += size_dsu[u];\n    }\n  }\n}\nlong long int modulo_pow(long long int x, long long int y, long long int p) {\n  long long int res = 1;\n  x = x % p;\n  if (x == 0) {\n    return 0;\n  }\n  while (y > 0) {\n    if (y % 2 == 1) {\n      res = (res * x) % p;\n    }\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nvoid solve() {\n  long long int x, y, u, ans;\n  cin >> n >> k;\n  for (long long int i = 1; i <= n; i++) {\n    init_edge(i);\n  }\n  for (long long int i = 1; i < n; i++) {\n    cin >> x >> y >> u;\n    if (u != 1) {\n      union_dsu(x, y);\n    }\n  }\n  set<long long int> s;\n  for (long long int i = 1; i <= n; i++) {\n    s.insert(find_parent(i));\n  }\n  ans = modulo_pow(n, k, (long long int)1e9 + 7);\n  for (auto i : s) {\n    ans -= modulo_pow(size_dsu[i], k, (long long int)1e9 + 7);\n    if (ans < 0) {\n      ans += (long long int)1e9 + 7;\n    }\n  }\n  cout << ans << endl;\n}\nint main(void) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cout << fixed << showpoint;\n  cout << setprecision(9);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class pr1139C {\n    static final long MOD = (long)1e9 + 7;\n    static ArrayList<Integer> graph[];\n    static boolean[] vis;\n    static int cnt;\n    public static void main(String[] args) {\n        FastScanner in = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int k = in.nextInt();\n\n        graph = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < n - 1; i++) {\n            int u = in.nextInt() - 1;\n            int v = in.nextInt() - 1;\n            int x = in.nextInt();\n\n            if(x == 0) {\n                graph[u].add(v);\n                graph[v].add(u);\n            }\n        }\n\n        out.println(solve(n, k));\n        out.flush();\n        out.close();\n    }\n\n    private static long solve(int n, int k) {\n        long ans = fast_exp(n, k);\n\n        vis = new boolean[n];\n        long r = 0;\n        for (int i = 0; i < n; i++) {\n            if(!vis[i]) {\n                cnt = 0;\n                dfs(i);\n                r += fast_exp(cnt, k);\n            }\n        }\n\n        r %= MOD;\n        return (ans - r + MOD) % MOD;\n    }\n\n    private static void dfs(int i) {\n        vis[i] = true;\n        cnt++;\n\n        for(int j: graph[i]) {\n            if(!vis[j])\n                dfs(j);\n        }\n    }\n\n    private static long fast_exp(int n, int k) {\n        if(k == 1) {\n            return (long) n;\n        }\n        long a = fast_exp(n, k/2);\n\n        if(k % 2 == 0) {\n            return a * a % MOD;\n        }\n//        return (a * a * (n % MOD)) % MOD;\n        return a * a % MOD * n % MOD;\n    }\n\n    static class FastScanner\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 3;\nconst long long M = 1e9 + 7;\nlong long n, k, res;\nvector<long long> g[N];\nvector<bool> used(N, false);\nlong long pow_mod(long long a, long long x) {\n  long long r = 1;\n  while (x) {\n    if (x & 1) r = r * a % M;\n    a = a * a % M;\n    x >>= 1;\n  }\n  return r;\n}\nlong long dfs(long long v) {\n  used[v] = true;\n  long long r = 1;\n  for (long long& to : g[v]) {\n    if (!used[to]) r += dfs(to);\n  }\n  return r;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long long i = 1; i < n; ++i) {\n    long long x, y, c;\n    cin >> x >> y >> c;\n    if (c == 0) {\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n  }\n  res = 0;\n  for (long long i = 1; i <= n; ++i) {\n    if (!used[i]) res = (res + pow_mod(dfs(i), k)) % M;\n  }\n  res = (pow_mod(n, k) - res + M) % M;\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n,k = map(int,raw_input().split())\ng = []\nfor i in range(n):\n\tg.append([])\nq = []\nvis = [0]*(n+1)  \nfor i in range(n-1):\n\tu,v,x = map(int,raw_input().split())\n\tif not x:\n\t\tq.append(u-1)\n\t\tq.append(v-1)\n\t\tg[u-1].append(v-1)\n\t\tg[v-1].append(u-1)\nx = 0\nMOD = 10**9 + 7\nans = pow(n,k,MOD) - n\nans%=MOD\n# print q\nstck = []\nwhile len(q)!=0:\n\tcnt = 0\n\tv = q.pop()\n\tif vis[v]:\n\t\tcontinue\n\t# print \"new query\",v\n\tstck.append(v)\n\twhile len(stck)!=0:\n\t\ti = stck.pop()\n\t\tif vis[i]:\n\t\t\tcontinue\n\t\tvis[i] = 1\n\t\t# print \"dfs\",i,g[i],cnt\n\t\tcnt+=1\n\t\tfor j in g[i]:\n\t\t\tif not vis[j]:\n\t\t\t\tstck.append(j)\n\tans-=pow(cnt,k,MOD)\n\tans+=cnt\n\tans%=MOD\nprint ans%MOD\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int MAXN = 1e5 + 15;\nvector<int> Graph[MAXN];\nbool visited[MAXN];\nint T, N, K;\nlong long Pow(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) {\n      ans = ans * a % MOD;\n    }\n    a = a * a % MOD;\n    b >>= 1;\n  }\n  return ans;\n}\nvoid DFS(int v) {\n  if (visited[v]) return;\n  visited[v] = 1;\n  T++;\n  for (auto &itr : Graph[v]) {\n    DFS(itr);\n  }\n}\nint main() {\n  scanf(\"%d %d\", &N, &K);\n  memset(visited, 0, sizeof(visited));\n  for (int i = 1; i < N; i++) {\n    int x, y, c;\n    scanf(\"%d %d %d\", &x, &y, &c);\n    if (c == 0) {\n      Graph[x].push_back(y);\n      Graph[y].push_back(x);\n    }\n  }\n  long long Ans = 0;\n  for (int i = 1; i <= N; i++) {\n    if (visited[i]) continue;\n    T = 0;\n    DFS(i);\n    Ans = (Ans + Pow(T, K)) % MOD;\n  }\n  Ans = (Pow(N, K) - Ans + MOD) % MOD;\n  printf(\"%I64d\\n\", Ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# 1-indexed verticies\n\nimport sys\nsys.setrecursionlimit(10 ** 5 + 10)\n\nn, k = map(int, input().split())\n\nparents = [i for i in range(n + 1)]\nsize = [1 for i in range(n + 1)]\n\ndef find(a):\n\tif a == parents[a]:\n\t\treturn a\n\tparents[a] = find(parents[a])\n\treturn parents[a]\n\ndef union(a, b):\n\ta = find(a)\n\tb = find(b)\n\tif a != b:\n\t\tif size[a] < size[b]:\n\t\t\ta, b = b, a\n\t\tparents[b] = a\n\t\tsize[a] += size[b]\n\ndef same(a, b):\n\treturn find(a) == find(b)\n\nfor _ in range(n - 1):\n\ta, b, c = map(int, input().split())\n\tif c == 0:\n\t\tunion(a, b)\n\ndictionary = {}\nfor i in range(1, n + 1):\n\tf = find(i)\n\tif f not in dictionary:\n\t\tdictionary[f] = 0\n\tdictionary[f] += 1\n\ns = pow(n, k, 10 ** 9 + 7)\nfor key in dictionary:\n\ts -= pow(dictionary[key], k, 10 ** 9 + 7)\nprint ((s % (10 ** 9 + 7) + (10 ** 9 + 7)) % (10 ** 9 + 7))"
        },
        {
            "language": 3,
            "solution": "from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\n#from math import *\nfrom collections import defaultdict as dd, deque\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return map(int, data().split())\n#sys.setrecursionlimit(100000)\nmod=int(1e9+7)\n\ndef find(x):\n    if x!=par[x]:\n        par[x]=find(par[x])\n    return par[x]\n\nn,k=mdata()\npar=[i for i in range(n+1)]\nfor i in range(n-1):\n    u,v,x=mdata()\n    if x==0:\n        par[find(par[u])]=find(par[v])\nd=dd(int)\nfor i in range(1,n+1):\n    d[find(par[i])]+=1\nans=pow(n,k,mod)\nfor i in d:\n    ans-=pow(d[i],k,mod)\nprint((ans+mod)%mod)"
        },
        {
            "language": 3,
            "solution": "from collections import deque\nmod = 10**9 + 7\n\n\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.edges = {}\n\n    def add_edge(self, node, color):\n        self.edges[node] = color\n\n\nn, k = map(int, input().split())\ntree = []\nfor i in range(1, n+1):\n    tree.append(TreeNode(i))\n\nfor _ in range(n-1):\n    u, v, x = map(int, input().split())\n    tree[u-1].add_edge(v, x)\n    tree[v-1].add_edge(u, x)\n\nvisited = set()\ntotal = 0\n\nfor node in range(1, n+1):\n    if node in visited:\n        continue\n\n    queue = deque()\n    queue.append(node)\n    visited.add(node)\n    red_vertexes = 1\n    while queue:\n\n        vertex = queue.popleft()\n\n        for (e, c) in tree[vertex-1].edges.items():\n            if c == 0 and e not in visited:\n                queue.append(e)\n                red_vertexes = red_vertexes + 1\n                visited.add(e)\n\n    total = (total + pow(red_vertexes, k, mod)) % mod\n\ntotal = (pow(n, k, mod) - total) % mod\nprint(total)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic final class Main {\n    BufferedReader br;\n    StringTokenizer stk;\n    \n    public static void main(String[] args) throws Exception {\n        new Main().run();\n    }\n    \n    {\n        stk = null;\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    \n    boolean tests = false;\n    \n    long mod = 1000_000_000 + 7;\n    StringBuilder res = new StringBuilder(1000005);\n    \n    void run() throws Exception {\n        int t = tests ? ni() : 1;\n        for(int i = 1; i <= t; i++) {\n            go(i);\n        }\n        System.out.print(res.length() == 0 ? \"\" : res);\n    }\n    \n    void go(int T) throws Exception {\n        int n = ni(), k = ni();\n        Node[] g = new Node[n + 1];\n        for(int i = 1; i <= n; i++) {\n            g[i] = new Node();\n        }\n        for(int i = 1; i < n; i++) {\n            int u = ni(), v = ni(), x = ni();\n            if(x == 0) {\n                g[u].adj.add(v);\n                g[v].adj.add(u);\n            }\n        }\n        \n        boolean[] visited = new boolean[n + 1];\n        \n        long ans = 0, total = modPow(n, k);\n        for(int i = 1; i <= n; i++) {\n            if(!visited[i]) {\n                int N = recur(i, visited, g);\n                ans += modPow(N, k);\n                ans %= mod;\n            }\n        }\n        \n        ans = (total - ans + mod) % mod;\n        \n        res.append(ans).append(\"\\n\");\n    }\n    \n    int recur(int node, boolean[] v, Node[] g) {\n        if(v[node]) return 0;\n        v[node] = true; // mark visited\n        int value = 1;\n        for(int adj : g[node].adj) {\n            value += recur(adj, v, g);\n        }\n        return value;\n    }\n    \n    long modPow(long x, long y) {\n        if(y == 0) return 1;\n        if(y == 1) return x;\n        long val = modPow(x, y / 2);\n        val = ((((val * val) % mod) * modPow(x, y % 2)) % mod);\n        return val;\n    }\n    \n    class Node {\n        HashSet<Integer> adj;\n        public Node() {\n            adj = new HashSet<>();\n        }\n    }\n    \n    //Reader & Writer\n    String nt() throws Exception {\n        if (stk == null || !stk.hasMoreTokens())\n            stk = new StringTokenizer(br.readLine(), \" \");\n        return stk.nextToken();\n    }\n\n    char[] nc() throws Exception {\n        return nt().toCharArray();\n    }\n\n    int ni() throws Exception {\n        return Integer.parseInt(nt());\n    }\n\n    long nl() throws Exception {\n        return Long.parseLong(nt());\n    }\n    \n    double nd() throws Exception {\n        return Double.parseDouble(nt());\n    }\n    \n    //Some Misc methods\n    int get(int l, int r, int[] a) {\n        return l == 0 ? a[r] : a[r] - a[l - 1];\n    }\n    \n    void shuffle(int[] a) {\n        Random r = new Random();\n        for(int i = 0; i < a.length; i++) {\n            int idx = r.nextInt(a.length);\n            int temp = a[i];\n            a[i] = a[idx];\n            a[idx] = temp;\n        }\n    }\n    \n    void reverse(long[] a) {\n        for(int i = 0, j = a.length - 1; i < j; i++, j--) {\n            long temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n        }\n    }\n    \n    void print(int[] a) {\n        System.out.println(Arrays.toString(a));\n    }\n    \n    void print(long[] a) {\n        System.out.println(Arrays.toString(a));\n    }\n}"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split())\n\np = [i for i in range(n + 1)]\nsz = [1] * (n + 1)\n\n\ndef par(u):\n    if u == p[u]:\n        return u\n    p[u] = par(p[u])\n    return p[u]\n\n\ndef merge(u, v):\n    sz[par(v)] += sz[par(u)]\n    p[par(u)] = par(v)\n\n\nfor i in range(n - 1):\n    u, v, x = map(int, input().split())\n    if not x:\n        merge(u, v)\n\nMOD = int(1e9 + 7)\n\n\ndef mul(n, p):\n    ret = 1\n    while p:\n        if p & 1:\n            ret *= n\n            ret %= MOD\n        p >>= 1\n        n *= n\n        n %= MOD\n\n    return ret\n\n\nans = mul(n, k)\n\ncounted = [0] * (n + 1)\n\nfor i in range(1, n + 1):\n    parent = par(i)\n    if counted[parent]:\n        continue\n    counted[parent] = 1\n    ans -= mul(sz[parent], k)\n    if ans < 0:\n        ans += MOD\n\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class EdgyTree {\n\n    static int mod = 1000000007;\n\n    public static void main(String[] args) {\n\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int k = scan.nextInt();\n\n        Graph graph = new Graph(n);\n\n        boolean[] visited = new boolean[n];\n        long total = power(n, k, mod);\n\n        for(int i = 0; i < n - 1; i++) {\n\n            int u = scan.nextInt()-1;\n            int v = scan.nextInt()-1;\n            int x = scan.nextInt();\n\n            if(x == 0){\n                graph.union(u, v);\n            }\n        }\n\n        for(int i = 0; i < n; i++) {\n\n            int p = graph.findParent(i);\n\n            if(visited[p]){\n                continue;\n            }\n\n            visited[p] = true;\n            long now = power(graph.len[p], k, mod);\n            total = (total - now + mod) % mod;\n        }\n\n        System.out.println(total);\n    }\n\n    static long power(long x, long y, int p) {\n        long res = 1;\n        x = x % p;\n\n        while (y > 0) {\n            if ((y & 1) == 1) {\n                res = (((res % p) * (x % p)) % p);\n            }\n\n            y = y >> 1;\n            x = (((x % p) * (x % p)) % p);\n        }\n        return res;\n    }\n\n}\n\nclass Graph {\n\n    int[] root;\n    int[] len;\n    int n;\n\n    Graph(int n) {\n        this.n = n;\n        root = new int[n];\n        len = new int[n];\n        for (int i = 0; i < n; i++) {\n            root[i] = i;\n            len[i] = 1;;\n        }\n    }\n\n    int findParent(int i) {\n        while(root[i]!=i) {\n            root[i] = root[root[i]];\n            i=root[i];\n        }\n        return i;\n    }\n\n    boolean union(int x, int y) {\n\n        int parX = findParent(x);\n        int parY = findParent(y);\n\n        if (parX == parY)\n            return false;\n\n        if (len[parX] < len[parY]) {\n            root[parY] = parX;\n            len[parX] += len[parY];\n        } else {\n            root[parX] = parY;\n            len[parY] += len[parX];\n        }\n\n        return true;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = double;\nbool DEBUGGING = 0;\nvoid useiostream() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n}\nvoid drop(char const *bu) {\n  printf(\"%s\", bu);\n  exit(0);\n}\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nld const pi = acos(-1.0);\nld const eps = 0.000000001;\ntemplate <typename T, typename TT>\nbool mi(T &a, TT b) {\n  return a > b ? (a = b, true) : false;\n}\ntemplate <typename T, typename TT>\nbool ma(T &a, TT b) {\n  return a < b ? (a = b, true) : false;\n}\nmt19937 ran(time(0));\nint const mod = (int)1e9 + 7;\nint bp(int a, int p) {\n  int re = 1;\n  while (p) {\n    if (p & 1) re = (re * 1LL * a) % mod;\n    p >>= 1;\n    a = (a * 1LL * a) % mod;\n  }\n  return re;\n}\nint inv(int a) { return bp(a, mod - 2); }\nint n, k;\nvector<int> g[100005];\nset<int> black[100005];\nint color[100005];\nvector<int> ng[100005];\nint cnt[100005];\nint sz[100005];\nvoid dfs(int ind, int col) {\n  color[ind] = col;\n  cnt[col]++;\n  for (auto &x : g[ind]) {\n    if (black[ind].count(x)) continue;\n    if (color[x] == 0) dfs(x, col);\n  }\n}\nint used[100005];\nint res = 0;\nint mul[100005];\nint todel[100005];\nint re[100005];\nint get(int from, int what) { return bp(from, what); }\nint dfsf(int ind) {\n  sz[ind] = cnt[ind];\n  for (auto &x : ng[ind]) {\n    if (sz[x] == 0) {\n      sz[ind] += dfsf(x);\n    }\n  }\n  return sz[ind];\n}\nvoid dfsc(int ind) {\n  used[ind] = 1;\n  todel[ind] = bp(cnt[ind], k);\n  for (auto &x : ng[ind]) {\n    if (!used[x]) {\n      dfsc(x);\n      todel[ind] += todel[x];\n      todel[ind] %= mod;\n    }\n  }\n  re[ind] = (bp(sz[ind], k) - todel[ind] + mod) % mod;\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < n - 1; i++) {\n    int a, b, c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    a--;\n    b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n    if (c == 1) {\n      black[a].insert(b);\n      black[b].insert(a);\n    }\n  }\n  int kek = 1;\n  for (int i = 0; i < n; i++) {\n    if (color[i] == 0) {\n      dfs(i, kek++);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (auto &x : black[i]) {\n      ng[color[x]].push_back(color[i]);\n    }\n  }\n  dfsf(1);\n  dfsc(1);\n  printf(\"%d\", re[1]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 5, mod = 1e9 + 7;\ntemplate <class o>\ninline void qr(o &x) {\n  x = 0;\n  char c = getchar();\n  int f = 1;\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + (c ^ 48);\n    c = getchar();\n  }\n  x *= f;\n}\ntemplate <class o>\nvoid qw(o x) {\n  if (x / 10) qw(x / 10);\n  putchar(x % 10 + 48);\n}\ntemplate <class o>\nvoid pr1(o x) {\n  if (x < 0) putchar('-'), x = -x;\n  qw(x);\n  putchar(' ');\n}\ntemplate <class o>\nvoid pr2(o x) {\n  if (x < 0) putchar('-'), x = -x;\n  qw(x);\n  puts(\"\");\n}\ninline int ksm(int a, int b = mod - 2) {\n  int ans = 1;\n  for (; b; b >>= 1, a = 1ll * a * a % mod)\n    if (b & 1) ans = 1ll * ans * a % mod;\n  return ans;\n}\ninline int add(int a, int b) { return a += b, a >= mod ? a - mod : a; }\ninline int sub(int a, int b) { return a -= b, a < 0 ? a + mod : a; }\nvector<pair<int, int> > e[N];\nint siz[N], col[N], cnt, pw[N];\nvoid dfs(int x) {\n  ++siz[cnt];\n  col[x] = cnt;\n  for (pair<int, int> t : e[x]) {\n    int y = t.first, z = t.second;\n    if (z || col[y]) continue;\n    dfs(y);\n  }\n}\nvoid solve() {\n  int n, k;\n  qr(n), qr(k);\n  for (int i = 1; i <= n; ++i) pw[i] = ksm(i, k);\n  for (int i = 1; i < n; ++i) {\n    int x, y, z;\n    qr(x), qr(y), qr(z);\n    e[x].emplace_back(y, z);\n    e[y].emplace_back(x, z);\n  }\n  int ans = pw[n];\n  for (int i = 1; i <= n; ++i)\n    if (!col[i]) {\n      ++cnt;\n      dfs(i);\n      ans = sub(ans, pw[siz[cnt]]);\n    }\n  pr2(ans);\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 2e5 + 5;\nconst long long MOD = 1e9 + 7;\nlong long father[MAX], num[MAX];\nlong long finds(long long x) {\n  return x == father[x] ? x : father[x] = finds(father[x]);\n}\nvoid combine(long long x, long long y) {\n  long long fatherx = finds(x);\n  long long fathery = finds(y);\n  if (fatherx != fathery) {\n    father[fatherx] = fathery;\n    num[fathery] += num[fatherx];\n    num[fatherx] = 0;\n  }\n}\nlong long qpow(long long a, long long b) {\n  long long base = a % MOD;\n  long long ans = 1;\n  while (b) {\n    if (b & 1) {\n      ans = ans * base % MOD;\n    }\n    base = base * base % MOD;\n    b >>= 1;\n  }\n  return ans;\n}\nint main() {\n  long long n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    father[i] = i;\n    num[i] = 1;\n  }\n  for (int i = 1; i <= n - 1; i++) {\n    long long from, to, col;\n    cin >> from >> to >> col;\n    if (!col) combine(from, to);\n  }\n  long long ans = qpow(n, k);\n  for (int i = 1; i <= n; i++) {\n    if (num[i] != 0) {\n      ans = (ans - qpow(num[i], k) + MOD) % MOD;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import collections\nn,k = map(int,input().split())\n# cc = collections.defaultdict(int)\n# ccn = 0\nvisited = [0]*(n+1)\ng = collections.defaultdict(set)\n# sz = collections.defaultdict(int)\n# def dfs(n,ccn):\n# \tcc[n] = ccn\n# \tfor i in g[n]:\n# \t\tif i not in cc:\n# \t\t\tdfs(i,ccn)\n\nfor i in range(n-1):\n\tu,v, color = map(int,input().split())\n\tif not color :\n\t\tg[u].add(v)\n\t\tg[v].add(u)\n\n\nMOD = 10**9 + 7\nans = pow(n,k,MOD)\nfor i in range(1,n+1):\n\tif not visited[i]:\n\t\tsz = 0\n\t\tst = [i]\n\t\twhile st:\n\t\t\tcur = st.pop()\n\t\t\tvisited[cur] = 1\n\t\t\tsz += 1\n\t\t\tfor node in g[cur]:\n\t\t\t\tif not visited[node]:\n\t\t\t\t\tst.append(node)\n\t\tans -= pow(sz,k,MOD)\n\t\tif ans<0:\n\t\t\tans += MOD\n\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "import collections\n\nMOD = 1000000007\nn, k = map(int, input().split())\n\ng = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u, v, x = map(int, input().split())\n    u -= 1\n    v -= 1\n    if x == 0:\n        g[u].append(v)\n        g[v].append(u)\n\nres = 0\nvisit = [False] * n\n\nall = pow(n, k, MOD)\nbad = 0\nfor i in range(n):\n    if visit[i]:\n        continue\n    d = collections.deque()\n    d.append(i)\n    visit[i] = True\n    c = 1\n    while d:\n        u = d.pop()\n        for v in g[u]:\n            if visit[v]:\n                continue\n            visit[v] = True\n            d.append(v)\n            c += 1\n    bad += pow(c, k, MOD)\n\nprint ((all - bad + MOD) % MOD)"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Tree {\n   \n    public static HashMap<Integer, Integer> sortByValue(HashMap<Integer, Integer> hm) \n    { \n        \n        List<Map.Entry<Integer, Integer> > list = \n               new LinkedList<Map.Entry<Integer, Integer> >(hm.entrySet()); \n  \n      \n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() { \n            public int compare(Map.Entry<Integer, Integer> o1,  \n                               Map.Entry<Integer, Integer> o2) \n            { \n                return (o1.getValue()).compareTo(o2.getValue()); \n            } \n        }); \n          \n       \n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>(); \n        for (Map.Entry<Integer, Integer> aa : list) { \n            temp.put(aa.getKey(), aa.getValue()); \n        } \n        return temp; \n    } \n    static class InputReader {\n \n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n \n\t\tpublic InputReader(InputStream st) {\n\t\t\tthis.stream = st;\n\t\t}\n \n\t\tpublic int read() {\n\t\t\tif (snumChars == -1)\n\t \t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n \n\t\tpublic int ni() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic long nl() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic int[] nia(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = ni();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic String rs() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n \n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n \n\t}\n    static PrintWriter w = new PrintWriter(System.out);\n//    static int parent[];\n//    public static int find(int parent[],int i){\n//        if(parent[i]==-1)\n//            return i;\n//        return find(parent,parent[i]);\n//    }\n//    public static void union(int parent[],int x,int y){\n//        int xset=find(parent,x);\n//        int yset=find(parent,y);\n//        parent[xset]=yset;\n//    }\n//    static  HashMap<String,Character> map;\n//    static int color[][];\n    static ArrayList<Integer> arr[];\n    static long mod=1000000007;\n    public static int bfs(ArrayList<Integer> arr[],boolean visited[],int count,int i){\n         \n        Queue<Integer> q=new LinkedList();\n        q.add(i);\n        while(!q.isEmpty()){\n            int j=q.poll();\n            if(visited[j])\n                continue;\n            else{\n                visited[j]=true;\n                 count++;\n                 \n                 Iterator itr=arr[j].iterator();\n                 while(itr.hasNext()){\n                     int a=(int)itr.next();\n                     if(!visited[a])\n                        q.add(a);\n                 }\n            }\n        }\n       return count;     \n    } \n//     static boolean found=false,founda1=false,foundb1=false;\n//     static int ans=0, minlength=1000000,n,ones=0,r1,c1,r2,c2;\n//    public static int dfs(ArrayList<Integer> arr[],boolean visited[],int count,int i){\n//       \n//      \n//    }\n    public static void main(String[] args) {\n         InputReader sc=new InputReader(System.in);\n       \n            int n=sc.ni();\n            int k=sc.ni();\n            arr=new ArrayList[n+1];\n            for(int i=1;i<n+1;i++)\n                arr[i]=new ArrayList<Integer>();\n            for(int i=0;i<n-1;i++){\n                int a=sc.ni();\n                int b=sc.ni();\n                int c=sc.ni();\n                \n                if(c==0){\n                    arr[a].add(b);\n                    arr[b].add(a);\n                }\n               \n            }\n            boolean visited[]=new boolean[n+1];\n            BigInteger a=BigInteger.valueOf(n).pow(k).mod(BigInteger.valueOf(mod));\n            for(int i=1;i<=n;i++){\n                if(!visited[i]){\n                   int count=0;\n                  int ans= bfs(arr,visited,count,i);\n                  BigInteger b=BigInteger.valueOf(ans).pow(k).mod(BigInteger.valueOf(mod));\n                  a=a.subtract(b).add(BigInteger.valueOf(mod)).mod(BigInteger.valueOf(mod));\n                 \n                }\n               \n            }\n            w.println(a);\n        w.close();\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "def read_line():\n\treturn list(map(int, input().split()))\n\nmod = 1000000007\ng = {}\nn,k = read_line()\ndone = set()\n\ncurr = 1\ncount = 0\nfor _ in range(n-1):\n\tu,v,x = read_line()\n\tif x == 0:\n\t\tli = g.get(u,[])\n\t\tli.append(v)\n\t\tg[u] = li\n\n\t\tli = g.get(v,[])\n\t\tli.append(u)\n\t\tg[v] = li\n\ndef width_search(n):\n\tcomp = 0\n\tq = []\n\tq.append(n)\n\tdone.add(n)\n\twhile q:\n\t\tx = q.pop(0)\n\t\tcomp += 1\n\t\tl = g.get(x,[])\n\t\tfor i in l:\n\t\t\tif i not in done:\n\t\t\t\tq.append(i)\n\t\t\t\tdone.add(i)\n\treturn comp\n\nanswer = n**k\nfor i in range(1,n+1):\n\tif i not in done:\n\t\tanswer -= width_search(i)**k\n\n\nprint(str(answer % mod))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint visited[100 * 1000 + 20] = {};\nstd::vector<int> g[100 * 1000 + 20];\nconst int p = 1000 * 1000 * 1000 + 7;\nint dfs(int v) {\n  visited[v] = 1;\n  int sum = 1;\n  for (int i = 0; i < g[v].size(); i++) {\n    if (visited[g[v][i]]) continue;\n    sum += dfs(g[v][i]);\n  }\n  return sum;\n}\nnamespace miller {\nunsigned long long int multiply(unsigned long long int a,\n                                unsigned long long int b,\n                                unsigned long long int p) {\n  unsigned long long int ans = 0;\n  a = a % p;\n  b = b % p;\n  if (a >> 32 == 0 && b >> 32 == 0) return (a * b) % p;\n  if (b > a) {\n    b = a ^ b;\n    a = a ^ b;\n    b = a ^ b;\n  }\n  for (; b != 0; b = b >> 1) {\n    if (b & 1) ans = (ans + a) % p;\n    a = (a << 1) % p;\n  }\n  return ans;\n}\nunsigned long long int power(unsigned long long int a, unsigned long long int b,\n                             unsigned long long int p) {\n  unsigned long long int ans = 1;\n  for (; b != 0; b = b >> 1) {\n    if (b & 1) ans = multiply(ans, a, p);\n    a = multiply(a, a, p);\n  }\n  return ans;\n}\nint single_test(unsigned long long int a, unsigned long long int d,\n                unsigned long long int p) {\n  unsigned long long int m = power(a, d, p);\n  if (m == 1 || m == p - 1) return 1;\n  while (d != p - 1) {\n    m = multiply(m, m, p);\n    d = d << 1;\n    if (m == 1) return 0;\n    if (m == p - 1) return 1;\n  }\n  return 0;\n}\nint bruteforce(int n) {\n  int m;\n  if (n == 2) return 1;\n  if (n % 2 == 0) return 0;\n  for (m = 3; m * m <= n; m = m + 2) {\n    if (n % m == 0) return 0;\n  }\n  return 1;\n}\nint prime(unsigned long long int p) {\n  if (p < 1000) return bruteforce(p);\n  if ((p % 2 && p % 5 && p % 7 && p % 11 && p % 13 && p % 17 && p % 19 &&\n       p % 23) == 0)\n    return 0;\n  unsigned long long int d = p - 1;\n  while (d % 2 == 0) d = d >> 1;\n  unsigned long long int t = p;\n  if (!single_test(2, d, p)) return 0;\n  if (t >> 10 == 0) return 1;\n  if (!single_test(3, d, p)) return 0;\n  if (t >> 20 == 0) return 1;\n  if (!single_test(5, d, p)) return 0;\n  if (t >> 24 == 0) return 1;\n  if (!single_test(7, d, p)) return 0;\n  if (t >> 31 == 0) return 1;\n  if (!single_test(11, d, p)) return 0;\n  if (t >> 40 == 0) return 1;\n  if (single_test(13, d, p) && single_test(17, d, p) && single_test(19, d, p) &&\n      single_test(23, d, p))\n    return 1;\n  return 0;\n}\n}  // namespace miller\nint main() {\n  int n, k;\n  std::cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v, x;\n    scanf(\"%d%d%d\", &u, &v, &x);\n    if (!x) {\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n  }\n  long long int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) ans += miller::power(dfs(i), k, p);\n  }\n  ans = miller::power(n, k, p) - ans;\n  ans = ans % p;\n  ans = ans < 0 ? p + ans : ans;\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int modul = (int)1e9 + 7;\nint powermod(int a, int b, int n = modul) {\n  if (b == 0) return 1;\n  long long tmp = powermod(a, b / 2, n);\n  if (b % 2 == 0) return (tmp * tmp) % n;\n  return (((tmp * tmp) % n) * a) % n;\n}\nint getRoot(int parents[], int i) {\n  while (parents[i] != i) i = parents[i];\n  return i;\n}\nint main(int argc, char** argv) {\n  int n, k;\n  std::cin >> n >> k;\n  int roots[n], accums[n];\n  for (int i = 0; i < n; i++) {\n    roots[i] = i;\n    accums[i] = 1;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int u, v, cl;\n    std::cin >> u >> v >> cl;\n    u--, v--;\n    if (cl == 0) {\n      int x = getRoot(roots, u);\n      int y = getRoot(roots, v);\n      if (x != y) {\n        roots[x] = y;\n        accums[y] += accums[x];\n        accums[x] = 0;\n      }\n    }\n  }\n  std::vector<int> counts;\n  for (int i = 0; i < n; i++)\n    if (accums[i] > 0) counts.push_back(accums[i]);\n  long long result = 0;\n  for (int j = 0; j < counts.size(); j++)\n    result = (result + powermod(counts[j], k)) % modul;\n  result = powermod(n, k) + modul - result;\n  std::cout << result % modul << std::endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\ninput = sys.stdin.readline\n\n\n############ ---- Input Functions ---- ############\ndef inp():\n    return (int(input()))\n\n\ndef inlt():\n    return (list(map(int, input().split())))\n\n\ndef insr():\n    s = input()\n    return (list(s[:len(s) - 1]))\n\n\ndef invr():\n    return (map(int, input().split()))\n\nsys.setrecursionlimit(10 ** 6)\ndef explore(adj,i):\n    visited[i]=1\n    count=1\n    for j in adj[i]:\n        if visited[j] !=1:\n            count+=explore(adj,j)\n    return count\n\n\nn,k=invr()\nadj=[[] for i in range(n)]\nx=0\nfor i in range(n-1):\n    a,b,c=invr()\n    if c==0:\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n    else:\n        x+=1\nvisited=[0 for i in range(n)]\nans=0\n\nif x !=0:\n    for i in range(n):\n        if visited[i]==0:\n            count= explore(adj,i)\n            ans+=pow(count,k,1000000007)\n\n\n    print((pow(n,k,1000000007)-ans%1000000007)%1000000007)\nelse:\n    print(0)\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Solution implements Runnable{\n    FastScanner sc;\n    PrintWriter pw;\n    final class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n \n        public long nlo() {\n            return Long.parseLong(next());\n        }\n \n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return st.nextToken();\n        }\n \n        public int ni() {\n            return Integer.parseInt(next());\n        }\n \n        public String nli() {\n            String line = \"\";\n            if (st.hasMoreTokens()) line = st.nextToken();\n            else try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            while (st.hasMoreTokens()) line += \" \" + st.nextToken();\n            return line;\n        }\n \n        public double nd() {\n            return Double.parseDouble(next());\n        }\n    }\n    public static void main(String[] args) throws Exception\n    {\n        new Thread(null,new Solution(),\"codeforces\",1<<28).start();\n    }\n    public void run()\n    {\n        sc=new FastScanner();\n        pw=new PrintWriter(System.out);\n        solve();\n        pw.flush();\n        pw.close();\n    }\n    public long gcd(long a,long b)\n    {\n        return b==0L?a:gcd(b,a%b);\n    }\n    public long ppow(long a,long b,long mod)\n    {\n        if(b==0L)\n        return 1L;\n        long tmp=1;\n        while(b>1L)\n        {\n            if((b&1L)==1)\n            tmp*=a;\n            a*=a;\n            a%=mod;\n            tmp%=mod;\n            b>>=1;\n        }\n        return (tmp*a)%mod;\n    }\n    public  int gcd(int x,int y)\n    {\n        return y==0?x:gcd(y,x%y);\n    }\n    //////////////////////////////////\n    /////////////  LOGIC  ///////////\n    ////////////////////////////////\n    int[] visit,res;\n    ArrayList<Integer>[] adj;\n    public void solve()\n    {\n        int t=1;\n        while(t-->0)\n        {\n          int n=sc.ni();\n          int k=sc.ni();\n          long mod=1000000007;\n          visit=new int[n];\n          adj=new ArrayList[n];\n          for(int i=0;i<n;i++)\n          adj[i]=new ArrayList();\n          long ans=ppow(n,k,mod);\n          for(int i=0;i<n-1;i++)\n          {\n              int x=sc.ni()-1;\n              int y=sc.ni()-1;\n              int z=sc.ni();\n              if(z==0)\n              {\n                  adj[x].add(y);\n                  adj[y].add(x);\n              }\n          }\n          for(int i=0;i<n;i++)\n          {\n            if(visit[i]==0)\n            {\n                long tmp=dfs(i);\n                tmp=ppow(tmp,k,mod);\n                ans=(ans+mod-tmp)%mod;\n            }\n          }\n          pw.println(ans);\n        }\n    }\n    public int dfs(int x)\n    {\n        visit[x]=1;\n        int tmp=1;\n        for(int y:adj[x])\n        if(visit[y]==0)\n        tmp+=dfs(y);\n        return tmp;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int po(long long int x, long long int n, long long int mod) {\n  long long int res = 1;\n  while (n > 0) {\n    if (n % 2 == 1) res = ((res % mod) * (x % mod)) % mod;\n    x = (x * x) % mod;\n    n = n / 2;\n  }\n  return res;\n}\nlong long int ceil(long long int x, long long int y) {\n  if (x % y == 0)\n    return x / y;\n  else\n    return (x / y) + 1;\n}\nvector<long long int> graph[200005];\nbool visited[200005];\nlong long int cc;\nvector<long long int> ans;\nlong long int jk;\nvoid dfs(long long int node) {\n  visited[node] = 1;\n  jk++;\n  for (auto i : graph[node]) {\n    if (visited[i] == 0) dfs(i);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int n, m;\n  cin >> n >> m;\n  long long int mod = 1000000007;\n  for (long long int i = 0; i < n - 1; i++) {\n    long long int a, b, q;\n    cin >> a >> b >> q;\n    if (q == 0) {\n      graph[a].push_back(b);\n      graph[b].push_back(a);\n    }\n  }\n  for (long long int i = 1; i <= n; i++) {\n    if (visited[i] == 0) {\n      jk = 0;\n      dfs(i);\n      cc++;\n      ans.push_back(jk);\n    }\n  }\n  long long int op = po(n, m, mod);\n  for (auto i : ans) {\n    op = ((op % mod) - (po(i, m, mod) % mod)) % mod;\n  }\n  cout << (op + mod) % mod;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nimport bisect\n\ndef argsort(ls):\n    return sorted(range(len(ls)), key=ls.__getitem__)\n\ndef f(p=0):\n    if p==0:\n        return int(input())\n    if p==1:\n        return map(int, input().split())\n    elif p==2:\n        return list(map(int, input().split()))\n    else:\n        return sorted(list(map(int, input().split())))\n\n\nn, k = f(1)\n\ndl = [0]*(n+1)\ndl[0] = -1\ng = [list() for i in range(n+1)]\n\nfor i in range(n-1):\n    u, v, x = f(1)\n    if x==0:\n        g[u].append(v)\n        g[v].append(u)\n\ncl = []\nqueue = [1]\ncount = n\nfor i in range(1, n+1):\n    if dl[i]!=1:\n        queue = [i]\n        for x in queue:\n            count -= 1\n            dl[x] = 1\n            for v in g[x]:\n                if dl[v]!=1:\n                    queue.append(v)\n\n        cl.append(list(queue))\n\nres = (n**k)%(10**9+7)\n\nfor x in cl:\n    t = len(x)\n    t = (t**k)%(10**9+7)\n    res-=t\n\nprint(res%(10**9+7))"
        },
        {
            "language": 3,
            "solution": "\ndef dfs(x, p):\n    vertex = 1\n    vis[x] = True\n    for i in graph[x].keys():\n        if not vis[i]:\n            vertex += dfs(i, x)\n    return vertex\n\n\nn, k = map(int, input().split())\nanswer = pow(n, k)\nvis = [False for _ in range(n+1)]\ngraph = [{} for _ in range(n+1)]\ndark_edges = 0\nfor _ in range(1, n):\n    u, v, x = map(int, input().split())\n    if not x:\n        graph[u][v] = x\n        graph[v][u] = x\n    else:\n        dark_edges += 1\ntemp = 0\nif dark_edges:\n    for i in range(1, n+1):\n        if not vis[i]:\n            temp += pow(dfs(i, -1), k)\n    print((pow(n, k) - temp) % (pow(10, 9) + 7))\nelse:\n    print(0)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nusing max_pq = priority_queue<T>;\ntemplate <class T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\nint oo = 0x3f3f3f3f;\nlong long n, k;\nvector<vector<pair<int, int>>> graph;\nvector<int> redGroups;\nset<int> visited;\nint dfs(int curr) {\n  int size = 1;\n  visited.insert(curr);\n  for (int i = 0; i < graph[curr].size(); i++) {\n    if (graph[curr][i].second == 0 &&\n        visited.find(graph[curr][i].first) == visited.end()) {\n      size += dfs(graph[curr][i].first);\n    }\n  }\n  return size;\n}\nclass CEdgyTrees {\n public:\n  void solve(istream& cin, ostream& cout) {\n    graph.clear();\n    redGroups.clear();\n    cin >> n >> k;\n    for (int i = 0; i < n; i++) {\n      vector<pair<int, int>> tmp;\n      graph.push_back(tmp);\n    }\n    for (int i = 0; i < n - 1; i++) {\n      int u, v, x;\n      cin >> u >> v >> x;\n      u--;\n      v--;\n      graph[u].push_back(make_pair(v, x));\n      graph[v].push_back(make_pair(u, x));\n    }\n    for (int i = 0; i < n; i++) {\n      if (visited.find(i) == visited.end()) {\n        redGroups.push_back(dfs(i));\n      }\n    }\n    long long ans = 1;\n    for (int i = 0; i < k; i++) {\n      ans = ((ans % 1000000007ll) * n) % 1000000007ll;\n    }\n    for (int i = 0; i < redGroups.size(); i++) {\n      if (redGroups[i] == 1) {\n        ans--;\n      } else {\n        int x = 1;\n        for (int j = 0; j < k; j++) {\n          x = ((x % 1000000007ll) * (redGroups[i] % 1000000007ll)) %\n              1000000007ll;\n        }\n        ans -= x;\n        if (ans < 0) ans += 1000000007ll;\n      }\n    }\n    cout << ans;\n  }\n};\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  CEdgyTrees solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "// Created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class C\n{\n    private static final long MOD=1000000007;\n    private static int vis[];\n    private static ArrayList<Pair>[] edge;\n    private static ArrayDeque<Integer> DQ;\n    static class Pair\n    {\n        int a,b;\n        Pair(int a, int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n\n    private static long DFS(int i)\n    {\n        int count=1,v,x;\n        vis[i]=1;\n\n        for(Pair obj:edge[i])\n        {\n            v=obj.a;\n            x=obj.b;\n\n            if(vis[v]==0)\n            {\n                if(x==1)\n                    DQ.add(v);\n                else\n                    count+=DFS(v);\n            }\n        }\n\n        return count;\n    }\n\n    private static long pow(long x, long a)\n    {\n            if(a==0)\n                return 1;\n            long ans=pow(x,a/2);\n\n            ans=(ans*ans)%MOD;\n\n            if((a&1)==1)\n                ans=(ans*x)%MOD;\n\n            return ans%MOD;\n    }\n\n    private static long pow2(long a, long b)\n    {\n        a%=MOD;\n        b%=MOD-1;\n        \n        long res=1;\n    \n        while(b>0)\n        {\n            if((b&1)==1)\n                res=(res*a)%MOD;\n    \n            a=(a*a)%MOD;\n            b>>=1;\n        }\n    \n        return res%MOD;\n    }\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N,k,u,v,x;\n        long count=0,tmp,tmp2,total;\n\n        String s[]=br.readLine().trim().split(\" \");\n        N=Integer.parseInt(s[0]);\n        k=Integer.parseInt(s[1]);\n\n        vis=new int[N+1];\n        edge=new ArrayList[N+1];\n        DQ=new ArrayDeque<>();\n        for(i=0;i<=N;i++)\n            edge[i]=new ArrayList<>();\n\n        total=pow2(N,k);\n\n        for(i=1;i<=N-1;i++)\n        {\n            s=br.readLine().trim().split(\" \");\n            u=Integer.parseInt(s[0]);\n            v=Integer.parseInt(s[1]);\n            x=Integer.parseInt(s[2]);\n\n            edge[u].add(new Pair(v,x));\n            edge[v].add(new Pair(u,x));\n        }\n\n        DQ.add(1);\n        while(!DQ.isEmpty())\n        {\n            tmp=DFS(DQ.poll());\n            tmp2=pow2(tmp,k);\n            count=(count+tmp2)%MOD;\n        }\n\n        total-=count;\n        while(total<0)\n            total+=MOD;\n\n        System.out.println(total);\n    }\n\n    \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nlong long powe(long long n, long long p) {\n  if (p == 0) {\n    return 1;\n  }\n  if (p % 2) {\n    return (n * powe(n, p - 1)) % mod;\n  } else {\n    return powe((n * n) % mod, p / 2);\n  }\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n, k, val = 0;\n  cin >> n >> k;\n  vector<vector<long long>> adj_list(n + 1);\n  for (long long i = 0; i < n - 1; i++) {\n    long long ui, vi, xi;\n    cin >> ui >> vi >> xi;\n    if (xi == 0) {\n      adj_list[ui].push_back(vi);\n      adj_list[vi].push_back(ui);\n    }\n  }\n  vector<bool> seen(n + 1, false);\n  for (long long i = 1; i <= n; i++) {\n    if (seen[i]) {\n      continue;\n    }\n    long long nr = 0;\n    queue<long long> pending;\n    pending.push(i);\n    seen[i] = true;\n    nr++;\n    while (!pending.empty()) {\n      long long curr = pending.front();\n      pending.pop();\n      for (auto el : adj_list[curr]) {\n        if (seen[el]) {\n          continue;\n        }\n        pending.push(el);\n        seen[el] = true;\n        nr++;\n      }\n    }\n    val = (val + powe(nr, k)) % mod;\n  }\n  cout << (powe(n, k) - val + mod) % mod << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CEdgyTrees solver = new CEdgyTrees();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CEdgyTrees {\n        int mod = 1000000007;\n        boolean[] vis;\n        List[] g;\n        int c = 0;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n\n            g = new List[n];\n\n\n            for (int i = 0; i < n; i++) {\n                g[i] = new ArrayList();\n            }\n            for (int i = 0; i < n - 1; i++) {\n                int u = in.nextInt();\n                int v = in.nextInt();\n\n                u--;\n                v--;\n\n                int w = in.nextInt();\n\n                if (w == 0) {\n                    g[u].add(v);\n                    g[v].add(u);\n                }\n            }\n\n//        SparseTableLca sparseTableLca = new SparseTableLca(g, new SparseTableLca.node(0, -1));\n//\n//        long[][][] dp = new long[n][k][2];\n//\n//        for (int i = 0; i < n; i++) {\n//            dp[i][0][0] = 1;\n//        }\n//\n//        for (int i = 1; i < k; i++)\n//        {\n//            for (int j = 0; j < n; j++)\n//            {\n//                //inc\n//\n//            }\n//        }\n\n            vis = new boolean[n];\n            long cans = 0;\n            for (int i = 0; i < n; i++) {\n                if (!vis[i]) {\n                    c = 0;\n                    dfs(i, -1);\n                    cans += pow(c, k, mod);\n                    cans %= mod;\n                }\n            }\n\n            long ans = pow(n, k, mod);\n\n            ans -= cans;\n\n            ans %= mod;\n\n            if (ans < 0) {\n                ans += mod;\n            }\n\n            out.println(ans);\n\n        }\n\n        long pow(long a, long p, int mod) {\n            if (p == 0) {\n                return 1;\n            }\n\n            long t = pow(a, p / 2, mod);\n\n            if (p % 2 != 0) {\n                return (((t * t) % mod) * a) % mod;\n            } else {\n                return (t * t) % mod;\n            }\n        }\n\n        void dfs(int u, int p) {\n            c++;\n            vis[u] = true;\n            for (int i = 0; i < g[u].size(); i++) {\n                int v = (int) g[u].get(i);\n\n                if (v != p) {\n                    dfs(v, u);\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 1e5 + 10, MOD = 1e9 + 7;\nint n, k, cnt, sum, ans;\nint head[MAXN];\nbool vis[MAXN];\nstruct Edge {\n  int link, color, to;\n} edge[MAXN << 1];\ninline void add(int u, int v, int c) {\n  edge[++sum] = (Edge){v, c, head[u]}, head[u] = sum;\n  return;\n}\ninline int qpow(int a, int b) {\n  int ans = 1;\n  for (; b; a = 1LL * a * a % MOD, b >>= 1)\n    if (b & 1) ans = 1LL * ans * a % MOD;\n  return ans;\n}\nvoid dfs(int u, int fa) {\n  ++cnt, vis[u] = true;\n  for (int i = head[u]; i; i = edge[i].to) {\n    int v = edge[i].link, c = edge[i].color;\n    if (!c && v != fa) dfs(v, u);\n  }\n  return;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1, u, v, c; i < n; ++i) {\n    scanf(\"%d%d%d\", &u, &v, &c);\n    add(u, v, c), add(v, u, c);\n  }\n  for (int i = 1; i <= n; ++i)\n    if (!vis[i]) cnt = 0, dfs(i, i), (ans += qpow(cnt, k)) %= MOD;\n  printf(\"%d\\n\", (qpow(n, k) - ans + MOD) % MOD);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class edgytrees {\n    public static void main(String[] args) {\n        FastScanner in = new FastScanner(System.in);\n        int n = in.nextInt();\n        long k = in.nextInt();\n        long mod = 1000000007;\n\n        ArrayList<Edge>[] graph = new ArrayList[n];\n\n        for(int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for(int i = 0; i < n-1; i++) {\n            int u = in.nextInt()-1;\n            int v = in.nextInt()-1;\n            int c = in.nextInt();\n\n            graph[u].add(new Edge(v,c));\n            graph[v].add(new Edge(u,c));\n        }\n\n        long total = pow(n,k,mod);\n\n        boolean[] vis = new boolean[n];\n        for(int i = 0; i < n; i++) {\n            if(vis[i])\n                continue;\n            Queue<Integer> q = new LinkedList<>();\n            q.add(i);\n            long size = 0;\n\n            while(!q.isEmpty()) {\n                int at = q.poll();\n                if(vis[at])\n                    continue;\n                vis[at] = true;\n                size++;\n                for(Edge node : graph[at]) {\n                    if(!vis[node.to] && node.color != 1) {\n                        q.add(node.to);\n                    }\n                }\n            }\n            total = ((total-pow(size,k,mod) % mod)+mod)%mod;\n        }\n        System.out.println(total);\n\n    }\n    static long pow(long x, long y, long p) {\n        long res = 1;\n        x = x % p;\n\n        if (x == 0)\n            return 0;\n\n        while (y > 0) {\n            if((y & 1)==1)\n                res = (res * x) % p;\n\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    static class Edge {\n        int to, color;\n        public Edge(int to, int color) {\n            this.to = to;\n            this.color = color;\n        }\n    }\n\n\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        boolean isEndline(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        String nextLine() {\n            int c = read();\n            while (isEndline(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndline(c));\n            return res.toString();\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> g[100005];\nlong long bigmod(long long a, long long b, long long c) {\n  if (b == 0) return 1;\n  if (b % 2 == 0) {\n    long long x = bigmod(a, b / 2, c);\n    return (x * x) % c;\n  } else\n    return (a % c * bigmod(a, b - 1, c)) % c;\n}\nbool vis[100005];\nlong long bfs(int st) {\n  queue<long long> q;\n  q.push(st);\n  vis[st] = 1;\n  long long cn = 1;\n  while (!q.empty()) {\n    long long u = q.front();\n    q.pop();\n    long long sz = g[u].size();\n    for (int i = 0; i < sz; i++) {\n      long long x = g[u][i];\n      if (!vis[x]) {\n        cn++;\n        vis[x] = 1;\n        q.push(x);\n      }\n    }\n  }\n  return cn;\n}\nint main() {\n  long long n, i, j, k;\n  scanf(\"%lld\", &n), scanf(\"%lld\", &k);\n  for (i = 0; i < n - 1; i++) {\n    long long u, v, x;\n    scanf(\"%lld\", &u), scanf(\"%lld\", &v), scanf(\"%lld\", &x);\n    if (x == 0) {\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n  }\n  long long ans = bigmod(n, k, 1000000007);\n  long long red = 0;\n  for (long long p = 1; p <= n; p++) {\n    if (!vis[p]) {\n      long long white = bfs(p);\n      red = ((red % 1000000007) + (bigmod(white, k, 1000000007) % 1000000007)) %\n            1000000007;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) red = ((red % 1000000007) - (1 % 1000000007)) % 1000000007;\n  }\n  ans %= 1000000007;\n  red %= 1000000007;\n  ans -= red;\n  ans %= 1000000007;\n  if (ans < 0) ans = 1000000007 + ans;\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\n\n\ndef dfs(u):\n    st = [u]\n    id = u\n    while st:\n        u = st.pop()\n        if cv[u]:\n            continue\n        cv[u] = 1\n        count[id] += 1\n        for nxt, w in adj[u]:\n            if w == 1:\n                continue\n            st.append(nxt)\n\n\nn, k = [int(item) for item in input().split()]\n\nadj = defaultdict(list)\nvs = []\n\nfor i in range(n - 1):\n    u, v, w = [int(item) for item in input().split()]\n    adj[u].append([v, w])\n    adj[v].append([u, w])\n    if w == 1:\n        vs.append([u, v])\ncount = {key: 0 for key in range(1, n + 1)}\ncv = [0] * (n + 1)\nccs = []\nfor i in range(1, n + 1):\n    if not cv[i]:\n        dfs(i)\n        ccs.append(count[i])\nans = pow(n, k, MOD)\nfor x in ccs:\n    ans = (ans - pow(x, k, MOD) + MOD) % MOD\n\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5;\nconst long long MOD = 1e9 + 7;\nlong long pow(long long a, long long b, long long m) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % m;\n    b /= 2;\n    a = (a * a) % m;\n  }\n  return ans;\n}\nlong long n, k, sz, ans = 0;\nbool vis[N];\nvector<long long> g[N];\nvoid dfs(long long u) {\n  if (vis[u]) return;\n  sz++;\n  vis[u] = 1;\n  for (auto &it : g[u]) dfs(it);\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> n >> k;\n  long long ans = pow(n, k, MOD);\n  for (long long i = 1; i <= n - 1; i++) {\n    long long u, v, x;\n    cin >> u >> v >> x;\n    if (x == 0) g[u].push_back(v), g[v].push_back(u);\n  }\n  for (long long i = 1; i <= n; i++) {\n    if (vis[i]) continue;\n    sz = 0;\n    dfs(i);\n    ans -= pow(sz, k, MOD);\n    ans += MOD;\n    ans %= MOD;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "mod=10**9+7\ndef dfs(v,vis):\n    cnt=1\n    st=[]\n    st.append(v)\n    while(st):\n        x=st.pop()\n        for i in g[x]:\n            if vis[i[0]]==0 and i[1]==0:\n                vis[i[0]]=1\n                cnt+=1\n                st.append(i[0])\n    return cnt\nn,k=map(int,input().split())\ng=[[] for i in range(n)]\nfor i in range(n-1):\n    x,y,z=map(int,input().split())\n    x-=1;y-=1\n    g[x].append([y,z])\n    g[y].append([x,z])\nvis=[0]*n\nres=pow(n,k,mod)\nfor i in range(n):\n    if vis[i]==0:\n        vis[i]=1\n        tmp=dfs(i,vis)\n        res=(res%mod-pow(tmp,k,mod))%mod\nprint(res)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class EdgyTrees {\n\tstatic final long M = (long) Math.pow(10, 9) + 7;\n\tpublic static void main (String [] args) throws IOException{\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tStringTokenizer st = new StringTokenizer(in.readLine());\n\t\t\t\n\t\t\t\n\t\t\tint n = Integer.parseInt(st.nextToken());\n\t\t\tint k = Integer.parseInt(st.nextToken());\n\t\t\tNode [] nod = new Node [n];\n\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t\tnod[i] = new Node();\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\tint u = Integer.parseInt(st.nextToken()) - 1;\n\t\t\t\tint v = Integer.parseInt(st.nextToken()) - 1;\n\t\t\t\tint x = Integer.parseInt(st.nextToken());\n\t\t\t\tif (x == 0) {\n\t\t\t\t\tnod[u].rcon.add(nod[v]);\n\t\t\t\t\tnod[v].rcon.add(nod[u]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong ans = pow (n, k);\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (nod[i].group == false) {\n\t\t\t\t\tans -= pow(form(nod[i]), k);\n\t\t\t\t\tans %= M;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans < 0)\n\t\t\t\tSystem.out.println(ans + M);\n\t\t\telse\n\t\t\t\tSystem.out.println(ans);\n\t}\n\tpublic static long pow (long a, long b) {\n\t\tlong p = 1;\n\t\tfor (int i = 0; i < b; i++) \n\t\t\tp = (p * a) % M;\n\t\treturn p;\n\t}\n\tpublic static int form (Node n) {\n\t\tn.group = true;\n\t\tint size = 1;\n\t\tfor (Node newNode: n.rcon) {\n\t\t\tif (newNode.group == false)\n\t\t\t\tsize += form(newNode);\n\t\t}\n\t\treturn size;\n\t}\n\tstatic class Node {\n\t\tboolean group = false;\n\t\tArrayList<Node> rcon = new ArrayList<Node>();\n\t\t\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class edgytrees {\n    static final int MOD = (int) (Math.pow(10, 9) + 7);\n    public static void main(String[] args) {\n       Scanner in = new Scanner(System.in);\n       int N = in.nextInt();\n       int k = in.nextInt();\n       long total = modExponentiate(N, k);\n       DisjointUnionSets set = new DisjointUnionSets(N);\n       for (int i = 0; i < N-1; i++) {\n           int a = in.nextInt()-1;\n           int b = in.nextInt() - 1;\n           int decider = in.nextInt();\n           if (decider == 0) {\n               set.union(a, b);\n           }\n       }\n       for (int i = 0; i < N; i++) {\n           if (set.parent[i] == i) {\n               total -= modExponentiate(set.rank[i], k);\n           }\n       }\n       while (total < 0) {\n           total += MOD;\n       }\n       System.out.println(total);\n    }\n    public static long modExponentiate(int base, int power) {\n        long val = 1;\n        while (power > 0) {\n            val *= base;\n            val %= MOD;\n            power--;\n        }\n        return val;\n    }\n    static class DisjointUnionSets {\n        int[] rank, parent;\n        int n;\n        int size;\n\n        // Constructor\n        public DisjointUnionSets(int n) {\n            size = n;\n            rank = new int[n];\n            parent = new int[n];\n            this.n = n;\n            makeSet();\n        }\n\n        // Creates n sets with single item in each\n        void makeSet() {\n            for (int i = 0; i < n; i++) {\n                // Initially, all elements are in\n                // their own set.\n                parent[i] = i;\n                rank[i] = 1;\n            }\n        }\n\n        // Returns representative of x's set\n        int find(int x) {\n            // Finds the representative of the set\n            // that x is an element of\n            if (parent[x] != x) {\n                // if x is not the parent of itself\n                // Then x is not the representative of\n                // his set,\n                parent[x] = find(parent[x]);\n\n                // so we recursively call Find on its parent\n                // and move i's node directly under the\n                // representative of this set\n            }\n\n            return parent[x];\n        }\n\n        // Unites the set that includes x and the set\n        // that includes x\n        void union(int x, int y) {\n            // Find representatives of two sets\n            int xRoot = find(x), yRoot = find(y);\n\n            // Elements are in the same set, no need\n            // to unite anything.\n            if (xRoot == yRoot)\n                return;\n            rank[xRoot] = rank[xRoot]+rank[yRoot];\n\n            // If x's rank is less than y's rank\n            if (rank[xRoot] < rank[yRoot])\n\n                // Then move x under y  so that depth\n                // of tree remains less\n                parent[xRoot] = yRoot;\n\n                // Else if y's rank is less than x's rank\n            else if (rank[yRoot] < rank[xRoot])\n\n                // Then move y under x so that depth of\n                // tree remains less\n                parent[yRoot] = xRoot;\n\n            else // if ranks are the same\n            {\n                // Then move y under x (doesn't matter\n                // which one goes where)\n                parent[yRoot] = xRoot;\n\n                // And increment the the result tree's\n                // rank by 1\n            }\n            size--;\n\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom collections import defaultdict, deque\n\nlength = sys.stdin.readline().strip().split(\" \")\nn, k = map(int, length)\n\ngraph = defaultdict(list)\nfor _ in range(int(n - 1)):\n\tline = sys.stdin.readline().strip().split(\" \")\n\tif int(line[2]) == 0:\n\t\tgraph[int(line[0])].append(int(line[1]))\n\t\tgraph[int(line[1])].append(int(line[0]))\n\telse:\n\t\tif (int(line[0])) not in graph:\n\t\t\tgraph[int(line[0])] = []\n\t\tif (int(line[1])) not in graph:\n\t\t\tgraph[int(line[1])] = []\n\nvisited = set()\n\ndef bfs(graph, visited):\n\tqueue = deque()\n\tgraph_parts_sizes = []\n\tfor vertex in graph:\n\t\tif vertex in visited:\n\t\t\tcontinue\n\n\t\tprev_size = len(visited)\n\t\tqueue.append(vertex)\n\t\twhile len(queue) != 0:\n\t\t\tvertex = queue.popleft()\n\t\t\tvisited.add(vertex)\n\t\t\tfor neighbour in graph[vertex]:\n\t\t\t\tif neighbour not in visited:\n\t\t\t\t\tqueue.append(neighbour)\n\t\tgraph_parts_sizes.append(len(visited) - prev_size)\n\treturn graph_parts_sizes\n\nparts_size = bfs(graph, visited)\nMODULO = int(1e9 + 7)\n\nanswer = (n ** k) % MODULO\nfor size in parts_size:\n\tanswer -= (size ** k) % MODULO\n\tanswer %= MODULO\nprint(answer % MODULO)"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nimport javax.swing.text.InternationalFormatter;\n\nimport java.math.*;\n\nimport org.omg.CORBA.Any;\n\npublic class template {\n\n\tstatic int ans = 0, mp = Integer.MAX_VALUE, k = 0, cnt=0;;\n\t\n\tstatic int[][]a;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t\n\t\tReader scn = new Reader();\n\t\t \n\t\t int n=scn.nextInt(), k=scn.nextInt();\n\t\t \n\t\t ArrayList<pair>[]a=new ArrayList[n+1];\n\t\t \n\t\t for(int i=0; i<a.length; i++)\n\t\t\t a[i]=new ArrayList<pair>();\n\t\t \n\t\t for(int i=0; i<n-1; i++){\n\t\t\t  int u=scn.nextInt(), v=scn.nextInt(), w=scn.nextInt();\n\t\t\t  a[u].add(new pair(v,w));\n\t\t\t  a[v].add(new pair(u,w));\n\t\t }\n\t\t \n\t\t \n\t\t \n\t\t HashSet<Integer> visited=new HashSet<>();\n\t\t ArrayList<Integer> p=new ArrayList<>();\n\t\t \n\t\t for(int i=1; i<=n; i++){\n\t\t\t cnt=0;\n\t\t\t \n\t\t\t if(!visited.contains(i))\n\t\t\t   dfs(i,a,visited);\n\t\t\t \n\t\t\t if(cnt != 0)\n\t\t\t p.add(cnt);\n\t\t }\n\t\t \n\t\t long ans=power(n, k, (long) (1e9+7));\n\t\t long a2=0;\n\t\t for(int i:p){\n\t\t\ta2+= power(i,k,(long) (1e9+7));\n\t\t }\n\t\t a2=a2%(long)(1e9+7);\n\t\t \n\t\t System.out.println((-a2+ans+(long)1e9+7)%(long) (1e9+7));\n\t\t \n\t\t \n\n\t}\n\n\tprivate static void dfs(int v,ArrayList<pair>[] a, HashSet<Integer> visited) {\n          \t\n\t\tcnt++;\n\t\t  visited.add(v);\n\t\t  \n\t\t  for(pair nbr:a[v]){\n\t\t\t  \n\t\t\t   if(!visited.contains(nbr.v) && nbr.w  == 0)\n\t\t\t\t    dfs(nbr.v, a, visited);\n\t\t  }\n\t}\n\t\n\tpublic static long power(long x, long y, long p) \n\t{ \n\t    long res = 1;      // Initialize result \n\t  \n\t    x = x % p;  // Update x if it is more than or  \n\t                // equal to p \n\t  \n\t    while (y > 0) \n\t    { \n\t        // If y is odd, multiply x with result \n\t        if ( (y & 1 )== 1) \n\t            res = (res*x) % p; \n\t  \n\t        // y must be even now \n\t        y = y>>1; // y = y/2 \n\t        x = (x*x) % p;   \n\t    } \n\t    return res; \n\t} \n\n\t// _________________________TEMPLATE_____________________________________________________________\n\n\n\n\tstatic class pair implements Comparable<pair> {\n\t\tint v;\n\t\tint w;\n//\t\tint cnt;\n\n\t\tpair(int b, int a) {\n\t\t\tv = b;\n\t\t\tw = a;\n//\t\t\tcnt = x;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\n\t\t\t return this.v -o.v;\n\t\t}\n\t}\n\n\t// -----------PrintWriter for faster output---------------------------------\n\tpublic static PrintWriter out;\n\n\tpublic static class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[100000 + 1]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic int[][] nextInt2DArray(int m, int n) throws IOException {\n\t\t\tint[][] arr = new int[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tarr[i][j] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t}\n\n\t// private static void rem(HashMap<Integer, Integer> hm) {\n\t//\n\t// Iterator<Map.Entry<Integer, Integer>> itr = hm.entrySet().iterator();\n\t// ArrayList<Integer> p=new ArrayList<>();\n\t//\n\t//\n\t// while(itr.hasNext()){\n\t// Map.Entry<Integer, Integer> entry = itr.next();\n\t// p.add(entry.getKey());\n\t//\n\t// }\n\t//\n\t//\n\t// for(int i:p){\n\t//\n\t// if(hm.get(i)>1)\n\t// hm.put(i, hm.get(i)-1);\n\t// else\n\t// hm.remove(i);\n\t// }\n\t// }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n    static Scanner in = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n    static int parent[];\n    static int size[];\n    static long MOD = (long) 1e9 + 7;\n    static Random rand = new Random();\n\n    static void makeSet (int u) {\n        parent[u] = u;\n        size[u] = 1;\n    }\n\n    static int findSet (int u) {\n        if (u == parent[u]) return u;\n        parent[u] = findSet(parent[u]);\n        return parent[u];\n    }\n\n    static void unionSet (int u, int v) {\n        int parentU = findSet(u);\n        int parentV = findSet(v);\n        if (parentU != parentV) {\n            if (size[parentU] < size[parentV]) {\n                parent[parentU] = parentV;\n                size[parentV] += size[parentU];\n            } else {\n                parent[parentV] = parentU;\n                size[parentU] += size[parentV];\n            }\n        }\n    }\n\n    static long fast_pow (long base, long exponent) {\n        if (exponent == 0) {\n            return 1;\n        }\n        long mid = fast_pow(base, exponent / 2);\n        if (exponent % 2 == 0) {\n            return mid * mid % MOD;\n        } else {\n            return mid * mid % MOD * base % MOD;\n        }\n    }\n\n    public static void main(String[] args) {\n        int n = in.nextInt();\n        int k = in.nextInt();\n\n        parent = new int[n];\n        size = new int[n];\n        for (int i = 0; i < n; i++) {\n            makeSet(i);\n        }\n\n        for (int i = 0; i < n - 1; i++) {\n            int u = in.nextInt() - 1;\n            int v = in.nextInt() - 1;\n            int color = in.nextInt();\n            if (color == 0) {\n                unionSet(u, v);\n            }\n        }\n\n        // get unique parent\n        TreeSet<Integer> uniqueParent = new TreeSet<>();\n        for (int i = 0; i < n; i++) {\n            uniqueParent.add(findSet(i));\n        }\n\n        Object uniqueParentList[] = uniqueParent.toArray();\n        // count inverse graph\n        long inverseGraph = 0;\n        for (Object uParent : uniqueParentList) {\n            inverseGraph = (inverseGraph + fast_pow(size[(Integer)uParent], k)) % MOD;\n            // out.println(\"unique Parent: \" + ((Integer)uParent + 1));\n        }\n\n        // for (int i = 0; i < n; i++) {\n        //     out.println(\"i: \" + (i + 1) + \" parent: \" + (findSet(i) + 1) + \" size: \" + size[i]);\n        // }\n\n        long sum = fast_pow(n, k);\n        sum = (sum - inverseGraph + MOD) % MOD;\n\n        out.println(sum);\n\n        in.close();\n        out.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int dp[2010][2010];\nvector<long long int> adj[100010];\nlong long int parent[100010];\nlong long int Size[100010];\nlong long int power(long long int x, long long int y, long long int p) {\n  long long int res = 1;\n  x = x % p;\n  if (x == 0) return 0;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nlong long int find(long long int x) {\n  if (x == parent[x])\n    return x;\n  else\n    return parent[x] = find(parent[x]);\n}\nvoid merge_edge(long long int x, long long int y, long long int z) {\n  x = find(x);\n  y = find(y);\n  if (x != y) {\n    if (Size[x] < Size[y]) swap(x, y);\n    parent[y] = x;\n    Size[x] += Size[y];\n    Size[x] %= 1000000007;\n  }\n}\nint32_t main() {\n  long long int n, i, j;\n  long long int k;\n  cin >> n >> k;\n  for (i = 1; i <= n; i++) {\n    parent[i] = i;\n    Size[i] = 1;\n  }\n  for (i = 0; i < n - 1; i++) {\n    long long int x, y, z;\n    cin >> x >> y >> z;\n    if (z == 1) {\n    } else {\n      merge_edge(x, y, 0);\n    }\n  }\n  long long int ans = power(n, k, 1000000007);\n  for (i = 1; i <= n; i++) {\n    if (parent[i] == i) {\n      ans -= power(Size[i], k, 1000000007);\n      ans = (ans + 1000000007) % 1000000007;\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    private final long MODULO = (long) 1e9 + 7;\n    private int N, K;\n    private long count;\n    private ArrayList<ArrayList<NodeInfo>> tree;\n    private boolean[] visited;\n\n    protected Solution(InputReader in) {\n        N = in.nextInt();\n        K = in.nextInt();\n        tree = new ArrayList<ArrayList<NodeInfo>>(N);\n        for (int j = 0; j < N; j++) {\n            tree.add(new ArrayList<NodeInfo>());\n        }\n        for (int j = 0; j < N - 1; j++) {\n            int a = in.nextInt(), b = in.nextInt(), color = in.nextInt();\n            a--; b--;\n            tree.get(a).add(new NodeInfo(b, color));\n            tree.get(b).add(new NodeInfo(a, color));\n        }\n    }\n\n    private long modPow(int a, int b) {\n        long p = 1;\n        for (int j = 0; j < b; j++) {\n            p = (p * a) % MODULO;\n        }\n        return p;\n    }\n\n    private int dfs(int current) {\n        visited[current] = true;\n        int size = 1;\n        for (NodeInfo next: tree.get(current)) {\n            if (!visited[next.node] && next.color == 0) {\n                size += dfs(next.node);\n            }\n        }\n        return size;\n    }\n\n    public long solve() {\n        count = 0;\n        visited = new boolean[N];\n        for (int j = 0; j < N; j++) {\n            if (!visited[j]) {\n                int cs = dfs(j);\n                count = (count + modPow(cs, K)) % MODULO;\n            }\n        }\n        return (modPow(N, K) + MODULO - count) % MODULO;\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        Solution solution = new Solution(in);\n        out.println(solution.solve());\n        out.close();\n    }\n\n}\n\nclass NodeInfo {\n    int node, color;\n\n    public NodeInfo(int node, int color) {\n        this.node = node;\n        this.color = color;\n    }\n}\n\nclass InputReader {\n\n    private static final int BUFFER_SIZE = 1<<16;\n\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), BUFFER_SIZE);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long inf = 1000000000000000009;\nlong long p = 1000000000 + 7;\nvoid visit(int node, vector<vector<int> > &edges, vector<int> &visited,\n           int &compsize) {\n  visited[node] = 1;\n  compsize++;\n  for (int nbi = 0; nbi < edges[node].size(); nbi++) {\n    int nb = edges[node][nbi];\n    if (not visited[nb]) visit(nb, edges, visited, compsize);\n  }\n}\nlong long fastexp(long long a, long long k) {\n  long long res = 1;\n  if (k % 2 == 1) {\n    res = (a * res) % p;\n    k--;\n  }\n  if (k == 0) return res;\n  long long root = fastexp(a, k / 2);\n  res = (res * root) % p;\n  res = (res * root) % p;\n  return res;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int> > edges(n);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    u--;\n    v--;\n    if (x == 1) continue;\n    edges[u].push_back(v);\n    edges[v].push_back(u);\n  }\n  vector<int> visited(n, 0);\n  vector<int> comps;\n  for (int i = 0; i < n; i++) {\n    if (visited[i]) continue;\n    int compsize = 0;\n    visit(i, edges, visited, compsize);\n    comps.push_back(compsize);\n  }\n  long long res = 0;\n  res += fastexp(n, k);\n  for (int compnum = 0; compnum < comps.size(); compnum++) {\n    int compsize = comps[compnum];\n    long long subst = fastexp(compsize, k);\n    res = (res + p - subst) % p;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 9;\nvector<vector<int> > graph;\nint vis[maxn];\nint dfs(int node) {\n  vis[node] = true;\n  int answer = 1;\n  for (auto child : graph[node]) {\n    if (vis[child]) continue;\n    answer += dfs(child);\n  }\n  return answer;\n}\nlong long binexp(long long a, int b) {\n  long long temp = 1;\n  while (b > 0) {\n    if (b & 1) temp = (temp * a) % mod;\n    a = (a * a) % mod;\n    b /= 2;\n  }\n  return temp;\n}\nvoid test_case(int tc) {\n  int n, k;\n  cin >> n >> k;\n  int m = n - 1;\n  graph.resize(n + 1);\n  for (int i = 1; i <= m; ++i) {\n    int u, v, b;\n    cin >> u >> v >> b;\n    if (b == 1) continue;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (vis[i]) {\n      continue;\n    }\n    long long p = dfs(i);\n    ans += (binexp(p, k));\n    ans %= mod;\n  }\n  long long answer = binexp(n, k);\n  answer = (answer - ans + mod) % mod;\n  cout << answer;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n  int t = 1;\n  for (int tc = 1; tc <= t; ++tc) test_case(tc);\n}\n"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport io\nimport os\nimport sys\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from cStringIO import StringIO\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    from io import BytesIO as StringIO\n\nsys.stdout, stream = io.IOBase(), StringIO()\nsys.stdout.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\nsys.stdout.write = stream.write if sys.version_info[0] < 3 else lambda s: stream.write(s.encode())\n\ninput, flush = sys.stdin.readline, sys.stdout.flush\ninput = StringIO(os.read(0, os.fstat(0).st_size)).readline\n\nMOD = 10 ** 9 + 7\n\n\ndef connected_components(n, graph):\n    components, visited = [], [False] * n\n\n    def dfs(start):\n        component, stack = [], [start]\n\n        while stack:\n            start = stack[-1]\n\n            if visited[start]:\n                stack.pop()\n                continue\n            else:\n                visited[start] = True\n                component.append(start)\n\n            for i in graph[start]:\n                if not visited[i]:\n                    stack.append(i)\n\n        return component\n\n    for i in range(n):\n        if not visited[i]:\n            components.append(dfs(i))\n\n    return components\n\n\ndef main():\n    n, k = map(int, input().split())\n\n    red_graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v, x = map(int, input().split())\n        if x == 0:\n            red_graph[u - 1].append(v - 1)\n            red_graph[v - 1].append(u - 1)\n\n    sol = pow(n, k, MOD) - sum(len(x) ** k for x in connected_components(n, red_graph))\n    print(sol % MOD)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod_pow(long long a, long long b, long long mod) {\n  long long res = 1, c = a;\n  while (b) {\n    if (b & 1) res = res * c % mod;\n    c = c * c % mod;\n    b /= 2;\n  }\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int>> ad(n);\n  for (int i = 0; i < n - 1; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    if (c == 1) continue;\n    a--, b--;\n    ad[a].push_back(b);\n    ad[b].push_back(a);\n  }\n  long long mod = 1000000007;\n  vector<bool> ju(n);\n  int prev = -1;\n  int count = 0;\n  long long ren = 0;\n  function<void(int, int)> dfs = [&](int cur, int par) {\n    ju[cur] = true;\n    for (int ch : ad[cur]) {\n      if (ch == par) continue;\n      if (ju[ch]) continue;\n      dfs(ch, cur);\n    }\n    ren++;\n    count++;\n  };\n  long long res = 0;\n  while (count < n) {\n    int root = 0;\n    for (int i = prev + 1; i < n; i++) {\n      if (ju[i]) continue;\n      root = i;\n      prev = root;\n      break;\n    }\n    ren = 0;\n    dfs(root, -1);\n    res = (res + mod_pow(ren, k, mod)) % mod;\n  }\n  res = (mod_pow(n, k, mod) - res + mod) % mod;\n  cout << res << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    u,v,x = map(int, input().split())\n    g[u-1].append((v-1, x))\n    g[v - 1].append((u - 1, x))\n\nv = [0 for i in range(n)]\ncomps = []\nfor i in range(n):\n    if v[i] == 1:\n        continue\n    v[i] = 1\n    comps.append([i])\n    q = [i]\n    while q:\n        u0 = q[0]\n        q = q[1:]\n        for u, x in g[u0]:\n            if x == 0 and v[u] == 0:\n                q.append(u)\n                v[u] = 1\n                comps[-1].append(u)\n\nans = n**k\n\nfor comp in comps:\n    ans -= len(comp)**k\nprint(ans%((10**9) + 7))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nlong long qpow(long long a, long long n) {\n  long long re = 1;\n  while (n) {\n    if (n & 1) re = (re * a) % mod;\n    n >>= 1;\n    a = (a * a) % mod;\n  }\n  return re % mod;\n}\nstruct edge {\n  long long to, next, w;\n} edge[200005];\nlong long head[100005], cnt, top, num, ho[100005];\nbool vis[100005];\nvoid add1(long long u, long long v) {\n  edge[++cnt].to = v;\n  edge[cnt].next = head[u];\n  head[u] = cnt;\n}\nlong long dfs(long long x) {\n  vis[x] = true;\n  num++;\n  for (long long i = head[x]; ~i; i = edge[i].next) {\n    if (!vis[edge[i].to]) dfs(edge[i].to);\n  }\n  return num;\n}\nlong long n, k;\nint main() {\n  cin >> n >> k;\n  long long u, v, x;\n  for (long long i = 1; i <= n; i++) head[i] = -1;\n  for (long long i = 1; i < n; i++) {\n    cin >> u >> v >> x;\n    if (x == 0) add1(u, v), add1(v, u);\n  }\n  for (long long i = 1; i <= n; i++) {\n    if (!vis[i]) num = 0, ho[++top] = dfs(i);\n  }\n  long long ans = qpow(n, k);\n  for (long long i = 1; i <= top; i++) {\n    long long temp = qpow(ho[i], k);\n    ans = (ans - temp + mod) % mod;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def power(x,y,n):\n    ans=1\n    while y>0 :\n        if y&1==1 :\n            ans=ans*x%n\n        x=x*x%n\n        y>>=1\n    return(ans)\n\n\n\nclass disjoint_set:\n    def __init__(self,num):\n\n        self.array=[0]+[[i,0,1] for i in range(1,num+1)]  # our set\n    \n    def union(self,a,b):\n        \n        ''' a and b are the vertices that we want to connect them to each other '''\n        \n        a=self.find(a) # finds the ancestor of a\n        b=self.find(b) # finds the ancestor of b\n    \n        if a==b:\n            # if the ancestors of a and b are the same , do nothing\n            return False\n    \n\n        # connecting two graph components to each other\n\n        if self.array[a][1] > self.array[b][1] :\n            self.array[b][0]=a\n            self.array[a][2]+=self.array[b][2]\n        \n        elif self.array[a][1] < self.array[b][1] :\n            self.array[a][0]=b\n            self.array[b][2]+=self.array[a][2]\n\n        else:\n            self.array[a][0]=b\n            self.array[b][1]+=1\n            self.array[b][2]+=self.array[a][2]\n        return True\n            \n    def find(self,a):\n        p=[]\n        while self.array[a][0]!=a :\n            p.append(a)\n            a=self.array[a][0]\n        for i in p:\n            self.array[i][0]=a\n        return a\n\n###### start #######\n\nn,k=map(int,input().split())\n\ngraph=disjoint_set(n)\nfor _ in range(n-1):\n    a,b,c=map(int,input().split())\n    if not c :\n        graph.union(a,b)\n\ns=set()\nfor i in range(1,n+1):\n    s.add(graph.find(i))\n\nans=power(n,k,1000000000+7)\nfor i in s:\n    p=graph.array[i][2]\n    ans-=(power(p,k,1000000000+7))\n\nprint(ans%(1000000000+7))\n"
        },
        {
            "language": 3,
            "solution": "# from debug import debug\nimport sys;input = sys.stdin.readline\nfrom collections import deque\nmod = int(1e9)+7\nn, k = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n-1):\n\ta, b, c = map(int, input().split())\n\tif c: continue\n\tgraph[a-1].append(b-1)\n\tgraph[b-1].append(a-1)\n\nv = [False]*n\nans = 0\nfor i in range(n):\n\tif not v[i]:\n\t\tq = deque([i])\n\t\tv[i] = True\n\t\ts = 0\n\t\twhile q:\n\t\t\tnode = q.popleft()\n\t\t\ts+=1\n\t\t\tfor j in graph[node]:\n\t\t\t\tif not v[j]: v[j] = True; q.append(j)\n\t\tans = (ans%mod + pow(s, k, mod))%mod\nprint((pow(n, k, mod)%mod - ans%mod)%mod)"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict,deque\nMOD = (10**9)+7\ndef bfs(v):\n    q.append(v)\n    visited[v]=True\n    while q:\n        s=q.popleft()\n        b.append(v)\n        for i in g[s]:\n            if not visited[i[0]] and i[1]==0:\n                q.append(i[0])\n                visited[i[0]]=True\n    \nn,k=map(int,input().split())\ng=defaultdict(list)\nfor _ in range(n-1):\n    x,y,c=map(int,input().split())\n    g[x].append((y,c))\n    g[y].append((x,c))\nvisited=[False]*(n+1)\ncount=0;ans=pow(n,k,MOD)\nq=deque()\nfor i in range(1,n+1):\n    b=[]\n    if visited[i]==False:\n        bfs(i)\n    #print(b)\n    f =len(b) \n    count=(count+pow(f,k,MOD))%MOD\n\nans=(ans-count)%MOD\nprint(ans)\n\n"
        },
        {
            "language": 3,
            "solution": "import collections\n\np = 10 ** 9 + 7\nn, k = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\n\nfor _ in range(1, n):\n    a, b, x = map(int, input().split())\n    if (x == 0):\n        graph[a].append(b)\n        graph[b].append(a)\n\nvisited = [False] * (n + 1)\nbad = 0\nqueue = collections.deque()\n\nfor i in range(1, n + 1):\n    if not visited[i]:\n        queue.append(i)\n        visited[i] = True\n\n        # calculate the size of the current connected component\n        size_connected_component = 0\n        while(queue):\n            front = queue.pop()\n            for adj_front in graph[front]:\n                if not visited[adj_front]:\n                    visited[adj_front] = True\n                    queue.append(adj_front)\n            size_connected_component += 1\n        \n        # calculate the number of bad sequence\n        bad += pow(size_connected_component, k, p)\n\nprint((pow(n, k, p)- bad) % p)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nvector<int> graph[100005];\nbool vis[100005];\nint cnt;\nlong long fastpower(int b, int p) {\n  if (p == 0) return 1;\n  long long term = fastpower(b, p / 2);\n  term = (term * term) % mod;\n  if (p % 2 == 1) {\n    term = (b * term) % mod;\n  }\n  return term;\n}\nvoid dfs(int node) {\n  if (vis[node]) return;\n  vis[node] = 1;\n  cnt++;\n  for (auto child : graph[node]) {\n    dfs(child);\n  }\n}\nint main() {\n  int nodes, edges, u, v, p, k, bad = 0, all;\n  cin >> nodes >> k;\n  edges = nodes - 1;\n  all = fastpower(nodes, k);\n  all %= mod;\n  while (edges--) {\n    cin >> u >> v >> p;\n    if (!p) {\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n  }\n  for (int i = 1; i <= nodes; i++) {\n    cnt = 0;\n    if (!vis[i]) {\n      dfs(i);\n      bad += fastpower(cnt, k);\n      bad %= mod;\n    }\n  }\n  int ans = all - bad;\n  ans %= mod;\n  while (ans < 0) ans += mod;\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint f[100005];\nlong long cnt[100005];\nlong long ans;\nlong long find(int x) {\n  if (f[x] == x) return x;\n  f[x] = find(f[x]);\n  return f[x];\n}\nvoid merge(int x, int y) {\n  int fx = find(x);\n  int fy = find(y);\n  if (fx != fy) {\n    f[fy] = fx;\n  }\n}\nlong long ksm(long long a, long long n) {\n  long long ans = 1;\n  while (n) {\n    if (n & 1) ans = ans * a % mod;\n    a = a * a % mod;\n    n = n >> 1;\n  }\n  return ans;\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    f[i] = i;\n  }\n  int x, y, w;\n  for (int i = 1; i <= n - 1; i++) {\n    cin >> x >> y >> w;\n    if (w == 0) {\n      merge(x, y);\n      cnt[x] += cnt[y];\n    }\n  }\n  for (int i = 1; i <= n; i++) cnt[find(i)]++;\n  for (int i = 1; i <= n; i++) {\n    if (f[i] == i) {\n      ans = (ans % mod + ksm(cnt[i], k) % mod) % mod;\n    }\n  }\n  cout << (ksm(n, k) + mod - ans) % mod;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,k = [int(x) for x in input().split()]\n\ngraph = {x+1: [] for x in range(n)}\n\nfor _ in range(n-1):\n    u,v,c = [int(x) for x in input().split()]\n    if c == 0:\n        graph[u].append(v)\n        graph[v].append(u)\n\n\n\nMOD = int(1e9 + 7)\n\nexplored = [False for _ in range(n+1)]\n\ndef count(u):\n    ans = 0\n    stack = [u]\n    while len(stack) > 0 :\n        u = stack.pop()\n        ans += 1\n        for v in graph[u]:\n            if not explored[v]:\n                explored[v] = True\n                stack.append(v)\n    return ans\n\ninvalid = 0\n\nfor i in range(1,n+1):\n    if not explored[i]:\n        explored[i] = True\n        c = count(i)\n        invalid += pow(c,k,MOD)\n        invalid %= MOD\n\nans = (MOD + (pow(n,k,MOD) - invalid))%MOD\n\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskC solver = new TaskC();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskC extends ChelperSolution {\n    LongMod MOD = new LongMod(1000000007L);\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      super.solve(testNumber, in, out);\n    }\n\n    public void solve(int testNumber) {\n      int n = in.nextInt();\n      int k = in.nextInt();\n\n      List<List<Integer>> edges = new ArrayList<>();\n\n      for (int i = 0; i < n; i++) {\n        edges.add(new ArrayList<>());\n      }\n\n      for (int i = 0; i < n - 1; i++) {\n        int v1 = in.nextInt() - 1;\n        int v2 = in.nextInt() - 1;\n        int color = in.nextInt();\n\n        if (color == 1) {\n          continue;\n        }\n\n        edges.get(v1).add(v2);\n        edges.get(v2).add(v1);\n      }\n\n      boolean[] visited = new boolean[n];\n\n      long totalCount = MOD.pow(n, k);\n      long badCount = 0;\n\n      for (int i = 0; i < n; i++) {\n        int componentSize = dfs(i, edges, visited);\n\n        badCount = MOD.sum(badCount, MOD.pow(componentSize, k));\n      }\n\n      long goodCount = MOD.sub(totalCount, badCount);\n\n      out.println(goodCount);\n    }\n\n    private int dfs(int v, List<List<Integer>> edges, boolean[] visited) {\n      if (visited[v]) {\n        return 0;\n      }\n\n      visited[v] = true;\n      int res = 1;\n\n      for (int u : edges.get(v)) {\n        res += dfs(u, edges, visited);\n      }\n\n      return res;\n    }\n\n  }\n\n  static abstract class ChelperSolution implements ChelperCallable {\n    public static final String LOCAL_FILE = \"chelper.properties\";\n    public static final String SAVE_RESULT_FILE = \"last_test_output.txt\";\n    protected final boolean local = new File(LOCAL_FILE).exists();\n    protected boolean firstTest = true;\n    protected InputReader in;\n    protected OutputWriter out;\n    protected OutputWriter debug;\n    protected OutputWriter fileOut;\n    protected boolean saveTestResult = true;\n    protected boolean gcj = false;\n\n    protected void init() {\n      if (local) {\n        debug = new OutputWriter(System.err);\n        if (saveTestResult) {\n          fileOut = OutputWriter.toFile(SAVE_RESULT_FILE);\n        }\n      } else {\n        debug = new OutputWriter(new NullOutputStream());\n      }\n    }\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      if (firstTest) {\n        init();\n        precalc();\n        firstTest = false;\n      }\n\n      this.in = in;\n      if (local && saveTestResult) {\n        this.out = new SplittingOutputWriter(out, fileOut);\n      } else {\n        this.out = out;\n      }\n\n      preSolve(testNumber);\n      solve(testNumber);\n      postSolve(testNumber);\n    }\n\n    protected void precalc() {\n\n    }\n\n    protected void preSolve(int testNumber) {\n      if (gcj) {\n        out.printf(\"Case #%d: \", testNumber);\n      }\n    }\n\n    public abstract void solve(int testNumber);\n\n    protected void postSolve(int testNumber) {\n      out.flush();\n      debug.flush();\n    }\n\n  }\n\n  static class OutputWriter extends PrintWriter {\n    public static OutputWriter toFile(String fileName) {\n      try {\n        return new OutputWriter(fileName);\n      } catch (FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public void close() {\n      super.close();\n    }\n\n    public OutputWriter(String fileName) throws FileNotFoundException {\n      super(fileName);\n    }\n\n    public OutputWriter(OutputStream outputStream) {\n      super(outputStream, true);\n    }\n\n    public OutputWriter(Writer writer) {\n      super(writer, true);\n    }\n\n  }\n\n  static class NullOutputStream extends OutputStream {\n    public void write(int b) throws IOException {\n      // nothing\n    }\n\n  }\n\n  static class LongMod {\n    public final long mod;\n\n    public LongMod(long mod) {\n      if (mod <= 0) {\n        throw new IllegalArgumentException();\n      }\n      this.mod = mod;\n    }\n\n    public long mod(long val) {\n      return val % mod;\n    }\n\n    public long sum(long a, long b) {\n      return (a + b) % mod;\n    }\n\n    public long sub(long a, long b) {\n      return mod(mod(a - b) + mod);\n    }\n\n    public long prod(long a, long b) {\n      return (a * b) % mod;\n    }\n\n    public long pow(long a, long b) {\n      if (b < 0) {\n        throw new IllegalArgumentException();\n      }\n\n      if (b == 0) {\n        return 1 % mod;\n      }\n\n      if (b == 1) {\n        return a % mod;\n      }\n\n      if (b % 2 == 0) {\n        long c = pow(a, b / 2);\n        return prod(c, c);\n      } else {\n        return prod(a, pow(a, b - 1));\n      }\n    }\n\n  }\n\n  static class SplittingOutputWriter extends OutputWriter {\n    private final OutputWriter[] outputWriters;\n\n    public SplittingOutputWriter(OutputWriter... outputWriters) {\n      super(new OutputStream() {\n\n        public void write(int b) throws IOException {\n          for (OutputWriter outputWriter : outputWriters) {\n            outputWriter.write(b);\n          }\n        }\n      });\n\n      this.outputWriters = outputWriters;\n    }\n\n    public void flush() {\n      for (OutputWriter outputWriter : outputWriters) {\n        outputWriter.flush();\n      }\n    }\n\n    public void close() {\n      for (OutputWriter outputWriter : outputWriters) {\n        outputWriter.close();\n      }\n    }\n\n  }\n\n  static interface ChelperCallable {\n  }\n\n  static class InputReader {\n    private BufferedReader br;\n    private StringTokenizer in;\n\n    public InputReader(String fileName) {\n      try {\n        br = new BufferedReader(new FileReader(fileName));\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public InputReader(InputStream inputStream) {\n      br = new BufferedReader(new InputStreamReader(inputStream));\n    }\n\n    private boolean hasMoreTokens() {\n      while (in == null || !in.hasMoreTokens()) {\n        String s = nextLine();\n        if (s == null) {\n          return false;\n        }\n        in = new StringTokenizer(s);\n      }\n      return true;\n    }\n\n    public String nextString() {\n      return hasMoreTokens() ? in.nextToken() : null;\n    }\n\n    public String nextLine() {\n      try {\n        in = null;\n        return br.readLine();\n      } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(nextString());\n    }\n\n  }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, cnt;\nvector<int> G[101010];\nbool vis[101010];\nlong long ans = 1;\nint Power(int a, int b) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = 1ll * ans * a % 1000000007;\n    a = 1ll * a * a % 1000000007;\n    b >>= 1;\n  }\n  return ans;\n}\nvoid dfs(int u) {\n  vis[u] = true;\n  cnt++;\n  for (auto& v : G[u]) {\n    if (!vis[v]) {\n      dfs(v);\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  ans = Power(n, k);\n  for (int i = 2; i <= n; ++i) {\n    int u, v, w;\n    scanf(\"%d%d%d\", &u, &v, &w);\n    if (!w) {\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (!vis[i]) {\n      cnt = 0;\n      dfs(i);\n      ans = (ans - Power(cnt, k) + 1000000007) % 1000000007;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class c\n{\n    static long mod = (long)1e9+7;\n    \n    public static void main(String[] args) throws IOException\n    {\n        FastScanner in = new FastScanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        DSU tree = new DSU(n);\n        for (int i = 0; i < n-1; i++)\n        {\n            int u = in.nextInt()-1;\n            int v = in.nextInt()-1;\n            int x = in.nextInt();\n            if (x == 1) continue;\n            tree.union(u, v);\n        }\n        \n        int[] sizes = new int[n];\n        for (int i = 0; i < n; i++)\n            sizes[tree.find(i)]++;\n        long ans = exp(n, k);\n        for (int i = 0; i < n; i++)\n        {\n            ans -= exp(sizes[i], k);\n            if (ans < 0) ans += mod;\n        }\n        ans %= mod;\n        System.out.println(ans);\n    }\n    \n    public static long exp(long s, long k)\n    {\n        if (s == 0) return 0;\n        if (k == 0) return 1L;\n        if (k == 1) return s %mod;\n        long ans = exp(s, k/2);\n        ans *= ans; ans %= mod;\n        if (k %2 == 0) return ans;\n        return (s*ans) %mod;\n    }\n    \n    public static class DSU\n    {\n        int[] set;\n        \n        DSU(int n)\n        {\n            Arrays.fill(set = new int[n], -1);\n        }\n        \n        int find(int i)\n        {\n            return set[i] < 0 ? i : (set[i] = find(set[i]));\n        }\n        \n        boolean union(int a, int b)\n        {\n            if ((a = find(a)) == (b = find(b))) return false;\n            if (set[a] == set[b]) set[a]--;\n            if (set[a] <= set[b]) set[b] = a; else set[a] = b;\n            return true;\n        }\n    }\n    \n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n    \t\n        public FastScanner(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer(\"\");\n        }\n    \t\t\t\n        public String next() throws IOException {\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n    \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        //$\n    }\n    \n}"
        },
        {
            "language": 3,
            "solution": "import sys\nMOD = 10**9 + 7\n\n\nclass UnionFind:\n    def __init__(self, n):\n\n        self.par = [-1 for i in range(n + 1)]\n\n    def root(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.root(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n        self.par[x] += self.par[y]\n        self.par[y] = x\n\n    def issame(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def size(self, x):\n        return - self.par[self.root(x)]\n\n\nif __name__ == '__main__':\n    n, k = map(int, sys.stdin.readline().rstrip().split())\n    Tree = UnionFind(n)\n    for i in range(n - 1):\n        u, v, x = map(int, sys.stdin.readline().rstrip().split())\n        if x == 0:\n            Tree.union(u-1, v-1)\n    ans = pow(n, k, MOD)\n    for i in range(n):\n        if Tree.root(i) == i:\n            # print(i)\n            ans -= pow(Tree.size(i), k, MOD)\n    print(ans % MOD)\n"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\n\nmodulo = 10**9 + 7\ndef pow(a, n):\n\tres = 1\n\twhile n:\n\t\t#print('pow:', a, res, n)\n\t\tif n & 1:\n\t\t\tres *= a\n\t\t\tres %= modulo\n\t\ta *= a\n\t\ta %= modulo\n\t\tn //= 2\n\treturn res\n\t\nn, k = map(int, input().split())\nlinks = [[i] for i in range(n)]\ndef mark(a):\n\tres = links[a-1]\n\twhile type(res[0]) == list:\n\t\tres = res[0]\n\tif type(links[a-1][0]) == list:\n\t\tlinks[a-1][:] = [res]\n\treturn res\nfor _ in range(n - 1):\n\ta, b, t = map(int, input().split())\n\tif not t:\n\t\tma = mark(a)\n\t\tmb = mark(b)\n\t\t#print(ma, mb, \"->\", *links)\n\t\tif ma != mb:\n\t\t\tmb[:] = [ma]\n\t\t#print(ma, mb, \"->\", *links)\n\t\t\t\nres = pow(n, k)\nfor v in Counter(mark(x)[0] for x in range(1, n+1)).values():\n\t#print(v, pow(v,k), res)\n\tres -= pow(v, k)\n\tres %= modulo\n\t\nprint(res)\n\n\t\t\t\n\t\t\t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<long long>> g;\nvector<bool> visited;\nlong long dfs(long long second) {\n  visited[second] = 1;\n  long long nov = 1;\n  for (long long i = 0; i < g[second].size(); i++) {\n    if (visited[g[second][i]] == 0) nov += dfs(g[second][i]);\n  }\n  return nov;\n}\nint main() {\n  long long n, k, u, v, b;\n  cin >> n >> k;\n  g.resize(n + 1, vector<long long>());\n  visited.resize(n + 1, 0);\n  for (long long i = 1; i <= n - 1; i++) {\n    cin >> u >> v >> b;\n    if (b == 0) {\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n  }\n  vector<long long> ans;\n  for (long long i = 1; i <= n; i++) {\n    if (visited[i] == 0) ans.push_back(dfs(i));\n  }\n  long long sum = 0;\n  for (long long i = 0; i < ans.size(); i++) {\n    long long tk = k, mul = 1;\n    while (tk--) mul = (mul * ans[i]) % 1000000007;\n    sum = (sum + mul) % 1000000007;\n  }\n  long long tmul = 1;\n  while (k--) tmul = (tmul * n) % 1000000007;\n  cout << (tmul - sum + 1000000007) % 1000000007;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nimport time\nfrom collections import defaultdict,deque\nfrom sys import stdin,stdout\nfrom bisect import bisect_left,bisect_right\nMOD=1000000007\nn,power=map(int,stdin.readline().split())\ngraph=defaultdict(lambda:[])\nfor _ in range(n-1):\n    u,v,x=map(int,stdin.readline().split())\n    graph[u].append([v,x])\n    graph[v].append([u,x])\nans=pow(n,power,MOD)\nvisited=[False]*(n+1)\nfor i in range(1,n+1):\n    if(not visited[i]):\n        visited[i]=True\n        count=0\n        q=deque()\n        q.append(i)\n        while(len(q)>0):\n            temp=q.popleft()\n            count+=1\n            for j,k in graph[temp]:\n                if(not visited[j] and k==0):\n                    visited[j]=True\n                    q.append(j)\n        ans-=pow(count,power,MOD)\nprint(ans%MOD)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int[] u = new int[n - 1];\n        int[] v = new int[n - 1];\n        int[] x = new int[n - 1];\n        for (int i = 0; i < n - 1; i++) {\n            u[i] = sc.nextInt();\n            v[i] = sc.nextInt();\n            x[i] = sc.nextInt();\n        }\n        System.out.println(solve(u, v, x, k));\n\n        sc.close();\n    }\n\n    static int solve(int[] u, int[] v, int[] x, int k) {\n        int n = u.length + 1;\n\n        int[] parents = new int[n];\n        Arrays.fill(parents, -1);\n\n        for (int i = 0; i < x.length; i++) {\n            if (x[i] == 0) {\n                int root1 = findRoot(parents, u[i] - 1);\n                int root2 = findRoot(parents, v[i] - 1);\n\n                if (root1 != root2) {\n                    parents[root2] = root1;\n                }\n            }\n        }\n\n        Map<Integer, Integer> rootToCount = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int root = findRoot(parents, i);\n\n            rootToCount.put(root, rootToCount.getOrDefault(root, 0) + 1);\n        }\n\n        int result = powMod(n, k);\n        for (int count : rootToCount.values()) {\n            result = subtractMod(result, powMod(count, k));\n        }\n\n        return result;\n    }\n\n    static int findRoot(int[] parents, int node) {\n        int root = node;\n        while (parents[root] != -1) {\n            root = parents[root];\n        }\n\n        int p = node;\n        while (p != root) {\n            int next = parents[p];\n            parents[p] = root;\n\n            p = next;\n        }\n\n        return root;\n    }\n\n    static int powMod(int base, int exponent) {\n        int result = 1;\n        for (int i = 0; i < exponent; i++) {\n            result = multiplyMod(result, base);\n        }\n\n        return result;\n    }\n\n    static int subtractMod(int x, int y) {\n        return (x - y + MOD) % MOD;\n    }\n\n    static int multiplyMod(int x, int y) {\n        return (int) ((long) x * y % MOD);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\nclass UnionFind():\n    def __init__(self):\n        self.rank  = {}\n        self.leader = {}\n        \n    def __repr__(self):\n        return f\"\"\" Ranks : {self.rank}, leaders : {self.leader} \"\"\"\n    \n    def find(self,x):\n        leader = self.leader.get(x, x)\n        if leader != x:\n            leader = self.find(leader)\n            self.leader[x] = leader\n        return leader\n    \n    def getRank(self,x):\n        return self.rank.get( x, 0)\n    \n    def union(self,x,y):\n        leader1 = self.find(x)\n        leader2 = self.find(y)\n        if leader1 == leader2 : return\n        if self.getRank(leader1) > self.getRank(leader2):\n            self.leader[leader2] = leader1\n        elif self.getRank(leader1) < self.getRank(leader2):\n            self.leader[leader1] = leader2\n        else:\n            self.leader[leader1] = leader2\n            self.rank[leader2] = 1 + self.getRank(leader2)\n\nn, k = map(int,input().split())\nedges = [ tuple(map(int,input().split())) for _ in range(n-1) ]\nuf = UnionFind()\nfor u,v,x in edges:\n    if x == 0: uf.union( u,v )\n\n        \nmod = int(1e9+7)\ntotal = pow(n,k,mod)\nclusters = defaultdict(int)\nfor i in range(1,n+1):\n    leader = uf.find(i)\n    clusters[leader]+=1\n\nfor val in clusters.values():\n    total -= pow( val, k, mod )\nprint(total%mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntypedef struct Node* node;\nusing namespace std;\nvector<int> dfs_order;\nvector<pair<int, int> > a[100001];\nint visited[100001];\nmap<pair<int, int>, int> m;\nint co = 0;\nvoid dfs(int r) {\n  visited[r] = 1;\n  for (auto it : a[r]) {\n    if (!visited[it.first] && it.second == 0) {\n      co++;\n      dfs(it.first);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, k, x, b, c;\n  cin >> n >> k;\n  long long ch = 1;\n  for (int i = 0; i < k; i++) {\n    ch = (ch * n) % 1000000007;\n    ch %= 1000000007;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    cin >> x >> b >> c;\n    a[x].push_back({b, c});\n    a[b].push_back({x, c});\n  }\n  long long ans = 1, v = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      co = 0;\n      dfs(i);\n      co++;\n      ans = 1;\n      for (int j = 0; j < k; j++) {\n        ans = ((ans % 1000000007) * (co % 1000000007)) % 1000000007;\n        ans %= 1000000007;\n      }\n      ch -= ans;\n      ch += 1000000007;\n      ch %= 1000000007;\n    }\n  }\n  cout << ch << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\nfrom collections import *\n\n\nclass graph:\n    # initialize graph\n    def __init__(self, gdict=None):\n        self.gdict = [[] for _ in range(10 ** 5 + 1)]\n\n    # add edge\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.gdict[node2].append(node1)\n\n    def bfs_util(self, i):\n        queue, self.visit[i], nodes = deque([i]), 1, 0\n\n        while queue:\n            # dequeue parent vertix\n            s = queue.popleft()\n            nodes += 1\n\n            # enqueue child vertices\n            for v in self.gdict[s]:\n                if self.visit[v] == 0:\n                    self.visit[v] = 1\n                    queue.append(v)\n\n        return nodes\n\n    def bfs(self):\n        self.visit, self.cnt = [0] * (n + 1), 0\n\n        for i in range(1, n + 1):\n            if self.visit[i] == 0:\n                self.cnt = add(self.cnt, pow(self.bfs_util(i), k, mod))\n\n        print(add(pow(n, k, mod), -self.cnt))\n\n\nadd = lambda a, b: (a % mod + b % mod) % mod\nmult = lambda a, b: ((a % mod) * (b % mod)) % mod\nrints = lambda: [int(x) for x in stdin.readline().split()]\ng, mod = graph(), 10 ** 9 + 7\n\nn, k = rints()\nfor _ in range(n - 1):\n    u, v, w = rints()\n    if w == 0:\n        g.addEdge(u, v)\n\ng.bfs()\n"
        },
        {
            "language": 4,
            "solution": "/*\n *\n * @Author  Ajudiya_13(Bhargav Girdharbhai Ajudiya)\n * Dhirubhai Ambani Institute of Information And Communication Technology\n *\n */\n\n\nimport java.util.*;\nimport java.io.*;\nimport java.lang.*;\n\npublic class Code49\n{\n    public static int n;\n    public static ArrayList<Integer> adj[];\n    public static boolean visited [];\n\n    public static int dfs(int u)\n    {\n        int count = 1;\n        visited[u] = true;\n        for(int v : adj[u])\n        {\n            if(!visited[v])\n                count += dfs(v);\n        }\n        return count;\n    }\n    public static void main(String[] args)\n    {\n        InputReader in = new InputReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        n = in.nextInt();\n        long k = in.nextLong();\n        adj = new ArrayList[n+1];\n        for(int i=0;i<=n;i++)\n            adj[i] = new ArrayList<>();\n        visited = new boolean[n+1];\n\n        for(int i=0;i<n-1;i++)\n        {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            int x = in.nextInt();\n            if(x==0)\n            {\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n        }\n\n        long ans = modularExponentiation((long)n,k,mod);\n        for(int i=1;i<=n;i++)\n        {\n            if(!visited[i])\n            {\n                long count = dfs(i);\n                ans = (ans - modularExponentiation(count,k,mod) + mod)%mod;\n            }\n        }\n        pw.print(ans);\n        pw.flush();\n        pw.close();\n    }\n\n    static class InputReader\n    {\n\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream)\n        {\n            this.stream = stream;\n        }\n\n        public int snext()\n        {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars)\n            {\n                curChar = 0;\n                try\n                {\n                    snumChars = stream.read(buf);\n                }\n                catch (IOException e)\n                {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt()\n        {\n            int c = snext();\n            while (isSpaceChar(c))\n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong()\n        {\n            int c = snext();\n            while (isSpaceChar(c))\n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n)\n        {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public String readString()\n        {\n            int c = snext();\n            while (isSpaceChar(c))\n            {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public String nextLine()\n        {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c)\n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c)\n        {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static long mod = 1000000007;\n    public static int d;\n    public static int p;\n    public static int q;\n\n    public static int[] suffle(int[] a,Random gen)\n    {\n        int n = a.length;\n        for(int i=0;i<n;i++)\n        {\n            int ind = gen.nextInt(n-i)+i;\n            int temp = a[ind];\n            a[ind] = a[i];\n            a[i] = temp;\n        }\n        return a;\n    }\n\n    public static void swap(int a, int b){\n        int temp = a;\n        a = b;\n        b = temp;\n    }\n\n    public static HashSet<Integer> primeFactorization(int n)\n    {\n        HashSet<Integer> a =new HashSet<Integer>();\n        for(int i=2;i*i<=n;i++)\n        {\n            while(n%i==0)\n            {\n                a.add(i);\n                n/=i;\n            }\n        }\n        if(n!=1)\n            a.add(n);\n        return a;\n    }\n\n    public static void sieve(boolean[] isPrime,int n)\n    {\n        for(int i=1;i<n;i++)\n            isPrime[i] = true;\n\n        isPrime[0] = false;\n        isPrime[1] = false;\n\n        for(int i=2;i*i<n;i++)\n        {\n            if(isPrime[i] == true)\n            {\n                for(int j=(2*i);j<n;j+=i)\n                    isPrime[j] = false;\n            }\n        }\n    }\n\n    public static int GCD(int a,int b)\n    {\n        if(b==0)\n            return a;\n        else\n            return GCD(b,a%b);\n    }\n\n    public static long GCD(long a,long b)\n    {\n        if(b==0)\n            return a;\n        else\n            return GCD(b,a%b);\n    }\n\n    public static void extendedEuclid(int A,int B)\n    {\n        if(B==0)\n        {\n            d = A;\n            p = 1 ;\n            q = 0;\n        }\n        else\n        {\n            extendedEuclid(B, A%B);\n            int temp = p;\n            p = q;\n            q = temp - (A/B)*q;\n        }\n    }\n\n    public static long LCM(long a,long b)\n    {\n        return (a*b)/GCD(a,b);\n    }\n\n    public static int LCM(int a,int b)\n    {\n        return (a*b)/GCD(a,b);\n    }\n\n    public static int binaryExponentiation(int x,int n)\n    {\n        int result=1;\n        while(n>0)\n        {\n            if(n % 2 ==1)\n                result=result * x;\n            x=x*x;\n            n=n/2;\n        }\n        return result;\n    }\n\n    public static long binaryExponentiation(long x,long n)\n    {\n        long result=1;\n        while(n>0)\n        {\n            if(n % 2 ==1)\n                result=result * x;\n            x=x*x;\n            n=n/2;\n        }\n        return result;\n    }\n\n    public static int modularExponentiation(int x,int n,int M)\n    {\n        int result=1;\n        while(n>0)\n        {\n            if(n % 2 ==1)\n                result=(result * x)%M;\n            x=(x*x)%M;\n            n=n/2;\n        }\n        return result;\n    }\n\n    public static long modularExponentiation(long x,long n,long M)\n    {\n        long result=1;\n        while(n>0)\n        {\n            if(n % 2 ==1)\n                result=(result * x)%M;\n            x=(x*x)%M;\n            n=n/2;\n        }\n        return result;\n    }\n\n    public static int modInverse(int A,int M)\n    {\n        return modularExponentiation(A,M-2,M);\n    }\n\n    public static long modInverse(long A,long M)\n    {\n        return modularExponentiation(A,M-2,M);\n    }\n\n    public static boolean isPrime(int n)\n    {\n\n        if (n <= 1)  return false;\n        if (n <= 3)  return true;\n\n        if (n%2 == 0 || n%3 == 0)\n            return false;\n\n        for (int i=5; i*i<=n; i=i+6)\n        {\n            if (n%i == 0 || n%(i+2) == 0)\n                return false;\n        }\n\n        return true;\n    }\n\n    static class pair implements Comparable<pair>\n    {\n        Integer x, y;\n        pair(int x,int y)\n        {\n            this.x=x;\n            this.y=y;\n        }\n\n        public int compareTo(pair o) {\n            int result = x.compareTo(o.x);\n            if(result==0)\n                result = y.compareTo(o.y);\n\n            return result;\n        }\n\n        public String toString()\n        {\n            return x+\" \"+y;\n        }\n\n        public boolean equals(Object o)\n        {\n            if (o instanceof pair)\n            {\n                pair p = (pair)o;\n                return (Math.abs(p.x-x)==0 && Math.abs(p.y-y)==0);\n            }\n            return false;\n        }\n\n        public int hashCode()\n        {\n            return new Long(x).hashCode()*31 + new Long(y).hashCode();\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid canhazfast() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n}\ntemplate <typename T>\nT gcd(T a, T b) {\n  return b ? gcd(b, a % b) : a;\n}\ntemplate <typename T>\nT extgcd(T a, T b, T &x, T &y) {\n  T x0 = 1, y0 = 0, x1 = 0, y1 = 1;\n  while (b) {\n    T q = a / b;\n    a %= b;\n    swap(a, b);\n    x0 -= q * x1;\n    swap(x0, x1);\n    y0 -= q * y1;\n    swap(y0, y1);\n  }\n  x = x0;\n  y = y0;\n  return a;\n}\nint ctz(unsigned x) { return __builtin_ctz(x); }\nint ctzll(unsigned long long x) { return __builtin_ctzll(x); }\nint clz(unsigned x) { return __builtin_clz(x); }\nint clzll(unsigned long long x) { return __builtin_clzll(x); }\nint popcnt(unsigned x) { return __builtin_popcount(x); }\nint popcntll(unsigned long long x) { return __builtin_popcountll(x); }\nint bsr(unsigned x) { return 31 ^ clz(x); }\nint bsrll(unsigned long long x) { return 63 ^ clzll(x); }\nunsigned add(unsigned a, unsigned b) {\n  return a + b < 1000000007 ? a + b : a + b - 1000000007;\n}\nunsigned sub(unsigned a, unsigned b) {\n  return a < b ? a + 1000000007 - b : a - b;\n}\nunsigned mul(unsigned a, unsigned b) {\n  return (unsigned long long)a * b % 1000000007;\n}\nunsigned sqr(unsigned a) { return mul(a, a); }\nunsigned modpow(unsigned b, unsigned e) {\n  unsigned r = 1;\n  for (; e; e >>= 1) {\n    if (e & 1) r = mul(r, b);\n    b = mul(b, b);\n  }\n  return r;\n}\nunsigned modinv(unsigned n) { return modpow(n, 1000000007 - 2); }\nunsigned moddiv(unsigned n, unsigned d) { return mul(n, modinv(d)); }\nint sz[100016];\nvector<pair<int, int> > adj[100016];\nvoid dfs(int u, int p = 0) {\n  sz[u] = 1;\n  for (pair<int, int> &e : adj[u]) {\n    int v = e.first, x = e.second;\n    if (v == p || x != 0) continue;\n    dfs(v, u);\n    sz[u] += sz[v];\n  }\n}\nint main() {\n  canhazfast();\n  int n, k;\n  unsigned ans;\n  vector<int> ccs;\n  cin >> n >> k;\n  for (int i = 1; i < n; ++i) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    adj[u].emplace_back(v, x);\n    adj[v].emplace_back(u, x);\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (sz[i]) continue;\n    dfs(i);\n    ccs.push_back(sz[i]);\n  }\n  ans = modpow(n, k);\n  for (int s : ccs) ans = sub(ans, modpow(s, k));\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "class UnionFind:\n    def __init__(self, n):\n        self.par = [int(i) for i in range(n)]\n        self.rank = [1] * (n + 1)\n        self.rank[0] = 0\n    \n    def union(self, x, y):\n        if not self.same_set(x, y):\n            par_x = self.find(x)\n            par_y = self.find(y)\n\n            if self.rank[par_x] > self.rank[par_y]:\n                self.rank[par_x] += self.rank[par_y]\n                self.rank[par_y] = 0\n                self.par[par_y] = par_x\n            else:\n                self.rank[par_y] += self.rank[par_x]\n                self.rank[par_x] = 0\n                self.par[par_x] = par_y\n            self.find(x)\n            self.find(y)\n\n    def find(self, x):\n        if self.par[x] == x: return x\n        self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def same_set(self, x, y):\n        return self.find(x) == self.find(y)\n\ndef fast_pow(x, y):\n    if y == 1: return x\n    if y % 2 != 0: return ((x % M) * (fast_pow(x, y - 1) % M)) % M\n    aux = fast_pow(x, y / 2)\n    return ((aux % M) * (aux % M)) % M\n\nM = 1000000007\nn, k = map(int, input().split())\n\nmax_pos = fast_pow(n, k)\n\nuf = UnionFind(n+1)\n\nfor i in range(n - 1):\n    u, v, x = map(int, input().split())\n    \n    if x == 0:\n        uf.union(u, v)\nnao_bons = 0\nfor i in range(n+1):\n    if uf.rank[i] > 0:\n        nao_bons = ((nao_bons % M) + (fast_pow(uf.rank[i], k) % M)) % M\nprint(((max_pos % M) - (nao_bons % M)) % M)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n \n    \n    \n    \n\n public class test {\n    \n    \n       static class DSU {\n    \n    int[] p;int[] sz;int op;int c;\n    public void G(int n)\n    {\n        p=new int[n];\n        sz=new int[n];c=n;\n        op=n;\n        for(int h=0;h<n;h++)\n        {\n            sz[h]=1;p[h]=h;\n        }\n    }\n    public int find(int x)\n    {\n        int y=x;\n        while(x!=p[x]) x=p[x];\n        while(y!=p[y])\n        {\n            int tem=p[y];\n            p[y]=x;y=tem;\n        }\n        return p[y];\n    }\n    public void union(int a,int b)\n    {\n        int x,y;\n        x=find(a);y=find(b);\n        if(x==y) return;\n        if(sz[x]>sz[y])\n        {\n            p[y] = x;\n            sz[x]+=sz[y];\n        }\n        else\n        {\n            p[x]=y;sz[y]+=sz[x];\n        }\n        c--;\n        \n    }}\n    static long mod=1000000000+7l;\n    static long power(long x, long y)\n\t  {\n\t    long res = 1l; // Initialize result\n\t\tlong p=mod;\n\t    x = x % p; // Update x if it is more than or\n\t    // equal to p\n\t \n\t    if (x == 0l)\n\t      return 0; // In case x is divisible by p;\n\t \n\t    while (y > 0)\n\t    {\n\t \n\t      // If y is odd, multiply x with result\n\t      if ((y & 1) != 0)\n\t        res = (res * x) % p;\n\t \n\t      // y must be even now\n\t      y = y >> 1; // y = y/2\n\t      x = (x * x) % p;\n\t    }\n\t    return res;\n\t  }\n    public static void main (String[] args) throws Exception {\n        \n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        \n        int y=1;//Integer.parseInt(bf.readLine());\n        for(int h=0;h<y;h++)\n        {\n           String[] xl=(bf.readLine()).split(\" \");\n            //long a,b,c,d;long ans=0l;\n            int n,t;\n            n=Integer.parseInt(xl[0]);\n            t=Integer.parseInt(xl[1]);\n            \n            DSU ds=new DSU();\n            ds.G(n);\n           for(int o=0;o<n-1;o++)\n           {\n           \t  String[] lk = bf.readLine().split(\" \");\n           \t  int a = Integer.parseInt(lk[0])-1;\n           \t  int b=Integer.parseInt(lk[1])-1;\n           \t  int c=Integer.parseInt(lk[2]);\n           \t  if(c==0) ds.union(a,b);\n           }\n           long sum=0l;\n           int[] arr=ds.sz;\n           \n           for(int u=0;u<arr.length;u++)\n           {\n           \t   if(ds.find(u) == u)\n           \t   {\n           \t   \t   sum = (sum%mod + power(arr[u]+0l,t+0l)%mod)%mod;\n           \t   }\n           }\n           sum = power(n+0l,t+0l) - sum;\n           if(sum<0) sum= (sum+mod)%mod;\n           System.out.println(sum);\n            \n        }\n    }\n}\n/*\n\n2\n1000000000 1000000000\naaabb\n\n*/\n\n\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict as dd\nn,k=map(int,input().strip().split())\ngraph=dd(list)\n\n\ndef bfs(a):\n    visited[a]=1\n    arr=[a]\n    ct=1\n\n    while(arr):\n        b=arr.pop(0)\n        for i in graph[b]:\n            if(visited[i]==0):\n                visited[i]=1\n                arr.append(i)\n                ct+=1\n    return ct\n\nfor i in range(n-1):\n    a,b,c=map(int,input().strip().split())\n    if(c==0):\n        graph[a].append(b)\n        graph[b].append(a)\n\nvisited=[0]*(n+1)\nmod=10**9+7\ntot=pow(n,k,mod)\nfor i in range(1,n+1):\n    if(visited[i]==0):\n        w=bfs(i)\n        tot=(tot-pow(w,k,mod))%mod\nprint(tot%mod)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 100100;\nconst long long Mod = 1e9 + 7;\nbool Vis[N];\nvector<long long> Adj[N];\nvoid sub(long long& x, long long y) { x = (x - y + 10 * Mod) % Mod; }\nlong long fp(long long x, long long y) {\n  if (!y) return 1;\n  long long Res = fp(x, y / 2);\n  Res = (Res * Res) % Mod;\n  if (y & 1) Res = (x * Res) % Mod;\n  return Res;\n}\nlong long DFS(long long i) {\n  if (Vis[i]) return 0;\n  Vis[i] = true;\n  long long Res = 1;\n  for (auto j : Adj[i]) Res += DFS(j);\n  return Res;\n}\nint main() {\n  long long n, k;\n  cin >> n >> k;\n  for (long long i = 1; i < n; ++i) {\n    long long x, y, w;\n    scanf(\"%I64d%I64d%I64d\", &x, &y, &w);\n    if (w) continue;\n    Adj[x].push_back(y);\n    Adj[y].push_back(x);\n  }\n  long long Ans = fp(n, k);\n  for (long long i = 1; i <= n; i++)\n    if (!Vis[i]) sub(Ans, fp(DFS(i), k));\n  cout << Ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import org.omg.PortableInterceptor.SYSTEM_EXCEPTION;\n\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\n\n// author @mdazmat9\npublic class codeforces{\n\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int test = 1;\n        for (int ind = 0; ind < test; ind++) {\n            int n=sc.nextInt();\n            int k=sc.nextInt();\n            Graph g=new Graph(n);\n\n            for(int i = 0; i < n - 1; ++i) {\n                int u = sc.nextInt() - 1;\n                int v = sc.nextInt() - 1;\n                int col = sc.nextInt();\n\n                if(col == 0) {\n                    g.addEdge(u,v);\n                }\n            }\n            long ans = fast_pow(n, k);\n            long rem = g.DFS(k);\n           // out.println(ans+\" \"+rem);\n            ans = (ans - rem + mod) % mod;\n            out.println(ans);\n\n\n\n\n        }\n        out.flush();\n    }\n    static long fast_pow(long a, long b) {\n        if(b == 0)\n            return 1L;\n\n        long val = fast_pow(a, b / 2);\n\n        if(b % 2 == 0)\n            return val * val % mod;\n        else\n            return val * val % mod * a % mod;\n    }\n    static long mod = (long)1e9 + 7;\n    static   void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n    static long gcd(long a , long b)\n    {\n        if(b == 0)\n            return a;\n        return gcd(b , a % b);\n    }\n\n}\nclass Scanner {\n    public BufferedReader reader;\n    public StringTokenizer st;\n\n    public Scanner(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        st = null;\n    }\n\n    public String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                String line = reader.readLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            } catch (Exception e) {\n                throw (new RuntimeException());\n            }\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n\nclass OutputWriter {\n    BufferedWriter writer;\n\n    public OutputWriter(OutputStream stream) {\n        writer = new BufferedWriter(new OutputStreamWriter(stream));\n    }\n\n    public void print(int i) throws IOException {\n        writer.write(i);\n    }\n\n    public void print(String s) throws IOException {\n        writer.write(s);\n    }\n\n    public void print(char[] c) throws IOException {\n        writer.write(c);\n    }\n\n    public void close() throws IOException {\n        writer.close();\n    }\n\n}\nclass Pair {\n    int x;\n    int y;\n\n    // Constructor\n    public Pair(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n}\nclass Compare {\n\n    static void compare(Pair arr[], int n)\n    {\n        // Comparator to sort the pair according to second element\n        Arrays.sort(arr, new Comparator<Pair>() {\n            @Override public int compare(Pair p1, Pair p2)\n            {\n                return p1.x - p2.x;\n            }\n        });\n    }\n}\n\nclass Graph {\n    // A user define class to represent a graph.\n    // A graph is an array of adjacency lists.\n    // Size of array will be V (number of vertices\n    // in graph)\n    int V;\n    ArrayList<Integer>[] adjListArray;\n\n    // constructor\n    Graph(int V) {\n        this.V = V;\n        // define the size of array as\n        // number of vertices\n        adjListArray = new ArrayList[V];\n\n        // Create a new list for each vertex\n        // such that adjacent nodes can be stored\n\n        for (int i = 0; i < V; i++) {\n            adjListArray[i] = new ArrayList<>();\n        }\n    }\n\n    // Adds an edge to an undirected graph\n    void addEdge(int src, int dest) {\n\n        // Add an edge from src to dest.\n        //src--;dest--; //do this for 1 based indexing\n\n        //\n        adjListArray[src].add(dest);\n\n        // Since graph is undirected, add an edge from dest\n        // to src also\n          adjListArray[dest].add(src);\n    }\n\n\n\n\n\n    void DFSUtil(int u,boolean[] visited) {\n        // Mark the current node as visited and print it\n              visited[u] = true;\n                count++;\n         //   System.out.print(set);\n\n        // Recur for all the vertices adjacent to this vertex\n        for (int i = 0; i < adjListArray[u].size(); i++) {\n            int n = adjListArray[u].get(i);\n            if (!visited[n]) {\n                DFSUtil(n, visited);\n            }\n        }\n        // visited[u] = false;\n\n    }\n    static long fast_pow(long a, long b) {\n        if(b == 0)\n            return 1L;\n\n        long val = fast_pow(a, b / 2);\n\n        if(b % 2 == 0)\n            return val * val % mod;\n        else\n            return val * val % mod * a % mod;\n    }\n    static long mod = (long)1e9 + 7;\nstatic long count=0;\n    // The function to do DFS traversal. It uses recursive DFSUtil()\n    long DFS(int k) {\n        // Mark all the vertices as not visited(set as\n        // false by default in java)\n        boolean visited[] = new boolean[V];\n        long rem=0;\n        // Call the recursive helper function to print DFS traversal\n        for(int i = 0; i < V; ++i) {\n            if(!visited[i] ) {\n                count = 0;\n                DFSUtil(i,visited);\n                rem += fast_pow(count, k);\n            }\n        }\n        rem %= mod;\n       return rem;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long md = 1e9 + 7;\nconst int N = 200005;\nint INF = 1e9 + 7;\nint n, k;\nvector<vector<int>> g1(200005), g0(200005);\nbool used[200005];\nlong long ans;\nlong long dfs(int v) {\n  used[v] = 1;\n  queue<int> q;\n  q.push(v);\n  long long ans1 = 1;\n  while (!q.empty()) {\n    int t = q.front();\n    q.pop();\n    for (int i = 0; i < g0[t].size(); i++)\n      if (!used[g0[t][i]]) {\n        used[g0[t][i]] = 1;\n        ans1++;\n        q.push(g0[t][i]);\n      }\n  }\n  return ans1;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i <= n; i++) used[i] = 0;\n  for (int i = 0; i < n - 1; i++) {\n    int x, y, c;\n    cin >> x >> y >> c;\n    if (c) {\n      g1[x].push_back(y);\n      g1[y].push_back(x);\n    } else {\n      g0[x].push_back(y);\n      g0[y].push_back(x);\n    }\n  }\n  ans = 1;\n  for (int i = 0; i < k; i++) {\n    ans *= (long long)n;\n    ans %= md;\n  }\n  for (int i = 1; i <= n; i++)\n    if (!used[i]) {\n      long long n1 = dfs(i);\n      if (n1 == 1) {\n        ans--;\n        if (ans < 0) ans += md;\n        ans %= md;\n      } else {\n        long long ans1 = 1;\n        for (int j = 0; j < k; j++) {\n          ans1 *= n1;\n          ans1 %= md;\n        }\n        ans -= ans1;\n        if (ans < 0) ans += md;\n        ans %= md;\n      }\n    }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import collections\nfrom collections import defaultdict \nn,k = input().split()\nn,k=[int(n),int(k)]\ngraph1=defaultdict(list)\npower=(n**k)%(10**9+7)\n\nfor x in range(n-1):\n    u,v,x= input().split()\n    u,v,x=[int(u),int(v),int(x)]\n    if x==0:\n        graph1[u].append(v)\n        graph1[v].append(u)\ndef bfs(graph, root):\n    count=1\n    queue =  collections.deque([root])\n    visited.add(root)\n    while queue: \n        vertex = queue.popleft()\n        for neighbour in graph[vertex]: \n            if neighbour not in visited: \n                visited.add(neighbour) \n                queue.append(neighbour)\n                count+=1\n    \n    return count\nvisited=set()\nfor i in range(1,n+1):\n    \n    if i not in visited:\n        \n        xy=bfs(graph1,i)\n        power=(power-(xy**k)%(10**9+7))%(10**9+7)\n        \nprint(power%(10**9+7))\n\n\n\n\n    \n    \n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a;\n    swap(a, m);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod())\n      v = static_cast<Type>(x);\n    else\n      v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const {\n    return static_cast<U>(value);\n  }\n  constexpr static Type mod() { return T::value; }\n  Modular& operator+=(const Modular& other) {\n    if ((value += other.value) >= mod()) value -= mod();\n    return *this;\n  }\n  Modular& operator-=(const Modular& other) {\n    if ((value -= other.value) < 0) value += mod();\n    return *this;\n  }\n  template <typename U>\n  Modular& operator+=(const U& other) {\n    return *this += Modular(other);\n  }\n  template <typename U>\n  Modular& operator-=(const U& other) {\n    return *this -= Modular(other);\n  }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) {\n    Modular result(*this);\n    *this += 1;\n    return result;\n  }\n  Modular operator--(int) {\n    Modular result(*this);\n    *this -= 1;\n    return result;\n  }\n  Modular operator-() const { return Modular(-value); }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) *\n                      static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) *\n                                     rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n  Modular& operator/=(const Modular& other) {\n    return *this *= Modular(inverse(other.value, mod()));\n  }\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) {\n    return v;\n  }\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\ntemplate <typename T>\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value == rhs.value;\n}\ntemplate <typename T, typename U>\nbool operator==(const Modular<T>& lhs, U rhs) {\n  return lhs == Modular<T>(rhs);\n}\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) == rhs;\n}\ntemplate <typename T>\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T>& lhs, U rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T>\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value < rhs.value;\n}\ntemplate <typename T>\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T>\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T>\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T>\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\nusing ModType = int;\nconstexpr int md = 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int)fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int)fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<set<pair<int, int>>> g(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    u--, v--;\n    g[u].insert({v, x});\n    g[v].insert({u, x});\n  }\n  vector<int> used(n, 0);\n  Mint ans = 0;\n  for (int i = 0; i < n; ++i) {\n    if (used[i]) continue;\n    int sz = 0;\n    queue<int> q;\n    q.push(i);\n    while (!q.empty()) {\n      sz++;\n      int v = q.front();\n      q.pop();\n      used[v] = 1;\n      for (auto x : g[v]) {\n        if (x.second == 0 && !used[x.first]) {\n          q.push(x.first);\n        }\n      }\n    }\n    ans += power(Mint(sz), k);\n  }\n  cout << power(Mint(n), k) - ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "mod = 10**9+7\nn, k = [int(i) for i in input().split(' ')]\nroot = [i for i in range(n+1)]\nnum = [1]*(n+1)\ndef findroot(x):\n    if root[x] == x:\n        return x\n    else:\n        root[x] = findroot(root[x])\n        return root[x]\ndef union(x, y):\n    xroot = findroot(x)\n    yroot = findroot(y)\n    if num[xroot] >= num[yroot]:\n        num[xroot] += num[yroot]\n        root[yroot] = xroot\n    else:\n        num[yroot] += num[xroot]\n        root[xroot] = yroot\nfor i in range(n-1):\n    u, v, x = [int(s) for s in input().split(' ')]\n    if x == 0:\n        union(u, v)\nans = n**k\nfor i in range(1, n+1):\n    if i == root[i]:\n       ans -= num[i]**k\nprint(ans%mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nlist<pair<int, int> > adj[100005];\nlong long ans = 0;\nlong long us(long long a, long long b) {\n  long long taban = 1;\n  while (b) {\n    if (b & 1) {\n      taban *= a;\n      taban %= 1000000007;\n    }\n    b >>= 1;\n    a *= a;\n    a %= 1000000007;\n  }\n  return taban;\n}\nint find(int node, int ata, int bas) {\n  long long say = 1;\n  for (list<pair<int, int> >::iterator it = adj[node].begin();\n       it != adj[node].end(); ++it) {\n    if (it->first == ata) continue;\n    if (it->second == 0)\n      say += find(it->first, node, 0);\n    else\n      find(it->first, node, 1);\n  }\n  if (bas) {\n    ans += us(say, k);\n    ans %= 1000000007;\n  }\n  return say;\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a--;\n    b--;\n    adj[a].push_back(make_pair(b, c));\n    adj[b].push_back(make_pair(a, c));\n  }\n  find(0, -1, 1);\n  ans = us(n, k) - ans;\n  ans += 1000000007;\n  ans %= 1000000007;\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization(\"unroll-loops\")\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid __print(int x) { cout << x; }\nvoid __print(long x) { cout << x; }\nvoid __print(long long x) { cout << x; }\nvoid __print(unsigned x) { cout << x; }\nvoid __print(unsigned long x) { cout << x; }\nvoid __print(unsigned long long x) { cout << x; }\nvoid __print(float x) { cout << x; }\nvoid __print(double x) { cout << x; }\nvoid __print(long double x) { cout << x; }\nvoid __print(char x) { cout << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cout << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cout << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cout << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cout << '{';\n  __print(x.first);\n  cout << ',';\n  __print(x.second);\n  cout << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int first = 0;\n  cout << '{';\n  for (auto &i : x) cout << (first++ ? \",\" : \"\"), __print(i);\n  cout << \"}\";\n}\nvoid _print() { cout << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cout << \", \";\n  _print(v...);\n}\ntemplate <class T>\nvoid remdup(vector<T> &v) {\n  sort((v).begin(), (v).end());\n  v.erase(unique((v).begin(), (v).end()), end(v));\n}\ntemplate <typename T>\nstruct cmp {\n  bool operator()(const T &p1, const T &p2) {}\n};\nconst long long N = 2e5 + 100;\nconst long long mod = 1e9 + 7;\nvector<long long> a[N];\nlong long check[N];\nlong long count1 = 0;\nlong long power(long long x, long long n) {\n  long long result = 1;\n  while (n > 0) {\n    if (n % 2 == 1) result = (result * x) % mod;\n    x = (x * x) % mod;\n    n = n / 2;\n  }\n  return result;\n}\nvoid dfs(long long x) {\n  count1++;\n  check[x] = 1;\n  for (auto &it : a[x])\n    if (!check[it]) dfs(it);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  ;\n  long long n, k, x, y, z;\n  cin >> n >> k;\n  for (long long i = (0); i < (n - 1); ++i) {\n    cin >> x >> y >> z;\n    if (!z) {\n      a[x].push_back(y);\n      a[y].push_back(x);\n    }\n  }\n  long long ans = 0;\n  for (long long i = (1); i < (n + 1); ++i) {\n    if (!check[i]) dfs(i);\n    ans += power(count1, k);\n    ans = ans % mod;\n    count1 = 0;\n  }\n  cout << (power(n, k) - ans + mod) % mod << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.lang.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.regex.*;\nimport java.util.stream.LongStream;\n\npublic class Main{\n\n\tstatic ArrayList a[]=new ArrayList[5000001];\n\tstatic boolean visited[]=new boolean [5000001];\n\tstatic long cnt=0;\n\tstatic void dfs(int n) {\n\t\tvisited[n]=true;\n\t\tcnt++;\n\t\tfor(int i=0;i<a[n].size();i++) {\n\t\t\tpair p=(pair) a[n].get(i);\n\t\t\tif(!visited[p.x] && p.y==0) {\n\t\t\t\tdfs(p.x);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args)\n   {\n       InputReader in=new InputReader(System.in);\n       PrintWriter pw = new PrintWriter(System.out);\n       int n=in.nextInt();\n       for(int i=0;i<=n;i++)\n    \t   a[i]=new ArrayList<pair>();\n    \tlong k=in.nextLong();\n    \tfor(int i=0;i<n-1;i++) {\n    \t\tint x=in.nextInt();\n    \t\tint y=in.nextInt();\n    \t\tint c=in.nextInt();\n    \t\ta[x].add(new pair(y,c));\n    \t\ta[y].add(new pair(x,c));\n    \t}\n    \tlong ans=(modularExponentiation((long)n,k,mod)-n+mod)%mod;\n    \tfor(int i=1;i<=n;i++) {\n    \t\tif(!visited[i]) {\n    \t\t\tdfs(i);\n    \t\t\tans=(ans-((modularExponentiation(cnt,k,mod)-cnt+mod)%mod)+mod)%mod;\n    \t\t\tcnt=0;\n\n    \t\t}\n    \t}\n    \tpw.println(ans);\n       pw.flush();\n       pw.close();\n        \n    }\n         private static void debug(Object... o) {\n     \t\tSystem.out.println(Arrays.deepToString(o));\n     \t}\n        static class InputReader \n        {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) \n        { \n            this.stream = stream;\n        }\n        public int snext() \n        {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) \n            {\n                curChar = 0;\n                try \n                {\n                    snumChars = stream.read(buf);\n                } \n                \n                catch (IOException e) \n                {\n                    throw new InputMismatchException();\n                }\n                \n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n \n        public int nextInt() \n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public long nextLong()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') \n            {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public int[] nextIntArray(int n) \n        {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) \n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        static class tri implements Comparable<tri> {\n            int p, c, l;\n \n            tri(int p, int c, int l) {\n                this.p = p;\n                this.c = c;\n                this.l = l;\n            }\n \n            public int compareTo(tri o) {\n                return Integer.compare(l, o.l);\n            }\n        }\n \n        public String readString()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n \n        public String nextLine() \n        {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n \n        public boolean isSpaceChar(int c) \n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        private boolean isEndOfLine(int c) \n        {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n \n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n        public static long mod = 1000000007;\n        public static int d;\n        public static int p;\n        public static int q;\n        \n        public static int[] suffle(int[] a,Random gen)\n        {\n            int n = a.length;\n            for(int i=0;i<n;i++)\n            {\n                int ind = gen.nextInt(n-i)+i;\n                int temp = a[ind];\n                a[ind] = a[i];\n                a[i] = temp;\n            }\n            return a;\n        }\n        \n        public static void swap(int a, int b){\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n      \n        \n        public static void sieve(boolean[] isPrime,int n)\n        {\n            for(int i=1;i<n;i++)\n                isPrime[i] = true;\n            \n            isPrime[0] = false;\n            isPrime[1] = false;\n            \n            for(int i=2;i*i<n;i++)\n            {\n                if(isPrime[i] == true)\n                {\n                    for(int j=(2*i);j<n;j+=i)\n                        isPrime[j] = false;\n                }\n            }\n        }\n        \n        public static int GCD(int a,int b)\n        {\n            if(b==0)\n                return a;\n            else\n                return GCD(b,a%b);\n        }\n        \n        public static long GCD(long a,long b)\n        {\n            if(b==0)\n                return a;\n            else\n                return GCD(b,a%b);\n        }\n        \n        public static void extendedEuclid(int A,int B)\n        {\n            if(B==0)\n            {\n                d = A;\n                p = 1 ;\n                q = 0;\n            }\n            else\n            {\n                extendedEuclid(B, A%B);\n                int temp = p;\n                p = q;\n                q = temp - (A/B)*q;\n            }\n        }\n        \n        public static long LCM(long a,long b)\n        {\n            return (a*b)/GCD(a,b);\n        }\n        \n        public static int LCM(int a,int b)\n        {\n            return (a*b)/GCD(a,b);\n        }\n        \n        public static int binaryExponentiation(int x,int n)\n        {\n            int result=1;\n            while(n>0)\n            {\n                if(n % 2 ==1)\n                    result=result * x;\n                x=x*x;\n                n=n/2;\n            }\n            return result;\n        }\n        \n        public static long binaryExponentiation(long x,long n)\n        {\n            long result=1;\n            while(n>0)\n            {\n                if(n % 2 ==1)\n                    result=result * x;\n                x=x*x;\n                n=n/2;\n            }\n            return result;\n        }\n        \n        public static int modularExponentiation(int x,int n,int M)\n        {\n            int result=1;\n            while(n>0)\n            {\n                if(n % 2 ==1)\n                    result=(result * x)%M;\n                x=(x%M*x)%M;\n                n=n/2;\n            }\n            return result;\n        }\n        \n        public static long modularExponentiation(long x,long n,long M)\n        {\n            long result=1;\n            while(n>0)\n            {\n                if(n % 2 ==1)\n                    result=(result%M * x%M)%M;\n                x=(x%M * x%M)%M;\n                n=n/2;\n            }\n            return result;\n        }\n        \n        public static long modInverse(int A,int M)\n        {\n            return modularExponentiation(A,M-2,M);\n        }\n        \n        public static long modInverse(long A,long M)\n        {\n            return modularExponentiation(A,M-2,M);\n        }\n        \n        public static boolean isPrime(int n)\n        {\n            \n            if (n <= 1)  return false;\n            if (n <= 3)  return true;\n            \n            if (n%2 == 0 || n%3 == 0) \n                return false;\n         \n            for (int i=5; i*i<=n; i=i+6)\n            {\n                if (n%i == 0 || n%(i+2) == 0)\n                   return false;\n            }\n            \n            return true;\n        }\n        \n         public static long[] shuffle(long[] a, Random gen){ \n                for(int i = 0, n = a.length;i < n;i++){ \n                    int ind = gen.nextInt(n-i)+i; \n                    long d = a[i]; \n                    a[i] = a[ind]; \n                    a[ind] = d; \n                } \n                return a; \n            }\n         static class pair implements Comparable<pair>{\n             Integer x;\n             Integer y;\n             pair(int l,int id){\n                 this.x=l;\n                 this.y=id;\n             }\n              public int compareTo(pair o) {\n                     int result = x.compareTo(o.x);\n                     if(result==0)\n                         result = y.compareTo(o.y);\n                     \n                 return result;\n                 }  \n              public String toString(){\n                 return (x+\" \"+y);\n             }\n       }       \n \n      \n}"
        },
        {
            "language": 1,
            "solution": "from collections import defaultdict\nn,k=map(int,raw_input().split())\nd=defaultdict(list)\nfor i in range(n-1):\n    u,v,c=map(int,raw_input().split())\n    if not c:\n        d[u].append(v)\n        d[v].append(u)\nvis=[0]*(n+1)\ncom=[]\nfor i in range(1,n+1):\n    if not vis[i]:\n        vis[i]=1\n        c=0\n        q=[i]\n        while q:\n            x=q.pop()\n            c+=1\n            for j in d[x]:\n                if not vis[j]:\n                    vis[j]=1\n                    q.append(j)\n        com.append(c)\nn1=len(com)\nans=pow(n,k,1000000007)\nfor i in com:\n    ans=(ans-pow(i,k,1000000007))%1000000007\nprint ans\n\n                    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long powMOD(long long n, long long k) {\n  if (n == 0) return 0ll;\n  if (n == 1 || k == 0) {\n    return 1ll;\n  }\n  if (k == 1) {\n    return n % 1000000007;\n  }\n  long long x = powMOD(n, k / 2);\n  if (k % 2 == 0) {\n    return (x * x) % 1000000007;\n  }\n  return (((x * n) % 1000000007) * x) % 1000000007;\n}\nvoid f(int testCase) {\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int> > adj(n);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    if (x == 0) {\n      adj[u - 1].push_back(v - 1);\n      adj[v - 1].push_back(u - 1);\n    }\n  }\n  vector<long long> sizes;\n  vector<bool> vis(n, false);\n  for (int i = 0; i < n; i++) {\n    if (!vis[i]) {\n      queue<int> q;\n      long long count = 0ll;\n      q.push(i);\n      vis[i] = true;\n      while (!q.empty()) {\n        auto u = q.front();\n        q.pop();\n        count++;\n        for (auto v : adj[u]) {\n          if (!vis[v]) {\n            vis[v] = true;\n            q.push(v);\n          }\n        }\n      }\n      sizes.push_back(count);\n    }\n  }\n  long long ans = powMOD(n, k);\n  for (auto x : sizes) {\n    ans = (ans - powMOD(x, k)) % 1000000007;\n  }\n  cout << (ans + 1000000007) % 1000000007 << endl;\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  int t = 1;\n  for (int i = 1; i <= t; i++) f(i);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C implements Runnable {\n\tpublic static void main (String[] args) {new Thread(null, new C(), \"_cf\", 1 << 28).start();}\n\t\n\tpublic void run() {\n\t\tFastScanner fs = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tSystem.err.println(\"\");\n\n\t\tint n = fs.nextInt(), k = fs.nextInt();\n\t\tArrayList<int[]>[] adj = new ArrayList[n];\n\t\tfor(int i = 0; i < n; i++) adj[i] = new ArrayList<>();\n\t\tfor(int i = 0; i < n-1; i++) {\n\t\t\tint u = fs.nextInt()-1, v = fs.nextInt()-1;\n\t\t\tint c = fs.nextInt();\n\t\t\tadj[u].add(new int[] {v, c});\n\t\t\tadj[v].add(new int[] {u, c});\n\t\t}\n\t\tlong MOD = (long)1e9+7;\n\t\tlong res = pow(n, k, MOD);\n\t\tboolean[] vis = new boolean[n];\n\t\tArrayDeque<Integer> dq = new ArrayDeque<Integer>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(vis[i]) continue;\n\t\t\tdq.add(i);\n\t\t\tint sz = 0; vis[i] = true;\n\t\t\twhile(!dq.isEmpty()) {\n\t\t\t\tint u = dq.pollFirst();\n\t\t\t\tsz++;\n\t\t\t\tfor(int[] e : adj[u]) {\n\t\t\t\t\tint v = e[0], c = e[1];\n\t\t\t\t\tif(c == 1) continue;\n\t\t\t\t\tif(vis[v]) continue;\n\t\t\t\t\tvis[v] = true;\n\t\t\t\t\tdq.add(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres -= pow(sz, k, MOD);\n\t\t\twhile(res < 0) res += MOD;\n\t\t\tres %= MOD;\n\t\t}\n\t\tout.println(res);\n\t\tout.close();\n\t}\n\t\n\tlong pow(long base, long expo, long MOD) {\n\t\tif(expo == 0) return 1;\n\t\tif(expo == 1) return base;\n\t\tif(expo % 2 == 1) {\n\t\t\treturn (base * pow(base, expo-1, MOD)) % MOD;\n\t\t}\n\t\telse {\n\t\t\tlong ret = pow(base, expo/2, MOD);\n\t\t\treturn (ret * ret) % MOD;\n\t\t}\n\t}\n\n\tclass FastScanner {\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\n\t\tpublic FastScanner() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\n\t\tpublic FastScanner(String s) throws FileNotFoundException {\n\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t}\n\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}                \n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c!='.' ? cur:cur+nextLong()/num;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) res[i] = nextInt();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t}\n\n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5, mod = 1e9 + 7;\nvector<pair<int, int> > v[N];\nbool vis[N] = {};\nint dfs(int node, int par) {\n  int ret = 1;\n  vis[node] = true;\n  for (auto u : v[node]) {\n    if (u.first == par || u.second) continue;\n    ret += dfs(u.first, node);\n  }\n  return ret;\n}\nlong long fast_pow(int base, int power) {\n  if (!power) return 1;\n  long long answer = fast_pow(base, power / 2) % mod;\n  answer *= answer;\n  if (answer >= mod) answer %= mod;\n  if (power & 1) answer *= base;\n  if (answer >= mod) answer %= mod;\n  return answer;\n}\nint main() {\n  ios::sync_with_stdio(0), ios_base::sync_with_stdio(0), cin.tie(0),\n      cout.tie(0);\n  ;\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= (int)n - 1; ++i) {\n    int a, b, x;\n    cin >> a >> b >> x;\n    v[a].push_back({b, x});\n    v[b].push_back({a, x});\n  }\n  long long fans = fast_pow(n, k);\n  for (int i = 1; i <= (int)n; ++i) {\n    if (vis[i]) continue;\n    long long ans = dfs(i, i);\n    fans = (fans - fast_pow(ans, k) + mod) % mod;\n  }\n  cout << fans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom collections import defaultdict, deque\ninput = lambda: sys.stdin.readline().strip(\"\\r\\n\")\n\nMOD = 10**9 + 7\n\n\ndef BFS(v):\n    visited[v] = True\n    queue = deque()\n    queue.append(v)\n    cnt = 1\n\n    while queue:\n        curr = queue.popleft()\n        for i in g[curr]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n                cnt += 1\n    return cnt\n\n\ndef addEdges(edges, u, v):\n    edges[v].append(u)\n    edges[u].append(v)\n\n\nn, k = map(int, input().split())\ng = defaultdict(list)\n\nfor _ in range(n-1):\n    x, y, c = map(int, input().split())\n    if not c:\n        addEdges(g, x, y)\n\nvisited = [False] * (n + 1)\nans = pow(n, k, MOD)\nfor i in range(1, n+1):\n    if not visited[i]:\n        val = BFS(i)\n        ans = (ans - pow(val, k, MOD)) % MOD\nprint(ans % MOD)\n"
        },
        {
            "language": 3,
            "solution": "n,k=map(int,input().split())\nimport math\ntr=[[] for i in range(n)]\n\nfor i in range(n-1):\n\ta,b,x=map(int,input().split())\n\tif x==0:\n\t\ttr[a-1].append(b-1)\n\t\ttr[b-1].append(a-1)\n\nseq=[]\nv=[False for i in range(n)]\n\nfor i in range(n):\n\tif v[i]:continue\n\tm=[]\n\ts=[i]\n\twhile s:\n\t\tx=s.pop()\n\t\tm.append(x)\n\t\tv[x]=True\n\t\tfor y in tr[x]:\n\t\t\tif v[y]:continue\n\t\t\ts.append(y)\n\n\tseq.append(len(m))\n\nans=0\nmod=10**9+7\nfor i in seq:\n\tans=(ans+pow(i,k,mod))\nprint((pow(n,k,mod)-ans)%mod)"
        },
        {
            "language": 3,
            "solution": "def find(x):\n    if(par[x]==x):\n        return x\n    par[x]=find(par[x])\n    return par[x]\n\ndef union(a,x):\n    xa=find(a)\n    xb=find(b)\n    if(xa!=xb):\n        if(size[xa]>size[xb]):\n            xa,xb=xb,xa\n        size[xb]+=size[xa]\n        size[xa]=1\n        par[xa]=par[xb]\n\n\nn,k=map(int,input().split())\npar=[i for i in range(n+1)]\nsize=[1 for i in range(n+1)]\nvisited=[0 for i in range(n+1)]\nfor i in range(n-1):\n    a,b,c=map(int,input().split())\n    if(c==0):\n        visited[a]=1\n        visited[b]=1\n        union(a,b)\nf_ans=n**k\ncount=0\nans=0\nfor i in range(1,n+1):\n    ans+=size[i]**k  if(size[i]>1) else 0\n    if(visited[i]==0):\n        count+=1\nprint((f_ans-ans-(count))%(10**9+7))"
        },
        {
            "language": 3,
            "solution": "p = 10 ** 9 + 7\nn, k = map(int, input().split())\ng = [[] for _ in range(n)]\n# print(g)\nfor _ in range(n - 1):\n\ta, b, x = map(int, input().split())\n\tif(x != 0):\n\t\tcontinue\n\tg[a - 1].append(b - 1)\n\tg[b - 1].append(a - 1)\n# print(g)\n\nvisited = [False] * n\n# g = sorted(g, key = lambda x : len(x), reverse = True)\n# print(g)\nm = 0\nfor i in range(len(g)):\n\tif(visited[i] == True):\n\t\tcontinue\n\td = []\n\tvisited[i] =True\n\td.append(i)\n\tc = 0\n\twhile(d):\n\t\to = d.pop()\n\t\tfor j in g[o]:\n\t\t\tif(visited[j] == True):\n\t\t\t\tcontinue\n\t\t\tvisited[j] = True\n\t\t\td.append(j)\n\t\tc += 1\n\tm += pow(c, k, p)\n\nprint((pow(n, k, p) + p - m) % p)\t\n\t\t\n\t\t\n\t\t"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h \nfrom types import GeneratorType\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \nimport time\nstart_time = time.time()\n\nimport collections as col\nimport math, string\nfrom functools import reduce\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\n\n\n\"\"\"\nIt would appear to be enough to count the number of good pairs. Once we have this number, we can place the good pair in any of 2*(K-1) positions, and for each\nof these we have N**(K-2) choices\nDoes this create conflicts? Yes. Damn.\nIs it easier to count only red sequences? Probably\nThe total number of sequences is N**K\nNow we need to find the number of connected components with only red edges, and consider any nodes not in this list as isolated.\nAnswer is therefore N**K - sum_i(L_i**K) where L_i is the number of nodes in the ith red-connected component\n\"\"\"\nM = 10**9 + 7\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef solve():\n    N, K = getInts()\n    graph = col.defaultdict(set)\n    nodes = set([j+1 for j in range(N)])\n    for n in range(N-1):\n        U, V, X = getInts()\n        if not X:\n            graph[U].add(V)\n            graph[V].add(U)\n    ans = pow(N,K,M)\n    @bootstrap\n    def dfs(node):\n        if node in nodes:\n            nodes.remove(node)\n            visited.append(node)\n        for neighbour in graph[node]:\n            if neighbour in nodes:\n                yield dfs(neighbour)\n        yield\n    \n    while nodes:\n        node = next(iter(nodes))\n        visited = []\n        dfs(node)\n        ans -= pow(len(visited),K,M)\n    \n    return ans % M\n\n#for _ in range(getInt()):    \nprint(solve())\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nlong long dp[102][100005];\nvector<pair<int, int> > graph[100005];\nint grp[100005], sz[100005];\nint find_grp(int idx) {\n  if (grp[idx] == idx) return idx;\n  return grp[idx] = find_grp(grp[idx]);\n}\nint vt[100005];\nlong long mod = 1e9 + 7;\nlong long pow(int a, int b) {\n  long long ret = 1;\n  for (int i = 0; i < b; i++) {\n    ret = (ret * a) % mod;\n  }\n  return ret;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int t1, t2, t3;\n    cin >> t1 >> t2 >> t3;\n    graph[t1].push_back(pair<int, int>(t2, t3));\n    graph[t2].push_back(pair<int, int>(t1, t3));\n  }\n  for (int i = 1; i <= n; i++) grp[i] = i, sz[i] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (pair<int, int> nxt : graph[i]) {\n      if (nxt.second == 0) {\n        int b = nxt.first;\n        int a = i;\n        a = find_grp(a);\n        b = find_grp(b);\n        if (a != b) {\n          grp[a] = b;\n          sz[b] += sz[a];\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int a = find_grp(i);\n    if (vt[a] == 1) continue;\n    vt[a] = 1;\n    int s = sz[a];\n    ans = (ans - pow(s, k) + mod) % mod;\n  }\n  ans = (ans + pow(n, k)) % mod;\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import collections as cc\nI=lambda:list(map(int,input().split()))\nn,k=I()\nmod=10**9+7\nparent=[i for i in range(n+1)]\ndef find(x):\n\tglobal count\n\tcount+=1\n\twhile parent[x]!=x:\n\t\tx=parent[x]\n\treturn x\ndef union(x,y):\n\ta=find(x)\n\tb=find(y)\n\tif a!=b:\n\t\tparent[a]=parent[b]=min(a,b)\ncount=0\ntf=0\nfor i in range(n-1):\n\ta,b,c=I()\n\tif not c:\n\t\ttf=1\n\t\tunion(a,b)\n\ntemp=[find(i) for i in range(1,n+1)]\ntem=cc.Counter(temp)\nans=pow(n,k,mod)\nfor i in tem:\n\tans-=((tem[i]**k)%mod)\n\tans%=mod\nprint(ans)\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std::chrono;\nstruct custom_hash {\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    x ^= FIXED_RANDOM;\n    return x ^ (x >> 16);\n  }\n};\nvector<long long> ar[200001];\nbool vis[200001];\nlong long cnt;\nlong long modExp(long long base, long long exp) {\n  long long res = 1;\n  while (exp) {\n    if (exp % 2) res = (res * base) % 1000000007;\n    base = (base * base) % 1000000007;\n    exp /= 2;\n  }\n  return res;\n}\nvoid dfs(long long node) {\n  vis[node] = true;\n  cnt++;\n  for (long long child : ar[node]) {\n    if (!vis[child]) dfs(child);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, k, u, v, c;\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    cin >> u >> v >> c;\n    if (!c) {\n      ar[u].push_back(v);\n      ar[v].push_back(u);\n    }\n  }\n  long long ans;\n  ans = modExp(n, k);\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      cnt = 0;\n      dfs(i);\n      ans = (ans - modExp(cnt, k) + 1000000007) % 1000000007;\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n\n/*\n * Author    : joney_000[developer.jaswant@gmail.com]\n * Algorithm : N/A\n * Platform  : Codeforces\n * Ref       : \n */\n\npublic class A {\n\n  private InputStream inputStream;\n  private OutputStream outputStream;\n  private FastReader in;\n  private PrintWriter out;\n\n  private final int BUFFER = 100005;\n\n  private int auxInts[] = new int[BUFFER];\n  private long auxLongs[] = new long[1];\n  private double auxDoubles[] = new double[1];\n  private char auxChars[] = new char[1];\n  private final long mod = 1000000000 + 7;\n  private final int INF = Integer.MAX_VALUE;\n  private final long INF_L = Long.MAX_VALUE / 10;\n\n  public A() {\n  }\n\n  public A(boolean stdIO) throws FileNotFoundException {\n    // stdIO = false;\n    if (stdIO) {\n      inputStream = System.in;\n      outputStream = System.out;\n    } else {\n      inputStream = new FileInputStream(\"input.txt\");\n      outputStream = new FileOutputStream(\"output.txt\");\n    }\n    in = new FastReader(inputStream);\n    out = new PrintWriter(outputStream);\n  }\n\n  int n = 0, m = 0;\n\n  void run()throws Exception{\n    once();\n    clear();\n    n = i(); m = n - 1; int k = i();\n    for(int i = 1; i <= m; i++){\n      int u = i(); int v = i(); int w = i();\n      if(w == 1)continue;\n      adj[u].add(v);\n      adj[v].add(u);\n    }\n    LinkedList<Integer> adj0[] = getCopy(adj, n);     // wow \n    long ans = pow(n * 1L, k, mod);\n    for(int i = 1; i <= n ; i++){\n      if(vis[i])continue;\n      int cnt = dfs(adj0, i, n);    //Assuming that node 1 is the root node\n      ans = (ans - pow(cnt, k, mod) + mod) % mod;\n    }\n    out.write(\"\"+ans+\"\\n\");\n  \n  }// end run\n\n  void once(){\n    \n  }\n\n  int MAXN = 100005;\n  int depth[]  = new int[MAXN + 1];                  \n  int f[]  = new int[MAXN + 1];                  // f[i] = parent of i   \n  LinkedList<Integer> adj[] = new LinkedList[MAXN + 1];\n  boolean vis[] = new boolean[MAXN+1]; \n  \n  void clear(){\n    for(int i = 1; i <= MAXN; i++){\n      adj[i] = new LinkedList<Integer>();\n    }\n  }\n  \n  // Maintain immutability\n  LinkedList<Integer>[] getCopy(LinkedList<Integer>[] adj, int n)throws Exception{\n    LinkedList<Integer> adjCopy[] = new LinkedList[n + 1];\n    for(int i = 1; i <= n; i++){\n      adjCopy[i] = new LinkedList<Integer>();\n      for(int x: adj[i]){\n        adjCopy[i].add(x);\n      }\n    }\n    return adjCopy; \n  }\n\n  int dfs(LinkedList<Integer> adj[], int root, int n)throws Exception{\n  \n    LinkedList <Integer> queue = new LinkedList<Integer>();\n    int currentDepth = 0;               //level\n    queue.add(root);\n    vis[root] = true;\n    int cnt = 1;\n    while(!queue.isEmpty()){\n    \n      int u = queue.getLast();        // The Stack\n      depth[u] = currentDepth; \n\n      if(adj[u].size()>0){  \n        int v = adj[u].removeFirst();\n        if(!vis[v]){\n          queue.add(v);\n          currentDepth++;\n          vis[v]    = true;\n          depth[v]  = currentDepth;\n          cnt++;\n          // f[v] = u;\n        }\n      }else {\n        int v = queue.removeLast();\n        currentDepth--;\n      }\n    }\n    return cnt;\n  }\n\n  long gcd(long a, long b) {\n    if (b == 0)\n      return a;\n    return gcd(b, a % b);\n  }\n\n  long lcm(long a, long b) {\n    if (a == 0 || b == 0)\n      return 0;\n    return (a * b) / gcd(a, b);\n  }\n\n  long mulMod(long a, long b, long mod) {\n    if (a == 0 || b == 0)\n      return 0;\n    if (b == 1)\n      return a;\n    long ans = mulMod(a, b / 2, mod);\n    ans = (ans * 2) % mod;\n    if (b % 2 == 1)\n      ans = (a + ans) % mod;\n    return ans;\n  }\n\n  long pow(long a, long b, long mod) {\n    if (b == 0)\n      return 1;\n    if (b == 1)\n      return a;\n    long ans = pow(a, b / 2, mod);\n    ans = (ans * ans);\n    if (ans >= mod)\n      ans %= mod;\n\n    if (b % 2 == 1)\n      ans = (a * ans);\n    if (ans >= mod)\n      ans %= mod;\n\n    return ans;\n  }\n\n  // 20*20 nCr Pascal Table\n  long[][] ncrTable() {\n    long ncr[][] = new long[21][21];\n\n    for (int i = 0; i <= 20; i++) {\n      ncr[i][0] = ncr[i][i] = 1L;\n    }\n\n    for (int j = 0; j <= 20; j++) {\n      for (int i = j + 1; i <= 20; i++) {\n        ncr[i][j] = ncr[i - 1][j] + ncr[i - 1][j - 1];\n      }\n    }\n\n    return ncr;\n  }\n\n  int i() throws Exception {\n    return in.nextInt();\n  }\n\n  int[] is(int n) throws Exception {\n    for (int i = 1; i <= n; i++)\n      auxInts[i] = in.nextInt();\n    return auxInts;\n  }\n\n  long l() throws Exception {\n    return in.nextLong();\n  }\n\n  long[] ls(int n) throws Exception {\n    for (int i = 1; i <= n; i++)\n      auxLongs[i] = in.nextLong();\n    return auxLongs;\n  }\n\n  double d() throws Exception {\n    return in.nextDouble();\n  }\n\n  double[] ds(int n) throws Exception {\n    for (int i = 1; i <= n; i++)\n      auxDoubles[i] = in.nextDouble();\n    return auxDoubles;\n  }\n\n  char c() throws Exception {\n    return in.nextCharacter();\n  }\n\n  char[] cs(int n) throws Exception {\n    for (int i = 1; i <= n; i++)\n      auxChars[i] = in.nextCharacter();\n    return auxChars;\n  }\n\n  String s() throws Exception {\n    return in.nextLine();\n  }\n\n  BigInteger bi() throws Exception {\n    return in.nextBigInteger();\n  }\n\n  private void closeResources() {\n    out.flush();\n    out.close();\n    return;\n  }\n\n  // IMP: roundoff upto 2 digits\n  // double roundOff = Math.round(a * 100.0) / 100.0;\n  // or\n  // System.out.printf(\"%.2f\", val);\n\n  // print upto 2 digits after decimal\n  // val = ((long)(val * 100.0))/100.0;\n\n  public static void main(String[] args) throws java.lang.Exception {\n\n    A driver = new A(true);\n    driver.run();\n    driver.closeResources();\n  }\n}\n\nclass FastReader {\n\n  private boolean finished = false;\n\n  private InputStream stream;\n  private byte[] buf = new byte[4 * 1024];\n  private int curChar;\n  private int numChars;\n  private SpaceCharFilter filter;\n\n  public FastReader(InputStream stream) {\n    this.stream = stream;\n  }\n\n  public int read() {\n    if (numChars == -1) {\n      throw new InputMismatchException();\n    }\n    if (curChar >= numChars) {\n      curChar = 0;\n      try {\n        numChars = stream.read(buf);\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      if (numChars <= 0) {\n        return -1;\n      }\n    }\n    return buf[curChar++];\n  }\n\n  public int peek() {\n    if (numChars == -1) {\n      return -1;\n    }\n    if (curChar >= numChars) {\n      curChar = 0;\n      try {\n        numChars = stream.read(buf);\n      } catch (IOException e) {\n        return -1;\n      }\n      if (numChars <= 0) {\n        return -1;\n      }\n    }\n    return buf[curChar];\n  }\n\n  public int nextInt() {\n    int c = read();\n    while (isSpaceChar(c))\n      c = read();\n    int sgn = 1;\n    if (c == '-') {\n      sgn = -1;\n      c = read();\n    }\n    int res = 0;\n    do {\n      if (c == ',') {\n        c = read();\n      }\n      if (c < '0' || c > '9') {\n        throw new InputMismatchException();\n      }\n      res *= 10;\n      res += c - '0';\n      c = read();\n    } while (!isSpaceChar(c));\n    return res * sgn;\n  }\n\n  public long nextLong() {\n    int c = read();\n    while (isSpaceChar(c))\n      c = read();\n    int sgn = 1;\n    if (c == '-') {\n      sgn = -1;\n      c = read();\n    }\n    long res = 0;\n    do {\n      if (c < '0' || c > '9') {\n        throw new InputMismatchException();\n      }\n      res *= 10;\n      res += c - '0';\n      c = read();\n    } while (!isSpaceChar(c));\n    return res * sgn;\n  }\n\n  public String nextString() {\n    int c = read();\n    while (isSpaceChar(c))\n      c = read();\n    StringBuilder res = new StringBuilder();\n    do {\n      res.appendCodePoint(c);\n      c = read();\n    } while (!isSpaceChar(c));\n    return res.toString();\n  }\n\n  public boolean isSpaceChar(int c) {\n    if (filter != null) {\n      return filter.isSpaceChar(c);\n    }\n    return isWhitespace(c);\n  }\n\n  public static boolean isWhitespace(int c) {\n    return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n  }\n\n  private String readLine0() {\n    StringBuilder buf = new StringBuilder();\n    int c = read();\n    while (c != '\\n' && c != -1) {\n      if (c != '\\r') {\n        buf.appendCodePoint(c);\n      }\n      c = read();\n    }\n    return buf.toString();\n  }\n\n  public String nextLine() {\n    String s = readLine0();\n    while (s.trim().length() == 0)\n      s = readLine0();\n    return s;\n  }\n\n  public String nextLine(boolean ignoreEmptyLines) {\n    if (ignoreEmptyLines) {\n      return nextLine();\n    } else {\n      return readLine0();\n    }\n  }\n\n  public BigInteger nextBigInteger() {\n    try {\n      return new BigInteger(nextString());\n    } catch (NumberFormatException e) {\n      throw new InputMismatchException();\n    }\n  }\n\n  public char nextCharacter() {\n    int c = read();\n    while (isSpaceChar(c))\n      c = read();\n    return (char) c;\n  }\n\n  public double nextDouble() {\n    int c = read();\n    while (isSpaceChar(c))\n      c = read();\n    int sgn = 1;\n    if (c == '-') {\n      sgn = -1;\n      c = read();\n    }\n    double res = 0;\n    while (!isSpaceChar(c) && c != '.') {\n      if (c == 'e' || c == 'E') {\n        return res * Math.pow(10, nextInt());\n      }\n      if (c < '0' || c > '9') {\n        throw new InputMismatchException();\n      }\n      res *= 10;\n      res += c - '0';\n      c = read();\n    }\n    if (c == '.') {\n      c = read();\n      double m = 1;\n      while (!isSpaceChar(c)) {\n        if (c == 'e' || c == 'E') {\n          return res * Math.pow(10, nextInt());\n        }\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        m /= 10;\n        res += (c - '0') * m;\n        c = read();\n      }\n    }\n    return res * sgn;\n  }\n\n  public boolean isExhausted() {\n    int value;\n    while (isSpaceChar(value = peek()) && value != -1)\n      read();\n    return value == -1;\n  }\n\n  public String next() {\n    return nextString();\n  }\n\n  public SpaceCharFilter getFilter() {\n    return filter;\n  }\n\n  public void setFilter(SpaceCharFilter filter) {\n    this.filter = filter;\n  }\n\n  public interface SpaceCharFilter {\n    public boolean isSpaceChar(int ch);\n  }\n}\n\nclass Pair implements Comparable<Pair> {\n  public int a;\n  public int b;\n\n  public Pair() {\n    this.a = 0;\n    this.b = 0;\n  }\n\n  public Pair(int a, int b) {\n    this.a = a;\n    this.b = b;\n  }\n\n  public int compareTo(Pair p) {\n    if (this.a == p.a) {\n      return this.b - p.b;\n    }\n    return this.a - p.a;\n  }\n\n  @Override\n  public String toString() {\n    return \"a = \" + this.a + \" b = \" + this.b;\n  }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\n\n/**\n * @author solarbeam\n */\n\npublic class CF1139C {\n    public static void main(String[] args) throws FileNotFoundException, InterruptedException {\n        InputStream stream = System.in;\n        Logger logger = new Logger();\n        if (args.length > 0 && args[0].equals(\"LOCAL\")) {\n            File inputFile = new File(\"resources/input.in\");\n            stream = new DataInputStream(new FileInputStream(inputFile));\n            logger.enableLogging(true, \"resources/logs.txt\");\n        }\n        InputReader in = new InputReader(stream);\n        PrintWriter out = new PrintWriter(System.out);\n        Runnable solver = () -> {\n            new Task1().solve(in, out, logger);\n        };\n        Thread th = new Thread(null, solver, \"Task1\", 1 << 24);\n        th.start();\n        th.join();\n        out.close();\n        logger.close();\n    }\n\n    static class Task1 {\n        static final int MOD = 1000000007;\n        boolean[] marked;\n        ArrayList<Integer>[] adj;\n\n        public void solve(InputReader in, PrintWriter out, Logger logger) {\n            int n = in.nextInt(), k = in.nextInt();\n            adj = new ArrayList[n+1];\n            for(int i=1; i<=n; i++)\n                adj[i] = new ArrayList<Integer>();\n\n            for(int i=1; i<=n-1; i++){\n                int u = in.nextInt(), v = in.nextInt(), type = in.nextInt();\n                if(type==0){\n                    adj[u].add(v);\n                    adj[v].add(u);\n                }\n            }\n\n            ArrayList<Integer> connectedComponentsSize = new ArrayList<Integer>();\n            marked = new boolean[n+1];\n            for(int i=1; i<=n; i++){\n                if(!marked[i]){\n                    int dfsSize = dfs(i);\n                    if(dfsSize>1) connectedComponentsSize.add(dfsSize);\n                }\n            }\n\n            for(int i: connectedComponentsSize){\n                logger.log(i+\" \");\n            }\n            logger.logln(\"\");\n\n            long ans = (fastPower(n, k) - n + MOD)%MOD;\n            for(int i:connectedComponentsSize){\n                ans = (ans - fastPower(i, k) + MOD)%MOD;\n                ans = (ans + i)%MOD;\n            }\n            out.println(ans);\n        }\n\n        int dfs(int v){\n            marked[v] = true;\n            int ans = 0;\n            for(int w:adj[v]){\n                if(!marked[w])\n                    ans += dfs(w);\n            }\n            return 1+ans;\n        }\n\n        long fastPower(long a, long b){\n            long result = 1;\n            while(b>0){\n                if(b%2==1) result = (result*a)%MOD;\n                a = (a*a)%MOD;\n                b >>= 1;\n            }\n            return result%MOD;\n        }\n    }\n\n    static class Logger {\n        private PrintWriter logger;\n        private boolean enableLogging;\n\n        public void enableLogging(boolean enableLogging, String filename) {\n            this.enableLogging = enableLogging;\n            try {\n                if (enableLogging) this.logger = new PrintWriter(filename);\n            } catch (FileNotFoundException e) {\n            }\n        }\n\n        public void log(Object s) {\n            if (enableLogging) {\n                logger.print(s.toString());\n            }\n        }\n\n        public void logln(Object s) {\n            if (enableLogging) {\n                logger.println(s.toString());\n            }\n        }\n\n        public void close() {\n            if (enableLogging) logger.close();\n        }\n    }\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.Stack;\n\npublic class JavaApplication6 {\n\n    static PrintWriter out = new PrintWriter(System.out);\n    static long x = 1000000007;\n\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n        int[] tab = parseArray(input);\n        int n = tab[0];\n        int m = tab[1];\n        long sum = 0;\n        long result = 1;\n        boolean[] find = new boolean[n + 1];\n        disjointset ds = new disjointset(n + 1);\n        for (int k = 0; k < n - 1; k++) {\n            tab = parseArray(input);\n            if (tab[2] == 0) {\n                ds.unify(tab[0], tab[1]);\n            }\n        }\n        ArrayList<Integer> set = new ArrayList<>();\n\n        Arrays.fill(find, false);\n        for (int k = 1; k <= n; k++) {\n            if (!find[ds.find(k)] && ds.componentSize(k) != 1) {\n\n                set.add(ds.componentSize(k));\n                find[ds.find(k)] = true;\n            }\n        }\n\n        for (int e : set) {\n            long temp = 1;\n            for (int k = 0; k < m; k++) {\n                temp *= e;\n                temp %= x;\n            }\n            temp = (temp - e + x) % x;\n            sum += temp;\n            sum %= x;\n        }\n\n        for (int k = 0; k < m; k++) {\n            result *= n;\n            result %= x;\n        }\n        result = (result - n + x) % x;\n        result = (result - sum + x) % x;\n        out.println(result);\n        out.close();\n    }\n\n    static int[] parseArray(BufferedReader gi) throws IOException {\n        String[] line = gi.readLine().trim().split(\" \");\n        int[] rez = new int[line.length];\n        for (int k = 0; k < line.length; k++) {\n            rez[k] = Integer.parseInt(line[k]);\n        }\n        return rez;\n    }\n\n}\n\nclass disjointset {\n\n    private int size;\n    private int[] component;\n    private int[] id;\n    private int nc;\n\n    public disjointset(int size) {\n\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"error size \");\n        }\n\n        this.size = nc = size;\n        component = new int[size];\n        id = new int[size];\n\n        for (int i = 0; i < size; i++) {\n            id[i] = i;\n            component[i] = 1;\n        }\n\n    }\n\n    public int find(int p) {\n\n        int root = p;\n        while (root != id[root]) {\n            root = id[root];\n        }\n        while (p != root) {\n            int next = id[p];\n            id[p] = root;\n            p = next;\n        }\n\n        return root;\n\n    }\n\n    \n\n    public int componentSize(int p) {\n        return component[find(p)];\n    }\n\n    \n\n    public void unify(int p, int q) {\n        int r1 = find(p);\n        int r2 = find(q);\n        if (r1 == r2) {\n            return;\n        }\n        if (component[r1] < component[r2]) {\n            component[r2] += component[r1];\n            id[r1] = r2;\n        } else {\n            component[r1] += component[r2];\n            id[r2] = r1;\n        }\n        nc--;\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\n\npublic class N1139C {\n\tstatic PrintWriter out;\n\tstatic Scanner sc;\n\tstatic ArrayList<Integer>ans,w;\n\tstatic ArrayList<Point>adj[];\n\tstatic HashSet<Integer>primesH;\n\tstatic boolean can;\n\t//static ArrayList<Integer>a;\n\tstatic HashSet<Long>h,tmp;\n\tstatic boolean[]vis;\n\tstatic int[]a,b,c,d,col,dist;\n\tstatic int[][]g;\n\tstatic long[]l,dp;\n\tstatic char[][]mp;\n\tstatic long oo=(long)1e9+7;\n\tpublic static void main(String[]args) throws IOException {\n\t\tsc=new Scanner(System.in);\n\t\tout=new PrintWriter(System.out);\n\t\tint n=ni(),k=ni();\n\t\tint x,y,w;\n\t\tadj=new ArrayList[n];\n\t\tvis=new boolean[n];\n\n\t\tfor(int i=0;i<n;i++)adj[i]=new ArrayList<Point>();\n\t//\tg=new int[n][n];\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tx=sc.nextInt()-1;\n\t\t\ty=sc.nextInt()-1;\n\t\t\tw=sc.nextInt();\n\t\t\tadj[y].add(new Point(x,w));\n\t\t\tadj[x].add(new Point(y,w));\n\t\t}\n\t\tans=new ArrayList<Integer>();\n\t\tlong res=pow(n,k);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(!vis[i]) {\n\t\t\t\tlong cur=dfs(i);\n\t\t\t\tlong pow=pow(cur,k);\n\t\t\t\tres=(res-pow%oo+oo)%oo;\n//\t\t\t\tif(res<0) {\n//\t\t\t\t\tres=(res+oo)%oo;\n//\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(res);\n\t\t\n\t\tout.close();\n\t}\n\n\n\tprivate static long pow(long a, long b) {\n\t\tif(b==0)return 1;\n\t\tlong sq=pow(a,b/2)%oo;\n\t\tsq=(sq*sq)%oo;\n\t\tif(b%2==1) {\n\t\t\tsq=(sq*a)%oo;\n\t\t}\n\t\treturn sq%oo;\n\t}\n\n\n\tprivate static int dfs(int u) {\n\t\tvis[u]=true;\n\t\tint ans=1;\n\t\tfor(Point p:adj[u]) {\n\t\t\tif(!vis[p.x]&&p.y==0) {\n\t\t\t\tans+=dfs(p.x);\n\t\t\t}\n\t\t}\n\t    return ans;\n\t}\n\n\tprivate static void disp(int[] revl) {\n\t\tfor(int i=0;i<revl.length;i++) {\n\t\t\tout.print(revl[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tstatic class Pair implements Comparable<Pair>{\n\t\tint a,b;\n\t\tPair(int a,int b){\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair p) {\n\t\t\treturn a-p.a;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"(\"+a+\" \"+b+\")\";\n\t\t}\n\t}\n\tstatic int ni() throws IOException {\n\t\treturn sc.nextInt();\n\t}\n\tstatic double nd() throws IOException {\n\t\treturn sc.nextDouble();\n\t}\n\tstatic long nl() throws IOException {\n\t\treturn  sc.nextLong();\n\t}\n\tstatic String ns() throws IOException {\n\t\treturn sc.next();\n\t}\n\tstatic int[] nai(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\treturn a;\n\t}\n\tstatic long[] nal(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = sc.nextLong();\n\t\treturn a;\n\t}\n\tstatic int[][] nmi(int n,int m) throws IOException{\n\t\tint[][]a=new int[n][m];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\ta[i][j]=sc.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\tstatic long[][] nml(int n,int m) throws IOException{\n\t\tlong[][]a=new long[n][m];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\ta[i][j]=sc.nextLong();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\tstatic void o(String x) {\n\t\tout.print(x);\n\t}\n\tstatic void ol(String x) {\n\t\tout.println(x);\n\t}\n\tstatic void ol(int x) {\n\t\tout.println(x);\n\t}\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic boolean hasNext() {return st.hasMoreTokens();}\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\t\n\t\tpublic double nextDouble() throws IOException {return Double.parseDouble(next());}\n\t\t\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\t\t\t\n\t\tpublic boolean ready() throws IOException {return br.ready(); }\n\t\t\n\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "N, k = map(int, input().split())\nMOD = 10 ** 9 + 7\ngr = [-1] * N\nG = [[] for i in range(N)]\nfor i in range(N - 1):\n    a, b, c = map(int, input().split())\n    if c == 0:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n\ng = 0\nfor i in range(N):\n    if gr[i] == -1:\n        que = [i]\n        while que:\n            j = que.pop()\n            gr[j] = g\n            for w in G[j]:\n                if gr[w] == -1:\n                    que.append(w)\n        g += 1\n\nnum = 0\nans = (N ** k) % MOD\nd = [0] * N\nfor i in range(N):\n    if gr[i] != -1:\n        d[gr[i]] += 1\n\nfor i in range(N):\n    num += d[i] ** k\n    num %= MOD\n\nprint((ans - num + MOD) % MOD)"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.AbstractSet;\nimport java.util.Set;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.AbstractMap;\nimport java.util.Map;\nimport java.io.Writer;\nimport java.util.Map.Entry;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author @Ziklon\n */\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    CEdgyTrees solver = new CEdgyTrees();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class CEdgyTrees {\n    long MOD = (int) 1e9 + 7;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.readInt(), k = in.readInt();\n      RecursiveIndependentSetSystem ris = new RecursiveIndependentSetSystem(n);\n\n      for (int i = 0; i + 1 < n; ++i) {\n        int x = in.readInt() - 1, y = in.readInt() - 1, z = in.readInt();\n        if (z == 0) ris.join(x, y);\n      }\n\n      Counter<Integer> counter = new Counter<>();\n      for (int i = 0; i < n; ++i) counter.add(ris.get(i));\n\n      if (ris.getSetCount() == 1) {\n        out.printLine(0);\n        return;\n      }\n\n      long ans = IntegerUtils.power(n, k, MOD);\n\n      for (long setCount : counter.values()) {\n\n        ans = (ans - IntegerUtils.power(setCount, k, MOD) + MOD) % MOD;\n      }\n\n      out.printLine(ans);\n    }\n  }\n\n  static class EHashMap<E, V> extends AbstractMap<E, V> {\n    private static final int[] shifts = new int[10];\n    private int size;\n    private EHashMap.HashEntry<E, V>[] data;\n    private int capacity;\n    private Set<Entry<E, V>> entrySet;\n\n    static {\n      Random random = new Random(System.currentTimeMillis());\n      for (int i = 0; i < 10; i++) {\n        shifts[i] = 1 + 3 * i + random.nextInt(3);\n      }\n    }\n\n    public EHashMap() {\n      this(4);\n    }\n\n    private void setCapacity(int size) {\n      capacity = Integer.highestOneBit(4 * size);\n      //noinspection unchecked\n      data = new EHashMap.HashEntry[capacity];\n    }\n\n    public EHashMap(int maxSize) {\n      setCapacity(maxSize);\n      entrySet =\n          new AbstractSet<Entry<E, V>>() {\n\n            public Iterator<Entry<E, V>> iterator() {\n              return new Iterator<Entry<E, V>>() {\n                private EHashMap.HashEntry<E, V> last = null;\n                private EHashMap.HashEntry<E, V> current = null;\n                private EHashMap.HashEntry<E, V> base = null;\n                private int lastIndex = -1;\n                private int index = -1;\n\n                public boolean hasNext() {\n                  if (current == null) {\n                    for (index++; index < capacity; index++) {\n                      if (data[index] != null) {\n                        base = current = data[index];\n                        break;\n                      }\n                    }\n                  }\n                  return current != null;\n                }\n\n                public Entry<E, V> next() {\n                  if (!hasNext()) {\n                    throw new NoSuchElementException();\n                  }\n                  last = current;\n                  lastIndex = index;\n                  current = current.next;\n                  if (base.next != last) {\n                    base = base.next;\n                  }\n                  return last;\n                }\n\n                public void remove() {\n                  if (last == null) {\n                    throw new IllegalStateException();\n                  }\n                  size--;\n                  if (base == last) {\n                    data[lastIndex] = last.next;\n                  } else {\n                    base.next = last.next;\n                  }\n                }\n              };\n            }\n\n            public int size() {\n              return size;\n            }\n          };\n    }\n\n    public EHashMap(Map<E, V> map) {\n      this(map.size());\n      putAll(map);\n    }\n\n    public Set<Entry<E, V>> entrySet() {\n      return entrySet;\n    }\n\n    public void clear() {\n      Arrays.fill(data, null);\n      size = 0;\n    }\n\n    private int index(Object o) {\n      return getHash(o.hashCode()) & (capacity - 1);\n    }\n\n    private int getHash(int h) {\n      int result = h;\n      for (int i : shifts) {\n        result ^= h >>> i;\n      }\n      return result;\n    }\n\n    public V remove(Object o) {\n      if (o == null) {\n        return null;\n      }\n      int index = index(o);\n      EHashMap.HashEntry<E, V> current = data[index];\n      EHashMap.HashEntry<E, V> last = null;\n      while (current != null) {\n        if (current.key.equals(o)) {\n          if (last == null) {\n            data[index] = current.next;\n          } else {\n            last.next = current.next;\n          }\n          size--;\n          return current.value;\n        }\n        last = current;\n        current = current.next;\n      }\n      return null;\n    }\n\n    public V put(E e, V value) {\n      if (e == null) {\n        return null;\n      }\n      int index = index(e);\n      EHashMap.HashEntry<E, V> current = data[index];\n      if (current != null) {\n        while (true) {\n          if (current.key.equals(e)) {\n            V oldValue = current.value;\n            current.value = value;\n            return oldValue;\n          }\n          if (current.next == null) {\n            break;\n          }\n          current = current.next;\n        }\n      }\n      if (current == null) {\n        data[index] = new EHashMap.HashEntry<E, V>(e, value);\n      } else {\n        current.next = new EHashMap.HashEntry<E, V>(e, value);\n      }\n      size++;\n      if (2 * size > capacity) {\n        EHashMap.HashEntry<E, V>[] oldData = data;\n        setCapacity(size);\n        for (EHashMap.HashEntry<E, V> entry : oldData) {\n          while (entry != null) {\n            EHashMap.HashEntry<E, V> next = entry.next;\n            index = index(entry.key);\n            entry.next = data[index];\n            data[index] = entry;\n            entry = next;\n          }\n        }\n      }\n      return null;\n    }\n\n    public V get(Object o) {\n      if (o == null) {\n        return null;\n      }\n      int index = index(o);\n      EHashMap.HashEntry<E, V> current = data[index];\n      while (current != null) {\n        if (current.key.equals(o)) {\n          return current.value;\n        }\n        current = current.next;\n      }\n      return null;\n    }\n\n    public boolean containsKey(Object o) {\n      if (o == null) {\n        return false;\n      }\n      int index = index(o);\n      EHashMap.HashEntry<E, V> current = data[index];\n      while (current != null) {\n        if (current.key.equals(o)) {\n          return true;\n        }\n        current = current.next;\n      }\n      return false;\n    }\n\n    public int size() {\n      return size;\n    }\n\n    private static class HashEntry<E, V> implements Entry<E, V> {\n      private final E key;\n      private V value;\n      private EHashMap.HashEntry<E, V> next;\n\n      private HashEntry(E key, V value) {\n        this.key = key;\n        this.value = value;\n      }\n\n      public E getKey() {\n        return key;\n      }\n\n      public V getValue() {\n        return value;\n      }\n\n      public V setValue(V value) {\n        V oldValue = this.value;\n        this.value = value;\n        return oldValue;\n      }\n    }\n  }\n\n  static class RecursiveIndependentSetSystem implements IndependentSetSystem {\n    private final int[] color;\n    private final int[] rank;\n    private int setCount;\n    private IndependentSetSystem.Listener listener;\n\n    public RecursiveIndependentSetSystem(int size) {\n      color = new int[size];\n      rank = new int[size];\n      for (int i = 0; i < size; i++) {\n        color[i] = i;\n      }\n      setCount = size;\n    }\n\n    public RecursiveIndependentSetSystem(RecursiveIndependentSetSystem other) {\n      color = other.color.clone();\n      rank = other.rank.clone();\n      setCount = other.setCount;\n    }\n\n    public boolean join(int first, int second) {\n      first = get(first);\n      second = get(second);\n      if (first == second) {\n        return false;\n      }\n      if (rank[first] < rank[second]) {\n        int temp = first;\n        first = second;\n        second = temp;\n      } else if (rank[first] == rank[second]) {\n        rank[first]++;\n      }\n      setCount--;\n      color[second] = first;\n      if (listener != null) {\n        listener.joined(second, first);\n      }\n      return true;\n    }\n\n    public int get(int index) {\n      int start = index;\n      while (color[index] != index) {\n        index = color[index];\n      }\n      while (start != index) {\n        int next = color[start];\n        color[start] = index;\n        start = next;\n      }\n      return index;\n    }\n\n    public int getSetCount() {\n      return setCount;\n    }\n  }\n\n  static class OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n    public void printLine(long i) {\n      writer.println(i);\n    }\n\n    public void printLine(int i) {\n      writer.println(i);\n    }\n  }\n\n  static interface IndependentSetSystem {\n    interface Listener {\n      void joined(int joinedRoot, int root);\n    }\n  }\n\n  static class Counter<K> extends EHashMap<K, Long> {\n    public Counter() {\n      super();\n    }\n\n    public Counter(int capacity) {\n      super(capacity);\n    }\n\n    public long add(K key) {\n      long result = get(key);\n      put(key, result + 1);\n      return result + 1;\n    }\n\n    public Long get(Object key) {\n      if (containsKey(key)) {\n        return super.get(key);\n      }\n      return 0L;\n    }\n  }\n\n  static class IntegerUtils {\n    public static long power(long base, long exponent, long mod) {\n      if (base >= mod) {\n        base %= mod;\n      }\n      if (exponent == 0) {\n        return 1 % mod;\n      }\n      long result = power(base, exponent >> 1, mod);\n      result = result * result % mod;\n      if ((exponent & 1) != 0) {\n        result = result * base % mod;\n      }\n      return result;\n    }\n  }\n\n  static class InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private InputReader.SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (numChars == -1) {\n        throw new InputMismatchException();\n      }\n      if (curChar >= numChars) {\n        curChar = 0;\n        try {\n          numChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (numChars <= 0) {\n          return -1;\n        }\n      }\n      return buf[curChar++];\n    }\n\n    public int readInt() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n      if (filter != null) {\n        return filter.isSpaceChar(c);\n      }\n      return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n      public boolean isSpaceChar(int ch);\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<pair<long long, long long> > > grafo;\nvector<int> tomados;\nint n, k;\nlong long total;\nvoid dfs(int u) {\n  tomados[u] = 1;\n  for (int i = 0; i < (int)grafo[u].size(); ++i) {\n    pair<long long, long long> v = grafo[u][i];\n    if (!tomados[v.first]) {\n      if (v.second) continue;\n      dfs(v.first);\n      tomados[u] += tomados[v.first];\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  vector<pair<long long, long long> > empty;\n  cin >> n >> k;\n  grafo.assign(n, empty);\n  tomados.assign(n, 0);\n  int x, y, z;\n  for (int i = 0; i < n - 1; ++i) {\n    cin >> x >> y >> z;\n    grafo[x - 1].push_back({y - 1, z});\n    grafo[y - 1].push_back({x - 1, z});\n  }\n  total = 1;\n  for (int i = 0; i < k; ++i) {\n    total *= n;\n    total %= 1000000000 + 7;\n  }\n  for (int i = 0; i < n; ++i) {\n    if (tomados[i]) continue;\n    dfs(i);\n    long long a = 1;\n    for (int j = 0; j < k; ++j) {\n      a *= (long long)tomados[i];\n      a %= 1000000000 + 7;\n    }\n    total -= a;\n    total += 1000000000 + 7;\n    total %= 1000000000 + 7;\n  }\n  cout << total << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long global = 1;\nvoid dfs(long long* vis, vector<long long>* adj, long long curr) {\n  vis[curr] = 1;\n  for (long long i = 0; i < adj[curr].size(); i++) {\n    if (vis[adj[curr][i]] == 0) {\n      global++;\n      dfs(vis, adj, adj[curr][i]);\n    }\n  }\n}\nlong long prime = 1000000007;\nlong long process_ret(long long ret, long long k) {\n  long long ans = 1;\n  ret = ret % prime;\n  while (k > 0) {\n    if (k & 1) ans = (ans * ret) % prime;\n    k = k >> 1;\n    ret = (ret * ret) % prime;\n  }\n  return ans;\n}\nint main() {\n  long long n, k;\n  cin >> n >> k;\n  vector<long long> adj[n];\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, v, x;\n    cin >> u >> v >> x;\n    u--;\n    v--;\n    if (x == 0) {\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n  }\n  long long vis[n];\n  for (long long i = 0; i < n; i++) vis[i] = 0;\n  long long ans = 0;\n  for (long long i = 0; i < n; i++) {\n    if (!vis[i]) {\n      global = 1;\n      dfs(vis, adj, i);\n      long long ret = global;\n      ans = (ans % prime + process_ret(ret, k)) % prime;\n    }\n  }\n  long long total = process_ret(n, k);\n  cout << (total - ans + prime) % prime;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nfrom collections import deque, defaultdict\nfrom sys import stdin, stdout\ninput = stdin.readline\n# print = stdout.write\nlistin = lambda : list(map(int, input().split()))\nmapin = lambda : map(int, input().split())\nn, k = mapin()\nd = defaultdict(list)\nfor _ in range(n-1):\n    u, v, z = mapin()\n    if not z:\n        d[u-1].append(v-1)\n        d[v-1].append(u-1)\nmark = [0]*n\ntree_num = 1\nfor i in range(n):\n    if not mark[i]:\n        mark[i] = tree_num\n        q = deque([i])\n        while q:\n            first = q.pop()\n            for j in d[first]:\n                if not mark[j]:\n                    mark[j] = tree_num\n                    q.append(j)\n        tree_num+=1\ncount = defaultdict(int)\nfor i in mark:\n    count[i]+=1\nex = 0\nmod = 10**9 + 7\nfor i in count.values():\n    ex+=pow(i, k, mod)\nprint((pow(n, k, mod)+mod - ex)%mod)"
        },
        {
            "language": 4,
            "solution": "/*\n......................................................................................................................................\n.....................................  ________ ____ __________________________________________ .....................................\n..................................... /  _____/|    |   \\      \\__    ___/\\_   _____/\\______   \\.....................................\n...................................../   \\  ___|    |   /   |   \\|    |    |    __)_  |       _/.....................................\n.....................................\\    \\_\\  \\    |  /    |    \\    |    |        \\ |    |   \\.....................................\n..................................... \\______  /______/\\____|__  /____|   /_______  / |____|_  /.....................................\n.....................................        \\/                \\/                 \\/         \\/ .....................................\n......................................................................................................................................\n.............................................................,;'';:...................................................................\n........................................................+@@@@@@@@@@@@@@'..............................................................\n.....................................................#@@@##############@@@:...........................................................\n...................................................@@@####################@@,.........................................................\n.................................................@@#########################@@........................................................\n...............................................:@############################@@.......................................................\n..............................................@@######@@@#';;'#@@@############@@:.....................................................\n.............................................@#####@@,````````````,@@###########@:....................................................\n............................................@####@;``````````````````+@##########@....................................................\n...........................................@###@:``````````````````````#@########@@...................................................\n..........................................@####``````````````````````````@########@@..................................................\n.........................................###@.````````````````````````````@########@+.................................................\n.........................................@#@```````````````````````````````#########@.................................................\n........................................@#@`````````````````````````````````########@@................................................\n.......................................,@@```````````````````````````````````@#######@:...............................................\n.......................................@@`````````````````````````````````````@#######@...............................................\n.......................................@:````````````````````#@@'``````````````@######@+..............................................\n......................................#@```````````````````@@@@@@@#````````````########@..............................................\n......................................@```````````````````@@@@@@@@@@````````````@######@+.............................................\n......................................@``````````````````@@@@@@@+   +```````````+#######@.............................................\n.....................................;:``````````````````@@@@@@@    @````````````@######@'............................................\n.....................................@``````````````````:@@@@@@@    @````````````@#######@............................................\n.....................................@```,@@@#``````````;@@@@@@@    @````````````:#######@:...........................................\n.....................................@``@@@@@@@@````````.@@@@@@@#  ,#`````````````@#######@...........................................\n.....................................@`@@@@@@@+'@````````@@@@@@@@@@@``````````````@#######@...........................................\n.....................................@,@@@@@@   ,```:+:``:@@@@@@@@@.``````````````@########@..........................................\n.....................................#@@@@@@@  ;@@#;,,,@``:@@@@@@@````````````````#########@..........................................\n.....................................+@@@@@@@@',,,,,,,,;,```.'+;``````````````````'########@;.........................................\n.....................................'@@@@',,,,,,,,,,,,,@`````````````````````````:#########@.........................................\n....................................:@#,,,,,:;;;;;:,,,,,@`````````````````````````.#########@.........................................\n.................................:@#@@@@#++';;;;;;;;;;;;@``````````````````````````##########+........................................\n...............................#@#+;;;;;;;;;;;;;;;;;;;;':``````````````````````````##########@........................................\n....................................,@#@@@@@#+'';;;;;+@#```````````````````````````##########@........................................\n.....................................@``````````.,,,.``````````````````````````````############.......................................\n.....................................@`````````````````````````````````````````````#######+'+#@.......................................\n.....................................@`````````````````````````````````````````````##########'@.......................................\n.....................................#`````````````````````````````````````````````############@#.....................................\n.....................................:.````````````````````````````````````````````##############@,...................................\n......................................+```````````````````````````````````````````.###############@#..................................\n......................................@```````````````````````````````````````````.################@@.................................\n......................................@```````````````````````````````````````````.###+##############@................................\n......................................@```````````````````````````````````````````.###+###############@...............................\n......................................',``````````````````````````````````````````.####'##############@@..............................\n.......................................@```````````````````````````````````````````#####+##############@:.............................\n.......................................@```````````````````````````````````````````#####'###############@.............................\n.......................................@```````````````````````````````````````````######'################............................\n.......................................#,``````````````````````````````````````````#######'##############@............................\n........................................@``````````````````````````````````````````@######++##############+...........................\n........................................@``````````````````````````````````````````@#######'##############@...........................\n........................................@``````````````````````````````````````````@########'#############@...........................\n.......................................@#'`````````````````````````````````````````@#########'##############..........................\n.......................................@#@`````````````````````````````````````````+#########+'############@..........................\n......................................@##@`````````````````````````````````````````.##########+'###########@..........................\n......................................@##@:`````````````````````````````````````````###########+'###########..........................\n.....................................:@###@`````````````````````````````````````````@###########+'+#########,.........................\n.....................................@####@`````````````````````````````````````````@#############''########..........................\n.....................................@####@.````````````````````````````````````````;##############+'######@..........................\n.....................................@#####@`````````````````````````````````````````################@@@###+..........................\n.....................................@#####@`````````````````````````````````````````@###############@..;;............................\n....................................,@#####@.````````````````````````````````````````+################'...............................\n....................................:#######@`````````````````````````````````````````################@...............................\n....................................:#######@`````````````````````````````````````````@###############@...............................\n....................................,@#######,````````````````````````````````````````:###############@...............................\n.....................................@######@@`````````````````````````````````````````@##############@...............................\n.....................................@######@@`````````````````````````````````````````+##############@...............................\n.....................................@#####@,;;`````````````````````````````````````````@#############@...............................\n.....................................@####@@..@`````````````````````````````````````````+#############@...............................\n.....................................,####@...@``````````````````````````````````````````@############+...............................\n......................................@##@.....@`````````````````````````````````````````:###########@,...............................\n.......................................@+......@``````````````````````````````````````````@##########@................................\n...............................................:#``````````````````````````````````````````##########@................................\n................................................@``````````````````````````````````````````+########@,................................\n................................................'+``````````````````````````````````````````@#######@.................................\n.................................................@```````````````````````````````````````````@#####@:.................................\n.................................................'#``````````````````````````````````````````.#####@..................................\n..................................................@```````````````````````````````````````````;###@...................................\n...................................................@```````````````````````````````````````````+#@'...................................\n...................................................'#```````````````````````````````````````````@#....................................\n....................................................##`````````````````````````````````````````@#.....................................\n.....................................................#@```````````````````````````````````````@+......................................\n......................................................:@;```````````````````````````````````;@,.......................................\n.......................................................;@@'```````````````````````````````:@@+;.......................................\n.......................................................@,,'@@'``````````````````````````@@@,,,@.......................................\n......................................................@,,,,,,'@@@@;````````````````.+@@@;,,,,,@.......................................\n......................................................#@+@,,,,,,,,+@@@@@@@@@@@@@@@@@;,,,,,'@@@........................................\n.........................................................+,,,#',,@@..............@,,,,,,,,@...........................................\n..........................................................@@@,#@@,...............:+,,,'@,,@...........................................\n..................................................................................@,,,@.##............................................\n...................................................................................@;@................................................\n....................................................................................:.................................................\n......................................................................................................................................\n......................................................................................................................................\n */\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.pow;\nimport static java.lang.Math.abs;\n\nimport static java.lang.String.format;\n\n\npublic class Main {\n    final static int INF = Integer.MAX_VALUE>>1;\n    final static int MOD = 1_000_000_007;\n    final static int[] dx4 = { 0, 1, 0, -1 };\n    final static int[] dy4 = { 1, 0, -1, 0 };\n    final static int[] dx8 = {0, 1, 1,  1,  0, -1, -1, -1};\n    final static int[] dy8 = {1, 1, 0, -1, -1, -1, 0, 1};\n    public static void main(String[] args) {\n        Scanner sc=new Scanner();\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        int[] u = new int[n - 1];\n        int[] v = new int[n - 1];\n        int[] x = new int[n - 1];\n        for (int i = 0; i < n - 1; i++) {\n            u[i]=sc.nextInt()-1;\n            v[i]=sc.nextInt()-1;\n            x[i]=sc.nextInt();\n        }\n        UnionFindbySize ufbs = new UnionFindbySize(n);\n        for (int i = 0; i < n - 1; i++) {\n            if(x[i]==1)continue;\n            ufbs.union(u[i],v[i]);\n        }\n\n        long ans=ModPow.modPow(n,k,MOD);\n        ans-=n;\n        if(ans<0)ans+=MOD;\n        Set<Integer> usedParent=new HashSet<>();\n        for (int i = 0; i < n; i++) {\n            if(usedParent.contains(ufbs.rootParent(i)))continue;\n            usedParent.add(ufbs.rootParent(i));\n            ans-=ModPow.modPow(ufbs.size(i),k,MOD)-ufbs.size(i);\n            while(ans<0){\n                ans += MOD;\n            }\n        }\n        put(ans);\n\n\n\n\n\n\n    }\n    final static private class ModPow{\n        //(x^y)%MOD\n        public static long modPow(long x,long y,long mod){\n            if(y==0)return 1;\n            if(y%2==0){\n                long halfY=y/2;\n                long halfModPow = modPow(x,halfY,mod)%mod;\n                return halfModPow*halfModPow%mod;\n            }else{\n                return x*modPow(x,y-1,mod)%mod;\n            }\n        }\n\n    }\n    final static private class UnionFindbySize{\n        final int[] parent;\n        UnionFindbySize(int n){\n            parent=new int[n];\n            Arrays.fill(parent,-1);\n        }\n        int rootParent(int child){\n            if(parent[child]<=-1){\n                return child;\n            }\n            int par=rootParent(parent[child]);\n            return par;\n        }\n        int size(int child){\n            return -parent[rootParent(child)];\n        }\n        void union(int i,int j){\n            int rootPI=rootParent(i);\n            int rootPJ=rootParent(j);\n            if(rootParent(rootPI)==rootParent(rootPJ)){\n                return;\n            }\n            if(size(rootPI)>=size(rootPJ)){\n                parent[rootPI]+=parent[rootPJ];\n                parent[rootPJ]=rootPI;\n            }else{\n                parent[rootPJ]+=parent[rootPI];\n                parent[rootPI]=rootPJ;\n            }\n        }\n        boolean same(int i,int j){\n            if(rootParent(i)==rootParent(j)){\n                return true;\n            }else{\n                return false;\n            }\n        }\n    }\n\n\n    public static void print(Object object){\n        System.out.print(object);\n    }\n    public static void put(Object object) {\n        System.out.println(object);\n    }\n    public static void put(){\n        System.out.println();\n    }\n\n    public static void printE(Object object){\n        System.err.print(\"DEBUG:\"+object);\n    }\n    public static void putE(Object object){\n        System.err.println(\"DEBUG:\"+object);\n    }\n    public static void putE(){\n        System.err.println(\"DEBUG:\");\n    }\n\n    public static void print(String format,Object... args){\n        System.out.print(String.format(format,args));\n    }\n    public static void put(String format,Object... args) {\n        System.out.println(String.format(format,args));\n    }\n    public static void printE(String format,Object... args){\n        System.err.print(\"DEBUG:\"+String.format(format,args));\n    }\n    public static void putE(String format,Object... args){\n        System.err.println(\"DEBUG:\"+String.format(format,args));\n    }\n\n    final static private class Scanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte())\n                return buffer[ptr++];\n            else\n                return -1;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n                ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext())\n                throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext())\n                throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n                throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n    final static private class FixedIntPair {\n        final public int x, y;\n        final static public FixedIntPair ZEROS=new FixedIntPair(0,0);\n        FixedIntPair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        public static double distance(FixedIntPair fip1,FixedIntPair fip2){\n            double x = (double) fip1.x - fip2.x;\n            double y = (double) fip1.y - fip2.y;\n            return Math.sqrt(x*x+y*y);\n        }\n\n        @Override\n        public int hashCode() {\n            return x+y;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            boolean result=super.equals(obj);\n            if(obj.getClass()!=this.getClass()){\n                return false;\n            }\n            FixedIntPair pair=(FixedIntPair) obj;\n            if(this.x==pair.x&&this.y==pair.y) return true;\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(FixedIntPair.class.getSimpleName()+\":(%d,%d)\", x, y);\n        }\n    }\n    final static private class FixedLongPair {\n        final public long x, y;\n        final static public FixedLongPair ZEROS=new FixedLongPair(0,0);\n        FixedLongPair(long x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n        public static double distance(FixedLongPair flp1,FixedLongPair flp2){\n            double x = (double) flp1.x - flp2.x;\n            double y = (double) flp1.y - flp2.y;\n            return Math.sqrt(x*x+y*y);\n        }\n\n        @Override\n        public int hashCode() {\n            return (int)x+(int)y;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            boolean result=super.equals(obj);\n            if(obj.getClass()!=this.getClass()){\n                return false;\n            }\n            FixedLongPair pair=(FixedLongPair)obj;\n            if(this.x==pair.x&&this.y==pair.y) return true;\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(FixedLongPair.class.getSimpleName()+\":(%d,%d)\", x, y);\n        }\n    }\n    final static private class Binary{\n        public static String toZeroPadding(int i){\n            return String.format(\"%\"+Integer.toBinaryString(-1).length()+\"s\",Integer.toBinaryString(i)).replace(' ','0');\n        }\n        public static String toZeroPadding(long i){\n            return String.format(\"%\"+Long.toBinaryString(-1).length()+\"s\",Long.toBinaryString(i)).replace(' ','0');\n        }\n    }\n\n    final static private class Util {\n        static long gcd(long a,long b){\n            //\u6700\u5927\u516c\u7d04\u6570\u3000\n            if(a%b==0)return b;\n            return gcd(b,a%b);\n        }\n        static long lcm(long a,long b){\n            //\u6700\u5c0f\u516c\u500d\u6570\n            long gcd=gcd(a,b);\n            long result=b/gcd;\n            return a*result;\n        }\n        static <T extends Comparable<T>> Map<T,Integer> count(List<T> list){\n            //\u526f\u4f5c\u7528\n            Collections.sort(list);\n            Map<T,Integer> result=new HashMap<>();\n            int l=0,r=0;\n            while(l<list.size()){\n                while(r<list.size()-1&&list.get(r).equals(r+1)){\n                    r++;\n                }\n                result.put(list.get(r),r-l+1);\n                r++;\n                l=r;\n            }\n            return result;\n\n        }\n        static Map<Integer,Integer> count(int[] array){\n            //\u526f\u4f5c\u7528\n            Arrays.sort(array);\n            Map<Integer,Integer> result=new HashMap<>();\n            int l=0,r=0;\n            while(l<array.length){\n                while(r<array.length-1&&array[r]==array[r+1]){\n                    r++;\n                }\n                result.put(array[l],r-l+1);\n                r++;\n                l=r;\n            }\n            return result;\n        }\n        static <T> String toStringBWS(Iterable<T> iterable){\n            Iterator<T> ite=iterable.iterator();\n            return toStringBWS(ite);\n        }\n        static <T> String toStringBWS(Iterator<T> ite){\n            StringBuilder sb=new StringBuilder();\n            sb.append(ite.next());\n            while(ite.hasNext()){\n                sb.append(\" \");\n                sb.append(ite.next());\n            }\n            return sb.toString();\n        }\n        static long factoringInPrimeNumbers(long n,int[] a){\n            //\u7d20\u56e0\u6570\u5206\u89e3\n            for(int i=2;n>1&&i< a.length;i++){\n                while(n%i==0){\n                    a[i]++;\n                    n/=i;\n                }\n            }\n            return n;\n\n        }\n        static boolean isValidCell(int i,int j,int h,int w){\n            return i>=0&&i<h&&j>=0&&j<w;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int M = 1e9 + 7;\nlong long int power(long long int x, long long int y) {\n  x %= M;\n  long long int ans = 1;\n  while (y) {\n    if (y & 1) ans = (ans * x) % M;\n    y >>= 1LL;\n    x = (x * x) % M;\n  }\n  return ans;\n}\nlong long int add(long long int a, long long int b) {\n  return ((a % M + b % M) % M);\n}\nlong long int sub(long long int a, long long int b) {\n  return ((a % M - b % M + M) % M);\n}\nlong long int mul(long long int a, long long int b) {\n  return (((a % M) * (b % M)) % M);\n}\nlong long int divi(long long int a, long long int b) {\n  return (mul(a, power(b, M - 2)) % M);\n}\nvector<long long int> adj[100001];\nlong long int p;\nlong long int vis[100001];\nvoid dfs(long long int src) {\n  p++;\n  vis[src] = 1;\n  for (auto x : adj[src]) {\n    if (vis[x] == 0) dfs(x);\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long int n, m;\n  cin >> n >> m;\n  long long int ans = power(n, m);\n  for (long long int i = 0; i < n - 1; i++) {\n    long long int x, y, z;\n    cin >> x >> y >> z;\n    if (z == 0) {\n      adj[x].push_back(y);\n      adj[y].push_back(x);\n    }\n  }\n  long long int val = 0;\n  for (long long int i = 1; i <= n; i++) {\n    if (vis[i] == 0) {\n      p = 0;\n      dfs(i);\n      val = ((val + power(p, m)) % M);\n    }\n  }\n  cout << sub(ans, val);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nconst long long msize = 1e6 + 100;\nlong long n, k;\nvector<int> adj[msize];\nbool vis[msize];\nvector<long long> boo;\nlong long val = 0;\nvoid dfs(int index) {\n  if (vis[index]) return;\n  vis[index] = 1;\n  val++;\n  for (auto j : adj[index]) dfs(j);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    long long x, y, z;\n    cin >> x >> y >> z;\n    if (!z) {\n      adj[x - 1].push_back(y - 1);\n      adj[y - 1].push_back(x - 1);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    val = 0;\n    if (vis[i]) continue;\n    dfs(i);\n    boo.push_back(val);\n  }\n  long long ans = 1, temp = 0;\n  for (long long i = 0; i < k; i++) {\n    ans = (ans * n) % mod;\n  }\n  for (auto j : boo) {\n    temp = 1;\n    for (long long i = 0; i < k; i++) temp = (temp * j) % mod;\n    ans = (ans + mod - temp) % mod;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/env python2\n\"\"\"\nThis file is part of https://github.com/cheran-senthil/PyRival\nCheran Senthilkumar <hello@cheran.io>\n\"\"\"\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom atexit import register\nfrom cStringIO import StringIO\nfrom itertools import ifilter, imap, izip\n\nrange = xrange\nfilter, map, zip = ifilter, imap, izip\n\nsys.stdout = StringIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\ninput = StringIO(os.read(0, os.fstat(0).st_size)).readline\n\nMOD = 10**9 + 7\n\n\ndef connected_components(graph):\n    n = len(graph)\n    components, visited = [], [False] * n\n\n    def dfs(start):\n        component, stack = 0, [start]\n\n        while stack:\n            start = stack[-1]\n\n            if visited[start]:\n                stack.pop()\n                continue\n            else:\n                visited[start] = True\n                component += 1\n\n            for i in graph[start]:\n                if not visited[i]:\n                    stack.append(i)\n\n        return component\n\n    for i in range(n):\n        if not visited[i]:\n            components.append(dfs(i))\n\n    return components\n\n\ndef main():\n    n, k = map(int, input().split())\n    res = pow(n, k, MOD) - n\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(n - 1):\n        u, v, x = map(int, input().split())\n        if x == 0:\n            tree[u - 1].append(v - 1)\n            tree[v - 1].append(u - 1)\n\n    for component in connected_components(tree):\n        res -= pow(component, k, MOD) - component\n    print(res % MOD)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 3,
            "solution": "def fact(n):\n\tif n == 0:\n\t\treturn 1\n\telse:\n\t\treturn (n * fact(n - 1))%(10 ** 9 + 7)\n\n\nn, k = [int(i) for i  in input().split()]\nq = [[] for i in range(n)]\nfor i in range(n - 1):\n\ta, b ,c = [int(i) for i in input().split()]\n\tif c == 0:\n\t\tq[a - 1].append(b - 1)\n\t\tq[b - 1].append(a - 1)\nused = [False]*n\nans = pow(n, k, 10**9+7)\nfor i in range(n):\n\tif not used[i]:\n\t\tcomp = []\n\t\tused[i] = True\n\t\tcomp.append(i)\n\t\tc = 0\n\t\twhile c < len(comp):\n\t\t\tfor h in q[comp[c]]:\n\t\t\t\tif not used[h]:\n\t\t\t\t\tused[h] = True\n\t\t\t\t\tcomp.append(h)\n\t\t\tc += 1\n\t\tans = (ans - pow(len(comp), k, 10 **9 + 7)) % (10 ** 9 + 7)\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.* ;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class ghh {\n\tstatic int count  ;\n\tstatic void dfs(int i)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tvis[i]=true ; count++ ;\n\t\t\tArrayList<Integer> ve = v.get(i) ; \n\t\t\tfor(int ele: ve) dfs(ele) ;\n\t\t}\n\t}\n\nstatic ArrayList<ArrayList<Integer>> v ; \nstatic boolean vis[] ;\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader jk = new BufferedReader(new InputStreamReader(System.in)) ;\n\t\tPrintWriter out = new PrintWriter(System.out) ;\n\n\t\tStringTokenizer ana = new StringTokenizer(jk.readLine()) ;\n\t\tint n = Integer.parseInt(ana.nextToken()) ;\n\t\tint k = Integer.parseInt(ana.nextToken()) ;\n\t\tvis = new boolean[n] ;\n\t\tv= new ArrayList<>() ;\n\t\tfor(int i=0 ;i<n;i++) v.add(new ArrayList<Integer>()) ;\n\t\tfor(int i=0 ;i<n-1 ;i++)\n\t\t{\n\t\t\tana = new StringTokenizer(jk.readLine()) ;\n\t\t\tint a = Integer.parseInt(ana.nextToken())-1 ;\n\t\t\tint b = Integer.parseInt(ana.nextToken())-1 ;\n\t\t\tint c = Integer.parseInt(ana.nextToken()) ;\n\t\t\tif(c==0)\n\t\t\t{\n\t\t\t\tv.get(a).add(b) ; v.get(b).add(a) ;\n\t\t\t}\n\t\t}\n\t\tBigInteger sum = BigInteger.ZERO ;\n\t\tfor(int i=0 ;i<n ;i++)\n\t\t{\n\t\t\tcount =0 ;\n\t\t\tdfs(i) ;\n\t\t\tif(count>0)\n\t\t\t{\n\t\t\t\tBigInteger d =  new BigInteger(Integer.toString(count)) ;\n\t\t\t\td=d.pow(k) ;\n\t\t\n\t\t\t\tsum=sum.add(d) ;\n\t\t\t}\n\t\t}\n\t\tBigInteger e = new BigInteger(Integer.toString(n)) ;\n\t\te=e.pow(k) ;\n\t\te=e.subtract(sum) ;\n\t\tBigInteger big= new BigInteger(\"1000000007\") ;\n\t\te=e.mod(big) ;\n\t\tout.println(e);\n\t\t\n\n        \n\n\t\tout.flush();\n\t}\n\n}\n\n"
        },
        {
            "language": 3,
            "solution": "def findCC(temp, queue):\n    while(queue):\n        node = queue.pop(0)\n        if visited[node]==False:\n            temp.append(node)\n            visited[node] = True\n            for adj in edgeList[node]:\n                if visited[adj]==False:\n                    queue.append(adj)\n                    \n    return temp\n\nn, k = map(int, input().split())\nMOD = 1000000007\n\nedgeList = dict()\nfor i in range(n):\n    edgeList[i] = []\n\nfor _ in range(n-1):\n    u, v, c = map(int, input().split())\n    if c==0:\n        edgeList[u-1].append(v-1)\n        edgeList[v-1].append(u-1)\n\nvisited = [False for i in range(n)]\ncc = []\n\nfor i in range(n):\n    if visited[i]==False:\n        temp = []\n        queue = [i]\n        cc.append(findCC(temp, queue))\n        visited[i] = True\n\nnoOfCC = len(cc)\ntotalAns = pow(n, k, MOD)\n\nfor i in range(noOfCC):\n    ni = len(cc[i])\n    totalAns = (totalAns-pow(ni, k, MOD))%MOD\n\nprint(totalAns)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int mod = 1000000007;\nvector<long long int> adj[100005];\nlong long int visited[100005];\nlong long int cnt = 0;\nlong long int power(long long int b, long long int e) {\n  long long int ans = 1;\n  while (e) {\n    if (e & 1) {\n      ans = (ans * b) % mod;\n    }\n    e /= 2;\n    b = (b * b) % mod;\n  }\n  return ans;\n}\nvoid dfs(long long int src) {\n  if (visited[src]) {\n    return;\n  }\n  cnt++;\n  visited[src] = 1;\n  for (auto &u : adj[src]) {\n    dfs(u);\n  }\n}\nint32_t main() {\n  long long int n, k;\n  cin >> n >> k;\n  long long int ans = power(n, k);\n  long long int u, v, c;\n  for (long long int i = 0; i < n - 1; i++) {\n    cin >> u >> v >> c;\n    if (c == 0) {\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n  }\n  for (long long int i = 1; i <= n; i++) {\n    if (visited[i]) {\n      continue;\n    }\n    cnt = 0;\n    dfs(i);\n    ans = (ans - power(cnt, k) + mod) % mod;\n  }\n  cout << ans % mod << \"\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.lang.*;\nimport java.math.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    void solve() {\n        int n=ni();\n        int k=ni();\n        F=new int[n+1];\n        sz=new int[n+1];\n        for(int i=1;i<=n;i++){\n            F[i]=i;\n            sz[i]=1;\n        }\n        for(int i=1;i<n;i++){\n            int u=ni(),v=ni(),x=ni();\n            if(x==1) continue;\n            union(u,v);\n        }\n        long ans=modpow(n,k);\n        boolean vis[]=new boolean[n+1];\n        for(int i=1;i<=n;i++){\n            int r=root(i);\n            if(vis[r]) continue;\n            vis[r]=true;\n            ans=sub(ans,modpow(sz[r],k));\n        }\n        pw.println(ans);\n    }\n    int F[];\n    int sz[];\n    int root(int a){\n        while(F[a]!=a){\n            F[a]=F[F[a]];\n            a=F[a];\n        }\n        return a;\n    }\n    void union(int a,int b){\n\n        int rootA=root(a);\n        int rootB=root(b);\n        if(rootA==rootB) return;\n        if(sz[rootA]>sz[rootB]){\n            int tmp=rootA; rootA=rootB; rootB=tmp;\n        }\n        F[rootA]=rootB;\n        sz[rootB]+=sz[rootA];\n\n\n    }\n    long add(long x,long y){\n        x+=y;\n        if(x>=M) x-=M;\n        return x;\n    }\n    long sub(long x,long y){\n        x-=y;\n        if(x<0) x+=M;\n        return x;\n    }\n    long mul(long x,long y){\n        x*=y;\n        if(x>=M) x%=M;\n        return x;\n    }\n    long modpow(long a, long b)\n    {\n        long r=1;\n        while(b>0)\n        {\n            if((b&1)>0) r=mul(r,a);\n            a=mul(a,a);\n            b>>=1;\n        }\n        return r;\n    }\n\n    long modInverse(long A, long M)\n    {\n\n        return modpow(A,M-2);\n    }\n    long M = (long)1e9+7;\n    InputStream is;\n    PrintWriter pw;\n    String INPUT = \"\";\n\n    void run() throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        pw = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        pw.flush();\n        if (!INPUT.isEmpty()) tr(System.currentTimeMillis() - s + \"ms\");\n\n    }\n\n    public static void main(String[] args) throws Exception {\n        new Main().run();\n    }\n\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b)) ;\n        return b;\n    }\n\n    private double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    private char nc() {\n        return (char) skip();\n    }\n\n    private String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    private int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    private void tr(Object... o) {\n        if (INPUT.length() > 0) System.out.println(Arrays.deepToString(o));\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int P = 1e9 + 7, INF = 0x3f3f3f3f;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long qpow(long long a, long long n) {\n  long long r = 1 % P;\n  for (a %= P; n; a = a * a % P, n >>= 1)\n    if (n & 1) r = r * a % P;\n  return r;\n}\nlong long inv(long long first) {\n  return first <= 1 ? 1 : inv(P % first) * (P - P / first) % P;\n}\ninline int rd() {\n  int first = 0;\n  char p = getchar();\n  while (p < '0' || p > '9') p = getchar();\n  while (p >= '0' && p <= '9') first = first * 10 + p - '0', p = getchar();\n  return first;\n}\nconst int N = 1e6 + 50;\nint n, k, sz[N], fa[N];\nint Find(int first) { return fa[first] ? fa[first] = Find(fa[first]) : first; }\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; ++i) sz[i] = 1;\n  for (int i = 2; i <= n; ++i) {\n    int u, v, w;\n    scanf(\"%d%d%d\", &u, &v, &w);\n    if (w == 0) {\n      u = Find(u), v = Find(v);\n      fa[u] = v, sz[v] += sz[u];\n    }\n  }\n  int ans = qpow(n, k);\n  for (int i = 1; i <= n; ++i)\n    if (Find(i) == i) ans = (ans - qpow(sz[i], k)) % P;\n  if (ans < 0) ans += P;\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst long long mod = 1e9 + 7;\nint n, k;\nvector<vector<int> > v(N + 1);\nbool vis[N];\nlong long ksm(long long x, long long n, long long mod) {\n  long long res = 1;\n  while (n > 0) {\n    if (n & 1) res = res * x % mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\nint main() {\n  int a, b, c, num;\n  long long sum = 0, ans, kk = 0;\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < n - 1; i++) {\n    scanf(\"%d %d %d\", &a, &b, &c);\n    if (c == 0) {\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (v[i].size() != 0) {\n      num = 1;\n      queue<int> q;\n      if (!vis[i]) {\n        q.push(i);\n        vis[i] = true;\n      }\n      while (!q.empty()) {\n        int top = q.front();\n        q.pop();\n        for (int j = 0; j < v[top].size(); j++) {\n          if (!vis[v[top][j]]) {\n            q.push(v[top][j]);\n            vis[v[top][j]] = true;\n            num++;\n          }\n        }\n      }\n      if (num != 1) {\n        sum += ksm(num, k, mod);\n        kk += num;\n        sum %= mod;\n      }\n    }\n  }\n  ans = ksm(n, k, mod) - sum - (n - kk);\n  if (ans < 0) ans = mod + ans;\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, chk[101010];\nconst long long mod = 1000000007;\nlong long ans;\nvector<int> v[3][101010], c;\nint dfs(int x) {\n  if (chk[x]) return 0;\n  chk[x] = 1;\n  int re = 1;\n  for (int nxt : v[0][x]) re += dfs(nxt);\n  return re;\n}\nlong long pw(long long a, int b) {\n  if (b == 1) return a;\n  return pw(a, b / 2) * pw(a, b / 2) % mod * ((b % 2) ? a : 1) % mod;\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  ans = pw(n, k);\n  for (int i = 1; i < n; i++) {\n    int a, b, c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    v[c][a].push_back(b);\n    v[c][b].push_back(a);\n  }\n  for (int i = 1; i <= n; i++)\n    if (!chk[i]) ans = (ans - pw(dfs(i), k) + mod) % mod;\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint gcdExtended(int a, int b, int *x, int *y) {\n  if (a == 0) {\n    *x = 0, *y = 1;\n    return b;\n  }\n  int x1, y1;\n  int gcd = gcdExtended(b % a, a, &x1, &y1);\n  *x = y1 - (b / a) * x1;\n  *y = x1;\n  return gcd;\n}\nlong long int modInverse(int a, int m) {\n  int x, y;\n  int g = gcdExtended(a, m, &x, &y);\n  long long int res = ((long long int)x % m + (long long int)m) % m;\n  return res;\n}\nlong long int poww(long long int x, long long int n) {\n  if (n == 0)\n    return 1;\n  else if (n % 2 == 0)\n    return poww(x * x, n / 2);\n  else\n    return x * poww(x * x, (n - 1) / 2);\n}\nlong long int modularExponentiation(long long int x, long long int n,\n                                    long long int M) {\n  long long int result = 1;\n  while (n > 0) {\n    if (n % 2 == 1) result = (result * x) % M;\n    x = (x * x) % M;\n    n = n / 2;\n  }\n  return result;\n}\ninline long long int max(long long int a, long long int b) {\n  if (a > b)\n    return a;\n  else\n    return b;\n}\ninline long long int min(long long int a, long long int b) {\n  if (a > b)\n    return b;\n  else\n    return a;\n}\nint gcd(int a, int b) {\n  if (a == 0) return b;\n  if (b == 0) return a;\n  if (a == b) return a;\n  if (a > b)\n    return gcd(a - b, b);\n  else\n    return gcd(a, b - a);\n}\nlong long int ncr(int n, int r) {\n  long long int ans = 1;\n  r = min(r, n - r);\n  for (int i = 0; i < r; i++) {\n    ans = (ans * (n - i) / (i + 1)) % 1000000007;\n  }\n  return ans;\n}\nbool vis[100001] = {0};\nset<pair<int, int> > s;\nvector<int> v[100001];\nvoid dfs(int start, long long int &z) {\n  if (vis[start]) return;\n  vis[start] = 1;\n  for (auto x : v[start]) {\n    if (!vis[x] && s.find({x, start}) == s.end() &&\n        s.find({start, x}) == s.end()) {\n      z++;\n      dfs(x, z);\n    }\n  }\n  return;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t = 1;\n  while (t--) {\n    long long int n, m, k;\n    cin >> n >> k;\n    vector<int> req;\n    for (int i = 0; i < n - 1; i++) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      if (a > b) swap(a, b);\n      if (c == 1) {\n        s.insert(make_pair(a, b));\n        req.push_back(a);\n        req.push_back(b);\n      }\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n    long long int ans = modularExponentiation(n, k, 1000000007);\n    if (req.size() == 0) {\n      cout << \"0\";\n      return 0;\n    }\n    for (auto x : req) {\n      long long int z = 1;\n      if (!vis[x]) {\n        dfs(x, z);\n        ans = ans - modularExponentiation(z, k, 1000000007);\n        ans += (long long int)100 * 1000000007;\n        ans %= 1000000007;\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.math.*;\nimport java.util.*;\nimport java.io.*;\n\n/**\n * created by vidyut on 2019-03-21\n **/\n\npublic class C {\n    private static Vector<Vector<Integer>> cc;\n    public static void main(String[] args) {\n        try {\n            InputReader in = new InputReader(System.in);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n            long MOD = (long)1e9 + 7;\n            int n = in.readInt();\n            int k = in.readInt();\n            long ans = binPow(n, k, MOD);\n            cc = new Vector<>();\n            Vector<Integer> graph[] = new Vector[n];\n            for (int i = 0; i < n; i++) {\n                graph[i] = new Vector<>();\n            }\n            for (int i = 0; i < n - 1; i++) {\n                int u = in.readInt() - 1;\n                int v = in.readInt() - 1;\n                int col = in.readInt();\n                if (col == 0) {\n                    graph[u].add(v);\n                    graph[v].add(u);\n                }\n            }\n            boolean vis[] = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                if (!vis[i]) {\n                    cc.add(new Vector<>());\n                    dfs(vis, i, graph);\n                }\n            }\n            for (Vector<Integer> ccomponent: cc) {\n                ans -= binPow(ccomponent.size(), k, MOD);\n            }\n            while(ans < 0) {\n                ans += MOD;\n            }\n            out.write(Long.toString(ans % MOD));\n            out.newLine();\n            out.close();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    private static void dfs(boolean v[], int ver, Vector<Integer> g[]) {\n        v[ver] = true;\n        cc.get(cc.size() - 1).add(ver);\n        for (int ch: g[ver]) {\n            if (!v[ch]) {\n                dfs(v, ch, g);\n            }\n        }\n    }\n    private static long binPow(long a, long b, long MOD) {\n        if (a == 1 || b == 0) {\n            return 1L;\n        }\n        long res = binPow(a, b >> 1, MOD);\n        res = res % MOD * res % MOD;\n        if (b % 2 != 0) {\n            res = res * a;\n        }\n        res %= MOD;\n        return res;\n    }\n}\n\n\nclass InputReader {\n    private boolean finished = false;\n\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int peek() {\n        if (numChars == -1)\n            return -1;\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                return -1;\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public long readLong() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public String readString() {\n        int length = readInt();\n        if (length < 0)\n            return null;\n        byte[] bytes = new byte[length];\n        for (int i = 0; i < length; i++)\n            bytes[i] = (byte) read();\n        try {\n            return new String(bytes, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            return new String(bytes);\n        }\n    }\n\n    public static boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    private String readLine0() {\n        StringBuffer buf = new StringBuffer();\n        int c = read();\n        while (c != '\\n' && c != -1) {\n            if (c != '\\r')\n                buf.appendCodePoint(c);\n            c = read();\n        }\n        return buf.toString();\n    }\n\n    public String readLine() {\n        String s = readLine0();\n        while (s.trim().length() == 0)\n            s = readLine0();\n        return s;\n    }\n\n    public String readLine(boolean ignoreEmptyLines) {\n        if (ignoreEmptyLines)\n            return readLine();\n        else\n            return readLine0();\n    }\n\n    public BigInteger readBigInteger() {\n        try {\n            return new BigInteger(readString());\n        } catch (NumberFormatException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    public char readCharacter() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        return (char) c;\n    }\n\n    public double readDouble() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        double res = 0;\n        while (!isSpaceChar(c) && c != '.') {\n            if (c == 'e' || c == 'E')\n                return res * Math.pow(10, readInt());\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        }\n        if (c == '.') {\n            c = read();\n            double m = 1;\n            while (!isSpaceChar(c)) {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, readInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                m /= 10;\n                res += (c - '0') * m;\n                c = read();\n            }\n        }\n        return res * sgn;\n    }\n\n    public boolean isExhausted() {\n        int value;\n        while (isSpaceChar(value = peek()) && value != -1)\n            read();\n        return value == -1;\n    }\n\n    public String next() {\n        return readString();\n    }\n\n    public boolean readBoolean() {\n        return readInt() == 1;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long s[100005], ans, n, k, i, u, v, x, cnt;\nvector<pair<int, int> > e[100005];\nlong long mypow(long long a, long long b) {\n  if (a == 0) return 0;\n  long long ans = 1;\n  for (long long j = 1; j <= b; j++) ans = ans * a % 1000000007;\n  return ans;\n}\nvoid dfs(int u, int fa) {\n  int x;\n  for (int i = 0; i < e[u].size(); i++) {\n    int v = e[u][i].first;\n    if (v == fa) {\n      x = e[u][i].second;\n      continue;\n    }\n    if (e[u][i].second == 0) s[u]++;\n    dfs(v, u);\n  }\n  if (fa) {\n    if (x == 0)\n      s[fa] += s[u];\n    else {\n      s[u]++;\n      ans -= mypow(s[u], k);\n      cnt += s[u];\n    }\n  }\n}\nint main() {\n  cin >> n >> k;\n  ans = mypow(n, k);\n  for (i = 1; i < n; i++) {\n    cin >> u >> v >> x;\n    e[u].push_back({v, x});\n    e[v].push_back({u, x});\n  }\n  dfs(1, 0);\n  if (s[1]) s[1]++;\n  ans -= mypow(s[1], k);\n  cnt += s[1];\n  ans -= n - cnt;\n  cout << (ans % 1000000007 + 1000000007) % 1000000007 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1);\nconst int N = 1e5 + 7, mod = 1000000007, M = 2e9;\nconst long long MAX = 5e18;\nint moding(long long x) {\n  while (x < 0) x += mod;\n  if (x >= mod) x %= mod;\n  return x;\n}\nint n, k, u, v, x, c[N];\nlong long ans = 1;\nstruct dsu {\n  int sz[N], cl[N];\n  void init() {\n    fill(sz, sz + N, 0);\n    iota(cl, cl + N, 0);\n  }\n  int par(int x) { return cl[x] = (x == cl[x] ? x : par(cl[x])); }\n  void con(int x, int y) {\n    x = par(x);\n    y = par(y);\n    if (x == y) return;\n    if (sz[y] > sz[x]) swap(x, y);\n    sz[x] += sz[y];\n    cl[y] = x;\n  }\n} tree;\nlong long fac(int x) {\n  long long ret = 1;\n  for (int i = 0; i < k; i++) ret = moding(ret * x);\n  return ret;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  tree.init();\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d%d\", &u, &v, &x);\n    if (!x) tree.con(u, v);\n  }\n  for (int i = 1; i <= n; i++) c[tree.par(i)]++;\n  ans = fac(n);\n  for (int i = 1; i <= n; i++) ans = moding(ans - fac(c[i]));\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "class UnionFind:\n    def __init__(self, n):\n        self.sz = [ -1 for i in range(n)]\n\n    def find(self, x):\n        if self.sz[x] < 0:\n            return x\n        else:\n            self.sz[x] = self.find(self.sz[x])\n            return self.sz[x]\n\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.sz[x] > self.sz[y]:\n            x,y = y,x\n        self.sz[x] += self.sz[y]\n        self.sz[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self,x):\n        return -self.sz[self.find(x)]\n\nMOD = 10**9+7\nN,k = map(int,input().split())\nuf = UnionFind(N)\nfor i in range(N-1):\n    a,b,c = map(int,input().split())\n    a -= 1\n    b -= 1\n    if c == 0:\n        uf.union(a,b)\n\n#print(uf.sz)\nans = N**k % MOD\nl = [0]*N\nfor i in range(N):\n    l[i] = uf.find(i)\n\nfor a in list(set(l)):\n    if a == -1:\n        continue\n    ans -= uf.size(a)**k\n    ans %= MOD\nans -= l.count(-1)\nprint(ans % MOD)\n\n"
        },
        {
            "language": 4,
            "solution": "/*\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2877\u28ef\u28bf\u28ff\u28f7\u28fb\u28af\u28ff\u287d\u28fb\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u2838\u28ff\u28ff\u28c6\u2839\u28ff\u28ff\u28be\u28df\u28ef\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28fb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fb\u28fd\u287f\u28ff\u28ce\u2819\u28ff\u28de\u28f7\u284c\u28bb\u28df\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2839\u28ff\u28ff\u2846\u283b\u28ff\u28df\u28ef\u287f\u28fd\u287f\u28ff\u28ff\u28ff\u28ff\u28fd\u2877\u28ef\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u28f7\u28ff\u28ff\u28ff\u2840\u2839\u28df\u28fe\u28df\u28c6\u2839\u28ef\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28a0\u2858\u28ff\u28ff\u2844\u2809\u28bf\u28ff\u28fd\u2877\u28ff\u28fb\u28ff\u28ff\u28ff\u28ff\u285d\u28f7\u28ef\u28bf\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ef\u28bf\u28fe\u28bf\u28ff\u2844\u2884\u2818\u28bf\u28de\u287f\u28e7\u2848\u28b7\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28b8\u28e7\u2818\u28ff\u28f7\u2808\u28e6\u2819\u28bf\u28fd\u28f7\u28fb\u28fd\u28ff\u28ff\u28ff\u28ff\u28cc\u28bf\u28ef\u28bf\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u28ef\u28ff\u28bf\u28ff\u2846\u28b8\u2877\u2848\u28bb\u287d\u28f7\u2877\u2844\u283b\u28fd\u28ff\u28ff\u287f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ff\u28ff\u28ff\u28ff\u28cf\u28b0\u28ef\u28b7\u2808\u28ff\u2846\u28b9\u28b7\u284c\u283b\u287e\u288b\u28f1\u28ef\u28ff\u28ff\u28ff\u28ff\u2846\u28bb\u287f\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u284e\u28ff\u28be\u287f\u28ff\u2846\u28b8\u28fd\u28bb\u28c4\u2839\u28f7\u28df\u28ff\u28c4\u2839\u28df\u28ff\u28ff\u28df\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28ff\u28ff\u28ff\u2847\u28b8\u28ef\u28df\u28e7\u2818\u28f7\u2808\u286f\u281b\u2880\u2850\u28be\u28df\u28f7\u28fb\u28ff\u28ff\u28ff\u287f\u284c\u28bf\u28fb\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u28b8\u287f\u28df\u28ff\u2847\u28b8\u28ef\u28df\u28ee\u28a7\u2848\u28bf\u28de\u287f\u28e6\u2818\u280f\u28f9\u28ff\u28fd\u28bf\u28ff\u28ff\u28ff\u28ff\u28ef\u28ff\u28ff\u28ff\u2847\u28b8\u28ff\u28ff\u28fe\u2846\u2839\u2880\u28e0\u28fe\u28df\u28f7\u2848\u28bf\u28de\u28ef\u28bf\u28ff\u28ff\u28ff\u28b7\u2818\u28ef\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2848\u28ff\u28bf\u28fd\u2847\u2818\u281b\u281b\u281b\u2813\u2813\u2808\u281b\u281b\u281f\u2807\u2880\u28bf\u28fb\u28ff\u28ef\u28bf\u28ff\u28ff\u28ff\u28f7\u28bf\u28ff\u28ff\u2801\u28fe\u28ff\u28ff\u28ff\u28e7\u2844\u2807\u28f9\u28ff\u28fe\u28ef\u28ff\u2844\u283b\u28fd\u28ef\u28bf\u28fb\u28ff\u28ff\u2847\u28b9\u28fe\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28b9\u28ff\u287d\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28de\u28c6\u2830\u28f6\u28f6\u2844\u2880\u28bb\u287f\u28ef\u28ff\u287d\u28ff\u28ff\u28ff\u28af\u28df\u287f\u2880\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2810\u28f8\u28ff\u28ff\u28f7\u28ff\u28ff\u28c6\u2839\u28ef\u28ff\u28fb\u28ff\u28ff\u28ff\u2880\u28ff\u28bf\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2818\u28ef\u287f\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2848\u28bf\u28f3\u2818\u2844\u283b\u28ff\u28be\u28fd\u28df\u287f\u28ff\u28af\u28ff\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2840\u28be\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c6\u2839\u28fe\u28f7\u28fb\u28ff\u287f\u2847\u28b8\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28b9\u28ff\u2807\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u283b\u2847\u28b9\u28c6\u2839\u28df\u28fe\u28fd\u28fb\u28df\u28ff\u28fd\u2801\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u28ff\u28ff\u283f\u281b\u281b\u2809\u2819\u280b\u2880\u2801\u2898\u28ef\u28ff\u28ff\u28e7\u2818\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2848\u28ff\u2843\u28bc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2859\u280c\u28ff\u28c6\u2818\u28ff\u28de\u287f\u28de\u287f\u285e\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u281b\u2809\u2801\u2880\u28c0\u28e0\u28e4\u28e4\u28f6\u28f6\u28f6\u2846\u28bb\u28fd\u28de\u287f\u28f7\u2808\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2818\u2801\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2819\u281b\u281b\u28bf\u28c4\u28bb\u28ff\u28e7\u2818\u28af\u28df\u287f\u28fd\u2801\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u2843\u2880\u2880\u2818\u281b\u283f\u28bf\u28fb\u28df\u28ef\u28fd\u28fb\u28f5\u2840\u28bf\u28ef\u28df\u28ff\u2880\u28ff\n\u28ff\u28ff\u28ff\u28df\u28ff\u28ff\u28ff\u28ff\u28f6\u28f6\u2846\u2880\u28ff\u28fe\u28ff\u28fe\u28f7\u28ff\u28f6\u283f\u281a\u2809\u2880\u2880\u28e4\u28ff\u28f7\u28ff\u28ff\u28f7\u2848\u28bf\u28fb\u2883\u28fc\u28ff\u28ff\u28ff\u28ff\u28fb\u28ff\u28ff\u28ff\u2876\u28e6\u28e4\u28c4\u28c0\u2840\u2809\u281b\u281b\u2837\u28ef\u28f3\u2808\u28fe\u287d\u28fe\u2880\u28ff\n\u28ff\u28bf\u28ff\u28ff\u28fb\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2810\u28ff\u28ff\u28ff\u28ff\u283f\u280b\u2801\u2880\u2880\u28e4\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28cc\u28e5\u28fe\u287f\u28ff\u28ff\u28f7\u28ff\u28ff\u28bf\u28f7\u28ff\u28ff\u28df\u28fe\u28fd\u28f3\u28af\u28df\u28f6\u28e6\u28e4\u287e\u28df\u28e6\u2818\u28ff\u28be\u2841\u28ba\n\u28ff\u28fb\u28ff\u28ff\u2877\u28ff\u28ff\u28ff\u28ff\u28ff\u2857\u28e6\u2838\u287f\u280b\u2801\u2880\u2880\u28e0\u28f4\u28bf\u28ff\u28fd\u28fb\u28bd\u28fe\u28df\u28f7\u28ff\u28df\u28ff\u28ff\u28ff\u28f3\u283f\u28f5\u28e7\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28f3\u28ef\u28ff\u28ff\u28ff\u28fd\u2880\u28b7\u28fb\u2804\u2818\n\u28ff\u28b7\u28fb\u28ff\u28ff\u28f7\u28fb\u28ff\u28ff\u28ff\u2877\u281b\u28c1\u2880\u28c0\u28e4\u28f6\u28ff\u28db\u287f\u28ff\u28ee\u28fd\u287b\u28ff\u28ee\u28fd\u28fb\u28af\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ef\u2880\u28b8\u28ff\u2880\u2846\n\u2838\u28df\u28ef\u28ff\u28ff\u28f7\u28bf\u28fd\u28ff\u28ff\u28f7\u28ff\u28f7\u28c6\u2839\u28ff\u28f6\u28ef\u283f\u28ff\u28f6\u28df\u28fb\u28bf\u28f7\u28fd\u28fb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2880\u28ef\u28df\u2880\u2847\n\u28c7\u2839\u28df\u28fe\u28fb\u28ff\u28ff\u28be\u287d\u28ff\u28ff\u28ff\u28ff\u28ff\u28c6\u28b9\u28f6\u28ff\u28fb\u28f7\u28ef\u28df\u28ff\u28ff\u28fd\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2880\u287f\u2847\u28b8\u2847\n\u28ff\u28c6\u2839\u28f7\u287b\u28fd\u28ff\u28ef\u28bf\u28fd\u28fb\u28ff\u28ff\u28ff\u28ff\u28c6\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2807\u28b8\u28ff\u2807\u28fc\u2847\n\u2859\u283e\u28c6\u2839\u28ff\u28e6\u281b\u28ff\u28af\u28f7\u28bf\u287d\u28ff\u28ff\u28ff\u28ff\u28c6\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2803\u280e\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u280f\u2880\u28ff\u28fe\u28e3\u287f\u2847\n\u28ff\u28f7\u284c\u28a6\u2819\u28ff\u28ff\u28cc\u283b\u28fd\u28af\u28ff\u28fd\u28fb\u28ff\u28ff\u28ff\u28e7\u2829\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u284f\u28b0\u28a3\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2880\u2880\u28bf\u28de\u28f7\u28bf\u2847\n\u28ff\u28fd\u28c6\u2839\u28e7\u2818\u28ff\u28ff\u2877\u28cc\u2819\u28b7\u28ef\u2877\u28df\u28ff\u28ff\u28ff\u28f7\u2840\u2879\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c8\u2803\u28f8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u2880\u28f4\u2867\u2880\u2838\u28ff\u287d\u28ff\u2880\n\u28bb\u28fd\u28ff\u2844\u28bb\u28f7\u2848\u28bf\u28ff\u28ff\u28a7\u2880\u2819\u28bf\u28fb\u287e\u28fd\u28fb\u28ff\u28ff\u28c4\u280c\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u2881\u28f0\u28fe\u28df\u287f\u2880\u2844\u28bf\u28df\u28ff\u2880\n\u2844\u28bf\u28ff\u28f7\u2880\u2839\u28df\u28c6\u283b\u28ff\u28ff\u28c6\u2880\u28c0\u2809\u283b\u28ff\u287d\u28ef\u28ff\u28ff\u28f7\u28c8\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2880\u28e0\u2818\u28ef\u28f7\u28ff\u285f\u2880\u2886\u2838\u28ff\u285f\u28b8\n\u28f7\u2848\u28bf\u28ff\u28c7\u28b1\u2858\u28bf\u28f7\u28ec\u28d9\u283f\u28e7\u2818\u28c6\u2880\u2808\u283b\u28f7\u28df\u28fe\u28bf\u28ff\u28c6\u2839\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28e0\u285e\u28a1\u28ff\u2880\u28ff\u28ff\u28ff\u2807\u2844\u28b8\u2844\u28bb\u2847\u28fc\n\u28ff\u28f7\u2848\u28bf\u28ff\u2846\u28a3\u2840\u2819\u28be\u28df\u28ff\u28ff\u28f7\u2848\u2802\u2818\u28e6\u2848\u283f\u28ef\u28ff\u28be\u28ff\u28c6\u2819\u283b\u283f\u283f\u283f\u283f\u287f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u283f\u281b\u288b\u28e0\u28fe\u285f\u28a0\u28ff\u28ff\u2880\u28ff\u28ff\u285f\u28a0\u28ff\u2888\u28e7\u2818\u28a0\u28ff\n\u28ff\u28ff\u28ff\u28c4\u283b\u28ff\u2844\u28b3\u2844\u2886\u2859\u283e\u28fd\u28ff\u28ff\u28c6\u2840\u28b9\u2877\u28c4\u2819\u28bf\u28ff\u287e\u28ff\u28c6\u2880\u2840\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u28c0\u28e0\u28f4\u287f\u28ef\u280f\u28e0\u28ff\u28ff\u284f\u28b8\u28ff\u287f\u2881\u28ff\u28ff\u2880\u28ff\u2806\u28b8\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28e6\u2859\u28ff\u28c6\u28bb\u284c\u28bf\u28f6\u28a4\u28c9\u28d9\u28ff\u28f7\u2840\u2819\u283d\u2837\u2804\u2839\u28ff\u28df\u28ff\u28c6\u2899\u28cb\u28e4\u28e4\u28e4\u28c4\u28c0\u2880\u2880\u2880\u2880\u28fe\u28ff\u28df\u2877\u28ef\u287f\u2883\u28fc\u28ff\u28ff\u28ff\u2807\u28fc\u285f\u28e1\u28ff\u28ff\u28ff\u2880\u287f\u28a0\u2808\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ee\u28ff\u28ff\u28ff\u284c\u2801\u28a4\u28e4\u28e4\u28e4\u28ec\u28ed\u28f4\u28f6\u28f6\u28f6\u28c6\u2808\u28bb\u28ff\u28ff\u28c6\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28e4\u28cc\u28c9\u2858\u281b\u283b\u2836\u28ff\u28ff\u28ff\u28ff\u285f\u28f0\u28eb\u28f4\u28ff\u28ff\u28ff\u28ff\u2804\u28f7\u28ff\u28ff\u28ff\n*/\n\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Scanner;\n public class b{\n\t\n\tpublic static void main(String[] args) throws Exception \n\t{ \n\t\tScanner s=new Scanner(System.in);\n       int n=s.nextInt();\n       int k=s.nextInt();\n       ArrayList[] arr=new ArrayList[n+1];\n       \n       for(int i=0;i<n+1;i++) {\n    \t   ArrayList<Integer>list=new ArrayList<>();\n    \t   arr[i]=list;\n       }\n       \n       for(int i=0;i<n-1;i++) {\n    \t   int a=s.nextInt();\n    \t   int b=s.nextInt();\n    \t   int c=s.nextInt();\n    \t   \n    \t   if(c==0) {\n    \t\t   arr[a].add(b);\n    \t\t   arr[b].add(a);\n    \t   }\n    \t\t\t   \n    \t\t\t  \n    \t\t\t   \n       }\n       long m=1000000007;\n       \n       long ans=power((long)n,(long)k,m)-n;\n       \n       int[] visited=new int[n+1];\n       \n       for(int i=1;i<n+1;i++) {\n    \t   if(visited[i]==0) {\n    \t\t   long minus=dfs(arr,visited,i,m)%m;\n    \t\t   ans=(ans%m+m+minus%m-power(minus,(long)k,m)%m)%m;\n    \t   }\n       }\n       \n       System.out.println(ans);\n    \t\t   \n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tpublic static long power(long x,long y,long m) {\n\t\tlong res=1;\n\t\t\n\t\twhile(y>0) {\n\t\t\n\t\t\tif(y%2!=0) {\n\t\t\t\tres=(res%m*x%m)%m;\n\t\t\t}\n\t\t\ty=y/2;\n\t\t\tx=(x%m*x%m)%m;\n\t\t\n\t\t}\n\t\t\n\t\treturn res;\n\t\n\t}\n\t\n\t\n\tpublic static long dfs(ArrayList[] arr,int[] visited,int curr,long m) {\n\t\tvisited[curr]=1;\n\t\tlong l=0;\n\t\tfor(int i=0;i<arr[curr].size();i++) {\n\t\t\tint now=(int)arr[curr].get(i);\n\t\t\tif(visited[now]==0) {\n\t\t\t\t\n\t\t\t\tl=(l%m+dfs(arr,visited,now,m)%m)%m;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\treturn l+1;\n\t\t\n\t\t\n\t}\n\t\n }"
        },
        {
            "language": 3,
            "solution": "import collections\n\np = 10 ** 9 + 7\nn, k = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\n\nfor _ in range(1, n):\n    a, b, x = map(int, input().split())\n    if (x == 0):\n        graph[a].append(b)\n        graph[b].append(a)\n\nvisited = [False] * (n + 1)\nbad = 0\nqueue = collections.deque()\n\nfor i in range(1, n + 1):\n    if not visited[i]:\n        queue.append(i)\n        visited[i] = True\n\n        # calculate the size of the current connected component\n        size_connected_component = 0\n        while(queue):\n            front = queue.pop()\n            for adj_front in graph[front]:\n                if not visited[adj_front]:\n                    visited[adj_front] = True\n                    queue.append(adj_front)\n            size_connected_component += 1\n        \n        # calculate the number of bad sequence\n        bad += pow(size_connected_component, k, p)\nprint((pow(n, k, p) + p - bad) % p)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class C {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    int n = sc.nextInt();\n    int k = sc.nextInt();\n    List<List<Integer>> g = new ArrayList<>();\n    for (int i = 0; i < n; i++)\n      g.add(new ArrayList<>());\n    for (int i = 0; i < n-1; i++) {\n      int u = sc.nextInt()-1;\n      int v = sc.nextInt()-1;\n      int x = sc.nextInt();\n      if (x==0) {\n        g.get(u).add(v);\n        g.get(v).add(u);\n      }\n    }\n    List<Integer> sizes = new ArrayList<>();\n    ArrayDeque<Integer> q = new ArrayDeque<>();\n    boolean[] vis = new boolean[n];\n    for (int i = 0; i < n; i++) {\n      if (vis[i])\n        continue;\n      int nn = 0;\n      q.add(i);\n      vis[i] = true;\n      while (!q.isEmpty()) {\n        int u = q.removeFirst();\n        nn++;\n        for (int v : g.get(u)) {\n          if (!vis[v]) {\n            vis[v] = true;\n            q.add(v);\n          }\n        }\n      }\n      sizes.add(nn);\n    }\n    int MOD = 1000000007;\n    int[] mods = new int[n+1];\n    int ans = 0;\n    for (int s : sizes) {\n      if (mods[s] > 0) {\n        ans += mods[s];\n        ans %= MOD;\n        continue;\n      }\n      long ta = 1;\n      for (int i = 0; i < k; ++i) {\n        ta *= s;\n        ta %= MOD;\n      }\n      mods[s] = (int)ta;\n      ans += mods[s];\n      ans %= MOD;\n    }\n    ans = (MOD-ans)%MOD;\n    long ta = 1;\n    for (int i = 0; i < k; ++i) {\n      ta *= n;\n      ta %= MOD;\n    }\n    System.out.println((ta+ans)%MOD);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 2e6 + 10, inf = 1e18, mod = 1e9 + 7;\nstruct pair_hash {\n  template <class T1, class T2>\n  std::size_t operator()(const std::pair<T1, T2> &p) const {\n    auto h1 = std::hash<T1>{}(p.first);\n    auto h2 = std::hash<T2>{}(p.second);\n    return h1 ^ h2;\n  }\n};\nlong long pw(long long te, long long tee) {\n  if (tee == 0) return 1;\n  long long res = pw(te, tee / 2) % mod;\n  return (tee % 2 ? (((te * res) % mod) * res) % mod : (res * res) % mod);\n}\nlong long v, u, c, n, k, cnt, p[MAXN];\nbool mark[MAXN];\nvector<long long> e[MAXN];\nvoid Read_input() {\n  cin >> n >> k;\n  for (long long i = 1; i < n; i++) {\n    cin >> v >> u >> c;\n    if (c != 1) e[u].push_back(v), e[v].push_back(u);\n  }\n}\nvoid dfs(long long v, bool f) {\n  cnt += f;\n  p[cnt]++;\n  mark[v] = true;\n  for (auto i : e[v])\n    if (!mark[i]) dfs(i, false);\n}\nvoid Solve() {\n  for (long long i = 1; i <= n; i++)\n    if (!mark[i]) dfs(i, true);\n  long long t = 0;\n  for (long long i = 1; i <= cnt; i++) t = (t + (pw(p[i], k) % mod)) % mod;\n  cout << (((pw(n, k) - t) % mod + mod) % mod);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  Read_input(), Solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nconst int mod = 1e9 + 7;\nlong long n, k, ans;\nlong long cnt[MAXN];\nlong long parent[MAXN];\nlong long find_root(long long x) {\n  if (x == parent[x]) return x;\n  return parent[x] = find_root(parent[x]);\n}\nvoid unity(int x, int y) {\n  if (find_root(x) != find_root(y)) parent[find_root(x)] = find_root(y);\n}\nlong long qpow(long long a, long long b) {\n  long long res = 1, base = a;\n  while (b) {\n    if (b & 1) (res *= base) %= mod;\n    (base *= base) %= mod;\n    b >>= 1;\n  }\n  return res;\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; ++i) parent[i] = i;\n  for (int i = 1; i < n; ++i) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    if (z == 0) unity(x, y);\n  }\n  for (int i = 1; i <= n; ++i) cnt[find_root(i)]++;\n  for (int i = 1; i <= n; ++i)\n    if (parent[i] == i) (ans += qpow(cnt[i], k)) %= mod;\n  cout << (qpow(n, k) + mod - ans) % mod << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static int n, k;\n\tprivate static int[][] edges;\n\tprivate static int[] id;\n\tprivate static int[] size;\n\tprivate static int components;\n\tprivate static final int MOD = (int)1e9+7;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tn = in.nextInt();\n\t\tk = in.nextInt();\n\t\tedges = new int[n-1][3];\n\t\tfor(int i=0; i<n-1; i++) {\n\t\t\tint p = in.nextInt()-1;\n\t\t\tint q = in.nextInt()-1;\n\t\t\tint w = in.nextInt();\n\t\t\tedges[i] = new int[] {p, q, w};\n\t\t}\n\t\t\n\t\tid = new int[n];\n\t\tsize = new int[n];\n\t\t\n\t\tArrays.fill(size, 1);\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tid[i] = i;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<n-1; i++) {\n\t\t\tif (edges[i][2]==1) continue;\n\t\t\t// else red edges\n\t\t\t\n\t\t\tunion(edges[i][0], edges[i][1]);\n\t\t}\n\t\t\n\t\t\n\t\tboolean[] isRoot = new boolean[n];\n\t\t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tisRoot[root(i)] = true;\n\t\t}\n\t\t\n\t\tlong ans = exp(n, k);\n\t\t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tif (isRoot[i]) {\n\t\t\t\tans = (ans-exp(size[i], k)+MOD)%MOD;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t\n\t\t\n\t\t\n\t\t\n\n\t}\n\t\n\t\n\tprivate static long exp(int n, int k) {\n\t\tif (k==0) return 1;\n\t\t\n\t\tif (k%2!=0) {\n\t\t\treturn (n*exp(n, k-1))%MOD;\n\t\t} else {\n\t\t\tlong halfExp = exp(n, k/2);\n\t\t\treturn (halfExp*halfExp)%MOD;\n\t\t}\n\t}\n\n\tprivate static void union(int i, int j) {\n\t\tint p = root(i);\n\t\tint q = root(j);\n\t\t\n\t\tif (size[p]>size[q]) {\n\t\t\tid[q] = p;\n\t\t\tsize[p] += size[q];\n\t\t} else {\n\t\t\tid[p] = q;\n\t\t\tsize[q] += size[p];\n\t\t}\n\t}\n\t\n\t\n\tprivate static int root(int u) {\n\t\twhile(u!=id[u]) {\n\t\t\tid[u] = id[id[u]]; //path compression\n\t\t\tu = id[u];\n\t\t}\n\t\treturn u;\n\t}\n\t\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C_EdgyTree {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt(), k = inp.nextInt();\n            DSU dsu = new DSU(n);\n            for (int i = 0; i < n - 1; i++) {\n                int u = inp.nextInt() - 1, v = inp.nextInt() - 1, x = inp.nextInt();\n                if (x == 1) continue;\n                if (!dsu.sameSet(u, v)) dsu.union(u, v);\n            }\n            ArrayList<Integer>[] sets = dsu.getSets();\n            long res = 0;\n            long MOD = 1000000007;\n            long[] nPower = new long[k+1];\n            nPower[0] = 1;\n            for (int i = 1; i < k + 1; i++) nPower[i] = (nPower[i-1] * n) % MOD;\n            for (ArrayList<Integer> set: sets) {\n                long in = set.size();\n                for (int i = 2; i <= k; i++) {\n                    long temp = (in * (n - set.size())) % MOD;\n                    temp = (temp * nPower[k - i]) % MOD;\n                    res = (res + temp) % MOD;\n                    in = (in * set.size()) % MOD;\n                }\n            }\n            out.print(res);\n        }\n\n        public class DSU {\n            private int[] parents, rank;\n\n            public DSU(int n) {\n                parents = new int[n];\n                rank = new int[n];\n                for (int i = 0; i < n; i++) parents[i] = -1;\n            }\n\n            public int findParent(int node) {\n                if (parents[node] == -1) return node; //recursively search\n                int parent = findParent(parents[node]);\n                parents[node] = parent; //don't search another time for parent\n                return parent;\n            }\n\n            public void union(int x, int y) {\n                int xParent = findParent(x), yParent = findParent(y);\n                if (rank[x] < rank[y]) parents[xParent] = yParent;\n                else if (rank[x] > rank[y]) parents[yParent] = xParent;\n                else {\n                    parents[yParent] = xParent;\n                    rank[xParent]++;\n                }\n            }\n\n            public ArrayList<Integer>[] getSets() {\n                HashMap<Integer, ArrayList<Integer>> sets = new HashMap<>();\n                for (int i = 0; i < parents.length; i++) {\n                    int parent = findParent(i);\n                    if (!sets.containsKey(parent)) sets.put(parent, new ArrayList<>());\n                    sets.get(parent).add(i);\n                }\n                int i = 0;\n                ArrayList<Integer>[] res = new ArrayList[sets.size()];\n                for (ArrayList<Integer> set: sets.values()) {\n                    res[i] = set;\n                    i++;\n                }\n                return res;\n            }\n\n            public boolean sameSet(int x, int y) {\n                return findParent(x) == findParent(y);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5;\nconst long long MOD = 1e9 + 7;\nlong long powe(long long a, long long b, long long m) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % m;\n    b /= 2;\n    a = (a * a) % m;\n  }\n  return ans;\n}\nlong long n, k, sz, ans = 0;\nbool vis[N];\nvector<long long> g[N];\nvoid dffs(long long u) {\n  if (vis[u]) return;\n  sz++;\n  vis[u] = 1;\n  for (auto &it : g[u]) dffs(it);\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> n >> k;\n  long long ans = powe(n, k, MOD);\n  for (long long i = 1; i <= n - 1; i++) {\n    long long u, v, x;\n    cin >> u >> v >> x;\n    if (x == 0) g[u].push_back(v), g[v].push_back(u);\n  }\n  for (long long i = 1; i <= n; i++) {\n    if (vis[i]) continue;\n    sz = 0;\n    dffs(i);\n    ans -= powe(sz, k, MOD);\n    ans += MOD;\n    ans %= MOD;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long maxn = 1e5 + 1;\nset<long long> a;\nconst long long mod = 1e9 + 7;\nlong long exp(long long base, long long expz) {\n  long long res = 1;\n  while (expz > 0) {\n    if (expz % 2 == 1) res = (res * base) % mod;\n    base = (base * base) % mod;\n    expz /= 2;\n  }\n  return res % mod;\n}\nlong long inv(long long a) { return exp(a, mod - 2); }\nclass graph {\n public:\n  vector<vector<pair<long long, long long>>> adj;\n  vector<long long> parent, level, visited;\n  long long size;\n  graph(long long n) {\n    size = n;\n    parent = vector<long long>(n, 0);\n    level = vector<long long>(n, 0);\n    visited = vector<long long>(n, 0);\n    adj = vector<vector<pair<long long, long long>>>(n);\n  }\n  void addEdge(long long a, long long b, long long v) {\n    --a;\n    --b;\n    adj[a].push_back(make_pair(b, v));\n    adj[b].push_back(make_pair(a, v));\n  }\n  void dfs(long long root, long long parent, long long color = -1) {\n    visited[root] = 1;\n    if (color == 0) {\n      a.insert(root);\n      a.insert(parent);\n    }\n    if (color == 1) {\n      return;\n    }\n    for (auto i : adj[root]) {\n      if (!visited[i.first] && i.second == 0) {\n        dfs(i.first, root, i.second);\n      }\n    }\n  }\n};\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  long long n, k;\n  cin >> n >> k;\n  graph t(n);\n  for (long long i = 0; i < n - 1; i++) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    t.addEdge(a, b, c);\n  }\n  long long res = exp(n, k) - n;\n  for (long long i = 0; i < n; i++) {\n    if (!t.visited[i]) {\n      t.dfs(i, i, -1);\n      long long top = a.size();\n      res -= exp(top, k) - top;\n      a.clear();\n      res %= mod;\n    }\n  }\n  if (res < 0) res += mod;\n  cout << res << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict, deque\n\n\ndef solve(n, k, graph):\n    lst = defaultdict(list)\n\n    for a, b, col in graph:\n        lst[a - 1].append((b - 1, col))\n        lst[b - 1].append((a - 1, col))\n\n    components = {}\n\n    def get_component(i):\n        visited = set([i])\n        component = set([i])\n        q = deque([i])\n\n        while q:\n            node = q.popleft()\n            visited.add(node)\n\n            for j, col in lst[node]:\n                if j in visited:\n                    continue\n\n                if col == 0:\n                    q.append(j)\n                    component.add(j)\n\n        return component\n\n    components = []\n    visited = set()\n    for i in range(n):\n        if i in visited:\n            continue\n\n        component = get_component(i)\n        components.append(len(component))\n\n        for j in component:\n            visited.add(j)\n\n    ans = n ** k\n    for c in components:\n        ans -= c ** k\n\n    return ans % (10 ** 9 + 7)\n\n\nif __name__ == '__main__':\n    n, k = (int(p) for p in input().split())\n    graph = []\n    for i in range(n - 1):\n        a, b, col = (int(p) for p in input().split())\n        graph.append((a, b, col))\n    print(solve(n, k, graph))\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Basics {\n\n    int mod = 1000000007;\n    int n; // 2 <= n <= 10^5\n    int k; // 2 <= k <= 100\n    List<List<Integer>> neighbours = new ArrayList<>();\n    boolean[] visted;\n    int color;\n\n    public void run() {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        k = sc.nextInt();\n        for (int i = 0; i < n + 1; i++) {\n            neighbours.add(new ArrayList<>());\n        }\n        visted = new boolean[n + 1];\n\n        for (int i = 0; i < n - 1; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int w = sc.nextInt();\n            if (w == 0) {\n                neighbours.get(x).add(y);\n                neighbours.get(y).add(x);\n            }\n        }\n\n        int answer = power(n, k);\n\n        for (int i = 1; i <= n; i++) {\n            if (!visted[i]) {\n                color++;\n                int nodeCount = dfs(i);\n                answer = (answer - power(nodeCount, k) + mod) % mod;\n            }\n        }\n        System.out.println(answer);\n    }\n\n    int dfs(int start) {\n        visted[start] = true;\n        int count = 0;\n        for (int next : neighbours.get(start)) {\n            if (!visted[next]) {\n                count += dfs(next);\n            }\n        }\n        return count + 1;\n    }\n\n    // raw power is okay\n    public int power(int n, int k) {\n        long answer = 1;\n        for (int i = 0; i < k; i++) {\n            answer = (answer * n) % mod;\n        }\n        // safe cast\n        return (int) answer;\n    }\n\n\n    public static void main(String[] args) {\n        new Basics().run();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<unsigned long long> adj[100001];\nvector<pair<unsigned long long, unsigned long long> > ans;\nunsigned long long vis[100001];\nunsigned long long m = 1e9 + 7;\nunsigned long long p;\nvoid dfs(unsigned long long v) {\n  p++;\n  vis[v] = 1;\n  for (unsigned long long i = 0; i < adj[v].size(); i++) {\n    unsigned long long to = adj[v][i];\n    if (!vis[to]) dfs(to);\n  }\n}\nunsigned long long pwr(unsigned long long a, unsigned long long b) {\n  unsigned long long ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % m;\n    b /= 2;\n    a = (a * a) % m;\n  }\n  return ans;\n}\nvoid love_for_infinity() {\n  unsigned long long n, k, bad = 0;\n  cin >> n >> k;\n  for (unsigned long long i = 0; i < n - 1; i++) {\n    unsigned long long x, y, z;\n    cin >> x >> y >> z;\n    if (z == 0) {\n      adj[x].push_back(y);\n      adj[y].push_back(x);\n    }\n  }\n  unsigned long long ans = pwr(n, k);\n  for (unsigned long long i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      p = 0;\n      dfs(i);\n      ans -= pwr(p, k);\n      ans += m;\n      ans = ans % m;\n    }\n  }\n  cout << ans;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  unsigned long long t;\n  t = 1;\n  while (t--) {\n    love_for_infinity();\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int mod = 1000000007;\n\n    static int find_conn(ArrayList<Integer>[] tree, boolean[] vis, int ver){\n        vis[ver] = true;\n        int ans = 1;\n        for(int x: tree[ver]){\n            if(!vis[x]) ans += find_conn(tree, vis, x);\n        }\n        return ans;\n    }\n\n    static long exp(int a, int b){\n        if(b == 0 || a == 1) return 1;\n        if(b%2 == 1) return (a*(exp(a, b-1)))%mod;\n        else{\n            long x = exp(a, b/2);\n            return (x*x)%mod;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] str = br.readLine().split(\" \");\n        int n = Integer.parseInt(str[0]), k = Integer.parseInt(str[1]);\n        ArrayList<Integer>[] tree = new ArrayList[n];\n        for(int i = 0; i<n; i++){\n            tree[i] = new ArrayList<>();\n        }\n        for(int i = 0; i<n-1; i++){\n            String[] st = br.readLine().split(\" \");\n            int u = Integer.parseInt(st[0])-1, v = Integer.parseInt(st[1])-1, c = Integer.parseInt(st[2]);\n            if(c == 0){\n                tree[v].add(u);\n                tree[u].add(v);\n            }\n        }\n        boolean[] vis = new boolean[n];\n        ArrayList<Integer> lst =new ArrayList<>();\n        for(int i = 0; i<n; i++) {\n            if(!vis[i]) lst.add(find_conn(tree, vis, i));\n        }\n        long exp1 = exp(n, k)%mod;\n        long exp2 = 0;\n        for(int x: lst){\n            exp2 = (exp2%mod + exp(x, k)%mod)%mod;\n        }\n        System.out.println((exp1-exp2+mod)%mod);\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys,threading\nsys.setrecursionlimit(10**6)\nthreading.stack_size(10**8)\ndef main():\n        global al,va\n        mod=1000000007\n        n,m=map(int,input().split())\n        al=[[]for i in range(n+1)]\n        for i in range(n-1):\n                a,b,c=map(int,input().split())\n                if(c==0):\n                        al[a].append(b)\n                        al[b].append(a)\n\n        va=[0]*(n+1)\n        ans=pow(n,m,mod)\n        #print(ans,al)\n        for e in range(1,n+1):\n                if(va[e]==0):\n                        global co\n                        co=0\n                        dfs(e)\n                        #print(co,\"rndurbfr4\")\n                        ans=ans-pow(co,m,mod)\n                        ans=ans%mod\n        print(ans)\n                        \n\n\n        \ndef dfs(n):\n        global al,va,co\n        va[n]=1\n        #print(co,\"drefrfcrevcrfvr\")\n        co=co+1\n        for e in al[n]:\n                if(va[e]==0):\n                        #print(co)\n                        dfs(e)\n           \n        \n\nt=threading.Thread(target=main)\nt.start()\nt.join()\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint val[100005];\nlong long mod = 1000000007;\nlong long fast(long long a, long long b, long long mod) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) {\n      res *= a;\n      res = (res + mod) % mod;\n      b--;\n    }\n    a *= a;\n    a = (a + mod) % mod;\n    b /= 2;\n  }\n  return res;\n}\nvector<pair<int, int> > a[100005];\nvector<int> v;\nint dfs(int x, int par) {\n  for (auto i : a[x]) {\n    if (i.first != par) {\n      if (i.second == 0)\n        val[x] += dfs(i.first, x);\n      else\n        dfs(i.first, x);\n    }\n  }\n  return val[x];\n}\nvoid dfs1(int x, int par, int p) {\n  if (p == 1 && val[x] > 1) {\n    v.push_back(val[x]);\n  }\n  for (auto i : a[x]) {\n    if (i.first != par) dfs1(i.first, x, i.second);\n  }\n  return;\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i <= n; i++) val[i] = 1;\n  for (int x, y, w, i = 0; i < n - 1; i++) {\n    cin >> x >> y >> w;\n    a[x].push_back({y, w});\n    a[y].push_back({x, w});\n  }\n  dfs(1, -1);\n  dfs1(1, -1, (val[1] > 1));\n  long long ans = fast(n, k, mod);\n  for (int i = 0; i < v.size(); i++) {\n    ans -= fast(v[i], k, mod);\n    ans = ans + v[i];\n    ans = (ans + mod) % mod;\n  }\n  ans -= n;\n  ans = (ans + mod) % mod;\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class D {\n\t\n\tstatic int mod = (int)1e9+7;\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\t\n\t\tUnionFind uf = new UnionFind(n);\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tint u = sc.nextInt()-1;\n\t\t\tint v = sc.nextInt()-1;\n\t\t\tint c = sc.nextInt();\n\t\t\t\n\t\t\tif(c==0)\n\t\t\t\tuf.unionSet(u, v);\n\t\t\t\n\t\t}\n\t\t\n\t\tHashSet<Integer> ps = new HashSet<Integer>();\n\t\tArrayList<Integer> cc = new ArrayList<Integer>();\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(!ps.contains(uf.findSet(i)))\n\t\t\t{\n\t\t\t\tps.add(uf.findSet(i));\n\t\t\t\tcc.add(uf.size[uf.findSet(i)]);\n\t\t\t}\n\t\t\n\t\t\n\t\tlong tot = exp(n,k);\n\t\tfor(int s:cc)\n\t\t{\n\t\t\ttot = add(tot,-exp(s,k));\n\t\t}\n\t\t\n\t\tSystem.out.println(tot);\n\t\t\n\t}\n\t\n\tstatic long add(long a,long b)\n\t{\n\t\treturn (mod + a+b)%mod;\n\t}\n\t\n\tstatic long mul(long a,long b)\n\t{\n\t\treturn (a*b)%mod;\n\t}\n\t\n\tstatic long exp(long base,long pow)\n\t{\n\t\tif(pow==0) return 1;\n\t\tlong half = exp(base,pow/2);\n\t\t\n\t\tif(pow%2==0) return mul(half,half);\n\t\treturn mul(half,mul(half,base));\n\t}\n\t\n\tstatic class UnionFind\n\t{\n\t\tint[] p;\n\t\tint[] size;\n\t\t\n\t\tUnionFind(int n)\n\t\t{\n\t\t\tp = new int[n];\n\t\t\tsize = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tp[i] = i;\n\t\t\tArrays.fill(size, 1);\n\t\t\t\n\t\t}\n\t\t\n\t\tint findSet(int i)\n\t\t{\n\t\t\treturn (p[i]==i)?i:(p[i] = findSet(p[i]));\n\t\t}\n\t\t\n\t\tboolean isSameSet(int i,int j)\n\t\t{\n\t\t\treturn findSet(i)==findSet(j);\n\t\t}\n\t\t\n\t\tvoid unionSet(int i,int j)\n\t\t{\n\t\t\tint x = findSet(i);\n\t\t\tint y = findSet(j);\n \n\t\t\tif(x==y) return;\n\t\t\tif(size[x]>size[y])\n\t\t\t{\n\t\t\t\tp[y] = x;\n\t\t\t\tsize[x]+=size[y];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp[x] = y;\n\t\t\t\tsize[y]+=size[x];\n\t\t\t}\n\t\t\t\t\n\t\t}\t\n\t}\n\t\n}\n\n\t   \t \t \t  \t\t \t\t\t\t \t \t\t  \t\t\t  \t"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\nfrom collections import deque\n\nMOD = pow(10, 9) + 7\n\nn, k = map(int, raw_input().strip().split())\n\ng = [[] for i in xrange(n + 1)]\nvis = [0 for i in xrange(n + 1)]\n\ndef bfs(u):\n    global vis, g\n    \n    ret = 0\n    vis[u] = 1\n    q = deque([u])\n    while q:\n        v = q.popleft()\n        ret += 1\n        for child in g[v]:\n            if not vis[child]:\n                vis[child] = 1\n                q.append(child)\n\n    return ret                \n\ninp = stdin.readlines()\n\nfor line in inp:\n    u, v, w = map(int, line.strip().split())\n    if w == 0:\n        g[u].append(v)\n        g[v].append(u)\n\nans = pow(n, k, MOD)\n\nfor u in xrange(1, n + 1):\n    if not vis[u]:\n        nc = bfs(u)\n        ans = ans - pow(nc, k, MOD)\n        if ans < 0 or ans >= MOD: ans %= MOD\n\nprint ans"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k;\nvector<vector<pair<long long, long long> > > nodes;\nvector<long long> bad;\nint main() {\n  cin >> n >> k;\n  nodes.resize(n);\n  bad.resize(n);\n  vector<long long> ins(n);\n  for (int i = 0; i < n - 1; i++) {\n    long long u, v, x;\n    cin >> u >> v >> x;\n    u--;\n    v--;\n    nodes[u].push_back({v, x});\n    nodes[v].push_back({u, x});\n  }\n  queue<long long> q;\n  for (int i = 0; i < n; i++) {\n    if (nodes[i].size() == 1) {\n      q.push(i);\n    }\n    ins[i] = nodes[i].size();\n  }\n  vector<bool> used(n);\n  while (q.size() > 0) {\n    long long cur = q.front();\n    q.pop();\n    used[cur] = 1;\n    bad[cur]++;\n    if (ins[cur] == 0) {\n      q.push(cur);\n      break;\n    }\n    for (int i = 0; i < nodes[cur].size(); i++) {\n      if (used[nodes[cur][i].first]) continue;\n      ins[nodes[cur][i].first]--;\n      if (nodes[cur][i].second == 0) bad[nodes[cur][i].first] += bad[cur];\n      if (ins[nodes[cur][i].first] <= 1) q.push(nodes[cur][i].first);\n    }\n  }\n  used.resize(0);\n  used.resize(n);\n  while (q.size() > 0) {\n    long long cur = q.front();\n    q.pop();\n    used[cur] = 1;\n    for (int i = 0; i < nodes[cur].size(); i++) {\n      if (used[nodes[cur][i].first]) continue;\n      if (nodes[cur][i].second == 0)\n        bad[nodes[cur][i].first] += bad[cur] - bad[nodes[cur][i].first];\n      q.push(nodes[cur][i].first);\n    }\n  }\n  long long allAnsw = 0;\n  for (int i = 0; i < n; i++) {\n    long long answ = 1;\n    answ %= (long long)(1e9 + 7);\n    long long wrong = 1;\n    for (int j = 1; j < k; j++) {\n      answ *= n;\n      answ %= (long long)(1e9 + 7);\n      wrong *= bad[i];\n      wrong %= (long long)(1e9 + 7);\n    }\n    answ = (answ - wrong + (long long)(1e9 + 7)) % (long long)(1e9 + 7);\n    allAnsw += answ;\n    allAnsw %= (long long)(1e9 + 7);\n  }\n  cout << allAnsw << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class c\n{\n    static long mod = (long)1e9+7;\n    \n    public static void main(String[] args) throws IOException\n    {\n        fs in = new fs();\n        int n = in.nextInt();\n        int k = in.nextInt();\n        DSU tree = new DSU(n);\n        for (int i = 0; i < n-1; i++)\n        {\n            int u = in.nextInt()-1;\n            int v = in.nextInt()-1;\n            int x = in.nextInt();\n            if (x == 1) continue;\n            tree.union(u, v);\n        }\n        \n        int[] sizes = new int[n];\n        for (int i = 0; i < n; i++)\n            sizes[tree.find(i)]++;\n        long ans = exp(n, k);\n        for (int i = 0; i < n; i++)\n        {\n            ans -= exp(sizes[i], k);\n            if (ans < 0) ans += mod;\n        }\n        ans %= mod;\n        System.out.println(ans);\n    }\n    \n    public static long exp(long s, long k)\n    {\n        if (s == 0) return 0;\n        if (k == 0) return 1L;\n        if (k == 1) return s %mod;\n        long ans = exp(s, k/2);\n        ans *= ans; ans %= mod;\n        if (k %2 == 0) return ans;\n        return (s*ans) %mod;\n    }\n    \n    public static class DSU\n    {\n        int[] set;\n        \n        DSU(int n)\n        {\n            Arrays.fill(set = new int[n], -1);\n        }\n        \n        int find(int i)\n        {\n            return set[i] < 0 ? i : (set[i] = find(set[i]));\n        }\n        \n        boolean union(int a, int b)\n        {\n            if ((a = find(a)) == (b = find(b))) return false;\n            if (set[a] == set[b]) set[a]--;\n            if (set[a] <= set[b]) set[b] = a; else set[a] = b;\n            return true;\n        }\n    }\n    \n    static class fs\n    {\n        BufferedReader b;\n        StringTokenizer s;\n        \n        public fs()\n        {\n            b = new BufferedReader(new InputStreamReader(System.in));\n            s = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException\n        {\n            if (s.hasMoreTokens()) return s.nextToken();\n            else s = new StringTokenizer(b.readLine());\n            return next();\n        }\n        \n        public int nextInt() throws IOException\n        {\n            return Integer.parseInt(next());\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "a = lambda:map(int,input().split())\ns = lambda:list(a())\nd, f = a()\nz = {i : {i} for i in range(d)}\nx = {i : i for i in range(d)}\nfor i in range(d - 1):\n\tc, v, q = a()\n\tc, v = c - 1, v - 1\n\tif q == 0:\n\t\tw, e = z[x[c]], z[x[v]]\n\t\tif len(w) > len(e):\n\t\t\tw |= e\n\t\t\tdel z[x[v]]\n\t\t\tfor o in e:\n\t\t\t\tx[o] = x[c]\n\t\telse:\n\t\t\te |= w\n\t\t\tdel z[x[c]]\n\t\t\tfor o in w:\n\t\t\t\tx[o] = x[v]\nr = 0\nfor i in z:\n\tr += len(z[i]) ** f\nprint((d ** f - r) % (7 + 10 ** 9))"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\n \npublic class Main {\n \n    void solve() throws IOException {\n        int N = ni();\n        int K = ni();\n        UnionFind uf = new UnionFind(N);\n        for (int i = 0; i < N-1; i++) {\n            int u = ni()-1;\n            int v = ni()-1;\n            int k = ni();\n            if(k==0) uf.union(u, v);\n        }\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            int par = uf.find(i);\n            map.putIfAbsent(par, new ArrayList<Integer>());\n            map.get(par).add(i);\n        }\n        int all = (int)MathLib.pow_mod(N, K, mod);\n        // System.out.println(all);\n        for (ArrayList<Integer> list : map.values()) {\n            int siz = list.size();\n            all = sub(all, (int)MathLib.pow_mod(siz, K, mod));\n        }\n        out.println(all);\n    }\n    class UnionFind{\n        int[] par;\n        UnionFind(int n){\n            par = new int[n];\n            for (int i = 0; i < n; i++) {\n                par[i] = -1;\n            }\n        }\n        int find (int n){\n            if(par[n] < 0){\n                return n;\n            }else{\n                return find(par[n]);\n            }\n        }\n        boolean union(int a, int b){\n            a = find(a);\n            b = find(b);\n            if(a == b) return false;\n            if(par[a] > par[b]){\n                int temp = b;\n                b = a;\n                a = temp;\n            }\n            par[a] += par[b];\n            par[b] = a;\n            return true;\n        }\n        int par(int n){\n            return par[n];\n        }\n        int size(int n){\n            return -par[find(n)];\n        }\n        boolean same(int a, int b){\n            return find(a) == find(b);\n        }\n    }\n    final int mod = 1000000007;\n    final BigInteger MOD = BigInteger.valueOf(mod);\n    \n    long gcd(long num1,long num2) {\n        if(num2 == 0) return num1;\n        else return gcd(num2 , num1 % num2 );\n    }\n    long lcm(long a, long b){\n        return (a / gcd(a, b)) * b;\n    }\n    int mul(int x, int y){\n        int val = (int)((x * 1L * y) % mod);\n        return val>=0 ? val : val+mod;\n    }\n    int add(int x, int y) {\n        x += y;\n        if(x < 0) x += mod;\n        if(x>=mod) x -= mod;\n        return x;\n    }\n    int sub(int x, int y){\n        x = add(x,mod-y);\n        if(x < 0) x += mod;\n        if(x>=mod) x -= mod;\n        return x;\n    }\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n \n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n \n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n \n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n \n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n \n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n \n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n    void print2DArray(int[][] a){\n        for (int i = 0; i < a.length; i++) {\n            System.out.println(Arrays.toString(a[i]));\n        }\n    }\n \n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n \n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}\nclass MathLib{\n    private static long safe_mod(long x, long m){\n        x %= m;\n        if(x<0) x += m;\n        return x;\n    }\n\n    private static long[] inv_gcd(long a, long b){\n        a = safe_mod(a, b);\n        if(a==0) return new long[]{b,0};\n\n        long s=b, t=a;\n        long m0=0, m1=1;\n        while(t>0){\n            long u = s/t;\n            s -= t*u;\n            m0 -= m1*u;\n            long tmp = s; s = t; t = tmp;\n            tmp = m0; m0 = m1; m1 = tmp;\n        }\n        if(m0<0) m0 += b/s;\n        return new long[]{s,m0};\n    }\n\n    public static long pow_mod(long x, long n, int m){\n        assert n >= 0;\n        assert m >= 1;\n        if(m == 1)return 0L;\n        x = safe_mod(x, m);\n        long ans = 1L;\n        while(n > 0){\n            if((n&1) == 1) ans = (ans * x) % m;\n            x = (x*x) % m;\n            n >>>= 1;\n        }\n        return ans;\n    }\n\n    public static long[] crt(long[] r, long[] m){\n        // find x = r[i] mod m[i] for all i\n        // x = y mod z (0 <= y < z = lcm(m))\n        // returns [y, z]\n        // if no solution returns [0,0]\n        assert(r.length == m.length);\n        int n = r.length;\n\n        long r0=0, m0=1;\n        for(int i=0; i<n; i++){\n            assert(1 <= m[i]);\n            long r1 = safe_mod(r[i], m[i]), m1 = m[i];\n            if(m0 < m1){\n                long tmp = r0; r0 = r1; r1 = tmp;\n                tmp = m0; m0 = m1; m1 = tmp;\n            }\n            if(m0%m1 == 0){\n                if(r0%m1 != r1) return new long[]{0,0};\n                continue;\n            }\n\n            long[] ig = inv_gcd(m0, m1);\n            long g = ig[0], im = ig[1];\n\n            long u1 = m1/g;\n            if((r1-r0)%g != 0) return new long[]{0,0};\n\n            long x = (r1-r0) / g % u1 * im % u1;\n\n            r0 += x * m0;\n            m0 *= u1;\n            if(r0<0) r0 += m0;\n            //System.err.printf(\"%d %d\\n\", r0, m0);\n        } \n        return new long[]{r0, m0};\n    }\n    public static long floor_sum(long n, long m, long a, long b){\n        long ans = 0;\n        if(a >= m){\n            ans += (n-1) * n * (a/m) / 2;\n            a %= m;\n        }\n        if(b >= m){\n            ans += n * (b/m);\n            b %= m;\n        }\n\n        long y_max = (a*n+b) / m;\n        long x_max = y_max * m - b;\n        if(y_max == 0) return ans;\n        ans += (n - (x_max+a-1)/a) * y_max;\n        ans += floor_sum(y_max, a, m, (a-x_max%a)%a);\n        return ans;\n    }\n}"
        },
        {
            "language": 1,
            "solution": "N,K = map(int,raw_input().split())\npar = [x for x in range(N)]\nrank = [0 for x in range(N)]\n\ndef p(a):\n    if par[a]==a:\n        return a\n    return p(par[a])\n\ndef join(a,b):\n    if rank[a]==rank[b]:\n        rank[a] += 1\n        par[b] = a\n    elif rank[a]<rank[b]:\n        par[a] = b\n    else:\n        par[b] = a\n\nfor i in range(N-1):\n    a,b,c = map(int,raw_input().split())\n    a -= 1\n    b -= 1\n    if not c:\n        a,b = p(a),p(b)\n        join(a,b)\n\narr = [0 for x in range(N)]\n\nmod = pow(10,9)+7\n\nfor i in range(N):\n    arr[p(i)] += 1\n\nans = pow(N,K,mod)\n\nfor i in range(N):\n    cur = pow(arr[i],K,mod)\n    ans -= cur\n    ans %= mod\n\nprint ans\n\n\n'''\n3 2\n1 2 1\n2 3 1\n\n'''"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class  Edgy_Trees\n{\n\tpublic static void main(String[] args) throws IOException \n\t{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\n\t\tint t=1;\n\n\t\twhile(t-->0)\n\t\t{ \n\t\t\tString str[]=br.readLine().trim().split(\" \");\n\t\t\tint n=Integer.parseInt(str[0]);\n\t\t\tint k=Integer.parseInt(str[1]);\n\n\t\t\tadj=new ArrayList[n+1];\n\t\t\tfor(int i=0;i<n+1;i++)\n\t\t\t\tadj[i]=new ArrayList<>();\n\n\t\t\tfor(int i=0;i<n-1;i++)\n\t\t\t{\n\t\t\t\tstr=br.readLine().trim().split(\" \");\n\n\t\t\t\tint type=Integer.parseInt(str[2]);\n\n\t\t\t\tint x=Integer.parseInt(str[0]);\n\t\t\t\tint y=Integer.parseInt(str[1]);\n\n\t\t\t\tif(type==0)\n\t\t\t\t{\n\t\t\t\t\tadj[x].add(y);\n\t\t\t\t\tadj[y].add(x);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv=new boolean[n+1];\n\t\t\tlong ans=0;\n\t\t\tlong mod=1000000007;\n\t\t\tfor(int i=1;i<n+1;i++)\n\t\t\t{\n\t\t\t\tif(!v[i])\n\t\t\t\t{\n\t\t\t\t\tcount=0;\n\t\t\t\t\tdsf(i,-1);\n\t\t\t\t\tans=(ans+power((long)count,(long)k,mod))%mod;\n\t\t\t\t\t//pw.println(count);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tlong total=power((long)n,(long)k,mod);\n\n\t\t\tpw.println((total-ans+mod)%mod);\n\n\n\t\t\t\n\t\t}\n\t\tpw.flush();\n\t}\t\n\n\tstatic ArrayList<Integer> adj[];\n\tstatic int n;\n\tstatic int k;\n\n\tstatic int count;\n\tstatic boolean v[];\n\n\tpublic static void dsf(int c,int p)\n\t{\n\t\tif(v[c])\n\t\t\treturn;\n\n\t\tv[c]=true;\n\t\tcount++;\n\t\tfor(int x:adj[c])\n\t\t{\n\t\t\tif(x!=p && !v[x])\n\t\t\t\tdsf(x,c);\n\t\t}\n\t}\n\n\tstatic long power(long x, long y, long m)  \n    { \n        if (y == 0) \n            return 1; \n          \n        long p = power(x, y / 2, m) % m; \n        p = (p * p) % m; \n      \n        if (y % 2 == 0) \n            return p; \n        else\n            return (x * p) % m; \n    } \n}"
        },
        {
            "language": 3,
            "solution": "n,k=map(int,input().split())\ng=[[] for _ in range(n+1)]\n\nfor i in range(n-1):\n    u,v,c=map(int,input().split())\n    if c==0:\n        g[u].append(v)\n        g[v].append(u)\nmod=10**9+7\ndef cal_pow(a,b):\n    global mod\n    i=0\n    val=1\n    while i<b:\n        val=(val*a)%mod\n        i+=1\n    return (val-a+mod)%mod\n\nsumm=cal_pow(n,k)\nvis=[False for _ in range(n+1)]\nfrom collections import deque\ndef bfs(ind):\n    q=deque()\n    q.append(ind)\n    cnt=0\n    vis[ind]=True\n    while q:\n        indx=q.popleft()\n        cnt+=1\n        for v in g[indx]:\n            if not vis[v]:\n                q.append(v)\n                vis[v]=True\n    return cnt\n\nfor v in range(1,n+1):\n    if not vis[v]:\n        cnt=bfs(v)\n        summ=((mod+summ)-(cal_pow(cnt,k)))%mod\nprint(summ)\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            int k=Integer.parseInt(s1[1]);\n            \n            HashSet<Integer> hs[]=new HashSet[n+1];\n            HashSet<Integer> h=new HashSet<Integer>();\n            for(int i=1;i<=n;i++)\n             hs[i]=new HashSet<Integer>();\n            for(int i=0;i<n-1;i++)\n            {\n                  String s2[]=br.readLine().split(\" \");\n                  int u=Integer.parseInt(s2[0]);\n                  int v=Integer.parseInt(s2[1]);\n                  int x=Integer.parseInt(s2[2]);\n                  \n                  if(x==1)\n                   continue;\n                  hs[u].add(v);\n                  hs[v].add(u);\n            }\n            \n            long S=0;\n            long mod=1000000007;\n            for(int i=1;i<=n;i++)\n            {\n                  if(h.contains(i))\n                   continue;\n                  Queue<Integer> q=new LinkedList<Integer>();\n                  q.add(i);\n                  long t=1;\n                  h.add(i);\n                  while(!q.isEmpty())\n                  {\n                        int u=q.poll();\n                        Iterator it=hs[u].iterator();\n                        while(it.hasNext())\n                        {\n                              int v=(int)it.next();\n                              if(!h.contains(v))\n                              { h.add(v); q.add(v); t++; }\n                        }\n                  }\n                  \n                  long p=1;\n                  for(int j=0;j<k;j++)\n                  {\n                      p=(p*t)%mod;\n                  }\n                  S=(S+p)%mod;\n            }\n            long r=1;\n            for(int i=0;i<k;i++)\n             r=(r*n)%mod;\n            \n            System.out.println((r-S+mod)%mod);\n      }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class GFG770 {\n    static int mod1 = (int) (1e9 + 7);\n    static LinkedList<Integer>[] linkedLists;\n    static int count1=0;\n    static int[] visited;\n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String nextString() throws IOException {\n            String str00 = scan.next();\n            return str00;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        String next() throws IOException {\n            int c;\n            for (c = read(); c <= 32; c = read());\n            StringBuilder sb = new StringBuilder();\n            for (; c > 32; c = read()) {\n                sb.append((char) c);\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null)\n                return;\n            din.close();\n        }\n\n        public int[] nextArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n    }\n\n\n    static int GCD(int a, int b) {\n        BigInteger big1 = new BigInteger(String.valueOf(a));\n        BigInteger big2 = new BigInteger(String.valueOf(b));\n        big1 = big1.gcd(big2);\n        return Integer.parseInt(big1.toString());\n    }\n\n\n    static long power(long x, long y, long p)\n    {\n        long res = 1;      // Initialize result\n\n        x = x % p;  // Update x if it is more than or\n        // equal to p\n\n        while (y > 0)\n        {\n            // If y is odd, multiply x with result\n            if (y%2!=0)\n                res = (res*x) % p;\n\n            // y must be even now\n            y = y>>1; // y = y/2\n            x = (x*x) % p;\n        }\n        return res;\n    }\n\n\n    static boolean primeCheck(long num0) {\n        boolean b1 = true;\n        if (num0 == 1) {\n            b1 = false;\n        } else {\n            int num01 = (int) (Math.sqrt(num0)) + 1;\n            me1:\n            for (int i = 2; i < num01; i++) {\n                if (num0 % i == 0) {\n                    b1 = false;\n                    break me1;\n                }\n            }\n        }\n        return b1;\n    }\n\n    public static int dev(long num1)\n    {\n        int count00=0;\n        while (num1%2==0)\n        {\n            count00++;\n            num1/=2;\n        }\n        HashMap<Long,Long> hashMap=new HashMap<>();\n        if(count00!=0)\n        {\n            hashMap.put(2L,(long)count00);\n        }\n        for (int i = 3; i <= (int)Math.sqrt(num1); i = i + 2)\n        {\n            // While i divides n, print i and divide n\n            if(num1%i==0) {\n                int count01 = 0;\n\n                while (num1 % i == 0) {\n                    num1 /= i;\n                    count01++;\n                }\n                hashMap.put((long)i,(long)count01);\n            }\n        }\n        if(num1>2)\n        {\n            hashMap.put((long)num1,1L);\n        }\n        long numOfDiv=1;\n        for(long num00:hashMap.keySet())\n        {\n            long cDiv0=hashMap.get(num00);\n            numOfDiv*=(cDiv0+1);\n        }\n\n        return (int)(numOfDiv);\n    }\n\n    static void dfs(int index)\n    {\n        visited[index]=1;\n        count1++;\n\n        for(int num00:linkedLists[index])\n        {\n            if(visited[num00]==0)\n            {\n                dfs(num00);\n            }\n        }\n    }\n\n\n    public static void main(String[] args) throws IOException {\n        //Reader r = new Reader();\n        //PrintWriter writer=new PrintWriter(System.out);\n        Scanner r = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        //OutputWriter770 out77 = new OutputWriter770(System.out);\n\n        int len1=r.nextInt();\n        int k=r.nextInt();\n        visited=new int[len1+1];\n        linkedLists=new LinkedList[len1+1];\n        for(int i=0;i<len1+1;i++)\n        {\n            linkedLists[i]=new LinkedList<>();\n        }\n        for(int i=0;i<len1-1;i++)\n        {\n            int U=r.nextInt();\n            int V=r.nextInt();\n            int st=r.nextInt();\n\n            if(st==0)\n            {\n                linkedLists[U].addLast(V);\n                linkedLists[V].addLast(U);\n            }\n        }\n\n        long res1=0;\n\n        for(int i=1;i<len1+1;i++)\n        {\n            if(visited[i]==0)\n            {\n                count1=0;\n                dfs(i);\n                long res2=power(count1,k,mod1);\n                res1+=res2;\n                res1%=mod1;\n            }\n        }\n        res1=power(len1,k,mod1)-res1;\n        res1+=mod1;\n        res1%=mod1;\n        System.out.print(res1+\"\");\n        r.close();\n    }\n}\n\nclass OutputWriter770\n{\n    BufferedWriter writer;\n\n    public OutputWriter770(OutputStream stream)\n    {\n        writer = new BufferedWriter(new OutputStreamWriter(stream));\n    }\n    public void print(int i) throws IOException\n    {\n        writer.write(i + \"\");\n    }\n\n    public void println(int i) throws IOException\n    {\n        writer.write(i + \"\\n\");\n    }\n\n    public void print(String s) throws IOException\n    {\n        writer.write(s + \"\");\n    }\n\n    public void println(String s) throws IOException\n    {\n        writer.write(s + \"\\n\");\n    }\n\n    public void print(char[] c) throws IOException\n    {\n        writer.write(c);\n    }\n\n    public void close() throws IOException\n    {\n        writer.flush();\n        writer.close();\n    }\n}\n\nclass NodeInfo\n{\n    int i,j;\n    NodeInfo(int i,int j)\n    {\n        this.i=i;\n        this.j=j;\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "from collections import deque\n\nn, k = map(int, raw_input().split())\ne = [[] for i in range(n)]\nf = {}\no = 1000000007\n\nfor i in range(n - 1):\n    u, v, c = map(int, raw_input().split())\n    e[u - 1].append(v - 1)\n    e[v - 1].append(u - 1)\n    f[(u - 1, v - 1)] = c\n    f[(v - 1, u - 1)] = c\n\nv = [False] * n\nz = 0\nfor i in range(n):\n    if not v[i]:\n        v[i] = True\n        s = deque([i])\n        c = 1\n        while len(s) > 0:\n            x = s.popleft()\n            for y in e[x]:\n                if not v[y] and f[(x, y)] == 0:\n                    v[y] = True\n                    s.append(y)\n                    c += 1\n        z += pow(c, k, o)\n\nprint (pow(n, k, o) - z) % o\n"
        },
        {
            "language": 3,
            "solution": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return (n * factorial(n-1))%(10**9+7)\n\n\n\nn, k = [int(i) for i  in input().split()]\ns = [[] for i in range(n)]\nfor i in range(n-1):\n    a,b,c = [int(i) for i in input().split()]\n    if c == 0:\n        s[a-1].append(b-1)\n        s[b - 1].append(a - 1)\nused = [False]*n\n\nans = pow(n, k, 10**9+7)\nfor i in range(n):\n    if not used[i]:\n        comp = []\n        used[i] = True\n        comp.append(i)\n        c=0\n        while c < len(comp):\n            for h in s[comp[c]]:\n                if not used[h]:\n                    used[h] = True\n                    comp.append(h)\n            c+=1\n        ans = (ans-pow(len(comp), k, 10**9+7))%(10**9+7)\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint64_t n, nn, k, i, j, y, u, v, a, b, c, Z = 1e9 + 7, l[222000], h[222000];\nint L(int x) { return l[x] == x ? x : l[x] = L(l[x]); }\nint main() {\n  cin >> n >> k;\n  for (i = 1; i <= n; i++) l[i] = i;\n  for (i = 1; i < n; i++) {\n    cin >> u >> v >> y;\n    if (!y) l[L(u)] = L(v);\n  }\n  for (i = 1; i <= n; i++) h[L(i)]++;\n  for (i = 1; i <= n; i++) {\n    if (h[i] == 1)\n      b++;\n    else {\n      for (c = 1, j = 0; j < k; j++) c *= h[i], c %= Z;\n      a += c;\n      a %= Z;\n    }\n  }\n  for (nn = 1, j = 0; j < k; j++) nn *= n, nn %= Z;\n  cout << (nn - a - b + Z + Z) % Z;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10, mo = 1e9 + 7;\nint n, k;\nint ds[N], si[N];\nint dsu(int x) { return x == ds[x] ? ds[x] : dsu(ds[x]); }\nlong long mul(int a, int n) {\n  if (n == 0) return 1;\n  long long t = mul(a, n / 2);\n  t = t * t % mo;\n  return (n & 1) ? t * a % mo : t;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1, _end = n; i <= _end; i++) si[i] = 1, ds[i] = i;\n  for (int i = 1, _end = n - 1; i <= _end; i++) {\n    int x, y, z;\n    scanf(\"%d%d%d\", &x, &y, &z);\n    if (z == 0) {\n      int X = dsu(x), Y = dsu(y);\n      ds[X] = Y;\n      si[Y] += si[X];\n    }\n  }\n  long long ans = 0;\n  for (int i = 1, _end = n; i <= _end; i++)\n    if (ds[i] == i) {\n      ans += mul(si[i], k);\n      ans %= mo;\n    }\n  long long tot = mul(n, k);\n  printf(\"%lld\", ((tot - ans) % mo + mo) % mo);\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\nclass Unionfind:\n    def __init__(self, n):\n        self.par = [-1]*n\n        self.rank = [1]*n\n    \n    def root(self, x):\n        p = x\n        \n        while not self.par[p]<0:\n            p = self.par[p]\n        \n        while x!=p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        \n        return p\n    \n    def unite(self, x, y):\n        rx, ry = self.root(x), self.root(y)\n        \n        if rx==ry: return False\n        \n        if self.rank[rx]<self.rank[ry]:\n            rx, ry = ry, rx\n        \n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n    \n        if self.rank[rx]==self.rank[ry]:\n            self.rank[rx] += 1\n    \n    def is_same(self, x, y):\n        return self.root(x)==self.root(y)\n    \n    def count(self, x):\n        return -self.par[self.root(x)]\n\nn, k = map(int, input().split())\nMOD = 10**9+7\nuf = Unionfind(n)\n\nfor _ in range(n-1):\n    u, v, x = map(int, input().split())\n    \n    if x==0:\n        uf.unite(u-1, v-1)\n    \nsub = 0\nroots = set(uf.root(i) for i in range(n))\n\nfor r in roots:\n    c = uf.count(r)\n    sub += pow(c, k, MOD)\n    sub %= MOD\n\nprint((pow(n, k, MOD)-sub)%MOD)"
        },
        {
            "language": 3,
            "solution": "from sys import stdin,stdout\nfrom itertools import combinations\nfrom collections import defaultdict\nimport math\nimport heapq\n\ndef listIn():\n    return list((map(int,stdin.readline().strip().split())))\n\ndef stringListIn():\n    return([x for x in stdin.readline().split()])\n    \ndef intIn():\n    return (int(stdin.readline()))\n\ndef stringIn():\n    return (stdin.readline().strip())\n\n\nif __name__==\"__main__\":\n    n,k=listIn()\n    di=defaultdict(list)\n    for i in range(n-1):\n        u,v,w=listIn()\n        if w==0:\n            di[u].append(v)\n            di[v].append(u)\n            \n    m=10**9+7\n    final=pow(n,k,m)\n    vis=[0]*(n+1)\n    for i in range(1,n+1):\n        if vis[i]==0:\n            li,s=[i],1\n            vis[i]=1\n            while(li):\n                ele=li.pop(-1)\n                for p in di[ele]:\n                    if vis[p]==0:\n                        s+=1\n                        li.append(p)\n                        vis[p]=1\n            #print(i,s)\n            final-=pow(s,k,m)\n            \n    print(final%m)\n        \n    \n    \n    \n    \n    \n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Mod = 1e9 + 7;\nint n, m, q, k;\nint a[300005], b[300005], f[300005], g[300005], c;\nint h[300005], nxt[600005], to[600005], tot;\ninline void ins(int x, int y) {\n  nxt[++tot] = h[x];\n  to[tot] = y;\n  h[x] = tot;\n}\nvoid d(int u) {\n  b[u] = 1;\n  ++c;\n  for (int i = h[u]; i; i = nxt[i])\n    if (!b[to[i]]) d(to[i]);\n}\nint main() {\n  int x, y, z;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 2; i <= (n); ++i)\n    scanf(\"%d%d%d\", &x, &y, &z), (!z ? (ins(x, y), ins(y, x)) : void(0));\n  int Ans = 1;\n  for (int i = 1; i <= (k); ++i) Ans = (long long)Ans * n % Mod;\n  for (int i = 1; i <= (n); ++i)\n    if (!b[i]) {\n      c = 0, d(i);\n      int s = 1;\n      for (int j = 1; j <= (k); ++j) s = (long long)s * c % Mod;\n      Ans = (Ans - s + Mod) % Mod;\n    }\n  printf(\"%d\\n\", Ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\nfrom collections import deque\nmod = 10**9 + 7\nn,k=map(int,input().split())\nd=defaultdict(list)\nfor i in range(n-1):\n    u,v,t=map(int,input().split())\n    if t==0:\n        d[u].append(v)\n        d[v].append(u)\nvisited={}\nans=0\nfor i in d:\n    if visited.get(i,0)==0:\n        x=1\n        visited[i]=1\n        q=deque()\n        q.append(i)\n        while q:\n            j=q.popleft()\n            for m in d[j]:\n                if visited.get(m,0)==0:\n                    visited[m]=1\n                    q.append(m)\n                    x=x+1\n        ans=(ans+pow(x,k,mod))%mod\nb=n-len(d)\nans=(pow(n,k,mod)-ans)%mod\nans=(ans-b)%mod\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "def dfs(s):\n\tstk,cnt=[],[]\n\tstk.append(s)\n\tcnt.append(0)\n\twhile (len(stk)>0):\n\t\ts=stk[-1]\n\t\tll=cnt[-1]\n\t\tvisit[s]=1\n\t\t# print(s)\n\t\tflag=1\n\t\tfor j in range(ll,len(adj[s]),1):\n\t\t\tif visit[adj[s][j]]==0:\n\t\t\t\tct[0]+=1\n\t\t\t\tcnt[-1]=j+1\n\t\t\t\tstk.append(adj[s][j])\n\t\t\t\tcnt.append(0)\n\t\t\t\tflag=0\n\t\t\t\tbreak\n\t\tif flag:\n\t\t\tstk.pop()\n\t\t\tcnt.pop()\n\ndef power(a,b,mod):\n\tres=1\n\twhile(b>0):\n\t\tif b&1:\n\t\t\tres=(res*a)%mod\n\t\ta=(a*a)%mod\n\t\tb>>=1\n\treturn res\n\t\nn,k=map(int,input().split())\nadj=[0]*(n+1)\nfor i in range(n+1):\n\tadj[i]=[]\nfor i in range(n-1):\n\tx,y,f=map(int,input().split())\n\tif f==0:\n\t\tadj[x].append(y)\n\t\tadj[y].append(x)\nvisit=[0]*(n+1)\nmp={}\n# print(adj)\nfor i in range(1,n+1):\n\tif visit[i]==0:\n\t\tct=[1]*1\n\t\tdfs(i)\n\t\tmp[i]=ct[0]\nans=power(n,k,1000000007)\nfor i in mp:\n\tans=(ans-power(mp[i],k,1000000007)+1000000007)%1000000007\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\n\n/**\n * Created by himanshubhardwaj on 09/04/19.\n */\npublic class EdgyTrees {\n    static long mod = 1000000007;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] str = br.readLine().split(\" \");\n\n        int n = Integer.parseInt(str[0]);\n        int k = Integer.parseInt(str[1]);\n\n        Tree tree = new Tree(n);\n\n        for (int i = 0; i < (n - 1); i++) {\n            str = br.readLine().split(\" \");\n            int source = Integer.parseInt(str[0]) - 1;\n            int destination = Integer.parseInt(str[1]) - 1;\n            boolean isGood = (Integer.parseInt(str[2]) == 1) ? false : true;\n            tree.insert(source, destination, isGood);\n        }\n        long sum = 0;\n        for (int x : tree.connectedComponents(n)) {\n          //  System.out.print(x+\", \");\n            sum += powMod(x, k);\n            sum = sum % mod;\n        }\n        //System.out.println(\"------\");\n        //System.out.println(tree.count);\n\n\n        System.out.print((powMod(n, k) - sum+mod) % mod);\n\n    }\n\n\n    static long powMod(long a, long x) {\n        long temp = 1;\n        for (int i = 1; i <= x; i++) {\n            temp = (temp * a) % mod;\n        }\n        return temp;\n    }\n}\n\n\nclass Tree {\n    ArrayList<Integer>[] neighbours = null;\n    int count = 0;\n\n\n    public Tree(int n) {\n        neighbours = new ArrayList[n];\n\n        for (int i = 0; i < n; i++) {\n            neighbours[i] = new ArrayList<>();\n        }\n    }\n\n\n    void insert(int source, int destination, boolean isGood) {\n        if (isGood) {\n            neighbours[source].add(destination);\n            neighbours[destination].add(source);\n            count++;\n        }\n    }\n\n    ArrayList<Integer> connectedComponents(int n) {\n        boolean[] reached = new boolean[n];\n        ArrayList<Integer> connectedComponentSize = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            if (!reached[i]) {\n                connectedComponentSize.add(connectedComponentSize(i, -1, reached));\n            }\n        }\n\n\n        return connectedComponentSize;\n    }\n\n    private Integer connectedComponentSize(int node, int parent, boolean[] reached) {\n        if (reached[node]) {\n            return 0;\n        }\n\n        reached[node] = true;\n        int count = 1;\n\n        for (int neightbour : neighbours[node]) {\n            if (neightbour != parent) {\n                count += connectedComponentSize(neightbour, node, reached);\n            }\n        }\n        return count;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "intin=lambda:map(int,input().split())\nAin=lambda:list(map(int,input().split()))\nmod=1000000007\n\nn,k=intin()\nm=n+1\nv=[[] for i in range(m)]\nvis=[False]*m\ndev=[]\nfor _ in range(n-1):\n    a,b,x=intin()\n    if x==0:\n        v[a].append(b)\n        v[b].append(a)\n\ndef dfs(node):\n    q=[node]\n    cnt=0\n    while len(q)>0:\n        cur=q.pop()\n        cnt+=1\n        vis[cur]=True\n        for i in range(len(v[cur])):\n            son=v[cur][i]\n            if not vis[son]:\n                q.append(son)       \n    dev.append(cnt)\n\nans=pow(n,k,mod)\nfor i in range(1,m):\n    if not vis[i]: dfs(i)\n\nsub=0\nfor i in range(len(dev)):\n    cur=dev[i]\n    sub=(sub+pow(cur,k,mod))%mod\n\nans=(ans-sub+mod)%mod\nprint(ans)\n\n\n\n    \n\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nconst long long int M = 1e9 + 7;\nbool u[N];\nint s;\nvector<vector<int>> a;\nvoid dfs(int x) {\n  if (u[x]) return;\n  u[x] = 1;\n  s++;\n  for (int y : a[x])\n    if (!u[y]) dfs(y);\n}\nlong long int powM(long long int b, int p) {\n  long long int r = 1;\n  for (; p; b = b * b % M, p /= 2)\n    if (p & 1) r = r * b % M;\n  return r;\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  a = std::vector<std::vector<int>>(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    u--, v--;\n    if (!x) a[u].push_back(v), a[v].push_back(u);\n  }\n  long long int ans = powM(n, k);\n  for (int i = 0; i < n; ++i) {\n    if (u[i]) continue;\n    s = 0;\n    dfs(i);\n    ans -= powM(s, k);\n    ans += M;\n    ans %= M;\n  }\n  cout << ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  solve();\n  cout << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5;\nlong long arr[N];\nlong long dp[N];\nvector<long long> adj[N];\nvector<long long> adjt[N];\nlong long vis[N] = {0};\nlong long ans, dest, src;\nvoid fast() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n}\nlong long power(long long first, unsigned long long second, long long p) {\n  long long res = 1;\n  first = first % p;\n  while (second > 0) {\n    if (second & 1) res = (res * first) % p;\n    second = second >> 1;\n    first = (first * first) % p;\n  }\n  return res;\n}\nvoid dfs(long long src, vector<long long> &temp) {\n  vis[src] = 1;\n  temp.push_back(src);\n  for (auto first : adj[src]) {\n    if (!vis[first]) {\n      dfs(first, temp);\n    }\n  }\n}\nvoid solve() {\n  long long n, k;\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; i++) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    if (c == 0) {\n      adj[a].push_back(b);\n      adj[b].push_back(a);\n    }\n  }\n  long long ans = power(n, k, 1000000007);\n  for (long long i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      vector<long long> temp;\n      dfs(i, temp);\n      long long curr = power(temp.size(), k, 1000000007);\n      if (curr > ans) ans += 1000000007;\n      ans = (ans % 1000000007 - curr % 1000000007) % 1000000007;\n    }\n  }\n  cout << ans % 1000000007 << '\\n';\n}\nint32_t main() {\n  fast();\n  long long t = 1;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "// Created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class C\n{\n    private static final long MOD=1000000007;\n    private static int vis[];\n    private static HashMap<Integer,Integer>[] edge;\n    private static ArrayDeque<Integer> DQ;\n\n    private static long DFS(int i)\n    {\n        int count=1,v,x;\n        vis[i]=1;\n\n        for(Map.Entry<Integer,Integer> obj:edge[i].entrySet())\n        {\n            v=obj.getKey();\n            x=obj.getValue();\n\n            if(vis[v]==0)\n            {\n                if(x==1)\n                    DQ.add(v);\n                else\n                    count+=DFS(v);\n            }\n        }\n\n        return count;\n    }\n\n    private static long pow2(long a, long b)\n    {\n        a%=MOD;\n        b%=MOD-1;\n\n        long res=1;\n\n        while(b>0)\n        {\n            if((b&1)==1)\n                res=(res*a)%MOD;\n\n            a=(a*a)%MOD;\n            b>>=1;\n        }\n\n        return res%MOD;\n    }\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N,k,u,v,x;\n        long count=0,tmp,tmp2,total;\n\n        String s[]=br.readLine().trim().split(\" \");\n        N=Integer.parseInt(s[0]);\n        k=Integer.parseInt(s[1]);\n\n        vis=new int[N+1];\n        edge=new HashMap[N+1];\n        DQ=new ArrayDeque<>();\n        for(i=0;i<=N;i++)\n            edge[i]=new HashMap<>();\n\n        total=pow2(N,k);\n\n        for(i=1;i<=N-1;i++)\n        {\n            s=br.readLine().trim().split(\" \");\n            u=Integer.parseInt(s[0]);\n            v=Integer.parseInt(s[1]);\n            x=Integer.parseInt(s[2]);\n\n            edge[u].put(v,x);\n            edge[v].put(u,x);\n        }\n\n        DQ.add(1);\n        while(!DQ.isEmpty())\n        {\n            tmp=DFS(DQ.poll());\n            tmp2=pow2(tmp,k);\n            count=(count+tmp2)%MOD;\n        }\n\n        total-=count;\n        while(total<0)\n            total+=MOD;\n\n        System.out.println(total);\n    }\n\n\n}"
        },
        {
            "language": 4,
            "solution": "// Created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class C\n{\n    private static final long MOD=1000000007;\n    private static int vis[];\n    private static HashMap<Integer,Integer>[] edge;\n    private static ArrayDeque<Integer> DQ;\n\n    private static long DFS(int i)\n    {\n        int count=1,v,x;\n        vis[i]=1;\n\n        Iterator<Map.Entry<Integer,Integer>> itr=edge[i].entrySet().iterator();\n\n        while(itr.hasNext())\n        {\n            Map.Entry<Integer, Integer> entry = itr.next();\n            v=entry.getKey();\n            x=entry.getValue();\n\n            if(vis[v]==0)\n            {\n                if(x==1)\n                    DQ.add(v);\n                else\n                    count+=DFS(v);\n            }\n        }\n\n        return count;\n    }\n\n    private static long pow2(long a, long b)\n    {\n        a%=MOD;\n        b%=MOD-1;\n\n        long res=1;\n\n        while(b>0)\n        {\n            if((b&1)==1)\n                res=(res*a)%MOD;\n\n            a=(a*a)%MOD;\n            b>>=1;\n        }\n\n        return res%MOD;\n    }\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N,k,u,v,x;\n        long count=0,tmp,tmp2,total;\n\n        String s[]=br.readLine().trim().split(\" \");\n        N=Integer.parseInt(s[0]);\n        k=Integer.parseInt(s[1]);\n\n        vis=new int[N+1];\n        edge=new HashMap[N+1];\n        DQ=new ArrayDeque<>();\n        for(i=0;i<=N;i++)\n            edge[i]=new HashMap<>();\n\n        total=pow2(N,k);\n\n        for(i=1;i<=N-1;i++)\n        {\n            s=br.readLine().trim().split(\" \");\n            u=Integer.parseInt(s[0]);\n            v=Integer.parseInt(s[1]);\n            x=Integer.parseInt(s[2]);\n\n            edge[u].put(v,x);\n            edge[v].put(u,x);\n        }\n\n        DQ.add(1);\n        while(!DQ.isEmpty())\n        {\n            tmp=DFS(DQ.poll());\n            tmp2=pow2(tmp,k);\n            count=(count+tmp2)%MOD;\n        }\n\n        total-=count;\n        while(total<0)\n            total+=MOD;\n\n        System.out.println(total);\n    }\n\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class SolutionEdgyTree\n{\n  static ArrayList<Integer> adj[];\n  static long cnt;\n  static int[] vis;\n  static long mod=(long)1e9+7;\n  public static void main(String[] args)\n  {\n    Scanner in=new Scanner(System.in);\n    int n=in.nextInt();\n    int k=in.nextInt();\n    adj=new ArrayList[n];\n    for(int i=0;i<n;i++)\n    {\n      adj[i]=new ArrayList<Integer>();\n    }\n    for(int i = 0; i < n - 1; ++i) \n    {\n      int u = in.nextInt() - 1;\n      int v = in.nextInt() - 1;\n      int col = in.nextInt();\n\n      if(col == 0) \n      {\n        adj[u].add(v);\n        adj[v].add(u);\n      }\n    }\n    long ans = (long)fast_pow(n, k);\n    long rem = 0;\n\n    vis = new int[n];\n    for(int i = 0; i < n; ++i) \n    {\n      if(vis[i] == 0) \n      {\n        cnt = 0;\n        dfs(i);\n        rem += (long)fast_pow(cnt, k);\n      }\n    }\n    rem %= mod;\n    ans = (ans - rem + mod) % mod;\n    System.out.print(ans);\n  }\n  static void dfs(int i)\n  {\n    vis[i]=1;\n    cnt++;\n    for(int j : adj[i])\n    {\n      if(vis[j] == 0)\n        dfs(j);\n    }\n  }\n  static long fast_pow(long a, long b) {\n  if(b == 0)\n   return 1L;\n\n  long val = fast_pow(a, b / 2);\n\n  if(b % 2 == 0)\n   return val * val % mod;\n  else \n   return val * val % mod * a % mod;\n }\n}"
        },
        {
            "language": 4,
            "solution": "//Codeforces 548 (Div. 2), 2019_03_21\nimport java.io.*;\nimport java.util.*;\n\npublic class TaskC {\n\n    public final static int M = 1000000007;\n\n    public static int cnt(int i, ArrayList<ArrayList<Integer>> e, int[] c) {\n        int q = 1;\n        c[i] = 1;\n        for (Integer j : e.get(i)) {\n            if (c[j] == 0) {\n                q += cnt(j, e, c);\n            }\n        }\n        return q;\n    }\n\n    public static int pow(int a, int b) {\n        long q = 1;\n        long p = a;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                q = (q*p)%M;\n            }\n            p = (p*p)%M;\n            b >>= 1;\n        }\n        return (int)q;\n    }\n\n    public static void main (String[] args) throws IOException {\n        FastScanner fs = new FastScanner(System.in);\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n\n        int n = fs.nextInt();\n        int k = fs.nextInt();\n\n        ArrayList<ArrayList<Integer>> e = new ArrayList<ArrayList<Integer>>();\n        for (int i = 0; i < n; i++) {\n            e.add(new ArrayList<Integer>());\n        }\n\n        for (int i = 1; i < n; i++) {\n            int u = fs.nextInt() - 1;\n            int v = fs.nextInt() - 1;\n            int x = fs.nextInt();\n            if (x == 0) {\n                e.get(u).add(v);\n                e.get(v).add(u);\n            }\n        }\n\n        int[] c = new int[n];\n        ArrayList<Integer> q = new ArrayList<Integer>();\n\n        for (int i = 0; i < n; i++) {\n            if (c[i] == 0) {\n                q.add(cnt(i, e, c));\n            }\n        }\n\n        long s = 0;\n        for (int i = 0; i < q.size(); i++) {\n            s = (s + pow(q.get(i), k))%M;\n        }\n\n        long ans = (pow(n,k)%M+M-s)%M;\n        pw.println(ans);\n\n        pw.close();\n    }\n\n    static class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n        FastScanner(InputStream i) {\n            reader = new BufferedReader(new InputStreamReader(i));\n            tokenizer = new StringTokenizer(\"\");\n        }\n        String next() throws IOException {\n            while(!tokenizer.hasMoreTokens()) tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        new Main().run(in, out);\n        out.close();\n    }\n\n    public static int mod = 1_000_000_007;\n\n    class Edge {\n        int v;\n        int c;\n        Edge(int v, int c) {\n            this.v = v;\n            this.c = c;\n        }\n    }\n    List<Edge>[] adj;\n    void run(FastScanner in, PrintWriter out) {\n        N = in.nextInt();\n        K = in.nextInt();\n\n        adj = new List[N+1];\n        for (int i = 0; i < adj.length; i++) adj[i] = new ArrayList<>();\n        for (int i = 0; i < N-1; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            int c = in.nextInt();\n            adj[u].add(new Edge(v, c == 0 ? RED : BLK));\n            adj[v].add(new Edge(u, c == 0 ? RED : BLK));\n        }\n\n        dfs(1, -1, BLK);\n\n        long tot = modpow(N, K);\n        long ans = (((tot - cntbad)%mod)+mod)%mod;\n        out.println(ans);\n    }\n\n    long cntbad = 0;\n    int N, K;\n\n    int dfs(int u, int p, int pc) {\n\n        int sz = 1;\n        for (Edge e : adj[u]) {\n            if (e.v == p) continue;\n            sz += dfs(e.v, u, e.c);\n        }\n\n        if (pc == BLK) {\n            cntbad = (cntbad + modpow(sz, K))%mod;\n            sz = 0;\n        }\n\n        return sz;\n    }\n\n\n\n\n    int RED = 0;\n    int BLK = 1;\n\n    long modpow(long x, int pow) {\n        long ret = 1;\n        while (pow > 0) {\n            if ((pow&1) == 1) ret = (ret*x)%mod;\n            x = (x*x)%mod;\n            pow >>=1;\n        }\n        return ret;\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n            st = null;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import floor\nn, k = map(int, input().split())\n\nchilds = [[] for i in range(n+1)]\n\nfor i in range(n - 1):\n    i, j, color = map(int, input().split())\n    childs[i].append((j, color))\n    childs[j].append((i, color))\n\n\n\n# (node, parent, color)\n# \u627e\u4e0d\u5305\u542b\u7684\nstack = [(1, 0, 1)]\nrecord = [0]*(n+1)\nvis = [False]*(n+1)\nans = 0\nMOD = floor(1e9 + 7)\nwhile len(stack):\n    node, parent, fcolor = stack[-1]\n    if not vis[node]:\n        vis[node] = True\n        for child, color in childs[node]:\n            if child != parent:\n                stack.append((child, node, color))\n    else:\n        stack.pop()\n        record[node] = 1\n        for child, color in childs[node]:\n            if child != parent and color == 0:\n                record[node] += record[child]\n        if fcolor:\n            ans = (ans + pow(record[node],k,MOD)) % MOD\nprint((pow(n,k,MOD) -  ans + MOD) % MOD)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\nimport javax.swing.plaf.synth.SynthScrollBarUI;\n\npublic class Main {\n\tstatic int[] par;\n\tstatic long[] len;\n\tstatic long mod = 1000000007;\n\n\tpublic static void main(String[] args) {\n\t\tReader in = new Reader();\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tpar = new int[n+1];\n\t\tlen = new long[n+1];\n\t\tfor(int i = 0; i<=n; i++) {\n\t\t\tpar[i] = i;\n\t\t\tlen[i] = 1;\n\t\t}\n\t\tlong ans = power(n, k, mod)%mod;\n\t\tfor(int i = 0; i<n-1; i++) {\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\tint c = in.nextInt();\n\t\t\tif(c==0) unite(a, b);\n\t\t}\n\t\tlong rem = 0;\n\t\tfor(int i = 1; i<=n; i++) if(par[i]==i) rem=(rem+power(len[i], k, mod))%mod;\n\t\tans = (ans - rem + mod) % mod;\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static int find(int x) {\n\t\tif (par[x] == x)\n\t\t\treturn x;\n\t\treturn find(par[x]);\n\t}\n\n\tpublic static void unite(int a, int b) {\n\t\tint p1 = find(a);\n\t\tint p2 = find(b);\n\t\tif(p1==p2) return;\n\t\tpar[p2] = p1;\n\t\tlen[p1] += len[p2];\n\t}\n\n\tstatic long power(long x, long y, long p) {\n\t\tlong res = 1;\n\t\tx = x % p;\n\t\twhile (y > 0) {\n\t\t\tif ((y & 1) == 1)\n\t\t\t\tres = (res * x) % p;\n\t\t\ty = y >> 1;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Reader {\n\t\tstatic BufferedReader br;\n\t\tstatic StringTokenizer st;\n\n\t\tpublic Reader() {\n\t\t\tthis.br = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic int[] na(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nl(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic String[] nS(int n) {\n\t\t\tString[] a = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = next();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (st == null || !st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\treadLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\treturn Integer.parseInt(st.nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tif (st == null || !st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\treadLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\treturn Double.parseDouble(st.nextToken());\n\t\t}\n\n\t\tpublic Long nextLong() {\n\t\t\tif (st == null || !st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\treadLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\treturn Long.parseLong(st.nextToken());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (st == null || !st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\treadLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic static void readLine() {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t}\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 1e5 + 10;\nconst long long mod = 1e9 + 7;\nlong long n, k, num = 1, cnt;\nvector<long long> v[maxn];\nbool vis[maxn];\nlong long color[maxn];\nmap<long long, long long> mp;\nvoid bfs(long long x) {\n  queue<long long> q;\n  vis[x] = true;\n  ++cnt;\n  q.push(x);\n  while (!q.empty()) {\n    long long kx = q.front();\n    q.pop();\n    for (long long i = 0; i < v[kx].size(); ++i) {\n      long long k = v[kx][i];\n      if (!vis[k]) {\n        vis[k] = true;\n        q.push(k);\n        ++cnt;\n      }\n    }\n  }\n}\nlong long ksm(long long a, long long x) {\n  if (x == 0) return 1;\n  if (x == 1) return a % mod;\n  long long tmp = ksm(a, x / 2) % mod;\n  if (x % 2 == 0)\n    return (tmp * tmp) % mod;\n  else\n    return (((tmp * tmp) % mod) * a) % mod;\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> k;\n  long long ans = ksm(n, k);\n  for (long long i = 1; i < n; ++i) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    if (c == 0) {\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n  }\n  for (long long i = 1; i <= n; ++i) {\n    if (!vis[i]) {\n      cnt = 0;\n      bfs(i);\n      long long BDFCL = ksm(cnt, k);\n      ans -= BDFCL;\n      if (ans < 0) ans += mod;\n    }\n  }\n  cout << ans % mod << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport functools\nimport os.path\n\nBase = 1000000007\n\nclass Dsu:\n    par = []\n    cnt = []\n    def __init__(self,size):\n        self.par = [x for x in range(size + 2)]\n        self.cnt = [1] * (size + 2)\n        \n    def findp(self,u):\n        if self.par[u] == u:\n            return u \n        else :\n            self.par[u] = self.findp(self.par[u])\n            return self.par[u]\n        \n    def join(self,u,v):\n        u,v = self.findp(u),self.findp(v)\n        if u == v :\n            return\n        if self.cnt[u] < self.cnt[v] :\n            u,v = v,u\n        self.cnt[u] += self.cnt[v]\n        self.par[v] = u\n        \n    def getSize(self,u): return self.cnt[self.findp(u)]\n\ndef mulmod(u,v): return ((u % Base) * (v % Base)) % Base\n\ndef submod(u,v): return ((u % Base) - (v % Base) + Base) % Base\n\ndef fastExp(x,h,ret = 1):\n    while h > 0: ret,x,h = mulmod(ret,x) if h & 1 else ret,mulmod(x,x),h // 2\n    return ret\n\ndef solve():\n    # code goes here!!         \n    n,k = map(int,input().split())\n    dsu = Dsu(n)\n    for i in range(1,n):\n        u,v,x = map(int,input().split())\n        if x == 0: dsu.join(u,v)\n    ans = functools.reduce(lambda x,y : submod(x,y),map(lambda u : fastExp(dsu.getSize(u),k),filter(lambda u : dsu.findp(u) == u,range(1,n + 1))),fastExp(n,k))\n    print(ans)\n\ndef main():\n    # comment when submit.\n    if os.path.exists('test.inp') :\n        sys.stdin = open(\"test.inp\",\"r\")\n    solve()\n\nif __name__ == '__main__':\n    main()\n\n\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict as dd\nmod= pow(10,9)+7\n\"\"\"\ndef dfs_visit(V,adj,s,c):\n    for v in adj[s]:\n        if v not in parent:\n            parent[v]=s\n            c=c+1\n            dfs_visit(V,adj,v,c)\n    return(c)\n            \ndef dfs(V,adj):\n    ans=[]\n    for s in V:\n        if s not in parent:\n            parent[s]=None\n            c=dfs_visit(V,adj,s,1)\n            ans.append(c)\n    return(ans)\n\"\"\"\ndef bfs(s,adj):\n    global parent\n    t=1\n    #print(\"df\",s)\n    frontier=[s]\n    while frontier:\n        nex=[]\n        for u in frontier:\n            for v in adj[u]:\n                if v not in parent:\n                    #print(v)\n                    t+=1\n                    parent.add(v)\n                    nex.append(v)\n        frontier=nex\n    return(t)\n\nadj=dd(list)\nn,k=[int(i) for i in input().split(' ')]\nfor ii in range(n-1):\n    x,y,h=[int(i) for i in input().split(' ')]\n    if h==0:\n        adj[x].append(y)\n        adj[y].append(x)\n\nV=[i+1 for i in range(n)]  \nparent=set()\n\nfk=[]\nfor i in V:\n    if i not in parent:\n        parent.add(i)\n        tr=bfs(i,adj)\n        #print(i,tr)\n        fk.append(tr)\n#print(fk)\nans=pow(n,k,mod)\nfor i in fk:\n    ans=(ans-pow(i,k,mod))%mod\nprint(ans%mod)\n"
        },
        {
            "language": 3,
            "solution": "\"\"\"\nif num edges red <= k - 1:\n    return (n choose k)\n\n# num edges red >= k\n\"\"\"\n\ndef n_perm_k(n, k):\n    return n ** k\n\ndef ways(xs, k):\n    total = n_perm_k(sum(xs), k)\n\n    for x in xs:\n        total -= n_perm_k(x, k)\n    \n    return total\n\ndef dfs(i, graph, visited):\n    stack = [i]\n    count = 0\n    while stack:\n        current = stack.pop()\n        count += 1\n        visited.add(current)\n        for neighbor, black in graph[current].items():\n            if not black and neighbor not in visited:\n                stack.append(neighbor)\n    return count                \n\ndef get_forest_sizes(n, graph):\n    visited = set()\n    components = []\n    for i in range(1, n + 1):\n        if i not in visited:\n            ans = dfs(i, graph, visited)\n            components.append(ans)\n    return components\n\ndef solve(n, k, graph, black_count):\n    if black_count == 0:\n        # no black\n        return 0\n    else:\n        return ways(get_forest_sizes(n, graph), k)\n\nn, k = map(int, input().split())\ngraph = { x: {} for x in range(1, n + 1) }\nblack_count = 0\nfor _ in range(1, n):\n    a, b, black = map(int, input().split())\n    black_count += black\n    graph[a][b] = (black == 1)\n    graph[b][a] = (black == 1)\n\nprint(solve(n, k, graph, black_count) % (10 ** 9 + 7))\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class ProblemC {\n\n    static int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int nodes = sc.nextInt();\n        int len = sc.nextInt();\n        DisjointSet ds = new DisjointSet(nodes);\n        for (int i = 0; i < nodes-1; i++) {\n            int ori = sc.nextInt();\n            int des = sc.nextInt();\n            int is = sc.nextInt();\n            if (is == 0){\n                ds.join(ori,des);\n            }\n        }\n        long sol = pow(nodes,len,MOD);\n        for (int j = 1; j <= nodes ; j++) {\n            int compSize = ds.si[ds.father(j)];\n            sol = (sol - pow(compSize,len-1,MOD) + MOD)%MOD;\n        }\n\n        pw.println(sol);\n\n\n        pw.flush();\n    }\n\n    static long pow(long base, long exp, long mod) {\n        long res = 1;\n        base = base % mod;\n        while (exp > 0) {\n            if((exp & 1)==1)\n                res = (res * base) % mod;\n            exp = exp/2;\n            base = (base * base) % mod;\n        }\n        return res;\n    }\n\n    static class DisjointSet{\n        public int[] fa;\n        public int[] si;\n        public int components;\n\n        public DisjointSet(int size) {\n            this.fa = new int[size+4];\n            this.si = new int[size+4];\n            this.components = size;\n            for (int i = 0; i < size + 4; i++) {\n                this.fa[i] = i;\n                this.si[i] = 1;\n            }\n        }\n\n        public int father (int node){\n            while (fa[node]!=node){\n                node = fa[node];\n            }\n            return node;\n        }\n\n        public boolean join(int n1, int n2){\n            int fa1 = father(n1);\n            int fa2 = father(n2);\n            if (fa1==fa2)return false;\n            components--;\n            if (si[fa1]>si[fa2]){\n                fa[fa2]=fa1;\n                si[fa1]+=si[fa2];\n            } else {\n                fa[fa1]=fa2;\n                si[fa2]+=si[fa1];\n            }\n            return true;\n        }\n\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import math,sys\n#from itertools import permutations, combinations;import heapq,random;\nfrom collections import defaultdict,deque\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\n#sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\ndef I():return (int(sys.stdin.readline()))\ndef In():return(map(int,sys.stdin.readline().split()))\ndef Sn():return sys.stdin.readline().strip()\n#sys.setrecursionlimit(1500)\ndef dict(a):\n    d={} \n    for x in a:\n        if d.get(x,-1)!=-1:\n            d[x]+=1\n        else:\n            d[x]=1\n    return d\ndef find_gt(a, x):\n    'Find leftmost value greater than x'\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:            \n        return -1\ndef dfs(d,visit,s):\n    q=[s]\n    cnt=0\n    while q:\n        t=q.pop(0)\n        visit[t]=True\n        cnt+=1\n        for x in d[t]:\n            if visit[x]==False:\n                q.insert(0,x)\n    return cnt\ndef mod(a, b, c):\n    res = a * b\n    return res % c\n\ndef power(a, b, m):\n    x, y = 1,a\n    while (b > 0):\n        if (b & 1):x = mod(x, y, m)\n        y = mod(y, y, m)\n        b >>= 1\n    return x\ndef expo(a, b):\n    x, y = 1, a\n    while (b > 0):\n        if (b & 1):\n            x = x * y\n        y = y * y\n        b >>= 1\n    return x\ndef main():\n    try:\n        n,k=In()\n        d=defaultdict(list)\n        for i in range(n-1):\n            a,b,c=In()\n            if c==0:\n                d[a].append(b)\n                d[b].append(a)\n        ans=power(n,k,P)\n        visit=[False for x in range(n+1)]\n        for i in range(1,n+1):\n            if not visit[i]:\n                ans-=power(dfs(d,visit,i),k,P)\n        print(ans%P)\n    except:\n        pass\n\nM = 998244353\nP = 1000000007\n \nif __name__ == '__main__':\n    # for _ in range(I()):main()\n    for _ in range(1):main()\n#End#\n\n#        ******************* All The Best *******************   #"
        },
        {
            "language": 3,
            "solution": "import math\nimport sys\nimport collections\n\n\ndef In():\n    return map(int, sys.stdin.readline().split())\n\n\ninput = sys.stdin.readline\n\n\ndef edgytrees():\n    def fastmodpow(n, power, mod):\n        res = 1\n        x = n\n        while power:\n            if power % 2:\n                res = (res * x) % mod\n            x = (x * x) % mod\n            power //= 2\n        return res\n    mod = int(1e9 + 7)\n    n,k = In()\n    l = [[] for _ in range(n)]\n    for _ in range(n-1):\n        f,s,c = In()\n        if not c:\n            f -= 1\n            s -= 1\n            l[f].append(s)\n            l[s].append(f)\n    ans = fastmodpow(n,k,mod)\n    visited = [False]*n\n    for i in range(n):\n        if not visited[i]:\n            visited[i] = True\n            todo = [i]\n            c = 0\n            while todo:\n                task = todo.pop()\n                c += 1\n                for x in l[task]:\n                    if not visited[x]:\n                        todo.append(x)\n                        visited[x] = True\n            ans -= fastmodpow(c,k,mod)\n            ans = (ans+mod)%mod\n    return ans\nprint(edgytrees())\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "from collections import deque\n\nmod=10**9 + 7\nn,k=map(int,input().split())\n\na=[[] for i in range(n+1)]\nfor i in range(n-1):\n    x,y,z=map(int,input().split())\n    if z==0:\n        a[x].append(y)\n        a[y].append(x)\nvis=[0]*(n+1)\nq=deque([])\nans=0\nfor i in range(1,n+1):\n    c=0\n    if vis[i]==0:\n        q.append(i)\n        vis[i]=1\n    while q:\n        p=q.popleft()\n        c+=1\n        for j in a[p]:\n            if vis[j]==0:\n                q.append(j)\n                vis[j]=1\n    ans+=pow(c,k,mod)\n    ans%=mod\nprint((pow(n,k,mod) - ans)%mod)    \n            \n        \n        \n        \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class A, class B>\ninline bool mina(A &first, B second) {\n  return (first > second) ? (first = second, 1) : 0;\n}\ntemplate <class A, class B>\ninline bool maxa(A &first, B second) {\n  return (first < second) ? (first = second, 1) : 0;\n}\nconst int MAXN = 100005;\nconst int MOD = 1000000007;\nint N, M;\nvector<int> adj[MAXN];\nbool visited[MAXN];\nint cnt = 0;\nvoid dfs(int at) {\n  cnt++;\n  visited[at] = true;\n  for (auto first : adj[at]) {\n    if (!visited[first]) {\n      dfs(first);\n    }\n  }\n}\nint my_power(long long b, long long e) {\n  long long ret = 1;\n  while (e) {\n    if (e & 1) ret *= b;\n    ret %= MOD;\n    b *= b;\n    b %= MOD;\n    e >>= 1;\n  }\n  return ret;\n}\nint main() {\n  int u, v, c;\n  cin >> N >> M;\n  for (int i = 0; (i) < (N - 1); ++(i)) {\n    scanf(\"%d %d %d\", &u, &v, &c);\n    u--, v--;\n    if (c == 0) {\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n  }\n  int ans = 0;\n  for (int i = 0; (i) < (N); ++(i)) {\n    if (!visited[i]) {\n      cnt = 0;\n      dfs(i);\n      ans += my_power(cnt, M);\n      ans %= MOD;\n    }\n  }\n  ans = my_power(N, M) - ans + MOD;\n  ans %= MOD;\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Graphs {\n\t\n\tpublic static int mod=1000000007;\n\t\n\tpublic static long poweraftermod(int a, int b, int mod)\n\t{\n\t\t//this will return (a^b)%mod\n\t\tlong prod=1;\n\t\tfor (int i=0;i<b;i++)\n\t\t{\n\t\t\tprod=((prod%mod)*(a%mod))%mod;\n\t\t}\n\t\treturn prod%mod;\n\t}\n\t\n\tpublic static int dfs(HashMap<Integer,HashSet> adj, int currvertex, boolean visited[])\n\t{\n\t\tif (visited[currvertex]==true)\n\t\t\treturn 0;\n\t\tvisited[currvertex]=true;\n\t\tHashSet<Integer> set=adj.get(currvertex);\n\t\tint ans=1;\n\t\tfor (int i: set)\n\t\t{\n\t\t\tif (visited[i]==true)\n\t\t\t\tcontinue;\n\t\t\tans+=dfs(adj, i, visited);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static void main(String[] args) throws Exception{\n\t\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tString inp[]=br.readLine().split(\" \");\n\t\tint n=Integer.parseInt(inp[0]);\n\t\tint k=Integer.parseInt(inp[1]);\n\t\tHashMap<Integer, HashSet> map=new HashMap<>();\n\t\tfor (int i=0;i<n;i++)\n\t\t{\n\t\t\tHashSet<Integer> arr=new HashSet<>();\n\t\t\tmap.put(i, arr);\n\t\t}\n\t\tHashSet<Integer> s=new HashSet<>();\n\t\tfor (int i=0;i<n-1;i++)\n\t\t{\n\t\t\tinp=br.readLine().split(\" \");\n\t\t\tint u=Integer.parseInt(inp[0])-1;\n\t\t\tint v=Integer.parseInt(inp[1])-1;\n\t\t\tint edge=Integer.parseInt(inp[2]);\n\t\t\tif (edge==0)\n\t\t\t{\n\t\t\t\tmap.get(u).add(v);\n\t\t\t\tmap.get(v).add(u);\n\t\t\t}\n\t\t\ts.add(u);\n\t\t\ts.add(v);\n\t\t}\n\t\t\n\t\tlong ans=0;\n\t\tboolean visited[]=new boolean[n];\n\t\t//count number of all red paths\n\t\tlong allpaths=poweraftermod(n,k,mod);\n\t\tfor (int i : s)\n\t\t{\n\t\t\tif (visited[i]==true)\n\t\t\t\tcontinue;\n\t\t\tint ans1= dfs(map, i, visited);\n\t\t\tvisited[i]=true;\n\t\t\tallpaths-=poweraftermod(ans1%mod, k, mod)%mod;\n\t\t\tallpaths+=mod;\n\t\t\tallpaths%=mod;\n\t\t}\n\t\tSystem.out.println((allpaths)%mod);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static long mod = (long)1e9 + 7;\n    static ArrayList<Integer> adj[];\n    static int vis[];\n    static long cnt = 0;\n    \n    private static void dfs(int i) {\n        cnt++;\n        vis[i] = 1;\n        for(int j : adj[i]) {\n            if(vis[j] == 0) {\n                dfs(j);\n            }\n        }\n    }\n    static long fast_pow(long a, long b) {\n\t\tif(b == 0)\n\t\t\treturn 1L;\n\n\t\tlong val = fast_pow(a, b / 2);\n\n\t\tif(b % 2 == 0)\n\t\t\treturn val * val % mod;\n\t\telse \n\t\t\treturn val * val % mod * a % mod;\n\t}\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        \n        adj = new ArrayList[n];\n        for(int i=0; i<n; i++) {\n            adj[i] = new ArrayList<>();\n        }\n        for(int i=0; i<n-1; i++) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            int col = sc.nextInt();\n            \n            if(col == 0) {\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n        }\n        \n        long ans = fast_pow(n, k);\n        long rem = 0;\n        \n        vis = new int[n];\n        for(int i=0; i<n; i++) {\n            if(vis[i] == 0) {\n                cnt = 0;\n                dfs(i);\n                rem += fast_pow(cnt, k);\n            }\n        }\n        rem %= mod;\n        ans = (ans - rem + mod) % mod;\n        System.out.println(ans);\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n# Testing filo code\n\ndef readLine():\n    return [int(i) for i in input().split()]\n\ndef deg(x, y):\n    if y == 1:\n        return x\n    res = deg(x, y // 2)\n    res *= res\n    res %= md\n    if y % 2 == 1:\n        res *= x\n        res %= md\n    return res\n\ndef dfs(v):\n    Q = [v]\n    used[v] = True\n    c = 0\n    while Q:\n        v = Q.pop()\n        c += 1\n        for to in g[v]:\n            if not used[to]:\n                used[to] = True\n                Q.append(to)\n    return c\n\nn, m = readLine()\ng = [[] for _ in range(n + 1)]\nmd = 1000000007\n\nfor i in range(n - 1):\n    x, y, t = readLine()\n    if t == 0:\n        g[x].append(y)\n        g[y].append(x)\n\nans = deg(n, m)\n\nused = [False]*(n+1)\nfor i in range(1, n + 1):\n    if used[i] == False:\n        b = dfs(i)\n        ans = ans - deg(b, m)\n        if ans < 0:\n            ans += md\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n \npublic class Solution {\n\tpublic static void main (String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n\t\tString[] temp=br.readLine().trim().split(\" \");\n\t\tint V=Integer.parseInt(temp[0]);\n\t\tint k=Integer.parseInt(temp[1]);\n\t\t\n\t\tDSU graph=new DSU(V);\n\t\tfor(int i=1;i<V;i++)\n\t\t{\n\t\t    temp=br.readLine().trim().split(\" \");\n\t\t    int u=Integer.parseInt(temp[0]);\n\t\t    int v=Integer.parseInt(temp[1]);\n\t\t    int color=Integer.parseInt(temp[2]);\n\t\t    if(color==0){\n\t\t        graph.makeUnion(u,v);\n\t\t    }\n\t\t}\n\t\tlong notGoodSequences=0;\n\t\tint mod=(int)(Math.pow(10,9)+7);\n\t\tboolean[] marked=new boolean[V+1];\n\t\tfor(int i=1;i<=V;i++){\n\t\t    int parent=graph.getParent(i);\n\t\t    if(marked[parent]==false){\n\t\t        marked[parent]=true;\n\t\t        int size=graph.componentSize(i);\n\t\t        notGoodSequences=(notGoodSequences+aPowerBModC(size,k,mod))%mod;\n\t\t    }\n\t\t}\n// \t\tSystem.out.println(\"total \"+aPowerBModC(V,k,mod));\n// \t\tSystem.out.println(\"not good \"+notGoodSequences);\n\t\tlong ans=(aPowerBModC(V,k,mod)-notGoodSequences+mod)%mod;\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static long aPowerBModC(int a,int b,int c){\n\t    if(b==0){\n\t        return 1;\n\t    }\n\t    long smallAns=aPowerBModC(a,b/2,c);\n\t    long ans=(smallAns*smallAns)%c;\n\t    if(b%2!=0){\n\t        ans=(ans*(a%c))%c;\n\t    }\n\t    return ans;\n\t}\n}\nclass DSU{\n    private int[] parent;\n    private int[] size;\n    \n    public DSU(int V)\n    {\n        parent=new int[V+1];\n        size=new int[V+1];\n        for(int i=1;i<=V;i++)\n        {\n            parent[i]=i;\n            size[i]=1;\n        }\n    }\n    public int getParent(int vertex)\n    {\n        int temp=vertex;\n        while(parent[vertex]!=vertex){\n            vertex=parent[vertex];\n        }\n        parent[temp]=vertex;\n        return vertex;\n    }\n    public void makeUnion(int u,int v){\n        int parent1=getParent(u);\n        int parent2=getParent(v);\n        \n        if(parent2==parent1)\n        {\n            return;\n        }\n        int size1=size[parent1];\n        int size2=size[parent2];\n        \n        if(size2<size1){\n            parent[parent2]=parent1;\n            size[parent1]+=size[parent2];\n        }\n        else{\n            parent[parent1]=parent2;\n            size[parent2]+=size[parent1];\n        }\n    }\n    public int numComponents(){\n        int ans=0;\n        int V=this.parent.length-1;\n        for(int i=1;i<=V;i++){\n            if(this.parent[i]==i){\n                ans++;\n            }\n        }\n        return ans;\n    }\n    public int componentSize(int vertex){\n        int parent=getParent(vertex);\n        return size[parent];\n    }\n}"
        },
        {
            "language": 3,
            "solution": "n,k=map(int,input().split())\nmaxi=10**9+7\ndef union(a,x,y,size):\n    xs=find(x,a)\n    ys=find(y,a)\n    if xs==ys:\n        return\n    elif size[xs]<=size[ys]:\n        a[xs]=ys\n        size[ys]+=size[xs]\n    else:   \n         a[ys]=xs\n         size[xs]+=size[ys]\ndef find(i,a):\n    if i==a[i]:\n        return i\n    else:\n        a[i]=find(a[i],a)\n        return a[i]\na=[i for i in range(n+1)]\nsize=[1 for i in range(n+1)]\nfor i in range(n-1):\n    p,q,col=map(int,input().split())\n    if col==0:\n        union(a,p,q,size)\n        #print(a)    \n\ns=set()\nfor i in range(n+1):\n    s.add(find(a[i],a))\ns=s-{0}\ns=list(s)\nsumi=pow(n,k,maxi)\n#print(s)\nfor i in range(len(s)):\n    sumi=(sumi-pow(size[s[i]],k,maxi))%maxi\nprint(sumi)   "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize \"03\"\nusing namespace std;\nconst char E = '\\n';\nconst int N = 100005;\nvector<long long> g[N];\nlong long ans, kilk;\nbool used[N];\nvoid dfs(int v, int p) {\n  kilk++;\n  used[v] = 1;\n  for (int i = 0; i < g[v].size(); i++)\n    if (used[g[v][i]] == 0) dfs(g[v][i], v);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k, x, y, z;\n  cin >> n >> k;\n  ans = n;\n  for (int i = 1; i <= n - 1; i++) {\n    cin >> x >> y >> z;\n    if (z == 0) {\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n  }\n  long long mod = 1e9 + 7;\n  for (int i = 2; i <= k; i++) ans *= n, ans %= mod;\n  for (int i = 1; i <= n; i++) {\n    kilk = 0;\n    if (used[i] == 0) {\n      dfs(i, -1);\n      long long cnt = kilk;\n      for (int j = 2; j <= k; j++) cnt *= kilk, cnt %= mod;\n      ans -= cnt;\n      ans %= mod;\n      ans += mod;\n      ans %= mod;\n      ans += mod;\n      ans %= mod;\n    }\n  }\n  cout << ans << E;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "[n, k] = list(map(lambda x: int(x), input().split(\" \")))\n\nmodulus = 10**9+7\ncomponents = [None]*(n+1)\n\ndef power(n, k):\n    if k == 0:\n        return 1\n    if n == 1:\n        return 1\n    if k%2 == 1:\n        return power(n,k//2) * power(n, k//2) * n\n    else:\n        return power(n,k//2) * power(n, k//2)\n\ndef union_set_compressed_path(elementA, elementB):\n    global components\n    setA = components[elementA]\n    setB = components[elementB]\n    \n    if setB and not setA:\n        # Le doy la vuelta para simplificar\n        # As\u00ed siempre es el setA el que existe y el setB el nuevo\n        return union_set_compressed_path(elementB, elementA)\n\n    if setA and not setB:\n        components[elementB] = setA\n        return setA\n\n    if setA and setA == setB:\n        # Ya pertenecen al mismo conjunto\n        return setA\n\n    if setA and setB:\n        # Si existen los dos sets, comprimo uno de ellos\n        components[elementB] = setA\n        union_set_compressed_path(setA, setB)\n        return setA\n\n    # No existen ninguno de los dos sets:\n    components[elementA] = elementA\n    components[elementB] = elementA\n\n    return elementA\n\ndef union_get_compressed_path(element):\n    theSet = components[element]\n    if theSet == element:\n        return theSet\n    \n    components[element] = union_get_compressed_path(theSet)\n    return components[element]\n\nfor i in range(n-1):\n    [u, v, x] = list(map(lambda x: int(x), input().split(\" \")))\n    v = v\n    u = u\n    if x == 0:\n        union_set_compressed_path(u,v)\n    else:\n        components[u] = components[u] or u\n        components[v] = components[v] or v\n\ncomponentSize = dict()\n\nfor x in range(n):\n    key = union_get_compressed_path(x+1)\n    value = (componentSize.get(key) or 0) + 1\n    componentSize[key] = value\n\ncombinations = power(n,k)\n\nfor key, value in componentSize.items():\n    combinations = (combinations - power(value,k))%modulus\n\nprint(combinations)"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class G {\n\tstatic int MOD = 1000000007;\n\tpublic static void main(String[] args) throws Exception {\n\t\tInputReader scan = new InputReader(new BufferedInputStream(System.in));\n\t\tint n = scan.nextInt(), k = scan.nextInt();\n\t\tNode[] arr = new Node[n];\n\t\tfor(int i=0;i<n;i++)arr[i]=new Node();\n\t\tfor (int i=0;i<n-1;i++) {\n\t\t\tint s = scan.nextInt() - 1, v = scan.nextInt() - 1, color = scan.nextInt();\n\t\t\tif (color == 0) {\n\t\t\t\tarr[s].adjacentNodes.add(arr[v]);\n\t\t\t\tarr[v].adjacentNodes.add(arr[s]);\n\t\t\t}\n\t\t}\n\t\tList<Integer> nodeGroups = dfs(arr);\n\t\tlong ans=0L;\n\t\tfor (Integer key: nodeGroups) {\n\t\t\tans = Math.floorMod(ans+pow(key, k), MOD);\n\t\t}\n\t\tans = Math.floorMod((pow(n, k) - ans),MOD);\n\t\tif (ans<0)ans+=MOD;\n\t\tSystem.out.println(ans);\n\t\tscan.close();\n\t}\n\n\tprivate static List<Integer> dfs(Node[] arr) {\n\n\t\tList<Integer> nodes = new LinkedList<>();\n\t\tfor (int i=0;i<arr.length;i++) {\n\t\t\tif (!arr[i].visited)\n\t\t\t\tnodes.add(dfs(arr[i]));\n\n\t\t}\n\t\t//System.out.println(nodes);\n\t\treturn nodes;\n\t}\n\n\tprivate static Integer dfs(Node node) {\n\t\t//List<Node> nodes = new LinkedList<>();\n\t\t//nodes.add(node);\n\t\tint ans = 1;\n\t\tnode.visited=true;\n\t\tfor (Node n: node.adjacentNodes) {\n\t\t\tif (!n.visited)\n\t\t\t\tans += dfs(n);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic class Node {\n\t\tint key;boolean visited=false;\n\t\tList<Node> adjacentNodes = new LinkedList<G.Node>();\n\t}\n\n\tprivate static long pow(int base, int exponent) {\n\t\tif (base==1)return 1l;\n\t\tif (exponent==1)return (long)base;\n\t\tif (exponent==0)return 1l;\n\t\tif (exponent%2==0) {\n\t\t\tlong ans = pow(base,exponent/2);\n\t\t\treturn Math.floorMod((ans*ans),MOD);\n\t\t}\n\t\treturn Math.floorMod(((long)base*(long)pow(base,exponent-1)),MOD);\n/*\t\tlong result = 1;\n\t\tbase = base % MOD;\n\t\twhile (exponent > 0) {\n\t\t\tif (exponent % 2 == 1) {\n\t\t\t\tresult = result * base;\n\t\t\t\tresult %= MOD;\n\t\t\t}\n\t\t\texponent = exponent / 2;\n\t\t\tbase = (base * base) % MOD;\n\t\t}\n\t\treturn result;*/\n\t}\n\n\tstatic class UF {\n\n\t\tprivate int[] parent;  // parent[i] = parent of i\n\t\tprivate byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)\n\t\tprivate int count;     // number of components\n\n\t\tpublic UF(int n) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tcount = n;\n\t\t\tparent = new int[n];\n\t\t\trank = new byte[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t\trank[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tpublic Map<Integer, Integer> getCounts() {\n\t\t\tMap<Integer, Integer> map = new HashMap<>(count);\n\t\t\tfor (int i:parent) \n\t\t\t\tmap.put(i, 1+map.getOrDefault(i, 0));\n\t\t\treturn map;\n\t\t}\n\n\t\tpublic void print() {\n\t\t\tSystem.out.println(Arrays.toString(parent));\n\t\t\tSystem.out.println(Arrays.toString(rank));\n\t\t}\n\n\t\tpublic int find(int p) {\n\t\t\twhile (p != parent[p]) {\n\t\t\t\tparent[p] = parent[parent[p]];    // path compression by halving\n\t\t\t\tp = parent[p];\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\n\t\tpublic int count() {\n\t\t\treturn count;\n\t\t}\n\n\t\tpublic boolean connected(int p, int q) {\n\t\t\treturn find(p) == find(q);\n\t\t}\n\n\t\tpublic void union(int p, int q) {\n\t\t\tint rootP = find(p);\n\t\t\tint rootQ = find(q);\n\t\t\tif (rootP == rootQ) return;\n\t\t\t// make root of smaller rank point to root of larger rank\n\t\t\tif      (rank[rootP] < rank[rootQ]) parent[rootP] = rootQ;\n\t\t\telse if (rank[rootP] > rank[rootQ]) parent[rootQ] = rootP;\n\t\t\telse {\n\t\t\t\tparent[rootQ] = rootP;\n\n\t\t\t\trank[rootP]++;\n\t\t\t}\n\t\t\tcount--;\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tthis.stream.close();\n\t\t}\n\n\t\tpublic static boolean isWhitespace(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null) {\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t}\n\t\t\treturn isWhitespace(c);\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\n\t\tpublic String next() {\n\t\t\treturn nextString();\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9') {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic Long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic Double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic char nextCharacter() {\n\t\t\treturn nextString().charAt(0);\n\t\t}\n\n\t\tpublic int[] nextIntArray(int N) {\n\t\t\tint A[] = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tA[i] = nextInt();\n\t\t\t}\n\t\t\treturn A;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int N) {\n\t\t\tlong A[] = new long[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tA[i] = nextLong();\n\t\t\t}\n\t\t\treturn A;\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int N) {\n\t\t\tdouble A[] = new double[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tA[i] = nextDouble();\n\t\t\t}\n\t\t\treturn A;\n\t\t}\n\t}\n\n\tint min(int... a) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int v : a) {\n\t\t\tmin = Math.min(min, v);\n\t\t}\n\t\treturn min;\n\t}\n\n\tlong min(long... a) {\n\t\tlong min = Long.MAX_VALUE;\n\t\tfor (long v : a) {\n\t\t\tmin = Math.min(min, v);\n\t\t}\n\t\treturn min;\n\t}\n\n\tdouble min(double... a) {\n\t\tdouble min = Double.MAX_VALUE;\n\t\tfor (double v : a) {\n\t\t\tmin = Math.min(min, v);\n\t\t}\n\t\treturn min;\n\t}\n\n\tint max(int... a) {\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor (int v : a) {\n\t\t\tmax = Math.max(max, v);\n\t\t}\n\t\treturn max;\n\t}\n\n\tlong max(long... a) {\n\t\tlong max = Long.MIN_VALUE;\n\t\tfor (long v : a) {\n\t\t\tmax = Math.max(max, v);\n\t\t}\n\t\treturn max;\n\t}\n\n\tdouble max(double... a) {\n\t\tdouble max = Double.MIN_VALUE;\n\t\tfor (double v : a) {\n\t\t\tmax = Math.max(max, v);\n\t\t}\n\t\treturn max;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class C {\n    static BufferedReader br;\n    static StringTokenizer st;\n\n    static String nextToken() {\n        try {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return st.nextToken();\n    }\n\n    static String nextString() throws IOException {\n        return br.readLine();\n    }\n\n    static char nextChar() throws IOException {\n        return (char) br.read();\n    }\n\n    private static int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    static ArrayList<Integer>[] graf;\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = nextInt();\n        int k = nextInt();\n        graf = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            graf[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int x = nextInt() - 1;\n            int y = nextInt() - 1;\n            int s = nextInt();\n            if (s == 0) {\n                graf[x].add(y);\n                graf[y].add(x);\n            }\n        }\n        tr = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!tr[i]) {\n                b.add(new TreeSet<>());\n                id++;\n                dfs(i);\n            }\n        }\n        long ans = n;\n        for (int i = 1; i < k; i++) {\n            ans *= n;\n            ans %= 1000000007;\n        }\n        long p = 0;\n        for (int i = 0; i < b.size(); i++) {\n            long km = 1;\n            for (int j = 0; j < k; j++) {\n                km = km * b.get(i).size() % 1000000007;\n            }\n            p += km;\n            p %= 1000000007;\n        }\n        if(p > ans){\n            ans += 1000000007;\n        }\n        System.out.println((ans - p));\n        pw.close();\n    }\n\n    static int id = -1;\n    static ArrayList<TreeSet<Integer>> b = new ArrayList<>();\n    static boolean[] tr;\n\n    private static void dfs(int v) {\n        if (tr[v]) {\n            return;\n        }\n        tr[v] = true;\n        b.get(id).add(v);\n        for (int i = 0; i < graf[v].size(); i++) {\n            dfs(graf[v].get(i));\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "MOD = int(1e9 + 7)\n\ndef join(a, b):\n    par[root(u)] = v\n\ndef root(u):\n    if u == par[u]:\n        return u\n    par[u] = root(par[u])\n    return par[u]\n\ndef bigmod(a, b):\n    ret = 1\n    while b != 0:\n        if b % 2 == 1:\n            ret *= a\n            ret %= MOD\n        b //= 2\n        a *= a\n        a %= MOD\n    return ret\n\nn, m = map(int, input().split())\npar = [i for i in range(0, n + 1)]\nfor i in range(n - 1):\n    u, v, x = map(int, input().split())\n    if x == 0:\n        join(u, v)\ncnt = [0] * (n + 1)\nfor i in range(1, n + 1):\n    cnt[root(i)] += 1\nans = 0\nfor i in range(1, n + 1):\n    ans += bigmod(cnt[i], m)\n    ans %= MOD\nans = bigmod(n, m) - ans\nans %= MOD\nans = (ans + MOD) % MOD\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\npublic class tr {\nstatic int n,k;\nstatic boolean []vis;\nstatic ArrayList<Integer> []ad;\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tScanner sc=new Scanner(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\t n=sc.nextInt();\n\t\t k=sc.nextInt();\n\t\t ad=new ArrayList[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tad[i]=new ArrayList();\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tint a=sc.nextInt()-1;\n\t\t\tint b=sc.nextInt()-1;\n\t\t\tint t=sc.nextInt();\n\t\t\tif(t==0) {\n\t\t\t\tad[a].add(b);\n\t\t\t\tad[b].add(a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvis=new boolean [n];\n\t\t\tlong num=fast_pow(n,k);\n            long sum=0;\n            for(int i=0;i<n;i++) {\n            \t c=0;\n            \tif(!vis[i]) {\n            \t\tdfs(i);\n            \t}\n            \tsum+=cal(c)%mod;\n            }\n            sum%=mod;\n         //   System.out.println(num+\" num\");\n         //   System.out.println(sum+\" sum\");\n         //   System.out.println((num-sum)+\" 2sum\");\n            num = (num - sum + mod) % mod;\n            out.println(num);\n\t\t\tout.flush();\n\t}\n\tstatic long fast_pow(long a, long b) {\n\t\tif(b == 0)\n\t\t\treturn 1L;\n\n\t\tlong val = fast_pow(a, b / 2);\n\n\t\tif(b % 2 == 0)\n\t\t\treturn val * val % mod;\n\t\telse \n\t\t\treturn val * val % mod * a % mod;\n\t}\n\tstatic int c;\n\tstatic void dfs(int s) {\n\t\tc++;\n\t\tvis[s]=true;\n\t\tfor(int u:ad[s])\n\t\t\tif(!vis[u])\n\t\t\t\tdfs(u);\n\t}\n\tstatic long cal(int r) {\n\t\tlong ans=r;\n\t\tint u=k;\n\t\twhile(--u>0) {\n\t\t\tans=(ans*r)%mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic long mod=(long)1e9+7;\n\tstatic class pair2 implements Comparable<pair2> {\n\t\tlong a;\n\t\tlong b;\n\t\tpair2(long a, long b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\t\tpublic int compareTo(pair2 o) {\n\t\t\tif(o.b<b)\n\t\t\t  return 1;\n\t\t\telse if(o.b>b)\n\t\t\t  return -1;\n\t\t\treturn 0;\t\t\t\n\t\t}\n\t}\n\tstatic class pair implements Comparable<pair> {\n\t\tlong a;\n\t\tint b;\n\t\tpair(long a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\t//if(o.a!=a)\n\t\t\t//return  a-o.a ;\n            return b-o.b;\t\t\t\n\t\t}\n\t}\n\tstatic int gcd(int a,int b) {\n\t\tif(b==0) {\n\t\t\treturn a;\n\t\t}\t\n\t\treturn gcd(b,a%b);\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class CF1139C {\n    static LinkedList<Integer> list[];\n    static long power(long a, long b) {\n        if(b == 0)\n            return 1L;\n\n        long val = power(a, b / 2);\n\n        if(b % 2 == 0)\n            return val * val % mod;\n        else\n            return val * val % mod * a % mod;\n    }\n    static long mod = (long) (1e9 + 7);\n    static void dfs(int i,boolean[] visited){\n        visited[i] = true;\n        count++;\n        //System.out.println(\"Here\");\n        for(int j : list[i]){\n            if(!visited[j]){\n                dfs(j,visited);\n            }\n        }\n    }\n    static long count = 0L;\n    public static void main(String[] args) {\n        FastReader input = new FastReader();\n        long n = input.nextLong();\n        long k = input.nextLong();\n        list = new LinkedList[(int)n+1];\n        for(int i = 1;i <= n;i++){\n            list[i] = new LinkedList<Integer>();\n        }\n        for(int i = 0;i < n-1;i++){\n            int u = input.nextInt();\n            int v = input.nextInt();\n            int color = input.nextInt();\n            if(color == 0){\n                list[u].add(v);\n                list[v].add(u);\n            }\n        }\n        long res = power(n,k);\n        long sub = 0;\n        boolean[] visited = new boolean[(int)n+1];\n        for(int i = 1;i <= n;i++){\n            if(!visited[i]){\n                count = 0L;\n                dfs(i,visited);\n                //System.out.println(count);\n                sub += power(count,k);\n            }\n        }\n        sub = sub % mod;\n        res = (res - sub + mod) % mod;\n        System.out.println(res);\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tPrintWriter out = new PrintWriter(System.out);\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok = new StringTokenizer(\"\");\n    String next() throws IOException {\n        if (!tok.hasMoreTokens()) { tok = new StringTokenizer(in.readLine()); }\n        return tok.nextToken();\n    }\n    int ni() throws IOException { return Integer.parseInt(next()); }\n    long nl() throws IOException { return Long.parseLong(next()); }\n    \n    static int n,k,ns;\n    static ArrayList<Integer>[]A;\n    static int[]S;\n    static long ans;\n    static long m=1000000007;\n    \n    void solve() throws IOException {\n        n=ni();\n        k=ni();\n        A=new ArrayList[n+1];\n        S=new int[n+1];\n        for (int x=1;x<=n;x++) A[x]=new ArrayList();\n        for (int x=1;x<n;x++) {\n            int u=ni(),v=ni(),w=ni();\n            A[u].add(v);\n            A[u].add(w);\n            A[v].add(u);\n            A[v].add(w);\n        }\n        \n        ans=mp(n,k);\n        ns=1;\n        dfs(1,0,1);\n        \n        for (int x=1;x<=ns;x++) {\n            ans=(ans-mp(S[x],k))%m;\n            if (ans<0) ans=ans+m;\n        }\n        \n        System.out.println(ans);\n    }\n    \n    long mp(long a,long b) {\n        long r=1;\n        while (b>0) {\n            if ((b&1)>0) r=(r*a)%m;\n            b=b>>1;\n            a=(a*a)%m;\n        }\n        return r;\n    }\n    \n    void dfs(int v,int p,int s) {\n        S[s]++;\n        for (int x=0;x<A[v].size();x+=2) {\n            int u=A[v].get(x);\n            int w=A[v].get(x+1);\n            if (u==p) continue;\n            if (w==0) dfs(u,v,s);\n            else { ns++; dfs(u,v,ns); }\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        new Main().solve();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\npublic class tr {\nstatic int n,k;\nstatic boolean []vis;\nstatic ArrayList<Integer> []ad;\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tScanner sc=new Scanner(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\t n=sc.nextInt();\n\t\t k=sc.nextInt();\n\t\t ad=new ArrayList[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tad[i]=new ArrayList();\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tint a=sc.nextInt()-1;\n\t\t\tint b=sc.nextInt()-1;\n\t\t\tint t=sc.nextInt();\n\t\t\tif(t==0) {\n\t\t\t\tad[a].add(b);\n\t\t\t\tad[b].add(a);\n\t\t\t}\n\t\t}\n\t\tvis=new boolean [n];\n\t\t\tlong num=fast_pow(n,k);\n            long sum=0;\n            for(int i=0;i<n;i++) {\n            \t c=0;\n            \tif(!vis[i]) {\n            \t\tdfs(i);\n            \t}\n            \tsum+=fast_pow(c,k)%mod;\n            }\n            sum%=mod;\n         //   System.out.println(num+\" num\");\n         //   System.out.println(sum+\" sum\");\n         //   System.out.println((num-sum)+\" 2sum\");\n            num = (num - sum + mod) % mod;\n            out.println(num);\n\t\t\tout.flush();\n\t}\n\tstatic long fast_pow(long a, long b) {\n\t\tif(b == 0)\n\t\t\treturn 1L;\n\n\t\tlong val = fast_pow(a, b / 2);\n\n\t\tif(b % 2 == 0)\n\t\t\treturn val * val % mod;\n\t\telse \n\t\t\treturn val * val % mod * a % mod;\n\t}\n\tstatic int c;\n\tstatic void dfs(int s) {\n\t\tc++;\n\t\tvis[s]=true;\n\t\tfor(int u:ad[s])\n\t\t\tif(!vis[u])\n\t\t\t\tdfs(u);\n\t}\n\tstatic long cal(int r) {\n\t\tlong ans=r;\n\t\tint u=k;\n\t\twhile(--u>0) {\n\t\t\tans=(ans*r)%mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic long mod=(long)1e9+7;\n\tstatic class pair2 implements Comparable<pair2> {\n\t\tlong a;\n\t\tlong b;\n\t\tpair2(long a, long b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\t\tpublic int compareTo(pair2 o) {\n\t\t\tif(o.b<b)\n\t\t\t  return 1;\n\t\t\telse if(o.b>b)\n\t\t\t  return -1;\n\t\t\treturn 0;\t\t\t\n\t\t}\n\t}\n\tstatic class pair implements Comparable<pair> {\n\t\tlong a;\n\t\tint b;\n\t\tpair(long a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\t//if(o.a!=a)\n\t\t\t//return  a-o.a ;\n            return b-o.b;\t\t\t\n\t\t}\n\t}\n\tstatic int gcd(int a,int b) {\n\t\tif(b==0) {\n\t\t\treturn a;\n\t\t}\t\n\t\treturn gcd(b,a%b);\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nlong long int INF = 1001001001001001LL;\nint inf = 1000000007;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\nlong long int di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nlong long int dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate <typename T1, typename T2>\ninline void chmin(T1 &a, const T2 &b) {\n  if (a > b) a = b;\n}\ntemplate <typename T1, typename T2>\ninline void chmax(T1 &a, const T2 &b) {\n  if (a < b) a = b;\n}\nstruct UnionFind {\n  vector<int> M_par;\n  vector<int> M_rank;\n  vector<int> M_size;\n\n private:\n  void init(int n = 1) {\n    M_par.resize(n);\n    M_rank.resize(n);\n    M_size.resize(n);\n    for (int i = 0; i < n; i++) {\n      M_par[i] = i;\n      M_rank[i] = 0;\n      M_size[i] = 1;\n    }\n  }\n\n public:\n  UnionFind(size_t n = 1) { init(n); }\n  size_t find(size_t x) {\n    if (M_par[x] == x) return x;\n    size_t r = find(M_par[x]);\n    return M_par[x] = r;\n  }\n  bool same(size_t x, size_t y) { return find(x) == find(y); }\n  bool unite(size_t x, size_t y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return false;\n    if (M_rank[x] < M_rank[y]) swap(x, y);\n    if (M_rank[x] == M_rank[y]) M_rank[x]++;\n    M_par[y] = x;\n    M_size[x] = M_size[x] + M_size[y];\n    return true;\n  }\n  size_t size(size_t x) { return M_size[find(x)]; }\n};\nconst long long MAXN = 1001024;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long extgcd(long long a, long long b, long long &x, long long &y) {\n  long long d = a;\n  if (b != 0) {\n    d = extgcd(b, a, y, x);\n    y -= (a / b) * x;\n  } else {\n    x = 1;\n    y = 0;\n  }\n  return d;\n}\nlong long prime[MAXN];\nbool is_prime[MAXN];\nbool is_prime_ab[MAXN];\nlong long sieve(long long n) {\n  long long res = 0;\n  fill(is_prime, is_prime + MAXN, true);\n  is_prime[0] = is_prime[1] = false;\n  for (long long i = 2; i <= n; ++i) {\n    if (!is_prime[i]) continue;\n    prime[res++] = i;\n    for (long long j = 2 * i; j <= n; j += i) is_prime[j] = false;\n  }\n  return res;\n}\nvector<long long> divisors(long long n) {\n  vector<long long> res;\n  for (long long i = 1; i * i <= n; ++i) {\n    if (n % i != 0) continue;\n    res.push_back(i);\n    if (n / i == i) continue;\n    res.push_back(n / i);\n  }\n  return res;\n}\nmap<long long, long long> prime_factors(long long n) {\n  map<long long, long long> res;\n  if (n == 1) {\n    res[n] = 1;\n    return res;\n  }\n  for (long long i = 2, _n = n; i * i <= _n; ++i) {\n    while (n % i == 0) {\n      ++res[i];\n      n /= i;\n    }\n  }\n  if (n != 1) res[n] = 1;\n  return res;\n}\nlong long modpow(long long a, long long n) {\n  long long res = 1;\n  while (n > 0) {\n    if (n & 1) res = res * a % MOD;\n    a = a * a % MOD;\n    n >>= 1;\n  }\n  return res;\n}\nlong long modinv(long long a, long long m) {\n  long long b = m, u = 1, v = 0;\n  while (b) {\n    long long t = a / b;\n    a -= t * b;\n    swap(a, b);\n    u -= t * v;\n    swap(u, v);\n  }\n  u %= m;\n  if (u < 0) u += m;\n  return u;\n}\nlong long fac[MAXN], finv[MAXN], inv[MAXN];\nvoid math_init() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (long long i = 2; i < MAXN; i++) {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\nlong long COM(long long n, long long k) {\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  UnionFind uf(n);\n  for (int i = 0; i < n - 1; i++) {\n    int a, b, x;\n    cin >> a >> b >> x;\n    a--;\n    b--;\n    if (x == 0) uf.unite(a, b);\n  }\n  lint ans = modpow(n, k);\n  for (int i = 0; i < n; i++) {\n    if (uf.find(i) == i) {\n      ans = ans + MOD - modpow(uf.size(i), k);\n      ans %= MOD;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int mxN = 1e5;\nvector<int> g[mxN + 1];\nvector<int> path;\nint visited[mxN + 1];\nlong long n, k, ans, c;\nlong long powmod(long long a, long long b) {\n  long long res = 1;\n  if (a >= mod) a %= mod;\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a;\n    if (res >= mod) res %= mod;\n    a = a * a;\n    if (a >= mod) a %= mod;\n  }\n  return res;\n}\nvoid dfs(int u, int p) {\n  c++;\n  visited[u] = 1;\n  for (auto ch : g[u])\n    if (ch != p && !visited[ch]) dfs(ch, u);\n}\nvoid solve2() {\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) dfs(i, -1), ans -= powmod(c, k), c = 0;\n    if (ans < 0) ans = (ans + mod) % mod;\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  for (int u, v, c, i = 1; i <= n - 1; i++) {\n    cin >> u >> v >> c;\n    if (!c) g[u].push_back(v), g[v].push_back(u);\n  }\n  ans = powmod(n, k);\n  solve2();\n  cout << (ans + mod) % mod << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > t[100001];\nint visit[100001];\nint go(int now) {\n  if (visit[now]) return 0;\n  visit[now] = 1;\n  int sum = 1;\n  for (int i = 0; i < t[now].size(); i++) {\n    if (t[now][i].second == 0) sum += go(t[now][i].first);\n  }\n  return sum;\n}\nconst unsigned long long mod = 1000000007;\nunsigned long long n_k(unsigned long long n, unsigned long long k) {\n  unsigned long long now = 1;\n  for (int i = 0; i < k; i++) {\n    now = now * (n % mod);\n    now %= mod;\n  }\n  return now;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, k, u, v, x;\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    cin >> u >> v >> x;\n    t[u].push_back({v, x});\n    t[v].push_back({u, x});\n  }\n  unsigned long long ans = 1;\n  unsigned long long onlyRed = 0;\n  ans = n_k(n, k);\n  for (int i = 1; i <= n; i++) {\n    if (!visit[i]) {\n      unsigned long long sum = 0;\n      sum = go(i);\n      onlyRed = onlyRed + (n_k(sum, k) % mod);\n      onlyRed %= mod;\n    }\n  }\n  cout << (ans - onlyRed + mod) % mod;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\t\npublic class C \n{\t\n\tstatic ArrayList<Integer> g[];\n\tstatic int[] vis,cc;\n\tstatic long mod=(long)1e9 + 7;\n\t\n\tpublic static void main(String[] args)throws IOException \n\t{\t\n\t\t\n\t\tFastReader f=new FastReader();\n\t\tStringBuffer sb=new StringBuffer();\n\t\n\t\tint n=f.nextInt();\n\t\tint k=f.nextInt();\n\t\t\n\t\tg=new ArrayList[n+1];\n\t\tvis=new int[n+1];\n\t\tcc=new int[n+1];\n\t\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tg[i]=new ArrayList<Integer>();\n\t\t\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint x=f.nextInt();\n\t\t\tint y=f.nextInt();\n\t\t\tint col=f.nextInt();\n\t\t\t\n\t\t\tif(col==0)\n\t\t\t{\n\t\t\t\tg[x].add(y);\n\t\t\t\tg[y].add(x);\n\t\t\t}\n\t\t}\n\t\tint count=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\t\n\t\t\tif(vis[i]==0)\n\t\t\t{\n\t\t\t\tdfs(i,count);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tMap<Integer,Integer> map=new HashMap<>();\n\t\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint val=cc[i];\n\t\t\tif(map.containsKey(val))\n\t\t\t\tmap.put(val,map.get(val)+1);\n\t\t\telse\n\t\t\t\tmap.put(val,1);\n\t\t}\n//\t\tSystem.out.println(\"map = \"+map);\n\t\tlong ans=fastPow(n,k);\n//\t\tSystem.out.println(\"ans ini = \"+ans);\n\t\tfor(int key : map.keySet())\n\t\t{\n\t\t\tint val=map.get(key);\n\t\t\t// val^k\n\t\t\tlong sub=fastPow((long)val,(long)k)%mod;\n\t\t\tans=(ans-sub)%mod ;\n//\t\t\tSystem.out.println(\"sub : \"+sub);\n\t\t}\n\t\tif(ans<0)\n\t\t\tans=mod+ans;\n\t\tSystem.out.println(ans);\n\t}\n\tstatic void dfs(int n,int count)\n\t{\n\t\tvis[n]=1;\n\t\tcc[n]=count;\n\t\t\n\t\tfor(int child : g[n])\n\t\t{\n\t\t\tif(vis[child]==0)\n\t\t\t\tdfs(child,count);\n\t\t}\n\t}\n\tstatic long fastPow(long n, long m) {\n\t\tlong res = 1L;\n\t\t\n\t\twhile (m > 0) {\n\t\t\tif ((m & 1) != 0) {\n\t\t\t\tres=((res%mod)*(n%mod))%mod;\n\t\t\t\tm--;\n\t\t\t} else {\n\t\t\t\tn=(n%mod * n%mod)%mod;\n\t\t\t\tm /= 2;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass FastReader \n{ \n\tBufferedReader br; \n    StringTokenizer st; \n\n    public FastReader() {\n    \tbr = new BufferedReader(new\n                 InputStreamReader(System.in)); \n    }\n    String next() { \n        while (st == null || !st.hasMoreElements()) { \n            try{ \n                st = new StringTokenizer(br.readLine()); \n\t            } \n\t            catch (IOException  e) { \n\t                e.printStackTrace(); \n\t            } \n\t    } \n\t    return st.nextToken(); \n\t} \n\tint nextInt() { \n\t\treturn Integer.parseInt(next()); \n\t} \n\tlong nextLong() { \n\t\treturn Long.parseLong(next()); \n\t} \n\tdouble nextDouble() { \n\t    return Double.parseDouble(next()); \n\t} \n\tString nextLine() { \n\t    String str = \"\"; \n\t    try{ \n\t        str = br.readLine(); \n\t    } \n\t    catch (IOException e) { \n\t            e.printStackTrace(); \n\t    } \n\t    return str; \n    } \n} \n"
        },
        {
            "language": 3,
            "solution": "# maa chudaaye duniya\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**9)\nmd = 10**9+7\nn, k = map(int, input().split())\ncnt_e = 0\ngraph = [[] for i in range(n+1)]\nfor _ in range(n-1):\n    u, v, x = map(int, input().split())\n    if x == 0:\n        cnt_e += 1\n        graph[u].append(v)\n        graph[v].append(u)\ntotal = pow(n, k, md)\nif cnt_e == n:\n    print(0)\n    exit()\nvisited = [False]*(n+1)\n\nb = 0\n\nfor i in range(1, n+1):\n    if visited[i]:\n        continue\n    queue = deque()\n    queue.append(i)\n    visited[i] = True\n    cnt = 0\n    while queue:\n        el = queue.pop()\n        for node in graph[el]:\n            if visited[node]:\n                continue\n            visited[node] = True\n            queue.append(node)\n        cnt += 1\n    b += pow(cnt, k, md)\nprint((total + md -b) % md)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class A{\n\n\tstatic int MOD=(int)1e9+7;\n\tstatic boolean []visited;\n\tstatic ArrayList<Integer>[]adj;\n\tstatic int dfs(int u) {\n\t\tint ans=1;\n\t\tvisited[u]=true;\n\t\tfor(int v:adj[u])\n\t\t\tif(!visited[v])\n\t\t\t\tans+=dfs(v);\n\t\treturn ans;\n\t}\n\tstatic int pow(long b,int e) {\n\t\tlong ans=1;\n\t\twhile(e-->0)\n\t\t\tans=ans*b%MOD;\n\t\treturn (int)ans;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc=new Scanner();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tint n=sc.nextInt(),k=sc.nextInt();\n\t\tadj=new ArrayList[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tadj[i]=new ArrayList();\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tint u=sc.nextInt()-1,v=sc.nextInt()-1;\n\t\t\tif(sc.nextInt()==1)\n\t\t\t\tcontinue;\n\t\t\tadj[u].add(v);\n\t\t\tadj[v].add(u);\n\t\t}\n\t\tvisited=new boolean[n];\n\t\tint ans=pow(n, k);\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(!visited[i])\n\t\t\t{\n\t\t\t\tint c=dfs(i);\n\t\t\t\tans-=pow(c,k);\n\t\t\t\tif(ans<0)\n\t\t\t\t\tans+=MOD;\n\t\t\t\t\n\t\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\n\t}\n\tstatic class Scanner\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tScanner(){\n\t\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tScanner(String fileName) throws FileNotFoundException{\n\t\t\tbr=new BufferedReader(new FileReader(fileName));\n\t\t}\n\t\tString next() throws IOException {\n\t\t\twhile(st==null || !st.hasMoreTokens())\n\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\t\tint nextInt() throws IOException{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong()  throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.Objects;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        CEdgyTrees solver = new CEdgyTrees();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CEdgyTrees {\n        private static final int MOD = (int) 1e9 + 7;\n\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            int n = in.ints(), k = in.ints();\n            IntUnionFind uf = new IntUnionFind(n);\n            for (int i = 1; i < n; i++) {\n                int u = in.ints() - 1, v = in.ints() - 1, x = in.ints();\n                if (x == 1) {\n                    continue;\n                }\n                uf.union(u, v);\n            }\n\n            ModMath mod = new ModMath(MOD);\n            long ans = mod.pow(n, k);\n\n            boolean[] done = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                int g = uf.find(i);\n                if (done[g]) {\n                    continue;\n                }\n                done[g] = true;\n                long siz = uf.size(i);\n                ans -= mod.pow(siz, k);\n                ans += MOD;\n                ans %= MOD;\n            }\n            out.ansln(ans);\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l));\n        }\n\n        public LightWriter ansln(long... n) {\n            for (long n1 : n) {\n                ans(n1).ln();\n            }\n            return this;\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n\n    static class LongEuclidSolver {\n        private LongEuclidSolver() {\n        }\n\n        public static Vec3l solve(long p, long q) {\n            if (q == 0) {\n                return new Vec3l(p, 1, p);\n            }\n            Vec3l vals = solve(q, p % q);\n            long a = vals.y;\n            long b = vals.x - (p / q) * a;\n            return new Vec3l(a, b, vals.z);\n        }\n\n    }\n\n    static class Vec3i implements Comparable<Vec3i> {\n        public int x;\n        public int y;\n        public int z;\n\n        public Vec3i(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Vec3i vec3i = (Vec3i) o;\n            return x == vec3i.x &&\n                    y == vec3i.y &&\n                    z == vec3i.z;\n        }\n\n        public int hashCode() {\n            return Objects.hash(x, y, z);\n        }\n\n        public String toString() {\n            return \"(\" + x + \", \" + y + \", \" + z + \")\";\n        }\n\n        public int compareTo(Vec3i o) {\n            if (x == o.x) {\n                if (y == o.y) {\n                    return Integer.compare(z, o.z);\n                }\n                return Integer.compare(y, o.z);\n            }\n            return Integer.compare(x, o.x);\n        }\n\n    }\n\n    static class ModMath {\n        private static final int DEFAULT_MOD = 1_000_000_007;\n        private final long mod;\n\n        public ModMath(long mod) {\n            this.mod = mod;\n        }\n\n        public ModMath() {\n            this(DEFAULT_MOD);\n        }\n\n        public long mod(long x) {\n            x %= mod;\n            return x < 0 ? x + mod : x;\n        }\n\n        public long inv(long x) {\n            return mod(LongEuclidSolver.solve(x, -mod).x);\n        }\n\n        public long pow(long x, long y) {\n            if (y < 0) {\n                return pow(inv(x), -y);\n            } else if (y == 0) {\n                return 1;\n            } else if (y % 2 == 0) {\n                long z = pow(x, y / 2);\n                return (z * z) % mod;\n            } else {\n                return (x % mod) * pow(x, y - 1) % mod;\n            }\n        }\n\n    }\n\n    static class Vec3l implements Comparable<Vec3l> {\n        public long x;\n        public long y;\n        public long z;\n\n        public Vec3l(long x, long y, long z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Vec3i vec3i = (Vec3i) o;\n            return x == vec3i.x &&\n                    y == vec3i.y &&\n                    z == vec3i.z;\n        }\n\n        public int hashCode() {\n            return Objects.hash(x, y, z);\n        }\n\n        public String toString() {\n            return \"(\" + x + \", \" + y + \", \" + z + \")\";\n        }\n\n        public int compareTo(Vec3l o) {\n            if (x == o.x) {\n                if (y == o.y) {\n                    return Long.compare(z, o.z);\n                }\n                return Long.compare(y, o.z);\n            }\n            return Long.compare(x, o.x);\n        }\n\n    }\n\n    static final class IntUnionFind {\n        private final int[] nodes;\n        private final int[] rank;\n\n        public IntUnionFind(int n) {\n            nodes = new int[n];\n            Arrays.fill(nodes, -1);\n            rank = new int[n];\n        }\n\n        public int find(int i) {\n            int ans = nodes[i];\n            if (ans < 0) {\n                return i;\n            } else {\n                return nodes[i] = find(ans);\n            }\n        }\n\n        public int size(int i) {\n            return -nodes[find(i)];\n        }\n\n        public boolean union(int x, int y) {\n            x = find(x);\n            y = find(y);\n            if (x == y) {\n                return false;\n            } else if (rank[x] < rank[y]) {\n                nodes[y] += nodes[x];\n                nodes[x] = y;\n            } else if (rank[x] == rank[y]) {\n                rank[x]++;\n                nodes[x] += nodes[y];\n                nodes[y] = x;\n            } else {\n                nodes[x] += nodes[y];\n                nodes[y] = x;\n            }\n            return true;\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nconst int mo = 1e9 + 7;\nlong long n, k;\nint uset[maxn];\nint siz[maxn];\nlong long q_pow(long long a, long long p) {\n  long long ans = 1;\n  while (p) {\n    if (p & 1) {\n      ans = ans * a % mo;\n    }\n    a = a * a % mo;\n    p >>= 1;\n  }\n  return ans;\n}\nint find(int x) {\n  if (x != uset[x]) uset[x] = find(uset[x]);\n  return uset[x];\n}\nint main() {\n  scanf(\"%lld%lld\", &n, &k);\n  for (int i = 1; i <= n; i++) {\n    uset[i] = i;\n    siz[i] = 1;\n  }\n  for (int i = 1; i <= n - 1; i++) {\n    int u, v, x;\n    scanf(\"%d%d%d\", &u, &v, &x);\n    if (x == 0) {\n      u = find(u);\n      v = find(v);\n      if (u == v) continue;\n      siz[u] += siz[v];\n      siz[v] = 0;\n      uset[v] = u;\n    }\n  }\n  long long ans = q_pow(n, k);\n  for (int i = 1; i <= n; i++)\n    if (uset[i] = i) {\n      ans -= q_pow((long long)siz[i], k);\n      ans = (ans + mo) % mo;\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.ArrayList;\n\npublic class TaskC {\n\n\tstatic List<Integer>[] graph;\n\tstatic long counter;\n\tstatic long mod = 1000000007;\n\t\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tgraph = new ArrayList[n];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tgraph[i] = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint u = in.nextInt()-1;\n\t\t\tint v = in.nextInt()-1;\n\t\t\tint x = in.nextInt();\n\t\t\tif(x == 0) {\n\t\t\t\tgraph[u].add(v);\n\t\t\t\tgraph[v].add(u);\n\t\t\t}\n\t\t}\n\t\tboolean[] visited = new boolean[n];\n\t\tlong total = 0;\n\t\tlong ans = fast_pow(n, k);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\tcounter = 0;\n\t\t\t\tdfs(i, visited);\n\t\t\t\ttotal += fast_pow(counter, k);\n\t\t\t}\n\t\t}\n\t\ttotal %= mod;\n\t\tans = (ans - total + mod)%mod;\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n\n\tstatic long fast_pow(long a, long b) {\n\t\tif(b == 0)\n\t\t\treturn 1L;\n\n\t\tlong val = fast_pow(a, b / 2);\n\n\t\tif(b % 2 == 0)\n\t\t\treturn val * val % mod;\n\t\telse \n\t\t\treturn val * val % mod * a % mod;\n\t}  \n\t\n\tstatic void dfs(int v, boolean[] visited) {\n\t\tvisited[v] = true;\n\t\tcounter++;\n\t\t\n\t\tfor(int j : graph[v]) {\n\t\t\tif(!visited[j])\n\t\t\t\tdfs(j, visited);\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "\nn,k=map(int,input().split())\nr=[0]\nfor i in range(1,n+1):\n    r.append(i)\nnd=[1]*(n+1)\nfor i in range(n-1):\n    u,v,x=map(int,input().split())\n    if not x:\n        while r[r[u]]!=r[u]:\n            r[u]=r[r[u]]\n        while r[r[v]]!=r[v]:\n            r[v]=r[r[v]]\n        if nd[r[u]]>=nd[r[v]]:\n            nd[r[u]]+=nd[r[v]]\n            r[r[v]]=r[u]\n        else:\n            nd[r[v]]+=nd[r[u]]\n            r[r[u]]=r[v]\nfor i in range(1,1+n):\n    while r[r[i]]!=r[i]:\n        r[i]=r[r[i]]\nc=n**k\nfor i in range(1,1+n):\n    if r[i]==i:\n        c-=nd[i]**k\ny=7+10**9\nprint(c%y)      "
        },
        {
            "language": 4,
            "solution": "//package F;\n\nimport java.io.*;\nimport java.security.KeyPair;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n    static long mod = (long) (1e9 + 7);\n\n    private static long pow(long a, long b) {\n        if (b == 0)\n            return 1L;\n\n        long val = pow(a, b / 2);\n\n        if (b % 2 == 0)\n            return val * val % mod;\n        else\n            return val * val % mod * a % mod;\n    }\n\n    public static void solve() {\n        int n = in.nextInt();\n        int k = in.nextInt();\n\n        List<Integer>[] graph = new ArrayList[n + 1];\n\n        for (int i = 1; i <= n; i += 1) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for (int i = 1; i < n; i += 1) {\n            int from = in.nextInt();\n            int to = in.nextInt();\n            int color = in.nextInt();\n\n            if (color == 0) {\n                graph[from].add(to);\n                graph[to].add(from);\n            }\n        }\n\n        boolean[] visited = new boolean[n + 1];\n        List<Integer> comps = new ArrayList<>();\n\n        for (int i = 1; i <= n; i += 1) {\n            if (!visited[i]) {\n                comps.add(dfs(i, graph, visited));\n            }\n        }\n\n        long count = 0;\n        for (int c : comps) {\n            count = (count +  pow(c, k)%mod) % mod;\n        }\n\n        long pow = pow(n, k);\n        long ans = ((pow - count) + mod) % mod;\n        out.println(ans);\n    }\n\n    private static int dfs(int node, List<Integer>[] graph, boolean[] visited) {\n        int nodes = 1;\n        visited[node] = true;\n\n        for (int n : graph[node]) {\n            if (!visited[n])\n                nodes += dfs(n, graph, visited);\n        }\n\n        return nodes;\n    }\n\n\n    public static InputReader in = new InputReader();\n    public static PrintWriter out;\n\n    public static void main(String[] args) {\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader() {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        /**\n         * When you call next(), that entire line will be skipped.\n         * No flushing buffers.\n         * Doesn't work when you want to scan the remaining line.\n         *\n         * @return entire line\n         */\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = reader.readLine();\n                tokenizer = null;\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\n\n// **** C. Edgy Trees ****\n\npublic class C {\n\tstatic char [] in = new char [10000];\n\tstatic int [] stack = new int [100001];\n\tstatic long MOD = 1000000007L;\n\tstatic class AL extends ArrayList<Integer>{ \n\t\tpublic AL (int n) { super(n);}\n\t};\n\tpublic static void main (String [] arg) throws Throwable {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\tAL [] graphB = new AL[n];\n\t\tAL [] graphR = new AL[n];\n\t\tfor (int i = 0; i<n-1; ++i) {\n\t\t\tint u = nextInt()-1;\n\t\t\tint v = nextInt()-1;\n\t\t\tint x = nextInt();\n\t\t\tif (x == 1) {\n\t\t\t\tadd(graphB, u, v);\n\t\t\t} else {\n\t\t\t\tadd(graphR, u, v);\n\t\t\t}\n\t\t}\n\t\tboolean [] visR = new boolean [n];\n\t\tboolean [] visB = new boolean [n];\n\t\tlong ans = ntothek(n,k);\n\t\t\n\t\tfor (int i = 0; i<n; ++i) {\n\t\t\tlong TMP1 = CountConnected(graphR, visR, i);\n\t\t\t//long TMP2 = CountConnected(graphB, visB, i);\n\t\t\t//System.err.println(i + \" : \" + TMP1 + \" red  and \" + TMP2 + \" black\");\n\t\t\tans = (ans - ntothek(TMP1, k) + MOD) % MOD;\n\t\t\t//ans -= ntothek(TMP2, k);\n\t\t\t//ans++; //Doublecount iiiiiiii\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static long CountConnected(AL[] graph, boolean [] vis, int start) {\n\t\tif (vis[start]) return 0;\n\t\tif (graph[start] == null) return 1;\n\t\t\n\t\tint stackptr = 1;\n\t\tint curptr = 0;\n\t\tstack[0] = start;\n\t\tlong ans = 0;\n\t\twhile (curptr < stackptr) {\n\t\t\tint cur = stack[curptr];\n\t\t\tvis[cur] = true;\n\t\t\tfor (int i = 0; i<graph[cur].size(); ++i) {\n\t\t\t\tint v = graph[cur].get(i);\n\t\t\t\tif (!vis[v]) {\n\t\t\t\t\tstack[stackptr] = v;\n\t\t\t\t\tstackptr++;\n\t\t\t\t\tvis[v] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurptr++;\n\t\t}\n\t\treturn stackptr;\n\t}\n\t\n\t\n\tpublic static long ntothek(long n, long k) {\n\t\tlong ans = 1L;\n\t\tfor (int i = 0; i<k; ++i) ans = (ans * n) % MOD;\n\t\treturn ans;\n\t}\n\tpublic static void add(AL[] graph, int u, int v) {\n\t\t\tif (graph[u] == null) graph[u] = new AL(10);\n\t\t\tif (graph[v] == null) graph[v] = new AL(10);\n\t\t\tgraph[u].add(v);\n\t\t\tgraph[v].add(u);\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t/************** FAST IO CODE FOLLOWS *****************/\n\tpublic static long nextLong() throws Throwable {\n\t\tlong i = System.in.read();boolean neg = false;while (i < 45) i = System.in.read();if (i == 45) {neg=true;i=48;}i = i - 48;\n\t\tint j = System.in.read();while (j > 32) {i*=10;i+=j-48;j = System.in.read();}return (neg) ? -i : i;\n\t}\n\tpublic static int nextInt() throws Throwable {return (int)nextLong();}\n\tpublic static String next() throws Throwable {\n\t\tint i = 0; while (i < 42 && i != -1) i = System.in.read(); int cptr = 0; while (i >= 42) { in[cptr++] = (char)i; i = System.in.read();}\n\t\treturn new String(in, 0,cptr);\n\t}\n\t/**** LIBRARIES ****/\n\tpublic static long gcdL(long a, long b) {while (b != 0) {long tmp = b;b = (a % b);a = tmp;}return a;}\n\tpublic static int gcd(int a, int b) {while (b != 0) {int tmp = b;b = (a % b);a = tmp;}return a;}\n}\n\n/* Full Problem Text:\n  \nYou are given a tree (a connected undirected graph without cycles) of n vertices.\nEach of the n - 1 edges of the tree is colored in either black or red.\nYou are also given an integer k.\nConsider sequences of k vertices.\nLet's call a sequence a_1, a_2, ..., a_k good if it satisfies the following criterion:\n \n We will walk a path (possibly visiting same edge/vertex multiple times) on the tree, starting from a_1 and ending at a_k.\nStart at a_1, then go to a_2 using the shortest path between a_1 and a_2, then go to a_3 in a similar way, and so on, until you travel the shortest path between a_{k-1} and a_k.\nIf you walked over at least one black edge during this process, then the sequence is good.\nConsider the tree on the picture.\nIf k=3 then the following sequences are good: [1, 4, 7], [5, 5, 3] and [2, 3, 7].\nThe following sequences are not good: [1, 4, 6], [5, 5, 5], [3, 7, 3].\nThere are n^k sequences of vertices, count how many of them are good.\nSince this number can be quite large, print it modulo 10^9+7.\n\n */"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInputReader in = new MyInputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        ArrayList<ArrayList<Integer>> graph;\n        boolean[] visited;\n        static int mod = ((int) 1e9) + 7;\n\n        int visit(int u) {\n            visited[u] = true;\n            int ans = 1;\n            for (int v : graph.get(u)) {\n                if (!visited[v]) {\n                    ans += visit(v);\n                }\n            }\n            return ans;\n        }\n\n        long powmod(int a, int b, int mod) {\n            if (b == 0) return 1;\n            if (b % 2 == 0) {\n                long h = powmod(a, b / 2, mod) % mod;\n                return (h * h) % mod;\n            } else {\n                return ((a % mod) * powmod(a, b - 1, mod)) % mod;\n            }\n        }\n\n        public void solve(int testNumber, MyInputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            visited = new boolean[n];\n            graph = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                graph.add(new ArrayList<>());\n            }\n            for (int i = 0; i < n - 1; i++) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                boolean black = in.nextInt() == 1;\n                if (black) continue;\n                graph.get(u).add(v);\n                graph.get(v).add(u);\n            }\n\n            long total = powmod(n, k, mod);\n            for (int i = 0; i < n; i++) {\n                if (!visited[i]) {\n                    int how = visit(i);\n                    long m = powmod(how, k, mod);\n                    total -= m;\n                    if (total < 0) total += mod;\n                }\n            }\n            out.println(total);\n\n        }\n\n    }\n\n    static class MyInputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public MyInputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    String l = reader.readLine();\n                    if (l == null) throw new RuntimeException(\"asd\");\n                    tokenizer = new StringTokenizer(l);\n                } catch (Exception e) {\n                    //return null;\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "//package com.example.myPackage;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n/*\nHere idea is to calculate pow(n,k) and subtract it from the permutation of all the orange Edges\ni.e sum pow(p,k) of differnt combination of orange edges and sub with pow(n,k) \n */\n\npublic class EdgyTrees {\n    private static Scanner fs = new Scanner (System.in);\n    private PrintWriter out = new PrintWriter(System.out);\n    private static boolean isVisited[];\n    private static int Mod = 1000_000_007;\n    private static List<Integer> tree[];\n    public static void main(String[] args) {\n    int n = fs.nextInt(); // Size of Tree\n    int k = fs.nextInt() ; // Length of vertex\n        tree = new ArrayList[n];\n        for(int i=0;i<n;i++) tree[i] = new ArrayList<>();\n        isVisited = new boolean[n];\n        for(int i=0;i<n-1;i++)\n        {\n            int From = fs.nextInt();\n            int To = fs.nextInt();\n            int color  = fs.nextInt();\n            --From;--To;\n            if(color==0)\n            {\n                tree[From].add(To);\n                tree[To].add(From);\n            }\n        }\n        long toSub =0;\n        for(int i=0;i<n;i++) {\n            if (!isVisited[i]) {\n                check =0;\n                dfs(i);\n                toSub=(toSub+(pow(check,k)))%Mod;\n            }\n        }\n        long res = -1;\n//        System.out.println(toSub);\n        res = (pow(n,k) -(toSub)+ Mod)%Mod;\n        System.out.println(res);\n//        System.out.println(pow(n,k));\n\n    }\n    private static int check =0;\n    private static  void dfs(int start)\n    {\n        isVisited[start] = true;\n        check++;\n        for(int i : tree[start])\n        {\n            if(!isVisited[i])\n            dfs(i);\n        }\n    }\n   private static long pow(long x, int n) {\n        long temp = n;\n        long res = 1;\n        while(temp>0)\n        {\n            if((temp&1)==1) res =(res*x)%Mod;\n            x = (x*x)%Mod;\n            temp =temp >>1;\n        }\n        return res;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nenum { N = 1000000007 };\nint64_t pow(int64_t a, int64_t b) {\n  int64_t p = 1;\n  while (b) {\n    if (b & 1) {\n      p = (p * a) % N;\n    }\n    b >>= 1;\n    a = (a * a) % N;\n  }\n  return p;\n}\nint64_t dfs(std::vector<bool> &visited,\n            const std::vector<std::vector<int64_t>> &info, int64_t i) {\n  int64_t sz{};\n  if (!visited[i]) {\n    visited[i] = true;\n    sz++;\n    for (auto &n : info[i]) {\n      sz += dfs(visited, info, n);\n    }\n  }\n  return sz;\n}\nint main() {\n  int64_t n, k;\n  int64_t u, v, x;\n  std::cin >> n >> k;\n  std::vector<std::vector<int64_t>> info(n);\n  int64_t ans = pow(n, k);\n  for (int64_t i = 1; i < n; ++i) {\n    std::cin >> u >> v >> x;\n    if (x == 0) {\n      info[u - 1].push_back(v - 1);\n      info[v - 1].push_back(u - 1);\n    }\n  }\n  std::vector<bool> visited(n);\n  for (int64_t i = 0; i < n; ++i) {\n    if (!visited[i]) {\n      ans -= pow(dfs(visited, info, i), k);\n      ans += N;\n      ans %= N;\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\nimport threading\nthreading.stack_size(67108864)\n \ndef main():\n    n, k = map(int, input().split())\n    uw = []\n    ubw = []\n    for i in range(n):\n        uw.append([])\n        ubw.append([])\n    for i in range(n - 1):\n        a, b, v = map(int, input().split())\n        ubw[a - 1].append(b - 1)\n        ubw[b - 1].append(a - 1)\n        if v == 0:\n            uw[a - 1].append(b - 1)\n            uw[b - 1].append(a - 1)\n    def dfs(v):\n        use[v] = 1\n        com[c] += 1\n        for i in uw[v]:\n            if not use[i]:\n                dfs(i)\n    use = [0] * n\n    c = 0\n    com = []\n    for i in range(n):\n        if not use[i]:\n            com.append(0)\n            dfs(i)\n            c += 1\n    q = 10 ** 9 + 7\n    ans = pow(n, k, q)\n    for i in range(c):\n        ans -= pow(com[i], k, q)\n        ans %= q\n    print(ans)\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()\n\n"
        },
        {
            "language": 1,
            "solution": "#import resource\nimport sys\n#resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\nimport threading\nthreading.stack_size(2**26)\nsys.setrecursionlimit(10**7)\nmod=(10**9)+7\n#fact=[1]\n#for i in range(1,1001):\n#    fact.append((fact[-1]*i)%mod)\n#ifact=[0]*1001\n#ifact[1000]=pow(fact[1000],mod-2,mod)\n#for i in range(1000,0,-1):\n#    ifact[i-1]=(i*ifact[i])%mod\nfrom sys import stdin, stdout\n#from bisect import bisect_left as bl\n#from bisect import bisect_right as br\n#import itertools\n#import math\n#import heapq\n#from random import randint as rn\n#from Queue import Queue as Q\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef ncr(n,r,p):\n    t=((fact[n])*((ifact[r]*ifact[n-r])%p))%p\n    return t\ndef ain():\n    return map(int,sin().split())\ndef sin():\n    return stdin.readline().strip()\ndef GCD(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\n\"\"\"**************************************************************************\"\"\"\ndef main():\n    def dfs(x):\n        if(p[x]==0):\n            p[x]=1\n            k[0]+=1\n            for i in adj[x]:\n                dfs(i)\n    n,k1=ain()\n    adj=[[] for i in range(n)]\n    for i in range(n-1):\n        x,y,w=ain()\n        if(w==0):\n            adj[y-1].append(x-1)\n            adj[x-1].append(y-1)\n    p=[0]*n\n    k=[0]\n    t=[]\n    for i in range(n):\n        if(p[i]==0):\n            k[0]=0\n            dfs(i)\n            t.append(k[0])\n    s=pow(n,k1,mod)\n    f=0\n    for i in range(len(t)):\n        f=(f+pow(t[i],k1,mod))%mod\n    s=(s-f)%mod\n    print s\nthreading.Thread(target=main).start()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author MaxHeap\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    CEdgyTrees solver = new CEdgyTrees();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class CEdgyTrees {\n\n    static final long MOD = (long) (1e9 + 7);\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n      int n = in.nextInt();\n      int k = in.nextInt();\n      DisjointSet ds = new DisjointSet(n);\n      int[] size = ArrayUtils.createArray(n, 1);\n      for (int i = 0; i < n - 1; ++i) {\n        int u = in.nextInt() - 1;\n        int v = in.nextInt() - 1;\n        boolean isWhite = in.nextInt() == 0;\n        if (isWhite) {\n          ds.merge(u, v);\n        }\n      }\n      long all = LongMath.powMod(n, k, MOD);\n      long other = 0;\n      for (int i = 0; i < n; ++i) {\n        if (ds.find(i) == i) {\n          other = (other + LongMath.powMod(ds.getSize(i), k, MOD)) % MOD;\n        }\n      }\n      all = ((all - other) % MOD + MOD) % MOD;\n      out.println(all);\n    }\n\n  }\n\n  static class DisjointSet {\n\n    int[] parent;\n    int[] rank;\n    int[] count;\n\n    public DisjointSet(int[] parent, int[] rank) {\n      this.parent = parent.clone();\n      this.rank = rank.clone();\n\n    }\n\n    public DisjointSet clone() {\n      return new DisjointSet(parent, rank);\n    }\n\n    public DisjointSet(int size) {\n      parent = new int[size];\n      for (int i = 0; i < size; i++) {\n        parent[i] = i;\n      }\n      rank = new int[size];\n      count = ArrayUtils.createArray(size, 1);\n    }\n\n    public int find(int x) {\n      return x == parent[x] ? x : (parent[x] = find(parent[x]));\n    }\n\n    public void merge(int a, int b) {\n      a = find(a);\n      b = find(b);\n      if (a == b) {\n        return;\n      }\n      if (rank[a] < rank[b]) {\n        parent[a] = b;\n        count[b] += count[a];\n      } else {\n        parent[b] = a;\n        count[a] += count[b];\n        if (rank[a] == rank[b]) {\n          ++rank[a];\n        }\n      }\n    }\n\n    public int getSize(int u) {\n      return count[u];\n    }\n\n  }\n\n  static interface FastIO {\n\n  }\n\n  static class ArrayUtils {\n\n    public static int[] createArray(int count, int value) {\n      int[] array = new int[count];\n      Arrays.fill(array, value);\n      return array;\n    }\n\n  }\n\n  static class InputReader implements FastIO {\n\n    private InputStream stream;\n    private static final int DEFAULT_BUFFER_SIZE = 1 << 16;\n    private static final int EOF = -1;\n    private byte[] buf = new byte[DEFAULT_BUFFER_SIZE];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (this.numChars == EOF) {\n        throw new UnknownError();\n      } else {\n        if (this.curChar >= this.numChars) {\n          this.curChar = 0;\n\n          try {\n            this.numChars = this.stream.read(this.buf);\n          } catch (IOException ex) {\n            throw new InputMismatchException();\n          }\n\n          if (this.numChars <= 0) {\n            return EOF;\n          }\n        }\n\n        return this.buf[this.curChar++];\n      }\n    }\n\n    public int nextInt() {\n      int c;\n      for (c = this.read(); isSpaceChar(c); c = this.read()) {\n      }\n\n      byte sgn = 1;\n      if (c == 45) {\n        sgn = -1;\n        c = this.read();\n      }\n\n      int res = 0;\n\n      while (c >= 48 && c <= 57) {\n        res *= 10;\n        res += c - 48;\n        c = this.read();\n        if (isSpaceChar(c)) {\n          return res * sgn;\n        }\n      }\n\n      throw new InputMismatchException();\n    }\n\n    public static boolean isSpaceChar(int c) {\n      return c == 32 || c == 10 || c == 13 || c == 9 || c == EOF;\n    }\n\n  }\n\n  static class LongMath {\n\n    private LongMath() {\n    }\n\n    public static long powMod(long base, int power, long Mod) {\n      base %= Mod;\n      long res = 1;\n      while (power != 0) {\n        if ((power & 1) != 0) {\n          res = (res * base) % Mod;\n        }\n        base = (base * base) % Mod;\n        power >>= 1;\n      }\n      return res;\n    }\n\n  }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split())\n\nmd = 10**9 + 7\nres = n**k\nbn = [0] + [1] * n\nneighbours = {}\nfor i in range(n - 1):\n  u, v, x = map(int, input().split())\n  if x == 0:\n    bn[u] = 0\n    bn[v] = 0\n    if u in neighbours:\n      neighbours[u].add(v)\n    else:\n      neighbours[u] = set([v])\n    if v in neighbours:\n      neighbours[v].add(u)\n    else:\n      neighbours[v] = set([u])\n\ncomp = []\nvisited = [0] * (n + 1)\n\nfor i in neighbours:\n  if not visited[i]:\n    comp.append([i])\n    visited[i] = 1\n    q = [i]\n    # bfs\n    while len(q) > 0:\n      u = q.pop(0)\n      for v in neighbours[u]:\n        if not visited[v]:\n          q.append(v)\n          comp[-1].append(v)\n          visited[v] = 1\n          \nfor c in comp:\n  m = len(c)\n  res -= m**k\n\nres -= sum(bn)\nprint(res%md)\n\n"
        },
        {
            "language": 1,
            "solution": "N,K = map(int,raw_input().split())\n\nadjacency_lists = [[] for x in range(N)]\n\nfor i in range(N-1):\n    u,v,c = map(int,raw_input().split())\n    if (c == 0):\n        adjacency_lists[u-1].append(v-1)\n        adjacency_lists[v-1].append(u-1)\n\n\nvisited = [False] * N\nsizes = []\nfor idx in range(N):\n    if (visited[idx] == False):\n        queue = []\n\n        queue.append(idx)\n        visited[idx] = True\n        cSize = 0\n        while queue:\n            s = queue.pop(0)\n            cSize +=1\n            for i in adjacency_lists[s]:\n                if visited[i] == False:\n                    queue.append(i)\n                    visited[i] = True\n        sizes.append(cSize)\n\ncurrTotal = N**K\n\nfor s in sizes:\n    currTotal -= s**K\n\nprint (currTotal%(10**9+7))\n"
        },
        {
            "language": 3,
            "solution": "n,k = map(int, input().strip().split())\nl = [[] for i in range(n+1)]\nused = [False for i in range(n+1)]\nfor i in range(n-1):\n    u,v,x = map(int, input().strip().split())\n    if x == 0:\n        l[v].append(u)\n        l[u].append(v)\ncomponents = []\ndef func(l,v,components,used):\n    vert = [v]\n    used[v] = True\n    temp = l[v]\n    while temp != []:\n        newverts = []\n        for i in temp:\n            used[i] = True\n            for j in l[i]:\n                if used[j] == False:\n                    newverts.append(j)\n                    used[j] = True\n        for i in temp:\n            vert.append(i)\n        temp  = newverts\n    components.append(len(vert))                    \nfor i in range(1,n+1):\n    if used[i] == False:\n        func(l,i,components,used)\nans = pow(n,k,1000000007)\nfor i in components:\n    ans -= pow(i,k,1000000007)\n    ans = ans % 1000000007\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100001;\nint n, k;\nint tot = 0;\nint head[maxn];\nstruct abcd {\n  int to, nxt;\n  long long f;\n} table[2 * maxn];\nvoid Add(int x, int y, long long z) {\n  table[++tot].to = y;\n  table[tot].f = z;\n  table[tot].nxt = head[x];\n  head[x] = tot;\n}\nint flag[maxn];\nnamespace Union_Find_Set {\nint fa[maxn], size[maxn], max_val[maxn], min_val[maxn], vis[maxn];\nint Find(int x) {\n  if (!fa[x]) size[x] = 1, fa[x] = x;\n  if (fa[x] == x) return x;\n  return fa[x] = Find(fa[x]);\n}\nvoid Union(int x, int y) {\n  x = Find(x);\n  y = Find(y);\n  if (x == y) return;\n  fa[x] = y;\n  size[y] += size[x];\n}\n}  // namespace Union_Find_Set\nlong long kpow(long long x, long long n, long long p) {\n  long long s = 1;\n  while (n) {\n    if (n & 1) s = (s * x) % p;\n    x = (x * x) % p;\n    n = n >> 1;\n  }\n  return s;\n}\nvoid dfs(int x, int p) {\n  flag[x] = 1;\n  using namespace Union_Find_Set;\n  for (int i = head[x]; i; i = table[i].nxt) {\n    if (table[i].to == p || table[i].f == 1) continue;\n    Union(x, table[i].to);\n    dfs(table[i].to, x);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  long long ans = kpow(n, k, 1000000007);\n  using namespace Union_Find_Set;\n  for (int i = 0; i < n - 1; i++) {\n    int x, y, w;\n    cin >> x >> y >> w;\n    Add(x, y, w);\n    Add(y, x, w);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!flag[i]) dfs(i, -1);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!vis[Find(i)]) {\n      long long t = kpow(size[Find(i)], k, 1000000007);\n      ans = (ans - t + 1000000007) % 1000000007;\n      vis[Find(i)] = 1;\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n/**\n * Date: 26 May, 2019\n * Link:\n *\n * @author Prasad-Chaudhari\n * @linkedIn: https://www.linkedin.com/in/prasad-chaudhari-841655a6/\n * @git: https://github.com/Prasad-Chaudhari\n */\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\npublic class newProgram2 {\n\n    public static void main(String[] args) throws IOException {\n        // TODO code application logic here\n        FastIO in = new FastIO();\n        int n = in.ni();\n        int k = in.ni();\n        long mod = (long) ((1e9) + 7);\n        UnionFind uf = new UnionFind(n);\n        long ans = 0;\n        int from[] = new int[n - 1];\n        int to[] = new int[n - 1];\n        int x[] = new int[n - 1];\n        int count[] = new int[n + 1];\n        for (int i = 0; i < n-1; i++) {\n            from[i] = in.ni();\n            to[i] = in.ni();\n            x[i] = in.ni();\n            count[from[i]]++;\n            count[to[i]]++;\n        }\n        int adja[][] = new int[n + 1][];\n        int xx[][] = new int[n + 1][];\n\n        for (int i = 0; i <= n; i++) {\n            adja[i] = new int[count[i]];\n            xx[i] = new int[count[i]];\n        }\n\n        for (int i = 0; i < n - 1; i++) {\n            adja[from[i]][count[from[i]] - 1] = to[i];\n            adja[to[i]][count[to[i]] - 1] = from[i];\n            xx[from[i]][count[from[i]] - 1] = x[i];\n            xx[to[i]][count[to[i]] - 1] = x[i];\n\n            --count[from[i]];\n            --count[to[i]];\n        }\n        Stack<Integer> st = new Stack<>();\n        boolean b[] = new boolean[n + 1];\n        b[1] = true;\n        st.push(1);\n        while (!st.isEmpty()) {\n            int root = st.pop();\n            for (int i = 0; i < adja[root].length; i++) {\n                int c = adja[root][i];\n                if (!b[c]) {\n                    st.push(c);\n                    b[c] = true;\n                    if (xx[root][i] == 0) {\n                        uf.union(root, c);\n                    }\n                }\n            }\n        }\n        int sizes[] = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            sizes[uf.find(i)] = uf.size[uf.find(i)];\n        }\n        ans += Expo.a_pow_n_mod_m(n, k, mod);\n        for (int i = 1; i <= n; i++) {\n            ans -= Expo.a_pow_n_mod_m(sizes[i], k, mod);\n            ans += mod;\n            ans %= mod;\n        }\n        \n        System.out.println(ans);\n    }\n\n    static class Expo {\n\n        static long a_pow_n_mod_m(long a, long n, long m) {\n            if (n == 0) {\n                return 1;\n            }\n            if (n == 1) {\n                return a;\n            }\n            long p = a_pow_n_mod_m(a, n / 2, m);\n            if (n % 2 == 0) {\n                return (p * p) % m;\n            } else {\n                return ((p * p) % m * a) % m;\n            }\n        }\n\n        static long a_pow_n(long a, long n) {\n            if (n == 0) {\n                return 1;\n            }\n            if (n == 1) {\n                return a;\n            }\n            long p = a_pow_n(a, n / 2);\n            if (n % 2 == 0) {\n                return (p * p);\n            } else {\n                return ((p * p) * a);\n            }\n        }\n    }\n\n    static class FastIO {\n\n        private final BufferedReader br;\n        private final BufferedWriter bw;\n        private String s[];\n        private int index;\n        private StringBuilder sb;\n\n        public FastIO() throws IOException {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            bw = new BufferedWriter(new OutputStreamWriter(System.out, \"UTF-8\"));\n            s = br.readLine().split(\" \");\n            sb = new StringBuilder();\n            index = 0;\n        }\n\n        public int ni() throws IOException {\n            return Integer.parseInt(nextToken());\n        }\n\n        public double nd() throws IOException {\n            return Double.parseDouble(nextToken());\n        }\n\n        public long nl() throws IOException {\n            return Long.parseLong(nextToken());\n        }\n\n        public String next() throws IOException {\n            return nextToken();\n        }\n\n        public String nli() throws IOException {\n            try {\n                return br.readLine();\n            } catch (IOException ex) {\n\n            }\n            return null;\n        }\n\n        public int[] gia(int n) throws IOException {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public int[] gia(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            int a[] = new int[n];\n            for (int i = start; i < end; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public double[] gda(int n) throws IOException {\n            double a[] = new double[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nd();\n            }\n            return a;\n        }\n\n        public double[] gda(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            double a[] = new double[n];\n            for (int i = start; i < end; i++) {\n                a[i] = nd();\n            }\n            return a;\n        }\n\n        public long[] gla(int n) throws IOException {\n            long a[] = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nl();\n            }\n            return a;\n        }\n\n        public long[] gla(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            long a[] = new long[n];\n            for (int i = start; i < end; i++) {\n                a[i] = nl();\n            }\n            return a;\n        }\n\n        public int[][][] gwtree(int n) throws IOException {\n            int m = n - 1;\n            int adja[][] = new int[n + 1][];\n            int weight[][] = new int[n + 1][];\n            int from[] = new int[m];\n            int to[] = new int[m];\n            int count[] = new int[n + 1];\n            int cost[] = new int[n + 1];\n            for (int i = 0; i < m; i++) {\n                from[i] = i + 1;\n                to[i] = ni();\n                cost[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n                weight[i] = new int[count[i]];\n            }\n            for (int i = 0; i < m; i++) {\n                adja[from[i]][count[from[i]] - 1] = to[i];\n                adja[to[i]][count[to[i]] - 1] = from[i];\n                weight[from[i]][count[from[i]] - 1] = cost[i];\n                weight[to[i]][count[to[i]] - 1] = cost[i];\n                count[from[i]]--;\n                count[to[i]]--;\n            }\n            return new int[][][]{adja, weight};\n        }\n\n        public int[][][] gwg(int n, int m) throws IOException {\n            int adja[][] = new int[n + 1][];\n            int weight[][] = new int[n + 1][];\n            int from[] = new int[m];\n            int to[] = new int[m];\n            int count[] = new int[n + 1];\n            int cost[] = new int[n + 1];\n            for (int i = 0; i < m; i++) {\n                from[i] = ni();\n                to[i] = ni();\n                cost[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n                weight[i] = new int[count[i]];\n            }\n            for (int i = 0; i < m; i++) {\n                adja[from[i]][count[from[i]] - 1] = to[i];\n                adja[to[i]][count[to[i]] - 1] = from[i];\n                weight[from[i]][count[from[i]] - 1] = cost[i];\n                weight[to[i]][count[to[i]] - 1] = cost[i];\n                count[from[i]]--;\n                count[to[i]]--;\n            }\n            return new int[][][]{adja, weight};\n        }\n\n        public int[][] gtree(int n) throws IOException {\n            int adja[][] = new int[n + 1][];\n            int from[] = new int[n - 1];\n            int to[] = new int[n - 1];\n            int count[] = new int[n + 1];\n            for (int i = 0; i < n - 1; i++) {\n                from[i] = i + 1;\n                to[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n            }\n            for (int i = 0; i < n - 1; i++) {\n                adja[from[i]][--count[from[i]]] = to[i];\n                adja[to[i]][--count[to[i]]] = from[i];\n            }\n            return adja;\n        }\n\n        public int[][] gg(int n, int m) throws IOException {\n            int adja[][] = new int[n + 1][];\n            int from[] = new int[m];\n            int to[] = new int[m];\n            int count[] = new int[n + 1];\n            for (int i = 0; i < m; i++) {\n                from[i] = ni();\n                to[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n            }\n            for (int i = 0; i < m; i++) {\n                adja[from[i]][--count[from[i]]] = to[i];\n                adja[to[i]][--count[to[i]]] = from[i];\n            }\n            return adja;\n        }\n\n        public void print(String s) throws IOException {\n            bw.write(s);\n        }\n\n        public void println(String s) throws IOException {\n            bw.write(s);\n            bw.newLine();\n        }\n\n        private String nextToken() throws IndexOutOfBoundsException, IOException {\n            if (index == s.length) {\n                s = br.readLine().split(\" \");\n                index = 0;\n            }\n            return s[index++];\n        }\n\n        private void validate(int n, int start, int end) {\n            if (start < 0 || end >= n) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    static class Data implements Comparable<Data> {\n\n        int a, b;\n\n        public Data(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Data o) {\n            if (a == o.a) {\n                return Integer.compare(b, o.b);\n            }\n            return Integer.compare(a, o.a);\n        }\n\n        public static void sort(int a[]) {\n            Data d[] = new Data[a.length];\n            for (int i = 0; i < a.length; i++) {\n                d[i] = new Data(a[i], 0);\n            }\n            Arrays.sort(d);\n            for (int i = 0; i < a.length; i++) {\n                a[i] = d[i].a;\n            }\n        }\n    }\n\n    static class UnionFind {\n\n        private int noOfComponents, n;\n        private int component[], size[];\n        private ArrayList<LinkedList<Integer>> members;\n\n        public UnionFind(int p) {\n            n = p;\n            noOfComponents = n;\n            component = new int[n + 1];\n            size = new int[n + 1];\n            members = new ArrayList<>();\n            for (int i = 0; i <= n; i++) {\n                component[i] = i;\n                size[i] = 1;\n                members.add(new LinkedList<Integer>());\n                members.get(i).add(i);\n            }\n        }\n\n        public int find(int k) {\n            return component[k];\n        }\n\n        public void union(int a, int b) {\n            a = find(a);\n            b = find(b);\n            if (a == b) {\n                return;\n            }\n            if (size[a] > size[b]) {\n                a = a ^ b;\n                b = a ^ b;\n                a = a ^ b;\n            }\n            LinkedList<Integer> membersofa = members.get(a);\n            LinkedList<Integer> membersofb = members.get(b);\n            for (int i = 0; i < size[a]; i++) {\n                int member = membersofa.removeFirst();\n                component[member] = component[b];\n                membersofb.add(member);\n            }\n            size[b] = size[b] + size[a];\n            noOfComponents--;\n        }\n\n        public int noOfComponents() {\n            return noOfComponents;\n        }\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C1139 {\n    static int n, k;\n    static int mod = 1_000_000_000 + 7;\n    static List<Integer>[] graph;\n    static long nodeCount;\n    static boolean[] visited;\n    public static void main(String[] args) throws IOException {\n        PrintWriter w = new PrintWriter(System.out);\n        InputReader in = new InputReader(System.in);\n        n = in.nextInt();\n        k = in.nextInt();\n        long n1 = n;\n        long k1 = k;\n        graph = new ArrayList[n+1];\n        Arrays.setAll(graph, i -> new ArrayList<>());\n        for (int i=1; i<=n-1; i++) {\n            int a = in.nextInt(), b = in.nextInt(), color = in.nextInt();\n            if (color == 0) {\n                graph[a].add(b); graph[b].add(a);\n            }\n        }\n        visited = new boolean[n+1];\n        long total = modexpo(n1, k1);\n        total %= mod;\n        //w.println(total);\n        long total2 = 0;\n        for (int i=1; i<=n; i++) {\n            if (!visited[i]) {\n                nodeCount = 0;\n                dfs(i);\n                total2 += modexpo(nodeCount, k1);\n            }\n        }\n        //w.println(total2);\n        total2 %= mod;\n        w.println((total-total2+mod)%mod);\n        w.close();\n    }\n    static void dfs(int u) {\n        visited[u] = true;\n        nodeCount++;\n        for (int v : graph[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    }\n    // static long fast_pow(long a, long b) {\n\t// \tif(b == 0)\n\t// \t\treturn 1L;\n\n\t// \tlong val = fast_pow(a, b / 2);\n\n\t// \tif(b % 2 == 0)\n\t// \t\treturn val * val % mod;\n\t// \telse \n\t// \t\treturn val * val % mod * a % mod;\n\t// }\n    static long modexpo(long n1, long k1) {\n        long result = 1;\n        n1 %= mod;\n        while (k1 > 0) {\n            if (k1%2==1) {\n                result = (result * n1) % mod;\n            }\n            k1 >>= 1;\n            n1 = (n1 * n1) % mod;\n        }\n        return result;\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\t\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader sc = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, sc, out);\n        out.close();\n    }\n\n    static class Task {\n    \tpublic static final long Mod=(long)1e9+7;\n    \tpublic ArrayList<Integer>[] buf;\n    \tpublic ArrayList<Node>[] edge;\n    \tpublic boolean[] vis;\n    \t\n    \tpublic long quickPow(long x,long y) {\n    \t\tlong res=1;\n    \t\t\n    \t\twhile(y>0) {\n    \t\t\tif((y&1)==1)\n    \t\t\t\tres=res*x%Mod;\n    \t\t\ty>>=1;\n    \t\t\tx=x*x%Mod;\n    \t\t}\n    \t\t\n    \t\treturn res;\n    \t}\n    \t\n    \tpublic void bfs(int begin) {\n    \t\tQueue<Integer> que=new LinkedList<Integer>();\n    \t\tque.offer(begin);\n    \t\t\n    \t\twhile(!que.isEmpty()) {\n    \t\t\tint u=que.poll();\n    \t\t\tif(vis[u])\n    \t\t\t\tcontinue;\n    \t\t\tvis[u]=true;\n    \t\t\tbuf[begin].add(u);\n    \t\t\tfor(Node temp:edge[u]) {\n    \t\t\t\tint v=temp.index;\n    \t\t\t\tboolean color=temp.color;\n    \t\t\t\tif(color)\n    \t\t\t\t\tcontinue;\n    \t\t\t\tif(!vis[v])\n    \t\t\t\t    que.offer(v);\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n        public void solve(int testNumber, InputReader sc, PrintWriter out) {\n            int n=sc.nextInt();\n            int k=sc.nextInt();\n            buf=new ArrayList[n+1];\n            edge=new ArrayList[n+1];\n            vis=new boolean[n+1];\n            \n            for(int i=0;i<=n;i++) {\n            \tbuf[i]=new ArrayList<Integer>();\n            \tedge[i]=new ArrayList<Node>();\n            }\n            for(int i=0;i<n-1;i++) {\n            \tint u=sc.nextInt();\n            \tint v=sc.nextInt();\n            \tboolean color=sc.nextInt()==1?true:false;            //true black   false rede\n            \tedge[u].add(new Node(v,color));\n            \tedge[v].add(new Node(u,color));\n            }\n            for(int i=1;i<=n;i++) {\n            \tif(!vis[i])\n            \t\tbfs(i);\n            }\n            long ans=quickPow(n,k);\n            long temp=0;\n            for(int i=1;i<=n;i++)\n            \ttemp=(temp+quickPow(buf[i].size(),k))%Mod;\n            ans=(ans-temp+Mod)%Mod;\n            out.println(ans);\n        }\n    }\n    \n    static class Node{\n    \tpublic int index;\n    \tpublic boolean color;\n    \t\n    \tpublic Node(int index,boolean color) {\n    \t\tthis.index=index;\n    \t\tthis.color=color;\n    \t}\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict \n  \nclass Graph: \n  \n    def __init__(self): \n  \n        self.graph = defaultdict(list) \n  \n    def addEdge(self,u,v): \n        self.graph[u].append(v) \n  \n    def BFS(self, s): \n        path=[]\n        d2={}\n  \n        queue = [] \n  \n        \n        queue.append(s) \n        d2[s]=1\n  \n        while queue: \n  \n            # Dequeue a vertex from  \n            # queue and print it \n            s = queue.pop(0) \n            path.append(s)\n  \n            \n            for i in self.graph[s]: \n                if i not in d2: \n                    queue.append(i)\n                    d2[i]=1\n        return(path)\n\nn,k=map(int,input().split())\ng=Graph()\nd1={}\nl1=[]\nx=0\nfor i in range(0,n-1):\n    a,b,c=map(int,input().split())\n    x=max(a,b,x)\n    if c==0:\n        if a not in d1:\n            l1.append(a)\n            d1[a]=1\n        if b not in d1:\n            l1.append(b)\n            d1[b]=1\n        g.addEdge(a,b)\n        g.addEdge(b,a)\nl3=[]\nfor item in l1:\n    l2=[]\n    if item in d1:\n        \n        l2=g.BFS(item)\n        l3.append(len(l2))\n        for item in l2:\n            del d1[item]\nans=pow(x,k,10**9+7)\nf=0\nfor item in l3:\n    f+=item\n    ans-=pow(item,k,10**9+7)\n    ans=ans%(10**9+7)\nprint(ans-(x-f))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMAX = 200000;\nconst long long MOD = 1000000007;\nint N, K;\nvector<int> g[NMAX + 5];\nbool vis[NMAX + 5];\nint nrc;\nint dim[NMAX + 5];\nvoid DFS(int node) {\n  vis[node] = 1;\n  dim[nrc]++;\n  for (auto it : g[node])\n    if (!vis[it]) DFS(it);\n}\nlong long ans;\nint main() {\n  cin >> N >> K;\n  int x, y, t;\n  for (int i = 1; i <= N - 1; i++) {\n    cin >> x >> y >> t;\n    if (t == 0) g[x].push_back(y), g[y].push_back(x);\n  }\n  for (int i = 1; i <= N; i++)\n    if (!vis[i]) {\n      nrc++;\n      DFS(i);\n    }\n  long long currentProd = 1;\n  for (int i = 1; i <= K; i++) currentProd *= N, currentProd %= MOD;\n  ans = currentProd;\n  for (int i = 1; i <= nrc; i++) {\n    currentProd = 1;\n    for (int j = 1; j <= K; j++) currentProd *= dim[i], currentProd %= MOD;\n    ans -= currentProd;\n    while (ans < 0) ans += MOD;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class C {\n    public static long MOD = 1000000007;\n    public static void main(String[] args) throws IOException{\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        StringTokenizer st = new StringTokenizer(f.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        LinkedList<Integer>[] edges = new LinkedList[n+1];\n        for(int i = 0; i < n+1; i++) edges[i] = new LinkedList<Integer>();\n        long subtractVal = 1;\n        for(int i = 0; i < k; i++){\n            subtractVal*=n;\n            subtractVal%=MOD;\n        }\n        for(int i = 0; i < n-1; i++){\n            st = new StringTokenizer(f.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            int c = Integer.parseInt(st.nextToken());\n            if(c == 0){\n                edges[a].add(b);\n                edges[b].add(a);\n            }\n        }\n        boolean[] seen = new boolean[n+1];\n        long ans = 0;\n        for(int i = 1; i <= n; i++){\n            if(seen[i]) continue;\n            int size = 0;\n            LinkedList<Integer> q = new LinkedList<Integer>();\n            q.add(i);\n            while(!q.isEmpty()){\n                int temp = q.poll();\n                if(seen[temp]) continue;\n                seen[temp] = true;\n                size++;\n                for(int e: edges[temp]) {\n                    if (!seen[e]) q.add(e);\n                }\n            }\n            long ct = 1;\n            for(int j = 0; j < k; j++){\n                ct*=size;\n                ct%=MOD;\n            }\n            ans+=ct;\n            ans%=MOD;\n        }\n        out.println(((subtractVal-ans)%MOD+MOD)%MOD);\n\n        out.close();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> v[100005];\nlong long p[100005] = {0};\nlong long cnt = 0;\nlong long power(long long x, long long y, long long p) {\n  long long res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) res = ((res % p) * (x % p) % p) % p;\n    y = y >> 1;\n    x = ((x % p) * (x % p)) % p;\n  }\n  return (res % p);\n}\nlong long dfs(long long x) {\n  p[x] = 1;\n  cnt++;\n  for (long long i = 0; i < v[x].size(); i++) {\n    if (p[v[x][i]] == 0) {\n      dfs(v[x][i]);\n    }\n  }\n  return cnt;\n}\nint main() {\n  long long n, k, x, y, z;\n  vector<long long> c;\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; i++) {\n    cin >> x >> y >> z;\n    if (z == 0) {\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    cnt = 0;\n    if (p[i] == 0) {\n      c.push_back(dfs(i));\n    }\n  }\n  long long sum = 0, sum1 = 0;\n  for (long long i = 0; i < c.size(); i++) {\n    sum = (sum % 1000000007 + power(c[i], k, 1000000007) % 1000000007) %\n          1000000007;\n    sum1 += c[i];\n  }\n  sum1 = n - sum1;\n  long long ans = (power(n, k, 1000000007) - sum1 - sum);\n  while (ans < 0) {\n    ans += 1000000007;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int m = 1e9 + 7;\nbool vis[100005];\nvector<int> tr[100005];\nmap<pair<int, int>, int> ma;\nlong long ans = 0;\nint k;\nlong long po(long long a, long long n) {\n  long long ret = 1;\n  while (n) {\n    if (n & 1) ret = (ret * a) % m;\n    a = (a * a) % m;\n    n >>= 1;\n  }\n  return ret;\n}\nint dfs(int x) {\n  vis[x] = 1;\n  int child = 0;\n  for (auto i : tr[x]) {\n    if (!vis[i]) {\n      if (ma[{x, i}]) {\n        int ch = dfs(i);\n        ans -= po(ch, k);\n        ans %= m;\n        if (ans < 0) ans += m;\n      } else\n        child += dfs(i);\n    }\n  }\n  return child + 1;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n >> k;\n  for (int i = 1; i < n; ++i) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    tr[u].push_back(v);\n    tr[v].push_back(u);\n    ma[{u, v}] = ma[{v, u}] = c;\n  }\n  ans = po(n, k);\n  ans %= m;\n  memset(vis, 0, sizeof vis);\n  int tmp = dfs(1);\n  ans -= po(tmp, k);\n  ans %= m;\n  if (ans < 0) ans += m;\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 2e5 + 5;\nconst int MOD = 1e9 + 7;\nint n, k, god, visited[MAX];\nlong long result;\nvector<int> adjlist[MAX];\nclass fastio {\n public:\n  fastio() {\n    ios_base::sync_with_stdio(false);\n    cout.tie(nullptr);\n    cin.tie(nullptr);\n  }\n} __fastio;\nlong long power(int x) {\n  long long tmp = 1;\n  for (int i = 1; i <= k; i++) (tmp *= x) %= MOD;\n  return tmp;\n}\nvoid create_graph(int u, int v) {\n  adjlist[u].push_back(v);\n  adjlist[v].push_back(u);\n}\nvoid dfs(int node) {\n  god++;\n  visited[node] = 1;\n  for (int i = 0; i < adjlist[node].size(); i++) {\n    if (!visited[adjlist[node][i]]) dfs(adjlist[node][i]);\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    if (c == 0) create_graph(u, v);\n  }\n  int total = power(n);\n  for (int i = 1; i <= n; i++) {\n    if (visited[i]) continue;\n    god = 0;\n    dfs(i);\n    total = (total - power(god) + MOD) % MOD;\n  }\n  cout << total << endl;\n}\nint main() {\n  __fastio;\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &x) {\n  x = 0;\n  int f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  x = x * f;\n}\ntemplate <typename T>\ninline void print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <typename E>\nE gcd(E a, E b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\ntemplate <typename E>\nE lcm(E a, E b) {\n  return a * b / gcd(a, b);\n}\ntemplate <typename E>\nE ex_gcd(E a, E b, E &x, E &y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n  } else {\n    ex_gcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n}\ntemplate <typename E>\nE quick_mul(E a, E b, E c) {\n  E ans = 0;\n  while (b) {\n    if (b & 1) ans = (ans + a) % c;\n    a = (a + a) % c;\n    b >>= 1;\n  }\n  return ans;\n}\ntemplate <typename E>\nE quick_pow(E a, E b, E c) {\n  E ans = 1;\n  while (b) {\n    if (b & 1) ans = ans * a % c;\n    a = a * a % c;\n    b >>= 1;\n  }\n  return ans;\n}\ntemplate <typename E>\nE inv1(E a, E b) {\n  return quick_pow(a, b - 2, b);\n}\ntemplate <typename E>\nE inv2(E a, E b) {\n  E x, y;\n  ex_gcd(a, b, x, y);\n  return (x % b + b) % b;\n}\nconst double eps = 1.0e-5;\nconst int maxn = 200000 + 10;\nconst long long mod = 1e9 + 7;\nint n, k, u, v;\nvector<int> vec[maxn];\nint r[maxn], b[maxn], l1 = 0, l2 = 0, c;\nint fa[maxn], fa1[maxn], num[maxn], num1[maxn];\nlong long ans = 0;\nint fin(int cur) { return fa[cur] == cur ? cur : (fa[cur] = fin(fa[cur])); }\nint fin1(int cur) {\n  return fa1[cur] == cur ? cur : (fa1[cur] = fin1(fa1[cur]));\n}\nvoid unite(int u, int v, int c) {\n  if (c == 1) {\n    int x = fin(u), y = fin(v);\n    if (x != y) fa[x] = y;\n  } else {\n    int x = fin1(u), y = fin1(v);\n    if (x != y) fa1[x] = y;\n  }\n}\nstruct node {\n  int u, v, c;\n} e[maxn];\nbool cmp(node a, node b) { return a.c < b.c; }\nint x, y, co[maxn];\nbool flag[maxn];\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = (1); i <= (n); i++) fa[i] = fa1[i] = i;\n  for (int i = (1); i <= (n - 1); i++) {\n    scanf(\"%d %d %d\", &e[i].u, &e[i].v, &e[i].c);\n  }\n  int sta;\n  sort(e + 1, e + n, cmp);\n  for (int i = 1; i < n && e[i].c == 0; i++) {\n    unite(e[i].u, e[i].v, 0);\n    sta = i;\n    co[e[i].u] = co[e[i].v] = 1;\n  }\n  long long cnt = 0;\n  for (int i = sta + 1; i < n; i++) {\n    if (!co[e[i].u]) {\n      cnt++;\n      co[e[i].u] = 1;\n    }\n    if (!co[e[i].v]) {\n      cnt++;\n      co[e[i].v] = 1;\n    }\n  }\n  for (int i = (1); i <= (n); i++) {\n    num1[fin1(i)]++;\n  }\n  for (int i = (1); i <= (n); i++) {\n    if (num1[i] > 1) r[++l2] = num1[i];\n  }\n  ans = quick_pow((long long)n, (long long)k, mod) - cnt;\n  for (int i = (1); i <= (l2); i++) {\n    ans = (ans - quick_pow((long long)r[i], (long long)k, mod)) % mod;\n  }\n  printf(\"%lld\\n\", ((ans % mod) + mod) % mod);\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\n\nn, k = map(int, stdin.readline().split())\nparent = [i for i in range(n + 1)]\nsize = [1]*(n+1)\nMOD = 10**9+7\nans = pow(n, k, MOD)\n\ndef find(u):\n    if parent[u] == u:\n        return u\n    parent[u] = find(parent[u])\n    return parent[u]\n\nfor i in range(n-1):\n    u, v, c = map(int, stdin.readline().split())\n    if not c:\n        pu = find(u)\n        pv = find(v)\n        size[pu]+=size[pv]\n        parent[pv] = pu\n\nprint((ans - sum([pow(size[u], k, MOD) for u in range(1, n + 1) if parent[u] == u]))%MOD)"
        },
        {
            "language": 3,
            "solution": "#from collections import OrderedDict\nfrom collections import defaultdict\n#from functools import reduce\n#from itertools import groupby\n#sys.setrecursionlimit(10**6)\n#from itertools import accumulate\nfrom collections import Counter\nimport math\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n'''\nfrom threading import stack_size,Thread\nsys.setrecursionlimit(10**6)\nstack_size(10**8)\n'''\ndef listt():\n    return [int(i) for i in input().split()]\n       \nparent={}\nrank={}\nl=[]\nparent={}\ndef find(x):\n    lii=[]\n    while parent[x]!=x:\n        lii.append(x)\n        x=parent[x]\n    for i in lii:\n        parent[i]=x\n    return x \ndef union(a,b):\n    a=find(a)\n    b=find(b)\n    if a==b:\n        return\n    if rank[a]>rank[b]:\n        parent[b]=a\n        rank[a]+=rank[b]\n    else:\n        parent[a]=b\n        rank[b]+=rank[a]\n           \nn,k=map(int,input().split())\nfor i in range(1,n+1):\n    parent[i]=i\n    rank[i]=1\nfor i in range(n-1):\n        u,v,w=map(int,input().split()) \n        if w==0:\n            union(u,v)\ns=set()            \nfor i in range(1,n+1):\n    s.add(find(i))\nsu=0    \nfor i in s:   \n    su+=rank[i]**k\nprint((n**k-su)%1000000007)    \n                        "
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    static ArrayList<Integer> gr[];\n    static boolean used[];\n    static int cnt = 0;\n    static public void dfs(int v) {\n        if (used[v]) return;\n        used[v] = true;\n        cnt++;\n        for(int i : gr[v]) {\n            dfs(i);\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = nextInt();\n        int k = nextInt();\n        gr = new ArrayList[n];\n        used = new boolean [n];\n        for(int i = 0;i < n;i++) gr[i] = new ArrayList<>();\n        for(int i = 0;i < n - 1;i++) {\n            int v = nextInt() - 1;\n            int u = nextInt() - 1;\n            int c = nextInt();\n            if (c == 1) continue;\n            gr[v].add(u);\n            gr[u].add(v);\n        }\n        long ans = n;\n        int st = 1;\n        int mod = (int) 1e9 + 7;\n        while(st != k) {\n            ans = (ans * n) % mod;\n            st++;\n        }\n        for(int i = 0;i < n;i++) {\n            if (!used[i]) {\n                cnt = 0;\n                dfs(i);\n                st = 1;\n                long u = cnt;\n                while(st != k) {\n                    u = (u * cnt) % mod;\n                    st++;\n                }\n                ans -= u;\n            }\n        }\n        pw.println((ans % mod + mod) % mod);\n        pw.close();\n    }\n\n    static BufferedReader br;\n    static StringTokenizer st = new StringTokenizer(\"\");\n\n    public static int nextInt() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return Integer.parseInt(st.nextToken());\n    }\n\n    public static long nextLong() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer((br.readLine()));\n        }\n        return Long.parseLong(st.nextToken());\n    }\n\n    public static double nextDouble() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return Double.parseDouble(st.nextToken());\n    }\n\n    public static String next() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n}"
        },
        {
            "language": 1,
            "solution": "n,k = map(int,raw_input().split())\ng = []\nfor i in range(n):\n\tg.append([])\nq = []\nvis = [0]*(n+1)  \nb = 0\ncolor = [1]*(n+1)\nfor i in range(n-1):\n\tu,v,x = map(int,raw_input().split())\n\tif not x:\n\t\tq.append(u-1)\n\t\tq.append(v-1)\n\t\tg[u-1].append(v-1)\n\t\tg[v-1].append(u-1)\n\t\tcolor[u] = 0\n\t\tcolor[v] = 0\n\n# print color\nfor i in range(1,n+1):\n\tif color[i]:\n\t\tb+=1\nx = 0\nMOD = 10**9 + 7\nans = pow(n,k,MOD) \n# print q\nstck = []\nwhile len(q)!=0:\n\tcnt = 0\n\tv = q.pop()\n\tif vis[v]:\n\t\tcontinue\n\t# print \"new query\",v\n\tstck.append(v)\n\twhile len(stck)!=0:\n\t\ti = stck.pop()\n\t\tif vis[i]:\n\t\t\tcontinue\n\t\tvis[i] = 1\n\t\t# print \"dfs\",i,g[i],cnt\n\t\tcnt+=1\n\t\tfor j in g[i]:\n\t\t\tif not vis[j]:\n\t\t\t\tstck.append(j)\n\tans-=pow(cnt,k,MOD)\n\tans%=MOD\nprint (ans - b)%MOD"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\n\n// @author : Dinosparton \n\npublic class test {\n\t \n\t   static class Pair{ \n\t\t   long x;\n\t\t   long y;\n\t\t   \n\t\t   Pair(long x,long y){ \n\t\t\t   this.x = x;\n\t\t\t   this.y = y;\n\t\t\t   \n\t\t   }\n\t   }\n\t  \n\t   static class Sort implements Comparator<Pair>\n\t   {\n\n\t       @Override\n\t       public int compare(Pair a, Pair b)\n\t       {\n\t           if(a.x!=b.x)\n\t           {\n\t               return (int)(a.x - b.x);\n\t           }\n\t           else\n\t           {\n\t               return (int)(a.y-b.y);\n\t           }\n\t       }\n\t   }\n\t   \n\t   static class Compare { \n\t\t   \n\t\t     void compare(Pair arr[], int n) \n\t\t    { \n\t\t        // Comparator to sort the pair according to second element \n\t\t        Arrays.sort(arr, new Comparator<Pair>() { \n\t\t            @Override public int compare(Pair p1, Pair p2) \n\t\t            { \n\t\t            \tif(p1.x!=p2.x) {\n\t\t                return (int)(p1.x - p2.x); \n\t\t            \t}\n\t\t            \telse { \n\t\t            \t\treturn (int)(p1.y - p2.y);\n\t\t            \t}\n\t\t            } \n\t\t        }); \n\t\t  \n//\t\t        for (int i = 0; i < n; i++) { \n//\t\t            System.out.print(arr[i].x + \" \" + arr[i].y + \" \"); \n//\t\t        } \n//\t\t        System.out.println(); \n\t\t    } \n\t\t} \n\t \n\t   static class Scanner {\n\t        BufferedReader br;\n\t        StringTokenizer st;\n\t \n\t        public Scanner()\n\t        {\n\t            br = new BufferedReader(\n\t                new InputStreamReader(System.in));\n\t        }\n\t \n\t        String next()\n\t        {\n\t            while (st == null || !st.hasMoreElements()) {\n\t                try {\n\t                    st = new StringTokenizer(br.readLine());\n\t                }\n\t                catch (IOException e) {\n\t                    e.printStackTrace();\n\t                }\n\t            }\n\t            return st.nextToken();\n\t        }\n\t \n\t        int nextInt() { return Integer.parseInt(next()); }\n\t \n\t        long nextLong() { return Long.parseLong(next()); }\n\t \n\t        double nextDouble()\n\t        {\n\t            return Double.parseDouble(next());\n\t        }\n\t \n\t        String nextLine()\n\t        {\n\t            String str = \"\";\n\t            try {\n\t                str = br.readLine();\n\t            }\n\t            catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            return str;\n\t        }\n\t    }\n\t\n\t  static long MOD = 1000000007;\n\t  \n\t  static long pow (long a , long b) { \n\t\t  \n\t\t  long ans = 1;\n\t\t  \n\t\t  for(int i=1;i<=b;i++) { \n\t\t\t  \n\t\t\t  ans = ans*a;\n\t\t\t  ans = (ans + MOD) %MOD;\n\t\t  }\n\t\t  \n\t\t  return (ans+MOD)%MOD;\n\t  }\n\t  \n\t  static int dfs(int cur,boolean visited[],ArrayList<Integer> graph[]) { \n\t\t  \n\t\t  int cnt = 1;\n\t\t  \n\t\t  visited[cur] = true;\n\t\t  \n\t\t  for(int i : graph[cur]) { \n\t\t\t  \n\t\t\t  if(!visited[i]) { \n\t\t\t\t  cnt += dfs(i,visited,graph);\n\t\t\t  }\n\t\t  }\n\t\t  \n\t\t  return cnt;\n\t  }\n\t   public static void main(String args[]) throws Exception { \n\t\t\n\t\t   \n\t\t   Scanner sc = new Scanner();\n\t\t   StringBuilder res = new StringBuilder();\n\t\t  \n\t\t  \n\t\t   int tc = 1;\n\t\t  \n\t\t   while(tc-->0) { \n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\t\n\t\t\tArrayList<Integer> graph[] = new ArrayList[n+1];\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++) { \n\t\t\t\tgraph[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n-1;i++) { \n\t\t\t\t\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\t\n\t\t\t\tif(e==0) { \n\t\t\t\t\tgraph[u].add(v);\n\t\t\t\t\tgraph[v].add(u);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tlong ans = pow(n,k);\n\t\t\tlong min = 0;\n\t\t\tboolean visited[] = new boolean[n+1];\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++) { \n\t\t\t\t\n\t\t\t\tint cnt = 0;\n\t\t\t\t\n\t\t\t\tif(!visited[i]) { \n\t\t\t\t\tcnt  = dfs(i,visited,graph);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin += pow(cnt,k);\n\t\t\t\tmin = min%MOD;\n\t\t\t}\n\t\t\t\n\t\t\tans = ans - min;\n\t\t\tans = (ans+MOD)%MOD;\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t   }\n\t\t   \n\t\t   System.out.println(res);\n\t   }\n}  \n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "n,k=map(int,input().split())\ngr=[None]*(n+1)\n\nvis=[False]*(n+1)\ncnt=0\ndef dfs(i):\n         global vis,cnt\n         l=[i]\n         size=1\n         while(size>0):\n                  i=l[size-1]\n                  vis[i]=True\n                  l.pop()\n                  size-=1\n                  for x in gr[i]:\n                           if(vis[x]==False):\n                                    l.append(x)\n                                    size+=1\n                  cnt+=1\nfor i in range(n+1):\n         gr[i]=[]\nfor i in range(1,n):\n         x,y,w=map(int,input().split())\n         if(w==0):\n                  gr[x].append(y)\n                  gr[y].append(x)\nans=pow(n,k,1000000007)\nfor i in range(1,n+1):\n         if(vis[i]==False):\n                  cnt=0\n                  dfs(i)\n                  ans-=pow(cnt,k,1000000007)\nprint(ans%1000000007)"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class cf2 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scn = new Scanner(System.in);\n\t\tint n = scn.nextInt();\n\t\tint k = scn.nextInt();\n\t\tint[] set = new int[n];\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tset[i] = i;\n\t\t\tarr[i] = 1;\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint x = scn.nextInt() - 1;\n\t\t\tint y = scn.nextInt() - 1;\n\t\t\tint s = scn.nextInt();\n\t\t\tif (s == 0) {\n\t\t\t\tint fa = find(x, set);\n\t\t\t\tint fb = find(y, set);\n\t\t\t\tif (fa != fb) {\n\t\t\t\t\tif (arr[fa] > arr[fb]) {\n\t\t\t\t\t\tarr[fa] += arr[fb];\n\t\t\t\t\t\tset[fb] = fa;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tarr[fb] += arr[fa];\n\t\t\t\t\t\tset[fa] = fb;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tlong ans = 0;\n\t\tint mod = 1000000007;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (set[i] == i) {\n\t\t\t\tans = ((ans + power(arr[i], k)) % mod);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(((long)power(n, k) - ans + mod) % mod);\n\t}\n\n\tpublic static int find(int myindex, int[] set) {\n\n\t\tif (myindex != set[myindex]) {\n\t\t\treturn find(set[myindex], set);\n\t\t} else {\n\t\t\treturn myindex;\n\t\t}\n\t}\n\n\tpublic static long power(int val, int po) {\n\t\tif (po == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tint mod = 1000000007;\n\t\tlong v = power(val, po / 2);\n\t\tv = (v * v) % mod;\n\t\tif (po % 2 == 0) {\n\t\t\treturn v;\n\t\t} else {\n\t\t\treturn (v * val) % mod;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import deque\nimport sys,math\n\ndef get_int(): # returns a list of integers after taking an input\n    return list(map(int,sys.stdin.readline().strip().split()))\nmod=10**9+7\n\ndef dfs(adj_list,n):\n    v_list=[False]*(n+1)\n    v_list[0]=None\n    comp_cnt=[]\n    for u in range(1,n+1):\n        if v_list[u]==False:\n            q=deque([u])\n            v_list[u]=True\n            c=1\n            while len(q)>0:\n                v=deque.popleft(q)\n                # print(v)\n                for w in adj_list[v]:\n                    if v_list[w]==False:\n                        c+=1\n                        v_list[w]=True\n                        deque.append(q,w)\n            comp_cnt.append(c)\n    return comp_cnt\n\ndef power(x, y, p=mod) : \n    res = 1 \n    x = x % p        \n    if (x == 0) : \n        return 0  \n    while (y > 0) : \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n        y = y >> 1 \n        x = (x * x) % p           \n    return res \n\nif __name__ == \"__main__\":\n    n,k=get_int()\n    adj_list=[[] for _ in range(n+1)] #Stores the adjacency list\n    adj_list[0]=None\n    for _ in range(n-1):\n        a,b,c=get_int()\n        if c==0:\n            adj_list[a].append(b) \n            adj_list[b].append(a)\n    comp_stngth=dfs(adj_list,n)\n    t_pos=power(n,k)\n    n_pos=0\n    for c in comp_stngth:\n        n_pos=(n_pos+power(c,k))%mod\n    print((t_pos-n_pos)%mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long infl = 1e18 + 5;\nlong long n, m, k, q, x, y, f, val, t, i, j;\nlong long ind, cnt, sz, sm, mx, mn, ans;\nlong long a[1000004], vis[1000004];\nvector<long long> v[1000004];\nmap<pair<long long, long long>, long long> mp;\nlong long pow_mod(long long a, long long b) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res *= a;\n      res %= 1000000007;\n    }\n    a *= a;\n    a %= 1000000007;\n    b /= 2;\n  }\n  return res;\n}\nlong long dfs(int i) {\n  if (vis[i]) return 0;\n  vis[i] = 1;\n  long long re = 1;\n  for (auto it : v[i]) {\n    if (mp[{it, i}] == 0) {\n      re += dfs(it);\n    }\n  }\n  return re;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  if (fopen(\"inp.txt\", \"r\")) {\n    freopen(\"myfile.txt\", \"w\", stdout);\n    freopen(\"inp.txt\", \"r\", stdin);\n  }\n  cin >> n >> k;\n  for (i = 0; i < n - 1; i++) {\n    cin >> x >> y >> val;\n    v[x].emplace_back(y);\n    v[y].emplace_back(x);\n    mp[{x, y}] = val;\n    mp[{y, x}] = val;\n  }\n  ans = pow_mod(n, k);\n  for (i = 1; i < n + 1; i++) {\n    if (!vis[i]) {\n      sz = dfs(i);\n      ans -= pow_mod(sz, k);\n      ans += 1000000007 + 1000000007;\n      ans %= 1000000007;\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def dfs(x):\n    q = [x]\n    s[x] = 1\n    ans = 1\n    while len(q) != 0:\n        i = q.pop()\n        for y in range(len(w[i])):\n            if s[w[i][y]] == 0:\n                q.append(w[i][y])\n                s[w[i][y]] = 1\n                ans = (ans + 1) % e\n    return ans\n\n\nn, k = map(int, input(). split())\ne = 10 ** 9 + 7\nw = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b, c = map(int, input(). split())\n    if c == 0:\n        w[a - 1].append(b - 1)\n        w[b - 1].append(a - 1)\np = 0\ns = [0] * n\nfor i in range(n):\n    if s[i] == 0:\n        p += dfs(i) ** k\nprint((n ** k - p) % e)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class _1139C {\n\n    public static final long MOD = 1000000007l;\n    Scanner scanner = new Scanner(System.in);\n    int n, k;\n    UnionFind unionFind;\n\n    public static void main(String[] args) {\n        _1139C solution = new _1139C();\n\n        solution.solve();\n    }\n\n    private class UnionFind{\n        int[] parent = new int[n+1];\n        int[] weight = new int[n+1];\n\n        {\n            for(int i=1; i<=n; i++){\n                parent[i] = i;\n                weight[i] = 1;\n            }\n        }\n\n        private int find(int v){\n            if(parent[v]!=v){\n                parent[v] = find(parent[v]);\n                return parent[v];\n            }\n            return v;\n        }\n\n        private void union(int u, int v){\n            int pu = find(u), pv = find(v);\n\n            if(pu==pv) return;\n\n            if(weight[pu] > weight[pv]){\n                parent[pv] = pu;\n                weight[pu] += weight[pv];\n            }\n            else{\n                parent[pu] = pv;\n                weight[pv] += weight[pu];\n            }\n        }\n    }\n\n    public void solve(){\n        n = scanner.nextInt();\n        k = scanner.nextInt();\n        unionFind = new UnionFind();\n\n\n        int u, v, col;\n        for(int i=1; i<=n-1; i++){\n            u = scanner.nextInt();\n            v = scanner.nextInt();\n            col = scanner.nextInt();\n\n            if(col==0) {\n                unionFind.union(u, v);\n            }\n        }\n\n        System.out.println(pathWithBlack());\n    }\n\n    private long pathWithBlack(){\n        List<Long> groupSize = new ArrayList<>();\n        long noOfPaths = powK(n, k);\n\n        for(int i=1; i<=n; i++){\n            if(unionFind.parent[i] == i){\n                groupSize.add((long) unionFind.weight[i]);\n            }\n        }\n\n        for(long grp: groupSize){\n            noOfPaths = subtractWithModulo(noOfPaths, powK(grp, k));\n        }\n\n        return noOfPaths;\n    }\n\n    private long subtractWithModulo(long a, long b){\n        return ((a-b) % MOD + MOD) % MOD;\n    }\n\n    private long powK(long n, long k){\n        long ans=1;\n        long multiplier = n;\n        while(k>0){\n            if(k%2==1){\n                ans = (ans * multiplier) % MOD;\n            }\n            multiplier = (multiplier * multiplier) % MOD;\n            k /= 2;\n        }\n\n        return ans;\n    }\n\n\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nimport heapq\nimport bisect\nfrom collections import Counter\nfrom collections import defaultdict\nfrom io import BytesIO, IOBase\nimport string\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n        self.BUFSIZE = 8192\n\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef get_int():\n    return int(input())\n\n\ndef get_ints():\n    return list(map(int, input().split(' ')))\n\n\ndef get_int_grid(n):\n    return [get_ints() for _ in range(n)]\n\n\ndef get_str():\n    return input().split(' ')\n\n\ndef yes_no(b):\n    if b:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ndef binary_search(good, left, right, delta=1, right_true=False):\n    \"\"\"\n    Performs binary search\n    ----------\n    Parameters\n    ----------\n    :param good: Function used to perform the binary search\n    :param left: Starting value of left limit\n    :param right: Starting value of the right limit\n    :param delta: Margin of error, defaults value of 1 for integer binary search\n    :param right_true: Boolean, for whether the right limit is the true invariant\n    :return: Returns the most extremal value interval [left, right] which is good function evaluates to True,\n            alternatively returns False if no such value found\n    \"\"\"\n\n    limits = [left, right]\n    while limits[1] - limits[0] > delta:\n        if delta == 1:\n            mid = sum(limits) // 2\n        else:\n            mid = sum(limits) / 2\n        if good(mid):\n            limits[int(right_true)] = mid\n        else:\n            limits[int(~right_true)] = mid\n    if good(limits[int(right_true)]):\n        return limits[int(right_true)]\n    else:\n        return False\n\n\ndef prefix_sums(a, drop_zero=False):\n    p = [0]\n    for x in a:\n        p.append(p[-1] + x)\n    if drop_zero:\n        return p[1:]\n    else:\n        return p\n\n\ndef prefix_mins(a, drop_zero=False):\n    p = [float('inf')]\n    for x in a:\n        p.append(min(p[-1], x))\n    if drop_zero:\n        return p[1:]\n    else:\n        return p\n\n\ndef solve_a():\n    n = get_int()\n    s = get_str()\n    cnt = 0\n    for i in range(n):\n        if int(s[i]) % 2 == 0:\n            cnt += i + 1\n    return cnt\n\n\ndef solve_b():\n    n = get_int()\n    a = get_ints()\n    curr = float('inf')\n    S = 0\n    while a:\n        curr = max(0, min(curr - 1, a.pop()))\n        S += curr\n    return S\n\n\nclass DSU:\n\n    # Disjoint Set Union (Union-Find) Data Structure\n    def __init__(self, nodes, recursive=True, choose_join=True):\n        # Parents\n        self.p = [i for i in range(nodes)]\n        # Ranks\n        self.r = [0 for i in range(nodes)]\n        # Sizes\n        self.s = [1 for i in range(nodes)]\n        self.recursive = recursive\n        self.choose_join = choose_join\n\n    def _get_recursive(self, u):\n        if u != self.p[u]:\n            self.p[u] = self.get(self.p[u])\n        return self.p[u]\n\n    def _get_nonrecursive(self, u):\n        v = self.p[u]\n        while v != self.p[v]:\n            v = self.p[v]\n        while u != v:\n            u, self.p[u] = self.p[u], v\n        return v\n\n    def get(self, u):\n        if self.recursive:\n            return self._get_recursive(u)\n        else:\n            return self._get_nonrecursive(u)\n\n    def union(self, u, v):\n        # Unites the sets with identifiers u and v\n        u = self.get(u)\n        v = self.get(v)\n        if u != v:\n            if self.r[u] > self.r[v] and self.choose_join:\n                u, v = v, u\n            self.p[u] = v\n            if self.r[u] == self.r[v]:\n                self.r[v] += 1\n            self.s[v] += self.s[u]\n\n\ndef solve_c():\n    n, k = get_ints()\n    M = 10 ** 9 + 7\n    D = DSU(n)\n    for _ in range(n - 1):\n        u, v, x = get_ints()\n        if x == 0:\n            D.union(u - 1, v - 1)\n    good = pow(n, k, M)\n    for i in range(n):\n        if D.get(i) == i:\n            good -= pow(D.s[i], k, M)\n            good %= M\n    return good\n\n\nprint(solve_c())\n"
        },
        {
            "language": 3,
            "solution": "# curr_comp\n# dfs(v):\n#     for all children of v\n#         if not visited c\n#             visited c = true\n#             comp c = curr comp\n#             dfs(c)\n#\n# dfs(v):\n#     if visited v:\n#         return\n#     visited v = true\n#     comp v = curr\n#\n#     for all red children:\n#         dfs(c)\nimport functools\n\nif __name__ == '__main__':\n    nodes_nr, seq_len = (int(x) for x in input().split())\n    node_idx___red_children = [[] for _ in range(nodes_nr)]\n    mod = 10 **9 + 7\n    for _ in range(nodes_nr - 1):\n        n1, n2, color = (int(x) for x in input().split())\n        if color == 0:\n            node_idx___red_children[n1 - 1].append(n2 - 1)\n            node_idx___red_children[n2 - 1].append(n1 - 1)\n\n    node_idx___component = [-1 for _ in range(nodes_nr)]\n    component___size = []\n    curr_component = 0\n    for node in range(nodes_nr):\n        if node_idx___component[node] != -1:\n            continue\n\n        curr_component_size = 1\n\n        stack = [node]\n        node_idx___component[node] = curr_component\n        while len(stack) > 0:\n            node_idx = stack.pop()\n            for child_idx in node_idx___red_children[node_idx]:\n                if node_idx___component[child_idx] == -1:\n                    node_idx___component[child_idx] = curr_component\n                    curr_component_size += 1\n                    stack.append(child_idx)\n                elif node_idx___component[child_idx] != curr_component:\n                    raise Exception('Two connectivity components are connected somehow. Go investigate it')\n\n        component___size.append(curr_component_size)\n        curr_component += 1\n\n    ans = pow(nodes_nr, seq_len, mod)\n    for size in component___size:\n        ans -= pow(size, seq_len, mod)\n        ans %= mod\n    print((ans % mod + mod) % mod)"
        },
        {
            "language": 3,
            "solution": "def parser():\n    while 1:\n        data = list(input().split(' '))\n        for number in data:\n            if len(number) > 0:\n                yield(number)   \n\ninput_parser = parser()\ndef get_word():\n    global input_parser\n    return next(input_parser)\ndef get_number():\n    data = get_word()\n    try:\n        return int(data)\n    except ValueError:\n        return float(data)\n\ndef calc(pa,pb,a,b):\n    p = max(pa, pb)\n    n = min(a,b)\n    if pa == pb and n - p > 0:\n        #print(a,b, \"add\", n-p, n, p)\n        return n - p\n    elif not(pa == pb) and n - p  >= 0:\n        #print(a,b, \"add D\", 1+  n-p, \"n :\", n, \"p:\", p)\n        return 1 + n - p\n    else:\n        return 0\n\n\nclass Elem:\n    def __init__(self,data):\n        self.data = data\n        self.parent = self\n        self.size = 1\n\n    def merge(self, toElem):\n        toParent = toElem.getParent()\n        myParent = self.getParent()\n        myParent.parent = toParent\n        toParent.size += myParent.size\n        myParent.size = toParent.size\n\n    def getParent(self):\n        if self == self.parent:\n            return self\n        else:\n            return self.parent.getParent()\n\n\nn = get_number()\nk = get_number()\n\nelems = []\nfor i in range(n):\n    elems.append( Elem(i + 1) )\nfor i in range(n - 1):\n        u = get_number()\n        v = get_number()\n        x = get_number()\n        if x == 0:\n            elems[u-1].merge(elems[v-1])\ngroups = []\nfor i in elems:\n    if  i.getParent().data == i.data:\n        groups.append([i.data , i.size])\n\n\nbad = 0\nfor i in groups:\n    bad += i[1]**k\nresult = n ** k\nm = 1000000007\nprint ((result - bad) % m )\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class main {\n\tstatic int parent[], rank[];\n\tstatic int find(int x) {\n\t\tif(parent[x] != x)\n\t\t\tparent[x] = find(parent[x]);\n\t\treturn parent[x];\n\t}\n\tstatic void union(int a, int b) {\n\t\tint x = find(a), y = find(b);\n\t\tif(x == y)\n\t\t\treturn;\n\t\tif(rank[x] > rank[y])\n\t\t\tparent[y] = x;\n\t\telse if(rank[x] < rank[y])\n\t\t\tparent[x] = y;\n\t\telse {\n\t\t\tparent[y] = x;\n\t\t\trank[x]++;\n\t\t}\n\t}\n\tpublic static final int MOD = 1000000000 + 7;\n\tstatic long fastExp(long x, long y) { \n        long Ans = 1L;      \n        while(y > 0) { \n            if((y & 1) == 1) \n                Ans = (Ans * x) % MOD; \n            y = y >> 1;  \n            x = (x * x) % MOD;  \n        } \n        return Ans % MOD; \n    }\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tString s[] = br.readLine().split(\" \");\n\t\tint N = Integer.parseInt(s[0]), k = Integer.parseInt(s[1]);\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tfor(int i = 0 ; i < N ; i++)\n\t\t\tparent[i] = i;\n\t\tfor(int i = 0 ; i < N - 1 ; i++) {\n\t\t\ts = br.readLine().split(\" \");\n\t\t\tif(s[2].equals(\"1\"))\n\t\t\t\tcontinue;\n\t\t\tunion(Integer.parseInt(s[0]) - 1 ,Integer.parseInt(s[1]) - 1);\n\t\t}\n\t\tHashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n\t\tfor(int i = 0 ; i < N ; i++) {\n\t\t\tint key = find(parent[i]);\n\t\t\tif(hm.containsKey(key))\n\t\t\t\thm.put(key, hm.get(key) + 1);\n\t\t\telse\n\t\t\t\thm.put(key, 1);\n\t\t}\n\t\tlong Ans = fastExp(N, k);\n\t\tfor(Map.Entry<Integer, Integer> entry : hm.entrySet()) {\n\t\t\tAns -= fastExp(entry.getValue(), k);\n\t\t\tAns = (Ans + MOD) % MOD;\n\t\t}\n\t\tpw.println(Ans);\n\t\tpw.flush();\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "mod = 10**9+7\nimport sys\ninput = sys.stdin.buffer.readline\nfrom collections import deque\n\nclass Graph(object):\n\t\"\"\"docstring for Graph\"\"\"\n\tdef __init__(self,n,d): # Number of nodes and d is True if directed\n\t\tself.n = n\n\t\tself.graph = [[] for i in range(n)]\n\t\tself.parent = [-1 for i in range(n)]\n\t\tself.directed = d\n\t\t\n\tdef addEdge(self,x,y):\n\t\tself.graph[x].append(y)\n\t\tif not self.directed:\n\t\t\tself.graph[y].append(x)\n\n\tdef bfs(self, root, vis): # NORMAL BFS\n\t\tqueue = [root]\n\t\tqueue = deque(queue)\n\t\tc = 0\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tc += 1\n\t\t\tvis[element] = 1\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tself.parent[i] = element\n\t\treturn c\n\n\tdef dfs(self, root, ans): # Iterative DFS\n\t\tstack=[root]\n\t\tvis=[0]*self.n\n\t\tstack2=[]\n\t\twhile len(stack)!=0: # INITIAL TRAVERSAL\n\t\t\telement = stack.pop()\n\t\t\tif vis[element]:\n\t\t\t\tcontinue\n\t\t\tvis[element] = 1\n\t\t\tstack2.append(element)\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tstack.append(i)\n\n\t\twhile len(stack2)!=0: # BACKTRACING. Modify the loop according to the question\n\t\t\telement = stack2.pop()\n\t\t\tm = 0\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif i!=self.parent[element]:\n\t\t\t\t\tm += ans[i]\n\t\t\tans[element] = m\n\t\treturn ans\n\n\tdef shortestpath(self, source, dest): # Calculate Shortest Path between two nodes\n\t\tself.bfs(source)\n\t\tpath = [dest]\n\t\twhile self.parent[path[-1]]!=-1:\n\t\t\tpath.append(parent[path[-1]])\n\t\treturn path[::-1]\n\n\tdef ifcycle(self):\n\t\tself.bfs(0)\n\t\tqueue = [0]\n\t\tvis = [0]*n\n\t\tqueue = deque(queue)\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in graph[element]:\n\t\t\t\tif vis[i]==1 and i!=parent[element]:\n\t\t\t\t\treturn True\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tvis[i] = 1\n\t\treturn False\n\n\tdef reroot(self, root, ans):\n\t\tstack = [root]\n\t\tvis = [0]*n\n\t\twhile len(stack)!=0:\n\t\t\te = stack[-1]\n\t\t\tif vis[e]:\n\t\t\t\tstack.pop()\n\t\t\t\t# Reverse_The_Change()\n\t\t\t\tcontinue\n\t\t\tvis[e] = 1\n\t\t\tfor i in graph[e]:\n\t\t\t\tif not vis[e]:\n\t\t\t\t\tstack.append(i)\n\t\t\tif self.parent[e]==-1:\n\t\t\t\tcontinue\n\t\t\t# Change_The_Answers()\n\n\n\nn,k = map(int,input().split())\ng = Graph(n,False)\nfor i in range(n-1):\n\ta,b,c = map(int,input().split())\n\tif not c:\n\t\tg.addEdge(a-1,b-1)\nvis = [0]*n\ncount = 0\nfor i in range(n):\n\tif not vis[i]:\n\t\tc = g.bfs(i,vis)\n\t\tcount += pow(c,k,mod)\n\t\tcount %= mod\nprint ((pow(n,k,mod)-count)%mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mx = 1e9 + 7;\nlong long longpow(long long a, long long b) {\n  a = a % mx;\n  if (b == 0 || a == 1) {\n    return 1;\n  } else {\n    long long ans = 1;\n    while (b != 0) {\n      ans = (ans * a);\n      ans = ans % mx;\n      b--;\n    }\n    return ans % mx;\n  }\n}\nint main() {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios::sync_with_stdio(false);\n  long long n, k;\n  cin >> n >> k;\n  unordered_map<long long, vector<long long>> nmap;\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, v, x;\n    cin >> u >> v >> x;\n    if (x == 0) {\n      nmap[u].push_back(v);\n      nmap[v].push_back(u);\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    nmap[i].push_back(i);\n  }\n  vector<bool> visit(n + 1);\n  long long answer = longpow(n, k);\n  for (long long i = 1; i <= n; i++) {\n    queue<long long> qu;\n    qu.push(i);\n    long long cnt = 0;\n    while (!qu.empty()) {\n      long long start = qu.front();\n      qu.pop();\n      for (auto x : nmap[start]) {\n        if (visit[x] != true) {\n          qu.push(x);\n          visit[x] = true;\n          cnt++;\n        }\n      }\n    }\n    answer -= (long long)longpow(cnt, k);\n    answer += mx;\n    answer %= mx;\n  }\n  cout << answer;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class C>\ninline void log_c(const C& c) {}\ntemplate <class C>\ninline int sz(const C& c) {\n  return static_cast<int>(c.size());\n}\nusing namespace std;\nusing num = int64_t;\nconst std::string eol = \"\\n\";\nusing pii = pair<int, int>;\nnum sum = 0;\nvector<vector<int>> adj;\nvector<bool> visited;\nconst num mod = 1000000000 + 7;\ninline num pow_by_mod(num n, num exp) {\n  num ax = 1;\n  for (; exp; --exp) {\n    ax = (ax * n) % mod;\n  }\n  return ax;\n}\ninline int tree_size(int u, int p) {\n  int ans = 1;\n  visited.at(u) = true;\n  for (int v : adj.at(u)) {\n    if (v == p) continue;\n    ans += tree_size(v, u);\n  }\n  return ans;\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  adj.resize(n);\n  visited.resize(n);\n  for (int k = 0; k < (n - 1); ++k) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    if (x == 0) {\n      --u;\n      --v;\n      adj.at(u).push_back(v);\n      adj.at(v).push_back(u);\n    }\n  }\n  num bad_path_count = 0;\n  for (int u = 0; u < (n); ++u) {\n    if (visited.at(u)) continue;\n    num sz = tree_size(u, u);\n    bad_path_count = (bad_path_count + pow_by_mod(sz, m)) % mod;\n  }\n  const num path_count = pow_by_mod(n, m);\n  const num good_path_count = (path_count - bad_path_count + mod) % mod;\n  cout << good_path_count << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class EdgyTrees {\n    static class Edge {\n        int to;\n        int col;\n\n        public Edge(int to, int col) {\n            this.to = to;\n            this.col = col;\n        }\n    }\n\n    static int res = 0;\n\n    static void dfs(List<List<Edge>> graph, boolean[] visited, int cur) {\n        visited[cur] = true;\n        res++;\n        for (Edge e : graph.get(cur)) {\n            if (e.col == 1 || visited[e.to]) continue;\n            dfs(graph, visited, e.to);\n        }\n    }\n\n    static final long mod = 1_000_000_000 + 7;\n\n    static long pow(long base, long exp) {\n        long ans = 1;\n        while (exp > 0) {\n            if (exp % 2 == 0) {\n                exp /= 2;\n                base = base * base;\n                base %= mod;\n            } else {\n                exp--;\n                ans *= base;\n                ans %= mod;\n            }\n        }\n        return ans % mod;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer stringTokenizer = new StringTokenizer(reader.readLine());\n        int n = Integer.parseInt(stringTokenizer.nextToken());\n        int k = Integer.parseInt(stringTokenizer.nextToken());\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < n - 1; i++) {\n            stringTokenizer = new StringTokenizer(reader.readLine());\n            int from = Integer.parseInt(stringTokenizer.nextToken()) - 1;\n            int to = Integer.parseInt(stringTokenizer.nextToken()) - 1;\n            int c = Integer.parseInt(stringTokenizer.nextToken());\n            graph.get(from).add(new Edge(to, c));\n            graph.get(to).add(new Edge(from, c));\n        }\n        boolean[] visited = new boolean[n];\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (visited[i]) continue;\n            res = 0;\n            dfs(graph, visited, i);\n            ans += pow(res, k);\n        }\n\n        long possibleans = (pow(n, k) - ans) % mod;\n        if (possibleans < 0) {\n            possibleans += mod;\n        }\n        System.out.println(possibleans);\n\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 7)\n\n\ndef BFC(digraph, v, oboid):\n    s2 = set()\n    s1 = set()\n    s1.add(v)\n    cnt = 0\n    while s1 != set():\n        for element in s1:\n            if element not in oboid:\n                oboid.add(element)\n                cnt += 1\n                for key in digraph[element]:\n                    s2.add(key)\n        s1 = s2\n        s2 = set()\n    return cnt\n\n\nn, k = map(int, input().split())\nMOD = 10 ** 9 + 7\ngraph = {i: set() for i in range(1, n + 1)}\nD = []\nfor i in range(n - 1):\n    u, v, x = map(int, input().split())\n    if x == 0:\n        graph[u].add(v)\n        graph[v].add(u)\nwo = len(graph)\noboid = set()\ncomps = 0\nansq = 0\nfor v in graph:\n    if v not in oboid:\n        cnt = BFC(graph, v, oboid)\n        ansq += pow(cnt, k, MOD)\n        ansq %= MOD\nprint((pow(n, k, MOD) - ansq) % MOD)"
        },
        {
            "language": 3,
            "solution": "n, k = [int(i) for i in input().split()]\npre = [i for i in range(n)]\nsz = [1 for i in range(n)]\nmod = 10 ** 9 + 7\n\ndef get_pre(i):\n    if (i == pre[i]):\n        return i\n    pre[i] = get_pre(pre[i])\n    return pre[i]\n\ndef merge(i, j):\n    i = get_pre(i)\n    j = get_pre(j)\n    if (i == j):\n        return 0\n    if (sz[i] < sz[j]):\n        i, j = j, i\n    pre[j] = i\n    sz[i] += sz[j]\n\ndef bp(a, n):\n    if n == 0:\n        return 1\n    if (n & 1) == 1:\n        return a * bp(a * a % mod, n // 2) % mod\n    return bp(a * a % mod, n // 2)\n\nans = bp(n, k)\nfor i in range(n - 1):\n    [x, y, t] = [int(i) for i in input().split()]\n    if t == 0:\n        merge(x - 1, y - 1)\n\nfor i in range(n):\n    if pre[i] == i:\n        ans -= bp(sz[i], k)\nans %= mod\nans += mod\nans %= mod\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "import sys\n\nn, k = list(map(int, sys.stdin.readline().split()))\n\nsc = 0\nd = dict()\nlos = []\n\nfor i in range(n-1):\n    u, v, x = list(map(int, sys.stdin.readline().split()))\n    if not x:\n        if u not in d and v not in d:\n            d[u] = sc\n            d[v] = sc\n            los += [{u, v}]\n            sc += 1\n        elif u in d and v not in d:\n            d[v] = d[u]\n            los[d[u]].add(v)\n        elif u not in d and v in d:\n            d[u] = d[v]\n            los[d[v]].add(u)\n        elif u in d and v in d:\n            stc = d[v]\n            los[d[u]] |= los[d[v]]\n            for j in los[stc]:\n                d[j] = d[u]\n            los[stc] = set()\n\ncolos = []\nfor s in los:\n    if s:\n        colos += [len(s)]\n\nif sum(colos) < n:\n    colos += [1] * (n - sum(colos))\n\ncs = n**k\n\nfor s in colos:\n    cs -= s**k\n\nprint(cs%1000000007)\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\nM = 10**9 + 7\nclass Graph:\n    def __init__(self,n,k):\n        self.red =defaultdict(list)\n        self.black = defaultdict(list)\n        self.visitedRed = defaultdict(bool)\n        self.vertices = n\n        self.power = k\n        self.minus = 0\n        self.blackPowerNegative = 0\n    def addEdge(self,fr,to,col):\n        if(col==0):\n            self.red[fr].append(to)\n            self.red[to].append(fr)\n        else:\n            self.black[fr].append(to)\n            self.black[to].append(fr)\n    def BFSUtil(self,root):\n        count = 0\n        if(len(self.red[root])==0):\n            return\n        queue = [root]\n        self.visitedRed[root] = True\n        while(queue):\n            s = queue.pop(0)\n            count += 1\n            for k in self.red[s]:\n                if(self.visitedRed[k]==False):\n                    self.visitedRed[k] = True\n                    queue.append(k)\n        self.minus+=pow(count,self.power,M)\n    def BFS(self):\n        for i in range(1,self.vertices+1):\n            if(self.visitedRed[i]==False):\n                self.BFSUtil(i)\n    def BFSBlack(self):\n        for i in self.black.keys():\n            if(not self.red[i]):\n                self.blackPowerNegative+=1\n    def solve(self):\n        # print(\"S: \",self.minus)\n        X = (pow(self.vertices,self.power,M) - self.minus)%M - self.blackPowerNegative\n        print(X)\nn,k = map(int,input().split())\nG = Graph(n,k)\nfor i in range(n-1):\n    a,b,col = [int(x) for x in input().split()]\n    G.addEdge(a,b,col)\nG.BFS()\nG.BFSBlack()\nG.solve()"
        },
        {
            "language": 3,
            "solution": "n, k = list(map(int, input().split()))\ngrafo = {}\n\nfor _ in range(n-1):\n\ti, j, tipo = list(map(int, input().split()))\n\tif tipo == 0:\n\t\tl = grafo.get(i, None)\n\t\tif l:\n\t\t\tl.append(j)\n\t\telse:\n\t\t\tl = [j]\n\n\t\tgrafo[i] = l\n\n\t\tl = grafo.get(j, None)\n\t\tif l:\n\t\t\tl.append(i)\n\t\telse:\n\t\t\tl = [i]\n\n\t\tgrafo[j] = l\n\n# print(grafo)\n\n\n\nv = [0]*(n+1)# visitou\ng = [0]*(n+1)# grupo\ncurrent_group = 0\n\n\ndef passa(pos):\n\tfila = []\n\tfila.append(pos)\n\n\tglobal current_group\n\tglobal v\n\tglobal g\n\tv[pos] = 1\n\tcurrent_group+=1\n\t# print('current group {}'.format(current_group))\n\twhile fila:\n\t\tcurrent = fila.pop(0)\n\t\t# print('Desempilha {}'.format(current))\n\t\tg[current] = current_group\n\t\tl = grafo.get(current, [])\n\n\t\tfor i in l:\n\t\t\tif v[i] == 0:\n\n\t\t\t\t# print('Empilha {}'.format(i))\n\t\t\t\tv[i] = 1\n\t\t\t\tfila.append(i)\n\nfor i in range(1, n+1):\n\tif v[i] == 0:\n\t\tpassa(i)\n\n\n\nfrom collections import Counter\nc = Counter(g[1:])\n# print(g)\n\nmod_divisor = 1000000007\n\n# total = ((n%mod_divisor)**k)%mod_divisor\nsubtracao = 0\nfor i in c:\n\tsubtracao+= c[i]**k\n\n\n\nprint(((n**k)-subtracao)%mod_divisor)\n\n# print(c)\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long m = 1000000007;\nvoid dfs(long long x, vector<long long> v1[], bool vis[]) {\n  vis[x] = true;\n  for (long long i = 0; i < v1[x].size(); i++) {\n    if (vis[v1[x][i]] == false) {\n      vis[v1[x][i]] = true;\n      dfs(v1[x][i], v1, vis);\n    }\n  }\n}\nlong long power(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % m;\n    b /= 2;\n    a = (a * a) % m;\n  }\n  return ans;\n}\nlong long cnt = 0;\nvoid dfs(long long x, vector<long long> v1[], bool vis[], long long v) {\n  cnt++;\n  vis[x] = true;\n  for (long long i = 0; i < v1[x].size(); i++) {\n    if (vis[v1[x][i]] == false) {\n      vis[v1[x][i]] = true;\n      dfs(v1[x][i], v1, vis, 1);\n    }\n  }\n}\nsigned main() {\n  long long n, k;\n  cin >> n >> k;\n  vector<long long> v[n + 1];\n  vector<long long> v1[n + 1];\n  vector<long long> v2;\n  bool vis[n + 1];\n  memset(vis, false, sizeof(vis));\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, vv, x;\n    cin >> u >> vv >> x;\n    v[u].push_back(vv);\n    v[vv].push_back(u);\n    if (x == 0) {\n      v1[u].push_back(vv);\n      v1[vv].push_back(u);\n      if (vis[u] == false) {\n        v2.push_back(u);\n        vis[u] = true;\n      }\n      if (vis[vv] == false) {\n        v2.push_back(vv);\n        vis[vv] = true;\n      }\n    }\n  }\n  long long con = 0;\n  memset(vis, false, sizeof(vis));\n  for (long long i = 0; i < v2.size(); i++) {\n    if (vis[v2[i]] == false) {\n      dfs(v2[i], v1, vis);\n      con++;\n    }\n  }\n  long long c[con + 1];\n  memset(c, 0, sizeof(c));\n  con = 0;\n  memset(vis, false, sizeof(vis));\n  for (long long i = 0; i < v2.size(); i++) {\n    if (vis[v2[i]] == false) {\n      dfs(v2[i], v1, vis, 1);\n      con++;\n      c[con] = cnt;\n      cnt = 0;\n    }\n  }\n  long long pro;\n  pro = power(n, k);\n  long long ans = 0;\n  for (long long i = 1; i <= con; i++) {\n    pro -= power(c[i], k);\n    pro += m;\n    pro %= m;\n    pro += c[i];\n  }\n  pro -= n;\n  cout << pro << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\nlong long int ans = 0;\nlong long int z = 0;\nvector<pair<long, long>> adj[100100];\nint vis[100100] = {0};\nvoid dfs(long long int x) {\n  vis[x] = 1;\n  for (auto y : adj[x]) {\n    if (!vis[y.first] && y.second) {\n      z++;\n      dfs(y.first);\n    }\n  }\n}\nlong long int pot(long long int a, long long int b) {\n  if (b == 0) return 1;\n  long long int ret = pot(a, b / 2);\n  ret *= ret;\n  ret %= MOD;\n  if (b % 2) ret *= a;\n  ret %= MOD;\n  return ret;\n}\nint main() {\n  long long int n, k;\n  scanf(\"%lld%lld\", &n, &k);\n  for (int i = 0; i < n - 1; i++) {\n    long long int a, b, c;\n    scanf(\"%lld%lld%lld\", &a, &b, &c);\n    adj[a].push_back(make_pair(b, !c));\n    adj[b].push_back(make_pair(a, !c));\n  }\n  ans = (pot(n, k) % MOD - n) % MOD;\n  for (int i = 0; i < n; i++) {\n    z = 1;\n    if (!vis[i]) dfs(i);\n    if (z != 1) ans -= (pot(z, k) - z);\n    ans += MOD;\n    ans %= MOD;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int maxn = 240000;\nconstexpr LL mod = 1000000007;\nint f[maxn];\nint getf(int u) { return f[u] < 0 ? u : f[u] = getf(f[u]); }\nLL power(LL a, LL r) {\n  LL res = 1;\n  for (; r; r >>= 1, a = a * a % mod)\n    if (r & 1) res = res * a % mod;\n  return res;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= n; i += 1) f[i] = -1;\n  for (int i = 1; i < n; i += 1) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    if (x == 0) {\n      u = getf(u);\n      v = getf(v);\n      if (f[u] < f[v])\n        f[u] += f[v], f[v] = u;\n      else\n        f[v] += f[u], f[u] = v;\n    }\n  }\n  LL ans = power(n, k);\n  for (int i = 1; i <= n; i += 1)\n    if (f[i] < 0) ans = (ans - power(-f[i], k) + mod) % mod;\n  cout << ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nfrom collections import defaultdict,deque\nimport heapq\nmod=10**9+7\ndef find(node,parent):\n\twhile parent[node]!=node:\n\t\tnode=parent[node]\n\treturn node\ndef union(u,v,parent,child):\n\tparu=find(u,parent)\n\tparv=find(v,parent)\n\tif child[paru]>child[parv]:\n\t\tchild[paru]+=child[parv]\n\t\tchild[parv]=0\n\t\tparent[parv]=paru\n\telse:\n\t\tchild[parv]+=child[paru]\n\t\tchild[paru]=0\n\t\tparent[paru]=parv\nn,k=map(int,sys.stdin.readline().split())\nchild = [1 for _ in range(n+1)]\nparent = [i for i in range(n+1)]\nedges=[]\nfor i in range(n-1):\n\tu,v,w=map(int,sys.stdin.readline().split())\n\tedges.append([u,v,w])\n\tif w==0:\n\t\tunion(u,v,parent,child)\n#print(parent)\nans=pow(n,k,mod)\nfor i in range(1,n+1):\n\tans-=pow(child[i],k,mod)\n\tans%=mod\nprint(ans%mod)"
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] parent = new int[n + 1];\n        int[] size = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            size[i] = 1;\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int node1 = sc.nextInt();\n            int node2 = sc.nextInt();\n            int redOrBlack = sc.nextInt();\n\n            if (redOrBlack == 0) {\n                int root1 = node1;\n                while (parent[root1] != 0)\n                    root1 = parent[root1];\n                int root2 = node2;\n                while (parent[root2] != 0)\n                    root2 = parent[root2];\n                parent[root2] = root1;\n                size[root1] += size[root2];\n            }\n        }\n\n        BigInteger total = BigInteger.valueOf(n).modPow(BigInteger.valueOf(k), BigInteger.valueOf(1000000007));\n\n        for (int i = 1; i <= n; i++) {\n            if (parent[i] == 0)\n                total = total.subtract(BigInteger.valueOf(size[i]).modPow(BigInteger.valueOf(k), BigInteger.valueOf(1000000007)));\n        }\n\n        System.out.println(total.mod(BigInteger.valueOf(1000000007)));\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom sys import stdin,stdout\nsys.setrecursionlimit(2*10**5)\n\n\n\nn,k=stdin.readline().strip().split(' ');n,k=int(n),int(k)\n\nadj=[[] for i in range(n)]\nvisited=[0 for i in range(n)]\n\nver_col=[[] for i in range(n)]\n\n\nfor i in range(n-1):\n\tu,v,x=stdin.readline().strip().split(' ');u,v,x=int(u),int(v),int(x)\n\tif x==0:\n\t\tadj[u-1].append(v-1)\n\t\tadj[v-1].append(u-1)\n\ncount=[]\n\n\ndef dfs(current_vertex,parent_vertex,idd):\n\tcount[idd]+=1\n\tvisited[current_vertex]=1;\n\tarr=adj[current_vertex]\n\twhile len(arr)>0:\n\t\tcv=arr.pop(0);\n\t\tif visited[cv]==0:\n\t\t\tcount[idd]+=1;\n\t\t\tvisited[cv]=1;\n\t\t\tarr+=adj[cv];\n\t\t\nctr=0\n\nfor i in range(n):\n\tif visited[i]==0:\n\t\tcount.append(0)\n\t\tdfs(i,-1,len(count)-1)\n\t\tctr+=count[-1]\n\t\tif ctr==n:\n\t\t\tbreak\n\n\nmo=10**9 + 7\nans=pow(n,k,mo)\n\nfor i in count:\n\tans=(ans-pow(i,k,mo))%mo\nstdout.write(str(ans)+\"\\n\")\n\n\n\n\n#[[][][][][]]"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long GCD(long long x, long long y) {\n  if (y == 0) return x;\n  return GCD(y, x % y);\n}\nlong long LCM(long long x, long long y) { return (x * y) / (GCD(x, y)); }\nlong long LOGK(long long x, long long k) {\n  if (x >= k) return 1 + LOGK(x / k, k);\n  return 0;\n}\nlong long MPOW(long long a, long long b, long long m) {\n  if (b == 0) return 1;\n  long long x = MPOW(a, b / 2, m);\n  x = (x * x) % m;\n  if (b % 2 == 1) x = (x * a) % m;\n  return x;\n}\nlong long MINV(long long a, long long m) { return MPOW(a, m - 2, m); }\nclass pnc {\n  long long FACT_MAX, MODU;\n  vector<long long> fact;\n\n public:\n  pnc(long long n, long long m) {\n    FACT_MAX = n;\n    fact.resize(FACT_MAX);\n    MODU = m;\n    MFACT_INIT(MODU);\n  }\n  void MFACT_INIT(long long m) {\n    fact[0] = 1;\n    for (long long i = 1; i < FACT_MAX; ++i) fact[i] = (i * fact[i - 1]) % MODU;\n  }\n  long long MFACT(long long n) { return fact[n]; }\n  long long PERM(long long n, long long r) {\n    return (fact[n] * ::MINV(fact[n - r], MODU)) % MODU;\n  }\n  long long COMB(long long n, long long r) {\n    return (PERM(n, r) * ::MINV(fact[r], MODU)) % MODU;\n  }\n};\nlong long n, k;\nvector<pair<long long, long long> > adj[200005];\nbool visited[200005] = {false};\nlong long tans = 0;\nvoid dfs(long long node) {\n  visited[node] = true;\n  tans++;\n  for (auto i : adj[node]) {\n    if (!visited[i.first] && !i.second) {\n      dfs(i.first);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long test = 1;\n  while (test--) {\n    cin >> n >> k;\n    long long x, y, color;\n    for (long long i = 1; i < n; i++) {\n      cin >> x >> y >> color;\n      adj[x].push_back({y, color});\n      adj[y].push_back({x, color});\n    }\n    long long ans = MPOW(n, k, 1000000007);\n    for (long long i = 1; i <= n; i++) {\n      tans = 0;\n      if (!visited[i]) {\n        dfs(i);\n      }\n      long long temp = MPOW(tans, k, 1000000007);\n      ans -= temp - 1000000007;\n      ans %= 1000000007;\n    }\n    cout << ans;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout  \n\nclass UnionFind:\n    def __init__(self):\n        self.sets = {}\n        self.sizes = {}\n    def make_set(self, s):\n        if s in self.sets:\n            return\n        else:\n            self.sets[s] = s\n            self.sizes[s] = 1\n\n    def find(self, s):\n        path = []\n        while s != self.sets[s]:\n            path.append(s)\n            s = self.sets[s]\n        for p in path:\n            self.sets[p] = s\n        return s\n\n    def union(self, s1, s2):\n        a = self.find(s1)\n        b = self.find(s2)\n        if a == b:\n            return\n        self.sets[a] = b\n        self.sizes[b] += self.sizes[a]\n    \n    def num_bad(self, k):\n        res = 0\n        for s in self.sets:\n            if s == self.sets[s]:\n                res += (self.sizes[s] ** k)\n        return res\n\ndef main():\n    n, k = [int(x) for x in stdin.readline().split()]\n    uf = UnionFind()\n    for i in range(1, n + 1):\n        uf.make_set(i)\n    for i in range(n - 1):\n        u, v, c = [int(x) for x in stdin.readline().split()]\n        if c == 0:\n            uf.union(u, v)\n    print(((n ** k) - uf.num_bad(k)) % (10 ** 9 + 7) )\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst long double PI = 4 * atan((long double)1);\nlong long int get_hash(string s) {\n  long long int N = 1000001;\n  long long int base[N], A = 11, MD = 1110111110111;\n  base[0] = 1;\n  for (int i = (1); i < (N); ++i) base[i] = (base[i - 1] * A) % MD;\n  long long int hs = 0;\n  for (int i = (0); i < (s.size()); ++i) {\n    hs += (s[i] * base[i]);\n    hs %= MD;\n  }\n  return hs;\n}\nlong long power(long long a, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n % 2) res = (res % MOD * a % MOD) % MOD;\n    a = (a % MOD * a % MOD) % MOD;\n    n /= 2;\n  }\n  return res % MOD;\n}\nint par(int i, int* dp) {\n  if (i == dp[i]) return i;\n  return (par(dp[i], dp));\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, k;\n  cin >> n >> k;\n  int dp[n + 1];\n  for (int i = (0); i < (n + 1); ++i) dp[i] = i;\n  for (int i = (0); i < (n - 1); ++i) {\n    int x, y, c;\n    cin >> x >> y >> c;\n    if (c == 0) dp[par(x, dp)] = dp[par(y, dp)] = min(par(x, dp), par(y, dp));\n  }\n  map<int, int> mpa;\n  map<int, int>::iterator it;\n  for (int i = (1); i < (n + 1); ++i) mpa[par(i, dp)]++;\n  long long int ans = 0;\n  for (it = mpa.begin(); it != mpa.end(); ++it) {\n    int sp = it->second;\n    long long int x = power(sp, k) % MOD;\n    ans = (ans % MOD + x % MOD) % MOD;\n  }\n  long long int tot = power(n, k) % MOD;\n  cout << (tot - ans + MOD) % MOD;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ck;\nint mod = 1e9 + 7;\nbool visited[200005];\nvector<long long> v[200005];\nlong long powr(long long c, long long d) {\n  long long val = 1;\n  while (d) {\n    if (d & 1) val = (c * val) % mod;\n    d /= 2;\n    c = (c * c) % mod;\n  }\n  return val;\n}\nvoid dfs(long long p) {\n  if (visited[p]) return;\n  ck++;\n  visited[p] = 1;\n  for (int i = 0; i < v[p].size(); ++i) {\n    dfs(v[p][i]);\n  }\n}\nlong long a[200005];\nint main() {\n  long long n, k;\n  cin >> n >> k;\n  long long ans = 0;\n  ans = powr(n, k);\n  for (int i = 0; i < n; ++i) {\n    long long x, y, z;\n    cin >> x >> y >> z;\n    if (z == 0) {\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n  }\n  long long mor = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (visited[i]) continue;\n    ck = 0;\n    dfs(i);\n    mor = powr(ck, k);\n    ans -= mor;\n    ans += mod;\n    ans %= mod;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int M = 1e9 + 7;\nint a[N];\nint parent[N], rnk[N];\nint ct[N];\nvoid make(int v) {\n  parent[v] = v;\n  rnk[v] = 0;\n  ct[v] = 1;\n}\nint find(int v) {\n  if (parent[v] != v) parent[v] = find(parent[v]);\n  return parent[v];\n}\nvoid Union(int a, int b) {\n  a = find(a);\n  b = find(b);\n  if (a != b) {\n    if (rnk[a] < rnk[b]) swap(a, b);\n    parent[b] = a;\n    ct[a] += ct[b];\n    if (rnk[a] == rnk[b]) rnk[a]++;\n  }\n}\nint binexp1(int a, int b, int m) {\n  int result = 1;\n  while (b > 0) {\n    if (b & 1) {\n      result = (result * 1LL * a) % m;\n    }\n    a = (a * 1LL * a) % m;\n    b >>= 1;\n  }\n  return result;\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i <= n; ++i) {\n    make(i);\n  }\n  int ans = binexp1(n, k, M);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    if (x == 0) {\n      Union(u, v);\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (find(i) == i) {\n      ans = (ans - binexp1(ct[i], k, M) + M) % M;\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\ninline void read(T &x) {\n  char c;\n  bool nega = 0;\n  while ((!isdigit(c = getchar())) && (c != '-'))\n    ;\n  if (c == '-') {\n    nega = 1;\n    c = getchar();\n  }\n  x = c - 48;\n  while (isdigit(c = getchar())) x = x * 10 + c - 48;\n  if (nega) x = -x;\n}\ntemplate <typename T>\ninline void writep(T x) {\n  if (x > 9) writep(x / 10);\n  putchar(x % 10 + 48);\n}\ntemplate <typename T>\ninline void write(T x) {\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  writep(x);\n  putchar(' ');\n}\ntemplate <typename T>\ninline void writeln(T x) {\n  write(x);\n  putchar('\\n');\n}\nusing namespace std;\nconst int mod = 1000000007;\nint n, k, sz[100005], par[100005], ans;\npair<pair<int, int>, int> ed[100005];\nvector<int> a[100005];\nvoid Dfs(int u) {\n  sz[u] = 1;\n  for (int v : a[u]) {\n    if (v == par[u]) continue;\n    par[v] = u;\n    Dfs(v);\n    sz[u] += sz[v];\n  }\n}\nint Pow(int a, int b) {\n  int res = 1;\n  for (; b; a = (1ll * a * a) % mod, b >>= 1)\n    if (b & 1) res = (1ll * res * a) % mod;\n  return res;\n}\nint Mul(int x, int y) { return (1ll * x * y) % mod; }\nvoid Add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\nvoid Sub(int &x, int y) {\n  x -= y;\n  if (x < 0) x += mod;\n}\nint main() {\n  ios_base::sync_with_stdio(NULL);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> k;\n  for (int i = (1); i <= (n - 1); ++i) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    ed[i] = {{x, y}, z};\n    if (z) continue;\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  ans = Pow(n, k);\n  for (int i = (1); i <= (n); ++i) {\n    if (sz[i]) continue;\n    Dfs(i);\n    Sub(ans, Pow(sz[i], k));\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Solu {\n    static StringBuffer str = new StringBuffer();\n    static InputReader in = new InputReader(System.in);\n    static int mm = 1000000007;\n    static int n;\n    static ArrayList<Integer> tree[];\n    static boolean vis[];\n    static long cnt=0;\n    public static void main(String[] args) {\n        int t, i, j, tt, m,k;\n        t = 1;\n        for (tt = 0; tt < t; tt++) {\n            n=in.nextInt();\n            tree=new ArrayList[n];\n            vis=new boolean[n];\n            for(i=0;i<n;i++){\n                tree[i]=new ArrayList<>();\n            }\n            k=in.nextInt();\n            for(i=0;i<n-1;i++){\n                int x=in.nextInt()-1;\n                int y=in.nextInt()-1;\n                int col=in.nextInt();\n                if(col==0){\n                    tree[x].add(y);\n                    tree[y].add(x);\n                }\n            }\n            long ans=0;\n            for(i=0;i<n;i++){\n                if(!vis[i]){\n                    cnt=0;\n                    dfs(i);\n                    ans=(ans+power(cnt,k,mm))%mm;\n                }\n            }\n            long hp=(power(n,k,mm)-ans+mm)%mm;\n            ap(hp+\"\\n\");\n        }\n        pn();\n    }\n    static void dfs(int x){\n        vis[x]=true;\n        cnt++;\n        for(Integer it:tree[x]){\n            if(!vis[it]){\n                dfs(it);\n            }\n        }\n    }\n    static class hog {\n\n        char ch;\n    }\n    static final Comparator<Entity> com = new Comparator<Entity>() {\n        public int compare(Entity x, Entity y) {\n            int xx = Integer.compare(x.a, y.a);\n            if (xx == 0) {\n                return Long.compare(y.c, x.c);\n            } else {\n                return xx;\n            }\n        }\n    };\n\n    static class Pair {\n\n        int a, b, c;\n\n        Pair(int x, int y, int z) {\n            a = x;\n            b = y;\n            c = z;\n        }\n    }\n\n    static class Entity {\n\n        int a;\n        int c;\n\n        Entity(int p, int q) {\n            a = p;\n            c = q;\n        }\n    }\n\n    static long gcd(long a, long b) {\n        return (b == 0) ? a : gcd(b, a % b);\n    }\n\n    static int gcdi(int a, int b) {\n        return (b == 0) ? a : gcdi(b, a % b);\n    }\n\n    static long power(long x, int y, int m) {\n        if (y == 0) {\n            return 1;\n        }\n        long p = power(x, y / 2, m) % m;\n        p = (p * p) % m;\n        return (y % 2 == 0) ? p : (x * p) % m;\n    }\n\n    public static void ap(String st) {\n        str.append(st);\n    }\n\n    public static void pn() {\n        System.out.println(str);\n    }\n\n    static class InputReader {\n\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int peek() {\n            if (numChars == -1) {\n                return -1;\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar];\n        }\n\n        public void skip(int x) {\n            while (x-- > 0) {\n                read();\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String nextString() {\n            return next();\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuffer buf = new StringBuffer();\n            int c = read();\n            while (c != '\\n' && c != -1) {\n                if (c != '\\r') {\n                    buf.appendCodePoint(c);\n                }\n                c = read();\n            }\n            return buf.toString();\n        }\n\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E') {\n                    return res * Math.pow(10, nextInt());\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E') {\n                        return res * Math.pow(10, nextInt());\n                    }\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public boolean hasNext() {\n            int value;\n            while (isSpaceChar(value = peek()) && value != -1) {\n                read();\n            }\n            return value != -1;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace zyt {\nconst int N = 1e5 + 10, K = 110, p = 1e9 + 7;\nint n, k, ans;\nint fa[N], size[N];\nint f(const int x) { return x == fa[x] ? x : fa[x] = f(fa[x]); }\nint power(int a, int b) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = (long long)ans * a % p;\n    a = (long long)a * a % p;\n    b >>= 1;\n  }\n  return ans;\n}\nint work() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; i++) fa[i] = i, size[i] = 1;\n  for (int i = 1; i < n; i++) {\n    int a, b, x;\n    scanf(\"%d%d%d\", &a, &b, &x);\n    if (!x) size[f(b)] += size[f(a)], fa[f(a)] = f(b);\n  }\n  for (int i = 1; i <= n; i++)\n    if (fa[i] == i) ans = (ans + power(size[i], k)) % p;\n  printf(\"%d\", (power(n, k) - ans + p) % p);\n  return 0;\n}\n}  // namespace zyt\nint main() { return zyt::work(); }\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\n/* abhi2601 */\n\npublic class Q2 implements Runnable{\n\n    final static long mod = (long)1e9 + 7;\n    ArrayList<Integer>[]a;\n    boolean visited[];\n    HashMap<String,Integer>hm=new HashMap<>();\n    int c=0;\n    static long gcd(long x,long y){\n        if(y==0) return x;\n        else return gcd(y,x%y);\n    }\n    void DFS(int v,boolean visited[])\n    {\n        visited[v] = true;\n        System.out.print(v+\" \");\n        Iterator<Integer> i = a[v].listIterator();\n        while (i.hasNext())\n        {\n            int n = i.next();\n            if (!visited[n])\n                DFS(n,visited);\n        }\n    }\n    void BFS(int v){\n        Queue<Integer>q=new LinkedList<>();\n        q.add(v);\n        Iterator<Integer>i=a[v].iterator();\n        while(i.hasNext()){\n            int x=i.next();\n            String s=v+\"-\"+x;\n            if(!visited[x] && hm.get(s).equals(0)){\n                //System.out.println(v+\" \"+x);\n                visited[x]=true;\n                c++;\n                q.add(x);\n                BFS(x);\n\n            }\n        }\n    }\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        a=new ArrayList[n+1];\n        String s;\n        for(int i=0;i<=n;i++){\n            a[i]=new ArrayList<>();\n        }\n        for(int i=1;i<n;i++){\n            int a1=sc.nextInt();\n            int a2=sc.nextInt();\n            int x=sc.nextInt();\n            a[a1].add(a2);\n            a[a2].add(a1);\n            s=a1+\"-\"+a2;\n            hm.put(s,x);\n            s=a2+\"-\"+a1;\n            hm.put(s,x);\n        }\n        visited=new boolean[n+1];\n        int aa[]=new int[n+1];\n        for(int i=1;i<=n;i++){\n            if(!visited[i]){\n                visited[i]=true;\n                c=1;\n                BFS(i);\n                aa[c]++;\n                //w.println(i+\" \"+c);\n            }\n        }\n        long fre[]=new long[n+1];\n        long p;\n        for(int i=1;i<=n;i++){\n            p=1L;\n            for(int j=1;j<=k;j++){\n                p=(p*(long)i)%mod;\n            }\n            fre[i]=p;\n        }\n        long ans=fre[n];\n        for(int i=1;i<=n;i++){\n            if(aa[i]>0){\n                long temp=((long)aa[i]*fre[i])%mod;\n                ans=(ans+mod-temp)%mod;\n            }\n        }\n        w.println(ans);\n        w.close();\n    }\n\n    static class InputReader {\n\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream)\n        {\n            this.stream = stream;\n        }\n\n        public int read()\n        {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars)\n            {\n                curChar = 0;\n                try\n                {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e)\n                {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine()\n        {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt()\n        {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do\n            {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.')\n            {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.')\n            {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c))\n                {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c)\n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next()\n        {\n            return readString();\n        }\n\n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static void main(String args[]) throws Exception\n    {\n        new Thread(null, new Q2(),\"cf3\",1<<26).start();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "// Created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class C\n{\n    private static final long MOD=1000000007;\n    private static int vis[];\n    private static ArrayList<Pair>[] edge;\n    private static ArrayDeque<Integer> DQ;\n    static class Pair\n    {\n        int a,b;\n        Pair(int a, int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n\n    private static long DFS(int i)\n    {\n        int count=1,v,x;\n        vis[i]=1;\n\n        for(Pair obj:edge[i])\n        {\n            v=obj.a;\n            x=obj.b;\n\n            if(vis[v]==0)\n            {\n                if(x==1)\n                    DQ.add(v);\n                else\n                    count+=DFS(v);\n            }\n        }\n\n        return count;\n    }\n\n    private static long pow(long x, long a)\n    {\n            if(a==0)\n                return 1;\n            long ans=pow(x,a/2);\n\n            ans=(ans*ans)%MOD;\n\n            if((a&1)==1)\n                ans=(ans*x)%MOD;\n\n            return ans%MOD;\n    }\n\n    private static long pow2(long x, long a)\n    {\n        long res=1;\n\n        while(a>0)\n        {\n            if((a&1)==1)\n                res=(res*x)%MOD;\n\n            x=(x*x)%MOD;\n            a>>=1;\n        }\n\n        return res%MOD;\n    }\n\n\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N,k,u,v,x;\n        long count=0,tmp,tmp2,total;\n\n        String s[]=br.readLine().trim().split(\" \");\n        N=Integer.parseInt(s[0]);\n        k=Integer.parseInt(s[1]);\n\n        vis=new int[N+1];\n        edge=new ArrayList[N+1];\n        DQ=new ArrayDeque<>();\n        for(i=0;i<=N;i++)\n            edge[i]=new ArrayList<>();\n\n        total=pow2(N,k);\n\n        for(i=1;i<=N-1;i++)\n        {\n            s=br.readLine().trim().split(\" \");\n            u=Integer.parseInt(s[0]);\n            v=Integer.parseInt(s[1]);\n            x=Integer.parseInt(s[2]);\n\n            edge[u].add(new Pair(v,x));\n            edge[v].add(new Pair(u,x));\n        }\n\n        DQ.add(1);\n        while(!DQ.isEmpty())\n        {\n            tmp=DFS(DQ.poll());\n            tmp2=pow2(tmp,k);\n            count=(count+tmp2)%MOD;\n        }\n\n        total-=count;\n        while(total<0)\n            total+=MOD;\n\n        System.out.println(total);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e5 + 5;\nvector<int> adj[M];\nlong long int visited[M], cnt;\nlong long int BIG(long long int base, long long int power) {\n  if (power == 0) return 1;\n  if (power == 1) return base;\n  long long int val = BIG(base, power / 2) % 1000000007;\n  if (power % 2)\n    return ((base % 1000000007) *\n            (((val % 1000000007) * (val % 1000000007)) % 1000000007)) %\n           1000000007;\n  else\n    return ((val % 1000000007) * (val % 1000000007)) % 1000000007;\n}\nvoid DFS(int u) {\n  visited[u] = 1;\n  cnt++;\n  for (int v : adj[u]) {\n    if (!visited[v]) {\n      DFS(v);\n    }\n  }\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v, color;\n    cin >> u >> v >> color;\n    if (color == 0) {\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n  }\n  long long int ans = BIG(n, k) % 1000000007;\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      cnt = 0;\n      DFS(i);\n      ans -= BIG(cnt, k);\n    }\n  }\n  ans = (ans + 1000000007) % 1000000007;\n  if (ans < 0) ans += 1000000007;\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*; \nimport java.io.BufferedReader; \nimport java.io.InputStreamReader; \nimport java.util.StringTokenizer; \nimport java.io.IOException; \nimport java.math.*;\n\n\npublic class cp{\n\n    static long pow(long x, long y, long p){ \n\n        // Initialize result \n        long res = 1;      \n         \n        // Update x if it is more   \n        // than or equal to p \n        x = x % p;  \n      \n        while (y > 0) \n        { \n            // If y is odd, multiply x \n            // with result \n            if((y & 1)==1) \n                res = (res * x) % p; \n      \n            // y must be even now \n            // y = y / 2 \n            y = y >> 1;  \n            x = (x * x) % p;  \n        } \n        return res; \n    }\n\n    public static void main(String[] args) throws IOException{\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer s = new StringTokenizer(br.readLine());\n        \n        int n = Integer.parseInt(s.nextToken());\n\n        int k = Integer.parseInt(s.nextToken());\n\n        ArrayList[] adjList = new ArrayList[n];\n        for(int i = 0;i < n; i ++){\n            adjList[i] = new ArrayList<Integer>();\n        }\n        for(int i = 0; i < n - 1; i ++){\n            s = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(s.nextToken()) - 1;\n            int b = Integer.parseInt(s.nextToken()) - 1;   \n            int c = Integer.parseInt(s.nextToken());\n\n            if(c == 0){\n                adjList[a].add(b);\n                adjList[b].add(a);\n            }\n        }\n\n        boolean[] visited = new boolean[n];\n        ArrayList components = new ArrayList();\n        for(int i = 0; i < n; i ++){\n            if(visited[i]){\n                continue;\n            }\n\n            Stack stack = new Stack();\n            stack.push(i);\n            visited[i] = true;\n            int count = 0;\n            while(!stack.isEmpty()){\n                int curr = (int)stack.pop();\n                count += 1;\n\n                for(int j = 0; j < adjList[curr].size(); j ++){\n                    if(visited[(int)adjList[curr].get(j)]){\n                        continue;\n                    }\n\n                    stack.push((int)adjList[curr].get(j));\n                    visited[(int)adjList[curr].get(j)] = true;\n                }\n            }\n\n            components.add(count);\n        }\n\n\n        long ans = pow(n, k, 1000000007);\n        // System.out.println(ans + \" \" + n + k);\n        for(int i = 0; i < components.size(); i ++){\n\n            ans = (ans - pow((int)components.get(i), k, 1000000007));\n            if( ans < 0){\n                ans = 1000000007 + ans;\n            }\n            // System.out.println(ans);\n        }\n\n        System.out.println(ans);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class Main {\n\tprivate static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static int mod = 1000000007;\n\tstatic long power(long x, long y, int p) \n    { \n        // Initialize result \n        long res = 1;      \n         \n        // Update x if it is more   \n        // than or equal to p \n        x = x % p;  \n      \n        while (y > 0) \n        { \n            // If y is odd, multiply x \n            // with result \n            if((y & 1)==1) \n                res = (res * x) % p; \n      \n            // y must be even now \n            // y = y / 2 \n            y = y >> 1;  \n            x = (x * x) % p;  \n        } \n        return res; \n    } \n\tprivate static int n;\n\tprivate static int k;\n\tprivate static ArrayList<Integer> gr[];\n\tprivate static boolean v[];\n\t\n\tprivate static int dfs(int x) {\n\t\tv[x] = true;\n\t\tint ans = 1;\n\t\tfor(int y: gr[x]) {\n\t\t\tif(!v[y]) ans += dfs(y);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tString s[] = br.readLine().trim().split(\" \");\n\t\tn = Integer.parseInt(s[0]);\n\t\tk = Integer.parseInt(s[1]);\n\t\tgr = new ArrayList[n+1];\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tgr[i] = new ArrayList<Integer>();\n\t\t}\n\t\tv = new boolean[n+1];\n\t\tfor(int i = 0; i < n-1; i++) {\n\t\t\ts = br.readLine().trim().split(\" \");\n\t\t\tif(Integer.parseInt(s[2]) == 0) {\n\t\t\t\tint x = Integer.parseInt(s[0]);\n\t\t\t\tint y = Integer.parseInt(s[1]);\n\t\t\t\tgr[x].add(y);\n\t\t\t\tgr[y].add(x);\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tif(!v[i]) {\n\t\t\t\tans = (ans + power(dfs(i), k, mod))%mod;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((power(n,k,mod)-ans+mod)%mod);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class C {\n    class Pair {\n        int to;\n        int c;\n\n        public Pair(int to, int c) {\n            this.to = to;\n            this.c = c;\n        }\n    }\n\n    int mod = 1000000007;\n\n    long pow(long a, int n) {\n        long res = 1;\n        while (n > 0) {\n            if (n % 2 == 1)\n                res = (res * a) % mod;\n            a = (a * a) % mod;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    public void solve() throws IOException {\n        int n = nextInt();\n        int k = nextInt();\n        ArrayList<Pair>[] g = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            g[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int x = nextInt() - 1;\n            int y = nextInt() - 1;\n            int c = nextInt();\n            Pair v1 = new Pair(y, c);\n            Pair v2 = new Pair(x, c);\n            if (c == 0) {\n                g[x].add(v1);\n                g[y].add(v2);\n            }\n        }\n        ArrayList<Integer> ks = new ArrayList<>();\n        boolean[] used = new boolean[n];\n        Stack<Integer> dfs = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                int count = 1;\n                used[i] = true;\n                dfs.add(i);\n                while (!dfs.isEmpty()) {\n                    int cur = dfs.pop();\n                    for (int j = 0; j < g[cur].size(); j++) {\n                        int t = g[cur].get(j).to;\n                        if (!used[t]) {\n                            dfs.add(t);\n                            used[t] = true;\n                            count++;\n                        }\n                    }\n                }\n                ks.add(count);\n            }\n        }\n        long ans = pow(n, k);\n        for (int i = 0; i < ks.size(); i++) {\n            ans = ((ans - pow(ks.get(i), k) + ks.get(i))+mod) % mod;\n        }\n        System.out.println(Math.max(0, ans - n));\n    }\n\n\n    public void run() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    BufferedReader br;\n    StringTokenizer in;\n    PrintWriter out;\n\n    public String nextToken() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n        return in.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    public int[] nextArr(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nextInt();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        Locale.setDefault(Locale.US);\n        new C().run();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n;\nconst long long INF64 = 0X3F3F3F3F3F3F3F3F;\nconst int INF32 = 0x3F3F3F3F;\nconst int mod = 1e9 + 7;\nconst int mod2 = 1e9 + 9;\nconst int N = 2e5 + 2;\nlong long quickpow(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = a * ans % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return ans;\n}\nvector<long long> fa, mark;\nint ffind(int x) {\n  if (x != fa[x]) {\n    return fa[x] = ffind(fa[x]);\n  }\n  return x;\n}\nvoid uunion(int x, int y) {\n  int a = ffind(x), b = ffind(y);\n  if (a < b) swap(a, b);\n  fa[b] = a;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int n, k;\n  cin >> n >> k;\n  fa.resize(n + 1);\n  mark.resize(n + 1);\n  for (int i = 0; i <= n; ++i) {\n    fa[i] = i;\n  }\n  long long u, v, t;\n  for (int i = 0; i < n - 1; ++i) {\n    cin >> u >> v >> t;\n    if (!t) uunion(u, v);\n  }\n  for (int i = 1; i <= n; ++i) ++mark[ffind(i)];\n  t = 0;\n  for (int i = 1; i <= n; ++i)\n    if (mark[i]) t = (t + quickpow(mark[i], k)) % mod;\n  cout << (quickpow(n, k) - t + mod) % mod << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int M = 1e9 + 7;\nconst long long int N = 2e5 + 5;\nvector<long long int> visited(N, 0);\nvector<vector<long long int> > g(N);\nlong long int sz = 0;\nlong long int pow(long long int a, long long int b, long long int M) {\n  long long int ans = 1;\n  while (b) {\n    if (b & 1) {\n      ans = (ans * a) % M;\n    }\n    b = b / 2;\n    a = (a * a) % M;\n  }\n  return ans;\n}\nvoid dfs(long long int ik) {\n  if (visited[ik] == 1) return;\n  sz++;\n  visited[ik] = 1;\n  for (long long int k = 0; k < g[ik].size(); k++) {\n    dfs(g[ik][k]);\n  }\n}\nint main() {\n  long long int n, k;\n  cin >> n >> k;\n  long long int ans = pow(n, k, M);\n  for (long long int i = 1; i < n; i++) {\n    long long int u, v, l;\n    cin >> u >> v >> l;\n    if (l == 0) {\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n  }\n  for (long long int i = 1; i <= n; i++) {\n    if (visited[i] == 1) continue;\n    sz = 0;\n    dfs(i);\n    ans = ans - pow(sz, k, M);\n    ans = ans + M;\n    ans = ans % M;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport com.sun.org.apache.xpath.internal.operations.Mod;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Q2 {\n\n    static int BFSList(ArrayList<Integer> graph[],int visit[],int m,int val){\n\n        LinkedList<Integer> check=new LinkedList<>();\n        check.add(m);\n        visit[m]=1;\n        val++;\n\n        while(true){\n            if(check.isEmpty())\n                return val;\n            int data=check.remove();\n           // System.out.print(data+\" \");\n\n            for(int i=0;i<graph[data].size();i++){\n                if(visit[graph[data].get(i)]==0) {\n                    check.add(graph[data].get(i));\n                    visit[graph[data].get(i)]=1;\n                    val++;\n                }\n            }\n\n        }\n\n    }\n\n\n    public static void main(String[] args) {\n\n        InputReader in = new InputReader();\n        int N = in.nextInt();\n\n        ArrayList<Integer>[] input = new ArrayList[N+1];\n        int k = in.nextInt();\n        int mod=(int)1e9+7;\n\n        for (int i = 1; i < N; i++) {\n            int a = in.nextInt(), b = in.nextInt(), c = in.nextInt();\n            if (input[a] == null)\n                input[a] = new ArrayList<>();\n            if (input[b] == null)\n                input[b] = new ArrayList<>();\n\n            if (c == 0) {\n                input[a].add(b);\n                input[b].add(a);\n            }\n        }\n\n        long FinalAns=ModMultiIteBetter(N,k,mod);\n\n        int visit[]=new int [N+1];\n\n\n        int val;\n        for(int i=1;i<=N;i++) {\n            if(visit[i]==0){\n                val=0;\n              val=BFSList(input,visit,i,val);\n              long tempAns=ModMultiIteBetter(val,k,mod);\n              FinalAns=(FinalAns-tempAns+mod)%mod;\n            }\n        }\n        long ans=(FinalAns )% mod;\n        System.out.println(ans);\n\n    }\n\n    static long ModMultiIteBetter(int a, int b, int c) {\n\n        if (b == 0)\n            return 1;\n\n        long sol = 1;\n\n        while (b != 0) {\n            int temp1 = b & 1;\n            if (temp1 == 1)\n                sol = (int) (((long) (a % c) * (sol % c)) % c);\n            a = (int) ((((long) a % c) * (a % c)) % c);\n            b = b / 2;\n        }\n\n        return sol;\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public int[] shuffle(int[] arr) {\n            Random r = new Random();\n            for (int i = 1, j; i < arr.length; i++) {\n                j = r.nextInt(i);\n                arr[i] = arr[i] ^ arr[j];\n                arr[j] = arr[i] ^ arr[j];\n                arr[i] = arr[i] ^ arr[j];\n            }\n            return arr;\n        }\n\n        public InputReader() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public char nextChar() {\n            return next().charAt(0);\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArr(int n) {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = this.nextInt();\n            }\n            return arr;\n        }\n\n        public Integer[] nextIntegerArr(int n) {\n            Integer[] arr = new Integer[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = new Integer(this.nextInt());\n\n            return arr;\n        }\n\n        public int[][] next2DIntArr(int n, int m) {\n            int[][] arr = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    arr[i][j] = this.nextInt();\n                }\n            }\n            return arr;\n        }\n\n        public int[] nextSortedIntArr(int n) {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = this.nextInt();\n            }\n            Arrays.sort(arr);\n            return arr;\n        }\n\n        public long[] nextLongArr(int n) {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = this.nextLong();\n            }\n            return arr;\n        }\n\n        public char[] nextCharArr(int n) {\n            char[] arr = new char[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = this.nextChar();\n            }\n            return arr;\n        }\n\n\n        public static int gcd(int a, int b) {\n            return b == 0 ? a : gcd(b, a % b);\n        }\n\n        public static int[] uwiSieve(int n) {\n            if (n <= 32) {\n                int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\n                for (int i = 0; i < primes.length; i++) {\n                    if (n < primes[i]) {\n                        return Arrays.copyOf(primes, i);\n                    }\n                }\n                return primes;\n            }\n\n            int u = n + 32;\n            double lu = Math.log(u);\n            int[] ret = new int[(int) (u / lu + u / lu / lu * 1.5)];\n            ret[0] = 2;\n            int pos = 1;\n\n            int[] isp = new int[(n + 1) / 32 / 2 + 1];\n            int sup = (n + 1) / 32 / 2 + 1;\n\n            int[] tprimes = {3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\n            for (int tp : tprimes) {\n                ret[pos++] = tp;\n                int[] ptn = new int[tp];\n                for (int i = (tp - 3) / 2; i < tp << 5; i += tp)\n                    ptn[i >> 5] |= 1 << (i & 31);\n                for (int i = 0; i < tp; i++) {\n                    for (int j = i; j < sup; j += tp)\n                        isp[j] |= ptn[i];\n                }\n            }\n\n            // 3,5,7\n            // 2x+3=n\n            int[] magic = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17,\n                    9, 6, 16, 5, 15, 14};\n            int h = n / 2;\n            for (int i = 0; i < sup; i++) {\n                for (int j = ~isp[i]; j != 0; j &= j - 1) {\n                    int pp = i << 5 | magic[(j & -j) * 0x076be629 >>> 27];\n                    int p = 2 * pp + 3;\n                    if (p > n)\n                        break;\n                    ret[pos++] = p;\n                    for (int q = pp; q <= h; q += p)\n                        isp[q >> 5] |= 1 << (q & 31);\n                }\n            }\n\n            return Arrays.copyOf(ret, pos);\n        }\n\n        public static int[] radixSort(int[] f) {\n            return radixSort(f, f.length);\n        }\n\n        public static int[] radixSort(int[] f, int n) {\n            int[] to = new int[n];\n            {\n                int[] b = new int[65537];\n                for (int i = 0; i < n; i++) b[1 + (f[i] & 0xffff)]++;\n                for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n                for (int i = 0; i < n; i++) to[b[f[i] & 0xffff]++] = f[i];\n                int[] d = f;\n                f = to;\n                to = d;\n            }\n            {\n                int[] b = new int[65537];\n                for (int i = 0; i < n; i++) b[1 + (f[i] >>> 16)]++;\n                for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n                for (int i = 0; i < n; i++) to[b[f[i] >>> 16]++] = f[i];\n                int[] d = f;\n                f = to;\n                to = d;\n            }\n            return f;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mpow(long long a, long long b, long long p) {\n  long long ans = 1;\n  a %= p;\n  while (b) {\n    if (b & 1) ans = ans * a % p;\n    a = a * a % p;\n    b >>= 1;\n  }\n  return ans;\n}\nint n, k;\nconst long long p = 1e9 + 7;\nmap<int, size_t> mp;\nnamespace UFS {\nint f[200000 + 2];\nvoid init(int n = 200000) {\n  for (long long i = (0); i < (n + 1); ++i) {\n    f[i] = i;\n  }\n}\nint fd(int nd) { return (f[nd] == nd ? nd : f[nd] = fd(f[nd])); }\nvoid cmb(int a, int b) { f[fd(b)] = fd(a); }\n}  // namespace UFS\nusing namespace UFS;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  init();\n  int u, v, x;\n  for (long long i = (0); i < (n - 1); ++i) {\n    cin >> u >> v >> x;\n    if (!x) cmb(u, v);\n  }\n  for (long long i = (1); i < (n + 1); ++i) mp[fd(i)]++;\n  long long ans = mpow(n, k, p);\n  for (auto &pir : mp) {\n    ans = (ans - mpow(pir.second, k, p) + p) % p;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MODULUS = 1_000_000_007;\n\n    public static void main(String[] args) {\n\tScanner sc = new Scanner(System.in);\n\n\tint n = sc.nextInt();\n\tint k = sc.nextInt();\n\tint[] u = new int[n - 1];\n\tint[] v = new int[n - 1];\n\tint[] x = new int[n - 1];\n\tfor (int i = 0; i < n - 1; i++) {\n\t    u[i] = sc.nextInt();\n\t    v[i] = sc.nextInt();\n\t    x[i] = sc.nextInt();\n\t}\n\tSystem.out.println(solve(u, v, x, k));\n\n\tsc.close();\n    }\n\n    static int solve(int[] u, int[] v, int[] x, int k) {\n\tint n = u.length + 1;\n\n\tint[] parents = new int[n];\n\tArrays.fill(parents, -1);\n\n\tfor (int i = 0; i < x.length; i++) {\n\t    if (x[i] == 0) {\n\t\tint root1 = findRoot(parents, u[i] - 1);\n\t\tint root2 = findRoot(parents, v[i] - 1);\n\n\t\tif (root1 != root2) {\n\t\t    parents[root2] = root1;\n\t\t}\n\t    }\n\t}\n\n\tMap<Integer, Integer> rootToCount = new HashMap<>();\n\tfor (int i = 0; i < n; i++) {\n\t    int root = findRoot(parents, i);\n\n\t    rootToCount.put(root, rootToCount.getOrDefault(root, 0) + 1);\n\t}\n\n\tint result = powMod(n, k);\n\tfor (int count : rootToCount.values()) {\n\t    result = subtractMod(result, powMod(count, k));\n\t}\n\n\treturn result;\n    }\n\n    static int findRoot(int[] parents, int node) {\n\tint root = node;\n\twhile (parents[root] != -1) {\n\t    root = parents[root];\n\t}\n\n\tint p = node;\n\twhile (p != root) {\n\t    int next = parents[p];\n\t    parents[p] = root;\n\n\t    p = next;\n\t}\n\n\treturn root;\n    }\n\n    static int powMod(int base, int exponent) {\n\tint result = 1;\n\tfor (int i = 0; i < exponent; i++) {\n\t    result = multiplyMod(result, base);\n\t}\n\n\treturn result;\n    }\n\n    static int subtractMod(int x, int y) {\n\treturn (x - y + MODULUS) % MODULUS;\n    }\n\n    static int multiplyMod(int x, int y) {\n\treturn (int) ((long) x * y % MODULUS);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class Main\n{\n    static final long mod=(int)1e9+7;\n    static ArrayList<pair>[] adj;\n    static boolean[] visited;\n    public static void main(String[] args) throws Exception\n    {\n    \tFastReader in=new FastReader();\n    \tPrintWriter pw=new PrintWriter(System.out);\n    \tint n=in.nextInt();\n    \tint k=in.nextInt();\n    \tadj=new ArrayList[n+1];\n    \tvisited=new boolean[n+1];\n    \tfor(int i=1;i<=n;i++)\n    \t\tadj[i]=new ArrayList();\n    \tfor(int i=1;i<n;i++)\n    \t{\n    \t\tint a=in.nextInt();\n    \t\tint b=in.nextInt();\n    \t\tint c=in.nextInt();\n    \t\tadj[a].add(new pair(b,c));\n    \t\tadj[b].add(new pair(a,c));\n    \t}\n    \tlong ans=fastMod((long)n,k);\n    \tfor(int i=1;i<=n;i++)\n    \t{\n    \t\tlong a=dfs(i);\n    \t\tans-=fastMod(a,k);\n    \t\twhile(ans<0)\n    \t\t\tans+=mod;\n    \t}\n    \tpw.println(ans);\n    \tpw.flush();\n    }\n\n    static long dfs(int a)\n    {\n    \tif(visited[a])\n    \t\treturn 0;\n    \tvisited[a]=true;\n    \tlong r=1;\n    \tfor(pair p:adj[a])\n    \t{\n    \t\tif(p.e==0)\n    \t\t\tr+=dfs(p.v);\n    \t}\n\n    \treturn r;\n    }\n\n    static long fastMod(long n,int k)\n    {\n    \tlong r=1;\n\n    \twhile(k>0)\n    \t{\n    \t\tif((k&1)==1)\n    \t\t{\n    \t\t\tr=(r*n)%mod;\n    \t\t}\n    \t\tn=(n*n)%mod;\n    \t\tk>>=1;\n    \t}\n\n    \treturn r;\n    }\n}\n\nclass pair\n{\n\tint v,e;\n\n\tpublic pair(int a,int b)\n\t{\n\t\tv=a;\n\t\te=b;\n\t}\n}\n\nclass FastReader\n{\n    BufferedReader br;\n    StringTokenizer st;\n \n    public FastReader()\n    {\n        br=new BufferedReader(new InputStreamReader(System.in));\n    }\n \n    public String next() throws IOException\n    {\n        if(st==null || !st.hasMoreElements())\n        {\n            st=new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n \n    public int nextInt() throws IOException\n    {\n        return Integer.parseInt(next());\n    }\n \n    public long nextLong() throws IOException\n    {\n        return Long.parseLong(next());\n    }\n}"
        },
        {
            "language": 4,
            "solution": "//package math_codet;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class lets_do {\n    FastReader in;\n    PrintWriter out;\n    Helper_class h;\n    final long mod = 1000000007;\n    final int MAXN = 1000005;\n    final int lgN = 20;\n    final long INF = (long)1e18;\n    final long MAX_Ai = (long)1e12;\n    public static void main(String[] args) throws java.lang.Exception{\n        new lets_do().run();\n    }\n    void run() throws Exception{\n        in=new FastReader(System.in);\n        out = new PrintWriter(System.out);\n        h = new Helper_class();\n        int t = 1;\n        while(t--> 0)\n            solve();\n        out.flush();\n        out.close();\n    }\n    int cnt;\n    ArrayList<Edge>[] tree;\n    boolean[] vis;\n    void dfs(int v){\n        vis[v] = true;\n        cnt++;\n        for(Edge e : tree[v]){\n            int u = e.other(v);\n            if(!vis[u] && e.wt == 0)\n                dfs(u);\n        }\n    }\n    void solve(){\n        int n = h.ni();\n        int k = h.ni();\n        tree = new ArrayList[n];\n        int i = 0;\n        for(i = 0; i < n; i++)\n            tree[i] = new ArrayList<Edge>();\n        vis = new boolean[n];\n        for(i = 0; i < n - 1; i++){\n            int u = h.ni() - 1;\n            int v = h.ni() - 1;\n            int col = h.ni();\n            Edge e = new Edge(u, v, col);\n            tree[u].add(e);\n            tree[v].add(e);\n        }\n        long sum = 0;\n        for(i = 0; i < n; i++){\n            if(!vis[i]){\n                cnt = 0;\n                dfs(i);\n                sum += h.modPow(cnt, k);\n                sum -= cnt;\n                sum += mod;\n                sum %= mod;\n            }\n        }\n        sum += n;\n        long ans = h.modPow(n, k);\n        ans -= sum;\n        ans += mod;\n        h.pn(ans % mod);\n    }\n\n\n\n    static final Comparator<Pair> com=new Comparator<Pair>(){\n        public int compare(Pair a, Pair b){\n            if(Integer.compare(a.x, b.x) != 0)\n                return Integer.compare(a.x, b.x);\n            else\n                return Integer.compare(a.y, b.y);\n        }\n    };\n\n    class Pair{\n        int x;\n        int y;\n        Pair(int p, int q){\n            x = p;\n            y = q;\n        }\n    }\n    class Edge{\n        int u , v;\n        int wt;\n        Edge(int a, int b, int w){\n            u = a;\n            v = b;\n            wt = w;\n        }\n        int other(int x) {\n            return u ^ v ^ x;\n        }\n    }\n\n\n    class Helper_class{\n        long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n        int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n        int bitcount(long n){return (n==0)?0:(1+bitcount(n&(n-1)));}\n        void p(Object o){out.print(o);}\n        void pn(Object o){out.println(o);}\n        void pni(Object o){out.println(o);out.flush();}\n        String n(){return in.next();}\n        String nln(){return in.nextLine();}\n        int ni(){return Integer.parseInt(in.next());}\n        long nl(){return Long.parseLong(in.next());}\n        double nd(){return Double.parseDouble(in.next());}\n\n        long mul(long a,long b){\n            if(a>=mod)a%=mod;\n            if(b>=mod)b%=mod;\n            a*=b;\n            if(a>=mod)a%=mod;\n            return a;\n        }\n        long modPow(long a, long p){\n            long o = 1;\n            while(p>0){\n                if((p&1)==1)o = mul(o,a);\n                a = mul(a,a);\n                p>>=1;\n            }\n            return o;\n        }\n        long add(long a, long b){\n            if(a>=mod)a%=mod;\n            if(b>=mod)b%=mod;\n            if(b<0)b+=mod;\n            a+=b;\n            if(a>=mod)a-=mod;\n            return a;\n        }\n    }\n\n    class FastReader{\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new UnknownError();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int peek() {\n            if (numChars == -1)\n                return -1;\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar];\n        }\n\n        public void skip(int x) {\n            while (x-- > 0)\n                read();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String nextString() {\n            return next();\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuffer buf = new StringBuffer();\n            int c = read();\n            while (c != '\\n' && c != -1) {\n                if (c != '\\r')\n                    buf.appendCodePoint(c);\n                c = read();\n            }\n            return buf.toString();\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public boolean hasNext() {\n            int value;\n            while (isSpaceChar(value = peek()) && value != -1)\n                read();\n            return value != -1;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n} "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 112345;\nconst int MOD = 1e9 + 7;\nint n, k, cnt;\nvector<int> g[MAXN], g2[MAXN];\nbool vis[MAXN];\nvoid dfs(int cur) {\n  cnt++;\n  vis[cur] = true;\n  for (int i = 0, sz = g[cur].size(); i < sz; i++) {\n    int tar = g[cur][i];\n    if (!vis[tar]) {\n      dfs(tar);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    u--;\n    v--;\n    if (w == 0) {\n      g2[u].push_back(v);\n      g2[v].push_back(u);\n    }\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    cnt = 0;\n    if (!vis[i]) {\n      dfs(i);\n    }\n    long long cur = 1;\n    for (int i = 0; i < k; i++) {\n      cur *= cnt;\n      cur %= MOD;\n    }\n    ans += cur;\n    ans %= MOD;\n  }\n  swap(g, g2);\n  memset(vis, false, sizeof(vis));\n  for (int i = 0; i < n; i++) {\n    cnt = 0;\n    if (!vis[i]) {\n      dfs(i);\n    }\n    long long cur = 1;\n    for (int i = 0; i < k; i++) {\n      cur *= cnt;\n      cur %= MOD;\n    }\n    ans -= cur;\n    ans %= MOD;\n    ans += MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# link: https://codeforces.com/problemset/problem/1139/C\n\nfrom collections import defaultdict\n\nfor _ in range(1):\n    n, k = map(int, input().split())\n    graph = defaultdict(list)\n    present = 0\n    for i in range(n-1):\n        u,v,color = map(int, input().split())\n        if color == 1:\n            present = 1\n        else:\n            graph[u].append(v)\n            graph[v].append(u)            \n    if not present:\n        print(0)\n    else:\n        visited = [0 for _ in range(n+1)]\n        ans = pow(n, k, 1000000007)\n        left = n\n        for node in range(1,n+1):\n            if node not in graph:\n                continue\n            if not visited[node]:\n                stack = [node]\n                visited[node] = 1\n                count = 1\n                while stack:\n                    cn = stack[-1]\n                    stack.pop()\n                    # explore current node\n                    for nn in graph[cn]:\n                        if not visited[nn]:\n                            stack.append(nn)\n                            visited[nn] = 1\n                            count += 1\n                ans -= pow(count, k, 1000000007)\n                left -= count\n        print((ans - left) % 1000000007)        \n        "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 100000;\nconst long long mod = 1000000007;\nlong long sz[maxn + 4], fa[maxn + 4], vis[maxn + 4] = {0};\nlong long find(long long x) {\n  if (fa[x] == x)\n    return x;\n  else\n    return fa[x] = find(fa[x]);\n}\nvoid merge(long long x, long long y) {\n  long long rx = find(x);\n  long long ry = find(y);\n  if (rx == ry) return;\n  fa[rx] = ry;\n  sz[ry] += sz[rx];\n}\nlong long ksm(long long a, long long b) {\n  long long t = a, ret = 1;\n  while (b) {\n    if (b & 1) ret = ret * t % mod;\n    t = t * t % mod;\n    b >>= 1;\n  }\n  return ret;\n}\nsigned main() {\n  long long n, k;\n  scanf(\"%lld%lld\", &n, &k);\n  long long u, v, w;\n  for (long long i = 1; i <= n; i++) fa[i] = i, sz[i] = 1;\n  for (long long i = 1; i < n; i++) {\n    scanf(\"%lld%lld%lld\", &u, &v, &w);\n    if (!w) merge(u, v);\n  }\n  long long sum = ksm(n, k);\n  for (long long i = 1; i <= n; i++) {\n    long long r = find(i);\n    if (!vis[r]) {\n      vis[r] = 1;\n      sum = (sum - ksm(sz[r], k) + mod) % mod;\n    }\n  }\n  printf(\"%lld\", sum);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n# import bisect\n# from collections import deque\n# sys.setrecursionlimit(100000)\n \nRi = lambda : [int(x) for x in sys.stdin.readline().split()]\nri = lambda : sys.stdin.readline().strip()\n \ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nmod = 10 ** 9 + 7\n \nn,k = Ri()\npar = [i for i in range(n)]\nrank = [1 for i in range(n)]\ncc = n\n\ndef find(x):\n    if par[x] == x:\n        return x\n    temp = find(par[x])\n    par[x] =temp\n    return temp\n\ndef union(a,b):\n    par[b] = a\n    rank[a]+=rank[b]\ns = set([i for i in range(n)])\nbedge = set([i for i in range(n)])\nfor _ in range(n-1):\n    a,b,x = Ri()\n    a-=1\n    b-=1\n    if x == 0:\n        pa = find(a)\n        pb = find(b)\n        if pa != pb:\n            s.remove(pb)\n            union(pa,pb)\n            cc-=1\n            if a in bedge:\n                bedge.remove(a)\n            if b in bedge:\n                bedge.remove(b)\ndif = 0\nans = 0\ntot = 0\nfor i in s:\n    if rank[i] > 1:\n        dif+=(pow(rank[i],k,mod))\n        dif=dif%mod\n        \nprint((pow(n,k,mod) - dif -len(bedge))%mod)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Main {\n    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n    static long MOD = (long) (1e9 + 7);\n    //static int MOD = 998244353;\n    static long MOD2 = MOD * MOD;\n    static FastReader sc = new FastReader();\n    static int pInf = Integer.MAX_VALUE;\n    static int nInf = Integer.MIN_VALUE;\n    static long ded = (long)(1e17)+9;\n    public static void main(String[] args) throws Exception {\n        int test = 1;\n        //test = sc.nextInt();\n        for (int i = 1; i <= test; i++){\n            //out.print(\"Case #\"+i+\": \");\n            solve();\n        }\n        out.flush();\n        out.close();\n    }\n    static int n,k;\n    static ArrayList<Integer>[] A;\n    static boolean[] vis;\n    static void solve(){\n        n = sc.nextInt();\n        int k = sc.nextInt();\n        A = new ArrayList[n+1];\n        vis = new boolean[n+1];\n        for(int i = 1; i <=n ;i++){\n            A[i] = new ArrayList<>();\n        }\n        for(int i = 1; i < n; i++){\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int col = sc.nextInt();\n            if(col==0){\n                A[u].add(v);\n                A[v].add(u);\n            }\n        }\n        long ans = modpow(n,k);\n        ans = (ans-n+MOD)%MOD;\n        for(int i = 1; i <= n; i++){\n            cnt = 0;\n            if(!vis[i]){\n                dfs(i,0);\n            }\n            long temp = modpow(cnt,k);\n            temp = (temp-cnt+MOD)%MOD;\n            ans = (ans-temp+MOD)%MOD;\n        }\n        out.println(ans%MOD);\n    }\n    static int cnt;\n    static void dfs(int u,int pu){\n        cnt++;\n        vis[u] = true;\n        for(int v: A[u]){\n            if(v==pu){\n                continue;\n            }\n            dfs(v,u);\n        }\n    }\n    static class Pair implements Comparable<Pair> {\n        int x;int y;\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        @Override\n        public int compareTo(Pair o) {\n            if(this.x==o.x){\n                return o.y-this.y;\n            }\n            return this.x-o.x;\n        }\n    }\n    static long nC2(long n) {\n        return add((n * (n + 1)) / 2, 0);\n    }\n    public static long mul(long a, long b) {\n        return ((a % MOD) * (b % MOD)) % MOD;\n    }\n    public static long add(long a, long b) {\n        return ((a % MOD) + (b % MOD)) % MOD;\n    }\n    public static long c2(long n) {\n        if ((n & 1) == 0) {\n            return mul(n / 2, n - 1);\n        } else {\n            return mul(n, (n - 1) / 2);\n        }\n    }\n    //Shuffle Sort\n    static final Random random = new Random();\n    static void ruffleSort(int[] a) {\n        int n = a.length;//shuffle, then sort\n        for (int i = 0; i < n; i++) {\n            int oi = random.nextInt(n); int temp= a[oi];\n            a[oi] = a[i];\n            a[i] = temp;\n        }\n        Arrays.sort(a);\n    }\n    //Brian Kernighans Algorithm\n    static long countSetBits(long n) {\n        if (n == 0) return 0;\n        return 1 + countSetBits(n & (n - 1));\n    }\n    //Euclidean Algorithm\n    static long gcd(long A, long B) {\n        if (B == 0) return A;\n        return gcd(B, A % B);\n    }\n    //Modular Exponentiation\n    static long fastExpo(long x, long n) {\n        if (n == 0) return 1;\n        if ((n & 1) == 0) return fastExpo((x * x) % MOD, n / 2) % MOD;\n        return ((x % MOD) * fastExpo((x * x) % MOD, (n - 1) / 2)) % MOD;\n    }\n    //AKS Algorithm\n    static boolean isPrime(long n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n        for (int i = 5; i <= Math.sqrt(n); i += 6)\n            if (n % i == 0 || n % (i + 2) == 0) return false;\n        return true;\n    }\n    public static long modinv(long x) {\n        return modpow(x, MOD - 2);\n    }\n    public static long modpow(long a, long b) {\n        if (b == 0) {\n            return 1;\n        }\n        long x = modpow(a, b / 2);\n        x = (x * x) % MOD;\n        if (b % 2 == 1) {\n            return (x * a) % MOD;\n        }\n        return x;\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\n\nn, k = list(map(int, sys.stdin.readline().split()))\n\nsc = 0\nd = dict()\nlos = []\n\nfor i in range(n-1):\n    u, v, x = list(map(int, sys.stdin.readline().split()))\n    if not x:\n        if u in d and v in d:\n            stc = d[v]\n            los[d[u]] |= los[d[v]]\n            for j in los[stc]:\n                d[j] = d[u]\n            los[stc] = set()\n        elif u in d and v not in d:\n            d[v] = d[u]\n            los[d[u]].add(v)\n        elif u not in d and v in d:\n            d[u] = d[v]\n            los[d[v]].add(u)\n        else:\n            d[u] = d[v] = sc\n            los += [{u, v}]\n            sc += 1\n\ncolos = []\nfor s in los:\n    if s:\n        colos += [len(s)]\n\nif sum(colos) < n:\n    colos += [1] * (n - sum(colos))\n\ncs = n**k\n\nfor s in colos:\n    cs -= s**k\n\nprint(cs % 1000000007)\n"
        },
        {
            "language": 4,
            "solution": "//package com.pb.codeforces.practice;\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class CF1139C {\n\t\n\tpublic static int mod = 1000000007;\n\tpublic static int cnt = 0;\n\t\n\tpublic static void dfs(int u, ArrayList<Integer>[] adj, boolean[] vi) {\n\t\tvi[u] = true;\n\t\tcnt++;\n\t\tfor(int v : adj[u]) {\n\t\t\tif(vi[v]) continue;\n\t\t\tdfs(v,adj,vi);\n\t\t}\n\t}\n\t\n\tpublic static long compute(int n, int k) {\n\t\tlong ans = 1;\n\t\tfor(int i=0; i<k; i++) {\n\t\t\tans = (ans%mod * n%mod)%mod;\n\t\t}\n\t\treturn ans%mod;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt(); int k = in.nextInt();\n\t\tArrayList<Integer>[] adj = new ArrayList[n];\n\t\tfor(int i=0; i<adj.length; i++)\n\t\t\tadj[i] = new ArrayList<Integer>();\n\t\tfor(int i=0; i<n-1; i++) {\n\t\t\tint u = in.nextInt()-1; int v = in.nextInt()-1; int b = in.nextInt();\n\t\t\tif(b == 1) continue;\n\t\t\tadj[u].add(v);\n\t\t\tadj[v].add(u);\n\t\t}\n\t\tboolean[] vi = new boolean[n];\n\t\tlong tot = compute(n,k)%mod;\n\t\tlong badSeq = 0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tif(vi[i]) continue;\n\t\t\tcnt = 0;\n\t\t\tdfs(i,adj,vi);\n\t\t\tbadSeq = (badSeq%mod + compute(cnt,k)%mod)%mod;\n\t\t}\n\t\tbadSeq%=mod;\n\t\tlong ans = tot - badSeq;\n\t\tif(ans < 0)\n\t\t\tans += mod;\n\t\tSystem.out.println(ans);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "    import java.io.*;\n    import java.util.ArrayList;\n    import java.util.StringTokenizer;\n    \n    public class Solution {\n        static final int INF = (int) 1e9;\n        static final int mod = (int) (1e9 + 7);\n        static final short UNCALC = -1;\n        static final int RED = 0, BLACK = 1;\n        static ArrayList<Integer> adjList[];\n        static int cnt;\n        static boolean[] vis;\n    \n        public static void main(String[] args) throws IOException {\n            Scanner sc = new Scanner(System.in);\n            PrintWriter out = new PrintWriter(System.out);\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            adjList = new ArrayList[n];\n            for (int i = 0; i < n; i++)\n                adjList[i] = new ArrayList<>();\n            for (int i = 0; i < n - 1; i++) {\n                int u = sc.nextInt() - 1;\n                int v = sc.nextInt() - 1;\n                int c = sc.nextInt();\n                if (c == BLACK) continue;\n                adjList[u].add(v);\n                adjList[v].add(u);\n    \n            }\n            cnt = 0;\n            vis = new boolean[n];\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (vis[i]) continue;\n                cnt = 0;\n                dfs(i, i);\n                ans = (ans + modPow(cnt, k)) % mod;\n            }\n            ans = modPow(n, k) - ans;\n            while (ans < 0)\n                ans += mod;\n            out.println(ans % mod);\n            out.flush();\n            out.close();\n        }\n    \n        static void dfs(int u, int p) {\n            vis[u] = true;\n            cnt++;\n            for (int v : adjList[u])\n                if (v != p) dfs(v, u);\n        }\n    \n        static int modPow(int b, int e) {\n            long res = 1;\n            b %= mod;\n            while (e > 0) {\n                if ((e & 1) == 1)\n                    res = (res * b) % mod;\n                b = (int) ((1l * b * b) % mod);\n                e >>= 1;\n            }\n            return (int) res;\n        }\n    \n        static class Scanner {\n            StringTokenizer st;\n            BufferedReader br;\n    \n            public Scanner(InputStream system) {\n                br = new BufferedReader(new InputStreamReader(system));\n            }\n    \n            public Scanner(String file) throws Exception {\n                br = new BufferedReader(new FileReader(file));\n            }\n    \n            public String next() throws IOException {\n                while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            }\n    \n            public String nextLine() throws IOException {\n                return br.readLine();\n            }\n    \n            public int nextInt() throws IOException {\n                return Integer.parseInt(next());\n            }\n    \n            public double nextDouble() throws IOException {\n                return Double.parseDouble(next());\n            }\n    \n            public char nextChar() throws IOException {\n                return next().charAt(0);\n            }\n    \n            public Long nextLong() throws IOException {\n                return Long.parseLong(next());\n            }\n    \n            public boolean ready() throws IOException {\n                return br.ready();\n            }\n    \n            public void waitForInput() throws InterruptedException {\n                Thread.sleep(3000);\n            }\n    \n            public int[] nextIntArray(int n) throws IOException {\n                int[] a = new int[n];\n                for (int i = 0; i < n; i++)\n                    a[i] = nextInt();\n                return a;\n            }\n    \n            public Integer[] nextIntegerArray(int n) throws IOException {\n                Integer[] a = new Integer[n];\n                for (int i = 0; i < n; i++)\n                    a[i] = nextInt();\n                return a;\n            }\n    \n            public double[] nextDoubleArray(int n) throws IOException {\n                double[] ans = new double[n];\n                for (int i = 0; i < n; i++)\n                    ans[i] = nextDouble();\n                return ans;\n            }\n    \n            public short nextShort() throws IOException {\n                return Short.parseShort(next());\n            }\n    \n        }\n    }"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, i, a, b, c, ans, cnt, m;\nbool visit[100007];\nvector<long long> adj[100007];\nlong long modpow(long long bot, long long top) {\n  long long t = bot;\n  t %= 1000000007;\n  for (long long i = 1; i < top; i++) {\n    bot *= t;\n    bot %= 1000000007;\n  }\n  return bot;\n}\nvoid DFS(long long k) {\n  visit[k] = true;\n  cnt++;\n  for (int j = 0; j < adj[k].size(); j++) {\n    if (!visit[adj[k][j]]) {\n      DFS(adj[k][j]);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> m;\n  for (i = 0; i < n - 1; i++) {\n    cin >> a >> b >> c;\n    if (c == 0) {\n      adj[a].push_back(b);\n      adj[b].push_back(a);\n    } else\n      continue;\n  }\n  for (i = 1; i <= n; i++) {\n    if (!visit[i]) {\n      DFS(i);\n      ans += (modpow(cnt, m));\n      ans %= 1000000007;\n      cnt = 0;\n    }\n  }\n  long long res = ((modpow(n, m))) - (ans);\n  if (res < 0) res += 1000000007;\n  cout << res << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin,stdout\nfrom collections import defaultdict,Counter,deque\nfrom bisect import bisect,bisect_left\nimport math\nfrom itertools import permutations \nimport queue\n\n\ntot = 0\ndef dfs(arr,start):\n\tglobal tot\n\tglobal visited\n\tif(visited[start-1]): return\n\tvisited[start-1] = True\n\ttot+=1\n\t#print(tot,\"efef\")\n\tfor child in arr[start]:\n\t\tif(not visited[child-1]):\n\t\t\tdfs(arr,child)\n\n\n\n\n\n#stdin = open('input.txt','r')\nI = stdin.readline\n\nn,k = map(int,I().split())\n\nblacks = dict()\narr = defaultdict(lambda : [])\nfor i in range(n-1):\n\ta,b,c = map(int,I().split())\n\tif(c == 0):\n\t\tarr[a].append(b)\n\t\tarr[b].append(a)\n\telse:\n\t\tblacks[a]=1\n\t\tblacks[b]=1\nlengts = []\n#print(arr)\n#print((blacks.keys()))\n#print(blacks,arr)\nvisited = [False for i in range(n)]\nfor i in blacks.keys():\n\t\n\ttot=0\n\tdfs(arr,i)\n\tlengts.append(tot)\n\t\n\n#print(lengts)\nif(len(blacks.keys()) == 0): print(0)\nelse:\n\tmod = 10**9+7\n\tans = pow(n,k,mod)\n\tfor i in lengts:\n\t\tans-=pow(i,k,mod)\n\t\tans+=mod\n\t\tans%=mod\n\t\t#print(ans)\n\tprint(ans)\n\n\t\t\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "def find(v):\n    if parent[v] == v:\n        return v\n    parent[v] = find(parent[v])\n    return parent[v]\n\n\ndef union(u, v):\n    root_u, root_v = find(u), find(v)\n    if cnt[root_v] > cnt[root_u]:\n        root_u, root_v = root_v, root_u\n    parent[root_v] = root_u\n    cnt[root_u] += cnt[root_v]\n\n\nn, k = map(int, input().split())\nparent = [v for v in range(n + 1)]\ncnt = [1 for _ in range(n + 1)]\nfor _ in range(1, n):\n    u, v, x = map(int, input().split())\n    if x == 1:\n        continue\n    union(u, v)\nmod = 10 ** 9 + 7\nanswer = (n ** k) % mod\nfor v in range(1, n + 1):\n    if parent[v] == v:\n        val = (cnt[v] ** k) % mod\n        answer = (answer - val) % mod\nprint(answer)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class c {\n\tclass Edge {\n\t\tint u, v, c;\n\t\tpublic Edge(int uu, int vv, int cc) {\n\t\t\tu = uu;  v = vv;  c = cc;\n\t\t}\n\t}\n\tclass Tree {\n\t\tint n;  List<Edge>[] adj;\n\t\tpublic Tree(int nn) {\n\t\t\tadj = new ArrayList[n = nn];\n\t\t\tfor(int i = 0 ; i < n ; adj[i++] = new ArrayList<>());\n\t\t}\n\t\tvoid add(int u, int v, int c) {\n\t\t\tadj[u].add(new Edge(u, v, c));\n\t\t\tadj[v].add(new Edge(v, u, c));\n\t\t}\n\t\tlong solve(int k) {\n\t\t\tlong all = exp(n, k, MOD);\n\t\t\tlong remove = 0;\n\t\t\tboolean[] visited = new boolean[n];\n\t\t\tDeque<Integer> q = new ArrayDeque<>();\n\t\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\t\tif(!visited[i]) {\n\t\t\t\t\tvisited[i] = true;\n\t\t\t\t\tq.add(i);\n\t\t\t\t\tint cmp = 0;\n\t\t\t\t\twhile(!q.isEmpty()) {\n\t\t\t\t\t\tint u = q.pop();\n\t\t\t\t\t\tcmp++;\n\t\t\t\t\t\tfor(Edge e : adj[u]) {\n\t\t\t\t\t\t\tif(e.c == 0 && !visited[e.v]) {\n\t\t\t\t\t\t\t\tvisited[e.v] = true;\n\t\t\t\t\t\t\t\tq.add(e.v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremove += exp(cmp, k, MOD);\n\t\t\t\t\tremove %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (all - remove + MOD) % MOD;\n\t\t}\n\t}\n\tlong exp(long b, long e, long m) {\n\t\tif(e == 0) return 1;\n\t\tlong res = exp(b, e / 2, m);\n\t\tres = (res * res) % m;\n\t\tif((e & 1) > 0) res = (res * b) % m;\n\t\treturn res;\n\t}\n\tfinal int MOD = (int) 1e9 + 7;\n\tpublic c() {\n\t\tFS scan = new FS();\n\t\tint n = scan.nextInt(), k = scan.nextInt();\n\t\tTree t = new Tree(n);\n\t\tfor(int i = 0 ; i < n - 1 ; i++) {\n\t\t\tint u = scan.nextInt() - 1,v = scan.nextInt() - 1, c = scan.nextInt();\n\t\t\tt.add(u, v, c);\n\t\t}\n\t\tSystem.out.println(t.solve(k));\n\t}\n\tclass FS {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\tpublic String next() {\n\t\t\twhile(!st.hasMoreTokens()) {\n\t\t\t\ttry { st = new StringTokenizer(br.readLine()); }\n\t\t\t\tcatch(Exception e) { e.printStackTrace(); }\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int nextInt() { return Integer.parseInt(next()); }\n\t\tpublic long nextLong() { return Long.parseLong(next()); }\n\t}\n\tpublic static void main(String[] args) { new c(); }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Graph {\n\tint V;\n\tLinkedList<Integer>[] adjListArray;\n\n\tGraph(int V) {\n\t\tthis.V = V;\n\t\tadjListArray = new LinkedList[V];\n\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tadjListArray[i] = new LinkedList<Integer>();\n\t\t}\n\t}\n\n\tvoid addEdge(int src, int dest) {\n\t\tadjListArray[src].add(dest);\n\t\tadjListArray[dest].add(src);\n\t}\n\n\tvoid DFSUtil(int v, boolean[] visited) {\n\t\tvisited[v] = true;\n\t\tcount++;\n\t\tfor (int x : adjListArray[v]) {\n\t\t\tif (!visited[x])\n\t\t\t\tDFSUtil(x, visited);\n\t\t}\n\n\t}\n\t\n\t static long power(long x, long y, int p) \n\t    { \n\t        // Initialize result \n\t        long res = 1;      \n\t         \n\t        // Update x if it is more   \n\t        // than or equal to p \n\t        x = x % p;  \n\t      \n\t        while (y > 0) \n\t        { \n\t            // If y is odd, multiply x \n\t            // with result \n\t            if((y & 1)==1) \n\t                res = (res * x) % p; \n\t      \n\t            // y must be even now \n\t            // y = y / 2 \n\t            y = y >> 1;  \n\t            x = (x * x) % p;  \n\t        } \n\t        return res; \n\t    } \n\n\tvoid connectedComponents() {\n\t\tboolean[] visited = new boolean[V];\n\t\tfor (int v = 0; v < V; ++v) {\n\t\t\tif (!visited[v]) {\n\t\t\t\tcount = 0;\n\t\t\t\tDFSUtil(v, visited);\n\t\t\t\tismese = (ismese%MOD - power(count,k,MOD)%MOD + MOD)%MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int count = 0;\n\tpublic static long nhihonge = 0;\n\tpublic static int k;\n\tpublic static final int MOD = 1000000007;\n\tpublic static long ismese;\n\tpublic static void main(String[] args) {\n\t\tScanner scn = new Scanner(System.in);\n\t\tint n = scn.nextInt();\n\t\tk = scn.nextInt();\n\t\tismese = power(n,k,MOD);\n\t\tGraph g = new Graph(n);\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tint u = scn.nextInt();\n\t\t\tint v = scn.nextInt();\n\t\t\tint x = scn.nextInt();\n\t\t\tif (x == 0) {\n\t\t\t\tg.addEdge(u - 1, v - 1);\n\t\t\t}\n\t\t}\n\t\tg.connectedComponents();\n\n\t\tSystem.out.println(ismese);\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\n\nclass UnionFind:\n    def __init__(self, size):\n        \"\"\"\n        size:\n        parent[x]->parent of x\n        rank[x] -> height of tree of x\n        conN[x] ->size of group x belong\n        \"\"\"\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for _ in range(size)]\n        self.conN = [1 for _ in range(size)]\n\n    def find(self, x):\n        \"\"\"\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n\n    def union(self, x, y):\n        \"\"\"\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n            self.conN[y] += self.conN[x]\n        else:\n            self.parent[y] = x\n            self.conN[x] += self.conN[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        \"\"\"\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def component(self):\n        \"\"\"\n        \"\"\"\n        comp = set()\n        for i in self.parent:\n            p = self.find(i)\n            comp.add(p)\n        return comp\n\n    def componentNumm(self):\n        \"\"\"\n        \"\"\"\n        return len(self.component())\n\n    def connectedNum(self, x):\n        \"\"\"\n        \"\"\"\n        p = self.find(x)\n        return self.conN[p]\n\n    def __str__(self):\n        \"\"\"\n        for debug\n        \"\"\"\n        ret = \"parents\\n\"\n        ret += \" \".join(map(str, self.parent))\n        ret += '\\n'\n        ret += \" \".join(map(str, self.rank))\n        return ret\n\n\nMOD = 10**9+7\nN, K = map(int, input().split())\nUn = UnionFind(N)\nfor _ in range(N-1):\n    a, b, c = map(int, input().split())\n    if c == 0:\n        a -= 1\n        b -= 1\n        Un.union(a, b)\n\nnoGood = 0\nparent = set()\nfor i in range(N):\n    p = Un.find(i)\n    if p in parent:\n        continue\n    else:\n        parent.add(p)\n        noGood += pow(Un.connectedNum(p), K, MOD)\nans = pow(N, K, MOD)-noGood\nif ans < 0:\n    ans += MOD\nans %= MOD\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "rr = lambda: input().strip()\nrri = lambda: int(rr())\nrrm = lambda: list(map(int, rr().split()))\nMOD = 10**9 + 7\n\nclass DSU:\n    def __init__(self, N):\n        #R * C is the source, and isn't a grid square\n        self.par = list(range(N+1))\n        self.rnk = [0] * (N+1)\n        self.sz = [1] * (N+1)\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        if self.rnk[xr] < self.rnk[yr]:\n            xr, yr = yr, xr\n        if self.rnk[xr] == self.rnk[yr]:\n            self.rnk[xr] += 1\n\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n        \ndef solve(N, K, edges):\n    graph = [[] for _ in range(N)]\n    dsu = DSU(N)\n    for u,v,w in edges:\n        u-=1;v-=1\n        if w==0: #red\n            dsu.union(u, v)\n\n    ans = pow(N, K, MOD)\n    for x in range(N):\n        if dsu.find(x) == x:\n            ans -= pow(dsu.size(x), K, MOD)\n            ans %= MOD\n    return ans\n\nfor tc in range(1):#rri()):\n    N, K = rrm()\n    edges = [rrm() for _ in range(N-1)]\n    print(solve(N, K, edges))\n"
        },
        {
            "language": 3,
            "solution": "from collections import *\n\ndef power(a, b, mod):\n    res = 1\n    \n    while b:\n        if b%2:\n            res = (res*a)%mod\n        \n        b //= 2\n        a = (a*a)%mod    \n            \n    return res%mod\n\nMOD = 1000000007\nn, k = map(int, input().split())\nans = power(n, k, MOD)\nadj = defaultdict(list)\n\nfor i in range(n-1):\n    u, v, x = map(int, input().split())\n    if not x:\n        adj[u].append(v)\n        adj[v].append(u)\n        \nv = [0]*(1+n)\n\nfor i in range(1, 1+n):\n    if not v[i]:\n        cmp = 0\n        q = [i]\n        \n        while q:\n            e = q.pop()\n            if not v[e]:\n                cmp += 1\n            v[e] = 1\n            \n            for j in adj[e]:\n                if not v[j]:\n                    q.append(j)\n\n        ans = (ans%MOD-power(cmp, k, MOD))%MOD\n                    \nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 20, MOD = 1e9 + 7;\nint n, k, u, v, c, cnt, ans;\nvector<int> adj[2][N];\nbool vis[N];\nint power(int a, int b) {\n  if (b == 0) return 1;\n  int ans = power(a, b >> 1);\n  ans = (1ll * ans * ans) % MOD;\n  if (b & 1) ans = (1ll * ans * a) % MOD;\n  return ans;\n}\nvoid go(int node, int parent) {\n  vis[node] = true;\n  cnt++;\n  for (auto child : adj[0][node])\n    if (child != parent) go(child, node);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n - 1; i++) {\n    scanf(\"%d%d%d\", &u, &v, &c);\n    adj[c][u].push_back(v);\n    adj[c][v].push_back(u);\n  }\n  ans = power(n, k);\n  for (int i = 1; i <= n; i++) {\n    if (vis[i]) continue;\n    cnt = 0;\n    go(i, 0);\n    ans = (ans - power(cnt, k) + MOD) % MOD;\n  }\n  printf(\"%d\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class _548C {\n\t\n\tstatic final long mod=1_000_000_007;\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs=new FastScanner();\n\t\tint n=fs.nextInt(), k=fs.nextInt();\n\t\tlong ways=fastPow(n, k);\n\t\tArrayList<Integer>[] adj=new ArrayList[n];\n\t\tfor (int i=0; i<n; i++) adj[i]=new ArrayList<>();\n\t\tboolean[] seen=new boolean[n];\n\t\tArrayList<Integer> sizes=new ArrayList<>();\n\t\tfor (int i=1; i<n; i++) {\n\t\t\tint a=fs.nextInt()-1, b=fs.nextInt()-1, c=fs.nextInt();\n\t\t\tif (c==1) continue;\n\t\t\tadj[a].add(b);\n\t\t\tadj[b].add(a);\n\t\t}\n\t\tfor (int base=0; base<n; base++) {\n\t\t\tif (seen[base]) continue;\n\t\t\tArrayDeque<Integer> bfs=new ArrayDeque<>();\n\t\t\tbfs.add(base);\n\t\t\tseen[base]=true;\n\t\t\tint size=1;\n\t\t\twhile (!bfs.isEmpty()) {\n\t\t\t\tint next=bfs.remove();\n\t\t\t\tfor (int i:adj[next]) {\n\t\t\t\t\tif (seen[i])continue;\n\t\t\t\t\tseen[i]=true;\n\t\t\t\t\tsize++;\n\t\t\t\t\tbfs.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsizes.add(size);\n\t\t}\n\t\tfor (int i:sizes) {\n\t\t\tways=((ways-fastPow(i, k))%mod+mod)%mod;\n\t\t}\n\t\tSystem.out.println(ways);\n\t}\n\t\n\tstatic long fastPow(int base, int pow) {\n\t\tif (pow==0)\n\t\t\treturn 1;\n\t\tlong half=fastPow(base, pow/2);\n\t\tif (pow%2==0)\n\t\t\treturn half*half%mod;\n\t\treturn half*half%mod*base%mod;\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tpublic String next() {\n\t\t\twhile (!st.hasMoreElements())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport functools\nimport os.path\n\nBase = 1000000007\n\nclass Dsu:\n    par = []\n    cnt = []\n    def __init__(self,size):\n        self.par = [x for x in range(size + 2)]\n        self.cnt = [1] * (size + 2)\n        \n    def findp(self,u):\n        if self.par[u] == u:\n            return u \n        else :\n            self.par[u] = self.findp(self.par[u])\n            return self.par[u]\n        \n    def join(self,u,v):\n        u,v = self.findp(u),self.findp(v)\n        if u == v :\n            return\n        if self.cnt[u] < self.cnt[v] :\n            u,v = v,u\n        self.cnt[u] += self.cnt[v]\n        self.par[v] = u\n        \n    def getSize(self,u):\n        return self.cnt[self.findp(u)]\n\ndef mulmod(u,v):\n    return ((u % Base) * (v % Base)) % Base\n\ndef submod(u,v):\n    return ((u % Base) - (v % Base) + Base) % Base\n\ndef fastExp(x,h):\n    ret = 1\n    while h > 0:\n        if h & 1 == 1 :\n            ret = mulmod(ret,x)\n        x = mulmod(x,x)\n        h = h // 2\n    return ret\n\ndef solve():\n    # code goes here!!         \n    n,k = map(int,input().split())\n    dsu = Dsu(n)\n    for i in range(1,n):\n        u,v,x = map(int,input().split())\n        if x == 0:\n            dsu.join(u,v)\n            \n    ans = functools.reduce(lambda x,y : submod(x,y),map(lambda u : fastExp(dsu.getSize(u),k),filter(lambda u : dsu.findp(u) == u,range(1,n + 1))),fastExp(n,k))\n    print(ans)\n    \n\ndef main():\n    # comment when submit.\n    if os.path.exists('test.inp') :\n        sys.stdin = open(\"test.inp\",\"r\")\n    solve()\n\nif __name__ == '__main__':\n    main()\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int ans = 0;\nlong long int p = 1000000007;\nvoid dfs(vector<vector<int>> &ad, int index, int parent, bool visited[]) {\n  ans++;\n  int a, b, c, d, e, f;\n  visited[index] = true;\n  for (int i = 0; i < ad[index].size(); i++) {\n    a = ad[index][i];\n    if (visited[a] == false && a != parent) {\n      dfs(ad, a, index, visited);\n    }\n  }\n}\nlong long int _pow(long long int a, long long int b) {\n  long long int c, e, d;\n  c = 1;\n  while (b >= 1) {\n    if (b % 2 != 0) c = (c * a) % p;\n    a = (a * a) % p;\n    b /= 2;\n  }\n  return c;\n}\nint main() {\n  int t;\n  t = 1;\n  while (t--) {\n    long long int n, k;\n    cin >> n >> k;\n    vector<vector<int>> ad(n + 1);\n    long long int a, b, c;\n    for (long long int i = 0; i < n - 1; i++) {\n      cin >> a >> b >> c;\n      if (c == 0) {\n        ad[a].push_back(b);\n        ad[b].push_back(a);\n      }\n    }\n    bool visited[n + 1];\n    memset(visited, false, sizeof(visited));\n    long long int ans1 = 0;\n    for (int i = 1; i <= n; i++) {\n      if (visited[i] == false) {\n        ans = 0;\n        dfs(ad, i, 0, visited);\n        ans1 = (ans1 + _pow(ans, k)) % p;\n      }\n    }\n    b = _pow(n, k) % p;\n    cout << (b + p - ans1) % p << endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "mod = 1000000007\nn,k = map(int,input().split())\nparent = [i for i in range(n+1)]\nsize = [1 for i in range(n+1)]\ndef find(node):\n    if parent[node]==node:\n        return node\n    parent[node] = find(parent[node])\n    return parent[node]\nfor i in range(n-1):\n    a,b,c = map(int,input().split())\n    if c==0:\n        pa = find(parent[a])\n        pb = find(parent[b])\n        size[pa]+=size[pb]\n        parent[pb] = pa\nans = (n**k)%mod\nfor i in range(1,n+1):\n    if parent[i]==i:\n        ans -= (size[i]**k)%mod\nprint(ans%mod)"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package trees;\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n/**\n *\n * @author ABC\n */\npublic class Main {\n\n    /**\n     * @param args the command line arguments\n     */\n    static boolean vis[];\n    static ArrayList<Integer> adj[];\n    static long component_size=0;\n    public static void main(String[] args) {\n        // TODO code application logic here\n        Scanner sc =new Scanner(System.in);\n        int n= sc.nextInt();\n        int k = sc.nextInt();\n       adj = new ArrayList[n+1];\n        for(int i=1;i<=n;i++){\n            adj[i]=new ArrayList<>();\n        }\n        for(int i=1;i<n;i++){\n            int u=sc.nextInt();\n            int v = sc.nextInt();\n            int col = sc.nextInt();\n            \n            if(col==0){\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n        }\n        \n        long all_cases = fast_exp(n,k);\n        vis=new boolean[n+1];\n        long white_comp=0;\n        for(int i=1;i<=n;i++){\n            if(!vis[i]){\n                component_size=0;\n                dfs(i);\n                white_comp+=fast_exp(component_size,k);\n            }\n        }\n        white_comp%=mod;\n        long ans  = (all_cases-white_comp+mod)%mod;\n        System.out.println(ans);\n    }\n    static long mod=(int)1e9+7;\n    static long fast_exp(long a,long b){\n        if(b==0)\n            return 1;\n        \n        long val = fast_exp(a,b/2);\n        \n        if(b%2==0)\n            return val%mod*val%mod;\n        \n        return val%mod*val%mod*a%mod;\n    }\n    \n    static void dfs(int pos){\n        vis[pos]=true;\n        component_size++;\n        \n        for(Integer u:adj[pos]){\n            if(!vis[u])\n                dfs(u);\n        }\n    }\n    \n}\n"
        },
        {
            "language": 1,
            "solution": "n, k = map(int, raw_input().split())\ng = [[] for _ in xrange(n+1)]\nfor i in xrange(n-1):\n\tu, v, x = map(int, raw_input().split())\n\tif x == 0:\n\t\tg[u].append(v)\n\t\tg[v].append(u)\nMOD = 10**9 + 7\nvis = [0] * (n+1)\nans = pow(n, k)\nfor i in xrange(1, n+1):\n\tif vis[i] == 0:\n\t\tcnt = 0\n\t\tstack = [i]\n\t\twhile stack:\n\t\t\tu = stack.pop()\n\t\t\tif vis[u]:\n\t\t\t\tcontinue\n\t\t\tvis[u] = 1\n\t\t\tcnt += 1\n\t\t\tfor v in g[u]:\n\t\t\t\tif not vis[v]:\n\t\t\t\t\tstack.append(v)\n\t\tans -= pow(cnt, k)\n\t\t\nprint ans % MOD"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\nfrom collections import *\n\n\nclass graph:\n    # initialize graph\n    def __init__(self, gdict=None):\n        if gdict is None:\n            gdict = defaultdict(list)\n        self.gdict, self.edges, self.l = gdict, [], defaultdict(int)\n\n    # add edge\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.gdict[node2].append(node1)\n\n    def bfs_util(self, i):\n        queue, self.visit[i], nodes = deque([i]), 1, 0\n\n        while queue:\n            # dequeue parent vertix\n            s = queue.popleft()\n            nodes += 1\n\n            # enqueue child vertices\n            for v in self.gdict[s]:\n                if self.visit[v] == 0:\n                    self.visit[v] = 1\n                    queue.append(v)\n\n        return nodes\n\n    def bfs(self):\n        self.visit, self.cnt = [0] * (n + 1), 0\n\n        for i in range(1, n + 1):\n            if self.visit[i] == 0:\n                self.cnt = add(self.cnt, pow(self.bfs_util(i), k, mod))\n\n        print(add(pow(n, k, mod), -self.cnt))\n\n\nadd = lambda a, b: (a % mod + b % mod) % mod\nmult = lambda a, b: ((a % mod) * (b % mod)) % mod\nrints = lambda: [int(x) for x in stdin.readline().split()]\ng, mod = graph(), 10 ** 9 + 7\n\nn, k = rints()\nfor _ in range(n - 1):\n    u, v, w = rints()\n    if w == 0:\n        g.addEdge(u, v)\n\ng.bfs()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nvector<vector<long long> > v(300005);\nlong long vis[300005];\nlong long ct;\nlong long pmod(long long x, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n & 1) {\n      res = (res * x) % mod;\n    }\n    x = (x * x) % mod;\n    n /= 2;\n  }\n  return res % mod;\n}\nvoid dfs(long long root) {\n  ct++;\n  vis[root] = 1;\n  vector<long long> j = v[root];\n  for (long long i = 0; i < j.size(); i++) {\n    if (vis[j[i]] == 0) {\n      dfs(j[i]);\n    }\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, k;\n  cin >> n >> k;\n  long long ans = 1;\n  long long a, b, c;\n  for (long long i = 0; i < n - 1; i++) {\n    cin >> a >> b >> c;\n    if (c == 0) {\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n  }\n  ans = pmod(n, k);\n  long long x = 0;\n  for (long long i = 1; i <= n; i++) {\n    if (vis[i] == 0) {\n      ct = 0;\n      dfs(i);\n      ans -= pmod(ct, k);\n      ans += mod;\n      ans %= mod;\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "class UnionFind:\n \n    def __init__(self, n):\n        self.follow = [-1]*(n+1)\n        self.num_follower = [1]*(n+1)\n \n    def root_index_of(self, a):\n        r = a\n        while self.follow[r] > -1:\n                 r = self.follow[r]\n        return r\n \n    def connected(self, a, b):\n        return self.root_index_of(a) == self.root_index_of(b)\n \n    def connect(self, a, b):\n        ra = self.root_index_of(a)\n        rb = self.root_index_of(b)\n \n        if ra == rb:\n            return\n \n        if self.num_follower[ra] < self.num_follower[rb]:\n            self.follow[ra] = rb\n            self.follow[a] = rb\n            self.num_follower[rb] += self.num_follower[ra]\n        else:\n            self.follow[rb] = ra\n            self.follow[b] = ra\n            self.num_follower[ra] += self.num_follower[rb]\n\nmod = 10**9+7\nn, k = map(int, input().split())\n\nb = 0\nr = 0\nuf = UnionFind(n)\nfor _ in range(n-1):\n    u, v, color = map(int, input().split())\n    if color:\n        b += 1\n    else:\n        uf.connect(u, v)\n        r += 1\n\nif b == 0:\n    print(0)\n    exit()\n\ns = set()\ncnt = 0\nfor i in range(1, n+1):\n    root = uf.root_index_of(i)\n    num = uf.num_follower[root]\n    if root in s:\n        continue\n    else:\n        s.add(root)\n        cnt += pow(num, k, mod)\n\nans = pow(n, k, mod)\nans -= cnt\nprint(ans%mod)\n"
        },
        {
            "language": 3,
            "solution": "#after reading editorial\n\ndef union(a,b,root) :\n\tra = a\n\trb = b\n\twhile(ra != root[ra]) :\n\t\tra = root[root[ra]]\n\twhile(rb != root[rb]) :\n\t\trb = root[root[rb]]\n\tif(ra != rb) :\n\t\troot[rb] = ra \n\t\tsize[ra] += size[rb]\n\t\tsize[rb] = 0 \n\nn,k = map(int, input().split())\nmod = int(1e9 + 7)\n#print(mod)\nroot = [0]*n\nsize = [1]*n\n\nfor i in range(n):\n\troot[i] = i \n\n\nfor i in range(1,n):\n\ta,b,c= map(int,input().split())\n\tif(c == 0) :\n\t\tunion(a-1,b-1,root)\n\n#print(root)\nallcom = pow(n,k)\nfailedcom = 0\nfor ele in size :\n\tif(ele != 0) :\n\t\tfailedcom += pow(ele,k)\n\n# print(allcom)\n# print(failedcom)\nprint((allcom-failedcom)%mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nvector<long long> tree[100005];\nbool vis[100005];\nlong long con, res = 0, n, k;\nlong long modexp(long long a, long long b, long long mod) {\n  long long pw = 1;\n  a %= mod;\n  while (b) {\n    if (b & 1) {\n      pw = (pw * a) % mod;\n    }\n    b /= 2;\n    a = ((a % mod) * (a % mod)) % mod;\n  }\n  return pw;\n}\nvoid dfs(long long u) {\n  if (!vis[u]) {\n    con++;\n    vis[u] = true;\n    for (long long i = 0; i < tree[u].size(); i++) {\n      dfs(tree[u][i]);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, v, w;\n    cin >> u >> v >> w;\n    if (w == 0) {\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n  }\n  res = modexp(n, k, MOD);\n  for (long long i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      con = 0;\n      dfs(i);\n      res = (res + MOD - modexp(con, k, MOD)) % MOD;\n    }\n  }\n  cout << res << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n    static class DSU {\n        private final int n;\n        private final int[] root;\n        final int[] size;\n\n        DSU(int n) {\n            this.n = n;\n            root = new int[n + 1];\n            for (int i = 0; i <= n; i++) {\n                root[i] = i;\n            }\n            size = new int[n + 1];\n            Arrays.fill(size, 1);\n        }\n\n        int findRoot(int x) {\n            if (root[x] == x) {\n                return x;\n            }\n            return root[x] = findRoot(root[x]);\n        }\n\n        void unite(int x, int y) {\n            x = findRoot(x);\n            y = findRoot(y);\n            if (x != y) {\n                root[x] = y;\n                size[y] += size[x];\n            }\n        }\n    }\n\n    static class ModularArithmetic {\n        private final int module;\n\n        public ModularArithmetic(int module) {\n            this.module = module;\n        }\n\n        public ModularArithmetic() {\n            this(1_000_000_007);\n        }\n\n        final int sum(int a, int b) {\n            int sum = a + b;\n            return sum >= module ? sum - module : sum;\n        }\n\n        final int difference(int a, int b) {\n            return sum(a, module - b);\n        }\n\n        final int product(int a, int b) {\n            return (int)((long)a * b % module);\n        }\n\n        final int power(int x, int k) {\n            int result = 1;\n            while (k > 0) {\n                if (k % 2 == 1) {\n                    result = product(result, x);\n                }\n                x = product(x, x);\n                k /= 2;\n            }\n            return result;\n        }\n\n        final int inverse(int x) {\n            return power(x, module - 2);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        try (Input input = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {\n            int n = input.nextInt();\n            int k = input.nextInt();\n            DSU dsu = new DSU(n);\n            for (int i = 1; i < n; i++) {\n                int u = input.nextInt();\n                int v = input.nextInt();\n                int color = input.nextInt();\n                if (color == 0) {\n                    dsu.unite(u, v);\n                }\n            }\n            ModularArithmetic modular = new ModularArithmetic();\n            int answer = modular.power(n, k);\n            for (int i = 1; i <= n; i++) {\n                if (dsu.findRoot(i) == i) {\n                    answer = modular.difference(answer, modular.power(dsu.size[i], k));\n                }\n            }\n            writer.println(answer);\n        }\n    }\n\n    interface Input extends Closeable {\n        String next() throws IOException;\n\n        default int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        default long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n\n    private static class StandardInput implements Input {\n        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        private StringTokenizer stringTokenizer;\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n        }\n\n        @Override\n        public String next() throws IOException {\n            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                stringTokenizer = new StringTokenizer(reader.readLine());\n            }\n            return stringTokenizer.nextToken();\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nsys.setrecursionlimit(30000)\ndef gcd(n,p):\n    if n in v:\n        answer=1\n        time=set([n])\n        invite.add(n)\n        counter=1\n        timer=set([n])\n        while counter>0:\n           time=timer\n           timer=set()\n           counter=0\n           for item in time:\n               for i in v[item]:\n                   if i not in invite:\n                       timer.add(i)\n                       invite.add(i)\n                       counter+=1\n           answer+=counter\n        return answer\n    return 1\n\nv={}\ncounter=0\ninvite=set()\nn,k=[int(x) for x in input().split()]\nfor i in range(n-1):\n    a,b,c=[int(x) for x in input().split()]\n    if c==0:\n        for i,j in (a,b),(b,a):\n            if i not in v:\n                v[i]=set([j])\n            else:\n                v[i].add(j)\nfor i in range(1,n+1):\n    if i not in invite:\n        counter+=pow(gcd(i,0),k)\n\nprint(((pow(n,k))-counter)%(10**9+7))\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long max(long long a, long long b) { return ((a > b) ? a : b); }\ninline long long min(long long a, long long b) { return ((a > b) ? b : a); }\ninline long long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  a %= b;\n  return gcd(b, a);\n}\nlong long power(long long x, long long y) {\n  if (y == 0) return 1;\n  long long a = power(x, y / 2);\n  if (y % 2 == 0)\n    return a * a;\n  else\n    return x * a * a;\n}\nlong long powermod(long long x, long long ex, long long md) {\n  long long ans = 1ll;\n  while (ex > 0) {\n    if (ex & 1ll) ans = (ans * x) % md;\n    ex >>= 1ll;\n    x = (x * x) % md;\n  }\n  return ans;\n}\nconst long long inf = 1e18 + 9;\nconst long long mod = 1e9 + 7;\nconst long double PI = acos(-1);\nconst long double eps = 1e-9;\nconst long long N = 1e6 + 1;\nlong long n, k;\nvector<long long> red[N];\nbool vis[N];\nset<long long> second;\nvoid dfs(long long node) {\n  vis[node] = 1;\n  second.insert(node);\n  for (auto child : red[node]) {\n    if (!vis[child]) {\n      dfs(child);\n    }\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    long long x, y, c;\n    cin >> x >> y >> c;\n    if (c == 0) {\n      red[x].push_back(y);\n      red[y].push_back(x);\n    }\n  }\n  long long ans = 0;\n  ans = powermod(n, k, mod);\n  long long x = 0;\n  for (long long i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      second.clear();\n      dfs(i);\n      long long len = second.size();\n      x += powermod(len, k, mod);\n      x %= mod;\n    }\n  }\n  cout << (ans - x + mod) % mod << \"\\n\";\n}\nint main() {\n  {\n    ios ::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n  };\n  cout << fixed << setprecision(20);\n  long long NTC = 1;\n  long long PTC = 0;\n  while (PTC++ < NTC) {\n    solve();\n  }\n  cerr << \"Time : \" << 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC\n       << \"ms\\n\";\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys,math\nfrom fractions import gcd\nfrom collections import defaultdict\nfrom io import BytesIO\nsys.stdin = BytesIO(sys.stdin.read())\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n#n = int(input())\nmod = 10**9 + 7\nn,k = [int(x) for x in input().split(' ')]\nds = defaultdict(set)\narr = [0] * n\nfor _ in range(n-1):\n    s,f,c = [int(x) for x in input().split(' ')]\n    if c == 0:\n        ds[s-1].add(f-1)\n        ds[f-1].add(s-1)\n\ncur = 0\nd = defaultdict(int)\nfor i in range(n):\n    if arr[i] == 0:\n        cur += 1\n        s = {i}\n        sv = {i}\n        while len(s):\n            nxt = s.pop()\n            arr[nxt] = cur\n            d[cur] += 1\n            for el in ds[nxt]:\n                if el not in sv:\n                    sv.add(el)\n                    s.add(el)\n#print(arr,d)\nres = 1\nfor i in range(k):\n    res = (res * n) % mod\n\nfor key in d:\n    newsub = 1\n    for i in range(k):\n        newsub = (newsub * d[key]) % mod\n    res -= newsub\nwhile res < 0:\n    res += mod\nprint(res)\n"
        },
        {
            "language": 3,
            "solution": "import os\nfrom io import BytesIO, StringIO\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef pow(x, p):\n    m = 1\n    while p > 0:\n        m *= x\n        p -= 1\n        if m >= MOD:\n            m %= MOD\n    return m\n\n\nn, k = map(int, input().split())\nG = [list() for _ in range(n)]\n\nfor _ in range(n-1):\n    u, v, x = map(int, input().split())\n    if x == 0:\n        u, v = u-1, v-1\n        G[u].append(v)\n        G[v].append(u)\n\nset_count = defaultdict(int)\nvisited = [False] * n\nstack = []\n\nfor u in range(n):\n    if not visited[u]:\n        root = u\n        stack.append(u)\n        while stack:\n            u = stack.pop()\n            visited[u] = True\n            set_count[root] += 1\n            for v in G[u]:\n                if not visited[v]:\n                    stack.append(v)\n\nss = sum(pow(x, k) for x in set_count.values())\n\nprint((pow(n, k) - ss) % MOD)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1000000007ll;\nconst int INTMAX = numeric_limits<int>::max();\nconst long long LLMAX = numeric_limits<long long>::max();\nvoid writeln() { cout << \"\\n\"; }\ntemplate <class T>\ninline void print(T&& a);\ntemplate <class T>\ninline void priws(T&& a);\ntemplate <class T>\ninline void read(T& a);\ntemplate <class... Args>\ninline void readln(Args&... args) {\n  (read(args), ...);\n}\ntemplate <class H, class... T>\ninline void writeln(H&& h, T&&... t) {\n  priws(h);\n  (print(t), ...);\n  writeln();\n}\ntemplate <class T>\ninline void writeln_range(T f, T s) {\n  if (f != s)\n    for (auto i = f; i != s; ++i) writeln(*i);\n}\nvector<string> split(string& s, string d) {\n  vector<string> v;\n  size_t p = 0;\n  while ((p = s.find(d)) != string::npos)\n    v.push_back(s.substr(0, p)), s.erase(0, p + d.length());\n  v.push_back(s);\n  return v;\n}\ntemplate <class... Args>\ninline void err(string v, Args... args) {\n  auto vv = split(v, \", \");\n  auto it = vv.begin();\n  (writeln(*it++, \"=\", args), ...);\n}\ntemplate <typename T>\nT binpowmod(T a, long long n, T mod) {\n  assert(n > 0);\n  T res = a;\n  --n;\n  while (n > 0) {\n    if (n & 1) res = (res * a) % mod;\n    a = (a * a) % mod;\n    n >>= 1;\n  }\n  return res;\n}\nvoid run() {\n  int n, k;\n  readln(n, k);\n  vector<vector<pair<int, int>>> g(n);\n  int u, v, x;\n  for (int i = 0; i < (int)(n - 1); ++i)\n    readln(u, v, x), --u, --v, g[u].push_back({v, x}), g[v].push_back({u, x});\n  vector<long long> degs(n + 1, 0);\n  for (int i = 1; i < (int)(n + 1); ++i) degs[i] = binpowmod(i * 1ll, k, MOD);\n  vector<bool> used(n, false);\n  function<int(int)> dfs = [&](int u) {\n    used[u] = true;\n    int cnt = 1;\n    for (auto& [v, x] : g[u])\n      if (!x && !used[v]) cnt += dfs(v);\n    return cnt;\n  };\n  long long ans = degs[n];\n  for (int i = 0; i < (int)(n); ++i)\n    if (!used[i]) {\n      int cnt = dfs(i);\n      ans -= degs[cnt];\n      if (ans < 0) ans += MOD;\n    }\n  writeln(ans);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  run();\n  return 0;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, vector<T> const& _a);\ntemplate <class T1, class T2>\ninline istream& operator>>(istream& is, pair<T1, T2>& _a) {\n  return is >> _a.first >> _a.second;\n}\ntemplate <class T1, class T2>\ninline ostream& operator<<(ostream& os, pair<T1, T2> const& _a) {\n  return os << _a.first << \" \" << _a.second;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, vector<T> const& _a) {\n  if (_a.size())\n    os << _a[0];\n  else\n    os << \"\\n\";\n  for (int i = 1; i < (int)(_a.size()); ++i)\n    os << \"\\n \"[is_fundamental<T>::value] << _a[i];\n  return os;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, valarray<T> const& _a) {\n  if (_a.size())\n    os << _a[0];\n  else\n    os << \"\\n\";\n  for (int i = 1; i < (int)(_a.size()); ++i)\n    os << \"\\n \"[is_fundamental<T>::value] << _a[i];\n  return os;\n}\ntemplate <class T>\ninline istream& operator>>(istream& is, vector<T>& _a) {\n  for (int i = 0; i < (int)(_a.size()); ++i) is >> _a[i];\n  return is;\n}\ntemplate <class T>\ninline istream& operator>>(istream& is, valarray<T>& _a) {\n  for (int i = 0; i < (int)(_a.size()); ++i) is >> _a[i];\n  return is;\n}\ntemplate <class T>\ninline void print(T&& _a) {\n  cout << \" \" << _a;\n}\ntemplate <class T>\ninline void priws(T&& _a) {\n  cout << _a;\n}\ntemplate <class T>\ninline void read(T& _a) {\n  cin >> _a;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 5;\nvector<long long> v[N];\nlong long vis[N];\nlong long nodes = 0;\nconst long long m = 1e9 + 7;\nlong long pow(long long a, long long b, long long m) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % m;\n    b /= 2;\n    a = (a * a) % m;\n  }\n  return ans;\n}\nlong long dfs(long long s) {\n  vis[s] = true;\n  nodes++;\n  for (long long i : v[s]) {\n    if (!vis[i]) dfs(i);\n  }\n  return nodes;\n}\nint32_t main() {\n  long long n, k;\n  cin >> n >> k;\n  long long a, b, c;\n  for (long long i = 1; i < n; i++) {\n    cin >> a >> b >> c;\n    if (c == 0) {\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n  }\n  long long p;\n  long long fans = pow(n, k, m);\n  for (long long i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      nodes = 0;\n      p = 0;\n      p = dfs(i);\n      fans -= pow(p, k, m);\n      fans += m;\n      fans %= m;\n    }\n  }\n  cout << fans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v[200005];\nunordered_map<int, int> m1[200005];\nbool vis[200005];\nlong long int power(long long int x, long long int y, long long int p) {\n  int res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nlong long int bfs(int k) {\n  long long int sum = 1, i, j;\n  for (i = 0; i < v[k].size(); i++)\n    if (vis[v[k][i]] == 0) {\n      if (m1[k][v[k][i]] == 1) continue;\n      vis[v[k][i]] = 1;\n      sum += bfs(v[k][i]);\n    }\n  return sum;\n}\nint main() {\n  long long int i, j, k, n, m = 1, x, y, p, q;\n  cin >> n >> k;\n  for (i = 0; i < n - 1; i++) {\n    cin >> x >> y >> p;\n    v[x].push_back(y);\n    v[y].push_back(x);\n    m1[x][y] = p;\n    m1[y][x] = p;\n  }\n  m = power(n, k, 1000000007);\n  memset(vis, 0, sizeof(vis));\n  for (i = 1; i <= n; i++)\n    if (vis[i] == 0) {\n      vis[i] = 1;\n      p = bfs(i);\n      m = (m - power(p, k, 1000000007) + 1000000007) % 1000000007;\n    }\n  cout << m;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Solution {\n    static ArrayList<Integer>[] adj;\n    static int[] vis;\n    static int cnt = 0;\n\n    static long mod = (long)1e9+7;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n\n        adj = new ArrayList[n];\n\n        for(int i=0;i<n;i++){\n            adj[i] = new ArrayList<Integer>();\n        }\n\n        for(int i=0;i<n-1;i++){\n            int u = sc.nextInt()-1;\n            int v = sc.nextInt()-1;\n            int col = sc.nextInt();\n            if(col==0){\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n        }\n\n        long ans = fast_pow(n,k);\n\n        long remaining = 0;\n\n        vis = new int[n];\n\n        for(int i=0;i<n;i++){\n            if(vis[i]==0){\n                cnt = 0;\n                dfs(i);\n                remaining +=fast_pow(cnt,k);\n            }\n        }\n        remaining %= mod;\n        System.out.println( (ans - remaining+mod)%mod);\n    }\n\n    private static void dfs(int i) {\n        vis[i] = 1;\n        cnt++;\n        for(int j: adj[i]){\n            if(vis[j]==0){\n                dfs(j);\n            }\n        }\n    }\n\n    static long fast_pow(long a, long b) {\n        if(b == 0)\n            return 1L;\n\n        long val = fast_pow(a, b / 2);\n\n        if(b % 2 == 0)\n            return val * val % mod;\n        else{\n            return val * val % mod * a % mod;\n        }\n\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "// package codeForces;\n\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\n\npublic class TEdgyTrees {\n\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic OutputWriter out = new OutputWriter(System.out);\n\tstatic long count=0L;\n\t\n\tstatic void dfs(int s,ArrayList<ArrayList<Integer>> ar,boolean vis[]) {\n\t\t\n\t\tvis[s]=true;\n\t\tcount++;\n\t\tfor(int j:ar.get(s) ) {\n\t\t\tif(!vis[j]) {\n\t\t\t\t\n\t\t\t\tdfs(j,ar,vis);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic int mod=1000000007;\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint t = 1;\n\t\twhile (t > 0) {\n\t\t\tint n=i();\n\t\t\tint k=i();\n\t\t\tint c1=0;\n\t\t\tint c0=0;\n\t\t\tArrayList<ArrayList<Integer>> ar=new ArrayList<>();\n\t\t\tfor(int i=0;i<=n;i++) {\n\t\t\t\tar.add(new ArrayList<>());\n\t\t\t}\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\tint a=i();\n\t\t\t\tint b=i();\n\t\t\t\tint x=i();\n\t\t\t\tif(x==0) {\n\t\t\t\t\tar.get(a).add(b);\n\t\t\t\t\tar.get(b).add(a);\n\t\t\t\t}\n\t\t\t\tif(x==0) {\n\t\t\t\t\tc0++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(ar);\n\t\t\t\n\t\t\tlong ans1=0L;\n\t\t\tlong ans2=0L;\n\t\t\tans1=pow(n,k);\n\t\t\tboolean vis[]=new boolean[n+1];\n\t\t\tfor(int i=1;i<=n;i++) {\n\t\t\t\tif(!vis[i]) {\n\t\t\t\t\tcount=0;\n\t\t\t\t\tdfs(i,ar,vis);\n\t\t\t\t\tans2=ans2+pow(count,k);\n//\t\t\t\t\tSystem.out.println(ans2);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(ans1);\n//\t\t\tSystem.out.println(ans2);\n\t\t\tans2=ans2%mod;\n\t\t\tlong ansf=0L;\n\t\t\tansf=(ans1-ans2+mod)%mod;\n\t\t\tSystem.out.println(ansf);\n\t\t\t\t\n\t\t\t\n\n\t\t\tt--;\n\t\t}\n\n\t\t//\t\tlong l=l();\n\t\t//\t\tString s=s();     //\tONLY BEFORE SPACE IN STRING , ELSE USE BUFFER-READER\n\n\t}\n\n\tpublic static long pow(long a, long b) {\n\t\tlong m = 1000000007;\n\t\tlong result = 1;\n\t\twhile (b > 0) {\n\t\t\tif (b % 2 != 0) {\n\t\t\t\tresult = (result * a) % m;\n\t\t\t\tb--;\n\t\t\t}\n\t\t\ta = (a * a) % m;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn result % m;\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tif (a == 0) {\n\t\t\treturn b;\n\t\t}\n\t\treturn gcd(b % a, a);\n\t}\n\n\tpublic static long lcm(long a, long b) {\n\t\treturn a * (b / gcd(a, b));\n\t}\n\n\tpublic static long l() {\n\t\tString s = in.String();\n\t\treturn Long.parseLong(s);\n\t}\n\n\tpublic static void pln(String value) {\n\t\tSystem.out.println(value);\n\t}\n\n\tpublic static int i() {\n\t\treturn in.Int();\n\t}\n\n\tpublic static String s() {\n\t\treturn in.String();\n\t}\n\n}\n\nclass pair {\n\tint x, y;\n\n\tpair(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass CompareValue {\n\n\tstatic void compare(pair arr[], int n) {\n\t\tArrays.sort(arr, new Comparator<pair>() {\n\t\t\tpublic int compare(pair p1, pair p2) {\n\t\t\t\treturn p1.y - p2.y;\n\t\t\t}\n\t\t});\n\t}\n}\n\nclass CompareKey {\n\tstatic void compare(pair arr[], int n) {\n\t\tArrays.sort(arr, new Comparator<pair>() {\n\t\t\tpublic int compare(pair p1, pair p2) {\n\t\t\t\treturn p2.x - p1.x;\n\t\t\t}\n\t\t});\n\t}\n}\n\nclass InputReader {\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int Int() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic String String() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tpublic String next() {\n\t\treturn String();\n\t}\n\n\tpublic interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n\n\tpublic double readDouble() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tdouble res = 0;\n\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\tif (c == 'e' || c == 'E') {\n\t\t\t\treturn res * Math.pow(10, Int());\n\t\t\t}\n\t\t\tif (c < '0' || c > '9') {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t}\n\t\tif (c == '.') {\n\t\t\tc = read();\n\t\t\tdouble m = 1;\n\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\tif (c == 'e' || c == 'E') {\n\t\t\t\t\treturn res * Math.pow(10, Int());\n\t\t\t\t}\n\t\t\t\tif (c < '0' || c > '9') {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tm /= 10;\n\t\t\t\tres += (c - '0') * m;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t}\n\t\treturn res * sgn;\n\t}\n}\n\nclass OutputWriter {\n\tprivate final PrintWriter writer;\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t}\n\n\tpublic OutputWriter(Writer writer) {\n\t\tthis.writer = new PrintWriter(writer);\n\t}\n\n\tpublic void print(Object... objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0) {\n\t\t\t\twriter.print(' ');\n\t\t\t}\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t\twriter.flush();\n\t}\n\n\tpublic void printLine(Object... objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t\twriter.flush();\n\t}\n\n\tpublic void close() {\n\t\twriter.close();\n\t}\n\n\tpublic void flush() {\n\t\twriter.flush();\n\t}\n}\n\nclass IOUtils {\n\tpublic static int[] readIntArray(InputReader in, int size) {\n\t\tint[] array = new int[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tarray[i] = in.Int();\n\t\treturn array;\n\t}\n}\n\n/**\n * TO SORT VIA TWO KEYS , HERE IT IS ACCORDING TO ASCENDING ORDER OF FIRST AND\n * DESC ORDER OF SECOND\n * LIST name-list \n * ARRAYLIST\n * COPY PASTE\n * \n * Collections.sort(list, (first,second) ->{\n\t\t    \tif(first.con >second.con)\n\t\t    \t\treturn -1;\n\t\t    \telse if(first.con<second.con)\n\t\t    \t\treturn 1;\n\t\t    \telse {\n\t\t    \t\tif(first.index >second.index)\n\t\t    \t\t\treturn 1;\n\t\t    \t\telse\n\t\t    \t\t\treturn -1;\n\t\t    \t}\n\t\t    \t\n\t\t    });\n * \n */\n\n/**\n * \n \n\n  DECIMAL FORMATTER\nDouble k = in.readDouble();\n\nSystem.out.println(k);\nDecimalFormat df = new DecimalFormat(\"#.##\");\nSystem.out.print(df.format(k));\nout.printLine(k);\n* \n* */\n"
        },
        {
            "language": 4,
            "solution": "//package com.example.programming;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class CodeforcesProblems {\n\n    static long mod = 1000000007L;\n\n    static class Node {\n        ArrayList<Integer> adj = new ArrayList<>();\n        boolean is = false;\n    }\n\n    static long getPower(long n, long k) {\n        if(k==0) return 1L;\n        if(k==1) return n;\n        long half = k/2;\n        long f = getPower(n, half) % mod;\n        long s = getPower(n, half) % mod;\n        long res = (f * s) % mod;\n        if(k%2 == 1) res = (res * n) % mod;\n        return res;\n    }\n\n    static int connectedNodes(Node[] tree, int start) {\n        ArrayList<Integer> q = new ArrayList<>();\n        int count = 1;\n        q.add(start);\n        tree[start].is = true;\n        int c = 0;\n        for(;c < q.size();) {\n            int pos = q.get(c++);\n            Node cur = tree[pos];\n            for(int i : cur.adj) {\n                if(!tree[i].is) {\n                    count++;\n                    tree[i].is = true;\n                    q.add(i);\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        long k = Long.parseLong(s[1]);\n        Node[] tree = new Node[n+1];\n        for(int i = 1; i<=n; i++) tree[i] = new Node();\n        for(int i = 0; i<n-1; i++) {\n            s = br.readLine().split(\" \");\n            if(s[2].charAt(0) == '1') continue;\n            int x = Integer.parseInt(s[0]);\n            int y = Integer.parseInt(s[1]);\n            tree[x].adj.add(y);\n            tree[y].adj.add(x);\n        }\n        long res = getPower(n, k);\n        long minus = 0;\n        int count = 0;\n        for(int i = 1; i<=n; i++) {\n            if(tree[i].adj.size()>0 && !tree[i].is) {\n                int x = connectedNodes(tree, i);\n                long pow = getPower(x, k);\n                minus = (minus + pow) % mod;\n                count += x;\n            }\n        }\n        count = n-count;\n        res = res >= count ? res - count : mod + res - count;\n        res = res >= minus ? res - minus : mod + res - minus;\n        System.out.println(res);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nconst int N = 100005;\nbool vis[N];\nvector<pair<int, int> > g[N];\nlong long c = 0;\nlong long power(long long x, long long y);\nlong long powerm(long long x, long long y, int mod2);\nvoid seive(bool arr[], int n);\nvoid dfs(int node);\nvoid solve() {\n  long long n, k;\n  cin >> n >> k;\n  for (long long i = 1; i < n; i++) {\n    long long x, y, z;\n    cin >> x >> y >> z;\n    g[x].push_back({y, z}), g[y].push_back({x, z});\n  }\n  long long ans = power(n, k);\n  memset(vis, false, sizeof(vis));\n  for (long long i = 1; i < n + 1; i++) {\n    c = 0;\n    if (!vis[i]) {\n      dfs(i);\n      ans = (ans - power(c, k) + 1000000007) % 1000000007;\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  int t = 1;\n  while (t--) solve();\n}\nvoid dfs(int node) {\n  vis[node] = true;\n  c++;\n  for (auto x : g[node]) {\n    if (!vis[x.first] && x.second == 0) {\n      dfs(x.first);\n    }\n  }\n}\nlong long power(long long x, long long y) {\n  long long ans = 1;\n  while (y) {\n    if (y & 1)\n      ans = ((long long)(ans % 1000000007) * (long long)(x % 1000000007)) %\n            1000000007;\n    x = ((long long)(x % 1000000007) * (long long)(x % 1000000007)) %\n        1000000007;\n    y = y >> 1;\n  }\n  return ans % 1000000007;\n}\nlong long powerm(long long x, long long y, int mod2) {\n  long long ans = 1;\n  while (y) {\n    if (y & 1) ans = ((long long)(ans % mod2) * (long long)(x % mod2)) % mod2;\n    x = ((long long)(x % mod2) * (long long)(x % mod2)) % mod2;\n    y = y >> 1;\n  }\n  return ans % mod2;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nvector<int> rk, f;\nvector<long long> sum;\nset<int> s;\nint find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }\nvoid merge(int x, int y) {\n  if (rk[x] >= rk[y]) {\n    f[y] = x;\n    rk[x] += rk[y];\n  } else {\n    f[x] = y;\n    rk[y] += rk[x];\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, k, a;\n  int b, c, cnt;\n  f.reserve(200000);\n  rk.reserve(200000);\n  sum.reserve(100000);\n  cin >> n >> k;\n  cnt = 0;\n  rk.resize(n, 1);\n  f.resize(n);\n  for (int i = 0; i < n; i++) {\n    f[i] = i;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    cin >> a >> b >> c;\n    if (!c) {\n      cnt++;\n      a = find(a);\n      b = find(b);\n      if (a != b) merge(a, b);\n    }\n  }\n  if (cnt == n - 1) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    a = find(i);\n    if (rk[a] > 1 && !s.count(a)) {\n      s.insert(a);\n      sum.push_back(rk[a]);\n    }\n  }\n  long long ans = n % 1000000007;\n  for (int i = 1; i < k; i++) {\n    ans *= n;\n    ans %= 1000000007;\n  }\n  ans -= n;\n  for (int i = 0; i < sum.size(); i++) {\n    long long tmp = sum[i];\n    for (int j = 1; j < k; j++) {\n      tmp *= sum[i];\n      tmp %= 1000000007;\n    }\n    tmp -= sum[i];\n    ans -= tmp;\n    if (ans < 0) ans += 1000000007;\n  }\n  cout << ans % 1000000007 << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7LL;\nconst int MAXN = 212345;\nint vis[MAXN];\nvector<int> g[MAXN];\nlong long dfs(int u) {\n  vis[u] = 1;\n  long long r = 1;\n  for (int v : g[u])\n    if (!vis[v]) r += dfs(v);\n  return r;\n}\nlong long fexp(long long b, long long e) {\n  if (b == 1 || e == 0) return 1;\n  if (b == 0) return 0;\n  long long resp = fexp(b, e / 2);\n  resp = ((resp % MOD) * (resp % MOD)) % MOD;\n  if (e & 1) resp = ((resp % MOD) * (b % MOD)) % MOD;\n  return resp % MOD;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0, u, v, w; i < n - 1; ++i) {\n    cin >> u >> v >> w;\n    if (!w) {\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n  }\n  long long r = fexp(n, k);\n  for (int i = 1; i <= n; ++i) {\n    if (!vis[i]) {\n      r = (r % MOD - fexp(dfs(i), k) % MOD) % MOD;\n      if (r < 0) r += MOD;\n      r %= MOD;\n    }\n  }\n  cout << r << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def dfs(edges,visited,node):\n    red = 0\n    if node not in visited:\n        for kid in edges[node]:\n            if kid[1] == 0 and kid[0] not in visited:\n                red += 1\n                break\n            \n    stack = [node]\n    while stack:\n        curr = stack.pop()\n        if curr not in visited:\n            found = False\n            visited.add(curr)\n            for kid in edges[curr]:\n                if kid[1] == 0 and kid[0] not in visited:\n                    stack.append(kid[0])\n                    red += 1\n\n    return red\n\ndef solve(edges,k):\n    mod = 10**9+7\n    n = len(edges)\n    total = pow(n,k,mod)\n    remove = 0\n    visited = set()\n    for i in range(1,n+1):\n        if i not in visited:\n            red = dfs(edges,visited,i)\n            #print(red)\n            remove += pow(red,k,mod)\n            remove -= red\n            remove = remove%mod\n\n    remove += n\n    remove = remove%mod\n    #print(total,remove)\n            \n    print((total-remove)%mod)\n            \n\ndef main():\n    n,k = map(int,input().split())\n    edges = {}\n    for i in range(1,n+1):\n        edges[i] = []\n\n    for i in range(n-1):\n        u,v,x = map(int,input().split())\n        edges[u].append((v,x))\n        edges[v].append((u,x))\n\n    solve(edges,k)\n\n\nmain()\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\n\npublic class C {\n\tFastScanner in;\n\tPrintWriter out;\n\tboolean systemIO = true;\n\n\tpublic static void quickSort(int[] a, int from, int to) {\n\t\tif (to - from <= 1) {\n\t\t\treturn;\n\t\t}\n\t\tint i = from;\n\t\tint j = to - 1;\n\t\tint x = a[from + (new Random()).nextInt(to - from)];\n\t\twhile (i <= j) {\n\t\t\twhile (a[i] < x) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (a[j] > x) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif (i <= j) {\n\t\t\t\tint t = a[i];\n\t\t\t\ta[i] = a[j];\n\t\t\t\ta[j] = t;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tquickSort(a, from, j + 1);\n\t\tquickSort(a, j + 1, to);\n\t}\n\n\tpublic long gcd(long x, long y) {\n\t\tif (y == 0) {\n\t\t\treturn x;\n\t\t}\n\t\tif (x == 0) {\n\t\t\treturn y;\n\t\t}\n\t\treturn gcd(y, x % y);\n\t}\n\n\tpublic boolean prime(long x) {\n\t\tfor (int i = 2; i * i <= x; i++) {\n\t\t\tif (x % i == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic long pow(long x, long p) {\n\t\tif (p == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tlong t = pow(x, p / 2);\n\t\tt *= t;\n\t\tt %= mod;\n\t\tif (p % 2 == 1) {\n\t\t\tt *= x;\n\t\t\tt %= mod;\n\t\t}\n\t\treturn t;\n\t}\n\n\tpublic class Pair {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tlong mod = 1000000007;\n\t\n\tArrayList<Integer>[] to;\n\tHashSet<Integer> used = new HashSet<>();\n\t\n\tpublic void solve() {\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tlong ans = pow(n, k);\n\t\tto = new ArrayList[n];\n\t\tfor (int i = 0; i < to.length; i++) {\n\t\t\tto[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint x = in.nextInt() - 1;\n\t\t\tint y = in.nextInt() - 1;\n\t\t\tif (in.nextInt() == 0) {\n\t\t\t\tto[x].add(y);\n\t\t\t\tto[y].add(x);\n\t\t\t}\n\t\t}\n\t\tint sz = 0;\n\t\tfor (int i = 0; i < to.length; i++) {\n\t\t\tif (!used.contains(i)) {\n\t\t\t\tsz = used.size();\n\t\t\t\tdfs(i);\n\t\t\t\tans -= pow(used.size() - sz, k);\n\t\t\t\tans += mod;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tprivate void dfs(int i) {\n\t\tused.add(i);\n\t\tfor (int j : to[i]) {\n\t\t\tif (!used.contains(j)) {\n\t\t\t\tdfs(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tif (systemIO) {\n\t\t\t\tin = new FastScanner(System.in);\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t} else {\n\t\t\t\tin = new FastScanner(new File(\"input.txt\"));\n\t\t\t\tout = new PrintWriter(new File(\"output.txt\"));\n\t\t\t}\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tFastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\treturn br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\t// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\tpublic static void main(String[] arg) {\n\t\tnew C().run();\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\n\npublic class Main{\n    \n\tpublic static int find(int[] array, int pos) {\n\t\tif (array[pos] != pos) {\n\t\t\treturn array[pos] = find(array, array[pos]);\n\t\t}\n\t\treturn pos;\n\t}\n \n\tpublic static int pow(int a, int n) {\n\t\tlong ans = 1;\n\t\tlong base = a;\n\t\tint mod = (int) (1e9 + 7);\n\t\twhile (n != 0) {\n\t\t\tif ((n & 1) == 1) {\n\t\t\t\tans *= base;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t\tbase = (base * base) % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn (int) ans % mod;\n\t}\n    \n\tpublic static void main(String[] args) {\n\t    \n\t\tScanner s = new Scanner(System.in);\n\t\tint mod = (int) (1e9 + 7);\n\t\tint vert = s.nextInt();\n\t\tint comprimento = s.nextInt();\n\t\tint[] array = new int[vert + 1];\n\t\tint[] arrayAux = new int[vert + 1];\n\t\tfor (int i = 1; i <= vert; i++) {\n\t\t\tarray[i] = i;\n\t\t\tarrayAux[i] = 1;\n\t\t}\n\t\t\n\t\tfor (int i = 1; i < vert; i++) {\n\t\t\tint inicio = s.nextInt();\n\t\t\tint fim = s.nextInt();\n\t\t\tint cor = s.nextInt();\n\t\t\tif (cor == 0) {\n\t\t\t\tint auxInicio = find(array, inicio);\n\t\t\t\tint auxFim = find(array, fim);\n\t\t\t\tarray[auxInicio] = auxFim;\n\t\t\t\tarrayAux[auxFim] += arrayAux[auxInicio];\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong resp = 0;\n\t\tfor (int i = 1; i <= vert; i++) {\n\t\t\tif (array[i] == i) {\n\t\t\t\tresp = (resp + pow(arrayAux[i], comprimento)) % mod;\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(((long) pow(vert, comprimento) - resp + mod) % mod);\n\t}\n}\n\t\t\t\t\t\t \t\t\t\t\t\t\t\t       \t\t\t\t"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.RoundingMode;\nimport java.util.*;\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\n\n\n// graph, dfs,bfs, get connected components,iscycle, isbipartite, dfs on trees\n\n\n\npublic class scratch_25 {\n    static class Graph{\n\n        public static class Vertex{\n            HashMap<Integer,Integer> nb= new HashMap<>();     // for neighbours of each vertex\n        }\n\n        public static HashMap<Integer,Vertex> vt;   // for vertices(all)\n\n        public Graph(){\n            vt= new HashMap<>();\n        }\n\n        public static int numVer(){\n            return vt.size();\n        }\n\n        public static boolean contVer(int ver){\n            return vt.containsKey(ver);\n        }\n\n        public static void addVer(int ver){\n            Vertex v= new Vertex();\n            vt.put(ver,v);\n        }\n        public class Pair{\n            int vname;\n            ArrayList<Integer> psf= new ArrayList<>();       // path so far\n            int dis;\n            int col;\n        }\n\n\n\n\n\n        public static void addEdge(int ver1, int ver2, int weight){\n            if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){\n                return;\n            }\n            Vertex v1= vt.get(ver1);\n            Vertex v2= vt.get(ver2);\n            v1.nb.put(ver2,weight);                                 // if previously there is an edge, then this replaces that edge\n            v2.nb.put(ver1,weight);\n        }\n\n        public static void delEdge(int ver1, int ver2){\n\n            if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){\n                return;\n            }\n            vt.get(ver1).nb.remove(ver2);\n            vt.get(ver2).nb.remove(ver1);\n        }\n        public static void delVer(int ver){\n            if(!vt.containsKey(ver)){\n                return;\n            }\n            Vertex v1= vt.get(ver);\n            ArrayList<Integer> arr= new ArrayList<>(v1.nb.keySet());\n            for (int i = 0; i <arr.size() ; i++) {\n                int s= arr.get(i);\n                vt.get(s).nb.remove(ver);\n            }\n            vt.remove(ver);\n        }\n           static boolean done[];\n            static int parent[];\n            static ArrayList<Integer>vals= new ArrayList<>();\n\n\n        public static boolean isCycle(int i){\n            Stack<Integer>stk= new Stack<>();\n\n            stk.push(i);\n            while(!stk.isEmpty()){\n                int x= stk.pop();\n                vals.add(x);\n             //   System.out.print(\"current=\"+x+\" stackinit=\"+stk);\n                if(!done[x]){\n                    done[x]=true;\n                }\n                else if(done[x] ){\n                    return true;\n                }\n\n                ArrayList<Integer>ar= new ArrayList<>(vt.get(x).nb.keySet());\n                for (int j = 0; j <ar.size() ; j++) {\n                   if(parent[x]!=ar.get(j)){\n                       parent[ar.get(j)]=x;\n                    stk.push(ar.get(j));\n                   }\n                }\n               // System.out.println(\" stackfin=\"+stk);\n            }\n            return false;\n        }\n        static int distance[];\n        static ArrayList<Integer>ans= new ArrayList<>();\n\n        public static long bfs(int v){\n           long total=0;\n           Queue<Integer>q= new LinkedList<>();\n           q.add(v);\n           while(!q.isEmpty()){\n               int x= q.poll();\n               done[x]=true;\n               total++;\n               ArrayList<Integer>vals= new ArrayList<>(vt.get(x).nb.keySet());\n               for (int i = 0; i <vals.size() ; i++) {\n                   int c= vals.get(i);\n                   if(!done[c]){\n                       q.add(c);\n                   }\n               }\n\n\n\n           }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn total;\n            }\n        }\n\n\n    // int count=0;\n    //static long count=0;\n    static class Reader {\n        static BufferedReader reader;\n        static StringTokenizer tokenizer;\n\n        /**\n         * call this method to initialize reader for InputStream\n         */\n        static void init(InputStream input) {\n            reader = new BufferedReader(\n                    new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        /**\n         * get next word\n         */\n        static String next() throws IOException {\n            while (!tokenizer.hasMoreTokens()) {\n                //TODO add check for eof if necessary\n                tokenizer = new StringTokenizer(\n                        reader.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        static int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        static double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        static long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n\n\n\n\n    // After writing solution, quick scan for:\n    //   array out of bounds\n    //   special cases e.g. n=1?\n    //\n    // Big numbers arithmetic bugs:\n    //   int overflow\n    //   sorting, or taking max, or negative after MOD\n    public static void main(String[] args)  throws IOException {\n        Reader.init(System.in);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n        int n= Reader.nextInt();\n        long k= Reader.nextLong();\n        long mod=(long)(1e9 +7);\n        Graph g= new Graph();\n        for (int i = 1; i <=n ; i++) {\n            g.addVer(i);\n        }\n        long ans= power((long)n,k,mod);\n        for (int i = 0; i <n-1 ; i++) {\n            long x1= Reader.nextLong();\n            long x2= Reader.nextLong();\n            long v= Reader.nextLong();\n            if(v==0){\n                g.addEdge((int)x1,(int)x2,1);\n            }\n        }\n        g.done= new boolean[n+1];\n        for (int i = 1; i <=n ; i++) {\n            if(!g.done[i]){\n                long x=g.bfs(i);\n                ans=(ans-power(x,k,mod)+mod)%mod;\n            }\n        }\n        out.append(ans+\"\\n\");\n\n\n\n\n\n\n        \n\n\n\n\n        out.flush();\n        out.close();\n\n    }\n\n\n\n    static long modExp(long a, long b, long mod) {\n        //System.out.println(\"a is \" + a + \" and b is \" + b);\n        if (a==1) return 1;\n        long ans = 1;\n        while (b!=0) {\n            if (b%2==1) {\n                ans = (ans*a)%mod;\n            }\n            a = (a*a)%mod;\n            b/=2;\n        }\n        return ans;\n    }\n\n\n    public static long modmul(long a, long b, long mod) {\n        return b == 0 ? 0 : ((modmul(a, b >> 1, mod) << 1) % mod + a * (b & 1)) % mod;\n    }\n\n    static long sum(long n){\n        //   System.out.println(\"lol=\"+ (n*(n-1))/2);\n        return (n*(n+1))/2;\n    }\n\n\n\n\n\n\n    public static ArrayList<Integer> Sieve(int n) {\n        boolean arr[]= new boolean [n+1];\n        Arrays.fill(arr,true);\n        arr[0]=false;\n        arr[1]=false;\n        for (int i = 2; i*i <=n ; i++) {\n            if(arr[i]){\n                for (int j = 2; j <=n/i ; j++) {\n                    int u= i*j;\n                    arr[u]=false;\n                }}\n        }\n        ArrayList<Integer> ans= new ArrayList<>();\n        for (int i = 0; i <n+1 ; i++) {\n            if(arr[i]){\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n\n\n\n\n    static long power( long x, long y, long p)\n    {\n\n        long res = 1;\n\n\n        x = x % p;\n\n        if (x == 0) return 0;\n\n        while (y > 0)\n        {\n\n            if((y & 1)==1)\n                res = (res * x) % p;\n\n\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    public static long ceil_div(long a, long b){\n        return (a+b-1)/b;\n    }\n\n    static long gcd(long a, long b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    static long lcm(long a, long b)\n    {\n        return (a*b)/gcd(a, b);\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 1e9 + 7;\nvoid dfs(int node, vector<vector<pair<int, int>>>& adj, vector<bool>& vu,\n         ll& cnt) {\n  for (auto& p : adj[node]) {\n    if (!vu[p.first] and p.second == 0) {\n      vu[p.first] = true;\n      ++cnt;\n      dfs(p.first, adj, vu, cnt);\n    }\n  }\n}\nll getPow(ll a, ll p) {\n  ll ret = 1, cp = a;\n  while (p) {\n    if (p & 1) ret = (ret * cp) % MOD;\n    p >>= 1;\n    cp = (cp * cp) % MOD;\n  }\n  return ret;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, k, a, b, c;\n  cin >> n >> k;\n  vector<vector<pair<int, int>>> adj(n + 1);\n  for (int i = 1; i < n; ++i) {\n    cin >> a >> b >> c;\n    adj[a].emplace_back(b, c);\n    adj[b].emplace_back(a, c);\n  }\n  vector<bool> vu(n + 1);\n  ll ans = getPow(n, k);\n  for (int i = 1; i <= n; ++i) {\n    if (!vu[i]) {\n      ll tmp = 1;\n      vu[i] = true;\n      dfs(i, adj, vu, tmp);\n      ans = (ans - getPow(tmp, k)) % MOD;\n    }\n  }\n  cout << (ans + MOD) % MOD;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static int n, k;\n    static ArrayDeque[] edges;\n    static boolean[] seen;\n    static long mod = (long)(1e9 + 7);\n\tpublic static void main (String[] args) throws IOException {\n\t    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t    String[] line = br.readLine().split(\" \");\n\t    n = p(line[0]);\n\t    k = p(line[1]);\n\t    edges = new ArrayDeque[n];\n\t    for(int i = 0; i < n; ++i) edges[i] = new ArrayDeque<>();\n\t    \n\t    for(int i = 0; i < n - 1; ++i){\n\t        line = br.readLine().split(\" \");\n\t        int a = p(line[0]) - 1, b = p(line[1]) - 1, c = p(line[2]);\n\t        edges[a].offer(new edge(b, c));\n\t        edges[b].offer(new edge(a, c));\n\t    }\n\t    \n\t    long tot = pow(n, k);\n\t    seen = new boolean[n];\n\t    for(int i = 0; i < n; ++i){\n\t        if(!seen[i]){\n\t            int size = dfs(i);\n\t            long num = pow(size, k);\n\t            tot = (tot - num + mod) % mod;\n\t        }\n\t    }\n\t    \n\t    System.out.println(tot);\n\t}\n\tstatic int dfs(int idx){\n\t    seen[idx] = true;\n\t    int out = 1;\n\t    for(edge e : (ArrayDeque<edge>) edges[idx]){\n\t        if(!seen[e.v] && e.c == 0){\n\t            out += dfs(e.v);\n\t        }\n\t    }\n\t    return out;\n\t}\n\tstatic long pow(long base, int pow){\n\t    if(pow == 0) return 1;\n\t    if(pow == 1) return base;\n\t    long out = pow(base, pow / 2);\n\t    out = (out * out) % mod;\n\t    if(pow % 2 == 1) out = (out * base) % mod;\n\t    return out;\n\t}\n\tstatic class edge{\n\t    int v, c;\n\t    edge(int vv, int cc){\n\t        v = vv;\n\t        c = cc;\n\t    }\n\t}\n\tstatic int p(String in){\n\t    return Integer.parseInt(in);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline T GCD(T a, T b) {\n  a = abs(a);\n  b = abs(b);\n  if (a < b) swap(a, b);\n  while (b) {\n    a = a % b;\n    swap(a, b);\n  }\n  return a;\n}\ntemplate <typename T>\ninline T EGCD(T a, T b, T &x, T &y) {\n  if (a == 0) {\n    x = 0;\n    y = 1;\n    return b;\n  }\n  T x1, y1;\n  T d = EGCD(b % a, a, x1, y1);\n  x = y1 - (b / a) * x1;\n  y = x1;\n  return d;\n}\ntemplate <typename T>\ninline T LCM(T x, T y) {\n  T tp = GCD(x, y);\n  if ((x / tp) * 1. * y > 9e18) return 9e18;\n  return (x / tp) * y;\n}\ntemplate <typename T>\ninline T BigMod(T A, T B) {\n  T ret = 1;\n  while (B) {\n    if (B & 1) ret = (ret * A) % 1000000007;\n    A = (A * A) % 1000000007;\n    B = B >> 1;\n  }\n  return ret;\n}\ntemplate <typename T>\ninline T InvMod(T A, T M = 1000000007) {\n  return BigMod(A, M - 2);\n}\nvector<pair<int, int> > g[1000007];\nlong long node, k;\nint vis[1000007];\nint dfs(int u) {\n  vis[u] = 1;\n  int cc = 1;\n  for (auto ch : g[u]) {\n    if (ch.second == 0 && vis[ch.first] == 0) {\n      cc += dfs(ch.first);\n    }\n  }\n  return cc;\n}\nint main(void) {\n  scanf(\"%lld%lld\", &node, &k);\n  for (int i = 1; i < node; i++) {\n    int x, y, z;\n    scanf(\"%d%d%d\", &x, &y, &z);\n    g[x].push_back({y, z});\n    g[y].push_back({x, z});\n  }\n  long long ans = BigMod(node, k);\n  for (int i = 1; i <= node; i++) {\n    if (vis[i] == 0) {\n      long long res = dfs(i);\n      ans = (ans - BigMod(res, k) + 1000000007) % 1000000007;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport static java.lang.System.in;\n\npublic class Main {\n    static int n,k;\n    static long mod = 1000000000+7;\n    static long[] fac,inv;\n    static int[] id,size;\n    //static long mod = 1000000000+7;\n    //static HashSet<Integer>[] graph;\n    public static void main(String[] args)throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String[] buf = reader.readLine().split(\" \");\n        //Scanner sc = new Scanner(System.in);\n        n = Integer.parseInt(buf[0]); k = Integer.parseInt(buf[1]);\n        init();\n        id = new int[n+1]; size = new int[n+1];\n        Arrays.fill(size,1);\n        for(int i=1;i<=n;i++) id[i] = i;\n        for(int i=0;i<n-1;i++){\n            buf = reader.readLine().split(\" \");\n            int a=Integer.parseInt(buf[0]), b=Integer.parseInt(buf[1]), color=Integer.parseInt(buf[2]);\n            if(color==0) unite(a,b);\n        }\n        boolean[] vis = new boolean[n+1];\n        long res = 0; // to record the only-red-edge choices\n        for(int i=1;i<=n;i++){\n            int root = find(i);\n            if(vis[root]) continue;\n            vis[root] = true;\n            int len = size[root];\n            long cur = power(len,k)-len;\n            res = (res+cur)%mod;\n        }\n        long ans = power(n,k)-n;\n        ans = (ans+mod-res)%mod;\n        System.out.println(ans);\n    }\n    static int find(int p){\n        while(p!=id[p]){\n            id[p]=id[id[p]];\n            p=id[p];\n        }\n        return p;\n    }\n    static void unite(int p, int q){\n        int i=find(p), j=find(q);\n        if(i==j) return;\n        id[j] = i;\n        size[i] += size[j];\n    }\n    static void init(){\n        fac = new long[n+1]; inv = new long[n+1];\n        fac[0] = 1; inv[0] = 1;\n        for(int i=1;i<=n;i++) fac[i] = fac[i-1]*i;\n        inv[n] = power(fac[n],mod-2);\n        for(int i=n-1;i>=0;i--) inv[i] = (i+1)*inv[i+1]%mod;\n    }\n    static long power(long base, long p){\n        long ans = 1;\n        while(p>0){\n            if(p%2==1) ans = ans*base%mod;\n            base = base*base%mod;\n            p /= 2;\n        }\n        return ans;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main\n{\n    static ArrayList<Integer> edge[];\n    static int dfs(int src,boolean vis[],int cntr)\n    {\n        vis[src]=true;\n        for(int i=0;i<edge[src].size();i++)\n        {\n            int tp=edge[src].get(i);\n            if(!vis[tp])\n            {\n                cntr=dfs(tp,vis,cntr+1);\n            }\n        }\n        return cntr;\n    }\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw=new PrintWriter(System.out);\n        String str[]=br.readLine().split(\" \");\n        int n=Integer.parseInt(str[0]);\n        int k=Integer.parseInt(str[1]);\n        //Set<Integer> set=new HashSet<>();\n        edge=new ArrayList[n+1];\n        for(int i=1;i<=n;i++)\n        edge[i]=new ArrayList<>();\n        for(int i=0;i<n-1;i++)\n        {\n            str=br.readLine().split(\" \");\n            int u=Integer.parseInt(str[0]);\n            int v=Integer.parseInt(str[1]);\n            int x=Integer.parseInt(str[2]);\n            if(x==0)\n            {\n                edge[u].add(v);\n                edge[v].add(u);\n            }\n        }\n        BigInteger big=new BigInteger(Integer.toString(n));\n        big=big.pow(k);\n        boolean vis[]=new boolean[n+1];\n        for(int i=1;i<=n;i++)\n        {\n            if(!vis[i]&&edge[i].size()>0)\n            {\n                int nov=dfs(i,vis,1);\n                BigInteger temp=new BigInteger(Integer.toString(nov)).pow(k);\n                temp=temp.subtract(new BigInteger(Integer.toString(nov)));\n                big=big.subtract(temp);\n            }\n        }\n        big=big.subtract(new BigInteger(Integer.toString(n)));\n        pw.println(big.mod(new BigInteger(\"1000000007\")));\n        pw.flush();\n        pw.close();\n    }\n}"
        },
        {
            "language": 3,
            "solution": "# 1-indexed verticies\n\nimport sys\nsys.setrecursionlimit(10 ** 5 + 10)\n\nn, k = map(int, input().split())\n\nparents = [i for i in range(n + 1)]\nsize = [1 for i in range(n + 1)]\n\ndef find(a):\n\tif a == parents[a]:\n\t\treturn a\n\tparents[a] = find(parents[a])\n\treturn parents[a]\n\ndef union(a, b):\n\ta = find(a)\n\tb = find(b)\n\tif a != b:\n\t\tif size[a] < size[b]:\n\t\t\ta, b = b, a\n\t\tparents[b] = a\n\t\tsize[a] += size[b]\n\ndef same(a, b):\n\treturn find(a) == find(b)\n\nfor _ in range(n - 1):\n\ta, b, c = map(int, input().split())\n\tif c == 0:\n\t\tunion(a, b)\n\ndictionary = {}\nfor i in range(1, n + 1):\n\tf = find(i)\n\tif f not in dictionary:\n\t\tdictionary[f] = 0\n\tdictionary[f] += 1\n\ns = n ** k\nfor key in dictionary:\n\ts -= dictionary[key] ** k\nprint (s % (10 ** 9 + 7))"
        },
        {
            "language": 3,
            "solution": "import sys\n[n, k] = list(map(int,sys.stdin.readline().strip().split()))\nA = [[] for i in range (0, n)]\nC = [0] * n\ne = 0\nans = 1\nfor i in range (0, k // 10):\n    ans = (ans * (n ** 10)) % (10 ** 9 + 7)\nfor i in range (0, k % 10):\n    ans = (ans * n) % (10 ** 9 + 7)\nfor i in range (0, n - 1):\n    line = sys.stdin.readline().strip().split()\n    u = int(line[0]) - 1\n    v = int(line[1]) - 1\n    if int(line[2]) == 0:\n        A[u].append(v)\n        A[v].append(u)\n        e = e + 2\n\nfor i in range (0, n):\n    if len(A[i]) == 0:\n        ans = ans - 1\n        C[i] = -1\n        \nwhile e != 0:\n    i = 0\n    x = 0\n    while C[i] == -1:\n        i = i + 1\n    L = [i]\n    while len(L) != 0:\n        i = L.pop()\n        if C[i] != -1:\n            for j in A[i]:\n                L.append(j)\n                e = e - 1\n            x = x + 1\n            C[i] = -1\n    y = 1\n    for i in range (0, k // 10):\n        y = (y * (x ** 10)) % (10 ** 9 + 7)\n    for i in range (0, k % 10):\n        y = (y * x) % (10 ** 9 + 7)\n    ans = ans - y\n    \nans = (ans % (10 ** 9 + 7) + 10 ** 9 + 7) % (10 ** 9 + 7)\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long power(long long a, long long b, long long m) {\n  long long ans = 1;\n  a %= m;\n  while (b) {\n    if (b & 1) ans = (ans * a) % m;\n    a = (a * a) % m;\n    b >>= 1;\n  }\n  return ans;\n}\nvector<long long> adj[100009];\nbool vis[100009];\nlong long sz = 0;\nvoid dfs(int i) {\n  vis[i] = true;\n  sz++;\n  for (auto v : adj[i]) {\n    if (vis[v] == false) dfs(v);\n  }\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin.tie(0);\n  memset(vis, false, sizeof(vis));\n  unsigned long long n, k, u, v, c;\n  cin >> n >> k;\n  for (long long i = 1; i < n; ++i) {\n    cin >> u >> v >> c;\n    if (c == 0) {\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n  }\n  long long ans = (power(n, k, 1000000007) - n) % 1000000007;\n  for (long long i = 1; i <= n; ++i) {\n    if (vis[i] == false) {\n      sz = 0;\n      dfs(i);\n      ans += 1000000007;\n      ans -= power(sz, k, 1000000007);\n      ans += sz;\n      ans = ans % 1000000007;\n    }\n  }\n  ans = ans % 1000000007;\n  while (ans < 0) {\n    ans += 1000000007;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def union(x, y, sets: list, parents: list, inds: set):\n    x = parents[x]\n    y = parents[y]\n    if x == y:\n        return\n\n    if len(sets[x]) > len(sets[y]):\n        x, y = y, x\n    inds.discard(x)\n    for nd in sets[x]:\n        parents[nd] = y\n        sets[y].append(nd)\n\n\nn, k = map(int, input().split())\nparents = list(range(n))\nsets = [[i] for i in range(n)]\ninds = set(range(n))\nfor _ in range(n-1):\n    x, y, c = map(int, input().split())\n    x -= 1\n    y -= 1\n    if c == 0:\n       union(x, y, sets, parents, inds)\ncnt = n**k\nfor i in inds:\n    cnt -= len(sets[i])**k\nprint(cnt % (10**9 + 7))"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    public static void main(String[] args) throws IOException {\n        try {\n            in = new BufferedReader(new FileReader(\"unequal.in\"));\n            out = new PrintWriter(new File(\"unequal.out\"));\n        } catch (Exception e) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n        }\n        tok = new StringTokenizer(\"\");\n        new A().solve();\n        out.flush();\n        out.close();\n    }\n\n    String nextTok() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    String nextLine() throws IOException {\n        return in.readLine();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextTok());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextTok());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextTok());\n    }\n\n\n    class Pair implements Comparable<Pair> {\n        int x;\n        int y;\n        Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            if (this.x != o.x) {\n                return Integer.compare(this.x, o.x);\n            } else {\n                return Integer.compare(this.y, o.y);\n            }\n        }\n    }\n\n    int mod = 1000000007;\n    ArrayList<Integer>[] g;\n    boolean used[];\n    int cnt = 0;\n\n    void solve() throws IOException {\n        int n = nextInt();\n        int k = nextInt();\n        g = new ArrayList[n];\n        used = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            g[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int from = nextInt() - 1;\n            int to = nextInt() - 1;\n            int color = nextInt();\n            if (color == 0) {\n                g[from].add(to);\n                g[to].add(from);\n            }\n        }\n\n        long bad = 0;\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                cnt = 0;\n                dfs(i);\n                bad = (bad + binPow(cnt, k)) % mod;\n            }\n        }\n\n        out.println((binPow(n, k) - bad + mod) % mod);\n\n    }\n\n    void dfs(int v) {\n        used[v] = true;\n        cnt++;\n        for (int to: g[v]) {\n            if (!used[to]) {\n                dfs(to);\n            }\n        }\n    }\n\n    long binPow(long a, long b) {\n        long res = 1;\n        while (b != 0) {\n            if ((b & 1) == 1) {\n                res = (res * a) % mod;\n            }\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Jenish\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CEdgyTrees solver = new CEdgyTrees();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CEdgyTrees {\n        ArrayList<Integer>[] arrayList;\n        boolean[] visited;\n        long c = 0;\n        long mod = (long) (1e9 + 7);\n\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            int n = in.scanInt();\n            int k = in.scanInt();\n            arrayList = new ArrayList[n + 1];\n            for (int i = 0; i <= n; i++) arrayList[i] = new ArrayList<>();\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.scanInt();\n                int b = in.scanInt();\n                int c = in.scanInt();\n                if (c == 0) {\n                    arrayList[a].add(b);\n                    arrayList[b].add(a);\n                }\n            }\n\n            visited = new boolean[n + 1];\n            long sub = 0;\n            for (int i = 1; i <= n; i++) {\n                if (!visited[i]) {\n                    c = 0;\n                    DFS(i);\n                    sub = (sub + CodeX.power(c, k, mod)) % mod;\n                }\n            }\n            long ans = CodeX.power(n, k, mod);\n            ans = ans - sub;\n            while (ans < 0) ans += mod;\n            out.println(ans);\n\n        }\n\n        void DFS(int s) {\n            c++;\n            visited[s] = true;\n            for (int j : arrayList[s]) {\n                if (!visited[j]) {\n                    DFS(j);\n                }\n            }\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int INDEX;\n        private BufferedInputStream in;\n        private int TOTAL;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (INDEX >= TOTAL) {\n                INDEX = 0;\n                try {\n                    TOTAL = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (TOTAL <= 0) return -1;\n            }\n            return buf[INDEX++];\n        }\n\n        public int scanInt() {\n            int I = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    I *= 10;\n                    I += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * I;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n    }\n\n    static class CodeX {\n        public static long power(long x, long y, long p) {\n            long res = 1;\n            x = x % p;\n            while (y > 0) {\n                if ((y & 1) != 0)\n                    res = (res * x) % p;\n                y = y >> 1;\n                x = (x * x) % p;\n            }\n            return res;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "\n# -*- coding: utf-8 -*-\n# @Date    : 2019-03-22 08:08:26\n# @Author  : raj lath (oorja.halt@gmail.com)\n# @Link    : link\n# @Version : 1.0.0\n\nimport sys\nsys.setrecursionlimit(10**5+1)\n\ninf     =  int(10 ** 20)\nmax_val =  inf\nmin_val = -inf\n\nRW  = lambda : sys.stdin.readline().strip()\nRI  = lambda : int(RW())\nRMI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRWI = lambda : [x for x in sys.stdin.readline().strip().split()]\n\nvertices, limit = RMI()\ngraph = [[] for _ in range(vertices)]\nfor i in range(vertices - 1):\n    u, v, x = RMI()\n    graph[u - 1].append((v - 1, x))\n    graph[v - 1].append((u - 1, x))\ndone = [0 for _ in range(vertices)]\ncomps = []\nfor i in range(vertices):\n    if done[i]:continue\n    done[i] = 1\n    comps.append([i])\n    qu = [i]\n    while qu:\n        curr_u = qu[0]\n        qu = qu[1:]\n        for u, x in graph[curr_u]:\n            if x == 0 and done[u] == 0:\n                qu.append(u)\n                done[u] = 1\n                comps[-1].append(u)\nanswer = vertices ** limit\n\nfor comp in comps:\n    answer -= len(comp) ** limit\n\nprint( answer % (10 ** 9 + 7))"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict as ddict\n\nway = ddict(list)\nisland = list()\nwent = set()\n\nn, k = map(int, input().split())\nfor i in range(n-1):\n    u,v,x = map(int, input().split())\n    if x == 0:\n        way[u-1].append(v-1)\n        way[v-1].append(u-1)\n\nfor i in range(n):\n    if i not in went:\n        stack = [i]\n        went.add(i)\n        mini_island = 1\n        while stack:\n            now = stack.pop()\n            for v in way[now]:\n                if v not in went:\n                    stack.append(v)\n                    went.add(v)\n                    mini_island += 1\n        island.append(mini_island)\n\n#print(island)\nmd = 10**9+7\nans = pow(n,k,md)\nfor it in island:\n    ans -= pow(it,k,md)\n    ans %= md\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split())\n\np = [i for i in range(n + 1)]\nsz = [1] * (n + 1)\n\n\ndef par(u):\n    if u == p[u]:\n        return u\n    p[u] = par(p[u])\n    return p[u]\n\n\ndef merge(u, v):\n    sz[par(v)] += sz[par(u)]\n    p[par(u)] = par(v)\n\n\nfor i in range(n - 1):\n    u, v, x = map(int, input().split())\n    if not x:\n        merge(u, v)\n\nMOD = int(1e9 + 7)\n\nans = n ** k % MOD\n\nuniques = set()\nfor i in range(1, n + 1):\n    parent = par(i)\n    if parent in uniques:\n        continue\n    uniques.add(parent)\n    ans -= sz[parent] ** k % MOD\n    if ans < 0:\n        ans += MOD\n\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "import math,sys\n#from itertools import permutations, combinations;import heapq,random;\n# from collections import defaultdict,deque\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\n#sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\ndef I():return (int(sys.stdin.readline()))\ndef In():return(map(int,sys.stdin.readline().split()))\ndef Sn():return sys.stdin.readline().strip()\n#sys.setrecursionlimit(1500)\ndef dict(a):\n    d={} \n    for x in a:\n        if d.get(x,-1)!=-1:\n            d[x]+=1\n        else:\n            d[x]=1\n    return d\ndef find_gt(a, x):\n    'Find leftmost value greater than x'\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:            \n        return -1\ndef dfs(d,visit,s):\n    q=[s]\n    cnt=0\n    while q:\n        t=q.pop(0)\n        visit[t]=True\n        cnt+=1\n        for x in d[t]:\n            if visit[x]==False:\n                q.insert(0,x)\n    return cnt\ndef mod(a, b, c):\n    res = a * b\n    return res % c\n\ndef power(a, b, m):\n    x, y = 1,a\n    while (b > 0):\n        if (b & 1):x = mod(x, y, m)\n        y = mod(y, y, m)\n        b >>= 1\n    return x\ndef expo(a, b):\n    x, y = 1, a\n    while (b > 0):\n        if (b & 1):\n            x = x * y\n        y = y * y\n        b >>= 1\n    return x\ndef main():\n    try:\n        n,k=In()\n        d=[[] for x in range(n+1)]\n        for i in range(n-1):\n            a,b,c=In()\n            if c==0:\n                d[a].append(b)\n                d[b].append(a)\n        ans=power(n,k,P)\n        visit=[False for x in range(n+1)]\n        for i in range(1,n+1):\n            if not visit[i]:\n                ans-=power(dfs(d,visit,i),k,P)\n        print(ans%P)\n    except:\n        pass\n\nM = 998244353\nP = 1000000007\n \nif __name__ == '__main__':\n    # for _ in range(I()):main()\n    for _ in range(1):main()\n#End#\n\n#        ******************* All The Best *******************   #"
        },
        {
            "language": 3,
            "solution": "import collections\n\nclass UnionFind:\n    \"\"\"Weighted quick-union with path compression.\n    The original Java implementation is introduced at\n    https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf\n    >>> uf = UnionFind(10)\n    >>> for (p, q) in [(3, 4), (4, 9), (8, 0), (2, 3), (5, 6), (5, 9),\n    ...                (7, 3), (4, 8), (6, 1)]:\n    ...     uf.union(p, q)\n    >>> uf._id\n    [8, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    >>> uf.find(0, 1)\n    True\n    >>> uf._id\n    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    \"\"\"\n\n    def __init__(self, n):\n        self._id = list(range(n))\n        self._sz = [1] * n\n\n    def _root(self, i):\n        j = i\n        while (j != self._id[j]):\n            self._id[j] = self._id[self._id[j]]\n            j = self._id[j]\n        return j\n\n    def find(self, p, q):\n        return self._root(p) == self._root(q)\n    \n    def union(self, p, q):\n        i = self._root(p)\n        j = self._root(q)\n        if i == j:\n            return\n        if (self._sz[i] < self._sz[j]):\n            self._id[i] = j\n            self._sz[j] += self._sz[i]\n        else:\n            self._id[j] = i\n            self._sz[i] += self._sz[j]\n\nn, k = map(int, input().split())\n\nuf = UnionFind(n)\n\nfor i in range(n-1):\n    u, v, x = map(int, input().split())\n    u -= 1\n    v -= 1\n    if x==0:\n        uf.union(u, v)\n\nd = collections.defaultdict(int)\nfor i in range(n):\n    d[uf._root(i)] += 1\n\ntotal = pow(n, k, 10**9+7)\nfor size in d.values():\n    total -= pow(size, k, 10**9+7)\n\ntotal %= 10**9+7\n\nprint(total)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 1e5 + 1;\nvector<long long> tr[maxn];\nlong long visited[maxn];\nlong long dfs(long long i) {\n  visited[i] = 1;\n  long long y = 0;\n  for (long long x : tr[i]) {\n    if (!visited[x]) y += dfs(x);\n  }\n  return 1 + y;\n}\nvoid solve() {\n  long long n, k;\n  cin >> n >> k;\n  vector<long long> v;\n  memset(visited, 0, sizeof(visited));\n  for (long long i = 0; i < n - 1; ++i) {\n    long long x, y, w;\n    cin >> x >> y >> w;\n    if (w == 1) continue;\n    tr[x].push_back(y);\n    tr[y].push_back(x);\n  }\n  for (long long i = 1; i <= n; ++i) {\n    long long ct = 0;\n    if (!visited[i]) ct = dfs(i);\n    if (ct != 0) v.push_back(ct);\n  }\n  long long ans = 1;\n  for (long long i = 0; i < k; ++i) (ans *= n) %= 1000000007;\n  long long xx = 0;\n  for (long long x : v) {\n    long long y = 1;\n    for (long long i = 0; i < k; ++i) (y *= x) %= 1000000007;\n    (xx += y) %= 1000000007;\n  }\n  cout << (ans - xx + 1000000007) % 1000000007 << endl;\n}\nsigned main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  long long t = 1;\n  for (long long i = 1; i <= t; ++i) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nvector<vector<pair<int, int> > > adj(100005);\nbool visited[100005];\ndeque<int> nodes;\nlong long ans1 = 0;\nlong long ans = 1;\nint x = 1;\nlong long mod = 1000000007;\nvoid dfs(int nd) {\n  visited[nd] = true;\n  for (int i = 0; i < adj[nd].size(); i++) {\n    if (visited[adj[nd][i].first] == false) {\n      if (adj[nd][i].second == 1) {\n        nodes.push_back(adj[nd][i].first);\n      } else {\n        x++;\n        dfs(adj[nd][i].first);\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  int a, b, c;\n  for (int i = 0; i < int(n - 1); i++) {\n    scanf(\"%d %d %d\", &a, &b, &c);\n    adj[a].push_back(make_pair(b, c));\n    adj[b].push_back(make_pair(a, c));\n  }\n  memset(visited, false, sizeof visited);\n  nodes.push_back(1);\n  for (int i = 0; i < int(k); i++) {\n    ans = (n * ans) % mod;\n  }\n  long long aux = 1;\n  while (nodes.size() > 0) {\n    x = 1;\n    int aux2 = nodes.back();\n    nodes.pop_back();\n    dfs(aux2);\n    aux = 1;\n    for (int i = 0; i < int(k); i++) {\n      aux = (x * aux) % mod;\n    }\n    ans1 = (ans1 + aux) % mod;\n  }\n  if (ans1 > ans) {\n    ans += mod;\n  }\n  cout << (ans - ans1) % mod << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "MOD = 1000000007\n\ndef find(x):\n  if parent[x] != x:\n    parent[x] = find(parent[x])\n  return parent[x]\n\ndef union(x, y):\n  x_par = find(x)\n  y_par = find(y)\n  if x_par != y_par:\n    parent[x_par] = y_par\n    size[y_par] += size[x_par]\n    size[x_par] = 0\n\nn, k = map(int, raw_input().split())\nparent = [i for i in range(n)]\nsize = [1 for i in range(n)]\nsol = n**k\nfor _ in range(n-1):\n    x, y, c = map(int, raw_input().split())\n    if c == 0:\n        union(x-1, y-1)\n\nfor elm in size:\n  sol -= elm**k\n\nprint sol%MOD"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid printprecise(double l, long long int precision) {\n  std::cout << std::fixed;\n  std::cout << std::setprecision(precision);\n  std::cout << l;\n}\nlong long int power_wm(long long int x, long long int y, long long int p) {\n  long long int res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nlong long int power(long long int x, long long int y) {\n  long long int res = 1;\n  while (y > 0) {\n    if (y & 1) res = (res * x);\n    y = y >> 1;\n    x = (x * x);\n  }\n  return res;\n}\nlong long int root(long long int x, vector<long long int> &roots) {\n  if (roots[x] != x) roots[x] = root(roots[x], roots);\n  return roots[x];\n}\nvoid unoin(long long int p, long long int q, vector<long long int> &roots,\n           vector<long long int> &rank) {\n  long long int rp = root(p, roots);\n  long long int rq = root(q, roots);\n  if (rank[rq] < rank[rp]) {\n    roots[rq] = rp;\n  } else if (rank[rp] > rank[rq]) {\n    roots[rp] = rq;\n  } else {\n    roots[rp] = rq;\n    rank[rq]++;\n  }\n}\nlong long int dig_sum(long long int n) {\n  long long int s = 0;\n  while (n) {\n    s += n % 10;\n    n /= 10;\n  }\n  return s;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n, k;\n  cin >> n >> k;\n  vector<long long int> roots(n), rank(n);\n  for (long long int i = 0; i < n; i++) {\n    roots[i] = i;\n  }\n  long long int a, b, x;\n  for (long long int i = 0; i < n - 1; i++) {\n    cin >> a >> b >> x;\n    if (x) continue;\n    a--, b--;\n    unoin(a, b, roots, rank);\n  }\n  vector<long long int> ccs(n);\n  for (long long int i = 0; i < n; i++) {\n    ccs[root(i, roots)]++;\n  }\n  long long int badSequences = 0;\n  for (long long int i = 0; i < n; i++) {\n    badSequences =\n        (badSequences + power_wm(ccs[i], k, 1000000007)) % 1000000007;\n  }\n  cout << (power_wm(n, k, 1000000007) - badSequences + 1000000007) % 1000000007;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\npublic class C {\n\tstatic BufferedReader br;\n\tstatic PrintWriter pr;\n\tstatic int cin() throws Exception\n\t{\n\t\treturn Integer.valueOf(br.readLine());\n\t}\n\tstatic int[] split() throws Exception\n\t{\n\t\tString[] cmd=br.readLine().split(\" \");\n\t\tint[] ans=new int[cmd.length];\n\t\tfor(int i=0;i<cmd.length;i++)\n\t\t{\n\t\t\tans[i]=Integer.valueOf(cmd[i]);\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic long[] splitL() throws IOException\n\t{\n\t\tString[] cmd=br.readLine().split(\" \");\n\t\tlong[] ans=new long[cmd.length];\n\t\tfor(int i=0;i<cmd.length;i++)\n\t\t{\n\t\t\tans[i]=Long.valueOf(cmd[i]);\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic long p=1000000007;\n\tstatic long power(long x, long y) \n    { \n        long res = 1;      \n        x = x % p;  \n       if (x == 0) return 0;\n        while (y > 0) \n        { \n            if((y & 1)==1) \n                res = (res * x) % p; \n            y = y >> 1;  \n            x = (x * x) % p;  \n        } \n        return res; \n    }\n\tstatic int[]par;\n\tstatic int[]rank;\n\tstatic int[]size;\n\tstatic int find(int n)\n\t{\n\t\tif(n==par[n])\n\t\t\treturn n;\n\t\treturn par[n]=find(par[n]);\n\t}\n\tstatic void union(int x,int y)\n\t{\n\t\tint p1=find(x);\n\t\tint p2=find(y);\n\t\tif(p1==p2)\n\t\t\treturn;\n\t\tif(rank[p1]>rank[p2])\n\t\t{\n\t\t\tpar[p2]=p1;\n\t\t\tsize[p1]+=size[p2];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[p1]=p2;\n\t\t\tif(rank[p1]==rank[p2])\n\t\t\t\trank[p1]++;\n\t\t\tsize[p2]+=size[p1];\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws Exception{\n\t\t// TODO Auto-generated method stub\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t\tpr=new PrintWriter(new OutputStreamWriter(System.out));\n\t\tint cases=1;\n\t\twhile(cases!=0)\n\t\t{\n\t\t\tcases--;\n\t\t\tint[]arr=split();\n\t\t\tint n=arr[0];\n\t\t\tint k=arr[1];\n\t\t\tpar=new int[n+1];\n\t\t\trank=new int[n+1];\n\t\t\tsize=new int[n+1];\n\t\t\tArrays.fill(size, 1);\n\t\t\tlong mod=(long)1e9+7;\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t{\n\t\t\t\tpar[i]=i;\n\t\t\t}\n\t\t\tint[]mark=new int[n+1];\n\t\t\tint[][]store=new int[n][3];\n\t\t\tfor(int i=0;i<n-1;i++)\n\t\t\t{\n\t\t\t\tstore[i]=split();\n\t\t\t\tif(store[i][2]==0)\n\t\t\t\t\tunion(store[i][0],store[i][1]);\n\t\t\t}\n\t\t\tlong ans=1;\n\t\t\tfor(int i=1;i<=k;i++)\n\t\t\t{\n\t\t\t\tans=(ans*n)%mod;\n\t\t\t}\n\t\t\tint tot=0;\n\t\t\tfor(int i=0;i<n-1;i++)\n\t\t\t{\n\t\t\t\tif(store[i][2]==1)\n\t\t\t\t\tcontinue;\n\t\t\t\tint f=find(store[i][0]);\n\t\t\t\tif(mark[f]==1)\n\t\t\t\t\tcontinue;\n\t\t\t\tmark[f]=1;\n\t\t\t\tint y=size[f];\n\t\t\t\t//System.out.println(f+\" \"+y+\" \"+power((long)y,(long)k));\n\t\t\t\ttot+=y;\n\t\t\t\tans=((ans-power((long)y,(long)k))%mod+mod)%mod;\n\t\t\t}\n\t\t\ttot=n-tot;\n\t\t\tans=((ans-tot)%mod+mod)%mod;\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "# AC\nimport sys\n\n\nclass E:\n    def __init__(self, fr, to, c):\n        self.fr = fr - 1\n        self.to = to - 1\n        self.c = c\n\n\nclass Main:\n    def __init__(self):\n        self.buff = None\n        self.index = 0\n\n    def next(self):\n        if self.buff is None or self.index == len(self.buff):\n            self.buff = sys.stdin.readline().split()\n            self.index = 0\n        val = self.buff[self.index]\n        self.index += 1\n        return val\n\n    def next_int(self):\n        return int(self.next())\n\n    def solve(self):\n        n = self.next_int()\n        k = self.next_int()\n        fa = [-1 for _ in range(0, n)]\n        sz = [1 for _ in range(0, n)]\n        for _ in range(1, n):\n            fr = self.find(self.next_int() - 1, fa)\n            to = self.find(self.next_int() - 1, fa)\n            c = self.next_int()\n            if c == 0 and fr != to:\n                sz[fr] += sz[to]\n                fa[to] = fr\n        mod = 1000000007\n        ans = self.pp(n, k, mod)\n        for i in range(0, n):\n            if fa[i] == -1:\n                ans = (ans + mod - self.pp(sz[i], k, mod)) % mod\n        print(ans)\n\n    def find(self, k, fa):\n        if fa[k] == -1:\n            return k\n        fa[k] = self.find(fa[k], fa)\n        return fa[k]\n\n    def pp(self, n, k, mod):\n        if k == 0:\n            return 1\n        tmp = self.pp(n, k // 2, mod)\n        tmp = tmp * tmp % mod\n        if k % 2 == 1:\n            tmp = tmp * n % mod\n        return tmp\n\n\nif __name__ == '__main__':\n    Main().solve()\n"
        },
        {
            "language": 1,
            "solution": "M=1000000007\nR=lambda:map(int,raw_input().split())\nn,k=R()\nr=range(n+1)\nh=[0]*(n+1)\nz=[1]*(n+1)\ndef rof(x):\n    if x==r[x]:\n        return x\n    r[x]=rof(r[x])\n    return r[x]\nfor _ in range(n-1):\n    a,b,c=R()\n    if not c:\n        a=rof(a)\n        b=rof(b)\n        if a!=b:\n            if h[a]<h[b]:\n                a,b=b,a\n            r[b]=a\n            h[a]=max(h[a],h[b]+1)\n            z[a]+=z[b]\nt=pow(n,k,M)\nfor i in range(1,n+1):\n    if i==rof(i):\n        t-=pow(z[i],k,M)\nprint (t%M+M)%M"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst long long N5 = 1e5 + 9;\nconst long long N6 = 1e6 + 9;\nlong long pow(long long a, unsigned long long b, long long m) {\n  long long ans = 1;\n  a = a % m;\n  while (b > 0) {\n    if (b & 1) {\n      ans = (ans * a) % m;\n    }\n    a = (a * a) % m;\n    b = b >> 1;\n  }\n  return ans;\n}\nlong long modInverse(long long a, long long m) { return pow(a, m - 2, m) % m; }\nvoid init() {}\nlong long ans = 0;\nvoid DFS(vector<long long> graph[], long long u, long long visited[]) {\n  ans++;\n  visited[u] = 1;\n  for (long long i = 0; i < graph[u].size(); i++) {\n    if (visited[graph[u][i]] == 0) DFS(graph, graph[u][i], visited);\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long n, k;\n  cin >> n >> k;\n  vector<long long> graph[n];\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, v, w;\n    cin >> u >> v >> w;\n    if (w == 0) {\n      graph[u - 1].push_back(v - 1);\n      graph[v - 1].push_back(u - 1);\n    }\n  }\n  long long visited[n];\n  memset(visited, 0, sizeof(visited));\n  long long total = pow(n, k, mod);\n  for (long long i = 0; i < n; i++) {\n    if (visited[i] == 0) {\n      ans = 0;\n      DFS(graph, i, visited);\n      total = (total - pow(ans, k, mod) + mod) % mod;\n    }\n  }\n  cout << total << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class Main {\n    private static Scanner sc;\n    private static Printer pr;\n    static boolean []visited;\n    static ArrayList<Integer>[]list;\n    private static long aLong=(long)(Math.pow(10,9)+7);\n    private static void solve() throws IOException {\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        list=new ArrayList[n+5];\n        visited=new boolean[n+5];\n        for (int i=0;i<=n;i++)\n            list[i]=new ArrayList<>();\n        for (int i=0;i<n-1;i++){\n            int x=sc.nextInt();\n            int y=sc.nextInt();\n            int w=sc.nextInt();\n            if (w==0){\n                list[x].add(y);\n                list[y].add(x);\n            }\n        }\n        long ans=powerMod(n,k);\n        //System.out.println(\"ans:\"+ans);\n        for (int i=1;i<=n;i++){\n            //System.out.println(i);\n            if (!visited[i]){\n                int dfsValue=dfs(i);\n                long anss=powerMod(dfsValue,k);\n                ans=(ans-anss);\n                if (ans<0)\n                    ans+=aLong;\n                //System.out.println(\"ans11:\"+ans);\n            }\n        }\n        pr.println(ans);\n    }\n    public static int powerMod(long b, long e){\n        long ans=1;\n        while (e-->0){\n            ans=ans*b%aLong;\n        }\n        return (int)ans;\n    }\n    public static int dfs(int s){\n        int ans=1;\n        visited[s]=true;\n        for (int k:list[s]){\n            if (!visited[k]){\n                ans+=dfs(k);\n            }\n        }\n        return ans;\n    }\n    public static int[] radixSort(int[] f) {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for (int i = 0; i < f.length; i++) b[1 + (f[i] & 0xffff)]++;\n            for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n            for (int i = 0; i < f.length; i++) to[b[f[i] & 0xffff]++] = f[i];\n            int[] d = f;\n            f = to;\n            to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for (int i = 0; i < f.length; i++) b[1 + (f[i] >>> 16)]++;\n            for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n            for (int i = 0; i < f.length; i++) to[b[f[i] >>> 16]++] = f[i];\n            int[] d = f;\n            f = to;\n            to = d;\n        }\n        return f;\n    }\n    public static long []primeFactor(int n){\n        long []prime=new long[n+1];\n        prime[1]=1;\n        for (int i=2;i<=n;i++)\n            prime[i]=((i&1)==0)?2:i;\n        for (int i=3;i*i<=n;i++){\n            if (prime[i]==i){\n                for (int j=i*i;j<=n;j+=i){\n                    if (prime[j]==j)\n                        prime[j]=i;\n                }\n            }\n        }\n        return prime;\n    }\n    public static StringBuilder binaryradix(long number){\n        StringBuilder builder=new StringBuilder();\n        long remainder;\n        while (number!=0) {\n            remainder = number % 2;\n            number >>= 1;\n            builder.append(remainder);\n        }\n        builder.reverse();\n        return builder;\n    }\n    public static int binarySearch(long[] a, int index,long target) {\n            int l = index;\n            int h = a.length - 1;\n            while (l<=h) {\n                int med = l + (h-l)/2;\n                if(a[med] - target <= target) {\n                    l = med + 1;\n                }\n                else h = med  - 1;\n            }\n            return h;\n    }\n    public static int val(char c){\n        return c-'0';\n    }\n    public static long gcd(long a,long b) {\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n        private static class Pair implements Comparable<Pair> {\n            long x;\n            long y;\n\n            Pair() {\n                this.x = 0;\n                this.y = 0;\n            }\n\n            Pair(long x, long y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            @Override\n            public boolean equals(Object obj) {\n                if (this == obj) {\n                    return true;\n                }\n                if (obj == null) return false;\n                Pair other = (Pair) obj;\n                if (this.x == other.x && this.y == other.y) {\n                    return true;\n                }\n                return false;\n            }\n\n            @Override\n            public int compareTo(Pair other) {\n                if (this.x != other.x) return Long.compare(this.x, other.x);\n                return Long.compare(this.y*other.x, this.x*other.y);\n            }\n    }\n\n    public static void main(String[] args) throws IOException {\n        sc = new Scanner(System.in);\n        pr = new Printer(System.out);\n        solve();\n\n        pr.close();\n       // sc.close();\n    }\n    private static class Scanner {\n        BufferedReader br;\n\n        Scanner (InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        private boolean isPrintable(int ch) {\n            return ch >= '!' && ch <= '~';\n        }\n\n        private boolean isCRLF(int ch) {\n            return ch == '\\n' || ch == '\\r' || ch == -1;\n        }\n\n        private int nextPrintable() {\n            try {\n                int ch;\n                while (!isPrintable(ch = br.read())) {\n                    if (ch == -1) {\n                        throw new NoSuchElementException();\n                    }\n                }\n\n                return ch;\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        String next() {\n            try {\n                int ch = nextPrintable();\n                StringBuilder sb = new StringBuilder();\n                do {\n                    sb.appendCodePoint(ch);\n                } while (isPrintable(ch = br.read()));\n\n                return sb.toString();\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        int nextInt() {\n            try {\n                // parseInt from Integer.parseInt()\n                boolean negative = false;\n                int res = 0;\n                int limit = -Integer.MAX_VALUE;\n                int radix = 10;\n\n                int fc = nextPrintable();\n                if (fc < '0') {\n                    if (fc == '-') {\n                        negative = true;\n                        limit = Integer.MIN_VALUE;\n                    } else if (fc != '+') {\n                        throw new NumberFormatException();\n                    }\n                    fc = br.read();\n                }\n                int multmin = limit / radix;\n\n                int ch = fc;\n                do {\n                    int digit = ch - '0';\n                    if (digit < 0 || digit >= radix) {\n                        throw new NumberFormatException();\n                    }\n                    if (res < multmin) {\n                        throw new NumberFormatException();\n                    }\n                    res *= radix;\n                    if (res < limit + digit) {\n                        throw new NumberFormatException();\n                    }\n                    res -= digit;\n\n                } while (isPrintable(ch = br.read()));\n\n                return negative ? res : -res;\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        long nextLong() {\n            try {\n                // parseLong from Long.parseLong()\n                boolean negative = false;\n                long res = 0;\n                long limit = -Long.MAX_VALUE;\n                int radix = 10;\n\n                int fc = nextPrintable();\n                if (fc < '0') {\n                    if (fc == '-') {\n                        negative = true;\n                        limit = Long.MIN_VALUE;\n                    } else if (fc != '+') {\n                        throw new NumberFormatException();\n                    }\n                    fc = br.read();\n                }\n                long multmin = limit / radix;\n\n                int ch = fc;\n                do {\n                    int digit = ch - '0';\n                    if (digit < 0 || digit >= radix) {\n                        throw new NumberFormatException();\n                    }\n                    if (res < multmin) {\n                        throw new NumberFormatException();\n                    }\n                    res *= radix;\n                    if (res < limit + digit) {\n                        throw new NumberFormatException();\n                    }\n                    res -= digit;\n\n                } while (isPrintable(ch = br.read()));\n\n                return negative ? res : -res;\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            try {\n                int ch;\n                while (isCRLF(ch = br.read())) {\n                    if (ch == -1) {\n                        throw new NoSuchElementException();\n                    }\n                }\n                StringBuilder sb = new StringBuilder();\n                do {\n                    sb.appendCodePoint(ch);\n                } while (!isCRLF(ch = br.read()));\n\n                return sb.toString();\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n            }\n        }\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class List {\n        String Word;\n        int length;\n\n        List(String Word, int length) {\n            this.Word = Word;\n            this.length = length;\n        }\n    }\n    private static class Printer extends PrintWriter {\n        Printer(PrintStream out) {\n            super(out);\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n    import java.lang.*;\n    import java.io.*;\n    public class C{\n\n    \tstatic long MOD = 1000000007;\n        public static int dfs(int u,boolean visited[],ArrayList<Integer> list[]){\n        \tint count =0;\n        \tfor(int neighbour : list[u]){\n        \t\tif(!visited[neighbour]){\n        \t\t\tvisited[neighbour] =true;\n        \t\t\tcount += dfs(neighbour,visited,list);\n        \t\t}\n        \t}\n        \treturn 1 + count;\n        }\n\n        public static long pow(int a,int b){\n\t\t    long x =a,y=b;\n\t\t    long res = 1;\n\t\t    while (y > 0) \n\t\t    { \n\t\t        // If y is odd, multiply x with result \n\t\t        if (y %2!=0) \n\t\t            res = (res*x)%MOD; \n\n\t\t        y = y>>1; // y = y/2 \n\t\t        x = (x*x)%MOD;  // Change x to x^2 \n\t\t    } \n\t\t    return res%MOD; \n\t\t}\n\n        public static long f(long count,int connected,int k){\n        \treturn count = (count +pow(connected,k))%MOD;\n        }\n\n        public static void main(String[] args){\n            InputStream inputStream = System.in;\n            InputReader in = new InputReader(inputStream);\n            int n = in.nextInt();\n            int k = in.nextInt();\n            ArrayList<Integer> list[] = new ArrayList[n+1];\n            for(int i=1;i<=n;i++)\n            \tlist[i] = new ArrayList<Integer>();\n            for(int i=0;i<n-1;i++){\n            \tint u = in.nextInt();\n            \tint v = in.nextInt();\n            \tint x = in.nextInt();\n            \tif(x==0){\n            \t\tlist[u].add(v);\n            \t\tlist[v].add(u);\n            \t}\n            }\n            //perform dfs:\n            long count = 0;\n            boolean visited[] = new boolean[n+1];\n            for(int u=1;u<=n;u++){\n            \tint connected = 0;\n            \tif(!visited[u]){\n            \t\tvisited[u] = true;\n            \t\tconnected = dfs(u,visited,list);\n            \t}\n            \t// System.out.println(connected);\n            \tcount = f(count,connected,k);\n            }\n            count = (pow(n,k) - count)%MOD;\n            if(count<0)\n            \tcount += MOD;\n            System.out.println(count);\n        }\n\n        static class InputReader {\n            public BufferedReader reader;\n            public StringTokenizer tokenizer;\n\n            public InputReader(InputStream stream) {\n                reader = new BufferedReader(new InputStreamReader(stream), 32768);\n                tokenizer = null;\n            }\n\n            public String next() {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    try {\n                        tokenizer = new StringTokenizer(reader.readLine());\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n                return tokenizer.nextToken();\n            }\n\n            public long nextLong() {\n                return Long.parseLong(next());\n            }\n            public int nextInt() {\n                return Integer.parseInt(next());\n            }\n        }\n    }"
        },
        {
            "language": 4,
            "solution": "/*\nRoses are red\nMemes are neat\nAll my test cases time out\nLmao yeet\n*/\nimport java.util.*;\nimport java.io.*;\n\n   public class x1139C\n   {\n      public static void main(String args[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));  \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int K = Integer.parseInt(st.nextToken());\n         LinkedList<Integer>[] edges = new LinkedList[N+1];\n         for(int i=0; i <= N; i++)\n            edges[i] = new LinkedList<Integer>();\n         //floof\n         for(int i=0; i < N-1; i++)\n         {\n            st = new StringTokenizer(infile.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            int c = Integer.parseInt(st.nextToken());\n            if(c == 0)\n            {\n               edges[a].add(b);\n               edges[b].add(a);\n            }\n         }\n         final long MOD = 1000000007L;\n         long res = power(N, (long)K, MOD);\n         //PIE\n         boolean[] seen = new boolean[N+1];\n         for(int i=1; i <= N; i++)\n         {\n            long ret = 0L;\n            if(!seen[i] && edges[i].size() > 0)\n            {\n               Queue<Integer> q = new LinkedList<Integer>();\n               q.add(i);\n               seen[i] = true;\n               while(q.size() > 0)\n               {\n                  int curr = q.poll();\n                  ret++;\n                  for(int next: edges[curr])\n                     if(!seen[next])\n                     {\n                        q.add(next);\n                        seen[next] = true;\n                     }\n               }\n            }\n            else if(!seen[i])\n               ret++;\n            res -= power(ret, (long)K, MOD);\n            while(res < 0) \n               res += MOD;\n         }\n         System.out.println(res);\n      }\n      static long power(long x, long y, long p) \n       { \n           long res = 1L;      \n           x = x % p;  \n         \n           while (y > 0) \n           { \n               if((y & 1)==1) \n                   res = (res * x) % p; \n               y = y >> 1;  \n               x = (x * x) % p;  \n           } \n           return res; \n       } \n   }"
        },
        {
            "language": 3,
            "solution": "n,k=map(int,input().split())\n\nA = []\nfor i in range(n):\n    A += [[[], 0]]\nfor i in range(n - 1):\n    u, v, rb = map(int,input().split())\n    \n    if rb == 0:\n        A[u-1][0] += [(v-1)]\n        A[v-1][0] += [(u-1)]\n        \ntr = []\nfor i in range(len(A)):\n    if A[i][1] == 0:\n        A[i][1] = 1\n        vertices = 1\n        can = A[i][0]\n        \n        while can:\n            nex = []\n            for c in can:\n                if A[c][1] == 0:\n                    vertices += 1\n                    A[c][1] = 1\n                    nex += A[c][0]\n            can = nex\n        tr += [vertices]\n                    \n                     \n        \n        \ntotal = n ** k\nfor t in tr:\n    total -= t ** k\nprint(total%1000000007)    \n        \n    \n            \n        "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nbool uax(T &a, const T b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T>\nbool uin(T &a, const T b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n  in >> p.first >> p.second;\n  return in;\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p) {\n  out << p.first << ' ' << p.second;\n  return out;\n}\nmt19937 rnd(1928);\nconst long long MOD = 1e9 + 7;\nlong long n, k;\nvector<vector<pair<int, bool>>> g;\nvector<int> used;\nvector<long long> szc;\nvoid dfs(int v) {\n  szc.back()++;\n  for (int i = 0; i < g[v].size(); i++) {\n    if (used[g[v][i].first] == 0 && !g[v][i].second) {\n      used[g[v][i].first] = used[v];\n      dfs(g[v][i].first);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(15);\n  cin >> n >> k;\n  g.resize(n);\n  used.resize(n);\n  int x, y, z;\n  for (int i = 0; i < n - 1; i++) {\n    cin >> x >> y >> z;\n    x--;\n    y--;\n    g[x].push_back(make_pair(y, z));\n    g[y].push_back(make_pair(x, z));\n  }\n  int cnt = 1;\n  for (int i = 0; i < n; i++) {\n    if (used[i] == 0) {\n      szc.push_back(0);\n      used[i] = cnt++;\n      dfs(i);\n    }\n  }\n  long long ans = 1;\n  for (int i = 0; i < k; i++) {\n    ans = (ans * n) % MOD;\n  }\n  for (int i = 0; i < szc.size(); i++) {\n    long long x = 1;\n    for (int j = 0; j < k; j++) {\n      x = (x * szc[i]) % MOD;\n    }\n    ans = (ans - x + MOD) % MOD;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> adj[100005];\nint vis[100005];\nlong long m = 1000000007, cnt = 0;\nvoid dfs(int s) {\n  vis[s] = 1;\n  for (int i = 0; i < adj[s].size(); i++) {\n    if (!vis[adj[s][i]]) {\n      cnt++;\n      dfs(adj[s][i]);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    if (!c) {\n      adj[a].push_back(b);\n      adj[b].push_back(a);\n    }\n  }\n  long long ans = 0, nk = n;\n  for (int i = 1; i <= n; i++) {\n    long long cntK;\n    cnt = 1;\n    if (!vis[i]) {\n      dfs(i);\n      cntK = cnt;\n      for (int i = 2; i <= k; i++) {\n        cntK *= cnt;\n        cntK %= m;\n      }\n      ans = (ans + cntK) % m;\n      ans %= m;\n    }\n  }\n  for (int i = 2; i <= k; i++) {\n    nk *= n;\n    nk %= m;\n  }\n  nk %= m;\n  cout << (nk - ans + m) % m;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> adj[1000000];\nlong long mod = 1000000007;\nbool visited[1000000];\nint pow(long long x, long long n) {\n  long long result = 1;\n  while (n > 0) {\n    if (n % 2 == 1) result = (result * x) % mod;\n    x = (x * x) % mod;\n    n = n / 2;\n  }\n  return result;\n}\nint count1 = 0;\nvoid dfs(int i) {\n  count1++;\n  visited[i] = true;\n  for (int j = 0; j < adj[i].size(); j++) {\n    if (!visited[adj[i][j]]) {\n      dfs(adj[i][j]);\n    }\n  }\n}\nint main() {\n  long long n, k;\n  cin >> n >> k;\n  long long parent[n + 10];\n  long long count[n + 10];\n  memset(parent, -1, sizeof(parent));\n  memset(count, 0, sizeof(count));\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, v, x;\n    cin >> u >> v >> x;\n    if (x == 0) {\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      dfs(i);\n      count[i] = count1;\n      count1 = 0;\n    }\n  }\n  set<long long> s;\n  long long si = 0;\n  for (long long i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      si++;\n    }\n  }\n  long long tobesub = 0;\n  for (long long i = 1; i <= n; i++) {\n    tobesub = (tobesub + pow(count[i], k)) % mod;\n  }\n  long long ans = ((pow(n, k) - tobesub) + mod) % mod;\n  ans = (ans - si + mod) % mod;\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package com.fan.Learn.codeforces.p1139;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class C {\n    private final int MAX_N = 200000;\n    private final int M = 1000000007;\n\n    private int n, k;\n    private List<ArrayList<Integer>> G = new ArrayList<>();\n    private boolean[] used = new boolean[MAX_N];\n\n    public long mod_pow(long x, long n, long mod) {\n        long res = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) res = res * x % mod;\n            x = x * x % mod;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    public int dfs(int x) {\n        int ans = 1;\n        used[x] = true;\n        for (int i = 0; i < G.get(x).size(); i++) {\n            int v = G.get(x).get(i);\n            if (used[v] == false) {\n                ans += dfs(v);\n            }\n        }\n        return ans;\n    }\n\n    public void solve() {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int k = scan.nextInt();\n        for (int i = 0; i < n; i++) {\n            ArrayList<Integer> x = new ArrayList<>();\n            G.add(x);\n        }\n        int u, v, t;\n        for (int i = 0; i < n - 1; i++) {\n            u = scan.nextInt();\n            v = scan.nextInt();\n            t = scan.nextInt();\n            u--;\n            v--;\n            if (t == 0) {\n                G.get(u).add(v);\n                G.get(v).add(u);\n            }\n        }\n        long res = mod_pow(n, k, M);\n        for (int i = 0; i < n; i++) {\n            if (used[i] == false) {\n                int x = dfs(i);\n                res = (res + M - mod_pow(x, k, M)) % M;\n            }\n        }\n        System.out.println(res);\n\n\n    }\n\n    public static void main(String[] args) {\n        C mn = new C();\n        mn.solve();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ff[200005], g[200005];\nint n, m, x, y, z;\nlong long ans, mod = 1000000007;\nlong long power(long long a, long long b) {\n  long long ret = 1;\n  while (b > 0) {\n    if (b & 1 == 1) {\n      ret = ret * a % mod;\n    }\n    a = a * a % mod;\n    b = b >> 1;\n  }\n  return ret;\n}\nint f(int x) {\n  if (ff[x] == x) return x;\n  int t = f(ff[x]);\n  ff[x] = t;\n  return t;\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    g[i] = 1;\n    ff[i] = i;\n  }\n  for (int i = 1; i <= n - 1; i++) {\n    cin >> x >> y >> z;\n    if (z == 0) {\n      int p = f(x);\n      int q = f(y);\n      ff[p] = q;\n      g[q] += g[p];\n      g[p] = 0;\n    }\n  }\n  long long ans = power(n, m);\n  for (int i = 1; i <= n; i++) {\n    if (g[i]) ans = (ans - power(g[i], m) + mod) % mod;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long power(long long x, long long y, long long p) {\n  long long res = 1;\n  x = x % p;\n  if (x == 0) return 0;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nvector<pair<long long, long long>> g[100001];\nvector<long long> vis(100001, 0);\nlong long dfs(long long u) {\n  vis[u] = 1;\n  long long res = 1;\n  for (long long i = 0; i < g[u].size(); i++) {\n    long long v = g[u][i].first;\n    if (!vis[v] && g[u][i].second == 0) {\n      res += dfs(v);\n    }\n  }\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, m, k, i, j, x, y, l, r, maxm = -1e18, minm = 1e18;\n  string str;\n  cin >> n >> k;\n  for (i = 0; i < n - 1; i++) {\n    cin >> x >> y >> m;\n    g[x].push_back({y, m});\n    g[y].push_back({x, m});\n  }\n  long long ans = power(n, k, 1000000007);\n  for (i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      long long res = dfs(i);\n      ans = (ans % 1000000007 - power(res, k, 1000000007) % 1000000007 +\n             1000000007) %\n            1000000007;\n    }\n  }\n  cout << ans;\n  cout << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nconst int MOD = 1e9 + 7;\nlong long mpower(long long x, long long y, long long p) {\n  int res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nlong long lol = 0;\nvector<int> con[N];\nbool visit[N] = {0};\nvoid dfs(long long u) {\n  if (visit[u]) return;\n  visit[u] = 1;\n  lol++;\n  for (int i = 0; i < con[u].size(); i++) dfs(con[u][i]);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, k, ans;\n  cin >> n >> k;\n  long long l, r, c;\n  for (long long i = 1; i <= n - 1; i++) {\n    cin >> l >> r >> c;\n    if (c == 1) continue;\n    con[l].push_back(r);\n    con[r].push_back(l);\n  }\n  ans = mpower(n, k, MOD);\n  for (int i = 1; i <= n; i++) {\n    if (visit[i]) continue;\n    lol = 0;\n    dfs(i);\n    ans -= mpower(lol, k, MOD);\n    ans += MOD;\n    ans %= MOD;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int sum[] = new int[1000000];\n\tstatic int sz[] = new int[1000000];\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tint n = sc.nextInt(), k = sc.nextInt();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tsum[i] = i;sz[i]=0;\n\t\t\t}\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tint u = sc.nextInt(), v = sc.nextInt(), x = sc.nextInt();\n\t\t\t\tif (x == 0) {\n\t\t\t\t\tunit(u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfind(i);\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tsz[sum[i]]++;\n\t\t\t}\n\t\t\tlong p = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tp += poww(sz[i], k);\n\t\t\t\tp%=1000000007;\n\t\t\t}\n\t\t\tlong an = (poww(n, k) + 1000000007 - p) % 1000000007;\n\t\t\tSystem.out.println(an);\n\t\t}\n\t}\n\n\tpublic static long poww(int x, int n) {// \u5feb\u901f\u5e42\n\t\tif (n == 0)\n\t\t\treturn 1;\n\t\tlong t = poww(x, n / 2) % 1000000007;\n\t\tt = t * t;\n\t\tt %= 1000000007;\n\t\tif (n % 2 == 1) {\n\t\t\tt = t * x;\n\t\t\tt %= 1000000007;\n\t\t}\n\t\treturn t;\n\t}\n\n\tstatic int find(int x) {\n\t\tif (sum[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tsum[x] = find(sum[x]);\n\t\t\treturn sum[x];\n\t\t}\n\t}\n\n//\u5408\u5e76\u4e24\u5b50\u96c6\u7684\u51fd\u6570\n\tstatic void unit(int x, int y) {// \u83b7\u53d6xy\u5408\u5e76\n\t\tint fx = find(x);// \u627e\u5230\u5404\u81ea\u7684\u8001\u5927\n\t\tint fy = find(y);\n\t\tif (fx != fy) {// \u5982\u679c\u5404\u81ea\u8001\u5927\u4e0d\u4e00\u6837\n\t\t\tsum[fy] = fx;// \u5c31\u9760\u5de6\n\t\t}\n\t\treturn;// \u52a0\u7684\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\tstatic int n,k,a,b,c;\n\tstatic int rank[]=new int[100005],num[]=new int[100005],pre[]=new int[100005];\n\tstatic void init(){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\trank[i]=1;\n\t\t\tpre[i]=i;\n\t\t}\n\t}\n\tstatic int find_pre(int x){\n\t\tif(pre[x]==x) return x;\n\t\treturn pre[x]=find_pre(pre[x]);\n\t}\n\tstatic void union(int x,int y){\n\t\tint px=find_pre(x);\n\t\tint py=find_pre(y);\n\t\tif(px==py) return;\n\t\tif(rank[px]<rank[py]){\n\t\t\tpre[px]=py;\n\t\t}\n\t\telse{\n\t\t\tif(rank[px]==rank[py]){\n\t\t\t\trank[px]++;\n\t\t\t}\n\t\t\tpre[py]=px;\n\t\t}\n\t}\n\tpublic static void main(String argas[]){\n\t\tScanner cin=new Scanner(System.in);\n\t\tn=cin.nextInt();\n\t\tk=cin.nextInt();\n\t\tinit();\n\t\tfor(int i=2;i<=n;i++){\n\t\t\ta=cin.nextInt();\n\t\t\tb=cin.nextInt();\n\t\t\tc=cin.nextInt();\n\t\t\tif(c==0){\n\t\t\t\tunion(a,b);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tnum[find_pre(i)]++;\n\t\t}\n\t\tlong ans=1,uu=(long)(1e9+7),tt=n,temp;\n        for(int i=1;i<=k;i++){\n\t\t\tans=(ans*tt)%uu;\n\t\t}\n        ans-=n;\n        if(ans<0) ans+=uu;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(num[i]>0){\n\t\t\t\ttemp=1;\n\t\t\t\ttt=num[i];\n\t\t\t\tfor(int j=1;j<=k;j++){\n\t\t\t\t\ttemp=(temp*tt)%uu;\n\t\t\t\t}\n\t\t\t\ttemp-=num[i];\n\t\t\t\tif(temp<0) temp+=uu;\n\t\t\t\tans-=temp;\n\t\t\t\tif(ans<0) ans+=uu;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*; \nimport java.util.*; \n  \npublic class Graph \n{ \n    private int V; \n    private ArrayList<Integer> adj[]; \n  static long MOD=1000000007;\n    Graph(int v) \n    { \n        V = v; \n        adj = new ArrayList[v]; \n        for (int i=0; i<v; ++i) \n            adj[i] = new ArrayList(); \n    } \n    void addEdge(int u,int v) \n    { \n        adj[u].add(v);\n        adj[v].add(u);\n    }\n    static long pow(long l,long k){\n        long m=1000000007;\n        long power=1;\n        for(int i=1;i<=k;i++){\n            power=((power%m)*(l%m))%m;\n        }\n        return power;\n    }\n    long DFS(int k)\n    {\n        boolean visited[]=new  boolean[V];\n        long sum=0;\n        for(int i=0;i<V;i++){\n            if(!visited[i]){\n                int l=DFSUtil(i,visited);\n                sum=((sum%MOD)+(pow((long)l,(long)k)%MOD))%MOD;\n            }\n        }\n        return sum;\n    }\n   \n  \n   int DFSUtil(int s,boolean visited[])\n  {\n      visited[s]=true;int k=0;\n      for (int i=0;i<adj[s].size();i++)\n      {\n          if(!visited[adj[s].get(i)])\n          {\n             k=k+DFSUtil(adj[s].get(i),visited);\n          }\n      }\n      return k+1;\n  }\n  \n    public static void main(String args[]) \n    { \n        try{\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        Graph g = new Graph(n);\n        for(int i=1;i<n;i++)\n        {\n            int u=sc.nextInt();int v=sc.nextInt();int e=sc.nextInt();\n            if(e==0)\n            g.addEdge(u-1,v-1);\n        }\n        long bad=g.DFS(k);\n        long ans=((pow((long)n,(long)k)%MOD)-(bad%MOD))%MOD;\n         if(ans<0)\n         System.out.println(MOD+ans);\n         else\n         System.out.println(ans);\n        }catch(Exception e)\n        {\n            return;\n        }\n    } \n} "
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractCollection;\nimport java.util.Iterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        long mod = 1000000007;\n        long combin = 0;\n        boolean[] visited;\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            combin = power(n, k);\n            visited = new boolean[n + 1];\n            for (int i = 0; i <= n; i++) {\n                graph.add(new ArrayList<>());\n            }\n            for (int i = 0; i < n - 1; i++) {\n                int u = in.nextInt();\n                int v = in.nextInt();\n                int x = in.nextInt();\n                if (x == 0) {\n                    graph.get(u).add(v);\n                    graph.get(v).add(u);\n                }\n            }\n            for (int i = 1; i <= n; i++) {\n                if (!visited[i]) {\n                    long count = 0;\n                    PriorityQueue<Integer> q = new PriorityQueue<>();\n                    q.add(i);\n                    while (!q.isEmpty()) {\n                        int p = q.poll();\n                        if (!visited[p]) {\n                            count++;\n                            visited[p] = true;\n                            Iterator<Integer> x = graph.get(p).iterator();\n                            while (x.hasNext()) {\n                                int m = x.next();\n                                if (!visited[m]) q.add(m);\n                            }\n                        }\n                    }\n\n                    combin = combin % mod - power(count, k) % mod;\n                    combin = combin % mod;\n                }\n            }\n            if (combin < 0) combin += 1000000007;\n            out.println(combin);\n        }\n\n        long power(long a, long b) {\n            if (b == 0) return 1;\n            return ((a % mod) * power(a, b - 1 % mod) % mod);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5;\nconst long long mod = 1e9 + 7;\nconst long long mod2 = 998244353;\nconst int oo = 0x7fffffff;\nconst int sup = 0x80000000;\ntemplate <typename it>\nvoid db(it *begin, it *end) {\n  while (begin != end) cout << (*begin++) << \" \";\n  puts(\"\");\n}\ntemplate <typename it>\nstring to_str(it n) {\n  string s = \"\";\n  while (n) s += n % 10 + '0', n /= 10;\n  reverse(s.begin(), s.end());\n  return s;\n}\ntemplate <typename it>\nint o(it a) {\n  cout << a << endl;\n  return 0;\n}\ninline long long mul_64(long long x, long long y, long long c) {\n  return (x * y - (long long)((long double)x / c * y) * c + c) % c;\n}\ninline long long ksm(long long a, long long b, long long c) {\n  long long ans = 1;\n  for (; b; b >>= 1, a = a * a % c)\n    if (b & 1) ans = ans * a % c;\n  return ans;\n}\ninline void exgcd(long long a, long long b, long long &x, long long &y) {\n  if (!b)\n    x = 1, y = 0;\n  else\n    exgcd(b, a % b, y, x), y -= x * (a / b);\n}\nint n, k;\nint f[N], son[N];\nint fa(int x) { return f[x] = x == f[x] ? x : fa(f[x]); }\nint main() {\n  for (int i = 1; i < N; i++) f[i] = i, son[i] = 1;\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v, c;\n    scanf(\"%d%d%d\", &u, &v, &c);\n    if (c == 1) continue;\n    int fx = fa(u), fy = fa(v);\n    if (fx ^ fy) {\n      f[fx] = fy;\n      son[fy] += son[fx];\n    }\n  }\n  long long ans = (ksm(n, k, mod) - n + mod) % mod;\n  for (int i = 1; i <= n; i++) {\n    if (f[i] == i && son[i] > 1) {\n      ans -= ksm(son[i], k, mod) - son[i];\n      ans = (ans % mod + mod) % mod;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\tstatic class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\tprivate BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\n\t\t\tint sgn = 1;\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') {\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\treturn readString();\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) throws Exception {\n\t\tnew Thread(null, new Solution(), \"Main\", 1 << 27).start();\n\t}\n\tpublic static void addEdge(ArrayList<ArrayList<Integer>> adj,int u,int v)\n\t{\n\t\tadj.get(u).add(v);\n\t\tadj.get(v).add(u);\n\t}\n\tpublic void run() {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\tint n=in.nextInt();\n\t\tint k=in.nextInt();\n\t\tboolean RED[]=new boolean[n+1];\n\t\tArrays.fill(RED, false);\n\t\tArrayList<ArrayList<Integer>> adj1=new ArrayList<ArrayList<Integer>>();\n\t\tArrayList<ArrayList<Integer>> adj2=new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=1;i<=n+1;i++)\n\t\t{\n\t\t\tadj1.add(new ArrayList<Integer>());\n\t\t\tadj2.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tint x=in.nextInt();\n\t\t\tint y=in.nextInt();\n\t\t\tint z=in.nextInt();\n\t\t\tif(z==0)\n\t\t\t{\tRED[x]=RED[y]=true;\n\t\t\t\taddEdge(adj1, x, y);\n\t\t\t}\n\t\t\telse\n\t\t\t\taddEdge(adj2, x, y);\n\t\t}\n\t\tboolean visited[]=new boolean[n+1];\n\t\tArrays.fill(visited, false);\n\t\tBigInteger ans=new BigInteger(\"0\");\n\t\tint tv=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(RED[i] && !visited[i])\n\t\t\t{\n\t\t\t\tint count=1;\n\t\t\t\tQueue<Integer> Q=new LinkedList<Integer>();\n\t\t\t\tQ.add(i);\n\t\t\t\tvisited[i]=true;\n\t\t\t\twhile(!Q.isEmpty())\n\t\t\t\t{\n\t\t\t\t\tint p=Q.poll();\n\t\t\t\t\tfor(int j=0;j<adj1.get(p).size();j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint child=adj1.get(p).get(j);\n\t\t\t\t\t\tif(!visited[child])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tvisited[child]=true;\n\t\t\t\t\t\t\tQ.add(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttv+=count;\n\t\t\t\tans=ans.add(BigInteger.valueOf(count).pow(k));\n\t\t\t}\n\t\t}\n\t\tans=ans.add(BigInteger.valueOf(n-tv));\n\t\tans=(BigInteger.valueOf(n).pow(k)).subtract(ans);\n\t\tBigInteger result=ans.mod(BigInteger.valueOf(1000000007));\n\t\tw.println(result);\n\t\tw.flush();\n\t\tw.close();\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Problem {\n\n\tstatic int find(int[] parents, int i) {\n\t\tif (parents[i] != i) {\n\t\t\tparents[i] = find(parents, parents[i]);\n\t\t}\n\t\treturn parents[i];\n\t}\n\n\tstatic void union(int[] parents, int[] size, int i, int j) {\n\t\tint setI = find(parents, i);\n\t\tint setJ = find(parents, j);\n\t\tif (setI == setJ)\n\t\t\treturn;\n\n\t\tif (size[setI] >= size[setJ]) {\n\t\t\tparents[setJ] = setI;\n\t\t\tsize[setI] += size[setJ];\n\t\t} else {\n\t\t\tparents[setI] = setJ;\n\t\t\tsize[setJ] += size[setI];\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] next = in.readLine().trim().split(\" \");\n\t\tint numNodes = Integer.parseInt(next[0]);\n\t\tint length = Integer.parseInt(next[1]);\n\t\tint[] parents = new int[numNodes];\n\t\tint[] size = new int[numNodes];\n\t\tBigInteger res = BigInteger.valueOf(numNodes);\n\t\tres=res.pow(length);\n\t\t\n\t\t//System.out.println(res);\n\t\tfor (int i = 0; i < numNodes; i++) {\n\t\t\tparents[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t\tfor (int i = 0; i < numNodes - 1; i++) {\n\t\t\tString[] edge = in.readLine().trim().split(\" \");\n\t\t\tif (edge[2].equals(\"0\")) {\n\t\t\t\tint src =Integer.parseInt(edge[0])-1;\n\t\t\t\tint dest = Integer.parseInt(edge[1])-1;\n\t\t\t\tunion(parents, size,src,dest);\n\t\n\t\t\t\t\n\t\t\t}\n\n\t\t}\n\t\tfor(int i=0;i<numNodes;i++) {\n\t\t\t\n\t\t\tif(find(parents,i)==i) {\n\t\t\t\tBigInteger ccComb = BigInteger.valueOf(size[i]);\n\t\t\t\tccComb=ccComb.pow(length);\n\t\t\t\tres=res.subtract(ccComb);\n\t\t\t\tBigInteger mod = BigInteger.valueOf(1000000007);\n\t\t\t\tres=res.mod(mod);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(res);\n\n\t\tin.close();\n\n\t}\n\n}"
        },
        {
            "language": 3,
            "solution": "# Author: S Mahesh Raju\n# Username: maheshraju2020\n# Created on: 25/09/2020 18:27:28\n\nfrom sys import stdin, stdout, setrecursionlimit\nimport heapq\nfrom math import gcd, ceil, sqrt\nfrom collections import Counter, deque\nfrom bisect import bisect_left, bisect_right\nfrom itertools import combinations, permutations\nii1 = lambda: int(stdin.readline().strip())\nis1 = lambda: stdin.readline().strip()\niia = lambda: list(map(int, stdin.readline().strip().split()))\nisa = lambda: stdin.readline().strip().split()\nsetrecursionlimit(100000)\nmod = 1000000007\n\ndef get(cur, d, seen):\n    queue = deque([cur])\n    compo = []\n    while len(queue):\n        cur = queue.popleft()\n        if cur not in seen:\n            seen.add(cur)\n            compo.append(cur)\n            for neigh in d.get(cur, []):\n                queue.append(neigh)\n    return len(compo)\n\n\nn, k = iia()\nd = {}\nfor i in range(n - 1):\n    u, v, c = iia()\n    if c == 0:\n        d.setdefault(u, []).append(v)\n        d.setdefault(v, []).append(u)\n\nseen = set()\nres = 0\nfor i in range(1, n + 1):\n    if i not in seen:\n        res += pow(get(i, d, seen), k, mod)\n        res %= mod\nres = pow(n, k, mod) - res\nprint(res % mod)\n\n        "
        },
        {
            "language": 3,
            "solution": "\"\"\"\n    Satwik_Tiwari ;) .\n    30th july , 2020  - Thursday\n\"\"\"\n\n#===============================================================================================\n#importing some useful libraries.\nfrom __future__ import division, print_function\n\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\n\nfrom itertools import *\nimport bisect\nfrom heapq import *\nfrom math import *\nfrom copy import *\nfrom collections import deque\nfrom collections import Counter as counter  # Counter(list)  return a dict with {key: count}\nfrom itertools import combinations as comb # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\nfrom itertools import permutations as permutate\nfrom bisect import bisect_left as bl\n#If the element is already present in the list,\n# the left most position where element has to be inserted is returned.\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n#If the element is already present in the list,\n# the right most position where element has to be inserted is returned\n\n#==============================================================================================\n#fast I/O region\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\ndef iterative(f, stack=[]):\n  def wrapped_func(*args, **kwargs):\n    if stack: return f(*args, **kwargs)\n    to = f(*args, **kwargs)\n    while True:\n      if type(to) is GeneratorType:\n        stack.append(to)\n        to = next(to)\n        continue\n      stack.pop()\n      if not stack: break\n      to = stack[-1].send(to)\n    return to\n  return wrapped_func\n#### END ITERATE RECURSION ####\n\n#===============================================================================================\n#some shortcuts\n\nmod = 1000000007\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\") #for fast input\ndef out(var): sys.stdout.write(str(var))  #for fast output, always take string\ndef lis(): return list(map(int, inp().split()))\ndef stringlis(): return list(map(str, inp().split()))\ndef sep(): return map(int, inp().split())\ndef strsep(): return map(str, inp().split())\n# def graph(vertex): return [[] for i in range(0,vertex+1)]\ndef zerolist(n): return [0]*n\ndef nextline(): out(\"\\n\")  #as stdout.write always print sring.\ndef testcase(t):\n    for p in range(t):\n        solve()\ndef printlist(a) :\n    for p in range(0,len(a)):\n        out(str(a[p]) + ' ')\ndef lcm(a,b): return (a*b)//gcd(a,b)\ndef power(a,b):\n    ans = 1\n    while(b>0):\n        if(b%2==1):\n            ans*=a\n        a*=a\n        b//=2\n    return ans\ndef ncr(n,r): return factorial(n)//(factorial(r)*factorial(max(n-r,1)))\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\n\n#===============================================================================================\n# code here ;))\ndef bfs(g,st,vis):\n    # visited = [0]*(len(g))\n    vis[st] = st\n    queue = deque([])\n    queue.append(st)\n    new = []\n    while(len(queue) != 0):\n        s = queue.popleft()\n        new.append(s)\n        for i in g[s]:\n            if(vis[i] == -1):\n                vis[i] = st\n                queue.append(i)\n    return vis\n\ndef var(g):\n    vis = [-1]*(len(g))\n    curr = 0\n    while(curr<len(g)):\n        if(vis[curr] !=-1):\n            curr+=1\n            continue\n        else:\n            vis = bfs(g,curr,vis)\n            # print(vis)\n            curr+=1\n    return vis\n\n\ndef solve():\n    n,k = sep()\n    graph = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b,c = sep()\n        if(c==1):\n            continue\n\n        a-=1\n        b-=1\n        graph[a].append(b)\n        graph[b].append(a)\n\n    diff = var(graph)\n    # print(diff)\n\n    cnt = {}\n    for i in range(n):\n        if(diff[i] in cnt):\n            cnt[diff[i]]+=1\n        else:\n            cnt[diff[i]] = 1\n    # print(cnt)\n    deduct = 0\n    for i in cnt:\n        temp = 1\n        for j in range(k):\n            temp*=cnt[i]\n            temp%=mod\n        deduct+=temp\n        # print(deduct)\n\n    ans = 1\n    for i in range(k):\n        ans*=n\n        ans%=mod\n    # print(ans)\n    print((ans-deduct)%mod)\n\n\n\n\ntestcase(1)\n# testcase(int(inp()))\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, dd[100005];\nvector<int> a[100005];\nlong long res = 0;\nvoid nhap() {\n  cin >> n >> k;\n  for (int i = 1; i <= n - 1; ++i) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    if (w == 0) {\n      a[u].push_back(v);\n      a[v].push_back(u);\n    }\n  }\n}\nvoid DFS(int u) {\n  dd[u] = 1;\n  for (auto v : a[u])\n    if (!dd[v]) DFS(v), dd[u] += dd[v];\n}\nlong long Poww(int x, int y) {\n  long long temp = 1;\n  for (int i = 1; i <= y; ++i) {\n    temp *= x;\n    if (temp > 1000000007) temp %= 1000000007;\n  }\n  return temp;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  nhap();\n  res = Poww(n, k);\n  for (int i = 1; i <= n; ++i)\n    if (!dd[i]) {\n      DFS(i);\n      res -= Poww(dd[i], k);\n      while (res < 0) res += 1000000007;\n    }\n  cout << res;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nconst int MAX = 100005;\nconst int MAX1 = 1005;\nconst int MAX2 = 105;\nconst int LEN = 105;\nconst int BASE = 1000000000;\nconst double EPS = 1e-7;\nconst int MOD = 1000000007;\nint par[100005];\nlong long pow(long long a, long long b, int m) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % m;\n    b /= 2;\n    a = (a * a) % m;\n  }\n  return ans;\n}\nint root(int v) {\n  if (par[v] < 0)\n    return v;\n  else\n    return par[v] = root(par[v]);\n}\nvoid connect(int u, int v) {\n  int n = root(u), m = root(v);\n  if (n == m) return;\n  if (par[n] < par[m]) {\n    par[n] += par[m];\n    par[m] = n;\n  } else {\n    par[m] += par[n];\n    par[n] = m;\n  }\n}\nint main(void) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ifstream in(\"\");\n  ofstream out(\"\");\n  clock_t begin = clock();\n  for (int i = (0); i < (100005); ++i) par[i] = -1;\n  int n, k;\n  cin >> n >> k;\n  for (int i = (0); i < (n - 1); ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    if (c == 0) {\n      connect(a, b);\n    }\n  }\n  long long res = 0;\n  set<int> S;\n  for (int i = (1); i < (n + 1); ++i) {\n    int r = root(i);\n    if (S.find(r) != S.end()) continue;\n    S.insert(r);\n    res += pow(-1 * (long long)par[r], (long long)k, MOD);\n  }\n  cout << ((pow(n, k, MOD) - res) % MOD + MOD) % MOD << '\\n';\n  clock_t end = clock();\n  double esecs = double(end - begin) / CLOCKS_PER_SEC;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport os.path\n\nBase = 1000000007\n\nclass Dsu:\n    par = []\n    cnt = []\n    def __init__(self,size):\n        self.par = [x for x in range(size + 2)]\n        self.cnt = [1] * (size + 2)\n        \n    def findp(self,u):\n        if self.par[u] == u:\n            return u \n        else :\n            self.par[u] = self.findp(self.par[u])\n            return self.par[u]\n        \n    def join(self,u,v):\n        u,v = self.findp(u),self.findp(v)\n        if u == v :\n            return\n        if self.cnt[u] < self.cnt[v] :\n            u,v = v,u\n        self.cnt[u] += self.cnt[v]\n        self.par[v] = u\n        \n    def getSize(self,u):\n        return self.cnt[self.findp(u)]\n\ndef mulmod(u,v):\n    return ((u % Base) * (v % Base)) % Base\n\ndef submod(u,v):\n    return ((u % Base) - (v % Base) + Base) % Base\n\ndef fastExp(x,h):\n    ret = 1\n    while h > 0:\n        if h & 1 == 1 :\n            ret = mulmod(ret,x)\n        x = mulmod(x,x)\n        h = h // 2\n    return ret\n\ndef solve():\n    # code goes here!!         \n    n,k = map(int,input().split())\n    dsu = Dsu(n)\n    for i in range(1,n):\n        u,v,x = map(int,input().split())\n        if x == 0:\n            dsu.join(u,v)\n            \n    ans = fastExp(n,k)\n    for u in range(1,n + 1):\n        if dsu.findp(u)  == u : \n           ans = submod(ans,fastExp(dsu.getSize(u),k)) \n    print(ans)\n    \n\ndef main():\n    # comment when submit.\n    if os.path.exists('test.inp') :\n        sys.stdin = open(\"test.inp\",\"r\")\n    solve()\n\nif __name__ == '__main__':\n    main()\n\n\n"
        },
        {
            "language": 4,
            "solution": "//package year2019.month03.cf.round548div2;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.Objects;\n\npublic class round548div2C {\n\n    boolean ONLINE_JUDGE = (System.getProperty(\"ONLINE_JUDGE\") != null);\n\n    public round548div2C() throws IOException {\n        InputReader in;\n        if (ONLINE_JUDGE) {\n            in = new InputReader(System.in);\n        } else {\n            in = new InputReader(new FileInputStream(\"/Users/karj/cp/input.txt\"));\n        }\n        PrintWriter out = new PrintWriter(System.out);\n\n        int T = 1;\n        for (int caseNo = 1; caseNo <= T; caseNo++) {\n            solve(caseNo, in, out);\n        }\n\n        out.close();\n    }\n\n    long MOD = (long) (1e9 + 7);\n\n    private void solve(int caseNo, InputReader in, PrintWriter out) throws IOException {\n        int n = in.nextInt(), k = in.nextInt();\n        LinkedList<Integer> g[] = new LinkedList[n];\n        int c[] = new int[n - 1];\n        for (int i = 0; i < n; i++) {\n            g[i] = new LinkedList<>();\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int u = in.nextInt() - 1, v = in.nextInt() - 1, cc = in.nextInt();\n            c[i] = cc;\n            debug(u, v, cc);\n            if (cc == 0) {\n                g[u].addLast(v);\n                g[v].addLast(u);\n            }\n        }\n        debug(g);\n        int ccc = 0;\n        int ccs[] = new int[n + 1];\n        boolean vis[]= new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!vis[i]) {\n                ccc++;\n                int cc = 0;\n                dfs(i, cc, ccc, ccs, vis, g);\n            }\n        }\n        debug(ccc, ccs);\n        long ans = modPow(n, k, MOD);\n        for (int i = 1; i <= ccc; i++) {\n            long vv = modPow(ccs[i], k, MOD);\n            vv %= MOD;\n            ans -= vv;\n            if (ans < 0) {\n                ans += MOD;\n            }\n        }\n        out.println(ans);\n    }\n\n    private int dfs(int u, int cc, int ccc, int[] ccs, boolean[] vis, LinkedList<Integer>[] g) {\n        vis[u] = true;\n        cc++;\n        for (int v : g[u]) {\n            if (!vis[v]) {\n                int c = 0;\n                cc += dfs(v, c, ccc, ccs, vis, g);\n            }\n        }\n        ccs[ccc] = cc;\n        return cc;\n    }\n\n    long modPow(long base, long exponent, long MOD) {\n        long result = 1;\n        base = base % MOD;\n        while (exponent > 0) {\n            if (exponent % 2 == 1) {\n                result = result * base;\n                result %= MOD;\n            }\n            exponent = exponent / 2;\n            base = (base * base) % MOD;\n        }\n        return result;\n    }\n\n    static class InputReader {\n\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n\n            public boolean isSpaceChar(int ch);\n        }\n\n        public String next() {\n            return nextString();\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public Long nextLong() {\n            return Long.parseLong(nextString());\n        }\n\n        public Double nextDouble() {\n            return Double.parseDouble(nextString());\n        }\n\n        public char nextCharacter() {\n            return nextString().charAt(0);\n        }\n\n        public int[] nextIntArray(int N) {\n            int A[] = new int[N];\n            for (int i = 0; i < N; i++) {\n                A[i] = nextInt();\n            }\n            return A;\n        }\n\n        public long[] nextLongArray(int N) {\n            long A[] = new long[N];\n            for (int i = 0; i < N; i++) {\n                A[i] = nextLong();\n            }\n            return A;\n        }\n\n        public double[] nextDoubleArray(int N) {\n            double A[] = new double[N];\n            for (int i = 0; i < N; i++) {\n                A[i] = nextDouble();\n            }\n            return A;\n        }\n    }\n\n    int min(int... a) {\n        int min = Integer.MAX_VALUE;\n        for (int v : a) {\n            min = Math.min(min, v);\n        }\n        return min;\n    }\n\n    long min(long... a) {\n        long min = Long.MAX_VALUE;\n        for (long v : a) {\n            min = Math.min(min, v);\n        }\n        return min;\n    }\n\n    double min(double... a) {\n        double min = Double.MAX_VALUE;\n        for (double v : a) {\n            min = Math.min(min, v);\n        }\n        return min;\n    }\n\n    int max(int... a) {\n        int max = Integer.MIN_VALUE;\n        for (int v : a) {\n            max = Math.max(max, v);\n        }\n        return max;\n    }\n\n    long max(long... a) {\n        long max = Long.MIN_VALUE;\n        for (long v : a) {\n            max = Math.max(max, v);\n        }\n        return max;\n    }\n\n    double max(double... a) {\n        double max = Double.MIN_VALUE;\n        for (double v : a) {\n            max = Math.max(max, v);\n        }\n        return max;\n    }\n\n    public <A, B> Pair MP(A a, B b) {\n        return new Pair<A, B>(a, b);\n    }\n\n    class Pair<F, S> {\n        public final F f;\n        public final S s;\n\n        public Pair(F f, S s) {\n            this.f = f;\n            this.s = s;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Pair<?, ?> pair = (Pair<?, ?>) o;\n            return Objects.equals(f, pair.f) &&\n                    Objects.equals(s, pair.s);\n        }\n\n        @Override\n        public int hashCode() {\n\n            return Objects.hash(f, s);\n        }\n\n        @Override\n        public String toString() {\n            return f.toString() + \" \" + s.toString();\n        }\n    }\n\n\n    private void debug(Object... o) {\n        if (ONLINE_JUDGE) {\n            return;\n        }\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static void main(String args[]) throws IOException {\n        new round548div2C();\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            int k=Integer.parseInt(s1[1]);\n            HashSet<Integer> hs[]=new HashSet[n+1];\n            HashSet<Integer> h=new HashSet<Integer>();\n            ArrayList<Integer> al=new ArrayList<Integer>();\n            for(int i=1;i<=n;i++)\n             hs[i]=new HashSet<Integer>();\n            for(int i=0;i<n-1;i++)\n            {\n              String s2[]=br.readLine().split(\" \");\n              int x=Integer.parseInt(s2[0]);\n              int y=Integer.parseInt(s2[1]);\n              int l=Integer.parseInt(s2[2]);\n              if(l==0)\n              { hs[x].add(y);  hs[y].add(x);  }\n            }\n            \n            for(int i=1;i<=n;i++)\n            {\n                  //System.out.println(hs[i]);\n                  if(h.contains(i))\n                   continue;\n                  Stack<Integer> st=new Stack<Integer>();\n                  st.push(i);\n                  int n1=h.size();\n                  h.add(i);\n                  while(!st.empty())\n                  {\n                     int x=st.pop();\n                     Iterator it=hs[x].iterator();\n                     while(it.hasNext())\n                     {  \n                        int u=(int)it.next(); \n                        if(!h.contains(u))\n                        { h.add(u); st.push(u); }\n                     }\n                  }\n                  int n2=h.size();\n                 // System.out.println(i+\" \"+(n2-n1));\n                  al.add(n2-n1);\n            }\n            \n           long mod=1000000007;\n           long r=1;\n           for(int i=0;i<k;i++)\n           { r=r*((long)n); r=r%mod; }\n           \n           long S=0;\n           for(int i=0;i<al.size();i++)\n           {\n               long p=1;\n               for(int j=0;j<k;j++)\n               { p=p*((long)al.get(i));  p=p%mod; }\n               S=(S+p)%mod;\n               //System.out.println(al.get(i));\n           }\n           \n           System.out.println((r+mod-S)%mod);\n      }\n}"
        },
        {
            "language": 3,
            "solution": "#from collections import OrderedDict\nfrom collections import defaultdict\n#from functools import reduce\n#from itertools import groupby\n#sys.setrecursionlimit(10**6)\n#from itertools import accumulate\nfrom collections import Counter\nimport math\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nfrom threading import stack_size,Thread\nsys.setrecursionlimit(10**6)\nstack_size(10**8)\ndef listt():\n    return [int(i) for i in input().split()]\ncount=0\ndic={} \nvisited={}\ndef dfs(src):\n    global count,visited,dic\n    count+=1\n    visited[src]=1\n    for i in dic[src]:\n        if visited[i]==0:\n            dfs(i)\n    return count        \ndef main():     \n    global count,visited,dic      \n    n,k=map(int,input().split())\n    dic={}\n    visited={}\n    for i in range(1,n+1):\n        visited[i]=0\n    for i in range(n-1):\n        u,v,w=map(int,input().split()) \n        if w==0:\n            #union(u,v)\n            if u in dic:\n                dic[u].append(v)\n            else:\n                dic[u]=[v]\n            if v in dic:\n                dic[v].append(u)\n            else:\n                dic[v]=[u] \n        else:\n            if u in dic:\n                dic[u].append(u)\n            else:\n                dic[u]=[u]\n            if v in dic:\n                dic[v].append(v)\n            else:\n                dic[v]=[v]        \n    l=[]            \n    for i in dic:\n        if visited[i]==0:\n            count=0\n            l.append(dfs(i))                \n    su=0        \n    for i in l:\n        su+=i**k\n    print((n**k-su)%1000000007)    \nThread(target=main).start()         \n        "
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split())\n\nG = []\np = [i for i in range(n+1)]\nh = [0 for i in range(n+1)]\nr = [1 for i in range(n+1)]\n\ndef get(x):\n    while p[x] != x:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    x = get(x)\n    y = get(y)\n    \n    if x == y:\n        return 0\n    \n    if h[x] > h[y]:\n        x, y = y, x\n        \n    p[x] = y\n    if h[x] == h[y]:\n        h[y] += 1\n        \n    r[y] += r[x]\n        \n    return 1\n\nfor i in range(n-1):\n    u, v, x = map(int, input().split())\n    \n    if x == 0:\n        union(u, v)\n        \nfor i in range(1, n+1):\n    if i == p[i]:\n        G.append(r[i])\n        \nans = 0\nfor x in G:\n    ans += pow(x, k, 10**9 + 7)\n    \nans = (pow(n, k, 10**9 + 7) - ans) % (10**9 + 7)\nprint(ans)\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\ninput = sys.stdin.readline\n\ndef One(type):\n\treturn (type(input()))\ndef List(type):\n\treturn list(map(type,input().split()))\ndef Str():\n\treturn (list(input()))\ndef Many(type):\n\treturn map(type,input().split())\nsys.setrecursionlimit(100100)\n\n\n\ng = []\nvis = []\nMOD = 1000000007\n\ndef dfs(cur):\n\tstack = []\n\tret = 1\n\tstack.append(cur)\n\n\twhile (len(stack)):\n\n\t\tcur = stack[-1]\n\t\tstack.pop()\n\n\t\tif vis[cur]:\n\t\t\tvis[cur] = False\n\t\t\tret+=1\n\n\t\tfor nxt in g[cur]:\n\t\t\tif vis[nxt]:\n\t\t\t\tstack.append(nxt)\n\n\treturn ret\n\ndef main():\n\tglobal vis,g,MOD\n\n\tn,k = Many(int)\n\tvis = [True]*n\n\n\tfor _ in range(n): g.append([])\n\n\tfor _ in range(n-1):\n\t\ta,b,c = Many(int)\n\t\tif c==0:\n\t\t\tg[a-1].append(b-1)\n\t\t\tg[b-1].append(a-1)\n\n\tans = 0\n\n\tfor i in range(n):\n\t\tif vis[i]==True:\n\t\t\tvis[i] = False\n\t\t\tans+=pow(dfs(i),k)\n\t\t\tans = ans%MOD\n\n\tprint((pow(n,k)-ans)%1000000007)\n\nmain()\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class nextgraph {\n\tstatic boolean visited[];\n\tstatic ArrayList<Integer> ar[];\n\tstatic long mod = (long)1e9 + 7;\n\tstatic long count=0l;\n\tpublic static void dfs(int i)\n\t{\n\t\tvisited[i]=true;\n\t\tcount++;\n\t\t\n\t\tfor(int x:ar[i])\n\t\t{\n\t\t\tif(!visited[x])\n\t\t\t{\n\t\t\t\tdfs(x);\n\t\t\t}\n\t\t}\n\t\t\n\t}static long fast_pow(long a, long b) {\n\t\tif(b == 0)\n\t\t\treturn 1L;\n\n\t\tlong val = fast_pow(a, b / 2);\n\n\t\tif(b % 2 == 0)\n\t\t\treturn val * val % mod;\n\t\telse \n\t\t\treturn val * val % mod * a % mod;\n\t}\n\tpublic static void main(String args[])\n\t{\n\t\tScanner scan=new Scanner(System.in);\n\t\tint n=scan.nextInt();\n\t\tint k=scan.nextInt();\n\t\tar=new ArrayList[n];\n\t\tfor(int i=0;i<n;i++)ar[i]=new ArrayList<Integer>();\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tint u=scan.nextInt()-1;\n\t\t\tint v=scan.nextInt()-1;\n\t\t\tint col=scan.nextInt();\n\t\t\tif(col==0)\n\t\t\t{\n\t\t\t\tar[u].add(v);\n\t\t\t\tar[v].add(u);\n\t\t\t}\n\t\t}\n\t\tvisited=new boolean[n];\n\t\tlong tot=fast_pow(n,k);\n\t\tlong diff=0L;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(!visited[i])\n\t\t\t{\n\t\t\t\tcount=0L;\n\t\t\t\tdfs(i);\n\t\t\t\t\n\t\t\t\tdiff+=fast_pow(count,k);\n\t\t\t}\n\t\t}\n\t\tdiff=diff%mod;\n\t\tSystem.out.println((tot-diff+mod)%mod);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "//package Practice_Problems;\nimport java.util.*;\nimport java.io.*;\npublic class EdgyTrees\n{\n\tstatic ArrayList<Integer> adj[] = new ArrayList[(int) 1e5 + 1];\n\tstatic boolean vis[]=new boolean[adj.length];\n\tstatic final int mod=(int)1e9+7;\n\tstatic final int inf=(int)1e9;\n\tstatic final long INF=(long)1e18;\n\tstatic int cnt=0;\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tFastScanner fs=new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint nodes=fs.nextInt();\n\t\tint k=fs.nextInt();\n\t\tfor(int i=1;i<=nodes;i++)adj[i]=new ArrayList<Integer>();\n\t\tfor(int i=1;i<=nodes-1;i++)\n\t\t{\n\t\t\tint a=fs.nextInt();int b=fs.nextInt();int col=fs.nextInt();\n\t\t\tif(col==0)\n\t\t\t{adj[a].add(b);adj[b].add(a);}\n\t\t}\n\t\tlong ans=modpow(nodes,k);\n\t\tlong sub=0;\n\t\tfor(int i=1;i<=nodes;i++)\n\t\t{\n\t\t\tif(!vis[i])\n\t\t\t{\n\t\t\t\tdfs(i);\n\t\t\t\tsub=sub+modpow(cnt,k);\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t}\n\t\t//System.out.println(sub+\" \"+ans);\n\t\tsub%=mod;\n\t\tans=(ans-sub+mod)%mod;\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n\tpublic static long modpow(long x,long n)\n\t{\n\t\tlong res=1;\n\t\twhile(n>0)\n\t\t{\n\t\t\t//System.out.println(x+\" \"+n+\" \"+res);\n\t\t\tif(n%2!=0)\n\t\t\t{\n\t\t\t\tres=((res%mod)*(x%mod))%mod;n--;\n\t\t\t}\n\t\t\telse\n\t\t\t\t{x=((x%mod)*(x%mod))%mod;n/=2;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void dfs(int node)\n\t{\n\t\tvis[node]=true;\n\t\tcnt++;\n\t\tfor(int child:adj[node])\n\t\t{\n\t\t\tif(!vis[child])dfs(child);\n\t\t}\n\t}\n\t//returns the index of the smallest element in the array that is greater than or equal to\n\t//the given element.\n\tpublic static int lower_bound(int arr[],int key)\n\t{\n\t\tint index=inf,num=0;\n\t\tint left=0,right=arr.length-1;\n\t\twhile(left<=right)\n\t\t{\n\t\t\tint mid=left+(right-left)/2;\n\t\t\tif(arr[mid]>=key) {index=mid;num=arr[mid];right=mid-1;}\n\t\t\telse \n\t\t\t\tleft=mid+1;\n\t\t}\n\t\treturn index==inf ? arr.length:index;\n\t}\n\t//returns the index of the smallest element in the array that is less than or equal to\n    //the given element.\n\tpublic static int upper_bound(int arr[],int key)\n\t{\n\t\tint index=inf,num=0;\n\t\tint left=0,right=arr.length-1;\n\t\twhile(left<=right)\n\t\t{\n\t\t\tint mid=left+(right-left)/2;\n\t\t\tif(arr[mid]<=key) {index=mid;num=arr[mid];left=mid+1;}\n\t\t\telse \n\t\t\t\tright=mid-1;\n\t\t}\n\t\treturn index==inf ? arr.length:index;\n\t}\n}\nclass FastScanner \n{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\tpublic String next() \n\t\t{\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t\t\n\t\t}\n\t\tpublic String nextLine() throws IOException\n\t\t{\n\t\t    return br.readLine();\n\t\t}\n\t\tint[] sort(int arr[])\n\t\t{\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int i:arr)list.add(i);\n\t\t\tCollections.sort(list);\n\t\t\tfor(int i=0;i<arr.length;i++)\n\t\t\t{\n\t\t\t\tarr[i]=list.get(i);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\tchar[] charsort(char arr[])\n\t        {\n\t    \tArrayList<Character> list = new ArrayList<>();\n\t    \tfor(char c:arr)list.add(c);\n\t    \tCollections.sort(list);\n\t    \tfor(int i=0;i<list.size();i++)\n\t    \t{\n\t    \t\tarr[i]=list.get(i);\n\t    \t}\n\t    \treturn arr;\n\t        }\n\t\tlong[] longsort(long arr[])\n\t\t{\n\t\t\tArrayList<Long> list = new ArrayList<Long>();\n\t\t\tfor(long i:arr)list.add(i);\n\t\t\tCollections.sort(list);\n\t\t\tfor(int i=0;i<arr.length;i++)\n\t\t\t{\n\t\t\t\tarr[i]=list.get(i);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\tpublic int nextInt() \n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic int[] readArray(int n)\n\t\t{\n\t\t\tint[] arr=new int[n];\n\t\t\tfor (int i=0; i<n; i++) arr[i]=nextInt();\n\t\t\treturn arr;\n\t\t}\t\n\t\tpublic long nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic long[] longreadArray(int n) \n\t\t{\n\t\t\tlong[] a=new long[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "def readLine():\n\ta = input()\n\treturn [int(i) for i in a.split(' ')]\n\ndef deg(x, y):\n\tif y == 1:\n\t\treturn x\n\tres = deg(x, y // 2)\n\tres *= res\n\tres %= md\n\tif y % 2 == 1:\n\t\tres *= x\n\t\tres %= md\n\treturn res\n\ndef bfs(v):\n\tq = [v]\n\tused[v] = True\n\tres = 1\n\twhile len(q) != 0:\n\t\tv = q[0]\n\t\tq.pop(0)\n\t\tfor _, to in enumerate(g[v]):\n\t\t\tif used[to] == False:\n\t\t\t\tused[to] = True\n\t\t\t\tq.append(to)\n\t\t\t\tres += 1\n\treturn res\n\nnm = readLine()\nn, m = nm[0], nm[1]\ng = [[] for _ in range(n + 1)]\nmd = 1000000007\n\nfor i in range(n - 1):\n\ts = readLine()\n\tx, y, t = s[0], s[1], s[2]\n\tif t == 0:\n\t\tg[x].append(y)\n\t\tg[y].append(x)\nans = deg(n, m)\nused = [False for _ in range (n + 1)]\nfor i in range(1, n + 1):\n\tif used[i] == False:\n\t\tb = bfs(i)\n\t\tans = ans - deg(b, m)\n\t\tif ans < 0:\n\t\t\tans += md\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "import sys\ndef dfs(start):\n    global array,size\n    queue = []\n    queue.append(start)\n    used[start] = 1\n    while len(queue):\n        curr = queue.pop()\n        for i in range(len(array[curr])):\n            if not used[array[curr][i]]:\n                queue.insert(0, array[curr][i])\n                size += 1\n                used[array[curr][i]] = 1\n\n\n#sys.setrecursionlimit(10 ** 5)\ntry:\n    n, k = [int(s) for s in input().split()]\n    array = [[] for i in range(n)]\n    used = [0] * n\n    for i in range(n - 1):\n        u, v, num = [int(s) for s in input().split()]\n        if num == 1:\n            continue\n        u -= 1\n        v -= 1\n        if not u in array[v]:\n            array[v].append(u)\n        if not v in array[u]:\n            array[u].append(v)\n    ans = (n ** k)\n    for i in range(n):\n        if not used[i]:\n            size = 1\n            dfs(i)\n            ans -= size ** k\n    print(ans % (10 ** 9 + 7))\nexcept Exception as e:\n    print(e)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, i, j, x, rez, nr, y, ok, md = 1000000007;\nlong long z[100005];\nstruct per {\n  long long x, t;\n} s;\nvector<per> ad[100005];\ndeque<per> q;\nint main() {\n  cin >> n >> k;\n  for (i = 1; i < n; i++) {\n    cin >> x >> y >> j;\n    ad[x].push_back({y, j});\n    ad[y].push_back({x, j});\n    if (j == 1) ok = 1;\n  }\n  rez = 1;\n  for (i = 1; i <= k; i++) rez = rez * n % md;\n  q.push_back({1, 0});\n  z[s.x] = 1;\n  while (!q.empty()) {\n    s = q.front();\n    q.pop_front();\n    z[s.x] = 1;\n    if (s.t == 0)\n      nr++;\n    else {\n      long long sc = 1;\n      for (i = 1; i <= k; i++) sc = sc * nr % md;\n      rez -= sc;\n      if (rez < 0) rez += md;\n      nr = 1;\n    }\n    for (auto i : ad[s.x]) {\n      if (z[i.x] == 0) {\n        z[i.x] = 1;\n        if (i.t == 0)\n          q.push_front(i);\n        else\n          q.push_back(i);\n      }\n    }\n  }\n  if (nr) {\n    long long sc = 1;\n    for (i = 1; i <= k; i++) sc = sc * nr % md;\n    rez -= sc;\n    if (rez < 0) rez += md;\n  }\n  if (ok == 0) rez = 0;\n  cout << rez << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long, long long> > adj[200002];\nbool visited[200002];\nlong long nPk(long long n, long long k) {\n  if (k == 0) return 1;\n  long long prod = 1;\n  for (long long i = 1; i <= k; i++) {\n    prod = (prod * n) % 1000000007;\n  }\n  return prod;\n}\nvoid dfs(long long s, long long &temp) {\n  visited[s] = true;\n  for (long long i = 0; i < adj[s].size(); i++) {\n    if (adj[s][i].second == 1) continue;\n    if (!visited[adj[s][i].first]) {\n      dfs(adj[s][i].first, ++temp);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; i++) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    adj[a].push_back(make_pair(b, c));\n    adj[b].push_back(make_pair(a, c));\n  }\n  for (long long i = 1; i <= n; i++) visited[i] = false;\n  long long ans = 0;\n  for (long long i = 1; i <= n; i++) {\n    long long temp = 1;\n    if (!visited[i]) {\n      dfs(i, temp);\n      long long tans;\n      tans = nPk(temp, k);\n      ans = (ans + tans) % 1000000007;\n    }\n  }\n  long long asd = nPk(n, k);\n  long long res = ((asd - ans) + 1000000007) % 1000000007;\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int res = 0;\nlong long int checker[100005] = {0};\nvector<long long int> v[100005];\nlong long int power(long long int n, long long int k) {\n  long long int result = 1;\n  while (k > 0) {\n    if (k % 2 == 1) result = (result * n) % 1000000007;\n    n = (n * n) % 1000000007;\n    k /= 2;\n  }\n  return result % 1000000007;\n}\nvoid dfs(long long int x) {\n  if (checker[x] == 1) return;\n  res++;\n  checker[x] = 1;\n  long long int i;\n  for (i = 0; i < v[x].size(); i++) {\n    dfs(v[x][i]);\n  }\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t = 1;\n  while (t--) {\n    long long int n, k, i, j;\n    cin >> n >> k;\n    for (i = 0; i < n - 1; i++) {\n      long long int a, b, c;\n      cin >> a >> b >> c;\n      if (c == 0) {\n        v[a].push_back(b);\n        v[b].push_back(a);\n      }\n    }\n    long long int ans = power(n, k);\n    for (i = 1; i <= n; i++) {\n      if (checker[i] == 1) continue;\n      res = 0;\n      dfs(i);\n      long long int sub = power(res, k);\n      ans -= sub;\n      ans += 1000000007;\n      ans = ans % 1000000007;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> adj[100005];\nvector<bool> vis;\nlong long int sz;\nlong long int power(long long int x, long long int y, long long int p) {\n  long long int res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nvoid dfs(int v) {\n  if (!vis[v]) {\n    vis[v] = true;\n    sz++;\n    for (int u : adj[v]) {\n      dfs(u);\n    }\n  } else {\n    return;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  long long int n, k;\n  cin >> n >> k;\n  long long int ans = power(n, k, 1000000007);\n  long long int i;\n  for (i = 1; i < n; i++) {\n    long long int u, v, x;\n    cin >> u >> v >> x;\n    if (!x) {\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n  }\n  vis.assign(n + 1, false);\n  for (i = 1; i <= n; i++) {\n    if (vis[i]) {\n      continue;\n    }\n    sz = 0;\n    dfs(i);\n    ans -= power(sz, k, 1000000007);\n    ans += 1000000007;\n    ans %= 1000000007;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput=sys.stdin.readline\nclass disjoint:\n    def __init__(self,n):\n        self.rank=[1]*n\n        self.parent=[i for i in range(n)]\n        self.size=[1]*n\n        \n    def find(self,x):\n        if(self.parent[x]!=x):\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x];\n       \n    def union(self,x,y):\n        xid=self.find(x)\n        yid=self.find(y)\n        \n        if(xid==yid):\n            return;\n        if(self.rank[xid]<self.rank[yid]):\n            self.parent[xid]=yid\n            self.size[yid]+=self.size[xid]\n            return;\n        elif(self.rank[xid]>self.rank[yid]):\n            self.parent[yid]=xid # merging y into x\n            self.size[xid]+=self.size[yid]\n            return;\n        else:\n            self.parent[yid]=xid\n            self.rank[xid]+=1\n            self.size[xid]+=self.size[yid]\n            return;        \n    \nfrom collections import *\n\npri=pow(10,9)+7\nn,k=map(int,input().split())\nobj=disjoint(n+1)\nfor i in range(n-1):\n    x,y,z=map(int,input().split())\n    if(z==0):\n        obj.union(x,y);\n\n    \nal=defaultdict(int)\ntotal=0\n\nfor i in range(1,n+1):\n    if(al[obj.find(i)]==0):\n        m=obj.size[obj.find(i)]\n        \n        total+=pow(m,k,pri)\n        al[obj.find(i)]=1\nprint((pow(n,k,pri)-total)%pri)\n\n\n#init function sort of creates the parent and the rank list\n#find function is used for to find rank\n#union function is used for doing the union\n#what does path function do , it makes find operation almost linear\n#makes our tree of very less height\n\n\n#use of log *n function -\n\n#number times log has to be applied to make log value as 1\n\n#by using path compression time complexty of each function is log*n\n\n#\n    \n            \n                            \n    \n\\\n  \n"
        },
        {
            "language": 3,
            "solution": "# your code goes here\nMOD = 1000000007\nN,K = [int(s) for s in input().split(\" \")]\nedges = [[] for i in range(N)]\nfor i in range(N-1):\n\ta,b,c = [int(s) for s in input().split(\" \")]\n\ta -= 1\n\tb -= 1\n\tif c == 0:\n\t\tedges[a].append(b)\n\t\tedges[b].append(a)\nans = pow(N,K,MOD)\nvisited = [False for i in range(N)]\ndef dfs(i):\n\tret = 0\n\ttodo = [i]\n\twhile len(todo)>0:\n\t\tv = todo.pop()\n\t\tif visited[v]:\n\t\t\tcontinue\n\t\tret += 1\n\t\tvisited[v] = True\n\t\tfor j in edges[v]:\n\t\t\ttodo.append(j)\n\treturn ret\n\t\nfor i in range(N):\n\tnum = dfs(i)\n\tans = (ans-pow(num,K,MOD)+MOD)%MOD\n\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int mxN = 1e5;\nmap<pair<int, int>, int> color;\nvector<int> g[mxN + 1];\nvector<int> path;\nint visited[mxN + 1];\nlong long n, k, ans, c;\nlong long powmod(long long a, long long b) {\n  long long res = 1;\n  if (a >= mod) a %= mod;\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a;\n    if (res >= mod) res %= mod;\n    a = a * a;\n    if (a >= mod) a %= mod;\n  }\n  return res;\n}\nvoid dfs(int u, int p) {\n  c++;\n  visited[u] = 1;\n  for (auto ch : g[u]) {\n    if (ch == p) continue;\n    if (!visited[ch] && !color[{u, ch}]) dfs(ch, u);\n  }\n}\nvoid solve2() {\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) dfs(i, -1), ans -= powmod(c, k), c = 0;\n    if (ans < 0) ans = (ans + mod) % mod;\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  for (int u, v, c, i = 1; i <= n - 1; i++)\n    cin >> u >> v >> c, g[u].push_back(v), g[v].push_back(u),\n        color.insert({{u, v}, c}), color.insert({{v, u}, c});\n  ans = powmod(n, k);\n  solve2();\n  cout << (ans + mod) % mod << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v[100005];\nlong long int vis[100005] = {0}, k, a[100005], z, ans, x = 0;\nmap<pair<int, int>, int> m;\nint bigmod(long long int a, long long int b, long long int m) {\n  if (b == 0) {\n    return 1 % m;\n  }\n  long long int x = bigmod(a, b / 2, m);\n  x = (x * x) % m;\n  if (b % 2 == 1) x = (x * a) % m;\n  return x;\n}\nvoid dfs(long long int x) {\n  long long int i;\n  vis[x] = 1;\n  for (i = 0; i < v[x].size(); i++) {\n    long long int d = v[x][i];\n    if (vis[d] == 0) {\n      dfs(d);\n      if (m[make_pair(x, d)] == 0) {\n        a[x] += a[d];\n      }\n      if (m[make_pair(x, d)] == 1) {\n        ans -= (bigmod(a[d], k, 1000000007));\n        ans += 1000000007;\n        ans = ans % 1000000007;\n      }\n    }\n  }\n}\nint main() {\n  long long int node, x, y, color, tot;\n  cin >> node >> k;\n  ans = bigmod(node, k, 1000000007);\n  for (int i = 0; i < node - 1; i++) {\n    cin >> x >> y >> color;\n    m[make_pair(x, y)] = color;\n    m[make_pair(y, x)] = color;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  for (z = 0; z < 100004; z++) a[z] = 1;\n  dfs(1);\n  ans -= (bigmod(a[1], k, 1000000007));\n  ans += 1000000007;\n  ans = ans % 1000000007;\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split(' '))\nsmej = []\nseen = []\nans = n ** k\n\n\ndef bfs(t):\n    global c, ocher\n    if seen[t] is False:\n        seen[t] = True\n        ocher.pop(0)\n        c += 1\n        for s in smej[t]:\n            if seen[s] is False and s not in ocher:\n                ocher.append(s)\n    else:\n        ocher.pop(0)\n\n\nfor t in range(n):\n    smej.append([])\n    seen.append(False)\nfor q in range(n - 1):\n    u, v, x = map(int, input().split(' '))\n    if x == 1:\n        continue\n    else:\n        smej[u - 1].append(v - 1)\n        smej[v - 1].append(u - 1)\n\nfor e in range(n):\n    c = 0\n    ocher = [e]\n    while len(ocher) != 0:\n        bfs(ocher[0])\n    ans -= c ** k\nprint(ans % (10 ** 9 + 7))\n"
        },
        {
            "language": 3,
            "solution": "def fact(n):\n\tif n == 0:\n\t\treturn 1\n\telse:\n\t\treturn (n * fact(n - 1))%(10 ** 9 + 7)\n\n\nn, k = [int(i) for i  in input().split()]\nq = [[] for i in range(n)]\nfor i in range(n - 1):\n\ta, b ,c = [int(i) for i in input().split()]\n\tif c == 0:\n\t\tq[a - 1].append(b - 1)\n\t\tq[b - 1].append(a - 1)\nused = [False]*n\nans = pow(n, k, 10**9+7)\nfor i in range(n):\n\tif not used[i]:\n\t\tcomp = []\n\t\tused[i] = True\n\t\tcomp.append(i)\n\t\tc = 0\n\t\twhile c < len(comp):\n\t\t\tfor j in q[comp[c]]:\n\t\t\t\tif not used[j]:\n\t\t\t\t\tused[j] = True\n\t\t\t\t\tcomp.append(j)\n\t\t\tc += 1\n\t\tans = (ans - pow(len(comp), k, 10 **9 + 7)) % (10 ** 9 + 7)\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split())\n\np = [i for i in range(n + 1)]\nsz = [1] * (n + 1)\n\n\ndef par(u):\n    if u == p[u]:\n        return u\n    p[u] = par(p[u])\n    return p[u]\n\n\ndef merge(u, v):\n    sz[par(v)] += sz[par(u)]\n    p[par(u)] = par(v)\n\n\nfor i in range(n - 1):\n    u, v, x = map(int, input().split())\n    if not x:\n        merge(u, v)\n\nMOD = int(1e9 + 7)\n\n\ndef mul(n, p):\n    ret = 1\n    while p:\n        if p % 2:\n            ret *= n\n            ret %= MOD\n        p //= 2\n        n *= n\n        n %= MOD\n    \n    return ret\n\n\n# ans = n ** k % MOD\nans = mul(n, k)\n\nuniques = set()\nfor i in range(1, n + 1):\n    parent = par(i)\n    if parent in uniques:\n        continue\n    uniques.add(parent)\n    # ans -= sz[parent] ** k % MOD\n    ans -= mul(sz[parent], k)\n    if ans < 0:\n        ans += MOD\n\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Edges {\n\tpublic static long mod = 1000000007;\n\tpublic static ArrayList<ArrayList<Integer>> list;\n\tpublic static int vis[];\n\tstatic long count = 0;\n\tpublic static long fast_pow(long a, long b) {\n\t\tif(b == 0)\n\t\t\treturn 1L;\n \n\t\tlong val = fast_pow(a, b / 2);\n \n\t\tif(b % 2 == 0)\n\t\t\treturn val * val % mod;\n\t\telse \n\t\t\treturn val * val % mod * a % mod;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tlist =  new ArrayList<ArrayList<Integer>>(n);\n\t\tfor (int i = 0; i<=n; i++) {\n\t\t\tlist.add(new ArrayList<Integer>());\n\t\t}\n\t\tvis =  new int[n+1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tif(c==0) {\n\t\t\t\tlist.get(u).add(v);\n\t\t\t\tlist.get(v).add(u);\n\t\t\t}\n\t\t}\n\t\tlong total = fast_pow(n, k)%mod;\n\t\tlong rem = 0;\n\t\tfor (int i = 1; i <=n; i++) {\n\t\t\tif(vis[i]==0) {\n\t\t\tcount  = 0;\n\t\t\tdfs(i);\n\t\t\trem = (rem%mod + (fast_pow(count,k))%mod)%mod;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((total-rem+mod)%mod);\n\t}\n\n\tprivate static void dfs(int i) {\n\t\tvis[i] = 1;\n\t\tcount++;\n\t\tfor (Integer e : list.get(i)) {\n\t\t\tif(vis[e]==0) {\n\t\t\t\tdfs(e);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO in pypy =D /pajenegod\n\nclass FastI:\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream, self.bufflines = BytesIO(), 0\n        def read2buffer(stream):\n            curpos,s = stream.tell(), os.read(fd, buffersize + os.fstat(fd).st_size)\n            return [s, stream.seek(0,2), stream.write(s), stream.seek(curpos)][0]\n        self.read2buffer = lambda: read2buffer(self.stream)\n        self.input = lambda: self.readline().rstrip(b'\\r\\n')\n    \n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read()\n\n    def readline(self):\n        while self.bufflines == 0: \n            s = self.read2buffer()\n            self.bufflines += s.count(b'\\n') + (not s)\n        self.bufflines -= 1\n        return self.stream.readline()\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(fd, stream.getvalue()) + stream.truncate(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.input\n\n################################# Testing filo code\n\ndef readLine():\n    return [int(i) for i in input().split()]\n\ndef deg(x, y):\n    if y == 1:\n        return x\n    res = deg(x, y // 2)\n    res *= res\n    res %= md\n    if y % 2 == 1:\n        res *= x\n        res %= md\n    return res\n\ndef dfs(v):\n    Q = [v]\n    used[v] = True\n    c = 0\n    while Q:\n        v = Q.pop()\n        c += 1\n        for to in g[v]:\n            if not used[to]:\n                used[to] = True\n                Q.append(to)\n    return c\n\nn, m = readLine()\ng = [[] for _ in range(n + 1)]\nmd = 1000000007\n\nfor i in range(n - 1):\n    x, y, t = readLine()\n    if t == 0:\n        g[x].append(y)\n        g[y].append(x)\n\nans = deg(n, m)\n\nused = [False]*(n+1)\nfor i in range(1, n + 1):\n    if used[i] == False:\n        b = dfs(i)\n        ans = ans - deg(b, m)\n        if ans < 0:\n            ans += md\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "def find_set(v):\n    if v == parent[v]:\n        return v\n    else:\n        parent[v]=find_set(parent[v])\n        return parent[v]\n\ndef union_sets(a,b):\n    a = find_set(a)\n    b = find_set(b)\n    if a != b:\n        if rank[a]<rank[b]:\n            a,b=b,a\n        parent[b] = a\n        if rank[a]==rank[b]:\n            rank[a]+=1\n\n\nn,k=list(map(int,input().split()))\nparent=[i for i in range(n)]\nrank=[0]*n\nfor i in range(n-1):\n    a,b,c=list(map(int,input().split()))\n    if c==0:\n        union_sets(a-1,b-1)\na={}\nfor i in range(n):\n    if find_set(i) not in a:\n        a[find_set(i)]=1\n    else:\n        a[find_set(i)]+=1\ns=0\nm=10**9+7\nfor i in a:\n    s=(s+pow(a[i],k,m))%m\nprint((pow(n,k,m)-s)%m)"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split())\nparent = [i for i in range(n + 1)]\ncnt = [1 for _ in range(n + 1)]\nmod = 10 ** 9 + 7\nans = (n ** k) % mod\n\ndef find(target):\n    if parent[target] == target:\n        return target\n    \n    parent[target] = find(parent[target])\n    return parent[target]\n\ndef union(u, v):\n    a = find(u)\n    b = find(v)\n\n    if cnt[a] < cnt[b]:\n        a,b = b,a\n    parent[b] = a\n    cnt[a] += cnt[b]\n\nfor _ in range(1, n):\n    u, v, x = map(int, input().split())\n    if x == 1:\n        continue\n    union(u, v)\n        \nfor j in range(1, n + 1):\n    if parent[j] == j:\n        val = (cnt[j] ** k) % mod\n        ans = (ans - val) % mod\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict as ddict\n\nway = ddict(list)\nisland = list()\nwent = set()\nmini_island = 0\n\ndef dfs(nd):\n    global mini_island, went\n    mini_island += 1\n    went.add(nd)\n    for it in way[nd]:\n        if it not in  went:\n            dfs(it)\n\nn, k = map(int, input().split())\nfor i in range(n-1):\n    u,v,x = map(int, input().split())\n    if x == 0:\n        way[u-1].append(v-1)\n        way[v-1].append(u-1)\n\nfor i in range(n):\n    if i not in went:\n        stack = [i]\n        went.add(i)\n        mini_island = 1\n        while stack:\n            now = stack.pop()\n            for v in way[now]:\n                if v not in went:\n                    stack.append(v)\n                    went.add(v)\n                    mini_island += 1\n        island.append(mini_island)\n\n#print(island)\nmd = 10**9+7\nans = pow(n,k,md)\nfor it in island:\n    ans -= pow(it,k,md)\n    ans %= md\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = -0x3ffffff;\nconst int maxn = 5e6 + 5;\nint fa[maxn];\nint fin(int x) {\n  if (x == fa[x]) return x;\n  return fa[x] = fin(fa[x]);\n}\nlong long n, m;\nlong long vis[maxn];\nconst long long mod = 1e9 + 7;\nlong long get(long long x, long long y) {\n  long long ans = 1;\n  long long h = x;\n  while (y) {\n    if (y % 2) ans = ans * x % mod;\n    y /= 2;\n    x = x * x % mod;\n  }\n  return (ans - h + mod) % mod;\n}\nint main() {\n  cin >> n >> m;\n  for (long long i = 1; i <= n + 5; i++) fa[i] = i;\n  for (int i = 0; i < n - 1; i++) {\n    long long l, r, t;\n    cin >> l >> r >> t;\n    if (!t) {\n      int x = fin(l), y = fin(r);\n      fa[x] = y;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    vis[fin(i)]++;\n  }\n  long long ans = 0;\n  long long res = get(n, m);\n  for (int i = 1; i <= n; i++) {\n    if (fin(i) == i) {\n      res -= get(vis[i], m);\n      res = (res + mod) % mod;\n    }\n  }\n  cout << (res + mod) % mod;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e5 + 9;\nconst int K = 102;\nconst long long MOD = (long long)1e9 + 7;\nvector<int> T[N];\nint sz = 0;\nbool vis[N];\nvoid dfs(int u, int par) {\n  if (vis[u]) return;\n  vis[u] = true;\n  sz++;\n  for (auto x : T[u]) {\n    dfs(x, u);\n  }\n}\nlong long powr(long long n, long long k) {\n  if (k == 0) return 1;\n  long long p = powr(n, k / 2);\n  p = (p * p) % MOD;\n  if (k & 1) p = (p * n) % MOD;\n  return p;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, k;\n  cin >> n >> k;\n  int u, v, r;\n  for (int i = 1; i < n; i++) {\n    cin >> u >> v >> r;\n    if (r == 0) {\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n  }\n  long long answ = powr(n, k);\n  for (int i = 1; i <= n; i++) {\n    sz = 0;\n    dfs(i, -1);\n    answ -= powr(sz, k);\n    answ += MOD;\n    answ %= MOD;\n  }\n  cout << answ;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, k = map(int,input().split())\nli = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v, c = map(int,input().split())\n    li[u].append((v,c))\n    li[v].append((u,c))\n\nstack = [(1,0)]\ni, j = 0, 0\nstart = [0]\nvisited = [False] * (n+1)\nwhile len(stack) != 0:\n    popped = stack.pop()\n    item = popped[0]\n    if not visited[item]:\n        start[popped[1]] += 1\n    visited[item] = True\n    for i in range(len(li[item])):\n        child = li[item][i]\n        if not visited[child[0]]:\n            if child[1] == 0:\n                stack.append((child[0],popped[1]))\n            else:\n                start.append(0)\n                pos = len(start) - 1\n                stack.append((child[0],pos))\nans = n**k\nfor i in start:\n    ans = ans - i**k\nprint(ans % (10**9+7))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int inf = 1e9 + 7, cnt;\nmap<long long int, vector<long long int>> red, black;\nvector<bool> visb, visr;\nset<long long int> tmp;\nvoid dfs(long long int r) {\n  visr[r] = true;\n  tmp.insert(r);\n  for (long long int i = 0; i < red[r].size(); ++i) {\n    if (visr[red[r][i]] == false and red.find(red[r][i]) != red.end())\n      dfs(red[r][i]);\n  }\n}\nvoid dfsb(long long int r) {\n  visb[r] = true;\n  tmp.insert(r);\n  for (long long int i = 0; i < black[r].size(); ++i) {\n    if (visb[black[r][i]] == false and black.find(black[r][i]) != black.end())\n      dfsb(black[r][i]);\n  }\n}\nlong long int power(long long int x, long long int y) {\n  long long int res = 1;\n  x = x % inf;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % inf;\n    y = y >> 1;\n    x = (x * x) % inf;\n  }\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n, k, ans;\n  cin >> n >> k;\n  ans = power(n, k);\n  visb.resize(n + 1, false);\n  visr.resize(n + 1, false);\n  for (long long int i = 0; i < n - 1; ++i) {\n    long long int x, y, z;\n    cin >> x >> y >> z;\n    if (z == 0)\n      red[x].push_back(y), red[y].push_back(x);\n    else\n      black[x].push_back(y), black[y].push_back(x);\n  }\n  for (long long int i = (1); i <= (n); ++i) {\n    if (red.find(i) != red.end() and visr[i] == 0) {\n      tmp.clear();\n      dfs(i);\n      cnt = tmp.size();\n      ans -= power(cnt, k);\n      if (ans < 0) ans += inf;\n    }\n    if (black.find(i) != black.end() and visb[i] == 0) {\n      tmp.clear();\n      dfsb(i);\n      cnt = tmp.size();\n      ans -= cnt;\n      if (ans < 0) ans += inf;\n    }\n    if (red.find(i) != red.end() and black.find(i) != black.end()) ans++;\n    ans %= inf;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dsu_root(int a, int *parent) {\n  return (a == parent[a]) ? a : parent[a] = dsu_root(parent[a], parent);\n}\nvoid dsu_join(int a, int b, int *parent) {\n  parent[dsu_root(b, parent)] = dsu_root(a, parent);\n}\nconstexpr int MOD = 1e9 + 7;\nunsigned pow_mod(unsigned b, unsigned p) {\n  uint64_t r = 1;\n  uint64_t b2 = b;\n  while (p) {\n    if (p & 1) {\n      r *= b2;\n      r %= MOD;\n    }\n    b2 *= b2;\n    b2 %= MOD;\n    p >>= 1;\n  }\n  return unsigned(r);\n}\nint main(int argc, char **argv) {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  int parent[n + 1];\n  memset(parent, 0, sizeof(parent));\n  for (int i = 0; i < n - 1; i++) {\n    int u, v, x;\n    scanf(\"%d%d%d\", &u, &v, &x);\n    if (!x) {\n      if (!parent[u]) parent[u] = u;\n      if (!parent[v]) parent[v] = v;\n      dsu_join(u, v, parent);\n    }\n  }\n  int sz[n + 1];\n  memset(sz, 0, sizeof(sz));\n  for (int i = 1; i <= n; i++) sz[dsu_root(i, parent)]++;\n  unsigned ans = pow_mod(n, k);\n  ans += MOD - n;\n  ans %= MOD;\n  for (int i = 1; i <= n; i++) {\n    if (sz[i] > 0) {\n      unsigned minus = pow_mod(sz[i], k);\n      minus += MOD - sz[i];\n      minus %= MOD;\n      ans += MOD - minus;\n      ans %= MOD;\n    }\n  }\n  printf(\"%u\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1139c {\n    static BufferedReader __in;\n    static PrintWriter __out;\n    static StringTokenizer input;\n\n    public static void main(String[] args) throws IOException {\n        __in = new BufferedReader(new InputStreamReader(System.in));\n        __out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        int n = rni(), k = ni();\n        DSU dsu = new DSU(n);\n        for(int i = 0; i < n - 1; ++i) {\n            int u = rni() - 1, v = ni() - 1, x = ni();\n            if(x == 0) {\n                dsu.union(u, v);\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < n; ++i) {\n            if(dsu.find(i) == i) {\n                ans = (ans + fmul(dsu.sz[i], (fpow(n, k - 1) - fpow(dsu.sz[i], k - 1) + IBIG) % IBIG)) % IBIG;\n            }\n        }\n        prln(ans);\n\n        close();\n    }\n\n    static int fpow(int a, int b) {\n        return fpow(a, b, IBIG);\n    }\n\n    static int fpow(int a, int b, int mod) {\n        if(a == 0) {\n            return 0;\n        }\n        long ans = 1, aL = a;\n        while(b > 0) {\n            if((b & 1) > 0) {\n                ans = (ans * aL) % mod;\n            }\n            aL = (aL * aL) % mod;\n            b >>= 1;\n        }\n        return (int)(ans % mod);\n    }\n\n    static int fmul(int a, int b) {\n        return fmul(a, b, IBIG);\n    }\n\n    static int fmul(int a, int b, int mod) {\n        long ans = 0, aL = a;\n        while(b > 0) {\n            if((b & 1) > 0) {\n                ans = (ans + aL) % mod;\n            }\n            aL = (aL << 1) % mod;\n            b >>= 1;\n        }\n        return (int)(ans % mod);\n    }\n\n    static class DSU {\n        boolean init = true;\n        int n, par[], sz[];\n\n        DSU(int n_) {\n            n = n_;\n            par = new int[n];\n            sz = new int[n];\n            if(init) {\n                init();\n            } else {\n                fill(par, -1);\n            }\n        }\n\n        void make(int v) {\n            par[v] = v;\n            sz[v] = 1;\n        }\n\n        void init() {\n            for(int i = 0; i < n; ++i) {\n                make(i);\n            }\n        }\n\n        int find(int v) {\n            if(par[v] == -1) {\n                return -1;\n            } else if(v == par[v]) {\n                return v;\n            } else {\n                par[v] = find(par[v]);\n                return par[v];\n            }\n        }\n\n        void union(int u, int v) {\n            int a = find(u), b = find(v);\n            if(a != b) {\n                if(sz[a] < sz[b]) {\n                    int swap = a;\n                    a = b;\n                    b = swap;\n                }\n                par[b] = a;\n                sz[a] += sz[b];\n            }\n        }\n    }\n\n    // references\n    // IBIG = 1e9 + 7\n    // IRAND ~= 3e8\n    // IMAX ~= 2e10\n    // LMAX ~= 9e18\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IRAND = 327859546;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {return x.length == 1 ? x[0] : x.length == 2 ? min(x[0], x[1]) : min(x[0], minstarting(1, x));}\n    static int minstarting(int offset, int... x) {assert x.length > 2; return offset == x.length - 2 ? min(x[offset], x[offset + 1]) : min(x[offset], minstarting(offset + 1, x));}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {return x.length == 1 ? x[0] : x.length == 2 ? min(x[0], x[1]) : min(x[0], minstarting(1, x));}\n    static long minstarting(int offset, long... x) {assert x.length > 2; return offset == x.length - 2 ? min(x[offset], x[offset + 1]) : min(x[offset], minstarting(offset + 1, x));}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {return x.length == 1 ? x[0] : x.length == 2 ? max(x[0], x[1]) : max(x[0], maxstarting(1, x));}\n    static int maxstarting(int offset, int... x) {assert x.length > 2; return offset == x.length - 2 ? max(x[offset], x[offset + 1]) : max(x[offset], maxstarting(offset + 1, x));}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {return x.length == 1 ? x[0] : x.length == 2 ? max(x[0], x[1]) : max(x[0], maxstarting(1, x));}\n    static long maxstarting(int offset, long... x) {assert x.length > 2; return offset == x.length - 2 ? max(x[offset], x[offset + 1]) : max(x[offset], maxstarting(offset + 1, x));}\n    static int powi(int a, int b) {if(a == 0) return 0; int ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if(a == 0) return 0; long ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int floori(double d) {return (int)d;}\n    static int ceili(double d) {return (int)ceil(d);}\n    static long floorl(double d) {return (long)d;}\n    static long ceill(double d) {return (long)ceil(d);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(__in.readLine());}\n    static int ri() throws IOException {return Integer.parseInt(__in.readLine());}\n    static long rl() throws IOException {return Long.parseLong(__in.readLine());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()); return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Long.parseLong(input.nextToken()); return a;}\n    static char[] rcha() throws IOException {return __in.readLine().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static int rni() throws IOException {input = new StringTokenizer(__in.readLine()); return Integer.parseInt(input.nextToken());}\n    static int ni() {return Integer.parseInt(input.nextToken());}\n    static long rnl() throws IOException {input = new StringTokenizer(__in.readLine()); return Long.parseLong(input.nextToken());}\n    static long nl() {return Long.parseLong(input.nextToken());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {__out.println(\"yes\");}\n    static void pry() {__out.println(\"Yes\");}\n    static void prY() {__out.println(\"YES\");}\n    static void prno() {__out.println(\"no\");}\n    static void prn() {__out.println(\"No\");}\n    static void prN() {__out.println(\"NO\");}\n    static void pryesno(boolean b) {__out.println(b ? \"yes\" : \"no\");};\n    static void pryn(boolean b) {__out.println(b ? \"Yes\" : \"No\");}\n    static void prYN(boolean b) {__out.println(b ? \"YES\" : \"NO\");}\n    static void prln(int... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static void prln(long... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for(int i = 0; i < n; __out.print(iter.next()), __out.print(' '), ++i); __out.println(iter.next());}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\t\n\tstatic long mod=1000000007;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tWriter out=new Writer(System.out);\n\t\tReader in=new Reader(System.in);\n\t\tint t=1;\n\t\twhile(t-->0) {\t\t\n\t\t\tint n=in.nextInt();\n\t\t\tint k=in.nextInt();\n\t\t\tlong total=pow(n,k);\n\t\t\tArrayList<Integer> [] gr=new ArrayList[n];\n\t\t\tfor(int i=0; i<n; i++) gr[i]=new ArrayList<>();\n\t\t\tfor(int i=0; i<n-1; i++) {\n\t\t\t\tint x=in.nextInt()-1;\n\t\t\t\tint y=in.nextInt()-1;\n\t\t\t\tint c=in.nextInt();\n\t\t\t\tif(c==0) {\n\t\t\t\t\tgr[x].add(y);\n\t\t\t\t\tgr[y].add(x);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tboolean vis[]=new boolean[n];\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tif(!vis[i]) {\n\t\t\t\t\tlong g=dfs(gr,vis,i);\n\t\t\t\t\ttotal=(total-pow(g,k)+mod)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(total);\n\t\t}\n\t\tout.close();\t\t\n\t}\n\t\n\tstatic long dfs(ArrayList<Integer> [] gr, boolean [] vis, int n) {\n\t\t\n\t\tlong g=1;\n\t\tvis[n]=true;\n\t\tfor(int i=0; i<gr[n].size(); i++) {\n\t\t\tif(!vis[gr[n].get(i)]) {\n\t\t\t\tg=(g+dfs(gr,vis,gr[n].get(i)))%mod;\n\t\t\t}\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tstatic long pow(long n, long k) {\n\t\tif(k==0) return 1;\n\t\tif(k==1) return n;\n\t\tlong temp=pow(n,k/2);\n\t\ttemp=(temp*temp)%mod;\n\t\tif(k%2==0) return temp%mod;\n\t\treturn (temp*n)%mod;\n\t}\n\t\n/**************************************************** UTILITY CODE BELOW ***********************************************************/\t\n\t\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> list=new ArrayList<>();\n\t\tfor (int i:a) list.add(i);\n\t\tCollections.sort(list);\n\t\tfor (int i=0; i<a.length; i++) a[i]=list.get(i);\n\t}\n\t\n\tstatic class Reader{\n\t\t\n\t\tBufferedReader br;\n\t\tStringTokenizer to;\n\t\t\n\t\tReader(InputStream stream){\n\t\t\tbr=new BufferedReader(new InputStreamReader(stream));\n\t\t\tto=new StringTokenizer(\"\");\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\twhile(!to.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tto=new StringTokenizer(br.readLine());\t\n\t\t\t\t}catch(IOException e) {}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn to.nextToken();\n\t\t\t\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tint [] readArray(int n) {\n\t\t\tint a[]=new int[n];\n\t\t\tfor(int i=0; i<n ;i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong [] readLongArray(int n) {\n\t\t\tlong a[]=new long[n];\n\t\t\tfor(int i=0; i<n ;i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class Writer extends PrintWriter{\n\t\tWriter(OutputStream stream){\n\t\t\tsuper(stream);\n\t\t}\n\t\tvoid println(int [] array) {\n\t\t\tfor(int i=0; i<array.length; i++) {\n\t\t\t\tprint(array[i]+\" \");\n\t\t\t}\n\t\t\tprintln();\n\t\t}\n\t}\n\t\n}"
        },
        {
            "language": 4,
            "solution": "//package albert.codeforces.edgytrees1139c;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Solution {\n    static long MOD = (long) (1e9 + 7);\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n        int[] uf = new int[n];\n        for (int i = 1; i < n; i++) {\n            uf[i] = i;\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int s = scanner.nextInt() - 1;\n            int d = scanner.nextInt() - 1;\n            int c = scanner.nextInt();\n            if (c == 0) {\n                int sp = parent(s, uf);\n                int dp = parent(d, uf);\n                uf[sp] = dp;\n            }\n        }\n        Map<Integer, Integer> componentSize = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int p = parent(i, uf);\n            componentSize.put(p, componentSize.getOrDefault(p, 0) + 1);\n        }\n        long ans = 0;\n\n        for (Integer v : componentSize.values()) {\n            ans += npowk(v, k);\n            ans = ans % MOD;\n        }\n        System.out.println((npowk(n, k) + MOD - ans) % MOD);\n    }\n\n    private static long npowk(int n, int k) {\n        long ans = 1;\n        for (int i = 0; i < k; i++) {\n            ans = ans * n;\n            ans = ans % MOD;\n        }\n        return ans;\n    }\n\n    private static int parent(int n, int[] uf) {\n        int parent = n;\n        while (uf[parent] != parent) {\n            parent = uf[parent];\n        }\n        uf[n] = parent;\n        return parent;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v[100005];\nlong long vis[100005];\nlong long bigmod(long long a, long long b, long long M) {\n  if (b == 0) return 1 % M;\n  long long x = bigmod(a, b / 2, M);\n  x = (x * x) % M;\n  if (b % 2 == 1) x = (x * a) % M;\n  return x;\n}\nlong long dfs(int u) {\n  vis[u] = 1;\n  for (int i : v[u]) {\n    if (vis[i] == 0) {\n      vis[u] += dfs(i);\n    }\n  }\n  return vis[u];\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  long long a, b, c, d, e, f, i, j, k, m, n, o, x, y;\n  cin >> n >> k;\n  for (i = 0; i < n - 1; i++) {\n    cin >> a >> b >> c;\n    if (!c) {\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n  }\n  long long pans = 0;\n  for (i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      d = dfs(i);\n      pans += bigmod(d, k, (int)1e9 + 7);\n      pans %= (int)1e9 + 7;\n    }\n  }\n  long long ans = bigmod(n, k, (int)1e9 + 7) + (int)1e9 + 7 - pans;\n  ans %= (int)1e9 + 7;\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 100;\nconst int mod = 1e9 + 7;\nint cnt[maxn];\nvector<pair<int, int> > edge[maxn];\nvector<int> q[maxn];\nvoid dfs(int u, int col) {\n  cnt[u] = col;\n  for (int i = 0; i < edge[u].size(); i++) {\n    int to = edge[u][i].first;\n    if (cnt[to] || edge[u][i].second) continue;\n    dfs(to, col);\n  }\n}\nint main() {\n  int n, m, tot = 0;\n  scanf(\"%d %d\", &n, &m);\n  int st, ed, col;\n  for (int i = 1; i <= n - 1; i++) {\n    scanf(\"%d %d %d\", &st, &ed, &col);\n    edge[st].push_back(make_pair(ed, col));\n    edge[ed].push_back(make_pair(st, col));\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!cnt[i]) {\n      tot++;\n      dfs(i, tot);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    q[cnt[i]].push_back(i);\n  }\n  long long sum = 0;\n  long long tmp = 1;\n  for (int i = 1; i <= m; i++) {\n    tmp = tmp * n % mod;\n  }\n  sum = tmp;\n  for (int i = 1; i <= tot; i++) {\n    long long tmp = 1;\n    for (int j = 0; j < m; j++) {\n      tmp = tmp * q[i].size() % mod;\n    }\n    sum = (sum - tmp + mod) % mod;\n  }\n  printf(\"%lld\\n\", sum);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9 + 7;\nlong long r;\nvector<vector<int>> g(100010);\nvector<vector<int>> w(100010);\nbool used[1000100];\nvoid dfs(int x) {\n  r++;\n  used[x] = true;\n  for (int i = 0; i < g[x].size(); i++) {\n    if (!used[g[x][i]] && !w[x][i]) dfs(g[x][i]);\n  }\n}\nint main() {\n  long long n, k, u, v, b;\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    cin >> u >> v >> b;\n    g[u].emplace_back(v);\n    g[v].emplace_back(u);\n    w[u].emplace_back(b);\n    w[v].emplace_back(b);\n  }\n  long long mr = 0;\n  for (int i = 1; i <= n; i++)\n    if (!used[i]) {\n      r = 0;\n      dfs(i);\n      long long ss = r;\n      r = 1;\n      for (int j = 0; j < k; j++) r = (ss * r) % INF;\n      mr = (mr + r) % INF;\n    }\n  long long h = n;\n  n = 1;\n  for (int i = 0; i < k; i++) n = (n * h) % INF;\n  h = n - mr;\n  while (h < 0) h += INF;\n  cout << h % INF << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n \npublic class A\n{\n    \n\n\tstatic Node[] graph;\n    static boolean[] visited;\n    static int n;\n    static int k;\n    static ArrayList<Integer> tab;\n    static final int MOD = (int) 1e9 + 7;\n\n    static void dfs(int a) {\n        visited[a] = true;\n        for (Pair p : graph[a].edges) {\n            if (!visited[p.x]) {\n                dfs(p.x);\n                graph[a].nb += graph[p.x].nb + 1;\n            }\n        }\n    }\n\n    static int pow(long x, long y, int p) {\n        long res = 1;\n        x = x % p;\n\n        while (y > 0) {\n            if ((y & 1) == 1)\n                res = (res * x) % p;\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return (int) res;\n    }\n\n    \n        \n\n\n    static class Pair {\n        int x;\n        int y;\n\n    }\n\n    static class Node {\n        ArrayList<Pair> edges;\n        int nb;\n\n    }\n\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc=new Scanner(System.in);\n\t\tn = sc.nextInt();\n        k = sc.nextInt();\n        graph = new Node[n];\n        visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new Node();\n            graph[i].edges = new ArrayList<>();\n        }\n        tab = new ArrayList<>();\n        int x, y, t;\n        Pair p;\n        for (int i = 0; i < n - 1; i++) {\n            x = sc.nextInt()- 1;\n            y = sc.nextInt() - 1;\n            t = sc.nextInt();\n            if (t == 0) {\n                p = new Pair();\n                p.x = y;\n                p.y = t;\n                graph[x].edges.add(p);\n                p = new Pair();\n                p.x = x;\n                p.y = t;\n                graph[y].edges.add(p);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i);\n                tab.add(graph[i].nb + 1);\n            }\n        }\n        long ans = pow(n, k, MOD);\n        for (int i = 0; i < tab.size(); i++) {\n            ans -= (pow(tab.get(i), k, MOD));\n            if (ans < 0) {\n                ans += MOD;\n            }\n        }\n\n        System.out.println(ans);\n        \n\n\t}\n\n}"
        },
        {
            "language": 3,
            "solution": "# -*- coding: utf-8 -*-\n# @Time    : 2019/3/21 23:56\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : C. Edgy Trees.py\n\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.root = [i for i in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def find(self, x):\n        if self.root[x] == x:\n            return x\n        self.root[x] = self.find(self.root[x])\n        return self.root[x]\n\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        self.root[y] = x\n        self.size[x] += self.size[y]\n\n\ndef pow_mod(a, b, p):\n    ret = 1\n    while b > 0:\n        if b % 2 == 1:\n            ret = ret * a % p\n        b //= 2\n        a = a * a % p\n    return ret\n\n\ndef main():\n    n, k = map(int, input().split())\n\n    union_find = UnionFind(n + 1)\n    for _ in range(n - 1):\n        u, v, c = map(int, input().split())\n        if c == 0:\n            union_find.union(u, v)\n\n    p = int(1e9 + 7)\n    ret = pow_mod(n, k, p)\n    used = set()\n    for i in range(1, n + 1):\n        x = union_find.find(i)\n        if x not in used:\n            ret = (ret + p - pow_mod(union_find.size[x], k, p)) % p\n            used.add(x)\n    print(ret)\n\n\nif __name__ == '__main__':\n    main()\n    # print(pow_mod(4, 4, 3))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000 * 1000 + 10, M = (1 << 9);\nconst int mod = 1000 * 1000 * 1000 + 7;\nvector<int> adj[N];\nint cnt;\nint tv(int x, int y) {\n  if (!y) return 1;\n  long long ans = tv(x, y / 2);\n  ans *= ans;\n  ans %= mod;\n  if (y & 1) ans *= x;\n  return ans % mod;\n}\nbool mark[N];\nvoid dfs(int u) {\n  mark[u] = 1;\n  cnt++;\n  for (auto v : adj[u])\n    if (!mark[v]) dfs(v);\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, k, ans;\n  cin >> n >> k;\n  ans = tv(n, k);\n  for (int i = 1; i < n; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    if (!z) {\n      adj[x].push_back(y);\n      adj[y].push_back(x);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (mark[i]) continue;\n    cnt = 0;\n    dfs(i);\n    ans += mod - tv(cnt, k);\n    ans %= mod;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "# Fast IO Region\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# Get out of main function\ndef main():\n    pass\n# decimal to binary\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n# binary to decimal\ndef decimal(s):\n    return (int(s, 2))\n# power of a number base 2\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return (p)\n# if  number is prime in \u221an time\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n# list to string ,no spaces\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n# String to list\ndef stl(s):\n    # for each character in string to list with no spaces -->\n    l = list(s)\n    # for space in string  -->\n    # l=list(s.split(\" \"))\n    return l\n# Returns list of numbers with a particular sum\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n# Sieve for prime numbers in a range\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n            # print(p)\n    return (cnt)\n# for positive integerse only\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n# 1000000007\nmod = int(1e9) + 7\nimport math\n#import random\n#import bisect\n#from fractions import Fraction\n#from collections import OrderedDict\n#from collections import deque\n########################                         mat=[[0 for i in range(n)] for j in range(m)]                      ########################\n########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################\n########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################\n########################                         from collections import deque                              ########################\n########################                         ASCII of A-Z= 65-90                                        ########################\n########################                         ASCII of a-z= 97-122                                       ########################\n########################                         d1.setdefault(key, []).append(value)                       ########################\n#sys.setrecursionlimit(300000)          #Gives memory limit exceeded if used a lot\n#for ___ in range(int(input())):\nn,k=map(int,input().split())\nd={}\nfor i in range(n-1):\n    u,v,x=map(int,input().split())\n    d.setdefault(v,[])\n    d.setdefault(u,[])\n    if(x==0):\n        d[u].append(v)\n        d[v].append(u)\nvisited=[0]*n\ncnt=0\ntot=n**k\nlength=[]\nstack=[]\nwhile(cnt!=n):\n    stack.append(visited.index(0)+1)\n    ans=1\n    while(stack):\n        node=stack.pop()\n        visited[node-1]=1\n        cnt+=1\n        for child in d[node]:\n            if(visited[child-1]==0):\n                stack.append(child)\n                ans+=1\n    length.append(ans)\nfor c in length:\n    tot-=c**k\nprint(tot%mod)"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\nn, k = map(int, input().split())\ng = defaultdict(list)\nfor _ in range(n-1):\n    u, v, x = map(int, input().split())\n    u, v = u-1, v-1\n    if not x:\n        g[u].append(v)\n        g[v].append(u)\nMOD = 10**9 + 7\n\nres = pow(n, k, MOD)\n\nvisited = [False for _ in range(n)]\nfor i in range(n):\n    if not visited[i]:\n        cnt = 1\n        visited[i] = True\n        stack = [i]\n        while stack:\n            curr = stack.pop()\n            for ne in g[curr]:\n                if not visited[ne]:\n                    visited[ne] = True\n                    cnt += 1\n                    stack.append(ne)\n        res -= pow(cnt, k, MOD)\n\nprint(res % MOD)\n"
        },
        {
            "language": 4,
            "solution": "//package com.company;\n// Always comment out package when submitting.\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static class Task {\n\n        public int dfs(int u, List<Integer>[] edges, boolean[] visit) {\n            visit[u] = true;\n            int cnt = 0;\n            for (int v: edges[u]) {\n                if (!visit[v]) {\n                    cnt += dfs(v, edges, visit);\n                }\n            }\n            return cnt + 1;\n        }\n        int mod = 1_000_000_007;\n        public long pow(long a, int b){\n            if (b == 0) return 1;\n            if (b % 2 == 0) return pow(a * a % mod, b >> 1);\n            return a * pow(a * a % mod, b >> 1) % mod;\n        }\n\n        public void solve(Scanner sc, PrintWriter pw) throws IOException {\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            List<Integer>[] edges = new List[n];\n            for (int i = 0; i < n; i++) {\n                edges[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < n - 1; i++) {\n                int u = sc.nextInt() - 1;\n                int v = sc.nextInt() - 1;\n                int t = sc.nextInt();\n                if (t == 0) {\n                    edges[u].add(v);\n                    edges[v].add(u);\n                }\n            }\n            List<Integer> components = new ArrayList<>();\n            boolean[] visit=  new boolean[n];\n            for (int i = 0; i < n; i++) {\n                if (!visit[i]) {\n                    components.add(dfs(i, edges, visit));\n                }\n            }\n            long tot = pow(n, k);\n            for (int y : components) {\n                tot = (tot + mod - pow(y, k)) % mod;\n            }\n            pw.println(tot);\n        }\n    }\n\n    // template, actual code is in class Task.\n    static long TIME_START, TIME_END;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n//        Scanner sc = new Scanner(new FileInputStream(\"Test.in\"));\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n//        PrintWriter pw = new PrintWriter(new FileOutputStream(\"Test.out\"));\n        Runtime runtime = Runtime.getRuntime();\n        long usedMemoryBefore = runtime.totalMemory() - runtime.freeMemory();\n        TIME_START = System.currentTimeMillis();\n        Task t = new Task();\n        t.solve(sc, pw);\n        TIME_END = System.currentTimeMillis();\n        long usedMemoryAfter = runtime.totalMemory() - runtime.freeMemory();\n        pw.close();\n//        System.err.println(\"Memory increased: \" + (usedMemoryAfter - usedMemoryBefore) / 1000000);\n//        System.err.println(\"Time used: \" + (TIME_END - TIME_START) + \".\");\n    }\n\n    // Faster IO with BufferedReader wrapped with Scanner\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader s) throws FileNotFoundException {\n            br = new BufferedReader(s);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CEdgyTrees solver = new CEdgyTrees();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CEdgyTrees {\n        long ans[][] = new long[100005][105];\n        public static Node graph[] = new Node[100005];\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) throws IOException {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            for (int i = 0; i < n + 5; i++)\n                for (int j = 0; j < k + 1; j++)\n                    ans[i][j] = -1;\n            for (int i = 0; i < n; i++)\n                graph[i] = new Node(i + 1);\n            for (int i = 0; i < n - 1; i++) {\n                int c1 = in.nextInt() - 1, c2 = in.nextInt() - 1;\n                int color = in.nextInt();\n                if (color == 0) {\n                    graph[c1].connectedNodes.add(graph[c2]);\n                    graph[c2].connectedNodes.add(graph[c1]);\n                }\n            }\n            long length;\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (!graph[i].isVisited) {\n                    length = spread(graph[i]);\n                    ans += power(length, k);\n                }\n            }\n            long temp=(power(n, k) - ans + 1000000007) % 1000000007;\n            if(temp<0)\n                temp+=1000000007;\n            out.printLine(temp);\n        }\n\n        public static long power(long x, int p) {\n            if (p == 1)\n                return x;\n            else if (p % 2 == 0)\n                return (power(x, p / 2) * power(x, p / 2)) % 1000000007;\n            else\n                return (x * power(x, p - 1)) % 1000000007;\n        }\n\n        public int spread(Node N) {\n            N.isVisited = true;\n            Node x;\n            int ans = 0;\n            for (int i = 0; i < N.connectedNodes.size(); i++) {\n                x = N.connectedNodes.get(i);\n                if (!x.isVisited)\n                    ans += spread(x);\n            }\n            return 1 + ans;\n        }\n\n        public class Node {\n            ArrayList<Node> connectedNodes;\n            int x;\n            boolean isVisited;\n\n            Node(int x) {\n                isVisited = false;\n                this.x = x;\n                connectedNodes = new ArrayList<>();\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private static final int DEFAULT_BUFFER_SIZE = 1 << 16;\n        private static final InputStream DEFAULT_STREAM = System.in;\n        private int c;\n        private byte[] buf;\n        private int bufferSize;\n        private int bufIndex;\n        private int numBytesRead;\n        private InputStream stream;\n        private static final byte EOF = -1;\n        private static final byte SPACE = 32;\n        private static final byte DASH = 45;\n        private char[] charBuffer;\n        private static byte[] bytes = new byte[58];\n        private static int[] ints = new int[58];\n        private static char[] chars = new char[128];\n\n        static {\n            char ch = ' ';\n            int value = 0;\n            byte _byte = 0;\n            for (int i = 48; i < 58; i++) bytes[i] = _byte++;\n            for (int i = 48; i < 58; i++) ints[i] = value++;\n            for (int i = 32; i < 128; i++) chars[i] = ch++;\n        }\n\n        public InputReader() {\n            this(DEFAULT_STREAM, DEFAULT_BUFFER_SIZE);\n        }\n\n        public InputReader(int bufferSize) {\n            this(DEFAULT_STREAM, bufferSize);\n        }\n\n        public InputReader(InputStream stream) {\n            this(stream, DEFAULT_BUFFER_SIZE);\n        }\n\n        public InputReader(InputStream stream, int bufferSize) {\n            if (stream == null || bufferSize <= 0)\n                throw new IllegalArgumentException();\n            buf = new byte[bufferSize];\n            charBuffer = new char[128];\n            this.bufferSize = bufferSize;\n            this.stream = stream;\n        }\n\n        private int readJunk(int token) throws IOException {\n\n            if (numBytesRead == EOF) return EOF;\n\n            // Seek to the first valid position index\n            do {\n\n                while (bufIndex < numBytesRead) {\n                    if (buf[bufIndex] > token) return 0;\n                    bufIndex++;\n                }\n\n                // reload buffer\n                numBytesRead = stream.read(buf);\n                if (numBytesRead == EOF) return EOF;\n                bufIndex = 0;\n\n            } while (true);\n\n        }\n\n        public int nextInt() throws IOException {\n\n            if (readJunk(DASH - 1) == EOF) throw new IOException();\n            int sgn = 1, res = 0;\n\n            c = buf[bufIndex];\n            if (c == DASH) {\n                sgn = -1;\n                bufIndex++;\n            }\n\n            do {\n\n                while (bufIndex < numBytesRead) {\n                    if (buf[bufIndex] > SPACE) {\n                        res = (res << 3) + (res << 1);\n                        res += ints[buf[bufIndex++]];\n                    } else {\n                        bufIndex++;\n                        return res * sgn;\n                    }\n                }\n\n                // Reload buffer\n                numBytesRead = stream.read(buf);\n                if (numBytesRead == EOF) return res * sgn;\n                bufIndex = 0;\n\n            } while (true);\n\n        }\n\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n    private static FastScanner sc = new FastScanner();\n    static Node[] V;\n    static long clusterSize = 0;\n    private static long mod = 1000000007;\n\n    public static void main(String[] args) {\n    \tint n = sc.nextInt();\n    \tint k = sc.nextInt();\n    \tV = new Node[n];\n    \tfor(int i=0; i<n; i++) {\n    \t\tV[i] = new Node();\n    \t}\n    \tfor(int i=0; i<n-1; i++) {\n    \t\tint a = sc.nextInt() - 1;\n    \t\tint b = sc.nextInt() - 1;\n    \t\tint x = sc.nextInt();\n    \t\tif(x == 1) continue;\n    \t\tV[a].nbr.add(b);\n    \t\tV[b].nbr.add(a);\n    \t}\n    \tArrayList<Long> redCluster = new ArrayList<>();\n    \tfor(int i=0; i<n; i++) {\n    \t\tif(!V[i].vst) {\n    \t\t\tclusterSize = 0;\n    \t\t\tV[i].dfs();\n    \t\t\tredCluster.add(clusterSize);\n    \t\t}\n    \t}\n    \tlong ans = power(n, k);\n    \tfor(long x : redCluster) {\n    \t\tans = (ans - power(x, k) + mod) % mod;\n    \t}\n    \tSystem.out.println(ans);\n    }\n\n    static class Node {\n        HashSet<Integer> nbr = new HashSet<>();\n        boolean vst = false;\n        void dfs() {\n        \tvst = true;\n        \tclusterSize++;\n        \tfor(int x : nbr) {\n        \t\tif(!V[x].vst) V[x].dfs();\n        \t}\n        }\n    }\n\n    static long power(long m , long n){\n    \tif(n == 0) {\n    \t\treturn 1;\n    \t}else if(n == 1){\n            return m;\n        }else if(n % 2 == 0){\n            long s = power(m, n/2);\n            return ( (s % mod) * (s % mod) ) % mod;\n        }else{\n            return ( (m % mod) * (power(m, n-1) % mod) ) % mod;\n        }\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nlong long rand_seed() {\n  long long a = rng();\n  return a;\n}\nint n, k;\nlong long nr[102][100002], gg[102][100002];\nvector<pair<int, int> > v[100002];\nvector<int> cc[100002];\nint ccc;\nbool viz[100002];\nvoid dfs(int nod) {\n  cc[ccc].push_back(nod);\n  viz[nod] = 1;\n  for (int i = 0; i < v[nod].size(); ++i) {\n    int vecin = v[nod][i].first;\n    int cl = v[nod][i].second;\n    if (cl == 0 && !viz[vecin]) dfs(vecin);\n  }\n}\nlong long tsum[100002];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k;\n  for (int i = 1; i < n; ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[a].push_back({b, c});\n    ;\n    v[b].push_back({a, c});\n  }\n  for (int i = 1; i <= n; ++i) nr[1][i] = 1;\n  for (int i = 1; i <= n; ++i) {\n    if (!viz[i]) {\n      ++ccc;\n      dfs(i);\n    }\n  }\n  for (int i = 1; i < k; ++i) {\n    long long totsum = 0;\n    long long tt = 0;\n    for (int j = 1; j <= ccc; ++j) {\n      long long sum = 0;\n      for (int p = 0; p < cc[j].size(); ++p)\n        sum = (sum + nr[i][cc[j][p]]) % 1000000007,\n        tt = (tt + gg[i][cc[j][p]]) % 1000000007;\n      for (int p = 0; p < cc[j].size(); ++p) nr[i + 1][cc[j][p]] = sum;\n      totsum = (totsum + sum) % 1000000007;\n      tsum[j] = sum;\n    }\n    for (int j = 1; j <= ccc; ++j) {\n      long long sum = totsum + 1000000007 - tsum[j];\n      sum %= 1000000007;\n      for (int p = 0; p < cc[j].size(); ++p)\n        gg[i + 1][cc[j][p]] = (sum + tt) % 1000000007;\n    }\n  }\n  long long ans = 0;\n  for (int j = 1; j <= n; ++j) ans = (ans + gg[k][j]) % 1000000007;\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class Solution \n{\n\tstatic class InputReader\n\t{\n\t    private final InputStream stream;\n\t    private final byte[] buf = new byte[8192];\n\t    private int curChar, snumChars;\n\n\t    public InputReader(InputStream st) {\n\t      this.stream = st;\n\t    }\n\n\t    public int read() {\n\t      if (snumChars == -1)\n\t        throw new InputMismatchException();\n\t      if (curChar >= snumChars) {\n\t        curChar = 0;\n\t        try {\n\t          snumChars = stream.read(buf);\n\t        } catch (IOException e) {\n\t          throw new InputMismatchException();\n\t        }\n\t        if (snumChars <= 0)\n\t          return -1;\n\t      }\n\t      return buf[curChar++];\n\t    }\n\n\t    public int nextInt() {\n\t      int c = read();\n\t      while (isSpaceChar(c)) {\n\t        c = read();\n\t      }\n\t      int sgn = 1;\n\t      if (c == '-') {\n\t        sgn = -1;\n\t        c = read();\n\t      }\n\t      int res = 0;\n\t      do {\n\t        res *= 10;\n\t        res += c - '0';\n\t        c = read();\n\t      } while (!isSpaceChar(c));\n\t      return res * sgn;\n\t    }\n\n\t    public long nextLong() {\n\t      int c = read();\n\t      while (isSpaceChar(c)) {\n\t        c = read();\n\t      }\n\t      int sgn = 1;\n\t      if (c == '-') {\n\t        sgn = -1;\n\t        c = read();\n\t      }\n\t      long res = 0;\n\t      do {\n\t        res *= 10;\n\t        res += c - '0';\n\t        c = read();\n\t      } while (!isSpaceChar(c));\n\t      return res * sgn;\n\t    }\n\n\t    public int[] nextIntArray(int n) {\n\t      int a[] = new int[n];\n\t      for (int i = 0; i < n; i++) {\n\t        a[i] = nextInt();\n\t      }\n\t      return a;\n\t    }\n\n\t    public String readString() {\n\t      int c = read();\n\t      while (isSpaceChar(c)) {\n\t        c = read();\n\t      }\n\t      StringBuilder res = new StringBuilder();\n\t      do {\n\t        res.appendCodePoint(c);\n\t        c = read();\n\t      } while (!isSpaceChar(c));\n\t      return res.toString();\n\t    }\n\n\t    public String nextLine() {\n\t      int c = read();\n\t      while (isSpaceChar(c))\n\t        c = read();\n\t      StringBuilder res = new StringBuilder();\n\t      do {\n\t        res.appendCodePoint(c);\n\t        c = read();\n\t      } while (!isEndOfLine(c));\n\t      return res.toString();\n\t    }\n\n\t    public boolean isSpaceChar(int c) {\n\t      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t    }\n\n\t    private boolean isEndOfLine(int c) {\n\t      return c == '\\n' || c == '\\r' || c == -1;\n\t    }\n\t}\n  public static class pair\n    {\n        int val,level;\n        public pair(int a,int b)\n        {\n            this.val = a;\n            this.level = b;\n        }\n    }\n   public static class graph\n    {\n        public LinkedList<Integer>[] adj;\n        public int size;\n        public int count;\n        public graph(int n)\n        {\n            this.size = n;\n            this.count = 0;\n            adj = new LinkedList[n+1];\n            for(int i=0;i<=n;i++)\n                adj[i] = new LinkedList<>();\n        }\n        public void add(int u,int v)\n        {\n            adj[u].add(v);\n            adj[v].add(u);\n        }\n        public void dfs(int src,boolean[] vis)\n        {\n            vis[src] = true;\n            count++;\n            Iterator<Integer> it = adj[src].iterator();\n            while(it.hasNext())\n            {\n                int n = it.next();\n                if(!vis[n])\n                    dfs(n,vis);\n            }\n        }\n        public void print()\n        {\n            for(int i=0;i<=size;i++)\n            {\n                System.out.print(i + \" --> \");\n                Iterator<Integer> it = adj[i].iterator();\n                while(it.hasNext())\n                {\n                    int n = it.next();\n                    System.out.print(n + \", \");\n                }\n                System.out.println();\n            }\n        }\n    }\n    public static void main(String[] args) throws Exception\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n       \tString[] str = (br.readLine()).trim().split(\" \");\n        int n = Integer.parseInt(str[0]);\n        int k = Integer.parseInt(str[1]);\n        graph g = new graph(n);\n        for(int i=0;i<n-1;i++)\n        {\n            str = (br.readLine()).trim().split(\" \");\n            int u = Integer.parseInt(str[0]);\n            int v = Integer.parseInt(str[1]);\n            int type = Integer.parseInt(str[2]);\n            if(type == 0)\n                g.add(u,v);\n        }\n        long mod = 1000000000 + 7;\n        long sum = 0;\n        boolean[] vis = new boolean[n+1];\n        //g.print();\n        for(int i=1;i<=n;i++)\n        {\n            long pro = 1;\n            if(!vis[i])\n            {\n                g.count = 0;\n                g.dfs(i,vis);\n                //System.out.println(g.count);\n                for(int j=0;j<k;j++)\n                {\n                    pro = (pro*g.count)%mod;\n                }\n                sum = (sum + pro)%mod;\n            }    \n        }\n        long total = 1;\n        for(int i=0;i<k;i++)\n        {\n            total = (total*n)%mod;\n        }\n        long ans = (total - sum + mod)%mod;\n        out.println(ans);\n       \tout.close();\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict as dd\ndef dfs(s, tree, visited):\n    stack = []\n    if s not in visited:\n        stack.append(s)\n    ccsize = 0\n    while stack:\n        v = stack.pop()\n        ccsize+=1\n        if v not in visited:\n            visited.add(v)\n        for n in tree[v]:\n            if n not in visited:\n                stack.append(n)\n    return ccsize\n\ndef read_input():\n    return [int(i) for i in input().split()]\n\n\nif __name__ == '__main__':\n    n, k = read_input()\n    total = n**k\n    final = 10**9+7\n    tree = dd(list)\n    for i in range(n-1):\n        u, v, c = read_input()\n        if c == 0:\n            tree[u].append(v)\n            tree[v].append(u)\n    count_bad = 0\n    visited = set()\n    for i in range(1,n+1):\n        count_bad= (count_bad % final + dfs(i,tree, visited)**k % final)\n    print(((total % final) - (count_bad % final) + final) % final)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int MOD = 1000000007;\nvector<vector<long long int> > graph;\nvector<int> visited;\nvector<int> level;\nvector<int> colors;\nlong long int multmod(long long int a, long long int b, long long int m) {\n  a = a % m;\n  b = b % m;\n  long long int ans = 0;\n  while (b > 0) {\n    if (b & 1 == 1) {\n      ans = (ans + a) % m;\n    }\n    b = b >> 1;\n    a = (a * 2) % m;\n  }\n  return ans % m;\n}\nlong long int powmod(long long int x, long long int y, long long int m) {\n  if (x == 0) {\n    return 0;\n  }\n  long long int ans = 1;\n  x = x % m;\n  while (y > 0) {\n    if (y & 1 == 1) {\n      ans = multmod(ans, x, m) % m;\n    }\n    x = multmod(x, x, m) % m;\n    y = y >> 1;\n  }\n  return ans % m;\n}\nlong long int nodesnum;\nvoid dfs_stack(long long int node) {\n  long long int top;\n  stack<long long int> nodes;\n  nodes.push(node);\n  visited[node] = 1;\n  while (!nodes.empty()) {\n    top = nodes.top();\n    nodes.pop();\n    nodesnum++;\n    for (long long int i : graph[top]) {\n      if (!visited[i]) {\n        nodes.push(i);\n        visited[i] = 1;\n      }\n    }\n  }\n}\nvoid bfs(long long int node) {\n  long long int top;\n  queue<long long int> nodes;\n  nodes.push(node);\n  visited[node] = 1;\n  level[node] = 0;\n  while (!nodes.empty()) {\n    top = nodes.front();\n    nodes.pop();\n    cout << top << endl;\n    for (long long int i : graph[top]) {\n      if (!visited[i]) {\n        nodes.push(i);\n        visited[i] = 1;\n        level[i] = level[top] + 1;\n      }\n    }\n  }\n}\nint main() {\n  long long int n, k;\n  cin >> n >> k;\n  graph.resize(n);\n  visited.resize(n);\n  long long int u, v, x;\n  for (long long int i = 0; i < n - 1; i++) {\n    cin >> u >> v >> x;\n    if (x == 0) {\n      graph[u - 1].push_back(v - 1);\n      graph[v - 1].push_back(u - 1);\n    }\n  }\n  nodesnum = 0;\n  long long int sub = 0;\n  for (long long int i = 0; i < n; i++) {\n    if (!visited[i]) {\n      nodesnum = 0;\n      dfs_stack(i);\n      sub = (sub + powmod(nodesnum, k, 1000000007)) % 1000000007;\n    }\n  }\n  long long int ans = powmod(n, k, 1000000007) % 1000000007;\n  ans = (ans + MOD - sub) % 1000000007;\n  cout << ans % 1000000007;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split())\n\np = [i for i in range(n + 1)]\nsz = [1] * (n + 1)\n\n\ndef par(u):\n    if u == p[u]:\n        return u\n    p[u] = par(p[u])\n    return p[u]\n\n\ndef merge(u, v):\n    sz[par(v)] += sz[par(u)]\n    p[par(u)] = par(v)\n\n\nfor i in range(n - 1):\n    u, v, x = map(int, input().split())\n    if not x:\n        merge(u, v)\n\nMOD = int(1e9 + 7)\n\n\ndef mul(n, p):\n    ret = 1\n    for i in range(p):\n        ret *= n\n        ret %= MOD\n    return ret\n\n\n# ans = n ** k % MOD\nans = mul(n, k)\n\nuniques = set()\nfor i in range(1, n + 1):\n    parent = par(i)\n    if parent in uniques:\n        continue\n    uniques.add(parent)\n    # ans -= sz[parent] ** k % MOD\n    ans -= mul(sz[parent], k)\n    if ans < 0:\n        ans += MOD\n\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class File {\n\tstatic class DSU {\n\t\tint[] parents;\n\t\tint[] size;\n\t\t\n\t\tpublic DSU(int N) {\n\t\t\tparents = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tparents[i] = i;\n\t\t\t}\n\t\t\t\n\t\t\tsize = new int[N];\n\t\t}\n\t\t\n\t\tpublic int getParent(int x) {\n\t\t\tif (x != parents[x]) parents[x] = getParent(parents[x]);\n\t\t\treturn parents[x];\n\t\t}\n\t\t\n\t\tpublic void union(int x, int y) {\n\t\t\tint xParent = getParent(x);\n\t\t\tint yParent = getParent(y);\n\t\t\t\n\t\t\tif (xParent != yParent) {\n\t\t\t\tif (size[xParent] < size[yParent]) {\n\t\t\t\t\tparents[xParent] = yParent;\n\t\t\t\t}\n\t\t\t\telse if (size[xParent] > size[yParent]) {\n\t\t\t\t\tparents[yParent] = xParent;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparents[yParent] = xParent;\n\t\t\t\t\tsize[xParent]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\t\t\t\t\n\t\tlong n = sc.nextInt(); // Size of tree.\n\t\tlong k = sc.nextInt(); // Length of vertex sequence.\n\t\t\n\t\tlong mod = 1000000007;\n\t\t\n\t\tboolean hasBlackEdge = false;\n\t\t\n\t\tDSU dsu = new DSU((int)n);\n\t\t\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tint color = sc.nextInt(); // 0=red, 1=black\n\t\t\t\n\t\t\tif (color == 1) {\n\t\t\t\thasBlackEdge = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsu.union(u, v);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// There are no black edges in this graph, so no valid paths.\n\t\tif (!hasBlackEdge) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong totalSequences = fastPow(n, k, mod) % mod;\n\t\t\n\t\t// Count how many nodes have a parent in the DSU.\n\t\tMap<Integer, Integer> sizes = new HashMap<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint parent = dsu.getParent(i);\n\t\t\tsizes.put(parent, sizes.getOrDefault(parent, 0) + 1);\n\t\t}\n\t\t\n\t\tlong invalidSequences = 0;\n\t\tfor (int parent : sizes.keySet()) {\n\t\t\tinvalidSequences = (invalidSequences + fastPow(sizes.get(parent), k, mod)) % mod;\n\t\t}\n\t\t\n\t\tif (totalSequences < invalidSequences) {\n\t\t    totalSequences = (totalSequences + mod);\n\t\t}\n\t\t\n\t\t// Count the total invalid sequences.\n\t\tlong res = (totalSequences - invalidSequences) % mod;\n\t\t\n\t\tSystem.out.println(res);\n\t}\n\t\n\tpublic static long fastPow(long x, long pow, long mod) {\n\t\tif (pow == 0) return 1;\n\t\tif (pow == 1) return x;\n\t\t\n\t\tlong half = fastPow(x, pow / 2, mod) % mod;\n\t\t\n\t\tif (pow % 2 == 0) {\n\t\t\treturn (half * half) % mod;\n\t\t}\n\t\telse {\n\t\t\treturn (((half * half) % mod) * x) % mod;\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "//package Main;\n\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int maxn = 1000010; \n\tstatic int mod = 1000000007; \n\tstatic int[] pre = new int[maxn];\n\tstatic int[] siz = new int[maxn];\n\tpublic static void init(){\n\t\tfor(int i=0;i<maxn;i++){\n\t\t\tpre[i]=i;\n\t\t\tsiz[i]=0;\n\t\t}\n\t}\n\tpublic static int find(int x){\n\t\tif(pre[x]==x) return x;\n\t\treturn pre[x]=find(pre[x]);\n\t}\n\tpublic static void unite(int a,int b){\n\t\tint fx=find(a);\n\t\tint fy=find(b);\n\t\tif(fx!=fy) pre[fx]=fy;\n\t}\n\tpublic static long qpow(long a,long b){\n\t\tlong res=1;\n\t\twhile(b>0){\n\t\t\tif(b%2==1) res=res*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn res%mod;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tinit();\n\t\tint n = input.nextInt();\n\t\tint k = input.nextInt();\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint a=input.nextInt();\n\t\t\tint b=input.nextInt();\n\t\t\tint c=input.nextInt();\n\t\t\tif(c==0) unite(a,b);\n\t\t}\n\t\tlong ans=qpow(n,k);\n\t\tfor(int i=1;i<=n;i++) siz[find(i)]++;\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(pre[i]==i){\n\t\t\t\tcnt+=siz[i];\n\t\t\t\tans=(ans-qpow(siz[i],k)+mod)%mod;\n\t\t\t}\n\t\t}\n\t\tans=(ans-(n-cnt)+mod)%mod;\n\t\tans=(ans+mod)%mod;\n\t\tSystem.out.println(ans);\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nimport sys\n\ndef bfs(start):\n    q=[start]\n    count=1\n    used[start]=1\n    while q!=[]:\n        for u in g[q[0]]:\n            if used[u]==0:\n                count+=1\n                used[u]=1\n                q.append(u)\n        q.pop(0)\n    return count\n\nn,k=map(int,input().split())\n\nmod=10**9+7\nblack=0\ng=[[] for i in range(n)]\nfor i in range(n-1):\n    v,u,x=map(int,input().split())\n    v-=1;u-=1\n    if x==0:\n        g[v].append(u)\n        g[u].append(v)\n\nused=[0]*n\nres=1\nr=[]\n\nfor i in range(n):\n    if g[i]!=[] and used[i]==0:\n        qq=bfs(i)\n\n        #print(qq) #--------------------------------\n\n        r.append(qq)\n\nfor i in range(k):\n    res=(res*n)%mod\n\nfor i in range(len(r)):\n    rt=1\n    for j in range(k):\n        rt=(rt*r[i])%mod\n    #print(\"rt = \",rt)\n    res=(res+mod-rt)%mod\n\nprint((res-(n-sum(r))+mod)%mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long int N, M;\n  cin >> N >> M;\n  vector<vector<long long int> > vect(N + 1);\n  long long int a, b, c, i, j, k;\n  for (i = 1; i < N; i++) {\n    cin >> a >> b >> c;\n    vect[a].push_back(b);\n    vect[a].push_back(c);\n    vect[b].push_back(a);\n    vect[b].push_back(c);\n  }\n  queue<long long int> q;\n  bool x[N + 1];\n  memset(x, false, sizeof(x));\n  long long int count = 0;\n  vector<long long int> vect1;\n  for (i = 1; i <= N; i++) {\n    if (x[i] == false) {\n      q.push(i);\n      x[i] = true;\n      count = 1;\n      while (q.size() > 0) {\n        a = q.front();\n        q.pop();\n        for (j = 0; j < vect[a].size(); j += 2) {\n          if ((vect[a][j + 1] == 0) && (x[vect[a][j]] == false)) {\n            q.push(vect[a][j]);\n            x[vect[a][j]] = true;\n            count++;\n          }\n        }\n      }\n      vect1.push_back(count);\n    }\n  }\n  long long int ans = 1;\n  for (i = 1; i <= M; i++) {\n    ans = (ans * N) % 1000000007;\n    ;\n  }\n  a = 0;\n  for (i = 0; i < vect1.size(); i++) {\n    b = 1;\n    for (j = 1; j <= M; j++) {\n      b = (b * vect1[i]) % 1000000007;\n      ;\n    }\n    a = (a + b) % 1000000007;\n    ;\n  }\n  ans = ans - a;\n  if (ans < 0) {\n    ans += 1000000007;\n    ;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> adj[100005];\nbool vis[100005];\nlong long power(long long x, long long y, long long p) {\n  long long res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nlong long cnt1 = 0;\nmap<pair<long long, long long>, long long> mpp;\nvoid dfs(long long val) {\n  vis[val] = true;\n  cnt1++;\n  for (auto& i : adj[val]) {\n    if (!vis[i] && (mpp[{i, val}] == 0 && mpp[{val, i}] == 0)) {\n      dfs(i);\n    }\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k, mod = 1e9 + 7, x, y, z, ans;\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; i++) {\n    cin >> x >> y >> z;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n    mpp[{x, y}] = z;\n    mpp[{y, x}] = z;\n  }\n  ans = power(n, k, mod);\n  for (long long i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      cnt1 = 0;\n      dfs(i);\n      ans -= power(cnt1, k, mod);\n      while (ans < 0) ans += mod;\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import collections\nfrom collections import defaultdict as dd\nn,k = input().split()\nn,k=[int(n),int(k)]\ngraph1=dd(list)\npower=(n**k)%(10**9+7)\n\nfor x in range(n-1):\n    u,v,x= input().split()\n    u,v,x=[int(u),int(v),int(x)]\n    if x==0:\n        graph1[u].append(v)\n        graph1[v].append(u)\ndef bfs(graph, root):\n    count=1\n    queue =  collections.deque([root])\n    visited.add(root)\n    while queue: \n        vertex = queue.popleft()\n        for neighbour in graph[vertex]: \n            if neighbour not in visited: \n                visited.add(neighbour) \n                queue.append(neighbour)\n                count+=1\n    \n    return count\nvisited=set()\nfor i in range(1,n+1):\n    \n    if i not in visited:\n        \n        xy=bfs(graph1,i)\n        power=(power-(xy**k)%(10**9+7))%(10**9+7)\n        \nprint(power%(10**9+7))\n\n\n\n\n    \n    \n\n"
        },
        {
            "language": 3,
            "solution": "import io, os\ninput = io.StringIO(os.read(0, os.fstat(0).st_size).decode()).readline\n\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nMOD = 10 ** 9 + 7\n\nn, k = mi()\np, s = list(range(n + 1)), [1] * (n + 1)\n\ndef find(x):\n    if p[x] != x:\n        p[x] = find(p[x])\n    return p[x]\n\ndef union(x, y):\n    x, y = find(x), find(y)\n    if x == y: return\n    if s[x] < s[y]: x, y = y, x\n    p[y] = x\n    s[x] += s[y]\n\nfor _ in range(n - 1):\n    u, v, c = mi()\n    if c == 0:\n        union(u, v)\n\ngrps = []\nfor u in range(1, n + 1):\n    if p[u] == u:\n        grps.append(s[u])\n\nans = (pow(n, k, MOD) - sum(pow(x, k, MOD) for x in grps)) % MOD\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst int N = 1e5 + 69;\nint n, k;\nvector<int> red[N];\nbool vis[N];\nint child[N];\nlong long modpow(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) {\n      res = res * a % MOD;\n    }\n    a = a * a % MOD;\n    b >>= 1;\n  }\n  return res;\n}\nvoid dfs(int node) {\n  child[node] = 1;\n  for (auto i : red[node]) {\n    if (vis[i]) continue;\n    vis[i] = true;\n    dfs(i);\n    child[node] += child[i];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    if (!x) {\n      red[u].push_back(v);\n      red[v].push_back(u);\n    }\n  }\n  long long redOnly = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      vis[i] = true;\n      dfs(i);\n      redOnly = redOnly + modpow(1LL * child[i], 1LL * k);\n      redOnly %= MOD;\n    }\n  }\n  long long ans = modpow(1LL * n, 1LL * k) - redOnly;\n  ans %= MOD;\n  if (ans < 0) ans += MOD;\n  ans %= MOD;\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long parent[100000 + 5];\nlong long Size[100000 + 5];\nlong long power(long long x, long long y, long long p) {\n  long long res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nvoid first(long long n) {\n  for (long long i = 1; i <= n; i++) {\n    parent[i] = i;\n    Size[i] = 1;\n  }\n}\nlong long findroot(long long p) {\n  while (parent[p] != p) {\n    p = parent[p];\n  }\n  return p;\n}\nint main() {\n  long long n, k, x, y, t, cnt1 = 0, root1, root2, ans = 0, finans, cnt2 = 0;\n  long long mod = 1000000007;\n  map<long long, long long> m1;\n  map<long long, long long> m0;\n  scanf(\"%lld\", &n);\n  ;\n  scanf(\"%lld\", &k);\n  ;\n  first(n);\n  finans = power(n, k, mod);\n  for (long long i = 0; i < n - 1; i++) {\n    scanf(\"%lld\", &x);\n    ;\n    scanf(\"%lld\", &y);\n    ;\n    scanf(\"%lld\", &t);\n    ;\n    if (t == 1) {\n      m1[x] = 1;\n      m1[y] = 1;\n    }\n    if (t == 0) {\n      m0[x] = 1;\n      m0[y] = 1;\n      root1 = findroot(x);\n      root2 = findroot(y);\n      if (root1 != root2) {\n        if (Size[root1] > Size[root2] || Size[root1] == Size[root2]) {\n          parent[root2] = root1;\n          Size[root1] += Size[root2];\n        } else {\n          parent[root1] = root2;\n          Size[root2] += Size[root1];\n        }\n      }\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    if (m1[i] == 1 && m0.find(i) == m0.end()) {\n      cnt1++;\n    }\n    if (m1[i] == 1) {\n      cnt2++;\n    }\n  }\n  for (long long j = 1; j <= n; j++) {\n    if (m0[j] == 1 && parent[j] == j) {\n      long long val = Size[j];\n      ans = ((ans % mod) + power(val, k, mod)) % mod;\n    }\n  }\n  if (cnt2 == 0) {\n    printf(\"%s\", \"0\");\n    ;\n    printf(\"\\n\");\n    ;\n  } else {\n    finans = (((finans - ans) % mod) + mod) % mod;\n    finans = (((finans - cnt1) % mod) + mod) % mod;\n    printf(\"%lld\", finans);\n    ;\n    printf(\"\\n\");\n    ;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint father[100005], answer[100005];\nint getfather(int x) {\n  if (father[x] != x) {\n    father[x] = getfather(father[x]);\n  }\n  return father[x];\n}\nvoid join(int a, int b) {\n  a = getfather(a);\n  b = getfather(b);\n  if (a != b) {\n    if (a < b) {\n      father[a] = b;\n    } else {\n      father[b] = a;\n    }\n  }\n}\nint main() {\n  int n, k, a, b, c;\n  int64_t total, now;\n  total = 1;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= k; i++) {\n    total *= n;\n    total %= mod;\n  }\n  for (int i = 1; i <= n; i++) {\n    father[i] = i;\n  }\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d%d\", &a, &b, &c);\n    if (c == 0) {\n      join(a, b);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    father[i] = getfather(i);\n    answer[father[i]]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (answer[i]) {\n      now = 1;\n      for (int j = 1; j <= k; j++) {\n        now *= answer[i];\n        now %= mod;\n      }\n      total -= now;\n      total %= mod;\n      total += mod;\n      total %= mod;\n    }\n  }\n  printf(\"%I64d\\n\", total);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Edgy_Tress\n{\n    static ArrayList<Integer> arr [];\n    static ArrayList<Integer> visited;\n    static long mod = 1000000007;\n    static long DFS(int start,int n)\n    {\n        visited.set(start,1);\n        //System.out.print(start+\" \");\n        Iterator<Integer> i = arr[start].listIterator();\n        long count = 1;\n        while(i.hasNext())\n        {\n            int next = i.next();\n            //System.out.print(next+\" \");\n            if(visited.get(next)==0)\n                count+=DFS(next,n);\n        }\n        return count;\n\n\n    }\n    static long pow(long a, int b)\n    {\n        if(b==0)\n            return 1;\n        long ans = pow(a,b/2);\n        if(b%2==0)\n            return ans*ans%mod;\n        else\n            return ans*ans%mod*a%mod;\n    }\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int  n =sc.nextInt();\n        int  k =sc.nextInt();\n        arr=  new ArrayList[n+1];\n        visited = new ArrayList<>();\n\n        for(int i =0;i<=n;i++)\n        {\n            arr[i] = new ArrayList<>();\n\n            visited.add(0);\n\n        }\n\n        for(int i=0;i<n-1;i++)\n        {\n            int v1 =sc.nextInt(), v2 = sc.nextInt();\n            int c = sc.nextInt();\n            if(c==0)\n            {\n                arr[v1].add(v2);\n                arr[v2].add(v1);\n            }\n\n        }\n        long bad=0;\n\n        for(int i=1;i<=n;i++)\n        {\n            if(visited.get(i)==0)\n            {\n                bad+= (long)(pow(DFS(i,n),k));\n\n                //System.out.println(bad);\n            }\n        }\n        //System.out.println((long)Math.pow(n,k)-bad);\n        bad%=mod;\n        long ans = (pow(n,k)-bad+mod)%mod;\n        System.out.print(ans);\n\n\n\n\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split())\n\nmd = 10**9 + 7\nres = n**k\n\nneighbours = {}\nfor i in range(n - 1):\n  u, v, x = map(int, input().split())\n  if x == 0:\n    if u in neighbours:\n      neighbours[u].add(v)\n    else:\n      neighbours[u] = set([v])\n    if v in neighbours:\n      neighbours[v].add(u)\n    else:\n      neighbours[v] = set([u])\n\ncomp = []\nvisited = [0] * (n + 1)\n# compute all component\nfor i in range(1, n + 1):\n  if not visited[i]:\n    comp.append([i])\n    visited[i] = 1\n    q = [i]\n    while len(q) > 0:\n      u = q.pop(0)\n      if u not in neighbours:\n        continue\n      for v in neighbours[u]:\n        if not visited[v]:\n          q.append(v)\n          comp[-1].append(v)\n          visited[v] = 1\n          \nfor c in comp:\n  m = len(c)\n  res -= m**k\n\nprint(res%md)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 1;\nconst long long mod = 1e9 + 7;\nconst int inf = 0x7fffffff;\nint shuyu[N], num[N], fa[N];\nbool flag[N];\nint n, k, t = 0;\nint find(int x) {\n  if (fa[x] == x) return x;\n  return fa[x] = find(fa[x]);\n}\nint poww(int a, long long n, int p) {\n  int x = 1;\n  while (n) {\n    if (n & 1) x = 1ll * x * a % p;\n    a = 1ll * a * a % p;\n    n >>= 1;\n  }\n  return x;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  int g, j, m;\n  for (int i = 0; i < N; i++) fa[i] = i;\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d%d\", &g, &j, &m);\n    if (!m) {\n      fa[find(g)] = find(j);\n      flag[g] = flag[j] = true;\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (flag[i]) {\n      shuyu[i] = find(i);\n      num[shuyu[i]]++;\n    }\n  long long ans = poww(n, k, mod);\n  for (int i = 1; i <= n; i++) {\n    if (num[i]) ans = 1ll * (ans - poww(num[i], k, mod) + mod) % mod;\n    if (!shuyu[i]) ans = 1ll * (ans - 1 + mod) % mod;\n  }\n  printf(\"%I64d\\n\", ans % mod);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static int bfs(ArrayList<ArrayList<Integer>> edges, boolean[] visited, int src) {\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.add(src);\n\t\tvisited[src] = true;\n\t\tint size = 1;\n\t\twhile(queue.size() > 0) {\n\t\t\tint curr = queue.poll();\n\t\t\tfor(int i = 0; i < edges.get(curr).size(); i++) {\n\t\t\t\tint pt = edges.get(curr).get(i);\n\t\t\t\tif(!visited[pt]) {\n\t\t\t\t\tsize++;\n\t\t\t\t\tqueue.add(pt);\n\t\t\t\t\tvisited[pt] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\n\t\n\tpublic static long power(long a, long b, long c) {\n\t\tif(b == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(b % 2 == 0) {\n\t\t\treturn power((a * a) % c, b / 2, c);\n\t\t} else {\n\t\t\treturn (a % c * power((a * a) % c, b / 2, c)) % c;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt(), k = s.nextInt();\n\t\tArrayList<ArrayList<Integer>> edges = new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tedges.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tint u = s.nextInt() - 1, v = s.nextInt() - 1, c = s.nextInt();\n\t\t\tif(c == 0) {\n\t\t\t\tedges.get(u).add(v);\n\t\t\t\tedges.get(v).add(u);\n\t\t\t}\n\t\t}\n\t\tlong ans = 0, mod = (long)Math.pow(10, 9) + 7;\n\t\tans = power(n, k, mod);\n\t\tboolean[] visited = new boolean[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\tans = (ans - power(bfs(edges, visited, i), k, mod) + mod) % mod;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n\n        new Main().go();\n    }\n\n    PrintWriter out;\n    Reader in;\n    BufferedReader br;\n\n    Main() throws IOException {\n\n        try {\n\n            //br = new BufferedReader( new FileReader(\"input.txt\") );\n            //in = new Reader(\"input.txt\");\n            in = new Reader(\"input.txt\");\n            out = new PrintWriter( new BufferedWriter(new FileWriter(\"output.txt\")) );\n        }\n        catch (Exception e) {\n\n            //br = new BufferedReader( new InputStreamReader( System.in ) );\n            in = new Reader();\n            out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );\n        }\n    }\n\n    void go() throws Exception {\n\n        //int t = in.nextInt();\n        int t = 1;\n        while (t > 0) {\n            solve();\n            t--;\n        }\n\n        out.flush();\n        out.close();\n    }\n\n\n    int inf = 2000000000;\n    int mod = 1000000007;\n    double eps = 0.000000001;\n\n    int n;\n    int m;\n\n    ArrayList<Integer>[] g;\n    int[] a;\n\n    void solve() throws IOException {\n\n        int n = in.nextInt();\n        int k = in.nextInt();\n        g = new ArrayList[n];\n        for (int i = 0; i < n; i++)\n            g[i] = new ArrayList<>();\n        for (int i = 0; i < n - 1; i++) {\n            int x = in.nextInt() - 1;\n            int y = in.nextInt() - 1;\n            int c = in.nextInt();\n            if (c == 0) {\n                g[x].add(y);\n                g[y].add(x);\n            }\n        }\n\n        long ans = 1;\n\n        for (int i = 0; i < k; i++)\n            ans = (ans * n) % mod;\n\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                int cnt = dfs(i);\n                long st = 1;\n                for (int j = 0; j < k; j++)\n                    st = (st * cnt) % mod;\n                ans = (ans - st + mod) % mod;\n            }\n        }\n\n        out.println(ans);\n    }\n\n    boolean[] used = new boolean[200000];\n    int dfs(int v) {\n        int cnt = 1;\n        used[v] = true;\n        for (int u : g[v])\n            if (!used[u])\n                cnt += dfs(u);\n        return cnt;\n    }\n\n    class Pair implements Comparable<Pair>{\n\n        int a;\n        int b;\n\n        Pair(int a, int b) {\n\n            this.a = a;\n            this.b = b;\n        }\n\n        public int compareTo(Pair p) {\n            if (a != p.a)\n                return Integer.compare(a, p.a);\n            else\n                return Integer.compare(b, p.b);\n        }\n    }\n\n    class Item {\n\n        int a;\n        int b;\n        int c;\n\n        Item(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n    }\n\n\n    class Reader {\n\n        BufferedReader  br;\n        StringTokenizer tok;\n\n        Reader(String file) throws IOException {\n            br = new BufferedReader( new FileReader(file) );\n        }\n\n        Reader() throws IOException {\n            br = new BufferedReader( new InputStreamReader(System.in) );\n        }\n\n        String next() throws IOException {\n\n            while (tok == null || !tok.hasMoreElements())\n                tok = new StringTokenizer(br.readLine());\n            return tok.nextToken();\n        }\n\n        int nextInt() throws NumberFormatException, IOException {\n            return Integer.valueOf(next());\n        }\n\n        long nextLong() throws NumberFormatException, IOException {\n            return Long.valueOf(next());\n        }\n\n        double nextDouble() throws NumberFormatException, IOException {\n            return Double.valueOf(next());\n        }\n\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n    }\n\n    static class InputReader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public InputReader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n} "
        },
        {
            "language": 3,
            "solution": "# Template 1.0\nimport sys, re, math\nfrom collections import deque, defaultdict, Counter, OrderedDict\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom heapq import heappush, heappop, heapify, nlargest, nsmallest\ndef STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef sortListWithIndex(listOfTuples, idx):   return (sorted(listOfTuples, key=lambda x: x[idx]))\ndef sortDictWithVal(passedDic):\n    temp = sorted(passedDic.items(), key=lambda kv: (kv[1], kv[0]))[::-1]\n    toret = {}\n    for tup in temp:\n        toret[tup[0]] = tup[1]\n    return toret\ndef sortDictWithKey(passedDic):\n    return dict(OrderedDict(sorted(passedDic.items())))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nn,k = MAP()\n\nredNodes = set()\n\ngraph = defaultdict(list)\nedges = defaultdict(lambda: None)\n\nfor _ in range(n-1):\n    a,b,c = MAP()\n    if(c==0):\n        redNodes.add(a)\n        redNodes.add(b)\n    graph[a].append(b)\n    graph[b].append(a)\n\n    edges[(a,b)] = c\n    edges[(b, a)] = c\n\ntotalRed = len(redNodes)\n\ntotal = pow(n,k,mod)\n\nvisited = [0]*(n+1)\n\nconsReds = []\n\nfor i in range(1, n+1):\n    if(visited[i]==False):\n        stack = [i]\n        numReds = 0\n        while(stack):\n            node = stack.pop()\n\n            visited[node] = True\n\n            # flag = 1\n            for child in graph[node]:\n                if(visited[child]==False):\n                    # flag = 0\n                    if(edges[(node, child)]==0):\n                        stack.append(child)\n                        numReds+=1\n\n        consReds.append(numReds)\n\n# print(consReds, n - totalRed)\ntoSub = n-totalRed\nfor el in consReds:\n    if(el!=0):\n        toSub += pow(el+1, k, mod)\n\n# print(total, toSub)\nrem = (total - toSub)%mod\nif(rem<0):\n    print(mod - rem)\nelse:\n    print(rem)\n'''\n13 3\n9 13 1\n8 3 1\n11 9 0\n8 13 0\n10 9 0\n2 7 0\n4 8 1\n11 5 0\n10 12 0\n12 1 1\n5 7 0\n6 8 1\n'''"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nlong long quick_pow(long long x, long long a) {\n  long long ans = 1;\n  while (a) {\n    if (a & 1) ans = ans * x % MOD;\n    x = x * x % MOD;\n    a >>= 1;\n  }\n  return ans;\n}\nint n, k, pa[100005], size[100005];\nint find(int x) { return x == pa[x] ? x : pa[x] = find(pa[x]); }\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; i++) pa[i] = i, size[i] = 1;\n  for (int i = 1; i < n; i++) {\n    int u, v, l;\n    scanf(\"%d%d%d\", &u, &v, &l);\n    if (l == 0) {\n      u = find(u), v = find(v);\n      if (u == v) continue;\n      if (size[u] > size[v]) swap(u, v);\n      pa[u] = v;\n      size[v] += size[u];\n    }\n  }\n  long long ans = quick_pow(n, k);\n  for (int i = 1; i <= n; i++) {\n    if (find(i) == i) ans -= quick_pow(size[i], k);\n  }\n  ans %= MOD;\n  if (ans < 0) ans += MOD;\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nfrom collections import *\n\ndef power(a, b, mod):\n    res = 1\n    \n    while b:\n        if b%2:\n            res = (res*a)%mod\n        \n        b //= 2\n        a = (a*a)%mod    \n            \n    return res%mod\n\nMOD = 1000000007\nn, k = map(int, input().split())\nans = power(n, k, MOD)\nadj = defaultdict(list)\n\nfor i in range(n-1):\n    u, v, x = map(int, input().split())\n    if not x:\n        adj[u].append(v)\n        adj[v].append(u)\n        \nv = [0]*(1+n)\n\nfor i in range(1, 1+n):\n    if not v[i]:\n        cmp = 0\n        q = [i]\n        \n        while q:\n            e = q.pop()\n            if not v[e]:\n                cmp += 1\n            v[e] = 1\n            \n            for j in adj[e]:\n                if not v[j]:\n                    q.append(j)\n\n        ans = (ans%MOD-power(cmp, k, MOD))%MOD\n                    \nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class C {\n    static BufferedReader br;\n    static StringTokenizer st;\n\n    static String nextToken() {\n        try {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return st.nextToken();\n    }\n\n    static String nextString() throws IOException {\n        return br.readLine();\n    }\n\n    static char nextChar() throws IOException {\n        return (char) br.read();\n    }\n\n    private static int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    static ArrayList<Integer>[] graf;\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = nextInt();\n        int k = nextInt();\n        graf = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            graf[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int x = nextInt() - 1;\n            int y = nextInt() - 1;\n            if (nextInt() == 0) {\n                graf[x].add(y);\n                graf[y].add(x);\n            }\n        }\n        tr = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!tr[i]) {\n                b.add(0);\n                id++;\n                dfs(i);\n            }\n        }\n        int mod = (int) 10e8 + 7;\n        long ans = 1;\n        for (int i = 0; i < k; i++) {\n            ans = ans * n % mod;\n        }\n        long p = 0;\n        for (int i = 0; i < b.size(); i++) {\n            long km = 1;\n            for (int j = 0; j < k; j++) {\n                km = km * b.get(i) % mod;\n            }\n            p = (p + km) % mod;\n        }\n        if (p > ans) {\n            ans += mod;\n        }\n        pw.println(ans - p);\n        pw.close();\n    }\n\n    static int id = -1;\n    static ArrayList<Integer> b = new ArrayList<>();\n    static boolean[] tr;\n\n    private static void dfs(int v) {\n        if (tr[v]) {\n            return;\n        }\n        tr[v] = true;\n        b.set(id, b.get(id) + 1);\n        for (int i = 0; i < graf[v].size(); i++) {\n            dfs(graf[v].get(i));\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long hell = 1e9 + 7;\nlong long n, k, ans = 0;\nset<long long> st;\nvector<long long> graph[200001];\nbool visited[200001];\nvoid dfs(long long v) {\n  st.insert(v);\n  visited[v] = true;\n  for (long long i : graph[v]) {\n    if (!visited[i]) dfs(i);\n  }\n}\nlong long binpow(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) (res *= a) %= hell;\n    (a *= a) %= hell;\n    b /= 2;\n  }\n  return res;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  fill(visited, visited + n, false);\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, v, x;\n    cin >> u >> v >> x;\n    u--;\n    v--;\n    if (x == 0) {\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n  }\n  for (long long i = 0; i < n; i++) {\n    if (!visited[i]) {\n      dfs(i);\n      ans += binpow((long long)st.size(), k);\n      st.clear();\n    }\n  }\n  cout << (hell + (binpow(n, k) - ans) % hell) % hell << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 2147483647;\nconst long long INFL = 9223372036854775807LL;\nconst double EPSILON = 0.00000001;\nconst long long MOD = 1000000007;\nvector<long long> adj[100000 + 5];\nbool visited[100000 + 5];\nlong long mod_pow(long long b, long long e, long long mod) {\n  long long r = 1, q = b;\n  while (e) {\n    if (e & 1) r = (r * q) % mod;\n    q = (q * q) % mod;\n    e >>= 1;\n  }\n  return r;\n}\nlong long search(long long start) {\n  long long cnt = 0;\n  queue<long long> q;\n  q.push(start);\n  visited[start] = true;\n  while (not q.empty()) {\n    long long top = q.front();\n    q.pop();\n    cnt++;\n    for (long long x : adj[top]) {\n      if (not visited[x]) {\n        visited[x] = true;\n        q.push(x);\n      }\n    }\n  }\n  return cnt;\n}\nint32_t main() {\n  long long n, k;\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, v, x;\n    scanf(\"%I64d\", &u);\n    ;\n    scanf(\"%I64d\", &v);\n    ;\n    scanf(\"%I64d\", &x);\n    ;\n    u--;\n    v--;\n    if (x == 0) {\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n  }\n  long long tot = mod_pow(n, k, MOD);\n  long long bad = 0;\n  memset(visited, false, sizeof(visited));\n  ;\n  for (long long i = 0; i < n; i++) {\n    if (not visited[i]) {\n      long long cnt = search(i);\n      bad += mod_pow(cnt, k, MOD);\n      bad %= MOD;\n    }\n  }\n  long long good = tot - bad;\n  cout << (((good) % (MOD) + MOD) % MOD) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*; \nimport java.io.* ;\n\npublic class CF_1110 {\n\n    static long power(long x, long y, long p) \n    { \n        // Initialize result \n        long res = 1;      \n         \n        // Update x if it is more   \n        // than or equal to p \n        x = x % p;  \n      \n        while (y > 0) \n        { \n            // If y is odd, multiply x \n            // with result \n            if((y & 1)==1) \n                res = (res * x) % p; \n      \n            // y must be even now \n            // y = y / 2 \n            y = y >> 1;  \n            x = (x * x) % p;  \n        } \n        return res; \n    } \n    static boolean[] vis = new boolean[100007] ;\n    static long dfs(int u , int p){\n        vis[u] = true ;\n        long cnt = 0;\n        for(int v : adj[u]){\n            if(v == p) continue ;\n            cnt = (cnt + dfs(v, u))%MOD ; \n        }\n        return (cnt + 1)%MOD ;\n    }\n    static long MOD = 1000000007 ;\n    static ArrayList<Integer>[] adj = new ArrayList[100007] ;\n     public static void main(String[] args) {\n        FastReader scn = new FastReader() ;\n        int n  = scn.nextInt() , k = scn.nextInt();\n        for(int i = 0 ;i <= n ;i++){\n            adj[i] = new ArrayList<>() ;\n        }\n        for(int i = 0 ; i < n - 1 ;i++){\n            int u = scn.nextInt() , v = scn.nextInt() ;\n            int c = scn.nextInt() ;\n            if(c == 0){\n                adj[u].add(v) ;\n                adj[v].add(u) ;\n            }\n        }\n        long ans = 0 ;\n        for(int i = 1 ; i <= n ;i++){\n            if(!vis[i]){\n                long x = dfs(i, 0) ;\n                ans = (ans + power(x, k, MOD)) % MOD ;\n            }\n        }\n        long a = power(n, k, MOD) ;\n        long f = (a - ans +MOD)%MOD ;\n        System.out.println(f);\n       \n        \n     }\n     \n     \n     \n     \n     static class FastReader \n     { \n         BufferedReader br; \n         StringTokenizer st; \n   \n         public FastReader() \n         { \n             br = new BufferedReader(new\n                      InputStreamReader(System.in)); \n         } \n   \n         String next() \n         { \n             while (st == null || !st.hasMoreElements()) \n             { \n                 try\n                 { \n                     st = new StringTokenizer(br.readLine()); \n                 } \n                 catch (IOException  e) \n                 { \n                     e.printStackTrace(); \n                 } \n             } \n             return st.nextToken(); \n         } \n   \n         int nextInt() \n         { \n             return Integer.parseInt(next()); \n         } \n   \n         long nextLong() \n         { \n             return Long.parseLong(next()); \n         } \n   \n         double nextDouble() \n         { \n             return Double.parseDouble(next()); \n         } \n   \n         String nextLine() \n         { \n             String str = \"\"; \n             try\n             { \n                 str = br.readLine(); \n             } \n             catch (IOException e) \n             { \n                 e.printStackTrace(); \n             } \n             return str; \n         } \n     } \n     \n }"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Sparsh Sanchorawala\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CEdgyTrees solver = new CEdgyTrees();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CEdgyTrees {\n        ArrayList<Integer>[] adj;\n        int[] vis;\n\n        long modExp(long x, long y, long mod) {\n            if (y == 0)\n                return 1;\n            if (y == 1)\n                return x % mod;\n            long ret = modExp(x, y / 2, mod);\n            ret = ret * ret % mod;\n            if (y % 2 == 1)\n                ret = ret * (x % mod) % mod;\n            return ret;\n        }\n\n        int dfs(int x) {\n            vis[x] = 1;\n            int ret = 1;\n            for (int y : adj[x]) {\n                if (vis[y] == 0)\n                    ret += dfs(y);\n            }\n            return ret;\n        }\n\n        public void solve(int testNumber, InputReader s, PrintWriter w) {\n            int n = s.nextInt(), k = s.nextInt();\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++)\n                adj[i] = new ArrayList<>();\n            for (int i = 0; i < n - 1; i++) {\n                int u = s.nextInt() - 1, v = s.nextInt() - 1;\n                if (s.nextInt() == 0) {\n                    adj[u].add(v);\n                    adj[v].add(u);\n                }\n            }\n            long mod = (long) 1e9 + 7;\n            long res = modExp(n, k, mod);\n            vis = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (vis[i] == 0) {\n                    res = (res - modExp(dfs(i), k, mod) + mod) % mod;\n                }\n            }\n            w.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing i64 = long long;\ntemplate <class T>\nT pow(T x, T n, T mod) {\n  T ret = 1;\n  while (n > 0) {\n    if ((n & 1) == 1) ret = (ret * x) % mod;\n    x = (x * x) % mod;\n    n >>= 1;\n  }\n  return ret;\n}\ntemplate <class T>\nT inverse(T x, T p) {\n  return pow(x, p - 2, p);\n}\ntemplate <class T = int>\nclass UF {\n  T *par;\n\n public:\n  UF(T n) : par(new T[n]) {\n    for (T i = 0; i < n; i++) par[i] = i;\n  }\n  ~UF() { delete[] par; }\n  T root(T x) {\n    if (par[x] == x) return x;\n    return par[x] = root(par[x]);\n  }\n  bool same(T x, T y) { return root(x) == root(y); }\n  void unite(T x, T y) {\n    x = root(x);\n    y = root(y);\n    if (x != y) par[x] = y;\n  }\n};\nconstexpr i64 mod = 1000000007;\nstd::vector<std::deque<std::pair<int, int>>> g;\nint main() {\n  i64 n, k;\n  scanf(\"%lld%lld\", &n, &k);\n  g.resize(n);\n  UF<> uft(n);\n  std::vector<int> s(n, 1);\n  for (int i = 1; i < n; i++) {\n    int u, v, x;\n    scanf(\"%d%d%d\", &u, &v, &x);\n    u--;\n    v--;\n    g[u].emplace_back(v, x);\n    g[v].emplace_back(u, x);\n    if (!x) {\n      uft.unite(u, v);\n    }\n  }\n  std::map<int, std::deque<int>> m;\n  for (int i = 0; i < n; i++) {\n    m[uft.root(i)].push_back(i);\n  }\n  i64 ret = 0;\n  for (auto &el : m) {\n    i64 size = el.second.size();\n    ret = (ret + pow(size, k, mod)) % mod;\n  }\n  ret = (pow(n, k, mod) + mod - ret) % mod;\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split())\ng, s, v, m, cs = [[] for _ in range(n + 1)], 0, [0] * (n + 1), 10 ** 9 + 7, []\nfor _ in range(n - 1):\n    a, b, c = map(int, input().split())\n    if not c:\n        g[a].append(b)\n        g[b].append(a)\nfor i in range(1, n + 1):\n    if not v[i]:\n        cs.append(i)\n        v[i] = 1\n        res = 0\n        while cs:\n            p = cs.pop()\n            for j in g[p]:\n                if not v[j]:\n                    cs.append(j)\n                    v[j] = 1\n            res += 1\n        s += pow(res, k, m)\nprint((pow(n, k, m) - s) % m)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool visited[10000007];\nvector<long long> g[10000007];\nlong long ct = 0;\nlong long pow(long long a, long long b, long long m) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % m;\n    b /= 2;\n    a = (a * a) % m;\n  }\n  return ans;\n}\nvoid dfs(long long i) {\n  if (visited[i]) return;\n  ct++;\n  visited[i] = true;\n  for (auto &it : g[i]) dfs(it);\n}\nint32_t main() {\n  long long n, k, u, v, x, ct2;\n  cin >> n >> k;\n  ct2 = pow(n, k, 1000000007);\n  for (long long i = 0; i < n - 1; i++) {\n    cin >> u >> v >> x;\n    if (x == 0) {\n      g[u - 1].push_back(v - 1);\n      g[v - 1].push_back(u - 1);\n    }\n  }\n  long long ct1 = 0;\n  memset(visited, false, sizeof(visited));\n  for (long long i = 0; i < n; i++) {\n    if (visited[i]) continue;\n    ct = 0;\n    dfs(i);\n    ct2 -= pow(ct, k, 1000000007);\n    ;\n    ct2 += 1000000007;\n    ct2 %= 1000000007;\n  }\n  cout << ct2;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n\n    /**\n     * \u5e76\u67e5\u96c6\n     *\n     * @author hemenghai\n     * @date 2019-02-24\n     */\n    private static class Dsu {\n\n        private int[] ancient;\n        private int[] count;\n\n        public Dsu(int size){\n            ancient = new int[size];\n            count = new int[size];\n            for (int i = 0; i < size; i++) {\n                ancient[i] = i;\n                count[i] = 1;\n            }\n        }\n\n        /**\n         * \u5bfb\u627e\u7956\u5148\u8282\u70b9\n         */\n        public int root(int x){\n            while (x != ancient[x]){\n                x = ancient[x];\n            }\n            return x;\n        }\n\n        /**\n         * \u662f\u5426\u4e3a\u6839\u8282\u70b9\n         */\n        public boolean isRoot(int x){\n            return x == ancient[x];\n        }\n        \n        /**\n         * \u83b7\u53d6\u96c6\u5408\u6210\u5458\u4e2a\u6570\n         */\n        public int count(int x){\n            while (x != ancient[x]){\n                x = ancient[x];\n            }\n            return count[x];\n        }\n\n        /**\n         * \u5408\u5e76\u65cf\u7fa4\n         */\n        public void union(int a, int b){\n            int ra = root(a);\n            int rb = root(b);\n\n            if(ra!=rb){\n                ancient[ra] = rb;\n                count[rb] = count[rb] + count[ra];\n            }\n        }\n    }\n\n    private static final long MODULE = 1_000_000_000 + 7;\n\n    private static long cur, pos, sum, len;\n    private static long max, min, ans, res;\n    private static int ai, bi, ci, di;\n    private static int[] aix, bix;\n    private static int[][] aixx, bixx;\n    private static long al, bl, cl, dl;\n    private static long[] alx, blx;\n    private static long[][] alxx, blxx;\n    private static double ad, bd, cd, dd;\n    private static double[] adx, bdx;\n    private static double[][] adxx, bdxx;\n    private static boolean ab, bb, cb, db;\n    private static boolean[] abx, bbx;\n    private static boolean[][] abxx, bbxx;\n    private static char ac, bc, cc, dc;\n    private static char[] acx, bcx;\n    private static char[][] acxx, bcxx;\n    private static String as, bs, cs, ds;\n    private static InputReader in = new InputReader(System.in);\n    private static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        int n = in.nextInt();\n        int k = in.nextInt();\n\n        Dsu dsu = new Dsu(n);\n        \n        int a, b, tag;\n        for (int i = 1; i < n; i++) {\n            a = in.nextInt() - 1;\n            b = in.nextInt() - 1;\n            tag = in.nextInt();\n            if(tag == 0){\n                dsu.union(a, b);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if(dsu.isRoot(i)){\n                sum = (sum + powerMod(dsu.count(i), k, MODULE)) % MODULE;\n            }\n        }\n        ans = (powerMod(n, k, MODULE) + MODULE - sum) % MODULE;\n        out.println(ans);\n        out.close();\n    }\n\n\n    private static long  powerMod(long  x, long  n, long  module) {\n        // \u7279\u5224\n        if(module == 1){\n            return 0;\n        }\n        long sum = 1;\n        x = x % module;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                //\u5224\u65ad\u662f\u5426\u662f\u5947\u6570\uff0c\u662f\u5947\u6570\u7684\u8bdd\u5c06\u591a\u51fa\u6765\u7684\u6570\u4e8b\u5148\u4e58\u5982sum\n                sum = (sum * x) % module;\n            }\n            n >>= 1;\n            // \u4e0d\u65ad\u7684\u4e24\u4e24\u5408\u5e76\u518d\u53d6\u6a21\uff0c\u51cf\u5c0fa\u548cb\u7684\u89c4\u6a21\n            x = (x * x) % module;\n        }\n        return sum;\n    }\n\n    private static class InputReader {\n\n        private InputStream stream;\n\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        private int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint father[100005];\nlong long size[100005];\nconst int mod = 1000000007;\nint find(int x) {\n  if (father[x] == x) return x;\n  return father[x] = find(father[x]);\n}\nint main() {\n  for (int i = 0; i < 100005; i++) {\n    father[i] = i;\n    size[i] = 1;\n  }\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int tmp, tmp1, tmp2;\n    cin >> tmp >> tmp1 >> tmp2;\n    if (tmp2 == 0) {\n      int u = find(tmp);\n      int v = find(tmp1);\n      father[u] = v;\n      size[v] += size[u];\n    }\n  }\n  long long sum = 0;\n  for (int i = 1; i <= n; i++) {\n    if (father[i] == i) {\n      long long tmp = size[i];\n      for (int j = 1; j < k; j++) {\n        size[i] *= tmp;\n        size[i] %= mod;\n      }\n      sum += size[i] % mod;\n    }\n  }\n  long long nk = 1;\n  for (int i = 0; i < k; i++) {\n    nk *= n;\n    nk %= mod;\n  }\n  cout << ((nk - sum) % mod + mod) % mod;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long power(long long x, unsigned long long y, long long p) {\n  long long res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nlong long root(long long x, vector<long long> &arr) {\n  while (arr[x] != x) {\n    arr[x] = arr[arr[x]];\n    x = arr[x];\n  }\n  return x;\n}\nbool find(long long x, long long y, vector<long long> &arr) {\n  if (root(x, arr) == root(y, arr))\n    return true;\n  else\n    return false;\n}\nvoid uni(long long x, long long y, vector<long long> &arr,\n         vector<long long> &si) {\n  long long rx = root(x, arr);\n  long long ry = root(y, arr);\n  if (si[rx] <= si[ry]) {\n    arr[rx] = ry;\n    si[ry] += si[rx];\n  } else {\n    arr[ry] = rx;\n    si[rx] += si[ry];\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t = 1;\n  while (t--) {\n    long long n, k, ans;\n    cin >> n >> k;\n    ans = power(n, k, 1000000007);\n    if (ans < 0) ans += 1000000007;\n    vector<long long> arr(n + 1), si(n + 1), col(n + 1, -1);\n    for (long long i = 0; i <= n; i++) {\n      arr[i] = i;\n      si[i] = 1;\n    }\n    vector<pair<long long, long long> > v(n - 1);\n    for (long long i = 0; i < n - 1; i++) {\n      long long x, y, c;\n      cin >> x >> y >> c;\n      if (c == 0) {\n        if (col[x] != 0) col[x] = c;\n        if (col[y] != 0) col[y] = c;\n        if (!find(x, y, arr)) uni(x, y, arr, si);\n      }\n    }\n    for (long long i = 1; i <= n; i++) {\n      if (arr[i] == i) {\n        long long x = power(si[i], k, 1000000007);\n        if (x < 0) x += 1000000007;\n        ans -= x;\n        if (ans < 0) ans += 1000000007;\n      }\n    }\n    if (ans < 0) ans += 1000000007;\n    cout << ans;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "// Created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class C\n{\n    private static final long MOD=1000000007;\n    private static int vis[];\n    private static HashMap<Integer,Integer>[] edge;\n    private static ArrayDeque<Integer> DQ;\n\n    private static long DFS(int i)\n    {\n        int count=1,v,x;\n        vis[i]=1;\n\n        for(int obj: edge[i].keySet())\n        {\n            v=obj;\n            x=edge[i].get(v);\n\n            if(vis[v]==0)\n            {\n                if(x==1)\n                    DQ.add(v);\n                else\n                    count+=DFS(v);\n            }\n        }\n\n        return count;\n    }\n\n    private static long pow2(long a, long b)\n    {\n        a%=MOD;\n        b%=MOD-1;\n\n        long res=1;\n\n        while(b>0)\n        {\n            if((b&1)==1)\n                res=(res*a)%MOD;\n\n            a=(a*a)%MOD;\n            b>>=1;\n        }\n\n        return res%MOD;\n    }\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N,k,u,v,x;\n        long count=0,tmp,tmp2,total;\n\n        String s[]=br.readLine().trim().split(\" \");\n        N=Integer.parseInt(s[0]);\n        k=Integer.parseInt(s[1]);\n\n        vis=new int[N+1];\n        edge=new HashMap[N+1];\n        DQ=new ArrayDeque<>();\n        for(i=0;i<=N;i++)\n            edge[i]=new HashMap<>();\n\n        total=pow2(N,k);\n\n        for(i=1;i<=N-1;i++)\n        {\n            s=br.readLine().trim().split(\" \");\n            u=Integer.parseInt(s[0]);\n            v=Integer.parseInt(s[1]);\n            x=Integer.parseInt(s[2]);\n\n            edge[u].put(v,x);\n            edge[v].put(u,x);\n        }\n\n        DQ.add(1);\n        while(!DQ.isEmpty())\n        {\n            tmp=DFS(DQ.poll());\n            tmp2=pow2(tmp,k);\n            count=(count+tmp2)%MOD;\n        }\n\n        total-=count;\n        while(total<0)\n            total+=MOD;\n\n        System.out.println(total);\n    }\n\n\n}"
        },
        {
            "language": 3,
            "solution": "from sys import setrecursionlimit\nimport threading\nsetrecursionlimit(10 ** 9)\nthreading.stack_size(67108864)\n \n\ndef dfs(i):\n\tglobal used, g, kol\n\t#print(i, 100)\n\tkol += 1\n\tfor c in g[i]:\n\t\tif not used[c]:\n\t\t\tused[c] = True\n\t\t\tdfs(c) \n\n \nkol = 0\nused = []\ng = []\n\n\ndef main():\n\tglobal kol, used, g\n\t\n\t\n\t\n\t\n\tn, k = map(int, input().split())\n\tg = [[] for i in range(n + 1)]\n\tfor i in range(n - 1):\n\t\tx, y , z = map(int, input().split())\n\t\t\n\t\tif z == 0:\n\t\t\tg[x].append(y)\n\t\t\tg[y].append(x)\n\t\t\t\n\tans = n ** k\n\tused = [False] * (n + 1)\n\n\tfor i in range(1, n + 1):\n\t\tkol = 0\n\t\tif not used[i]:\n\t\t\tkol = 0\n\t\t\tused[i] = True\n\t\t\tdfs(i)\n\t\t\t#print(kol)\n\t\t\tans -= kol ** k\n\tprint(ans % (10 ** 9 + 7))\n\tpass\n\nthread = threading.Thread(target=main)\nthread.start()\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author real\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        ArrayList<ArrayList<Integer>> list;\n        int[] vis;\n        ArrayList<Integer> sets;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            list = in.initlist(n);\n            for (int i = 0; i < n - 1; i++) {\n                int u = in.nextInt();\n                int v = in.nextInt();\n                int wt = in.nextInt();\n                if (wt == 0) {\n                    list.get(u).add(v);\n                    list.get(v).add(u);\n                }\n            }\n            sets = new ArrayList<>();\n            vis = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                if (vis[i] == 1) {\n                    continue;\n                } else {\n                    int ans = dfs(i);\n                    sets.add(ans);\n                }\n            }\n            long mod = in.mod1e97;\n            long pow[] = new long[102 + 1];\n            pow[0] = 1;\n            for (int i = 1; i < 101 + 1; i++) {\n                pow[i] = pow[i - 1] * n;\n                pow[i] %= mod;\n            }\n\n            long set[] = new long[sets.size()];\n            for (int i = 0; i < sets.size(); i++) {\n                set[i] = sets.get(i);\n            }\n            //    System.out.println(sets);\n            long ans = 0;\n            for (int j = 0; j < set.length; j++) {\n                long poss = set[j];\n                for (int i = 0; i < k - 1; i++) {\n                    long now = poss;\n                    now = now * (n - set[j]);\n                    now %= mod;\n                    now *= pow[k - i - 2];\n                    now %= mod;\n                    ans += now;\n                    ans %= mod;\n                    poss = poss * set[j];\n                    poss %= mod;\n                }\n            }\n            out.println(ans);\n        }\n\n        int dfs(int node) {\n            if (vis[node] == 1) {\n                return 0;\n            }\n            vis[node] = 1;\n            int ans = 1;\n            for (int x : list.get(node)) {\n                ans += dfs(x);\n            }\n            return ans;\n        }\n\n    }\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar;\n        private int snumChars;\n        int mod1e97 = (int) 1e9 + 7;\n\n        public InputReader(InputStream st) {\n            this.stream = st;\n        }\n\n        public int read() {\n            //*-*------clare------\n//remeber while comparing 2 non primitive data type not to use ==\n//remember Arrays.sort for primitive data has worst time case complexity of 0(n^2) bcoz it uses quick sort\n//again silly mistakes ,yr kb tk krta rhega ye mistakes\n//try to write simple codes ,break it into simple things\n            // for test cases make sure println(); ;)\n//knowledge>rating\n        /*\n        public class Main\n        implements Runnable{\n    public static void main(String[] args) {\n        new Thread(null,new Main(),\"Main\",1<<26).start();\n\n    }\n    public void run() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();//chenge the name of task\n        solver.solve(1, in, out);\n        out.close();\n    }\n         */\n\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public ArrayList<ArrayList<Integer>> initlist(int n) {\n            ArrayList<ArrayList<Integer>> list = new ArrayList<>();\n            for (int i = 0; i <= n; i++) {\n                list.add(new ArrayList<Integer>());\n            }\n            return list;\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CEdgyTrees solver = new CEdgyTrees();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CEdgyTrees {\n        NumberTheory.Mod107 mod = new NumberTheory.Mod107();\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n\n            UnionFind uf = new UnionFind(n);\n            for (int i = 0; i < n - 1; i++) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                int x = in.nextInt();\n                if (x == 0)\n                    uf.union(u, v);\n            }\n\n            long answer = 0;\n            for (int i = 0; i < n; i++) {\n                if (uf.rep(i) != i)\n                    continue;\n\n                long s = uf.size(i);\n                answer = mod.add(answer, mod.pow(s, k));\n            }\n\n            answer = mod.subtract(mod.pow(n, k), answer);\n\n            out.println(answer);\n        }\n\n    }\n\n    static class InputReader {\n        public final BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class NumberTheory {\n        private static void ASSERT(boolean assertion) {\n            if (!assertion)\n                throw new AssertionError();\n        }\n\n        public abstract static class Modulus<M extends NumberTheory.Modulus<M>> {\n            final ArrayList<Long> factorial = new ArrayList<>();\n            final ArrayList<Long> invFactorial = new ArrayList<>();\n\n            public abstract long modulus();\n\n            public Modulus() {\n                super();\n                factorial.add(1L);\n                invFactorial.add(1L);\n            }\n\n            public long normalize(long x) {\n                x %= modulus();\n                if (x < 0)\n                    x += modulus();\n                return x;\n            }\n\n            public long add(long a, long b) {\n                long v = a + b;\n                return v < modulus() ? v : v - modulus();\n            }\n\n            public long subtract(long a, long b) {\n                long v = a - b;\n                return v < 0 ? v + modulus() : v;\n            }\n\n            public long mult(long a, long b) {\n                return (a * b) % modulus();\n            }\n\n            public long pow(long x, int e) {\n                if (e < 0) {\n                    x = inv(x);\n                    e *= -1;\n                }\n                if (e == 0)\n                    return 1;\n                if ((e & 1) > 0)\n                    return mult(x, pow(x, e - 1));\n                return pow(mult(x, x), e / 2);\n            }\n\n            public long inv(long value) {\n                long g = modulus(), x = 0, y = 1;\n                for (long r = value; r != 0; ) {\n                    long q = g / r;\n                    g %= r;\n\n                    long temp = g;\n                    g = r;\n                    r = temp;\n\n                    x -= q * y;\n\n                    temp = x;\n                    x = y;\n                    y = temp;\n                }\n\n                ASSERT(g == 1);\n                ASSERT(y == modulus() || y == -modulus());\n\n                return normalize(x);\n            }\n\n        }\n\n        public static class Mod107 extends NumberTheory.Modulus<NumberTheory.Mod107> {\n            public long modulus() {\n                return 1_000_000_007L;\n            }\n\n        }\n\n    }\n\n    static class UnionFind {\n        private final int[] __rep;\n        private final int[] __size;\n\n        public UnionFind(int n) {\n            __rep = new int[n];\n            __size = new int[n];\n            for (int i = 0; i < n; i++) {\n                __rep[i] = i;\n                __size[i] = 1;\n            }\n        }\n\n        public int rep(int x) {\n            if (__rep[x] == x) {\n                return x;\n            }\n\n            int r = rep(__rep[x]);\n            __rep[x] = r;\n            return r;\n        }\n\n        public int size(int x) {\n            return __size[rep(x)];\n        }\n\n        public boolean union(int x, int y) {\n            x = rep(x);\n            y = rep(y);\n\n            if (x == y) {\n                return false;\n            }\n\n            if (size(x) < size(y)) {\n                int t = x;\n                x = y;\n                y = t;\n            }\n\n            // now size(x) >= size(y)\n\n            __rep[y] = x;\n            __size[x] += __size[y];\n            return true;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static class Task {\n        PrintWriter out;\n        MyScanner in;\n\n\n        private static long MOD = 1_000_000_000 + 7;\n\n        class Edge {\n            int to;\n            boolean black;\n\n            @Override\n            public String toString() {\n                return \"Edge{\" +\n                        \"to=\" + to +\n                        \", black=\" + black +\n                        '}';\n            }\n\n            public Edge(int to, boolean black) {\n                this.to = to;\n                this.black = black;\n\n\n            }\n        }\n\n        List<Edge>[] tree;\n        boolean vis[];\n        int k;\n\n        public void solve(MyScanner in, PrintWriter out) {\n            int n = in.nextInt();\n             k = in.nextInt();\n\n            tree = new ArrayList[n];\n\n            long total = pow(n);\n\n            vis = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                vis[i] = false;\n                tree[i] = new ArrayList<>();\n            }\n\n            for (int i = 0; i < (n - 1); i++) {\n                int u = in.nextInt();\n                int v = in.nextInt();\n                int bl = in.nextInt();\n                u--;\n                v--;\n\n                tree[u].add(new Edge(v, bl == 1));\n                tree[v].add(new Edge(u, bl == 1));\n            }\n\n            long bad = 0;\n\n            for (int i = 0; i < n; i++) {\n                //System.out.println(\"Tree [ \" + i + \"] = \" + tree[i]);\n                if (!vis[i]) {\n                    int size = count(i);\n                    bad = (bad + pow(size)) % MOD;\n                   // System.out.println(\"Found block of size \" + size + \"  giving \" + pow(size));\n                }\n            }\n\n           // System.out.println(\"Total \" + total + \" bad \" + bad);\n            long good = total - bad;\n            while (good < 0) {\n                good += MOD;\n            }\n\n            out.println(good);\n\n        }\n\n        long pow(int a) {\n            long total = 1;\n            for (int i = 0; i < k; i++) {\n                total = ( total * a) % MOD;\n            }\n            return total;\n        }\n\n        int count(int v) {\n            vis[v] = true;\n\n            int sum = 1;\n\n\n            for (Edge edge: tree[v]) {\n                if (!vis[edge.to] && !edge.black) {\n                    sum += count(edge.to);\n                }\n            }\n\n            return sum;\n\n        }\n\n    }\n\n    public static void main(String[] args) {\n        MyScanner in = new MyScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        Task solver = new Task();\n        solver.solve(in, out);\n        out.close();\n    }\n\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CEdgyTrees solver = new CEdgyTrees();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CEdgyTrees {\n        public static final long MODULO = (long) (1e9 + 7);\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int K = in.nextInt();\n            DJSet djSet = new DJSet(n);\n            for (int i = 0; i < n - 1; ++i) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                int x = in.nextInt();\n                if (x == 0) djSet.union(u, v);\n            }\n            ArrayList<Long> sizes = new ArrayList<>();\n            for (int i = 0; i < n; ++i) {\n                if (djSet.upper[i] < 0) {\n                    sizes.add(djSet.size(i));\n                }\n            }\n            long ans = NT.powerMod(n, K, MODULO);\n            for (Long size : sizes) {\n                ans -= NT.powerMod(size, K, MODULO);\n                while (ans < 0) ans += MODULO;\n            }\n            while (ans < 0) ans += MODULO;\n            out.println(ans % MODULO);\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n\n    static class DJSet {\n        public int[] upper;\n        public int count;\n\n        public DJSet(int n) {\n            upper = new int[n];\n            count = n;\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n                --count;\n                return true;\n            }\n            return false;\n        }\n\n        public long size(int u) {\n            return -upper[root(u)];\n        }\n\n    }\n\n    static class NT {\n        public static long powerMod(long a, long n, long mod) {\n            //    a %= mod;\n            long ret = 1;\n            int x = 63 - Long.numberOfLeadingZeros(n);\n            for (; x >= 0; x--) {\n                ret = ret * ret % mod;\n                if (n << 63 - x < 0) ret = ret * a % mod;\n            }\n            return ret;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package learning;\n\n/**\n *\n * @author hp\n */\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\npublic class Math1 {\n    static long mod=(long)1e9+7;\n    \n    static int n = (int)1e8;\n    static boolean[] prime;\n    public static void main(String[] args)\n    {\n        //Scanner sc = new Scanner(System.in);\n           InputReader sc = new InputReader(System.in);\n         PrintWriter w = new PrintWriter(System.out);\n  \n\n        int x = sc.ni();\n        long k = sc.nl();\n        int c = 0;\n        boolean []v  =new boolean[(int)x+1];\n        a1 = new ArrayList[x+1];\n        for(int i=1;i<=x;i++)\n        {\n            a1[i] = new ArrayList<>();\n            \n        }\n        for(int i=0;i<x-1;i++)\n        {\n            int a  =sc.ni();\n            int b = sc.ni();\n            int c1 = sc.ni();\n            if(c1==0)\n            {\n               // c++;\n                a1[a].add(b);\n                a1[b].add(a);\n            }\n        }\n      vis = new boolean[x+1];\n       \n        int p = 0;\n        long res = modexp((long)x,k,mod);\n         long res1 = 0;\n        for(int i=1;i<=x;i++)\n        {\n            cnt = 0;\n          if(!vis[i])\n          {\n              dfs(i);\n              res1 += modexp((long)cnt,k,mod);\n              res1 %= mod;\n          }\n        }\n       \n        //c = (int)x-p;\n       \n  \n   long res3 = (res - res1 + mod)%mod;\n   //w.println(res1);\n   w.println(res3);\n        \n         \n         w.close();\n           \n       \n    }\n    static boolean []vis;\n    static int cnt;\n    static ArrayList<Integer> []a1;\n    static void dfs(int i)\n    {\n        vis[i] = true;\n        cnt++;\n        for(int e:a1[i])\n        {\n            \n                for(int e1:a1[i])\n                {\n                    if(!vis[e1])\n                    dfs(e1);\n                }\n            \n        }\n        \n    }\n    static void newsieve() {\n\t\t\tArrays.fill(prime\t, true);\n\t\t\tprime[0] = prime[1] = false;\n\t\t\tfor(int i = 2 ; i * i <= n ; ++i) {\n\t\t\t\tif(prime[i]) {\n\t\t\t\t\tfor(int k = i * i; k< n ; k+=i) {\n\t\t\t\t\t\tprime[k] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n    \n    static long phi(long nx)\n    {\n        // Initialize result as n\n        double result = nx; \n        long temp = 0;\n     \n        // Consider all prime factors of n and for \n        // every prime factor p, multiply result\n        // with (1 - 1/p)\n        for (long p = 2; p * p <= nx; ++p)\n        {\n            // Check if p is a prime factor.\n            if (nx % p == 0)\n            {\n                // If yes, then update n and result\n                while (nx % p == 0)\n                    nx /= p;\n                result *= (1.0 - (1.0 / (double) p));\n            }\n        }\n     \n        // If n has a prime factor greater than sqrt(n)\n        // (There can be at-most one such prime factor)\n        if (nx > 1)\n            result *= (1.0 - (1.0 / (double) nx));\n     \n        return (long)result;\n    \n    }\n    \n    static boolean[] seive(int n)\n    {\n        boolean []isp = new boolean[n+1];\n        for(int i=2;i<=n;i++)\n        {\n            isp[i] = true;\n        }\n        for(int i=2;i*i<=n;i++)\n        {\n            if(isp[i])\n            {\n                for(int j=i*i;j<=n;j+=i)\n                {\n                    isp[j] = false;\n                }\n            }\n        }\n        return isp;\n    }\n    static int countDivisors(int n)\n    {\n        int cnt = 0;\n        for (int i = 1; i*i <=n; i++)\n        {\n             if (n % i == 0)\n             {\n                // If divisors are equal,\n                // count only one\n                if (n / i == i)\n                   cnt++;\n      \n                else // Otherwise count both\n                    cnt = cnt + 2;\n             }\n         }\n        return cnt;\n    }\n    \n    static long modexp(long x,long n,long M)\n{\n    long power = n;\n    long result=1;\n    while(power>0)\n    {\n        if(power % 2 ==1)\n            result=(result * x)%M;\n        x=(x*x)%M;\n        power = power/2;\n    }\n    return result;\n}\n    static int nCr(int n, int r, int p)\n{\n    // The array C is going to store last row of\n    // pascal triangle at the end. And last entry\n    // of last row is nCr\n    int []C = new int[r+1];\n    Arrays.fill(C, 0);\n \n    C[0] = 1; // Top row of Pascal Triangle\n \n    // One by constructs remaining rows of Pascal\n    // Triangle from top to bottom\n    for (int i = 1; i <= n; i++)\n    {\n        // Fill entries of current row using previous\n        // row values\n        for (int j = Math.min(i, r); j > 0; j--)\n \n            // nCj = (n-1)Cj + (n-1)C(j-1);\n            C[j] = (C[j] + C[j-1])%p;\n    }\n    return C[r];\n}\n \n// Lucas Theorem based function that returns nCr % p\n// This function works like decimal to binary conversion\n// recursive function.  First we compute last digits of\n// n and r in base p, then recur for remaining digits\n\n    \n    \n    \n    \n    static int gcd(int a, int b)\n    {\n\t if (a == 0)\n\t  return b;\n\t\t\t\t         \n\treturn gcd(b%a, a);\n    }\n    \n    static int lcm(int a, int b)\n    {\n\t return (a*b)/gcd(a, b);\n    }\n    static int digitsum(int x)\n    \n    {    \n\n        int sum = 0;\n        while(x > 0)\n        {\n            int temp = x % 10;\n            sum += temp;\n            x /= 10;\n        }\n        return sum;\n        \n    }\n    static int d = 0;\n    static int x = 0;\n    static int y = 0;\n    \nstatic void extendedEuclid(int A, int B)\n{\n    \n    if(B == 0) {\n        d = A;\n        x = 1;\n        y = 0;\n    }\n    else {\n        extendedEuclid(B, A%B);\n        int temp = x;\n        x = y;\n        y = temp - (A/B)*y;\n    }\n    \n}\n static long modInverse(long A,long M)\n{\n    return modexp(A,M-2,M);\n}\n \n public static boolean returnPrime(BigInteger number) {\n    //check via BigInteger.isProbablePrime(certainty)\n    if (!number.isProbablePrime(5))\n        return false;\n\n    //check if even\n    BigInteger two = new BigInteger(\"2\");\n    if (!two.equals(number) && BigInteger.ZERO.equals(number.mod(two)))\n        return false;\n\n    //find divisor if any from 3 to 'number'\n    for (BigInteger i = new BigInteger(\"3\"); i.multiply(i).compareTo(number) < 1; i = i.add(two)) { //start from 3, 5, etc. the odd number, and look for a divisor if any\n        if (BigInteger.ZERO.equals(number.mod(i))) //check if 'i' is divisor of 'number'\n            return false;\n    }\n    return true;\n}\n public static long lcm_of_array_elements(int[] element_array)\n    {\n        long lcm_of_array_elements = 1;\n        int divisor = 2;\n        while (true)\n        {\n            int counter = 0;\n            boolean divisible = false;\n            for (int i = 0; i < element_array.length; i++)\n            {\n                 \n                 // lcm_of_array_elements (n1,n2,... 0) = 0.\n                 // For negative number we convert into\n                 // positive and calculate lcm_of_array_elements.\n                 \n                if (element_array[i] == 0)\n                {\n                    return 0;\n                }\n                else if (element_array[i] < 0)\n                {\n                    element_array[i] = element_array[i] * (-1);\n                }\n                if (element_array[i] == 1)\n                {\n                    counter++;\n                }\n                 \n                 // divide element_array by devisor if complete division i.e. without\n                 // remainder then replace number with quotient; used for find\n                 // next factor\n                 \n                if (element_array[i] % divisor == 0)\n                {\n                    divisible = true;\n                    element_array[i] = element_array[i] / divisor;\n                }\n            }\n            \n             // If divisor able to completely divide any number from array\n             // multiply with lcm_of_array_elements and store into lcm_of_array_elements \n             // and continue to same divisor\n             // for next factor finding. else increment divisor\n              \n            if (divisible)\n            {\n                lcm_of_array_elements = lcm_of_array_elements * divisor;\n            }\n            else\n            {\n                divisor++;\n            }\n         \n             // Check if all element_array is 1 indicate we found all factors and\n             // terminate while loop.\n  \n            if (counter == element_array.length)\n            {\n                return lcm_of_array_elements;\n            }\n        }\n    }     \n    // Function to find gcd of array of\n    // numbers\n    static int findGCD(int arr[], int n)\n    {\n        int result = arr[0];\n        for (int i=1; i<n; i++)\n            result = gcd(arr[i], result);\n         \n        return result;\n    }\n     static class InputReader {\n \n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n \n\t\tpublic InputReader(InputStream st) {\n\t\t\tthis.stream = st;\n\t\t}\n \n\t\tpublic int read() {\n\t\t\tif (snumChars == -1)\n\t \t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n \n\t\tpublic int ni() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic long nl() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic int[] nia(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = ni();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic String rs() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n \n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n \n\t}\n\t\n\n\t\n\t\n\t\n   \n\t\tstatic PrintWriter w = new PrintWriter(System.out);\n static char [][]sol;\n    \n    \n    \n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author dmytro.prytula prituladima@gmail.com\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CDerevoIRebra solver = new CDerevoIRebra();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CDerevoIRebra {\n        int n;\n        int k;\n        long ans;\n        long MOD = (long) 1e9 + 7;\n        int[][] tree;\n        Map<Integer, Set<Integer>> g;\n        Set<Integer> used = new HashSet<>();\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.nextInt();\n            k = in.nextInt();\n            tree = new int[n - 1][3];\n            g = new HashMap<>();\n            for (int i = 1; i <= n; i++) {\n                g.put(i, new HashSet<>(1));//try 1\n            }\n            for (int i = 0; i < n - 1; i++) {\n                tree[i][0] = in.nextInt();\n                tree[i][1] = in.nextInt();\n                tree[i][2] = in.nextInt();\n                if (tree[i][2] == 0) {\n                    g.get(tree[i][0]).add(tree[i][1]);\n                    g.get(tree[i][1]).add(tree[i][0]);\n                }\n            }\n            List<Integer> amounts = new ArrayList<>();\n            for (int i = 0; i < n - 1; i++) {\n//            if (tree[i][2] == 1) {\n                if (!used.contains(tree[i][0]))\n                    amounts.add(dfs(tree[i][0]));\n                if (!used.contains(tree[i][1]))\n                    amounts.add(dfs(tree[i][1]));\n//            }\n            }\n\n//        System.out.println(amounts);\n\n            ans = 0;\n            ans += IntegerUtils.power(n, k, MOD);\n\n            for (Integer integer : amounts) {\n                ans -= IntegerUtils.power(integer, k, MOD);\n//            ans %= MOD;\n                ans = IntegerUtils.trueMod(ans, MOD);\n            }\n\n            out.printLine(ans);\n        }\n\n        private int dfs(int from) {\n            used.add(from);\n            int am = 1;\n            for (int to : g.get(from))\n                if (!used.contains(to)) {\n                    am += dfs(to);\n                }\n            return am;\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static long trueMod(long a, long b) {\n            a %= b;\n            a += b;\n            a %= b;\n            return a;\n        }\n\n        public static long power(long base, long exponent, long mod) {\n            if (base >= mod) {\n                base %= mod;\n            }\n            if (exponent == 0) {\n                return 1 % mod;\n            }\n            long result = power(base, exponent >> 1, mod);\n            result = result * result % mod;\n            if ((exponent & 1) != 0) {\n                result = result * base % mod;\n            }\n            return result;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        private static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint readInt() {\n  int x;\n  if (scanf(\" %d\", &x) != EOF) return x;\n  return -1;\n}\nlong long int readLint() {\n  long long int x;\n  if (cin >> x) return x;\n  return -1;\n}\nstring readString() {\n  string s;\n  if (cin >> s) return s;\n  return \"\";\n}\nstruct UnionFind {\n  int n;\n  vector<int> parent;\n  vector<int> size;\n  UnionFind(int n) : n(n) {\n    parent = vector<int>(n, -1);\n    for (int i = 0; i < n; ++i) parent[i] = i;\n    size = vector<int>(n, 1);\n  }\n  int findset(int u) {\n    if (parent[u] == u) return u;\n    int x = u;\n    while (x != parent[x]) {\n      x = parent[x];\n    }\n    while (u != x) {\n      int old = parent[u];\n      parent[u] = x;\n      u = old;\n    }\n    return x;\n  }\n  void attach(int u, int v) {\n    parent[u] = v;\n    size[v] += size[u];\n  }\n  void merge(int u, int v) {\n    int U = findset(u);\n    int V = findset(v);\n    if (rand() % 2) {\n      attach(U, V);\n    } else\n      attach(V, U);\n  }\n  int getComponentSize(int u) { return size[findset(u)]; }\n};\nconst long long int mod = 1000000007;\nstruct SingleCase {\n  bool solveCase() {\n    int n = readInt();\n    if (n < 0) return false;\n    int k = readInt();\n    UnionFind zero(n);\n    for (int i = 0; i < (n - 1); ++i) {\n      int u = readInt() - 1;\n      int v = readInt() - 1;\n      int c = readInt();\n      if (c == 0) {\n        zero.merge(u, v);\n      }\n    }\n    vector<long long int> p(k + 1, 0);\n    p[0] = 1;\n    for (int i = 1; i < p.size(); i++) {\n      p[i] = p[i - 1] * n % mod;\n    }\n    long long int ret = 0;\n    for (int i = 0; i < n; ++i) {\n      long long int cur = 0;\n      long long int size = zero.getComponentSize(i);\n      long long int seq = 1;\n      for (long long int seq = 1, r = 2; r <= k; r++) {\n        cur = (cur + seq * (n - size) % mod * p[k - r] % mod) % mod;\n        seq = seq * size % mod;\n      }\n      ret = (ret + cur) % mod;\n    }\n    cout << ret << endl;\n    return true;\n  }\n};\nint main() {\n  while (SingleCase().solveCase()) {\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\n\t\tint N=sc.nextInt();\n\t\tint K=sc.nextInt();\n\n\t\tHashMap<Integer,ArrayList<Integer>>tree=new HashMap<>();\n\t\tint from,to,color;\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tfrom=sc.nextInt();\n\t\t\tto=sc.nextInt();\n\t\t\tcolor=sc.nextInt();\n\t\t\tif(tree.get(from)==null)tree.put(from,new ArrayList<>());\n\t\t\tif(tree.get(to)==null)tree.put(to,new ArrayList<>());\n\t\t\tif(color==0){\n\t\t\t\ttree.get(from).add(to);\n\t\t\t\ttree.get(to).add(from);\n\t\t\t}\n\t\t}\n\n\t\tboolean[] vis=new boolean[N+1];\n\t\tint temp=0,mod=1_000_000_007,ss,pp;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(!vis[i]){\n\t\t\t\tss=size(tree,vis,i);\n\t\t\t\tpp=pow(ss,K,mod);\n\t\t\t\t// System.out.println(\"ss= \"+ss);\n\t\t\t\ttemp=(mod+(temp+pp-ss)%mod)%mod;\n\t\t\t\t// System.out.println(\"pp= \"+pp);\n\t\t\t}\n\t\t}\n\t\t\n// \t\tSystem.out.println(temp);\n\t\ttemp=(mod+(pow(N,K,mod)-temp-N)%mod)%mod;\n\t\tSystem.out.println(temp);\n\t}\n\n\tstatic int size(HashMap<Integer,ArrayList<Integer>>G,boolean[] vis,int v){\n\t\tint ans=1;\n\t\tvis[v]=true;\n\t\tif(G.get(v)!=null){\n\t\t\tfor(int x:G.get(v)){\n\t\t\t\tif(!vis[x])\n\t\t\t\tans+=size(G,vis,x);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic int pow(int base,int exp,int mod){\n\t\tlong ans=base;\n\t\tfor(int i=1;i<exp;i++){\n\t\t\tans=(ans*base)%mod;\n\t\t}\n\t\treturn (int)ans;\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 2e5 + 20, mod = 1e9 + 7;\nlong long n, sz[maxn], ans, k;\nvector<long long> adj[maxn];\nbool mark[maxn];\nlong long dfs(long long v, long long p) {\n  mark[v] = 1;\n  long long ret = 1;\n  for (auto u : adj[v]) {\n    if (u != p) ret += dfs(u, v);\n  }\n  return ret;\n}\nlong long tav(long long a, long long b) {\n  long long ret = 1;\n  for (long long i = 0; i < b; i++) {\n    ret %= mod;\n    ret *= a;\n    ret %= mod;\n  }\n  return ret;\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; i++) {\n    long long v, u, x;\n    cin >> v >> u >> x;\n    if (!x) {\n      adj[v].push_back(u);\n      adj[u].push_back(v);\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    if (!mark[i]) {\n      long long siz = dfs(i, i);\n      ans %= mod;\n      ans += (tav(siz, k) % mod);\n      ans %= mod;\n    }\n  }\n  long long y = tav(n, k);\n  y %= mod;\n  long long yy = y - ans;\n  while (yy < 0) {\n    yy += mod;\n  }\n  cout << yy % mod;\n}\n"
        }
    ]
}