{
    "name": "1554_E. You",
    "source": "CODEFORCES",
    "description": "You are given a tree with n nodes. As a reminder, a tree is a connected undirected graph without cycles.\n\nLet a_1, a_2, \u2026, a_n be a sequence of integers. Perform the following operation exactly n times: \n\n  * Select an unerased node u. Assign a_u := number of unerased nodes adjacent to u. Then, erase the node u along with all edges that have it as an endpoint. \n\n\n\nFor each integer k from 1 to n, find the number, modulo 998 244 353, of different sequences a_1, a_2, \u2026, a_n that satisfy the following conditions:\n\n  * it is possible to obtain a by performing the aforementioned operations exactly n times in some order. \n  * \\operatorname{gcd}(a_1, a_2, \u2026, a_n) = k. Here, \\operatorname{gcd} means the greatest common divisor of the elements in a. \n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5).\n\nEach of the next n - 1 lines contains two integers u and v (1 \u2264 u, v \u2264 n) indicating there is an edge between vertices u and v. It is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\n\nOutput\n\nFor each test case, print n integers in a single line, where for each k from 1 to n, the k-th integer denotes the answer when \\operatorname{gcd} equals to k.\n\nExample\n\nInput\n\n\n2\n3\n2 1\n1 3\n2\n1 2\n\n\nOutput\n\n\n3 1 0\n2 0\n\nNote\n\nIn the first test case, \n\n<image>\n\n  * If we delete the nodes in order 1 \u2192 2 \u2192 3 or 1 \u2192 3 \u2192 2, then the obtained sequence will be a = [2, 0, 0] which has \\operatorname{gcd} equals to 2. \n  * If we delete the nodes in order 2 \u2192 1 \u2192 3, then the obtained sequence will be a = [1, 1, 0] which has \\operatorname{gcd} equals to 1. \n  * If we delete the nodes in order 3 \u2192 1 \u2192 2, then the obtained sequence will be a = [1, 0, 1] which has \\operatorname{gcd} equals to 1. \n  * If we delete the nodes in order 2 \u2192 3 \u2192 1 or 3 \u2192 2 \u2192 1, then the obtained sequence will be a = [0, 1, 1] which has \\operatorname{gcd} equals to 1. \n\n\n\nNote that here we are counting the number of different sequences, not the number of different orders of deleting nodes.",
    "difficulty": "E",
    "tags": [
        "dfs and similar",
        "dp",
        "math",
        "number theory"
    ],
    "rating": 2600,
    "public_test": [
        {
            "input": "2\n3\n2 1\n1 3\n2\n1 2\n",
            "output": "3 1 0 \n2 0 \n"
        }
    ],
    "generated_test": [
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 2\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "3\n3\n2 1\n1 3\n3\n1 2\n1 3\n3\n1 3\n2 3\n",
            "output": "3 1 0\n3 1 0\n3 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n1 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n1 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 4\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 4\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 2\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 2\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 1\n",
            "output": "7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 2\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "2\n3\n2 1\n2 3\n2\n1 2\n",
            "output": "3 1 0\n2 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 4\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 4\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n1 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 4\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 2\n2 3\n1 4\n4\n1 2\n2 3\n2 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 2\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n1 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n1 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 3\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 4\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 2\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 1\n4\n1 2\n3 2\n1 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 2\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 2\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 1\n",
            "output": "7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 4\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 2\n4\n1 4\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 2\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 2\n1 4\n4\n3 2\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 1\n",
            "output": "8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 2\n1 2\n1 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 1\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 2\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 1\n4\n1 3\n3 2\n1 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 2\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n1 4\n4\n1 3\n2 1\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n1 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 2\n4\n1 4\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 2\n",
            "output": "7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 2\n4\n1 2\n3 2\n2 4\n4\n1 4\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 2\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n1 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 4\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 4\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n2 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n2 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n1 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 2\n2 4\n4\n3 1\n1 4\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 4\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 1\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 4\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n1 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n2 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "3\n3\n2 1\n2 3\n3\n1 2\n2 3\n3\n1 3\n2 3\n",
            "output": "3 1 0\n3 1 0\n3 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n2 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 1\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 2\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 2\n2 4\n4\n3 1\n1 4\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n2 4\n3 4\n4\n1 2\n3 4\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n2 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 1\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "3\n3\n2 1\n2 3\n3\n1 2\n2 3\n3\n1 3\n2 1\n",
            "output": "3 1 0\n3 1 0\n3 1 0\n"
        },
        {
            "input": "3\n3\n2 1\n2 3\n3\n1 3\n2 3\n3\n1 3\n2 3\n",
            "output": "3 1 0\n3 1 0\n3 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 1\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n2 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 2\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 2\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n1 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 2\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 2\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n1 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n2 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 4\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 4\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 4\n1 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n4 1\n1 2\n3 4\n4\n2 1\n1 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n1 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 2\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 2\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 1\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 4\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 2\n4\n1 4\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 3\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "3\n3\n2 1\n1 3\n3\n1 3\n2 3\n3\n1 3\n2 3\n",
            "output": "3 1 0\n3 1 0\n3 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 2\n4\n1 2\n3 2\n2 4\n4\n1 4\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 2\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 2\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 3\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n2 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 4\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 1\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n2 4\n3 4\n4\n1 2\n3 2\n3 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 4\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 2\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n2 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n1 4\n4\n1 2\n2 4\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 1\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 4\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 2\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 3\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n2 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n4 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 1\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 2\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n1 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "3\n3\n2 1\n2 3\n3\n1 2\n1 3\n3\n1 3\n2 1\n",
            "output": "3 1 0\n3 1 0\n3 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n2 3\n3 4\n4\n2 1\n2 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n1 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 4\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 3\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n1 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n3 4\n3 2\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 3\n2 3\n2 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 4\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n2 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n2 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n1 4\n4\n1 2\n2 4\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n2 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n1 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n1 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n2 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 2\n1 2\n2 4\n4\n2 1\n1 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n1 4\n4\n1 3\n2 1\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n1 4\n4\n1 3\n2 1\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n1 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 4\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 4\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n2 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n2 4\n4\n3 1\n1 2\n3 4\n4\n2 1\n1 4\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 3\n2 3\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n2 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 3\n3 2\n2 4\n4\n1 3\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 2\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n2 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 3\n2 3\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 3\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 2\n2 4\n4\n1 2\n2 4\n3 4\n4\n1 2\n1 4\n3 4\n4\n1 3\n2 1\n3 4\n4\n1 3\n2 4\n3 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        },
        {
            "input": "10\n4\n2 1\n3 1\n1 4\n4\n3 1\n1 2\n2 4\n4\n2 1\n1 3\n3 4\n4\n2 1\n1 4\n3 4\n4\n1 2\n3 1\n2 4\n4\n1 3\n2 1\n3 4\n4\n1 2\n2 4\n3 4\n4\n1 3\n2 3\n1 4\n4\n1 3\n2 3\n1 4\n4\n1 4\n2 4\n3 4\n",
            "output": "7 0 1 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n8 0 0 0\n7 0 1 0\n"
        }
    ],
    "solution": [
        {
            "language": 3,
            "solution": "import sys\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nMOD = 998244353\n\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    g = [[] for i in range(n)]\n    for i in range(n - 1):\n        x, y = map(int, input().split())\n        g[x - 1] += [y - 1]\n        g[y - 1] += [x - 1]\n    f = [0] * n\n    parent = [0] * n\n    f[1] = pow(2, n - 1, MOD)\n    order = [0]\n    for v in order:\n        for u in g[v]:\n            if u != parent[v]:\n                parent[u] = v\n                order += [u]\n\n\n    def dfs(k):\n        size = [0] * n\n        for v in reversed(order):\n            if size[v] % k == 0:\n                if v != 0:\n                    size[parent[v]] += 1\n            elif v == 0 or (size[v] + 1) % k != 0:\n                return False\n        return True\n\n\n    for i in range(2, n):\n        if (n - 1) % i == 0:\n            f[i] = int(dfs(i))\n    h = [0] * (n + 1)\n    for i in range(n - 1, 0, -1):\n        h[i] = f[i]\n        for j in range(i * 2, n, i):\n            h[i] -= h[j]\n    print(*(x for x in h[1:n + 1]))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid dbg() { std::cout << \"  #\\n\"; }\ntemplate <typename T, typename... Args>\nvoid dbg(T a, Args... args) {\n  std::cout << a << ' ';\n  dbg(args...);\n}\nconst long long maxn = 2e5 + 10;\nconst long long MAX = 1000;\nconst long long inf = 0x3f3f3f3f;\nconst long long mod = 998244353;\nlong long n, m;\nlong long a[maxn];\nlong long f[maxn];\nlong long ans[maxn];\nvector<long long> A[maxn];\nlong long getint() {\n  char ch;\n  while (!isdigit(ch = getchar()))\n    ;\n  long long x = ch - 48;\n  while (isdigit(ch = getchar())) x = x * 10 + ch - 48;\n  return x;\n}\nbool isok;\nvoid dfs(long long now, long long fa, long long k) {\n  for (auto to : A[now])\n    if (to != fa) {\n      dfs(to, now, k);\n    }\n  if (a[now] % k == 0) {\n    a[fa]++;\n  } else {\n    if (fa != 0) {\n      a[now]++;\n      if (a[now] % k != 0) {\n        isok = false;\n      }\n    }\n  }\n}\nvoid solve() {\n  n = getint();\n  for (long long i = (1); i <= (n); ++i) ans[i] = 0, A[i].clear();\n  for (long long i = (1); i <= (n - 1); ++i) {\n    long long x, y;\n    x = getint();\n    y = getint();\n    A[x].push_back(y);\n    A[y].push_back(x);\n  }\n  ans[1] = 1;\n  for (long long i = (1); i <= (n - 1); ++i) ans[1] = (ans[1] * 2ll % mod);\n  for (long long i = (2); i <= (n); ++i)\n    if ((n - 1) % i == 0) {\n      for (long long j = (1); j <= (n); ++j) a[j] = 0;\n      isok = 1;\n      dfs(1, 0, i);\n      if (isok) ans[i]++;\n    }\n  for (long long i = (n); i >= (1); --i) {\n    long long j = i + i;\n    while (j <= n) {\n      ans[i] -= ans[j];\n      ans[i] = (ans[i] + mod) % mod;\n      j = j + i;\n    }\n  }\n  for (long long i = (1); i <= (n); ++i) printf(\"%d \", ans[i] % mod);\n  printf(\"\\n\");\n}\nsigned main() {\n  long long TestCase = 1;\n  cin >> TestCase;\n  while (TestCase--) {\n    solve();\n  }\n  char EndFile = getchar();\n  EndFile = getchar();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> ch[100005];\nlong long num[100005], B = 998244353;\nlong long dfs(long long now, long long from, long long mod) {\n  long long a, b, c;\n  c = 0;\n  for (auto a : ch[now]) {\n    if (a == now || a == from) continue;\n    b = dfs(a, now, mod);\n    if (b == -1) return -1;\n    c += b;\n  }\n  if ((ch[now].size() - c) % mod == 0) return 1;\n  if (ch[now].size() - c > 0 && (ch[now].size() - c - 1) % mod == 0 &&\n      from != 0)\n    return 0;\n  return -1;\n}\nvoid solve() {\n  long long i, j, k, a, b, c, n;\n  scanf(\"%lld\", &n);\n  for (i = 1; i <= n; i++) num[i] = 0;\n  for (i = 1; i <= n; i++) {\n    ch[i].clear();\n  }\n  for (i = 1; i < n; i++) {\n    scanf(\"%lld%lld\", &a, &b);\n    ch[a].push_back(b);\n    ch[b].push_back(a);\n  }\n  for (i = 2; i <= n; i++) {\n    if ((2 * n - 2) % i) continue;\n    if (dfs(1, 0, i) >= 0) num[i] = 1;\n  }\n  num[1] = 1;\n  for (i = 1; i < n; i++) num[1] = (num[1] * 2) % B;\n  c = 0;\n  for (i = n; i > 1; i--) {\n    for (j = i * 2; j <= n; j += i) {\n      if (num[j] == 1) num[i] = 0;\n    }\n    c += num[i];\n  }\n  num[1] -= c;\n  while (num[1] < 0) num[1] += B;\n  for (i = 1; i <= n; i++) printf(\"%lld \", num[i]);\n  printf(\"\\n\");\n}\nint main() {\n  int T = 1;\n  scanf(\"%d\", &T);\n  while (T--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010, MOD = 998244353;\nint Q, n, tot, head[N], f[N];\nvector<int> d[N];\nstruct edge {\n  int next, to;\n} e[N * 2];\nvoid add(int from, int to) {\n  e[++tot] = (edge){head[from], to};\n  head[from] = tot;\n}\nint dfs(int x, int fa, int k) {\n  int cnt = 0;\n  for (int i = head[x]; ~i; i = e[i].next) {\n    int v = e[i].to;\n    if (v != fa) {\n      int val = dfs(v, x, k);\n      if (val == -1) return -1;\n      cnt += val;\n    }\n  }\n  if (cnt % k == 0) return 1;\n  if (cnt % k == k - 1) return 0;\n  return -1;\n}\nint main() {\n  for (int i = 2; i < N; i++)\n    for (int j = i; j < N; j += i) d[j].push_back(i);\n  scanf(\"%d\", &Q);\n  while (Q--) {\n    memset(head, -1, sizeof(head));\n    memset(f, 0, sizeof(f));\n    tot = 0;\n    f[1] = 1;\n    scanf(\"%d\", &n);\n    for (int i = 1, x, y; i < n; i++) {\n      scanf(\"%d%d\", &x, &y);\n      add(x, y);\n      add(y, x);\n      f[1] = f[1] * 2 % MOD;\n    }\n    for (int i = 0; i < d[n - 1].size(); i++)\n      if (dfs(1, 0, d[n - 1][i]) == 1) f[d[n - 1][i]] = 1;\n    for (int i = n; i >= 1; i--)\n      for (int j = i * 2; j <= n; j += i) f[i] -= f[j];\n    for (int i = 1; i <= n; i++) cout << f[i] << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 50;\nconst long long mod = 998244353;\nvector<long long> g[N];\nlong long F[N];\nlong long H[N];\nlong long binpow(long long a, long long b) {\n  long long ret = 1;\n  while (b) {\n    if (b & 1) {\n      ret = (ret * a) % mod;\n    }\n    a = (a * a) % mod;\n    b >>= 1;\n  }\n  return ret;\n}\nvoid reset(long long n) {\n  for (long long i = 1; i <= n; i++) {\n    g[i].clear();\n    F[i] = 0;\n  }\n}\nlong long getF(long long node, long long k, long long par = -1) {\n  long long val = 0;\n  for (auto to : g[node]) {\n    if (to == par) continue;\n    long long res = getF(to, k, node);\n    if (res == -1) {\n      return -1;\n    }\n    if (res == 0) val++;\n  }\n  if (val % k == 0) {\n    return 0;\n  } else if (val % k == k - 1) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    for (long long i = 0; i < n - 1; i++) {\n      long long u, v;\n      cin >> u >> v;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n    F[1] = binpow(2, n - 1);\n    for (long long i = 2; i <= n; i++) {\n      if ((n - 1) % i == 0) {\n        if (getF(1, i) != -1) F[i] = 1;\n      }\n    }\n    for (long long i = n; i >= 1; i--) {\n      H[i] = F[i];\n      for (long long j = i * 2; j <= n; j += i) {\n        H[i] -= H[j];\n      }\n    }\n    for (long long i = 1; i <= n; i++) cout << H[i] << ' ';\n    cout << '\\n';\n    reset(n);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nconst long long MAX = 1e5 + 5;\nlong long ans[MAX];\nvector<long long> P[MAX];\nlong long pom[MAX];\nbool czy = true;\nlong long akt;\nvoid dfs(long long u, long long fa) {\n  for (auto it : P[u]) {\n    if (it == fa) continue;\n    dfs(it, u);\n  }\n  if (pom[u] % akt == 0) {\n    if (fa != -1) pom[fa]++;\n  } else {\n    pom[u]++;\n    if (pom[u] % akt != 0) czy = false;\n  }\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  for (long long i = 1; i <= n; i++) P[i].clear();\n  for (long long i = 1; i <= n - 1; i++) {\n    long long a, b;\n    cin >> a >> b;\n    P[a].push_back(b);\n    P[b].push_back(a);\n  }\n  ans[1] = 1;\n  for (long long i = 1; i <= n - 1; i++) ans[1] = (ans[1] * 2) % mod;\n  for (long long i = 2; i <= n; i++) {\n    if ((n - 1) % i == 0) {\n      czy = true;\n      akt = i;\n      for (long long j = 1; j <= n; j++) pom[j] = 0;\n      dfs(1, -1);\n      ans[i] = czy;\n    } else\n      ans[i] = 0;\n  }\n  for (long long i = n; i >= 1; i--) {\n    for (long long j = 2 * i; j <= n; j += i)\n      ans[i] = (ans[i] - ans[j] + mod) % mod;\n  }\n  for (long long i = 1; i <= n; i++) cout << ans[i] << \" \";\n  cout << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  cin >> t;\n  for (long long z = 0; z < t; z++) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline bool isdigit(char& ch) { return ch >= '0' && ch <= '9'; }\ntemplate <class T>\nvoid read(T& x) {\n  x = 0;\n  long long f = 1;\n  char ch = getchar();\n  for (; !isdigit(ch); ch = getchar())\n    if (ch == '-') f = -1;\n  for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + ch - '0';\n  x *= f;\n}\ntemplate <class T>\ninline void write(T x) {\n  if (x == 0) {\n    putchar('0');\n    return;\n  }\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  int _stk[65], _top = 0;\n  for (; x; x /= 10) _stk[++_top] = x % 10 + 48;\n  for (; _top; _top--) putchar(_stk[_top]);\n}\nconst int MAXN = 1e5 + 10;\nconst int mod = 998244353;\nint f[MAXN], ans[MAXN], n, flag;\nvector<int> g[MAXN];\nvoid dfs(int u, int fa, int d) {\n  if (!flag) return;\n  for (auto v : g[u]) {\n    if (v == fa) continue;\n    dfs(v, u, d);\n  }\n  if (f[u] % d == 0)\n    f[fa]++;\n  else {\n    if (fa) f[u]++;\n    if (f[u] % d != 0) flag = 0;\n  }\n  if (!flag) return;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int T;\n  cin >> T;\n  while (T--) {\n    cin >> n;\n    for (int i = (int)(1); i < (int)(n); i++) {\n      int u, v;\n      cin >> u >> v;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n    ans[1] = 1;\n    for (int i = (int)(1); i < (int)(n); i++)\n      ans[1] = (1ll * ans[1] + ans[1]) % mod;\n    for (int d = (int)(2); d < (int)(n + 1); d++) {\n      if ((n - 1) % d == 0) {\n        flag = 1;\n        dfs(1, 0, d);\n        ans[d] = flag;\n        for (int i = (int)(1); i < (int)(n + 1); i++) f[i] = 0;\n      }\n    }\n    for (int i = n; i >= 1; --i) {\n      for (int j = i + i; j <= n; j += i) ans[i] = (ans[i] - ans[j]) % mod;\n    }\n    for (int i = (int)(1); i < (int)(n + 1); i++) {\n      ans[i] = (ans[i] % mod + mod) % mod;\n      cout << ans[i] << ' ';\n    }\n    cout << '\\n';\n    for (int i = (int)(1); i < (int)(n + 1); i++) g[i].clear(), ans[i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid read(T &x) {\n  T f = 1;\n  x = 0;\n  char s = getchar();\n  while (s < '0' || s > '9') {\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while (s >= '0' && s <= '9') {\n    x = (x << 3) + (x << 1) + (s ^ '0');\n    s = getchar();\n  }\n  x *= f;\n}\ntemplate <typename T>\nvoid write(T x, char s = '\\n') {\n  if (!x) {\n    putchar('0');\n    putchar(s);\n    return;\n  }\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  T t = 0, tmp[25] = {};\n  while (x) tmp[t++] = x % 10, x /= 10;\n  while (t-- > 0) putchar(tmp[t] + '0');\n  putchar(s);\n}\nconst int MAXN = 1e5 + 5;\nconst int mod = 998244353;\nlong long ans[MAXN], dp[MAXN][2], deg[MAXN];\nint head[MAXN], to[MAXN << 1], nxt[MAXN << 1], cnt, n;\nvoid add(int u, int v) {\n  nxt[++cnt] = head[u];\n  head[u] = cnt;\n  to[cnt] = v;\n}\nlong long tmp[MAXN];\nvoid dfs(int x, int fa, long long k) {\n  dp[x][0] = dp[x][1] = 0;\n  for (int i = head[x]; i; i = nxt[i]) {\n    int v = to[i];\n    if (v == fa) continue;\n    dfs(v, x, k);\n  }\n  if (k > 1) {\n    if (deg[x] < k) {\n      dp[x][1] = 0;\n      dp[x][0] = 1;\n      for (int i = head[x]; i; i = nxt[i]) {\n        int v = to[i];\n        if (v == fa) continue;\n        dp[x][0] *= dp[v][1];\n      }\n    } else {\n      long long zer = 0, one = 0, nei = 0;\n      for (int i = head[x]; i; i = nxt[i]) {\n        int v = to[i];\n        if (v == fa) continue;\n        if (dp[v][1])\n          one++;\n        else if (dp[v][0])\n          zer++;\n        else\n          nei++;\n      }\n      if (nei)\n        dp[x][0] = dp[x][1] = 0;\n      else {\n        if (zer % k == 0) dp[x][0] = 1;\n        if ((zer + 1) % k == 0) dp[x][1] = 1;\n      }\n    }\n  } else {\n    for (int i = 0; i < k; ++i) tmp[i] = 0;\n    tmp[0] = 1;\n    for (int i = head[x]; i; i = nxt[i]) {\n      int v = to[i];\n      if (v == fa) continue;\n      long long las = tmp[k - 1];\n      for (int j = k - 1; j > 0; --j)\n        tmp[j] = (tmp[j] * dp[v][1] + tmp[j - 1] * dp[v][0]) % mod;\n      tmp[0] = (tmp[0] * dp[v][1] + las * dp[v][0]) % mod;\n    }\n    dp[x][0] = tmp[0], dp[x][1] = tmp[k - 1];\n  }\n}\nlong long calc(long long x) {\n  dfs(1, 0, x);\n  return dp[1][0];\n}\nint main() {\n  int T;\n  read(T);\n  while (T-- > 0) {\n    read(n);\n    for (int i = 1; i < n; ++i) {\n      int u, v;\n      read(u), read(v);\n      add(u, v), add(v, u);\n      deg[u]++, deg[v]++;\n    }\n    for (int i = 1; i * i <= n - 1; ++i) {\n      if ((n - 1) % i) continue;\n      ans[i] = calc(i);\n      if ((n - 1) / i != i) ans[(n - 1) / i] = calc((n - 1) / i);\n    }\n    for (int i = (n - 1); i >= 1; --i)\n      if (ans[i]) {\n        for (int j = i * 2; j <= (n - 1); j += i)\n          ans[i] = (ans[i] - ans[j] + mod) % mod;\n      }\n    for (int i = 1; i <= n; ++i)\n      write(ans[i], ' '), ans[i] = 0, deg[i] = 0, head[i] = 0;\n    cnt = 0;\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long PosMod(long long a) { return a >= 0 ? a : a + 998244353; }\nlong long AddMod(long long a, long long b) {\n  return PosMod((a + b) % 998244353);\n}\nlong long MultMod(long long a, long long b) {\n  return PosMod((a * b) % 998244353);\n}\nlong long powll(long long a, long long n) {\n  long long r = 1;\n  for (long long b = n; b > 0; b >>= 1, a = MultMod(a, a))\n    if (b & 1) r = MultMod(r, a);\n  return r;\n}\nvector<vector<int>> adj;\nbool fail;\nint dfs(int here, int p, int targetK) {\n  if (fail) return 0;\n  int incoming = 0;\n  for (int there : adj[here]) {\n    if (there == p) continue;\n    incoming += dfs(there, here, targetK);\n  }\n  if (incoming % targetK == 0)\n    return 1;\n  else if ((incoming + 1) % targetK == 0 && here != 1)\n    return 0;\n  else {\n    fail = true;\n    return 0;\n  }\n}\nint n;\nvoid solve() {\n  cin >> n;\n  adj = vector<vector<int>>(n + 1);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    adj[v].push_back(u);\n    adj[u].push_back(v);\n  }\n  vector<long long> f = vector<long long>(n + 1);\n  f[1] = powll(2, (long long)n - 1);\n  for (int k = 2; k <= n - 1; k++) {\n    if ((n - 1) % k != 0) continue;\n    fail = false;\n    dfs(1, 0, k);\n    f[k] = fail ? 0 : 1;\n  }\n  vector<long long> h = vector<long long>(n + 1);\n  h[1] = f[1];\n  for (int i = 2; i <= n; i++) {\n    long long val = f[i];\n    if (val > 0) {\n      for (int k = 2; i * k <= n; k++) {\n        if (f[i * k]) val = 0;\n      }\n    }\n    h[i] = val;\n    h[1] -= val;\n  }\n  for (int i = 1; i <= n; i++) {\n    printf(\"%lld \", h[i]);\n  }\n  cout << '\\n';\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353, N = 1e5 + 5;\nvector<int> G[N];\nint n, k, f[N], pwer[N];\nbool ok;\nbool dfs(int u, int fa) {\n  bool leaf = true;\n  int d = 0;\n  for (int v : G[u])\n    if (v != fa) {\n      d += dfs(v, u);\n      leaf = false;\n    }\n  if (leaf) return true;\n  if (d % k == 0) return true;\n  if (!fa) return ok = false;\n  if ((d + 1) % k == 0) return false;\n  ok = false;\n}\nint main() {\n  int test;\n  scanf(\"%d\", &test);\n  pwer[0] = 1;\n  for (int i = 1; i < N; i++) pwer[i] = (pwer[i - 1] << 1) % MOD;\n  while (test--) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) G[i].clear();\n    for (int i = 1; i < n; i++) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n    fill(f + 1, f + n + 1, 0);\n    f[1] = pwer[n - 1];\n    for (int i = 2; i < n; i++)\n      if ((n - 1) % i == 0) {\n        ok = true;\n        k = i;\n        dfs(1, 0);\n        f[i] = ok;\n      }\n    for (int i = n; i; i--)\n      for (int j = i + i; j <= n; j += i) f[i] -= f[j];\n    for (int i = 1; i <= n; i++) printf(\"%d \", f[i]);\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nconst int P = 998244353;\nint T, n;\nint ans[N];\nvector<int> e[N];\nint f[N];\nbool dfs(int x, int fa, int y) {\n  for (auto v : e[x])\n    if (v != fa && !dfs(v, x, y)) return 0;\n  if (f[x] % y == 0) {\n    f[fa]--;\n    return 1;\n  }\n  f[x]--;\n  if (f[x] % y == 0) return 1;\n  return 0;\n}\nvector<int> pri;\nbool is[N];\nint mu[N];\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  cin >> T;\n  for (int i = 2; i < N; i++) {\n    if (!is[i]) pri.push_back(i), mu[i] = -1;\n    for (int j = 0; j < ((int)pri.size()) && i * pri[j] < N; j++) {\n      is[i * pri[j]] = 1;\n      mu[i * pri[j]] = i % pri[j] ? -mu[i] : 0;\n      if (i % pri[j] == 0) break;\n    }\n  }\n  while (T--) {\n    cin >> n;\n    for (int i = 1; i <= n; i++) e[i].clear();\n    for (int i = 1; i < n; i++) {\n      int u, v;\n      cin >> u >> v;\n      e[u].push_back(v);\n      e[v].push_back(u);\n    }\n    if (n == 2) {\n      cout << 2 << \" \" << 0 << \"\\n\";\n    } else {\n      int rt = 0;\n      for (int i = 1; i <= n; i++)\n        if (((int)e[i].size()) > 1) rt = i;\n      for (int i = 1; i <= n; i++) ans[i] = 0;\n      for (int i = 1; i * i <= (n - 1); i++) {\n        if ((n - 1) % i) continue;\n        for (int j = 1; j <= n; j++) f[j] = ((int)e[j].size());\n        if (dfs(rt, 0, i)) ans[i] = 1;\n        for (int j = 1; j <= n; j++) f[j] = ((int)e[j].size());\n        if (dfs(rt, 0, (n - 1) / i)) ans[(n - 1) / i] = 1;\n      }\n      for (int i = 2; i <= n; i++) {\n        for (int j = i + i; j <= n; j += i)\n          ans[i] = (ans[i] + mu[j / i] * ans[j]);\n        ans[i] = (ans[i] + P) % P;\n      }\n      for (int i = 1; i < n; i++) ans[1] = 2 * ans[1] % P;\n      for (int i = 2; i <= n; i++) ans[1] = (ans[1] - ans[i] + P) % P;\n      for (int i = 1; i <= n; i++) cout << ans[i] << \" \\n\"[i == n];\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef const int& ci;\nvector<int> sn[100000 + 1];\nint deg[100000 + 1], que[100000 + 1], par[100000 + 1], ans[100000],\n    cnt[100000 + 1];\nint check(ci n, ci k) {\n  memset(cnt + 1, 0, n << 2);\n  for (int i = 1; i < n; ++i) {\n    int u = que[i];\n    if (cnt[u] % k) {\n      if ((++cnt[u]) % k) return 0;\n    } else\n      ++cnt[par[u]];\n  }\n  return 1;\n}\n__inline__ __attribute__((always_inline)) void test() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) sn[i].clear();\n  memset(deg + 1, 0, n << 2);\n  for (int i = n, u, v; --i;) {\n    scanf(\"%d%d\", &u, &v);\n    sn[u].push_back(v), sn[v].push_back(u), ++deg[u], ++deg[v];\n  }\n  int tail = 0;\n  for (int i = 1; i <= n; ++i)\n    if (deg[i] == 1) que[++tail] = i;\n  for (int head = 1; head < n; ++head) {\n    int u = que[head];\n    for (auto v : sn[u])\n      if (deg[v] > 1) {\n        par[u] = v;\n        if (--deg[v] == 1) que[++tail] = v;\n      }\n  }\n  int m = n - 1;\n  ans[1] = 1;\n  for (int i = m; i; --i, ans[1] = (ans[1] << 1) % 998244353)\n    ;\n  for (int i = m; i > 1; --i)\n    if (!(m % i)) {\n      ans[i] = check(n, i);\n      for (int j = i << 1; j <= m; j += i) ans[i] -= ans[j];\n      ans[1] -= ans[i];\n    } else\n      ans[i] = 0;\n  for (int i = 1; i < n; ++i) printf(\"%d \", ans[i]);\n  puts(\"0\");\n}\nint main() {\n  int t;\n  for (scanf(\"%d\", &t); t; test(), --t)\n    ;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  char c = getchar();\n  int s = 0;\n  int x = 1;\n  while (c < '0' || c > '9') {\n    if (c == '-') x = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    s = s * 10 + c - '0';\n    c = getchar();\n  }\n  return s * x;\n}\nconst int mod = 998244353;\nconst int N = 1e5 + 5;\nint T, n, x, y, f[N], ans[N];\nvector<int> v[N];\nint ksm(int x, int k) {\n  int base = 1;\n  while (k) {\n    if (k & 1) base = 1ll * base * x % mod;\n    k >>= 1;\n    x = 1ll * x * x % mod;\n  }\n  return base;\n}\nint gcd(int x, int y) {\n  if (!x) return y;\n  return gcd(y % x, x);\n}\nvoid dfs(int u, int fa, int p) {\n  int siz = 0;\n  for (int i = 0; i < v[u].size(); i++) {\n    if (v[u][i] == fa) continue;\n    dfs(v[u][i], u, p);\n    siz++;\n  }\n  if (!siz) {\n    f[fa]++;\n  } else {\n    if (fa) {\n      if (f[u] % p == 0)\n        f[fa]++;\n      else\n        f[u]++;\n    }\n  }\n}\nint main() {\n  T = read();\n  while (T--) {\n    n = read();\n    for (int i = 1; i < n; i++) {\n      x = read();\n      y = read();\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n    int tmp = ksm(2, n - 1);\n    int pre = 0;\n    for (int i = 2; i < n; i++) {\n      if ((n - 1) % i == 0) {\n        memset(f, 0, (n + 1) * 4);\n        dfs(1, 0, i);\n        int mi = 0;\n        bool flag = 0;\n        for (int k = 1; k <= n; k++) {\n          mi = gcd(f[k], mi);\n          if (f[k] % i) flag = 1;\n        }\n        if (!flag && mi == i) ans[i] = 1, pre++;\n      }\n    }\n    cout << (tmp - pre + mod) % mod << \" \";\n    for (int i = 2; i <= n; i++) {\n      cout << ans[i] << \" \";\n    }\n    memset(ans, 0, (n + 1) * 4);\n    for (int i = 1; i <= n; i++) v[i].clear();\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n  long long to, cost;\n  edge() {}\n  edge(long long a, long long b) { to = a, cost = b; }\n};\nconst long long dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nconst long long mod = 998244353;\nstruct mint {\n  long long x = 0;\n  mint(long long y = 0) {\n    x = y;\n    if (x < 0 || x >= mod) x = (x % mod + mod) % mod;\n  }\n  mint(const mint& ope) { x = ope.x; }\n  mint operator-() { return mint(-x); }\n  mint operator+(const mint& ope) { return mint(x) += ope; }\n  mint operator-(const mint& ope) { return mint(x) -= ope; }\n  mint operator*(const mint& ope) { return mint(x) *= ope; }\n  mint operator/(const mint& ope) { return mint(x) /= ope; }\n  mint& operator+=(const mint& ope) {\n    x += ope.x;\n    if (x >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint& ope) {\n    x += mod - ope.x;\n    if (x >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint& ope) {\n    x *= ope.x, x %= mod;\n    return *this;\n  }\n  mint& operator/=(const mint& ope) {\n    long long n = mod - 2;\n    mint mul = ope;\n    while (n) {\n      if (n & 1) *this *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return *this;\n  }\n  mint inverse() { return mint(1) / *this; }\n  bool operator==(const mint& ope) { return x == ope.x; }\n  bool operator!=(const mint& ope) { return x != ope.x; }\n  bool operator<(const mint& ope) { return x < ope.x; }\n};\nmint modpow(mint a, long long n) {\n  if (n == 0) return mint(1);\n  if (n % 2)\n    return a * modpow(a, n - 1);\n  else\n    return modpow(a * a, n / 2);\n}\nistream& operator>>(istream& is, mint& ope) {\n  long long t;\n  is >> t, ope.x = t;\n  return is;\n}\nostream& operator<<(ostream& os, mint& ope) { return os << ope.x; }\nostream& operator<<(ostream& os, const mint& ope) { return os << ope.x; }\nvector<mint> fact, fact_inv;\nvoid make_fact(int n) {\n  fact.resize(n + 1), fact_inv.resize(n + 1);\n  fact[0] = mint(1);\n  for (long long i = (1); (i) <= (n); (i)++) fact[i] = fact[i - 1] * mint(i);\n  fact_inv[n] = fact[n].inverse();\n  for (long long i = (n - 1); (i) >= (0); (i)--)\n    fact_inv[i] = fact_inv[i + 1] * mint(i + 1);\n}\nmint comb(long long n, long long k) {\n  if (n < 0 || k < 0 || n < k) return mint(0);\n  return fact[n] * fact_inv[k] * fact_inv[n - k];\n}\nmint perm(long long n, long long k) { return comb(n, k) * fact[k]; }\nvector<int> prime, pvec;\nvoid make_prime(int n) {\n  prime.resize(n + 1);\n  for (long long i = (2); (i) <= (n); (i)++) {\n    if (prime[i]) continue;\n    for (int j = i; j <= n; j += i) prime[j] = i;\n  }\n  for (long long i = (2); (i) <= (n); (i)++)\n    if (prime[i] == i) pvec.push_back(i);\n}\nbool exceed(long long x, long long y, long long m) { return x >= m / y + 1; }\nvoid mark() { cout << \"*\" << endl; }\nvoid yes() { cout << \"YES\" << endl; }\nvoid no() { cout << \"NO\" << endl; }\nlong long sgn(long long x) {\n  if (x > 0) return 1;\n  if (x < 0) return -1;\n  return 0;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\nlong long digitnum(long long x, long long b = 10) {\n  long long ret = 0;\n  for (; x; x /= b) ret++;\n  return ret;\n}\nlong long digitsum(long long x, long long b = 10) {\n  long long ret = 0;\n  for (; x; x /= b) ret += x % b;\n  return ret;\n}\nstring lltos(long long x) {\n  string ret;\n  for (; x; x /= 10) ret += x % 10 + '0';\n  reverse(ret.begin(), ret.end());\n  return ret;\n}\nlong long stoll(string& s) {\n  long long ret = 0;\n  for (auto c : s) ret *= 10, ret += c - '0';\n  return ret;\n}\ntemplate <typename T>\nvoid uniq(T& vec) {\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n}\ntemplate <class S, class T>\npair<S, T>& operator+=(pair<S, T>& s, const pair<S, T>& t) {\n  s.first += t.first, s.second += t.second;\n  return s;\n}\ntemplate <class S, class T>\npair<S, T>& operator-=(pair<S, T>& s, const pair<S, T>& t) {\n  s.first -= t.first, s.second -= t.second;\n  return s;\n}\ntemplate <class S, class T>\npair<S, T> operator+(const pair<S, T>& s, const pair<S, T>& t) {\n  return pair<S, T>(s.first + t.first, s.second + t.second);\n}\ntemplate <class S, class T>\npair<S, T> operator-(const pair<S, T>& s, const pair<S, T>& t) {\n  return pair<S, T>(s.first - t.first, s.second - t.second);\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n  for (int i = 0; i < vec.size(); i++)\n    os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, deque<T>& deq) {\n  for (int i = 0; i < deq.size(); i++)\n    os << deq[i] << (i + 1 == deq.size() ? \"\" : \" \");\n  return os;\n}\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, pair<T, U>& pair_var) {\n  os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n  return os;\n}\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& pair_var) {\n  os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n  return os;\n}\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, map<T, U>& map_var) {\n  for (typename map<T, U>::iterator itr = map_var.begin(); itr != map_var.end();\n       itr++) {\n    os << \"(\" << itr->first << \", \" << itr->second << \")\";\n    itr++;\n    if (itr != map_var.end()) os << \",\";\n    itr--;\n  }\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T>& set_var) {\n  for (typename set<T>::iterator itr = set_var.begin(); itr != set_var.end();\n       itr++) {\n    os << *itr;\n    ++itr;\n    if (itr != set_var.end()) os << \" \";\n    itr--;\n  }\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, multiset<T>& set_var) {\n  for (typename multiset<T>::iterator itr = set_var.begin();\n       itr != set_var.end(); itr++) {\n    os << *itr;\n    ++itr;\n    if (itr != set_var.end()) os << \" \";\n    itr--;\n  }\n  return os;\n}\ntemplate <typename T>\nvoid outa(T a[], long long s, long long t) {\n  for (long long i = s; i <= t; i++) {\n    cout << a[i];\n    if (i < t) cout << \" \";\n  }\n  cout << endl;\n}\nvoid dump_func() { cout << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head&& head, Tail&&... tail) {\n  cout << head;\n  if (sizeof...(Tail) > 0) cout << \" \";\n  dump_func(std::move(tail)...);\n}\nlong long T;\nlong long n;\nvector<long long> G[100005];\nlong long sum[100005];\nlong long cnt[100005];\nmint dp[100005];\nvector<long long> dvec[200005];\nvoid dfs(int v, int p) {\n  sum[v] += ((long long)(G[v]).size());\n  for (auto u : G[v]) {\n    if (u == p) continue;\n    dfs(u, v);\n    sum[v] += sum[u];\n  }\n}\nvoid dfs2(int v, int p) {\n  for (auto u : G[v]) {\n    if (u == p) continue;\n    long long S = sum[u], T = sum[1] - sum[u];\n    long long g = gcd(S - 1, T + 1), h = gcd(S + 1, T - 1);\n    vector<long long> vec = dvec[g];\n    vec.insert(vec.end(), (dvec[h]).begin(), (dvec[h]).end());\n    uniq(vec);\n    for (auto x : vec)\n      if (x <= n) cnt[x]++;\n    dfs2(u, v);\n  }\n}\nlong long deg[100005];\nbool dfs3(int v, int p, int g) {\n  if (sum[v] == 1) return false;\n  for (auto u : G[v]) {\n    if (u == p) continue;\n    if (dfs3(u, v, g)) deg[v]++;\n  }\n  bool ret = true;\n  if (p != -1 && (deg[v] + 1) % g == ((long long)(G[v]).size()) % g)\n    ret = false, deg[v]++;\n  else if (deg[v] % g != ((long long)(G[v]).size()) % g)\n    cnt[g] = 0;\n  return ret;\n}\nint main(void) {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  for (long long i = (1); (i) <= (200003); (i)++) {\n    for (int j = i; j <= 200003; j += i) dvec[j].push_back(i);\n  }\n  cin >> T;\n  while (T--) {\n    cin >> n;\n    long long u, v;\n    for (long long i = (1); (i) <= (n); (i)++) G[i].clear();\n    for (long long i = (1); (i) <= (n - 1); (i)++) {\n      cin >> u >> v;\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n    for (long long i = (1); (i) <= (n); (i)++) sum[i] = cnt[i] = 0;\n    dfs(1, -1), dfs2(1, -1);\n    for (long long i = (1); (i) <= (n); (i)++) dp[i] = 0;\n    for (long long i = (2); (i) <= (n); (i)++) {\n      if (cnt[i] == n - 1) {\n        for (long long j = (1); (j) <= (n); (j)++) deg[j] = 0;\n        dfs3(1, -1, i);\n        if (cnt[i] == n - 1) dp[i] = 1;\n      }\n    }\n    dp[1] = modpow(mint(2), n - 1);\n    for (long long i = (n); (i) >= (1); (i)--)\n      for (int j = 2 * i; j <= n; j += i) dp[i] -= dp[j];\n    outa(dp, 1, n);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int mod = 998244353;\nint n;\nvector<int> dsk[N];\nlong long f[N];\nint cur[N];\nbool ok = 1;\nvoid dfs(int u, int pre, int val) {\n  if (((int)(dsk[u]).size()) == 1 && u != 1) {\n    cur[u] = 1;\n    return;\n  }\n  for (int v : dsk[u])\n    if (v != pre) {\n      dfs(v, u, val);\n      cur[u] += cur[v];\n    }\n  if (cur[u] % val == 0)\n    cur[u] = 1;\n  else if (u != pre && (cur[u] + 1) % val == 0)\n    cur[u] = 0;\n  else\n    ok = 0;\n}\nint solve(int val) {\n  for (int i = 1; i <= n; ++i) cur[i] = 0;\n  ok = 1;\n  dfs(1, 1, val);\n  return ok;\n}\nvoid gogo() {\n  cin >> n;\n  for (int i = 1; i <= n; ++i) dsk[i].clear();\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    cin >> u >> v;\n    dsk[u].push_back(v);\n    dsk[v].push_back(u);\n  }\n  for (int i = 1; i <= n; ++i) f[i] = 0;\n  f[1] = 1;\n  for (int i = 1; i < n; ++i) (f[1] *= 2) %= mod;\n  for (int i = 2; i <= n - 1; ++i)\n    if ((n - 1) % i == 0) f[i] = solve(i);\n  for (int i = n; i >= 1; --i)\n    for (int j = 2 * i; j <= n; j += i) f[i] = (f[i] - f[j] + mod) % mod;\n  for (int i = 1; i <= n; ++i) {\n    if (i >= 2) assert(f[i] <= 1);\n    cout << f[i] << ' ';\n  }\n  cout << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  if (fopen(\"sol\"\n            \".inp\",\n            \"r\")) {\n    freopen(\n        \"sol\"\n        \".inp\",\n        \"r\", stdin);\n    freopen(\n        \"sol\"\n        \".out\",\n        \"w\", stdout);\n  }\n  int t;\n  cin >> t;\n  while (t--) gogo();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint t, n;\nvector<int> g[100100];\nlong long ans[100100];\nbool extra[100100];\nbool poss(int c, int l, int k) {\n  int cv = 0;\n  for (int i : g[c]) {\n    if (i == l) continue;\n    if (!poss(i, c, k)) return false;\n    cv += extra[i];\n  }\n  if (cv % k == 0) {\n    extra[c] = true;\n    return true;\n  }\n  if ((cv + 1) % k == 0) {\n    extra[c] = false;\n    return true;\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    long long ctot = 1;\n    for (int i = 1; i < n; i++) {\n      int n1, n2;\n      scanf(\" %d%d\", &n1, &n2);\n      g[n1].push_back(n2);\n      g[n2].push_back(n1);\n      ctot *= 2;\n      ctot %= 998244353;\n    }\n    ans[1] = ctot;\n    for (int i = n; i > 1; i--) {\n      ans[i] = 0;\n      if ((n - 1) % i) continue;\n      for (int j = 1; j <= n; j++) extra[j] = false;\n      bool cv = poss(1, -1, i);\n      if (cv && extra[1]) ans[i] = 1;\n    }\n    for (int i = n; i >= 1; i--) {\n      for (int j = i * 2; j <= n; j += i) ans[i] -= ans[j];\n      ans[i] += 998244353;\n      ans[i] %= 998244353;\n    }\n    for (int i = 1; i <= n; i++) printf(\"%lld \", ans[i]);\n    printf(\"\\n\");\n    for (int i = 1; i <= n; i++) g[i].clear();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n//i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n//=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res//x * (x-1)\n            while n%x==0:\n                n //= x\n    if n!=1:\n        res = res//n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n//=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n // g): return n // g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\n#O(|S|)\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=0):\n        self.BIT = [0]*(n+1)\n        self.num = n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        mod = self.mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass SegmentTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        self.size = n\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        if r==self.size:\n            r = self.num\n\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def bisect_l(self,l,r,x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l<r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin==-1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r-1] <=x:\n                    Rmin = r-1\n            l >>= 1\n            r >>= 1\n\n        if Lmin != -1:\n            pos = Lmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        else:\n            return -1\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log\n\ninput = lambda :sys.stdin.buffer.readline()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nfor _ in range(int(input())):\n    n = int(input())\n    edge = [[] for i in range(n)]\n    for _ in range(n-1):\n        a,b = mi()\n        edge[a-1].append(b-1)\n        edge[b-1].append(a-1)\n\n    deq = deque([0])\n    parent = [-1 for v in range(n)]\n    topo = []\n    while deq:\n        v = deq.popleft()\n        topo.append(v)\n        for nv in edge[v]:\n            if nv!=parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n\n    size = [1 for v in range(n)]\n    for v in topo[::-1]:\n        for nv in edge[v]:\n            if nv==parent[v]:\n                continue\n            size[v] += size[nv]\n\n    cnt = [0 for i in range(n)]\n    k = 0\n    for v in range(n):\n        if size[v] >= 2:\n            k += 1\n            if size[v]==n:\n                cnt[size[v]-1] += 1\n            else:\n                cnt[size[v]-1] += 1\n                cnt[size[v]] += 1\n\n    res = [0 for i in range(n+1)]\n    mod = 998244353\n    res[1] = pow(2,n-1,mod)\n    for d in range(n-1,1,-1):\n        res[d] = cnt[d]\n        for i in range(2*d,n,d):\n            res[d] += cnt[i]\n            if res[i]:\n                res[d] = 0\n                break\n        else:\n            if res[d] >= k:\n                res[d] = 1\n                res[1] -= 1\n                res[1] %= mod\n            else:\n                res[d] = 0\n\n    print(*res[1:])\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T, n, k, dp[100010], fl, ans[100010];\nvector<int> g[100010];\nconst int mod = 998244353;\nvoid dfs(int x, int f) {\n  int s = 0;\n  for (int i = 0, v; i < g[x].size(); i++) {\n    v = g[x][i];\n    if (v == f) continue;\n    dfs(v, x);\n    s += dp[v];\n  }\n  dp[x] = 1;\n  if (f && s % k) s++, dp[x] = 0;\n  if (s % k) fl = 1;\n}\nconst int N = 1e5;\nint mu[N + 10], f[N + 10], pri[N + 10], cn;\nvoid sieve() {\n  mu[1] = 1;\n  for (int i = 2; i <= N; i++) {\n    if (!f[i]) pri[++cn] = i, mu[i] = -1;\n    for (int j = 1; j <= cn && i * pri[j] <= N; j++) {\n      f[i * pri[j]] = 1;\n      if (!(i % pri[j])) break;\n      mu[i * pri[j]] = -mu[i];\n    }\n  }\n}\nvoid sol() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) g[i].clear(), ans[i] = dp[i] = f[i] = 0;\n  for (int i = 1, u, v; i < n; i++) {\n    scanf(\"%d%d\", &u, &v);\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  f[1] = 1;\n  for (int i = 1; i < n; i++) (f[1] *= 2) %= mod;\n  for (k = 2; k < n; k++)\n    if (!((n - 1) % k)) {\n      fl = 0;\n      dfs(1, 0);\n      if (!fl) f[k] = 1;\n    }\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; i * j <= n; j++) (ans[i] += f[i * j] * mu[j]) %= mod;\n  for (int i = 1; i <= n; i++) printf(\"%d \", (ans[i] + mod) % mod);\n  printf(\"\\n\");\n}\nint main() {\n  sieve();\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) sol();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int n = 0, f = 1, ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    n = n * 10 + ch - '0';\n    ch = getchar();\n  }\n  return n * f;\n}\nchar str[200005];\nint a[200005];\nvector<int> v[200005];\nint k;\nint dp[200005][2], rd[200005];\nint da[200005], jda[200005];\nvoid dfs(int x, int f) {\n  if (rd[x] < k) {\n    dp[x][0] = 1;\n    for (int i = 0; i < v[x].size(); i++) {\n      if (v[x][i] == f) continue;\n      dfs(v[x][i], x);\n      dp[x][0] = 1LL * dp[x][0] * dp[v[x][i]][1] % 998244353;\n    }\n    dp[x][1] = 0;\n    return;\n  }\n  int cj = 1, sl = 0;\n  for (int i = 0; i < v[x].size(); i++) {\n    if (v[x][i] == f) continue;\n    dfs(v[x][i], x);\n    if (dp[v[x][i]][1] == 0) {\n      cj = 1LL * dp[v[x][i]][0] * cj % 998244353;\n      sl++;\n    }\n  }\n  for (int i = 0; i < k; i++) da[i] = 0;\n  da[sl % k] = cj;\n  for (int i = 0; i < v[x].size(); i++) {\n    if (v[x][i] == f) continue;\n    if (dp[v[x][i]][1] == 0) continue;\n    for (int j = 0; j < k; j++) jda[j] = da[j];\n    for (int j = 0; j < k; j++) {\n      da[j] = 1LL * jda[j] * dp[v[x][i]][1] % 998244353;\n      if (j == 0)\n        da[j] =\n            (da[j] + 1LL * jda[k - 1] * dp[v[x][i]][0] % 998244353) % 998244353;\n      else\n        da[j] =\n            (da[j] + 1LL * jda[j - 1] * dp[v[x][i]][0] % 998244353) % 998244353;\n    }\n  }\n  dp[x][0] = da[0];\n  dp[x][1] = da[k - 1];\n}\nint tans[200005];\nint main() {\n  int t, n, x, y;\n  t = read();\n  for (int greg = 1; greg <= t; greg++) {\n    n = read();\n    for (int i = 1; i <= n - 1; i++) {\n      x = read();\n      y = read();\n      v[x].push_back(y);\n      v[y].push_back(x);\n      rd[x]++;\n      rd[y]++;\n    }\n    for (int i = 1; i <= n; i++) {\n      if ((n - 1) % i == 0) {\n        k = i;\n        dfs(1, 0);\n        tans[i] = dp[1][0];\n      } else\n        tans[i] = 0;\n    }\n    for (int i = n; i >= 1; i--) {\n      for (int j = 2 * i; j <= n; j += i)\n        tans[i] = (tans[i] + 998244353 - tans[j]) % 998244353;\n    }\n    for (int i = 1; i <= n; i++) printf(\"%d \", tans[i]);\n    printf(\"\\n\");\n    for (int i = 1; i <= n; i++) {\n      v[i].clear();\n      dp[i][0] = dp[i][1] = 0;\n      rd[i] = 0;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing db = double;\nusing str = string;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>;\nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>;\nusing vpd = vector<pd>;\nll cdiv(ll a, ll b) { return a / b + ((a ^ b) > 0 && a % b); }\nll fdiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); }\ntemplate <class T>\nbool ckmin(T& a, const T& b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\ntemplate <class T>\nvoid remDup(vector<T>& v) {\n  sort(begin(v), end(v));\n  v.erase(unique(begin(v), end(v)), v.end());\n}\nconst int MOD = 998244353;\nconst int MX = 1e5 + 10;\nconst ll INF = 1e18;\nstruct mint {\n  int v;\n  explicit operator int() const { return v; }\n  mint() { v = 0; }\n  mint(ll _v) {\n    v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n    if (v < 0) v += MOD;\n  }\n  friend bool operator==(const mint& a, const mint& b) { return a.v == b.v; }\n  friend bool operator!=(const mint& a, const mint& b) { return !(a == b); }\n  friend bool operator<(const mint& a, const mint& b) { return a.v < b.v; }\n  mint& operator+=(const mint& m) {\n    if ((v += m.v) >= MOD) v -= MOD;\n    return *this;\n  }\n  mint& operator-=(const mint& m) {\n    if ((v -= m.v) < 0) v += MOD;\n    return *this;\n  }\n  mint& operator*=(const mint& m) {\n    v = int((ll)v * m.v % MOD);\n    return *this;\n  }\n  mint& operator/=(const mint& m) { return (*this) *= inv(m); }\n  friend mint pow(mint a, long long p) {\n    mint ans = 1;\n    for (; p; p /= 2, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  friend mint inv(const mint& a) { return pow(a, MOD - 2); }\n  mint operator-() const { return mint(-v); }\n  mint& operator++() { return *this += 1; }\n  mint& operator--() { return *this -= 1; }\n  friend mint operator+(mint a, const mint& b) { return a += b; }\n  friend mint operator-(mint a, const mint& b) { return a -= b; }\n  friend mint operator*(mint a, const mint& b) { return a *= b; }\n  friend mint operator/(mint a, const mint& b) { return a /= b; }\n};\nint T, N;\nvi adj[MX];\nmint DP[MX];\nint cnt[MX], DIV;\nbool bad;\nvoid DFS(int X, int P) {\n  if (bad) return;\n  for (auto& Y : adj[X])\n    if (Y != P) DFS(Y, X);\n  if (cnt[X] % DIV != 0) {\n    if (P != 0) cnt[X]++;\n    if (cnt[X] % DIV != 0) {\n      bad = true;\n      return;\n    }\n  } else\n    cnt[P]++;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> T;\n  while (T--) {\n    cin >> N;\n    for (int i = (1); i < (N + 1); i++) adj[i].clear(), DP[i] = 0;\n    for (int i = (0); i < (N - 1); i++) {\n      int A, B;\n      cin >> A >> B;\n      adj[A].push_back(B), adj[B].push_back(A);\n    }\n    DP[1] = pow(mint(2), N - 1);\n    for (int i = (2); i < (N + 1); i++)\n      if ((N - 1) % i == 0) {\n        bad = false;\n        DIV = i;\n        for (int j = (1); j < (N + 1); j++) cnt[j] = 0;\n        DFS(1, 0);\n        if (!bad) DP[i] = 1;\n      }\n    for (int i = (N + 1) - 1; i >= (1); i--)\n      for (int j = 2 * i; j <= N; j += i) DP[i] -= DP[j];\n    for (int i = (1); i < (N + 1); i++) cout << int(DP[i]) << \" \";\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int f = 1, ans = 0;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    ans = ans * 10 + c - '0';\n    c = getchar();\n  }\n  return f * ans;\n}\nconst int MAXN = 3e5 + 11;\nvector<int> vec[MAXN];\nint cas, N, Ans[MAXN], nw[MAXN];\nbool ff;\nvoid dfs(int u, int fath, int Lim) {\n  nw[u] = 0;\n  for (auto v : vec[u])\n    if (v != fath) dfs(v, u, Lim);\n  if (fath) {\n    if (nw[u])\n      nw[u] = (nw[u] + 1) % Lim;\n    else\n      nw[fath] = (nw[fath] + 1) % Lim;\n  }\n  if (nw[u]) ff = 0;\n  return;\n}\nsigned main() {\n  cas = read();\n  while (cas--) {\n    N = read();\n    for (int i = 1; i <= N; i++) vec[i].clear(), Ans[i] = 0;\n    int res = 1;\n    for (int i = 1; i < N; i++) {\n      res = res * 2 % 998244353;\n      int u = read(), v = read();\n      vec[u].push_back(v), vec[v].push_back(u);\n    }\n    int cnt = 0;\n    for (int i = 2; i <= N; i++)\n      if (!((N - 1) % i)) {\n        ff = 1;\n        dfs(1, 0, i);\n        Ans[i] = ff;\n      }\n    for (int i = N - 1; i >= 2; i--)\n      for (int j = i + i; j <= N - 1; j += i) Ans[i] -= Ans[j];\n    for (int i = 2; i <= N - 1; i++) cnt += Ans[i];\n    Ans[1] = (res - cnt + 998244353) % 998244353;\n    for (int i = 1; i <= N; i++) printf(\"%d \", Ans[i]);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9, mod = 998244353;\nvector<int> g[N];\nint dp[N], d, ok, ans[N];\nvoid dfs(int u, int p = 0) {\n  if (!ok) return;\n  for (auto v : g[u]) {\n    if (v ^ p) {\n      dfs(v, u);\n    }\n  }\n  if (dp[u] % d != 0) {\n    if (p) {\n      dp[u]++;\n    }\n    if (dp[u] % d != 0) {\n      ok = 0;\n      return;\n    }\n  } else {\n    dp[p]++;\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n      int u, v;\n      cin >> u >> v;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n    for (int i = 1; i <= n; i++) {\n      ans[i] = 0;\n    }\n    ans[1] = 1;\n    for (int k = 1; k <= n - 1; k++) {\n      ans[1] = (ans[1] + ans[1]) % mod;\n    }\n    for (d = 2; d <= n - 1; d++) {\n      if ((n - 1) % d == 0) {\n        ok = 1;\n        dfs(1);\n        ans[d] = ok;\n        for (int i = 0; i <= n; i++) {\n          dp[i] = 0;\n        }\n      }\n    }\n    for (int i = n; i >= 1; i--) {\n      for (int j = i + i; j <= n; j += i) {\n        ans[i] = (ans[i] - ans[j] + mod) % mod;\n      }\n    }\n    for (int i = 1; i <= n; i++) {\n      if (i > 1) cout << ' ';\n      cout << ans[i];\n    }\n    cout << '\\n';\n    for (int i = 1; i <= n; i++) {\n      g[i].clear();\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconst int MONKE = 0;\nconst ll mod = 998244353;\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<pair<int, int>> edges(n - 1);\n  vector<vector<int>> adj(n);\n  for (auto &[l, r] : edges) {\n    cin >> l >> r;\n    adj[l - 1].push_back(r - 1);\n    adj[r - 1].push_back(l - 1);\n  }\n  vector<ll> f(n + 1);\n  f[1] = 1;\n  for (int i = 1; i < n; i++) f[1] = (f[1] + f[1]) % mod;\n  function<int(int, int, int)> dfs = [&](int node, int par, int val) {\n    int cnt = 0;\n    for (auto e : adj[node]) {\n      if (e == par) continue;\n      int res = dfs(e, node, val);\n      if (res == -1) return -1;\n      cnt += res;\n    }\n    if (cnt % val == 0) return 1;\n    if (cnt % val == val - 1) return 0;\n    return -1;\n  };\n  for (int i = 2; i < n; i++) {\n    if ((n - 1) % i == 0) {\n      f[i] = (dfs(0, -1, i) > 0);\n    }\n  }\n  for (int i = n; i > 0; i--) {\n    for (int j = i + i; j < n; j += i) f[i] -= f[j];\n    if (i == 1) f[i] = (f[i] + mod) % mod;\n  }\n  for (int i = 1; i <= n; i++) cout << f[i] << \" \\n\"[i == n];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t = 1;\n  cin >> t;\n  for (int tc = 1; tc <= t; tc++) {\n    solve();\n  }\n  return MONKE;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:150777216\")\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nmt19937 rnd(123);\ntemplate <typename T1, typename T2>\ninline void chkmin(T1& x, const T2& y) {\n  if (y < x) x = y;\n}\ntemplate <typename T1, typename T2>\ninline void chkmax(T1& x, const T2& y) {\n  if (x < y) x = y;\n}\nconst int MAXN = 1e5 + 228;\nvector<int> g[MAXN];\nint mod = 998244353;\nint mul(int a, int b) { return 1ll * a * b % mod; }\nint add(int a, int b) {\n  if (a + b >= mod) return a + b - mod;\n  return a + b;\n}\nint sub(int a, int b) {\n  if (a - b < 0) return a - b + mod;\n  return a - b;\n}\nint binpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = mul(res, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\nint inv(int x) { return binpow(x, mod - 2); }\nint fact[MAXN];\nint rfact[MAXN];\nint cnk(int n, int k) {\n  if (n < 0 || k > n) return 0;\n  return mul(fact[n], mul(rfact[k], rfact[n - k]));\n}\nint k;\nint dfs(int v, int p) {\n  int cnt = 0;\n  for (int i : g[v]) {\n    if (i == p) continue;\n    int x = dfs(i, v);\n    if (x == -1) return -1;\n    cnt += x;\n  }\n  if (cnt % k == 0) {\n    if (p == v) return 0;\n    return 1;\n  }\n  if ((cnt + 1) % k == 0 && v != p) return 0;\n  return -1;\n}\nsigned main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cout.precision(20), cout.setf(ios::fixed);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) g[i].clear();\n    for (int i = 0; i < n - 1; ++i) {\n      int a, b;\n      cin >> a >> b;\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n    vector<int> dd;\n    vector<int> ans(n + 1);\n    ans[1] = binpow(2, n - 1);\n    int x = n - 1;\n    for (int i = 1; i * i <= x; ++i) {\n      if (x % i == 0) {\n        dd.push_back(i);\n        dd.push_back(x / i);\n      }\n    }\n    for (int i : dd) {\n      if (i > 1) {\n        k = i;\n        ans[i] = (dfs(1, 1) == 0);\n      }\n    }\n    for (int i = n; i >= 1; --i) {\n      for (int j = i * 2; j <= n; j += i) {\n        ans[i] = sub(ans[i], ans[j]);\n      }\n    }\n    for (int i = 1; i <= n; ++i) cout << ans[i] << ' ';\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200020, MOD = 998244353;\ninline int read() {\n  int s = 0, w = 1;\n  char ch = getchar();\n  while (ch > '9' || ch < '0') {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n  return s * w;\n}\nint T, n, u, v, f[N];\nbool flag;\nvector<int> e[N];\nint dfs(int k, int fa, int gr) {\n  int cnt = 0;\n  for (int i = 0; i < e[k].size(); i++) {\n    int to = e[k][i];\n    if (to == fa) continue;\n    cnt = cnt + dfs(to, k, gr);\n  }\n  if (cnt % gr == 0) return 1;\n  if ((cnt + 1) % gr == 0) return 0;\n  flag = 0;\n  return 0;\n}\nint main() {\n  T = read();\n  while (T--) {\n    n = read();\n    for (int i = 1; i <= n; i++) e[i].clear();\n    memset(f, 0, sizeof(f)), f[1] = 1;\n    for (int i = 1; i <= n - 1; i++) {\n      f[1] = f[1] * 2 % MOD;\n      u = read(), v = read();\n      e[u].push_back(v), e[v].push_back(u);\n    }\n    for (int i = 2; i <= n - 1; i++)\n      if ((n - 1) % i == 0) {\n        flag = 1;\n        if (dfs(1, 0, i) == 1 && flag) f[i] = 1;\n      }\n    for (int i = n - 1; i >= 1; i--)\n      for (int j = 2; i * j <= n - 1; j++) f[i] = f[i] - f[i * j];\n    f[1] = (f[1] + MOD) % MOD;\n    for (int i = 1; i <= n; i++) printf(\"%d \", f[i]);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename A, typename B>\nostream& operator<<(ostream& cout, pair<A, B> const& p) {\n  return cout << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <typename A>\nostream& operator<<(ostream& cout, vector<A> const& v) {\n  cout << \"[\";\n  for (int i = 0; i < (int)v.size(); i++) {\n    if (i) cout << \", \";\n    cout << v[i];\n  }\n  return cout << \"]\";\n}\ntemplate <typename T>\nbool ckmin(T& a, const T& b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <typename T>\nbool ckmax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\ntypedef std::decay<decltype(998244353)>::type mod_t;\nstruct mi {\n  mod_t val;\n  explicit operator mod_t() const { return val; }\n  mi() { val = 0; }\n  mi(const long long& v) {\n    val = (-998244353 <= v && v < 998244353) ? v : v % 998244353;\n    if (val < 0) val += 998244353;\n  }\n  friend std::istream& operator>>(std::istream& in, mi& a) {\n    long long x;\n    std::cin >> x;\n    a = mi(x);\n    return in;\n  }\n  friend std::ostream& operator<<(std::ostream& os, const mi& a) {\n    return os << a.val;\n  }\n  friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n  friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n  friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n  friend bool operator>(const mi& a, const mi& b) { return a.val > b.val; }\n  friend bool operator<=(const mi& a, const mi& b) { return a.val <= b.val; }\n  friend bool operator>=(const mi& a, const mi& b) { return a.val >= b.val; }\n  mi operator-() const { return mi(-val); }\n  mi& operator+=(const mi& m) {\n    if ((val += m.val) >= 998244353) val -= 998244353;\n    return *this;\n  }\n  mi& operator-=(const mi& m) {\n    if ((val -= m.val) < 0) val += 998244353;\n    return *this;\n  }\n  mi& operator*=(const mi& m) {\n    val = (long long)val * m.val % 998244353;\n    return *this;\n  }\n  friend mi pow(mi a, long long p) {\n    mi ans = 1;\n    assert(p >= 0);\n    for (; p; p /= 2, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  friend mi inv(const mi& a) {\n    assert(a != 0);\n    return pow(a, 998244353 - 2);\n  }\n  mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n  friend mi operator+(mi a, const mi& b) { return a += b; }\n  friend mi operator-(mi a, const mi& b) { return a -= b; }\n  friend mi operator*(mi a, const mi& b) { return a *= b; }\n  friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  int t;\n  cin >> t;\n  for (int ti = 0; ti < (t); ti++) {\n    int n;\n    cin >> n;\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < (n - 1); i++) {\n      int x, y;\n      cin >> x >> y;\n      x--;\n      y--;\n      adj[x].push_back(y);\n      adj[y].push_back(x);\n    }\n    vector<mi> v(n);\n    bool good;\n    function<bool(int, int, int)> check = [&](int u, int par, int k) {\n      int x = 0;\n      for (int oth : adj[u])\n        if (oth != par) x += check(oth, u, k);\n      if (x % k == 0) {\n        return true;\n      }\n      if ((x + 1) % k == 0) {\n        return false;\n      }\n      good = false;\n      return false;\n    };\n    for (int k = 2; k <= n; k++) {\n      if ((n - 1) % k) continue;\n      good = true;\n      if (!check(0, -1, k)) good = false;\n      if (good) {\n        v[k - 1] = true;\n      }\n    }\n    for (int k = n; k >= 2; k--) {\n      for (int z = k + k; z <= n; z += k) {\n        if (v[z - 1] > 0) v[k - 1] = 0;\n      }\n    }\n    v[0] = pow((mi)2, n - 1);\n    for (int i = 1; i < n; i++) {\n      v[0] -= v[i];\n    }\n    for (int i = 0; i < (n); i++) cout << v[i] << \" \";\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void Read(int &first) {\n  int f = 1;\n  first = 0;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    first = (first << 3) + (first << 1) + c - '0', c = getchar();\n  }\n  first *= f;\n}\nconst int N = 100010, p = 998244353;\nint T, n, f[N];\nstruct Edge {\n  int to, nxt;\n} e[N << 1];\nint hd[N], cnt;\ninline void ade(int u, int v) {\n  e[++cnt].to = v, e[cnt].nxt = hd[u], hd[u] = cnt;\n}\nint ff;\nint DFS(int u, int fa, int m) {\n  if (!ff) return 0;\n  int tot = 0;\n  for (register int i = hd[u]; i; i = e[i].nxt) {\n    int v = e[i].to;\n    if (v != fa) tot += DFS(v, u, m);\n  }\n  if (tot % m == 0) return 1;\n  if ((tot + 1) % m == 0) return 0;\n  ff = 0;\n  return 0;\n}\nint main() {\n  Read(T);\n  while (T--) {\n    memset(f, 0, sizeof f);\n    Read(n), memset(hd, 0, sizeof hd), cnt = 0, f[1] = 1;\n    for (register int i = 1, u, v; i < n; i++) {\n      Read(u), Read(v), ade(u, v), ade(v, u), f[1] = 2ll * f[1] % p;\n    }\n    for (register int i = 2; i < n; i++) {\n      if ((n - 1) % i == 0) {\n        ff = 1, f[i] = DFS(1, 0, i) & ff;\n      }\n    }\n    for (register int i = n - 1; i; i--) {\n      for (register int j = i + i; j < n; j += i) f[i] -= f[j];\n      f[i] = (f[i] % p + p) % p;\n    }\n    for (register int i = 1; i <= n; i++) printf(\"%d \", f[i]);\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long M = 998244353;\nlong long fpow(long long x, long long y) {\n  if (y == 0) return 1;\n  if (y == 1) return x;\n  long long p = fpow(x, y / 2);\n  p *= p;\n  p %= M;\n  if (y & 1) p *= x;\n  return p % M;\n}\nvector<int> v[100005];\nlong long ans[100005], po[100005];\nbool ok;\nint dfs(int ver, int k, int par) {\n  int sum = 0;\n  for (int i = 0; i < v[ver].size(); i++) {\n    if (v[ver][i] == par) continue;\n    sum += dfs(v[ver][i], k, ver);\n  }\n  if (sum % k == 0) {\n    return 1;\n  }\n  if ((sum + 1) % k != 0) ok = 0;\n  return 0;\n}\nint main() {\n  po[0] = 1;\n  for (int i = 1; i < 100005; i++) {\n    po[i] = 2 * po[i - 1];\n    po[i] %= M;\n  }\n  int t, x, y, n;\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n      cin >> x >> y;\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n    ans[1] = po[n - 1];\n    for (int k = 2; k <= n; k++) {\n      ok = 1;\n      ans[k] = 0;\n      if ((n - 1) % k != 0) continue;\n      dfs(1, k, -1);\n      ans[k] = ok;\n    }\n    for (int k = n; k >= 1; k--) {\n      for (int i = k * 2; i <= n; i += k) {\n        ans[k] = (ans[k] - ans[i] + M) % M;\n      }\n    }\n    for (int i = 1; i <= n; i++) {\n      cout << ans[i] << ' ';\n      v[i].clear();\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MN = 100005, MOD = 998244353;\nlong long t, n, u, v, val[MN], ans[MN];\nvector<long long> a[MN];\nvoid dfs(long long cur, long long par, long long k) {\n  for (long long nxt : a[cur]) {\n    if (nxt == par) continue;\n    dfs(nxt, cur, k);\n  }\n  if (val[cur] % k && par)\n    val[cur]++;\n  else\n    val[par]++;\n}\nint32_t main() {\n  cin.tie(0), cin.sync_with_stdio(0);\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (long long i = 1; i < n; i++) {\n      cin >> u >> v;\n      a[u].push_back(v);\n      a[v].push_back(u);\n    }\n    ans[1] = 1;\n    for (long long i = 1; i < n; i++) ans[1] = ans[1] * 2 % MOD;\n    for (long long i = 2; i <= n; i++) {\n      if ((n - 1) % i) continue;\n      memset(val, 0, sizeof(val));\n      dfs(1, 0, i);\n      ans[i] = 1;\n      for (long long j = 1; j <= n; j++)\n        if (val[j] % i) ans[i] = 0;\n    }\n    for (long long i = n; i > 0; i--) {\n      for (long long j = i + i; j <= n; j += i) ans[i] -= ans[j];\n    }\n    for (long long i = 1; i <= n; i++) printf(\"%lld \", ans[i]);\n    printf(\"\\n\");\n    for (long long i = 1; i <= n; i++) a[i].clear(), val[i] = ans[i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 10, MOD = 998244353;\nint n;\nvector<int> adj[MAXN];\nbool work[MAXN], ans[MAXN];\nint dfs(int c, int p, int k) {\n  int me = 0;\n  for (auto nxt : adj[c])\n    if (nxt != p) {\n      int they = dfs(nxt, c, k);\n      if (they == -1) return -1;\n      assert(they == 0 || they == 1);\n      me += they;\n    }\n  if ((me + 1) % k == 0) return 0;\n  if (me % k == 0) return 1;\n  return -1;\n}\nvoid solve() {\n  cin >> n;\n  for (int i = 0; i <= n; i++) adj[i].clear(), ans[i] = work[i] = 0;\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b, --a, --b;\n    adj[a].push_back(b), adj[b].push_back(a);\n  }\n  for (int i = 2; i <= n; i++)\n    if ((n - 1) % i == 0) {\n      work[i] = dfs(0, -1, i) == 1;\n    }\n  int cur = 1;\n  for (int i = 0; i < n - 1; i++) cur = cur * 2 % MOD;\n  for (int i = 2; i <= n; i++) {\n    ans[i] = work[i];\n    for (int j = 2 * i; j <= n; j += i) ans[i] &= !work[j];\n    cur -= ans[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    if (i == 1)\n      cout << cur;\n    else\n      cout << ' ' << ans[i];\n  }\n  cout << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T = 1;\n  cin >> T;\n  while (T--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint recur_depth = 0;\nconst long long sz = 1e5 + 10, mod = 998244353;\nvector<long long> g[sz];\nlong long ans[sz], dp[sz];\nvoid dfs(long long u, long long p, long long k) {\n  for (long long& v : g[u]) {\n    if (v == p) continue;\n    dfs(v, u, k);\n    if (dp[v] % k != 0)\n      dp[v]++;\n    else\n      dp[u]++;\n  }\n}\nint main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    scanf(\"%lld\", &n);\n    for (long long i = 1; i <= n - 1; ++i) {\n      long long u, v;\n      scanf(\"%lld\", &u), scanf(\"%lld\", &v);\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n    long long m = n - 1;\n    ans[1] = 1;\n    for (long long i = 1; i <= m; ++i) ans[1] = (ans[1] * 2) % mod;\n    for (long long i = 2; i <= m; i++) {\n      if (m % i == 0) {\n        for (long long j = 1; j <= n; ++j) dp[j] = 0;\n        dfs(1, -1, i);\n        bool ok = 1;\n        for (long long j = 1; j <= n; ++j) ok &= (dp[j] % i == 0);\n        ans[i] = ok;\n      }\n    }\n    for (long long i = n; i >= 1; --i)\n      for (long long j = i + i; j <= n; j += i) ans[i] -= ans[j];\n    for (long long i = 1; i <= n; ++i) {\n      if (ans[i] < 0) ans[i] += mod;\n      printf(\"%lld \", ans[i]);\n    }\n    printf(\"\\n\");\n    for (long long i = 1; i <= n; ++i) g[i].clear(), ans[i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.List;\n import java.util.*;\n public class realfast implements Runnable \n  {\n    private static final int INF = (int) 1e9;\n    long in= 998244353;\n    long fac[]= new long[1000001];\n    long inv[]=new long[1000001];\n    int queue[]=new int[100001];\n    boolean visited[]=new boolean[100001];\n    int deg[]=new int[100001];\n    int a[]=new int[100001];\n    public  void solve() throws IOException \n    {\n\n        \n         \n\n        int t = readInt();\n\n        for(int f =0;f<t;f++)\n        {\n             int n = readInt();\n             ArrayList<Integer> arr[]=new ArrayList[n+1];\n             for(int i=1;i<=n;i++)\n                arr[i]= new ArrayList<Integer>();\n             for(int i=1;i<=n-1;i++)\n             {\n                 int u = readInt();\n                 int v = readInt();\n                 arr[u].add(v);\n                 arr[v].add(u);\n             }\n\n             ArrayList<Integer> div = new ArrayList<Integer>();\n\n             int root = (int)Math.pow(n-1,0.5);\n\n             if(n-1==1)\n             {\n                div.add(1);\n             }\n             else \n             {\n                div.add(1);\n                div.add(n-1);\n                for(int i=2;i<=root;i++)\n                {\n                     if((n-1)%i==0)\n                     {\n                        div.add(i);\n                        if(i!=((n-1)/i))\n                        {\n                            div.add((n-1)/i);\n                        }\n                     }\n                }\n             }\n             Collections.sort(div);\n\n             long dp[]=new long[n+1];\n\n\n             dp[1]= pow(2,n-1,in);\n            // out.println(dp[1]);\n\n             for(int i= div.size()-1;i>=1;i--)\n             {\n                   int l = div.get(i);\n                   if(check(arr,l))\n                   {\n                     dp[l]=1;\n                   }\n                   \n             }\n             for(int i=div.size()-1;i>=0;i--)\n             {\n                int l = div.get(i);\n                for(int j =i+1;j<div.size();j++)\n                {\n                   int l1= div.get(j);\n\n                   if(l1%l==0)\n                   {\n                    dp[l]= (dp[l]-dp[l1]+in)%in; \n                   }\n                }\n             }\n\n\n             for(int i=1;i<=n;i++)\n                out.print(dp[i]+\" \");\n\n             out.println();\n\n\n        }\n        \n\n\n\n    }\n    public boolean check(ArrayList<Integer> arr[], int k )\n    {\n       int n = arr.length-1;\n     //  boolean visited[]=new boolean[n+1];\n\n       for(int i=1;i<=n;i++)\n        visited[i]= false;\n       int start=0;\n       int end=-1;\n       for(int i=1;i<=n;i++)\n        deg[i]= arr[i].size();\n       for(int i=1;i<=n;i++)\n        a[i]=0;\n       for(int i=1;i<=n;i++)\n       {\n          if(deg[i]==1)\n          {\n            end++;\n            queue[end]=i;\n          }\n       }\n\n       while(start<=end)\n       {\n         int c=queue[start];\n         \n         visited[c]= true;\n\n\n\n         for(int j =0;j<arr[c].size();j++)\n         {\n            int v = arr[c].get(j);\n            if(!visited[v])\n            {\n                deg[v]--;\n\n                if((a[c]%k)==0)\n                {\n                    a[v]++;\n                }\n                else\n                {\n                    a[c]++;\n                }\n                if(deg[v]==1)\n                {\n                    end++;\n                    queue[end]=v;\n                }\n            }\n\n         }\n\n         if((a[c]%k)!=0)\n            return false;\n         \n\n         start++;\n       }\n\n       return true;\n\n    }\n    \n    public int value (int seg[], int left , int right ,int index, int l, int r)\n    {\n            \n            if(left>right)\n            {\n              return -100000000;\n            }\n            if(right<l||left>r)\n                return -100000000;\n            if(left>=l&&right<=r)\n                return seg[index];\n            int mid = left+(right-left)/2;\n            int val = value(seg,left,mid,2*index+1,l,r);\n            int val2 = value(seg,mid+1,right,2*index+2,l,r);\n            return Math.max(val,val2);\n\n    }\n   \n    public int gcd(int a , int b )\n    {\n      if(a<b)\n      {\n        int t =a;\n        a=b;\n        b=t;\n      }\n      if(a%b==0)\n        return b ;\n      return gcd(b,a%b);\n    }\n    public long pow(long n , long p,long m)\n    {\n         if(p==0)\n            return 1;\n        long val = pow(n,p/2,m);;\n        val= (val*val)%m;\n        if(p%2==0)\n            return val;\n        else\n            return (val*n)%m;\n    }\n    \n    \n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    public static void main(String[] args) {\n        new Thread(null, new realfast(), \"\", 128 * (1L << 20)).start();\n    }\n \n    private static final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private PrintWriter out;\n \n    @Override\n    public void run() {\n        try {\n            if (ONLINE_JUDGE || !new File(\"input.txt\").exists()) {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                reader = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            solve();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // nothing\n            }\n            out.close();\n        }\n    }\n \n    private String readString() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n \n    @SuppressWarnings(\"unused\")\n    private int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n \n    @SuppressWarnings(\"unused\")\n    private long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n \n    @SuppressWarnings(\"unused\")\n    private double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n}\nclass edge implements Comparable<edge>{\n    int u ;\n    int v;\n    \n    edge(int  u, int v)\n    {\n       this.u=u;\n       this.v=v;\n    }\n    public int compareTo(edge e)\n    {\n        return this.v-e.v;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9, mod = 998244353;\nvector<int> g[N];\nint dp[N], d, ok, ans[N];\nvoid dfs(int u, int p = 0) {\n  if (!ok) return;\n  for (auto v : g[u]) {\n    if (v ^ p) {\n      dfs(v, u);\n    }\n  }\n  if (dp[u] % d != 0) {\n    if (p) {\n      dp[u]++;\n    }\n    if (dp[u] % d != 0) {\n      ok = 0;\n      return;\n    }\n  } else {\n    dp[p]++;\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n      int u, v;\n      cin >> u >> v;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n    for (int i = 1; i <= n; i++) {\n      ans[i] = 0;\n    }\n    ans[1] = 1;\n    for (int k = 1; k <= n - 1; k++) {\n      ans[1] = (ans[1] + ans[1]) % mod;\n    }\n    for (d = 2; d <= n - 1; d++) {\n      if ((n - 1) % d == 0) {\n        ok = 1;\n        dfs(1);\n        ans[d] = ok;\n        for (int i = 0; i <= n; i++) {\n          dp[i] = 0;\n        }\n      }\n    }\n    for (int i = n; i >= 1; i--) {\n      for (int j = i + i; j <= n; j += i) {\n        ans[i] = (ans[i] - ans[j] + mod) % mod;\n      }\n    }\n    for (int i = 1; i <= n; i++) {\n      if (i > 1) cout << ' ';\n      cout << ans[i];\n    }\n    cout << '\\n';\n    for (int i = 1; i <= n; i++) {\n      g[i].clear();\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstd::mt19937 rnd(\n    (int)std::chrono::steady_clock::now().time_since_epoch().count());\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nconst int MAXN = 100000;\nconst int MOD = 998244353;\nint n;\nvector<int> adj[MAXN];\nint ans[MAXN + 1];\nint par[MAXN], sz[MAXN];\nvoid dfsinit(int at) {\n  sz[at] = 1;\n  for (int to : adj[at]) {\n    if (to == par[at]) continue;\n    par[to] = at;\n    dfsinit(to);\n    sz[at] += sz[to];\n  }\n}\nvoid solve() {\n  par[0] = -1;\n  dfsinit(0);\n  for (int i = (1); i <= (n); ++i) ans[i] = 0;\n  ans[1] = 1;\n  for (int i = (0); i < (n - 1); ++i) ans[1] = (long long)ans[1] * 2 % MOD;\n  for (int i = (2); i <= (n); ++i)\n    if ((n - 1) % i == 0) {\n      bool ok = true;\n      for (int j = (0); j < (n); ++j)\n        if ((sz[j] - 1) % i != 0 && sz[j] % i != 0) ok = false;\n      if (ok) ++ans[i];\n    }\n  for (int i = n; i >= 1; --i)\n    for (int j = i + i; j <= n; j += i) ans[i] -= ans[j];\n}\nvoid run() {\n  scanf(\"%d\", &n);\n  for (int i = (0); i < (n - 1); ++i) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    --a, --b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  solve();\n  for (int i = (1); i <= (n); ++i) {\n    if (i != 1) printf(\" \");\n    printf(\"%d\", ans[i]);\n  }\n  puts(\"\");\n  for (int i = (0); i < (n); ++i) adj[i].clear();\n}\nint main() {\n  int ncase;\n  scanf(\"%d\", &ncase);\n  for (int i = (1); i <= (ncase); ++i) run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nlong long int gcd(long long int A, long long int B) {\n  if (!B) return A;\n  return gcd(B, A % B);\n}\nvector<vector<int>> adj(100005);\nvector<int> dp(100005, 0);\nbool dfs(int v, int u, int k) {\n  int cur = 0;\n  for (int x : adj[v]) {\n    if (x == u) continue;\n    cur += dfs(x, v, k);\n  }\n  bool res = 0;\n  if (cur % k && u != -1) {\n    cur++;\n    res = 1;\n  }\n  if (cur % k) dp[k] = 0;\n  return res ^ 1;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n      adj[i].clear();\n      dp[i + 1] = 0;\n    }\n    for (int i = 0; i < n - 1; i++) {\n      int v, u;\n      cin >> v >> u;\n      v--;\n      u--;\n      adj[v].push_back(u);\n      adj[u].push_back(v);\n    }\n    n--;\n    vector<int> fac = {1};\n    dp[1] = 1;\n    for (int i = 0; i < n; i++) {\n      dp[1] *= 2;\n      if (dp[1] >= (long long int)(998244353))\n        dp[1] -= (long long int)(998244353);\n    }\n    for (int i = 2; i * i <= n; i++) {\n      if (n % i == 0) {\n        dp[i] = 1;\n        dfs(0, -1, i);\n        fac.push_back(i);\n        if (i * i != n) {\n          dp[n / i] = 1;\n          dfs(0, -1, n / i);\n          fac.push_back(n / i);\n        }\n      }\n    }\n    if (n != 1) {\n      dp[n] = 1;\n      fac.push_back(n);\n      dfs(0, -1, n);\n    }\n    sort(fac.begin(), fac.end());\n    for (int i = (int)(fac.size()) - 1; i >= 0; i--) {\n      for (int j = 2 * fac[i]; j <= n; j += fac[i]) {\n        dp[fac[i]] -= dp[j];\n      }\n    }\n    dp[1] += (long long int)(998244353);\n    if (dp[1] >= (long long int)(998244353))\n      dp[1] -= (long long int)(998244353);\n    for (int i = 1; i <= n + 1; i++) cout << dp[i] << \" \";\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nvector<int> G[100020];\nlong long num[100010], dp[100010];\nint falg;\nlong long qpow(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = ans * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return ans;\n}\nvoid dfs(int x, int fa, int k) {\n  if (falg == 1) return;\n  for (int i = 0; i < G[x].size(); i++)\n    if (G[x][i] != fa) dfs(G[x][i], x, k);\n  if (dp[x] % k == 0)\n    dp[fa]++;\n  else {\n    if (fa) dp[x]++;\n    if (dp[x] % k != 0) falg = 1;\n  }\n  if (falg == 1) return;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, a, b;\n    cin >> n;\n    for (int i = (0); i < (n + 1); ++i) G[i].clear(), num[i] = dp[i] = 0;\n    for (int i = (0); i < (n - 1); ++i) {\n      scanf(\"%d%d\", &a, &b);\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    num[1] = qpow(2, n - 1);\n    for (int i = (2); i < (n); ++i) {\n      if ((n - 1) % i == 0) {\n        falg = 0;\n        dfs(1, 0, i);\n        num[i] = 1 - falg;\n        for (int i = (0); i < (n + 1); ++i) dp[i] = 0;\n      }\n    }\n    for (int i = n; i >= 1; i--)\n      for (int j = 2 * i; j <= n; j += i) num[i] -= num[j];\n    for (int i = (1); i < (n + 1); ++i) cout << (num[i] + mod) % mod << ' ';\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace chrono;\ntemplate <typename T>\nT gcd(T a, T b) {\n  return (b ? __gcd(a, b) : a);\n}\ntemplate <typename T>\nT lcm(T a, T b) {\n  return (a * (b / gcd(a, b)));\n}\ntemplate <typename T, typename T1>\nT amax(T &a, T1 b) {\n  if (b > a) a = b;\n  return a;\n}\ntemplate <typename T, typename T1>\nT amin(T &a, T1 b) {\n  if (b < a) a = b;\n  return a;\n}\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &a) {\n  in >> a.first >> a.second;\n  return in;\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> a) {\n  out << \"{\" << a.first << \", \" << a.second << \"}\";\n  return out;\n}\nconst int mod = 998244353;\ntemplate <typename T>\nvoid print(T &a) {\n  for (auto &x : a) cout << x << \" \";\n  cout << \"\\n\";\n}\nint power(int x, int y) {\n  int res = 1;\n  while (y) {\n    if (y & 1) res = res * 1ll * x % mod;\n    y = y >> 1;\n    x = x * 1ll * x % mod;\n  }\n  return res;\n}\nconst int N = 1e5 + 10;\nvector<int> adj[N];\nvoid addedge(int u, int v) {\n  adj[u].push_back(v);\n  adj[v].push_back(u);\n}\nbool notpossible;\nint dfs(int v, int p, int d) {\n  if (notpossible) {\n    return 0;\n  }\n  int my = 0;\n  for (auto &x : adj[v]) {\n    if (x == p) continue;\n    int tmp = dfs(x, v, d);\n    if (tmp == 0)\n      my++;\n    else if (tmp + 1 == d)\n      continue;\n    else {\n      notpossible = 1;\n      return 0;\n    }\n  }\n  return (my) % d;\n}\nint ans[N];\nint real_ans[N];\nvoid solve() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < (n + 1); i++) adj[i].clear();\n  for (int i = 0; i < (n - 1); i++) {\n    int t1, t2;\n    cin >> t1 >> t2;\n    addedge(t1, t2);\n  }\n  ans[1] = power(2, (n - 1));\n  for (int i = 2; i < (n + 1); i++) {\n    if ((n - 1) % i) continue;\n    notpossible = 0;\n    int tmp = dfs(1, -1, i);\n    if (notpossible || tmp) {\n      ans[i] = 0;\n    } else {\n      ans[i] = 1;\n    }\n  }\n  for (int i = 1; i < (n + 1); i++) {\n    ;\n  }\n  for (int i = (n + 1) - 1; i >= 1; i--) {\n    if ((n - 1) % i) {\n      real_ans[i] = 0;\n      continue;\n    }\n    int x = 2 * i;\n    real_ans[i] = ans[i];\n    while (x <= n) {\n      if (i == 1) {\n        ;\n      }\n      real_ans[i] -= real_ans[x];\n      x += i;\n    }\n  }\n  for (int i = 1; i < (n + 1); i++) cout << real_ans[i] << \" \";\n  cout << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  auto start1 = high_resolution_clock::now();\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  auto stop1 = high_resolution_clock::now();\n  auto duration = duration_cast<milliseconds>(stop1 - start1);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n//i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n//=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res//x * (x-1)\n            while n%x==0:\n                n //= x\n    if n!=1:\n        res = res//n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n//=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n // g): return n // g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\n#O(|S|)\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=0):\n        self.BIT = [0]*(n+1)\n        self.num = n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        mod = self.mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass SegmentTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        self.size = n\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        if r==self.size:\n            r = self.num\n\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def bisect_l(self,l,r,x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l<r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin==-1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r-1] <=x:\n                    Rmin = r-1\n            l >>= 1\n            r >>= 1\n\n        if Lmin != -1:\n            pos = Lmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        else:\n            return -1\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log\n\ninput = lambda :sys.stdin.buffer.readline()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nfor _ in range(int(input())):\n    n = int(input())\n    edge = [[] for i in range(n)]\n    for _ in range(n-1):\n        a,b = mi()\n        edge[a-1].append(b-1)\n        edge[b-1].append(a-1)\n\n    deq = deque([0])\n    parent = [-1 for v in range(n)]\n    topo = []\n    while deq:\n        v = deq.popleft()\n        topo.append(v)\n        for nv in edge[v]:\n            if nv!=parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n\n    size = [1 for v in range(n)]\n    for v in topo[::-1]:\n        for nv in edge[v]:\n            if nv==parent[v]:\n                continue\n            size[v] += size[nv]\n\n    cnt = [0 for i in range(n)]\n    k = 0\n    for v in range(n):\n        if size[v] >= 2:\n            k += 1\n            if size[v]==n:\n                cnt[size[v]-1] += 1\n            else:\n                cnt[size[v]-1] += 1\n                cnt[size[v]] += 1\n\n    res = [0 for i in range(n+1)]\n    mod = 998244353\n    res[1] = pow(2,n-1,mod)\n    for d in range(2,n):\n        for i in range(2*d,n,d):\n            cnt[d] += cnt[i]\n        if cnt[d] >= k:\n            res[d] = 1\n\n    for d in range(n,0,-1):\n        for i in range(2*d,n+1,d):\n            res[d] -= res[i]\n        res[d] %= mod\n\n    print(*res[1:])\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T1, typename T2>\nvoid chkmin(T1 &x, T2 y) {\n  if (x > y) x = y;\n}\ntemplate <typename T1, typename T2>\nvoid chkmax(T1 &x, T2 y) {\n  if (x < y) x = y;\n}\nnamespace fastio {\nchar rbuf[1 << 23], *p1 = rbuf, *p2 = rbuf, wbuf[1 << 23], *p3 = wbuf;\ninline char getc() {\n  return p1 == p2 &&\n                 (p2 = (p1 = rbuf) + fread(rbuf, 1, 1 << 23, stdin), p1 == p2)\n             ? -1\n             : *p1++;\n}\ninline void putc(char x) { (*p3++ = x); }\ntemplate <typename T>\nvoid read(T &x) {\n  x = 0;\n  char c = getchar();\n  T neg = 0;\n  while (!isdigit(c)) neg |= !(c ^ '-'), c = getchar();\n  while (isdigit(c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  if (neg) x = (~x) + 1;\n}\ntemplate <typename T>\nvoid recursive_print(T x) {\n  return (!x) ? void() : (recursive_print(x / 10), putc(x % 10 ^ 48), void());\n}\ntemplate <typename T>\nvoid print(T x) {\n  (!x) && (putc('0'), 0);\n  (x < 0) && (putc('-'), x = ~x + 1);\n  recursive_print(x);\n}\ntemplate <typename T>\nvoid print(T x, char c) {\n  (!x) && (putc('0'), 0);\n  (x < 0) && (putc('-'), x = ~x + 1);\n  recursive_print(x);\n  putc(c);\n}\nvoid print_final() { fwrite(wbuf, 1, p3 - wbuf, stdout); }\n}  // namespace fastio\nconst int MOD = 998244353;\nconst int MAXN = 1e5;\nint n, hd[MAXN + 5], to[MAXN * 2 + 5], nxt[MAXN * 2 + 5], ec = 0, deg[MAXN + 5],\n                                                          pw2[MAXN + 5];\nvoid adde(int u, int v) {\n  to[++ec] = v;\n  nxt[ec] = hd[u];\n  hd[u] = ec;\n}\nint res[MAXN + 5], vis[MAXN + 5], cdeg[MAXN + 5], lft[MAXN + 5];\nvoid solve() {\n  scanf(\"%d\", &n);\n  ec = 0;\n  for (int i = 1; i <= n; i++) hd[i] = deg[i] = res[i] = 0;\n  int cnt = 0;\n  for (int i = 1, u, v; i < n; i++)\n    scanf(\"%d%d\", &u, &v), deg[u]++, deg[v]++, adde(u, v), adde(v, u);\n  for (int i = 2; i <= n - 1; i++) {\n    if ((n - 1) % i) continue;\n    queue<int> q;\n    bool flg = 1;\n    for (int j = 1; j <= n; j++) vis[j] = 0, cdeg[j] = lft[j] = deg[j];\n    for (int j = 1; j <= n; j++)\n      if (deg[j] == 1) q.push(j);\n    while (!q.empty()) {\n      int x = q.front();\n      q.pop();\n      vis[x] = 1;\n      int y = 0;\n      for (int e = hd[x]; e; e = nxt[e])\n        if (!vis[to[e]]) y = to[e];\n      if (!y) {\n        if (cdeg[x] % i) {\n          flg = 0;\n          break;\n        }\n      } else {\n        if (cdeg[x] % i == 0)\n          cdeg[y]--;\n        else if (cdeg[x] % i == 1)\n          cdeg[x]--;\n        else {\n          flg = 0;\n          break;\n        }\n        if ((--lft[y]) <= 1) q.push(y);\n      }\n    }\n    res[i] = flg;\n    cnt += flg;\n  }\n  res[1] = pw2[n - 1];\n  for (int i = n; i; i--)\n    for (int j = i << 1; j <= n; j += i) res[i] = (res[i] - res[j] + MOD) % MOD;\n  for (int i = 1; i <= n; i++) printf(\"%d%c\", res[i], \" \\n\"[i == n]);\n}\nint main() {\n  for (int i = (pw2[0] = 1); i <= MAXN; i++) pw2[i] = (pw2[i - 1] << 1) % MOD;\n  int qu;\n  scanf(\"%d\", &qu);\n  while (qu--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int mod = 998244353;\nusing std::vector;\nint ans[100000 + 5];\nvector<int> e[100000 + 5];\nint qpow(int bsc, int y) {\n  int ret = 1;\n  while (y) {\n    if (y & 1) ret = (long long)ret * bsc % mod;\n    bsc = (long long)bsc * bsc % mod;\n    y >>= 1;\n  }\n  return ret;\n}\nbool flag;\nint d;\nint dfs(int u, int f) {\n  int cnt = 0;\n  for (int v : e[u]) {\n    if (v == f) continue;\n    int sum = dfs(v, u);\n    if (!flag) return 0;\n    if (sum % d && (sum + 1) % d) {\n      flag = false;\n      return 0;\n    }\n    cnt += sum + 1;\n  }\n  return cnt;\n}\nbool check(int _d) {\n  flag = true;\n  d = _d;\n  dfs(1, 0);\n  return flag;\n}\nvoid solve() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 2; i <= n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  for (int i = 1; i <= n; i++) ans[i] = 0;\n  int cnto = 0;\n  vector<int> fs;\n  for (int i = 2; i * i <= n - 1; i++)\n    if ((n - 1) % i == 0) {\n      fs.push_back(i);\n      if (i * i != n - 1) fs.push_back((n - 1) / i);\n    }\n  if (n - 1 != 1) fs.push_back(n - 1);\n  for (int d : fs) {\n    if (check(d)) {\n      cnto++;\n      ans[d] = 1;\n    }\n  }\n  for (int x : fs) {\n    if (!ans[x]) continue;\n    for (int y : fs) {\n      if (!ans[y]) continue;\n      if (x != y && x % y == 0) {\n        ans[y] = 0;\n        cnto--;\n      }\n    }\n  }\n  ans[1] = (qpow(2, n - 1) + mod - cnto) % mod;\n  for (int i = 1; i <= n; i++) printf(\"%d%c\", ans[i], \" \\n\"[i == n]);\n  for (int i = 1; i <= n; i++) {\n    e[i].clear();\n  }\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid rd(T& x) {\n  int f = 0, c;\n  while (!isdigit(c = getchar())) f ^= !(c ^ 45);\n  x = (c & 15);\n  while (isdigit(c = getchar())) x = x * 10 + (c & 15);\n  if (f) x = -x;\n}\ntemplate <typename T>\nvoid pt(T x, int c = -1) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) pt(x / 10);\n  putchar(x % 10 + 48);\n  if (c != -1) putchar(c);\n}\nconst int P = 998244353;\nint ad(int k1, int k2) { return k1 += k2 - P, k1 += k1 >> 31 & P; }\nint su(int k1, int k2) { return k1 -= k2, k1 += k1 >> 31 & P; }\nint mu(int k1, int k2) { return 1LL * k1 * k2 % P; }\nvoid uad(int& k1, int k2) { k1 += k2 - P, k1 += k1 >> 31 & P; }\nvoid usu(int& k1, int k2) { k1 -= k2, k1 += k1 >> 31 & P; }\ntemplate <typename... T>\nint ad(int k1, T... k2) {\n  return ad(k1, ad(k2...));\n}\ntemplate <typename... T>\nvoid uad(int& k1, T... k2) {\n  return uad(k1, ad(k2...));\n}\ntemplate <typename... T>\nvoid usu(int& k1, T... k2) {\n  return usu(k1, ad(k2...));\n}\ntemplate <typename... T>\nint mu(int k1, T... k2) {\n  return mu(k1, mu(k2...));\n}\nint po(int k1, int k2) {\n  int k3 = 1;\n  for (; k2; k2 >>= 1, k1 = mu(k1, k1))\n    if (k2 & 1) k3 = mu(k3, k1);\n  return k3;\n}\nnamespace ntt {\nint base = 1, root = -1, maxbase = -1;\nstd::vector<int> roots = {0, 1}, rev = {0, 1};\nvoid init() {\n  int tmp = P - 1;\n  maxbase = 0;\n  while (!(tmp & 1)) tmp >>= 1, maxbase++;\n  root = 2;\n  while (1) {\n    if (po(root, 1 << maxbase) == 1 && po(root, 1 << (maxbase - 1)) != 1) break;\n    root++;\n  }\n}\nvoid ensure_base(int nbase) {\n  if (maxbase == -1) init();\n  if (nbase <= base) return;\n  rev.resize(1 << nbase);\n  for (int i = 1; i < (1 << nbase); ++i)\n    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (nbase - 1));\n  roots.resize(1 << nbase);\n  while (base < nbase) {\n    int z = po(root, 1 << (maxbase - base - 1));\n    for (int i = (1 << (base - 1)); i < (1 << base); ++i)\n      roots[i << 1] = roots[i], roots[i << 1 | 1] = mu(roots[i], z);\n    base++;\n  }\n}\nvoid dft(std::vector<int>& a) {\n  int n = a.size(), zeros = __builtin_ctz(n);\n  ensure_base(zeros);\n  int shift = base - zeros;\n  for (int i = 0; i < n; ++i)\n    if (i < (rev[i] >> shift)) std::swap(a[i], a[rev[i] >> shift]);\n  for (int mid = 1; mid < n; mid <<= 1)\n    for (int i = 0; i < n; i += (mid << 1))\n      for (int j = 0; j < mid; ++j) {\n        int x = a[i + j], y = mu(a[i + j + mid], roots[mid + j]);\n        a[i + j] = ad(x, y);\n        a[i + j + mid] = su(x, y);\n      }\n}\nstd::vector<int> operator*(std::vector<int> a, std::vector<int> b) {\n  if (((int)(a).size()) <= 50 && ((int)(b).size()) <= 50) {\n    vector<int> c(((int)(a).size()) + ((int)(b).size()) - 1);\n    for (int i = (0); i <= (((int)(a).size()) - 1); ++i)\n      for (int j = (0); j <= (((int)(b).size()) - 1); ++j)\n        uad(c[i + j], mu(a[i], b[j]));\n    return c;\n  }\n  int need = a.size() + b.size() - 1, nbase = 0;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  dft(a);\n  dft(b);\n  int inv = po(size, P - 2);\n  for (int i = 0; i < size; ++i) a[i] = mu(a[i], mu(b[i], inv));\n  std::reverse(a.begin() + 1, a.end());\n  dft(a);\n  a.resize(need);\n  return a;\n}\n}  // namespace ntt\nusing ntt::operator*;\nconst int N = 100005;\nint T, n, K, deg[N], f[N], dp[N][2];\nint pp, lnk[N], nxt[N * 2], to[N * 2];\nvector<int> e;\nvoid ae(int k1, int k2) { to[++pp] = k2, nxt[pp] = lnk[k1], lnk[k1] = pp; }\nvector<int> prod(int l, int r) {\n  if (l == r) {\n    if (K == 1) return {ad(dp[e[l]][1], dp[e[l]][0])};\n    return {dp[e[l]][1], dp[e[l]][0]};\n  }\n  int mid = (l + r) >> 1;\n  auto res = prod(l, mid) * prod(mid + 1, r);\n  while (((int)(res).size()) > K) {\n    uad(res[((int)(res).size()) - 1 - K], res.back());\n    res.pop_back();\n  }\n  return res;\n}\nvoid dfs(int k1, int k2) {\n  for (int i = lnk[k1]; i; i = nxt[i])\n    if (to[i] != k2) {\n      dfs(to[i], k1);\n    }\n  dp[k1][0] = dp[k1][1] = 0;\n  if (deg[k1] >= K) {\n    e.clear();\n    int pos = 0, val = 1;\n    for (int i = lnk[k1]; i; i = nxt[i])\n      if (to[i] != k2) {\n        if (dp[to[i]][1] == 0) {\n          if (++pos == K) pos = 0;\n          val = mu(val, dp[to[i]][0]);\n        } else\n          e.push_back(to[i]);\n      }\n    if (e.empty()) {\n      dp[k1][0] = pos == 0 ? val : 0, dp[k1][1] = pos == K - 1 ? val : 0;\n    } else {\n      auto v = prod(0, ((int)(e).size()) - 1);\n      auto get = [&](int x) { return x < ((int)(v).size()) ? v[x] : 0; };\n      dp[k1][0] = mu(val, get((K - pos) % K)),\n      dp[k1][1] = mu(val, get((K - 1 - pos) % K));\n    }\n  } else {\n    dp[k1][0] = 1;\n    for (int i = lnk[k1]; i; i = nxt[i])\n      if (to[i] != k2) {\n        dp[k1][0] = mu(dp[k1][0], dp[to[i]][1]);\n      }\n  }\n}\nint main() {\n  rd(T);\n  while (T--) {\n    rd(n);\n    for (int i = (1); i <= (n); ++i) lnk[i] = 0, deg[i] = 0, f[i] = 0;\n    pp = 0;\n    for (int i = (2); i <= (n); ++i) {\n      int k1, k2;\n      rd(k1), rd(k2);\n      ae(k1, k2), ae(k2, k1);\n      ++deg[k1], ++deg[k2];\n    }\n    int lim = n;\n    for (int k1 = (1); k1 <= (n); ++k1)\n      for (int i = lnk[k1]; i; i = nxt[i]) {\n        lim = min(lim, max(deg[k1], deg[to[i]]));\n      }\n    for (K = 1; K <= lim; ++K)\n      if ((n - 1) * 2 % K == 0) {\n        dfs(1, 0);\n        f[K] = dp[1][0];\n      }\n    for (int i = (lim); i >= (1); --i) {\n      for (int j = i + i; j <= lim; j += i) {\n        usu(f[i], f[j]);\n      }\n    }\n    for (int i = (1); i <= (n); ++i) pt(f[i], i == n ? '\\n' : ' ');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> a;\nbool valido;\nvector<vector<long long>> adj;\nlong long d;\nvoid dfs(long long u, long long p = 0) {\n  if (!valido) return;\n  for (long long v : adj[u])\n    if (v != p) dfs(v, u);\n  if (a[u] % d == 0) {\n    a[p]++;\n  } else {\n    a[u]++;\n    if (p == 0 || a[u] % d != 0) valido = 0;\n  }\n}\nint32_t main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    a.resize(n + 1);\n    adj = vector<vector<long long>>(n + 1);\n    for (long long i = 0; i < n - 1; i++) {\n      long long a, b;\n      cin >> a >> b;\n      adj[a].push_back(b);\n      adj[b].push_back(a);\n    }\n    vector<long long> freq(n + 1);\n    freq[1] = 2;\n    for (long long i = 1; i < n - 1; i++) freq[1] = 2 * freq[1] % 998244353;\n    for (d = 2; d <= n - 1; d++) {\n      if ((n - 1) % d == 0) {\n        valido = 1;\n        fill(a.begin(), a.end(), 0);\n        dfs(1);\n        freq[d] = valido;\n      }\n    }\n    vector<long long> res(n + 1);\n    for (long long d = n; d >= 1; d--) {\n      res[d] = freq[d];\n      for (long long mult = 2 * d; mult <= n; mult += d) {\n        res[d] = res[d] - res[mult] + 998244353;\n        res[d] %= 998244353;\n      }\n    }\n    for (long long d = 1; d <= n; d++) {\n      cout << res[d] << ' ';\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid main0();\nint main() {\n  clock_t start, end;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  main0();\n  return 0;\n}\nconst int dx[8] = {0, 1, -1, 0, 1, 1, -1, -1};\nconst int dy[8] = {1, 0, 0, -1, 1, -1, -1, 1};\nconst int N = 2e5 + 5;\nconst int M = 1e5;\nconst int INF = 0x3f3f3f3f;\nconst long long INFF = 0x3f3f3f3f3f3f3f3f;\nconst int mod = 998244353;\nconst double eps = 1e-6;\nconst double Pi = acos(-1.0);\nmt19937 rnd(\n    (unsigned int)chrono::steady_clock::now().time_since_epoch().count());\nlong long qpow(long long n, long long m) {\n  long long ret = 1;\n  while (m) {\n    if (m & 1) ret = ret * n % mod;\n    n = n * n % mod;\n    m >>= 1;\n  }\n  return ret;\n}\nvector<int> e[N];\nint ans[N];\nint succ;\nint dfs(int k, int u, int fa) {\n  int cnt = 0;\n  for (int v : e[u])\n    if (v != fa) {\n      cnt += dfs(k, v, u);\n    }\n  if (cnt % k == 0) return 1;\n  if (cnt % k == k - 1) return 0;\n  succ = 0;\n  return 0;\n}\nvoid main0() {\n  int T;\n  cin >> T;\n  while (T--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n      e[i].clear();\n      ans[i] = (i == 1 ? qpow(2, n - 1) : 0);\n    }\n    for (int i = 1; i <= n - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      e[u].push_back(v);\n      e[v].push_back(u);\n    }\n    for (int i = 2; i <= n - 1; ++i)\n      if ((n - 1) % i == 0) {\n        succ = 1;\n        dfs(i, 1, -1);\n        if (succ) ans[1]--, ans[i]++;\n      }\n    for (int i = 2; i <= n; ++i)\n      if (ans[i]) {\n        for (int j = 2; i * j <= n; ++j)\n          if (ans[i * j]) {\n            ans[1]++, ans[i]--;\n            break;\n          }\n      }\n    ans[1] += mod;\n    ans[1] %= mod;\n    for (int i = 1; i <= n; ++i) {\n      cout << ans[i] << ' ';\n    }\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid main0();\nint main() {\n  clock_t start, end;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  main0();\n  return 0;\n}\nconst int dx[8] = {0, 1, -1, 0, 1, 1, -1, -1};\nconst int dy[8] = {1, 0, 0, -1, 1, -1, -1, 1};\nconst int N = 2e5 + 5;\nconst int M = 1e5;\nconst int INF = 0x3f3f3f3f;\nconst long long INFF = 0x3f3f3f3f3f3f3f3f;\nconst int mod = 998244353;\nconst double eps = 1e-6;\nconst double Pi = acos(-1.0);\nmt19937 rnd(\n    (unsigned int)chrono::steady_clock::now().time_since_epoch().count());\nlong long qpow(long long n, long long m) {\n  long long ret = 1;\n  while (m) {\n    if (m & 1) ret = ret * n % mod;\n    n = n * n % mod;\n    m >>= 1;\n  }\n  return ret;\n}\nvector<int> e[N];\nint ans[N];\nint succ;\nint dfs(int k, int u, int fa) {\n  int cnt = 0;\n  for (int v : e[u])\n    if (v != fa) {\n      cnt += dfs(k, v, u);\n    }\n  if (cnt % k == 0) return 1;\n  if (cnt % k == k - 1) return 0;\n  succ = 0;\n  return 0;\n}\nvoid main0() {\n  int T;\n  cin >> T;\n  while (T--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n      e[i].clear();\n      ans[i] = (i == 1 ? qpow(2, n - 1) : 0);\n    }\n    for (int i = 1; i <= n - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      e[u].push_back(v);\n      e[v].push_back(u);\n    }\n    for (int i = 2; i <= n - 1; ++i)\n      if ((n - 1) % i == 0) {\n        succ = 1;\n        dfs(i, 1, -1);\n        if (succ) ans[1]--, ans[i]++;\n      }\n    for (int i = n; i >= 2; --i) {\n      for (int j = 2; i * j <= n; ++j) {\n        ans[i] -= ans[i * j];\n        ans[1] += ans[i * j];\n      }\n    }\n    ans[1] += mod;\n    ans[1] %= mod;\n    for (int i = 1; i <= n; ++i) {\n      cout << ans[i] << ' ';\n    }\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e5 + 7;\nconst int MOD = 998244353;\nint t;\nint n;\nvector<int> G[MAX];\nint f[MAX], k;\nbool dfs(int u, int fa) {\n  f[u] = 0;\n  if (u != 1 && G[u].size() == 1) return true;\n  for (auto v : G[u]) {\n    if (v == fa) continue;\n    if (dfs(v, u)) f[u]++;\n  }\n  if (fa && f[u] % k != 0) {\n    f[u]++;\n    return false;\n  }\n  return true;\n}\nint qw[MAX];\nint ans[MAX];\nint main() {\n  ios::sync_with_stdio(false), cin.tie(NULL);\n  qw[0] = 1;\n  for (int i = 1; i <= 100000; i++) qw[i] = qw[i - 1] * 2 % MOD;\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (int i = 1; i <= n; i++) G[i].clear(), ans[i] = 0;\n    for (int i = 1; i < n; i++) {\n      int u, v;\n      cin >> u >> v;\n      G[u].push_back(v), G[v].push_back(u);\n    }\n    ans[1] = qw[n - 1];\n    for (int i = 2; i < n; i++) {\n      if ((n - 1) % i != 0) continue;\n      k = i;\n      dfs(1, 0);\n      int fg = 0;\n      for (int j = 1; j <= n; j++)\n        if (f[j] % i) {\n          fg = 1;\n          break;\n        }\n      if (!fg) ans[i]++;\n    }\n    for (int i = n; i >= 1; i--) {\n      for (int j = 2 * i; j <= n; j += i) ans[i] -= ans[j];\n    }\n    for (int i = 1; i <= n; i++) cout << ans[i] << \" \";\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import deque\nimport sys\ninput = sys.stdin.readline\ndef NC_Dij(lis,start):\n    ret = [float(\"inf\")] * len(lis);ret[start] = 0;q = deque([start]);plis = [i for i in range(len(lis))]\n    while len(q) > 0:\n        now = q.popleft()\n        for nex in lis[now]:\n            if ret[nex] > ret[now] + 1:ret[nex] = ret[now] + 1;plis[nex] = now;q.append(nex)\n    return ret,plis\ndef search(k):\n    enum = [len(lis[i]) for i in range(n)];able = [True] * n\n    for d,v in dv:\n        able[v] = False\n        for nex in lis[v]:\n            if able[nex] and enum[v] % k != 0:enum[v] -= 1\n            elif able[nex]:enum[nex] -= 1\n        if enum[v] % k != 0:return False\n    return True\nmod = 998244353\nfor loop in range(int(input())):\n    n = int(input());lis = [ [] for i in range(n) ];enum = [0] * n\n    for i in range(n-1):u,v = map(int,input().split());u -= 1;v -= 1;lis[u].append(v);lis[v].append(u);enum[u] += 1;enum[v] += 1\n    if n == 2:print (2,0);continue\n    for i in range(n):\n        if len(lis[i]) == 1:\n            for nex in lis[i]:enum[nex] -= 1\n    mins = float(\"inf\")\n    for i in range(n):\n        if enum[i] <= 1 and len(lis[i]) != 1:mins = len(lis[i]) - enum[i]\n    dlis,tmp = NC_Dij(lis,0);dv = [(dlis[i],i) for i in range(n)];dv.sort();dv.reverse();ps = set();ans = [0] * (n+1)\n    for i in range(1,int(mins**0.5+10)):\n        if mins % i == 0:ps.add(i);ps.add(mins//i)\n        if (mins+1) % i == 0:ps.add(i);ps.add((mins+1)//i)\n    for p in ps:\n        if p != 1 and search(p):ans[p] = 1\n    for i in range(n+1):\n        if ans[i] == 1:\n            for j in range(2*i,n+1,i):\n                if ans[j] == 1:ans[i] = 0;break\n    ans[1] = ( pow(2,n-1,mod) - sum(ans) ) % mod;print (*ans[1:])"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ninline char gc() {\n  static const int L = 23333;\n  static char sxd[L], *sss = sxd, *ttt = sxd;\n  if (sss == ttt) {\n    ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n    if (sss == ttt) {\n      return EOF;\n    }\n  }\n  return *sss++;\n}\ntemplate <class T>\ninline bool read(T& x) {\n  x = 0;\n  char c = gc();\n  bool flg = false;\n  for (; !isdigit(c); c = gc()) {\n    if (c == '-') {\n      flg = true;\n    } else if (c == EOF) {\n      return false;\n    }\n  }\n  for (; isdigit(c); c = gc()) {\n    x = (x * 10) + (c ^ 48);\n  }\n  if (flg) {\n    x = -x;\n  }\n  return true;\n}\ntemplate <class T>\ninline void write(T x) {\n  if (x < 0) {\n    x = -x;\n    putchar('-');\n  }\n  if (x > 9) {\n    write(x / 10);\n    x %= 10;\n  }\n  putchar(x | 48);\n}\ntemplate <class T>\ninline void writeln(T x) {\n  write(x);\n  puts(\"\");\n}\ntemplate <class T>\ninline void writesp(T x) {\n  write(x);\n  putchar(' ');\n}\nusing namespace std;\nconst int maxn = 100005;\nint gcd(int a, int b) {\n  while (b) {\n    int t = a % b;\n    a = b;\n    b = t;\n  }\n  return a;\n}\nint n;\nstruct Edge {\n  int to, nxt;\n} e[maxn << 1];\nint first[maxn];\nint du[maxn];\nint dubk[maxn];\nint cnt;\nvoid add_edge(int u, int v) {\n  du[u]++, du[v]++;\n  e[++cnt].nxt = first[u];\n  first[u] = cnt;\n  e[cnt].to = v;\n  e[++cnt].nxt = first[v];\n  first[v] = cnt;\n  e[cnt].to = u;\n}\nint final_ans[maxn];\nvoid init() {\n  cnt = 0;\n  for (int i = 1; i <= n; ++i) {\n    first[i] = du[i] = final_ans[i] = 0;\n  }\n}\nbool np[maxn];\nint factor[maxn];\nint prime[maxn];\nvoid oula(const int n = 100000) {\n  np[1] = true;\n  int cnt = 0;\n  for (int i = 2; i <= n; ++i) {\n    if (!np[i]) {\n      prime[++cnt] = i;\n      factor[i] = i;\n    }\n    for (int j = 1; j <= cnt && (long long)i * prime[j] <= n; ++j) {\n      np[i * prime[j]] = true;\n      factor[i * prime[j]] = prime[j];\n      if (!(i % prime[j])) {\n        break;\n      }\n    }\n  }\n}\nbool vis[maxn];\nint nn[maxn];\nint bfs(int xx) {\n  for (int i = 1; i <= n; ++i) {\n    vis[i] = false;\n    nn[i] = du[i] = dubk[i];\n  }\n  queue<int> q;\n  while (!q.empty()) {\n    q.pop();\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (du[i] <= 1) {\n      q.push(i);\n      vis[i] = true;\n    }\n  }\n  int ans = n - 1;\n  while (!q.empty()) {\n    int now = q.front();\n    q.pop();\n    bool flg = false;\n    if (du[now]) {\n      int tmpans = gcd(ans, nn[now]);\n      if (tmpans % xx) {\n        nn[now]--;\n        ans = gcd(ans, nn[now]);\n      } else {\n        ans = tmpans;\n        flg = true;\n      }\n    } else {\n      ans = gcd(ans, nn[now]);\n    }\n    if (ans % xx) {\n      return 1;\n    }\n    for (int i = first[now]; i; i = e[i].nxt) {\n      int to = e[i].to;\n      if (!vis[to]) {\n        du[to]--;\n        if (flg) {\n          nn[to]--;\n        }\n        if (du[to] <= 1) {\n          q.push(to);\n          vis[to] = true;\n        }\n      }\n    }\n  }\n  return ans;\n}\nconst int mod = 998244353;\nint ksm(int a, int b) {\n  int ans = 1;\n  for (; b; b >>= 1, a = (long long)a * a % mod) {\n    if (b & 1) {\n      ans = (long long)ans * a % mod;\n    }\n  }\n  return ans;\n}\nvoid solve() {\n  read(n);\n  init();\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    read(u), read(v);\n    add_edge(u, v);\n  }\n  for (int i = 1; i <= n; ++i) {\n    dubk[i] = du[i];\n  }\n  int tt = n - 1;\n  int tmpans = 0;\n  while (tt > 1) {\n    int pme = factor[tt];\n    while (!(tt % pme)) {\n      tt /= pme;\n    }\n    int nowans = bfs(pme);\n    if (nowans > 1 && !final_ans[nowans]) {\n      final_ans[nowans] = 1;\n      tmpans++;\n    }\n  }\n  final_ans[1] = ksm(2, n - 1) - tmpans;\n  if (final_ans[1] < 0) {\n    final_ans[1] += mod;\n  }\n  for (int i = 1; i <= n; ++i) {\n    writesp(final_ans[i]);\n  }\n  puts(\"\");\n}\nint main() {\n  oula();\n  int T;\n  read(T);\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import deque\nimport sys\ninput = sys.stdin.readline\ndef NC_Dij(lis,start):\n    ret = [float(\"inf\")] * len(lis);ret[start] = 0;q = deque([start]);plis = [i for i in range(len(lis))]\n    while len(q) > 0:\n        now = q.popleft()\n        for nex in lis[now]:\n            if ret[nex] > ret[now] + 1:ret[nex] = ret[now] + 1;plis[nex] = now;q.append(nex)\n    return ret,plis\ndef search(k):\n    enum = [len(lis[i]) for i in range(n)];able = [True] * n\n    for d,v in dv:\n        able[v] = False\n        for nex in lis[v]:\n            if able[nex] and enum[v] % k != 0:enum[v] -= 1\n            elif able[nex]:enum[nex] -= 1\n        if enum[v] % k != 0:return False\n    return True\nmod = 998244353\nfor loop in range(int(input())):\n    n = int(input());lis = [ [] for i in range(n) ];enum = [0] * n\n    for i in range(n-1):u,v = map(int,input().split());u -= 1;v -= 1;lis[u].append(v);lis[v].append(u);enum[u] += 1;enum[v] += 1\n    if n == 2:print (2,0);continue\n    for i in range(n):\n        if len(lis[i]) == 1:\n            for nex in lis[i]:enum[nex] -= 1\n\n    mins = float(\"inf\")\n    for i in range(n):\n        if enum[i] <= 1 and len(lis[i]) != 1:mins = len(lis[i]) - enum[i]\n\n\n    dlis,tmp = NC_Dij(lis,0)\n    dv = [(dlis[i],i) for i in range(n)]\n    dv.sort()\n    dv.reverse()\n\n    ps = set()\n    for i in range(1,int(mins**0.5+10)):\n        if mins % i == 0:\n            ps.add(i)\n            ps.add(mins//i)\n        if (mins+1) % i == 0:\n            ps.add(i)\n            ps.add((mins+1)//i)\n\n    ans = [0] * (n+1)\n    for p in ps:\n        if p != 1 and search(p):\n            ans[p] = 1\n\n    for i in range(n+1):\n        if ans[i] == 1:\n            for j in range(2*i,n+1,i):\n                if ans[j] == 1:\n                    ans[i] = 0\n                    break\n\n    ans[1] = ( pow(2,n-1,mod) - sum(ans) ) % mod\n    print (*ans[1:])\n\n"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nfrom sys import stdin\n\nfrom collections import deque\ndef NC_Dij(lis,start):\n\n    ret = [float(\"inf\")] * len(lis)\n    ret[start] = 0\n    \n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n\n    while len(q) > 0:\n        now = q.popleft()\n\n        for nex in lis[now]:\n\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n    return ret,plis\n\ndef search(k):\n\n    enum = [len(lis[i]) for i in range(n)]\n    able = [True] * n\n\n    for d,v in dv:\n        able[v] = False\n        for nex in lis[v]:\n            if able[nex] and enum[v] % k != 0:\n                enum[v] -= 1\n            elif able[nex]:\n                enum[nex] -= 1\n    \n        if enum[v] % k != 0:\n            return False\n\n    return True\n    \nmod = 998244353\ntt = int(stdin.readline())\n\nfor loop in range(tt):\n\n    n = int(stdin.readline())\n\n    lis = [ [] for i in range(n) ]\n\n    enum = [0] * n\n    for i in range(n-1):\n        u,v = map(int,stdin.readline().split())\n        u -= 1\n        v -= 1\n        lis[u].append(v)\n        lis[v].append(u)\n        enum[u] += 1\n        enum[v] += 1\n\n    if n == 2:\n        print (2,0)\n        continue\n\n    \n    for i in range(n):\n        if len(lis[i]) == 1:\n            for nex in lis[i]:\n                enum[nex] -= 1\n    \n    mins = float(\"inf\")\n    for i in range(n):\n        if enum[i] <= 1 and len(lis[i]) != 1:\n            mins = len(lis[i]) - enum[i]\n\n\n    dlis,tmp = NC_Dij(lis,0)\n    dv = [(dlis[i],i) for i in range(n)]\n    dv.sort()\n    dv.reverse()\n\n    ps = set()\n    for i in range(1,int(mins**0.5+10)):\n        if mins % i == 0:\n            ps.add(i)\n            ps.add(mins//i)\n        if (mins+1) % i == 0:\n            ps.add(i)\n            ps.add((mins+1)//i)\n\n    ans = [0] * (n+1)\n    for p in ps:\n        if p != 1 and (n-1) % p == 0 and search(p):\n            ans[p] = 1\n\n    for i in range(n+1):\n        if ans[i] == 1:\n            for j in range(2*i,n+1,i):\n                if ans[j] == 1:\n                    ans[i] = 0\n                    break\n\n    ans[1] = ( pow(2,n-1,mod) - sum(ans) ) % mod\n    print (*ans[1:])\n    \n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nconst double PI = acos(-1);\ntemplate <class A, class B>\nstd::ostream& operator<<(std::ostream& st, const std::pair<A, B> p) {\n  st << \"(\" << p.first << \", \" << p.second << \")\";\n  return st;\n}\nvoid tc();\nauto test_cases = []() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) tc();\n};\nusing namespace std;\nconst int mod = 998244353;\nint add(int a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n  if (a < 0) a += mod;\n  return a;\n}\nint mul(int a, int b) { return (a * (long long)b) % mod; }\nvector<std::vector<int> > G;\nint n;\nstd::pair<int, int> dfs(int u, int p, int m) {\n  int ctr = 0;\n  for (int v : G[u])\n    if (v != p) {\n      auto [c, e] = dfs(v, u, m);\n      if (!c) return std::pair<int, int>(0, 0);\n      ctr += 1 - e;\n    }\n  if (ctr % m == 0) return std::pair<int, int>(1, 0);\n  if ((ctr + 1) % m == 0) return std::pair<int, int>(1, 1);\n  return std::pair<int, int>(0, 0);\n}\nint solve(int k) {\n  if ((n - 1) % k) return 0;\n  if (k == 1) {\n    int ret = 1;\n    for (int i = 0; i < (n - 1); i++) ret = mul(ret, 2);\n    return ret;\n  }\n  return dfs(1, 0, k).first;\n}\nint g[1 << 20];\nvoid tc() {\n  scanf(\"%d\", &n);\n  G.clear();\n  G.resize(n + 1);\n  for (int e = 0; e < (n - 1); e++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  for (int k = n; k >= 1; k--) {\n    g[k] = solve(k);\n    for (int s = 2 * k; s <= n; s += k) g[k] = add(g[k], -g[s]);\n  }\n  for (int k = 1; k <= n; k++) printf(\"%d%c\", g[k], \" \\n\"[k == n]);\n}\nint main() {\n  test_cases();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nbool dfs(vector<int> adj[], int p, int c, int a[], int k, bool &isposs) {\n  a[c] = 0;\n  for (auto u : adj[c])\n    if (u != p) {\n      bool f = dfs(adj, c, u, a, k, isposs);\n      if (!f) {\n        a[c]++;\n      }\n    }\n  if (a[c] % k && p != -1) {\n    a[c]++;\n    if (a[c] % k) {\n      isposs = false;\n    }\n    return true;\n  }\n  if (p == -1 && a[c] % k) {\n    isposs = false;\n  }\n  return false;\n}\nlong long fastexp(long long n, long long k) {\n  if (k == 0)\n    return 1;\n  else if (k % 2)\n    return (fastexp(n, k - 1) * n) % mod;\n  else {\n    long long w = fastexp(n, k / 2);\n    return (w * w) % mod;\n  }\n}\nvector<int> facts[100001];\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  for (int i = 2; i <= 100000; i++) {\n    for (int j = 2 * i; j <= 100000; j += i) {\n      facts[j].push_back(i);\n    }\n  }\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> adj[n];\n    int a[n];\n    for (int i = 0; i < n - 1; i++) {\n      int u, v;\n      cin >> u >> v;\n      u--;\n      v--;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n    int ans[n + 1];\n    for (int i = 1; i <= n; i++) {\n      ans[i] = 0;\n    }\n    ans[1] = fastexp(2, n - 1);\n    for (auto f : facts[n - 1]) {\n      bool ths = true;\n      dfs(adj, -1, 0, a, f, ths);\n      ans[f] = ths;\n    }\n    if (n != 2) {\n      bool ths = true;\n      dfs(adj, -1, 0, a, n - 1, ths);\n      ans[n - 1] = ths;\n    }\n    for (int j = n - 1; j >= 2; j--) {\n      for (auto f : facts[j]) {\n        ans[f] -= ans[j];\n      }\n      ans[1] = (ans[1] - ans[j] + mod) % mod;\n    }\n    for (int i = 1; i <= n; i++) {\n      cout << ans[i] << \" \";\n    }\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\n\npublic class CF_1554_E{\n    //SOLUTION BEGIN\n    long MOD = 998244353;\n    void pre() throws Exception{}\n    void solve(int TC) throws Exception{\n        int N = ni();\n        int[] from = new int[N-1], to = new int[N-1];\n        for(int i = 0; i< N-1; i++){\n            from[i] = ni()-1;\n            to[i] = ni()-1;\n        }\n        int[][] g = make(N, N-1, from, to, true);\n        long[] ans = new long[1+N];\n        for(int x = N-1; x >= 2; x--){\n            if((N-1)%x != 0)continue;\n            ans[x] = calc(g, x)?1:0;\n            for(int y = 2*x; y <= N-1; y += x){\n                ans[x] -= ans[y];\n                if(ans[x] < 0)ans[x] += MOD;\n            }\n        }\n        ans[1] = 1;\n        for(int i = 1; i<= N-1; i++)ans[1] = ans[1]*2%MOD;\n        for(int j = 2; j <= N-1; j++){\n            ans[1] -= ans[j];\n            if(ans[1] < 0)ans[1] += MOD;\n        }\n        for(int i = 1; i<= N; i++)p(ans[i]);\n        pn(\"\");\n    }\n    boolean calc(int[][] g, int x){\n        int[] val = new int[g.length];\n        if(!dfs(g, val, 0, -1, x))return false;\n        return val[0]%x == 0;\n    }\n    boolean dfs(int[][] g, int[] val, int u, int p, int x){\n        boolean f = true;\n        for(int v:g[u])if(v != p)f &= dfs(g, val, v, u, x);\n\n        if(p == -1 || !f)return f;\n        if(val[u]%x == 0){\n            val[p]++;\n            return true;\n        }\n        if((val[u]+1)%x == 0)return f;\n        return false;\n    }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(\"Hold right there, Sparky!\");}\n    void exit(boolean b){if(!b)System.exit(0);}\n    static void dbg(Object... o){System.err.println(Arrays.deepToString(o));}\n    final long IINF = (long)1e17;\n    final int INF = (int)1e9+2;\n    DecimalFormat df = new DecimalFormat(\"0.00000000000\");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-8;\n    static boolean multipleTC = true, memory = true, fileIO = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        long ct = System.currentTimeMillis();\n        if (fileIO) {\n            in = new FastReader(\"\");\n            out = new PrintWriter(\"\");\n        } else {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n        }\n        //Solution Credits: Taranpreet Singh\n        int T = multipleTC? ni():1;\n        pre();\n        for (int t = 1; t <= T; t++) solve(t);\n        out.flush();\n        out.close();\n        System.err.println(System.currentTimeMillis() - ct);\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new CF_1554_E().run();}catch(Exception e){e.printStackTrace();System.exit(1);}}}, \"1\", 1 << 28).start();\n        else new CF_1554_E().run();\n    }\n    int[][] make(int n, int e, int[] from, int[] to, boolean f){\n        int[][] g = new int[n][];int[]cnt = new int[n];\n        for(int i = 0; i< e; i++){\n            cnt[from[i]]++;\n            if(f)cnt[to[i]]++;\n        }\n        for(int i = 0; i< n; i++)g[i] = new int[cnt[i]];\n        for(int i = 0; i< e; i++){\n            g[from[i]][--cnt[from[i]]] = to[i];\n            if(f)g[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return g;\n    }\n    int[][][] makeS(int n, int e, int[] from, int[] to, boolean f){\n        int[][][] g = new int[n][][];int[]cnt = new int[n];\n        for(int i = 0; i< e; i++){\n            cnt[from[i]]++;\n            if(f)cnt[to[i]]++;\n        }\n        for(int i = 0; i< n; i++)g[i] = new int[cnt[i]][];\n        for(int i = 0; i< e; i++){\n            g[from[i]][--cnt[from[i]]] = new int[]{to[i], i, 0};\n            if(f)g[to[i]][--cnt[to[i]]] = new int[]{from[i], i, 1};\n        }\n        return g;\n    }\n    int find(int[] set, int u){return set[u] = (set[u] == u?u:find(set, set[u]));}\n    int digit(long s){int ans = 0;while(s>0){s/=10;ans++;}return ans;}\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object... o){for(Object oo:o)out.print(oo+\" \");}\n    void pn(Object... o){for(int i = 0; i< o.length; i++)out.print(o[i]+(i+1 < o.length?\" \":\"\\n\"));}\n    void pni(Object... o){for(Object oo:o)out.print(oo+\" \");out.println();out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n\n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() throws Exception{\n            String str;\n            try{\n                str = br.readLine();\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long PosMod(long long a) { return a >= 0 ? a : a + 998244353; }\nlong long AddMod(long long a, long long b) {\n  return PosMod((a + b) % 998244353);\n}\nlong long MultMod(long long a, long long b) {\n  return PosMod((a * b) % 998244353);\n}\nlong long powll(long long a, long long n) {\n  long long r = 1;\n  for (long long b = n; b > 0; b >>= 1, a = MultMod(a, a))\n    if (b & 1) r = MultMod(r, a);\n  return r;\n}\nvector<vector<int>> adj;\nbool fail;\nint dfs(int here, int p, int targetK) {\n  if (fail) return 0;\n  int incoming = 0;\n  for (int there : adj[here]) {\n    if (there == p) continue;\n    incoming += dfs(there, here, targetK);\n  }\n  if (incoming % targetK == 0)\n    return 1;\n  else if ((incoming + 1) % targetK == 0 && here != 1)\n    return 0;\n  else {\n    fail = true;\n    return 0;\n  }\n}\nint n;\nvoid solve() {\n  cin >> n;\n  adj = vector<vector<int>>(n + 1);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    adj[v].push_back(u);\n    adj[u].push_back(v);\n  }\n  vector<long long> f = vector<long long>(n + 1);\n  f[1] = powll(2, (long long)n - 1);\n  for (int k = 2; k <= n - 1; k++) {\n    if ((n - 1) % k != 0) continue;\n    fail = false;\n    dfs(1, 0, k);\n    f[k] = fail ? 0 : 1;\n  }\n  vector<long long> h = vector<long long>(n + 1);\n  h[1] = f[1];\n  for (int i = 2; i <= n; i++) {\n    long long val = f[i];\n    if (val > 0) {\n      for (int k = 2; i * k <= n; k++) {\n        if (f[i * k]) val = 0;\n      }\n    }\n    h[i] = val;\n    h[1] -= val;\n  }\n  for (int i = 1; i <= n; i++) {\n    printf(\"%lld \", h[i]);\n  }\n  printf(\"\\n\");\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nconst long long mod = 998244353;\ninline long long gcd(long long a, long long b) {\n  return !b ? a : gcd(b, a % b);\n}\ninline long long q_pow(long long a, long long x) {\n  long long ans = 1, tmp = a;\n  while (x) {\n    if (x & 1) (ans *= tmp) %= mod;\n    (tmp *= tmp) %= mod;\n    x >>= 1;\n  }\n  return ans;\n}\ntemplate <typename T>\ninline void re(T &N) {\n  int f = 1;\n  char c;\n  while ((c = getchar()) < '0' || c > '9')\n    if (c == '-') f = -1;\n  N = c - '0';\n  while ((c = getchar()) >= '0' && c <= '9') N = N * 10 + c - '0';\n  N *= f;\n}\ntemplate <class T, class... T_>\ninline void re(T &x, T_ &...y) {\n  re(x), re(y...);\n}\nint m, n, t = 1, st, en;\nstruct edge {\n  int to, nxt;\n} e[N << 1];\nint head[N];\ninline void add(int x, int y) {\n  e[++t] = {y, head[x]};\n  head[x] = t;\n  e[++t] = {x, head[y]};\n  head[y] = t;\n}\nint a[N], ok = 1;\nvoid dfs(int x, int p, int k) {\n  a[x] = 0;\n  for (int i = head[x]; i; i = e[i].nxt) {\n    int to = e[i].to;\n    if (to == p) continue;\n    dfs(to, x, k);\n    if (a[to] % k)\n      a[to]++;\n    else\n      a[x]++;\n    if (a[to] % k) ok = 0;\n  }\n}\nint check(int k) {\n  ok = 1;\n  dfs(1, 0, k);\n  if (a[1] % k) ok = 0;\n  return ok;\n}\nint p[N], v[N], ma_p[N], mi_p[N];\nint phi[N], miu[N];\nvoid get_prime() {\n  phi[1] = miu[1] = 1;\n  ma_p[1] = mi_p[1] = 1;\n  for (int i = 2; i <= N - 1; i++) {\n    if (!v[i])\n      v[i] = i, p[++p[0]] = i, mi_p[i] = ma_p[i] = i, phi[i] = i - 1,\n      miu[i] = -1;\n    for (int j = 1; j <= p[0]; j++) {\n      if (p[j] > v[i] || p[j] > (N - 1) / i) break;\n      int nxt = i * p[j];\n      v[nxt] = p[j];\n      ma_p[nxt] = ma_p[i];\n      mi_p[nxt] = p[j];\n      phi[nxt] = phi[i] * (i % p[j] ? p[j] - 1 : p[j]);\n      miu[nxt] = miu[i] * (i % p[j] ? -1 : 0);\n    }\n  }\n}\nlong long f[N], g[N];\nint main() {\n  get_prime();\n  int T;\n  re(T);\n  while (T--) {\n    re(n);\n    t = 1;\n    for (int i = 1; i <= n; i++) head[i] = f[i] = g[i] = 0;\n    for (int i = 1; i < n; i++) {\n      int x, y;\n      re(x, y);\n      add(x, y);\n    }\n    if (n == 2) {\n      puts(\"2 0\");\n      continue;\n    }\n    f[1] = q_pow(2, n - 1);\n    f[n - 1] = check(n - 1);\n    for (int i = 2; i * i <= n - 1; i++)\n      if (!((n - 1) % i)) {\n        f[i] = check(i);\n        f[(n - 1) / i] = check((n - 1) / i);\n      }\n    for (int i = 1; i <= n; i++)\n      for (int j = i; j <= n; j += i) g[i] += miu[j / i] * f[j];\n    for (int i = 1; i <= n; i++) printf(\"%lld \", (g[i] % mod + mod) % mod);\n    puts(\"\");\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nfrom sys import stdin\n\nfrom collections import deque\ndef NC_Dij(lis,start):\n\n    ret = [float(\"inf\")] * len(lis)\n    ret[start] = 0\n    \n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n\n    while len(q) > 0:\n        now = q.popleft()\n\n        for nex in lis[now]:\n\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n    return ret,plis\n\ndef search(k):\n\n    enum = [len(lis[i]) for i in range(n)]\n    able = [True] * n\n\n    for d,v in dv:\n        able[v] = False\n        for nex in lis[v]:\n            if able[nex] and enum[v] % k != 0:\n                enum[v] -= 1\n            elif able[nex]:\n                enum[nex] -= 1\n    \n        if enum[v] % k != 0:\n            return False\n\n    return True\n    \nmod = 998244353\ntt = int(stdin.readline())\n\nfor loop in range(tt):\n\n    n = int(stdin.readline())\n\n    lis = [ [] for i in range(n) ]\n\n    enum = [0] * n\n    for i in range(n-1):\n        u,v = map(int,stdin.readline().split())\n        u -= 1\n        v -= 1\n        lis[u].append(v)\n        lis[v].append(u)\n        enum[u] += 1\n        enum[v] += 1\n\n    if n == 2:\n        print (2,0)\n        continue\n\n    \n    for i in range(n):\n        if len(lis[i]) == 1:\n            for nex in lis[i]:\n                enum[nex] -= 1\n    \n    mins = float(\"inf\")\n    for i in range(n):\n        if enum[i] <= 1 and len(lis[i]) != 1:\n            mins = len(lis[i]) - enum[i]\n\n\n    dlis,tmp = NC_Dij(lis,0)\n    dv = [(dlis[i],i) for i in range(n)]\n    dv.sort()\n    dv.reverse()\n\n    ps = set()\n    for i in range(1,int(mins**0.5+10)):\n        if mins % i == 0:\n            ps.add(i)\n            ps.add(mins//i)\n        if (mins+1) % i == 0:\n            ps.add(i)\n            ps.add((mins+1)//i)\n\n    ans = [0] * (n+1)\n    for p in ps:\n        if p != 1 and search(p):\n            ans[p] = 1\n\n    for i in range(n+1):\n        if ans[i] == 1:\n            for j in range(2*i,n+1,i):\n                if ans[j] == 1:\n                    ans[i] = 0\n                    break\n\n    ans[1] = ( pow(2,n-1,mod) - sum(ans) ) % mod\n    print (*ans[1:])\n    \n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 1e5, MOD = 998244353;\nint n, ecnt, head[MAXN + 5], f[MAXN + 5];\nstruct Edge {\n  int to, nxt;\n} graph[MAXN * 2 + 5];\ninline void subeq(int& a, const int b) { (a -= b) < 0 && (a += MOD); }\ninline int mul(const int a, const int b) { return int(1ll * a * b % MOD); }\ninline int mpow(int a, int b) {\n  int ret = 1;\n  for (; b; a = mul(a, a), b >>= 1) ret = mul(ret, b & 1 ? a : 1);\n  return ret;\n}\ninline void link(const int u, const int v) {\n  graph[++ecnt] = {v, head[u]}, head[u] = ecnt;\n  graph[++ecnt] = {u, head[v]}, head[v] = ecnt;\n}\ninline bool check(const int u, const int fa, const int k) {\n  static int val[MAXN + 5];\n  val[u] = 0;\n  for (int i = head[u], v; i; i = graph[i].nxt) {\n    if ((v = graph[i].to) != fa) {\n      if (!check(v, u, k)) return false;\n    }\n  }\n  if (val[u] % k) {\n    if (!fa || (val[u] + 1) % k) return false;\n  } else if (fa)\n    ++val[fa];\n  return true;\n}\ninline void allClear() {\n  ecnt = 0;\n  for (int i = 1, repi = n; i <= repi; ++i) head[i] = 0;\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d\", &n), allClear();\n    for (int i = 2, repi = n; i <= repi; ++i) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      link(u, v);\n    }\n    f[1] = mpow(2, n - 1);\n    for (int i = 2, repi = n - 1; i <= repi; ++i)\n      f[i] = !((n - 1) % i) && check(1, 0, i);\n    f[n] = 0;\n    for (int i = n, peri = 1; i >= peri; --i)\n      for (int j = 2, repj = n / i; j <= repj; ++j) subeq(f[i], f[i * j]);\n    for (int i = 1, repi = n; i <= repi; ++i)\n      printf(\"%d%c\", f[i], i < n ? ' ' : '\\n');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nvector<int> v[100010];\nint n, m, now, ans;\nint a[100010];\nbool flag;\nint gcd(int x, int y) { return y == 0 ? x : gcd(y, x % y); }\nint dfs(int x, int f) {\n  if (flag) return 0;\n  int sum = v[x].size();\n  for (int i = 0; i < v[x].size(); i++)\n    if (v[x][i] != f) sum -= dfs(v[x][i], x);\n  if (sum % now && (sum - 1) % now) {\n    ans = 1;\n    flag = true;\n    return 0;\n  }\n  if (sum % now == 0) {\n    ans = gcd(ans, sum);\n    return 1;\n  }\n  ans = gcd(ans, sum - 1);\n  return 0;\n}\nint main() {\n  int t, x, y;\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n      scanf(\"%d%d\", &x, &y);\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n    m = n - 1;\n    for (now = 2; now <= sqrt(m); now++)\n      if (m % now == 0) {\n        ans = 0;\n        flag = 0;\n        dfs(1, -1);\n        a[ans] = 1;\n        while (m % now == 0) m /= now;\n      }\n    if (m > 1) {\n      ans = 0;\n      flag = 0;\n      now = m;\n      dfs(1, -1);\n      a[ans] = 1;\n    }\n    a[1] = 1;\n    for (int i = 1; i < n; i++) a[1] = a[1] * 2 % mod;\n    for (int i = 2; i < n; i++) a[1] = (a[1] - a[i] + mod) % mod;\n    for (int i = 1; i <= n; i++) printf(\"%d \", a[i]);\n    printf(\"\\n\");\n    for (int i = 1; i <= n; i++) v[i].clear(), a[i] = 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nconst int P = 998244353;\nint T, n;\nint ans[N];\nvector<int> e[N];\nint f[N];\nbool dfs(int x, int fa, int y) {\n  for (auto v : e[x])\n    if (v != fa && !dfs(v, x, y)) return 0;\n  if (f[x] % y == 0) {\n    f[fa]--;\n    return 1;\n  }\n  f[x]--;\n  if (f[x] % y == 0) return 1;\n  return 0;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  cin >> T;\n  while (T--) {\n    cin >> n;\n    for (int i = 1; i <= n; i++) e[i].clear();\n    for (int i = 1; i < n; i++) {\n      int u, v;\n      cin >> u >> v;\n      e[u].push_back(v);\n      e[v].push_back(u);\n    }\n    if (n == 2) {\n      cout << 2 << \" \" << 0 << \"\\n\";\n    } else {\n      int rt = 0;\n      for (int i = 1; i <= n; i++)\n        if (((int)e[i].size()) > 1) rt = i;\n      for (int i = 1; i <= n; i++) ans[i] = 0;\n      for (int i = 1; i * i <= (n - 1); i++) {\n        if ((n - 1) % i) continue;\n        for (int j = 1; j <= n; j++) f[j] = ((int)e[j].size());\n        if (dfs(rt, 0, i)) ans[i] = 1;\n        for (int j = 1; j <= n; j++) f[j] = ((int)e[j].size());\n        if (dfs(rt, 0, (n - 1) / i)) ans[(n - 1) / i] = 1;\n      }\n      for (int i = 2; i <= n; i++)\n        for (int j = i + i; j <= n; j += i)\n          if (ans[j]) ans[i] = 0;\n      for (int i = 1; i < n; i++) ans[1] = 2 * ans[1] % P;\n      for (int i = 2; i <= n; i++) ans[1] = (ans[1] - ans[i] + P) % P;\n      for (int i = 1; i <= n; i++) cout << ans[i] << \" \\n\"[i == n];\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long t;\nvector<long long> adj[100001];\nlong long ss[100001];\nvoid dfs(long long no, long long par = -1) {\n  ss[no] = 1;\n  for (auto j : adj[no]) {\n    if (j != par) {\n      dfs(j, no);\n      ss[no] += ss[j];\n    }\n  }\n}\nconst long long mod = 998244353;\nlong long ans[100001];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    for (long long i = 0; i < n; i++) {\n      adj[i].clear();\n    }\n    for (long long i = 0; i < n - 1; i++) {\n      long long aa, bb;\n      cin >> aa >> bb;\n      aa--;\n      bb--;\n      adj[aa].push_back(bb);\n      adj[bb].push_back(aa);\n    }\n    dfs(0);\n    vector<pair<long long, long long>> ss2;\n    vector<long long> tt;\n    for (long long i = 1; i <= n; i++) {\n      ans[i] = 0;\n    }\n    for (long long i = 1; i < n; i++) {\n      ss2.push_back({ss[i] - 1, ss[i]});\n    }\n    for (long long i = 1; i <= n - 1; i++) {\n      if ((n - 1) % i == 0) {\n        tt.push_back(i);\n      }\n    }\n    reverse(tt.begin(), tt.end());\n    for (auto j : tt) {\n      ans[j] = 1;\n      for (auto k : ss2) {\n        long long co = 0;\n        if ((k.first) % j == 0) {\n          co++;\n        }\n        if ((k.second) % j == 0) {\n          co++;\n        }\n        ans[j] = (ans[j] * co) % mod;\n      }\n      for (auto i : tt) {\n        if (i > j) {\n          if ((i % j) == 0) {\n            ans[j] = (ans[j] - ans[i] + mod) % mod;\n          }\n        }\n      }\n    }\n    for (long long i = 1; i <= n; i++) {\n      cout << ans[i] << \" \";\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"-O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nmt19937_64 rnd(time(0));\nlong long MOD = 998244353;\nconst long double E = 1e-10;\nlong long n, m, k, T, ans[500005];\nvector<long long> c[500005];\nlong long binpow(long long h, long long r, long long md) {\n  long long l = 1;\n  while (r) {\n    if (r & 1) l = (l * h) % md;\n    h = (h * h) % md;\n    r /= 2;\n  }\n  return l;\n}\nlong long read() {\n  char c = getchar();\n  while (!isdigit(c)) {\n    c = getchar();\n  }\n  long long res = 0;\n  while (isdigit(c)) {\n    res = res * 10 + c - '0';\n    c = getchar();\n  }\n  return res;\n}\nlong long gcd(long long x, long long y) {\n  while (x && y) {\n    if (x < y) swap(x, y);\n    x %= y;\n  }\n  return x + y;\n}\npair<long long, long long> dfs(int h, int p = -1) {\n  long long z = 0;\n  for (int i = 0; i < c[h].size(); i++)\n    if (c[h][i] != p) {\n      pair<long long, long long> u = dfs(c[h][i], h);\n      if (!u.first) return make_pair(0, 0);\n      z += u.second;\n    }\n  if (z % T == 0)\n    return make_pair(1, 1);\n  else if ((z + 1) % T == 0)\n    return make_pair(1, 0);\n  else\n    return make_pair(0, 0);\n}\nvoid solve() {\n  cin >> n;\n  long long x = n - 1, p = sqrt(x);\n  vector<long long> v;\n  for (int i = 1; i <= n; i++) ans[i] = 0, c[i].clear();\n  for (int i = 1; i <= p; i++)\n    if (x % i == 0) {\n      v.push_back(i);\n      if (x / i != i) v.push_back(x / i);\n    }\n  for (int i = 1; i < n; i++) {\n    long long x, y;\n    cin >> x >> y;\n    c[x].push_back(y);\n    c[y].push_back(x);\n  }\n  ans[1] = binpow(2, n - 1, MOD);\n  for (int i = 1; i < v.size(); i++) {\n    T = v[i];\n    pair<long long, long long> o = dfs(1);\n    if (o.first && o.second) ans[v[i]] = 1;\n  }\n  for (int i = n; i > 0; i--) {\n    for (int j = i * 2; j <= n; j += i) ans[i] -= ans[j];\n  }\n  for (int i = 1; i <= n; i++) cout << ans[i] << \" \";\n  cout << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 998244353;\nint Tc, n, ans[100004], dp[100004];\nvector<int> g[100004];\nbool ok;\nvoid dfs(int x, int par, int C) {\n  if (!ok) return;\n  for (auto y : g[x])\n    if (y != par) dfs(y, x, C);\n  if (dp[x] % C != 0) {\n    if (par) dp[x]++;\n    if (dp[x] % C != 0) {\n      ok = 0;\n      return;\n    }\n  } else\n    dp[par]++;\n}\nvoid solve() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) g[i].clear();\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    g[u].push_back(v), g[v].push_back(u);\n  }\n  for (int i = 1; i <= n; i++) ans[i] = 0;\n  ans[1] = 1;\n  for (int i = 1; i < n; i++) ans[1] = (ans[1] + ans[1]) % M;\n  for (int i = 2; i <= n - 1; i++)\n    if ((n - 1) % i == 0) {\n      for (int j = 0; j <= n; j++) dp[j] = 0;\n      ok = 1, dfs(1, 0, i), ans[i] = ok;\n    }\n  for (int i = n; i; i--)\n    for (int j = i + i; j <= n; j += i) ans[i] = (ans[i] - ans[j] + M) % M;\n  for (int i = 1; i <= n; i++) printf(\"%d \", ans[i]);\n  puts(\"\");\n}\nint main() {\n  for (scanf(\"%d\", &Tc); Tc--;) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nbool dfs(vector<int> adj[], int p, int c, int a[], int k, bool &isposs) {\n  a[c] = 0;\n  for (auto u : adj[c])\n    if (u != p) {\n      bool f = dfs(adj, c, u, a, k, isposs);\n      if (!f) {\n        a[c]++;\n      }\n    }\n  if (a[c] % k && p != -1) {\n    a[c]++;\n    if (a[c] % k) {\n      isposs = false;\n    }\n    return true;\n  }\n  if (p == -1 && a[c] % k) {\n    isposs = false;\n  }\n  return false;\n}\nlong long fastexp(long long n, long long k) {\n  if (k == 0)\n    return 1;\n  else if (k % 2)\n    return (fastexp(n, k - 1) * n) % mod;\n  else {\n    long long w = fastexp(n, k / 2);\n    return (w * w) % mod;\n  }\n}\nvector<int> facts[100001];\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  for (int i = 2; i <= 100000; i++) {\n    for (int j = 2 * i; j <= 100000; j += i) {\n      facts[j].push_back(i);\n    }\n  }\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> adj[n];\n    int a[n];\n    for (int i = 0; i < n - 1; i++) {\n      int u, v;\n      cin >> u >> v;\n      u--;\n      v--;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n    int ans[n + 1];\n    for (int i = 1; i <= n; i++) {\n      ans[i] = 0;\n    }\n    ans[1] = fastexp(2, n - 1);\n    for (auto f : facts[n - 1]) {\n      bool ths = true;\n      dfs(adj, -1, 0, a, f, ths);\n      ans[f] = ths;\n    }\n    if (n != 2) {\n      bool ths = true;\n      dfs(adj, -1, 0, a, n - 1, ths);\n      ans[n - 1] = ths;\n    }\n    for (int j = n - 1; j >= 2; j--) {\n      if (ans[j]) {\n        for (auto f : facts[j]) {\n          ans[f] -= ans[j];\n        }\n        ans[1] -= ans[j];\n      }\n    }\n    ans[1] += mod;\n    ans[1] %= mod;\n    for (int i = 1; i <= n; i++) {\n      cout << ans[i] << \" \";\n    }\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a, b, g;\nint res[1000007];\nstruct wierzch {\n  list<int> l;\n};\nwierzch tab[1000007];\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nint testuj(int nr, int o, int k) {\n  int d = 0;\n  for (auto el : tab[nr].l)\n    if (el != o) {\n      int x = testuj(el, nr, k);\n      if (x == -1) return -1;\n      d += x;\n    }\n  if (d % k == 0) {\n    g = gcd(d, g);\n    return 1;\n  }\n  if ((d + 1) % k == 0) {\n    g = gcd(d + 1, g);\n    return 0;\n  }\n  return -1;\n}\nint solve() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) tab[i].l.clear();\n  for (int i = 0; i < n - 1; i++) {\n    scanf(\"%d %d\", &a, &b);\n    tab[a].l.push_back(b);\n    tab[b].l.push_back(a);\n  }\n  int r = 1;\n  for (int i = 0; i < n - 1; i++) r = r * 2 % 998244353;\n  for (int k = 2; k <= n; k++) {\n    g = 0;\n    if ((n - 1) % k == 0 && testuj(1, 1, k) == 1 && g == k)\n      res[k] = 1;\n    else\n      res[k] = 0;\n    r -= res[k];\n  }\n  res[1] = (r + 998244353) % 998244353;\n  for (int i = 1; i <= n; i++) printf(\"%d \", res[i]);\n  printf(\"\\n\");\n  return 0;\n}\nint main() {\n  int _tests;\n  scanf(\"%d\", &_tests);\n  for (int _test = 1; _test <= _tests; _test++) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nbool chkmin(T &a, T b) {\n  return (b < a) ? a = b, 1 : 0;\n}\ntemplate <typename T>\nbool chkmax(T &a, T b) {\n  return (b > a) ? a = b, 1 : 0;\n}\nlong long ksm(long long a, long long b) {\n  if (b == 0) return 1;\n  long long ns = ksm(a, b >> 1);\n  ns = ns * ns % 998244353;\n  if (b & 1) ns = ns * a % 998244353;\n  return ns;\n}\nusing namespace std;\nconst int maxn = 100050;\nint n;\nvector<int> g[maxn];\nint cn[maxn];\nint ans[maxn];\nvoid dfs(int u, int p, int k) {\n  int deg = 0;\n  for (int v : g[u]) {\n    if (v != p) {\n      deg++;\n      dfs(v, u, k);\n      if (cn[v] % k != 0) {\n        cn[v]++;\n        deg--;\n      }\n    }\n  }\n  cn[u] = deg;\n}\nint check(int k) {\n  for (int i = 1; i <= n; i++) cn[i] = 0;\n  dfs(1, 0, k);\n  for (int i = 1; i <= n; i++) {\n    if (cn[i] % k != 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) g[i].clear();\n    for (int i = 1; i < n; i++) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n    ans[1] = ksm(2, n - 1);\n    for (int k = 2; k <= n; k++) {\n      if ((n - 1) % k != 0) {\n        ans[k] = 0;\n        continue;\n      }\n      ans[k] = check(k);\n    }\n    for (int i = n; i >= 1; i--) {\n      for (int j = i + i; j <= n; j += i) {\n        ans[i] -= ans[j];\n      }\n    }\n    for (int i = 1; i <= n; i++) {\n      printf(\"%d \", ans[i]);\n    }\n    printf(\"\\n\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300000, mod = 998244353;\nint n;\nstruct side {\n  int y, next;\n} e[N * 2 + 9];\nint lin[N + 9], cs;\nvoid Ins(int x, int y) {\n  e[++cs].y = y;\n  e[cs].next = lin[x];\n  lin[x] = cs;\n}\nvoid Ins2(int x, int y) {\n  Ins(x, y);\n  Ins(y, x);\n}\nvoid into() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) lin[i] = 0;\n  cs = 0;\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    Ins2(x, y);\n  }\n}\nint cnt[N + 9];\nvoid Dfs_cnt(int k, int fa, int p) {\n  cnt[k] = 0;\n  for (int i = lin[k]; i; i = e[i].next) {\n    int y = e[i].y;\n    if (y == fa) continue;\n    Dfs_cnt(y, k, p);\n    cnt[y] % p ? ++cnt[y] : ++cnt[k];\n  }\n}\nint ans[N + 9];\nvoid Get_ans() {\n  for (int i = 1; i <= n; ++i) ans[i] = 0;\n  ans[1] = 1;\n  for (int i = 1; i < n; ++i) ans[1] = 1LL * ans[1] * 2 % mod;\n  for (int i = 2; i < n; ++i) {\n    if ((n - 1) % i) continue;\n    Dfs_cnt(1, 0, i);\n    ans[i] = 1;\n    for (int j = 1; j <= n; ++j)\n      if (cnt[j] % i) ans[i] = 0;\n  }\n  for (int i = n; i >= 1; --i)\n    for (int j = i << 1; j <= n; j += i) ans[i] = (ans[i] + mod - ans[j]) % mod;\n}\nvoid work() { Get_ans(); }\nvoid outo() {\n  for (int i = 1; i <= n; ++i) printf(\"%d \", ans[i]);\n  puts(\"\");\n}\nint main() {\n  int T = 1;\n  scanf(\"%d\", &T);\n  for (; T--;) {\n    into();\n    work();\n    outo();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef const int& ci;\nvector<int> sn[100000 + 1];\nint deg[100000 + 1], que[100000 + 1], par[100000 + 1], ans[100000],\n    cnt[100000 + 1];\nint check(ci n, ci k) {\n  memset(cnt + 1, 0, n << 2);\n  for (int i = 1; i < n; ++i) {\n    int u = que[i];\n    if (cnt[u] % k) {\n      if ((++cnt[u]) % k) return 0;\n    } else\n      ++cnt[par[u]];\n  }\n  return 1;\n}\n__inline__ __attribute__((always_inline)) void test() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) sn[i].clear();\n  memset(deg + 1, 0, n << 2);\n  for (int i = n, u, v; --i;) {\n    scanf(\"%d%d\", &u, &v);\n    sn[u].push_back(v), sn[v].push_back(u), ++deg[u], ++deg[v];\n  }\n  int tail = 0;\n  for (int i = 1; i <= n; ++i)\n    if (deg[i] == 1) que[++tail] = i;\n  for (int head = 1; head < n; ++head) {\n    int u = que[head];\n    for (auto v : sn[u])\n      if (deg[v] > 1) {\n        par[u] = v;\n        if (--deg[v] == 1) que[++tail] = v;\n      }\n  }\n  int m = n - 1;\n  ans[1] = 1;\n  for (int i = m; i; --i, ans[1] = (ans[1] << 1) % 998244353)\n    ;\n  for (int i = m; i > 1; --i)\n    if (!(m % i)) {\n      ans[i] = check(n, i);\n      for (int j = i << 1; j <= m; j += i) ans[i] -= ans[j];\n      ans[1] -= ans[i];\n    } else\n      ans[i] = 0;\n  for (int i = 1; i < n; ++i) printf(\"%d \", ans[i]);\n  puts(\"0\");\n}\nint main() {\n  int t;\n  for (scanf(\"%d\", &t); t; test(), --t)\n    ;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T, n, ans[200005], val[200005];\nint cnt, pri[200005], vis[200005], mu[200005];\nvector<int> g[200005];\nvoid init(int lim) {\n  mu[1] = 1;\n  for (int i = 2; i <= lim; ++i) {\n    if (!vis[i]) pri[++cnt] = i, mu[i] = -1;\n    for (int j = 1; j <= cnt && pri[j] * i <= lim; ++j) {\n      vis[pri[j] * i] = 1;\n      if (i % pri[j] == 0) {\n        mu[i * pri[j]] = 0;\n        break;\n      }\n      mu[pri[j] * i] = -mu[i];\n    }\n  }\n}\nint ksm(int x, int y) {\n  int num = 1;\n  while (y) {\n    if (y & 1) num = 1LL * num * x % 998244353;\n    x = 1LL * x * x % 998244353, y >>= 1;\n  }\n  return num;\n}\nbool dfs(int x, int fa, int k) {\n  val[x] = 0;\n  int flag = 1, num = 0;\n  for (int to : g[x])\n    if (to != fa) {\n      if (!dfs(to, x, k)) flag = 0;\n      if (!val[to]) num++;\n    }\n  if (num % k == 0)\n    val[x] = 0;\n  else if ((num + 1) % k == 0)\n    val[x] = 1;\n  else\n    flag = 0;\n  return flag;\n}\nint main() {\n  scanf(\"%d\", &T);\n  init(1e5);\n  while (T--) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n      ans[i] = 0;\n      g[i].clear();\n    }\n    for (int i = 1; i < n; ++i) {\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      g[x].push_back(y), g[y].push_back(x);\n    }\n    for (int i = 1; i * i <= (n - 1); ++i)\n      if ((n - 1) % i == 0) {\n        ans[i] = dfs(1, 0, i);\n        if (i * i != n - 1) ans[(n - 1) / i] = dfs(1, 0, (n - 1) / i);\n      }\n    ans[1] = ksm(2, n - 1);\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 2; j * i <= n; ++j)\n        ans[i] = (ans[i] + mu[j] * ans[i * j] + 998244353) % 998244353;\n      printf(\"%d \", ans[i]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long nax = 3e5 + 10, mod = 998244353;\nvector<long long> g[nax];\nlong long dp[nax], n, d, ok, res[nax];\nvoid dfs(long long s, long long p = 0) {\n  if (!ok) return;\n  for (auto it : g[s])\n    if (it ^ p) dfs(it, s);\n  if (dp[s] % d != 0) {\n    if (p) dp[s]++;\n    if (dp[s] % d != 0) {\n      ok = 0;\n      return;\n    }\n  } else\n    dp[p]++;\n}\nint32_t main() {\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (long long i = 1; i <= n; i++) dp[i] = res[i] = 0, g[i].clear();\n    for (long long i = 1; i < n; i++) {\n      long long x, y;\n      cin >> x >> y;\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n    res[1] = 1;\n    for (long long i = 1; i <= n - 1; i++) res[1] = (2 * res[1]) % mod;\n    for (d = 2; d <= n - 1; d++)\n      if ((n - 1) % d == 0) {\n        ok = 1;\n        dfs(1);\n        res[d] = ok;\n        for (long long i = 0; i <= n; i++) dp[i] = 0;\n      }\n    for (long long i = n; i >= 1; i--)\n      for (long long j = 2 * i; j <= n; j += i)\n        res[i] = (res[i] - res[j] + mod) % mod;\n    for (long long i = 1; i <= n; i++) cout << res[i] << ' ';\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\nusing namespace std;\nconst long long N = 1e5 + 100;\nvector<long long> p[N];\nvector<long long> g[N];\nlong long long long ans[N];\nlong long long long mod = 998244353;\nlong long long long dp[N];\nlong long long long vis[N];\nlong long long long fac[N];\nlong long long long fm[N];\nlong long long long sz[N];\nlong long long long power(long long long long n, long long long long k) {\n  if (k == 0) return 1;\n  if (k % 2 == 1) {\n    long long long long x = power(n, k / 2);\n    return x * x % mod * n % mod;\n  }\n  long long long long x = power(n, k / 2);\n  return x * x % mod;\n}\nlong long long long ent(long long long long k, long long long long n) {\n  if (k < 0 || k > n) return 0;\n  if (k == 0 || k == n) return 1;\n  return fac[n] * fm[k] % mod * fm[n - k] % mod;\n}\nvoid dfs(long long long long v, long long long long p, long long long long x) {\n  sz[v] = 1;\n  vis[v] = 0;\n  long long long long z = g[v].size();\n  long long long long p1 = 0, p2 = 0;\n  for (auto u : g[v]) {\n    if (u == p) continue;\n    dfs(u, v, x);\n    if (vis[u])\n      z--, p1++;\n    else\n      p2++;\n    sz[v] += sz[u];\n  }\n  if (z % x == 0) vis[v] = 1;\n  if (z % x > 1) {\n    dp[v] = 0;\n    return;\n  }\n  dp[v] = 1;\n  long long long long jj = sz[v];\n  for (auto u : g[v]) {\n    if (u == p) continue;\n    dp[v] *= dp[u];\n    dp[v] %= mod;\n  }\n}\nlong long Main() {\n  long long long long n;\n  cin >> n;\n  for (long long i = 1; i <= n; i++) {\n    g[i].clear();\n    ans[i] = 0;\n  }\n  for (long long i = 0; i < n - 1; i++) {\n    long long long long u, v;\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  ans[1] = 1;\n  for (long long i = 1; i < n; i++) ans[1] = ans[1] * 2 % mod;\n  long long long long id = 1;\n  for (long long i = 1; i <= n; i++) {\n    if (g[i].size() == 1) continue;\n    long long long long p1 = 0;\n    for (auto u : g[i]) {\n      if (g[u].size() > 1) p1++;\n    }\n    if (p1 <= 1) {\n      id = g[i].size();\n    }\n  }\n  for (auto u : p[id]) {\n    dfs(1, 1, u);\n    ans[u] = dp[1];\n    if (vis[1] == 0) ans[u] = 0;\n  }\n  for (auto u : p[id - 1]) {\n    dfs(1, 1, u);\n    ans[u] = dp[1];\n    if (vis[1] == 0) ans[u] = 0;\n  }\n  for (long long i = n; i; i--) {\n    for (long long j = i + i; j <= n; j += i) {\n      ans[i] -= ans[j];\n      ans[i] += mod;\n      ans[i] %= mod;\n    }\n  }\n  for (long long i = 1; i <= n; i++) cout << ans[i] << \" \";\n  cout << endl;\n  return 0;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  fac[0] = 1;\n  fm[0] = 1;\n  for (long long i = 1; i < N; i++) {\n    fac[i] = fac[i - 1] * i % mod;\n    fm[i] = power(fac[i], mod - 2);\n  }\n  for (long long i = 2; i < N; i++) {\n    for (long long j = i; j < N; j += i) p[j].push_back(i);\n  }\n  long long long long t = 1;\n  cin >> t;\n  while (t--) Main();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &a) {\n  T w = 1;\n  a = 0;\n  char ch = getchar();\n  for (; ch < '0' || ch > '9'; ch = getchar())\n    if (ch == '-') w = -1;\n  for (; ch >= '0' && ch <= '9'; ch = getchar())\n    a = (a << 3) + (a << 1) + (ch ^ 48);\n  a *= w;\n}\ntemplate <typename T>\ninline void ckmax(T &a, T b) {\n  a = a > b ? a : b;\n}\ntemplate <typename T>\ninline void ckmin(T &a, T b) {\n  a = a < b ? a : b;\n}\nconst int N = 1e5 + 10;\nconst int Mod = 998244353;\nvector<int> to[N];\nint f[N], g[N];\ninline int Sub(int x, int y) { return (x - y) < 0 ? (x + Mod - y) : (x - y); }\ninline int Mul(int x, int y) {\n  return (1ll * x * y) >= Mod ? (1ll * x * y % Mod) : (x * y);\n}\nint qpow(int a, int b) {\n  int base = a, ans = 1;\n  while (b) {\n    if (b & 1) ans = Mul(ans, base);\n    base = Mul(base, base);\n    b >>= 1;\n  }\n  return ans;\n}\nint fl;\nint dfs(int u, int fa, int k) {\n  int cnt = 0;\n  for (auto v : to[u]) {\n    if (v == fa) continue;\n    cnt += dfs(v, u, k);\n  }\n  if (!(cnt % k)) return 1;\n  if (!((cnt + 1) % k)) return 0;\n  fl = 0;\n  return 0;\n}\nint main() {\n  int cases;\n  read(cases);\n  while (cases--) {\n    int n;\n    read(n);\n    memset(f, 0, sizeof f);\n    for (int i = 1, u, v; i < n; ++i) {\n      read(u);\n      read(v);\n      to[u].push_back(v);\n      to[v].push_back(u);\n    }\n    f[1] = qpow(2, n - 1);\n    for (int i = 2; i < n; ++i) {\n      if (!((n - 1) % i)) {\n        fl = 1;\n        f[i] = dfs(1, 0, i) && fl;\n      }\n    }\n    for (int i = n - 1; i >= 1; --i) {\n      for (int j = i + i; j < n; j += i) f[i] = Sub(f[i], f[j]);\n    }\n    for (int i = 1; i <= n; ++i) printf(\"%d \", f[i]);\n    puts(\"\");\n    for (int i = 1; i <= n; ++i) to[i].clear();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300005;\nconst int base = 998244353;\nint t, n, f[N], d[N], par[N];\nvector<int> a[N];\nvoid dfs(int u, int p, int c) {\n  if (f[c] == 0) return;\n  d[u] = 0;\n  for (auto v : a[u])\n    if (v != p) dfs(v, u, c);\n  if (d[u] % c == 0)\n    d[p]++;\n  else if ((d[u] + 1) % c != 0)\n    f[c] = 0;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> t;\n  for (int iTest = 1; iTest <= t; iTest++) {\n    cin >> n;\n    for (int i = 1; i <= n; i++) a[i].clear(), f[i] = 0;\n    for (int i = 1; i < n; i++) {\n      int u, v;\n      cin >> u >> v;\n      a[u].push_back(v);\n      a[v].push_back(u);\n    }\n    f[n] = 0;\n    f[1] = 1;\n    for (int i = 1; i < n; i++) f[1] = (f[1] * 2) % base;\n    for (int i = 2; i < n; i++)\n      if ((n - 1) % i == 0) {\n        f[i] = 1;\n        dfs(1, 0, i);\n      }\n    for (int i = n - 1; i > 1; i--)\n      for (int j = i * 2; j < n; j += i)\n        if (f[j] > 0) {\n          f[i] = 0;\n          break;\n        }\n    for (int i = 2; i < n; i++) f[1] = (f[1] - f[i] + base) % base;\n    for (int i = 1; i <= n; i++) cout << f[i] << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\ntemplate <int M, int R>\nstruct modnum {\n  int v;\n  static int minv(int a, int m) {\n    return (a %= m) == 1 ? 1 : m - long long(minv(m, a)) * m / a;\n  }\n  static constexpr modnum root() { return R; }\n  static constexpr int mod() { return M; }\n  modnum() : v(0) {}\n  modnum(long long v_) : v(int(v_ % M)) {\n    if (v < 0) v += M;\n  }\n  explicit operator int() const { return v; }\n  explicit operator bool() const { return v; }\n  friend ostream& operator<<(ostream& out, const modnum& a) {\n    return out << int(a);\n  }\n  friend istream& operator>>(istream& in, modnum& a) {\n    long long v;\n    in >> v;\n    a = modnum(v);\n    return in;\n  }\n  friend bool operator==(const modnum& a, const modnum& b) {\n    return a.v == b.v;\n  }\n  friend bool operator!=(const modnum& a, const modnum& b) {\n    return a.v != b.v;\n  }\n  modnum inv() const { return modnum(minv(v, M)); }\n  friend modnum inv(const modnum& a) { return a.inv(); }\n  modnum neg() const { return modnum(v ? M - v : 0); }\n  friend modnum neg(const modnum& a) { return a.neg(); }\n  modnum operator-() const { return neg(); }\n  modnum operator+() const { return *this; }\n  modnum& operator++() {\n    if (++v == M) v = 0;\n    return *this;\n  }\n  modnum& operator--() {\n    if (!v--) v = M - 1;\n    return *this;\n  }\n  modnum& operator+=(const modnum& a) {\n    if ((v += a.v) >= M) v -= M;\n    return *this;\n  }\n  modnum& operator-=(const modnum& a) {\n    if ((v -= a.v) < 0) v += M;\n    return *this;\n  }\n  modnum& operator*=(const modnum& a) {\n    v = long long(v) * a.v % M;\n    return *this;\n  }\n  modnum& operator/=(const modnum& a) { return *this *= a.inv(); }\n  friend modnum operator++(modnum& a, int) {\n    modnum r = a;\n    ++a;\n    return r;\n  }\n  friend modnum operator--(modnum& a, int) {\n    modnum r = a;\n    --a;\n    return r;\n  }\n  friend modnum operator+(const modnum& a, const modnum& b) {\n    return modnum(a) += b;\n  }\n  friend modnum operator-(const modnum& a, const modnum& b) {\n    return modnum(a) -= b;\n  }\n  friend modnum operator*(const modnum& a, const modnum& b) {\n    return modnum(a) *= b;\n  }\n  friend modnum operator/(const modnum& a, const modnum& b) {\n    return modnum(a) /= b;\n  }\n  friend modnum mpow(modnum a, long long b) {\n    modnum res = 1;\n    for (; b; b >>= 1, a *= a)\n      if (b & 1) res *= a;\n    return res;\n  }\n};\nusing mint = modnum<mod, 5>;\nvector<int> muarr(int n) {\n  vector<int> comp(n);\n  vector<int> mu(n);\n  for (int i = 2; i < n; ++i)\n    if (!comp[i]) {\n      ++mu[i];\n      for (int j = 2 * i; j < n; j += i) {\n        comp[j] = true;\n        ++mu[j];\n      }\n      for (long long j = i * long long(i); j < n; j += i * i) mu[j] = 1e9;\n    }\n  for (int i = 0; i < n; ++i)\n    if (mu[i] >= 1e9)\n      mu[i] = 0;\n    else\n      mu[i] = 1 - 2 * (mu[i] & 1);\n  return mu;\n}\nvoid ProGamerMove() {\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int u, v, i = 1; i < n; ++i) {\n    cin >> u >> v;\n    --u;\n    --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  vector<int> children(n), lc(n), done(n), can(n);\n  vector<mint> div(n), res(n);\n  auto add = [&](int d) {\n    if (1 < d && d < n) {\n      for (int i = 2; i * i <= d; ++i) can[i] = can[d / i] = 1;\n      can[d] = true;\n    }\n  };\n  function<void(int, int)> dfs = [&](int u, int p) {\n    for (int i = 0; i < g[u].size(); ++i)\n      if (int& v = g[u][i]; v != p) {\n        dfs(v, u);\n        ++children[u];\n        if (!children[v]) {\n          swap(v, g[u].back());\n          g[u].pop_back();\n          --i;\n          ++lc[u];\n        }\n      }\n    if (!u || (children[u] > 1 && children[u] == lc[u])) {\n      add(children[u]);\n      add(children[u] + 1);\n    }\n  };\n  dfs(0, 0);\n  function<int(int, int, int, int&)> tr = [&](int u, int p, int d, int& pos) {\n    if (!pos) return 0;\n    int cnt = lc[u];\n    for (int v : g[u])\n      if (v != p) {\n        cnt += tr(v, u, d, pos);\n        if (!pos) return 0;\n      }\n    if (!u) {\n      if (cnt % d) pos = 0;\n      return 0;\n    }\n    if (cnt % d == 0) return 1;\n    if (cnt % d == d - 1) return 0;\n    pos = 0;\n    return 0;\n  };\n  div[1] = mpow(mint(2), n - 1);\n  for (int pos, d = 2; d < n; ++d)\n    if (!done[d]) {\n      pos = can[d];\n      tr(0, 0, d, pos);\n      done[d] = true;\n      div[d] = pos;\n      if (!pos) {\n        for (int j = 1; d * j < n; ++j) done[d * j] = 1;\n      }\n    }\n  auto mu = muarr(n);\n  for (int i = 1; i < n; ++i)\n    for (int j = 1; i * j < n; ++j) res[i] += mu[j] * div[i * j];\n  for (int i = 1; i < n; ++i) cout << res[i] << \" \";\n  cout << \"0\\n\";\n}\nsigned main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin.exceptions(cin.failbit);\n  cout << setprecision(9) << fixed;\n  int tc = 1;\n  cin >> tc;\n  while (tc--) ProGamerMove();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint t, n, ok, d, mod = 998244353;\nint dp[100010], ans[100010];\nvector<int> g[100010];\nvoid dfs(int u, int parent) {\n  if (!ok) return;\n  for (int v : g[u])\n    if (v ^ parent) dfs(v, u);\n  if (dp[u] % d != 0) {\n    if (parent != 0) dp[u]++;\n    if (dp[u] % d != 0) {\n      ok = 0;\n      return;\n    }\n  } else\n    dp[parent]++;\n}\nint main() {\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n      int u, v;\n      cin >> u >> v;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n    for (int i = 1; i <= n; i++) ans[i] = 0;\n    ans[1] = 1;\n    for (int i = 1; i < n; i++) ans[1] = (ans[1] + ans[1]) % mod;\n    for (d = 2; d <= n; d++)\n      if ((n - 1) % d == 0) {\n        ok = 1;\n        dfs(1, 0);\n        ans[d] = ok;\n        for (int i = 0; i <= n; i++) dp[i] = 0;\n      }\n    for (int i = n; i >= 1; i--)\n      for (int j = i + i; j <= n; j += i)\n        ans[i] = (ans[i] - ans[j] + mod) % mod;\n    for (int i = 1; i <= n; i++) cout << ans[i] << \" \";\n    cout << \"\\n\";\n    for (int i = 1; i <= n; i++) g[i].clear();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> adjList[300005];\nvector<int> visited(300005);\nvector<int> a(300005);\nvector<long long> f(300005);\nvector<long long> twoPowers(300005);\nlong long mod = 998244353;\nvector<long long> ans(300005);\nint dfs(int node, int goal) {\n  visited[node] = 1;\n  int accrued = 0;\n  for (int i = 0; i < adjList[node].size(); i++) {\n    int child = adjList[node][i];\n    if (!visited[child]) {\n      int au = dfs(child, goal);\n      if (au == -1) return -1;\n      accrued += au;\n    }\n  }\n  int toReturn = 1;\n  if (accrued % goal == 0)\n    toReturn = 1;\n  else if ((accrued + 1) % goal == 0)\n    toReturn = 0;\n  else\n    toReturn = -1;\n  return toReturn;\n}\nint main() {\n  iostream::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  twoPowers[0] = 1;\n  for (int i = 1; i < 300005; i++) {\n    twoPowers[i] = (twoPowers[i - 1] * 2) % mod;\n  }\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (int i = 0; i < n + 1; i++) {\n      vector<int> v;\n      adjList[i] = v;\n      f[i] = 0;\n      ans[i] = 0;\n    }\n    for (int i = 0; i < n - 1; i++) {\n      int u, v;\n      cin >> u >> v;\n      u--;\n      v--;\n      adjList[u].push_back(v);\n      adjList[v].push_back(u);\n    }\n    f[1] = twoPowers[n - 1];\n    for (int i = 2; i <= n - 1; i++) {\n      if ((n - 1) % i == 0) {\n        for (int j = 0; j <= n; j++) {\n          visited[j] = 0;\n          a[j] = 0;\n        }\n        int res = dfs(0, i);\n        if (res == 1) f[i] = 1;\n      }\n    }\n    for (int i = n - 1; i >= 1; i--) {\n      ans[i] = f[i];\n      for (int j = 2; j * i <= n - 1; j++) ans[i] = ans[i] - ans[j * i];\n    }\n    for (int i = 1; i <= n; i++) cout << ans[i] << ' ';\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint t, n;\nvector<int> g[100100];\nlong long ans[100100];\nbool extra[100100];\nbool poss(int c, int l, int k) {\n  int cv = 0;\n  for (int i : g[c]) {\n    if (i == l) continue;\n    if (!poss(i, c, k)) return false;\n    cv += extra[i];\n  }\n  if (cv % k == 0) {\n    extra[c] = true;\n    return true;\n  }\n  if ((cv + 1) % k == 0) {\n    extra[c] = false;\n    return true;\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    long long ctot = 1;\n    for (int i = 1; i < n; i++) {\n      int n1, n2;\n      scanf(\" %d%d\", &n1, &n2);\n      g[n1].push_back(n2);\n      g[n2].push_back(n1);\n      ctot *= 2;\n      ctot %= 998244353;\n    }\n    ans[1] = ctot;\n    for (int i = n; i > 1; i--) {\n      ans[i] = 0;\n      if ((n - 1) % i) continue;\n      for (int j = i * 2; j <= n; j += i)\n        if (ans[j]) ans[i] = 1;\n      if (ans[i]) continue;\n      for (int j = 1; j <= n; j++) extra[j] = false;\n      bool cv = poss(1, -1, i);\n      if (cv && extra[1]) ans[i] = 1;\n    }\n    for (int i = n; i >= 1; i--) {\n      for (int j = i * 2; j <= n; j += i) ans[i] -= ans[j];\n      ans[i] += 998244353;\n      ans[i] %= 998244353;\n    }\n    for (int i = 1; i <= n; i++) printf(\"%lld \", ans[i]);\n    printf(\"\\n\");\n    for (int i = 1; i <= n; i++) g[i].clear();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nconst unsigned gen_seed =\n    std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937_64 gen(gen_seed);\nstd::vector<std::pair<int, int>> ord;\nvector<set<int>> g;\nstd::vector<int> deg;\nvoid go(int v) {\n  if (deg[v] == 1) {\n    int to = *g[v].begin();\n    ord.push_back(make_pair(v, to));\n    g[to].erase(v);\n    g[v].erase(to);\n    deg[to]--;\n    deg[v]--;\n    go(to);\n  }\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  for (int afaf = 0; afaf < t; afaf++) {\n    int n;\n    scanf(\"%d\", &n);\n    g = vector<set<int>>(n);\n    deg = std::vector<int>(n, 0);\n    for (int i = 0; i < n - 1; i++) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      u--;\n      v--;\n      g[u].insert(v);\n      g[v].insert(u);\n      deg[u]++;\n      deg[v]++;\n    }\n    ord = std::vector<std::pair<int, int>>();\n    for (int i = 0; i < n; i++) go(i);\n    std::vector<int> ans(n + 1, 0);\n    long long lft = 1;\n    for (int i = 0; i < n - 1; i++) lft = lft * 2 % mod;\n    for (int d = n - 1; d >= 2; d--) {\n      if ((n - 1) % d == 0) {\n        std::vector<int> val(n, 0);\n        for (auto x : ord) {\n          if (val[x.first] % d == 0) {\n            val[x.second]++;\n          } else\n            val[x.first]++;\n        }\n        int can = 1;\n        for (int i = 0; i < n; i++)\n          if (val[i] % d != 0) can = 0;\n        for (int d2 = 2 * d; d2 < n; d2 += d) {\n          if (ans[d2] == 1) can = 0;\n        }\n        if (can == 1) {\n          ans[d] = 1;\n          lft = (lft + mod - 1) % mod;\n        }\n      }\n    }\n    ans[1] = lft;\n    for (int i = 1; i < n + 1; i++) {\n      printf(\"%d\", ans[i]);\n      if (i != n)\n        printf(\" \");\n      else\n        printf(\"\\n\");\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  char c = getchar();\n  int s = 0;\n  int x = 1;\n  while (c < '0' || c > '9') {\n    if (c == '-') x = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    s = s * 10 + c - '0';\n    c = getchar();\n  }\n  return s * x;\n}\nconst int mod = 998244353;\nconst int N = 1e5 + 5;\nint T, n, x, y, f[N], ans[N];\nvector<int> v[N];\nint ksm(int x, int k) {\n  int base = 1;\n  while (k) {\n    if (k & 1) base = 1ll * base * x % mod;\n    k >>= 1;\n    x = 1ll * x * x % mod;\n  }\n  return base;\n}\nint gcd(int x, int y) {\n  if (!x) return y;\n  return gcd(y % x, x);\n}\nvoid dfs(int u, int fa, int p) {\n  int siz = 0;\n  for (int i = 0; i < v[u].size(); i++) {\n    if (v[u][i] == fa) continue;\n    dfs(v[u][i], u, p);\n    siz++;\n  }\n  if (!siz) {\n    f[fa]++;\n  } else {\n    if (fa) {\n      if (f[u] % p == 0)\n        f[fa]++;\n      else\n        f[u]++;\n    }\n  }\n}\nint main() {\n  T = read();\n  while (T--) {\n    n = read();\n    for (int i = 1; i < n; i++) {\n      x = read();\n      y = read();\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n    int tmp = ksm(2, n - 1);\n    int pre = 0;\n    for (int i = 2; i < n; i++) {\n      if ((n - 1) % i == 0) {\n        dfs(1, 0, i);\n        int mi = 0;\n        bool flag = 0;\n        for (int k = 1; k <= n; k++) {\n          mi = gcd(f[k], mi);\n          if (f[k] % i) flag = 1;\n          f[k] = 0;\n        }\n        if (!flag && mi == i) ans[i] = 1, pre++;\n      }\n    }\n    cout << (tmp - pre + mod) % mod << \" \";\n    for (int i = 2; i <= n; i++) {\n      cout << ans[i] << \" \";\n    }\n    for (int i = 1; i <= n; i++) v[i].clear(), ans[i] = 0;\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 300000 + 50;\nconst long long mm = 998244353;\nint n, m, ans, T;\nlong long f[maxn], w[maxn];\nvector<int> tr[maxn];\nlong long dfs1(int x, int fa) {\n  long long tot = 1;\n  w[x] = 1;\n  for (int i = 0; i < tr[x].size(); ++i)\n    if (tr[x][i] != fa)\n      tot = tot * dfs1(tr[x][i], x) * 2 % mm, w[x] = (w[x] + w[tr[x][i]]);\n  return tot;\n}\nint dfs(int x, int fa, int z, int y) {\n  int tot = 0;\n  for (int i = 0; i < tr[x].size(); ++i)\n    if (tr[x][i] != fa)\n      if (w[tr[x][i]] % z == 0) {\n        if (!dfs(tr[x][i], x, z, 1)) return 0;\n      } else if ((w[tr[x][i]] - 1) % z == 0) {\n        ++tot;\n        if (!dfs(tr[x][i], x, z, 0)) return 0;\n      } else\n        return 0;\n  if ((tot + y) % z == 0)\n    ;\n  else\n    return 0;\n  return 1;\n}\nint main() {\n  scanf(\"%d\", &T);\n  for (int oo = 1; oo <= T; ++oo) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i)\n      while (!tr[i].empty()) tr[i].pop_back();\n    for (int i = 1; i < n; ++i) {\n      int q1, q2;\n      scanf(\"%d%d\", &q1, &q2);\n      tr[q1].push_back(q2);\n      tr[q2].push_back(q1);\n    }\n    for (int i = 1; i <= n; ++i) f[i] = 0;\n    f[1] = dfs1(1, 1);\n    for (int i = n - 1; i > 1; --i)\n      if ((n - 1) % i == 0 && !f[i]) {\n        f[i] += dfs(1, 1, i, 0);\n        if (f[i])\n          for (int j = 1; j * j <= i; ++j)\n            if (i % j == 0) {\n              f[j] -= f[i];\n              if (j * j != i && j != 1) f[i / j] -= f[i];\n            }\n      }\n    for (int i = 1; i <= n; ++i)\n      if (f[i] >= 0)\n        printf(\"%lld \", (f[i] + mm) % mm);\n      else\n        printf(\"0 \");\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 998244353;\nconst ll root = 3;\nll binpow(ll a, ll b) {\n  ll res = 1;\n  while (b) {\n    if (b & 1) res = (res * a) % MOD;\n    a = (a * a) % MOD;\n    b >>= 1;\n  }\n  return res;\n}\nll modInv(ll a) { return binpow(a, MOD - 2); }\nconst int INF = 0x3f3f3f3f;\nconst int NINF = 0xc0c0c0c0;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3f;\nconst ll NINFLL = 0xc0c0c0c0c0c0c0c0;\nconst int mxN = 100001;\nint n;\nvector<int> adj[mxN];\nint ans[mxN];\nll calc(int u, int p = -1) {\n  ll curr = 1;\n  for (int v : adj[u]) {\n    if (v ^ p) {\n      curr = (curr * 2LL * calc(v, u)) % MOD;\n    }\n  }\n  return curr;\n}\nbool die = false;\nint go(int u, int k, int p = -1) {\n  int curr = 0;\n  for (int v : adj[u]) {\n    if (v ^ p) {\n      curr += go(v, k, u);\n    }\n  }\n  if (curr % k == 0)\n    return 1;\n  else if ((curr + 1) % k == 0)\n    return 0;\n  die = 1;\n  return 0;\n}\nint check(int k) {\n  if (k == 1) {\n    return calc(0);\n  }\n  for (int i = (0); i < (n); ++i) {\n    if (adj[i].size() > 1) {\n      die = false;\n      bool ok = go(i, k);\n      if (die == 0 && ok == 1) return 1;\n      return 0;\n    }\n  }\n}\nvoid solve() {\n  cin >> n;\n  for (int i = (0); i < (n + 1); ++i) {\n    ans[i] = 0;\n    adj[i].clear();\n  }\n  for (int i = (0); i < (n - 1); ++i) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  if (n == 2) {\n    cout << \"2 0\\n\";\n    return;\n  }\n  for (int d = 1; d * d <= n - 1; d++) {\n    if ((n - 1) % d == 0) {\n      ans[d] = check(d);\n      ans[(n - 1) / d] = check((n - 1) / d);\n    }\n  }\n  for (int i = (n)-1; i >= (1); --i) {\n    for (int j = i + i; j < n; j += i) {\n      ans[i] = (ans[i] - ans[j] + MOD) % MOD;\n    }\n  }\n  for (int i = (1); i < (n + 1); ++i) {\n    cout << ans[i] << \" \";\n  }\n  cout << \"\\n\";\n}\nint main() {\n  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  cin.tie(0)->sync_with_stdio(0);\n  int T = 1;\n  cin >> T;\n  for (int tc = 1; tc <= T; tc++) {\n    solve();\n  }\n  return 0;\n}\n"
        }
    ]
}