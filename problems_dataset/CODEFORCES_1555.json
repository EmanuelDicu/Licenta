{
    "name": "1555_F. Good Graph",
    "source": "CODEFORCES",
    "description": "You have an undirected graph consisting of n vertices with weighted edges.\n\nA simple cycle is a cycle of the graph without repeated vertices. Let the weight of the cycle be the [XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of weights of edges it consists of.\n\nLet's say the graph is good if all its simple cycles have weight 1. A graph is bad if it's not good.\n\nInitially, the graph is empty. Then q queries follow. Each query has the next type: \n\n  * u v x \u2014 add edge between vertices u and v of weight x if it doesn't make the graph bad. \n\n\n\nFor each query print, was the edge added or not.\n\nInput\n\nThe first line contains two integers n and q (3 \u2264 n \u2264 3 \u22c5 10^5; 1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of vertices and queries.\n\nNext q lines contain queries \u2014 one per line. Each query contains three integers u, v and x (1 \u2264 u, v \u2264 n; u \u2260 v; 0 \u2264 x \u2264 1) \u2014 the vertices of the edge and its weight.\n\nIt's guaranteed that there are no multiple edges in the input.\n\nOutput\n\nFor each query, print YES if the edge was added to the graph, or NO otherwise (both case-insensitive).\n\nExample\n\nInput\n\n\n9 12\n6 1 0\n1 3 1\n3 6 0\n6 2 0\n6 4 1\n3 4 1\n2 4 0\n2 5 0\n4 5 0\n7 8 1\n8 9 1\n9 7 0\n\n\nOutput\n\n\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nNO",
    "difficulty": "F",
    "tags": [
        "data structures",
        "dsu",
        "graphs",
        "trees"
    ],
    "rating": 2700,
    "public_test": [
        {
            "input": "9 12\n6 1 0\n1 3 1\n3 6 0\n6 2 0\n6 4 1\n3 4 1\n2 4 0\n2 5 0\n4 5 0\n7 8 1\n8 9 1\n9 7 0\n",
            "output": "YES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nNO\n"
        }
    ],
    "generated_test": [
        {
            "input": "10 25\n3 2 0\n3 6 1\n2 6 0\n2 8 1\n3 8 1\n8 9 0\n2 9 0\n6 5 0\n8 5 1\n3 1 0\n5 1 0\n3 4 0\n5 4 1\n4 7 0\n9 7 1\n8 10 1\n2 10 1\n7 3 1\n10 5 1\n5 9 1\n5 7 1\n9 3 0\n10 3 0\n9 6 0\n3 5 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "8 8\n1 2 0\n1 3 0\n4 5 1\n4 6 1\n3 7 0\n7 8 0\n5 6 1\n6 8 1\n",
            "output": "YES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 1\n4 5 1\n5 6 1\n2 6 0\n2 5 1\n2 4 1\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "10 25\n8 4 1\n4 3 0\n8 3 0\n3 7 0\n4 7 1\n7 1 1\n3 1 0\n7 10 0\n1 10 0\n10 2 0\n1 2 0\n2 5 1\n10 5 1\n2 9 1\n5 9 1\n5 6 1\n9 6 1\n7 8 0\n5 8 1\n3 2 1\n9 7 1\n9 3 1\n8 1 0\n5 3 1\n3 5 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n10 3 0\n3 5 0\n10 5 0\n10 1 1\n5 1 1\n3 7 0\n10 7 0\n5 2 0\n7 2 1\n10 6 1\n7 6 1\n7 9 0\n2 9 1\n7 8 0\n9 8 0\n5 4 1\n9 6 1\n6 9 1\n7 5 0\n6 4 1\n5 6 1\n1 4 1\n2 1 1\n4 7 0\n4 2 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n6 8 1\n6 3 1\n8 3 0\n6 10 0\n8 10 1\n6 1 1\n8 1 0\n8 9 0\n6 9 0\n6 5 1\n8 5 1\n6 7 0\n8 7 1\n6 4 1\n8 4 0\n8 2 0\n6 2 0\n2 10 1\n7 9 0\n10 1 1\n7 3 0\n9 2 1\n4 5 0\n1 4 1\n4 7 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\n"
        },
        {
            "input": "5 5\n2 3 1\n3 4 1\n2 4 0\n4 5 1\n1 5 0\n",
            "output": "YES\nYES\nNO\nYES\nYES\n"
        },
        {
            "input": "10 25\n1 5 0\n5 4 1\n1 4 0\n4 3 0\n5 3 0\n3 9 1\n4 9 0\n9 10 0\n3 10 1\n10 8 0\n9 8 1\n8 6 0\n10 6 1\n8 7 0\n6 7 0\n7 2 1\n8 2 0\n10 7 1\n4 10 1\n4 7 0\n7 5 1\n3 1 0\n9 2 0\n10 2 1\n1 7 0\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n5 1 1\n5 7 0\n1 7 1\n5 8 0\n1 8 0\n5 10 1\n1 10 0\n5 4 1\n1 4 0\n5 3 0\n1 3 1\n5 9 0\n1 9 1\n1 6 1\n5 6 0\n7 2 0\n1 2 0\n3 10 1\n4 3 0\n4 2 1\n9 10 0\n2 7 1\n6 9 0\n2 6 0\n6 10 0\n",
            "output": "YES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\nYES\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n3 5 1\n5 4 0\n3 4 0\n3 1 1\n6 1 0\n5 8 0\n1 8 1\n4 7 0\n1 7 1\n5 9 1\n3 9 0\n4 2 1\n5 2 1\n5 6 0\n7 6 0\n2 10 0\n5 10 1\n4 6 0\n10 1 0\n2 6 0\n4 1 0\n1 2 0\n4 10 1\n6 8 1\n3 6 1\n",
            "output": "YES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n6 7 1\n6 10 0\n7 10 1\n6 3 1\n7 3 1\n6 9 1\n7 9 0\n6 2 1\n7 2 1\n7 8 1\n6 8 1\n7 4 1\n6 4 1\n6 5 1\n10 5 0\n10 1 0\n6 1 1\n1 5 1\n5 9 1\n8 5 1\n2 8 1\n3 1 0\n3 9 0\n10 2 0\n1 7 1\n",
            "output": "YES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n5 1 1\n5 7 0\n1 7 1\n5 8 0\n1 8 0\n5 10 1\n1 10 0\n5 4 1\n1 4 0\n5 3 0\n1 3 1\n5 9 1\n1 9 1\n1 6 1\n5 6 0\n7 2 0\n1 2 0\n3 10 1\n4 3 0\n4 2 1\n9 10 0\n2 7 1\n6 5 0\n2 6 0\n6 10 0\n",
            "output": "YES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n6 7 1\n6 10 0\n7 10 1\n6 3 0\n7 3 1\n6 9 1\n7 9 0\n6 2 1\n7 2 1\n7 8 1\n9 8 1\n7 4 1\n6 4 1\n6 5 1\n10 5 0\n10 1 0\n6 1 1\n1 5 1\n5 9 1\n8 5 1\n2 8 1\n3 1 0\n3 9 0\n10 2 0\n1 7 1\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"
        },
        {
            "input": "10 25\n3 2 0\n3 6 1\n2 6 0\n2 8 1\n3 8 1\n8 9 0\n2 9 0\n6 5 0\n8 5 1\n3 1 0\n5 1 0\n3 4 1\n5 4 1\n4 7 0\n9 7 0\n8 10 1\n2 10 1\n7 3 1\n10 5 1\n5 9 1\n5 8 1\n9 3 0\n10 3 0\n9 6 0\n3 5 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n5 1 1\n5 7 0\n1 7 1\n5 8 0\n1 8 1\n5 10 1\n1 10 0\n5 4 1\n1 4 0\n5 3 0\n1 3 1\n5 9 1\n1 9 1\n1 6 1\n5 6 0\n7 2 0\n1 2 0\n3 10 1\n4 3 0\n4 2 1\n9 10 0\n2 7 1\n6 5 0\n2 6 0\n6 10 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n3 2 0\n3 6 1\n2 6 0\n2 8 1\n3 8 1\n8 9 0\n2 9 0\n6 5 0\n8 1 1\n3 1 0\n5 1 0\n3 4 1\n5 4 1\n4 7 0\n9 7 0\n8 10 1\n2 10 1\n7 3 1\n10 5 1\n5 9 1\n5 8 1\n9 3 0\n10 3 0\n9 6 0\n3 5 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n5 1 1\n5 7 1\n1 7 1\n5 8 0\n1 8 1\n5 10 1\n1 10 0\n5 4 1\n1 4 0\n5 3 0\n1 3 1\n5 9 1\n1 9 1\n1 6 1\n5 6 0\n7 2 0\n1 2 0\n3 10 1\n4 3 0\n4 2 1\n9 10 0\n2 7 1\n6 5 0\n2 6 0\n6 10 0\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\n"
        },
        {
            "input": "6 9\n2 3 1\n3 4 1\n4 5 1\n5 6 1\n2 6 0\n2 5 1\n2 4 1\n3 5 1\n3 6 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nNO\nYES\nNO\nNO\n"
        },
        {
            "input": "10 25\n6 9 0\n6 2 0\n9 2 1\n9 7 1\n6 7 1\n6 4 1\n2 4 1\n9 1 1\n2 1 1\n6 8 0\n4 8 0\n1 10 0\n4 10 0\n1 5 0\n6 5 0\n4 3 1\n7 3 1\n3 5 1\n8 3 1\n8 10 1\n9 10 1\n8 5 0\n6 10 1\n2 10 1\n4 7 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n8 4 0\n4 3 0\n8 3 0\n3 7 0\n4 7 1\n7 1 1\n3 1 0\n7 10 0\n1 10 0\n10 2 0\n1 2 0\n2 5 1\n10 5 1\n2 9 1\n5 9 1\n5 6 1\n9 6 1\n7 8 0\n5 8 1\n3 2 1\n9 7 1\n9 3 1\n8 1 0\n5 3 1\n4 5 1\n",
            "output": "YES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n3 5 1\n5 4 0\n3 4 0\n3 1 1\n5 1 0\n5 8 0\n1 8 1\n4 7 0\n1 7 1\n5 9 1\n3 9 1\n4 2 1\n5 2 1\n5 6 0\n7 6 0\n2 10 0\n5 10 1\n4 6 0\n10 1 0\n2 6 0\n4 1 0\n1 2 0\n4 10 1\n6 8 1\n3 6 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\n"
        },
        {
            "input": "10 25\n9 6 1\n6 8 0\n9 8 0\n8 10 1\n6 7 1\n10 5 1\n8 5 1\n5 2 1\n10 2 0\n2 3 1\n10 3 0\n3 1 0\n5 1 0\n2 4 0\n3 4 1\n4 7 1\n1 7 0\n2 1 1\n9 1 1\n9 10 0\n5 7 1\n6 5 1\n4 1 0\n6 1 0\n5 9 1\n",
            "output": "YES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"
        },
        {
            "input": "10 25\n4 5 1\n5 6 0\n4 6 1\n6 10 0\n5 10 1\n10 9 0\n5 9 1\n9 2 1\n10 2 0\n2 3 0\n9 3 1\n3 1 1\n2 1 1\n1 7 0\n3 7 1\n7 8 1\n1 8 0\n3 5 0\n6 2 1\n1 5 1\n8 5 1\n1 4 1\n8 2 1\n4 8 0\n9 1 1\n",
            "output": "YES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n9 8 1\n9 3 0\n8 3 0\n8 7 0\n9 7 0\n9 4 1\n3 4 1\n3 2 0\n8 2 1\n8 5 1\n3 5 1\n2 6 0\n9 6 0\n4 1 0\n2 1 0\n8 10 0\n9 10 1\n9 5 1\n7 1 0\n9 1 1\n10 4 0\n4 6 0\n7 3 1\n8 4 1\n6 5 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n1 5 0\n5 4 1\n1 4 0\n4 3 0\n5 3 0\n3 9 1\n1 9 0\n9 10 0\n3 10 1\n10 8 0\n9 8 1\n8 6 0\n10 6 1\n8 7 0\n6 7 0\n7 2 1\n8 2 0\n10 7 1\n4 10 1\n4 7 0\n7 5 1\n3 1 0\n9 2 0\n10 2 1\n1 7 0\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n5 1 1\n5 7 0\n1 7 1\n5 8 0\n1 8 0\n5 10 1\n1 10 0\n5 4 1\n1 4 0\n5 3 0\n1 3 1\n5 9 0\n1 9 1\n1 6 1\n5 6 0\n7 2 0\n1 2 0\n3 10 1\n8 3 0\n4 2 1\n9 10 0\n2 7 1\n6 9 0\n2 6 0\n6 10 0\n",
            "output": "YES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nYES\nYES\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n3 2 0\n3 6 1\n2 6 0\n2 8 1\n3 8 1\n8 9 0\n2 9 0\n6 5 0\n7 5 1\n3 1 0\n5 1 0\n3 4 0\n5 4 1\n4 7 0\n9 7 0\n8 10 1\n2 10 1\n7 3 1\n10 5 1\n5 9 1\n5 8 1\n9 3 0\n10 3 0\n9 6 0\n3 5 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n5 1 1\n5 7 0\n1 7 1\n5 8 0\n1 8 1\n5 10 1\n1 10 0\n5 4 1\n1 4 0\n5 3 0\n1 3 1\n5 9 1\n1 9 1\n1 6 1\n5 6 0\n7 2 0\n1 2 0\n3 10 1\n4 3 0\n4 2 1\n8 10 0\n2 7 1\n6 5 0\n2 6 0\n6 10 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\nYES\nNO\nNO\nNO\n"
        },
        {
            "input": "12 2\n7 1 1\n3 6 2\n4 10 1\n23 8 0\n2 6 4\n2 5 2\n2 9 1\n0 8 1\n1 6 0\n",
            "output": "YES\nYES\n"
        },
        {
            "input": "10 25\n6 9 0\n6 2 0\n9 2 1\n9 7 1\n6 7 1\n6 4 1\n2 4 1\n9 1 1\n2 1 1\n6 8 0\n4 5 0\n1 10 0\n4 10 0\n1 5 0\n6 5 0\n4 3 1\n7 3 1\n3 5 1\n8 3 1\n8 10 1\n9 10 1\n8 5 0\n6 10 1\n2 10 1\n4 7 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n5 1 1\n5 7 0\n1 7 1\n5 8 0\n1 8 0\n5 10 1\n1 10 0\n5 4 1\n1 4 0\n5 3 0\n1 3 1\n5 9 0\n1 9 1\n1 2 1\n5 6 0\n7 2 0\n1 2 0\n3 10 1\n8 3 0\n4 2 1\n9 10 0\n2 7 1\n6 9 0\n2 6 0\n6 10 0\n",
            "output": "YES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nNO\nYES\nNO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n5 1 1\n5 7 0\n1 7 1\n5 8 0\n1 8 1\n5 10 1\n1 10 0\n5 4 1\n1 4 0\n5 3 0\n1 3 1\n5 9 1\n1 9 1\n1 6 1\n5 6 0\n7 2 0\n1 2 0\n3 10 1\n4 3 0\n4 2 1\n8 10 0\n2 3 1\n6 5 0\n2 6 0\n6 10 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n10 3 0\n3 5 0\n10 5 0\n10 1 1\n5 1 1\n3 7 0\n10 7 0\n5 2 0\n7 2 1\n10 6 1\n7 6 1\n7 9 1\n2 9 1\n7 1 0\n9 1 0\n5 4 1\n9 4 1\n6 9 1\n7 5 0\n6 4 1\n5 6 2\n1 4 1\n2 1 1\n4 7 0\n4 2 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n10 3 0\n3 5 0\n10 5 0\n10 1 1\n5 1 1\n3 7 0\n10 7 0\n5 2 0\n7 2 1\n10 6 1\n7 6 1\n7 5 0\n2 9 1\n7 8 0\n9 8 0\n5 4 2\n9 6 1\n6 9 1\n6 5 0\n6 8 1\n5 6 1\n1 4 1\n2 1 1\n4 7 0\n4 2 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "4 1\n2 3 1\n3 4 0\n2 4 1\n",
            "output": "YES\n"
        },
        {
            "input": "10 25\n3 2 0\n3 6 1\n2 6 0\n2 8 1\n3 8 1\n8 9 0\n2 9 0\n6 5 0\n8 5 1\n3 1 0\n5 1 0\n3 4 0\n5 4 1\n4 7 0\n9 7 0\n8 10 1\n2 10 1\n7 3 1\n10 5 1\n5 9 1\n5 7 1\n9 3 0\n10 3 0\n9 6 0\n3 5 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "8 8\n1 2 0\n1 3 0\n4 5 1\n4 6 1\n3 7 0\n7 8 0\n5 6 1\n3 8 1\n",
            "output": "YES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 1\n4 5 1\n5 6 1\n2 6 0\n2 5 2\n2 4 1\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "4 1\n2 3 1\n3 4 1\n2 4 1\n",
            "output": "YES\n"
        },
        {
            "input": "5 5\n2 3 1\n3 4 1\n2 4 0\n3 5 1\n1 5 0\n",
            "output": "YES\nYES\nNO\nYES\nYES\n"
        },
        {
            "input": "10 25\n5 1 1\n5 7 0\n1 7 1\n5 8 0\n1 8 0\n5 10 1\n1 10 0\n5 4 1\n1 4 0\n5 3 0\n1 3 1\n5 9 0\n1 9 1\n1 6 1\n5 6 0\n7 2 0\n1 2 0\n3 10 1\n4 3 0\n4 2 1\n9 10 0\n2 7 1\n6 5 0\n2 6 0\n6 10 0\n",
            "output": "YES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\nYES\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n6 7 1\n6 10 0\n7 10 1\n6 3 1\n7 3 1\n6 9 1\n7 9 0\n6 2 1\n7 2 1\n7 8 1\n9 8 1\n7 4 1\n6 4 1\n6 5 1\n10 5 0\n10 1 0\n6 1 1\n1 5 1\n5 9 1\n8 5 1\n2 8 1\n3 1 0\n3 9 0\n10 2 0\n1 7 1\n",
            "output": "YES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n3 2 0\n3 6 1\n2 6 0\n2 8 1\n3 8 1\n8 9 0\n2 9 0\n6 5 0\n8 5 1\n3 1 0\n5 1 0\n3 4 0\n5 4 1\n4 7 0\n9 7 0\n8 10 1\n2 10 1\n7 3 1\n10 5 1\n5 9 1\n5 8 1\n9 3 0\n10 3 0\n9 6 0\n3 5 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 1\n4 5 1\n7 6 1\n2 6 0\n2 5 2\n2 4 1\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 1\n4 5 1\n7 6 1\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "10 25\n6 7 1\n6 10 0\n7 10 1\n6 3 0\n7 3 1\n6 9 1\n7 9 0\n6 2 1\n7 2 1\n7 8 1\n9 8 1\n7 4 1\n6 4 1\n6 5 1\n10 5 0\n10 1 0\n6 1 1\n1 5 1\n5 9 1\n8 5 1\n2 8 1\n3 1 0\n3 9 0\n10 2 0\n1 8 1\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 2\n4 5 1\n7 6 1\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 1 1\n3 4 2\n4 5 1\n7 6 1\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 1 1\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n4 1 1\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "8 1\n4 1 1\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "8 1\n4 1 1\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "8 1\n4 1 1\n3 6 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n7 6 0\n2 6 1\n2 5 2\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n13 6 0\n2 6 1\n2 5 2\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n13 6 0\n2 6 1\n2 5 2\n2 5 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n13 8 0\n2 6 1\n2 5 2\n2 5 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n13 8 0\n2 6 1\n2 5 2\n2 5 1\n4 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n13 8 0\n2 6 1\n2 5 2\n2 5 1\n4 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n13 8 0\n2 6 1\n2 5 2\n2 5 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n13 8 0\n2 6 1\n2 5 2\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n13 8 0\n2 6 1\n2 5 2\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n23 8 0\n2 6 1\n2 5 2\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n23 8 0\n2 6 2\n2 5 2\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n23 8 0\n2 6 4\n2 5 2\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "12 1\n7 1 1\n3 6 2\n4 10 1\n23 8 0\n2 6 4\n2 5 2\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "12 1\n7 1 1\n3 6 2\n4 10 1\n23 8 0\n2 6 4\n2 5 2\n2 9 1\n0 8 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "12 1\n7 1 1\n5 6 2\n4 10 1\n23 8 0\n2 6 4\n2 5 2\n2 9 1\n0 8 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "10 25\n3 2 0\n3 6 1\n2 6 0\n2 8 1\n3 8 1\n8 9 0\n2 9 0\n6 5 0\n8 5 1\n3 1 0\n5 1 0\n3 4 0\n5 4 1\n4 7 0\n9 7 1\n8 10 1\n4 10 1\n7 4 1\n10 5 1\n5 9 1\n5 7 1\n9 3 0\n10 3 0\n9 6 0\n3 5 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n10 3 0\n3 5 0\n10 5 0\n10 1 1\n5 1 1\n3 7 0\n10 7 0\n5 2 0\n7 2 1\n10 6 1\n7 6 1\n7 9 0\n2 9 1\n7 8 0\n9 8 0\n5 4 1\n9 4 1\n6 9 1\n7 5 0\n6 4 1\n5 6 2\n1 4 1\n2 1 1\n4 7 0\n4 2 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n3 2 0\n3 6 1\n2 6 0\n2 8 1\n3 8 1\n8 9 0\n2 9 0\n6 5 0\n8 5 1\n3 1 0\n5 1 0\n3 4 0\n5 4 1\n4 7 0\n9 7 1\n8 10 1\n2 10 1\n10 3 1\n10 5 1\n5 9 1\n5 7 1\n9 3 0\n10 3 0\n9 6 0\n3 5 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "6 1\n2 3 1\n1 4 1\n4 5 1\n5 6 1\n2 6 0\n2 5 1\n2 4 1\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "4 1\n4 3 1\n3 4 0\n2 4 1\n",
            "output": "YES\n"
        },
        {
            "input": "10 25\n8 4 1\n4 3 0\n8 3 0\n3 7 0\n4 7 1\n7 1 1\n3 1 0\n7 10 0\n1 10 0\n10 2 0\n1 2 0\n2 5 1\n10 5 1\n2 9 1\n5 9 1\n5 6 1\n9 6 1\n7 8 0\n5 8 1\n1 2 1\n9 7 1\n9 3 1\n8 1 0\n5 3 1\n3 5 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n10 3 0\n3 5 0\n10 5 0\n10 1 1\n5 1 1\n3 7 0\n10 7 0\n5 2 0\n7 2 1\n10 6 1\n7 6 1\n7 9 0\n2 9 1\n7 8 0\n9 8 0\n5 4 1\n9 6 1\n6 9 1\n7 5 0\n6 8 1\n5 6 1\n1 4 1\n2 1 1\n4 7 0\n4 2 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 1\n4 5 1\n5 6 1\n2 4 0\n2 5 2\n2 4 1\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "4 1\n2 4 1\n3 4 1\n2 4 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 3 1\n3 8 1\n4 5 1\n7 6 1\n2 6 0\n2 5 2\n2 4 1\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "10 25\n3 2 0\n3 6 1\n2 6 0\n2 8 1\n3 8 2\n8 9 0\n2 9 0\n6 5 0\n8 5 1\n3 1 0\n5 1 0\n3 4 1\n5 4 1\n4 7 0\n9 7 0\n8 10 1\n2 10 1\n7 3 1\n10 5 1\n5 9 1\n5 8 1\n9 3 0\n10 3 0\n9 6 0\n3 5 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 1\n4 5 1\n7 6 1\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 2\n",
            "output": "YES\n"
        },
        {
            "input": "10 25\n3 2 0\n3 6 1\n2 6 0\n2 8 1\n3 8 1\n8 9 0\n2 9 0\n6 5 0\n8 1 1\n3 1 0\n5 1 0\n3 4 1\n5 4 1\n4 7 0\n9 7 0\n8 10 1\n2 10 1\n7 3 1\n10 5 1\n5 9 1\n5 8 1\n9 3 0\n10 3 0\n9 6 0\n3 10 1\n",
            "output": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 2\n4 5 1\n7 6 1\n2 6 0\n1 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 1 1\n3 4 2\n4 5 1\n7 6 1\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n0 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 1 1\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n4 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "5 1\n4 1 1\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "8 1\n4 1 1\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n2 0 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "8 1\n4 1 1\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 2\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "8 1\n4 1 1\n3 6 2\n4 5 1\n7 6 0\n2 6 0\n2 5 0\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n7 6 0\n2 6 0\n0 5 2\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n7 6 0\n2 6 1\n2 5 2\n2 4 1\n4 2 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n2 5 1\n13 6 0\n2 6 1\n2 5 2\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n13 6 0\n2 6 1\n2 5 2\n2 5 1\n4 5 0\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n13 8 0\n2 6 1\n2 5 2\n2 5 2\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n9 8 0\n2 6 1\n2 5 2\n2 5 1\n4 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n13 8 0\n2 6 1\n2 5 2\n2 10 1\n4 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n13 8 -1\n2 6 1\n2 5 2\n2 5 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n13 8 0\n2 6 1\n2 5 2\n3 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n13 8 0\n2 6 1\n2 5 2\n2 9 1\n0 5 1\n0 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n23 8 0\n2 6 1\n4 5 2\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n23 8 0\n2 6 2\n2 6 2\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n23 12 0\n2 6 4\n2 5 2\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "12 1\n7 1 1\n3 6 2\n4 10 1\n23 8 0\n2 6 4\n2 5 2\n2 2 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "12 1\n7 1 1\n5 6 2\n4 10 1\n23 8 0\n2 6 4\n2 5 2\n2 9 1\n0 9 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "10 25\n8 4 0\n4 3 0\n8 3 0\n3 7 0\n4 7 1\n7 1 1\n3 1 0\n7 10 0\n1 10 0\n10 2 0\n1 2 0\n2 5 1\n10 5 1\n2 9 1\n5 9 1\n5 6 1\n9 6 1\n7 8 0\n5 8 1\n4 2 1\n9 7 1\n9 3 1\n8 1 0\n5 3 1\n4 5 1\n",
            "output": "YES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n10 3 0\n3 5 0\n10 5 0\n10 1 1\n5 1 1\n3 7 0\n10 7 0\n5 2 0\n7 2 1\n10 6 1\n7 6 1\n7 9 0\n2 9 1\n7 8 0\n9 1 0\n5 4 1\n9 4 1\n6 9 1\n7 5 0\n6 4 1\n5 6 2\n1 4 1\n2 1 1\n4 7 0\n4 2 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "10 25\n9 8 1\n9 3 0\n8 3 1\n8 7 0\n9 7 0\n9 4 1\n3 4 1\n3 2 0\n8 2 1\n8 5 1\n3 5 1\n2 6 0\n9 6 0\n4 1 0\n2 1 0\n8 10 0\n9 10 1\n9 5 1\n7 1 0\n9 1 1\n10 4 0\n4 6 0\n7 3 1\n8 4 1\n6 5 1\n",
            "output": "YES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "6 1\n2 3 1\n1 4 1\n4 5 1\n5 6 1\n2 6 0\n2 5 1\n2 4 1\n3 5 0\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "4 1\n4 3 1\n3 4 0\n2 4 0\n",
            "output": "YES\n"
        },
        {
            "input": "10 25\n10 3 0\n3 5 0\n10 5 0\n10 1 1\n5 1 1\n3 7 0\n10 7 0\n5 2 0\n7 2 1\n10 6 1\n7 6 1\n7 9 0\n2 9 1\n7 8 0\n9 8 0\n5 4 1\n9 6 1\n6 9 1\n6 5 0\n6 8 1\n5 6 1\n1 4 1\n2 1 1\n4 7 0\n4 2 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "6 1\n2 3 1\n4 4 1\n4 5 1\n5 6 1\n2 4 0\n2 5 2\n2 4 1\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "4 1\n2 4 1\n3 4 1\n2 4 2\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 3 1\n3 8 1\n4 5 1\n7 6 1\n2 6 0\n2 5 2\n2 4 2\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 1\n4 5 1\n7 6 1\n2 6 0\n2 5 2\n2 7 1\n4 5 1\n4 6 2\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 2\n4 5 1\n10 6 1\n2 6 0\n1 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 1 1\n3 4 2\n4 2 1\n7 6 1\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n0 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 1 1\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n4 5 2\n1 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "5 2\n4 1 1\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\nYES\n"
        },
        {
            "input": "8 1\n4 1 1\n3 4 2\n4 5 0\n7 6 0\n2 6 0\n2 0 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "8 1\n4 1 1\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 2\n1 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "8 1\n4 1 1\n3 6 2\n4 5 0\n7 6 0\n2 6 0\n2 5 0\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n7 6 0\n2 6 0\n0 5 2\n2 4 1\n4 10 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n7 6 0\n2 6 1\n2 5 2\n2 4 1\n4 4 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n2 5 1\n13 6 0\n2 6 1\n2 9 2\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n13 9 0\n2 6 1\n2 5 2\n2 5 1\n4 5 0\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n13 8 0\n2 6 1\n2 0 2\n2 5 2\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n9 8 0\n2 6 1\n2 5 2\n2 5 1\n4 5 1\n1 8 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n13 8 0\n2 6 1\n3 5 2\n2 10 1\n4 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n9 8 -1\n2 6 1\n2 5 2\n2 5 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n13 8 0\n2 6 1\n2 5 2\n3 9 1\n0 6 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 9 2\n4 10 1\n13 8 0\n2 6 1\n2 5 2\n2 9 1\n0 5 1\n0 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n23 8 0\n2 6 1\n4 5 1\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n23 8 0\n2 6 2\n2 11 2\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n23 12 0\n2 6 4\n2 5 2\n2 18 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "12 1\n7 1 1\n5 6 2\n4 10 1\n23 8 0\n2 6 4\n3 5 2\n2 9 1\n0 9 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "10 25\n10 3 0\n3 5 0\n10 5 0\n10 1 1\n5 1 1\n3 7 0\n10 7 0\n5 2 0\n7 2 1\n10 6 1\n7 6 1\n7 9 1\n2 9 1\n7 8 0\n9 1 0\n5 4 1\n9 4 1\n6 9 1\n7 5 0\n6 4 1\n5 6 2\n1 4 1\n2 1 1\n4 7 0\n4 2 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "6 1\n2 3 1\n1 4 1\n4 5 1\n5 6 1\n2 6 0\n2 5 1\n2 4 1\n3 5 0\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "4 2\n4 3 1\n3 4 0\n2 4 1\n",
            "output": "YES\nYES\n"
        },
        {
            "input": "10 25\n10 3 0\n3 5 0\n10 5 0\n10 1 1\n5 1 1\n3 7 0\n10 7 0\n5 2 0\n7 2 1\n10 6 1\n7 6 1\n7 9 0\n2 9 1\n7 8 0\n9 8 0\n5 4 2\n9 6 1\n6 9 1\n6 5 0\n6 8 1\n5 6 1\n1 4 1\n2 1 1\n4 7 0\n4 2 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "6 1\n2 3 1\n4 4 1\n4 5 1\n5 6 2\n2 4 0\n2 5 2\n2 4 1\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "4 1\n2 4 1\n3 0 1\n2 4 2\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n4 3 1\n3 8 1\n4 5 1\n7 6 1\n2 6 0\n2 5 2\n2 4 2\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 1\n4 5 1\n7 6 1\n2 6 0\n2 5 2\n2 7 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "10 25\n5 1 1\n5 7 0\n1 7 1\n5 8 0\n1 8 1\n5 10 1\n1 10 0\n5 4 1\n1 4 0\n5 3 0\n1 3 1\n5 9 1\n1 9 1\n1 6 1\n5 6 0\n7 2 0\n1 2 0\n3 10 1\n4 3 0\n4 1 1\n8 10 0\n2 3 1\n6 5 0\n2 6 0\n6 10 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 2\n4 5 1\n10 6 1\n2 6 0\n1 5 2\n2 4 1\n4 5 1\n0 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 1 1\n4 4 2\n4 2 1\n7 6 1\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n0 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 1 1\n3 4 2\n4 5 1\n7 6 0\n2 12 0\n4 5 2\n1 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "5 2\n4 1 0\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\nYES\n"
        },
        {
            "input": "8 1\n4 1 1\n3 4 2\n4 5 0\n7 6 0\n2 6 0\n2 0 2\n2 8 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "8 1\n4 1 0\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 2\n1 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "7 1\n4 1 1\n3 6 2\n4 5 0\n7 6 0\n2 6 0\n2 5 0\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 0\n7 6 0\n2 6 0\n0 5 2\n2 4 1\n4 10 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 2 1\n3 6 2\n4 5 1\n7 6 0\n2 6 1\n2 5 2\n2 4 1\n4 4 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n2 5 1\n13 6 0\n0 6 1\n2 9 2\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n13 9 0\n2 6 1\n2 5 2\n2 5 1\n4 10 0\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n24 8 0\n2 6 1\n2 0 2\n2 5 2\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n9 8 0\n2 6 1\n2 5 2\n2 5 0\n4 5 1\n1 8 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n13 8 0\n2 6 1\n3 5 3\n2 10 1\n4 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n9 8 -1\n2 6 1\n2 5 2\n2 5 1\n0 5 1\n1 10 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n13 8 0\n2 6 2\n2 5 2\n3 9 1\n0 6 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 0\n3 9 2\n4 10 1\n13 8 0\n2 6 1\n2 5 2\n2 9 1\n0 5 1\n0 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n18 8 0\n2 6 1\n4 5 1\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n23 4 0\n2 6 2\n2 11 2\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 1\n23 12 0\n2 6 4\n2 5 2\n2 18 1\n0 9 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "12 1\n7 1 1\n5 6 2\n4 10 1\n23 8 0\n2 6 4\n3 5 2\n2 9 1\n0 9 1\n1 6 -1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 3 1\n1 4 1\n4 5 1\n5 6 1\n2 6 0\n2 5 1\n2 8 1\n3 5 0\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "4 2\n4 3 1\n2 4 0\n2 4 1\n",
            "output": "YES\nYES\n"
        },
        {
            "input": "6 1\n2 3 1\n4 4 1\n4 5 2\n5 6 2\n2 4 0\n2 5 2\n2 4 1\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "4 1\n2 4 1\n3 0 0\n2 4 2\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n4 3 1\n3 8 1\n4 5 1\n7 6 1\n2 0 0\n2 5 2\n2 4 2\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 1\n4 5 1\n7 6 1\n2 6 0\n2 5 2\n2 7 1\n4 5 1\n4 9 0\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 2\n4 5 1\n2 6 1\n2 6 0\n1 5 2\n2 4 1\n4 5 1\n0 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 1 1\n4 4 2\n4 3 1\n7 6 1\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n0 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 1 1\n3 4 2\n4 5 1\n9 6 0\n2 12 0\n4 5 2\n1 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "5 2\n4 1 0\n3 4 2\n5 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n4 6 1\n",
            "output": "YES\nYES\n"
        },
        {
            "input": "8 1\n4 1 1\n0 4 2\n4 5 0\n7 6 0\n2 6 0\n2 0 2\n2 8 1\n4 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "8 1\n6 1 0\n3 4 2\n4 5 1\n7 6 0\n2 6 0\n2 5 2\n2 4 2\n1 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "7 1\n4 1 1\n3 6 2\n4 5 0\n7 6 0\n2 6 0\n2 5 0\n2 4 1\n4 2 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n0 5 0\n7 6 0\n2 6 0\n0 5 2\n2 4 1\n4 10 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 2 1\n3 6 2\n4 5 1\n7 6 0\n4 6 1\n2 5 2\n2 4 1\n4 4 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n2 5 1\n13 6 0\n-1 6 1\n2 9 2\n2 4 1\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n13 9 0\n2 6 1\n2 5 2\n2 5 2\n4 10 0\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n24 8 0\n2 11 1\n2 0 2\n2 5 2\n4 5 1\n4 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 5 1\n9 8 0\n2 6 1\n2 5 2\n2 5 0\n4 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 1\n4 10 1\n13 8 0\n2 6 1\n3 5 3\n2 10 1\n4 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n5 8 -1\n2 6 1\n2 5 2\n2 5 1\n0 5 1\n1 10 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n4 1 1\n3 6 2\n4 10 1\n13 8 0\n2 6 2\n2 5 2\n3 9 1\n0 6 1\n1 1 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n13 1 0\n3 9 2\n4 10 1\n13 8 0\n2 6 1\n2 5 2\n2 9 1\n0 5 1\n0 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n3 6 2\n4 10 2\n18 8 0\n2 6 1\n4 5 1\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n5 6 2\n4 10 1\n23 4 0\n2 6 2\n2 11 2\n2 9 1\n0 5 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "13 1\n7 1 1\n6 6 2\n4 10 1\n23 12 0\n2 6 4\n2 5 2\n2 18 1\n0 9 1\n1 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "12 1\n7 1 2\n5 6 2\n4 10 1\n23 8 0\n2 6 4\n3 5 2\n2 9 1\n0 9 1\n1 6 -1\n",
            "output": "YES\n"
        },
        {
            "input": "10 25\n10 3 0\n3 5 0\n10 5 0\n10 1 1\n5 1 1\n3 7 0\n10 7 0\n5 2 0\n7 2 1\n10 6 1\n7 6 1\n7 9 1\n2 9 1\n7 1 0\n9 1 0\n5 4 1\n9 4 1\n6 9 1\n7 6 0\n6 4 1\n5 6 2\n1 4 1\n2 1 1\n4 7 0\n4 2 0\n",
            "output": "YES\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"
        },
        {
            "input": "6 1\n2 3 1\n1 4 1\n4 5 1\n5 6 1\n2 6 0\n2 5 1\n2 8 1\n3 5 0\n2 6 0\n",
            "output": "YES\n"
        },
        {
            "input": "4 2\n4 3 1\n2 4 0\n2 8 1\n",
            "output": "YES\nYES\n"
        },
        {
            "input": "6 1\n2 3 1\n4 4 1\n4 5 2\n5 6 2\n3 4 0\n2 5 2\n2 4 1\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n6 3 1\n3 8 1\n4 5 1\n7 6 1\n2 0 0\n2 5 2\n2 4 2\n3 5 1\n4 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 1\n4 5 1\n7 7 1\n2 6 0\n2 5 2\n2 7 1\n4 5 1\n4 9 0\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 3 1\n3 4 2\n4 5 1\n2 6 1\n2 6 0\n1 5 3\n2 4 1\n4 5 1\n0 6 1\n",
            "output": "YES\n"
        },
        {
            "input": "6 1\n2 1 1\n4 4 4\n4 3 1\n7 6 1\n2 6 0\n2 5 2\n2 4 1\n4 5 1\n0 6 1\n",
            "output": "YES\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstruct disjoin_set_union {\n  std::vector<int> parent;\n  std::vector<int> rank;\n  disjoin_set_union(int n = 0) : parent(n), rank(n, 1) {\n    std::iota(parent.begin(), parent.end(), 0);\n  }\n  int root(int v) { return (v ^ parent[v]) ? parent[v] = root(parent[v]) : v; }\n  bool unite(int v, int u) {\n    v = root(v), u = root(u);\n    if (v == u) return false;\n    if (rank[v] < rank[u]) std::swap(v, u);\n    rank[v] += rank[u];\n    parent[u] = v;\n    return true;\n  }\n};\nstruct link_cut {\n  struct node {\n    int parent;\n    std::array<int, 2> sons;\n    bool inv;\n    int size;\n    int value, tot;\n    node()\n        : parent(-1), sons({-1, -1}), inv(false), size(1), value(0), tot(0) {}\n  };\n  std::vector<node> tree;\n  void push(int v) {\n    if (tree[v].inv) {\n      tree[v].inv = false;\n      std::swap(tree[v].sons[0], tree[v].sons[1]);\n      for (const auto u : tree[v].sons)\n        if (u != -1) tree[u].inv ^= 1;\n    }\n  }\n  void relax(int v) {\n    push(v);\n    tree[v].size = 1;\n    for (const auto x : tree[v].sons)\n      if (x != -1) tree[v].size += tree[x].size;\n    tree[v].tot = tree[v].value;\n    for (const auto x : tree[v].sons)\n      if (x != -1) tree[v].tot ^= tree[x].tot;\n  }\n  void rotate(int v) {\n    int u = tree[v].parent, w = tree[u].parent;\n    push(u), push(v);\n    tree[v].parent = w;\n    if (w != -1)\n      for (auto &x : tree[w].sons)\n        if (x == u) x = v;\n    int i = tree[u].sons[1] == v;\n    tree[u].sons[i] = tree[v].sons[i ^ 1];\n    if (tree[v].sons[i ^ 1] != -1) tree[tree[v].sons[i ^ 1]].parent = u;\n    tree[v].sons[i ^ 1] = u;\n    tree[u].parent = v;\n    relax(u), relax(v);\n  }\n  bool is_root(int v) {\n    return tree[v].parent == -1 || (tree[tree[v].parent].sons[0] != v &&\n                                    tree[tree[v].parent].sons[1] != v);\n  }\n  void splay(int v) {\n    while (!is_root(v)) {\n      int u = tree[v].parent;\n      if (!is_root(u))\n        rotate((tree[tree[u].parent].sons[0] == u) == (tree[u].sons[0] == v)\n                   ? u\n                   : v);\n      rotate(v);\n    }\n    push(v);\n  }\n  void expose(int v) {\n    for (int u = v, prev = -1; u != -1; prev = u, u = tree[u].parent) {\n      splay(u);\n      tree[u].sons[1] = prev;\n      relax(u);\n    }\n    splay(v);\n    assert(tree[v].sons[1] == -1 && tree[v].parent == -1);\n  }\n  link_cut(int n = 0) : tree(n) {}\n  int add() {\n    tree.push_back(node());\n    return int(tree.size()) - 1;\n  }\n  void set_root(int root) {\n    expose(root);\n    tree[root].inv ^= 1;\n  }\n  bool connected(int v, int u) {\n    if (v == u) return true;\n    expose(v), expose(u);\n    return tree[v].parent != -1;\n  }\n  bool link(int v, int u) {\n    if (connected(v, u)) return false;\n    tree[u].inv ^= 1;\n    tree[u].parent = v;\n    expose(u);\n    return true;\n  }\n  bool cut(int v, int u) {\n    if (v == u) return false;\n    set_root(v), expose(u);\n    if (tree[u].sons[0] != v) return false;\n    tree[u].sons[0] = -1;\n    relax(u);\n    tree[v].parent = -1;\n    return true;\n  }\n  int parent(int v, int root) {\n    if (!connected(v, root)) return -1;\n    set_root(root), expose(v);\n    if (tree[v].sons[0] == -1) return -1;\n    v = tree[v].sons[0];\n    while (push(v), tree[v].sons[1] != -1) v = tree[v].sons[1];\n    splay(v);\n    return v;\n  }\n  int distance(int v, int u) {\n    if (!connected(v, u)) return -1;\n    set_root(v), expose(u);\n    return tree[u].sons[0] == -1 ? 0 : tree[tree[u].sons[0]].size;\n  }\n  void update(int v, int value) {\n    splay(v);\n    tree[v].value = value;\n    relax(v);\n  }\n  int query(int v, int u) {\n    assert(v != u);\n    set_root(v), expose(u);\n    assert(tree[u].sons[0] != -1);\n    return tree[u].value ^ tree[tree[u].sons[0]].tot;\n  }\n};\nint main() {\n  using namespace std;\n  ios::sync_with_stdio(false), cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  disjoin_set_union dsu(n);\n  link_cut g(n + m);\n  for (int id = n; id < n + m; id++) {\n    int v, u, c;\n    cin >> v >> u >> c;\n    v--, u--;\n    if (dsu.root(v) != dsu.root(u)) {\n      cout << \"YES\\n\";\n      dsu.unite(v, u);\n      g.link(v, id);\n      g.link(u, id);\n      g.update(id, c);\n    } else {\n      if (!g.connected(v, u) || (g.query(v, u) ^ c) == 0) {\n        cout << \"NO\\n\";\n        continue;\n      }\n      cout << \"YES\\n\";\n      while (u != v) {\n        int w = g.parent(u, v);\n        g.cut(u, w);\n        u = w;\n      }\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int DIM = 5E5 + 7;\nstruct node {\n  int u, v, c;\n} Q[DIM];\nint P[DIM], ans[DIM];\nint F(int x) {\n  if (x == P[x]) return x;\n  return P[x] = F(P[x]);\n}\nint sz[DIM], col[DIM];\nvector<pair<int, int> > G[DIM];\nvoid calc(int v, int par) {\n  sz[v] = 1;\n  for (auto [to, cl] : G[v]) {\n    if (to == par) continue;\n    col[to] = col[v] ^ cl;\n    calc(to, v);\n    sz[v] += sz[to];\n  }\n}\nint CH[DIM], head[DIM], HP[DIM], ch_sz[DIM], ptr = 0, pos[DIM], depth[DIM];\nvector<int> T[DIM], mod[DIM];\nvoid hld(int v, int par, int chain) {\n  HP[v] = par;\n  ++ch_sz[chain];\n  pos[v] = ch_sz[chain];\n  if (ch_sz[chain] == 1) head[chain] = v;\n  CH[v] = chain;\n  int big = -1;\n  for (auto [to, cl] : G[v]) {\n    if (to == par) continue;\n    depth[to] = depth[v] + 1;\n    if (big == -1 || sz[big] < sz[to]) big = to;\n  }\n  if (big != -1) {\n    hld(big, v, chain);\n    for (auto [to, cl] : G[v]) {\n      if (to == par || to == big) continue;\n      hld(to, v, ++ptr);\n    }\n  }\n}\nvoid push(int t, int ind) {\n  if (mod[ind][t])\n    mod[ind][t * 2 + 1] = mod[ind][t * 2 + 2] = T[ind][t * 2 + 1] =\n        T[ind][t * 2 + 2] = 1;\n  mod[ind][t] = 0;\n}\nvoid update(int t, int tl, int tr, int l, int r, int ind) {\n  if (tl > r || l > tr) return;\n  if (l <= tl && tr <= r) {\n    T[ind][t] = mod[ind][t] = 1;\n    return;\n  }\n  push(t, ind);\n  int tm = (tl + tr) / 2;\n  update(t * 2 + 1, tl, tm, l, r, ind);\n  update(t * 2 + 2, tm + 1, tr, l, r, ind);\n  T[ind][t] = max(T[ind][t * 2 + 1], T[ind][t * 2 + 2]);\n}\nint get(int t, int tl, int tr, int l, int r, int ind) {\n  if (l > tr || tl > r) return 0;\n  if (l <= tl && tr <= r) return T[ind][t];\n  push(t, ind);\n  int tm = (tl + tr) / 2;\n  return max(get(t * 2 + 1, tl, tm, l, r, ind),\n             get(t * 2 + 2, tm + 1, tr, l, r, ind));\n}\nint get(int a, int b) {\n  int res = 0;\n  while (CH[a] != CH[b]) {\n    if (depth[head[CH[a]]] < depth[head[CH[b]]]) swap(a, b);\n    res = max(res, get(0, 1, ch_sz[CH[a]], 1, pos[a], CH[a]));\n    a = HP[head[CH[a]]];\n  }\n  if (depth[a] > depth[b]) swap(a, b);\n  if (a != b)\n    res = max(res, get(0, 1, ch_sz[CH[a]], pos[a] + 1, pos[b], CH[a]));\n  return res;\n}\nvoid paint(int a, int b) {\n  while (CH[a] != CH[b]) {\n    if (depth[head[CH[a]]] < depth[head[CH[b]]]) swap(a, b);\n    update(0, 1, ch_sz[CH[a]], 1, pos[a], CH[a]);\n    a = HP[head[CH[a]]];\n  }\n  if (depth[a] > depth[b]) swap(a, b);\n  if (a != b) update(0, 1, ch_sz[CH[a]], pos[a] + 1, pos[b], CH[a]);\n}\nvoid solve() {\n  int n, q;\n  cin >> n >> q;\n  for (int i = 1; i <= n; ++i) {\n    P[i] = i;\n  }\n  for (int i = 1; i <= q; ++i) {\n    cin >> Q[i].u >> Q[i].v >> Q[i].c;\n    int u = Q[i].u, v = Q[i].v;\n    if (F(u) != F(v)) {\n      G[u].push_back({v, Q[i].c});\n      G[v].push_back({u, Q[i].c});\n      P[F(u)] = F(v);\n      ans[i] = 1;\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (sz[i] == 0) calc(i, i);\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (CH[i] == 0) {\n      hld(i, i, ++ptr);\n    }\n  }\n  for (int i = 1; i <= ptr; ++i) {\n    T[i].resize(ch_sz[i] * 4);\n    mod[i].resize(ch_sz[i] * 4);\n    for (int j = 0; j < ch_sz[i] * 4; ++j) T[i][j] = 0, mod[i][j] = 0;\n  }\n  for (int i = 1; i <= n; ++i) P[i] = i;\n  for (int i = 1; i <= q; ++i) {\n    int u = Q[i].u, v = Q[i].v, c = Q[i].c;\n    if (ans[i]) {\n      cout << \"YES\\n\";\n      P[F(u)] = F(v);\n    } else {\n      if (col[u] ^ col[v] ^ c == 1 && !get(u, v))\n        paint(u, v), cout << \"YES\\n\";\n      else\n        cout << \"NO\\n\";\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstruct disjoin_set_union {\n  std::vector<int> parent;\n  std::vector<int> rank;\n  disjoin_set_union(int n = 0) : parent(n), rank(n, 1) {\n    std::iota(parent.begin(), parent.end(), 0);\n  }\n  int root(int v) { return (v ^ parent[v]) ? parent[v] = root(parent[v]) : v; }\n  bool unite(int v, int u) {\n    v = root(v), u = root(u);\n    if (v == u) return false;\n    if (rank[v] < rank[u]) std::swap(v, u);\n    rank[v] += rank[u];\n    parent[u] = v;\n    return true;\n  }\n};\nstruct link_cut {\n  struct node {\n    int parent;\n    std::array<int, 2> sons;\n    bool inv;\n    int size;\n    int value, tot;\n    node()\n        : parent(-1), sons({-1, -1}), inv(false), size(1), value(0), tot(0) {}\n  };\n  std::vector<node> tree;\n  void push(int v) {\n    if (tree[v].inv) {\n      tree[v].inv = false;\n      std::swap(tree[v].sons[0], tree[v].sons[1]);\n      for (const auto u : tree[v].sons)\n        if (u != -1) tree[u].inv ^= 1;\n    }\n  }\n  void relax(int v) {\n    push(v);\n    tree[v].size = 1;\n    for (const auto x : tree[v].sons)\n      if (x != -1) tree[v].size += tree[x].size;\n    tree[v].tot = tree[v].value;\n    for (const auto x : tree[v].sons)\n      if (x != -1) tree[v].tot ^= tree[x].tot;\n  }\n  void rotate(int v) {\n    int u = tree[v].parent, w = tree[u].parent;\n    push(u), push(v);\n    tree[v].parent = w;\n    if (w != -1)\n      for (auto &x : tree[w].sons)\n        if (x == u) x = v;\n    int i = tree[u].sons[1] == v;\n    tree[u].sons[i] = tree[v].sons[i ^ 1];\n    if (tree[v].sons[i ^ 1] != -1) tree[tree[v].sons[i ^ 1]].parent = u;\n    tree[v].sons[i ^ 1] = u;\n    tree[u].parent = v;\n    relax(u), relax(v);\n  }\n  bool is_root(int v) {\n    return tree[v].parent == -1 || (tree[tree[v].parent].sons[0] != v &&\n                                    tree[tree[v].parent].sons[1] != v);\n  }\n  void splay(int v) {\n    while (!is_root(v)) {\n      int u = tree[v].parent;\n      if (!is_root(u))\n        rotate((tree[tree[u].parent].sons[0] == u) == (tree[u].sons[0] == v)\n                   ? u\n                   : v);\n      rotate(v);\n    }\n    push(v);\n  }\n  void expose(int v) {\n    for (int u = v, prev = -1; u != -1; prev = u, u = tree[u].parent) {\n      splay(u);\n      tree[u].sons[1] = prev;\n      relax(u);\n    }\n    splay(v);\n  }\n  link_cut(int n = 0) : tree(n) {}\n  int add() {\n    tree.push_back(node());\n    return int(tree.size()) - 1;\n  }\n  void set_root(int root) {\n    expose(root);\n    tree[root].inv ^= 1;\n  }\n  bool connected(int v, int u) {\n    if (v == u) return true;\n    expose(v), expose(u);\n    return tree[v].parent != -1;\n  }\n  bool link(int v, int u) {\n    if (connected(v, u)) return false;\n    tree[u].inv ^= 1;\n    tree[u].parent = v;\n    expose(u);\n    return true;\n  }\n  bool cut(int v, int u) {\n    if (v == u) return false;\n    set_root(v), expose(u);\n    if (tree[u].sons[0] != v) return false;\n    tree[u].sons[0] = -1;\n    relax(u);\n    tree[v].parent = -1;\n    return true;\n  }\n  int parent(int v, int root) {\n    if (!connected(v, root)) return -1;\n    set_root(root), expose(v);\n    if (tree[v].sons[0] == -1) return -1;\n    v = tree[v].sons[0];\n    while (push(v), tree[v].sons[1] != -1) v = tree[v].sons[1];\n    splay(v);\n    return v;\n  }\n  int distance(int v, int u) {\n    if (!connected(v, u)) return -1;\n    set_root(v), expose(u);\n    return tree[u].sons[0] == -1 ? 0 : tree[tree[u].sons[0]].size;\n  }\n  void update(int v, int value) {\n    splay(v);\n    tree[v].value = value;\n    relax(v);\n  }\n  int query(int v, int u) {\n    set_root(v), expose(u);\n    return tree[u].value ^ tree[tree[u].sons[0]].tot;\n  }\n};\nint main() {\n  using namespace std;\n  ios::sync_with_stdio(false), cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  disjoin_set_union dsu(n);\n  link_cut g(n + m);\n  for (int id = n; id < n + m; id++) {\n    int v, u, c;\n    cin >> v >> u >> c;\n    v--, u--;\n    if (dsu.root(v) != dsu.root(u)) {\n      cout << \"YES\\n\";\n      dsu.unite(v, u);\n      g.link(v, id);\n      g.link(u, id);\n      g.update(id, c);\n    } else {\n      if (!g.connected(v, u) || (g.query(v, u) ^ c) == 0) {\n        cout << \"NO\\n\";\n        continue;\n      }\n      cout << \"YES\\n\";\n      while (u != v) {\n        int w = g.parent(u, v);\n        g.cut(u, w);\n        u = w;\n      }\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 8e5 + 10, inf = 0x3f3f3f3f, llinf = 0x3f3f3f3f3f3f3f3f;\nconst int M = 2e7 + 5;\nlong long n, m, q;\nlong long nn;\nint a[N];\nstruct LCT {\n  int c[N][2], fa[N], s[N], r[N], st[N], cir[N], tcir[N];\n  inline int lc(int x) { return c[x][0]; }\n  inline int rc(int x) { return c[x][1]; }\n  void pushup(int x) {\n    s[x] = s[lc(x)] ^ s[rc(x)] ^ a[x];\n    cir[x] = cir[lc(x)] | cir[rc(x)] | tcir[x];\n  }\n  void pushr(int x) {\n    swap(c[x][0], c[x][1]);\n    r[x] ^= 1;\n  }\n  void pushdown(int x) {\n    if (r[x]) {\n      if (lc(x)) pushr(lc(x));\n      if (rc(x)) pushr(rc(x));\n      r[x] = 0;\n    }\n  }\n  int nroot(int x) { return lc(fa[x]) == x || rc(fa[x]) == x; }\n  void rotate(int x) {\n    int y = fa[x], z = fa[y];\n    int ys = c[y][1] == x, zs = c[z][1] == y, w = c[x][!ys];\n    if (nroot(y)) c[z][zs] = x;\n    c[x][!ys] = y;\n    c[y][ys] = w;\n    if (w) fa[w] = y;\n    fa[x] = z;\n    fa[y] = x;\n    pushup(x);\n    pushup(y);\n  }\n  void splay(int x) {\n    int y = x, tot = 0;\n    st[++tot] = y;\n    while (nroot(y)) {\n      st[++tot] = fa[y];\n      y = fa[y];\n    }\n    while (tot) pushdown(st[tot--]);\n    while (nroot(x)) {\n      int y = fa[x], z = fa[y];\n      if (nroot(y)) {\n        rotate((c[y][0] == x) ^ (c[z][0] == y) ? x : y);\n      }\n      rotate(x);\n    }\n    pushup(x);\n  }\n  void access(int x) {\n    for (int y = 0; x; y = x, x = fa[x]) {\n      splay(x);\n      c[x][1] = y;\n      pushup(x);\n    }\n  }\n  int findroot(int x) {\n    access(x);\n    splay(x);\n    while (lc(x)) {\n      pushdown(x);\n      x = lc(x);\n    }\n    splay(x);\n    return x;\n  }\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    pushr(x);\n  }\n  void split(int x, int y) {\n    makeroot(x);\n    access(y);\n    splay(y);\n  }\n  void link(int x, int y) {\n    makeroot(x);\n    if (findroot(y) != x) fa[x] = y;\n  }\n  void cut(int x, int y) {\n    makeroot(x);\n    if (findroot(y) == x && fa[y] == x && !lc(y)) {\n      fa[y] = c[x][1] = 0;\n      pushup(x);\n    }\n  }\n  void update(int x) {\n    if (x > n) {\n      tcir[x] = 1;\n    }\n    if (lc(x)) update(lc(x));\n    if (rc(x)) update(rc(x));\n    pushup(x);\n  }\n  int work(int x, int y, int z) {\n    if (findroot(x) != findroot(y)) {\n      ++nn;\n      a[nn] = z;\n      link(x, nn);\n      link(nn, y);\n      return 1;\n    } else {\n      split(x, y);\n      if ((s[y] ^ z) == 1 && !cir[y]) {\n        splay(x);\n        update(x);\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }\n} lct;\nvoid solve() {\n  cin >> n >> q;\n  nn = n;\n  for (int i = 1; i <= q; ++i) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    if (lct.work(u, v, x)) {\n      cout << ((1) ? \"YES\" : \"NO\") << '\\n';\n    } else {\n      cout << ((0) ? \"YES\" : \"NO\") << '\\n';\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  ;\n  int tt = 1;\n  while (tt--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstatic char buf[200 << 20];\nvoid* operator new(size_t s) {\n  static size_t i = sizeof buf;\n  assert(s < i);\n  return (void*)&buf[i -= s];\n}\nvoid operator delete(void*) {}\nconst int inf = 1e9;\nstruct Node {\n  Node *l = 0, *r = 0;\n  int lo, hi, mset = inf, madd = 0, val = 0;\n  Node(int lo, int hi) : lo(lo), hi(hi) {}\n  Node(vector<int>& v, int lo, int hi) : lo(lo), hi(hi) {\n    if (lo + 1 < hi) {\n      int mid = lo + (hi - lo) / 2;\n      l = new Node(v, lo, mid);\n      r = new Node(v, mid, hi);\n      val = max(l->val, r->val);\n    } else\n      val = v[lo];\n  }\n  int query(int L, int R) {\n    if (R <= lo || hi <= L) return -inf;\n    if (L <= lo && hi <= R) return val;\n    push();\n    return max(l->query(L, R), r->query(L, R));\n  }\n  void set(int L, int R, int x) {\n    if (R <= lo || hi <= L) return;\n    if (L <= lo && hi <= R)\n      mset = val = x, madd = 0;\n    else {\n      push(), l->set(L, R, x), r->set(L, R, x);\n      val = max(l->val, r->val);\n    }\n  }\n  void add(int L, int R, int x) {\n    if (R <= lo || hi <= L) return;\n    if (L <= lo && hi <= R) {\n      if (mset != inf)\n        mset += x;\n      else\n        madd += x;\n      val += x;\n    } else {\n      push(), l->add(L, R, x), r->add(L, R, x);\n      val = max(l->val, r->val);\n    }\n  }\n  void push() {\n    if (!l) {\n      int mid = lo + (hi - lo) / 2;\n      l = new Node(lo, mid);\n      r = new Node(mid, hi);\n    }\n    if (mset != inf)\n      l->set(lo, hi, mset), r->set(lo, hi, mset), mset = inf;\n    else if (madd)\n      l->add(lo, hi, madd), r->add(lo, hi, madd), madd = 0;\n  }\n};\ntemplate <bool VALS_EDGES>\nstruct HLD {\n  int N, tim = 0;\n  vector<vector<int>> adj;\n  vector<int> par, siz, depth, rt, pos;\n  Node* tree;\n  HLD(vector<vector<int>> adj_)\n      : N(adj_.size()),\n        adj(adj_),\n        par(N, -1),\n        siz(N, 1),\n        depth(N),\n        rt(N),\n        pos(N),\n        tree(new Node(0, N)) {\n    dfsSz(0);\n    dfsHld(0);\n  }\n  void dfsSz(int v) {\n    if (par[v] != -1) adj[v].erase(find(adj[v].begin(), adj[v].end(), par[v]));\n    for (int& u : adj[v]) {\n      par[u] = v, depth[u] = depth[v] + 1;\n      dfsSz(u);\n      siz[v] += siz[u];\n      if (siz[u] > siz[adj[v][0]]) swap(u, adj[v][0]);\n    }\n  }\n  void dfsHld(int v) {\n    pos[v] = tim++;\n    for (int u : adj[v]) {\n      rt[u] = (u == adj[v][0] ? rt[v] : u);\n      dfsHld(u);\n    }\n  }\n  template <class B>\n  void process(int u, int v, B op) {\n    for (; rt[u] != rt[v]; v = par[rt[v]]) {\n      if (depth[rt[u]] > depth[rt[v]]) swap(u, v);\n      op(pos[rt[v]], pos[v] + 1);\n    }\n    if (depth[u] > depth[v]) swap(u, v);\n    op(pos[u] + VALS_EDGES, pos[v] + 1);\n  }\n  void modifyPath(int u, int v, int val) {\n    process(u, v, [&](int l, int r) { tree->add(l, r, val); });\n  }\n  int queryPath(int u, int v) {\n    int res = -1e9;\n    process(u, v, [&](int l, int r) { res = max(res, tree->query(l, r)); });\n    return res;\n  }\n  int querySubtree(int v) {\n    return tree->query(pos[v] + VALS_EDGES, pos[v] + siz[v]);\n  }\n};\nclass DSU {\n  vector<int> rank, parent;\n  int n;\n\n public:\n  DSU(int n) : rank(n, 0), parent(n) {\n    this->n = n;\n    for (int i = 0; i < n; ++i) parent[i] = i;\n  }\n  int find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n  }\n  void join(int x, int y) {\n    int xset = find(x);\n    int yset = find(y);\n    if (xset == yset) return;\n    if (rank[xset] < rank[yset])\n      parent[xset] = yset;\n    else if (rank[xset] > rank[yset])\n      parent[yset] = xset;\n    else {\n      parent[yset] = xset;\n      rank[xset]++;\n    }\n  }\n};\nvector<int> get_parents(const vector<vector<int>>& adj, int root) {\n  int n = adj.size();\n  vector<int> parents(n, -1);\n  stack<pair<int, int>> st;\n  st.emplace(root, -1);\n  while (!st.empty()) {\n    int node = st.top().first;\n    parents[node] = st.top().second;\n    st.pop();\n    for (int i : adj[node]) {\n      if (i != parents[node]) {\n        st.emplace(i, node);\n      }\n    }\n  }\n  return parents;\n}\nvector<vector<int>> get_children(const vector<int>& parents) {\n  int n = parents.size();\n  vector<vector<int>> children(n);\n  for (int i = 0; i < n; ++i) {\n    if (parents[i] >= 0) {\n      children[parents[i]].push_back(i);\n    }\n  }\n  return children;\n}\nvector<bool> solve_component(int n,\n                             const vector<pair<pair<int, int>, int>>& queries) {\n  int n_queries = queries.size();\n  vector<bool> ans(n_queries, false);\n  vector<int> edge_indices;\n  DSU dsu(n);\n  vector<int> remaining;\n  for (int qi = 0; qi < n_queries; ++qi) {\n    int u = queries[qi].first.first;\n    int v = queries[qi].first.second;\n    if (dsu.find(u) != dsu.find(v)) {\n      ans[qi] = true;\n      edge_indices.push_back(qi);\n      dsu.join(u, v);\n    } else {\n      remaining.push_back(qi);\n    }\n  }\n  assert(int(edge_indices.size()) == (n - 1));\n  vector<vector<int>> adj(n);\n  for (int i : edge_indices) {\n    const pair<int, int>& edge = queries[i].first;\n    adj[edge.first].push_back(edge.second);\n    adj[edge.second].push_back(edge.first);\n  }\n  vector<int> parents = get_parents(adj, 0);\n  vector<int> cumxor(n, 0);\n  for (int i : edge_indices) {\n    const pair<int, int>& edge = queries[i].first;\n    if (parents[edge.first] == edge.second) {\n      cumxor[edge.first] = queries[i].second;\n    } else {\n      cumxor[edge.second] = queries[i].second;\n    }\n  }\n  vector<vector<int>> children = get_children(parents);\n  vector<int> q(1, 0);\n  for (int i = 0; i < int(q.size()); ++i) {\n    if (parents[q[i]] >= 0) {\n      cumxor[q[i]] ^= cumxor[parents[q[i]]];\n    }\n    q.insert(q.end(), children[q[i]].begin(), children[q[i]].end());\n  }\n  HLD<true> hld(adj);\n  for (int qi : remaining) {\n    int u = queries[qi].first.first;\n    int v = queries[qi].first.second;\n    int x = queries[qi].second;\n    if (((cumxor[u] ^ cumxor[v] ^ x) != 1) || (hld.queryPath(u, v) > 0)) {\n      ans[qi] = false;\n      continue;\n    }\n    ans[qi] = true;\n    hld.modifyPath(u, v, 1);\n  }\n  return ans;\n}\nvector<bool> solve(int n, const vector<int>& u, const vector<int>& v,\n                   const vector<int>& x) {\n  int q = u.size();\n  DSU dsu(n);\n  for (int i = 0; i < q; ++i) {\n    dsu.join(u[i], v[i]);\n  }\n  vector<int> component_map(n, -1);\n  vector<vector<int>> components;\n  int n_components = 0;\n  for (int i = 0; i < n; ++i) {\n    int compi = dsu.find(i);\n    if (component_map[compi] < 0) {\n      component_map[compi] = n_components++;\n      components.emplace_back();\n    }\n    int j = component_map[compi];\n    components[j].push_back(i);\n  }\n  vector<vector<int>> queries_by_component(n_components);\n  for (int i = 0; i < q; ++i) {\n    queries_by_component[component_map[dsu.find(u[i])]].push_back(i);\n  }\n  vector<bool> ans(q);\n  vector<int> vertex_map(n, -1);\n  for (int compi = 0; compi < n_components; ++compi) {\n    vector<pair<pair<int, int>, int>> queries;\n    int compn = components[compi].size();\n    for (int i = 0; i < compn; ++i) {\n      vertex_map[components[compi][i]] = i;\n    }\n    for (int i : queries_by_component[compi]) {\n      queries.emplace_back(make_pair(vertex_map[u[i]], vertex_map[v[i]]), x[i]);\n    }\n    vector<bool> comp_ans = solve_component(compn, queries);\n    for (int i = 0; i < int(queries_by_component[compi].size()); ++i) {\n      ans[queries_by_component[compi][i]] = comp_ans[i];\n    }\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, q;\n  cin >> n >> q;\n  vector<int> u(q), v(q), x(q);\n  for (int i = 0; i < q; ++i) {\n    cin >> u[i] >> v[i] >> x[i];\n    --u[i];\n    --v[i];\n  }\n  vector<bool> ans = solve(n, u, v, x);\n  for (int i = 0; i < q; ++i) {\n    cout << (ans[i] ? \"YES\" : \"NO\") << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 600005;\nconst int inf = 1 << 30;\nstruct BIT {\n  int c[maxn];\n  void update(int x, int val, int n) {\n    for (int i = x; i <= n; i += i & -i) {\n      c[i] += val;\n    }\n  }\n  int ask(int x) {\n    int ans = 0;\n    for (int i = x; i; i -= i & -i) {\n      ans += c[i];\n    }\n    return ans;\n  }\n} T;\nstruct Edge {\n  int to, next, val;\n  Edge(int to = 0, int next = 0, int val = 0) : to(to), next(next), val(val) {}\n} a[maxn * 2];\nstruct Question {\n  int x, y, val;\n} e[maxn];\nint n, m;\nint cnt;\nint tot;\nint top;\nint h[maxn];\nint fa[maxn];\nint lg[maxn];\nint ans[maxn];\nint pre[maxn];\nint fir[maxn];\nint lst[maxn];\nint depth[maxn];\nint st[20][maxn * 2];\nint xor_val[maxn * 2];\nbool vis[maxn];\nvoid add(int x, int y, int val) {\n  a[++cnt] = Edge(y, h[x], val);\n  h[x] = cnt;\n}\nint f(int x) { return fa[x] == x ? x : fa[x] = f(fa[x]); }\nvoid dfs(int x) {\n  vis[x] = 1;\n  st[0][++top] = x;\n  pre[x] = top;\n  fir[x] = ++tot;\n  for (int i = h[x]; i; i = a[i].next) {\n    if (vis[a[i].to]) {\n      continue;\n    }\n    xor_val[a[i].to] = xor_val[x] ^ a[i].val;\n    depth[a[i].to] = depth[x] + 1;\n    fa[a[i].to] = x;\n    dfs(a[i].to);\n    st[0][++top] = x;\n  }\n  lst[x] = tot;\n}\nint getmin(int x, int y) { return depth[x] < depth[y] ? x : y; }\nint lca(int x, int y) {\n  x = pre[x], y = pre[y];\n  if (x > y) {\n    swap(x, y);\n  }\n  int k = lg[y - x + 1];\n  return getmin(st[k][x], st[k][y - (1 << k) + 1]);\n}\nint xor_dist(int x, int y) { return xor_val[x] ^ xor_val[y]; }\nint check(int x, int y, int p) {\n  return T.ask(fir[x]) + T.ask(fir[y]) - 2 * T.ask(fir[p]);\n}\nvoid update(int x, int p) {\n  if (x == p) {\n    return;\n  }\n  while (x != p) {\n    T.update(fir[x], 1, n);\n    T.update(lst[x] + 1, -1, n);\n    x = fa[x];\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    fa[i] = i;\n  }\n  for (int i = 1; i <= m; i++) {\n    cin >> e[i].x >> e[i].y >> e[i].val;\n    int x = f(e[i].x), y = f(e[i].y);\n    if (x != y) {\n      add(e[i].x, e[i].y, e[i].val);\n      add(e[i].y, e[i].x, e[i].val);\n      fa[x] = y;\n      ans[i] = 1;\n    }\n  }\n  memset(fa, 0, sizeof(fa));\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      dfs(i);\n    }\n  }\n  for (int i = 2; i <= top; i++) {\n    lg[i] = lg[i >> 1] + 1;\n  }\n  for (int i = 1; (1 << i) <= top; i++) {\n    for (int j = 1; j + (1 << i) - 1 <= top; j++) {\n      st[i][j] = getmin(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    if (ans[i]) {\n      continue;\n    }\n    int x = e[i].x, y = e[i].y, val = e[i].val;\n    if ((xor_dist(x, y) ^ val) == 0) {\n      continue;\n    }\n    int p = lca(x, y);\n    if (check(x, y, p)) {\n      continue;\n    }\n    update(x, p);\n    update(y, p);\n    ans[i] = 1;\n  }\n  for (int i = 1; i <= m; i++) {\n    cout << (ans[i] ? \"YES\" : \"NO\") << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  bool f = true;\n  long long x = 0;\n  register char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = false;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9')\n    x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n  if (f) return x;\n  return ~(--x);\n}\ninline void write(const long long &x) {\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n}\ninline void print(const long long &x) {\n  x < 0 ? putchar('-'), write(~(x - 1)) : write(x);\n  putchar('\\n');\n}\ninline long long max(const long long &a, const long long &b) {\n  return a > b ? a : b;\n}\ninline long long min(const long long &a, const long long &b) {\n  return a < b ? a : b;\n}\nconst int MAXN = 3e5 + 7;\nint fa[MAXN];\nint find(int k) { return k == fa[k] ? k : fa[k] = find(fa[k]); }\nbool merge(int u, int v) {\n  u = find(u), v = find(v);\n  if (u == v) return 1;\n  fa[v] = u;\n  return 0;\n}\nvector<int> g[MAXN], W[MAXN];\nint ans[MAXN * 2];\nstruct edge {\n  int u, v, w, id;\n} e[MAXN * 2];\nint n, q, m;\nnamespace Tree {\nint dfn[MAXN], fa[MAXN], top[MAXN], siz[MAXN], son[MAXN], dep[MAXN], val[MAXN],\n    cnt;\nstruct BIT {\n  int t[MAXN];\n  void add(int k, int val) {\n    for (; k < MAXN; k += k & (-k)) t[k] += val;\n  }\n  inline int ask(int k) {\n    int ans = 0;\n    for (; k; k -= k & (-k)) ans += t[k];\n    return ans;\n  }\n  int query(int l, int r) { return ask(r) - ask(l - 1); }\n  void modify(int l, int r) {\n    for (register int i = l; i <= r; ++i) add(i, 1);\n  }\n} T;\nvoid dfs1(int u, int F) {\n  fa[u] = F;\n  siz[u] = 1;\n  for (register int i = 0; i < g[u].size(); ++i) {\n    int v = g[u][i];\n    if (v == F) continue;\n    dep[v] = dep[u] + 1, val[v] = val[u] ^ W[u][i], dfs1(v, u);\n    siz[u] += siz[v];\n    if (siz[v] > siz[son[u]]) son[u] = v;\n  }\n}\nvoid dfs2(int u, int F, int topf) {\n  top[u] = topf, dfn[u] = ++cnt;\n  if (son[u]) dfs2(son[u], u, topf);\n  for (auto v : g[u]) {\n    if (v == F || v == son[u]) continue;\n    dfs2(v, u, v);\n  }\n}\nint LCA(int u, int v) {\n  while (top[u] != top[v]) {\n    if (dep[top[u]] < dep[top[v]]) swap(u, v);\n    u = fa[top[u]];\n  }\n  if (dep[u] < dep[v]) swap(u, v);\n  return v;\n}\nint query(int u, int v) {\n  int res = 0;\n  while (top[u] != top[v]) {\n    if (dep[top[u]] < dep[top[v]]) swap(u, v);\n    res += T.query(dfn[top[u]], dfn[u]);\n    u = fa[top[u]];\n  }\n  if (dep[u] < dep[v]) swap(u, v);\n  res += T.query(dfn[v] + 1, dfn[u]);\n  return res;\n}\nvoid modify(int u, int v) {\n  while (top[u] != top[v]) {\n    if (dep[top[u]] < dep[top[v]]) swap(u, v);\n    T.modify(dfn[top[u]], dfn[u]);\n    u = fa[top[u]];\n  }\n  if (dep[u] < dep[v]) swap(u, v);\n  T.modify(dfn[v] + 1, dfn[u]);\n}\n}  // namespace Tree\nint main() {\n  n = read(), q = read();\n  for (register int i = 1; i <= n; ++i) fa[i] = i;\n  for (register int i = 1; i <= q; ++i) {\n    int u = read(), v = read(), w = read();\n    if (!merge(u, v)) {\n      g[u].push_back(v), g[v].push_back(u);\n      W[u].push_back(w), W[v].push_back(w);\n      ans[i] = 1;\n    } else\n      e[++m] = (edge){u, v, w, i};\n  }\n  for (register int i = 1; i <= n; ++i) {\n    if (!Tree::siz[i]) {\n      Tree::dfs1(i, i);\n      Tree::dfs2(i, i, i);\n    }\n  }\n  for (register int i = 1; i <= m; ++i) {\n    int u = e[i].u, v = e[i].v;\n    if ((Tree::val[u] ^ Tree::val[v] ^ e[i].w) && !Tree::query(u, v)) {\n      ans[e[i].id] = 1;\n      Tree::modify(u, v);\n    }\n  }\n  for (register int i = 1; i <= q; ++i) puts(ans[i] ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &r) {\n  r = 0;\n  bool w = true;\n  char ch = getchar();\n  for (; !isdigit(ch); ch = getchar()) w ^= !(ch ^ 45);\n  for (; isdigit(ch); ch = getchar()) r = (r << 1) + (r << 3) + (ch ^ 48);\n  r = w ? r : -r;\n}\nstruct node_edge {\n  int to, next, weight;\n} edge[(500000 + 5) << 1];\nint head[300000 + 5], edge_num;\nvoid add(int u, int v, int w) {\n  ++edge_num;\n  edge[edge_num].to = v;\n  edge[edge_num].weight = w;\n  edge[edge_num].next = head[u];\n  head[u] = edge_num;\n}\nint n, m, ans[500000 + 5];\nint fat[300000 + 5];\nint find(int x) {\n  if (fat[x] == x) return x;\n  return fat[x] = find(fat[x]);\n}\nint from[500000 + 5], to[500000 + 5], weight[500000 + 5];\nvoid init() {\n  read(n), read(m);\n  for (register int i = 1; i <= n; i++) fat[i] = i;\n  for (register int i = 1; i <= m; i++) {\n    read(from[i]), read(to[i]), read(weight[i]);\n    if (find(from[i]) != find(to[i])) {\n      fat[find(from[i])] = find(to[i]);\n      ans[i] = true;\n      add(from[i], to[i], weight[i]);\n      add(to[i], from[i], weight[i]);\n    }\n  }\n}\nint fa[300000 + 5], depth[300000 + 5], size[300000 + 5], son[300000 + 5],\n    val[300000 + 5];\nvoid dfs1(int u) {\n  size[u] = 1;\n  for (register int i = head[u]; i; i = edge[i].next) {\n    int v = edge[i].to;\n    if (fa[u] == v) continue;\n    fa[v] = u;\n    depth[v] = depth[u] + 1;\n    val[v] = edge[i].weight;\n    dfs1(v);\n    size[u] += size[v];\n    if (size[son[u]] < size[v]) son[u] = v;\n  }\n}\nint pos[300000 + 5], bac[300000 + 5], belong[300000 + 5];\nvoid dfs2(int u, int chain) {\n  belong[u] = chain;\n  pos[u] = ++pos[0];\n  bac[pos[0]] = u;\n  if (son[u]) dfs2(son[u], chain);\n  for (register int i = head[u]; i; i = edge[i].next) {\n    int v = edge[i].to;\n    if (fa[u] == v || son[u] == v) continue;\n    dfs2(v, v);\n  }\n}\nstruct node_tree {\n  int l, r, val;\n  bool vis, lazy;\n} a[300000 << 2];\nvoid pushup(int p) {\n  a[p].vis = a[(p << 1)].vis | a[((p << 1) + 1)].vis;\n  a[p].val = a[(p << 1)].val ^ a[((p << 1) + 1)].val;\n}\nvoid pushdown(int p) {\n  if (a[p].lazy) {\n    a[(p << 1)].vis = a[(p << 1)].lazy = a[((p << 1) + 1)].vis =\n        a[((p << 1) + 1)].lazy = true;\n    a[p].lazy = false;\n  }\n}\nvoid build(int p, int l, int r) {\n  a[p].l = l, a[p].r = r;\n  if (l == r) {\n    a[p].val = val[bac[l]];\n    a[p].vis = false;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build((p << 1), l, mid);\n  build(((p << 1) + 1), mid + 1, r);\n  pushup(p);\n}\nvoid update(int p, int l, int r) {\n  if (a[p].l == l && a[p].r == r) {\n    a[p].vis = a[p].lazy = true;\n    return;\n  }\n  pushdown(p);\n  int mid = (a[p].l + a[p].r) >> 1;\n  if (r <= mid)\n    update((p << 1), l, r);\n  else if (l > mid)\n    update(((p << 1) + 1), l, r);\n  else {\n    update((p << 1), l, mid);\n    update(((p << 1) + 1), mid + 1, r);\n  }\n  pushup(p);\n}\nint query(int p, int l, int r) {\n  if (a[p].l == l && a[p].r == r) {\n    if (a[p].vis) return -1;\n    return a[p].val;\n  }\n  pushdown(p);\n  int mid = (a[p].l + a[p].r) >> 1;\n  if (r <= mid) return query((p << 1), l, r);\n  if (l > mid) return query(((p << 1) + 1), l, r);\n  int ls = query((p << 1), l, mid), rs = query(((p << 1) + 1), mid + 1, r);\n  if (ls == -1 || rs == -1) return -1;\n  return ls ^ rs;\n}\nvoid getpath(int i) {\n  int x = from[i], y = to[i], ret = weight[i];\n  while (belong[x] != belong[y]) {\n    if (depth[belong[x]] < depth[belong[y]]) swap(x, y);\n    int g = query(1, pos[belong[x]], pos[x]);\n    if (g == -1) return;\n    ret ^= g;\n    x = fa[belong[x]];\n  }\n  if (depth[x] < depth[y]) swap(x, y);\n  if (x != y) {\n    int g = query(1, pos[y] + 1, pos[x]);\n    if (g == -1) return;\n    ret ^= g;\n  }\n  if (ret) {\n    ans[i] = 1;\n    if (x != y) update(1, pos[y] + 1, pos[x]);\n    x = from[i], y = to[i];\n    while (belong[x] != belong[y]) {\n      if (depth[belong[x]] < depth[belong[y]]) swap(x, y);\n      update(1, pos[belong[x]], pos[x]);\n      x = fa[belong[x]];\n    }\n  }\n}\nvoid solve() {\n  for (register int i = 1; i <= n; i++) {\n    if (!size[i]) {\n      dfs1(i);\n      dfs2(i, i);\n    }\n  }\n  build(1, 1, n);\n  for (register int i = 1; i <= m; i++) {\n    if (!ans[i]) {\n      getpath(i);\n    }\n  }\n  for (register int i = 1; i <= m; i++) puts(ans[i] ? \"YES\" : \"NO\");\n}\nvoid write() {}\nint main() {\n  init();\n  solve();\n  write();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int s = 0, w = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n  return s * w;\n}\nconst int p = 998244353;\nint qp(int x, int y) {\n  int res = 1;\n  for (int t = x; y; y >>= 1, t = t * t % p)\n    if (y & 1) res = res * t % p;\n  return res;\n}\nint u[500003], v[500003], w[500003], Fa[300003];\nint find(int x) {\n  if (x == Fa[x]) return Fa[x];\n  return Fa[x] = find(Fa[x]);\n}\nint ans[500003];\nvector<pair<int, int> > e[300003];\nint sz[300003], fa[300003], dep[300003], son[300003], top[300003];\nint dfn[300003], inv[300003], lst[300003], tot;\nint V[300003];\ninline void dfs1(int x) {\n  sz[x] = 1;\n  for (auto xx : e[x]) {\n    int y = xx.first;\n    if (y != fa[x]) {\n      if (y == fa[x]) continue;\n      fa[y] = x, dep[y] = dep[x] + 1, V[y] = V[x] ^ xx.second, dfs1(y),\n      sz[x] += sz[y];\n      (sz[y] > sz[son[x]]) && (son[x] = y);\n    }\n  }\n}\ninline void dfs2(int x, int tp) {\n  top[x] = tp, dfn[x] = ++tot, inv[tot] = x;\n  if (son[x]) dfs2(son[x], tp);\n  for (auto xx : e[x]) {\n    int y = xx.first;\n    if (y != son[x] && y != fa[x]) dfs2(y, y);\n  }\n  lst[x] = tot;\n}\nint sum[4000003];\ninline void upd1(int nl, int nr, int l, int r, int i) {\n  if (r < nl || nr < l || sum[i] == 2) return;\n  if (l <= nl && nr <= r) return (void)(sum[i] = 2);\n  int mid = (nl + nr) >> 1;\n  upd1(nl, mid, l, r, i << 1), upd1(mid + 1, nr, l, r, (i << 1) + 1),\n      sum[i] = 1 + (sum[i << 1] == 2 && sum[(i << 1) + 1] == 2);\n  return;\n}\ninline int query(int nl, int nr, int l, int r, int i) {\n  if (r < nl || nr < l) return 0;\n  if (!sum[i]) return 0;\n  if (sum[i] == 2) return 1;\n  if (l <= nl && nr <= r) return sum[i];\n  int mid = (nl + nr) >> 1;\n  return query(nl, mid, l, r, i << 1) + query(mid + 1, nr, l, r, (i << 1) + 1);\n}\nsigned main() {\n  int n = read(), m = read();\n  for (int i = 1; i <= n; ++i) Fa[i] = i;\n  for (int i = 1; i <= m; ++i) u[i] = read(), v[i] = read(), w[i] = read();\n  for (int i = 1; i <= m; ++i) {\n    int A = find(u[i]), B = find(v[i]);\n    if (A != B) {\n      e[u[i]].push_back(make_pair(v[i], w[i])),\n          e[v[i]].push_back(make_pair(u[i], w[i]));\n      Fa[A] = B;\n      ans[i] = 2;\n    }\n  }\n  for (int i = 1; i <= n; ++i)\n    if (!dfn[i]) dfs1(i), dfs2(i, i);\n  for (int i = 1; i <= m; ++i)\n    if (!ans[i]) {\n      int x = u[i], y = v[i];\n      bool flg = 1;\n      if (!(V[x] ^ V[y] ^ w[i])) continue;\n      ans[i] = -1;\n      while (top[x] != top[y]) {\n        if (dep[top[y]] > dep[top[x]]) swap(x, y);\n        if (query(1, n, dfn[top[x]], dfn[x], 1)) {\n          flg = 0;\n          break;\n        }\n        x = fa[top[x]];\n      }\n      if (flg)\n        if (x == y ||\n            query(1, n, min(dfn[x], dfn[y]) + 1, max(dfn[x], dfn[y]), 1) == 0) {\n          int x = u[i], y = v[i];\n          while (top[x] != top[y]) {\n            if (dep[top[y]] > dep[top[x]]) swap(x, y);\n            upd1(1, n, dfn[top[x]], dfn[x], 1);\n            assert(query(1, n, dfn[top[x]], dfn[x], 1) > 0);\n            x = fa[top[x]];\n          }\n          if (x != y)\n            upd1(1, n, min(dfn[x], dfn[y]) + 1, max(dfn[x], dfn[y]), 1);\n          ans[i] = 1;\n        }\n    }\n  for (int i = 1; i <= m; ++i)\n    if (ans[i] > 0)\n      puts(\"YES\");\n    else\n      puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::vector;\nint ans[500005];\nint p[300005];\nstruct Edge {\n  int u, v, w;\n  int id;\n  Edge() {}\n  Edge(int u, int v, int w) : u(u), v(v), w(w) {}\n};\nEdge e[500005];\nvector<int> node[300005];\nvector<Edge> edge[500005];\nvector<Edge> tEdge[500005];\nint main() {\n  int st = 18;\n  int n, q;\n  scanf(\"%d%d\", &n, &q);\n  std::function<int(int)> find = [&](int u) {\n    return p[u] == u ? u : (p[u] = find(p[u]));\n  };\n  for (int i = 1; i <= n; i++) {\n    p[i] = i;\n  }\n  for (int i = 1; i <= q; i++) {\n    int u, v, w;\n    scanf(\"%d%d%d\", &u, &v, &w);\n    int x = find(u), y = find(v);\n    if (x != y) {\n      p[y] = x;\n      ans[i] = 1;\n    }\n    Edge now;\n    now.u = u, now.v = v, now.w = w, now.id = i;\n    e[i] = now;\n  }\n  for (int i = 1; i <= q; i++) {\n    if (ans[i]) {\n      int p = find(e[i].u);\n      tEdge[p].push_back(e[i]);\n    } else {\n      int p = find(e[i].u);\n      edge[p].push_back(e[i]);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    int u = find(i);\n    node[u].push_back(i);\n  }\n  auto getPos = [&](int c, vector<int>& a) {\n    int L = 0, R = a.size() - 1;\n    int res = -1;\n    while (L <= R) {\n      int M = (L + R) / 2;\n      if (c <= a[M]) {\n        res = M;\n        R = M - 1;\n      } else\n        L = M + 1;\n    }\n    return res + 1;\n  };\n  auto solve = [&](int c) {\n    vector<int>& a = node[c];\n    int size = a.size();\n    std::sort(a.begin(), a.end());\n    for (Edge& e : edge[c]) {\n      e.u = getPos(e.u, node[c]);\n      e.v = getPos(e.v, node[c]);\n    }\n    vector<vector<Edge>> g(size + 1);\n    for (Edge& e : tEdge[c]) {\n      e.u = getPos(e.u, node[c]);\n      e.v = getPos(e.v, node[c]);\n      g[e.u].push_back(Edge(e.u, e.v, e.w));\n      g[e.v].push_back(Edge(e.v, e.u, e.w));\n    }\n    vector<int> vis(size + 1, 0);\n    vector<int> in(size + 1, 0), out(size + 1, 0);\n    vector<int> xSum(size + 1, 0);\n    vector<vector<int>> fa(size + 1, vector<int>(st + 1, 0));\n    int tot = 0;\n    std::function<void(int)> dfs = [&](int u) {\n      in[u] = ++tot;\n      for (Edge edge : g[u]) {\n        int v = edge.v, w = edge.w;\n        if (!vis[v]) {\n          xSum[v] = xSum[u] ^ w;\n          vis[v] = vis[u] + 1;\n          fa[v][0] = u;\n          dfs(v);\n        }\n      }\n      out[u] = tot;\n    };\n    vis[1] = 1;\n    dfs(1);\n    for (int j = 1; j <= st; j++) {\n      for (int i = 1; i <= size; i++) {\n        fa[i][j] = 0;\n        int p = fa[i][j - 1];\n        if (p) fa[i][j] = fa[p][j - 1];\n      }\n    }\n    auto lca = [&](int x, int y) {\n      if (vis[x] > vis[y]) {\n        int t = x;\n        x = y;\n        y = t;\n      }\n      for (int i = st; i >= 0; i--) {\n        if (fa[y][i] && vis[fa[y][i]] >= vis[x]) y = fa[y][i];\n      }\n      if (x == y) return x;\n      for (int i = st; i >= 0; i--) {\n        if (fa[x][i] && fa[y][i] && fa[x][i] != fa[y][i])\n          x = fa[x][i], y = fa[y][i];\n      }\n      return fa[x][0];\n    };\n    vector<int> bit(size + 1, 0);\n    auto ask = [&](int p) {\n      int res = 0;\n      while (p) {\n        res += bit[p];\n        p -= p & -p;\n      }\n      return res;\n    };\n    auto change = [&](int p, int v, int n) {\n      while (p <= n) {\n        bit[p] += v;\n        p += p & -p;\n      }\n    };\n    auto addSum = [&](int x, int y, int u) {\n      while (x != 0 && x != u) {\n        change(in[x], 1, size);\n        change(out[x] + 1, -1, size);\n        x = fa[x][0];\n      }\n      while (y != 0 && y != u) {\n        change(in[y], 1, size);\n        change(out[y] + 1, -1, size);\n        y = fa[y][0];\n      }\n    };\n    for (Edge& e : edge[c]) {\n      int x = e.u, y = e.v;\n      int u = lca(x, y);\n      int dis = xSum[x] ^ xSum[y] ^ e.w;\n      if (dis == 0)\n        ans[e.id] = 0;\n      else {\n        int mid = ask(in[x]) + ask(in[y]) - 2 * ask(in[u]);\n        if (mid != 0)\n          ans[e.id] = 0;\n        else {\n          ans[e.id] = 1;\n          addSum(x, y, u);\n        }\n      }\n    }\n  };\n  for (int i = 1; i <= n; i++) {\n    if (edge[i].size() != 0) {\n      solve(i);\n    }\n  }\n  for (int i = 1; i <= q; i++) printf(\"%s\\n\", ans[i] ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct unionfind {\n  vector<int> p;\n  unionfind(int N) { p = vector<int>(N, -1); }\n  int root(int x) {\n    if (p[x] < 0) {\n      return x;\n    } else {\n      p[x] = root(p[x]);\n      return p[x];\n    }\n  }\n  bool same(int x, int y) { return root(x) == root(y); }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x != y) {\n      if (p[x] < p[y]) {\n        swap(x, y);\n      }\n      p[y] += p[x];\n      p[x] = y;\n    }\n  }\n};\ntemplate <typename T>\nstruct lazy_segment_tree {\n  int N;\n  vector<T> ST;\n  vector<T> lazy;\n  lazy_segment_tree() {}\n  lazy_segment_tree(int n) {\n    N = 1;\n    while (N < n) {\n      N *= 2;\n    }\n    ST = vector<T>(N * 2 - 1, 0);\n    lazy = vector<T>(N * 2 - 1, -1);\n  }\n  void eval(int i, int l, int r) {\n    if (lazy[i] != -1) {\n      if (i < N - 1) {\n        lazy[i * 2 + 1] = lazy[i];\n        lazy[i * 2 + 2] = lazy[i];\n      }\n      ST[i] = lazy[i] * (r - l);\n      lazy[i] = -1;\n    }\n  }\n  void range_update(int L, int R, T x, int i, int l, int r) {\n    eval(i, l, r);\n    if (R <= l || r <= L) {\n      return;\n    } else if (L <= l && r <= R) {\n      lazy[i] = x;\n      eval(i, l, r);\n    } else {\n      int m = (l + r) / 2;\n      range_update(L, R, x, i * 2 + 1, l, m);\n      range_update(L, R, x, i * 2 + 2, m, r);\n      ST[i] = ST[i * 2 + 1] + ST[i * 2 + 2];\n    }\n  }\n  void range_update(int L, int R, T x) { range_update(L, R, x, 0, 0, N); }\n  T range_sum(int L, int R, int i, int l, int r) {\n    eval(i, l, r);\n    if (R <= l || r <= L) {\n      return 0;\n    } else if (L <= l && r <= R) {\n      return ST[i];\n    } else {\n      int m = (l + r) / 2;\n      return range_sum(L, R, i * 2 + 1, l, m) +\n             range_sum(L, R, i * 2 + 2, m, r);\n    }\n  }\n  T range_sum(int L, int R) { return range_sum(L, R, 0, 0, N); }\n};\nstruct heavy_light_decomposition {\n  vector<int> p, sz, in, next;\n  lazy_segment_tree<int> ST;\n  heavy_light_decomposition(vector<int> &p, vector<vector<int>> &c) : p(p) {\n    int N = p.size();\n    sz = vector<int>(N);\n    dfs1(c);\n    in = vector<int>(N);\n    next = vector<int>(N, 0);\n    int t = 0;\n    dfs2(c, t);\n    ST = lazy_segment_tree<int>(N);\n  }\n  void dfs1(vector<vector<int>> &c, int v = 0) {\n    sz[v] = 1;\n    for (int &w : c[v]) {\n      dfs1(c, w);\n      sz[v] += sz[w];\n      if (sz[w] > sz[c[v][0]]) {\n        swap(w, c[v][0]);\n      }\n    }\n  }\n  void dfs2(vector<vector<int>> &c, int &t, int v = 0) {\n    in[v] = t;\n    t++;\n    for (int w : c[v]) {\n      if (w == c[v][0]) {\n        next[w] = next[v];\n      } else {\n        next[w] = w;\n      }\n      dfs2(c, t, w);\n    }\n  }\n  int lca(int u, int v) {\n    while (true) {\n      if (in[u] > in[v]) {\n        swap(u, v);\n      }\n      if (next[u] == next[v]) {\n        return u;\n      }\n      v = p[next[v]];\n    }\n  }\n  void path_update(int u, int v) {\n    int w = lca(u, v);\n    while (next[u] != next[w]) {\n      ST.range_update(in[next[u]], in[u] + 1, 1);\n      u = p[next[u]];\n    }\n    ST.range_update(in[w] + 1, in[u] + 1, 1);\n    while (next[v] != next[w]) {\n      ST.range_update(in[next[v]], in[v] + 1, 1);\n      v = p[next[v]];\n    }\n    ST.range_update(in[w] + 1, in[v] + 1, 1);\n  }\n  int path_sum(int u, int v) {\n    int w = lca(u, v);\n    int ans = 0;\n    while (next[u] != next[w]) {\n      ans += ST.range_sum(in[next[u]], in[u] + 1);\n      u = p[next[u]];\n    }\n    ans += ST.range_sum(in[w] + 1, in[u] + 1);\n    while (next[v] != next[w]) {\n      ans += ST.range_sum(in[next[v]], in[v] + 1);\n      v = p[next[v]];\n    }\n    ans += ST.range_sum(in[w] + 1, in[v] + 1);\n    return ans;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(q), b(q), x(q);\n  for (int i = 0; i < q; i++) {\n    cin >> a[i] >> b[i] >> x[i];\n    a[i]--;\n    b[i]--;\n  }\n  unionfind UF(n);\n  vector<bool> tree(q, false);\n  vector<vector<pair<int, int>>> E(n);\n  for (int i = 0; i < q; i++) {\n    if (!UF.same(a[i], b[i])) {\n      UF.unite(a[i], b[i]);\n      tree[i] = true;\n      E[a[i]].push_back(make_pair(x[i], b[i]));\n      E[b[i]].push_back(make_pair(x[i], a[i]));\n    }\n  }\n  for (int i = 1; i < n; i++) {\n    if (!UF.same(0, i)) {\n      UF.unite(0, i);\n      E[0].push_back(make_pair(0, i));\n      E[i].push_back(make_pair(i, 0));\n    }\n  }\n  vector<int> p(n, -1);\n  vector<vector<int>> c(n);\n  vector<int> s(n, 0);\n  queue<int> Q;\n  Q.push(0);\n  while (!Q.empty()) {\n    int v = Q.front();\n    Q.pop();\n    for (auto P : E[v]) {\n      int w = P.second;\n      if (w != p[v]) {\n        p[w] = v;\n        c[v].push_back(w);\n        s[w] = s[v] + P.first;\n        Q.push(w);\n      }\n    }\n  }\n  heavy_light_decomposition T(p, c);\n  vector<bool> ans = tree;\n  for (int i = 0; i < q; i++) {\n    if (!tree[i]) {\n      if ((s[a[i]] % 2 - s[b[i]] % 2 + 2 + x[i]) % 2 == 1) {\n        if (T.path_sum(a[i], b[i]) == 0) {\n          ans[i] = true;\n          T.path_update(a[i], b[i]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < q; i++) {\n    if (ans[i]) {\n      cout << \"YES\"\n           << \"\\n\";\n    } else {\n      cout << \"NO\"\n           << \"\\n\";\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 800010;\nint n, m, cnt, father[N], xors[N];\nint find(int x) {\n  if (x == father[x]) return x;\n  int y = father[x];\n  father[x] = find(y);\n  xors[x] ^= xors[y];\n  return father[x];\n}\nint read() {\n  int d = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) ch = getchar();\n  while (isdigit(ch)) d = (d << 3) + (d << 1) + ch - 48, ch = getchar();\n  return d;\n}\nstruct LCT {\n  int ch[N][2], fa[N];\n  bool rev[N], vis[N], flag[N];\n  bool pos(int x) { return ch[fa[x]][1] == x; }\n  bool notrt(int x) { return (ch[fa[x]][0] == x) || (ch[fa[x]][1] == x); }\n  void pushup(int x) { flag[x] = flag[ch[x][0]] | flag[ch[x][1]] | vis[x]; }\n  void pushdown(int x) {\n    if (rev[x]) {\n      int lc = ch[x][0], rc = ch[x][1];\n      if (lc) swap(ch[lc][0], ch[lc][1]), rev[lc] ^= 1;\n      if (rc) swap(ch[rc][0], ch[rc][1]), rev[rc] ^= 1;\n      rev[x] = 0;\n    }\n  }\n  void rotate(int x) {\n    int y = fa[x], z = fa[y], k = pos(x), c = ch[x][k ^ 1];\n    if (notrt(y)) ch[z][pos(y)] = x;\n    ch[x][k ^ 1] = y;\n    ch[y][k] = c;\n    if (c) fa[c] = y;\n    fa[y] = x;\n    fa[x] = z;\n    pushup(y);\n    pushup(x);\n  }\n  void down(int x) {\n    if (notrt(x)) down(fa[x]);\n    pushdown(x);\n  }\n  void splay(int x) {\n    down(x);\n    for (; notrt(x); rotate(x))\n      if (notrt(fa[x])) rotate(pos(x) == pos(fa[x]) ? fa[x] : x);\n  }\n  void access(int x) {\n    for (int y = 0; x; y = x, x = fa[x]) {\n      splay(x);\n      ch[x][1] = y;\n      pushup(x);\n    }\n  }\n  void makert(int x) {\n    access(x);\n    splay(x);\n    rev[x] ^= 1;\n    swap(ch[x][0], ch[x][1]);\n  }\n  void link(int x, int y) {\n    makert(x);\n    fa[x] = y;\n  }\n  void update(int x) {\n    if (x > n) vis[x] = 1;\n    if (ch[x][0]) update(ch[x][0]);\n    if (ch[x][1]) update(ch[x][1]);\n    pushup(x);\n  }\n} lct;\nint main() {\n  n = cnt = read();\n  m = read();\n  for (int i = 1; i <= n; i++) father[i] = i;\n  for (int i = 1; i <= m; i++) {\n    int x = read(), y = read(), z = read();\n    if (find(x) != find(y)) {\n      int xx = find(x), yy = find(y);\n      father[xx] = yy;\n      xors[xx] = xors[x] ^ xors[y] ^ z;\n      cnt++;\n      lct.link(x, cnt);\n      lct.link(y, cnt);\n      cout << \"YES\\n\";\n    } else {\n      if (xors[x] ^ xors[y] == z) {\n        cout << \"NO\\n\";\n        continue;\n      }\n      lct.makert(x);\n      lct.access(y);\n      lct.splay(x);\n      if (lct.flag[x]) {\n        cout << \"NO\\n\";\n        continue;\n      }\n      lct.update(x);\n      cout << \"YES\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool ckmin(T &a, const T &b) {\n  return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T &a, const T &b) {\n  return a < b ? a = b, 1 : 0;\n}\nnamespace debug {\nvoid __print(int x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto z : x) cerr << (f++ ? \",\" : \"\"), __print(z);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\n}  // namespace debug\nusing namespace debug;\nconst char nl = '\\n';\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\nconst int mxN = 3e5 + 12;\nint dsu[mxN], vel[mxN];\nint findSet(int u) {\n  if (u == dsu[u]) return u;\n  return dsu[u] = findSet(dsu[u]);\n}\nbool unite(int u, int v) {\n  u = findSet(u);\n  v = findSet(v);\n  if (u == v) return 0;\n  if (vel[u] > vel[v]) swap(u, v);\n  dsu[u] = v;\n  vel[v] += vel[u];\n  return 1;\n}\nvector<pair<int, int>> adj[mxN];\nconst int LOG = 26;\nint timer = -1;\nint tin[mxN], tout[mxN];\nint lift[mxN][LOG];\nbool vis[mxN];\nint ksor[mxN];\nvoid dfs(int s, int p = -1, int tren = 0) {\n  vis[s] = 1;\n  tin[s] = ++timer;\n  lift[s][0] = p;\n  for (int i = 1; i < LOG; ++i) {\n    if (lift[s][i - 1] == -1) {\n      lift[s][i] = -1;\n      continue;\n    }\n    lift[s][i] = lift[lift[s][i - 1]][i - 1];\n  }\n  ksor[s] = tren;\n  for (auto e : adj[s]) {\n    if (e.first == p) continue;\n    dfs(e.first, s, tren ^ e.second);\n  }\n  tout[s] = timer;\n}\nbool isAncestor(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }\nint lca(int u, int v) {\n  if (isAncestor(u, v)) return u;\n  if (isAncestor(v, u)) return v;\n  for (int i = LOG - 1; i >= 0; --i) {\n    if (lift[u][i] == -1) continue;\n    if (!isAncestor(lift[u][i], v)) {\n      u = lift[u][i];\n    }\n  }\n  return lift[u][0];\n}\nint ft[mxN + 12];\nvoid update(int i, int x) {\n  for (; i <= mxN; i += i & -i) {\n    ft[i] += x;\n  }\n}\nint query(int i) {\n  int r = 0;\n  for (; i; i -= i & -i) {\n    r += ft[i];\n  }\n  return r;\n}\nvoid odradi(int u, int v) {\n  while (u != v) {\n    update(tin[u], 1);\n    update(tout[u] + 1, -1);\n    u = lift[u][0];\n  }\n}\nvoid solve() {\n  int n, q;\n  cin >> n >> q;\n  for (int i = 0; i < n; ++i) {\n    dsu[i] = i;\n    vel[i] = 1;\n  }\n  vector<array<int, 3>> upit(q);\n  for (auto &z : upit) {\n    for (int i = 0; i < 3; ++i) cin >> z[i];\n    --z[0], --z[1];\n  }\n  vector<bool> ans(q);\n  for (int i = 0; i < q; ++i) {\n    int u = upit[i][0];\n    int v = upit[i][1];\n    int x = upit[i][2];\n    if (unite(u, v)) {\n      ans[i] = 1;\n      adj[u].push_back({v, x});\n      adj[v].push_back({u, x});\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    if (!vis[i]) {\n      dfs(i);\n    }\n  }\n  for (int i = 0; i < q; ++i) {\n    if (ans[i]) continue;\n    int u = upit[i][0];\n    int v = upit[i][1];\n    int x = upit[i][2];\n    int izraz = ksor[u] ^ ksor[v];\n    izraz ^= x;\n    if (izraz == 0) continue;\n    int rodjak = lca(u, v);\n    int suma = query(tin[u]) + query(tin[v]) - 2 * query(tin[rodjak]);\n    if (suma > 0) continue;\n    ans[i] = 1;\n    odradi(u, rodjak);\n    odradi(v, rodjak);\n  }\n  for (auto z : ans) cout << (z ? \"YES\" : \"NO\") << nl;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int testCases = 1;\n  while (testCases--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst long long inf = 0x3f3f3f3f;\nconst double pi = acos(-1);\nconst double eps = 1e-9;\nstruct dsu {\n  int n;\n  int par[300005], size[300005];\n  void init(int n) {\n    this->n = n;\n    for (int i = 0; i <= n; ++i) par[i] = i, size[i] = 1;\n  }\n  int find(int u) { return par[u] == u ? u : par[u] = find(par[u]); }\n  bool same(int u, int v) { return find(u) == find(v); }\n  void uni(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n      --n;\n      if (size[u] > size[v]) swap(u, v);\n      size[v] += size[u];\n      par[u] = v;\n    }\n  }\n} cc;\nstruct segtree {\n  int n;\n  int t[1200005], lz[1200005];\n  void init(int n) {\n    this->n = n;\n    for (int i = 1; i <= 4 * n; ++i) t[i] = 0, lz[i] = -1;\n  }\n  void app(int u, int tl, int tr, int val) {\n    t[u] = (tr - tl + 1) * val;\n    lz[u] = val;\n  }\n  void push(int u, int tl, int tr, int tm) {\n    if (lz[u] == -1) return;\n    app(u << 1, tl, tm, lz[u]);\n    app(u << 1 | 1, tm + 1, tr, lz[u]);\n    lz[u] = -1;\n  }\n  void upd(int u, int tl, int tr, int l, int r, int val) {\n    if (l > r) return;\n    if (l == tl && r == tr) {\n      app(u, tl, tr, val);\n      return;\n    }\n    int tm = tl + tr >> 1;\n    push(u, tl, tr, tm);\n    upd(u << 1, tl, tm, l, min(r, tm), val);\n    upd(u << 1 | 1, tm + 1, tr, max(l, tm + 1), r, val);\n    t[u] = t[u << 1] + t[u << 1 | 1];\n  }\n  void upd(int l, int r, int val) { upd(1, 1, n, l, r, val); }\n  int query(int u, int tl, int tr, int l, int r) {\n    if (l > r) return 0;\n    if (l == tl && r == tr) return t[u];\n    int tm = tl + tr >> 1;\n    push(u, tl, tr, tm);\n    return query(u << 1, tl, tm, l, min(r, tm)) +\n           query(u << 1 | 1, tm + 1, tr, max(l, tm + 1), r);\n  }\n  int query(int l, int r) { return query(1, 1, n, l, r); }\n} ds;\nstruct edge {\n  int u, v;\n  bool w;\n};\nint timer = 0;\nint n, m;\nvector<edge> e;\nvector<pair<bool, int>> g[300005];\nint p[300005], sz[300005], in[300005] = {0}, nxt[300005];\nbool d[300005], ans[500005] = {0};\nvoid dfs(int u) {\n  sz[u] = 1;\n  for (auto &x : g[u]) {\n    if (x.second == p[u]) swap(x, g[u].back());\n    if (x.second != p[u]) {\n      int v = x.second;\n      bool w = x.first;\n      p[v] = u;\n      d[v] = d[u] ^ w;\n      dfs(v);\n      sz[u] += sz[v];\n    }\n  }\n}\nvoid hld(int u) {\n  in[u] = ++timer;\n  for (auto x : g[u])\n    if (x.second != p[u]) {\n      int v = x.second;\n      nxt[v] = (v == g[u][0].second ? nxt[u] : v);\n      hld(v);\n    }\n}\nvoid upd(int u, int v) {\n  while (nxt[u] != nxt[v]) {\n    if (in[nxt[u]] < in[nxt[v]]) swap(u, v);\n    ds.upd(in[nxt[u]], in[u], 1);\n    u = p[nxt[u]];\n  }\n  if (in[u] > in[v]) swap(u, v);\n  ds.upd(in[u] + 1, in[v], 1);\n}\nint query(int u, int v) {\n  int res = 0;\n  while (nxt[u] != nxt[v]) {\n    if (in[nxt[u]] < in[nxt[v]]) swap(u, v);\n    res += ds.query(in[nxt[u]], in[u]);\n    u = p[nxt[u]];\n  }\n  if (in[u] > in[v]) swap(u, v);\n  res += ds.query(in[u] + 1, in[v]);\n  return res;\n}\nvoid solve() {\n  cin >> n >> m;\n  cc.init(n);\n  for (int i = 0, u, v, w; i < m; ++i) {\n    cin >> u >> v >> w;\n    e.push_back({u, v, (bool)w});\n    if (!cc.same(u, v)) {\n      ans[i] = 1;\n      cc.uni(u, v);\n      g[u].push_back({w, v});\n      g[v].push_back({w, u});\n    }\n  }\n  for (int i = 1; i <= n; ++i)\n    if (!in[i]) p[i] = -1, nxt[i] = i, dfs(i), hld(i);\n  ds.init(n);\n  for (int i = 0; i < m; ++i)\n    if (!ans[i]) {\n      int u = e[i].u, v = e[i].v;\n      bool w = e[i].w;\n      if ((d[u] ^ d[v] ^ w) && !query(u, v)) ans[i] = 1, upd(u, v);\n    }\n  for (int i = 0; i < m; ++i) cout << (ans[i] ? \"YES\" : \"NO\") << \"\\n\";\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int test = 1;\n  for (int tc = 1; tc <= test; ++tc) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (is_same<int, long long>::value ? 1e18 + 666 : 1e9 + 666);\nconst long long INFll = 1e18 + 666;\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate <class t1, class t2>\ninline bool cmin(t1 &a, const t2 &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class t1, class t2>\ninline bool cmax(t1 &a, const t2 &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ninline int bpow(long long a, long long b, int mod) {\n  int res = 1;\n  a %= mod;\n  for (; b; b >>= 1) {\n    if (b & 1) {\n      res = int((1ll * a * res) % mod);\n      res %= mod;\n    }\n    a *= a;\n    a %= mod;\n  }\n  return res;\n}\nvoid UseFiles(const string &s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\nvoid run();\nsigned main() {\n  iostream::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  run();\n}\nstruct Dsu {\n  vector<int> l, h;\n  Dsu(int n) : l(n), h(n, 1) { iota(l.begin(), l.end(), 0); }\n  int get_root(int v) {\n    if (l[v] == v) return v;\n    return l[v] = get_root(l[v]);\n  }\n  bool Union(int u, int v) {\n    u = get_root(u);\n    v = get_root(v);\n    if (u == v) return false;\n    if (h[u] > h[v]) {\n      swap(u, v);\n    }\n    l[u] = v;\n    h[v] += h[u];\n    return true;\n  }\n};\nstruct Fenv {\n  const int n;\n  vector<int> tree;\n  Fenv(int sz) : n(sz + 1), tree(n, 0) {}\n  static int f(int i) { return i & -i; }\n  int get(int idx) const {\n    ++idx;\n    int sm = 0;\n    for (; idx > 0; idx -= f(idx)) {\n      sm += tree[idx];\n    }\n    return sm;\n  }\n  void plus(int idx, int val) {\n    ++idx;\n    for (; idx < n; idx += f(idx)) {\n      tree[idx] += val;\n    }\n  }\n};\nvoid run() {\n  constexpr int maxlg = 19;\n  int n, m;\n  cin >> n >> m;\n  vector<array<int, 3>> edges(m);\n  Dsu dsu(n);\n  vector<char> ans(m, -1);\n  vector<vector<pair<int, int>>> g(n);\n  for (int i = 0; i < m; ++i) {\n    auto &[u, v, x] = edges[i];\n    cin >> u >> v >> x;\n    --u, --v;\n    if (dsu.Union(u, v)) {\n      g[u].push_back({v, x});\n      g[v].push_back({u, x});\n      ans[i] = 1;\n    }\n  }\n  vector<int> xor_from_root(n, -1), tin(n, -1), sz(n, -1);\n  vector<int> d(n, -1);\n  vector<vector<int>> up(n, vector<int>(maxlg, -1));\n  {\n    int timer = 0;\n    function<void(int, int, int, int)> dfs = [&](int v, int p, int xr,\n                                                 int cur_d) {\n      if (p == -1) {\n        fill(up[v].begin(), up[v].end(), v);\n      } else {\n        up[v][0] = p;\n        for (int i = 1; i < maxlg; ++i) {\n          up[v][i] = up[up[v][i - 1]][i - 1];\n        }\n      }\n      d[v] = cur_d;\n      xor_from_root[v] = xr;\n      tin[v] = timer++;\n      int s = 1;\n      for (auto &[u, x] : g[v]) {\n        if (u == p) continue;\n        dfs(u, v, xr ^ x, cur_d + 1);\n        s += sz[u];\n      }\n      sz[v] = s;\n    };\n    for (int i = 0; i < n; ++i) {\n      if (d[i] != -1) continue;\n      dfs(i, -1, 0, 0);\n    }\n  }\n  auto lca = [&d, &up](int u, int v) {\n    if (d[u] < d[v]) {\n      swap(u, v);\n    }\n    for (int i = maxlg - 1; i > -1; --i) {\n      if (d[up[u][i]] >= d[v]) {\n        u = up[u][i];\n      }\n    }\n    if (u == v) {\n      return u;\n    }\n    for (int i = maxlg - 1; i > -1; --i) {\n      if (up[v][i] != up[u][i]) {\n        v = up[v][i];\n        u = up[u][i];\n      }\n    }\n    return up[v][0];\n  };\n  Fenv f(n + 1);\n  for (int i = 0; i < m; ++i) {\n    if (ans[i] != -1) continue;\n    auto [u, v, x] = edges[i];\n    if ((xor_from_root[u] ^ xor_from_root[v] ^ x) == 0) {\n      ans[i] = 0;\n      continue;\n    }\n    int l = lca(u, v);\n    if (f.get(tin[u]) + f.get(tin[v]) - 2 * f.get(tin[l]) != 0) {\n      ans[i] = 0;\n      continue;\n    }\n    ans[i] = 1;\n    for (int uu = u; uu != l; uu = up[uu][0]) {\n      f.plus(tin[uu], 1);\n      f.plus(tin[uu] + sz[uu], -1);\n    }\n    for (int vv = v; vv != l; vv = up[vv][0]) {\n      f.plus(tin[vv], 1);\n      f.plus(tin[vv] + sz[vv], -1);\n    }\n  }\n  for (auto &x : ans) {\n    if (x) {\n      cout << \"YES\\n\";\n    } else {\n      cout << \"NO\\n\";\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0;\n  char c = getchar();\n  while (!isdigit(c)) c = getchar();\n  while (isdigit(c)) x = x * 10 + (c ^ '0'), c = getchar();\n  return x;\n}\nconst int maxn = 3e5 + 10;\nconst int maxq = 5e5 + 10;\nstruct Node {\n  int s[2], p, siz, v1, sum, v2, _s, tag1, tag2;\n} tr[maxn * 2];\nint n, q, tot, stk[maxn * 2];\ninline void pushup(int x) {\n  tr[x].siz = tr[tr[x].s[0]].siz + tr[tr[x].s[1]].siz + (x > n);\n  tr[x].sum = tr[tr[x].s[0]].sum ^ tr[tr[x].s[1]].sum ^ tr[x].v1;\n  tr[x]._s = tr[tr[x].s[0]]._s | tr[tr[x].s[1]]._s | (x > n && tr[x].v2 > 0);\n}\ninline void pushrev(int x) {\n  swap(tr[x].s[0], tr[x].s[1]);\n  tr[x].tag1 ^= 1;\n}\ninline void pushadd(int x) {\n  tr[x]._s = tr[x].siz;\n  if (x > n) tr[x].v2 = 1;\n  tr[x].tag2 = 1;\n}\ninline void pushdown(int x) {\n  if (tr[x].tag1) {\n    pushrev(tr[x].s[0]), pushrev(tr[x].s[1]);\n    tr[x].tag1 = 0;\n  }\n  if (tr[x].tag2) {\n    pushadd(tr[x].s[0]), pushadd(tr[x].s[1]);\n    tr[x].tag2 = 0;\n  }\n}\ninline bool isroot(int x) {\n  return tr[tr[x].p].s[0] != x && tr[tr[x].p].s[1] != x;\n}\ninline void rotate(int x) {\n  int y = tr[x].p, z = tr[y].p, k = tr[y].s[1] == x;\n  if (!isroot(y)) tr[z].s[tr[z].s[1] == y] = x;\n  tr[x].p = z;\n  tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;\n  tr[x].s[k ^ 1] = y, tr[y].p = x;\n  pushup(y), pushup(x);\n}\nvoid splay(int x) {\n  int top = 0, r = x;\n  stk[++top] = r;\n  while (!isroot(r)) stk[++top] = r = tr[r].p;\n  while (top) pushdown(stk[top--]);\n  while (!isroot(x)) {\n    int y = tr[x].p, z = tr[y].p;\n    if (!isroot(y)) rotate(tr[y].s[1] == x ^ tr[z].s[1] == y ? x : y);\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  int z = x;\n  for (int y = 0; x; y = x, x = tr[x].p) {\n    splay(x);\n    tr[x].s[1] = y, pushup(x);\n  }\n  splay(z);\n}\nvoid makeroot(int x) { access(x), pushrev(x); }\nint findroot(int x) {\n  access(x);\n  while (tr[x].s[0]) pushdown(x), x = tr[x].s[0];\n  splay(x);\n  return x;\n}\nvoid split(int x, int y) { makeroot(x), access(y); }\nvoid link(int x, int y) {\n  makeroot(x);\n  if (findroot(y) != x) tr[x].p = y;\n}\nint main() {\n  n = read(), q = read();\n  tot = n;\n  for (int i = 1; i <= n; i++) tr[i].siz = 1;\n  for (int i = 1; i <= q; i++) {\n    int u = read(), v = read(), w = read();\n    makeroot(u);\n    if (findroot(v) != u) {\n      tot++, tr[tot].v1 = tr[tot].sum = w, tr[tot].siz = 1;\n      link(u, tot), link(tot, v);\n      puts(\"YES\");\n    } else {\n      split(u, v);\n      if (tr[v]._s > 0 || (tr[v].sum ^ w) != 1)\n        puts(\"NO\");\n      else {\n        pushadd(v);\n        puts(\"YES\");\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Random;\nimport java.util.Stack;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Vector;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author sarthakmanna\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FGoodGraph solver = new FGoodGraph();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FGoodGraph {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int i, j, k;\n\n            int N = in.nextInt(), M = in.nextInt();\n            ArrayList<Integer>[] graph = new ArrayList[N];\n            for (i = 0; i < N; ++i) graph[i] = new ArrayList<>();\n\n            ArrayList<Edge> tree = new ArrayList<>(), cycle = new ArrayList<>();\n            DSU dsu = new DSU(N);\n            boolean[] ans = new boolean[M];\n            for (i = 0; i < M; ++i) {\n                Edge edge = new Edge(i, in.nextInt() - 1, in.nextInt() - 1, in.nextInt());\n                if (dsu.isConnected(edge.getU(), edge.getV())) {\n                    cycle.add(edge);\n                } else {\n                    dsu.addEdge(edge.getU(), edge.getV());\n                    graph[edge.getU()].add(edge.getV());\n                    graph[edge.getV()].add(edge.getU());\n\n                    tree.add(edge);\n                    ans[i] = true;\n                }\n            }\n\n            HashSet<Integer> roots = new HashSet<>();\n            boolean[] vis = new boolean[N];\n            for (i = 0; i < N; ++i)\n                if (!vis[i]) {\n                    roots.add(i);\n                    dfs(i, vis, graph);\n                }\n\n            HLD_LCA hld_lca = new HLD_LCA(tree.toArray(new Edge[tree.size()]), N, roots);\n            for (Edge edge : cycle) {\n                if ((edge.getWeight() ^ hld_lca.pathQuery(edge.getU(), edge.getV())) == 1) {\n                    ans[edge.i] = true;\n                    hld_lca.pathUpdate(edge.getU(), edge.getV(), +1);\n                }\n            }\n\n            for (boolean val : ans) out.println(val ? \"YES\" : \"NO\");\n        }\n\n        void dfs(int node, boolean[] v, ArrayList<Integer>[] graph) {\n            if (v[node]) return;\n            v[node] = true;\n            for (int itr : graph[node]) dfs(itr, v, graph);\n        }\n\n    }\n\n    static class Helper {\n        public final long MOD;\n        public final int MAXN;\n        final Random rnd;\n\n        public Helper() {\n            MOD = 1000_000_007;\n            MAXN = 1000_006;\n            rnd = new Random();\n        }\n\n        public Helper(long mod, int maxn) {\n            MOD = mod;\n            MAXN = maxn;\n            rnd = new Random();\n        }\n\n        public int getRandomInRange(int l, int r) {\n            return rnd.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class DSU {\n        int N;\n        int[] parent;\n        int[] size;\n\n        public DSU(int nodeCount) {\n            N = nodeCount;\n            parent = new int[nodeCount];\n            Arrays.fill(parent, -7);\n            size = new int[nodeCount];\n            Arrays.fill(size, 1);\n        }\n\n        public int getParent(int node) {\n            if (parent[node] < 0) return node;\n            else return parent[node] = getParent(parent[node]);\n        }\n\n        public boolean isConnected(int a, int b) {\n            return getParent(a) == getParent(b);\n        }\n\n        public void addEdge(int a, int b) {\n            a = getParent(a);\n            b = getParent(b);\n            if (a == b) {\n                return;\n            } else if (size[a] > size[b]) {\n                a ^= b;\n                b ^= a;\n                a ^= b;\n            }\n            parent[a] = b;\n            size[b] += size[a];\n            size[a] = -7;\n        }\n\n    }\n\n    static class FastReader {\n        static final int BUFSIZE = 1 << 20;\n        static byte[] buf;\n        static int index;\n        static int total;\n        static InputStream in;\n\n        public FastReader(InputStream is) {\n            try {\n                in = is;\n                buf = new byte[BUFSIZE];\n            } catch (Exception e) {\n            }\n        }\n\n        private int scan() {\n            try {\n                if (index >= total) {\n                    index = 0;\n                    total = in.read(buf);\n                    if (total <= 0)\n                        return -1;\n                }\n                return buf[index++];\n            } catch (Exception | Error e) {\n                System.err.println(e.getMessage());\n                return 13 / 0;\n            }\n        }\n\n        public int nextInt() {\n            int c, val = 0;\n            for (c = scan(); c <= 32; c = scan()) ;\n            boolean neg = c == '-';\n            if (c == '-' || c == '+')\n                c = scan();\n            for (; c >= '0' && c <= '9'; c = scan())\n                val = (val << 3) + (val << 1) + (c & 15);\n            return neg ? -val : val;\n        }\n\n    }\n\n    static class HLD_LCA {\n        static final int defaultValue = 0;\n        ArrayList<Integer>[] graph;\n        int[] depth;\n        int[] parent;\n        int[] chCount;\n        int[] queue;\n        int N;\n        int[] weight;\n        HashSet<Integer> roots;\n        SegmentTree st;\n        int[] treePos;\n        int[] linearTree;\n        int[] segRoot;\n\n        public HLD_LCA(Edge[] edges, int n, HashSet<Integer> r) {\n            int i;\n            N = n;\n            roots = r;\n\n            graph = new ArrayList[N];\n            for (i = 0; i < N; ++i) graph[i] = new ArrayList<>();\n\n            for (Edge e : edges) {\n                graph[e.u].add(e.v);\n                graph[e.v].add(e.u);\n            }\n            iterativeDFS();\n\n            weight = new int[N];\n            for (Edge e : edges) {\n                int child = depth[e.u] > depth[e.v] ? e.u : e.v;\n                weight[child] = e.weight;\n            }\n\n            HLDify();\n        }\n\n        public int operate(int a, int b) {\n            return a ^ b;\n        }\n\n        private void iterativeDFS() {\n            parent = new int[N];\n            depth = new int[N];\n            chCount = new int[N];\n            queue = new int[N];\n            Arrays.fill(chCount, 1);\n\n            int i, st = 0, end = 0;\n            for (int root : roots) {\n                parent[root] = -1;\n                depth[root] = 1;\n                queue[end++] = root;\n            }\n\n            while (st < end) {\n                int node = queue[st++], h = depth[node] + 1;\n                Iterator<Integer> itr = graph[node].iterator();\n                while (itr.hasNext()) {\n                    int ch = itr.next();\n                    if (depth[ch] > 0) continue;\n                    depth[ch] = h;\n                    parent[ch] = node;\n                    queue[end++] = ch;\n                }\n            }\n            for (i = N - 1; i >= 0; --i)\n                if (!roots.contains(queue[i]))\n                    chCount[parent[queue[i]]] += chCount[queue[i]];\n        }\n\n        private void HLDify() {\n            int i, j, treeRoot = -7;\n\n            treePos = new int[N];\n            linearTree = new int[N];\n            segRoot = new int[N];\n\n            Stack<Integer> stack = new Stack<>();\n            stack.ensureCapacity(N << 1);\n            stack.addAll(roots);\n            for (i = 0; !stack.isEmpty(); ++i) {\n                int node = stack.pop();\n                if (i == 0 || linearTree[i - 1] != parent[node])\n                    treeRoot = node;\n                linearTree[i] = node;\n                treePos[node] = i;\n                segRoot[node] = treeRoot;\n\n                int bigChild = -7, bigChildPos = -7, lastPos = graph[node].size() - 1;\n                for (j = 0; j < graph[node].size(); ++j) {\n                    int tempNode = graph[node].get(j);\n                    if (tempNode == parent[node]) continue;\n                    if (bigChild < 0 || chCount[bigChild] < chCount[tempNode]) {\n                        bigChild = tempNode;\n                        bigChildPos = j;\n                    }\n                }\n                if (bigChildPos >= 0) {\n                    int temp = graph[node].get(lastPos);\n                    graph[node].set(lastPos, bigChild);\n                    graph[node].set(bigChildPos, temp);\n                }\n\n                for (int itr : graph[node])\n                    if (parent[node] != itr)\n                        stack.push(itr);\n            }\n\n            int[] respectiveWeights = new int[N];\n            for (i = 0; i < N; ++i)\n                respectiveWeights[i] = weight[linearTree[i]];\n            st = new SegmentTree(respectiveWeights, 0, 0);\n        }\n\n        public int pathQuery(int node1, int node2) {\n            int ret = defaultValue, temp;\n            while (segRoot[node1] != segRoot[node2]) {\n                if (depth[segRoot[node1]] > depth[segRoot[node2]]) {\n                    node1 ^= node2;\n                    node2 ^= node1;\n                    node1 ^= node2;\n                }\n\n                temp = st.rangeQuery(treePos[segRoot[node2]], treePos[node2]);\n                ret = operate(ret, temp);\n                node2 = parent[segRoot[node2]];\n            }\n\n            if (treePos[node1] > treePos[node2]) {\n                node1 ^= node2;\n                node2 ^= node1;\n                node1 ^= node2;\n            }\n            temp = st.rangeQuery(treePos[node1] + 1, treePos[node2]);   // ...treePos[node1] + 1... for Edge Query\n            ret = operate(ret, temp);\n\n            return ret;\n        }\n\n        public void pathUpdate(int node1, int node2, int value) {\n            while (segRoot[node1] != segRoot[node2]) {\n                if (depth[segRoot[node1]] > depth[segRoot[node2]]) {\n                    node1 ^= node2;\n                    node2 ^= node1;\n                    node1 ^= node2;\n                }\n                st.rangeUpdate(treePos[segRoot[node2]], treePos[node2], value);\n                node2 = parent[segRoot[node2]];\n            }\n            if (treePos[node1] > treePos[node2]) {\n                node1 ^= node2;\n                node2 ^= node1;\n                node1 ^= node2;\n            }\n            st.rangeUpdate(treePos[node1] + 1, treePos[node2], value);     // ...treePos[node1] + 1... for Edge Update\n        }\n\n    }\n\n    static class SegmentTree {\n        int N;\n        int[] tree;\n        Helper hp = new Helper();\n\n        public SegmentTree(int[] ar, int def_node, int def_lazy) {\n            N = ar.length + 1;\n            tree = new int[N];\n\n            for (int i = 0; i < ar.length; ++i) pointUpdate(i, ar[i]);\n        }\n\n        public void pointUpdate(int idx, int val) {\n            ++idx;\n            while (idx < N) {\n                tree[idx] ^= val;\n                idx += idx & -idx;\n            }\n        }\n\n        public void rangeUpdate(int l, int r, int val) {\n            for (int i = l; i <= r; ++i) {\n                pointUpdate(i, hp.getRandomInRange(0, Integer.MAX_VALUE >> 1));\n            }\n        }\n\n        public int prefixQuery(int idx) {\n            ++idx;\n            int ret = 0;\n            while (idx > 0) {\n                ret ^= tree[idx];\n                idx -= idx & -idx;\n            }\n            return ret;\n        }\n\n        public int rangeQuery(int l, int r) {\n            int ret = prefixQuery(r);\n            if (l > 0) ret ^= prefixQuery(l - 1);\n            return ret;\n        }\n\n    }\n\n    static class Edge {\n        public int i;\n        public int u;\n        public int v;\n        int weight;\n\n        public int getU() {\n            return u;\n        }\n\n        public int getV() {\n            return v;\n        }\n\n        public int getWeight() {\n            return weight;\n        }\n\n        public Edge(int id, int a, int b, int wt) {\n            i = id;\n            u = a;\n            v = b;\n            weight = wt;\n        }\n\n        public String toString() {\n            return \"(\" + u + \", \" + v + \" -> \" + weight + \")\";\n        }\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 600005;\nconst int inf = 1 << 30;\nstruct BIT {\n  int c[maxn];\n  void update(int x, int val, int n) {\n    for (int i = x; i <= n; i += i & -i) {\n      c[i] += val;\n    }\n  }\n  int ask(int x) {\n    int ans = 0;\n    for (int i = x; i; i -= i & -i) {\n      ans += c[i];\n    }\n    return ans;\n  }\n} T;\nstruct Edge {\n  int to, next, val;\n  Edge(int to = 0, int next = 0, int val = 0) : to(to), next(next), val(val) {}\n} a[maxn * 2];\nstruct Question {\n  int x, y, val;\n} e[maxn];\nint n, m;\nint cnt;\nint tot;\nint top;\nint h[maxn];\nint fa[maxn];\nint lg[maxn];\nint ans[maxn];\nint pre[maxn];\nint fir[maxn];\nint lst[maxn];\nint depth[maxn];\nint st[20][maxn * 2];\nint xor_val[maxn * 2];\nbool vis[maxn];\nvoid add(int x, int y, int val) {\n  a[++cnt] = Edge(y, h[x], val);\n  h[x] = cnt;\n}\nint f(int x) { return fa[x] == x ? x : fa[x] = f(fa[x]); }\nvoid dfs(int x) {\n  vis[x] = 1;\n  st[0][++top] = x;\n  pre[x] = top;\n  fir[x] = ++tot;\n  for (int i = h[x]; i; i = a[i].next) {\n    if (vis[a[i].to]) {\n      continue;\n    }\n    xor_val[a[i].to] = xor_val[x] ^ a[i].val;\n    depth[a[i].to] = depth[x] + 1;\n    fa[a[i].to] = x;\n    dfs(a[i].to);\n    st[0][++top] = x;\n  }\n  lst[x] = tot;\n}\nint getmin(int x, int y) { return depth[x] < depth[y] ? x : y; }\nint lca(int x, int y) {\n  x = pre[x], y = pre[y];\n  if (x > y) {\n    swap(x, y);\n  }\n  int k = lg[y - x + 1];\n  return getmin(st[k][x], st[k][y - (1 << k) + 1]);\n}\nint xor_dist(int x, int y) { return xor_val[x] ^ xor_val[y]; }\nint check(int x, int y, int p) {\n  return T.ask(fir[x]) + T.ask(fir[y]) - 2 * T.ask(fir[p]);\n}\nvoid update(int x, int p) {\n  if (x == p) {\n    return;\n  }\n  while (x != p) {\n    T.update(fir[x], 1, n);\n    T.update(lst[x] + 1, -1, n);\n    x = fa[x];\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    fa[i] = i;\n  }\n  for (int i = 1; i <= m; i++) {\n    cin >> e[i].x >> e[i].y >> e[i].val;\n    int x = f(e[i].x), y = f(e[i].y);\n    if (x != y) {\n      add(e[i].x, e[i].y, e[i].val);\n      add(e[i].y, e[i].x, e[i].val);\n      fa[x] = y;\n      ans[i] = 1;\n    }\n  }\n  memset(fa, 0, sizeof(fa));\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      dfs(i);\n    }\n  }\n  for (int i = 2; i <= top; i++) {\n    lg[i] = lg[i >> 1] + 1;\n  }\n  for (int i = 1; (1 << i) <= top; i++) {\n    for (int j = 1; j + (1 << i) - 1 <= top; j++) {\n      st[i][j] = getmin(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    if (ans[i]) {\n      continue;\n    }\n    int x = e[i].x, y = e[i].y, val = e[i].val;\n    if ((xor_dist(x, y) ^ val) == 0) {\n      continue;\n    }\n    int p = lca(x, y);\n    if (check(x, y, p)) {\n      continue;\n    }\n    update(x, p);\n    update(y, p);\n    ans[i] = 1;\n  }\n  for (int i = 1; i <= m; i++) {\n    cout << (ans[i] ? \"YES\" : \"NO\") << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int x = 0, b = 1;\n  char c;\n  do c = getchar();\n  while ((c > '9' || c < '0') && c != '-');\n  if (c == '-') b = 0;\n  do x = x * 10 + c - '0', c = getchar();\n  while (c >= '0' && c <= '9');\n  return b ? x : -x;\n}\nconst int maxn = 1000010;\nint i, j, k, n, m, T, F[maxn], vis[maxn], ROOT[maxn], DEEP[maxn], sum[maxn],\n    cnt, FA[maxn][21], deep[maxn], dfn[maxn], tot, size[maxn];\nnamespace BIT {\nint tree[maxn];\nint lowbit(int x) { return x & (-x); }\nvoid add(int x, int s) {\n  for (; x <= n; x += lowbit(x)) tree[x] += s;\n}\nint find(int x) {\n  if (!x) return 0;\n  int ans = 0;\n  for (; x; x -= lowbit(x)) ans += tree[x];\n  return ans;\n}\n}  // namespace BIT\nstruct edge {\n  int next, to, w;\n} e[maxn * 2];\nstruct QUERY {\n  int x, y, z, ans;\n} Q[maxn * 2];\nint head[maxn], len;\nvoid add(int x, int y, int z) {\n  e[++len] = {head[x], y, z};\n  head[x] = len;\n}\nint find(int x) { return F[x] == x ? x : F[x] = find(F[x]); }\nvoid dfs(int now, int fa) {\n  vis[now] = cnt;\n  FA[now][0] = fa;\n  deep[now] = deep[fa] + 1;\n  dfn[now] = ++tot;\n  size[now] = 1;\n  for (int i = 1; i <= 20; i++) FA[now][i] = FA[FA[now][i - 1]][i - 1];\n  for (int i = head[now]; i; i = e[i].next) {\n    int u = e[i].to;\n    if (u == fa) continue;\n    DEEP[u] = DEEP[now] ^ e[i].w;\n    dfs(u, now);\n    size[now] += size[u];\n  }\n}\nint lca(int x, int y) {\n  if (deep[x] > deep[y]) swap(x, y);\n  for (int i = 20; i >= 0; i--)\n    if (deep[x] <= deep[FA[y][i]]) y = FA[y][i];\n  if (x == y) return x;\n  for (int i = 20; i >= 0; i--)\n    if (FA[x][i] != FA[y][i]) x = FA[x][i], y = FA[y][i];\n  return FA[x][0];\n}\nvoid work(int x, int y) {\n  if (x == y) return;\n  BIT::add(dfn[x] + size[x], -1);\n  BIT::add(dfn[x], 1);\n  work(FA[x][0], y);\n}\nint getsum(int x) { return BIT::find(dfn[x]); }\nint main() {\n  cin >> n >> m;\n  for (i = 1; i <= n; i++) F[i] = i;\n  for (i = 1; i <= m; i++) {\n    int x, y, w;\n    x = read();\n    y = read();\n    w = read();\n    if (find(x) != find(y)) {\n      add(x, y, w);\n      add(y, x, w);\n      F[find(x)] = y;\n      Q[i].ans = 1;\n    }\n    Q[i].x = x;\n    Q[i].y = y;\n    Q[i].z = w;\n  }\n  for (i = 1; i <= n; i++)\n    if (!vis[i]) ROOT[++cnt] = i, dfs(i, 0);\n  for (i = 1; i <= m; i++) {\n    if (!Q[i].ans) {\n      int x = Q[i].x, y = Q[i].y, w = Q[i].z;\n      int z = lca(x, y);\n      if (getsum(x) + getsum(y) == 2 * getsum(z)) {\n        if ((DEEP[x] ^ DEEP[y]) != w) {\n          puts(\"YES\");\n          work(x, z);\n          work(y, z);\n        } else\n          puts(\"NO\");\n      } else\n        puts(\"NO\");\n    } else {\n      puts(\"YES\");\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300100, M = 500100;\nint n, m, ix[M], iy[M], iw[M], sjc, fa[20][N], indfn[N], outdfn[N], tag[M],\n    dep[N], pre[N];\nvector<pair<int, int>> G[N];\nvoid dfs(int x, int las) {\n  fa[0][x] = las;\n  indfn[x] = ++sjc;\n  dep[x] = dep[las] + 1;\n  for (int i = 1; i < 20; ++i) fa[i][x] = fa[i - 1][fa[i - 1][x]];\n  for (auto [y, w] : G[x])\n    if (y != las) pre[y] = pre[x] ^ w, dfs(y, x);\n  outdfn[x] = sjc;\n}\nint fwk[N];\nvoid ins(int x, int y) {\n  for (; x <= n; x += x & -x) fwk[x] += y;\n}\nint find(int x) {\n  int res = 0;\n  for (; x; x -= x & -x) res += fwk[x];\n  return res;\n}\nint lh[N];\nint dsuFind(int x) {\n  while (x != lh[x]) x = lh[x] = lh[lh[x]];\n  return x;\n}\nint LCA(int x, int y) {\n  if (dep[x] < dep[y]) swap(x, y);\n  for (int i = 19; ~i; --i)\n    if (dep[fa[i][x]] >= dep[y]) x = fa[i][x];\n  if (x == y) return x;\n  for (int i = 19; ~i; --i)\n    if (fa[i][x] != fa[i][y]) x = fa[i][x], y = fa[i][y];\n  return fa[0][x];\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr), cout.tie(nullptr);\n  cin >> n >> m;\n  iota(lh + 1, lh + n + 1, 1);\n  for (int i = 1; i <= m; ++i) {\n    cin >> ix[i] >> iy[i] >> iw[i];\n    int x = dsuFind(ix[i]), y = dsuFind(iy[i]);\n    if (x != y) {\n      G[ix[i]].emplace_back(iy[i], iw[i]);\n      G[iy[i]].emplace_back(ix[i], iw[i]);\n      tag[i] = 1, lh[x] = y;\n    }\n  }\n  for (int i = 1; i <= n; ++i)\n    if (!dep[i]) dfs(i, 0);\n  for (int i = 1; i <= m; ++i) {\n    if (tag[i])\n      cout << \"YES\\n\";\n    else {\n      int x = ix[i], y = iy[i];\n      if (find(indfn[x]) + find(indfn[y]) - find(indfn[LCA(x, y)]) * 2 > 0 ||\n          (pre[x] ^ pre[y] ^ iw[i]) != 1)\n        cout << \"NO\\n\";\n      else {\n        cout << \"YES\\n\";\n        while (x != y)\n          (dep[x] < dep[y]) && (x ^= y ^= x ^= y), ins(indfn[x], 1),\n              ins(outdfn[x] + 1, -1), x = fa[0][x];\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300000;\nconst int B = 18;\nint timerin, timerout;\nint tin[N + 1], tout[N + 1];\nint comp[N + 1], sz[N + 1];\nint par[N + 1][B + 1];\nint sum[N + 1], xorup[N + 1];\nint f[N + 2];\nvoid upd(int x, int d) {\n  for (; x <= N; x += (x & -x)) f[x] += d;\n}\nint cnt(int x) {\n  int ans = 0;\n  for (; x > 0; x -= (x & -x)) ans += f[x];\n  return ans;\n}\nvector<pair<int, int> > v[N + 1];\nbool isp(int a, int b) { return tin[a] <= tin[b] && tout[b] <= tout[a]; }\nint lca(int a, int b) {\n  if (isp(a, b)) return a;\n  for (int i = B; i >= 0; i--)\n    if (par[a][i] && !isp(par[a][i], b)) a = par[a][i];\n  return par[a][0];\n}\nint dfs(int p, int parent) {\n  tin[p] = ++timerin;\n  par[p][0] = parent;\n  for (int i = 1; i <= B; i++) par[p][i] = par[par[p][i - 1]][i - 1];\n  for (int i = 0; i < v[p].size(); i++)\n    if (v[p][i].first != parent) {\n      xorup[v[p][i].first] = xorup[p] ^ v[p][i].second;\n      int d = dfs(v[p][i].first, p);\n      sum[p] += d + 1;\n    }\n  tout[p] = ++timerout;\n  return sum[p];\n}\nvoid update(int p, int top) {\n  for (int t = p; t != top; t = par[t][0]) {\n    upd(tin[t], 1);\n    upd(tin[t] + sum[t] + 1, -1);\n  }\n}\nbool solve(int a, int b, int x) {\n  if (x == -1) return 1;\n  if ((xorup[a] ^ xorup[b] ^ x) == 0) return 0;\n  int top = lca(a, b);\n  if (cnt(tin[a]) + cnt(tin[b]) > 2 * cnt(tin[top])) return 0;\n  update(a, top);\n  update(b, top);\n  return 1;\n}\nint parent(int p) {\n  if (comp[p] != p) comp[p] = parent(comp[p]);\n  return comp[p];\n}\nvoid union_sets(int a, int b) {\n  if (sz[a] > sz[b]) swap(a, b);\n  comp[a] = b;\n  sz[b] += sz[a];\n}\nint main() {\n  ios::sync_with_stdio(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    comp[i] = i;\n    sz[i] = 1;\n  }\n  int a[m], b[m], x[m];\n  for (int i = 0; i < m; i++) {\n    cin >> a[i] >> b[i] >> x[i];\n    if (parent(a[i]) != parent(b[i])) {\n      union_sets(parent(a[i]), parent(b[i]));\n      v[a[i]].push_back(make_pair(b[i], x[i]));\n      v[b[i]].push_back(make_pair(a[i], x[i]));\n      x[i] = -1;\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (parent(i) == i) dfs(i, 0);\n  for (int i = 0; i < m; i++)\n    cout << (solve(a[i], b[i], x[i]) ? \"YES\" : \"NO\") << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint aib[600005][2];\nint lsb(int x) { return x & -x; }\nint qry(int pz, int fel) {\n  --fel;\n  int rz = 0;\n  for (int i = pz; i > 0; i -= lsb(i)) rz += aib[i][fel];\n  return rz;\n}\nvoid upd(int pz, int fel, int val) {\n  --fel;\n  for (int i = pz; i <= 600000; i += lsb(i)) aib[i][fel] += val;\n}\nint t[300005];\nint tata(int pz) {\n  if (t[pz] == pz || t[pz] == 0) return pz;\n  return t[pz] = tata(t[pz]);\n}\nvector<int> v[300005];\nint stramos[300005][19];\nstruct query {\n  int a, b, c;\n} qs[500005];\nint viz[300005];\nint in[300005], out[300005], tc = 0;\nvoid dfs(int pz, int tt) {\n  viz[pz] = 1;\n  in[pz] = ++tc;\n  stramos[pz][0] = tt;\n  for (int i = 0; i < v[pz].size(); ++i) {\n    if (v[pz][i] == tt) continue;\n    dfs(v[pz][i], pz);\n  }\n  out[pz] = ++tc;\n}\nbool estr(int a, int b) {\n  if (in[a] < in[b] && out[b] < out[a]) return true;\n  return false;\n}\nint getstr(int a, int b) {\n  if (estr(a, b)) return a;\n  if (estr(b, a)) return b;\n  int pas = 18;\n  while (pas >= 0) {\n    if (!estr(stramos[a][pas], b)) a = stramos[a][pas];\n    --pas;\n  }\n  return stramos[a][0];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  long long i, j, k, m, n;\n  cin >> n >> m;\n  for (i = 1; i <= m; ++i) cin >> qs[i].a >> qs[i].b >> qs[i].c;\n  for (i = 1; i <= m; ++i) {\n    if (tata(qs[i].a) != tata(qs[i].b)) {\n      t[tata(qs[i].a)] = tata(qs[i].b);\n      v[qs[i].a].push_back(qs[i].b);\n      v[qs[i].b].push_back(qs[i].a);\n    }\n  }\n  for (i = 1; i <= n; ++i)\n    if (!viz[i]) dfs(i, i);\n  for (int put = 1; put <= 18; ++put)\n    for (int i = 1; i <= n; ++i)\n      stramos[i][put] = stramos[stramos[i][put - 1]][put - 1];\n  for (i = 1; i <= n; ++i) t[i] = 0;\n  for (int qc = 1; qc <= m; ++qc) {\n    int a = qs[qc].a, b = qs[qc].b, c = qs[qc].c;\n    if (tata(a) != tata(b)) {\n      if (estr(a, b)) {\n        upd(in[b], 1, 1 * c);\n        upd(out[b], 1, -1 * c);\n      } else {\n        assert(estr(b, a));\n        upd(in[a], 1, 1 * c);\n        upd(out[a], 1, -1 * c);\n      }\n      t[tata(a)] = tata(b);\n      cout << \"YES\\n\";\n      continue;\n    }\n    int str = getstr(a, b);\n    if (qry(in[a], 2) + qry(in[b], 2) - qry(in[str], 2) * 2 != 0) {\n      cout << \"NO\\n\";\n      continue;\n    }\n    if ((qry(in[a], 1) + qry(in[b], 1) + c) % 2 == 0) {\n      cout << \"NO\\n\";\n      continue;\n    }\n    while (a != str) {\n      upd(in[a], 2, 1);\n      upd(out[a], 2, -1);\n      a = stramos[a][0];\n    }\n    while (b != str) {\n      upd(in[b], 2, 1);\n      upd(out[b], 2, -1);\n      b = stramos[b][0];\n    }\n    cout << \"YES\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nclass BinaryIndexedTree {\n private:\n  static const int N = 1 << 20;\n  int n;\n  int c[N];\n\n public:\n  void Build(int n) {\n    this->n = n;\n    for (int i = 0; i <= n; i++) c[i] = 0;\n  }\n  void Add(int x, int v) {\n    for (x++; x <= n; x += x & -x) c[x] += v;\n  }\n  T Sum(int x) {\n    T ret = 0;\n    for (x++; x; x -= x & -x) ret += c[x];\n    return ret;\n  }\n};\nclass DisjointSet {\n private:\n  int n;\n  vector<int> pa;\n\n public:\n  void Build(int n) {\n    this->n = n;\n    pa.resize(n);\n    for (int i = 0; i < n; i++) pa[i] = i;\n  }\n  int Find(int x) { return x == pa[x] ? x : pa[x] = Find(pa[x]); }\n  bool Union(int x, int y) {\n    int fx = Find(x), fy = Find(y);\n    if (fx == fy) return false;\n    pa[fx] = fy;\n    return true;\n  }\n};\nconst int N = 3e5, Q = 5e5;\nint n;\nvector<pair<int, int> > G[N];\nvector<pair<int, int> > queries[N];\nint f[N];\nint pa[N], pre[N], post[N];\nint dfs_clock;\nDisjointSet ds;\nint u[Q], v[Q], x[Q];\nint lca[Q];\nbool ans[Q];\nBinaryIndexedTree<int> bit;\nvoid dfs(int u, int fa = -1) {\n  pre[u] = dfs_clock++;\n  for (auto [v, qid] : G[u]) {\n    if (v == fa) continue;\n    f[v] = f[u] ^ x[qid];\n    pa[v] = u;\n    dfs(v, u);\n    ds.Union(v, u);\n  }\n  for (auto [v, qid] : queries[u]) {\n    int fv = ds.Find(v);\n    if (v != fv) lca[qid] = fv;\n  }\n  post[u] = dfs_clock;\n}\nint main() {\n  cin.tie(0), cout.tie(0);\n  ios::sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  ds.Build(n);\n  for (int i = 0; i < q; i++) {\n    cin >> u[i] >> v[i] >> x[i];\n    u[i]--, v[i]--;\n    if (ds.Union(u[i], v[i])) {\n      ans[i] = true;\n      G[u[i]].emplace_back(v[i], i);\n      G[v[i]].emplace_back(u[i], i);\n    } else {\n      queries[u[i]].emplace_back(v[i], i);\n      queries[v[i]].emplace_back(u[i], i);\n    }\n  }\n  ds.Build(n);\n  for (int i = 0; i < n; i++) pre[i] = -1;\n  for (int i = 0; i < n; i++)\n    if (pre[i] == -1) {\n      pa[i] = -1;\n      dfs(i);\n      f[i] = 0;\n    }\n  bit.Build(n + 1);\n  for (int i = 0; i < q; i++) {\n    if (ans[i]) continue;\n    int U = u[i], V = v[i];\n    if ((x[i] ^ f[U] ^ f[V]) != 1) continue;\n    int LCA = lca[i];\n    int s = bit.Sum(pre[U]) + bit.Sum(pre[V]) - 2 * bit.Sum(pre[LCA]);\n    if (s > 0) continue;\n    ans[i] = true;\n    for (int st : {U, V}) {\n      for (int i = st; i != LCA; i = pa[i]) {\n        bit.Add(pre[i], +1);\n        bit.Add(post[i], -1);\n      }\n    }\n  }\n  for (int i = 0; i < q; i++) puts(ans[i] ? \"YES\" : \"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 8e5 + 10, inf = 0x3f3f3f3f, llinf = 0x3f3f3f3f3f3f3f3f;\nconst int M = 2e7 + 5;\nlong long n, m, q;\nlong long nn;\nint a[N];\nstruct LCT {\n  int c[N][2], fa[N], s[N], r[N], st[N], cir[N], tcir[N];\n  inline int lc(int x) { return c[x][0]; }\n  inline int rc(int x) { return c[x][1]; }\n  void pushup(int x) {\n    s[x] = s[lc(x)] ^ s[rc(x)] ^ a[x];\n    cir[x] = cir[lc(x)] | cir[rc(x)] | tcir[x];\n  }\n  void pushr(int x) {\n    swap(c[x][0], c[x][1]);\n    r[x] ^= 1;\n  }\n  void pushdown(int x) {\n    if (r[x]) {\n      if (lc(x)) pushr(lc(x));\n      if (rc(x)) pushr(rc(x));\n      r[x] = 0;\n    }\n  }\n  int nroot(int x) { return lc(fa[x]) == x || rc(fa[x]) == x; }\n  void rotate(int x) {\n    int y = fa[x], z = fa[y];\n    int ys = c[y][1] == x, zs = c[z][1] == y, w = c[x][!ys];\n    if (nroot(y)) c[z][zs] = x;\n    c[x][!ys] = y;\n    c[y][ys] = w;\n    if (w) fa[w] = y;\n    fa[x] = z;\n    fa[y] = x;\n    pushup(x);\n    pushup(y);\n  }\n  void splay(int x) {\n    int y = x, tot = 0;\n    st[++tot] = y;\n    while (nroot(y)) {\n      st[++tot] = fa[y];\n      y = fa[y];\n    }\n    while (tot) pushdown(st[tot--]);\n    while (nroot(x)) {\n      int y = fa[x], z = fa[y];\n      if (nroot(y)) {\n        rotate((c[y][0] == x) ^ (c[z][0] == y) ? x : y);\n      }\n      rotate(x);\n    }\n    pushup(x);\n  }\n  void access(int x) {\n    for (int y = 0; x; y = x, x = fa[x]) {\n      splay(x);\n      c[x][1] = y;\n      pushup(x);\n    }\n  }\n  int findroot(int x) {\n    access(x);\n    splay(x);\n    while (lc(x)) {\n      pushdown(x);\n      x = lc(x);\n    }\n    splay(x);\n    return x;\n  }\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    pushr(x);\n  }\n  void split(int x, int y) {\n    makeroot(x);\n    access(y);\n    splay(y);\n  }\n  void link(int x, int y) {\n    makeroot(x);\n    if (findroot(y) != x) fa[x] = y;\n  }\n  void cut(int x, int y) {\n    makeroot(x);\n    if (findroot(y) == x && fa[y] == x && !lc(y)) {\n      fa[y] = c[x][1] = 0;\n      pushup(x);\n    }\n  }\n  void update(int x) {\n    if (x > n) {\n      tcir[x] = 1;\n    }\n    if (lc(x)) update(lc(x));\n    if (rc(x)) update(rc(x));\n    pushup(x);\n  }\n  int work(int x, int y, int z) {\n    makeroot(x);\n    if (findroot(y) != x) {\n      ++nn;\n      a[nn] = z;\n      link(x, nn);\n      link(nn, y);\n      return 1;\n    } else {\n      if ((s[x] ^ z) == 1 && !cir[x]) {\n        update(x);\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }\n} lct;\nvoid solve() {\n  cin >> n >> q;\n  nn = n;\n  for (int i = 1; i <= q; ++i) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    if (lct.work(u, v, x)) {\n      cout << ((1) ? \"YES\" : \"NO\") << '\\n';\n    } else {\n      cout << ((0) ? \"YES\" : \"NO\") << '\\n';\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  ;\n  int tt = 1;\n  while (tt--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Dsu {\n  vector<int> p;\n  Dsu(int n) : p(n, -1) {}\n  int find(int x) { return p[x] < 0 ? x : p[x] = find(p[x]); }\n  bool merge(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return false;\n    if (-p[u] > -p[v]) swap(u, v);\n    p[v] += p[u];\n    p[u] = v;\n    return true;\n  }\n};\nconst int N = 5e5 + 5, LG = 20;\nvector<pair<int, int>> g[N];\nint col[N], par[N], lv[N], in[N], out[N], ccounter = 0;\nint anc[LG][N];\nvoid dfs(int v) {\n  anc[0][v] = par[v];\n  for (int i = 0; i + 1 < LG; ++i) {\n    anc[i + 1][v] = anc[i][anc[i][v]];\n  }\n  in[v] = ccounter++;\n  for (auto& [u, w] : g[v]) {\n    if (u == par[v]) continue;\n    col[u] = col[v] ^ w;\n    par[u] = v;\n    lv[u] = lv[v] + 1;\n    dfs(u);\n  }\n  out[v] = ccounter;\n}\nint lca(int u, int v) {\n  if (lv[u] > lv[v]) swap(u, v);\n  int diff = lv[v] - lv[u];\n  for (int i = 0; i < LG; ++i) {\n    if (diff & (1 << i)) {\n      v = anc[i][v];\n    }\n  }\n  if (u == v) return u;\n  for (int i = LG - 1; i >= 0; --i) {\n    if (anc[i][u] != anc[i][v]) {\n      u = anc[i][u];\n      v = anc[i][v];\n    }\n  }\n  return anc[0][v];\n}\nstruct Fenwick {\n  vector<int> sum;\n  Fenwick(int _n) : sum(_n + 5, 0) {}\n  void update(int x, int v) {\n    for (++x; x < (int)sum.size(); x += x & -x) sum[x] += v;\n  }\n  int get(int x) {\n    int ret = 0;\n    for (++x; x; x -= x & -x) ret += sum[x];\n    return ret;\n  }\n};\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  vector<int> x(q), y(q), z(q);\n  Dsu dsu(n);\n  vector<int> ans(q, 0);\n  for (int i = 0; i < q; ++i) {\n    cin >> x[i] >> y[i] >> z[i];\n    --x[i], --y[i];\n    if (dsu.merge(x[i], y[i])) {\n      g[x[i]].emplace_back(y[i], z[i]);\n      g[y[i]].emplace_back(x[i], z[i]);\n      ans[i] = 1;\n    }\n  }\n  memset(col, -1, sizeof col);\n  for (int i = 0; i < n; ++i) {\n    if (col[i] != -1) continue;\n    par[i] = i;\n    col[i] = 0;\n    dfs(i);\n  }\n  Fenwick fen(n);\n  for (int i = 0; i < q; ++i) {\n    if (ans[i]) continue;\n    int u = x[i], v = y[i], w = z[i];\n    int cycle = col[u] ^ col[v] ^ w;\n    if (cycle == 0) continue;\n    int a = lca(u, v);\n    int tot = fen.get(in[u]) + fen.get(in[v]) - 2 * fen.get(in[a]);\n    if (tot > 0) {\n      continue;\n    }\n    ans[i] = 1;\n    while (u != v) {\n      if (lv[u] > lv[v]) {\n        swap(u, v);\n      }\n      fen.update(in[v], +1);\n      fen.update(out[v], -1);\n      v = par[v];\n    }\n  }\n  for (int i = 0; i < q; ++i) {\n    cout << (ans[i] ? \"YES\\n\" : \"NO\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 6e5 + 500;\nbool mk[N * 2], was[N];\nint xr[N], tim;\nint t[2 * N], up[N][19], tin[N], tout[N], pr[N];\nvector<pair<int, int> > g[N];\nvector<pair<pair<int, int>, int> > qr;\nvoid upd(int v, int val) {\n  for (; v < 2 * N; v = (v | (v + 1))) t[v] += val;\n}\nint get(int v) {\n  int ret = 0;\n  for (; v >= 0; v = (v & (v + 1)) - 1) ret += t[v];\n  return ret;\n}\nint f(int v) { return (pr[v] == v ? v : pr[v] = f(pr[v])); }\nvoid link(int v, int u) { pr[u] = v; }\nbool ispr(int v, int u) { return (tin[v] <= tin[u] && tout[v] >= tout[u]); }\nint lca(int v, int u) {\n  if (ispr(v, u)) {\n    return v;\n  }\n  if (ispr(u, v)) {\n    return u;\n  }\n  for (int st = 18; st >= 0; st--) {\n    if (!ispr(up[v][st], u)) {\n      v = up[v][st];\n    }\n  }\n  return up[v][0];\n}\nvoid dfs(int v, int pr) {\n  was[v] = 1;\n  tin[v] = tim++;\n  if (pr != -1) {\n    up[v][0] = pr;\n  }\n  for (auto u : g[v]) {\n    if (u.first == pr || was[u.first]) {\n      continue;\n    }\n    xr[u.first] = xr[v] ^ u.second;\n    dfs(u.first, v);\n  }\n  tout[v] = tim++;\n}\nvoid upd_path(int v, int u, int lc) {\n  while (v != lc) {\n    upd(tin[v], 1);\n    upd(tout[v], -1);\n    v = up[v][0];\n  }\n  while (u != lc) {\n    upd(tin[u], 1);\n    upd(tout[u], -1);\n    u = up[u][0];\n  }\n}\nbool get_path(int v, int u, int lc) {\n  return (get(tin[v]) + get(tin[u]) - 2 * get(tin[lc]));\n}\nint main() {\n  istream::sync_with_stdio(0);\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout.precision(9);\n  cout << fixed;\n  int n, m, v, u, x;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    pr[i] = i;\n    g[0].push_back({i, 0});\n    g[i].push_back({0, 0});\n  }\n  for (int i = 1; i <= m; i++) {\n    cin >> v >> u >> x;\n    qr.push_back({{v, u}, x});\n    if (f(v) == f(u)) {\n      continue;\n    } else {\n      link(f(v), f(u));\n      mk[i - 1] = 1;\n      g[v].push_back({u, x});\n      g[u].push_back({v, x});\n    }\n  }\n  xr[1] = 0;\n  dfs(0, -1);\n  for (int st = 1; st < 19; st++) {\n    for (int i = 1; i <= n; i++) {\n      up[i][st] = up[up[i][st - 1]][st - 1];\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    if (mk[i]) {\n      cout << \"YES\" << '\\n';\n      continue;\n    }\n    int v = qr[i].first.first;\n    int u = qr[i].first.second;\n    int x = qr[i].second;\n    int lc = lca(v, u);\n    if ((xr[v] ^ xr[u] ^ x) == 0 || get_path(v, u, lc)) {\n      cout << \"NO\" << '\\n';\n    } else {\n      upd_path(v, u, lc);\n      cout << \"YES\" << '\\n';\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 5e5 + 14, LG = 19;\nstruct Dsu {\n  int par[MAX_N];\n  Dsu() { memset(par, -1, sizeof par); }\n  int root(int v) { return par[v] < 0 ? v : par[v] = root(par[v]); }\n  bool fri(int v, int u) { return root(v) == root(u); }\n  bool merge(int v, int u) {\n    if ((v = root(v)) == (u = root(u))) return 0;\n    par[u] += par[v];\n    par[v] = u;\n    return 1;\n  }\n} dsu;\nint fen[MAX_N];\nint get(int p) {\n  int ans = 0;\n  for (p++; p; p ^= p & -p) ans += fen[p];\n  return ans;\n}\nvoid upd(int p, int v) {\n  for (p++; p < MAX_N; p += p & -p) fen[p] += v;\n}\nvoid upd(int l, int r, int v) { upd(l, v), upd(r, -v); }\nstruct Edge {\n  int v, u, x;\n  bool include;\n};\nint n, q, h[MAX_N], par[LG][MAX_N], st[MAX_N], en[MAX_N];\nbool weight_parity[MAX_N];\nvector<pair<int, bool>> g[MAX_N];\nvoid dfs(int v = 0, int p = -1) {\n  static int time = 0;\n  st[v] = time++;\n  for (auto [u, w] : g[v])\n    if (u != p) {\n      par[0][u] = v;\n      h[u] = h[v] + 1;\n      weight_parity[u] = weight_parity[v] ^ w;\n      dfs(u, v);\n    }\n  en[v] = time;\n}\nint lca(int v, int u) {\n  if (h[v] > h[u]) swap(v, u);\n  for (int i = 0; i < LG; i++)\n    if (h[u] - h[v] >> i & 1) u = par[i][u];\n  for (int i = LG - 1; i >= 0; i--)\n    if (par[i][v] != par[i][u]) v = par[i][v], u = par[i][u];\n  return v == u ? v : par[0][v];\n}\nEdge edges[MAX_N];\nvoid block_path(int v, int p) {\n  while (v != p) {\n    upd(st[v], en[v], +1);\n    v = par[0][v];\n  }\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  cin >> n >> q;\n  for (int i = 0; i < q; ++i) {\n    cin >> edges[i].v >> edges[i].u >> edges[i].x;\n    --edges[i].v;\n    --edges[i].u;\n    if (dsu.merge(edges[i].v, edges[i].u)) {\n      edges[i].include = true;\n      g[edges[i].v].emplace_back(edges[i].u, edges[i].x);\n      g[edges[i].u].emplace_back(edges[i].v, edges[i].x);\n    }\n  }\n  for (int i = 0; i < n; ++i)\n    if (h[i] == 0) {\n      dfs(i);\n      par[0][i] = i;\n    }\n  for (int k = 1; k < LG; k++)\n    for (int i = 0; i < n; i++) par[k][i] = par[k - 1][par[k - 1][i]];\n  for (int i = 0; i < q; ++i) {\n    if (!edges[i].include &&\n        (edges[i].x ^ weight_parity[edges[i].v] ^ weight_parity[edges[i].u]) &&\n        get(st[edges[i].v]) == get(st[edges[i].u]) &&\n        get(st[edges[i].v]) == get(st[lca(edges[i].v, edges[i].u)])) {\n      block_path(edges[i].v, lca(edges[i].v, edges[i].u));\n      block_path(edges[i].u, lca(edges[i].v, edges[i].u));\n      edges[i].include = true;\n    }\n    cout << (edges[i].include ? \"YES\\n\" : \"NO\\n\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5;\nint n, m, ff[N], aw[N];\nint NumE, Fir[N];\nint tot, fa[N], s[N], d[N], ws[N], tp[N], id[N];\nbool tv[N];\ninline int Read() {\n  int x = 0;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') ch = getchar();\n  while (ch >= '0' && ch <= '9') {\n    x = (x << 3) + (x << 1) + (ch ^ 48);\n    ch = getchar();\n  }\n  return x;\n}\nstruct Data {\n  int u, v, w;\n} ur[N];\nint Find(int x) {\n  if (x == ff[x]) return x;\n  return ff[x] = Find(ff[x]);\n}\nstruct Edge {\n  int v, w, nxt;\n} E[N];\nvoid AddE(int u, int v, int w) {\n  E[++NumE] = (Edge){v, w, Fir[u]};\n  Fir[u] = NumE;\n}\nvoid Dfs1(int x, int ft) {\n  fa[x] = ft, s[x] = 1, d[x] = d[ft] + 1;\n  for (int i = Fir[x]; i; i = E[i].nxt)\n    if (E[i].v != ft) {\n      aw[E[i].v] = aw[x] ^ E[i].w;\n      Dfs1(E[i].v, x);\n      s[x] += s[E[i].v];\n      if (s[ws[x]] < s[E[i].v]) ws[x] = E[i].v;\n    }\n}\nvoid Dfs2(int x, int ft) {\n  tp[x] = ft, id[x] = ++tot;\n  if (!ws[x]) return;\n  Dfs2(ws[x], ft);\n  for (int i = Fir[x]; i; i = E[i].nxt)\n    if (E[i].v != fa[x] && E[i].v != ws[x]) Dfs2(E[i].v, E[i].v);\n}\nstruct SegT {\n  int v[N * 4], t[N * 4];\n  void Chg(int x, int d, int y) { v[x] = y * d, t[x] = y; }\n  void Up(int x) { v[x] = v[x << 1] + v[x << 1 | 1]; }\n  void Dn(int x, int l, int r) {\n    if (t[x] == -1) return;\n    int mid = (l + r) >> 1;\n    Chg(x << 1, mid - l + 1, t[x]);\n    Chg(x << 1 | 1, r - mid, t[x]);\n    t[x] = -1;\n  }\n  void Bld(int x, int l, int r) {\n    t[x] = -1;\n    if (l == r) return;\n    int mid = (l + r) >> 1;\n    Bld(x << 1, l, mid);\n    Bld(x << 1 | 1, mid + 1, r);\n    Up(x);\n  }\n  void Upd(int x, int l, int r, int L, int R, int k) {\n    if (L > r || R < l) return;\n    if (L <= l && r <= R) {\n      Chg(x, r - l + 1, k);\n      return;\n    }\n    Dn(x, l, r);\n    int mid = (l + r) >> 1;\n    if (L <= mid) Upd(x << 1, l, mid, L, R, k);\n    if (R > mid) Upd(x << 1 | 1, mid + 1, r, L, R, k);\n    Up(x);\n  }\n  int Qry(int x, int l, int r, int L, int R) {\n    if (L > r || R < l) return 0;\n    if (L <= l && r <= R) return v[x];\n    Dn(x, l, r);\n    int mid = (l + r) >> 1, Sum = 0;\n    if (L <= mid) Sum = Qry(x << 1, l, mid, L, R);\n    if (R > mid) Sum += Qry(x << 1 | 1, mid + 1, r, L, R);\n    return Sum;\n  }\n} T;\nvoid Usum(int x, int y, int k) {\n  while (tp[x] != tp[y]) {\n    if (d[tp[x]] < d[tp[y]]) swap(x, y);\n    T.Upd(1, 1, n, id[tp[x]], id[x], k);\n    x = fa[tp[x]];\n  }\n  if (d[x] > d[y]) swap(x, y);\n  T.Upd(1, 1, n, id[x] + 1, id[y], k);\n}\nint Qsum(int x, int y) {\n  int Ret = 0;\n  while (tp[x] != tp[y]) {\n    if (d[tp[x]] < d[tp[y]]) swap(x, y);\n    Ret += T.Qry(1, 1, n, id[tp[x]], id[x]);\n    x = fa[tp[x]];\n  }\n  if (d[x] > d[y]) swap(x, y);\n  return Ret + T.Qry(1, 1, n, id[x] + 1, id[y]);\n}\nint LCA(int x, int y) {\n  while (tp[x] != tp[y]) {\n    if (d[tp[x]] < d[tp[y]]) swap(x, y);\n    x = fa[tp[x]];\n  }\n  if (d[x] < d[y]) return x;\n  return y;\n}\nint main() {\n  n = Read(), m = Read();\n  for (int i = 1; i <= n; i++) ff[i] = i;\n  for (int i = 1; i <= m; i++) {\n    int x = Read(), y = Read(), z = Read();\n    ur[i] = (Data){x, y, z};\n    int fu = Find(x), fv = Find(y);\n    if (fu != fv) {\n      ff[fv] = fu;\n      AddE(x, y, z), AddE(y, x, z);\n      tv[i] = true;\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (!s[i]) Dfs1(i, 0);\n  for (int i = 1; i <= n; i++)\n    if (!id[i]) Dfs2(i, i);\n  T.Bld(1, 1, n);\n  for (int i = 1; i <= m; i++) {\n    if (tv[i]) {\n      printf(\"YES\\n\");\n      continue;\n    }\n    if (!(aw[ur[i].u] ^ aw[ur[i].v] ^ ur[i].w)) {\n      printf(\"NO\\n\");\n      continue;\n    }\n    int lca = LCA(ur[i].u, ur[i].v);\n    int t1 = Qsum(ur[i].u, lca), t2 = Qsum(ur[i].v, lca);\n    if (!t1 && !t2) {\n      printf(\"YES\\n\"), Usum(ur[i].u, lca, 1), Usum(ur[i].v, lca, 1);\n      continue;\n    }\n    printf(\"NO\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class A, class B>\nostream& operator<<(ostream& out, const pair<A, B>& p) {\n  return out << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <class A>\nostream& operator<<(ostream& out, const vector<A>& v) {\n  for (int i = int(0); i < int(int((v).size())); i++) {\n    if (i) out << \" \";\n    out << v[i];\n  }\n  return out;\n}\nconst int INF = int(1e9);\nconst long long INF64 = long long(1e18);\nint n, q;\nvector<array<int, 3> > es;\ninline bool read() {\n  if (!(cin >> n >> q)) return false;\n  es.resize(q);\n  for (int i = int(0); i < int(q); i++) {\n    cin >> es[i][0] >> es[i][1] >> es[i][2];\n    es[i][0]--;\n    es[i][1]--;\n  }\n  return true;\n}\nvector<vector<pair<int, int> > > g;\nconst int LOG = 19;\nvector<int> up[LOG];\nvector<int> tin, tout;\nvector<int> xr;\nint T = 0;\nvoid dfs(int v, int p, int curXor) {\n  tin[v] = T++;\n  xr[v] = curXor;\n  up[0][v] = p;\n  for (int pw = int(1); pw < int(LOG); pw++)\n    up[pw][v] = up[pw - 1][up[pw - 1][v]];\n  for (auto [to, w] : g[v]) {\n    if (to == p) continue;\n    dfs(to, v, curXor ^ w);\n  }\n  tout[v] = T;\n}\nvoid buildLCA() {\n  for (int pw = int(0); pw < int(LOG); pw++) up[pw].resize(n);\n  tin.assign(n, -1);\n  tout.assign(n, -1);\n  xr.assign(n, 0);\n  T = 0;\n  for (int v = int(0); v < int(n); v++) {\n    if (tin[v] != -1) continue;\n    dfs(v, v, 0);\n  }\n}\nint isPar(int p, int v) { return tin[p] <= tin[v] && tout[v] <= tout[p]; }\nint lca(int u, int v) {\n  if (isPar(u, v)) return u;\n  if (isPar(v, u)) return v;\n  for (int pw = LOG - 1; pw >= 0; pw--) {\n    if (!isPar(up[pw][v], u)) v = up[pw][v];\n  }\n  return up[0][v];\n}\nvector<int> par, rk;\nvoid init(int n) {\n  par.assign(n, 0);\n  iota(par.begin(), par.end(), 0);\n  rk.assign(n, 1);\n}\nint top(int v) {\n  if (par[v] != v) return par[v] = top(par[v]);\n  return v;\n}\nbool unite(int u, int v) {\n  u = top(u);\n  v = top(v);\n  if (u == v) return false;\n  if (rk[u] < rk[v]) swap(u, v);\n  par[v] = u;\n  rk[u] += rk[v];\n  return true;\n}\nvector<int> F;\nvoid inc(int pos, int val) {\n  for (; pos < int((F).size()); pos |= pos + 1) F[pos] += val;\n}\nint sum(int pos) {\n  int ans = 0;\n  for (; pos >= 0; pos = (pos & (pos + 1)) - 1) ans += F[pos];\n  return ans;\n}\nvoid addOnPath(int v, int l) {\n  while (v != l) {\n    inc(tin[v], 1);\n    inc(tout[v], -1);\n    v = up[0][v];\n  }\n}\ninline void solve() {\n  init(n);\n  g.resize(n);\n  vector<int> ans(q, -1);\n  for (int i = int(0); i < int(q); i++) {\n    int u = es[i][0];\n    int v = es[i][1];\n    int first = es[i][2];\n    if (unite(u, v)) {\n      ans[i] = 1;\n      g[u].emplace_back(v, first);\n      g[v].emplace_back(u, first);\n    }\n  }\n  buildLCA();\n  F.assign(2 * n + 5, 0);\n  for (int i = int(0); i < int(q); i++) {\n    if (ans[i] != -1) continue;\n    ans[i] = 0;\n    int u = es[i][0];\n    int v = es[i][1];\n    int first = es[i][2];\n    int xorPath = xr[u] ^ xr[v];\n    if ((xorPath ^ first) != 1) continue;\n    int l = lca(u, v);\n    int usedOnPath = sum(tin[u]) + sum(tin[v]) - 2 * sum(tin[l]);\n    if (usedOnPath > 0) continue;\n    ans[i] = 1;\n    addOnPath(u, l);\n    addOnPath(v, l);\n  }\n  for (int res : ans) cout << (res ? \"YES\" : \"NO\") << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  cout << fixed << setprecision(15);\n  if (read()) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nusing ll = long long;\nusing datas = pair<ll, ll>;\nusing ddatas = pair<long double, long double>;\nusing tdata = pair<ll, datas>;\nusing vec = vector<ll>;\nusing mat = vector<vec>;\nusing pvec = vector<datas>;\nusing pmat = vector<pvec>;\nconstexpr ll mod = 1000000007;\nconstexpr ll inf = 1LL << 60;\nconstexpr long double eps = 1e-9;\nconst long double PI = acosl(-1);\ntemplate <class T, class E>\nostream& operator<<(ostream& os, const pair<T, E>& p) {\n  return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  os << \"{\";\n  bool f = false;\n  for (auto& x : v) {\n    if (f) os << \",\";\n    os << x;\n    f = true;\n  }\n  os << \"}\";\n  return os;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, const set<T>& v) {\n  os << \"{\";\n  bool f = false;\n  for (auto& x : v) {\n    if (f) os << \",\";\n    os << x;\n    f = true;\n  }\n  os << \"}\";\n  return os;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, const multiset<T>& v) {\n  os << \"{\";\n  bool f = false;\n  for (auto& x : v) {\n    if (f) os << \",\";\n    os << x;\n    f = true;\n  }\n  os << \"}\";\n  return os;\n}\ntemplate <class T, class E>\nostream& operator<<(ostream& os, const map<T, E>& v) {\n  os << \"{\";\n  bool f = false;\n  for (auto& x : v) {\n    if (f) os << \",\";\n    os << x;\n    f = true;\n  }\n  os << \"}\";\n  return os;\n}\ntemplate <class T>\ninline bool chmax(T& a, const T b) {\n  bool x = a < b;\n  if (x) a = b;\n  return x;\n}\ntemplate <class T>\ninline bool chmin(T& a, const T b) {\n  bool x = a > b;\n  if (x) a = b;\n  return x;\n}\ninline void startupcpp(void) noexcept {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\ntemplate <class S, S (*op)(S, S), S (*e)(), class F, S (*mapping)(S, F),\n          F (*composition)(F, F), F (*id)()>\nstruct lazy_segtree {\n public:\n  lazy_segtree() : lazy_segtree(0) {}\n  lazy_segtree(int n) : lazy_segtree(vector<S>(n, e())) {}\n  lazy_segtree(const vector<S>& v) : _n(int(v.size())) {\n    log = 0;\n    while ((1U << log) < (unsigned int)(_n)) ++log;\n    size = 1 << log;\n    d = vector<S>(size << 1, e());\n    lz = vector<F>(size, id());\n    for (int i = 0; i < _n; ++i) d[size + i] = v[i];\n    for (int i = size - 1; i >= 1; --i) {\n      update(i);\n    }\n  }\n  void set(int p, S x) {\n    assert(0 <= p && p < _n);\n    p += size;\n    for (int i = log; i >= 1; --i) push(p >> i);\n    d[p] = x;\n    for (int i = 1; i <= log; ++i) update(p >> i);\n  }\n  S get(int p) {\n    assert(0 <= p && p < _n);\n    p += size;\n    for (int i = log; i >= 1; --i) push(p >> i);\n    return d[p];\n  }\n  S prod(int l, int r) {\n    assert(0 <= l && l <= r && r <= _n);\n    if (l == r) return e();\n    l += size;\n    r += size;\n    for (int i = log; i >= 1; --i) {\n      if (((l >> i) << i) != l) push(l >> i);\n      if (((r >> i) << i) != r) push(r >> i);\n    }\n    S sml = e(), smr = e();\n    while (l < r) {\n      if (l & 1) sml = op(sml, d[l++]);\n      if (r & 1) smr = op(d[--r], smr);\n      l >>= 1;\n      r >>= 1;\n    }\n    return op(sml, smr);\n  }\n  S all_prod() { return d[1]; }\n  void apply(int p, F f) {\n    assert(0 <= p && p < _n);\n    p += size;\n    for (int i = log; i >= 1; --i) push(p >> i);\n    d[p] = mapping(d[p], f);\n    for (int i = 1; i <= log; ++i) update(p >> i);\n  }\n  void apply(int l, int r, F f) {\n    assert(0 <= l && l <= r && r <= _n);\n    if (l == r) return;\n    l += size;\n    r += size;\n    for (int i = log; i >= 1; --i) {\n      if (((l >> i) << i) != l) push(l >> i);\n      if (((r >> i) << i) != r) push((r - 1) >> i);\n    }\n    {\n      int l2 = l, r2 = r;\n      while (l < r) {\n        if (l & 1) all_apply(l++, f);\n        if (r & 1) all_apply(--r, f);\n        l >>= 1;\n        r >>= 1;\n      }\n      l = l2;\n      r = r2;\n    }\n    for (int i = 1; i <= log; ++i) {\n      if (((l >> i) << i) != l) update(l >> i);\n      if (((r >> i) << i) != r) update((r - 1) >> i);\n    }\n  }\n  template <bool (*g)(S)>\n  int max_right(int l) {\n    return max_right(l, [](S x) { return g(x); });\n  }\n  template <class G>\n  int max_right(int l, G g) {\n    assert(0 <= l && l <= _n);\n    assert(g(e()));\n    if (l == _n) return _n;\n    l += size;\n    for (int i = log; i >= 1; --i) push(l >> i);\n    S sm = e();\n    do {\n      while (~l & 1) l >>= 1;\n      if (!g(op(sm, d[l]))) {\n        while (l < size) {\n          push(l);\n          l <<= 1;\n          if (g(op(sm, d[l]))) {\n            sm = op(sm, d[l++]);\n          }\n        }\n        return l - size;\n      }\n      sm = op(sm, d[l++]);\n    } while ((l & -l) != l);\n    return _n;\n  }\n  template <bool (*g)(S)>\n  int min_left(int r) {\n    return min_left(r, [](S x) { return g(x); });\n  }\n  template <class G>\n  int min_left(int r, G g) {\n    assert(0 <= r && r <= _n);\n    assert(g(e()));\n    if (r == 0) return 0;\n    r += size;\n    for (int i = log; i >= 1; --i) push((r - 1) >> i);\n    S sm = e();\n    do {\n      --r;\n      while (r >> 1 && (r & 1)) r >>= 1;\n      if (!g(op(d[r], sm))) {\n        while (r < size) {\n          push(r);\n          r = r << 1 | 1;\n          if (g(op(d[r], sm))) {\n            sm = op(d[r--], sm);\n          }\n        }\n        return r + 1 - size;\n      }\n      sm = op(d[r], sm);\n    } while ((r & -r) != r);\n    return 0;\n  }\n  int _n;\n\n private:\n  int size, log;\n  vector<S> d;\n  vector<F> lz;\n  void update(int k) { d[k] = op(d[k << 1], d[k << 1 | 1]); }\n  void all_apply(int k, F f) {\n    d[k] = mapping(d[k], f);\n    if (k < size) lz[k] = composition(lz[k], f);\n  }\n  void push(int k) {\n    all_apply(k << 1, lz[k]);\n    all_apply(k << 1 | 1, lz[k]);\n    lz[k] = id();\n  }\n  friend ostream& operator<<(\n      ostream& os,\n      const lazy_segtree<S, op, e, F, mapping, composition, id>& p) {\n    lazy_segtree<S, op, e, F, mapping, composition, id> printout(p);\n    for (int i = 0; i < printout._n; ++i) {\n      os << \"{,\"[i > 0] << printout.prod(i, i + 1);\n    }\n    os << \"}\";\n    return os;\n  }\n};\nnamespace segtreefunction {\nbool op(bool a, bool b) { return a | b; }\nbool e() { return false; }\n}  // namespace segtreefunction\nusing segtree =\n    lazy_segtree<bool, segtreefunction::op, segtreefunction::e, bool,\n                 segtreefunction::op, segtreefunction::op, segtreefunction::e>;\nstruct unionfind {\n private:\n  int maxN;\n  vector<int> par, treesize;\n\n public:\n  unionfind(int N) : maxN(N), par(N), treesize(N, 1) {\n    for (int i = 0; i < maxN; ++i) par[i] = i;\n  }\n  int root(int x) {\n    while (par[x] != x) {\n      x = par[x] = par[par[x]];\n    }\n    return x;\n  }\n  bool unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) return false;\n    if (treesize[x] > treesize[y]) swap(x, y);\n    par[x] = y;\n    treesize[y] += treesize[x];\n    return true;\n  }\n  bool unite(pair<int, int> v) { return unite(v.first, v.second); }\n  bool parcheck(int x, int y) { return root(x) == root(y); }\n  bool parcheck(pair<int, int> v) { return parcheck(v.first, v.second); }\n  int size(int x) { return treesize[root(x)]; }\n  void clear() {\n    treesize.assign(maxN, 1);\n    for (int i = 0; i < maxN; ++i) par[i] = i;\n  }\n  vector<vector<int>> groups() {\n    vector<vector<int>> res(maxN);\n    for (int i = 0; i < maxN; ++i) res[root(i)].emplace_back(i);\n    vector<vector<int>> res2;\n    for (vector<int> x : res) {\n      if (x.size()) res2.emplace_back(x);\n    }\n    return res2;\n  }\n};\nstruct HLD {\n private:\n  vector<vector<int>> g;\n  int fdfs(int now, int p) {\n    int d = 0;\n    par[now] = p;\n    for (size_t i = 0; i + 1 < g[now].size(); ++i) {\n      if (g[now][i] == p) swap(g[now][i], g[now].back());\n      if (chmax(d, fdfs(g[now][i], now))) swap(g[now][0], g[now][i]);\n    }\n    g[now].pop_back();\n    return d + 1;\n  }\n  void sdfs(int now) {\n    in[now] = ETlist.size();\n    ETlist.emplace_back(now);\n    for (size_t i = 0; i < g[now].size(); ++i) {\n      nxt[g[now][i]] = i ? g[now][i] : nxt[now];\n      sdfs(g[now][i]);\n    }\n    out[now] = ETlist.size();\n  }\n\n public:\n  vector<int> par, nxt, in, out, ETlist;\n  segtree solvetree;\n  HLD(int N) : g(N), par(N), nxt(N), in(N), out(N), solvetree(N) {\n    ETlist.reserve(N);\n  };\n  void add_edge(int a, int b) {\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  void init(int first = 0) {\n    {\n      int d = 0;\n      par[first] = -1;\n      for (auto& x : g[first])\n        if (chmax(d, fdfs(x, first))) swap(x, g[first][0]);\n    }\n    nxt[first] = first;\n    sdfs(first);\n  }\n  int lca(int a, int b) {\n    if (in[a] > in[b]) swap(a, b);\n    if (nxt[a] == nxt[b]) return a;\n    return lca(a, par[nxt[b]]);\n  }\n  bool solveprod(int a, int b) {\n    if (in[a] > in[b]) swap(a, b);\n    if (nxt[a] == nxt[b]) return solvetree.prod(in[a] + 1, in[b] + 1);\n    return solveprod(a, par[nxt[b]]) | solvetree.prod(in[nxt[b]], in[b] + 1);\n  }\n  void solveapply(int a, int b) {\n    if (in[a] > in[b]) swap(a, b);\n    if (nxt[a] == nxt[b])\n      solvetree.apply(in[a] + 1, in[b] + 1, true);\n    else {\n      solveapply(a, par[nxt[b]]);\n      solvetree.apply(in[nxt[b]], in[b] + 1, true);\n    }\n  }\n};\nvector<vector<pair<int, int>>> g;\nvector<bool> xorlist;\nint N, Q;\nvoid dfs(int now = 0, int par = -1, bool s = false) {\n  xorlist[now] = s;\n  for (auto& [f, to] : g[now]) {\n    if (to == par) continue;\n    dfs(to, now, s ^ f);\n  }\n}\nint main() {\n  startupcpp();\n  cin >> N >> Q;\n  g.resize(N);\n  HLD hld(N);\n  unionfind dsu(N);\n  vector<bool> ans(Q);\n  vector<tuple<int, int, int, bool>> edge;\n  for (int i = 0; i < Q; ++i) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    --u;\n    --v;\n    if (dsu.unite(u, v)) {\n      ans[i] = true;\n      g[u].emplace_back(w, v);\n      g[v].emplace_back(w, u);\n      hld.add_edge(u, v);\n    } else\n      edge.emplace_back(i, u, v, !w);\n  }\n  for (int i = 1; i < N; ++i)\n    if (dsu.unite(0, i)) {\n      g[0].emplace_back(0, i);\n      hld.add_edge(0, i);\n    }\n  hld.init();\n  xorlist.resize(N);\n  dfs();\n  for (auto& [id, u, v, w] : edge) {\n    if ((xorlist[u] ^ xorlist[v] ^ w) || hld.solveprod(u, v)) {\n      ans[id] = false;\n      continue;\n    }\n    ans[id] = true;\n    hld.solveapply(u, v);\n  }\n  for (auto f : ans) {\n    if (f)\n      cout << \"YES\"\n           << \"\\n\";\n    else\n      cout << \"NO\"\n           << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 5e5 + 10;\nconst long long M = 1e6 + 11;\nconst long long big = 1e17;\nconst long long hsh2 = 1964325029;\nconst long long mod = 998244353;\nconst double EPS = 1e-9;\nconst long long block = 1e14;\nconst long long shift = 2e3;\nconst double pi = acos(-1.0);\nlong long n, q;\nlong long a[N], b[N], c[N];\nvector<pair<long long, long long> > g[N];\nstruct DSU {\n  long long p[N], sz[N];\n  void init(long long n) {\n    for (int i = 1; i <= n; i++) p[i] = i, sz[i] = 1;\n  }\n  long long fnd(long long a) { return p[a] = (p[a] == a ? a : fnd(p[a])); }\n  void unt(long long a, long long b) {\n    a = fnd(a), b = fnd(b);\n    if (a == b) return;\n    if (sz[a] < sz[b]) swap(a, b);\n    p[b] = a;\n    sz[a] += sz[b];\n  }\n} ds;\nstruct seg {\n  long long t[4 * N] = {0};\n  long long u[4 * N] = {0};\n  void push(long long v, long long l, long long r) {\n    if (u[v]) {\n      t[v] = u[v];\n      if (l != r) u[v * 2] = u[v * 2 + 1] = u[v];\n    }\n  }\n  void upd(long long l, long long r, long long v = 1, long long tl = 1,\n           long long tr = n + 10) {\n    push(v, tl, tr);\n    if (l > tr || tl > r || l > r) return;\n    if (l <= tl && tr <= r) {\n      u[v] = 1;\n      push(v, tl, tr);\n      return;\n    }\n    long long m = (tl + tr) >> 1ll;\n    upd(l, r, v * 2, tl, m);\n    upd(l, r, v * 2 + 1, m + 1, tr);\n    t[v] = max(t[v * 2], t[v * 2 + 1]);\n  }\n  long long get(long long l, long long r, long long v = 1, long long tl = 1,\n                long long tr = n + 10) {\n    push(v, tl, tr);\n    if (l > tr || tl > r || l > r) return 0;\n    if (l <= tl && tr <= r) return t[v];\n    long long m = (tl + tr) >> 1ll;\n    return max(get(l, r, v * 2, tl, m), get(l, r, v * 2 + 1, m + 1, tr));\n  }\n} rt;\nlong long bp[N][21], xr[N], sz[N], tin[N], tout[N];\nlong long hp[N];\nvoid dfs(long long v, long long p) {\n  for (int i = 1; i < 20; i++) bp[v][i] = bp[bp[v][i - 1]][i - 1];\n  sz[v] = 1;\n  for (auto u : g[v])\n    if (u.first != p)\n      bp[u.first][0] = v, xr[u.first] = u.second ^ xr[v], dfs(u.first, v),\n      sz[v] += sz[u.first];\n}\nvoid hldfs(long long v, long long p, long long pr) {\n  hp[v] = pr;\n  tin[v] = tout[0]++;\n  for (auto u : g[v])\n    if (u.first != p && sz[u.first] * 2 > sz[v]) hldfs(u.first, v, pr);\n  for (auto u : g[v])\n    if (u.first != p && sz[u.first] * 2 <= sz[v]) hldfs(u.first, v, u.first);\n  tout[v] = tout[0];\n}\nbool upper(long long a, long long b) {\n  return (tin[a] <= tin[b] && tout[b] <= tout[a]);\n}\nlong long LCA(long long a, long long b) {\n  if (upper(a, b)) return a;\n  if (upper(b, a)) return b;\n  for (int j = 19; j >= 0; j--)\n    if (!upper(bp[a][j], b)) a = bp[a][j];\n  return bp[a][0];\n}\nlong long pLCA(long long a, long long b) {\n  if (upper(a, b)) return -1;\n  for (int j = 19; j >= 0; j--)\n    if (!upper(bp[a][j], b)) a = bp[a][j];\n  return a;\n}\nlong long pxr(long long x, long long y) { return xr[x] ^ xr[y]; }\nvoid UpdBamboo(long long v, long long x) {\n  while (1) {\n    long long hm = hp[v];\n    if (hm == hp[x]) hm = x;\n    rt.upd(tin[hm], tin[v]);\n    if (hm == x) break;\n    v = bp[hm][0];\n  }\n}\nlong long GetBamboo(long long v, long long x) {\n  long long z = 0;\n  while (1) {\n    long long hm = hp[v];\n    if (hm == hp[x]) hm = x;\n    z = max(z, rt.get(tin[hm], tin[v]));\n    if (hm == x) break;\n    v = bp[hm][0];\n  }\n  return z;\n}\nvoid UpdPath(long long x, long long y) {\n  long long z = pLCA(x, y);\n  if (z != -1) UpdBamboo(x, z);\n  z = pLCA(y, x);\n  if (z != -1) UpdBamboo(y, z);\n}\nlong long getPath(long long x, long long y) {\n  long long z = pLCA(x, y);\n  long long ans = 0;\n  if (z != -1) ans = max(ans, GetBamboo(x, z));\n  z = pLCA(y, x);\n  if (z != -1) ans = max(ans, GetBamboo(y, z));\n  return ans;\n}\nbool READY[N];\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> q;\n  ds.init(n);\n  tout[0] = 1ll;\n  for (int i = 1; i <= q; i++) cin >> a[i] >> b[i] >> c[i];\n  for (int i = 1; i <= q; i++) {\n    if (ds.fnd(a[i]) != ds.fnd(b[i]))\n      ds.unt(a[i], b[i]), g[a[i]].push_back(make_pair(b[i], c[i])),\n          g[b[i]].push_back(make_pair(a[i], c[i])), READY[i] = 1;\n  }\n  for (int j = 1; j <= n; j++)\n    if (tin[j] == 0) dfs(j, 0), hldfs(j, 0, j);\n  for (int i = 1; i <= q; i++) {\n    if (READY[i])\n      cout << \"YES\\n\";\n    else {\n      long long z = pxr(a[i], b[i]);\n      if (z == c[i] || getPath(a[i], b[i])) {\n        cout << \"NO\\n\";\n        continue;\n      }\n      UpdPath(a[i], b[i]);\n      cout << \"YES\\n\";\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 300010;\nint Fir[maxn], Nxt[maxn << 1], Too[maxn << 1], w[maxn << 1], tot;\nint n, q, root[maxn], fa[maxn], siz[maxn], dfn[maxn], son[maxn], ts, mp[maxn],\n    top[maxn], vv[maxn], dep[maxn];\nint adu[maxn << 1], adv[maxn << 1], adw[maxn << 1], in_tr[maxn << 1];\ninline void Init() {\n  for (int i = 1; i <= n; ++i) root[i] = i;\n}\ninline int find(int x) { return root[x] == x ? x : root[x] = find(root[x]); }\ninline void merge(int x, int y) {\n  x = find(x);\n  y = find(y);\n  root[x] = y;\n}\ninline bool connect(int x, int y) { return find(x) == find(y); }\ninline void add(int a, int b, int c) {\n  Too[++tot] = b;\n  w[tot] = c;\n  Nxt[tot] = Fir[a];\n  Fir[a] = tot;\n}\ninline void dfs1(int u, int f) {\n  fa[u] = f;\n  siz[u] = 1;\n  dep[u] = dep[f] + 1;\n  for (int i = Fir[u]; i; i = Nxt[i]) {\n    int v = Too[i];\n    if (v == f) continue;\n    dfs1(v, u);\n    siz[u] += siz[v];\n    vv[v] = w[i];\n    if (siz[v] > siz[son[u]]) son[u] = v;\n  }\n}\ninline void dfs2(int u, int tp) {\n  top[u] = tp;\n  dfn[u] = ++ts;\n  mp[ts] = u;\n  if (son[u]) dfs2(son[u], tp);\n  for (int i = Fir[u]; i; i = Nxt[i]) {\n    int v = Too[i];\n    if (v != fa[u] && v != son[u]) dfs2(v, v);\n  }\n}\nstruct SegmentTree {\n  int l, r, v, s, tag;\n} tr[maxn << 2];\ninline void pushup(int u) {\n  tr[u].v = tr[(u << 1)].v ^ tr[(u << 1 | 1)].v;\n  tr[u].s = tr[(u << 1)].s + tr[(u << 1 | 1)].s;\n}\ninline void change(int u) {\n  tr[u].s = tr[u].r - tr[u].l + 1;\n  tr[u].tag = 1;\n}\ninline void pushdown(int u) {\n  if (tr[u].tag) {\n    change((u << 1));\n    change((u << 1 | 1));\n    tr[u].tag = 0;\n  }\n}\ninline void build(int u, int l, int r) {\n  tr[u].l = l;\n  tr[u].r = r;\n  if (l == r) {\n    tr[u].v = vv[mp[l]];\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build((u << 1), l, mid);\n  build((u << 1 | 1), mid + 1, r);\n  pushup(u);\n}\ninline void modify(int u, int l, int r) {\n  if (l <= tr[u].l && tr[u].r <= r) {\n    change(u);\n    return;\n  }\n  pushdown(u);\n  int mid = (tr[u].l + tr[u].r) >> 1;\n  if (l <= mid) modify((u << 1), l, r);\n  if (mid < r) modify((u << 1 | 1), l, r);\n  pushup(u);\n}\ninline int query(int u, int l, int r, int &cnt) {\n  if (l <= tr[u].l && tr[u].r <= r) {\n    cnt += tr[u].s;\n    return tr[u].v;\n  }\n  pushdown(u);\n  int mid = (tr[u].l + tr[u].r) >> 1, ans = 0;\n  if (l <= mid) ans = query((u << 1), l, r, cnt);\n  if (mid < r) ans ^= query((u << 1 | 1), l, r, cnt);\n  return ans;\n}\ninline void add(int x, int y) {\n  while (top[x] != top[y]) {\n    if (dep[top[x]] <= dep[top[y]]) swap(x, y);\n    modify(1, dfn[top[x]], dfn[x]);\n    x = fa[top[x]];\n  }\n  if (dep[x] < dep[y]) swap(x, y);\n  modify(1, dfn[son[y]], dfn[x]);\n}\ninline int ask(int x, int y, int w) {\n  int ans = 0, sum = 0;\n  while (top[x] != top[y]) {\n    if (dep[top[x]] <= dep[top[y]]) swap(x, y);\n    ans ^= query(1, dfn[top[x]], dfn[x], sum);\n    x = fa[top[x]];\n  }\n  if (dep[x] < dep[y]) swap(x, y);\n  ans ^= query(1, dfn[son[y]], dfn[x], sum);\n  if (sum) return 0;\n  return (ans ^ w) == 1;\n}\nint main() {\n  scanf(\"%d%d\", &n, &q);\n  Init();\n  for (int i = 1; i <= q; ++i) {\n    scanf(\"%d%d%d\", &adu[i], &adv[i], &adw[i]);\n    if (!connect(adu[i], adv[i])) {\n      add(adu[i], adv[i], adw[i]);\n      add(adv[i], adu[i], adw[i]);\n      in_tr[i] = 1;\n      merge(adu[i], adv[i]);\n    }\n  }\n  for (int i = 1; i <= n; ++i) find(root[i]);\n  for (int i = 1; i <= n; ++i)\n    if (root[i] == i) {\n      dfs1(i, i);\n      dfs2(i, i);\n    }\n  build(1, 1, n);\n  for (int i = 1; i <= q; ++i) {\n    if (in_tr[i])\n      puts(\"YES\");\n    else {\n      int x = adu[i], y = adv[i], w = adw[i];\n      int ans = ask(x, y, w);\n      puts(ans ? \"YES\" : \"NO\");\n      if (ans) add(x, y);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << ' ' << H;\n  debug_out(T...);\n}\nconst int N = 1e6 + 5;\nint n;\nnamespace LCT {\nint tag[N], v[N], siz[N], ch[N][2], fa[N], st[N], cov[N];\nvoid init(int n) {\n  for (int i = 1; i <= n; i++) cin >> v[i];\n}\ninline int get(int x) { return ch[fa[x]][1] == x; }\ninline int isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\nvoid pushup(int rt) {\n  cov[rt] = cov[ch[rt][0]] | cov[ch[rt][1]] | v[rt];\n  siz[rt] = siz[ch[rt][0]] + siz[ch[rt][1]] + 1;\n}\nvoid pushdown(int rt) {\n  if (tag[rt]) {\n    tag[ch[rt][0]] ^= 1, tag[ch[rt][1]] ^= 1;\n    swap(ch[rt][0], ch[rt][1]);\n    tag[rt] = 0;\n  }\n}\nvoid rotate(int x) {\n  int f = fa[x], ff = fa[f], w = get(x), ww = get(f);\n  if (!isroot(f)) ch[ff][ww] = x;\n  fa[ch[f][w] = ch[x][w ^ 1]] = f;\n  fa[ch[x][w ^ 1] = f] = x;\n  fa[x] = ff;\n  pushup(f), pushup(x);\n}\nvoid splay(int x) {\n  int top = 0, t = x;\n  st[++top] = x;\n  while (!isroot(t)) st[++top] = (t = fa[t]);\n  while (top) pushdown(st[top--]);\n  while (!isroot(x)) {\n    if (!isroot(fa[x])) {\n      if (get(x) == get(fa[x]))\n        rotate(fa[x]);\n      else\n        rotate(x);\n    }\n    rotate(x);\n  }\n  pushup(x);\n}\nvoid access(int x) {\n  for (int y = 0; x; y = x, x = fa[x]) {\n    splay(x), ch[x][1] = y, pushup(x);\n  }\n}\nvoid makeroot(int x) {\n  access(x);\n  splay(x);\n  tag[x] ^= 1;\n}\nvoid split(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(y);\n}\nint findroot(int x) {\n  access(x), splay(x);\n  while (ch[x][0]) x = ch[x][0], pushdown(x);\n  splay(x);\n  return x;\n}\nvoid link(int x, int y) {\n  makeroot(x);\n  if (findroot(y) != x) fa[x] = y;\n}\nvoid cut(int x, int y) {\n  makeroot(x);\n  if (findroot(y) != x) return;\n  if (ch[x][1] == y && !ch[y][0]) fa[y] = ch[x][1] = 0;\n}\nvoid dfs(int rt) {\n  if (rt > n) v[rt] = 1;\n  if (ch[rt][0]) dfs(ch[rt][0]);\n  if (ch[rt][1]) dfs(ch[rt][1]);\n  cov[rt] = cov[ch[rt][0]] | cov[ch[rt][1]] | v[rt];\n}\nvoid change(int x, int y) {\n  split(x, y);\n  dfs(y);\n}\nint query(int x, int y) {\n  split(x, y);\n  return cov[y];\n}\n};  // namespace LCT\nint f[N], s[N];\nint find(int x) {\n  if (x == f[x]) return x;\n  int t = f[x];\n  f[x] = find(f[x]);\n  s[x] ^= s[t];\n  return f[x];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  int q;\n  cin >> n >> q;\n  for (int i = 1; i <= n; i++) f[i] = i;\n  int tot = n;\n  for (int i = 1, u, v, x; i <= q; i++) {\n    cin >> u >> v >> x;\n    if (find(u) != find(v)) {\n      int fu = f[u], fv = f[v];\n      s[fu] = s[u] ^ s[v] ^ x;\n      f[fu] = fv;\n      tot++;\n      LCT::link(u, tot);\n      LCT::link(v, tot);\n      cout << \"YES\\n\";\n    } else {\n      if ((s[u] ^ s[v] ^ x) == 0 || LCT::query(u, v))\n        cout << \"NO\\n\";\n      else {\n        cout << \"YES\\n\";\n        LCT::change(u, v);\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > e[300005];\nint fa[300005], sz[300005], sn[300005], dp[300005], st[300005], ed[300005],\n    tp[300005], dis[300005], dft;\nvoid dfs1(int u, int fat) {\n  dp[u] = dp[fa[u] = fat] + 1, sz[u] = 1, sn[u] = 0;\n  for (auto [v, w] : e[u])\n    if (v ^ fat)\n      dis[v] = dis[u] ^ w, dfs1(v, u), sz[u] += sz[v],\n      sn[u] = (sz[sn[u]] > sz[v]) ? sn[u] : v;\n}\nvoid dfs2(int u, int top) {\n  tp[u] = top, st[u] = ++dft;\n  if (sn[u]) dfs2(sn[u], top);\n  for (auto [v, w] : e[u])\n    if (v != sn[u] && v != fa[u]) dfs2(v, v);\n  ed[u] = dft;\n}\nint tr[500005];\nint n, m, u[500005], v[500005], w[500005], an[300005];\nvoid add(int p) {\n  for (; p <= n; p += (p & -p)) tr[p]++;\n}\nint Q(int l, int r) {\n  if (l > r) return 0;\n  int res = 0;\n  for (; r; r -= (r & -r)) res += tr[r];\n  for (l--; l; l -= (l & -l)) res -= tr[l];\n  return res;\n}\nbool chk(int u, int v) {\n  for (; tp[u] ^ tp[v]; u = fa[tp[u]]) {\n    if (dp[tp[u]] < dp[tp[v]]) swap(u, v);\n    if (Q(st[tp[u]], st[u])) return 0;\n  }\n  if (dp[u] > dp[v]) swap(u, v);\n  if (Q(st[u] + 1, st[v])) return 0;\n  return 1;\n}\nint find(int x) { return an[x] == x ? x : an[x] = find(an[x]); }\nbool vis[500005];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) an[i] = i;\n  for (int i = 1, x, y; i <= m; i++) {\n    scanf(\"%d%d%d\", u + i, v + i, w + i);\n    if ((x = find(u[i])) != (y = find(v[i])))\n      an[x] = y, e[u[i]].emplace_back(v[i], w[i]),\n      e[v[i]].emplace_back(u[i], w[i]), vis[i] = 1;\n  }\n  for (int i = 1; i <= n; i++)\n    if (!st[i]) dfs1(i, 0), dfs2(i, i);\n  for (int i = 1; i <= m; i++) {\n    if (vis[i])\n      puts(\"YES\");\n    else if (w[i] ^ dis[u[i]] ^ dis[v[i]] == 0)\n      puts(\"NO\");\n    else {\n      if (chk(u[i], v[i])) {\n        puts(\"YES\");\n        for (int x = u[i], y = v[i]; x ^ y; add(st[x]), x = fa[x])\n          if (dp[x] < dp[y]) swap(x, y);\n      } else\n        puts(\"NO\");\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, Q, p[500010];\nvector<pair<int, int> > adj[500010];\nint twok[500010][20], depth[500010];\nbool dist[500010];\nint st[500010], en[500010];\nbool ans[500010];\nint co = 1;\nbool del[500010];\nstruct node {\n  int second, e, m, val = -1, lazy = -1;\n  node *l, *r;\n  node(int ss, int ee) {\n    second = ss;\n    e = ee;\n    m = (second + e) / 2;\n    if (second != e) {\n      l = new node(second, m);\n      r = new node(m + 1, e);\n    }\n  }\n  void prop() {\n    if (second == e || lazy == -1) return;\n    l->lazy = max(l->lazy, lazy);\n    l->val = max(l->val, lazy);\n    r->val = max(r->val, lazy);\n    r->lazy = max(r->lazy, lazy);\n    lazy = -1;\n  }\n  void upd(int a, int b, int c) {\n    prop();\n    if (a <= second && e <= b) {\n      val = max(val, c);\n      lazy = max(lazy, c);\n      return;\n    } else if (a > e || second > b)\n      return;\n    else {\n      l->upd(a, b, c);\n      r->upd(a, b, c);\n      val = max(l->val, r->val);\n    }\n  }\n  int qry(int p) {\n    prop();\n    if (second == e)\n      return val;\n    else if (p > m)\n      return r->qry(p);\n    else\n      return l->qry(p);\n  }\n} * root;\nint fl(int x) {\n  if (p[x] == x)\n    return x;\n  else\n    return p[x] = fl(p[x]);\n}\nvoid dfs(int x, int p) {\n  twok[x][0] = p;\n  st[x] = co++;\n  for (int i = 1; i <= int(19); ++i) {\n    if (twok[x][i - 1] == -1) break;\n    twok[x][i] = twok[twok[x][i - 1]][i - 1];\n  }\n  for (auto i : adj[x])\n    if (i.first != p) {\n      dist[i.first] = dist[x] ^ i.second;\n      depth[i.first] = depth[x] + 1;\n      dfs(i.first, x);\n    }\n  en[x] = co - 1;\n}\nint kpar(int x, int k) {\n  for (int i = 0; i <= int(19); ++i)\n    if (k & (1 << i)) x = twok[x][i];\n  return x;\n}\nint lca(int a, int b) {\n  if (depth[a] < depth[b]) swap(a, b);\n  a = kpar(a, depth[a] - depth[b]);\n  if (a == b) return a;\n  for (int i = 19; i >= int(0); --i)\n    if (twok[a][i] != twok[b][i]) {\n      a = twok[a][i];\n      b = twok[b][i];\n    }\n  return twok[a][0];\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0);\n  cin >> N >> Q;\n  iota(p + 1, p + N + 1, 1);\n  vector<pair<pair<int, int>, pair<int, int> > > v;\n  int a, b, c;\n  for (int i = 1; i <= int(Q); ++i) {\n    cin >> a >> b >> c;\n    if (fl(a) != fl(b)) {\n      p[fl(a)] = fl(b);\n      adj[a].push_back(pair<int, int>(b, c));\n      adj[b].push_back(pair<int, int>(a, c));\n      ans[i] = 1;\n    } else\n      v.push_back(pair<pair<int, int>, pair<int, int> >(pair<int, int>(a, b),\n                                                        pair<int, int>(c, i)));\n  }\n  memset(twok, -1, sizeof twok);\n  for (int i = 1; i <= int(N); ++i)\n    if (twok[i][0] == -1) dfs(i, -1);\n  root = new node(1, N);\n  for (auto i : v) {\n    int x = i.first.first, y = i.first.second;\n    bool d = dist[x] ^ dist[y];\n    if ((d ^ i.second.first) == 0) continue;\n    int z = lca(x, y);\n    if (root->qry(st[x]) > depth[z] || root->qry(st[y]) > depth[z]) continue;\n    ans[i.second.second] = 1;\n    while (x != z) {\n      assert(!del[x]);\n      del[x] = 1;\n      root->upd(st[x], en[x], depth[x]);\n      x = twok[x][0];\n    }\n    while (y != z) {\n      assert(!del[y]);\n      del[y] = 1;\n      root->upd(st[y], en[y], depth[y]);\n      y = twok[y][0];\n    }\n  }\n  for (int i = 1; i <= int(Q); ++i) {\n    cout << (ans[i] ? \"YES\" : \"NO\") << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n  int to, nxt;\n  bool wei;\n} e[600010];\nstruct segt {\n  int l, r, sum, tg;\n} tree[1200010];\nint cnt, h[500010], U[500010], V[500010], fa[300010], dep[300010], siz[300010],\n    hson[300010], dfn[300010], tp[300010];\nbool d[300010], w[500010], istree[500010];\ninline int read() {\n  char c = getchar();\n  int x = 0;\n  while (c < '0' || c > '9') c = getchar();\n  while (c >= '0' && c <= '9') {\n    x = (x << 3) + (x << 1) + c - '0';\n    c = getchar();\n  }\n  return x;\n}\ninline void adde(int x, int y, bool z) {\n  e[++cnt].to = y;\n  e[cnt].wei = z;\n  e[cnt].nxt = h[x];\n  h[x] = cnt;\n}\nint getfa(int x) {\n  if (x != fa[x]) return fa[x] = getfa(fa[x]);\n  return x;\n}\nvoid dfs1(int x, int f) {\n  fa[x] = f;\n  dep[x] = dep[f] + 1;\n  siz[x] = 1;\n  for (int i = h[x]; i; i = e[i].nxt)\n    if (e[i].to != f) {\n      d[e[i].to] = e[i].wei ^ d[x];\n      dfs1(e[i].to, x);\n      siz[x] += siz[e[i].to];\n      if (siz[e[i].to] > siz[hson[x]]) hson[x] = e[i].to;\n    }\n}\nvoid dfs2(int x, int t) {\n  dfn[x] = ++cnt;\n  tp[x] = t;\n  if (hson[x]) dfs2(hson[x], t);\n  for (int i = h[x]; i; i = e[i].nxt)\n    if (e[i].to != fa[x] && e[i].to != hson[x]) dfs2(e[i].to, e[i].to);\n}\ninline void push_down(int i) {\n  if (tree[i].tg) {\n    tree[i << 1].sum += tree[i].tg;\n    tree[i << 1].tg += tree[i].tg;\n    tree[i << 1 | 1].sum += tree[i].tg;\n    tree[i << 1 | 1].tg += tree[i].tg;\n    tree[i].tg = 0;\n  }\n}\nvoid build(int le, int ri, int i) {\n  tree[i].l = le;\n  tree[i].r = ri;\n  tree[i].sum = tree[i].tg = 0;\n  if (le == ri) return;\n  int mid = (le + ri) >> 1;\n  build(le, mid, i << 1);\n  build(mid + 1, ri, i << 1 | 1);\n}\nvoid change(int le, int ri, int i) {\n  if (le <= tree[i].l && tree[i].r <= ri) {\n    tree[i].sum++;\n    tree[i].tg++;\n    return;\n  }\n  push_down(i);\n  if (le <= tree[i << 1].r) change(le, ri, i << 1);\n  if (ri > tree[i << 1].r) change(le, ri, i << 1 | 1);\n  tree[i].sum = tree[i << 1].sum + tree[i << 1 | 1].sum;\n}\nint ask(int le, int ri, int i) {\n  if (le <= tree[i].l && tree[i].r <= ri) return tree[i].sum;\n  push_down(i);\n  int val = 0;\n  if (le <= tree[i << 1].r) val = ask(le, ri, i << 1);\n  if (ri > tree[i << 1].r) val += ask(le, ri, i << 1 | 1);\n  return val;\n}\ninline void changepath(int u, int v) {\n  while (tp[u] != tp[v])\n    if (dep[tp[u]] > dep[tp[v]]) {\n      change(dfn[tp[u]], dfn[u], 1);\n      u = fa[tp[u]];\n    } else {\n      change(dfn[tp[v]], dfn[v], 1);\n      v = fa[tp[v]];\n    }\n  if (u == v) return;\n  if (dep[u] < dep[v])\n    change(dfn[u] + 1, dfn[v], 1);\n  else\n    change(dfn[v] + 1, dfn[u], 1);\n}\ninline int askpath(int u, int v) {\n  int val = 0;\n  while (tp[u] != tp[v])\n    if (dep[tp[u]] > dep[tp[v]]) {\n      val += ask(dfn[tp[u]], dfn[u], 1);\n      u = fa[tp[u]];\n    } else {\n      val += ask(dfn[tp[v]], dfn[v], 1);\n      v = fa[tp[v]];\n    }\n  if (u == v) return val;\n  if (dep[u] < dep[v]) return val + ask(dfn[u] + 1, dfn[v], 1);\n  return val + ask(dfn[v] + 1, dfn[u], 1);\n}\nint main() {\n  int n = read(), m = read(), i;\n  for (i = 1; i <= n; i++) fa[i] = i;\n  for (i = 1; i <= m; i++) {\n    U[i] = read();\n    V[i] = read();\n    w[i] = read();\n    int fx = getfa(U[i]), fy = getfa(V[i]);\n    if (fx != fy) {\n      fa[fx] = fy;\n      istree[i] = true;\n      adde(U[i], V[i], w[i]);\n      adde(V[i], U[i], w[i]);\n    }\n  }\n  cnt = 0;\n  for (i = 1; i <= n; i++)\n    if (!dep[i]) {\n      dfs1(i, 0);\n      dfs2(i, i);\n    }\n  build(1, n, 1);\n  for (i = 1; i <= m; i++)\n    if (istree[i])\n      puts(\"YES\");\n    else if ((d[U[i]] ^ d[V[i]] ^ w[i]) && !askpath(U[i], V[i])) {\n      puts(\"YES\");\n      changepath(U[i], V[i]);\n    } else\n      puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass DSU {\n public:\n  vector<int> _parent;\n  int parent(int v) {\n    return _parent[v] < 0 ? v : (_parent[v] = parent(_parent[v]));\n  }\n  void merge(int v, int u) {\n    if ((v = parent(v)) == (u = parent(u))) return;\n    if (_parent[v] < _parent[u]) swap(v, u);\n    _parent[u] += _parent[v];\n    _parent[v] = u;\n  }\n  DSU(int size) { _parent.resize(size, -1); }\n};\nclass Node {\n  int left;\n  int right;\n  int sum;\n  Node* left_child;\n  Node* right_child;\n\n public:\n  Node(int l, int r) {\n    sum = 0;\n    right = r;\n    left = l;\n    if (l == r) {\n      return;\n    }\n    int mid = (r + l) / 2;\n    left_child = new Node(l, mid);\n    right_child = new Node(mid + 1, r);\n    sum += right_child->sum + left_child->sum;\n  }\n  void add(int l, int r, int x) {\n    if (right < l || left > r) {\n      return;\n    } else if (right <= r && left >= l) {\n      sum += x;\n    } else {\n      right_child->add(l, r, x);\n      left_child->add(l, r, x);\n      sum = left_child->sum + right_child->sum;\n    }\n  }\n  int query(int l, int r) {\n    if (right < l || left > r) {\n      return 0;\n    } else if (right <= r && left >= l) {\n      return sum;\n    } else {\n      return right_child->query(l, r) + left_child->query(l, r);\n    }\n  }\n};\nstruct edge {\n  int u;\n  int v;\n  int w;\n  int id;\n  edge(int u, int v, int w, int id) : u(u), v(v), w(w), id(id) {}\n};\nconst int N = 3e5 + 10, Q = 5e5 + 10;\nvector<edge> cycle_edges;\nint n, q, f[N][20], first[N], last[N], root[N], Xor[N], depth[N], tim = 1;\nvector<pair<int, int>> adj[N];\nbool visited[N], ans[Q];\nvoid dfs(int v, int p, int r) {\n  visited[v] = true;\n  root[v] = r;\n  first[v] = tim++;\n  f[v][0] = p;\n  for (int i = 1; i < 20; i++) {\n    f[v][i] = f[f[v][i - 1]][i - 1];\n  }\n  for (auto x : adj[v]) {\n    int u = x.first;\n    int w = x.second;\n    if (u != p) {\n      depth[u] = depth[v] + 1;\n      Xor[u] = Xor[v] ^ w;\n      dfs(u, v, r);\n    }\n  }\n  last[v] = tim++;\n}\nint lca(int a, int b) {\n  if (depth[a] < depth[b]) swap(a, b);\n  int k = depth[a] - depth[b];\n  for (int i = 0; i < 20; i++) {\n    if (k & (1 << i)) {\n      a = f[a][i];\n    }\n  }\n  if (a == b) return a;\n  for (int i = 19; i >= 0; i--) {\n    if (f[a][i] != f[b][i]) {\n      a = f[a][i];\n      b = f[b][i];\n    }\n  }\n  return f[a][0];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> q;\n  DSU dsu(n);\n  for (int i = 0; i < q; i++) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    u--;\n    v--;\n    if (dsu.parent(u) == dsu.parent(v)) {\n      cycle_edges.push_back(edge(u, v, w, i));\n      continue;\n    }\n    ans[i] = true;\n    adj[u].push_back({v, w});\n    adj[v].push_back({u, w});\n    dsu.merge(u, v);\n  }\n  for (int i = 0; i < n; i++) {\n    if (!visited[i]) {\n      dfs(i, i, i);\n    }\n  }\n  Node sum(0, tim);\n  for (int i = 0; i < cycle_edges.size(); i++) {\n    int u, v, w, id;\n    u = cycle_edges[i].u;\n    v = cycle_edges[i].v;\n    w = cycle_edges[i].w;\n    id = cycle_edges[i].id;\n    bool flag = false;\n    if ((Xor[u] ^ Xor[v] ^ w) == 1) {\n      int a = lca(u, v);\n      int s1 = sum.query(0, first[v]);\n      int s2 = sum.query(0, first[u]);\n      int s3 = sum.query(0, first[a]);\n      if (s1 + s2 - 2 * s3 == 0) {\n        flag = true;\n        while (u != a) {\n          sum.add(first[u], first[u], 1);\n          sum.add(last[u], last[u], -1);\n          u = f[u][0];\n        }\n        while (v != a) {\n          sum.add(first[v], first[v], 1);\n          sum.add(last[v], last[v], -1);\n          v = f[v][0];\n        }\n      }\n    }\n    if (flag) {\n      ans[id] = true;\n    }\n  }\n  for (int i = 0; i < q; i++) {\n    if (ans[i])\n      cout << \"YES\\n\";\n    else\n      cout << \"NO\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 3e5, MAXQ = 5e5, MAXLG = 18;\nint n, q, qu[MAXQ + 5], qv[MAXQ + 5], qw[MAXQ + 5];\nbool ans[MAXQ + 5], sum[MAXN + 5];\nint ecnt, head[MAXN + 5], dep[MAXN + 5], fa[MAXN + 5][MAXLG + 5];\nint dfc, dfn[MAXN + 5], siz[MAXN + 5];\nstruct Edge {\n  int to, val, nxt;\n} graph[MAXN * 2 + 5];\ninline void link(const int u, const int v, const int w) {\n  graph[++ecnt] = {v, w, head[u]}, head[u] = ecnt;\n  graph[++ecnt] = {u, w, head[v]}, head[v] = ecnt;\n}\nstruct DSU {\n  int fa[MAXN + 5], siz[MAXN + 5];\n  inline void init() {\n    for (int i = 1, repi = n; i <= repi; ++i) siz[fa[i] = i] = 1;\n  }\n  inline int find(const int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\n  inline bool unite(int x, int y) {\n    if ((x = find(x)) == (y = find(y))) return false;\n    if (siz[x] < siz[y]) x ^= y ^= x ^= y;\n    return siz[fa[y] = x] += siz[y], true;\n  }\n} dsu;\nstruct BinaryIndexTree {\n  int val[MAXN + 5];\n  inline void upd(int x, const int k) {\n    for (; x <= n; x += x & -x) val[x] += k;\n  }\n  inline int sum(int x) {\n    int ret = 0;\n    for (; x; x -= x & -x) ret += val[x];\n    return ret;\n  }\n} bit;\ninline void init(const int u) {\n  dep[u] = dep[fa[u][0]] + 1, dfn[u] = ++dfc, siz[u] = 1;\n  for (int j = 1; fa[u][j - 1]; fa[u][j] = fa[fa[u][j - 1]][j - 1], ++j)\n    ;\n  for (int i = head[u], v; i; i = graph[i].nxt) {\n    if ((v = graph[i].to) != fa[u][0]) {\n      fa[v][0] = u, sum[v] = sum[u] ^ graph[i].val;\n      init(v), siz[u] += siz[v];\n    }\n  }\n}\ninline int lca(int u, int v) {\n  if (dep[u] < dep[v]) u ^= v ^= u ^= v;\n  for (int i = MAXLG, peri = 0; i >= peri; --i)\n    if (dep[fa[u][i]] >= dep[v]) u = fa[u][i];\n  if (u == v) return u;\n  for (int i = MAXLG, peri = 0; i >= peri; --i)\n    if (fa[u][i] != fa[v][i]) {\n      u = fa[u][i], v = fa[v][i];\n    }\n  return fa[u][0];\n}\nint main() {\n  scanf(\"%d %d\", &n, &q), dsu.init();\n  for (int i = 1, repi = q; i <= repi; ++i) {\n    scanf(\"%d %d %d\", &qu[i], &qv[i], &qw[i]);\n    if (dsu.unite(qu[i], qv[i])) {\n      ans[i] = true, link(qu[i], qv[i], qw[i]);\n    }\n  }\n  for (int i = 1, repi = n; i <= repi; ++i)\n    if (!fa[i][0]) init(i);\n  for (int i = 1, repi = q; i <= repi; ++i)\n    if (!ans[i]) {\n      int u = qu[i], v = qv[i], w = lca(u, v);\n      if ((sum[u] ^ sum[v]) == qw[i] ||\n          bit.sum(dfn[u]) + bit.sum(dfn[v]) - 2 * bit.sum(dfn[w]))\n        continue;\n      ans[i] = true;\n      while (u != v) {\n        if (dep[u] < dep[v]) u ^= v ^= u ^= v;\n        bit.upd(dfn[u], 1), bit.upd(dfn[u] + siz[u], -1), u = fa[u][0];\n      }\n    }\n  for (int i = 1, repi = q; i <= repi; ++i) puts(ans[i] ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 300000;\nconst int M = 500000;\nconst int D = 20;\nint n, m, dsu[N], a[M], b[M], w[M], parent[N], depth[N], sum[N], jump[N][D],\n    dfs_count, pos[N], size[N];\nbool on_tree[M];\nstd::vector<std::pair<int, int>> tree[N];\nint find(int u) {\n  if (dsu[u] != u) {\n    dsu[u] = find(dsu[u]);\n  }\n  return dsu[u];\n}\nvoid dfs(int p, int u) {\n  parent[u] = p;\n  jump[u][0] = p;\n  for (int i = 1; i < D; ++i) {\n    if (jump[u][i - 1] == -1) {\n      jump[u][i] = -1;\n    } else {\n      jump[u][i] = jump[jump[u][i - 1]][i - 1];\n    }\n  }\n  pos[u] = dfs_count++;\n  size[u] = 1;\n  for (auto &&[v, w] : tree[u]) {\n    if (v != p) {\n      depth[v] = depth[u] + 1;\n      sum[v] = sum[u] ^ w;\n      dfs(u, v);\n      size[u] += size[v];\n    }\n  }\n}\nint fenwick[N];\ntemplate <int delta>\nvoid add(int k) {\n  for (; k < n; k += ~k & k + 1) {\n    fenwick[k] += delta;\n  }\n}\nint ask(int k) {\n  int result = 0;\n  for (; k >= 0; k -= ~k & k + 1) {\n    result += fenwick[k];\n  }\n  return result;\n}\nvoid cover(int u) {\n  add<1>(pos[u]);\n  add<-1>(pos[u] + size[u]);\n}\nint getLCA(int u, int v) {\n  if (depth[u] > depth[v]) {\n    std::swap(u, v);\n  }\n  for (int i = D; i--;) {\n    if ((depth[v] - depth[u]) >> i & 1) {\n      v = jump[v][i];\n    }\n  }\n  if (u == v) {\n    return u;\n  }\n  for (int i = D; i--;) {\n    if (jump[u][i] != jump[v][i]) {\n      u = jump[u][i];\n      v = jump[v][i];\n    }\n  }\n  return parent[u];\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  std::iota(dsu, dsu + n, 0);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d%d%d\", a + i, b + i, w + i);\n    a[i]--;\n    b[i]--;\n    if (find(a[i]) != find(b[i])) {\n      on_tree[i] = true;\n      tree[a[i]].emplace_back(b[i], w[i]);\n      tree[b[i]].emplace_back(a[i], w[i]);\n      dsu[find(a[i])] = find(b[i]);\n    }\n  }\n  memset(depth, -1, sizeof(depth));\n  for (int r = 0; r < n; ++r) {\n    if (depth[r] == -1) {\n      depth[r] = sum[r] = 0;\n      dfs(-1, r);\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    if (on_tree[i]) {\n      puts(\"YES\");\n    } else {\n      int LCA = getLCA(a[i], b[i]);\n      int count = ask(pos[a[i]]) + ask(pos[b[i]]) - 2 * ask(pos[LCA]);\n      if (count > 0 || (sum[a[i]] ^ sum[b[i]] ^ w[i]) != 1) {\n        puts(\"NO\");\n      } else {\n        puts(\"YES\");\n        int u = a[i];\n        int v = b[i];\n        while (u != v) {\n          if (depth[u] < depth[v]) {\n            std::swap(u, v);\n          }\n          cover(u);\n          u = parent[u];\n        }\n      }\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 600005;\nconst int inf = 1 << 30;\nstruct BIT {\n  int c[maxn];\n  void update(int x, int val, int n) {\n    for (int i = x; i <= n; i += i & -i) {\n      c[i] += val;\n    }\n  }\n  int ask(int x) {\n    int ans = 0;\n    for (int i = x; i; i -= i & -i) {\n      ans += c[i];\n    }\n    return ans;\n  }\n} T;\nstruct Edge {\n  int to, next, val;\n  Edge(int to = 0, int next = 0, int val = 0) : to(to), next(next), val(val) {}\n} a[maxn * 2];\nstruct Question {\n  int x, y, val;\n} e[maxn];\nint n, m;\nint cnt;\nint tot;\nint top;\nint h[maxn];\nint fa[maxn];\nint lg[maxn];\nint ans[maxn];\nint pre[maxn];\nint fir[maxn];\nint lst[maxn];\nint depth[maxn];\nint st[20][maxn * 2];\nint xor_val[maxn * 2];\nbool vis[maxn];\nvoid add(int x, int y, int val) {\n  a[++cnt] = Edge(y, h[x], val);\n  h[x] = cnt;\n}\nint f(int x) { return fa[x] == x ? x : fa[x] = f(fa[x]); }\nvoid dfs(int x) {\n  vis[x] = 1;\n  st[0][++top] = x;\n  pre[x] = top;\n  fir[x] = ++tot;\n  for (int i = h[x]; i; i = a[i].next) {\n    if (vis[a[i].to]) {\n      continue;\n    }\n    xor_val[a[i].to] = xor_val[x] ^ a[i].val;\n    depth[a[i].to] = depth[x] + 1;\n    fa[a[i].to] = x;\n    dfs(a[i].to);\n    st[0][++top] = x;\n  }\n  lst[x] = tot;\n}\nint getmin(int x, int y) { return depth[x] < depth[y] ? x : y; }\nint lca(int x, int y) {\n  x = pre[x], y = pre[y];\n  if (x > y) {\n    swap(x, y);\n  }\n  int k = lg[y - x + 1];\n  return getmin(st[k][x], st[k][y - (1 << k) + 1]);\n}\nint xor_dist(int x, int y) { return xor_val[x] ^ xor_val[y]; }\nint check(int x, int y, int p) {\n  return T.ask(fir[x]) + T.ask(fir[y]) - 2 * T.ask(fir[p]);\n}\nvoid update(int x, int p) {\n  if (x == p) {\n    return;\n  }\n  while (x != p) {\n    T.update(fir[x], 1, n);\n    T.update(lst[x] + 1, -1, n);\n    x = fa[x];\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    fa[i] = i;\n  }\n  for (int i = 1; i <= m; i++) {\n    cin >> e[i].x >> e[i].y >> e[i].val;\n    int x = f(e[i].x), y = f(e[i].y);\n    if (x != y) {\n      add(e[i].x, e[i].y, e[i].val);\n      add(e[i].y, e[i].x, e[i].val);\n      fa[x] = y;\n      ans[i] = 1;\n    }\n  }\n  memset(fa, 0, sizeof(fa));\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      dfs(i);\n    }\n  }\n  for (int i = 2; i <= top; i++) {\n    lg[i] = lg[i >> 1] + 1;\n  }\n  for (int i = 1; (1 << i) <= top; i++) {\n    for (int j = 1; j + (1 << i) - 1 <= top; j++) {\n      st[i][j] = getmin(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    if (ans[i]) {\n      continue;\n    }\n    int x = e[i].x, y = e[i].y, val = e[i].val;\n    if ((xor_dist(x, y) ^ val) == 0) {\n      continue;\n    }\n    int p = lca(x, y);\n    if (check(x, y, p)) {\n      continue;\n    }\n    update(x, p);\n    update(y, p);\n    ans[i] = 1;\n  }\n  for (int i = 1; i <= m; i++) {\n    cout << (ans[i] ? \"YES\" : \"NO\") << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long const mod = 1e9 + 7, MAXN = 3e5 + 5, oo = 3e18, N = 5e5 + 5;\nlong long tc, n, m;\nlong long dsu_par[MAXN], dsu_sz[MAXN];\nlong long find(long long u) {\n  if (dsu_par[u] == u) return u;\n  return dsu_par[u] = find(dsu_par[u]);\n}\nbool join(long long u, long long v) {\n  u = find(u);\n  v = find(v);\n  if (u == v) return false;\n  if (dsu_sz[u] < dsu_sz[v]) swap(u, v);\n  dsu_par[v] = u;\n  dsu_sz[u] += dsu_sz[v];\n  return true;\n}\nvoid dsu() {\n  for (int i = 1; i <= n; i++) {\n    dsu_sz[i] = 1;\n    dsu_par[i] = i;\n  }\n}\nclass fenwick {\n private:\n  vector<long long> ft;\n\n public:\n  fenwick(long long n) { ft.assign(n + 5, 0); }\n  long long ls(long long x) { return x & (-x); }\n  long long rsq(long long pos) {\n    long long res = 0;\n    for (; pos; pos -= ls(pos)) {\n      res += ft[pos];\n    }\n    return res;\n  }\n  void inc(long long pos, long long val) {\n    for (; pos < ft.size(); pos += ls(pos)) {\n      ft[pos] += val;\n    }\n  }\n};\nfenwick ft(MAXN);\nvector<pair<long long, long long> > g[MAXN];\nlong long prefix_xor[MAXN];\nlong long up[MAXN][21], dep[MAXN], tin[MAXN], tout[MAXN];\nbool ans[N];\nlong long now = 1;\nlong long get_lca(long long u, long long v) {\n  if (dep[u] < dep[v]) swap(u, v);\n  long long tmp = dep[u] - dep[v];\n  for (int i = 20; i >= 0; i--) {\n    if (tmp & (1 << i)) {\n      u = up[u][i];\n    }\n  }\n  if (u == v) return v;\n  for (int i = 20; i >= 0; i--) {\n    if (up[u][i] != up[v][i]) {\n      u = up[u][i];\n      v = up[v][i];\n    }\n  }\n  return up[u][0];\n}\nvoid dfs(long long u) {\n  tin[u] = now++;\n  for (int i = 1; i <= 20; i++) {\n    up[u][i] = up[up[u][i - 1]][i - 1];\n  }\n  for (pair<long long, long long> cur : g[u]) {\n    long long v = cur.first, w = cur.second;\n    if (v == up[u][0]) continue;\n    dep[v] = dep[u] + 1;\n    prefix_xor[v] = prefix_xor[u] ^ w;\n    up[v][0] = u;\n    dfs(v);\n  }\n  tout[u] = now;\n}\nvoid mark(long long u) {\n  ft.inc(tin[u], 1);\n  ft.inc(tout[u], -1);\n}\nvoid mark_path(long long u, long long v) {\n  while (u != v) {\n    mark(u);\n    u = up[u][0];\n  }\n}\nstruct uwu {\n  long long u, v, w, id;\n};\nvector<uwu> edges;\nvoid aurelion_sol() {\n  cin >> n >> m;\n  dsu();\n  for (int i = 1; i <= m; i++) {\n    uwu cur;\n    cur.id = i;\n    cin >> cur.u >> cur.v >> cur.w;\n    edges.push_back(cur);\n  }\n  for (auto cur : edges) {\n    if (join(cur.u, cur.v)) {\n      ans[cur.id] = true;\n      g[cur.u].push_back(make_pair(cur.v, cur.w));\n      g[cur.v].push_back(make_pair(cur.u, cur.w));\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!tin[i]) {\n      dfs(i);\n    }\n  }\n  for (auto cur : edges) {\n    if (ans[cur.id]) continue;\n    long long u = cur.u, v = cur.v, w = cur.w, id = cur.id;\n    long long tmp = prefix_xor[u] ^ prefix_xor[v] ^ w;\n    if (tmp != 1) continue;\n    long long lca = get_lca(u, v);\n    tmp = ft.rsq(tin[u]) + ft.rsq(tin[v]) - 2 * ft.rsq(tin[lca]);\n    if (tmp) continue;\n    ans[id] = true;\n    mark_path(u, lca);\n    mark_path(v, lca);\n  }\n  for (int i = 1; i <= m; i++) {\n    if (ans[i]) {\n      cout << \"YES\" << '\\n';\n    } else {\n      cout << \"NO\" << '\\n';\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  tc = 1;\n  while (tc--) aurelion_sol();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 5;\nstruct three {\n  int u, v, w;\n};\nstruct DSU {\n  vector<int> par;\n  void kc(int n) { par.assign(n + 5, -1); }\n  int root(int u) { return (par[u] < 0 ? u : par[u] = root(par[u])); }\n  bool dsu(int u, int v) {\n    if ((u = root(u)) == (v = root(v))) return 0;\n    if (par[u] > par[v]) swap(u, v);\n    par[u] += par[v];\n    par[v] = u;\n    return 1;\n  }\n} g;\nstruct fenwick {\n  vector<int> fw;\n  int n;\n  void kc(int _n) {\n    n = _n;\n    fw.assign(n + 5, 0);\n  }\n  void upd(int i, int val) {\n    for (; i <= n; i += i & -i) fw[i] += val;\n  }\n  void upd(int l, int r, int val) {\n    upd(l, val);\n    upd(r + 1, -val);\n  }\n  int get(int i) {\n    int ans = 0;\n    for (; i; i -= i & -i) ans += fw[i];\n    return ans;\n  }\n} fw;\nint n, q;\nint par[N];\nvector<three> edges;\nvector<pair<int, int> > dsk[N];\nbool used[N * 2], vis[N], useless[N];\nint anc[N][20], h[N];\nbool weight[N];\nint tin[N], tout[N], timer;\nvoid dfs(int u, int pre) {\n  tin[u] = ++timer;\n  vis[u] = 1;\n  for (pair<int, int> node : dsk[u])\n    if (!vis[node.first]) {\n      int v = node.first, c = node.second;\n      anc[v][0] = u;\n      weight[v] = (weight[u] ^ c);\n      h[v] = h[u] + 1;\n      dfs(v, u);\n    }\n  tout[u] = timer;\n}\nint LCA(int u, int v) {\n  if (h[u] < h[v]) swap(u, v);\n  int k = log2(h[u]);\n  for (int i = k; i >= 0; --i)\n    if (h[u] - (1 << i) >= h[v]) u = anc[u][i];\n  if (u == v) return u;\n  for (int i = k; i >= 0; --i)\n    if (anc[u][i] && anc[u][i] != anc[v][i]) u = anc[u][i], v = anc[v][i];\n  return anc[u][0];\n}\nvoid update(int u, int v) {\n  while (u != v) {\n    fw.upd(tin[u], tout[u], 1);\n    u = anc[u][0];\n  }\n}\nvoid gogo() {\n  cin >> n >> q;\n  DSU g;\n  g.kc(n);\n  for (int i = 1; i <= q; ++i) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    edges.push_back({u, v, w});\n    if (g.dsu(u, v)) {\n      used[i - 1] = 1;\n      dsk[u].push_back(make_pair(v, w));\n      dsk[v].push_back(make_pair(u, w));\n    }\n  }\n  for (int i = 1; i <= n; ++i)\n    if (!vis[i]) dfs(i, i);\n  for (int j = 1; j <= log2(n); ++j)\n    for (int i = 1; i <= n; ++i) anc[i][j] = anc[anc[i][j - 1]][j - 1];\n  fw.kc(n);\n  for (int i = 0; i < q; ++i) {\n    int u = edges[i].u, v = edges[i].v, w = edges[i].w;\n    if (used[i]) {\n      cout << \"YES\\n\";\n      continue;\n    }\n    int lca = LCA(u, v);\n    int val = fw.get(tin[u]) + fw.get(tin[v]) - 2 * fw.get(tin[lca]);\n    if (val || (weight[u] ^ weight[v] ^ w) == 0) {\n      cout << \"NO\\n\";\n      continue;\n    }\n    cout << \"YES\\n\";\n    update(u, lca);\n    update(v, lca);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  if (fopen(\"sol\"\n            \".inp\",\n            \"r\")) {\n    freopen(\n        \"sol\"\n        \".inp\",\n        \"r\", stdin);\n    freopen(\n        \"sol\"\n        \".out\",\n        \"w\", stdout);\n  }\n  gogo();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int c = (1 << 20), k = c / 2, lg = 20;\nint n, m, hv[c], aa[c], bb[c], xo[c];\nint kezd[c], veg[c], maxi[c];\nint cnt, be[c], ki[c], fel[c], ert[c], szint[c], fel2[c][lg];\nvector<pair<int, int> > sz[c];\nbool v[c], jo[c];\nint holvan(int a) { return (hv[a] ? hv[a] = holvan(hv[a]) : a); }\nbool unio(int a, int b) {\n  a = holvan(a), b = holvan(b);\n  if (a != b) {\n    hv[b] = a;\n    return true;\n  }\n  return false;\n}\nvoid dfs(int a) {\n  v[a] = true;\n  be[a] = ++cnt;\n  fel2[a][0] = fel[a];\n  for (int i = 1; i < lg; i++) {\n    fel2[a][i] = fel2[fel2[a][i - 1]][i - 1];\n  }\n  for (auto p : sz[a]) {\n    int x = p.first, y = p.second;\n    if (!v[x]) {\n      szint[x] = szint[a] + 1;\n      fel[x] = a;\n      ert[x] = (ert[a] ^ y);\n      dfs(x);\n    }\n  }\n  ki[a] = cnt;\n}\nint lca(int a, int b) {\n  if (szint[a] < szint[b]) {\n    swap(a, b);\n  }\n  for (int i = lg - 1; i >= 0; i--) {\n    if (szint[fel2[a][i]] >= szint[b]) {\n      a = fel2[a][i];\n    }\n  }\n  if (a == b) {\n    return a;\n  }\n  for (int i = lg - 1; i >= 0; i--) {\n    if (fel2[a][i] != fel2[b][i]) {\n      a = fel2[a][i], b = fel2[b][i];\n    }\n  }\n  return fel[a];\n}\nint calc(int a, int l, int r) {\n  if (kezd[a] > r || veg[a] < l) {\n    return 0;\n  }\n  if (l <= kezd[a] && veg[a] <= r) {\n    return 2;\n  }\n  return 1;\n}\nvoid add(int a, int l, int r, int ert) {\n  if (a == 1) {\n  }\n  int s = calc(a, l, r);\n  if (s == 0) {\n    return;\n  }\n  if (s == 2) {\n    maxi[a] = max(maxi[a], ert);\n  } else {\n    add(2 * a, l, r, ert), add(2 * a + 1, l, r, ert);\n  }\n}\nint ask(int a, int b) {\n  int s = calc(a, b, b);\n  if (s == 0) {\n    return 0;\n  }\n  if (s == 2) {\n    return maxi[a];\n  }\n  return max({maxi[a], ask(2 * a, b), ask(2 * a + 1, b)});\n}\nvoid init(int x) {\n  int po = 1;\n  while (po < x) {\n    po *= 2;\n  }\n  for (int i = po; i < 2 * po; i++) {\n    kezd[i] = i - po + 1, veg[i] = kezd[i];\n  }\n  for (int i = po - 1; i >= 1; i--) {\n    kezd[i] = kezd[2 * i], veg[i] = veg[2 * i + 1];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= m; i++) {\n    cin >> aa[i] >> bb[i] >> xo[i];\n    int a = aa[i], b = bb[i], c = xo[i];\n    if (unio(a, b)) {\n      jo[i] = 1;\n      sz[a].push_back({b, c});\n      sz[b].push_back({a, c});\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!v[i]) {\n      szint[i] = 1;\n      dfs(i);\n    }\n  }\n  init(n);\n  for (int i = 1; i <= m; i++) {\n    int a = aa[i], b = bb[i], c = xo[i];\n    if (jo[i] || (ert[a] ^ ert[b] ^ c) != 1) {\n      continue;\n    }\n    int x = lca(a, b);\n    if (ask(1, be[a]) <= be[x] && ask(1, be[b]) <= be[x]) {\n      jo[i] = 1;\n      while (a != x) {\n        add(1, be[a], ki[a], be[a]);\n        a = fel[a];\n      }\n      while (b != x) {\n        add(1, be[b], ki[b], be[b]);\n        b = fel[b];\n      }\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    cout << (jo[i] ? \"YES\" : \"NO\") << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 3e5 + 5;\nconst int Q = 5e5 + 5;\nint n, q;\nstruct edge {\n  int u, v, w;\n} e[Q];\nbool ans[Q];\nstd::vector<std::pair<int, int>> adj[N];\nint uset[N];\nint find(int x) { return x == uset[x] ? x : uset[x] = find(uset[x]); }\nint fa[N], dep[N];\nint siz[N], wson[N], wtop[N];\nint dfn[N], val[N], timer = 0;\nvoid dfs1(int x, int f) {\n  fa[x] = f, dep[x] = dep[f] + 1, siz[x] = 1;\n  for (auto e : adj[x])\n    if (e.first != f) {\n      int y = e.first, v = e.second;\n      val[y] = val[x] ^ v;\n      dfs1(y, x), siz[x] += siz[y];\n      if (siz[y] > siz[wson[x]]) wson[x] = y;\n    }\n}\nvoid dfs2(int x, int t) {\n  wtop[x] = t, dfn[x] = ++timer;\n  if (wson[x]) dfs2(wson[x], t);\n  for (auto e : adj[x])\n    if (e.first != fa[x] && e.first != wson[x]) dfs2(e.first, e.first);\n}\nint sum[N << 2], add[N << 2];\ninline void pushup(int x) { sum[x] = sum[x << 1] + sum[x << 1 | 1]; }\ninline void set_add(int x, int l, int r, int v) {\n  sum[x] += (r - l + 1) * v;\n  add[x] += v;\n}\ninline void pushdown(int x, int l, int r) {\n  if (add[x]) {\n    set_add(x << 1, l, ((l + r) >> 1), add[x]);\n    set_add(x << 1 | 1, ((l + r) >> 1) + 1, r, add[x]);\n    add[x] = 0;\n  }\n}\nvoid update(int x, int l, int r, int ql, int qr, int v) {\n  if (ql <= l && r <= qr) return set_add(x, l, r, v);\n  if (ql > r || l > qr) return;\n  pushdown(x, l, r);\n  update(x << 1, l, ((l + r) >> 1), ql, qr, v);\n  update(x << 1 | 1, ((l + r) >> 1) + 1, r, ql, qr, v);\n  pushup(x);\n}\nint get_sum(int x, int l, int r, int ql, int qr) {\n  if (ql <= l && r <= qr) return sum[x];\n  if (ql > r || l > qr) return 0;\n  pushdown(x, l, r);\n  return get_sum(x << 1, l, ((l + r) >> 1), ql, qr) +\n         get_sum(x << 1 | 1, ((l + r) >> 1) + 1, r, ql, qr);\n}\ninline int get_sum(int x, int y) {\n  int ans = 0;\n  while (wtop[x] != wtop[y]) {\n    if (dep[wtop[x]] < dep[wtop[y]]) std::swap(x, y);\n    ans += get_sum(1, 1, n, dfn[wtop[x]], dfn[x]);\n    x = fa[wtop[x]];\n  }\n  if (dep[x] > dep[y]) std::swap(x, y);\n  if (x != y) ans += get_sum(1, 1, n, dfn[x] + 1, dfn[y]);\n  return ans;\n}\ninline void update(int x, int y) {\n  while (wtop[x] != wtop[y]) {\n    if (dep[wtop[x]] < dep[wtop[y]]) std::swap(x, y);\n    update(1, 1, n, dfn[wtop[x]], dfn[x], 1);\n    x = fa[wtop[x]];\n  }\n  if (dep[x] > dep[y]) std::swap(x, y);\n  if (x != y) update(1, 1, n, dfn[x] + 1, dfn[y], 1);\n}\nsigned main() {\n  scanf(\"%d%d\", &n, &q);\n  for (int i = 1; i <= n; i++) uset[i] = i;\n  for (int i = 1; i <= q; i++) {\n    scanf(\"%d%d%d\", &e[i].u, &e[i].v, &e[i].w);\n    if (find(e[i].u) != find(e[i].v)) {\n      uset[find(e[i].u)] = find(e[i].v);\n      adj[e[i].u].emplace_back(e[i].v, e[i].w);\n      adj[e[i].v].emplace_back(e[i].u, e[i].w);\n      ans[i] = 1;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (dfn[i]) continue;\n    dfs1(i, 0);\n    dfs2(i, i);\n  }\n  for (int i = 1; i <= q; i++)\n    if (!ans[i]) {\n      int u = e[i].u, v = e[i].v;\n      if ((val[u] ^ val[v] ^ e[i].w) && !get_sum(u, v))\n        update(u, v), ans[i] = 1;\n    }\n  for (int i = 1; i <= q; i++)\n    if (ans[i])\n      puts(\"YES\");\n    else\n      puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300005;\nconst int M = 600005;\nconst int Q = 500005;\nint n, m;\nbool st[Q];\nint a[Q], b[Q], c[Q], lca[Q];\nint h[N], e[M], w[M], ne[M], idx;\nvector<int> s[N];\ninline void add(const int x, const int y, const int z) {\n  e[++idx] = y, w[idx] = z, ne[idx] = h[x], h[x] = idx;\n}\nstruct BIT {\n  int fw[N];\n  inline void add(int x, int c) {\n    for (; x <= n; x += x & -x) fw[x] += c;\n  }\n  inline int qry(int x) {\n    int res = 0;\n    for (; x; x &= x - 1) res += fw[x];\n    return res;\n  }\n} fw;\nstruct DSU {\n  int p[N];\n  void reset(int n) {\n    for (int i = 1; i <= n; ++i) p[i] = i;\n  }\n  int find(const int x) { return x != p[x] ? p[x] = find(p[x]) : x; }\n  inline bool check(const int x, const int y) { return find(x) == find(y); }\n  inline void merge(const int x, const int y) { p[find(x)] = find(y); }\n} z;\nint dfn[N], ts;\nint d[N], fa[N], sz[N];\nvoid dfs(int x) {\n  dfn[x] = ++ts;\n  for (int i : s[x]) {\n    int y = x ^ a[i] ^ b[i];\n    if (dfn[y]) lca[i] = z.find(y);\n  }\n  sz[x] = 1;\n  for (int i = h[x]; i; i = ne[i])\n    if (e[i] != fa[x]) {\n      fa[e[i]] = x;\n      d[e[i]] = d[x] ^ w[i];\n      dfs(e[i]);\n      sz[x] += sz[e[i]];\n      z.merge(e[i], x);\n    }\n}\nvoid update(int x, int t) {\n  while (x != t) {\n    fw.add(dfn[x], 1);\n    fw.add(dfn[x] + sz[x], -1);\n    x = fa[x];\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  z.reset(n);\n  for (int i = 0; i < m; ++i) {\n    int x, y, w;\n    scanf(\"%d%d%d\", &x, &y, &w);\n    a[i] = x, b[i] = y, c[i] = w;\n    if (!z.check(x, y)) {\n      st[i] = true;\n      z.merge(x, y);\n      add(x, y, w), add(y, x, w);\n    }\n    s[x].push_back(i);\n    s[y].push_back(i);\n  }\n  z.reset(n);\n  for (int x = 1; x <= n; ++x)\n    if (!dfn[x]) dfs(x);\n  for (int i = 0; i < m; ++i) {\n    if (st[i]) {\n      puts(\"YES\");\n    } else if ((d[a[i]] ^ d[b[i]]) != c[i] &&\n               fw.qry(dfn[a[i]]) == fw.qry(dfn[lca[i]]) &&\n               fw.qry(dfn[b[i]]) == fw.qry(dfn[lca[i]])) {\n      puts(\"YES\");\n      update(a[i], lca[i]);\n      update(b[i], lca[i]);\n    } else {\n      puts(\"NO\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 10;\nint n, m, tot;\nstruct LCT {\n  struct node {\n    int fa, ch[2];\n    bool v, f, z, xorz, ring, tag;\n  } t[N << 1];\n  int stk[N << 1], top;\n  inline void upd(int p) {\n    t[p].xorz = t[t[p].ch[0]].xorz ^ t[t[p].ch[1]].xorz ^ t[p].z;\n    t[p].ring = t[t[p].ch[0]].ring | t[t[p].ch[1]].ring | t[p].f;\n  }\n  inline bool get(int p) { return p == t[t[p].fa].ch[1]; }\n  inline void spd(int p) {\n    if (t[p].v) {\n      t[p].v = false, swap(t[p].ch[0], t[p].ch[1]);\n      if (t[p].ch[0]) t[t[p].ch[0]].v ^= 1;\n      if (t[p].ch[1]) t[t[p].ch[1]].v ^= 1;\n    }\n    if (t[p].tag) {\n      if (t[p].ch[0]) t[t[p].ch[0]].ring = true, t[t[p].ch[0]].tag = true;\n      if (t[p].ch[1]) t[t[p].ch[1]].ring = true, t[t[p].ch[1]].tag = true;\n      t[p].f = p > n, t[p].tag = false;\n    }\n  }\n  inline bool isrt(int p) {\n    return t[t[p].fa].ch[0] != p && t[t[p].fa].ch[1] != p;\n  }\n  inline void rot(int p) {\n    int x = t[p].fa, y = t[x].fa, u = get(p), v = get(x);\n    bool o = isrt(x);\n    t[t[p].ch[u ^ 1]].fa = x, t[x].ch[u] = t[p].ch[u ^ 1];\n    t[x].fa = p, t[p].ch[u ^ 1] = x, upd(x), upd(p);\n    if ((t[p].fa = y) && !o) t[y].ch[v] = p;\n  }\n  inline void pre(int p) {\n    while (!isrt(p)) stk[++top] = p, p = t[p].fa;\n    spd(p);\n    while (top) spd(stk[top--]);\n  }\n  inline void splay(int p) {\n    pre(p);\n    for (int x = t[p].fa; !isrt(p); rot(p), x = t[p].fa)\n      if (!isrt(x)) rot(get(p) == get(x) ? x : p);\n  }\n  inline void access(int p) {\n    for (int x = 0; p; p = t[x = p].fa) splay(p), t[p].ch[1] = x, upd(p);\n  }\n  inline void mkrt(int p) { access(p), splay(p), t[p].v ^= 1; }\n  inline void split(int x, int y) { mkrt(x), access(y), splay(y); }\n  inline int fdrt(int p) {\n    access(p), splay(p);\n    while (t[p].ch[0]) spd(p), p = t[p].ch[0];\n    return splay(p), p;\n  }\n  inline bool link(int x, int y) {\n    mkrt(x);\n    return fdrt(y) != x && (t[x].fa = y);\n  }\n} L;\nint main() {\n  scanf(\"%d%d\", &n, &m), tot = n;\n  for (int i = 1, x, y, z; i <= m; i++) {\n    scanf(\"%d%d%d\", &x, &y, &z);\n    if (L.fdrt(x) != L.fdrt(y)) {\n      puts(\"YES\"), ++tot, L.t[tot].z = z;\n      L.link(x, tot), L.link(tot, y);\n    } else {\n      L.split(x, y);\n      if (L.t[y].ring || (L.t[y].xorz ^ z) == 0) {\n        puts(\"NO\");\n        continue;\n      }\n      puts(\"YES\"), L.t[y].tag = true;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "// upsolve with kaiboy, coached by rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1555F extends PrintWriter {\n\tCF1555F() { super(System.out); }\n\tstatic class Scanner {\n\t\tScanner(InputStream in) { this.in = in; } InputStream in;\n\t\tbyte[] bb = new byte[1 << 15]; int i, n;\n\t\tbyte getc() {\n\t\t\tif (i == n) {\n\t\t\t\ti = n = 0;\n\t\t\t\ttry { n = in.read(bb); } catch (IOException e) {}\n\t\t\t}\n\t\t\treturn i < n ? bb[i++] : 0;\n\t\t}\n\t\tint nextInt() {\n\t\t\tbyte c = 0; while (c <= ' ') c = getc();\n\t\t\tint a = 0; while (c > ' ') { a = a * 10 + c - '0'; c = getc(); }\n\t\t\treturn a;\n\t\t}\n\t}\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1555F o = new CF1555F(); o.main(); o.flush();\n\t}\n\n\tint[] ds;\n\tint find(int i) {\n\t\treturn ds[i] < 0 ? i : (ds[i] = find(ds[i]));\n\t}\n\tvoid join(int i, int j) {\n\t\ti = find(i);\n\t\tj = find(j);\n\t\tif (i == j)\n\t\t\treturn;\n\t\tif (ds[i] > ds[j])\n\t\t\tds[i] = j;\n\t\telse {\n\t\t\tif (ds[i] == ds[j])\n\t\t\t\tds[i]--;\n\t\t\tds[j] = i;\n\t\t}\n\t}\n\tint[] eo; int[][] ej;\n\tvoid append(int i, int j) {\n\t\tint o = eo[i]++;\n\t\tif (o >= 2 && (o & o - 1) == 0)\n\t\t\tej[i] = Arrays.copyOf(ej[i], o << 1);\n\t\tej[i][o] = j;\n\t}\n\tint[] dd, pp, qq, ta, tb; int t_;\n\tint dfs1(int p, int i, int d) {\n\t\tdd[i] = d++;\n\t\tint s = 1, k_ = 0, j_ = -1;\n\t\tfor (int o = eo[i]; o-- > 0; ) {\n\t\t\tint j = ej[i][o];\n\t\t\tif (j != p) {\n\t\t\t\tint k = dfs1(i, j, d);\n\t\t\t\ts += k;\n\t\t\t\tif (k_ < k) {\n\t\t\t\t\tk_ = k;\n\t\t\t\t\tj_ = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqq[i] = j_;\n\t\treturn s;\n\t}\n\tvoid dfs2(int p, int i, int q) {\n\t\tta[i] = t_++;\n\t\tpp[i] = p;\n\t\tint j_ = qq[i]; qq[i] = q;\n\t\tfor (int o = eo[i]; o-- > 0; ) {\n\t\t\tint j = ej[i][o];\n\t\t\tif (j != p)\n\t\t\t\tdfs2(i, j, j == j_ ? q : j);\n\t\t}\n\t\ttb[i] = t_;\n\t}\n\tint lca(int i, int j) {\n\t\twhile (qq[i] != qq[j])\n\t\t\tif (dd[qq[i]] > dd[qq[j]])\n\t\t\t\ti = pp[qq[i]];\n\t\t\telse\n\t\t\t\tj = pp[qq[j]];\n\t\treturn dd[i] < dd[j] ? i : j;\n\t}\n\tint[] ft;\n\tvoid update(int i, int n, int x) {\n\t\twhile (i < n) {\n\t\t\tft[i] += x;\n\t\t\ti |= i + 1;\n\t\t}\n\t}\n\tint query(int i) {\n\t\tint x = 0;\n\t\twhile (i >= 0) {\n\t\t\tx += ft[i];\n\t\t\ti &= i + 1; i--;\n\t\t}\n\t\treturn x;\n\t}\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] ii = new int[q];\n\t\tint[] jj = new int[q];\n\t\tint[] xx = new int[q];\n\t\tbyte[] ans = new byte[q];\n\t\tfor (int h = 0; h < q; h++) {\n\t\t\tii[h] = sc.nextInt() - 1;\n\t\t\tjj[h] = sc.nextInt() - 1;\n\t\t\txx[h] = sc.nextInt();\n\t\t}\n\t\teo = new int[n]; ej = new int[n][2];\n\t\tds = new int[n * 2]; Arrays.fill(ds, -1);\n\t\tfor (int h = 0; h < q; h++) {\n\t\t\tint i = ii[h], j = jj[h], x = xx[h];\n\t\t\tboolean b00 = find(i << 1) == find(j << 1);\n\t\t\tboolean b01 = find(i << 1) == find(j << 1 | 1);\n\t\t\tif (b00 || b01) {\n\t\t\t\tif (b00 && x == 0 || b01 && x == 1)\n\t\t\t\t\tans[h] = -1;\n\t\t\t} else {\n\t\t\t\tans[h] = 1;\n\t\t\t\tappend(i, j);\n\t\t\t\tappend(j, i);\n\t\t\t\tif (x == 0) {\n\t\t\t\t\tjoin(i << 1, j << 1);\n\t\t\t\t\tjoin(i << 1 | 1, j << 1 | 1);\n\t\t\t\t} else {\n\t\t\t\t\tjoin(i << 1, j << 1 | 1);\n\t\t\t\t\tjoin(i << 1 | 1, j << 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdd = new int[n]; pp = new int[n]; qq = new int[n]; ta = new int[n]; tb = new int[n];\n\t\tft = new int[n];\n\t\tArrays.fill(ta, -1);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (ta[i] == -1) {\n\t\t\t\tdfs1(-1, i, 0);\n\t\t\t\tdfs2(-1, i, 0);\n\t\t\t}\n\t\tfor (int h = 0; h < q; h++) {\n\t\t\tif (ans[h] != 0)\n\t\t\t\tcontinue;\n\t\t\tint i = ii[h], j = jj[h], a = lca(i, j);\n\t\t\tif (query(ta[i]) + query(ta[j]) - query(ta[a]) * 2 > 0) {\n\t\t\t\tans[h] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[h] = 1;\n\t\t\twhile (i != a) {\n\t\t\t\tupdate(ta[i], n, 1);\n\t\t\t\tupdate(tb[i], n, -1);\n\t\t\t\ti = pp[i];\n\t\t\t}\n\t\t\twhile (j != a) {\n\t\t\t\tupdate(ta[j], n, 1);\n\t\t\t\tupdate(tb[j], n, -1);\n\t\t\t\tj = pp[j];\n\t\t\t}\n\t\t}\n\t\tfor (int h = 0; h < q; h++)\n\t\t\tprintln(ans[h] > 0 ? \"YES\" : \"NO\");\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T1, class T2>\ninline void upd1(T1& a, const T2& b) {\n  a = a < b ? a : b;\n}\ntemplate <class T1, class T2>\ninline void upd2(T1& a, const T2& b) {\n  a = b < a ? a : b;\n}\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nstruct Ano {\n  operator long long() {\n    long long x = 0, y = 0, c = getchar();\n    while (c < 48) {\n      y = c == 45;\n      c = getchar();\n    }\n    while (c > 47) {\n      x = x * 10 + c - 48;\n      c = getchar();\n    }\n    return y ? -x : x;\n  }\n} buf;\nconstexpr int N = 6e5 + 5;\nint n;\nstruct vec {\n  bool c, w;\n  vec() {}\n  vec(bool c, bool w) : c(c), w(w) {}\n};\nvec operator+(vec a, vec b) { return vec(a.c | b.c, a.w ^ b.w); }\nstruct node;\ntypedef node* ptr;\nstruct node {\n  ptr i, j, p;\n  bool r, c;\n  vec v, s;\n  node();\n  ptr up() {\n    s = i->s + v + j->s;\n    return this;\n  }\n  void down() {\n    if (r) i->r ^= 1, j->r ^= 1, swap(i, j), r = 0;\n    if (c) i->cov(), j->cov(), c = 0;\n  }\n  void cov();\n} e[N];\nnode::node() { i = j = p = e; }\nvoid node::cov() {\n  if (this == e) return;\n  c = 1;\n  if (this - e > n)\n    s.c = v.c = 1;\n  else\n    s.c = i != e || j != e;\n}\nbool root(ptr o) { return o != o->p->i && o != o->p->j; }\nvoid turn(ptr o) {\n  ptr s = o->p, t = s->p;\n  if (!root(s)) (s == t->i ? t->i : t->j) = o;\n  s->p = o, o->p = t;\n  if (o == s->i)\n    s->i = o->j, o->j->p = s, o->j = s->up();\n  else\n    s->j = o->i, o->i->p = s, o->i = s->up();\n}\nvoid push(ptr o) {\n  if (!root(o)) push(o->p);\n  o->down();\n}\nptr splay(ptr o) {\n  push(o);\n  while (!root(o)) {\n    if (!root(o->p)) turn(o == o->p->i ^ o->p == o->p->p->i ? o : o->p);\n    turn(o);\n  }\n  return o->up();\n}\nptr exp(ptr o) {\n  ptr s = e;\n  while (o != e) splay(o)->j = s, s = o->up(), o = o->p;\n  return s;\n}\nvoid link(int i, int j) { exp(e + i)->r = 1, splay(e + i)->p = e + j; }\nint main() {\n  n = buf;\n  int m = n;\n  for (int q = buf; q; --q) {\n    int u = buf, v = buf, w = buf;\n    exp(e + u)->r = 1;\n    ptr o = exp(e + v);\n    while (o->i != e) {\n      o = o->i, o->down();\n    }\n    bool a = 1;\n    if (splay(o) != e + u) {\n      e[++m].v = vec(0, w);\n      link(u, m);\n      link(v, m);\n    } else {\n      if (!o->s.c && o->s.w ^ w) {\n        o->cov();\n      } else {\n        a = 0;\n      }\n    }\n    puts(a ? \"YES\" : \"NO\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ii = pair<int, int>;\nusing pl = pair<ll, ll>;\nld const PI = 4 * atan((ld)1);\nconstexpr int MAX = 3e5 + 69;\nint n, q;\nint ds[MAX];\nvector<ii> adj[MAX];\ninline int frep(int x) { return ds[x] == x ? x : ds[x] = frep(ds[x]); }\ninline void join(int x, int y) { ds[frep(x)] = frep(y); }\nbool vst[MAX];\nint XOR[MAX], depth[MAX], par[MAX], head[MAX], heavy[MAX], pos[MAX], sz[MAX],\n    st[2 * MAX];\ninline void dfs_sz(int node) {\n  vst[node] = true;\n  sz[node] = 1;\n  int sz_max = 0;\n  for (auto [to, w] : adj[node]) {\n    if (to != par[node]) {\n      par[to] = node;\n      depth[to] = depth[node] + 1;\n      XOR[to] = XOR[node] ^ w;\n      dfs_sz(to);\n      sz[node] += sz[to];\n      if (sz[to] > sz_max) sz_max = sz[to], heavy[node] = to;\n    }\n  }\n}\nstatic int cur_pos = 0;\ninline void dfs_hld(int node, int h) {\n  vst[node] = true;\n  head[node] = h;\n  pos[node] = cur_pos++;\n  if (heavy[node] != -1) dfs_hld(heavy[node], h);\n  for (auto [to, w] : adj[node])\n    if (to != heavy[node] && to != par[node]) dfs_hld(to, to);\n}\ninline int lca(int u, int v) {\n  for (; head[u] != head[v]; u = par[head[u]]) {\n    if (depth[head[u]] < depth[head[v]]) swap(u, v);\n  }\n  return depth[u] < depth[v] ? u : v;\n}\ninline void modify(int p, int val) {\n  for (st[p += n] = val; p > 1; p >>= 1) st[p >> 1] = max(st[p], st[p ^ 1]);\n}\ninline int rmq(int l, int r) {\n  int res = 0;\n  for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\n    if (l & 1) res = max(res, st[l++]);\n    if (r & 1) res = max(res, st[--r]);\n  }\n  return res;\n}\ninline int get(int u, int lc) {\n  int res = 0;\n  for (; head[u] != head[lc]; u = par[head[u]])\n    res = max(res, rmq(pos[head[u]], pos[u]));\n  if (pos[lc] < pos[u]) res = max(res, rmq(pos[lc] + 1, pos[u]));\n  return res;\n}\ninline int ask(int u, int v) {\n  int lc = lca(u, v);\n  return max(get(u, lc), get(v, lc));\n}\nint main() {\n  ios ::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  iota(ds, ds + MAX, 0);\n  cin >> n >> q;\n  vector<bool> res(q);\n  vector<array<int, 4>> pending;\n  for (int i = 0; i < q; ++i) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    if (frep(u) != frep(v)) {\n      res[i] = true;\n      join(u, v);\n      adj[u].push_back({v, w});\n      adj[v].push_back({u, w});\n    } else\n      pending.push_back({u, v, w, i});\n  }\n  for (int i = 0; i < MAX; ++i) {\n    heavy[i] = -1;\n    depth[i] = XOR[i] = 0;\n  }\n  memset(vst, false, sizeof(vst));\n  for (int i = 1; i <= n; ++i)\n    if (!vst[i]) dfs_sz(i);\n  memset(vst, false, sizeof(vst));\n  for (int i = 1; i <= n; ++i)\n    if (!vst[i]) dfs_hld(i, i);\n  for (auto &[u, v, w, i] : pending) {\n    if ((XOR[u] ^ XOR[v] ^ w) == 1 && ask(u, v) == 0) {\n      res[i] = true;\n      for (; u != v; u = par[u]) {\n        if (depth[u] < depth[v]) swap(u, v);\n        modify(pos[u], 1);\n      }\n    }\n  }\n  string s[2] = {\"NO\", \"YES\"};\n  for (bool x : res) cout << s[x] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300000 + 10;\nint n, m;\nnamespace BXJ {\nint fa[N];\nint get(int x) { return x == fa[x] ? x : fa[x] = get(fa[x]); }\n}  // namespace BXJ\nint C[N];\nvoid update(int x, int s) {\n  for (int i = x; i <= n; i += i & -i) C[i] += s;\n}\nint query(int x) {\n  int s = 0;\n  for (int i = x; i; i -= i & -i) s += C[i];\n  return s;\n}\nstruct Edge {\n  int u, v, w;\n  bool mark;\n} e[N * 2];\nvector<pair<int, int>> g[N];\nint dep[N], fa[N], val[N];\nint in[N], out[N], dfn;\nint oula[2 * N], bin[2 * N], odfn;\nint fir[N];\nvoid dfs(int u) {\n  in[u] = ++dfn;\n  oula[++odfn] = u;\n  fir[u] = odfn;\n  for (auto p : g[u]) {\n    int v = p.first, w = p.second;\n    if (in[v]) continue;\n    dep[v] = dep[u] + 1;\n    fa[v] = u;\n    val[v] = val[u] ^ w;\n    dfs(v);\n    oula[++odfn] = u;\n  }\n  out[u] = dfn;\n}\nint mx(int x, int y) { return dep[x] < dep[y] ? x : y; }\nint st[25][2 * N];\nvoid st_init() {\n  bin[0] = -1;\n  for (int i = 1; i <= odfn; i++) {\n    if (i == (i & -i))\n      bin[i] = bin[i - 1] + 1;\n    else\n      bin[i] = bin[i - 1];\n  }\n  for (int i = 1; i <= odfn; i++) st[0][i] = oula[i];\n  for (int t = 1; t < 25; t++) {\n    for (int i = 1; i + (1 << t) - 1 <= odfn; i++) {\n      st[t][i] = mx(st[t - 1][i], st[t - 1][i + (1 << t - 1)]);\n    }\n  }\n}\nint st_query(int L, int R) {\n  if (L > R) swap(L, R);\n  int k = bin[R - L + 1];\n  return mx(st[k][L], st[k][R - (1 << k) + 1]);\n}\nint Lca(int x, int y) { return st_query(fir[x], fir[y]); }\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) BXJ::fa[i] = i;\n  for (int i = 1; i <= m; i++) {\n    cin >> e[i].u >> e[i].v >> e[i].w;\n    int fu = BXJ::get(e[i].u), fv = BXJ::get(e[i].v);\n    e[i].mark = fu == fv;\n    if (!e[i].mark) {\n      g[e[i].u].emplace_back(e[i].v, e[i].w);\n      g[e[i].v].emplace_back(e[i].u, e[i].w);\n      BXJ::fa[fu] = fv;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!in[i]) dfs(i);\n  }\n  st_init();\n  for (int i = 1; i <= m; i++) {\n    if (e[i].mark) {\n      if (val[e[i].u] ^ val[e[i].v] ^ e[i].w != 1)\n        cout << \"NO\" << endl;\n      else {\n        int x = e[i].u, y = e[i].v;\n        int lca = Lca(x, y);\n        int sum = query(in[x]) + query(in[y]) - 2 * query(in[lca]);\n        if (sum)\n          cout << \"NO\" << endl;\n        else {\n          while (x != lca) {\n            update(in[x], 1);\n            update(out[x] + 1, -1);\n            x = fa[x];\n          }\n          while (y != lca) {\n            update(in[y], 1);\n            update(out[y] + 1, -1);\n            y = fa[y];\n          }\n          cout << \"YES\" << endl;\n        }\n      }\n    } else\n      cout << \"YES\" << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, m;\nstd::vector<std::pair<std::pair<int, int>, std::pair<int, int>>> a;\nint f[300005];\ninline int fnd(int x) { return f[x] ? f[x] = fnd(f[x]) : x; }\nint hd[300005], _hd;\nstruct edge {\n  int v, w, nxt;\n} e[300005 << 1];\ninline void addedge(int u, int v, int w) {\n  e[++_hd] = (edge){v, w, hd[u]};\n  hd[u] = _hd;\n}\nstruct node {\n  int mx, add;\n} t[300005 << 2];\ninline void pshd(int p) {\n  t[p << 1].mx += t[p].add;\n  t[p << 1].add += t[p].add;\n  t[p << 1 | 1].mx += t[p].add;\n  t[p << 1 | 1].add += t[p].add;\n  t[p].add = 0;\n}\ninline void add(int p, int L, int R, int l, int r, int d) {\n  if (L > r || R < l) return;\n  if (l <= L && R <= r) {\n    t[p].mx += d;\n    t[p].add += d;\n    return;\n  }\n  pshd(p);\n  int mid = (L + R) >> 1;\n  add(p << 1, L, mid, l, r, d);\n  add(p << 1 | 1, mid + 1, R, l, r, d);\n  t[p].mx = std::max(t[p << 1].mx, t[p << 1 | 1].mx);\n}\ninline int mx(int p, int L, int R, int l, int r) {\n  if (L > r || R < l) return 0;\n  if (l <= L && R <= r) return t[p].mx;\n  pshd(p);\n  int mid = (L + R) >> 1;\n  return std::max(mx(p << 1, L, mid, l, r), mx(p << 1 | 1, mid + 1, R, l, r));\n}\nint fa[300005], son[300005], sz[300005], dep[300005], s[300005];\ninline void dfs1(int u) {\n  dep[u] = dep[fa[u]] + 1;\n  sz[u] = 1;\n  for (int i = hd[u]; i; i = e[i].nxt) {\n    int v = e[i].v;\n    if (v == fa[u]) continue;\n    fa[v] = u;\n    s[v] = s[u] ^ e[i].w;\n    dfs1(v);\n    sz[u] += sz[v];\n    if (sz[v] > sz[son[u]]) son[u] = v;\n  }\n}\nint top[300005], dfn[300005], _dfn;\ninline void dfs2(int u) {\n  top[u] = u == son[fa[u]] ? top[fa[u]] : u;\n  dfn[u] = ++_dfn;\n  if (son[u]) dfs2(son[u]);\n  for (int i = hd[u]; i; i = e[i].nxt) {\n    int v = e[i].v;\n    if (v == fa[u] || v == son[u]) continue;\n    dfs2(v);\n  }\n}\ninline void lca_add(int u, int v) {\n  while (top[u] != top[v]) {\n    if (dep[top[u]] < dep[top[v]]) std::swap(u, v);\n    add(1, 1, n, dfn[top[u]], dfn[u], 1);\n    u = fa[top[u]];\n  }\n  if (dep[u] < dep[v]) std::swap(u, v);\n  add(1, 1, n, dfn[v] + 1, dfn[u], 1);\n}\ninline int lca_mx(int u, int v) {\n  int res = 0;\n  while (top[u] != top[v]) {\n    if (dep[top[u]] < dep[top[v]]) std::swap(u, v);\n    res = std::max(res, mx(1, 1, n, dfn[top[u]], dfn[u]));\n    u = fa[top[u]];\n  }\n  if (dep[u] < dep[v]) std::swap(u, v);\n  res = std::max(res, mx(1, 1, n, dfn[v] + 1, dfn[u]));\n  return res;\n}\nint ans[500005];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= m; i++) {\n    int u, v, x;\n    scanf(\"%d%d%d\", &u, &v, &x);\n    int fu = fnd(u), fv = fnd(v);\n    if (fu == fv) {\n      a.push_back(std::make_pair(std::make_pair(u, v), std::make_pair(x, i)));\n    } else {\n      f[fu] = fv;\n      addedge(u, v, x);\n      addedge(v, u, x);\n      ans[i] = 1;\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (!dep[i]) dfs1(i);\n  for (int i = 1; i <= n; i++)\n    if (!dfn[i]) dfs2(i);\n  for (auto [_, __] : a) {\n    auto [u, v] = _;\n    auto [x, i] = __;\n    int y = s[u] ^ s[v];\n    if (!(x ^ y) || lca_mx(u, v)) continue;\n    lca_add(u, v);\n    ans[i] = 1;\n  }\n  for (int i = 1; i <= m; i++) puts(ans[i] ? \"YES\" : \"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename A, typename B>\nostream& operator<<(ostream& out, pair<A, B> p) {\n  return out << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename A,\n          typename B = typename enable_if<!is_same<A, string>::value,\n                                          typename A::value_type>::type>\nostream& operator<<(ostream& out, A vec) {\n  out << '{';\n  string sep;\n  for (B x : vec) out << sep << x, sep = \", \";\n  return out << '}';\n}\nvoid dbg_print() { cerr << endl; }\ntemplate <typename A, typename... B>\nvoid dbg_print(A a, B... b) {\n  cerr << ' ' << a;\n  dbg_print(b...);\n}\nstruct disjoin_set_union {\n  std::vector<int> parent;\n  std::vector<int> rank;\n  disjoin_set_union(int n = 0) : parent(n), rank(n, 1) {\n    std::iota(parent.begin(), parent.end(), 0);\n  }\n  int root(int v) { return (v ^ parent[v]) ? parent[v] = root(parent[v]) : v; }\n  bool unite(int v, int u) {\n    v = root(v), u = root(u);\n    if (v == u) return false;\n    if (rank[v] < rank[u]) std::swap(v, u);\n    rank[v] += rank[u];\n    parent[u] = v;\n    return true;\n  }\n};\nclass LinkCutTree {\n private:\n  struct Vertex {\n    int left, right, parent;\n    bool revert;\n    int size;\n    int64_t value, result, delta;\n    Vertex()\n        : left(-1),\n          right(-1),\n          parent(-1),\n          revert(),\n          size(1),\n          value(0),\n          result(0),\n          delta(0) {}\n  };\n  vector<Vertex> t;\n  bool isRoot(int x) const {\n    int p = t[x].parent;\n    return p == -1 || (t[p].left != x && t[p].right != x);\n  }\n  int64_t getValue(int x) const { return t[x].value + t[x].delta; }\n  int64_t getResult(int x) const {\n    return t[x].result + t[x].delta * t[x].size;\n  }\n  void push(int x) {\n    if (t[x].revert) {\n      if (t[x].left != -1) t[t[x].left].revert = !t[t[x].left].revert;\n      if (t[x].right != -1) t[t[x].right].revert = !t[t[x].right].revert;\n      swap(t[x].left, t[x].right);\n      t[x].revert = false;\n    }\n    t[x].value = getValue(x);\n    t[x].result = getResult(x);\n    if (t[x].left != -1) t[t[x].left].delta += t[x].delta;\n    if (t[x].right != -1) t[t[x].right].delta += t[x].delta;\n    t[x].delta = 0;\n  }\n  void keep(int x) {\n    t[x].size = 1;\n    t[x].result = getValue(x);\n    if (t[x].left != -1) {\n      t[x].size += t[t[x].left].size;\n      t[x].result += getResult(t[x].left);\n    }\n    if (t[x].right != -1) {\n      t[x].size += t[t[x].right].size;\n      t[x].result += getResult(t[x].right);\n    }\n  }\n  void rotate(int x) {\n    int p = t[x].parent;\n    int g = t[p].parent;\n    push(p), push(x);\n    if (g != -1) {\n      if (t[g].left == p)\n        t[g].left = x;\n      else if (t[g].right == p)\n        t[g].right = x;\n    }\n    t[x].parent = g;\n    if (t[p].left == x) {\n      t[p].left = t[x].right;\n      if (t[p].left != -1) t[t[p].left].parent = p;\n      t[x].right = p;\n    } else {\n      t[p].right = t[x].left;\n      if (t[p].right != -1) t[t[p].right].parent = p;\n      t[x].left = p;\n    }\n    t[p].parent = x;\n    keep(p), keep(x);\n  }\n  void splay(int x) {\n    while (!isRoot(x)) {\n      int p = t[x].parent;\n      if (!isRoot(p)) {\n        int g = t[p].parent;\n        bool zigzig = (x == t[p].left) == (p == t[g].left);\n        rotate(zigzig ? p : x);\n      }\n      rotate(x);\n    }\n    push(x);\n  }\n  int expose(int x) {\n    int c = -1;\n    for (int y = x; y != -1; y = t[y].parent) {\n      splay(y);\n      t[y].right = c;\n      keep(y);\n      c = y;\n    }\n    splay(x);\n    return c;\n  }\n\n public:\n  LinkCutTree(int n) : t(n) {}\n  void evert(int x) {\n    expose(x);\n    t[x].revert = !t[x].revert;\n  }\n  int root(int x) {\n    expose(x);\n    while (t[x].left != -1) {\n      x = t[x].left;\n      push(x);\n    }\n    expose(x);\n    return x;\n  }\n  int parent(int x) {\n    expose(x);\n    if (t[x].left == -1) return -1;\n    x = t[x].left;\n    push(x);\n    while (t[x].right != -1) {\n      x = t[x].right;\n      push(x);\n    }\n    return x;\n  }\n  bool path(int x, int y) {\n    if (x == y) return true;\n    expose(y), expose(x);\n    return t[y].parent != -1;\n  }\n  void link(int x, int y) {\n    if (path(x, y)) return;\n    evert(x);\n    t[x].parent = y;\n  }\n  void cut(int x) {\n    expose(x);\n    if (t[x].left == -1) return;\n    t[t[x].left].parent = -1;\n    t[x].left = -1;\n  }\n  int lca(int x, int y) {\n    if (!path(x, y)) return -1;\n    expose(x);\n    return expose(y);\n  }\n  int depth(int x) {\n    expose(x);\n    if (t[x].left == -1) return 0;\n    return t[t[x].left].size;\n  }\n  int distance(int x, int y) {\n    int l = lca(x, y);\n    if (l == -1) return -1;\n    return depth(y) + depth(x) - depth(l) * 2;\n  }\n  int64_t query(int x, int y) {\n    if (!path(x, y)) return 0;\n    evert(x), expose(y);\n    return t[y].result;\n  }\n  void update(int x, int y, int64_t value) {\n    if (!path(x, y)) return;\n    evert(x), expose(y);\n    t[y].delta += value;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false), cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  disjoin_set_union dsu(n);\n  LinkCutTree g(n + m);\n  vector<set<int>> adj(n + m);\n  for (int id = n; id < n + m; id++) {\n    int v, u, c;\n    cin >> v >> u >> c;\n    v--, u--;\n    if (dsu.root(v) != dsu.root(u)) {\n      cout << \"YES\\n\";\n      dsu.unite(v, u);\n      g.link(v, id);\n      g.link(u, id);\n      g.update(id, id, c);\n    } else {\n      if (!g.path(v, u) || (g.query(v, u) + c) % 2 == 0) {\n        cout << \"NO\\n\";\n        continue;\n      }\n      cout << \"YES\\n\";\n      while (u != v) {\n        g.evert(v);\n        int w = g.parent(u);\n        g.cut(u);\n        u = w;\n      }\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = x * 10 + ch - 48;\n    ch = getchar();\n  }\n  return x * f;\n}\nconst int N = 800005, Q = 500005;\nstruct LCT {\n  struct Node {\n    int s[2], p, v;\n    long long sum;\n    bool rev;\n  } tr[N];\n  int stk[N];\n  void pushup(int x) {\n    tr[x].sum = tr[tr[x].s[0]].sum + tr[x].v + tr[tr[x].s[1]].sum;\n  }\n  void pushrev(int x) {\n    swap(tr[x].s[0], tr[x].s[1]);\n    tr[x].rev ^= 1;\n  }\n  void pushdown(int x) {\n    if (tr[x].rev) {\n      pushrev(tr[x].s[0]), pushrev(tr[x].s[1]);\n      tr[x].rev = 0;\n    }\n  }\n  bool isroot(int x) { return tr[tr[x].p].s[0] != x && tr[tr[x].p].s[1] != x; }\n  void rotate(int x) {\n    int y = tr[x].p, z = tr[y].p;\n    int k = tr[y].s[1] == x;\n    if (!isroot(y)) tr[z].s[tr[z].s[1] == y] = x;\n    tr[x].p = z;\n    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;\n    tr[x].s[k ^ 1] = y, tr[y].p = x;\n    pushup(y), pushup(x);\n  }\n  void splay(int x) {\n    int top = 0, r = x;\n    stk[++top] = r;\n    while (!isroot(r)) stk[++top] = r = tr[r].p;\n    while (top) pushdown(stk[top--]);\n    while (!isroot(x)) {\n      int y = tr[x].p, z = tr[y].p;\n      if (!isroot(y))\n        if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y))\n          rotate(x);\n        else\n          rotate(y);\n      rotate(x);\n    }\n  }\n  void access(int x) {\n    int z = x;\n    for (int y = 0; x; y = x, x = tr[x].p) {\n      splay(x);\n      tr[x].s[1] = y, pushup(x);\n    }\n    splay(z);\n  }\n  void makeroot(int x) {\n    access(x);\n    pushrev(x);\n  }\n  int findroot(int x) {\n    access(x);\n    while (tr[x].s[0]) pushdown(x), x = tr[x].s[0];\n    splay(x);\n    return x;\n  }\n  void split(int x, int y) {\n    makeroot(x);\n    access(y);\n  }\n  bool is_link(int x, int y) {\n    makeroot(x);\n    return findroot(y) == x;\n  }\n  bool is_direct_link(int x, int y) {\n    return is_link(x, y) && tr[y].p == x && !tr[y].s[0];\n  }\n  void link(int x, int y) {\n    if (!is_link(x, y)) tr[x].p = y;\n  }\n  void cut(int x, int y) {\n    if (is_direct_link(x, y)) {\n      tr[x].s[1] = tr[y].p = 0;\n      pushup(x);\n    }\n  }\n  long long query(int x, int y) {\n    split(x, y);\n    return tr[y].sum;\n  }\n  void update(int x, long long y) {\n    splay(x);\n    tr[x].v = y;\n    pushup(x);\n  }\n} lct1, lct2;\nstruct Offline {\n  int u, v, x;\n  bool f;\n} off[Q];\nint stac[N], top;\nvoid dfs(int now) {\n  stac[++top] = now;\n  if (lct2.tr[now].s[0]) dfs(lct2.tr[now].s[0]);\n  if (lct2.tr[now].s[1]) dfs(lct2.tr[now].s[1]);\n}\nvoid solve() {\n  int n = read(), q = read();\n  for (int i = 1; i <= q; i++) {\n    int u = read(), v = read(), x = read();\n    off[i] = {u, v, x};\n    if (lct1.is_link(u, v)) continue;\n    off[i].f = 1;\n    int mid = i + n;\n    lct1.tr[mid].v = x;\n    lct1.link(u, mid), lct1.link(mid, v);\n    lct2.link(u, mid), lct2.link(mid, v);\n  }\n  for (int i = 1; i <= q; i++) {\n    if (off[i].f) {\n      puts(\"YES\");\n      continue;\n    }\n    int u = off[i].u, v = off[i].v, x = off[i].x;\n    if (lct2.query(u, v) > 0) {\n      puts(\"NO\");\n      continue;\n    }\n    if ((lct1.query(u, v) & 1) ^ x) {\n      puts(\"YES\");\n      lct2.split(u, v);\n      dfs(v);\n      while (top) {\n        int now = stac[top--];\n        if (now <= n) continue;\n        lct2.update(now, lct2.tr[now].v + 1);\n      }\n    } else\n      puts(\"NO\");\n  }\n}\nint main() {\n  int ttt = 1;\n  for (int i = 1; i <= ttt; i++) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nconst int N = 8e5 + 10;\nint n, q;\nstruct Node {\n  int val, fa, son[2], circletag, circle, xorsum, qs, revtag;\n} nd[N];\ninline void maintain(int u) {\n  nd[u].xorsum = nd[nd[u].son[0]].xorsum ^ nd[nd[u].son[1]].xorsum ^ nd[u].val;\n  nd[u].qs = nd[u].circle | nd[nd[u].son[0]].qs | nd[nd[u].son[1]].qs;\n}\ninline void cir(int u) {\n  nd[u].circletag = 1;\n  nd[u].circle = 1;\n  nd[u].qs = 1;\n}\ninline void rev(int u) { nd[u].revtag ^= 1; }\ninline void down(int u) {\n  if (nd[u].circletag) {\n    nd[u].circletag = 0;\n    nd[u].circle = u > n;\n    if (nd[u].son[0]) {\n      cir(nd[u].son[0]);\n    }\n    if (nd[u].son[1]) {\n      cir(nd[u].son[1]);\n    }\n  }\n  if (nd[u].revtag) {\n    nd[u].revtag = 0;\n    std::swap(nd[u].son[0], nd[u].son[1]);\n    if (nd[u].son[0]) {\n      rev(nd[u].son[0]);\n    }\n    if (nd[u].son[1]) {\n      rev(nd[u].son[1]);\n    }\n  }\n}\ninline bool no_root(int u) {\n  return nd[nd[u].fa].son[0] == u || nd[nd[u].fa].son[1] == u;\n}\nvoid rotate(int u) {\n  int p = nd[u].fa, isl = u == nd[p].son[1];\n  if (no_root(p)) {\n    nd[nd[p].fa].son[p == nd[nd[p].fa].son[1]] = u;\n  }\n  nd[u].fa = nd[p].fa;\n  nd[p].fa = u;\n  if (nd[u].son[isl ^ 1]) {\n    nd[nd[u].son[isl ^ 1]].fa = p;\n  }\n  nd[p].son[isl] = nd[u].son[isl ^ 1];\n  nd[u].son[isl ^ 1] = p;\n  maintain(p);\n}\nvoid splay(int u) {\n  static int top, stk[N];\n  int x = u;\n  stk[top = 1] = x;\n  for (; no_root(x); x = nd[x].fa) {\n    stk[++top] = nd[x].fa;\n  }\n  for (; top;) {\n    down(stk[top--]);\n  }\n  while (no_root(u)) {\n    if (no_root(nd[u].fa)) {\n      rotate((nd[nd[u].fa].son[1] == u) ==\n                     (nd[nd[nd[u].fa].fa].son[1] == nd[u].fa)\n                 ? nd[u].fa\n                 : u);\n    }\n    rotate(u);\n  }\n  maintain(u);\n}\nvoid access(int u) {\n  for (int v = 0; u; u = nd[v = u].fa) {\n    splay(u);\n    nd[u].son[1] = v;\n    maintain(u);\n  }\n}\ninline void make_root(int u) {\n  access(u);\n  splay(u);\n  rev(u);\n}\nint find_root(int u) {\n  access(u);\n  splay(u);\n  down(u);\n  while (nd[u].son[0]) {\n    down(u = nd[u].son[0]);\n  }\n  splay(u);\n  return u;\n}\nvoid link(int u, int v) {\n  make_root(u);\n  if (find_root(v) != u) {\n    nd[u].fa = v;\n  }\n}\nvoid cut(int u, int v) {\n  make_root(u);\n  access(v);\n  splay(v);\n  if (find_root(v) != u || nd[v].fa != u || nd[v].son[0]) {\n    return;\n  }\n  nd[u].son[1] = nd[v].fa = 0;\n  maintain(u);\n}\nvoid split(int u, int v) {\n  make_root(u);\n  access(v);\n  splay(v);\n}\nint main() {\n  std::ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> q;\n  for (int u, v, w, T = 1; T <= q; ++T) {\n    cin >> u >> v >> w;\n    make_root(u);\n    if (find_root(v) != u) {\n      nd[T + n].val = nd[T + n].xorsum = w;\n      link(T + n, u);\n      link(T + n, v);\n      cout << \"YES\\n\";\n    } else {\n      split(u, v);\n      if (nd[v].xorsum ^ w != 1 || nd[v].qs) {\n        cout << \"NO\\n\";\n      } else {\n        cout << \"YES\\n\";\n        cir(v);\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &r) {\n  r = 0;\n  bool w = true;\n  char ch = getchar();\n  for (; !isdigit(ch); ch = getchar()) w ^= !(ch ^ 45);\n  for (; isdigit(ch); ch = getchar()) r = (r << 1) + (r << 3) + (ch ^ 48);\n  r = w ? r : -r;\n}\nstruct node_edge {\n  int to, next, weight;\n} edge[(500000 + 5) << 1];\nint head[300000 + 5], edge_num;\nvoid add(int u, int v, int w) {\n  ++edge_num;\n  edge[edge_num].to = v;\n  edge[edge_num].weight = w;\n  edge[edge_num].next = head[u];\n  head[u] = edge_num;\n}\nint n, m, ans[500000 + 5];\nint fat[300000 + 5];\nint find(int x) {\n  if (fat[x] == x) return x;\n  return fat[x] = find(fat[x]);\n}\nint from[500000 + 5], to[500000 + 5], weight[500000 + 5];\nvoid init() {\n  read(n), read(m);\n  for (register int i = 1; i <= n; i++) fat[i] = i;\n  for (register int i = 1; i <= m; i++) {\n    read(from[i]), read(to[i]), read(weight[i]);\n    if (find(from[i]) != find(to[i])) {\n      fat[find(from[i])] = find(to[i]);\n      ans[i] = true;\n      add(from[i], to[i], weight[i]);\n      add(to[i], from[i], weight[i]);\n    }\n  }\n}\nint fa[300000 + 5], depth[300000 + 5], size[300000 + 5], son[300000 + 5],\n    val[300000 + 5];\nvoid dfs1(int u) {\n  size[u] = 1;\n  for (register int i = head[u]; i; i = edge[i].next) {\n    int v = edge[i].to;\n    if (fa[u] == v) continue;\n    fa[v] = u;\n    depth[v] = depth[u] + 1;\n    val[v] = edge[i].weight;\n    dfs1(v);\n    size[u] += size[v];\n    if (size[son[u]] < size[v]) son[u] = v;\n  }\n}\nint pos[300000 + 5], bac[300000 + 5], belong[300000 + 5];\nvoid dfs2(int u, int chain) {\n  belong[u] = chain;\n  pos[u] = ++pos[0];\n  bac[pos[0]] = u;\n  if (son[u]) dfs2(son[u], chain);\n  for (register int i = head[u]; i; i = edge[i].next) {\n    int v = edge[i].to;\n    if (fa[u] == v || son[u] == v) continue;\n    dfs2(v, v);\n  }\n}\nstruct node2 {\n  int l, r, val;\n  bool vis, lazy;\n} a[300000 << 2];\nvoid pushup(int p) {\n  a[p].val = a[(p << 1)].val ^ a[((p << 1) + 1)].val;\n  a[p].vis = a[(p << 1)].vis | a[((p << 1) + 1)].vis;\n}\nvoid pushdown(int p) {\n  if (a[p].lazy) {\n    a[(p << 1)].vis = a[((p << 1) + 1)].vis = a[(p << 1)].lazy =\n        a[((p << 1) + 1)].lazy = true;\n    a[p].lazy = false;\n  }\n}\nvoid build(int p, int l, int r) {\n  a[p].l = l, a[p].r = r;\n  if (l == r) {\n    a[p].val = val[bac[l]];\n    a[p].vis = false;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build((p << 1), l, mid);\n  build(((p << 1) + 1), mid + 1, r);\n  pushup(p);\n}\nvoid update(int p, int l, int r) {\n  if (a[p].l == l && a[p].r == r) {\n    a[p].vis = true;\n    a[p].lazy = true;\n    return;\n  }\n  pushdown(p);\n  int mid = (a[p].l + a[p].r) >> 1;\n  if (r <= mid)\n    update((p << 1), l, r);\n  else if (l > mid)\n    update(((p << 1) + 1), l, r);\n  else {\n    update((p << 1), l, mid);\n    update(((p << 1) + 1), mid + 1, r);\n  }\n  pushup(p);\n}\nint query(int p, int l, int r) {\n  if (a[p].l == l && a[p].r == r) {\n    if (a[p].vis) return -1;\n    return a[p].val;\n  }\n  pushdown(p);\n  int mid = (a[p].l + a[p].r) >> 1;\n  if (r <= mid) return query((p << 1), l, r);\n  if (l > mid) return query(((p << 1) + 1), l, r);\n  int ls = query((p << 1), l, mid), rs = query(((p << 1) + 1), mid + 1, r);\n  if (ls == -1 || rs == -1) return -1;\n  return ls ^ rs;\n}\nvoid getpath(int i) {\n  int x = from[i], y = to[i], ret = weight[i];\n  while (belong[x] != belong[y]) {\n    if (depth[belong[x]] < depth[belong[y]]) swap(x, y);\n    int g = query(1, pos[belong[x]], pos[x]);\n    if (g == -1) return;\n    ret ^= g;\n    x = fa[belong[x]];\n  }\n  if (depth[x] < depth[y]) swap(x, y);\n  if (x != y) {\n    int g = query(1, pos[y] + 1, pos[x]);\n    if (g == -1) return;\n    ret ^= g;\n  }\n  if (ret) {\n    ans[i] = 1;\n    if (x != y) update(1, pos[y] + 1, pos[x]);\n    x = from[i], y = to[i];\n    while (belong[x] != belong[y]) {\n      if (depth[belong[x]] < depth[belong[y]]) swap(x, y);\n      update(1, pos[belong[x]], pos[x]);\n      x = fa[belong[x]];\n    }\n  }\n}\nvoid solve() {\n  for (register int i = 1; i <= n; i++) {\n    if (!size[i]) {\n      dfs1(i);\n      dfs2(i, i);\n    }\n  }\n  build(1, 1, n);\n  for (register int i = 1; i <= m; i++) {\n    if (!ans[i]) {\n      getpath(i);\n    }\n  }\n  for (register int i = 1; i <= m; i++) puts(ans[i] ? \"YES\" : \"NO\");\n}\nvoid write() {}\nint main() {\n  init();\n  solve();\n  write();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  char ch = getchar();\n  int x = 0, pd = 0;\n  while (ch < '0' || ch > '9') pd ^= ch == '-', ch = getchar();\n  while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ 48), ch = getchar();\n  return pd ? -x : x;\n}\nconst int maxn = 300005;\nint n, m;\nstruct Edge {\n  int u, v, w, bj;\n} d[maxn * 2];\nint Fa[maxn];\nint ff(int x) { return Fa[x] == x ? x : Fa[x] = ff(Fa[x]); }\nint e, bg[maxn], to[maxn << 1], nx[maxn << 1], w[maxn << 1];\nvoid link(int u, int v, int _w) {\n  to[++e] = v, nx[e] = bg[u], w[e] = _w, bg[u] = e;\n}\nint val[maxn], fa[maxn], sz[maxn], son[maxn], dep[maxn], id[maxn], rk[maxn],\n    top[maxn];\nvoid dfs1(int u) {\n  sz[u] = 1, dep[u] = dep[fa[u]] + 1;\n  for (int i = bg[u]; i; i = nx[i]) {\n    int v = to[i];\n    if (v == u[fa]) continue;\n    v[fa] = u, v[val] = w[i], dfs1(v);\n    sz[u] += sz[v];\n    if (sz[v] > sz[son[u]]) son[u] = v;\n  }\n}\nint tot;\nvoid dfs2(int u, int t) {\n  top[u] = t, rk[id[u] = ++tot] = u;\n  if (son[u])\n    dfs2(son[u], t);\n  else\n    return;\n  for (int i = bg[u]; i; i = nx[i])\n    if (to[i] != u[fa] && to[i] != son[u]) dfs2(to[i], to[i]);\n}\nbool yh[maxn << 2], fg[maxn << 2];\nbool tag[maxn << 2];\nvoid pushdown(int o) {\n  (o << 1)[fg] = (o << 1 | 1)[fg] = 1;\n  (o << 1)[tag] = (o << 1 | 1)[tag] = 1;\n  o[tag] = 0;\n}\nvoid build(int o, int l, int r) {\n  if (l == r) {\n    o[yh] = val[rk[l]];\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build((o << 1), l, mid), build((o << 1 | 1), mid + 1, r);\n  o[yh] = (o << 1)[yh] ^ (o << 1 | 1)[yh];\n}\nvoid cover(int o, int l, int r, int L, int R) {\n  o[fg] = 1;\n  if (L <= l && r <= R) {\n    o[tag] = 1;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (L <= mid) cover((o << 1), l, mid, L, R);\n  if (R > mid) cover((o << 1 | 1), mid + 1, r, L, R);\n}\nbool query(int o, int l, int r, int L, int R) {\n  if (L <= l && r <= R) return o[yh];\n  int mid = (l + r) >> 1;\n  if (o[tag]) pushdown(o);\n  if (R <= mid) return query((o << 1), l, mid, L, R);\n  if (L > mid) return query((o << 1 | 1), mid + 1, r, L, R);\n  return query((o << 1), l, mid, L, R) ^ query((o << 1 | 1), mid + 1, r, L, R);\n}\nbool check(int o, int l, int r, int L, int R) {\n  if (L <= l && r <= R) return o[fg];\n  int mid = (l + r) >> 1;\n  if (o[tag]) {\n    pushdown(o);\n    return 1;\n  }\n  if (R <= mid) return check((o << 1), l, mid, L, R);\n  if (L > mid) return check((o << 1 | 1), mid + 1, r, L, R);\n  return check((o << 1), l, mid, L, R) || check((o << 1 | 1), mid + 1, r, L, R);\n}\nint getlca(int x, int y) {\n  while (x[top] != y[top])\n    if (x[top][dep] > y[top][dep])\n      x = x[top][fa];\n    else\n      y = y[top][fa];\n  return x[dep] < y[dep] ? x : y;\n}\nbool qrange(int x, int y) {\n  bool res = 0;\n  while (x[top] != y[top]) {\n    res ^= query(1, 1, n, id[x[top]], id[x]);\n    x = x[top][fa];\n  }\n  if (x != y) res ^= query(1, 1, n, id[y] + 1, id[x]);\n  return res;\n}\nbool check(int x, int y) {\n  bool ok = 0;\n  while (x[top] != y[top]) {\n    ok |= check(1, 1, n, id[x[top]], id[x]);\n    x = x[top][fa];\n  }\n  if (x != y) ok |= check(1, 1, n, id[y] + 1, id[x]);\n  return ok ^ 1;\n}\nvoid xrange(int x, int y) {\n  while (x[top] != y[top]) {\n    cover(1, 1, n, id[x[top]], id[x]);\n    x = x[top][fa];\n  }\n  if (x != y) cover(1, 1, n, id[y] + 1, id[x]);\n}\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++) Fa[i] = i;\n  for (int i = 1; i <= m; i++) {\n    int x = read(), y = read(), z = read();\n    int fx = ff(x), fy = ff(y);\n    if (fx != fy) Fa[fx] = fy, link(x, y, z), link(y, x, z), d[i].bj = 1;\n    d[i].u = x, d[i].v = y, d[i].w = z;\n  }\n  for (int i = 1; i <= n; i++)\n    if (Fa[i] == i) dfs1(i), dfs2(i, i);\n  build(1, 1, n);\n  for (int i = 1; i <= m; i++) {\n    if (d[i].bj) {\n      puts(\"YES\");\n      continue;\n    }\n    int lca = getlca(d[i].u, d[i].v);\n    if (qrange(d[i].u, lca) ^ qrange(d[i].v, lca) ^ d[i].w) {\n      if (check(d[i].u, lca) && check(d[i].v, lca)) {\n        puts(\"YES\");\n        xrange(d[i].u, lca), xrange(d[i].v, lca);\n      } else\n        puts(\"NO\");\n    } else\n      puts(\"NO\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INFF = 0x3f3f3f3f3f3f3f3fll;\nconst long long M = 998244353;\nconst long long maxn = 3e5 + 107;\nconst long long maxm = 5e5 + 107;\nconst double pi = acos(-1.0);\nconst double eps = 0.0000000001;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\ntemplate <typename T>\ninline void pr2(T x, unsigned long long k = 64) {\n  unsigned long long i;\n  for (i = 0; i < k; i++) fprintf(stderr, \"%d\", (int)((x >> i) & 1));\n  putchar(' ');\n}\ntemplate <typename T>\ninline void add_(T &A, int B, long long MOD = M) {\n  A += B;\n  (A >= MOD) && (A -= MOD);\n}\ntemplate <typename T>\ninline void mul_(T &A, long long B, long long MOD = M) {\n  A = (A * B) % MOD;\n}\ntemplate <typename T>\ninline void mod_(T &A, long long MOD = M) {\n  A %= MOD;\n  A += MOD;\n  A %= MOD;\n}\ntemplate <typename T>\ninline void max_(T &A, T B) {\n  (A < B) && (A = B);\n}\ntemplate <typename T>\ninline void min_(T &A, T B) {\n  (A > B) && (A = B);\n}\ntemplate <typename T>\ninline T abs(T a) {\n  return a > 0 ? a : -a;\n}\ninline long long powMM(long long a, long long b, long long mod = M) {\n  long long ret = 1;\n  for (; b; b >>= 1ll, a = a * a % mod)\n    if (b & 1) ret = ret * a % mod;\n  return ret;\n}\nint startTime;\nvoid startTimer() { startTime = clock(); }\nvoid printTimer() {\n  fprintf(stderr, \"/--- Time: %ld milliseconds ---/\\n\", clock() - startTime);\n}\nint MAX[maxn * 4];\nvoid update(int x, int l, int r, int value, int L, int R) {\n  if (l <= L && R <= r) {\n    MAX[x] = max(MAX[x], value);\n    return;\n  }\n  int mid = (L + R) / 2;\n  if (l <= mid) update(x << 1, l, r, value, L, mid);\n  if (mid < r) update(x << 1 | 1, l, r, value, mid + 1, R);\n}\nint query(int x, int pos, int L, int R) {\n  if (L == R) return MAX[x];\n  int mid = (L + R) / 2, ret = MAX[x];\n  if (pos <= mid) max_(ret, query(x << 1, pos, L, mid));\n  if (mid < pos) max_(ret, query(x << 1 | 1, pos, mid + 1, R));\n  return ret;\n}\nint in[maxn], out[maxn], tot;\nvector<pair<int, int> > edge[maxn];\nint fa[maxn], col[maxn], dep[maxn];\nint sz[maxn], son[maxn];\nvoid dfs(int x, int fa, int color) {\n  dep[x] = dep[fa] + 1;\n  col[x] = color;\n  ::fa[x] = fa;\n  in[x] = ++tot;\n  sz[x] = 1;\n  int mx = -1;\n  for (auto e : edge[x])\n    if (e.first != fa) {\n      dfs(e.first, x, color ^ e.second);\n      sz[x] += sz[e.first];\n      if (sz[e.first] > mx) mx = sz[e.first], son[x] = e.first;\n    }\n  out[x] = tot;\n}\nint top[maxn], id[maxn];\nvoid dfs2(int u, int x) {\n  top[u] = x;\n  if (son[u]) dfs2(son[u], x);\n  for (auto e : edge[u]) {\n    int v = e.first;\n    if (v == son[u]) continue;\n    if (v == fa[u]) continue;\n    dfs2(v, v);\n  }\n}\nint lca(int x, int y) {\n  while (top[x] != top[y]) {\n    if (dep[top[x]] < dep[top[y]]) swap(x, y);\n    x = fa[top[x]];\n  }\n  if (dep[x] > dep[y]) swap(x, y);\n  return x;\n}\ninline int getfa(int x) {\n  if (fa[x] == x) return x;\n  return fa[x] = getfa(fa[x]);\n}\nint U[maxm], V[maxm];\nbool C[maxm], ans[maxm];\nint main() {\n  int n, q, i;\n  scanf(\"%d%d\", &n, &q);\n  for (i = 1; i <= n; i++) fa[i] = i;\n  for (i = 1; i <= q; i++) {\n    int c;\n    scanf(\"%d%d%d\", &U[i], &V[i], &c);\n    C[i] = c;\n    int x = getfa(U[i]), y = getfa(V[i]);\n    if (x == y) continue;\n    if (x < 1 || x > n) continue;\n    fa[x] = y;\n    edge[U[i]].push_back(make_pair(V[i], C[i]));\n    edge[V[i]].push_back(make_pair(U[i], C[i]));\n    ans[i] = 1;\n  }\n  for (i = 1; i <= n; i++)\n    if (!in[i]) {\n      dfs(i, 0, 0);\n      dfs2(i, 1);\n    }\n  for (i = 1; i <= n; i++) vector<pair<int, int> >().swap(edge[i]);\n  for (i = 1; i <= q; i++)\n    if (!ans[i]) {\n      int u = U[i], v = V[i];\n      if (col[u] ^ col[v] ^ C[i]) {\n        int f = lca(u, v);\n        int du = query(1, in[u], 1, n);\n        int dv = query(1, in[v], 1, n);\n        if (max(du, dv) <= dep[f]) {\n          ans[i] = 1;\n          while (u != v) {\n            if (dep[u] < dep[v]) swap(u, v);\n            update(1, in[u], out[u], dep[u], 1, n);\n            u = fa[u];\n          }\n        }\n      }\n    }\n  for (i = 1; i <= q; i++) puts(ans[i] ? \"YES\" : \"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class T>\nvoid read(T &x) {\n  x = 0;\n  char f = 0, c = getc(stdin);\n  while (c < '0' || c > '9') f ^= (c == '-'), c = getc(stdin);\n  while (c >= '0' && c <= '9') x = x * 10 + (c & 15), c = getc(stdin);\n  f && (x = -x);\n}\nint Max(int a, int b) { return a > b ? a : b; }\nint Min(int a, int b) { return a < b ? a : b; }\nint Abs(int a) { return a < 0 ? -a : a; }\nint sqr(int a) { return (long long)a * a; }\nint qpow(int a, int b) {\n  if (b < 0) return 0;\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = 1ll * a * ans % 1000000007;\n    a = 1ll * a * a % 1000000007;\n    b >>= 1;\n  }\n  return ans;\n}\nint T = 1;\nint n, q;\nint u, v, opt;\nint cnt;\nint s[600010][2], f[600010];\nbool tagrev[600010];\nbool val[600010], flg[600010], tmp[600010], vis[600010];\ninline void rev(int x) {\n  if (!x) return;\n  s[x][0] ^= s[x][1] ^= s[x][0] ^= s[x][1];\n  tagrev[x] = !tagrev[x];\n}\ninline void pushdown(int x) {\n  if (!x) return;\n  if (tagrev[x]) rev(s[x][0]), rev(s[x][1]), tagrev[x] = 0;\n}\ninline void pushup(int x) {\n  tmp[x] = tmp[s[x][0]] ^ tmp[s[x][1]] ^ val[x];\n  vis[x] = vis[s[x][0]] | vis[s[x][1]] | flg[x];\n}\ninline bool brt(int x) { return s[f[x]][0] != x && s[f[x]][1] != x; }\ninline bool bl(int x) { return s[f[x]][1] == x; }\ninline void rotate(int x) {\n  int fa = f[x], ffa = f[fa], b = bl(x);\n  !brt(fa) && (s[ffa][bl(fa)] = x);\n  f[f[s[x][!b] = f[s[fa][b] = s[x][!b]] = fa] = x] = ffa;\n  pushup(fa);\n}\nvoid pd(int x) {\n  if (!brt(x)) pd(f[x]);\n  pushdown(x);\n}\ninline void splay(int x) {\n  pd(x);\n  while (!brt(x)) {\n    int fa = f[x];\n    if (!brt(fa)) rotate((bl(x) ^ bl(fa)) ? x : fa);\n    rotate(x);\n  }\n  pushup(x);\n}\ninline void ass(int x) {\n  for (int sx = 0; x; x = f[sx = x]) splay(x), s[x][1] = sx, pushup(x);\n}\ninline void mkrt(int x) {\n  ass(x);\n  splay(x);\n  rev(x);\n}\ninline int fdrt(int x) {\n  ass(x);\n  splay(x);\n  pushdown(x);\n  while (s[x][0]) pushdown(x = s[x][0]);\n  splay(x);\n  return x;\n}\ninline void split(int x, int y) {\n  mkrt(x);\n  ass(y);\n  splay(y);\n}\ninline void link(int x, int y) {\n  mkrt(x);\n  if (fdrt(y) != x) f[x] = y;\n}\ninline void cut(int x, int y) {\n  mkrt(x);\n  if (fdrt(y) != x || f[y] != x || s[y][0]) return;\n  f[y] = s[x][1] = 0;\n  pushup(x);\n}\ninline void mksbt(int x) {\n  if (!x) return;\n  if (x > n) flg[x] = 1;\n  mksbt(s[x][0]), mksbt(s[x][1]);\n  pushup(x);\n}\nconst int mod = 998244353;\nint main() {\n  while (T--) {\n    read(n), read(q);\n    cnt = n;\n    while (q--) {\n      read(u), read(v), read(opt);\n      if (fdrt(u) != fdrt(v)) {\n        puts(\"YES\");\n        ++cnt;\n        val[cnt] = opt;\n        link(u, cnt), link(v, cnt);\n      } else {\n        split(u, v);\n        if ((tmp[v] ^ opt) && !vis[v]) {\n          mksbt(v);\n          puts(\"YES\");\n        } else\n          puts(\"NO\");\n      }\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nconst int N = 1e6 + 10;\nconst long long mod = 1e9 + 7;\nconst long long inf = 8e18;\nconst int LOG = 20;\nlong long pw(long long a, long long b, long long M = mod, long long ret = 1) {\n  while (b) {\n    ret = ret * (b & 1 ? a : 1) % M, a = a * a % M, b >>= 1;\n  }\n  return ret;\n}\nint n, q, ptr, Ans[N], fir[N], sec[N], X[N], par[N], P[LOG][N], Xor[N], St[N],\n    Fi[N], H[N];\nvector<int> G[N];\nint get(int x) { return (x == par[x] ? x : par[x] = get(par[x])); }\nint unify(int v, int u) {\n  v = get(v), u = get(u);\n  if (v == u) return 0;\n  par[u] = v;\n  return 1;\n}\nvoid dfs(int v) {\n  St[v] = ++ptr;\n  for (int T = 1; T < LOG; T++) {\n    P[T][v] = P[T - 1][P[T - 1][v]];\n  }\n  for (auto id : G[v]) {\n    int u = fir[id] ^ sec[id] ^ v;\n    if (St[u]) continue;\n    H[u] = H[v] + 1;\n    P[0][u] = v;\n    Xor[u] = Xor[v] ^ X[id];\n    dfs(u);\n  }\n  Fi[v] = ptr;\n}\ninline int LCA(int v, int u) {\n  if (H[v] > H[u]) swap(u, v);\n  int del = H[u] - H[v];\n  for (int T = LOG - 1; ~T; T--) {\n    if (del >> T & 1) {\n      u = P[T][u];\n    }\n  }\n  if (v == u) return v;\n  for (int T = LOG - 1; ~T; T--) {\n    if (P[T][v] != P[T][u]) {\n      v = P[T][v];\n      u = P[T][u];\n    }\n  }\n  return P[0][v];\n}\nint seg[N << 2], lz[N << 2];\nvoid upd(int l, int r, int x, int v = 1, int tl = 1, int tr = n) {\n  if (l > tr || r < tl || l > r) return;\n  if (l <= tl && tr <= r) {\n    seg[v] = max(seg[v], x);\n    lz[v] = max(lz[v], x);\n    return;\n  }\n  int mid = (tl + tr) >> 1;\n  upd(l, r, x, v << 1, tl, mid), upd(l, r, x, v << 1 | 1, mid + 1, tr);\n  seg[v] = max(seg[v << 1], seg[v << 1 | 1]);\n}\nint ask(int p, int v = 1, int tl = 1, int tr = n) {\n  if (tl == tr) {\n    return seg[v];\n  }\n  int mid = (tl + tr) >> 1;\n  if (p <= mid) return max(lz[v], ask(p, v << 1, tl, mid));\n  return max(lz[v], ask(p, v << 1 | 1, mid + 1, tr));\n}\nint main() {\n  iota(par, par + N, 0);\n  scanf(\"%d%d\", &n, &q);\n  for (int i = 1; i <= q; i++) {\n    scanf(\"%d%d%d\", &fir[i], &sec[i], &X[i]);\n    if (unify(fir[i], sec[i])) {\n      Ans[i] = 1;\n      G[fir[i]].push_back(i);\n      G[sec[i]].push_back(i);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!St[i]) {\n      dfs(i);\n    }\n  }\n  for (int i = 1; i <= q; i++) {\n    if (Ans[i]) continue;\n    int lca = LCA(fir[i], sec[i]);\n    if ((Xor[fir[i]] ^ Xor[sec[i]] ^ X[i]) == 0) {\n      continue;\n    }\n    int v = fir[i], u = sec[i];\n    if (ask(St[v]) <= H[lca] && ask(St[u]) <= H[lca]) {\n      Ans[i] = 1;\n      while (v ^ u) {\n        if (H[u] < H[v]) {\n          swap(u, v);\n        }\n        upd(St[u], Fi[u], H[u]);\n        u = P[0][u];\n      }\n    }\n  }\n  for (int i = 1; i <= q; i++) {\n    if (Ans[i]) {\n      printf(\"YES\\n\");\n    } else {\n      printf(\"NO\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T1, class T2>\ninline void upd1(T1& a, const T2& b) {\n  a = a < b ? a : b;\n}\ntemplate <class T1, class T2>\ninline void upd2(T1& a, const T2& b) {\n  a = b < a ? a : b;\n}\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nstruct Ano {\n  operator long long() {\n    long long x = 0, y = 0, c = getchar();\n    while (c < 48) {\n      y = c == 45;\n      c = getchar();\n    }\n    while (c > 47) {\n      x = x * 10 + c - 48;\n      c = getchar();\n    }\n    return y ? -x : x;\n  }\n} buf;\nconstexpr int N = 6e5 + 5;\nint n;\nstruct vec {\n  bool c, w;\n  vec() {}\n  vec(bool c, bool w) : c(c), w(w) {}\n};\nvec operator+(vec a, vec b) { return vec(a.c | b.c, a.w ^ b.w); }\nstruct node;\ntypedef node* ptr;\nstruct node {\n  ptr i, j, p;\n  bool r;\n  vec v, s;\n  node();\n  ptr up() {\n    s = i->s + v + j->s;\n    return this;\n  }\n  void down() {\n    if (r) i->r ^= 1, j->r ^= 1, swap(i, j), r = 0;\n  }\n} e[N];\nnode::node() { i = j = p = e; }\nbool root(ptr o) { return o != o->p->i && o != o->p->j; }\nvoid turn(ptr o) {\n  ptr s = o->p, t = s->p;\n  if (!root(s)) (s == t->i ? t->i : t->j) = o;\n  s->p = o, o->p = t;\n  if (o == s->i)\n    s->i = o->j, o->j->p = s, o->j = s->up();\n  else\n    s->j = o->i, o->i->p = s, o->i = s->up();\n}\nvoid push(ptr o) {\n  if (!root(o)) push(o->p);\n  o->down();\n}\nptr splay(ptr o) {\n  push(o);\n  while (!root(o)) {\n    if (!root(o->p)) turn(o == o->p->i ^ o->p == o->p->p->i ? o : o->p);\n    turn(o);\n  }\n  return o->up();\n}\nptr exp(ptr o) {\n  ptr s = e;\n  while (o != e) splay(o)->j = s, s = o->up(), o = o->p;\n  return s;\n}\nvoid cov(ptr o) {\n  if (o != e) {\n    if (o - e > n) {\n      o->v.c = 1;\n    }\n    cov(o->i);\n    cov(o->j);\n    o->up();\n  }\n}\nint main() {\n  n = buf;\n  int m = n;\n  for (int q = buf; q; --q) {\n    int u = buf, v = buf, w = buf;\n    exp(e + u)->r = 1;\n    ptr o = exp(e + v);\n    while (o->i != e) {\n      o = o->i, o->down();\n    }\n    bool a = 1;\n    if (splay(o) != e + u) {\n      e[++m].v = vec(0, w);\n      splay(e + u)->p = e + m;\n      e[m].p = e + v;\n    } else {\n      if (!o->s.c && o->s.w ^ w) {\n        cov(o);\n      } else {\n        a = 0;\n      }\n    }\n    puts(a ? \"YES\" : \"NO\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nclass BinaryIndexedTree {\n private:\n  static const int N = 3e5 + 2;\n  int n;\n  int c[N];\n\n public:\n  void Build(int n) {\n    this->n = n;\n    for (int i = 0; i <= n; i++) c[i] = 0;\n  }\n  void Add(int x, int v) {\n    for (x++; x <= n; x += x & -x) c[x] += v;\n  }\n  T Sum(int x) {\n    T ret = 0;\n    for (x++; x; x -= x & -x) ret += c[x];\n    return ret;\n  }\n};\nclass DisjointSet {\n private:\n  int n;\n  vector<int> pa;\n\n public:\n  void Build(int n) {\n    this->n = n;\n    pa.resize(n);\n    for (int i = 0; i < n; i++) pa[i] = i;\n  }\n  int Find(int x) { return x == pa[x] ? x : pa[x] = Find(pa[x]); }\n  bool Union(int x, int y) {\n    int fx = Find(x), fy = Find(y);\n    if (fx == fy) return false;\n    pa[fx] = fy;\n    return true;\n  }\n};\nconst int N = 3e5, Q = 5e5;\nint n;\nvector<int> eids[N];\nvector<int> qids[N];\nint f[N];\nint fa[N], pre[N], post[N];\nint dfs_clock;\nDisjointSet ds;\nint U[Q], V[Q], x[Q];\nint lca[Q];\nbool ans[Q];\nBinaryIndexedTree<int> bit;\nvoid dfs(int u) {\n  pre[u] = dfs_clock++;\n  for (int i : eids[u]) {\n    int v = u ^ U[i] ^ V[i];\n    if (v == fa[u]) continue;\n    f[v] = f[u] ^ x[i];\n    fa[v] = u;\n    dfs(v);\n    ds.Union(v, u);\n  }\n  for (int i : qids[u]) {\n    int v = u ^ U[i] ^ V[i];\n    int fv = ds.Find(v);\n    if (v != fv) lca[i] = fv;\n  }\n  post[u] = dfs_clock;\n}\nint main() {\n  cin.tie(0), cout.tie(0);\n  ios::sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  ds.Build(n);\n  for (int i = 0; i < q; i++) {\n    cin >> U[i] >> V[i] >> x[i];\n    U[i]--, V[i]--;\n    if (ds.Union(U[i], V[i])) {\n      ans[i] = true;\n      eids[U[i]].push_back(i);\n      eids[V[i]].push_back(i);\n    } else {\n      qids[U[i]].push_back(i);\n      qids[V[i]].push_back(i);\n    }\n  }\n  ds.Build(n);\n  for (int i = 0; i < n; i++) fa[i] = -1, f[i] = 0;\n  for (int i = 0; i < n; i++)\n    if (fa[i] == -1) dfs(i);\n  bit.Build(n + 1);\n  for (int i = 0; i < q; i++) {\n    if (ans[i]) continue;\n    int u = U[i], v = V[i];\n    if ((x[i] ^ f[u] ^ f[v]) != 1) continue;\n    int s = bit.Sum(pre[lca[i]]);\n    if (bit.Sum(pre[u]) != s || bit.Sum(pre[v]) != s) continue;\n    ans[i] = true;\n    for (int pt : {u, v}) {\n      for (int j = pt; j != lca[i]; j = fa[j]) {\n        bit.Add(pre[j], +1);\n        bit.Add(post[j], -1);\n      }\n    }\n  }\n  for (int i = 0; i < q; i++) puts(ans[i] ? \"YES\" : \"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 3e5;\nlong long pr[maxn];\nvector<long long> g[maxn];\nlong long tin[maxn];\nlong long tout[maxn];\nlong long timer = 0;\nconst long long mx = 20;\nlong long pred[maxn][mx];\nbool used[maxn];\nvector<long long> euler;\npair<long long, long long> t[maxn * 4 * 2];\nvoid make_set(long long n) {\n  for (long long i = 0; i < n; ++i) {\n    pr[i] = i;\n  }\n}\nlong long find_set(long long v) {\n  if (pr[v] == v) return v;\n  return pr[v] = find_set(pr[v]);\n}\nvoid unic(long long a, long long b) {\n  a = find_set(a);\n  b = find_set(b);\n  pr[a] = b;\n}\nvoid dfs(long long v, long long p) {\n  euler.push_back(v);\n  tin[v] = timer++;\n  pred[v][0] = p;\n  used[v] = true;\n  for (long long j = 1; j < mx; ++j) {\n    pred[v][j] = pred[pred[v][j - 1]][j - 1];\n  }\n  for (long long i = 0; i < g[v].size(); ++i) {\n    long long to = g[v][i];\n    if (to == p) continue;\n    dfs(to, v);\n  }\n  tout[v] = timer++;\n  euler.push_back(v);\n}\nbool ispredok(long long fath, long long son) {\n  return tin[fath] <= tin[son] && tout[fath] >= tout[son];\n}\nlong long lca(long long a, long long b) {\n  if (ispredok(a, b)) return a;\n  if (ispredok(b, a)) return b;\n  for (long long i = mx - 1; i >= 0; --i) {\n    if (!ispredok(pred[a][i], b)) {\n      a = pred[a][i];\n    }\n  }\n  return pred[a][0];\n}\nvoid upd(long long v, long long tl, long long tr, long long pos,\n         pair<long long, long long> val) {\n  if (tl == tr) {\n    t[v].first += val.first;\n    t[v].second += val.second;\n  } else {\n    long long tm = (tl + tr) / 2;\n    if (pos <= tm) {\n      upd(v * 2, tl, tm, pos, val);\n    } else {\n      upd(v * 2 + 1, tm + 1, tr, pos, val);\n    }\n    t[v] = {t[v * 2].first + t[v * 2 + 1].first,\n            t[v * 2].second + t[v * 2 + 1].second};\n  }\n}\npair<long long, long long> get(long long v, long long tl, long long tr,\n                               long long l, long long r) {\n  if (tl > r || tr < l) {\n    return {0, 0};\n  }\n  if (l <= tl && tr <= r) {\n    return t[v];\n  }\n  long long tm = (tl + tr) / 2;\n  auto a1 = get(v * 2, tl, tm, l, r);\n  auto a2 = get(v * 2 + 1, tm + 1, tr, l, r);\n  return {a1.first + a2.first, a1.second + a2.second};\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie();\n  cout.tie();\n  long long n, q;\n  cin >> n >> q;\n  make_set(n);\n  vector<pair<pair<long long, long long>, long long>> qw(q);\n  for (long long i = 0; i < q; ++i) {\n    long long u, v, x;\n    cin >> u >> v >> x;\n    u--;\n    v--;\n    qw[i] = {{u, v}, x};\n    if (find_set(u) == find_set(v)) {\n      continue;\n    } else {\n      g[u].push_back(v);\n      g[v].push_back(u);\n      unic(u, v);\n    }\n  }\n  for (long long k = 0; k < n; ++k) {\n    if (used[k]) continue;\n    dfs(k, k);\n  }\n  for (long long j = 0; j < q; ++j) {\n    long long u = qw[j].first.first;\n    long long v = qw[j].first.second;\n    long long x = qw[j].second;\n    long long l = lca(u, v);\n    if (pred[u][0] == v) {\n      cout << \"YES\\n\";\n      long long tmp = 1;\n      if (x == 0) tmp = 0;\n      upd(1, 0, 2 * n - 1, tin[u], {tmp, 0});\n      upd(1, 0, 2 * n - 1, tout[u], {-tmp, 0});\n      continue;\n    }\n    if (pred[v][0] == u) {\n      cout << \"YES\\n\";\n      long long tmp = 1;\n      if (x == 0) tmp = 0;\n      upd(1, 0, 2 * n - 1, tin[v], {tmp, 0});\n      upd(1, 0, 2 * n - 1, tout[v], {-tmp, 0});\n      continue;\n    }\n    auto o1 = get(1, 0, 2 * n - 1, 0, tin[u]);\n    auto o2 = get(1, 0, 2 * n - 1, 0, tin[v]);\n    auto o3 = get(1, 0, 2 * n - 1, 0, tin[l]);\n    long long s1 = o1.first + o2.first - o3.first * 2;\n    long long s2 = o1.second + o2.second - o3.second * 2;\n    if ((s1 + x) % 2 == 0) {\n      cout << \"NO\\n\";\n      continue;\n    }\n    if (s2 > 0) {\n      cout << \"NO\\n\";\n      continue;\n    }\n    cout << \"YES\\n\";\n    while (v != l) {\n      long long tmp = 1;\n      upd(1, 0, 2 * n - 1, tin[v], {0, tmp});\n      upd(1, 0, 2 * n - 1, tout[v], {0, -tmp});\n      v = pred[v][0];\n    }\n    while (u != l) {\n      long long tmp = 1;\n      upd(1, 0, 2 * n - 1, tin[u], {0, tmp});\n      upd(1, 0, 2 * n - 1, tout[u], {0, -tmp});\n      u = pred[u][0];\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 800005;\nint n;\nvector<int> tree(4 * N, 0);\nvector<int> lazy(4 * N, 0);\nvoid apply(int idx, int x) {\n  tree[idx] += x;\n  lazy[idx] += x;\n}\nvoid push(int idx) {\n  for (int i = 0; i < 2; i++) apply(2 * idx + i, lazy[idx]);\n  lazy[idx] = 0;\n}\nvoid update(int idx, int l, int r, int ql, int qr, int x) {\n  if (ql > qr) return;\n  if (l == ql && r == qr)\n    apply(idx, x);\n  else {\n    int m = (l + r) / 2;\n    push(idx);\n    update(2 * idx, l, m, ql, min(qr, m), x);\n    update(2 * idx + 1, m + 1, r, max(ql, m + 1), qr, x);\n    tree[idx] = max(tree[2 * idx], tree[2 * idx + 1]);\n  }\n}\nint query(int idx, int l, int r, int ql, int qr) {\n  if (ql > qr) return 0;\n  if (l == ql && r == qr) return tree[idx];\n  int m = (l + r) / 2;\n  push(idx);\n  return max(query(2 * idx, l, m, ql, min(qr, m)),\n             query(2 * idx + 1, m + 1, r, max(ql, m + 1), qr));\n}\nvector<int> v[N];\nvector<int> p(N, 0);\nvector<int> depth(N, 0);\nvector<int> sz(N, 0);\nvector<int> big(N, 0);\nvector<int> head(N, 0);\nvector<int> pos(N, 0);\nint hidx = 0;\nvoid dfs(int a) {\n  depth[a] = depth[p[a]] + 1;\n  sz[a] = 1;\n  for (int to : v[a]) {\n    if (to == p[a]) continue;\n    p[to] = a;\n    dfs(to);\n    sz[a] += sz[to];\n    if (sz[to] > sz[big[a]]) big[a] = to;\n  }\n}\nvoid decompose(int a, int h) {\n  head[a] = h;\n  pos[a] = ++hidx;\n  if (big[a] != 0) decompose(big[a], h);\n  for (int to : v[a])\n    if (to != p[a] && to != big[a]) decompose(to, to);\n}\nvoid upd(int a, int b) {\n  while (head[a] != head[b]) {\n    if (depth[head[a]] < depth[head[b]]) swap(a, b);\n    update(1, 1, n, pos[head[a]], pos[a], 1);\n    a = p[head[a]];\n  }\n  if (depth[a] < depth[b]) swap(a, b);\n  update(1, 1, n, pos[b] + 1, pos[a], 1);\n}\nbool qry(int a, int b) {\n  bool ok = 1;\n  while (head[a] != head[b]) {\n    if (depth[head[a]] < depth[head[b]]) swap(a, b);\n    ok &= (query(1, 1, n, pos[head[a]], pos[a]) == 0);\n    a = p[head[a]];\n  }\n  if (depth[a] < depth[b]) swap(a, b);\n  ok &= (query(1, 1, n, pos[b] + 1, pos[a]) == 0);\n  return ok;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int q;\n  cin >> n >> q;\n  vector<array<int, 3>> edges;\n  auto add_edge = [&](int a, int b, int x) { edges.push_back({a, b, x}); };\n  while (q--) {\n    int a, b, x;\n    cin >> a >> b >> x;\n    if (x == 1)\n      add_edge(a, b, 1);\n    else {\n      n++;\n      add_edge(a, n, 0);\n      add_edge(b, n, 1);\n    }\n  }\n  vector<int> dsu_p(n + 1, 0);\n  for (int i = 1; i <= n; i++) dsu_p[i] = i;\n  vector<int> dsu_sz(n + 1, 1);\n  function<int(int)> find_set = [&](int a) -> int {\n    if (dsu_p[a] == a)\n      return a;\n    else\n      return dsu_p[a] = find_set(dsu_p[a]);\n  };\n  auto merge_sets = [&](int a, int b) -> bool {\n    a = find_set(a);\n    b = find_set(b);\n    if (a == b) return 0;\n    if (dsu_sz[a] < dsu_sz[b]) swap(a, b);\n    dsu_p[b] = a;\n    dsu_sz[a] += dsu_sz[b];\n    return 1;\n  };\n  q = edges.size();\n  for (int i = 0; i < q; i++) {\n    int a = edges[i][0];\n    int b = edges[i][1];\n    if (merge_sets(a, b)) {\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (depth[i] == 0) {\n      dfs(i);\n      decompose(i, i);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    dsu_p[i] = i;\n    dsu_sz[i] = 1;\n  }\n  for (auto [a, b, x] : edges) {\n    bool res = 0;\n    if (merge_sets(a, b))\n      res = 1;\n    else {\n      res = ((depth[a] & 1) == (depth[b] & 1) && qry(a, b));\n      if (res) upd(a, b);\n    }\n    if (x) {\n      if (res)\n        cout << \"YES\\n\";\n      else\n        cout << \"NO\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\n#pragma comment(linker, \"/STACK:16777216\")\nusing namespace std;\nconst int INF = 1000000000 + 1e8;\nconst long long LINF = 2000000000000000000;\nconst int N = 3e5 + 1010;\nint p[N];\nint sz[N];\nint find_set(int v) {\n  if (v == p[v]) return v;\n  return p[v] = find_set(p[v]);\n}\nvoid union_set(int a, int b) {\n  a = find_set(a);\n  b = find_set(b);\n  if (a != b) {\n    if (sz[a] < sz[b]) swap(a, b);\n    p[b] = a;\n    sz[a] += sz[b];\n  }\n}\nstruct edge {\n  int u, v, w;\n};\nvector<vector<pair<int, int>>> g;\nconst int LOG = 20;\nint n, q;\nvector<int> lvl;\nvector<vector<int>> jump;\nvector<int> par;\nvector<int> xr;\nvector<bool> used;\nvoid dfs1(int v, int p = -1) {\n  used[v] = true;\n  par[v] = p;\n  for (auto to : g[v])\n    if (to.first != p) dfs1(to.first, v);\n}\nvoid dfs(int v, int level = 0, int p = 0, int xorik = 0) {\n  used[v] = true;\n  lvl[v] = level;\n  jump[v][0] = p;\n  xr[v] = xorik;\n  for (auto to : g[v])\n    if (to.first != p) dfs(to.first, level + 1, v, xorik ^ to.second);\n}\nvoid InitJump() {\n  for (int j = 1; j < LOG; j++)\n    for (int v = 0; v < n; v++) jump[v][j] = jump[jump[v][j - 1]][j - 1];\n}\nint lca(int u, int v) {\n  if (lvl[u] > lvl[v]) swap(u, v);\n  for (int k = LOG - 1; k >= 0; k--)\n    if (lvl[jump[v][k]] >= lvl[u]) v = jump[v][k];\n  if (v == u) return u;\n  for (int k = LOG - 1; k >= 0; k--)\n    if (jump[v][k] != jump[u][k]) {\n      v = jump[v][k];\n      u = jump[u][k];\n    }\n  return jump[u][0];\n}\nint dist(int u, int v) { return xr[u] ^ xr[v]; }\nvector<int> euler;\nvoid dfs2(int v, int p = -1) {\n  used[v] = true;\n  euler.push_back(v);\n  for (auto to : g[v])\n    if (to.first != p) dfs2(to.first, v);\n  euler.push_back(v);\n}\nvector<int> first;\nvector<int> last;\nvector<int> fenw;\nint pref(int r) {\n  int res = 0;\n  for (; r >= 0; r = (r & (r + 1)) - 1) res += fenw[r];\n  return res;\n}\nvoid inc(int i, int val) {\n  for (; i < int(fenw.size()); i = (i | (i + 1))) fenw[i] += val;\n}\nvoid init_euler() {\n  first.resize(n);\n  last.resize(n);\n  fill((first).begin(), (first).end(), -1);\n  fill((last).begin(), (last).end(), -1);\n  for (int i = 0; i < int(euler.size()); i++) {\n    if (first[euler[i]] == -1) {\n      first[euler[i]] = i;\n    } else\n      last[euler[i]] = i;\n  }\n}\nvoid print(vector<int> a) {\n  for (auto to : a) cout << to << ' ';\n  cout << '\\n';\n}\nvector<bool> marked;\nvoid mark_verts(int u, int v) {\n  int lc = lca(u, v);\n  for (int t = u; t != lc; t = par[t]) {\n    inc(first[t], 1);\n    inc(last[t], -1);\n  }\n  for (int t = v; t != lc; t = par[t]) {\n    inc(first[t], 1);\n    inc(last[t], -1);\n  }\n}\nbool ok(int u, int v) {\n  int lc = lca(u, v);\n  int sum = pref(first[u]) - 2 * pref(first[lc]) + pref(first[v]);\n  return sum == 0;\n}\nvoid solve() {\n  cin >> n >> q;\n  for (int i = 0; i < n; i++) {\n    p[i] = i, sz[i] = 1;\n  }\n  vector<edge> qr(q);\n  vector<edge> norm;\n  vector<bool> done(q);\n  vector<string> ans(q, \"NO\");\n  used.resize(n);\n  for (int i = 0; i < q; i++) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    u--, v--;\n    qr[i] = {u, v, w};\n    if (find_set(u) != find_set(v)) {\n      norm.push_back({u, v, w});\n      union_set(u, v);\n      done[i] = true;\n      ans[i] = \"YES\";\n    }\n  }\n  g.resize(n);\n  xr.resize(n);\n  marked.resize(n);\n  lvl.resize(n);\n  par.resize(n);\n  jump = vector<vector<int>>(n, vector<int>(LOG));\n  for (auto to : norm) {\n    int u = to.u;\n    int v = to.v;\n    int w = to.w;\n    g[u].push_back({v, w});\n    g[v].push_back({u, w});\n  }\n  for (int i = 0; i < n; i++) {\n    if (!used[i]) dfs(i, 0, i, 0);\n  }\n  fill((used).begin(), (used).end(), false);\n  for (int i = 0; i < n; i++) {\n    if (!used[i]) dfs1(i);\n  }\n  fill((used).begin(), (used).end(), false);\n  for (int i = 0; i < n; i++) {\n    if (!used[i]) dfs2(i);\n  }\n  fenw.resize(int(euler.size()));\n  init_euler();\n  InitJump();\n  for (int i = 0; i < q; i++) {\n    if (done[i])\n      continue;\n    else {\n      int u = qr[i].u;\n      int v = qr[i].v;\n      int w = qr[i].w;\n      if (!ok(u, v)) {\n        continue;\n      } else {\n        if (dist(u, v) ^ w == 1) {\n          mark_verts(u, v);\n          ans[i] = \"YES\";\n        } else\n          continue;\n      }\n    }\n  }\n  for (auto to : ans) cout << to << '\\n';\n}\nint main() {\n  srand(time(0));\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int tst = 1;\n  while (tst--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-7;\nconst double PI = acos(-1);\nconst int MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst int N = 5e5 + 7;\nstruct DSU {\n  vector<int> fa;\n  void init(int n) {\n    fa = vector<int>(n + 1);\n    iota(fa.begin(), fa.end(), 0);\n  }\n  int get(int s) { return s == fa[s] ? s : fa[s] = get(fa[s]); }\n  int &operator[](int i) { return fa[get(i)]; }\n  bool merge(int x, int y) {\n    x = get(x);\n    y = get(y);\n    return x == y ? false : (fa[x] = y, true);\n  }\n};\nstruct BIT {\n  static const int SIZE = N;\n  long long bit1[SIZE], bit2[SIZE];\n  int limit;\n  void init(int n = SIZE - 1) {\n    limit = n;\n    for (int i = 1; i <= n; i++) bit1[i] = bit2[i] = 0;\n  }\n  BIT() { init(); }\n  void add(long long *bit, int x, long long v) {\n    while (x <= limit) bit[x] += v, x += x & -x;\n  }\n  long long query(long long *bit, int x) {\n    long long res = 0;\n    while (x) res += bit[x], x -= x & -x;\n    return res;\n  }\n  void add(int x, long long v) { add(x, x, v); }\n  void add(int l, int r, long long v) {\n    add(bit1, l, v);\n    add(bit2, l, v * l);\n    add(bit1, r + 1, -v);\n    add(bit2, r + 1, -v * (r + 1));\n  }\n  long long query(int x) { return query(x, x); }\n  long long query(int l, int r) {\n    return (r + 1) * query(bit1, r) - query(bit2, r) - l * query(bit1, l - 1) +\n           query(bit2, l - 1);\n  }\n};\ntemplate <typename T>\nstruct HLD {\n  int dfn;\n  int fa[N], d[N], num[N], son[N], id[N], tp[N];\n  vector<pair<int, int> > *e;\n  BIT t_xor, t_sum;\n  void build(vector<pair<int, int> > e[], const int &rt = 1) {\n    this->e = e;\n    fa[rt] = 0;\n    dfs1(rt);\n    dfs2(rt);\n  }\n  void dfs1(const int &u = 1) {\n    d[u] = d[fa[u]] + 1;\n    num[u] = 1;\n    son[u] = 0;\n    for (auto p : e[u]) {\n      int v = p.first;\n      if (v == fa[u]) continue;\n      fa[v] = u;\n      dfs1(v);\n      num[u] += num[v];\n      if (num[v] > num[son[u]]) son[u] = v;\n    }\n  }\n  void dfs2(const int &u = 1) {\n    tp[u] = son[fa[u]] == u ? tp[fa[u]] : u;\n    id[u] = ++dfn;\n    if (son[u]) dfs2(son[u]);\n    for (auto p : e[u]) {\n      int v = p.first;\n      int w = p.second;\n      if (v == fa[u]) continue;\n      if (v != son[u]) dfs2(v);\n      t_xor.add(id[v], w);\n    }\n  }\n  void add(int x, int y, const T &k, const int &is_edge = 1) {\n    while (tp[x] != tp[y]) {\n      if (d[tp[x]] < d[tp[y]]) swap(x, y);\n      t_sum.add(id[tp[x]], id[x], k);\n      x = fa[tp[x]];\n    }\n    if (d[x] > d[y]) swap(x, y);\n    t_sum.add(id[x], id[y], k);\n    if (is_edge) t_sum.add(id[x], -k);\n  }\n  T query(int x, int y, int is_edge = 1) {\n    T q_xor = 0, q_sum = 0;\n    while (tp[x] != tp[y]) {\n      if (d[tp[x]] < d[tp[y]]) swap(x, y);\n      q_xor += t_xor.query(id[tp[x]], id[x]);\n      q_sum += t_sum.query(id[tp[x]], id[x]);\n      x = fa[tp[x]];\n    }\n    if (d[x] > d[y]) swap(x, y);\n    q_xor += t_xor.query(id[x], id[y]);\n    q_sum += t_sum.query(id[x], id[y]);\n    if (is_edge) {\n      q_xor -= t_xor.query(id[x]);\n      q_sum -= t_sum.query(id[x]);\n    }\n    if (q_sum) return -1;\n    return q_xor & 1;\n  }\n};\nint n, q;\nint u[N], v[N], w[N], res[N];\nvector<int> qset[N];\nvector<pair<int, int> > e[N];\nDSU dsu;\nHLD<int> tree;\nvoid fuck(int i) {\n  if (res[i] == -1) {\n    int x = tree.query(u[i], v[i], 1);\n    if (x == -1 || w[i] == x)\n      res[i] = 0;\n    else\n      res[i] = 1, tree.add(u[i], v[i], 1, 1);\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  cin >> n >> q;\n  dsu.init(n);\n  for (int i = 1; i <= q; ++i) {\n    cin >> u[i] >> v[i] >> w[i];\n    res[i] = -1;\n    if (dsu.merge(u[i], v[i])) {\n      res[i] = 1;\n      e[u[i]].emplace_back(v[i], w[i]);\n      e[v[i]].emplace_back(u[i], w[i]);\n    }\n  }\n  for (int i = 1; i <= q; ++i) {\n    assert(dsu[u[i]] == dsu[v[i]]);\n    qset[dsu[u[i]]].emplace_back(i);\n  }\n  tree.t_xor.init(n);\n  tree.t_sum.init(n);\n  for (int i = 1; i <= n; ++i)\n    if (qset[i].size()) {\n      tree.build(e, i);\n      for (int j : qset[i]) fuck(j);\n    }\n  for (int i = 1; i <= q; ++i) {\n    cout << (res[i] ? \"YES\" : \"NO\") << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Random;\nimport java.util.Stack;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Vector;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author sarthakmanna\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FGoodGraph solver = new FGoodGraph();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FGoodGraph {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int i, j, k;\n\n            int N = in.nextInt(), M = in.nextInt();\n            ArrayList<Integer>[] graph = new ArrayList[N];\n            for (i = 0; i < N; ++i) graph[i] = new ArrayList<>();\n\n            ArrayList<Edge> tree = new ArrayList<>(), cycle = new ArrayList<>();\n            DSU dsu = new DSU(N);\n            boolean[] ans = new boolean[M];\n            for (i = 0; i < M; ++i) {\n                Edge edge = new Edge(i, in.nextInt() - 1, in.nextInt() - 1, in.nextInt());\n                if (dsu.isConnected(edge.getU(), edge.getV())) {\n                    cycle.add(edge);\n                } else {\n                    dsu.addEdge(edge.getU(), edge.getV());\n                    graph[edge.getU()].add(edge.getV());\n                    graph[edge.getV()].add(edge.getU());\n\n                    tree.add(edge);\n                    ans[i] = true;\n                }\n            }\n\n            HashSet<Integer> roots = new HashSet<>();\n            boolean[] vis = new boolean[N];\n            for (i = 0; i < N; ++i)\n                if (!vis[i]) {\n                    roots.add(i);\n                    dfs(i, vis, graph);\n                }\n\n            HLD_LCA hld_lca = new HLD_LCA(tree.toArray(new Edge[tree.size()]), N, roots);\n            for (Edge edge : cycle) {\n                if ((edge.getWeight() ^ hld_lca.pathQuery(edge.getU(), edge.getV())) == 1) {\n                    ans[edge.i] = true;\n                    hld_lca.pathUpdate(edge.getU(), edge.getV(), +7);\n                }\n            }\n\n            for (boolean val : ans) out.println(val ? \"YES\" : \"NO\");\n        }\n\n        void dfs(int node, boolean[] v, ArrayList<Integer>[] graph) {\n            if (v[node]) return;\n            v[node] = true;\n            for (int itr : graph[node]) dfs(itr, v, graph);\n        }\n\n    }\n\n    static class Helper {\n        public final long MOD;\n        public final int MAXN;\n        final Random rnd;\n\n        public Helper() {\n            MOD = 1000_000_007;\n            MAXN = 1000_006;\n            rnd = new Random();\n        }\n\n        public Helper(long mod, int maxn) {\n            MOD = mod;\n            MAXN = maxn;\n            rnd = new Random();\n        }\n\n        public int getRandomInRange(int l, int r) {\n            return rnd.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class DSU {\n        int N;\n        int[] parent;\n        int[] size;\n\n        public DSU(int nodeCount) {\n            N = nodeCount;\n            parent = new int[nodeCount];\n            Arrays.fill(parent, -7);\n            size = new int[nodeCount];\n            Arrays.fill(size, 1);\n        }\n\n        public int getParent(int node) {\n            if (parent[node] < 0) return node;\n            else return parent[node] = getParent(parent[node]);\n        }\n\n        public boolean isConnected(int a, int b) {\n            return getParent(a) == getParent(b);\n        }\n\n        public void addEdge(int a, int b) {\n            a = getParent(a);\n            b = getParent(b);\n            if (a == b) {\n                return;\n            } else if (size[a] > size[b]) {\n                a ^= b;\n                b ^= a;\n                a ^= b;\n            }\n            parent[a] = b;\n            size[b] += size[a];\n            size[a] = -7;\n        }\n\n    }\n\n    static class FastReader {\n        static final int BUFSIZE = 1 << 20;\n        static byte[] buf;\n        static int index;\n        static int total;\n        static InputStream in;\n\n        public FastReader(InputStream is) {\n            try {\n                in = is;\n                buf = new byte[BUFSIZE];\n            } catch (Exception e) {\n            }\n        }\n\n        private int scan() {\n            try {\n                if (index >= total) {\n                    index = 0;\n                    total = in.read(buf);\n                    if (total <= 0)\n                        return -1;\n                }\n                return buf[index++];\n            } catch (Exception | Error e) {\n                System.err.println(e.getMessage());\n                return 13 / 0;\n            }\n        }\n\n        public int nextInt() {\n            int c, val = 0;\n            for (c = scan(); c <= 32; c = scan()) ;\n            boolean neg = c == '-';\n            if (c == '-' || c == '+')\n                c = scan();\n            for (; c >= '0' && c <= '9'; c = scan())\n                val = (val << 3) + (val << 1) + (c & 15);\n            return neg ? -val : val;\n        }\n\n    }\n\n    static class HLD_LCA {\n        static final int defaultValue = 0;\n        ArrayList<Integer>[] graph;\n        int[] depth;\n        int[] parent;\n        int[] chCount;\n        int[] queue;\n        int N;\n        int[] weight;\n        HashSet<Integer> roots;\n        SegmentTree st;\n        int[] treePos;\n        int[] linearTree;\n        int[] segRoot;\n\n        public HLD_LCA(Edge[] edges, int n, HashSet<Integer> r) {\n            int i;\n            N = n;\n            roots = r;\n\n            graph = new ArrayList[N];\n            for (i = 0; i < N; ++i) graph[i] = new ArrayList<>();\n\n            for (Edge e : edges) {\n                graph[e.u].add(e.v);\n                graph[e.v].add(e.u);\n            }\n            iterativeDFS();\n\n            weight = new int[N];\n            for (Edge e : edges) {\n                int child = depth[e.u] > depth[e.v] ? e.u : e.v;\n                weight[child] = e.weight;\n            }\n\n            HLDify();\n        }\n\n        public int operate(int a, int b) {\n            return a ^ b;\n        }\n\n        private void iterativeDFS() {\n            parent = new int[N];\n            depth = new int[N];\n            chCount = new int[N];\n            queue = new int[N];\n            Arrays.fill(chCount, 1);\n\n            int i, st = 0, end = 0;\n            for (int root : roots) {\n                parent[root] = -1;\n                depth[root] = 1;\n                queue[end++] = root;\n            }\n\n            while (st < end) {\n                int node = queue[st++], h = depth[node] + 1;\n                Iterator<Integer> itr = graph[node].iterator();\n                while (itr.hasNext()) {\n                    int ch = itr.next();\n                    if (depth[ch] > 0) continue;\n                    depth[ch] = h;\n                    parent[ch] = node;\n                    queue[end++] = ch;\n                }\n            }\n            for (i = N - 1; i >= 0; --i)\n                if (!roots.contains(queue[i]))\n                    chCount[parent[queue[i]]] += chCount[queue[i]];\n        }\n\n        private void HLDify() {\n            int i, j, treeRoot = -7;\n\n            treePos = new int[N];\n            linearTree = new int[N];\n            segRoot = new int[N];\n\n            Stack<Integer> stack = new Stack<>();\n            stack.ensureCapacity(N << 1);\n            stack.addAll(roots);\n            for (i = 0; !stack.isEmpty(); ++i) {\n                int node = stack.pop();\n                if (i == 0 || linearTree[i - 1] != parent[node])\n                    treeRoot = node;\n                linearTree[i] = node;\n                treePos[node] = i;\n                segRoot[node] = treeRoot;\n\n                int bigChild = -7, bigChildPos = -7, lastPos = graph[node].size() - 1;\n                for (j = 0; j < graph[node].size(); ++j) {\n                    int tempNode = graph[node].get(j);\n                    if (tempNode == parent[node]) continue;\n                    if (bigChild < 0 || chCount[bigChild] < chCount[tempNode]) {\n                        bigChild = tempNode;\n                        bigChildPos = j;\n                    }\n                }\n                if (bigChildPos >= 0) {\n                    int temp = graph[node].get(lastPos);\n                    graph[node].set(lastPos, bigChild);\n                    graph[node].set(bigChildPos, temp);\n                }\n\n                for (int itr : graph[node])\n                    if (parent[node] != itr)\n                        stack.push(itr);\n            }\n\n            int[] respectiveWeights = new int[N];\n            for (i = 0; i < N; ++i)\n                respectiveWeights[i] = weight[linearTree[i]];\n            st = new SegmentTree(respectiveWeights, 0, 0);\n        }\n\n        public int pathQuery(int node1, int node2) {\n            int ret = defaultValue, temp;\n            while (segRoot[node1] != segRoot[node2]) {\n                if (depth[segRoot[node1]] > depth[segRoot[node2]]) {\n                    node1 ^= node2;\n                    node2 ^= node1;\n                    node1 ^= node2;\n                }\n\n                temp = st.rangeQuery(treePos[segRoot[node2]], treePos[node2]);\n                ret = operate(ret, temp);\n                node2 = parent[segRoot[node2]];\n            }\n\n            if (treePos[node1] > treePos[node2]) {\n                node1 ^= node2;\n                node2 ^= node1;\n                node1 ^= node2;\n            }\n            temp = st.rangeQuery(treePos[node1] + 1, treePos[node2]);   // ...treePos[node1] + 1... for Edge Query\n            ret = operate(ret, temp);\n\n            return ret;\n        }\n\n        public void pathUpdate(int node1, int node2, int value) {\n            while (segRoot[node1] != segRoot[node2]) {\n                if (depth[segRoot[node1]] > depth[segRoot[node2]]) {\n                    node1 ^= node2;\n                    node2 ^= node1;\n                    node1 ^= node2;\n                }\n                st.rangeUpdate(treePos[segRoot[node2]], treePos[node2], value);\n                node2 = parent[segRoot[node2]];\n            }\n            if (treePos[node1] > treePos[node2]) {\n                node1 ^= node2;\n                node2 ^= node1;\n                node1 ^= node2;\n            }\n            st.rangeUpdate(treePos[node1] + 1, treePos[node2], value);     // ...treePos[node1] + 1... for Edge Update\n        }\n\n    }\n\n    static class SegmentTree {\n        int N;\n        int[] tree;\n        Helper hp = new Helper();\n\n        public SegmentTree(int[] ar, int def_node, int def_lazy) {\n            N = ar.length + 1;\n            tree = new int[N];\n\n            for (int i = 0; i < ar.length; ++i) pointUpdate(i, ar[i]);\n        }\n\n        public void pointUpdate(int idx, int val) {\n            ++idx;\n            while (idx < N) {\n                tree[idx] ^= val;\n                idx += idx & -idx;\n            }\n        }\n\n        public void rangeUpdate(int l, int r, int val) {\n            for (int i = l; i <= r; ++i) {\n                pointUpdate(i, hp.getRandomInRange(0, Integer.MAX_VALUE >> 1));\n            }\n        }\n\n        public int prefixQuery(int idx) {\n            ++idx;\n            int ret = 0;\n            while (idx > 0) {\n                ret ^= tree[idx];\n                idx -= idx & -idx;\n            }\n            return ret;\n        }\n\n        public int rangeQuery(int l, int r) {\n            int ret = prefixQuery(r);\n            if (l > 0) ret ^= prefixQuery(l - 1);\n            return ret;\n        }\n\n    }\n\n    static class Edge {\n        public int i;\n        public int u;\n        public int v;\n        int weight;\n\n        public int getU() {\n            return u;\n        }\n\n        public int getV() {\n            return v;\n        }\n\n        public int getWeight() {\n            return weight;\n        }\n\n        public Edge(int id, int a, int b, int wt) {\n            i = id;\n            u = a;\n            v = b;\n            weight = wt;\n        }\n\n        public String toString() {\n            return \"(\" + u + \", \" + v + \" -> \" + weight + \")\";\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T>\nvoid dout(string name, int idx, T arg) {\n  cerr << name << \" = \" << to_string(arg);\n}\ntemplate <typename T1, typename... T2>\nvoid dout(string names, int idx, T1 arg, T2... args) {\n  cerr << names.substr(0, names.find(',')) << \" = \" << to_string(arg) << \", \";\n  dout(names.substr(names.find(',') + 2), idx + 1, args...);\n}\nclass segtree {\n public:\n  struct node {\n    int sum = 0;\n    void apply(int l, int r, int v) { sum += v; }\n  };\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.sum = a.sum + b.sum;\n    return res;\n  }\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n  }\n  inline void pull(int x, int z) { tree[x] = unite(tree[x + 1], tree[z]); }\n  int n;\n  vector<node> tree;\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M &...v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n  int find_first_knowingly(int x, int l, int r,\n                           const function<bool(const node &)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n  int find_first(int x, int l, int r, int ll, int rr,\n                 const function<bool(const node &)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n  int find_last_knowingly(int x, int l, int r,\n                          const function<bool(const node &)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n  int find_last(int x, int l, int r, int ll, int rr,\n                const function<bool(const node &)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n  template <typename... M>\n  void modify(int ll, int rr, const M &...v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n  int find_first(int ll, int rr, const function<bool(const node &)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n  int find_last(int ll, int rr, const function<bool(const node &)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\nclass DSU {\n public:\n  vector<int> p;\n  int n;\n  DSU(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n  inline int get(int x) { return (x == p[x] ? x : (p[x] = get(p[x]))); }\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  vector<int> qu(q), qv(q), qx(q);\n  for (int i = 0; i < q; i++) {\n    cin >> qu[i] >> qv[i] >> qx[i];\n    --qu[i];\n    --qv[i];\n  }\n  DSU dsu(n);\n  vector<vector<pair<int, int>>> g(n);\n  vector<int> tree_edge(q);\n  for (int i = 0; i < q; i++) {\n    int u = qu[i], v = qv[i], x = qx[i];\n    if (dsu.unite(u, v)) {\n      g[u].push_back(make_pair(v, x));\n      g[v].push_back(make_pair(u, x));\n      tree_edge[i] = 1;\n    }\n  }\n  vector<int> was(n);\n  vector<vector<int>> parent(n, vector<int>(22, -1));\n  vector<int> tin(n), tout(n);\n  vector<int> who(2 * n);\n  int timer = 0;\n  vector<int> len(n);\n  vector<int> my_root(n);\n  int root = -1;\n  vector<int> depth(n);\n  function<void(int, int)> DFS = [&](int v, int pv) {\n    was[v] = 1;\n    assert(root != -1);\n    my_root[v] = root;\n    parent[v][0] = pv;\n    tin[v] = timer;\n    who[timer] = v;\n    ++timer;\n    for (const auto &e : g[v]) {\n      int u = e.first;\n      if (u == pv) {\n        continue;\n      }\n      len[u] = len[v] ^ e.second;\n      depth[u] = depth[v] + 1;\n      DFS(u, v);\n    }\n    tout[v] = timer;\n    ++timer;\n  };\n  for (int i = 0; i < n; i++) {\n    if (!was[i]) {\n      root = i;\n      DFS(i, -1);\n    }\n  }\n  segtree st(timer);\n  assert(timer == 2 * n);\n  for (int j = 1; j < 22; j++) {\n    for (int i = 0; i < n; i++) {\n      if (parent[i][j - 1] != -1) {\n        parent[i][j] = parent[parent[i][j - 1]][j - 1];\n      }\n    }\n  }\n  auto Length = [&](int u, int v) { return len[u] ^ len[v]; };\n  int lg = 21;\n  auto LCA = [&](int x, int y) {\n    if (depth[x] < depth[y]) {\n      swap(x, y);\n    }\n    for (int i = lg; i >= 0; i--) {\n      if (depth[x] - (1 << i) >= depth[y] && parent[x][i] != -1) {\n        x = parent[x][i];\n      }\n    }\n    if (x == y) {\n      return x;\n    }\n    for (int i = lg; i >= 0; i--) {\n      if (parent[x][i] != -1 && parent[y][i] != -1) {\n        if (parent[x][i] != parent[y][i]) {\n          x = parent[x][i];\n          y = parent[y][i];\n        }\n      }\n    }\n    assert(parent[x][0] == parent[y][0]);\n    return parent[x][0];\n  };\n  auto Used = [&](int x, int y, int lca) {\n    assert(my_root[x] == my_root[y]);\n    int from_x = st.get(tin[my_root[x]], tin[x]).sum;\n    int from_y = st.get(tin[my_root[y]], tin[y]).sum;\n    int from_lca = st.get(tin[my_root[lca]], tin[lca]).sum;\n    return from_x + from_y - 2 * from_lca > 0;\n  };\n  for (int m = 0; m < q; m++) {\n    if (!tree_edge[m]) {\n      int u = qu[m], v = qv[m], x = qx[m];\n      int lca = LCA(u, v);\n      if ((Length(u, v) ^ x) == 1 && !Used(u, v, lca)) {\n        while (u != lca) {\n          st.modify(tin[u], tin[u], +1);\n          st.modify(tout[u], tout[u], -1);\n          u = parent[u][0];\n        }\n        while (v != lca) {\n          st.modify(tin[v], tin[v], +1);\n          st.modify(tout[v], tout[v], -1);\n          v = parent[v][0];\n        }\n        cout << \"YES\" << '\\n';\n      } else {\n        cout << \"NO\" << '\\n';\n      }\n    } else {\n      cout << \"YES\" << '\\n';\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\ntemplate <typename T>\ninline void read(T &x) {\n  x = 0;\n  char c = getchar();\n  bool f = false;\n  for (; !isdigit(c); c = getchar()) f |= c == '-';\n  for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n  if (f) x = -x;\n}\ntemplate <typename T, typename... Arg>\ninline void read(T &x, Arg &...args) {\n  read(x);\n  read(args...);\n}\ntemplate <typename T>\ninline void write(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) write(x / 10);\n  putchar(x % 10 + '0');\n}\nconst int N = 1e6 + 100;\nint n, m;\nstruct Link_Cut_Tree {\n  int f[N], c[N][2], v[N], s[N], sz[N];\n  int ban[N], kk[N];\n  bool r[N], bt[N], tmp[N];\n  bool nroot(int x) { return c[f[x]][0] == x || c[f[x]][1] == x; }\n  void pushup(int x) {\n    s[x] = s[c[x][0]] ^ v[x] ^ s[c[x][1]];\n    tmp[x] = tmp[c[x][0]] || tmp[c[x][1]] || x > n;\n    kk[x] = kk[c[x][0]] || kk[c[x][1]] || ban[x];\n  }\n  void pushr(int x) {\n    swap(c[x][0], c[x][1]);\n    r[x] ^= 1;\n  }\n  void pushb(int x) {\n    kk[x] = tmp[x];\n    if (x > n) ban[x] = 1;\n    bt[x] = 1;\n  }\n  void pushdown(int x) {\n    if (r[x]) {\n      if (c[x][0]) pushr(c[x][0]);\n      if (c[x][1]) pushr(c[x][1]);\n      r[x] = 0;\n    }\n    if (bt[x]) {\n      if (c[x][0]) pushb(c[x][0]);\n      if (c[x][1]) pushb(c[x][1]);\n      bt[x] = 0;\n    }\n  }\n  void rotate(int x) {\n    int fa = f[x], ffa = f[fa], k = (c[f[x]][1] == x), w = c[x][!k];\n    if (nroot(fa)) c[ffa][(c[f[fa]][1] == fa)] = x;\n    c[x][!k] = fa;\n    c[fa][k] = w;\n    if (w) f[w] = fa;\n    f[fa] = x;\n    f[x] = ffa;\n    pushup(fa);\n  }\n  void splay(int x) {\n    int y = x, top = 0;\n    static int s[N];\n    s[++top] = (y);\n    while (nroot(y)) s[++top] = (y = f[y]);\n    while (top) pushdown(s[top--]);\n    while (nroot(x)) {\n      int fa = f[x], ffa = f[fa];\n      if (nroot(fa)) rotate((c[f[x]][1] == x) != (c[f[fa]][1] == fa) ? x : fa);\n      rotate(x);\n    }\n    pushup(x);\n  }\n  void access(int x) {\n    for (int y = 0; x; x = f[y = x]) splay(x), c[x][1] = y, pushup(x);\n  }\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    pushr(x);\n  }\n  void split(int x, int y) {\n    makeroot(x);\n    access(y);\n    splay(y);\n  }\n  bool link(int x, int y) {\n    makeroot(x);\n    f[x] = y;\n    return 0;\n  }\n} T;\nstruct DSU {\n  int fa[N];\n  int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\n} D;\nsigned main() {\n  read(n, m);\n  for (int i = 1; i <= n + m; i++) D.fa[i] = i;\n  for (int i = 1; i <= m; i++) {\n    int a, b;\n    read(a, b, T.v[i + n]);\n    T.s[i + n] = T.v[i + n];\n    T.makeroot(a);\n    if (D.find(a) != D.find(b)) {\n      T.link(a, i + n);\n      T.link(i + n, b);\n      D.fa[D.find(a)] = D.find(b);\n      puts(\"YES\");\n    } else {\n      T.split(a, b);\n      if (T.s[b] ^ T.v[i + n] && T.kk[b] == 0)\n        puts(\"YES\"), T.pushb(b);\n      else\n        puts(\"NO\");\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class A, class B>\nostream& operator<<(ostream& out, const pair<A, B>& p) {\n  return out << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <class A>\nostream& operator<<(ostream& out, const vector<A>& v) {\n  for (int i = int(0); i < int(int((v).size())); i++) {\n    if (i) out << \" \";\n    out << v[i];\n  }\n  return out;\n}\nconst int INF = int(1e9);\nconst long long INF64 = long long(1e18);\nint n, q;\nvector<array<int, 3> > es;\ninline bool read() {\n  if (!(cin >> n >> q)) return false;\n  es.resize(q);\n  for (int i = int(0); i < int(q); i++) {\n    cin >> es[i][0] >> es[i][1] >> es[i][2];\n    es[i][0]--;\n    es[i][1]--;\n  }\n  return true;\n}\nvector<vector<pair<int, int> > > g;\nconst int LOG = 19;\nvector<int> up[LOG];\nvector<int> tin, tout;\nvector<int> xr;\nint T = 0;\nvoid dfs(int v, int p, int curXor) {\n  tin[v] = T++;\n  xr[v] = curXor;\n  up[0][v] = p;\n  for (int pw = int(1); pw < int(LOG); pw++)\n    up[pw][v] = up[pw - 1][up[pw - 1][v]];\n  for (auto [to, w] : g[v]) {\n    if (to == p) continue;\n    dfs(to, v, curXor ^ w);\n  }\n  tout[v] = T;\n}\nvoid buildLCA() {\n  for (int pw = int(0); pw < int(LOG); pw++) up[pw].resize(n);\n  tin.assign(n, -1);\n  tout.assign(n, -1);\n  xr.assign(n, 0);\n  T = 0;\n  for (int v = int(0); v < int(n); v++) {\n    if (tin[v] != -1) continue;\n    dfs(v, v, 0);\n  }\n}\nint isPar(int p, int v) { return tin[p] <= tin[v] && tout[v] <= tout[p]; }\nint lca(int u, int v) {\n  if (isPar(u, v)) return u;\n  if (isPar(v, u)) return v;\n  for (int pw = LOG - 1; pw >= 0; pw--) {\n    if (!isPar(up[pw][v], u)) v = up[pw][v];\n  }\n  return up[0][v];\n}\nvector<int> par, rk;\nvoid init(int n) {\n  par.assign(n, 0);\n  iota(par.begin(), par.end(), 0);\n  rk.assign(n, 1);\n}\nint top(int v) {\n  if (par[v] != v) return par[v] = top(par[v]);\n  return v;\n}\nbool unite(int u, int v) {\n  u = top(u);\n  v = top(v);\n  if (u == v) return false;\n  if (rk[u] < rk[v]) swap(u, v);\n  par[v] = u;\n  rk[u] += rk[v];\n  return true;\n}\nvector<int> F;\nvoid inc(int pos, int val) {\n  for (; pos < int((F).size()); pos |= pos + 1) F[pos] += val;\n}\nint sum(int pos) {\n  int ans = 0;\n  for (; pos >= 0; pos = (pos & (pos + 1)) - 1) ans += F[pos];\n  return ans;\n}\nvoid addOnPath(int v, int l) {\n  while (v != l) {\n    inc(tin[v], 1);\n    inc(tout[v], -1);\n    v = up[0][v];\n  }\n}\ninline void solve() {\n  init(n);\n  g.resize(n);\n  vector<int> ans(q, -1);\n  for (int i = int(0); i < int(q); i++) {\n    int u = es[i][0];\n    int v = es[i][1];\n    int first = es[i][2];\n    if (unite(u, v)) {\n      ans[i] = 1;\n      g[u].emplace_back(v, first);\n      g[v].emplace_back(u, first);\n    }\n  }\n  buildLCA();\n  F.assign(2 * n + 5, 0);\n  for (int i = int(0); i < int(q); i++) {\n    if (ans[i] != -1) continue;\n    ans[i] = 0;\n    int u = es[i][0];\n    int v = es[i][1];\n    int first = es[i][2];\n    int xorPath = xr[u] ^ xr[v];\n    if ((xorPath ^ first) != 1) continue;\n    int l = lca(u, v);\n    int usedOnPath = sum(tin[u]) + sum(tin[v]) - 2 * sum(tin[l]);\n    if (usedOnPath > 0) continue;\n    ans[i] = 1;\n    addOnPath(u, l);\n    addOnPath(v, l);\n  }\n  for (int res : ans) cout << (res ? \"YES\" : \"NO\") << '\\n';\n}\nint main() {\n  cout << fixed << setprecision(15);\n  if (read()) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dsu {\n  vector<int> p;\n  dsu(int n) : p(n + 1, -1) {}\n  int root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n  bool join(int x, int y) {\n    if ((x = root(x)) == (y = root(y))) return 0;\n    if (p[y] < p[x]) swap(x, y);\n    p[x] += p[y];\n    p[y] = x;\n    return 1;\n  }\n};\nconst int nmax = 300030;\nint n, m, tin[nmax], tout[nmax], xr[nmax], anc[nmax][20], f[nmax];\nvector<tuple<int, int, int>> query;\nvector<pair<int, int>> adj[nmax];\nvoid dfs(int u, int p = 0, int d = 0) {\n  anc[u][0] = p;\n  for (int j = 1; j < 19; ++j) anc[u][j] = anc[anc[u][j - 1]][j - 1];\n  xr[u] = d;\n  tin[u] = ++*tin;\n  for (auto& x : adj[u]) {\n    if (x.second == p) continue;\n    dfs(x.second, u, d ^ x.first);\n  }\n  tout[u] = *tin;\n}\nbool isanc(int u, int v) { return tin[u] <= tin[v] && tout[v] <= tout[u]; }\nint lca(int u, int v) {\n  if (isanc(u, v)) return u;\n  if (isanc(v, u)) return v;\n  for (int j = 18; j >= 0; --j)\n    if (!isanc(anc[v][j], u)) v = anc[v][j];\n  return anc[v][0];\n}\nvoid inc(int x, int d) {\n  for (; x <= n; x += x & -x) f[x] += d;\n}\nint sum(int x) {\n  int ans = 0;\n  for (x = tin[x]; x > 0; x &= x - 1) ans += f[x];\n  return ans;\n}\nvoid add(int x, int p) {\n  for (; x != p; x = anc[x][0]) {\n    inc(tin[x], 1);\n    inc(tout[x] + 1, -1);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> m;\n  dsu d(n);\n  vector<int> choose(m, 0);\n  for (int i = (0), _b = (m - 1); i <= _b; ++i) {\n    int x, y, w;\n    cin >> x >> y >> w;\n    query.push_back(make_tuple(x, y, w));\n    if (d.join(x, y)) {\n      adj[x].push_back({w, y});\n      adj[y].push_back({w, x});\n      choose[i] = 1;\n    }\n  }\n  for (int i = (1), _b = (n); i <= _b; ++i)\n    if (!tin[i]) dfs(i);\n  tin[0] = 0;\n  tout[0] = 0x3f3f3f3f;\n  for (int i = (0), _b = (m - 1); i <= _b; ++i) {\n    int u, v, w;\n    tie(u, v, w) = query[i];\n    if (!(xr[u] ^ xr[v] ^ w)) continue;\n    int x = lca(u, v);\n    if (sum(u) + sum(v) - 2 * sum(x) > 0) continue;\n    choose[i] = 1;\n    add(u, x);\n    add(v, x);\n  }\n  for (int i = (0), _b = (m - 1); i <= _b; ++i)\n    cout << (choose[i] ? \"YES\" : \"NO\") << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 100;\nconst int mod = 1e9 + 7;\nvector<pair<int, int> > g[N];\nint dsu[N], rang[N], used[N];\nconst int T = 20;\nint up[T][N];\nint pred(int a) { return a == dsu[a] ? a : dsu[a] = pred(dsu[a]); }\nvoid unite(int a, int b) {\n  a = pred(a);\n  b = pred(b);\n  if (rang[a] > rang[b]) {\n    swap(a, b);\n  }\n  dsu[a] = b;\n  rang[b] += rang[a];\n}\nint _sz[N], pred_tree[N];\nint val[N];\nint timer = 0;\nint tin[N], tout[N];\nvoid dfs(int v, int p = -1) {\n  used[v] = 1;\n  _sz[v] = 1;\n  tin[v] = timer++;\n  for (auto to : g[v]) {\n    if (to.first == p) {\n      continue;\n    }\n    up[0][to.first] = v;\n    val[to.first] = val[v] ^ to.second;\n    pred_tree[to.first] = v;\n    dfs(to.first, v);\n    _sz[v] += _sz[to.first];\n  }\n  tout[v] = timer++;\n}\nint mass[N];\nint idx[N], st[N], en[N];\nint Tree[4 * N], Tree_push[4 * N];\nint it = 0, it1 = 0;\nvoid dfs1(int v, int p = -1) {\n  int maxv = -1;\n  for (auto to : g[v]) {\n    if (to.first == p) {\n      continue;\n    }\n    if (maxv == -1 || _sz[to.first] > _sz[maxv]) {\n      maxv = to.first;\n    }\n  }\n  if (maxv != -1) {\n    idx[maxv] = it;\n    mass[it++] = maxv;\n    st[maxv] = st[v];\n    dfs1(maxv, v);\n  }\n  for (auto to : g[v]) {\n    if (to.first == p || maxv == to.first) {\n      continue;\n    }\n    idx[to.first] = it;\n    st[to.first] = it;\n    mass[it++] = to.first;\n    dfs1(to.first, v);\n  }\n}\nbool pr(int a, int b) { return tin[a] <= tin[b] && tout[a] >= tout[b]; }\nvoid push(int v) {\n  Tree[v * 2] |= Tree_push[v];\n  Tree[v * 2 + 1] |= Tree_push[v];\n  Tree_push[v * 2] |= Tree_push[v];\n  Tree_push[v * 2 + 1] |= Tree_push[v];\n}\nint ask(int v, int l, int r, int al, int ar) {\n  if (l >= al && r <= ar) {\n    return Tree[v];\n  }\n  if (l <= ar && r >= al) {\n    push(v);\n    return ask(v * 2, l, (r + l) / 2, al, ar) +\n           ask(v * 2 + 1, (r + l) / 2 + 1, r, al, ar);\n  }\n  return 0;\n}\nvoid update(int v, int l, int r, int al, int ar) {\n  if (l >= al && r <= ar) {\n    Tree[v] = 1;\n    Tree_push[v] = 1;\n  } else if (l <= ar && r >= al) {\n    push(v);\n    update(v * 2, l, (r + l) / 2, al, ar);\n    update(v * 2 + 1, (r + l) / 2 + 1, r, al, ar);\n    Tree[v] = Tree[v] | Tree[v * 2] | Tree[v * 2 + 1];\n  }\n}\nint n, q;\nbool up_(int a, int b) {\n  if (a == b) {\n    return 0;\n  }\n  while (1) {\n    if (pr(mass[st[a]], b)) {\n      if (ask(1, 0, n - 1, idx[b] + 1, idx[a])) {\n        return 1;\n      }\n      return 0;\n    } else {\n      if (ask(1, 0, n - 1, st[a], idx[a])) {\n        return 1;\n      }\n      a = pred_tree[mass[st[a]]];\n    }\n  }\n}\nvoid add(int a, int b) {\n  if (a == b) {\n    return;\n  }\n  while (1) {\n    if (pr(mass[st[a]], b)) {\n      update(1, 0, n - 1, idx[b] + 1, idx[a]);\n      break;\n    } else {\n      update(1, 0, n - 1, st[a], idx[a]);\n      a = pred_tree[mass[st[a]]];\n    }\n  }\n}\nint lca(int a, int b) {\n  if (pr(a, b)) {\n    return a;\n  }\n  for (int j = T - 1; j >= 0; j--) {\n    if (!pr(up[j][a], b)) {\n      a = up[j][a];\n    }\n  }\n  return up[0][a];\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> q;\n  for (int i = 0; i < n; i++) {\n    dsu[i] = i;\n    rang[i] = 1;\n  }\n  vector<bool> ans(q);\n  vector<vector<int> > vec;\n  for (int i = 0; i < q; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a--;\n    b--;\n    vec.push_back({a, b, c});\n    if (pred(a) != pred(b)) {\n      g[a].push_back({b, c});\n      g[b].push_back({a, c});\n      unite(a, b);\n      ans[i] = 1;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (!used[i]) {\n      up[0][i] = i;\n      dfs(i);\n      st[i] = it;\n      idx[i] = it;\n      mass[it++] = i;\n      dfs1(i);\n    }\n  }\n  for (int i = 1; i < T; i++) {\n    for (int j = 0; j < n; j++) {\n      up[i][j] = up[i - 1][up[i - 1][j]];\n    }\n  }\n  for (int i = 0; i < q; i++) {\n    if (ans[i]) {\n      continue;\n    }\n    int a = vec[i][0];\n    int b = vec[i][1];\n    int c = vec[i][2];\n    if ((val[a] ^ val[b] ^ c) == 0) {\n      continue;\n    }\n    int t = lca(a, b);\n    if (!up_(a, t) && !up_(b, t)) {\n      ans[i] = 1;\n      add(a, t);\n      add(b, t);\n    }\n  }\n  for (int i = 0; i < q; i++) {\n    if (ans[i]) {\n      cout << \"YES\\n\";\n    } else {\n      cout << \"NO\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct SegmentTree {\n  int n;\n  vector<int> a, st, stXor, lazy;\n  SegmentTree(int _n) : n(_n), st(4 * n), stXor(4 * n), lazy(4 * n) {}\n  SegmentTree(const vector<int> &_a)\n      : n((int)_a.size()), a(_a), st(4 * n), stXor(4 * n), lazy(4 * n) {\n    build(1, 0, n - 1);\n  }\n  void build(int p, int l, int r) {\n    if (l == r) {\n      st[p] = a[l];\n      return;\n    }\n    int m = (l + r) >> 1;\n    build(2 * p, l, m);\n    build((2 * p) + 1, m + 1, r);\n    st[p] = max(st[2 * p], st[(2 * p) + 1]);\n    stXor[p] = stXor[2 * p] ^ stXor[(2 * p) + 1];\n  }\n  void push(int p, int l, int r) {\n    if (lazy[p]) {\n      st[p] = lazy[p];\n      if (l != r) {\n        lazy[2 * p] = lazy[p];\n        lazy[2 * p + 1] = lazy[p];\n      }\n      lazy[p] = 0;\n    }\n  }\n  int query(int p, int l, int r, int i, int j) {\n    push(p, l, r);\n    if (i > r || j < l) return 0;\n    if (i <= l && r <= j) return st[p];\n    int m = (l + r) >> 1;\n    return max(query(2 * p, l, m, i, j), query(2 * p + 1, m + 1, r, i, j));\n  }\n  int query(int i, int j) { return query(1, 0, n - 1, i, j); }\n  void update(int p, int l, int r, int i, int j, int val) {\n    push(p, l, r);\n    if (i > r || j < l) return;\n    if (i <= l && r <= j) {\n      st[p] = val;\n      if (l != r) {\n        lazy[2 * p] = val;\n        lazy[2 * p + 1] = val;\n      }\n      return;\n    }\n    int m = (l + r) >> 1;\n    update(2 * p, l, m, i, j, val);\n    update(2 * p + 1, m + 1, r, i, j, val);\n    st[p] = max(st[2 * p], st[2 * p + 1]);\n    stXor[p] = stXor[2 * p] ^ stXor[2 * p + 1];\n  }\n  void update(int i, int j, int val) { update(1, 0, n - 1, i, j, val); }\n  void setEdge(int p, int l, int r, int i, int val) {\n    if (l == r) {\n      stXor[p] = val;\n      return;\n    }\n    int m = (l + r) >> 1;\n    push(2 * p, l, m);\n    push(2 * p + 1, m + 1, r);\n    if (i <= m) {\n      setEdge(2 * p, l, m, i, val);\n    } else\n      setEdge(2 * p + 1, m + 1, r, i, val);\n    st[p] = max(st[2 * p], st[2 * p + 1]);\n    stXor[p] = stXor[2 * p] ^ stXor[2 * p + 1];\n  }\n  void setEdge(int i, int val) { setEdge(1, 0, n - 1, i, val); }\n  int queryXor(int p, int l, int r, int i, int j) {\n    push(p, l, r);\n    if (i > r || j < l) return 0;\n    if (i <= l && r <= j) return stXor[p];\n    int m = (l + r) >> 1;\n    return queryXor(2 * p, l, m, i, j) ^ queryXor(2 * p + 1, m + 1, r, i, j);\n  }\n  int queryXor(int i, int j) { return queryXor(1, 0, n - 1, i, j); }\n};\ntemplate <bool VAL_IN_EDGES = false>\nstruct HLD {\n  int n, ti;\n  vector<int> par, sz, depth, root, pos;\n  vector<vector<int>> adj;\n  SegmentTree st;\n  HLD(int _n)\n      : n(_n),\n        ti(0),\n        par(n, -1),\n        sz(n, 1),\n        depth(n),\n        root(n),\n        pos(n),\n        adj(n),\n        st(n) {}\n  void addEdge(int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  void init(int r = -1) {\n    if (r == -1) {\n      for (int u = 0; u < n; u++) {\n        if (par[u] == -1) {\n          dfsSz(u);\n          dfsHld(u);\n        }\n      }\n    } else {\n      dfsSz(r);\n      dfsHld(r);\n    }\n  }\n  void dfsSz(int u) {\n    if (par[u] != -1) {\n      adj[u].erase(find(adj[u].begin(), adj[u].end(), par[u]));\n    }\n    for (int &v : adj[u]) {\n      par[v] = u;\n      depth[v] = depth[u] + 1;\n      dfsSz(v);\n      sz[u] += sz[v];\n      if (sz[v] > sz[adj[u][0]]) swap(v, adj[u][0]);\n    }\n  }\n  void dfsHld(int u) {\n    pos[u] = ti++;\n    for (int v : adj[u]) {\n      root[v] = ((v == adj[u][0]) ? root[u] : v);\n      dfsHld(v);\n    }\n  }\n  template <class B>\n  void process(int u, int v, B op) {\n    for (; root[u] != root[v]; u = par[root[u]]) {\n      if (depth[root[u]] < depth[root[v]]) swap(u, v);\n      op(pos[root[u]], pos[u]);\n    }\n    if (depth[u] > depth[v]) swap(u, v);\n    if (pos[u] + VAL_IN_EDGES <= pos[v]) op(pos[u] + VAL_IN_EDGES, pos[v]);\n  }\n  int query(int u, int v) {\n    int ret = 0;\n    process(u, v,\n            [this, &ret](int l, int r) { ret = max(ret, st.query(l, r)); });\n    return ret;\n  }\n  void update(int u, int v, int val) {\n    process(u, v, [this, &val](int l, int r) { st.update(l, r, val); });\n  }\n  void setEdge(int u, int v, int x) {\n    if (par[u] == v)\n      st.setEdge(pos[u], x);\n    else\n      st.setEdge(pos[v], x);\n  }\n  int queryXor(int u, int v) {\n    int ret = 0;\n    process(u, v, [this, &ret](int l, int r) { ret ^= st.queryXor(l, r); });\n    return ret;\n  }\n  int query(int u) {\n    return st.query(pos[u] + VAL_IN_EDGES, pos[u] + sz[u] - 1);\n  }\n  void update(int u, int val) {\n    st.update(pos[u] + VAL_IN_EDGES, pos[u] + sz[u] - 1, val);\n  }\n};\nstruct DSU {\n  vector<int> par, sz;\n  DSU(int n) : par(n), sz(n, 1) { iota(par.begin(), par.end(), 0); }\n  int find(int u) { return u == par[u] ? u : par[u] = find(par[u]); }\n  bool same(int u, int v) { return find(u) == find(v); }\n  bool unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return false;\n    if (sz[u] < sz[v]) {\n      swap(u, v);\n    }\n    par[v] = u;\n    sz[u] += sz[v];\n    return true;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n, q;\n  cin >> n >> q;\n  DSU dsu(n);\n  HLD<true> hld(n);\n  vector<tuple<int, int, int>> edges;\n  int i;\n  for (i = (0); i < (q); i++) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    u--, v--;\n    if (dsu.unite(u, v)) {\n      hld.addEdge(u, v);\n    }\n    edges.push_back({u, v, x});\n  }\n  dsu = DSU(n);\n  hld.init();\n  for (auto &[u, v, x] : edges) {\n    if (dsu.unite(u, v)) {\n      cout << \"YES\" << '\\n';\n      hld.setEdge(u, v, x);\n    } else if (hld.query(u, v) == 0 && hld.queryXor(u, v) ^ x) {\n      cout << \"YES\\n\";\n      hld.update(u, v, 1);\n    } else\n      cout << \"NO\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300000;\nconst int B = 18;\nint timerin, timerout;\nint tin[N + 1], tout[N + 1];\nint comp[N + 1];\nint par[N + 1][B + 1];\nint sum[N + 1], xorup[N + 1];\nint f[N + 2];\nvoid upd(int x, int d) {\n  for (; x <= N; x += (x & -x)) f[x] += d;\n}\nint cnt(int x) {\n  int ans = 0;\n  for (; x > 0; x -= (x & -x)) ans += f[x];\n  return ans;\n}\nvector<pair<int, int> > v[N + 1];\nbool isp(int a, int b) { return tin[a] <= tin[b] && tout[b] <= tout[a]; }\nint lca(int a, int b) {\n  if (isp(a, b)) return a;\n  for (int i = B; i >= 0; i--)\n    if (par[a][i] && !isp(par[a][i], b)) a = par[a][i];\n  return par[a][0];\n}\nint dfs(int p, int parent) {\n  tin[p] = ++timerin;\n  par[p][0] = parent;\n  for (int i = 1; i <= B; i++) par[p][i] = par[par[p][i - 1]][i - 1];\n  for (int i = 0; i < v[p].size(); i++)\n    if (v[p][i].first != parent) {\n      xorup[v[p][i].first] = xorup[p] ^ v[p][i].second;\n      int d = dfs(v[p][i].first, p);\n      sum[p] += d + 1;\n    }\n  tout[p] = ++timerout;\n  return sum[p];\n}\nvoid update(int p, int top) {\n  for (int t = p; t != top; t = par[t][0]) {\n    upd(tin[t], 1);\n    upd(tin[t] + sum[t] + 1, -1);\n  }\n}\nbool solve(int a, int b, int x) {\n  if (x == -1) return 1;\n  if ((xorup[a] ^ xorup[b] ^ x) == 0) return 0;\n  int top = lca(a, b);\n  if (cnt(tin[a]) + cnt(tin[b]) > 2 * cnt(tin[top])) return 0;\n  update(a, top);\n  update(b, top);\n  return 1;\n}\nint parent(int p) {\n  if (comp[p] != p) comp[p] = parent(comp[p]);\n  return comp[p];\n}\nint main() {\n  ios::sync_with_stdio(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) comp[i] = i;\n  int a[m], b[m], x[m];\n  for (int i = 0; i < m; i++) {\n    cin >> a[i] >> b[i] >> x[i];\n    if (parent(a[i]) != parent(b[i])) {\n      comp[parent(a[i])] = parent(b[i]);\n      v[a[i]].push_back(make_pair(b[i], x[i]));\n      v[b[i]].push_back(make_pair(a[i], x[i]));\n      x[i] = -1;\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (parent(i) == i) dfs(i, 0);\n  for (int i = 0; i < m; i++)\n    cout << (solve(a[i], b[i], x[i]) ? \"YES\" : \"NO\") << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int INF = 0x3f3f3f3f;\nconst int M = 5e5 + 5;\nint n, m, sign;\nint siz[M], prt[M], top[M], val[M], dfn[M];\nint fp[M], d[M], dis[M], son[M], fa[M], vis[M];\nstruct Edge {\n  int x, y, d;\n} e[M];\nstruct Tre {\n  int l, r, Mx, cov;\n} tre[M << 2];\nstd ::vector<int> P[M], D[M];\ninline void dfs(int x, int fa, int dep) {\n  d[x] = dep, siz[x] = 1;\n  for (int i = 0; i < P[x].size(); ++i) {\n    int y = P[x][i];\n    if (y == fa) continue;\n    prt[y] = x, dis[y] = dis[x] ^ D[x][i];\n    dfs(y, x, dep + 1);\n    siz[x] += siz[y];\n    if (son[x] == -1 || siz[y] > siz[son[x]]) son[x] = y;\n  }\n}\ninline void dfs(int x, int sp) {\n  top[x] = sp, fp[dfn[x] = ++sign] = x;\n  if (son[x] != -1) dfs(son[x], sp);\n  for (int i = 0; i < P[x].size(); ++i)\n    if (P[x][i] != prt[x] && P[x][i] != son[x]) dfs(P[x][i], P[x][i]);\n}\ninline void push_up(int p) {\n  tre[p].Mx = std ::max(tre[p << 1].Mx, tre[p << 1 | 1].Mx);\n}\ninline void push_down_cov(int p) { tre[p].cov = 1, tre[p].Mx = 1; }\ninline void push_down(int p) {\n  if (!tre[p].cov) return;\n  push_down_cov(p << 1), push_down_cov(p << 1 | 1);\n  tre[p].cov = 0;\n}\ninline void build(int p, int l, int r) {\n  tre[p].l = l, tre[p].r = r;\n  if (l == r) return;\n  int mid = l + r >> 1;\n  build(p << 1, l, mid), build(p << 1 | 1, mid + 1, r);\n}\ninline void update(int p, int l, int r) {\n  if (l <= tre[p].l && tre[p].r <= r) {\n    push_down_cov(p);\n    return;\n  }\n  int mid = tre[p].l + tre[p].r >> 1;\n  push_down(p);\n  if (l <= mid) update(p << 1, l, r);\n  if (r > mid) update(p << 1 | 1, l, r);\n  push_up(p);\n}\ninline int Query(int p, int l, int r) {\n  if (l <= tre[p].l && tre[p].r <= r) return tre[p].Mx;\n  int mid = tre[p].l + tre[p].r >> 1, res = 0;\n  push_down(p);\n  if (l <= mid) res = std ::max(res, Query(p << 1, l, r));\n  if (r > mid) res = std ::max(res, Query(p << 1 | 1, l, r));\n  return res;\n}\ninline void update_path(int x, int y) {\n  while (top[x] ^ top[y]) {\n    if (d[top[x]] < d[top[y]]) std ::swap(x, y);\n    update(1, dfn[top[x]], dfn[x]);\n    x = prt[top[x]];\n  }\n  if (x == y) return;\n  if (dfn[x] > dfn[y]) std ::swap(x, y);\n  update(1, dfn[x] + 1, dfn[y]);\n}\ninline int Query_path(int x, int y) {\n  int res = 0;\n  while (top[x] ^ top[y]) {\n    if (d[top[x]] < d[top[y]]) std ::swap(x, y);\n    res = std ::max(res, Query(1, dfn[top[x]], dfn[x]));\n    x = prt[top[x]];\n  }\n  if (x == y) return res;\n  if (dfn[x] > dfn[y]) std ::swap(x, y);\n  return std ::max(res, Query(1, dfn[x] + 1, dfn[y]));\n}\ninline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\ninline int read() {\n  int f = 1, s = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) (ch == '-') && (f = -1), ch = getchar();\n  while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n  return f * s;\n}\nint main() {\n  memset(son, -1, sizeof(son));\n  n = read(), m = read();\n  for (int i = 1; i <= n; ++i) fa[i] = i;\n  for (int i = 1; i <= m; ++i) {\n    e[i].x = read(), e[i].y = read(), e[i].d = read();\n    int kx = find(e[i].x), ky = find(e[i].y);\n    if (kx == ky) continue;\n    vis[i] = 1, fa[kx] = ky;\n    int x = e[i].x, y = e[i].y;\n    P[x].push_back(y), P[y].push_back(x);\n    D[x].push_back(e[i].d), D[y].push_back(e[i].d);\n  }\n  for (int i = 1; i <= n; ++i)\n    if (!siz[i]) dfs(i, 0, i), dfs(i, i);\n  build(1, 1, n);\n  for (int i = 1; i <= m; ++i) {\n    if (vis[i]) {\n      puts(\"YES\");\n      continue;\n    }\n    int x = e[i].x, y = e[i].y, d = e[i].d;\n    int val = (dis[x] ^ dis[y] ^ d);\n    if (!val) {\n      puts(\"NO\");\n      continue;\n    }\n    if (Query_path(x, y) == 0)\n      puts(\"YES\"), update_path(x, y);\n    else\n      puts(\"NO\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0;\n  char c = getchar();\n  while (!isdigit(c)) c = getchar();\n  while (isdigit(c)) x = x * 10 + (c ^ '0'), c = getchar();\n  return x;\n}\nconst int maxn = 3e5 + 10;\nconst int maxq = 5e5 + 10;\nstruct Node {\n  int s[2], p, siz, v1, sum, v2, _s, tag1, tag2;\n} tr[maxn * 2];\nint n, q, tot, stk[maxn * 2];\ninline void pushup(int x) {\n  tr[x].siz = tr[tr[x].s[0]].siz + tr[tr[x].s[1]].siz + (x > n);\n  tr[x].sum = tr[tr[x].s[0]].sum ^ tr[tr[x].s[1]].sum ^ tr[x].v1;\n  tr[x]._s = tr[tr[x].s[0]]._s | tr[tr[x].s[1]]._s | (x > n && tr[x].v2 > 0);\n}\ninline void pushrev(int x) {\n  swap(tr[x].s[0], tr[x].s[1]);\n  tr[x].tag1 ^= 1;\n}\ninline void pushadd(int x) {\n  tr[x]._s = tr[x].siz;\n  if (x > n) tr[x].v2 = 1;\n  tr[x].tag2 = 1;\n}\ninline void pushdown(int x) {\n  if (tr[x].tag1) {\n    pushrev(tr[x].s[0]), pushrev(tr[x].s[1]);\n    tr[x].tag1 = 0;\n  }\n  if (tr[x].tag2) {\n    pushadd(tr[x].s[0]), pushadd(tr[x].s[1]);\n    tr[x].tag2 = 0;\n  }\n}\ninline bool isroot(int x) {\n  return tr[tr[x].p].s[0] != x && tr[tr[x].p].s[1] != x;\n}\ninline void rotate(int x) {\n  int y = tr[x].p, z = tr[y].p, k = tr[y].s[1] == x;\n  if (!isroot(y)) tr[z].s[tr[z].s[1] == y] = x;\n  tr[x].p = z;\n  tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;\n  tr[x].s[k ^ 1] = y, tr[y].p = x;\n  pushup(y), pushup(x);\n}\nvoid splay(int x) {\n  int top = 0, r = x;\n  stk[++top] = r;\n  while (!isroot(r)) stk[++top] = r = tr[r].p;\n  while (top) pushdown(stk[top--]);\n  while (!isroot(x)) {\n    int y = tr[x].p, z = tr[y].p;\n    if (!isroot(y)) rotate(tr[y].s[1] == x ^ tr[z].s[1] == y ? x : y);\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  int z = x;\n  for (int y = 0; x; y = x, x = tr[x].p) {\n    splay(x);\n    tr[x].s[1] = y, pushup(x);\n  }\n  splay(z);\n}\nvoid makeroot(int x) { access(x), pushrev(x); }\nint findroot(int x) {\n  access(x);\n  while (tr[x].s[0]) pushdown(x), x = tr[x].s[0];\n  splay(x);\n  return x;\n}\nvoid split(int x, int y) { makeroot(x), access(y); }\nvoid link(int x, int y) {\n  makeroot(x);\n  if (findroot(y) != x) tr[x].p = y;\n}\nint main() {\n  n = read(), q = read();\n  tot = n;\n  for (int i = 1; i <= n; i++) tr[i].siz = 1;\n  for (int i = 1; i <= q; i++) {\n    int u = read(), v = read(), w = read();\n    makeroot(u);\n    if (findroot(v) != u) {\n      tot++, tr[tot].v1 = tr[tot].sum = w, tr[tot].siz = 1;\n      link(u, tot), link(tot, v);\n      puts(\"YES\");\n    } else {\n      split(u, v);\n      if (tr[v]._s > 0 || (tr[v].sum ^ w) != 1)\n        puts(\"NO\");\n      else {\n        pushadd(v);\n        puts(\"YES\");\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct SegmentTree {\n  int n;\n  vector<int> a, st, stXor, lazy;\n  SegmentTree(int _n) : n(_n), st(4 * n), stXor(4 * n), lazy(4 * n) {}\n  SegmentTree(const vector<int> &_a)\n      : n((int)_a.size()), a(_a), st(4 * n), stXor(4 * n), lazy(4 * n) {\n    build(1, 0, n - 1);\n  }\n  void build(int p, int l, int r) {\n    if (l == r) {\n      st[p] = a[l];\n      return;\n    }\n    int m = (l + r) >> 1;\n    build(2 * p, l, m);\n    build((2 * p) + 1, m + 1, r);\n    st[p] = max(st[2 * p], st[(2 * p) + 1]);\n    stXor[p] = stXor[2 * p] ^ stXor[(2 * p) + 1];\n  }\n  void push(int p, int l, int r) {\n    if (lazy[p]) {\n      st[p] = lazy[p];\n      if (l != r) {\n        lazy[2 * p] = lazy[p];\n        lazy[2 * p + 1] = lazy[p];\n      }\n      lazy[p] = 0;\n    }\n  }\n  int query(int p, int l, int r, int i, int j) {\n    push(p, l, r);\n    if (i > r || j < l) return 0;\n    if (i <= l && r <= j) return st[p];\n    int m = (l + r) >> 1;\n    return max(query(2 * p, l, m, i, j), query(2 * p + 1, m + 1, r, i, j));\n  }\n  int query(int i, int j) { return query(1, 0, n - 1, i, j); }\n  void update(int p, int l, int r, int i, int j, int val) {\n    push(p, l, r);\n    if (i > r || j < l) return;\n    if (i <= l && r <= j) {\n      st[p] = val;\n      if (l != r) {\n        lazy[2 * p] = val;\n        lazy[2 * p + 1] = val;\n      }\n      return;\n    }\n    int m = (l + r) >> 1;\n    update(2 * p, l, m, i, j, val);\n    update(2 * p + 1, m + 1, r, i, j, val);\n    st[p] = max(st[2 * p], st[2 * p + 1]);\n    stXor[p] = stXor[2 * p] ^ stXor[2 * p + 1];\n  }\n  void update(int i, int j, int val) { update(1, 0, n - 1, i, j, val); }\n  void setEdge(int p, int l, int r, int i, int val) {\n    if (l == r) {\n      stXor[p] = val;\n      return;\n    }\n    int m = (l + r) >> 1;\n    push(2 * p, l, m);\n    push(2 * p + 1, m + 1, r);\n    if (i <= m) {\n      setEdge(2 * p, l, m, i, val);\n    } else\n      setEdge(2 * p + 1, m + 1, r, i, val);\n    st[p] = max(st[2 * p], st[2 * p + 1]);\n    stXor[p] = stXor[2 * p] ^ stXor[2 * p + 1];\n  }\n  void setEdge(int i, int val) { setEdge(1, 0, n - 1, i, val); }\n  int queryXor(int p, int l, int r, int i, int j) {\n    push(p, l, r);\n    if (i > r || j < l) return 0;\n    if (i <= l && r <= j) return stXor[p];\n    int m = (l + r) >> 1;\n    return queryXor(2 * p, l, m, i, j) ^ queryXor(2 * p + 1, m + 1, r, i, j);\n  }\n  int queryXor(int i, int j) { return queryXor(1, 0, n - 1, i, j); }\n};\ntemplate <bool VAL_IN_EDGES = false>\nstruct HLD {\n  int n, ti;\n  vector<int> par, sz, depth, root, pos;\n  vector<vector<int>> adj;\n  SegmentTree st;\n  HLD(int _n)\n      : n(_n),\n        ti(0),\n        par(n, -1),\n        sz(n, 1),\n        depth(n),\n        root(n),\n        pos(n),\n        adj(n),\n        st(n) {}\n  void addEdge(int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  void init(int r = -1) {\n    if (r == -1) {\n      for (int u = 0; u < n; u++) {\n        if (par[u] == -1) {\n          dfsSz(u);\n          dfsHld(u);\n        }\n      }\n    } else {\n      dfsSz(r);\n      dfsHld(r);\n    }\n  }\n  void dfsSz(int u) {\n    if (par[u] != -1) {\n      adj[u].erase(find(adj[u].begin(), adj[u].end(), par[u]));\n    }\n    for (int &v : adj[u]) {\n      par[v] = u;\n      depth[v] = depth[u] + 1;\n      dfsSz(v);\n      sz[u] += sz[v];\n      if (sz[v] > sz[adj[u][0]]) swap(v, adj[u][0]);\n    }\n  }\n  void dfsHld(int u) {\n    pos[u] = ti++;\n    for (int v : adj[u]) {\n      root[v] = ((v == adj[u][0]) ? root[u] : v);\n      dfsHld(v);\n    }\n  }\n  template <class B>\n  void process(int u, int v, B op) {\n    for (; root[u] != root[v]; u = par[root[u]]) {\n      if (depth[root[u]] < depth[root[v]]) swap(u, v);\n      op(pos[root[u]], pos[u]);\n    }\n    if (depth[u] > depth[v]) swap(u, v);\n    if (pos[u] + VAL_IN_EDGES <= pos[v]) op(pos[u] + VAL_IN_EDGES, pos[v]);\n  }\n  int query(int u, int v) {\n    int ret = 0;\n    process(u, v,\n            [this, &ret](int l, int r) { ret = max(ret, st.query(l, r)); });\n    return ret;\n  }\n  void update(int u, int v, int val) {\n    process(u, v, [this, &val](int l, int r) { st.update(l, r, val); });\n  }\n  void setEdge(int u, int v, int x) {\n    if (par[u] == v)\n      st.setEdge(pos[u], x);\n    else\n      st.setEdge(pos[v], x);\n  }\n  int queryXor(int u, int v) {\n    int ret = 0;\n    process(u, v, [this, &ret](int l, int r) { ret ^= st.queryXor(l, r); });\n    return ret;\n  }\n  int query(int u) {\n    return st.query(pos[u] + VAL_IN_EDGES, pos[u] + sz[u] - 1);\n  }\n  void update(int u, int val) {\n    st.update(pos[u] + VAL_IN_EDGES, pos[u] + sz[u] - 1, val);\n  }\n};\nstruct DSU {\n  vector<int> par, sz;\n  DSU(int n) : par(n), sz(n, 1) { iota(par.begin(), par.end(), 0); }\n  int find(int u) { return u == par[u] ? u : par[u] = find(par[u]); }\n  bool same(int u, int v) { return find(u) == find(v); }\n  bool unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return false;\n    if (sz[u] < sz[v]) {\n      swap(u, v);\n    }\n    par[v] = u;\n    sz[u] += sz[v];\n    return true;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n, q;\n  cin >> n >> q;\n  DSU dsu(n);\n  HLD<true> hld(n);\n  vector<tuple<int, int, int>> edges;\n  int i;\n  for (i = (0); i < (q); i++) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    u--, v--;\n    if (dsu.unite(u, v)) {\n      hld.addEdge(u, v);\n    }\n    edges.push_back({u, v, x});\n  }\n  dsu = DSU(n);\n  hld.init();\n  for (auto &[u, v, x] : edges) {\n    if (dsu.unite(u, v)) {\n      cout << \"YES\" << '\\n';\n      hld.setEdge(u, v, x);\n    } else if (hld.query(u, v) == 0 && hld.queryXor(u, v) ^ x) {\n      cout << \"YES\\n\";\n      hld.update(u, v, 1);\n    } else\n      cout << \"NO\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e5 + 10, MOD = 1e9 + 7;\nvector<int> adj[N];\nint ts;\nint M2[N], fr[N], to[N], w[N], X[N], rt[N], first[2][N], St[N], hd[N], hv[N],\n    second[N], M[N], P[N], H[N], n, q;\nvoid upd(int id, int p, int x) {\n  for (p += 2; p < N; p += p & -p) first[id][p] += x;\n}\nint _get(int id, int p) {\n  int res = 0;\n  for (p += 2; p; p -= p & -p) res += first[id][p];\n  return res;\n}\nvoid add(int l, int r, int x) {\n  if (l > r) return;\n  upd(0, l, x), upd(0, r + 1, -x);\n  upd(1, l, x * (l - 1)), upd(1, r + 1, -x * r);\n}\nint get(int r) { return _get(0, r) * r - _get(1, r); }\nint get(int l, int r) {\n  if (l > r) return 0;\n  return get(r) - get(l - 1);\n}\nint Find(int v) { return !rt[v] ? v : rt[v] = Find(rt[v]); }\nint Union(int u, int v) {\n  u = Find(u), v = Find(v);\n  if (u ^ v) return rt[u] = v, 1;\n  return 0;\n}\nvoid preDFS(int v, int p = -1) {\n  M2[v] = second[v] = 1;\n  for (int &id : adj[v]) {\n    int u = fr[id] ^ to[id] ^ v;\n    if (u != p)\n      H[u] = H[v] + 1, P[u] = v, X[u] = X[v] ^ w[id], preDFS(u, v),\n      second[v] += second[u];\n  }\n  for (int &id : adj[v]) {\n    int u = fr[id] ^ to[id] ^ v;\n    if (u != p && second[u] > second[hv[v]]) hv[v] = u;\n  }\n}\nvoid hlDFS(int v, int p = -1) {\n  St[v] = ++ts;\n  if (!~p) hd[v] = v;\n  if (hv[v]) hd[hv[v]] = hd[v], hlDFS(hv[v], v);\n  for (int &id : adj[v]) {\n    int u = fr[id] ^ to[id] ^ v;\n    if (u != p && u != hv[v]) hlDFS(hd[u] = u, v);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &q);\n  for (int i = 1; i <= q; i++) {\n    scanf(\"%d%d%d\", &fr[i], &to[i], &w[i]);\n    if (Union(fr[i], to[i]))\n      M[i] = 1, adj[fr[i]].push_back(i), adj[to[i]].push_back(i);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!M2[i]) preDFS(i), hlDFS(i);\n  }\n  for (int i = 1; i <= q; i++) {\n    if (M[i]) {\n      printf(\"YES\\n\");\n      continue;\n    }\n    int u = fr[i], v = to[i], x = w[i], f = 0;\n    if (x ^ X[u] ^ X[v] ^ 1) {\n      printf(\"NO\\n\");\n      continue;\n    }\n    for (; hd[v] != hd[u];)\n      if (H[hd[v]] > H[hd[u]])\n        f += get(St[hd[v]], St[v]), v = P[hd[v]];\n      else\n        f += get(St[hd[u]], St[u]), u = P[hd[u]];\n    if (H[u] < H[v]) swap(u, v);\n    f += get(St[v] + 1, St[u]);\n    if (f) {\n      printf(\"NO\\n\");\n      continue;\n    }\n    v = fr[i], u = to[i];\n    for (; hd[v] != hd[u];)\n      if (H[hd[v]] > H[hd[u]])\n        add(St[hd[v]], St[v], 1), v = P[hd[v]];\n      else\n        add(St[hd[u]], St[u], 1), u = P[hd[u]];\n    if (H[u] < H[v]) swap(u, v);\n    add(St[v] + 1, St[u], 1);\n    printf(\"YES\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T1, class T2>\ninline void upd1(T1& a, const T2& b) {\n  a = a < b ? a : b;\n}\ntemplate <class T1, class T2>\ninline void upd2(T1& a, const T2& b) {\n  a = b < a ? a : b;\n}\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nstruct Ano {\n  operator long long() {\n    long long x = 0, y = 0, c = getchar();\n    while (c < 48) {\n      y = c == 45;\n      c = getchar();\n    }\n    while (c > 47) {\n      x = x * 10 + c - 48;\n      c = getchar();\n    }\n    return y ? -x : x;\n  }\n} buf;\nconstexpr int N = 6e5 + 5;\nint n;\nstruct vec {\n  bool c, w;\n  vec() {}\n  vec(bool c, bool w) : c(c), w(w) {}\n};\nvec operator+(vec a, vec b) { return vec(a.c | b.c, a.w ^ b.w); }\nstruct node;\ntypedef node* ptr;\nstruct node {\n  ptr i, j, p;\n  bool r, c;\n  vec v, s;\n  node();\n  ptr up() {\n    s = i->s + v + j->s;\n    return this;\n  }\n  void down() {\n    if (r) i->r ^= 1, j->r ^= 1, swap(i, j), r = 0;\n    if (c) i->cov(), j->cov(), c = 0;\n  }\n  void cov();\n} e[N];\nnode::node() { i = j = p = e; }\nvoid node::cov() {\n  if (this == e) return;\n  c = 1;\n  if (this - e > n)\n    s.c = v.c = 1;\n  else\n    s.c = i != e || j != e;\n}\nbool root(ptr o) { return o != o->p->i && o != o->p->j; }\nvoid turn(ptr o) {\n  ptr s = o->p, t = s->p;\n  if (!root(s)) (s == t->i ? t->i : t->j) = o;\n  s->p = o, o->p = t;\n  if (o == s->i)\n    s->i = o->j, o->j->p = s, o->j = s->up();\n  else\n    s->j = o->i, o->i->p = s, o->i = s->up();\n}\nvoid push(ptr o) {\n  if (!root(o)) push(o->p);\n  o->down();\n}\nptr splay(ptr o) {\n  push(o);\n  while (!root(o)) {\n    if (!root(o->p)) turn(o == o->p->i ^ o->p == o->p->p->i ? o : o->p);\n    turn(o);\n  }\n  return o->up();\n}\nptr exp(ptr o) {\n  ptr s = e;\n  while (o != e) splay(o)->j = s, s = o->up(), o = o->p;\n  return s;\n}\nint main() {\n  n = buf;\n  int m = n;\n  for (int q = buf; q; --q) {\n    int u = buf, v = buf, w = buf;\n    exp(e + u)->r = 1;\n    ptr o = exp(e + v);\n    while (o->i != e) {\n      o = o->i, o->down();\n    }\n    bool a = 1;\n    if (splay(o) != e + u) {\n      e[++m].v = vec(0, w);\n      splay(e + u)->p = e + m;\n      e[m].p = e + v;\n    } else {\n      if (!o->s.c && o->s.w ^ w) {\n        o->cov();\n      } else {\n        a = 0;\n      }\n    }\n    puts(a ? \"YES\" : \"NO\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &r) {\n  r = 0;\n  bool w = true;\n  char ch = getchar();\n  for (; !isdigit(ch); ch = getchar()) w ^= !(ch ^ 45);\n  for (; isdigit(ch); ch = getchar()) r = (r << 1) + (r << 3) + (ch ^ 48);\n  r = w ? r : -r;\n}\nstruct node_edge {\n  int to, next, weight;\n} edge[(500000 + 5) << 1];\nint head[300000 + 5], edge_num;\nvoid add(int u, int v, int w) {\n  ++edge_num;\n  edge[edge_num].to = v;\n  edge[edge_num].weight = w;\n  edge[edge_num].next = head[u];\n  head[u] = edge_num;\n}\nint n, m, ans[500000 + 5];\nint fat[300000 + 5];\nint find(int x) {\n  if (fat[x] == x) return x;\n  return fat[x] = find(fat[x]);\n}\nint from[500000 + 5], to[500000 + 5], weight[500000 + 5];\nvoid init() {\n  read(n), read(m);\n  for (register int i = 1; i <= n; i++) fat[i] = i;\n  for (register int i = 1; i <= m; i++) {\n    read(from[i]), read(to[i]), read(weight[i]);\n    if (find(from[i]) != find(to[i])) {\n      fat[find(from[i])] = find(to[i]);\n      ans[i] = true;\n      add(from[i], to[i], weight[i]);\n      add(to[i], from[i], weight[i]);\n    }\n  }\n}\nint fa[300000 + 5], depth[300000 + 5], size[300000 + 5], son[300000 + 5],\n    val[300000 + 5];\nvoid dfs1(int u) {\n  size[u] = 1;\n  for (register int i = head[u]; i; i = edge[i].next) {\n    int v = edge[i].to;\n    if (fa[u] == v) continue;\n    fa[v] = u;\n    depth[v] = depth[u] + 1;\n    val[v] = edge[i].weight;\n    dfs1(v);\n    size[u] += size[v];\n    if (size[son[u]] < size[v]) son[u] = v;\n  }\n}\nint pos[300000 + 5], bac[300000 + 5], belong[300000 + 5];\nvoid dfs2(int u, int chain) {\n  belong[u] = chain;\n  pos[u] = ++pos[0];\n  bac[pos[0]] = u;\n  if (son[u]) dfs2(son[u], chain);\n  for (register int i = head[u]; i; i = edge[i].next) {\n    int v = edge[i].to;\n    if (fa[u] == v || son[u] == v) continue;\n    dfs2(v, v);\n  }\n}\nstruct node2 {\n  int l, r, val;\n  bool vis, lazy;\n} a[300000 << 2];\nvoid pushup(int p) {\n  a[p].val = a[(p << 1)].val ^ a[((p << 1) + 1)].val;\n  a[p].vis = a[(p << 1)].vis | a[((p << 1) + 1)].vis;\n}\nvoid pushdown(int p) {\n  if (a[p].lazy) {\n    a[(p << 1)].vis = a[((p << 1) + 1)].vis = a[(p << 1)].lazy =\n        a[((p << 1) + 1)].lazy = true;\n    a[p].lazy = false;\n  }\n}\nvoid build(int p, int l, int r) {\n  a[p].l = l, a[p].r = r;\n  if (l == r) {\n    a[p].val = val[bac[l]];\n    a[p].vis = false;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build((p << 1), l, mid);\n  build(((p << 1) + 1), mid + 1, r);\n  pushup(p);\n}\nvoid update(int p, int l, int r) {\n  if (a[p].l == l && a[p].r == r) {\n    a[p].vis = true;\n    a[p].lazy = true;\n    return;\n  }\n  pushdown(p);\n  int mid = (a[p].l + a[p].r) >> 1;\n  if (r <= mid)\n    update((p << 1), l, r);\n  else if (l > mid)\n    update(((p << 1) + 1), l, r);\n  else {\n    update((p << 1), l, mid);\n    update(((p << 1) + 1), mid + 1, r);\n  }\n  pushup(p);\n}\nint query(int p, int l, int r) {\n  if (a[p].l == l && a[p].r == r) {\n    if (a[p].vis) return -1;\n    return a[p].val;\n  }\n  pushdown(p);\n  int mid = (a[p].l + a[p].r) >> 1;\n  if (r <= mid) return query((p << 1), l, r);\n  if (l > mid) return query(((p << 1) + 1), l, r);\n  int ls = query((p << 1), l, mid), rs = query(((p << 1) + 1), mid + 1, r);\n  if (ls == -1 || rs == -1) return -1;\n  return ls ^ rs;\n}\nvoid getpath(int i) {\n  int u = from[i], v = to[i];\n  int ret = 0;\n  while (belong[u] != belong[v]) {\n    if (depth[belong[u]] < depth[belong[v]]) swap(u, v);\n    int g = query(1, pos[belong[u]], pos[u]);\n    if (g == -1) {\n      ret = -1;\n      return;\n    } else\n      ret ^= g;\n    u = fa[belong[u]];\n  }\n  if (depth[u] < depth[v]) swap(u, v);\n  if (u != v) {\n    int g = query(1, pos[v] + 1, pos[u]);\n    if (g == -1)\n      ret = -1;\n    else\n      ret ^= g;\n  }\n  if ((ret ^ weight[i]) == 1) {\n    ans[i] = 1;\n    u = from[i], v = to[i];\n    while (belong[u] != belong[v]) {\n      if (depth[belong[u]] < depth[belong[v]]) swap(u, v);\n      update(1, pos[belong[u]], pos[u]);\n      u = fa[belong[u]];\n    }\n    if (depth[u] < depth[v]) swap(u, v);\n    if (u != v) {\n      update(1, pos[v] + 1, pos[u]);\n    }\n  }\n}\nvoid solve() {\n  for (register int i = 1; i <= n; i++) {\n    if (!size[i]) {\n      dfs1(i);\n      dfs2(i, i);\n    }\n  }\n  build(1, 1, n);\n  for (register int i = 1; i <= m; i++) {\n    if (!ans[i]) {\n      getpath(i);\n    }\n  }\n  for (register int i = 1; i <= m; i++) puts(ans[i] ? \"YES\" : \"NO\");\n}\nvoid write() {}\nint main() {\n  init();\n  solve();\n  write();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstruct disjoin_set_union {\n  std::vector<int> parent;\n  std::vector<int> rank;\n  disjoin_set_union(int n = 0) : parent(n), rank(n, 1) {\n    std::iota(parent.begin(), parent.end(), 0);\n  }\n  int root(int v) { return (v ^ parent[v]) ? parent[v] = root(parent[v]) : v; }\n  bool unite(int v, int u) {\n    v = root(v), u = root(u);\n    if (v == u) return false;\n    if (rank[v] < rank[u]) std::swap(v, u);\n    rank[v] += rank[u];\n    parent[u] = v;\n    return true;\n  }\n};\nstruct link_cut {\n  struct node {\n    int parent;\n    std::array<int, 2> sons;\n    bool inv;\n    int size;\n    int value, tot;\n    node()\n        : parent(-1), sons({-1, -1}), inv(false), size(1), value(0), tot(0) {}\n  };\n  std::vector<node> tree;\n  void push(int v) {\n    if (tree[v].inv) {\n      tree[v].inv = false;\n      std::swap(tree[v].sons[0], tree[v].sons[1]);\n      for (const auto u : tree[v].sons)\n        if (u != -1) tree[u].inv ^= 1;\n    }\n  }\n  void relax(int v) {\n    push(v);\n    tree[v].size = 1;\n    for (const auto x : tree[v].sons)\n      if (x != -1) tree[v].size += tree[x].size;\n    tree[v].tot = tree[v].value;\n    for (const auto x : tree[v].sons)\n      if (x != -1) tree[v].tot ^= tree[x].tot;\n  }\n  void rotate(int v) {\n    int u = tree[v].parent, w = tree[u].parent;\n    push(u), push(v);\n    tree[v].parent = w;\n    if (w != -1)\n      for (auto &x : tree[w].sons)\n        if (x == u) x = v;\n    int i = tree[u].sons[1] == v;\n    tree[u].sons[i] = tree[v].sons[i ^ 1];\n    if (tree[v].sons[i ^ 1] != -1) tree[tree[v].sons[i ^ 1]].parent = u;\n    tree[v].sons[i ^ 1] = u;\n    tree[u].parent = v;\n    relax(u), relax(v);\n  }\n  bool is_root(int v) {\n    return tree[v].parent == -1 || (tree[tree[v].parent].sons[0] != v &&\n                                    tree[tree[v].parent].sons[1] != v);\n  }\n  void splay(int v) {\n    while (!is_root(v)) {\n      int u = tree[v].parent;\n      if (!is_root(u))\n        rotate((tree[tree[u].parent].sons[0] == u) == (tree[u].sons[0] == v)\n                   ? u\n                   : v);\n      rotate(v);\n    }\n    push(v);\n  }\n  void expose(int v) {\n    for (int u = v, prev = -1; u != -1; prev = u, u = tree[u].parent) {\n      splay(u);\n      tree[u].sons[1] = prev;\n      relax(u);\n    }\n    splay(v);\n    assert(tree[v].sons[1] == -1 && tree[v].parent == -1);\n  }\n  link_cut(int n = 0) : tree(n) {}\n  int add() {\n    tree.push_back(node());\n    return int(tree.size()) - 1;\n  }\n  void set_root(int root) {\n    expose(root);\n    tree[root].inv ^= 1;\n  }\n  bool connected(int v, int u) {\n    if (v == u) return true;\n    expose(v), expose(u);\n    return tree[v].parent != -1;\n  }\n  bool link(int v, int u) {\n    if (connected(v, u)) return false;\n    tree[u].inv ^= 1;\n    tree[u].parent = v;\n    expose(u);\n    return true;\n  }\n  bool cut(int v, int u) {\n    if (v == u) return false;\n    set_root(v), expose(u);\n    if (tree[u].sons[0] != v) return false;\n    tree[u].sons[0] = -1;\n    relax(u);\n    tree[v].parent = -1;\n    return true;\n  }\n  int parent(int v, int root) {\n    if (!connected(v, root)) return -1;\n    set_root(root), expose(v);\n    push(v);\n    if (tree[v].sons[0] == -1) return -1;\n    v = tree[v].sons[0];\n    while (push(v), tree[v].sons[1] != -1) v = tree[v].sons[1];\n    splay(v);\n    return v;\n  }\n  int distance(int v, int u) {\n    if (!connected(v, u)) return -1;\n    set_root(v), expose(u);\n    return tree[u].sons[0] == -1 ? 0 : tree[tree[u].sons[0]].size;\n  }\n  void update(int v, int value) {\n    splay(v);\n    tree[v].value = value;\n    relax(v);\n  }\n  int query(int v, int u) {\n    assert(v != u);\n    set_root(v), expose(u);\n    assert(tree[u].sons[0] != -1);\n    return tree[u].value ^ tree[tree[u].sons[0]].tot;\n  }\n};\nint main() {\n  using namespace std;\n  ios::sync_with_stdio(false), cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  disjoin_set_union dsu(n);\n  link_cut g(n + m);\n  for (int id = n; id < n + m; id++) {\n    int v, u, c;\n    cin >> v >> u >> c;\n    v--, u--;\n    if (dsu.root(v) != dsu.root(u)) {\n      cout << \"YES\\n\";\n      dsu.unite(v, u);\n      g.link(v, id);\n      g.link(u, id);\n      g.update(id, c);\n    } else {\n      if (!g.connected(v, u) || (g.query(v, u) ^ c) == 0) {\n        cout << \"NO\\n\";\n        continue;\n      }\n      cout << \"YES\\n\";\n      while (u != v) {\n        int w = g.parent(u, v);\n        g.cut(u, w);\n        u = w;\n      }\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void read(T& a) {\n  char c = getchar();\n  int f = 1;\n  a = 0;\n  while (c > '9' || c < '0') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c <= '9' && c >= '0') a = a * 10 + c - 48, c = getchar();\n  a *= f;\n}\nconst int o = 3e5 + 10;\nint n, q, anc[o][20], fa[o], h[o], cnt, uu[o * 2], vv[o * 2], ww[o * 2], dfn[o],\n    ed[o], dis[o], ft[o];\nbool ans[o * 2];\nstruct Edge {\n  int v, p, w;\n} e[o * 2];\ninline void ad(int U, int V, int W) {\n  e[++cnt].v = V;\n  e[cnt].p = h[U];\n  e[h[U] = cnt].w = W;\n}\nint fr(int x) { return fa[x] == x ? x : fa[x] = fr(fa[x]); }\ninline bool merge(int x, int y) {\n  x = fr(x);\n  y = fr(y);\n  if (x == y) return false;\n  fa[x] = y;\n  return true;\n}\nvoid dfs(int nw) {\n  dfn[nw] = ++cnt;\n  for (int i = h[nw]; i; i = e[i].p)\n    if (e[i].v ^ anc[nw][0])\n      dis[e[i].v] = dis[anc[e[i].v][0] = nw] ^ e[i].w, dfs(e[i].v);\n  ed[nw] = cnt;\n}\ninline bool ancoff(int x, int y) { return dfn[x] <= dfn[y] && ed[y] <= ed[x]; }\ninline int lca(int x, int y) {\n  if (ancoff(x, y)) return x;\n  for (int i = 19; i + 1; --i)\n    if (!ancoff(anc[x][i], y)) x = anc[x][i];\n  return anc[x][0];\n}\ninline int lowbit(int x) { return x & -x; }\ninline void modify(int pos, int val) {\n  for (; pos <= n + 1; pos += lowbit(pos)) ft[pos] += val;\n}\ninline int query(int pos) {\n  int res = 0;\n  for (; pos; pos -= lowbit(pos)) res += ft[pos];\n  return res;\n}\ninline void change(int x, int y) {\n  for (; x ^ y; x = anc[x][0]) modify(dfn[x], 1), modify(ed[x] + 1, -1);\n}\nint main() {\n  read(n);\n  read(q);\n  for (int i = 1; i <= n; ++i) fa[i] = i;\n  for (int i = 1; i <= q; ++i) {\n    read(uu[i]);\n    read(vv[i]);\n    read(ww[i]);\n    if (merge(uu[i], vv[i]))\n      ad(uu[i], vv[i], ww[i]), ad(vv[i], uu[i], ww[i]), ans[i] = 1;\n  }\n  cnt = 0;\n  for (int i = 1; i <= n; ++i)\n    if (!dfn[i]) dfs(i);\n  ed[0] = cnt;\n  for (int i = 1; i < 20; ++i)\n    for (int j = 1; j <= n; ++j) anc[j][i] = anc[anc[j][i - 1]][i - 1];\n  for (int i = 1, j; i <= q; ++i)\n    if (!ans[i] && query(dfn[uu[i]]) + query(dfn[vv[i]]) ==\n                       2 * query(dfn[j = lca(uu[i], vv[i])]))\n      if (ww[i] ^ dis[uu[i]] ^ dis[vv[i]] == 1)\n        ans[i] = 1, change(uu[i], j), change(vv[i], j);\n  for (int i = 1; i <= q; ++i)\n    if (ans[i])\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization(\"unroll-loops, no-stack-protector\")\n#pragma GCC target(\"avx,avx2,fma\")\nusing namespace std;\nconst int maxn = 3e5 + 80;\nconst int mod = 998244353;\nconst int base = 1e18;\nint st[4 * maxn];\nstruct Seqment_tree {\n  int get(int id, int left, int right, int x, int y) {\n    if (left > y || right < x) return 0;\n    if (x <= left && right <= y) {\n      return st[id];\n    }\n    int mid = (left + right) / 2;\n    return (get(id * 2, left, mid, x, y) +\n            get(id * 2 + 1, mid + 1, right, x, y));\n  }\n  void update(int id, int left, int right, int pos, int diff) {\n    if (pos < left || pos > right) return;\n    if (left == right) {\n      st[id] = diff;\n      return;\n    }\n    int mid = (left + right) / 2;\n    update(id * 2, left, mid, pos, diff);\n    update(id * 2 + 1, mid + 1, right, pos, diff);\n    st[id] = (st[id * 2] + st[id * 2 + 1]);\n  }\n} man;\nvector<pair<int, int> > adj[maxn];\nint par[maxn];\nint siz[maxn];\nint find_par(int u) {\n  if (u == par[u]) return u;\n  return par[u] = find_par(par[u]);\n}\nbool dsu(int x, int y) {\n  x = find_par(x);\n  y = find_par(y);\n  if (x == y) return true;\n  par[x] = y;\n  return false;\n}\nint anc[maxn][20];\nbool dd[maxn * 2];\nint x[maxn * 2];\nint y[maxn * 2];\nint w[maxn * 2];\nint dep[maxn];\nint dep1[maxn];\nbool kt[maxn];\nvoid dfs(int u, int par) {\n  anc[u][0] = par;\n  for (int i = 1; i < 20; i++) {\n    anc[u][i] = anc[anc[u][i - 1]][i - 1];\n  }\n  siz[u] = 1;\n  kt[u] = 1;\n  for (auto p : adj[u]) {\n    int to = p.first;\n    int w = p.second;\n    if (to == par) continue;\n    dep[to] = dep[u] + 1;\n    dep1[to] = dep1[u] ^ w;\n    dfs(to, u);\n    siz[u] += siz[to];\n  }\n}\nint lca(int x, int y) {\n  if (dep[y] > dep[x]) swap(x, y);\n  int kc = dep[x] - dep[y];\n  for (int i = 19; i >= 0; i--) {\n    if (kc & (1ll << i)) {\n      x = anc[x][i];\n    }\n  }\n  if (x == y) return x;\n  for (int i = 19; i >= 0; i--) {\n    if (anc[x][i] != anc[y][i]) {\n      x = anc[x][i];\n      y = anc[y][i];\n    }\n  }\n  return anc[x][0];\n}\nint getd(int x, int y) { return dep1[x] ^ dep1[y]; }\nvoid dsu1(int x, int y) {\n  x = find_par(x);\n  y = find_par(y);\n  if (x == y) return;\n  if (dep[x] > dep[y]) swap(x, y);\n  par[x] = y;\n}\nint cntnw = 0;\nint nchain = 0;\nint chainhead[maxn];\nint chainid[maxn];\nint id[maxn];\nvoid hld(int u) {\n  if (!chainhead[nchain]) chainhead[nchain] = u;\n  cntnw++;\n  chainid[u] = nchain;\n  id[u] = cntnw;\n  int nxt = -1;\n  for (auto p : adj[u]) {\n    int to = p.first;\n    if (to == anc[u][0]) continue;\n    if (nxt == -1 || siz[nxt] < siz[to]) {\n      nxt = to;\n    }\n  }\n  if (nxt != -1) {\n    hld(nxt);\n  }\n  for (auto p : adj[u]) {\n    int to = p.first;\n    if (to == anc[u][0] || to == nxt) continue;\n    nchain++;\n    hld(to);\n  }\n}\nint getn(int x, int y) {\n  int kc = dep[x] - dep[y] - 1;\n  for (int i = 19; i >= 0; i--) {\n    if (kc & (1ll << i)) {\n      x = anc[x][i];\n    }\n  }\n  return x;\n}\nint get(int u, int a) {\n  int p = chainid[u];\n  int chk = chainid[a];\n  int ans = 0;\n  while (1) {\n    if (p == chk) {\n      ans += man.get(1, 1, cntnw, id[a], id[u]);\n      break;\n    }\n    ans += man.get(1, 1, cntnw, id[chainhead[p]], id[u]);\n    u = anc[chainhead[p]][0];\n    p = chainid[u];\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  if (fopen(\"t.inp\", \"r\")) {\n    freopen(\"test.inp\", \"r\", stdin);\n    freopen(\"test.out\", \"w\", stdout);\n  }\n  int n, q;\n  cin >> n >> q;\n  for (int i = 1; i <= n; i++) {\n    par[i] = i;\n  }\n  for (int i = 1; i <= q; i++) {\n    cin >> x[i] >> y[i] >> w[i];\n    if (!dsu(x[i], y[i])) {\n      adj[x[i]].push_back(make_pair(y[i], w[i]));\n      adj[y[i]].push_back(make_pair(x[i], w[i]));\n      dd[i] = 1;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (kt[i]) continue;\n    nchain++;\n    dfs(i, 0);\n    hld(i);\n  }\n  for (int i = 1; i <= q; i++) {\n    if (dd[i]) {\n      cout << \"YES\"\n           << \"\\n\";\n    } else {\n      if (dep[x[i]] < dep[y[i]]) swap(x[i], y[i]);\n      int h = lca(x[i], y[i]);\n      bool chk = true;\n      if (h == y[i]) {\n        if (get(x[i], getn(x[i], h))) {\n          chk = false;\n        }\n      } else {\n        if (get(x[i], getn(x[i], h))) chk = false;\n        if (get(y[i], getn(y[i], h))) chk = false;\n      }\n      if ((getd(x[i], y[i]) ^ w[i]) == 1 && chk) {\n        int nw = x[i];\n        while (dep[nw] > dep[h]) {\n          man.update(1, 1, cntnw, id[nw], 1);\n          nw = anc[nw][0];\n        }\n        nw = y[i];\n        while (dep[nw] > dep[h]) {\n          man.update(1, 1, cntnw, id[nw], 1);\n          nw = anc[nw][0];\n        }\n        cout << \"YES\"\n             << \"\\n\";\n      } else {\n        cout << \"NO\"\n             << \"\\n\";\n      }\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long val[1200005], tag[1200005], a[300005];\nlong long dfn[300005], dfc = 0, rid[300005], fa[300005], top[300005],\n                       siz[300005], son[300005], dep[300005];\nlong long sum[300005];\nlong long n, m, eu[600005], ev[600005], ew[600005], flg[600005];\nlong long ec = 0, to[600005], nxt[600005], hed[300005], w[600005];\nvoid add_edge(long long f, long long t, long long cst) {\n  ++ec;\n  to[ec] = t;\n  nxt[ec] = hed[f];\n  w[ec] = cst;\n  hed[f] = ec;\n}\nvoid pushup(long long x) { val[x] = val[(x << 1)] + val[((x << 1) | 1)]; }\nvoid pushdown(long long x, long long l, long long r) {\n  if (!tag[x]) return;\n  long long mid = (l + r) >> 1;\n  tag[(x << 1)] += tag[x];\n  val[(x << 1)] += tag[x] * (mid - l + 1);\n  tag[((x << 1) | 1)] += tag[x];\n  val[((x << 1) | 1)] += tag[x] * (r - mid);\n  tag[x] = 0;\n}\nvoid modify(long long x, long long l, long long r, long long L, long long R,\n            long long v) {\n  if (L > R) return;\n  if (L <= l && r <= R) {\n    tag[x] += v;\n    val[x] += v * (r - l + 1);\n    return;\n  }\n  long long mid = (l + r) >> 1;\n  pushdown(x, l, r);\n  if (L <= mid) modify((x << 1), l, mid, L, R, v);\n  if (R > mid) modify(((x << 1) | 1), mid + 1, r, L, R, v);\n  pushup(x);\n}\nlong long query(long long x, long long l, long long r, long long L,\n                long long R) {\n  if (L > R) return 0;\n  if (L <= l && r <= R) return val[x];\n  long long mid = (l + r) >> 1, ret = 0;\n  pushdown(x, l, r);\n  if (L <= mid) ret += query((x << 1), l, mid, L, R);\n  if (R > mid) ret += query(((x << 1) | 1), mid + 1, r, L, R);\n  pushup(x);\n  return ret;\n}\nvoid dfs1(long long u, long long f) {\n  siz[u] = 1;\n  dep[u] = dep[f] + 1;\n  fa[u] = f;\n  for (long long i = hed[u]; i; i = nxt[i]) {\n    long long v = to[i];\n    if (v == f) continue;\n    sum[v] = sum[u] ^ w[i];\n    dfs1(v, u);\n    siz[u] += siz[v];\n    if (siz[v] > siz[son[u]]) son[u] = v;\n  }\n}\nvoid dfs2(long long u, long long t) {\n  top[u] = t;\n  dfn[u] = ++dfc;\n  rid[dfc] = u;\n  if (son[u]) dfs2(son[u], t);\n  for (long long i = hed[u]; i; i = nxt[i]) {\n    long long v = to[i];\n    if (v == fa[u] || v == son[u]) continue;\n    dfs2(v, v);\n  }\n}\nvoid modify_chain(long long x, long long y, long long v) {\n  while (top[x] != top[y]) {\n    if (dep[top[x]] < dep[top[y]]) swap(x, y);\n    modify(1, 1, n, dfn[top[x]], dfn[x], v);\n    x = fa[top[x]];\n  }\n  if (dep[x] < dep[y]) swap(x, y);\n  modify(1, 1, n, dfn[y] + 1, dfn[x], v);\n}\nvoid modify_son(long long x, long long v) {\n  modify(1, 1, n, dfn[x], dfn[x] + siz[x] - 1, v);\n}\nlong long query_chain(long long x, long long y) {\n  long long ret = 0;\n  while (top[x] != top[y]) {\n    if (dep[top[x]] < dep[top[y]]) swap(x, y);\n    ret += query(1, 1, n, dfn[top[x]], dfn[x]);\n    x = fa[top[x]];\n  }\n  if (dep[x] < dep[y]) swap(x, y);\n  ret += query(1, 1, n, dfn[y] + 1, dfn[x]);\n  return ret;\n}\nlong long ff[300005];\nlong long getf(long long x) {\n  if (x == ff[x]) return x;\n  return ff[x] = getf(ff[x]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) ff[i] = i;\n  for (long long i = 1; i <= m; i++) {\n    cin >> eu[i] >> ev[i] >> ew[i];\n    if (getf(eu[i]) != getf(ev[i])) {\n      ff[getf(eu[i])] = getf(ev[i]);\n      add_edge(eu[i], ev[i], ew[i]);\n      add_edge(ev[i], eu[i], ew[i]);\n      flg[i] = 1;\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    if (!dfn[i]) {\n      sum[i] = 0;\n      dfs1(i, 0);\n      dfs2(i, 1);\n    }\n  }\n  for (long long i = 1; i <= m; i++) {\n    if (flg[i]) {\n      cout << \"YES\\n\";\n      continue;\n    }\n    if (query_chain(eu[i], ev[i]) > 0 ||\n        (sum[eu[i]] ^ sum[ev[i]] ^ ew[i]) != 1) {\n      cout << \"NO\\n\";\n      continue;\n    }\n    cout << \"YES\\n\";\n    modify_chain(eu[i], ev[i], 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300000;\nconst int B = 18;\nint timerin, timerout;\nint tin[N + 1], tout[N + 1];\nint comp[N + 1];\nint par[N + 1][B + 1];\nint sum[N + 1], xorup[N + 1];\nint f[N + 2];\nvoid upd(int x, int d) {\n  for (; x <= N; x += (x & -x)) f[x] += d;\n}\nint cnt(int x) {\n  int ans = 0;\n  for (; x > 0; x -= (x & -x)) ans += f[x];\n  return ans;\n}\nvector<pair<int, int> > v[N + 1];\nbool isp(int a, int b) { return tin[a] <= tin[b] && tout[b] <= tout[a]; }\nint lca(int a, int b) {\n  if (isp(a, b)) return a;\n  for (int i = B; i >= 0; i--)\n    if (par[a][i] && !isp(par[a][i], b)) a = par[a][i];\n  return par[a][0];\n}\nint dfs(int p, int parent) {\n  tin[p] = ++timerin;\n  par[p][0] = parent;\n  for (int i = 1; i <= B; i++) par[p][i] = par[par[p][i - 1]][i - 1];\n  for (int i = 0; i < v[p].size(); i++)\n    if (v[p][i].first != parent) {\n      xorup[v[p][i].first] = xorup[p] ^ v[p][i].second;\n      int d = dfs(v[p][i].first, p);\n      sum[p] += d + 1;\n    }\n  tout[p] = ++timerout;\n  return sum[p];\n}\nvoid update(int p, int top) {\n  for (int t = p; t != top; t = par[t][0]) {\n    upd(tin[t], 1);\n    upd(tin[t] + sum[t] + 1, -1);\n  }\n}\nbool solve(int a, int b, int x) {\n  if (x == -1) return 1;\n  if ((xorup[a] ^ xorup[b] ^ x) == 0) return 0;\n  int top = lca(a, b);\n  if (cnt(tin[a]) + cnt(tin[b]) > 2 * cnt(tin[top])) return 0;\n  update(a, top);\n  update(b, top);\n  return 1;\n}\nint parent(int p) {\n  if (comp[p] != p) comp[p] = parent(comp[p]);\n  return comp[p];\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) comp[i] = i;\n  int a[m], b[m], x[m];\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d %d\", a + i, b + i, x + i);\n    if (parent(a[i]) != parent(b[i])) {\n      comp[parent(a[i])] = parent(b[i]);\n      v[a[i]].push_back(make_pair(b[i], x[i]));\n      v[b[i]].push_back(make_pair(a[i], x[i]));\n      x[i] = -1;\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (parent(i) == i) dfs(i, 0);\n  for (int i = 0; i < m; i++)\n    if (solve(a[i], b[i], x[i]))\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 20;\nconst int L = 18;\nvector<pair<int, int>> g[N];\nint xr[N], sz[N];\nint up[N][L + 1], tin[N], tout[N], timer;\nint pr[N];\nint vis[N];\nint root(int v) {\n  if (pr[v] == v) return v;\n  return pr[v] = root(pr[v]);\n}\nbool merge(int u, int v) {\n  u = root(u);\n  v = root(v);\n  if (u == v) return false;\n  pr[u] = v;\n  return true;\n}\nvoid dfs(int v, int p) {\n  ++vis[v];\n  tin[v] = ++timer;\n  up[v][0] = (p == -1 ? v : p);\n  for (int i = 1; i <= L; i++) up[v][i] = up[up[v][i - 1]][i - 1];\n  sz[v] = 1;\n  for (auto [to, x] : g[v]) {\n    if (to == p) continue;\n    xr[to] = xr[v] ^ x;\n    dfs(to, v);\n    sz[v] += sz[to];\n  }\n  tout[v] = ++timer;\n}\nbool upper(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }\nint getLCA(int u, int v) {\n  if (upper(u, v)) return u;\n  if (upper(v, u)) return v;\n  for (int i = L; i >= 0; i--)\n    if (!upper(up[v][i], u)) v = up[v][i];\n  return up[v][0];\n}\nint chain[N], pos[N], start[N], curp, curch;\nvoid hld(int v, int p) {\n  ++vis[v];\n  pos[v] = curp++;\n  int big = -1;\n  for (auto [to, x] : g[v]) {\n    if (to == p) continue;\n    if (big == -1 || sz[to] > sz[big]) big = to;\n  }\n  if (big == -1) return;\n  chain[big] = chain[v];\n  hld(big, v);\n  for (auto [to, x] : g[v]) {\n    if (to == p || to == big) continue;\n    chain[to] = ++curch;\n    start[curch] = to;\n    hld(to, v);\n  }\n}\nbool t[4 * N], b[4 * N];\nbool get(int v, int tl, int tr, int l, int r) {\n  if (l > r) return 0;\n  if (t[v]) return true;\n  if (tl == l && tr == r) {\n    return b[v];\n  }\n  int tm = (tl + tr) / 2;\n  return (get(v * 2, tl, tm, l, min(r, tm)) ||\n          get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\n}\nvoid upd(int v, int tl, int tr, int l, int r) {\n  if (l > r) return;\n  if (tl == l && tr == r) {\n    t[v] = b[v] = true;\n    return;\n  }\n  b[v] = true;\n  int tm = (tl + tr) / 2;\n  upd(v * 2, tl, tm, l, min(r, tm));\n  upd(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);\n}\nbool query(int u, int v) {\n  int z = getLCA(u, v);\n  bool mark = false;\n  while (!mark) {\n    if (chain[u] == chain[z]) {\n      mark |= get(1, 0, N - 1, pos[z] + 1, pos[u]);\n      break;\n    }\n    mark |= get(1, 0, N - 1, pos[start[chain[u]]], pos[u]);\n    u = up[start[chain[u]]][0];\n  }\n  while (!mark) {\n    if (chain[v] == chain[z]) {\n      mark |= get(1, 0, N - 1, pos[z] + 1, pos[v]);\n      break;\n    }\n    mark |= get(1, 0, N - 1, pos[start[chain[v]]], pos[v]);\n    v = up[start[chain[v]]][0];\n  }\n  return mark;\n}\nvoid upd(int u, int v) {\n  int z = getLCA(u, v);\n  while (true) {\n    if (chain[u] == chain[z]) {\n      upd(1, 0, N - 1, pos[z] + 1, pos[u]);\n      break;\n    }\n    upd(1, 0, N - 1, pos[start[chain[u]]], pos[u]);\n    u = up[start[chain[u]]][0];\n  }\n  while (true) {\n    if (chain[v] == chain[z]) {\n      upd(1, 0, N - 1, pos[z] + 1, pos[v]);\n      break;\n    }\n    upd(1, 0, N - 1, pos[start[chain[v]]], pos[v]);\n    v = up[start[chain[v]]][0];\n  }\n}\nint main() {\n  ios_base ::sync_with_stdio(0);\n  cout.tie(0);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  vector<tuple<int, int, int>> s;\n  iota(pr, pr + n, 0);\n  for (int i = 0; i < q; i++) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    --u;\n    --v;\n    if (merge(u, v)) {\n      g[u].push_back({v, x});\n      g[v].push_back({u, x});\n      x = -1;\n    }\n    s.push_back(make_tuple(u, v, x));\n  }\n  for (int i = 0; i < n; i++)\n    if (vis[i] == 0) dfs(i, -1);\n  for (int i = 0; i < n; i++)\n    if (vis[i] == 1) hld(i, -1);\n  for (auto [u, v, x] : s) {\n    if (x == -1) {\n      cout << \"YES\\n\";\n      continue;\n    }\n    if ((xr[u] ^ xr[v] ^ x) != 1 || query(u, v)) {\n      cout << \"NO\\n\";\n      continue;\n    }\n    cout << \"YES\\n\";\n    upd(u, v);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid print(T& x) {\n  cout << x;\n}\ntemplate <class T, class U>\nvoid print(pair<T, U>& p) {\n  cout << \"(\";\n  print(p.first);\n  cout << \", \";\n  print(p.second);\n  cout << \")\";\n}\ntemplate <class T>\nvoid print(vector<T>& v) {\n  cout << \"{\";\n  if (((int)(v).size())) print(v[0]);\n  for (int i = 1; i < ((int)(v).size()); i++) cout << \", \", print(v[i]);\n  cout << \"}\\n\";\n}\nconst int n = 1e6 + 10;\nint N, Q;\nvector<vector<pair<int, int>>> T;\nint X[n];\nint Par[n];\npair<int, int> intv[n];\nint newNum[n];\nint cmp[n];\nstruct fenwick_tree {\n  int n;\n  vector<int> a, f;\n  fenwick_tree(int n = 0) : n(n), a(n), f(n + 1) {}\n  fenwick_tree(vector<int>& a) : fenwick_tree(a.size()) {\n    for (int i = 0; i < n; i++) setValue(i, a[i]);\n  }\n  void changeValue(int i, int d) {\n    for (a[i++] += d; i <= n; i += i & -i) f[i] += d;\n  }\n  void setValue(int i, int v) { changeValue(i, v - a[i]); }\n  int getSum(int i) {\n    int s = 0;\n    for (i++; i; i -= i & -i) s += f[i];\n    return s;\n  }\n  int getSum(int l, int r) { return getSum(r - 1) - getSum(l - 1); }\n};\nstruct sparse_table {\n  int n;\n  vector<int> a;\n  vector<vector<int>> st;\n  int combine(int dl, int dr) { return a[dl] > a[dr] ? dl : dr; }\n  sparse_table() {}\n  sparse_table(vector<int>& a)\n      : n(a.size()), a(a), st((31 - __builtin_clz(n)) + 1, vector<int>(n)) {\n    for (int i = 0; i < n; i++) st[0][i] = i;\n    for (int j = 1; 1 << j <= n; j++)\n      for (int i = 0; i + (1 << j) <= n; i++)\n        st[j][i] = combine(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);\n  }\n  int query(int l, int r) {\n    int s = (31 - __builtin_clz(r - l));\n    return combine(st[s][l], st[s][r - (1 << s)]);\n  }\n};\nstruct lowest_common_ancestor {\n  int n, m = 0;\n  vector<int> a, v, h;\n  vector<vector<int>>& e;\n  sparse_table st;\n  lowest_common_ancestor(vector<vector<int>>& e, int r)\n      : n(e.size()), a(n), v(2 * n - 1), h(2 * n - 1), e(e) {\n    dfs(r);\n    st = sparse_table(h);\n  }\n  void dfs(int i, int p = -1, int d = 0) {\n    a[i] = m;\n    v[m] = i;\n    h[m++] = d;\n    for (int j : e[i]) {\n      if (j == p) continue;\n      dfs(j, i, d - 1);\n      v[m] = i;\n      h[m++] = d;\n    }\n  }\n  int lca(int x, int y) {\n    return v[st.query(min(a[x], a[y]), max(a[x], a[y]) + 1)];\n  }\n};\nfenwick_tree BIT(n);\nvoid initDSU() {\n  for (int i = 0; i < N; i++) {\n    cmp[i] = i;\n  }\n}\nint find(int x) {\n  if (cmp[x] != x) cmp[x] = find(cmp[x]);\n  return cmp[x];\n}\nvoid combine(int a, int b) { cmp[find(a)] = find(b); }\nint newN = 0;\nvoid dfs(int cur, int par) {\n  newNum[cur] = newN;\n  int l = newN++;\n  for (auto [x, w] : T[cur]) {\n    if (x == par) continue;\n    Par[x] = cur;\n    X[x] = X[cur] ^ w;\n    dfs(x, cur);\n  }\n  intv[cur] = make_pair(l, newN - 1);\n}\nvoid mark(int x) {\n  auto [l, r] = intv[x];\n  BIT.changeValue(l, 1);\n  BIT.changeValue(r + 1, -1);\n}\nvoid markPath(int x, int to) {\n  while (x != to) {\n    mark(x);\n    x = Par[x];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> N >> Q;\n  T.resize(N);\n  vector<tuple<int, int, int>> A;\n  initDSU();\n  for (int i = 0; i < Q; i++) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    u--;\n    v--;\n    A.emplace_back(u, v, x);\n    if (find(u) != find(v)) {\n      T[u].emplace_back(v, x);\n      T[v].emplace_back(u, x);\n      combine(u, v);\n    }\n  }\n  for (int i = 1; i < N; i++) {\n    if (find(i) != find(0)) {\n      combine(0, i);\n      T[0].emplace_back(i, 0);\n      T[i].emplace_back(0, 0);\n    }\n  }\n  initDSU();\n  dfs(0, -1);\n  vector<vector<int>> e(N);\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < ((int)(T[i]).size()); j++)\n      e[i].push_back(T[i][j].first);\n  }\n  lowest_common_ancestor LCA(e, 0);\n  for (auto [u, v, x] : A) {\n    if (find(u) != find(v)) {\n      combine(u, v);\n      cout << \"YES\\n\";\n    } else if ((X[u] ^ X[v] ^ x) == 1) {\n      int lca = LCA.lca(u, v);\n      int sum = BIT.getSum(newNum[u]) + BIT.getSum(newNum[v]) -\n                2 * BIT.getSum(newNum[lca]);\n      if (sum == 0) {\n        cout << \"YES\\n\";\n        markPath(v, lca);\n        markPath(u, lca);\n      } else\n        cout << \"NO\\n\";\n    } else\n      cout << \"NO\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX = 6e5 + 10;\nint U[MX];\nint V[MX];\nint W[MX];\nbool ans[MX];\nint rnk[MX];\nint parent[MX];\nint findSet(int i) {\n  if (parent[i] == i) return i;\n  parent[i] = findSet(parent[i]);\n  return parent[i];\n}\nvoid unionSet(int i, int j) {\n  int x = findSet(i);\n  int y = findSet(j);\n  if (y != x) {\n    if (rnk[x] <= rnk[y]) swap(x, y);\n    parent[y] = x;\n    if (rnk[x] == rnk[y]) rnk[y]++;\n  }\n  return;\n}\nvector<int> eulerPath;\nvector<int> adj[MX];\nvector<int> pes[MX];\nint anc[MX][20];\nint pos[2][MX];\nint T[MX];\nint L[MX];\nint XOR[MX];\nvoid build(int n) {\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; (1ll << j) <= n; j++) {\n      anc[i][j] = -1;\n    }\n  }\n  for (int i = 0; i <= n; i++) anc[i][0] = T[i];\n  for (int j = 1; (1ll << j) <= n; j++) {\n    for (int i = 0; i <= n; i++) {\n      if (anc[i][j - 1] != -1) anc[i][j] = anc[anc[i][j - 1]][j - 1];\n    }\n  }\n  return;\n}\nint lca(int u, int v) {\n  if (L[u] < L[v]) swap(u, v);\n  int lg = 63 - (__builtin_clzll(L[u]));\n  for (int i = lg; i >= 0; i--) {\n    if (L[u] - (1ll << i) >= L[v]) u = anc[u][i];\n  }\n  if (u == v) return u;\n  for (int i = lg; i >= 0; i--) {\n    if (anc[u][i] != -1 && anc[u][i] != anc[v][i]) {\n      u = anc[u][i];\n      v = anc[v][i];\n    }\n  }\n  return T[u];\n}\nvoid dfs(int u, int ac = 0) {\n  XOR[u] = ac;\n  pos[0][u] = eulerPath.size();\n  eulerPath.push_back(u);\n  int sz = adj[u].size();\n  for (int i = 0; i < sz; i++) {\n    int v = adj[u][i];\n    int w = pes[u][i];\n    if (L[v] == -1) {\n      T[v] = u;\n      L[v] = L[u] + 1;\n      dfs(v, ac ^ w);\n    }\n  }\n  pos[1][u] = eulerPath.size();\n  eulerPath.push_back(u);\n  return;\n}\nstruct FenwickTree {\n  int tree[MX];\n  FenwickTree() {\n    for (int i = 0; i < MX; i++) tree[i] = 0;\n  }\n  int query(int i) {\n    i += 1;\n    int sum = 0;\n    while (i > 0) {\n      sum += tree[i];\n      i -= (i & -i);\n    }\n    return sum;\n  }\n  void update(int i, int dif) {\n    i += 1;\n    while (i < MX) {\n      tree[i] += dif;\n      i += (i & -i);\n    }\n  }\n} FT;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cout.precision(10);\n  cout << fixed;\n  for (int i = 0; i < MX; i++) parent[i] = i;\n  for (int i = 0; i < MX; i++) L[i] = T[i] = -1;\n  int n, m, u, v, w;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> U[i] >> V[i] >> W[i];\n    u = U[i], v = V[i], w = W[i];\n    if (findSet(u) != findSet(v)) {\n      adj[u].push_back(v);\n      pes[u].push_back(w);\n      adj[v].push_back(u);\n      pes[v].push_back(w);\n      unionSet(u, v);\n      ans[i] = true;\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (L[i] == -1) {\n      L[i] = 0;\n      dfs(i);\n    }\n  build(n);\n  for (int i = 0; i < m; i++) {\n    u = U[i], v = V[i], w = W[i];\n    if (ans[i]) {\n      cout << \"YES\\n\";\n    } else {\n      int lca_ = lca(u, v);\n      int val = FT.query(pos[0][u]) + FT.query(pos[0][v]) -\n                2 * FT.query(pos[0][lca_]);\n      int xr = ((XOR[u] ^ XOR[v]) ^ w);\n      if (val == 0 && xr == 1) {\n        cout << \"YES\\n\";\n        while (u != lca_) {\n          FT.update(pos[0][u], 1);\n          FT.update(pos[1][u], -1);\n          u = T[u];\n        }\n        while (v != lca_) {\n          FT.update(pos[0][v], 1);\n          FT.update(pos[1][v], -1);\n          v = T[v];\n        }\n      } else {\n        cout << \"NO\\n\";\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 600005;\nconst int inf = 1 << 30;\nstruct BIT {\n  int c[maxn];\n  void update(int x, int val, int n) {\n    for (int i = x; i <= n; i += i & -i) {\n      c[i] += val;\n    }\n  }\n  int ask(int x) {\n    int ans = 0;\n    for (int i = x; i; i -= i & -i) {\n      ans += c[i];\n    }\n    return ans;\n  }\n} T;\nstruct Edge {\n  int to, next, val;\n  Edge(int to = 0, int next = 0, int val = 0) : to(to), next(next), val(val) {}\n} a[maxn * 2];\nstruct Question {\n  int x, y, val;\n} e[maxn];\nint n, m;\nint cnt;\nint tot;\nint top;\nint h[maxn];\nint fa[maxn];\nint lg[maxn];\nint ans[maxn];\nint pre[maxn];\nint fir[maxn];\nint lst[maxn];\nint depth[maxn];\nint st[20][maxn * 2];\nint xor_val[maxn * 2];\nbool vis[maxn];\nvoid add(int x, int y, int val) {\n  a[++cnt] = Edge(y, h[x], val);\n  h[x] = cnt;\n}\nint f(int x) { return fa[x] == x ? x : fa[x] = f(fa[x]); }\nvoid dfs(int x) {\n  vis[x] = 1;\n  st[0][++top] = x;\n  pre[x] = top;\n  fir[x] = ++tot;\n  for (int i = h[x]; i; i = a[i].next) {\n    if (vis[a[i].to]) {\n      continue;\n    }\n    xor_val[a[i].to] = xor_val[x] ^ a[i].val;\n    depth[a[i].to] = depth[x] + 1;\n    fa[a[i].to] = x;\n    dfs(a[i].to);\n    st[0][++top] = x;\n  }\n  lst[x] = tot;\n}\nint getmin(int x, int y) { return depth[x] < depth[y] ? x : y; }\nint lca(int x, int y) {\n  x = pre[x], y = pre[y];\n  if (x > y) {\n    swap(x, y);\n  }\n  int k = lg[y - x + 1];\n  return getmin(st[k][x], st[k][y - (1 << k) + 1]);\n}\nint xor_dist(int x, int y) { return xor_val[x] ^ xor_val[y]; }\nint check(int x, int y, int p) {\n  return T.ask(fir[x]) + T.ask(fir[y]) - 2 * T.ask(fir[p]);\n}\nvoid update(int x, int p) {\n  if (x == p) {\n    return;\n  }\n  while (x != p) {\n    T.update(fir[x], 1, n);\n    T.update(lst[x] + 1, -1, n);\n    x = fa[x];\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    fa[i] = i;\n  }\n  for (int i = 1; i <= m; i++) {\n    cin >> e[i].x >> e[i].y >> e[i].val;\n    int x = f(e[i].x), y = f(e[i].y);\n    if (x != y) {\n      add(e[i].x, e[i].y, e[i].val);\n      add(e[i].y, e[i].x, e[i].val);\n      fa[x] = y;\n      ans[i] = 1;\n    }\n  }\n  memset(fa, 0, sizeof(fa));\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      dfs(i);\n    }\n  }\n  for (int i = 2; i <= top; i++) {\n    lg[i] = lg[i >> 1] + 1;\n  }\n  for (int i = 1; (1 << i) <= top; i++) {\n    for (int j = 1; j + (1 << i) - 1 <= top; j++) {\n      st[i][j] = getmin(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    if (ans[i]) {\n      continue;\n    }\n    int x = e[i].x, y = e[i].y, val = e[i].val;\n    if ((xor_dist(x, y) ^ val) == 0) {\n      continue;\n    }\n    int p = lca(x, y);\n    if (check(x, y, p)) {\n      continue;\n    }\n    update(x, p);\n    update(y, p);\n    ans[i] = 1;\n  }\n  for (int i = 1; i <= m; i++) {\n    cout << (ans[i] ? \"YES\" : \"NO\") << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct nodS {\n  bool viz;\n  int val, l, r, d;\n  int par[22];\n  vector<pair<int, int>> v;\n};\nstruct edgeS {\n  int x, y, w, id;\n  edgeS(int x, int y, int w, int id) {\n    this->x = x;\n    this->y = y;\n    this->w = w;\n    this->id = id;\n  }\n};\nint n, q, timp;\nnodS nod[300005];\nint dsu[300005];\nint euler[600005];\nint ans[500005];\nvector<edgeS> edges;\nint dsu_anc(int x) {\n  if (dsu[x] != x) dsu[x] = dsu_anc(dsu[x]);\n  return dsu[x];\n}\nbool dsu_merge(int x, int y) {\n  x = dsu_anc(x);\n  y = dsu_anc(y);\n  if (x == y) return false;\n  dsu[x] = y;\n  return true;\n}\nint anc(int x, int d) {\n  for (int b = 0; b <= 20; b++)\n    if ((d >> b) & 1) x = nod[x].par[b];\n  return x;\n}\nint lca(int x, int y) {\n  if (nod[x].d > nod[y].d) swap(x, y);\n  y = anc(y, nod[y].d - nod[x].d);\n  if (x == y) return x;\n  for (int b = 20; b >= 0; b--) {\n    if (nod[x].par[b] != nod[y].par[b]) {\n      x = nod[x].par[b];\n      y = nod[y].par[b];\n    }\n  }\n  return nod[x].par[0];\n}\nvoid addBit(int i, int val) {\n  for (; i <= 2 * n; i += ((i) & -(i))) euler[i] += val;\n}\nint queryBit(int i) {\n  int ans = 0;\n  for (; i >= 1; i -= ((i) & -(i))) ans += euler[i];\n  return ans;\n}\nvoid addNod(int x) {\n  addBit(nod[x].l, 1);\n  addBit(nod[x].r, -1);\n}\nvoid addPath(int x, int y) {\n  while (nod[x].d > nod[y].d) {\n    addNod(x);\n    x = nod[x].par[0];\n  }\n}\nint queryPath(int x, int y) { return queryBit(nod[x].l) - queryBit(nod[y].l); }\nvoid dfs(int p, int parV, int valX) {\n  timp++;\n  nod[p].l = timp;\n  nod[p].viz = true;\n  nod[p].d = nod[parV].d + 1;\n  nod[p].val = valX;\n  nod[p].par[0] = parV;\n  for (int b = 1; b <= 20; b++)\n    nod[p].par[b] = nod[nod[p].par[b - 1]].par[b - 1];\n  for (auto it : nod[p].v)\n    if (it.first != parV) dfs(it.first, p, valX ^ it.second);\n  timp++;\n  nod[p].r = timp;\n}\nvoid buildTree() {\n  cin >> n >> q;\n  for (int i = 1; i <= n; i++) dsu[i] = i;\n  for (int i = 1; i <= q; i++) {\n    int x, y, w;\n    cin >> x >> y >> w;\n    if (dsu_merge(x, y)) {\n      nod[x].v.push_back({y, w});\n      nod[y].v.push_back({x, w});\n      ans[i] = true;\n    } else\n      edges.push_back(edgeS(x, y, w, i));\n  }\n  for (int i = 1; i <= n; i++)\n    if (!nod[i].viz) dfs(i, 0, 0);\n}\nint main() {\n  buildTree();\n  for (auto it : edges) {\n    int x = it.x;\n    int y = it.y;\n    int w = it.w;\n    int id = it.id;\n    int valX = nod[x].val ^ nod[y].val;\n    if (valX == w) continue;\n    int l = lca(x, y);\n    if (queryPath(x, l) || queryPath(y, l)) continue;\n    ans[id] = true;\n    addPath(x, l);\n    addPath(y, l);\n  }\n  for (int i = 1; i <= q; i++) {\n    if (ans[i])\n      cout << \"yes\\n\";\n    else\n      cout << \"no\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int c = (1 << 20), k = c / 2, lg = 20;\nint n, m, hv[c], aa[c], bb[c], xo[c];\nint kezd[c], veg[c], maxi[c];\nint cnt, be[c], ki[c], fel[c], ert[c], szint[c], fel2[c][lg];\nvector<pair<int, int> > sz[c];\nbool v[c], jo[c];\nint holvan(int a) { return (hv[a] ? hv[a] = holvan(hv[a]) : a); }\nbool unio(int a, int b) {\n  a = holvan(a), b = holvan(b);\n  if (a != b) {\n    hv[b] = a;\n    return true;\n  }\n  return false;\n}\nvoid dfs(int a) {\n  v[a] = true;\n  be[a] = ++cnt;\n  fel2[a][0] = fel[a];\n  for (int i = 1; i < lg; i++) {\n    fel2[a][i] = fel2[fel2[a][i - 1]][i - 1];\n  }\n  for (auto p : sz[a]) {\n    int x = p.first, y = p.second;\n    if (!v[x]) {\n      szint[x] = szint[a] + 1;\n      fel[x] = a;\n      ert[x] = (ert[a] ^ y);\n      dfs(x);\n    }\n  }\n  ki[a] = cnt;\n}\nint lca(int a, int b) {\n  if (szint[a] < szint[b]) {\n    swap(a, b);\n  }\n  for (int i = lg - 1; i >= 0; i--) {\n    if (szint[fel2[a][i]] >= szint[b]) {\n      a = fel2[a][i];\n    }\n  }\n  if (a == b) {\n    return a;\n  }\n  for (int i = lg - 1; i >= 0; i--) {\n    if (fel2[a][i] != fel2[b][i]) {\n      a = fel2[a][i], b = fel2[b][i];\n    }\n  }\n  return fel[a];\n}\nint calc(int a, int l, int r) {\n  if (kezd[a] > r || veg[a] < l) {\n    return 0;\n  }\n  if (l <= kezd[a] && veg[a] <= r) {\n    return 2;\n  }\n  return 1;\n}\nvoid add(int a, int l, int r, int ert) {\n  int s = calc(a, l, r);\n  if (s == 0) {\n    return;\n  }\n  if (s == 2) {\n    maxi[a] = max(maxi[a], ert);\n  } else {\n    add(2 * a, l, r, ert), add(2 * a + 1, l, r, ert);\n  }\n}\nint ask(int a, int b) {\n  int s = calc(a, b, b);\n  if (s == 0) {\n    return 0;\n  }\n  if (s == 2) {\n    return maxi[a];\n  }\n  return max({maxi[a], ask(2 * a, b), ask(2 * a + 1, b)});\n}\nvoid init(int x) {\n  int po = 1;\n  while (po < x) {\n    po *= 2;\n  }\n  for (int i = po; i < 2 * po; i++) {\n    kezd[i] = i - po + 1, veg[i] = kezd[i];\n  }\n  for (int i = po - 1; i >= 1; i--) {\n    kezd[i] = kezd[2 * i], veg[i] = veg[2 * i + 1];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= m; i++) {\n    cin >> aa[i] >> bb[i] >> xo[i];\n    int a = aa[i], b = bb[i], c = xo[i];\n    if (unio(a, b)) {\n      jo[i] = 1;\n      sz[a].push_back({b, c});\n      sz[b].push_back({a, c});\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!v[i]) {\n      szint[i] = 1;\n      dfs(i);\n    }\n  }\n  init(n);\n  for (int i = 1; i <= m; i++) {\n    int a = aa[i], b = bb[i], c = xo[i];\n    if (jo[i] || (ert[a] ^ ert[b] ^ c) != 1) {\n      continue;\n    }\n    int x = lca(a, b);\n    if (ask(1, be[a]) <= be[x] && ask(1, be[b]) <= be[x]) {\n      jo[i] = 1;\n      while (a != x) {\n        add(1, be[a], ki[a], be[a]);\n        a = fel[a];\n      }\n      while (b != x) {\n        add(1, be[b], ki[b], be[b]);\n        b = fel[b];\n      }\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    cout << (jo[i] ? \"YES\" : \"NO\") << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, Q;\nvector<pair<int, int> > v[300005];\nint s[500005], e[500005], w[500005];\nint r[500005], xr[300005];\nint p[300005], in[300005], out[300005], ck;\nint parent[300005][21];\nvector<int> first;\nint log_n = 19;\nvector<int> par, rk;\nvoid init(int n) {\n  par.assign(n, 0);\n  iota(par.begin(), par.end(), 0);\n  rk.assign(n, 1);\n}\nint top(int v) {\n  if (par[v] != v) return par[v] = top(par[v]);\n  return v;\n}\nbool unite(int u, int v) {\n  u = top(u);\n  v = top(v);\n  if (u == v) return false;\n  if (rk[u] < rk[v]) swap(u, v);\n  par[v] = u;\n  rk[u] += rk[v];\n  return true;\n};\nvoid dfs(int x, int y, int cur) {\n  xr[x] = cur;\n  p[x] = y;\n  in[x] = ck++;\n  parent[x][0] = y;\n  for (int i = 1; i < log_n; i++) {\n    parent[x][i] = parent[parent[x][i - 1]][i - 1];\n  }\n  for (auto [z, t] : v[x]) {\n    if (z != y) dfs(z, x, cur ^ t);\n  }\n  out[x] = ck;\n}\nvoid inc(int pos, int val) {\n  for (; pos < first.size(); pos |= pos + 1) first[pos] += val;\n}\nint sum(int pos) {\n  int ans = 0;\n  for (; pos >= 0; pos = (pos & (pos + 1)) - 1) ans += first[pos];\n  return ans;\n}\nvoid addOnPath(int v, int l) {\n  while (v != l) {\n    inc(in[v], 1);\n    inc(out[v], -1);\n    v = p[v];\n  }\n}\nint isPar(int p, int v) { return in[p] <= in[v] && out[v] <= out[p]; }\nint lca2(int u, int v) {\n  if (isPar(u, v)) return u;\n  if (isPar(v, u)) return v;\n  for (int pw = log_n - 1; pw >= 0; pw--) {\n    if (!isPar(parent[v][pw], u)) v = parent[v][pw];\n  }\n  return parent[v][0];\n}\nvoid solve() {\n  cin >> n >> Q;\n  init(n);\n  for (int i = 0; i < Q; i++) {\n    cin >> s[i] >> e[i] >> w[i];\n    s[i]--;\n    e[i]--;\n    if (unite(s[i], e[i])) {\n      v[s[i]].push_back({e[i], w[i]});\n      v[e[i]].push_back({s[i], w[i]});\n    } else\n      r[i] = 1;\n  }\n  first.assign(2 * n + 5, 0);\n  memset(in, -1, sizeof(in));\n  memset(out, -1, sizeof(out));\n  for (int i = 0; i < n; i++)\n    if (in[i] == -1) dfs(i, i, 0);\n  for (int i = 0; i < Q; i++) {\n    if (r[i] == 0) {\n      cout << \"YES\" << endl;\n    } else {\n      int x = s[i], y = e[i];\n      int t = xr[x] ^ xr[y] ^ w[i];\n      if (t != 1) {\n        cout << \"NO\" << endl;\n        continue;\n      }\n      int a = lca2(x, y);\n      t = sum(in[x]) + sum(in[y]) - 2 * sum(in[a]);\n      if (t > 0) {\n        cout << \"NO\" << endl;\n        continue;\n      }\n      addOnPath(x, a);\n      addOnPath(y, a);\n      cout << \"YES\" << endl;\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &r) {\n  r = 0;\n  bool w = true;\n  char ch = getchar();\n  for (; !isdigit(ch); ch = getchar()) w ^= !(ch ^ 45);\n  for (; isdigit(ch); ch = getchar()) r = (r << 1) + (r << 3) + (ch ^ 48);\n  r = w ? r : -r;\n}\nstruct node {\n  int to, next, weight;\n} edge[(500000 + 5) << 1];\nint head[300000 + 5], edge_num;\nvoid add(int u, int v, int w) {\n  ++edge_num;\n  edge[edge_num].to = v;\n  edge[edge_num].next = head[u];\n  edge[edge_num].weight = w;\n  head[u] = edge_num;\n}\nint n, m;\nint fat[300000 + 5];\nint find(int x) {\n  if (fat[x] == x) return x;\n  return fat[x] = find(fat[x]);\n}\nint x[500000 + 5], y[500000 + 5], z[500000 + 5], ans[500000 + 5];\nvoid init() {\n  read(n), read(m);\n  for (register int i = 1; i <= n; i++) fat[i] = i;\n  for (register int i = 1; i <= m; i++) {\n    read(x[i]), read(y[i]), read(z[i]);\n    if (find(x[i]) != find(y[i])) {\n      fat[find(x[i])] = find(y[i]);\n      ans[i] = true;\n      add(x[i], y[i], z[i]);\n      add(y[i], x[i], z[i]);\n    }\n  }\n}\nint fa[300000 + 5], size[300000 + 5], son[300000 + 5], depth[300000 + 5],\n    val[300000 + 5];\nvoid dfs1(int u) {\n  size[u] = 1;\n  for (register int i = head[u]; i; i = edge[i].next) {\n    int v = edge[i].to;\n    if (fa[u] == v) continue;\n    fa[v] = u;\n    val[v] = edge[i].weight;\n    depth[v] = depth[u] + 1;\n    dfs1(v);\n    size[u] += size[v];\n    if (size[son[u]] < size[v]) son[u] = v;\n  }\n}\nint belong[300000 + 5], pos[300000 + 5], bac[300000 + 5];\nvoid dfs2(int u, int chain) {\n  belong[u] = chain;\n  pos[u] = ++pos[0];\n  bac[pos[0]] = u;\n  if (son[u]) dfs2(son[u], chain);\n  for (register int i = head[u]; i; i = edge[i].next) {\n    int v = edge[i].to;\n    if (fa[u] == v || son[u] == v) continue;\n    dfs2(v, v);\n  }\n}\nstruct node2 {\n  int l, r, val;\n  bool vis, lazy;\n} a[300000 << 2];\nvoid pushup(int p) {\n  a[p].val = a[(p << 1)].val ^ a[((p << 1) + 1)].val;\n  a[p].vis = a[(p << 1)].vis | a[((p << 1) + 1)].vis;\n}\nvoid pushdown(int p) {\n  if (a[p].lazy) {\n    a[(p << 1)].vis = a[((p << 1) + 1)].vis = a[(p << 1)].lazy =\n        a[((p << 1) + 1)].lazy = true;\n    a[p].lazy = false;\n  }\n}\nvoid build(int p, int l, int r) {\n  a[p].l = l, a[p].r = r;\n  if (l == r) {\n    a[p].val = val[bac[l]];\n    a[p].vis = false;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build((p << 1), l, mid);\n  build(((p << 1) + 1), mid + 1, r);\n  pushup(p);\n}\nvoid update(int p, int l, int r) {\n  if (a[p].l == l && a[p].r == r) {\n    a[p].vis = true;\n    a[p].lazy = true;\n    return;\n  }\n  pushdown(p);\n  int mid = (a[p].l + a[p].r) >> 1;\n  if (r <= mid)\n    update((p << 1), l, r);\n  else if (l > mid)\n    update(((p << 1) + 1), l, r);\n  else {\n    update((p << 1), l, mid);\n    update(((p << 1) + 1), mid + 1, r);\n  }\n  pushup(p);\n}\nint query(int p, int l, int r) {\n  if (a[p].l == l && a[p].r == r) {\n    if (a[p].vis) return -1;\n    return a[p].val;\n  }\n  pushdown(p);\n  int mid = (a[p].l + a[p].r) >> 1;\n  if (r <= mid) return query((p << 1), l, r);\n  if (l > mid) return query(((p << 1) + 1), l, r);\n  int ls = query((p << 1), l, mid), rs = query(((p << 1) + 1), mid + 1, r);\n  if (ls == -1 || rs == -1) return -1;\n  return ls ^ rs;\n}\nvoid getpath(int i) {\n  int u = x[i], v = y[i];\n  int ret = 0;\n  while (belong[u] != belong[v]) {\n    if (depth[belong[u]] < depth[belong[v]]) swap(u, v);\n    int g = query(1, pos[belong[u]], pos[u]);\n    if (g == -1) {\n      ret = -1;\n      return;\n    } else\n      ret ^= g;\n    u = fa[belong[u]];\n  }\n  if (depth[u] < depth[v]) swap(u, v);\n  if (u != v) {\n    int g = query(1, pos[v] + 1, pos[u]);\n    if (g == -1)\n      ret = -1;\n    else\n      ret ^= g;\n  }\n  if ((ret ^ z[i]) == 1) {\n    ans[i] = 1;\n    u = x[i], v = y[i];\n    while (belong[u] != belong[v]) {\n      if (depth[belong[u]] < depth[belong[v]]) swap(u, v);\n      update(1, pos[belong[u]], pos[u]);\n      u = fa[belong[u]];\n    }\n    if (depth[u] < depth[v]) swap(u, v);\n    if (u != v) {\n      update(1, pos[v] + 1, pos[u]);\n    }\n  }\n}\nvoid solve() {\n  for (register int i = 1; i <= n; i++) {\n    if (!size[i]) {\n      depth[i] = 1;\n      dfs1(i);\n      dfs2(i, i);\n    }\n  }\n  build(1, 1, n);\n  for (register int i = 1; i <= m; i++) {\n    if (!ans[i]) {\n      getpath(i);\n    }\n  }\n  for (register int i = 1; i <= m; i++) puts(ans[i] ? \"YES\" : \"NO\");\n}\nvoid write() {}\nint main() {\n  init();\n  solve();\n  write();\n  return 0;\n}\n"
        }
    ]
}